- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Using Component Mocks to Clarify Tests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件模拟来澄清测试
- en: The preceding chapter introduced the concept of a test double and showed how
    `vi.fn` can be used to swap out unwanted behavior within your Vitest test suites.
    The same technique can be used for Svelte components, but it’s a little more complicated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章介绍了测试替身（test double）的概念，并展示了如何使用`vi.fn`在Vitest测试套件中替换掉不希望的行为。同样的技术也可以用于Svelte组件，但稍微复杂一些。
- en: Imagine you’re writing unit tests for a component named `Parent`, and that component
    itself renders another developer-defined component, named `Child`. By default,
    when your tests render `Parent`, `Child` is rendered too. But using a component
    mock can stop that from happening. It swaps out the real `Child` for a test double.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为一个名为`Parent`的组件编写单元测试，而这个组件本身渲染了另一个开发者定义的组件，名为`Child`。默认情况下，当你的测试渲染`Parent`时，`Child`也会被渲染。但使用组件模拟可以阻止这种情况发生。它会用测试替身替换掉真实的`Child`。
- en: 'There are various reasons why you’d want to do this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要这样做的原因有很多：
- en: The `Child` component already has its own unit test suite, and you don’t want
    to repeat yourself (a form of overtesting, described in detail in the *Avoiding
    component* *mocks* section)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Child`组件已经有了自己的单元测试套件，你不想重复测试（这是过度测试的一种形式，在*避免组件模拟*部分有详细描述）'
- en: The `Child` component has behavior on mount, such as fetching data via the Fetch
    API, that you’d rather avoid running within your test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Child`组件在挂载时有一些行为，例如通过Fetch API获取数据，你更希望避免在测试中运行这些行为'
- en: The `Child` component comes from a third-party library and it’s more important
    that you verify the props it is rendered with, rather than verifying the behavior
    of the third-party component itself
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Child`组件来自第三方库，验证它渲染的属性比验证第三方组件本身的行为更重要'
- en: The downside of using component mocks is that they’re complex, and if you’re
    not careful, they can become a burden.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件模拟的缺点是它们很复杂，如果你不小心，它们可能会成为负担。
- en: Staying safe with test doubles
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试替身保持安全
- en: The number-one rule when using component mocks, and test doubles in general,
    is to avoid building any control logic (`if` statements and loops) into them.
    Instead, when you use `mockReturnValue` or `mockResolvedValue` to specify the
    value that is returned, always prefer to return fixed values.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件模拟以及测试替身的一般规则是避免在它们中构建任何控制逻辑（`if`语句和循环）。相反，当你使用`mockReturnValue`或`mockResolvedValue`来指定返回的值时，始终优先返回固定值。
- en: An easy way to ensure that happens is to ensure that each unit test gets its
    own test double instance. In other words, avoid setting up a test double in a
    `beforeEach` block and reusing it across all tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这一点的一个简单方法是为每个单元测试获取其自己的测试替身实例。换句话说，避免在`beforeEach`块中设置测试替身并在所有测试中重复使用它。
- en: If you’re struggling to keep test doubles simple, that can be a sign that the
    application code design is too complex. Try reconfiguring the object under test,
    perhaps by splitting it out into a number of separate objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现难以保持测试替身简单，这可能意味着应用程序代码设计过于复杂。尝试重新配置待测试的对象，例如将其拆分为多个单独的对象。
- en: 'This chapter covers the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Avoiding component mocks when possible
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下避免使用组件模拟
- en: Using hand-rolled component stubs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用手工制作的组件存根
- en: Using a component mock library
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件模拟库
- en: By the end of the chapter, you will be confident with using component mocking
    techniques and know when to use them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够自信地使用组件模拟技术，并知道何时使用它们。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，地址为[https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start)。
- en: Avoiding component mocks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用组件模拟
- en: This section covers how to build your application without using component mocks.
    Of course, the application we’ve built up to this point hasn’t used any, so you
    already know it’s possible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何在不需要使用组件模拟的情况下构建应用程序。当然，我们到目前为止构建的应用程序没有使用任何组件模拟，所以你已经知道这是可能的。
- en: The SvelteKit application we’ve built has a page route component that renders
    a list of `Birthday` components and a `BirthdayForm` component. Both of these
    components are covered by their own test suites, so they are certainly candidates
    for using component mocks. The page route component would simply check that it
    renders `Birthday` and `BirthdayForm` in the right way, and avoid testing any
    of the birthdays themselves.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的 SvelteKit 应用程序有一个页面路由组件，它渲染一个 `Birthday` 组件列表和一个 `BirthdayForm` 组件。这两个组件都有自己的测试套件，因此它们当然适合使用组件模拟。页面路由组件只需检查它是否以正确的方式渲染了
    `Birthday` 和 `BirthdayForm`，并避免测试任何生日本身。
- en: But there’s not much point in doing this. Neither of these components has any
    behavior on mount, so there’s no trouble in letting them render.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样做并没有多大意义。这两个组件在挂载时都没有任何行为，所以让它们渲染没有问题。
- en: The biggest risk you have in not using component mocks is that of `Birthday`
    component test suite and repeating them in the page route test suite.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用组件模拟的最大风险是 `Birthday` 组件测试套件在页面路由测试套件中的重复。
- en: '*Figure 12**.1* shows how the test suites for a `Parent` and `Child` component
    can be developed without overtesting. The `Parent` test suite only needs to test
    a single flow to `Child` to prove the connection. If there are any interesting
    return flows of data back from `Child` into `Parent` (such as component event
    bindings), then they should be tested too.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12.1* 显示了如何在不过度测试的情况下开发 `Parent` 和 `Child` 组件的测试套件。`Parent` 测试套件只需要测试一个到
    `Child` 的单一流程，以证明连接。如果有任何有趣的数据回流从 `Child` 返回到 `Parent`（例如组件事件绑定），那么它们也应该被测试。'
- en: '![Figure 12.1 – Overtesting caused by repeated tests at two levels in a component
    hierarchy](img/Figure_12.1_B19611.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 组件层次结构中两个级别的重复测试导致的过度测试](img/Figure_12.1_B19611.jpg)'
- en: Figure 12.1 – Overtesting caused by repeated tests at two levels in a component
    hierarchy
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 组件层次结构中两个级别的重复测试导致的过度测试
- en: Thankfully, TDD has a couple of rules that avoid the problem of overtesting.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，TDD 有几条规则可以避免过度测试的问题。
- en: Avoiding overtesting using TDD
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TDD 避免过度测试
- en: Imagine first that you’re building your application using a bottom-up approach,
    which is the approach this book has followed. That means that you write the `Child`
    component and its test suite before writing the `Parent` component and its test
    suite.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你首先使用自下而上的方法构建你的应用程序，这正是本书所采用的方法。这意味着你在编写 `Parent` 组件及其测试套件之前先编写 `Child`
    组件及其测试套件。
- en: When you begin test-driving `Parent`, you write a test that will bring in the
    `Child` component. (The test description might be something such as *displays
    the birthday information*.) Recall the TDD rule of *make the simplest change that
    could possibly work*. Since you’ve already written the `Child` component at your
    disposal, then the simplest change is to simply bring in the `Child` component.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始测试驱动 `Parent` 组件时，你会编写一个测试来引入 `Child` 组件。（测试描述可能类似于 *显示生日信息*。）回想一下 TDD 规则中的
    *进行可能的最简单更改*。由于你已经有现成的 `Child` 组件，那么最简单的更改就是直接引入 `Child` 组件。
- en: Then, the rule of the *Red* test comes into play, and this is the crucial one
    that avoids overtesting. You can’t work on a test unless you see it fail. But
    if your first test brought in the `Child` component, you suddenly get all the
    behavior of `Child` for free. So, if you’re following TDD, it’s impossible to
    write a *Red* test for all the behavior of `Child`, because it will already pass.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，*红* 测试的规则开始发挥作用，这是避免过度测试的关键规则。除非你看到测试失败，否则你不能进行测试。但是，如果你的第一个测试引入了 `Child`
    组件，你突然会免费获得 `Child` 的所有行为。所以，如果你遵循 TDD，你不可能为 `Child` 的所有行为编写 *红* 测试，因为它已经通过了。
- en: 'Now imagine that you started by building the `Parent` component and at some
    point felt the urge to extract a `Child` component (you might think of this as
    a top-down approach). How do you go about extracting `Child`? If you’re being
    strict, you might start by rewriting the tests for `Child`, as we did in [*Chapter
    9*](B19611_09.xhtml#_idTextAnchor111), *Extracting Logic Out of the Framework*,
    when we extracted the birthday repository. But generally, you wouldn’t stop there:
    you’d want to go back and delete those extra tests from `Parent`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你开始构建 `Parent` 组件，并在某个时刻产生了提取 `Child` 组件的冲动（你可能将其视为自顶向下的方法）。你如何进行提取 `Child`？如果你非常严格，你可能会从重写
    `Child` 组件的测试开始，就像我们在 [*第 9 章*](B19611_09.xhtml#_idTextAnchor111) 中所做的那样，*从框架中提取逻辑*，当时我们提取了生日存储库。但通常，你不会就此停止：你还会想回去删除
    `Parent` 中的那些额外测试。
- en: You could view this as part of the *Refactor* step of the TDD cycle. In fact,
    we did this in the preceding chapter when we ended up deleting a bunch of tests
    as we changed out the system functionality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这视为 TDD 循环中的 *重构* 步骤。实际上，我们在前一章中就是这样做的，当我们改变系统功能时，我们最终删除了一大堆测试。
- en: 'To repeat the message of this section: you don’t always need to use mocks.
    If you have a single test to prove the connection between `Parent` and `Child`,
    that’s often enough. Moreover, using TDD can naturally lead to you using this
    approach.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调本节的内容：你并不总是需要使用模拟。如果你只有一个测试来证明 `Parent` 和 `Child` 之间的连接，这通常就足够了。此外，使用 TDD
    可以自然地引导你采用这种方法。
- en: Using hand-rolled component stubs
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用手工组件存根
- en: In this section, we’ll look at a simple but effective way of mocking components,
    by building hand-rolled component stubs. This isn’t as clever as using a component
    mock library, but it’s simpler and easier to understand. Often, the simplest approach
    is the best choice.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一种简单但有效的方法来模拟组件，即通过构建手工组件存根。这并不像使用组件模拟库那样聪明，但它更简单，更容易理解。通常，最简单的方法是最好的选择。
- en: 'To recap what we’re trying to do: we have a child component that we want to
    avoid rendering, perhaps because it has mount behavior or it’s a complex third-party
    component.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾我们试图做什么：我们有一个我们想要避免渲染的子组件，可能是因为它有挂载行为或者它是一个复杂的第三方组件。
- en: Hand-rolled component stubs rely on Vitest’s `vi.mock` function combined with
    a special `__mocks__` directory. You create a stub component with the same name
    as your component, but inside a `__mocks__` directory at the same level as the
    component itself. Then, you instruct Vitest to use the mock using the `vi.mock`
    statement placed at the top of your test file. This will mean the entire test
    suite uses the mock.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 手工组件存根依赖于 Vitest 的 `vi.mock` 函数以及一个特殊的 `__mocks__` 目录。你创建一个与你的组件同名但位于同一级别的 `__mocks__`
    目录中的存根组件。然后，你通过在测试文件顶部放置 `vi.mock` 语句来指示 Vitest 使用模拟。这意味着整个测试套件都将使用模拟。
- en: We can demonstrate this using the page route component test suite, building
    mocks for the `Birthday` and `BirthdayForm` components. These components don’t
    have any side effects on mount, and they aren’t third party, but they do have
    their own test suites. So, even though it doesn’t feel necessary to make this
    change, it’s not unsafe to do so.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用页面路由组件测试套件来演示这一点，为 `Birthday` 和 `BirthdayForm` 组件构建模拟。这些组件在挂载时没有副作用，它们也不是第三方组件，但它们有自己的测试套件。因此，尽管感觉没有必要进行这种更改，但这样做并不危险。
- en: Since this work isn’t necessary, we’ll build an example test suite in a test
    file named `page.mocks.test.js`. Although this isn’t how I’d do this in the real
    world, it does highlight how you can have both mocked and non-mocked unit tests
    within the same code base.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这项工作不是必需的，我们将在名为 `page.mocks.test.js` 的测试文件中构建一个示例测试套件。虽然这并不是我在现实世界中会这样做的方式，但它确实突出了你如何在同一个代码库中既有模拟又有非模拟的单元测试。
- en: We’ll start with a look at how to verify props using a stub component. Then,
    we’ll look at checking the ordering of instances, followed by dealing with complex
    prop verification, and finishing with a look at how to dispatch component events.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从如何使用存根组件验证 props 开始，然后检查实例的顺序，接着处理复杂的 prop 验证，最后看看如何分发组件事件。
- en: Rendering all props within a component stub
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在组件存根中渲染所有 props
- en: In the preceding chapter, you saw that it’s important to verify the props that
    are passed into a test double. Component stubs are no different. The way we do
    this is to ensure that the component stub renders all the props and then use standard
    DOM matchers to verify their presence.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你看到了验证传递给测试替代的 props 的重要性。组件存根也不例外。我们这样做的方式是确保组件存根渲染所有 props，然后使用标准的 DOM
    匹配器来验证它们的存在。
- en: 'Let’s begin by creating a hand-rolled component stub for the `Birthday` component:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个 `Birthday` 组件的手工组件存根：
- en: Create a new directory named `src/routes/birthdays/__mocks__`. The special name
    is picked up automatically by Vitest as a location for your mocks.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `src/routes/birthdays/__mocks__` 的新目录。这个特殊的名称会被 Vitest 自动识别为存放你的模拟文件的位置。
- en: 'Create a new file named `src/routes/birthdays/__mocks__/Birthday.svelte` with
    the following content. It does nothing but render out all the props that are passed
    in:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `src/routes/birthdays/__mocks__/Birthday.svelte` 的新文件，内容如下。它什么也不做，只是渲染传入的所有
    props：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now create a new test file named `src/routes/birthdays/page.mock.test.js` and
    start with the usual `import` statements. Notice how `vi` is included; we’ll use
    that in the next step:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个名为`src/routes/birthdays/page.mock.test.js`的新测试文件，并从常用的`import`语句开始。注意`vi`是如何被包含在内的；我们将在下一步中使用它：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, just below the `import` statements, add a call to `vi.mock`. The path
    given must match the path to the *actual* `Birthday` component. Vitest will pick
    up the mock and load that instead:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`import`语句下方，添加对`vi.mock`的调用。提供的路径必须与`实际`的`Birthday`组件路径匹配。Vitest将拾取模拟并加载该组件：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, start a new `describe` block, together with a sample `birthdays` array.
    All our tests will use this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始一个新的`describe`块，以及一个示例`birthdays`数组。我们所有的测试都将使用这个：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Time for the first test. This is going to check that given the two birthdays
    defined previously, each of the correct bits of information is displayed on screen:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行第一次测试的时间。这将检查给定之前定义的两个生日，每个正确的信息片段都显示在屏幕上：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Testing lists of components
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试组件列表
- en: 'This test checks *two* birthdays, not one: since we’re interested in the listing
    behavior – one `Birthday` component per entry – it’s important to test that a
    list of birthdays does in fact give a list of `Birthday` components. A single
    birthday isn’t enough to prove a list.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试检查**两个**生日，而不是一个：因为我们感兴趣的是列表行为——每个条目一个`Birthday`组件——所以测试确实给出了生日列表的`Birthday`组件列表很重要。单个生日不足以证明列表。
- en: Because our implementation already exists, this test should already pass. But
    it’s important to prove the test works, and this time we want to also verify that
    the mock has been picked up. So, first delete the contents of the *actual* `Birthday`
    component (not the mock). The test should *still* pass. (Make sure you use the
    `v src/routes/birthdays/page.mocks.test.js` command to run your tests, otherwise
    you’ll see all the failures from other test suites.) This should convince you
    that the mock is being picked up.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的实现已经存在，此测试应该已经通过。但证明测试有效很重要，这次我们还想验证模拟已被拾取。所以，首先删除*实际*的`Birthday`组件的内容（不是模拟）。测试应该*仍然*通过。（确保您使用`v
    src/routes/birthdays/page.mocks.test.js`命令运行测试，否则您将看到来自其他测试套件的全部失败。）这应该让您相信模拟已被拾取。
- en: 'Undo your changes to the `Birthday` component, and now let’s make a change
    to make the test fail. In the page route component at `src/routes/birthday/+page.svelte`,
    comment out the rendering of the `Birthday` component, like this:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撤销对`Birthday`组件的更改，现在让我们进行一个更改以使测试失败。在页面路由组件`src/routes/birthday/+page.svelte`中，注释掉`Birthday`组件的渲染，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the tests with `v src/routes/birthdays/page.mocks.test.js` and verify the
    test now fails. Then, undo your change.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`v src/routes/birthdays/page.mocks.test.js`运行测试，并验证测试现在失败。然后，撤销您的更改。
- en: You’ve now learned about the basic usage of component stubs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解了组件存根的基本用法。
- en: Checking the ordering of component instances
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查组件实例的排序
- en: Sometimes, when we are dealing with lists of components, we want to check the
    ordering of instances. We can check that using the `data-testid` attribute to
    get hold of each specific instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当我们处理组件列表时，我们想检查实例的排序。我们可以使用`data-testid`属性来获取每个特定实例以进行检查。
- en: There is a general piece of advice to avoid using `data-testid` in tests. This
    is good advice, but your component stubs are a part of your test suite, not the
    application code, so it’s safe to use them here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个普遍的建议是避免在测试中使用`data-testid`。这是一个好建议，但您的组件存根是测试套件的一部分，而不是应用程序代码，所以在这里使用它们是安全的。
- en: When to use list ordering tests
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用列表排序测试
- en: The test in this section isn’t very TDD-like; it proves what I’d consider the
    *default* ordering of lists. If you already have a test that checks that data
    is listed, like the one in *step 6* of the preceding section, then the simplest
    way to make that pass is to implement the default ordering. So, writing a test
    like the one in *writing a test like the one your'e about to see* will likely
    pass by default, and is therefore an invalid test.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的测试并不非常符合TDD（测试驱动开发）的风格；它证明了我认为的*默认*列表排序。如果您已经有了一个检查数据是否列出的测试，就像前一个节中的*步骤6*中的那样，那么使那个测试通过的最简单方法就是实现默认排序。所以，编写一个像您即将看到的测试一样，可能会默认通过，因此是一个无效的测试。
- en: 'Let’s start:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'Update the component stub to add a `data-testid` attribute, like this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新组件存根以添加一个`data-testid`属性，如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, write a test that proves the ordering. It uses `queryAllByTestId` to return
    a list of elements that match a specific `data-testid` attribute value, in the
    order they are listed in the document:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写一个测试来证明排序。它使用`queryAllByTestId`来返回一个匹配特定`data-testid`属性值的元素列表，按照它们在文档中的顺序：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will pass, but make sure you verify it doesn’t pass by using the same commenting-out
    trick from previously.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将通过，但请确保你通过使用之前提到的注释技巧来验证它不会通过。
- en: It’s also worth pointing out that there is another way to write an ordering
    test that doesn’t involve using the `data-testid` attribute. You could instead
    get hold of the `ol` element on the page, then map each of the `li` elements to
    their text content and check that it is an array in the order that you expect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得指出的是，还有一种编写排序测试的方法，不涉及使用`data-testid`属性。你可以获取页面上的`ol`元素，然后将每个`li`元素映射到它们的文本内容，并检查它是否按照你预期的顺序是一个数组。
- en: Dealing with complex props
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理复杂属性
- en: Sometimes, the props to your component are objects or arrays, and if you were
    to render them all out within the component stub, you’d end up with a whole bunch
    of code in the stub. There’s a shorter way of outputting prop values, which is
    to use the `JSON.stringify` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你的组件的属性是对象或数组，如果你要在组件存根中渲染它们，你会在存根中结束于一大堆代码。有一种更短的方法来输出属性值，那就是使用`JSON.stringify`函数。
- en: 'Let’s do that now for the `BirthdayForm` component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为`BirthdayForm`组件做这件事：
- en: 'Create a new file named `src/routes/birthdays/__mocks__/BirthdayForm.svelte`
    with the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/routes/birthdays/__mocks__/BirthdayForm.svelte`的新文件，内容如下：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In your test suite, add a new call to `vi.mock` that pulls in this component,
    next to the previous call to `vi.mock`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的测试套件中，添加一个新的`vi.mock`调用，以获取这个组件，紧邻之前的`vi.mock`调用：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, add the following helper function at the top of the test suite:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在测试套件的顶部添加以下辅助函数：
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, add the next test, as shown; it also calls `JSON.stringify`. This should
    pass, but make sure to verify it before finishing:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加下一个测试，如图所示；它也调用了`JSON.stringify`。这应该会通过，但请确保在完成之前进行验证：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will note the coupling between the component stub and the test suite. This
    component stub is quite awkward. What I find is that this technique of utilising
    `JSON.stringify` is generally fine as long as it’s the single pattern you use
    to check complex props and is used consistently between developers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到组件存根和测试套件之间的耦合。我发现，只要它是你用来检查复杂属性的唯一模式，并且开发者之间使用一致，那么利用`JSON.stringify`的技术通常是可行的。
- en: Dispatching component events
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 派发组件事件
- en: The final component stub technique we will look at is the mechanism to dispatch
    component events. As in the last section, this is awkward, because it’s impossible
    to raise a component event on a hand-rolled stub without having a dispatcher object
    defined within the stub itself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的最后一个组件存根技术是派发组件事件的机制。正如上一节所述，这是尴尬的，因为在没有在存根本身中定义派发对象的情况下，不可能在手工制作的存根上引发组件事件。
- en: 'One way to deal with this is to just stick a button into the stub and use that
    to dispatch the event:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一种方法是将一个按钮放入存根中并使用它来派发事件：
- en: Warning
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'The following example doesn’t make a huge amount of sense in the context of
    our application: the actual `BirthdayForm` component doesn’t have this *cancel*
    behavior, and if this feature *did* exist, it would probably make more sense to
    have the **Cancel** button within the page route, avoiding the need for a component
    event.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在我们应用程序的上下文中并没有太多意义：实际的`BirthdayForm`组件没有这个*取消*行为，而且如果这个功能*确实*存在，可能更有意义的是在页面路由中放置**取消**按钮，避免需要组件事件。
- en: 'Update the `BirthdayForm` component stub to include a `button` element that
    dispatches a `cancel` event:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`BirthdayForm`组件存根以包含一个派发`cancel`事件的`button`元素：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, you can add a test that checks what happens when the `cancel` event is
    dispatched:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以添加一个测试来检查当派发`cancel`事件时会发生什么：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make this pass, update the `page` component to respond to the `cancel` event:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，更新`page`组件以响应`cancel`事件：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Remember, the *real* `BirthdayForm` component doesn’t have this behavior, and
    this exposes a big problem with mocking components: it’s challenging to keep the
    mock aligned with real implementations.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*真正的* `BirthdayForm` 组件没有这种行为，这暴露了模拟组件的一个大问题：保持模拟与实际实现一致是具有挑战性的。
- en: Avoiding hand-rolled mocks and using a library is one way to deal with this
    problem, as we’ll see in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 避免手工制作模拟并使用库是处理此问题的方法之一，我们将在下一节中看到。
- en: Using a component mock library
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件模拟库
- en: In the last chapter, you saw how you can use `vi.fn` to spy on functions. The
    `svelte-component-double` npm package can be used in a similar fashion, achieving
    the same effect as the hand-rolled mocks you’ve just learned about.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了如何使用`vi.fn`来监视函数。`svelte-component-double` npm包可以以类似的方式使用，实现你刚刚学到的手工制作模拟的相同效果。
- en: The package includes matchers such as `toBeRendered` and `toBeRenderedWithProps`
    to check that the component is indeed rendered in the way you wanted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包括`toBeRendered`和`toBeRenderedWithProps`等匹配器，用于检查组件是否确实以你想要的方式渲染。
- en: 'Let’s split this into a couple of parts: installing the library and writing
    tests.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个分成几个部分：安装库和编写测试。
- en: Installing the library
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装库
- en: 'The library requires a bit of setup to get the relevant matchers into place:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该库需要一些设置来将相关的匹配器放置到位：
- en: 'Run the following command to install the package:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来安装包：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, create a new file named `src/vitest/registerSvelteComponentDouble.js`
    with the following content. It registers the matchers and also gives us global
    access to the `componentDouble` function, which is not required but makes mock
    setup easier:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`src/vitest/registerSvelteComponentDouble.js`的新文件，内容如下。它注册了匹配器，并使我们能够全局访问`componentDouble`函数，这不是必需的，但使模拟设置更容易：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, update your `vite.config.js` file to include the new setup file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新你的`vite.config.js`文件，包括新的设置文件：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You’re now ready to use the library in your tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用库进行测试了。
- en: Writing tests using the componentDouble function
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`componentDouble`函数编写测试
- en: 'Now, we will rewrite the mock test suite to use the library rather than hand-rolled
    component stubs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重写模拟测试套件，使用库而不是手工制作的组件占位符：
- en: 'Start by redefining the two calls to `vi.mock` with the following definitions.
    Each call to `componentDouble` gets a string identifier. This appears in your
    DOM output and is used in expectation failures:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，重新定义对`vi.mock`的两个调用，如下所示。每个`componentDouble`调用都得到一个字符串标识符。这出现在你的DOM输出中，并在期望失败时使用：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You’ll also need to add two `import` statements at the top of the file so that
    you can access the mock object. Although it looks like you’re importing the actual
    components, you’ll actually get the component doubles:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要在文件顶部添加两个`import`语句，以便你可以访问模拟对象。虽然看起来你正在导入实际的组件，但实际上你会得到组件占位符：
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It’s also important to reset the component doubles between each test. That’s
    because `vi.mock` will only generate a double once per test suite. Add the following
    two calls to `beforeEach` at the top of the `describe` block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之间也很重要重置组件占位符。这是因为`vi.mock`在每个测试套件中只会生成一个占位符。在`describe`块顶部添加以下两个调用到`beforeEach`：
- en: '[PRE20]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You’ll also need to update the `import` statement to pull in the `beforeEach`
    function:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要更新`import`语句，以引入`beforeEach`函数：
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now for the first test. The makes use of the matcher `toBeRendered`, which
    checks that the component appears somewhere in the document. Update the first
    test to look like the following:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进行第一次测试。这次测试使用的是`toBeRendered`匹配器，它检查组件是否出现在文档的某个位置。更新第一个测试，使其看起来如下所示：
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To run this test, mark it as `it.only` and then run Vitest on this test suite.
    You should see it passing; you can verify it in the usual way, by commenting out
    the `Birthday` component instance in the page route component. This time, you’ll
    see a failure printed as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行此测试，将其标记为`it.only`，然后运行Vitest测试套件。你应该看到它通过；你可以通过以下方式验证它，即在页面路由组件中注释掉`Birthday`组件实例。这次，你会看到以下失败信息打印出来：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Undo that change so the test is passing again.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撤销该更改，以便测试再次通过。
- en: 'We know that not just one `Birthday` is displayed, but two. We can use the
    `toBeRenderedWithProps` matcher to check for individual instances of the component.
    Update the same test to use that matcher, like this:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道显示的不仅仅是`Birthday`组件一个，而是两个。我们可以使用`toBeRenderedWithProps`匹配器来检查组件的单独实例。更新相同的测试，使用该匹配器，如下所示：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how the calls to `toBeRenderedWithProps` do not need to specify the full
    set of props. If the given subset matches, the expectation passes. That means
    we can avoid checking the `id` field, which is unnecessary detail for the purposes
    of this test.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`toBeRenderedWithProps`的调用不需要指定完整的属性集。如果给定的子集匹配，则期望通过。这意味着我们可以避免检查`id`字段，这对于测试目的来说是不必要的细节。
- en: 'If you comment out the rendering of `Birthday` in the component, you’ll see
    what a failure for this matcher looks like:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你注释掉组件中`Birthday`的渲染，你会看到这个匹配器失败的样子：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second test in this test suite checks the ordering of components. We can
    do that with the library by using the `propsOfAllInstances` function that exists
    on the double. Update the test to read as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本测试套件的第二个测试检查组件的顺序。我们可以通过使用存在于双实例上的`propsOfAllInstances`函数来实现这一点。更新测试如下：
- en: '[PRE26]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first test for `BirthdayForm` no longer needs any `JSON.stringify` magic.
    We can just test the object prop directly. Update the test as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`BirthdayForm`的第一个测试不再需要任何`JSON.stringify`魔法。我们只需直接测试对象属性即可。更新测试如下：
- en: '[PRE27]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And finally, the last test can make use of the `dispatch` double function to
    dispatch an event to the parent component. Note how much simpler this is than
    the hand-rolled mock:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，最后一个测试可以利用`dispatch`双函数将事件分发给父组件。注意这比手动编写的模拟要简单得多：
- en: '[PRE28]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These last two tests show how much simpler it can be to use a component mock
    library over hand-rolled mocks. That completes this section. You’ve now discovered
    all there is to using the `svelte-component-double` library to simplify your test
    suites.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这两个测试展示了使用组件模拟库而不是手动编写的模拟可以多么简单。这完成了本节的内容。你现在已经发现了使用`svelte-component-double`库简化测试套件的全部内容。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has taken a very detailed look at component mocks. We started by
    looking at how it’s often possible to avoid using component mocks in the majority
    of cases, which is important because component mocks are a big cause of complexity
    in test suites.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细探讨了组件模拟。我们首先探讨了在大多数情况下通常可以避免使用组件模拟，这很重要，因为组件模拟是测试套件复杂性的主要原因之一。
- en: You then saw how to use hand-rolled mocks that take advantage of Vitest’s `vi.mock`
    function together with component stubs in the specially named `__mocks__` directory.
    You also saw how they can quickly become complex.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你看到了如何使用利用Vitest的`vi.mock`函数和特别命名的`__mocks__`目录中的组件存根的手动编写的模拟。你也看到了它们如何迅速变得复杂。
- en: Finally, we looked at using the `svelte-component-double` library to avoid using
    hand-rolled mocks. This provides a couple of simple matchers together with some
    helper functions to assist you in writing tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了使用`svelte-component-double`库来避免使用手动编写的模拟。这提供了一些简单的匹配器和一些辅助函数，以帮助你编写测试。
- en: 'That completes all the unit testing topics within this book. The next chapter
    adds one more testing technique: using Cucumber.js to write **Behavior-Driven
    Development** (**BDD**) style tests for your team.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了本书中所有单元测试主题。下一章将增加一种测试技术：使用Cucumber.js为团队编写**行为驱动开发**（**BDD**）风格的测试。
