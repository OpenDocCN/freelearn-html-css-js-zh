<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Creating and Loading Advanced Meshes and Geometries</h1></div></div></div><p>In this chapter, we'll look at a couple of different ways that you can create advanced and complex geometries and meshes. In <a class="link" href="ch05.html" title="Chapter 5. Learning to Work with Geometries">Chapter 5</a>, <em>Learning to Work with Geometries</em>, and <a class="link" href="ch06.html" title="Chapter 6. Advanced Geometries and Binary Operations">Chapter 6</a>, <em>Advanced Geometries and Binary Operations</em> ,we showed you how to create a few advanced geometries using the built-in objects from Three.js. In this chapter, we'll use the following two approaches to create advanced geometries and meshes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Grouping and merging</strong>: The first approach we explain uses built-in functionality from Three.js to group and merge existing geometries. This creates new meshes and geometries from existing objects.</li><li class="listitem" style="list-style-type: disc"><strong>Loading from external</strong>: In this section, we'll explain how you can load meshes and geometries from external sources. For instance, we'll show you how you can use Blender to export meshes in a format Three.js supports.</li></ul></div><p>We start with the <em>group and merge</em> approach. With this approach, we use the standard Three.js grouping and the <code class="literal">THREE.Geometry.merge()</code> function to create new objects.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Geometry grouping and merging</h1></div></div></div><p>In this section, we'll <a id="id742" class="indexterm"/>look at two basic features of Three.js: grouping objects together and merging multiple meshes into a single mesh. We'll start with grouping objects.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Grouping objects together</h2></div></div></div><p>In<a id="id743" class="indexterm"/> some <a id="id744" class="indexterm"/>of the previous chapters, you already saw this when working with multiple materials. When you create a mesh from a geometry using multiple materials, Three.js creates a group. Multiple copies of your geometry are added to this group, each with their own specific material. This group is returned, so it looks like a mesh that uses multiple materials. In truth, however, it is a group that contains a number of meshes.</p><p>Creating <a id="id745" class="indexterm"/>groups <a id="id746" class="indexterm"/>is very easy. Every mesh you create can contain child elements, which can be added using the add function. The effect of adding a child object to a group is that you can move, scale, rotate, and translate the parent object, and all the child objects will also be affected. Let's look at an example (<code class="literal">01-grouping.html</code>). The following screenshot shows this example:</p><div><img src="img/2215OS_08_01.jpg" alt="Grouping objects together"/></div><p>In this example, you can use the menu to move the sphere and the cube around. If you check the <strong>rotate</strong> option, you'll see these two meshes rotating around their center. This isn't anything new and is not very exciting. However, these two objects haven't been added to the scene directly, but have been added as a group. The following code encapsulates this discussion:</p><div><pre class="programlisting">sphere = createMesh(new THREE.SphereGeometry(5, 10, 10));
cube = createMesh(new THREE.BoxGeometry(6, 6, 6));

group = new THREE.Object3D();
group.add(sphere);
group.add(cube);

scene.add(group);</pre></div><p>In this code<a id="id747" class="indexterm"/> snippet, you can see that we create <code class="literal">THREE.Object3D</code>. This is the base class of <code class="literal">THREE.Mesh</code> and <code class="literal">THREE.Scene</code>, but by itself, it doesn't contain anything or cause anything to be rendered. Note that in the latest <a id="id748" class="indexterm"/>version of Three.js, a new object called <code class="literal">THREE.Group</code> was introduced to support grouping. This object is exactly the same as a <code class="literal">THREE.Object3D</code> object, and you can replace <code class="literal">new THREE.Object3D()</code> in the previous code with <code class="literal">new THREE.Group()</code> for the same effect. In this example, we use the <code class="literal">add</code> function to add the <code class="literal">sphere</code> and <code class="literal">cube</code> to this object, and then we add it to the <code class="literal">scene</code>. If you look at the example, you can still move the cube and sphere around and scale and rotate these two objects. You can also do these things on the group they are in. If you look at the group menu, you'll see position and scale options. You can use these to scale and move the entire group around. The scale and position of the objects inside this group are relative to the scale and position of the group itself.</p><p>Scale and position are very straightforward. One thing to keep in mind, though, is that when you rotate a group, it doesn't rotate the objects inside it separately; it rotates the entire group around its own center (in our example, you rotate the entire group around the center of the <code class="literal">group</code> object). In this example, we placed an arrow using the <code class="literal">THREE.ArrowHelper</code> object at the center of the group to indicate the rotation point:</p><div><pre class="programlisting">var arrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), group.position, 10, 0x0000ff);
scene.add(arrow);</pre></div><p>If you check both the <strong>grouping</strong> and <strong>rotate</strong> checkboxes, the group will rotate. You'll see the sphere and cube rotating around the center of the group (indicated by the arrow), as follows:</p><p> </p><div><img src="img/2215OS_08_02.jpg" alt="Grouping objects together"/></div><p>
</p><p>When <a id="id749" class="indexterm"/>using a<a id="id750" class="indexterm"/> group, you can still refer to, modify, and position the individual geometries. The only thing you need to remember is that all positions, rotations, and translations are done relative to the parent object. In the next section, we'll look at merging, where you'll combine multiple separate geometries and end up with a single <code class="literal">THREE.Geometry</code> object.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec52"/>Merging multiple meshes into a single mesh</h2></div></div></div><p>In most <a id="id751" class="indexterm"/>cases, using <a id="id752" class="indexterm"/>groups allows you to easily manipulate and manage a large number of meshes. When you're dealing with a very large number of objects, however, performance will become an issue. With groups, you're still working with individual objects that each need to be handled and rendered <a id="id753" class="indexterm"/>separately. With <code class="literal">THREE.Geometry.merge()</code>, you can merge geometries together and create a combined one. In the following example, you can see how this works and the effect it has on performance. If you open the <code class="literal">02-merging.html</code> example, you see a scene with a set of randomly distributed semitransparent cubes. With the slider in the menu, you can set the number of cubes you want in the scene and redraw the scene by clicking on the <strong>redraw</strong> button. Depending on the hardware you're running on, you'll see a performance degradation as the number of cubes increases. In our case, as you can see in the following screenshot, this happens at around 4,000 objects, where the refresh rate drops to around 40 fps instead of the normal 60 fps:</p><div><img src="img/2215OS_08_03.jpg" alt="Merging multiple meshes into a single mesh"/></div><p>As you can see, there <a id="id754" class="indexterm"/>is a <a id="id755" class="indexterm"/>certain limit to the number of meshes you can add to the scene. Normally, though, you probably wouldn't need that many meshes, but when creating specific games (for example, something like <em>Minecraft</em>) or advanced visualizations, you might need to manage a large number of individual meshes. With <code class="literal">THREE.Geometry.merge()</code>, you can solve this problem. Before we look at the code, let's run this same example, but this time, with the <strong>combine</strong> box checked. With this option flagged, we merge all the cubes into a single <code class="literal">THREE.Geometry</code> and add that one instead, as shown in the following screenshot:</p><div><img src="img/2215OS_08_04.jpg" alt="Merging multiple meshes into a single mesh"/></div><p>As you <a id="id756" class="indexterm"/>can see, we<a id="id757" class="indexterm"/> can easily render 20,000 cubes without any drop in performance. To do this, we use the following couple of lines of code:</p><div><pre class="programlisting">var geometry = new THREE.Geometry();
for (var i = 0; i &lt; controls.numberOfObjects; i++) {
  var cubeMesh = addcube();
  cubeMesh.updateMatrix();
  geometry.merge(cubeMesh.geometry,cubeMesh.matrix);
}
scene.add(new THREE.Mesh(geometry, cubeMaterial));</pre></div><p>In this code snippet, the <code class="literal">addCube()</code> function returns <code class="literal">THREE.Mesh</code>. In older versions of Three.js, we could use the <code class="literal">THREE.GeometryUtils.merge</code> function to also merge <code class="literal">THREE.Mesh</code> objects into <code class="literal">THREE.Geometry</code> objects. With the latest version, this functionality has been deprecated in favor of the <code class="literal">THREE.Geometry.merge</code> function. To make sure the merged-in <code class="literal">THREE.Geometry</code> object is positioned and rotated correctly, we not only provide <code class="literal">THREE.Geometry</code> to the <code class="literal">merge</code> function, but also its transformation matrix. When we add this matrix to the <code class="literal">merge</code> function, the cube we merge in will be positioned correctly.</p><p>We do this 20,000 times<a id="id758" class="indexterm"/> and are left with a single geometry that we add to the scene. If you look at the code, you can probably see a couple of drawbacks of this approach. Since you're left with a single geometry, you can't apply a material to each individual cube. This, however, can<a id="id759" class="indexterm"/> be somewhat solved using <code class="literal">THREE.MeshFaceMaterial</code>. The biggest drawback, however, is that you lose control over the individual cubes. If you want to move, rotate, or scale a single cube, you can't (unless you search for the correct faces and vertices and position them individually).</p><p>With the grouping and merging approach, you can create large and complex geometries using the basic geometries provided by Three.js. If you want to create more advanced geometries, then using the programmatic approach provided by Three.js isn't always the best and easiest option. Three.js, luckily, offers a couple of other options to create geometries. In the next section, we'll look at how you can load geometries and meshes from external resources.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec53"/>Loading geometries from external resources</h2></div></div></div><p>Three.js can <a id="id760" class="indexterm"/>read a number of 3D file formats and import geometries and meshes defined in those files. The following table shows the file formats<a id="id761" class="indexterm"/> that are supported by Three.js:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Format</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>JSON</p>
</td><td style="text-align: left" valign="top">
<p>Three.js<a id="id762" class="indexterm"/> has its own JSON format<a id="id763" class="indexterm"/> you can use to declaratively define a geometry or a scene. Even though this isn't an official format, it's very easy to use and comes in very handy when you want to reuse complex geometries or scenes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>OBJ or MTL</p>
</td><td style="text-align: left" valign="top">
<p>OBJ<a id="id764" class="indexterm"/> is a simple 3D format first <a id="id765" class="indexterm"/>developed by <a id="id766" class="indexterm"/>
<strong>Wavefront Technologies</strong>. It's one of the most widely adopted 3D file formats and is used to define the geometry of an object. MTL is a companion format to OBJ. In an<a id="id767" class="indexterm"/> MTL<a id="id768" class="indexterm"/> file, the material of the objects in an OBJ file is specified.</p>
<p>Three.js also has a custom OBJ exporter, called OBJExporter.js, should you want to export your models to OBJ from Three.js.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Collada</p>
</td><td style="text-align: left" valign="top">
<p>Collada<a id="id769" class="indexterm"/> is a<a id="id770" class="indexterm"/> format for defining <em>digital assets</em> in an XML-based format. This is also a widely used format that is supported by pretty much all 3D applications and rendering engines. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>STL</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>STL</strong><a id="id771" class="indexterm"/> stands for <strong>STereoLithography</strong> and<a id="id772" class="indexterm"/> is widely used for rapid prototyping. For instance, models for 3D printers are often defined as STL files.</p>
<p>Three.js also has a custom STL exporter, called STLExporter.js, should you want to export your models to STL from Three.js.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>CTM</p>
</td><td style="text-align: left" valign="top">
<p>CTM <a id="id773" class="indexterm"/>is a<a id="id774" class="indexterm"/> file format created by <a id="id775" class="indexterm"/>
<strong>openCTM</strong>. It's used as a format for storing 3D triangle-based meshes in a compact format.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>VTK</p>
</td><td style="text-align: left" valign="top">
<p>VTK<a id="id776" class="indexterm"/> is<a id="id777" class="indexterm"/> the file format defined by <a id="id778" class="indexterm"/>
<strong>Visualization Toolkit</strong> and is used to specify vertices and faces. There are two formats available: a binary one and a text-based ASCII one. Three.js only supports the ASCII-based format.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>AWD</p>
</td><td style="text-align: left" valign="top">
<p>AWD<a id="id779" class="indexterm"/> is <a id="id780" class="indexterm"/>a binary format <a id="id781" class="indexterm"/>for 3D scenes and is most often used with the <a class="ulink" href="http://away3d.com/">http://away3d.com/</a> engine. Note that this loader doesn't support compressed AWD files.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Assimp</p>
</td><td style="text-align: left" valign="top">
<p>Open<a id="id782" class="indexterm"/> asset import library (also called <strong>Assimp</strong>) is a<a id="id783" class="indexterm"/> standard way to import various 3D model formats. With this loader, you can import models from a large range of 3D formats that have been converted using <strong>assimp2json</strong>, details <a id="id784" class="indexterm"/>of which are available at <a class="ulink" href="https://github.com/acgessler/assimp2json">https://github.com/acgessler/assimp2json</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>VRML</p>
</td><td style="text-align: left" valign="top">
<p>
<strong>VRML</strong> <a id="id785" class="indexterm"/>stands for <strong>Virtual Reality Modeling Language</strong>. This <a id="id786" class="indexterm"/>is a text-based format that allows you to specify 3D objects and worlds. It has been superseded by the X3D file format. Three.js doesn't support loading X3D models, but these models can be easily <a id="id787" class="indexterm"/>converted to other formats. More information can be found at <a class="ulink" href="http://www.x3dom.org/?page_id=532#">http://www.x3dom.org/?page_id=532#</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Babylon</p>
</td><td style="text-align: left" valign="top">
<p>Babylon<a id="id788" class="indexterm"/> is a 3D JavaScript <a id="id789" class="indexterm"/>game library. It stores models in its own internal format. More<a id="id790" class="indexterm"/> information about this can be found at <a class="ulink" href="http://www.babylonjs.com/">http://www.babylonjs.com/</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PDB</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id791" class="indexterm"/> very specialized format, created by<a id="id792" class="indexterm"/> <strong>Protein Data Bank</strong>, that is used to specify what proteins look like. Three.js can load and visualize proteins specified in this format.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PLY</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id793" class="indexterm"/> format is called the <strong>Polygon</strong> file format. This <a id="id794" class="indexterm"/>is most often used to store information from 3D scanners.</p>
</td></tr></tbody></table></div><p>In the next chapter, we'll <a id="id795" class="indexterm"/>revisit some of these formats (and look at two additional ones, MD2 and glTF) when we look at animations. For now, we start with the first one on the list, the internal format of Three.js.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec54"/>Saving and loading in Three.js JSON format</h2></div></div></div><p>You can<a id="id796" class="indexterm"/> use Three.js' JSON format<a id="id797" class="indexterm"/> for two different scenarios in Three.js. You can use it to save and load a single <code class="literal">THREE.Mesh</code>, or you can use it to save and load a complete scene.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec20"/>Saving and loading THREE.Mesh</h3></div></div></div><p>To demonstrate <a id="id798" class="indexterm"/>saving and loading, we created a simple example based on <code class="literal">THREE.TorusKnotGeometry</code>. With this example, you can create a torus knot, just like we did in <a class="link" href="ch05.html" title="Chapter 5. Learning to Work with Geometries">Chapter 5</a>, <em>Learning to Work with Geometries</em>, and using the <strong>save</strong> button from the <strong>Save &amp; Load</strong> menu, you can save the current geometry. For this example, we save using the HTML5 local storage API. This API allows us to easily store persistent information in the client's browser and retrieve it at a later time (even after the browser has been shut down and restarted).</p><p>We will look at the <code class="literal">03-load-save-json-object.html</code> example. The following screenshot shows this example:</p><div><img src="img/2215OS_08_05.jpg" alt="Saving and loading THREE.Mesh"/></div><p>Exporting <a id="id799" class="indexterm"/>in JSON from Three.js is very easy and doesn't require you to include any additional libraries. The only thing you need to do to export <code class="literal">THREE.Mesh</code> as JSON is the following:</p><div><pre class="programlisting">var result = knot.toJSON();
localStorage.setItem("json", JSON.stringify(result));</pre></div><p>Before saving it, we first convert the result from the <code class="literal">toJSON</code> function, a JavaScript object, to a string using the <code class="literal">JSON.stringify</code> function. This results in a JSON string that looks like this (most of the vertices and faces are left out):</p><div><pre class="programlisting">{
  "metadata": {
    "version": 4.3,
    "type": "Object",
    "generator": "ObjectExporter"
  },
  "geometries": [{
    "uuid": "53E1B290-3EF3-4574-BD68-E65DFC618BA7",
    "type": "TorusKnotGeometry",
    "radius": 10,
    "tube": 1,
    "radialSegments": 64,
    "tubularSegments": 8,
    "p": 2,
    "q": 3,
    "heightScale": 1
  }],
  ...
}</pre></div><p>As you<a id="id800" class="indexterm"/> can see, Three.js saves all the information about <code class="literal">THREE.Mesh</code>. To save this information using the HTML5 local storage API, all we have to do is call the <code class="literal">localStorage.setItem</code> function. The first argument is the key value (<code class="literal">json</code>) that we can later use to retrieve the information we passed in as the second argument.</p><p>Loading <code class="literal">THREE.Mesh</code> back into Three.js also requires just a couple of lines of code, as follows:</p><div><pre class="programlisting">var json = localStorage.getItem("json");

if (json) {
  var loadedGeometry = JSON.parse(json);
  var loader = new THREE.ObjectLoader();

  loadedMesh = loader.parse(loadedGeometry);
  loadedMesh.position.x -= 50;
  scene.add(loadedMesh);
}</pre></div><p>Here, we first get the JSON from local storage using the name we saved it with (<code class="literal">json</code> in this case). For this, we use the <code class="literal">localStorage.getItem</code> function provided by the HTML5 local storage API. Next, we need to convert the string back to a JavaScript object (<code class="literal">JSON.parse</code>) and convert the JSON object back to <code class="literal">THREE.Mesh</code>. Three.js provides a helper object called <code class="literal">THREE.ObjectLoader</code>, which you can use to convert JSON to <code class="literal">THREE.Mesh</code>. In this example, we used the <code class="literal">parse</code> method on the loader to directly parse a JSON string. The loader also provides a <code class="literal">load</code> function, where you can pass in the URL to a file containing the JSON definition.</p><p>As you can see here, we only saved <code class="literal">THREE.Mesh</code>. We lose everything else. If you want to save the complete scene, including the lights and the cameras, you can use <code class="literal">THREE.SceneExporter</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec21"/>Saving and loading a scene</h3></div></div></div><p>If you want to<a id="id801" class="indexterm"/> save a complete scene, you use the same approach as we saw in the previous section for the geometry. <code class="literal">04-load-save-json-scene.html</code> is a working example showing this. The following screenshot shows this example:</p><div><img src="img/2215OS_08_06.jpg" alt="Saving and loading a scene"/></div><p>In this<a id="id802" class="indexterm"/> example, you've got three options: <strong>exportScene</strong>, <strong>clearScene</strong>, and <strong>importScene</strong>. With <strong>exportScene</strong>, the current state of the scene will be saved in the browser's local storage. To test the import functionality, you can remove the scene by clicking on the <strong>clearScene</strong> button and load it from local storage with the <strong>importScene</strong> button. The code to do all this is very simple, but before you can use it, you have to import the required exporter and loader from the Three.js distribution (look at the <code class="literal">examples/js/exporters</code> and <code class="literal">examples/js/loaders</code> directories):</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/SceneLoader.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/SceneExporter.js"&gt;&lt;/script&gt;</pre></div><p>With these JavaScript imports included in the page, you can export a scene with the following code:</p><div><pre class="programlisting">var exporter = new THREE.SceneExporter();
var sceneJson = JSON.stringify(exporter.parse(scene));
localStorage.setItem('scene', sceneJson);</pre></div><p>This approach is exactly the same as we used in the previous section—only this time, we use <code class="literal">THREE.SceneExporter()</code> to export<a id="id803" class="indexterm"/> a complete scene. The resulting JSON looks like this:</p><div><pre class="programlisting">{
  "metadata": {
    "formatVersion": 3.2,
    "type": "scene",
    "generatedBy": "SceneExporter",
    "objects": 5,
    "geometries": 3,
    "materials": 3,
    "textures": 0
  },
  "urlBaseType": "relativeToScene", "objects": {
    "Object_78B22F27-C5D8-46BF-A539-A42207DDDCA8": {
      "geometry": "Geometry_5",
      "material": "Material_1",
      "position": [15, 0, 0],
      "rotation": [-1.5707963267948966, 0, 0],
      "scale": [1, 1, 1],
      "visible": true
    }
    ... // removed all the other objects for legibility
  },
  "geometries": {
    "Geometry_8235FC68-64F0-45E9-917F-5981B082D5BC": {
      "type": "cube",
      "width": 4,
      "height": 4,
      "depth": 4,
      "widthSegments": 1,
      "heightSegments": 1,
      "depthSegments": 1
    }
    ... // removed all the other objects for legibility
  }
  ... other scene information like textures</pre></div><p>When you load this JSON again, Three.js just recreates the objects exactly as they were exported. Loading a scene is done like this:</p><div><pre class="programlisting">var json = (localStorage.getItem('scene'));
var sceneLoader = new THREE.SceneLoader();
sceneLoader.parse(JSON.parse(json), function(e) {
  scene = e.scene;
}, '.');</pre></div><p>The last argument passed into the loader (<code class="literal">'.'</code>) defines the relative URL. For instance, if you've got materials that use textures (for example, external images), those will be retrieved using this relative URL. In this example, where we don't use textures, we just pass in the current directory. Just as with <code class="literal">THREE.ObjectLoader</code>, you can also load a JSON file from a URL using the <code class="literal">load</code> function.</p><p>There are <a id="id804" class="indexterm"/>many different 3D programs you can use to create complex meshes. A popular open source one is Blender (<a class="ulink" href="http://www.blender.org">www.blender.org</a>). Three.js has<a id="id805" class="indexterm"/> an exporter for Blender (and for Maya and 3D Studio Max) that directly exports to the JSON format of Three.js. In the next section, we'll walk you through getting Blender configured to use this exporter and show you how you can export a complex model in Blender and show it in Three.js.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Working with Blender</h2></div></div></div><p>Before <a id="id806" class="indexterm"/>we get started with the configuration, we'll show the result that we'll be aiming for. In the following screenshot, you can see a simple Blender model that we exported with the Three.js plugin and imported in Three.js with <code class="literal">THREE.JSONLoader</code>:</p><div><img src="img/2215OS_08_07.jpg" alt="Working with Blender"/></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec22"/>Installing the Three.js exporter in Blender</h3></div></div></div><p>To get<a id="id807" class="indexterm"/> Blender to export Three.js models, we first need to add the <a id="id808" class="indexterm"/>Three.js exporter to Blender. The following steps are for Mac OS X but are pretty much the same on Windows and Linux. You can download Blender from <a class="ulink" href="http://www.blender.org">www.blender.org</a> and<a id="id809" class="indexterm"/> follow the platform-specific installation instructions. After installation, you can add the Three.js plugin. First, locate the <code class="literal">addons</code> directory from your Blender installation using a terminal window:</p><div><img src="img/2215OS_08_08.jpg" alt="Installing the Three.js exporter in Blender"/></div><p>On my Mac, it's located here: <code class="literal">./blender.app/Contents/MacOS/2.70/scripts/addons</code>. For Windows, this directory can be found at the following location: <code class="literal">C:\Users\USERNAME\AppData\Roaming\Blender Foundation\Blender\2.7X\scripts\addons</code>. And for Linux, you can find this directory here: <code class="literal">/home/USERNAME/.config/blender/2.7X/scripts/addons</code>.</p><p>Next, you need to get the Three.js distribution and unpack it locally. In this distribution, you can find the following folder: <code class="literal">utils/exporters/blender/2.65/scripts/addons/</code>. In this directory, there is a single subdirectory with the name <code class="literal">io_mesh_threejs</code>. Copy this directory to the <code class="literal">addons</code> folder of your Blender installation.</p><p>Now, all we need to do is start Blender and enable the exporter. In Blender, open <strong>Blender User Preferences</strong> (<strong>File</strong> | <strong>User Preferences</strong>). In the window that opens, select the <strong>Addons</strong> tab, and in the search box, type <code class="literal">three</code>. This will show the following screen:</p><div><img src="img/2215OS_08_09.jpg" alt="Installing the Three.js exporter in Blender"/></div><p>At this<a id="id810" class="indexterm"/> point, the <a id="id811" class="indexterm"/>Three.js plugin is found, but it is still disabled. Check the small checkbox to the right, and the Three.js exporter will be enabled. As a final check to see whether everything is working correctly, open the <strong>File</strong> | <strong>Export</strong> menu option, and you'll see Three.js listed as an export option. This is shown in the following screenshot:</p><div><img src="img/2215OS_08_10.jpg" alt="Installing the Three.js exporter in Blender"/></div><p>With<a id="id812" class="indexterm"/> the <a id="id813" class="indexterm"/>plugin installed, we can load our first model.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec23"/>Loading and exporting a model from Blender</h3></div></div></div><p>As an <a id="id814" class="indexterm"/>example, we've added a simple Blender model named <code class="literal">misc_chair01.blend</code> in the <code class="literal">assets/models</code> folder, which you can find in the sources for this book. In this section, we'll load this model and show the minimal steps it takes to export this model to Three.js.</p><p>First, we need to load this model in Blender. Use <strong>File</strong> | <strong>Open</strong> and navigate to the folder containing the <code class="literal">misc_chair01.blend</code> file. Select this file and click on <strong>Open</strong>. This will show you a screen that looks somewhat like this:</p><div><img src="img/2215OS_08_11.jpg" alt="Loading and exporting a model from Blender"/></div><p>Exporting<a id="id815" class="indexterm"/> this model to the Three.js JSON format is pretty straightforward. From the <strong>File</strong> menu, open <strong>Export</strong> | <strong>Three.js</strong>, type in the name of the export file, and select <strong>Export Three.js</strong>. This will create a JSON file in a format Three.js understands. A part of the contents of this file is shown next:</p><div><pre class="programlisting">{

  "metadata" :
  {
    "formatVersion" : 3.1,
    "generatedBy"   : "Blender 2.7 Exporter",
    "vertices"      : 208,
    "faces"         : 124,
    "normals"       : 115,
    "colors"        : 0,
    "uvs"           : [270,151],
    "materials"     : 1,
    "morphTargets"  : 0,
    "bones"         : 0
  },
...</pre></div><p>However, we <a id="id816" class="indexterm"/>aren't completely done. In the previous screenshot, you can see that the chair contains a wooden texture. If you look through the JSON export, you can see that the export for the chair also specifies a material, as follows:</p><div><pre class="programlisting">"materials": [{
  "DbgColor": 15658734,
  "DbgIndex": 0,
  "DbgName": "misc_chair01",
  "blending": "NormalBlending",
  "colorAmbient": [0.53132, 0.25074, 0.147919],
  "colorDiffuse": [0.53132, 0.25074, 0.147919],
  "colorSpecular": [0.0, 0.0, 0.0],
  "depthTest": true,
  "depthWrite": true,
  "mapDiffuse": "misc_chair01_col.jpg",
  "mapDiffuseWrap": ["repeat", "repeat"],
  "shading": "Lambert",
  "specularCoef": 50,
  "transparency": 1.0,
  "transparent": false,
  "vertexColors": false
}],</pre></div><p>This material specifies a texture, <code class="literal">misc_chair01_col.jpg</code>, for the <code class="literal">mapDiffuse</code> property. So, besides exporting the model, we also need to make sure the texture file is also available to Three.js. Luckily, we can save this texture directly from Blender.</p><p>In Blender, open the <strong>UV/Image Editor</strong> view. You can select this view from the drop-down menu on the left-hand side of the <strong>File</strong> menu option. This will replace the top menu with the following:</p><div><img src="img/2215OS_08_12.jpg" alt="Loading and exporting a model from Blender"/></div><p>Make sure the texture you want to export is selected, <code class="literal">misc_chair_01_col.jpg</code> in our case (you can select a different one using the small image icon). Next, click on the <strong>Image</strong> menu and use the <strong>Save as Image</strong> menu option to save the image. Save it in the same folder where you saved the model using the name specified in the JSON export file. At this point, we're ready to load the model into Three.js.</p><p>The code to load this into Three.js at this point looks like this:</p><div><pre class="programlisting">var loader = new THREE.JSONLoader();
loader.load('../assets/models/misc_chair01.js', function (geometry, mat) {
  mesh = new THREE.Mesh(geometry, mat[0]);

  mesh.scale.x = 15;
  mesh.scale.y = 15;
  mesh.scale.z = 15;

  scene.add(mesh);

}, '../assets/models/');</pre></div><p>We've already <a id="id817" class="indexterm"/>seen <code class="literal">JSONLoader</code> before, but this time, we use the <code class="literal">load</code> function instead of the <code class="literal">parse</code> function. In this function, we specify the URL we want to load (points to the exported JSON file), a callback that is called when the object is loaded, and the location, <code class="literal">../assets/models/</code>, where the texture can be found (relative to the page). This callback takes two parameters: <code class="literal">geometry</code> and <code class="literal">mat</code>. The <code class="literal">geometry</code> parameter contains the model, and the <code class="literal">mat</code> parameter contains an array of material objects. We know that there is only one material, so when we create <code class="literal">THREE.Mesh</code>, we directly reference that material. If you open the <code class="literal">05-blender-from-json.html</code> example, you can see the chair we just exported from Blender.</p><p>Using the Three.js exporter isn't the only way of loading models from Blender into Three.js. Three.js understands a number of 3D file formats, and Blender can export in a couple of those formats. Using the Three.js format, however, is very easy, and if things go wrong, they are often quickly found.</p><p>In the following section, we'll look at a couple of the formats Three.js supports and also show a Blender-based example for the OBJ and MTL file formats.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Importing from 3D file formats</h2></div></div></div><p>At the <a id="id818" class="indexterm"/>beginning <a id="id819" class="indexterm"/>of this chapter, we listed a number of formats that are supported by Three.js. In this section, we'll quickly walk through a couple of examples for those formats. Note that for all these formats, an additional JavaScript file needs to be included. You can find all these files in the Three.js distribution in the <code class="literal">examples/js/loaders</code> directory.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec24"/>The OBJ and MTL formats</h3></div></div></div><p>OBJ and MTL are<a id="id820" class="indexterm"/> companion formats and often used together. The <a id="id821" class="indexterm"/>OBJ file defines the geometry, and the MTL file defines the materials that are used. Both OBJ and MTL are text-based formats. A part of an OBJ file looks like this:</p><div><pre class="programlisting">v -0.032442 0.010796 0.025935
v -0.028519 0.013697 0.026201
v -0.029086 0.014533 0.021409
usemtl Material
s 1
f 2731 2735 2736 2732
f 2732 2736 3043 3044</pre></div><p>The MTL file defines materials like this:</p><div><pre class="programlisting">newmtl Material
Ns 56.862745
Ka 0.000000 0.000000 0.000000
Kd 0.360725 0.227524 0.127497
Ks 0.010000 0.010000 0.010000
Ni 1.000000
d 1.000000
illum 2</pre></div><p>The OBJ and MTL formats by Three.js are understood well and are also supported by Blender. So, as an alternative, you could choose to export models from Blender in the OBJ/MTL format instead of the Three.js JSON format. Three.js has two different loaders you can use. If you only want to load the geometry, you can use <code class="literal">OBJLoader</code>. We used this loader for our example (<code class="literal">06-load-obj.html</code>). The following screenshot shows this example:</p><div><img src="img/2215OS_08_13.jpg" alt="The OBJ and MTL formats"/></div><p>To import<a id="id822" class="indexterm"/> this in Three.js, you have to add the OBJLoader JavaScript file:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/OBJLoader.js"&gt;&lt;/script&gt;</pre></div><p>Import the<a id="id823" class="indexterm"/> model like this:</p><div><pre class="programlisting">var loader = new THREE.OBJLoader();
loader.load('../assets/models/pinecone.obj', function (loadedMesh) {
  var material = new THREE.MeshLambertMaterial({color: 0x5C3A21});

  // loadedMesh is a group of meshes. For
  // each mesh set the material, and compute the information
  // three.js needs for rendering.
  loadedMesh.children.forEach(function (child) {
    child.material = material;
    child.geometry.computeFaceNormals();
    child.geometry.computeVertexNormals();
  });

  mesh = loadedMesh;
  loadedMesh.scale.set(100, 100, 100);
  loadedMesh.rotation.x = -0.3;
  scene.add(loadedMesh);
});</pre></div><p>In this code, we use <code class="literal">OBJLoader</code> to load the model from a URL. Once the model is loaded, the callback we provide is called, and we add the model to the scene.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>Usually, a good first step is to print out the response from the callback to the console to understand how the loaded object is built up. Often with these loaders, the geometry or mesh is returned as a hierarchy of groups. Understanding this makes it much easier to place and apply the correct material and take any other additional steps. Also, look at the position of a couple of vertices to determine whether you need to scale the model up or down and where to position the camera. In this example, we've also made the calls to <code class="literal">computeFaceNormals</code> and <code class="literal">computeVertexNormals</code>. This is required to ensure that the material used (<code class="literal">THREE.MeshLambertMaterial</code>) is rendered correctly.</p></div></div><p>The <a id="id824" class="indexterm"/>next <a id="id825" class="indexterm"/>example (<code class="literal">07-load-obj-mtl.html</code>) uses <code class="literal">OBJMTLLoader</code> to load a model and directly assign a material. The following screenshot shows this example:</p><div><img src="img/2215OS_08_14.jpg" alt="The OBJ and MTL formats"/></div><p>First, we need to add the correct loaders to the page:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/OBJLoader.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/MTLLoader.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="img/OBJMTLLoader.js"&gt;&lt;/script&gt;</pre></div><p>We can <a id="id826" class="indexterm"/>load the model from<a id="id827" class="indexterm"/> the OBJ and MTL files like this:</p><div><pre class="programlisting">var loader = new THREE.OBJMTLLoader();
loader.load('../assets/models/butterfly.obj', '../assets/models/butterfly.mtl', function(object) {
  // configure the wings
  var wing2 = object.children[5].children[0];
  var wing1 = object.children[4].children[0];

  wing1.material.opacity = 0.6;
  wing1.material.transparent = true;
  wing1.material.depthTest = false;
  wing1.material.side = THREE.DoubleSide;

  wing2.material.opacity = 0.6;
  wing2.material.depthTest = false;
  wing2.material.transparent = true;
  wing2.material.side = THREE.DoubleSide;

  object.scale.set(140, 140, 140);
  mesh = object;
  scene.add(mesh);

  mesh.rotation.x = 0.2;
  mesh.rotation.y = -1.3;
});</pre></div><p>The first thing to mention before we look at the code is that if you receive an OBJ file, an MTL file, and the required texture files, you'll have to check how the MTL file references the textures. These should be referenced relative to the MTL file and not as an absolute path. The code itself isn't that different from the one we saw for <code class="literal">THREE.ObjLoader</code>. We specify the location of the OBJ file, the location of the MTL file, and the function to call when the model is loaded. The model we've used as an example in this case is a complex model. So, we set some specific properties in the callback to fix some rendering issues, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The opacity in the source files was set incorrectly, which caused the wings to be invisible. So, to fix that, we set the <code class="literal">opacity</code> and <code class="literal">transparent</code> properties ourselves.</li><li class="listitem" style="list-style-type: disc">By default, Three.js only renders one side of an object. Since we look at the wings from two sides, we need to set the <code class="literal">side</code> property to the <code class="literal">THREE.DoubleSide</code> value.</li><li class="listitem" style="list-style-type: disc">The wings caused some unwanted artifacts when they needed to be rendered on top of each other. We've fixed that by setting the <code class="literal">depthTest</code> property to <code class="literal">false</code>. This has a slight impact on performance but can often solve some strange rendering artifacts.</li></ul></div><p>But, as <a id="id828" class="indexterm"/>you <a id="id829" class="indexterm"/>can see, you can easily load complex models directly into Three.js and render them in real time in your browser. You might need to fine-tune some material properties though.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec25"/>Loading a Collada model</h3></div></div></div><p>Collada <a id="id830" class="indexterm"/>models (extension is <code class="literal">.dae</code>) are <a id="id831" class="indexterm"/>another very common format for defining scenes and models (and animations, as we'll see in the following chapter). In a Collada model, it is not just the geometry that is defined, but also the materials. It's even possible to define light sources.</p><p>To load Collada models, you have to take pretty much the same steps as for the OBJ and MTL models. You start by including the correct loader:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/ColladaLoader.js"&gt;&lt;/script&gt;</pre></div><p>For this example, we'll load the following model:</p><div><img src="img/2215OS_08_15.jpg" alt="Loading a Collada model"/></div><p>Loading a truck model is once again pretty simple:</p><div><pre class="programlisting">var mesh;
loader.load("../assets/models/dae/Truck_dae.dae", function (result) {
  mesh = result.scene.children[0].children[0].clone();
  mesh.scale.set(4, 4, 4);
  scene.add(mesh);
});</pre></div><p>The <a id="id832" class="indexterm"/>main<a id="id833" class="indexterm"/> difference here is the result of the object that is returned to the callback. The <code class="literal">result</code> object has the following structure:</p><div><pre class="programlisting">var result = {

  scene: scene,
  morphs: morphs,
  skins: skins,
  animations: animData,
  dae: {
    ...
  }
};</pre></div><p>In this chapter, we're interested in the objects that are in the <code class="literal">scene</code> parameter. I first printed out the scene to the console to look where the mesh was that I was interested in, which was <code class="literal">result.scene.children[0].children[0]</code>. All that was left to do was scale it to a reasonable size and add it to the scene. A final note on this specific example—when I loaded this model for the first time, the materials didn't render correctly. The reason <a id="id834" class="indexterm"/>was that the textures used the <code class="literal">.tga</code> format, which isn't supported in WebGL. To fix this, I had to convert the <code class="literal">.tga</code> files to <code class="literal">.png</code> and edit the XML of the <code class="literal">.dae</code> model to point to these <code class="literal">.png</code> files.</p><p>As you can see, for<a id="id835" class="indexterm"/> most complex models, including materials, you often have to take some additional steps to get the desired results. By looking closely at how the materials are configured (using <code class="literal">console.log()</code>) or replacing them with test materials, problems are often easy to spot.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec26"/>Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models</h3></div></div></div><p>We're going<a id="id836" class="indexterm"/> to quickly skim over these file formats as they all follow the same principles:</p><div><ol class="orderedlist arabic"><li class="listitem">Include <code class="literal">[NameOfFormat]Loader.js</code> in your web page.</li><li class="listitem">Use <code class="literal">[NameOfFormat]Loader.load()</code> to load a URL.</li><li class="listitem">Check what the response format for the callback looks like and render the result.</li></ol></div><p>We have included an example for all these formats:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th><th style="text-align: left" valign="bottom">
<p>Screenshot</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>STL<a id="id837" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">08-load-STL.html</code>
</p>
</td><td style="text-align: left" valign="top">
<div><img src="img/2215OS_08_16.jpg" alt="Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models"/></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>CTM<a id="id838" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">09-load-CTM.html</code>
</p>
</td><td style="text-align: left" valign="top">
<div><img src="img/2215OS_08_17.jpg" alt="Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models"/></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>VTK<a id="id839" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">10-load-vtk.html</code>
</p>
</td><td style="text-align: left" valign="top">
<div><img src="img/2215OS_08_18.jpg" alt="Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models"/></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>AWD<a id="id840" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">11-load-awd.html</code>
</p>
</td><td style="text-align: left" valign="top">
<div><img src="img/2215OS_08_19.jpg" alt="Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models"/></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Assimp<a id="id841" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">12-load-assimp.html</code>
</p>
</td><td style="text-align: left" valign="top">
<div><img src="img/2215OS_08_20.jpg" alt="Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models"/></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>VRML<a id="id842" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">13-load-vrml.html</code>
</p>
</td><td style="text-align: left" valign="top">
<div><img src="img/2215OS_08_21.jpg" alt="Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models"/></div>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Babylon</p>
</td><td style="text-align: left" valign="top">
<p>The Babylon<a id="id843" class="indexterm"/> loader is slightly different from the other loaders in this table. With this loader, you don't load a single <code class="literal">THREE.Mesh</code> or <code class="literal">THREE.Geometry</code> instance, but with this loader, you load a complete scene, including lights.</p>
<p>
<code class="literal">14-load-babylon.html</code>
</p>
</td><td style="text-align: left" valign="top">
<div><img src="img/2215OS_08_22.jpg" alt="Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models"/></div>
</td></tr></tbody></table></div><p>If you look at the source code for these examples, you might see that for some of them, we need to change some material properties or do some scaling before the model is rendered correctly. The reason we need to do this is because of the way the model is created in its external application, giving it different dimensions and grouping than we normally use in Three.js.</p><p>We've almost shown all the supported file formats. In the next two sections, we'll take a different approach. First, we'll look at how to render proteins from Protein Data Bank (PDB format), and finally we'll use a model defined in the PLY format to create a particle system.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec27"/>Show proteins from Protein Data Bank</h3></div></div></div><p>Protein Data<a id="id844" class="indexterm"/> Bank (<a class="ulink" href="http://www.rcsb.org">www.rcsb.org</a>) contains<a id="id845" class="indexterm"/> detailed <a id="id846" class="indexterm"/>information about many different molecules and proteins. Besides the explanation of these proteins, they also provide a way to download the structure of <a id="id847" class="indexterm"/>these molecules in the PDB format. Three.js provides a loader for files specified in the PDB format. In this section, we'll give an example of how you can parse PDB files and visualize them with Three.js.</p><p>The first thing we always need to do to load in a new file format is include the correct loader in Three.js, as follows:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/PDBLoader.js"&gt;&lt;/script&gt;</pre></div><p>With this loader included, we're going to create the following 3D model of the molecule description provided (see the <code class="literal">15-load-ptb.html</code> example):</p><div><img src="img/2215OS_08_23.jpg" alt="Show proteins from Protein Data Bank"/></div><p>Loading<a id="id848" class="indexterm"/> a <a id="id849" class="indexterm"/>PDB file is done in the same manner as the previous formats, as follows:</p><div><pre class="programlisting">var loader = new THREE.PDBLoader();
var group = new THREE.Object3D();
loader.load("../assets/models/diamond.pdb", function (geometry, geometryBonds) {
  var i = 0;

  geometry.vertices.forEach(function (position) {
    var sphere = new THREE.SphereGeometry(0.2);
    var material = new THREE.MeshPhongMaterial({color: geometry.colors[i++]});
    var mesh = new THREE.Mesh(sphere, material);
    mesh.position.copy(position);
    group.add(mesh);
  });

  for (var j = 0; j &lt; geometryBonds.vertices.length; j += 2) {
    var path = new THREE.SplineCurve3([geometryBonds.vertices[j], geometryBonds.vertices[j + 1]]);
    var tube = new THREE.TubeGeometry(path, 1, 0.04)
    var material = new THREE.MeshPhongMaterial({color: 0xcccccc});
    var mesh = new THREE.Mesh(tube, material);
    group.add(mesh);
  }
  console.log(geometry);
  console.log(geometryBonds);

  scene.add(group);
});</pre></div><p>As you <a id="id850" class="indexterm"/>can<a id="id851" class="indexterm"/> see from this example, we instantiate <code class="literal">THREE.PDBLoader</code>, pass in the model file we want to load, and provide a callback that is called when the model is loaded. For this specific loader, the callback function is called with two arguments: <code class="literal">geometry</code> and <code class="literal">geometryBonds</code>. The vertices from the <code class="literal">geometry</code> argument supplied contain the positions of the individual atoms, and <code class="literal">geometryBounds</code> is used for the connections between the atoms.</p><p>For each vertex, we create a sphere with the color that is also supplied by the model:</p><div><pre class="programlisting">var sphere = new THREE.SphereGeometry(0.2);
var material = new THREE.MeshPhongMaterial({color: geometry.colors[i++]});
var mesh = new THREE.Mesh(sphere, material);
mesh.position.copy(position);
group.add(mesh)</pre></div><p>Each connection is defined like this:</p><div><pre class="programlisting">var path = new THREE.SplineCurve3([geometryBonds.vertices[j], geometryBonds.vertices[j + 1]]);
var tube = new THREE.TubeGeometry(path, 1, 0.04)
var material = new THREE.MeshPhongMaterial({color: 0xcccccc});
var mesh = new THREE.Mesh(tube, material);
group.add(mesh);</pre></div><p>For the connection, we first create a 3D path using the <code class="literal">THREE.SplineCurve3</code> object. This path is used as input for <code class="literal">THREE.Tube</code> and used to create the connection between the atoms. All the connections and atoms are added to a group, and this group is added to the scene. There are many models you can download from Protein Data Bank. </p><p>The following image shows the structure of a diamond:</p><div><img src="img/2215OS_08_24.jpg" alt="Show proteins from Protein Data Bank"/></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec28"/>Creating a particle system from a PLY model</h3></div></div></div><p>Working with the <a id="id852" class="indexterm"/>PLY format isn't that much different from the other formats. You include the loader, provide a callback, and<a id="id853" class="indexterm"/> visualize the model. For this<a id="id854" class="indexterm"/> last example, however, we're going to do something different. Instead of rendering the model as a mesh, we'll use the information from this model to create a particle system (see the <code class="literal">15-load-ply.html</code> example). The following screenshot shows this example:</p><div><img src="img/2215OS_08_25.jpg" alt="Creating a particle system from a PLY model"/></div><p>The<a id="id855" class="indexterm"/> JavaScript code to render the<a id="id856" class="indexterm"/> preceding screenshot is actually<a id="id857" class="indexterm"/> very simple, as follows:</p><div><pre class="programlisting">var loader = new THREE.PLYLoader();
var group = new THREE.Object3D();
loader.load("../assets/models/test.ply", function (geometry) {
  var material = new THREE.PointCloudMaterial({
    color: 0xffffff,
    size: 0.4,
    opacity: 0.6,
    transparent: true,
    blending: THREE.AdditiveBlending,
    map: generateSprite()
  });

  group = new THREE.PointCloud(geometry, material);
  group.sortParticles = true;

  scene.add(group);
});</pre></div><p>As you can see, we use <code class="literal">THREE.PLYLoader</code> to load the model. The callback returns <code class="literal">geometry</code>, and we use this geometry as input for <code class="literal">THREE.PointCloud</code>. The material we use is the same<a id="id858" class="indexterm"/> as the one we used for the last example in the previous chapter. As you can see, with <a id="id859" class="indexterm"/>Three.js, it is very easy to combine models from various<a id="id860" class="indexterm"/> sources and render them in different ways, all with a few lines of code.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Summary</h1></div></div></div><p>Using models from external sources isn't that hard to do in Three.js. Especially for simple models, you only have to take a few simple steps. When working with external models, or creating them using grouping and merging, it is good to keep a couple of things in mind. The first thing you need to remember is that when you group objects, they still remain available as individual objects. Transformations applied to the parent also affect the children, but you can still transform the children individually. Besides grouping, you can also merge geometries together. With this approach, you lose the individual geometries and get a single new geometry. This is especially useful when you're dealing with thousands of geometries you need to render and you're running into performance issues.</p><p>Three.js supports a large number of external formats. When using these format loaders, it's a good idea to look through the source code and log out the information received in the callback. This will help you to understand the steps you need to take to get the correct mesh and set it to the correct position and scale. Often, when the model doesn't show correctly, this is caused by its material settings. It could be that incompatible texture formats are used, opacity is incorrectly defined, or the format contains incorrect links to the texture images. It is usually a good idea to use a test material to determine whether the model itself is loaded correctly and log the loaded material to the JavaScript console to check for unexpected values. It is also possible to export meshes and scenes, but remember that <code class="literal">GeometryExporter</code>, <code class="literal">SceneExporter</code>, and <code class="literal">SceneLoader</code> of Three.js are still work in progress.</p><p>The models you worked with in this chapter, and in the previous chapters, are mostly static models. They aren't animated, don't move around, and don't change shape. In the next chapter, you'll learn how you can animate your models to make them come to life. Besides animations, the following chapter will also explain the various camera controls provided by Three.js. With a camera control, you can move, pan, and rotate the camera around your scene.</p></div></body></html>