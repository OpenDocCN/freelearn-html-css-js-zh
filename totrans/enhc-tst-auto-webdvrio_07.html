<html><head></head><body>
		<div><h1 id="_idParaDest-105" class="chapter-number"><a id="_idTextAnchor154"/>7</h1>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor155"/>The Select Wrapper – Choosing Values in Lists and Comboboxes</h1>
			<p>In this chapter, we’ll extend our suite of utility belt functions with a versatile method called <code>selectAdv()</code>. This function is designed to handle list elements effectively, similar to how our existing <code>clickAdv()</code> and <code>setValue()</code> functions operate. We’ll incorporate a validation check to ensure the element passed to the function is a valid one. Moreover, we’ll implement a retry mechanism that attempts to locate the element up to three times, scrolling it into view each time as necessary.</p>
			<p>The true challenge, however, arises when dealing with comboboxes. These elements can be complex to interact with, especially when it comes to opening them to reveal a list of selectable items. Another point of concern is to clear any lingering text from the combobox before selecting a new value. We’ll explore three distinct strategies to achieve this.</p>
			<p>Once these hurdles are overcome, the next step is to identify the desired item from the list and select it. Here, another tool, <code>SelectorsHub</code>, comes into play as a life-saving sidekick, assisting us in pinpointing the correct item with precision.</p>
			<p>We’ll cover the following main topics in this chapter:</p>
			<ul>
				<li>Adding the base functionality of <code>Click</code> and <code>setValue</code></li>
				<li>Selecting an item from a list</li>
				<li>Inspecting a list that closes when it loses focus with <code>SelectorsHub</code></li>
			</ul>
			<p>We will begin with the code that is common to the prior methods discussed.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor156"/>Adding the base functionality of clickAdv() and setValueAdv() to selectAdv()</h1>
			<p>Just like our <code>clickAdv()</code> and <code>setValueAdv()</code> methods before, we will want to ensure that our elements are valid and scroll into view for our screen <a id="_idIndexMarker296"/><a id="_idIndexMarker297"/>captures. If the test itself has already failed, we will not perform any further <a id="_idIndexMarker298"/><a id="_idIndexMarker299"/>action, essentially stubbing out the function. The initial section of the method will be similar to the <code>clickAdv()</code> method:</p>
			<pre class="source-code">
exports.selectAdv = async (selector, text){
  element = await getValidElement(element, "list");
      let listName : String = getListName{element}</pre>			<p>If the list element does not exist, we will make three attempts to find a similar node in the <code>getValidElement()</code> function. This first approach is to try to find a list using the <code>@</code><code>id</code> property:</p>
			<pre class="source-code">
case 'list'
  newSelector = `//select[contains(@id,
    '${selector.toLowerCase()}'}]`;
  length = await (this.countMatches(newSelector)));
  exists = length != 0
  element = await ${`${newSelector}`);</pre>			<p>If there are no elements found with all-lowercase IDs, we will try again without the case:</p>
			<pre class="source-code">
  if (length == 0){
    // Second chance List locator
    newSelector = `//select[contains(@id, '${selector}'}]`;
    length = await (this.countMatches(newSelector)));
    exists = length != 0
    element = await ${`${newSelector}`);
  }</pre>			<p>Our final attempt will be to seek the child <code>select</code> node of any element that contains the text in the string. This is commonly a <code>Div</code> or <code>Span</code> node:</p>
			<pre class="source-code">
  if (length == 0){
    // Second chance List locator
    newSelector = `//*[contains(text(),       '${selector}')]/parent::*/select]`;
    length = await (this.countMatches(newSelector)));
    exists = length != 0
    element = await ${`${newSelector}`);
  }
    break;
}</pre>			<p>Now that we have the list element, we have three ways to select the item from the list. Each way has its advantages and disadvantages.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor157"/>Selecting an item from the list</h1>
			<p>WebdriverIO provides three ways to select an<a id="_idIndexMarker300"/><a id="_idIndexMarker301"/> item from an element:</p>
			<ul>
				<li><code>selectByVisibleText</code>: Matches the option<a id="_idIndexMarker302"/><a id="_idIndexMarker303"/> based on its visible text</li>
				<li><code>selectByIndex</code>: Matches the option based on its index location (0-based)</li>
				<li><code>selectByAttribute</code>: Matches the option based on a specific attribute and its value</li>
			</ul>
			<p>For example, if we wanted to select the third month from a list of months, each of these approaches could work:</p>
			<pre class="source-code">
await lstMonth.selectByVisibleText ("March");
await lstMonth.selectByAttribute ("value", "March");
await lstMonth.selectByIndex(2); // 0 based index</pre>			<p>Often, the WebdriverIO <code>selectByVisibleText</code> method works fine as the default method in a wrapper, but there are times when a list element needs to interact with open of the alternative ways.</p>
			<p>In each case, we should validate that the correct value has been selected:</p>
			<pre class="source-code">
await lstElement.selectByVisibleText (item);
let itemValue = await listElement.getText();
if (itemValue === item) return true</pre>			<p>In addition, if an error is thrown, we should attempt to find a close match in the list.</p>
			<p>One way is to send the down arrow in the list. Then, we check whether the selected value contains the expected value:</p>
			<pre class="source-code">
await listElement.click({ block: 'center' }) // Set focus
await browser.keys(["\uE015"]}; // Send down arrow key to open the list </pre>			<p>Then, we can loop through and note the match or print the list of non-matching values:</p>
			<pre class="source-code">
let item : String ="";
let arrItems: string[] = [];
let found : boolean = false
let lastItem : string = await listElement.getText()
arrItems.push(lastItem);</pre>			<p>This is an infinite loop with two exit points. Either a<a id="_idIndexMarker304"/><a id="_idIndexMarker305"/> close match was found or the last item of the list was reached and there was no <a id="_idIndexMarker306"/><a id="_idIndexMarker307"/>match:</p>
			<pre class="source-code">
do {
  if (await listElement).getText().contains(item){
    found = true
    global.log ("Found a close match: " +
      listElement).getText()
    break;
  }
  await browser.keys(["\uE015"]}; // Send down arrow key
  item = listElement.getText()
  if (lastValue === item) {
    break;
 global.log (`'${item}' was not found in list: ${arrValues}); // Output the item and the list of values
}
   arrItems.push(item)
} while !(lastValue == listElement.getText()) // No match</pre>			<p>If this loop never finds a match, we will output the item we sought and the list of available elements stored in <code>arrItems[]</code>:</p>
			<pre class="source-code">
if (found === false) {
  await this.log (`    Failed to select '${text}' from ${arrItems} in ${listName}
  return element;
}</pre>			<p>This completes the most common list element. However, we can also support a path that interacts with a combobox, which can be a whole different type of beast.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor158"/>Selecting from a combobox</h1>
			<p>Another reason to have a wrapper is to be able to identify and interact with an element that is not a true drop-down list. In this example, we have a combobox. This<a id="_idIndexMarker308"/><a id="_idIndexMarker309"/> is both an input field and a selection from a list of potential matches. Take, for example, a list of countries.</p>
			<div><div><img src="img/B19395_07_1.jpg" alt="Figure 7.1 – A combobox with an item selected from partial text"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A combobox with an item selected from partial text</p>
			<p>In <code>&lt;select&gt;</code> element with multiple <code>&lt;option&gt;</code> child elements. Here are a few approaches.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor159"/>Using selectByVisibleText</h2>
			<p>This method allows you to<a id="_idIndexMarker312"/><a id="_idIndexMarker313"/> select an option by<a id="_idIndexMarker314"/><a id="_idIndexMarker315"/> its visible text (the text displayed to the user):</p>
			<pre class="source-code">
<code>const comboBoxSelector = 'select#yourComboBoxId';</code>
<code>$(comboBoxSelector).selectByVisibleText('Option Text');</code></pre>			<h2 id="_idParaDest-111"><a id="_idTextAnchor160"/>Using selectByAttribute</h2>
			<p>This method allows you to select an option <a id="_idIndexMarker316"/><a id="_idIndexMarker317"/>by its <code>value</code><code><a id="_idIndexMarker318"/><a id="_idIndexMarker319"/></code> attribute:</p>
			<pre class="console">
const comboBoxSelector = 'select#yourComboBoxId';
$(comboBoxSelector).selectByAttribute('value', 'option-value');</pre>			<h2 id="_idParaDest-112"><a id="_idTextAnchor161"/>Using selectByIndex</h2>
			<p>This method allows you to select an option <a id="_idIndexMarker320"/><a id="_idIndexMarker321"/>by its index (<code>0</code>-based):</p>
			<pre class="console">
const comboBoxSelector = 'select#yourComboBoxId';
$(comboBoxSelector).selectByIndex(1); // Index starts from 0</pre>			<p>Then, we click the field and type the item text. If we find <a id="_idIndexMarker322"/><a id="_idIndexMarker323"/>an element containing the text, we click it. However, writing that element locator in a self-closing list can be tricky. That’s where <code>SelectorsHub</code> comes in handy.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor162"/>Inspecting a list that closes when it loses focus with SelectorsHub</h1>
			<p>On occasion, it is difficult to get the <a id="_idIndexMarker324"/><a id="_idIndexMarker325"/>locator of a list item because the list will only be open when the mouse cursor hovers over it. In this example, we can pause the execution of the web page in order to interact with the elements while the list is expanded. The pause feature in DevTools is located on the <strong class="bold">Sources</strong> tab:</p>
			<div><div><img src="img/B19395_07_2.jpg" alt="Figure 7.2 – The Sources tab selected to display the pause button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The Sources tab selected to display the pause button</p>
			<p>This is handy for catching elements that do not stay on the screen long, such as spinners and <em class="italic">loading...</em> mechanisms. Sometimes, we’re just not fast enough to get to the pause button or the list simply closes once we move our mouse off of it. This is where a tool called <code>SelectorsHub</code> comes in handy. This tool is a Chrome browser add-on:</p>
			<div><div><img src="img/B19395_07_3.jpg" alt="Figure 7.3 – SelectorsHub displayed in the browser tools’ extentions menu"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – SelectorsHub displayed in the browser tools’ extentions menu</p>
			<p>This tool can be installed by searching the Chrome browser extensions.</p>
			<p>Once installed, the tool can be found on the <strong class="bold">Elements</strong> tab. Usually, it’s the first tab listed, and sometimes, it’s the last. One of the hidden features of this tool is <strong class="bold">Debug</strong> mode.</p>
			<div><div><img src="img/B19395_07_4.jpg" alt="Figure 7.4 – Activating the pause from SelectorsHub to freeze a spinner and get its locator ID"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Activating the pause from SelectorsHub to freeze a spinner and get its locator ID</p>
			<p>By clicking the <code>SelectorsHub</code> will <a id="_idIndexMarker326"/><a id="_idIndexMarker327"/>automatically pause the web page after five seconds. This allows us to capture tricky elements in good time. Try pausing the <em class="italic">loading... </em> spinner page of the website at <a href="https://candymapperr2.com/launch-candymapper">https://candymapperr2.com/launch-candymapper</a>:</p>
			<div><div><img src="img/B19395_07_5.jpg" alt="Figure 7.5 – An example of a spinner on a web page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – An example of a spinner on a web page</p>
			<p>The default setting of entering pause mode after five seconds is sufficient for most of these situations. To catch very brief elements, the <strong class="bold">Settings</strong> option allows us to change<a id="_idIndexMarker328"/><a id="_idIndexMarker329"/> the delay to shorter or longer amounts as needed.</p>
			<div><div><img src="img/B19395_07_6.jpg" alt="Figure 7.6 – Setting the time for the debugger to wait"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Setting the time for the debugger to wait</p>
			<p>This also works well with <em class="italic">loading...</em> <strong class="bold">wait</strong> mechanisms that are briefly displayed.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor163"/>Writing a locator that is an element inside a list</h1>
			<p>Now, we have our list in a combobox and <a id="_idIndexMarker330"/><a id="_idIndexMarker331"/>can clear any existing element text. There are a few ways this can be done. We can set the value, we can double-click to select all the existing text, and lastly, we can send <em class="italic">Ctrl</em> + <em class="italic">A</em> keystrokes to the field:</p>
			<pre class="console">
ListElement.setValue("");</pre>			<p>However, that may not work for all input field elements. Perhaps a double-click to the field will work:</p>
			<pre class="console">
await listElement.doubleclick()</pre>			<p>Well, it will work if there is a single word already in the field, such as <code>Denmark</code>, but not if it includes spaces, such as <code>Trinidad </code><code>and Tobago</code>.</p>
			<p>Surprisingly, a triple click on a field will select everything. However, at the time of writing, the authors know of no automation tool that supports triple clicks. Also, in case you were wondering, this is not a triple-click:</p>
			<pre class="source-code">
await listElement.click(); await listElement.click(); await listElement.click()</pre>			<p>Here is a way to clear a field. Set the focus on the field <a id="_idIndexMarker332"/><a id="_idIndexMarker333"/>with a single click. Then, send a <code>Home</code> keystroke to place the cursor at the start of the field. Next, hit the <em class="italic">Shift</em> and <em class="italic">End</em> keys to highlight all the text in the field. Finally, send a <em class="italic">Delete</em> key to the field followed by the text, like this:</p>
			<pre class="source-code">
await listElement.click()
await browser.keys(['Home']);
await browser.keys(['Shift','End']);
await browser.keys(['Delete']);
await browser.keys(`${item}`)</pre>			<p>In this situation, the combobox displays all the items that are available to choose. Inside a <code>try</code> and <code>Catch</code>, we can now get a collection of all the list items that match our expected value:</p>
			<pre class="source-code">
        // Find the item in the list
        try {
          listItems = await browser.$$(`//li/*`)</pre>			<p>We search for a list item that is close to a perfect match.</p>
			<p>If found, we break the loop and perform a click, using the custom <code>clickAdv()</code> method:</p>
			<pre class="console">
          for (const listItem of listItems) {
            if ((await listItem.getText()).includes(item))             // Found the element
            break;
          }

          clickAdv(listItem)
        } catch (error) {</pre>			<p>If this fails, it means there was no item to click. The most important information we need to log now is what the available items displayed in the list were:</p>
			<pre class="source-code">
          listItems = await browser.$$(`//li/*`)
          for (const listItem of listItems) {
             textContent += await listItem.getText() + " | ";              // Get the text content of the element

        }
          await log(`  ERROR: "${item}" was not found in combobox: \n ${textContent}`)
        }</pre>			<p>Now, we have a robust custom method that will give <a id="_idIndexMarker334"/><a id="_idIndexMarker335"/>actionable details to help us maintain our tests when they fail. From here, we can extend this method to report when there are multiple close matches.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor164"/>Summary</h1>
			<p>In this chapter, we wrote a custom wrapper to select an item from a list element. We learned how to handle two separate types of objects with a single method, reducing test case code. The combobox path uses the <code>click()</code> method to open and navigate through a list, as well as clear the input field that filters matches in the list. We embedded reporting if no exact or close match exists, making debugging easier. This was done by sending a log error message, indicating what item was sought, the list element it was using, and the list of non-matching values. We also showed how to use <code>SelectorsHub</code> to provide a way to validate handwritten XPath selectors when the list closes, as soon as the object loses focus.</p>
			<p>This completes three of the four most common methods used in test automation. In the next chapter, we will create an enhanced <code>Assertion</code> method that validates the state or text of an object, as well as validating generic text that appears on a page.</p>
		</div>
	</body></html>