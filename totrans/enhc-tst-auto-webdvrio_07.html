<html><head></head><body>
		<div id="_idContainer083">
			<h1 id="_idParaDest-105" class="chapter-number"><a id="_idTextAnchor154"/>7</h1>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor155"/>The Select Wrapper – Choosing Values in Lists and Comboboxes</h1>
			<p>In this chapter, we’ll extend our suite of utility belt functions with a versatile method called <strong class="source-inline">selectAdv()</strong>. This function is designed to handle list elements effectively, similar to how our existing <strong class="source-inline">clickAdv()</strong> and <strong class="source-inline">setValue()</strong> functions operate. We’ll incorporate a validation check to ensure the element passed to the function is a valid one. Moreover, we’ll implement a retry mechanism that attempts to locate the element up to three times, scrolling it into view each time <span class="No-Break">as necessary.</span></p>
			<p>The true challenge, however, arises when dealing with comboboxes. These elements can be complex to interact with, especially when it comes to opening them to reveal a list of selectable items. Another point of concern is to clear any lingering text from the combobox before selecting a new value. We’ll explore three distinct strategies to <span class="No-Break">achieve this.</span></p>
			<p>Once these hurdles are overcome, the next step is to identify the desired item from the list and select it. Here, another tool, <strong class="source-inline">SelectorsHub</strong>, comes into play as a life-saving sidekick, assisting us in pinpointing the correct item <span class="No-Break">with precision.</span></p>
			<p>We’ll cover the following main topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Adding the base functionality of <strong class="source-inline">Click</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">setValue</strong></span></li>
				<li>Selecting an item from <span class="No-Break">a list</span></li>
				<li>Inspecting a list that closes when it loses focus <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">SelectorsHub</strong></span></li>
			</ul>
			<p>We will begin with the code that is common to the prior <span class="No-Break">methods discussed.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor156"/>Adding the base functionality of clickAdv() and setValueAdv() to selectAdv()</h1>
			<p>Just like our <strong class="source-inline">clickAdv()</strong> and <strong class="source-inline">setValueAdv()</strong> methods before, we will want to ensure that our elements are valid and scroll into view for our screen <a id="_idIndexMarker296"/><a id="_idIndexMarker297"/>captures. If the test itself has already failed, we will not perform any further <a id="_idIndexMarker298"/><a id="_idIndexMarker299"/>action, essentially stubbing out the function. The initial section of the method will be similar to the <span class="No-Break"><strong class="source-inline">clickAdv()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
exports.selectAdv = async (selector, text){
  element = await getValidElement(element, "list");
      let listName : String = getListName{element}</pre>			<p>If the list element does not exist, we will make three attempts to find a similar node in the <strong class="source-inline">getValidElement()</strong> function. This first approach is to try to find a list using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> property:</span></p>
			<pre class="source-code">
case 'list'
  newSelector = `//select[contains(@id,
    '${selector.toLowerCase()}'}]`;
  length = await (this.countMatches(newSelector)));
  exists = length != 0
  element = await ${`${newSelector}`);</pre>			<p>If there are no elements found with all-lowercase IDs, we will try again without <span class="No-Break">the case:</span></p>
			<pre class="source-code">
  if (length == 0){
    // Second chance List locator
    newSelector = `//select[contains(@id, '${selector}'}]`;
    length = await (this.countMatches(newSelector)));
    exists = length != 0
    element = await ${`${newSelector}`);
  }</pre>			<p>Our final attempt will be to seek the child <strong class="source-inline">select</strong> node of any element that contains the text in the string. This is commonly a <strong class="source-inline">Div</strong> or <span class="No-Break"><strong class="source-inline">Span</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
  if (length == 0){
    // Second chance List locator
    newSelector = `//*[contains(text(),       '${selector}')]/parent::*/select]`;
    length = await (this.countMatches(newSelector)));
    exists = length != 0
    element = await ${`${newSelector}`);
  }
    break;
}</pre>			<p>Now that we have the list element, we have three ways to select the item from the list. Each way has its advantages <span class="No-Break">and disadvantages.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor157"/>Selecting an item from the list</h1>
			<p>WebdriverIO provides three ways to select an<a id="_idIndexMarker300"/><a id="_idIndexMarker301"/> item from <span class="No-Break">an element:</span></p>
			<ul>
				<li><strong class="source-inline">selectByVisibleText</strong>: Matches the option<a id="_idIndexMarker302"/><a id="_idIndexMarker303"/> based on its <span class="No-Break">visible text</span></li>
				<li><strong class="source-inline">selectByIndex</strong>: Matches the option based on its index <span class="No-Break">location (0-based)</span></li>
				<li><strong class="source-inline">selectByAttribute</strong>: Matches the option based on a specific attribute and <span class="No-Break">its value</span></li>
			</ul>
			<p>For example, if we wanted to select the third month from a list of months, each of these approaches <span class="No-Break">could work:</span></p>
			<pre class="source-code">
await lstMonth.selectByVisibleText ("March");
await lstMonth.selectByAttribute ("value", "March");
await lstMonth.selectByIndex(2); // 0 based index</pre>			<p>Often, the WebdriverIO <strong class="source-inline">selectByVisibleText</strong> method works fine as the default method in a wrapper, but there are times when a list element needs to interact with open of the <span class="No-Break">alternative ways.</span></p>
			<p>In each case, we should validate that the correct value has <span class="No-Break">been selected:</span></p>
			<pre class="source-code">
await lstElement.selectByVisibleText (item);
let itemValue = await listElement.getText();
if (itemValue === item) return true</pre>			<p>In addition, if an error is thrown, we should attempt to find a close match in <span class="No-Break">the list.</span></p>
			<p>One way is to send the down arrow in the list. Then, we check whether the selected value contains the <span class="No-Break">expected value:</span></p>
			<pre class="source-code">
await listElement.click({ block: 'center' }) // Set focus
await browser.keys(["\uE015"]}; // Send down arrow key to open the list </pre>			<p>Then, we can loop through and note the match or print the list of <span class="No-Break">non-matching values:</span></p>
			<pre class="source-code">
let item : String ="";
let arrItems: string[] = [];
let found : boolean = false
let lastItem : string = await listElement.getText()
arrItems.push(lastItem);</pre>			<p>This is an infinite loop with two exit points. Either a<a id="_idIndexMarker304"/><a id="_idIndexMarker305"/> close match was found or the last item of the list was reached and there was <span class="No-Break">no </span><span class="No-Break"><a id="_idIndexMarker306"/><a id="_idIndexMarker307"/></span><span class="No-Break">match:</span></p>
			<pre class="source-code">
do {
  if (await listElement).getText().contains(item){
    found = true
    global.log ("Found a close match: " +
      listElement).getText()
    break;
  }
  await browser.keys(["\uE015"]}; // Send down arrow key
  item = listElement.getText()
  if (lastValue === item) {
    break;
 global.log (`'${item}' was not found in list: ${arrValues}); // Output the item and the list of values
}
   arrItems.push(item)
} while !(lastValue == listElement.getText()) // No match</pre>			<p>If this loop never finds a match, we will output the item we sought and the list of available elements stored <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">arrItems[]</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if (found === false) {
  await this.log (`    Failed to select '${text}' from ${arrItems} in ${listName}
  return element;
}</pre>			<p>This completes the most common list element. However, we can also support a path that interacts with a combobox, which can be a whole different type <span class="No-Break">of beast.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor158"/>Selecting from a combobox</h1>
			<p>Another reason to have a wrapper is to be able to identify and interact with an element that is not a true drop-down list. In this example, we have a combobox. This<a id="_idIndexMarker308"/><a id="_idIndexMarker309"/> is both an input field and a selection from a list of potential matches. Take, for example, a list <span class="No-Break">of countries.</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B19395_07_1.jpg" alt="Figure 7.1 – A combobox with an item selected from partial text"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A combobox with an item selected from partial text</p>
			<p>In <strong class="bold">WebdriverIO</strong> (<strong class="bold">WDIO</strong>), selecting an <a id="_idIndexMarker310"/><a id="_idIndexMarker311"/>option from a combobox (or dropdown) can be done in multiple ways. A combobox in HTML is usually represented by a <strong class="source-inline">&lt;select&gt;</strong> element with multiple <strong class="source-inline">&lt;option&gt;</strong> child elements. Here are a <span class="No-Break">few approaches.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor159"/>Using selectByVisibleText</h2>
			<p>This method allows you to<a id="_idIndexMarker312"/><a id="_idIndexMarker313"/> select an option by<a id="_idIndexMarker314"/><a id="_idIndexMarker315"/> its visible text (the text displayed to <span class="No-Break">the user):</span></p>
			<pre class="source-code">
<strong class="source-inline">const comboBoxSelector = 'select#yourComboBoxId';</strong>
<strong class="source-inline">$(comboBoxSelector).selectByVisibleText('Option Text');</strong></pre>			<h2 id="_idParaDest-111"><a id="_idTextAnchor160"/>Using selectByAttribute</h2>
			<p>This method allows you to select an option <a id="_idIndexMarker316"/><a id="_idIndexMarker317"/>by its <span class="No-Break"><strong class="source-inline">value</strong></span><span class="No-Break"><strong class="source-inline"><a id="_idIndexMarker318"/><a id="_idIndexMarker319"/></strong></span><span class="No-Break"> attribute:</span></p>
			<pre class="console">
const comboBoxSelector = 'select#yourComboBoxId';
$(comboBoxSelector).selectByAttribute('value', 'option-value');</pre>			<h2 id="_idParaDest-112"><a id="_idTextAnchor161"/>Using selectByIndex</h2>
			<p>This method allows you to select an option <a id="_idIndexMarker320"/><a id="_idIndexMarker321"/>by its <span class="No-Break">index (</span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">-based):</span></p>
			<pre class="console">
const comboBoxSelector = 'select#yourComboBoxId';
$(comboBoxSelector).selectByIndex(1); // Index starts from 0</pre>			<p>Then, we click the field and type the item text. If we find <a id="_idIndexMarker322"/><a id="_idIndexMarker323"/>an element containing the text, we click it. However, writing that element locator in a self-closing list can be tricky. That’s where <strong class="source-inline">SelectorsHub</strong> comes <span class="No-Break">in handy.</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor162"/>Inspecting a list that closes when it loses focus with SelectorsHub</h1>
			<p>On occasion, it is difficult to get the <a id="_idIndexMarker324"/><a id="_idIndexMarker325"/>locator of a list item because the list will only be open when the mouse cursor hovers over it. In this example, we can pause the execution of the web page in order to interact with the elements while the list is expanded. The pause feature in DevTools is located on the <span class="No-Break"><strong class="bold">Sources</strong></span><span class="No-Break"> tab:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B19395_07_2.jpg" alt="Figure 7.2 – The Sources tab selected to display the pause button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The Sources tab selected to display the pause button</p>
			<p>This is handy for catching elements that do not stay on the screen long, such as spinners and <em class="italic">loading...</em> mechanisms. Sometimes, we’re just not fast enough to get to the pause button or the list simply closes once we move our mouse off of it. This is where a tool called <strong class="source-inline">SelectorsHub</strong> comes in handy. This tool is a Chrome <span class="No-Break">browser add-on:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B19395_07_3.jpg" alt="Figure 7.3 – SelectorsHub displayed in the browser tools’ extentions menu"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – SelectorsHub displayed in the browser tools’ extentions menu</p>
			<p>This tool can be installed by searching the Chrome <span class="No-Break">browser extensions.</span></p>
			<p>Once installed, the tool can be found on the <strong class="bold">Elements</strong> tab. Usually, it’s the first tab listed, and sometimes, it’s the last. One of the hidden features of this tool is <span class="No-Break"><strong class="bold">Debug</strong></span><span class="No-Break"> mode.</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B19395_07_4.jpg" alt="Figure 7.4 – Activating the pause from SelectorsHub to freeze a spinner and get its locator ID"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Activating the pause from SelectorsHub to freeze a spinner and get its locator ID</p>
			<p>By clicking the <strong class="bold">Debugger</strong> icon, <strong class="source-inline">SelectorsHub</strong> will <a id="_idIndexMarker326"/><a id="_idIndexMarker327"/>automatically pause the web page after five seconds. This allows us to capture tricky elements in good time. Try pausing the <em class="italic">loading... </em> spinner page of the website <span class="No-Break">at </span><a href="https://candymapperr2.com/launch-candymapper"><span class="No-Break">https://candymapperr2.com/launch-candymapper</span></a><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B19395_07_5.jpg" alt="Figure 7.5 – An example of a spinner on a web page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – An example of a spinner on a web page</p>
			<p>The default setting of entering pause mode after five seconds is sufficient for most of these situations. To catch very brief elements, the <strong class="bold">Settings</strong> option allows us to change<a id="_idIndexMarker328"/><a id="_idIndexMarker329"/> the delay to shorter or longer amounts <span class="No-Break">as needed.</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B19395_07_6.jpg" alt="Figure 7.6 – Setting the time for the debugger to wait"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Setting the time for the debugger to wait</p>
			<p>This also works well with <em class="italic">loading...</em> <strong class="bold">wait</strong> mechanisms that are <span class="No-Break">briefly displayed.</span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor163"/>Writing a locator that is an element inside a list</h1>
			<p>Now, we have our list in a combobox and <a id="_idIndexMarker330"/><a id="_idIndexMarker331"/>can clear any existing element text. There are a few ways this can be done. We can set the value, we can double-click to select all the existing text, and lastly, we can send <em class="italic">Ctrl</em> + <em class="italic">A</em> keystrokes to <span class="No-Break">the field:</span></p>
			<pre class="console">
ListElement.setValue("");</pre>			<p>However, that may not work for all input field elements. Perhaps a double-click to the field <span class="No-Break">will work:</span></p>
			<pre class="console">
await listElement.doubleclick()</pre>			<p>Well, it will work if there is a single word already in the field, such as <strong class="source-inline">Denmark</strong>, but not if it includes spaces, such as <strong class="source-inline">Trinidad </strong><span class="No-Break"><strong class="source-inline">and Tobago</strong></span><span class="No-Break">.</span></p>
			<p>Surprisingly, a triple click on a field will select everything. However, at the time of writing, the authors know of no automation tool that supports triple clicks. Also, in case you were wondering, this is not <span class="No-Break">a triple-click:</span></p>
			<pre class="source-code">
await listElement.click(); await listElement.click(); await listElement.click()</pre>			<p>Here is a way to clear a field. Set the focus on the field <a id="_idIndexMarker332"/><a id="_idIndexMarker333"/>with a single click. Then, send a <strong class="source-inline">Home</strong> keystroke to place the cursor at the start of the field. Next, hit the <em class="italic">Shift</em> and <em class="italic">End</em> keys to highlight all the text in the field. Finally, send a <em class="italic">Delete</em> key to the field followed by the text, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
await listElement.click()
await browser.keys(['Home']);
await browser.keys(['Shift','End']);
await browser.keys(['Delete']);
await browser.keys(`${item}`)</pre>			<p>In this situation, the combobox displays all the items that are available to choose. Inside a <strong class="source-inline">try</strong> and <strong class="source-inline">Catch</strong>, we can now get a collection of all the list items that match our <span class="No-Break">expected value:</span></p>
			<pre class="source-code">
        // Find the item in the list
        try {
          listItems = await browser.$$(`//li/*`)</pre>			<p>We search for a list item that is close to a <span class="No-Break">perfect match.</span></p>
			<p>If found, we break the loop and perform a click, using the custom <span class="No-Break"><strong class="source-inline">clickAdv()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
          for (const listItem of listItems) {
            if ((await listItem.getText()).includes(item))             // Found the element
            break;
          }

          clickAdv(listItem)
        } catch (error) {</pre>			<p>If this fails, it means there was no item to click. The most important information we need to log now is what the available items displayed in the <span class="No-Break">list were:</span></p>
			<pre class="source-code">
          listItems = await browser.$$(`//li/*`)
          for (const listItem of listItems) {
             textContent += await listItem.getText() + " | ";              // Get the text content of the element

        }
          await log(`  ERROR: "${item}" was not found in combobox: \n ${textContent}`)
        }</pre>			<p>Now, we have a robust custom method that will give <a id="_idIndexMarker334"/><a id="_idIndexMarker335"/>actionable details to help us maintain our tests when they fail. From here, we can extend this method to report when there are multiple <span class="No-Break">close matches.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor164"/>Summary</h1>
			<p>In this chapter, we wrote a custom wrapper to select an item from a list element. We learned how to handle two separate types of objects with a single method, reducing test case code. The combobox path uses the <strong class="source-inline">click()</strong> method to open and navigate through a list, as well as clear the input field that filters matches in the list. We embedded reporting if no exact or close match exists, making debugging easier. This was done by sending a log error message, indicating what item was sought, the list element it was using, and the list of non-matching values. We also showed how to use <strong class="source-inline">SelectorsHub</strong> to provide a way to validate handwritten XPath selectors when the list closes, as soon as the object <span class="No-Break">loses focus.</span></p>
			<p>This completes three of the four most common methods used in test automation. In the next chapter, we will create an enhanced <strong class="source-inline">Assertion</strong> method that validates the state or text of an object, as well as validating generic text that appears on <span class="No-Break">a page.</span></p>
		</div>
	</body></html>