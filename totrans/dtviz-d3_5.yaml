- en: Chapter 5. Layouts – d3's Black Magic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。布局 – d3的黑色魔法
- en: Most of us look at the Internet for inspiration and code samples. You find something
    that looks great, look at the code, and your eyes glaze over. It doesn't make
    any sense.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的大多数人都在互联网上寻找灵感和代码示例。你找到一些看起来很棒的东西，看看代码，然后你的眼睛就会变得模糊。它没有任何意义。
- en: The usual culprit is d3's reliance on layouts for anything remotely complicated.
    The black magic of taking some data, calling a function, and voilà—visualization!
    This elegance makes layouts look deceptively difficult, but they make things a
    lot easier when you get a hang of them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的罪魁祸首是 d3 对任何稍微复杂的事情都依赖于布局。从一些数据调用一个函数，然后 voilà——可视化！这种优雅使布局看起来欺骗性地困难，但当你掌握了它们，它们会使事情变得容易得多。
- en: In this chapter, we'll go in, guns blazing, with everything we've learned so
    far to create 11 visualizations of the same dataset.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带着我们迄今为止所学的一切，全速前进，创建同一数据集的11个可视化。
- en: What are layouts and why should you care
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局是什么以及为什么你应该关心
- en: d3 layouts are modules that transform data into drawing rules. The simplest
    layout might only transform an array of objects into coordinates, like a scale.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: d3 布局是模块，将数据转换为绘图规则。最简单的布局可能只是将对象数组转换为坐标，就像一个比例尺。
- en: But we usually use layouts for more complex visualizations—drawing a force-directed
    graph or a tree, for instance. In these cases, layouts help us to separate calculating
    coordinates from putting pixels on a page. This not only makes our code cleaner,
    but it also lets us reuse the same layouts for vastly different visualizations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们通常使用布局来创建更复杂的可视化——例如绘制一个力导向图或一棵树。在这些情况下，布局帮助我们分离计算坐标和将像素放置在页面上的过程。这不仅使我们的代码更干净，而且还可以让我们为截然不同的可视化重用相同的布局。
- en: Theory is boring, let's dig in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 理论是无聊的，让我们深入挖掘。
- en: Built-in layouts
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置布局
- en: 'By default, d3 comes with 12 built-in layouts that cover most common visualizations.
    They can be split roughly into normal and hierarchical layouts. The normal layouts
    are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，d3附带12个内置布局，涵盖了大多数常见的可视化。它们可以大致分为普通布局和层次布局。普通布局如下：
- en: '`histogram`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`histogram`'
- en: '`pie`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pie`'
- en: '`stack`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stack`'
- en: '`chord`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chord`'
- en: '`force`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`force`'
- en: 'The hierarchical layouts are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 层次布局如下：
- en: '`partition`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition`'
- en: '`tree`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tree`'
- en: '`cluster`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster`'
- en: '`pack`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pack`'
- en: '`treemap`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`treemap`'
- en: To see how they behave, we're going to make an example for each type. We'll
    start with the humble pie chart and histogram, then progress to force-directed
    graphs and fancy trees. We're using the same dataset for all examples, so that
    we can get a feel of how different presentations affect the perception of data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它们的行为，我们将为每种类型创建一个示例。我们将从谦逊的饼图和直方图开始，然后过渡到力导向图和花哨的树。我们使用相同的数据集来展示所有示例，这样我们就可以感受到不同的展示方式如何影响数据的感知。
- en: These are the last examples in this book, so we're going to make them particularly
    magnificent. That's going to create a lot of code, so every time we come up with
    something reusable, we'll put it in a `helpers.js` file as a function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是本书中的最后几个示例，所以我们将使它们特别出色。这将创建大量的代码，所以每次我们想到可重用的东西，我们都会将其作为一个函数放入`helpers.js`文件中。
- en: 'Let''s create an empty `helper.js` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个空的`helper.js`文件：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We're going to add functions as members of this global object. Add the following
    line to the HTML right before including the normal code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把函数作为全局对象的成员添加。在包含正常代码之前，将以下行添加到 HTML 中。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's also agree that all examples start with a drawing area and fetching the
    data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们同意所有示例都以绘图区域和数据获取开始。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example code will go in the `d3.json` load listener.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码将放在`d3.json`加载监听器中。
- en: The dataset
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据集
- en: The dataset we'll be playing with has been scraped from my favorite IRC channel's
    log going back to late 2011\. The channel's special feature is the karma bot.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要玩的数据集是从我最喜欢的IRC频道的日志中抓取的，追溯到2011年末。该频道的特殊功能是 karma 机器人。
- en: When someone does something we like, we give them karma with `nick++` and the
    bot counts it as a vote for that person. Just like on Reddit, karma is supposed
    to measure how much the community likes someone, but it's really just about who
    is most active.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人做我们喜欢的事情时，我们用`nick++`给他们 karma，机器人将其计为对该人的投票。就像在 Reddit 上一样，karma 本来是用来衡量社区对某人的喜爱程度的，但实际上它只是关于谁最活跃。
- en: The karma is what we're interested in.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是 karma。
- en: 'You can get the dataset at [https://raw.github.com/Swizec/d3.js-book-examples/master/ch5/data/karma_matrix.json](https://raw.github.com/Swizec/d3.js-book-examples/master/ch5/data/karma_matrix.json).
    The dataset consists of objects representing instances of giving karma. Each looks
    like the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://raw.github.com/Swizec/d3.js-book-examples/master/ch5/data/karma_matrix.json](https://raw.github.com/Swizec/d3.js-book-examples/master/ch5/data/karma_matrix.json)
    获取数据集。该数据集由表示给予 karma 实例的对象组成。每个对象看起来像以下代码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every object tells us at what time (`time`) somebody (`from`) gave karma to
    (`to`) somebody else. To deal with the cruft often tacked onto nicknames—for instance,
    `smotko` is `smotko-nexus` from his phone—only the first four letters of the nickname
    were considered when scraping the dataset.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都告诉我们某人在何时（`time`）向某人（`from`）给予 karma。为了处理通常附加到昵称上的杂项——例如，`smotko` 是来自他手机的
    `smotko-nexus`——在抓取数据集时只考虑昵称的前四个字母。
- en: This creates a clean dataset for us to work with. You can think of it as a list
    of edges in a graph, where users are nodes and `to` and `from` create a directed
    edge.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们创建了一个干净的数据集来工作。您可以将其视为图中边的一个列表，其中用户是节点，`to` 和 `from` 创建一个有向边。
- en: Time to draw!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候绘制了！
- en: Using the histogram layout
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用直方图布局
- en: We are going to use the `histogram` layout to create a bar chart of the karma
    people have received. The layout itself will handle everything from collecting
    values into bins, to calculating heights, widths, and the positions of the bars.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `histogram` 布局来创建人们收到的 karma 的条形图。布局本身将处理从收集值到区间，再到计算条形的高度、宽度和位置的所有事情。
- en: Histograms usually represent a probability distribution over a continuous numerical
    domain, but nicknames are ordinal. To bend the `histogram` layout to our will,
    we have to turn nicknames into numbers—we'll use a scale.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图通常表示连续数值域上的概率分布，但昵称是序数的。为了使 `histogram` 布局符合我们的意愿，我们必须将昵称转换为数字——我们将使用一个刻度。
- en: 'Since it feels like this could be useful in other examples, we''ll put the
    code in `helpers.js`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于感觉这可能在其他示例中很有用，我们将代码放入 `helpers.js`：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These are two simple functions. `uniques` goes through the data and returns
    a list of unique nicknames. We help it with the `nick` accessor. `nick_id` creates
    an ordinal scale we'll be using to convert nicknames into numbers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是两个简单的函数。`uniques` 遍历数据并返回一个唯一昵称的列表。我们通过 `nick` 访问器帮助它。`nick_id` 创建一个序数刻度，我们将使用它将昵称转换为数字。
- en: Now we can tell the histogram how to handle our data with `nick_id`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以告诉直方图如何使用 `nick_id` 处理我们的数据。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `d3.layout.histogram()` we create a new histogram and use `.bins()` to
    define the upper threshold for each bin. Given `[1,2,3]`, values under `1` go
    in the first bin, values between `1` and `2` in the second, and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `d3.layout.histogram()` 我们创建一个新的直方图，并使用 `.bins()` 定义每个区间的上限。给定 `[1,2,3]`，小于
    `1` 的值进入第一个区间，介于 `1` 和 `2` 之间的值进入第二个区间，依此类推。
- en: The `.value()` accessor tells the histogram how to find values in our dataset.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`.value()` 访问器告诉直方图如何在我们的数据集中查找值。'
- en: Another way to specify bins is by specifying the number of bins you want and
    letting the histogram uniformly divide a continuous numerical input domain into
    bins. For such domains, you can even make probability histograms by setting `.frequency()`
    to `false`. You can limit the range of considered bins with `.range()`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种指定区间的方法是指定所需的区间数量，并让直方图将连续的数值输入域均匀地划分为区间。对于此类域，您甚至可以通过将 `.frequency()` 设置为
    `false` 来创建概率直方图。您可以使用 `.range()` 限制考虑的区间的范围。
- en: 'Finally, we used the layout as a function on our data to get an array of objects
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用布局作为我们数据上的一个函数来获取一个类似这样的对象数组：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Bin width is in the `dx` property, `x` is the horizontal position and `y` is
    the height. We access elements in bins with normal array functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 区间宽度在 `dx` 属性中，`x` 是水平位置，`y` 是高度。我们使用常规数组函数访问区间中的元素。
- en: Using this data to draw a bar chart should be easy by now. We'll define a scale
    for each dimension, label both axes, and place some rectangles for bars.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用这些数据绘制条形图应该很容易了。我们将为每个维度定义一个刻度，标注两个轴，并放置一些矩形作为条形。
- en: 'To make things easier, we begin with some margins. Remember, all this code
    goes in the data load listener we defined earlier:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更简单，我们首先设置一些边距。记住，所有这些代码都放在我们之前定义的数据加载监听器中：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And two scales.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并且两个刻度。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using a log scale for the vertical axis will make the graph easier to read despite
    the huge karma variations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用垂直轴的对数刻度将使图表更容易阅读，尽管 karma 变化很大。
- en: 'Next, put a vertical axis on the left:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在左侧放置一个垂直轴：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We create a grouping element for every bar and its label:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个条形及其标签创建一个分组元素：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Moving the group into position, as shown in the following code, means less
    work when positioning the bar and its label:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将分组移动到位置，如下面的代码所示，意味着在定位条形及其标签时工作量更少：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because the group is in place, we can put the bar a pixel from the group''s
    edge. All bars will be `histogram[0].dx` wide and we''ll calculate heights using
    the `y` position of each datum and the total graph height. Lastly, we create the
    labels:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为分组已经到位，我们可以将条形图放置在分组边缘的一个像素处。所有条形图的宽度将是`histogram[0].dx`，我们将使用每个数据点的`y`位置和总图高度来计算高度。最后，我们创建标签：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We move labels to the bottom of the graph, rotate them by 60 degrees to avoid
    overlap, and set their text to the `.to` property of the datum.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将标签移动到图的底部，旋转60度以避免重叠，并将它们的文本设置为数据点的`.to`属性。
- en: 'Add some CSS styling to the HTML:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为HTML添加一些CSS样式：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our bar chart looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可视化条形图看起来像这样：
- en: '![Using the histogram layout](img/0007_05_01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![使用直方图布局](img/0007_05_01.jpg)'
- en: Well, the whole graph wouldn't fit in the book. Run the example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，整个图表放不进这本书里。运行示例。
- en: Delicious pie
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 美味的饼图
- en: The previous bar chart reveals that **HairyFotr** has the most karma by far.
    Let's find out who's making him so popular.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的条形图显示**HairyFotr**的karma最多。让我们找出是谁让他如此受欢迎。
- en: We are going to use the pie chart layout to cut the karma of **HairyFotr** into
    slices, showing how much karma he gets from the others. After filtering the dataset
    for karma going to **HairyFotr**, we have to categorize entries by givers, and
    finally feed them into the pie chart layout to generate a pie chart.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用饼图布局将**HairyFotr**的karma分割成块，显示他从其他人那里得到多少karma。在过滤了要给**HairyFotr**的karma数据集之后，我们必须按捐赠者对条目进行分类，最后将它们输入饼图布局以生成饼图。
- en: 'We can use the `histogram` layout to put data into bins depending on the `.from`
    property. Let''s add a function to `helpers.js`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`histogram`布局根据`.from`属性将数据放入桶中。让我们在`helpers.js`中添加一个函数：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar to the `uniques` and `nick_id` functions, `bin_per_nick` takes the data
    and a `nick` accessor, and returns histogram data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与`uniques`和`nick_id`函数类似，`bin_per_nick`接受数据和`nick`访问器，并返回直方图数据。
- en: 'We can now do this in pie chart''s data listener:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在饼图的监听器中这样做：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Entries in the `per_nick` variable will tell us exactly how much karma **HairyFotr**
    got from someone.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`per_nick`变量中的条目将告诉我们**HairyFotr**从某人那里得到了多少karma。'
- en: 'To bake a pie, we call the `pie` layout and give it a value accessor:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作一个饼图，我们调用`pie`布局并提供一个值访问器：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `pie` layout is now full of slice objects, each holding the `startAngle`
    and `endAngle` values and the original value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`pie`布局现在充满了切片对象，每个对象都持有`startAngle`和`endAngle`值以及原始值。'
- en: 'Entries look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 条目看起来像这样：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We could have specified a `.sort()` function to change how slices are organized
    and a `.startAngle()` or `.endAngle()` function to limit the pie's size.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一个`.sort()`函数来改变切片的组织方式，或者一个`.startAngle()`或`.endAngle()`函数来限制饼图的大小。
- en: All that's left to do now is drawing a pie chart. We'll need an `arc` generator,
    just as the ones in [Chapter 2](ch02.html "Chapter 2. A Primer on DOM, SVG, and
    CSS"), *A Primer on DOM, SVG*, and CSS and some color to tell slices apart.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是绘制饼图。我们需要一个`arc`生成器，就像[第2章](ch02.html "第2章。DOM、SVG和CSS简介")中提到的那些，*DOM、SVG和CSS简介*，以及一些颜色来区分切片。
- en: Finding 24 distinct colors that look great together is hard; lucky for us, `@ponywithhiccups`
    jumped to the challenge and made the pick. Thank you!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 找到24种看起来很棒且不同的颜色很难；幸运的是，`@ponywithhiccups`接受了挑战并做出了选择。谢谢！
- en: 'Let''s add these colors to `helpers.js`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`helpers.js`中添加这些颜色：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `color` scale is an ordinal scale without a domain. To make sure nicknames
    always get the same color, a function in `helpers.js` will help us fixate the
    domain, as shown in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`color`刻度是一个没有域的顺序刻度。为了确保昵称总是得到相同的颜色，`helpers.js`中的一个函数将帮助我们固定域，如下面的代码所示：'
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can define the `arc` generator and fixate the colors:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`arc`生成器并固定颜色：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A group element will hold each arc and its label as shown in the following
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个弧形及其标签都由一个分组元素持有，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To make positioning simpler, we move every group to the center of the pie chart.
    Creating slices works the same as in [Chapter 2](ch02.html "Chapter 2. A Primer
    on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化定位，我们将每个分组移动到饼图的中心。创建切片的工作方式与[第2章](ch02.html "第2章。DOM、SVG和CSS简介")中提到的相同，*DOM、SVG和CSS简介*：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We get the color for a slice with `d.data[0].from`—the original dataset is in
    `.data` and all the `.from` properties in it are the same. That's what we grouped
    by.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`d.data[0].from`获取一个切片的颜色——原始数据集在`.data`中，其中所有的`.from`属性都是相同的。这是我们按其分组的。
- en: Labels take a bit more work. They need to be rotated into place and sometimes
    flipped so that they don't appear upside-down.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标签需要做更多的工作。它们需要旋转到合适的位置，有时还需要翻转，以免出现颠倒的情况。
- en: 'Labeling an arc will be handy later as well, so let''s make a general function
    in `helpers.js`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后标记弧线也会很有用，所以让我们在`helpers.js`中创建一个通用函数：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're using partial application to generate a function operating on a d3 selection.
    This means we can use it with `.call()`, while still defining our own parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用部分应用来生成一个在d3选择上操作的功能。这意味着我们可以使用它与`.call()`一起，同时仍然定义我们自己的参数。
- en: We'll give `arc_labels` a `text` accessor and a `radius` accessor, and it will
    return a function we can use with `.call()` on a selection to make labels appear
    in just the right places. The meaty part appends a text element, tweaks its `text-anchor`
    element, depending on whether we're going to flip it, and rotates the element
    into a particular position with the help of a `tickAngle` function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`arc_labels`提供一个`text`访问器和`radius`访问器，它将返回一个我们可以使用`.call()`在选择上调用的函数，以便在正确的位置显示标签。主要部分附加一个文本元素，根据是否需要翻转调整其`text-anchor`元素，并使用`tickAngle`函数将元素旋转到特定的位置。
- en: 'Let''s add the contents of the `tickAngle` function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`tickAngle`函数的内容：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`helpers.tickAngle` calculates the middle angle between `d.startAngle` and
    `d.endAngle` and transforms the result from radians to degrees so that SVG can
    understand it.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`helpers.tickAngle`计算`d.startAngle`和`d.endAngle`之间的中间角度，并将结果从弧度转换为度，以便 SVG
    可以理解它。'
- en: This is basic trigonometry, so I won't go into details, but your favorite high
    schooler should be able to explain the math.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是基本的三角学，所以我就不详细说明了，但你的高中好友应该能够解释这个数学。
- en: 'We use `arc_labels` back in the load listener:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在加载监听器中再次使用`arc_labels`：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And our delicious pie is done as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，我们的美味饼图已经完成：
- en: '![Delicious pie](img/0007_05_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![美味饼图](img/0007_05_02.jpg)'
- en: Clearly, the smallest values could do with some grouping under other, but you
    can play around with that on your own.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最小的值可以在其他值下进行分组，但你可以自己尝试一下。
- en: Showing popularity through time with stack
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过堆叠显示随时间推移的流行度
- en: 'D3''s official docs say:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: D3的官方文档说：
- en: '"The stack layout takes a two-dimensional array of data and computes a baseline;
    the baseline is then propagated to the above layers, so as to produce a stacked
    graph."'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “堆叠布局接受一个二维数组的数据，并计算一个基线；然后，基线被传播到上面的层，以产生一个堆叠图。”
- en: Not clear at all, but I am hard pressed to come up with better. The `stack`
    layout calculates where one layer ends and another begins. An example should help.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不清楚，但我实在想不出更好的方法。`stack`布局计算一个层结束和另一个层开始的位置。一个例子应该会有帮助。
- en: '![Showing popularity through time with stack](img/0007_05_14.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![通过堆叠显示随时间推移的流行度](img/0007_05_14.jpg)'
- en: We're going to make a layered timeline of karma, stretching as far back as 2011,
    with the width of each layer telling us how much karma went to a user at a certain
    time. This timeline is called a **streamgraph**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个从2011年开始的 karma 层次时间线，每个层的宽度告诉我们用户在特定时间有多少 karma。这个时间线被称为**流图**。
- en: To label layers, we're going to create a `mouseover` behavior that highlights
    a layer and shows a tooltip with the user's nickname. By fiddling until the graph
    looked pretty, I discovered that we should bin data into 12-day slots.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标记层级，我们将创建一个`mouseover`行为，该行为会突出显示一个层级并显示带有用户昵称的工具提示。通过调整直到图表看起来很漂亮，我发现我们应该将数据分入12天的时段。
- en: 'Let''s begin the binning:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始分桶：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To parse timestamps into date objects, we specified a format for strings like
    `2012-01-25 15:32:15`. Then, we used this format to find the earliest and latest
    time with `d3.extent`. Telling `d3.time.days()` to go from start to finish with
    a step of 12 days creates a list of bins.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将时间戳解析为日期对象，我们指定了类似`2012-01-25 15:32:15`的字符串格式。然后，我们使用这个格式通过`d3.extent`找到最早和最晚的时间。告诉`d3.time.days()`从开始到结束，以12天为步长创建一系列的桶。
- en: 'We use the `histogram` layout to munge our dataset into a more useful form:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`histogram`布局将我们的数据集转换成更有用的形式：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You already know what `helpers.bin_per_nick` does.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道`helpers.bin_per_nick`的作用。
- en: To bin data into time slots, we mapped through each layer of the `nick` accessors
    and turned it into a two-property object. The `.to` property tells us whom the
    layer represents, and `.values` is a histogram of time slots where entries tell
    us how much karma the user got in a certain 12-day period.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据分入时间槽，我们遍历了`nick`访问器的每一层，并将其转换为一个具有两个属性的对象。`.to`属性告诉我们哪一层代表谁，`.values`是时间槽的直方图，条目告诉我们用户在某个12天期间获得了多少karma。
- en: 'Time for a `stack` layout:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用`stack`布局了：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`d3.layout.stack()` creates a new `stack` layout. We told it how to order layers
    with `.order(''inside-out'')` (you should also try `default` and `reverse`) and
    decided how the final graph looks with `.offset(''wiggle'')`. `wiggle` minimizes
    change in slope. Other options include `silhouette`, `zero`, and `expand`. Try
    them.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.layout.stack()`创建了一个新的`stack`布局。我们告诉它如何使用`.order(''inside-out'')`（你也应该尝试`default`和`reverse`）来排序层，并决定最终图形的样式使用`.offset(''wiggle'')`。`wiggle`最小化了斜率的变化。其他选项包括`silhouette`、`zero`和`expand`。试试它们。'
- en: Once again, we told the layout how to find values with the `.values()` accessor.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们告诉布局如何使用`.values()`访问器找到值。
- en: 'Our `layers` array is now filled with objects like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在`layers`数组中填充了如下对象：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`values` is an array of arrays. Entries in the outer array are time bins that
    look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`values`是一个数组的数组。外部数组中的条目是时间桶，看起来像这样：'
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The important parts of this array are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组的重要部分如下：
- en: '`x` is the horizontal position, `y` is the thickness, and `y0` is the baseline.
    `d3.layout.stack` will always return these.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`是水平位置，`y`是厚度，`y0`是基线。`d3.layout.stack`总是会返回这些。'
- en: 'To start drawing, we need some margins and two scales:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始绘制，我们需要一些边距和两个比例尺：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The tricky thing was finding the vertical scale's domain. We found it by going
    through each value of every layer, looking for the maximum `d.y0+d.y` value—baseline
    plus thickness.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 难办的是找到垂直比例的域。我们通过遍历每一层的每个值，寻找最大`d.y0+d.y`值——基线加上厚度。
- en: We'll use an `area` path generator for the layers;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为层使用一个`area`路径生成器；
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Nothing too fancy, the baselines define bottom edges and adding the thickness
    gives the top edge. Fiddling determined that both should be pushed down by 100
    pixels.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么太复杂的，基线定义了底部边缘，加上厚度给出了顶部边缘。调整确定两者都应该向下推100像素。
- en: 'Let''s draw an axis first:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们画一个轴：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Same as usual—we defined an axis, called it on a selection, and let d3 do its
    thing. We only made it prettier with a custom `.tickFormat()` function and used
    `.ticks()` to say we want a new tick every two months.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样——我们定义了一个轴，在一个选择上调用它，并让d3做它的事情。我们只通过自定义的`.tickFormat()`函数让它更漂亮，并使用`.ticks()`表示我们想要每两个月有一个新的刻度。
- en: 'Ok, now for the streamgraph, add the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在对于流图，添加以下代码：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Not much is going on. We used the `area` generator to draw each layer, defined
    colors with `helpers.color`, and called a `tooltip` function, which we'll define
    in `helpers.js` later.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别的。我们使用了`area`生成器来绘制每一层，使用`helpers.color`定义了颜色，并调用了一个`tooltip`函数，我们将在`helpers.js`中稍后定义。
- en: 'The graph looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图形看起来像这样：
- en: '![Showing popularity through time with stack](img/0007_05_03.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![通过堆叠显示随时间变化的流行度](img/0007_05_03.jpg)'
- en: 'It looks pretty, but it is useless. Let''s add that `tooltip` function to `helpers.js`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来很漂亮，但毫无用处。让我们将那个`tooltip`函数添加到`helpers.js`中：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We defined event listeners with a `.tooltip` namespace so that we can define
    multiple listeners on the same events.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.tooltip`命名空间定义了事件监听器，这样我们就可以在相同的事件上定义多个监听器。
- en: The `mouseover` function will highlight streams and create tooltips, `mousemove`
    will move tooltips, and `mouseout` will put everything back to normal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseover`函数将突出显示流并创建工具提示，`mousemove`将移动工具提示，`mouseout`将一切恢复原状。'
- en: 'Let''s put the three listeners inside the inner function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把三个监听器放在内部函数中：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's the simple part of `mouseover`. It selects the current area and changes
    its class to `highlighted`. That will make it lighter and add a red outline.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`mouseover`的简单部分。它选择当前区域并将其类更改为`highlighted`。这将使其变亮并添加一个红色轮廓。
- en: 'In the same function, add the meaty part:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，添加主要内容：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is longer and with a dash of magic, but not scary at all!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它更长，带有一点魔法，但一点也不可怕！
- en: First we find the mouse's position, then create a group element, and position
    it down and to the right of the mouse. We add a text element to the group and
    call SVG's `getBBox()` function on its node. This gives us the text element's
    bounding box and helps us size the background rectangle.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们找到鼠标的位置，然后创建一个组元素，并将其放置在鼠标的下方和右侧。我们在组中添加一个文本元素，并在其节点上调用 SVG 的 `getBBox()`
    函数。这给我们文本元素的边界框，并帮助我们确定背景矩形的尺寸。
- en: 'Finally, we remove the text because it''s covered by the background and add
    it again. We might be able to avoid all this trouble by using divs, but I wanted
    to show you pure SVG tooltips. Hence, consider the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移除文本，因为它被背景覆盖，然后再次添加。我们可能可以通过使用 div 来避免所有这些麻烦，但我想要展示纯 SVG 工具提示。因此，考虑以下代码：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `mousemove` listener in the following code is much simpler. It just finds
    the `#nicktool` element and moves it to follow the cursor.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的 `mousemove` 监听器非常简单。它只是找到 `#nicktool` 元素，并将其移动到跟随光标的位置。
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `mouseout` function selects the current path, removes its `highlighted`
    styling, and removes the tooltip.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseout` 函数选择当前路径，移除其 `highlighted` 样式，并移除工具提示。'
- en: Voila! Tooltips
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！工具提示
- en: 'Very rudimentary—they don''t understand edges and they won''t break any hearts
    with their looks, but they get the job done. Let''s add some CSS to the HTML:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 非常基础——它们不理解边缘，也不会因为外观而打动人心，但它们能完成任务。让我们给 HTML 添加一些 CSS：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And now we have a potentially useful streamgraph on our hands.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们手中有一个可能很有用的流图。
- en: '![Showing popularity through time with stack](img/0007_05_04.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![通过堆叠显示随时间变化的流行度](img/0007_05_04.jpg)'
- en: Highlighting friends with chord
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用弦线突出显示朋友
- en: We've seen how much karma people have and when they got it, but there's another
    gem hiding in the data—connections. We can visualize who is a friend of whom using
    the `chord` layout.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了人们有多少 karma 以及他们何时获得它，但数据中还有一个隐藏的宝石——连接。我们可以使用 `chord` 布局来可视化谁是某人的朋友。
- en: We're going to draw a chord diagram—a circular diagram of connections between
    users. Chord diagrams are often used in genetics and have even appeared on covers
    of magazines ([http://circos.ca/intro/published_images/](http://circos.ca/intro/published_images/)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个弦图——用户之间连接的圆形图。弦图常用于遗传学，甚至出现在杂志的封面上([http://circos.ca/intro/published_images/](http://circos.ca/intro/published_images/))。
- en: Ours is going to have an outer ring showing how much karma users give out and
    chords showing where that karma is going.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个外环显示用户释放了多少 karma，以及弦线显示 karma 去向何方。
- en: 'First, we need a matrix of connections for the chord diagram, and then we''ll
    go the familiar route of path generators and adding elements. The matrix code
    will be useful later, so let''s put it in `helpers.js`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个用于弦图的连接矩阵，然后我们将走熟悉的路径，使用路径生成器并添加元素。矩阵代码将以后有用，所以让我们将其放在 `helpers.js`
    中：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We begin with the familiar `uniques` list and the `nick_id` scale, then create
    a zero matrix, and loop through the data to increase connection counts in cells.
    Rows are *from whom*, columns are *to whom*—if the fifth cell in the first row
    holds `10`, the first user has given ten karma to the fifth user. This is called
    an **adjacency matrix**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从熟悉的 `uniques` 列表和 `nick_id` 缩放开始，然后创建一个零矩阵，并通过数据循环增加单元格中的连接计数。行是 *来自谁*，列是
    *给谁*——如果第一行的第五个单元格包含 `10`，则第一个用户向第五个用户提供了十个 karma。这被称为 **邻接矩阵**。
- en: 'Back in the load listener, we can do this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载监听器中，我们可以这样做：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''re going to need `uniques` for labels and it would be nice to have the
    `innerRadius` and `outerRadius` variables handy:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 `uniques` 标签和 `innerRadius`、`outerRadius` 变量：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Time to make the `chord` layout do our bidding:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让 `chord` 布局为我们服务了：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is a little different from others. The `chord` layout takes data via the
    `.matrix()` method and can't be called as a function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它与其他布局略有不同。`chord` 布局通过 `.matrix()` 方法获取数据，不能作为一个函数调用。
- en: We started with `d3.layout.chord()` and put some `.padding()` method between
    groups which improves readability. To improve readability further, everything
    is sorted. `.sortGroups` sorts groups on the edge, `.sortSubgroups` sorts chord
    attachments in groups, and `.sortChords` sorts chord drawing order so that smaller
    chords overlap bigger ones.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `d3.layout.chord()` 开始，并在组之间添加一些 `.padding()` 方法以提高可读性。为了进一步提高可读性，一切都被排序了。`.sortGroups`
    按边缘排序组，`.sortSubgroups` 在组中排序弦附件，`.sortChords` 按弦绘制顺序排序，以便较小的弦重叠在较大的弦上。
- en: 'In the end, we feed data into the layout with `.matrix()`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `.matrix()` 将数据馈入布局：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We add a centered group element so that all our coordinates are relative to
    the center from now on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个居中的分组元素，这样我们的所有坐标都将从现在起相对于中心。
- en: 'Drawing the diagram happens in three steps—arcs, labels, and chords, as shown
    in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制图表分为三个步骤——弧、标签和和弦，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This creates the outer ring. We used `chord.groups` to get group data from
    the layout, created a new grouping element for every chord group, and then added
    an arc. We use `arc_labels` from the pie example to add the labels:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了外环。我们使用 `chord.groups` 从布局中获取分组数据，为每个和弦组创建一个新的分组元素，然后添加一个弧。我们使用饼图示例中的 `arc_labels`
    来添加标签：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Even though the radius is constant, we have to define it as a function using
    the following code because we didn't make `arc_labels` flexible enough for constants.
    Shame on us!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管半径是恒定的，但我们必须使用以下代码将其定义为函数，因为我们没有使 `arc_labels` 足够灵活以适应常数。我们真是自作自受！
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We got chord data from `chord.chords` and used a `chord path` generator to draw
    the chords. We pick colors with `d.target.index` because the graph looks better,
    but chord colors are *not* informative.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `chord.chords` 获取和弦数据，并使用 `chord path` 生成器来绘制和弦。我们使用 `d.target.index` 来选择颜色，因为这样图表看起来更好，但和弦颜色并不具有信息性。
- en: 'We add some CSS to make chords easier to follow:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一些 CSS 来使和弦更容易追踪：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And our diagram looks perfect:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表看起来完美无瑕：
- en: '![Highlighting friends with chord](img/0007_05_05.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用和弦突出显示朋友](img/0007_05_05.jpg)'
- en: It looks pretty but unintuitive. We spent hours bickering on IRC before we figured
    it out.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来很漂亮但不够直观。在我们弄清楚之前，我们在 IRC 上争论了好几个小时。
- en: First of all, chord colors don't mean anything! They just make it easier to
    distinguish chords. Furthermore, this graph shows how much karma everyone is *giving*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，和弦颜色没有任何意义！它们只是让区分和弦变得更简单。此外，这个图表显示了每个人给予的 Karma 量。
- en: From my arc's size you can see I've given about 30 percent of the karma ever
    given on this channel. I might be too generous.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的弧的大小可以看出，我给出了这个频道所有 Karma 的约 30%。我可能太慷慨了。
- en: The width of chords touching my arc tells you how much of that karma is going
    to whom.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接触我的弧和弦的宽度告诉你有多少 Karma 将流向谁。
- en: At the other end of each chord, it's exactly the same. Chord width tells you
    how much karma that user has given me. Chords are bidirectional connections between
    users.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个和弦的另一端，情况完全相同。和弦宽度告诉你该用户给了我多少 Karma。和弦是用户之间的双向连接。
- en: Drawing with force
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用力布局绘制
- en: The `force` layout is the most complicated of the non-hierarchical layouts.
    It lets you draw complex graphs using physical simulations—force-directed graphs
    if you will. Everything you draw will have built-in animation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`force` 布局是非层次布局中最复杂的。它允许你使用物理模拟来绘制复杂的图表——如果你愿意，可以称之为力导向图。你绘制的所有内容都将内置动画。'
- en: We're going to draw a graph of connections between users. Every user will be
    a node, the size of which will correspond to the user's karma. Links between nodes
    will tell us who is giving karma to whom.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制用户之间连接的图表。每个用户将是一个节点，其大小将与用户的 Karma 相对应。节点之间的链接将告诉我们谁给了谁 Karma。
- en: To make things clearer, we're going to add tooltips and make sure mousing over
    a node highlights the connected nodes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更清晰，我们将添加工具提示并确保将鼠标悬停在节点上时突出显示连接的节点。
- en: Let's begin.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 'As in the chord example, we begin with a matrix of connections. We aren''t
    going to feed this directly to the `force` layout, but we will use it to create
    the kind of data it enjoys:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 就像和弦示例一样，我们从一个连接矩阵开始。我们不会直接将其提供给 `force` 布局，但我们将使用它来创建它喜欢的数据类型：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `force` layout expects an array of nodes and links. Let''s make them:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`force` 布局期望一个节点和链接的数组。让我们来创建它们：'
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We're defining the bare minimum of what we need, and the layout will calculate
    all the hard stuff.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们需要的最基本的东西，布局将计算所有困难的部分。
- en: '`nodes` tell us who they represent and `links` connect a `source` object to
    a `target` object with an index into the `nodes` array—the layout will turn them
    into proper references as shown in the following code. Every link also contains
    a `count` object that we''ll use to define its strength.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodes` 告诉我们它们代表谁，`links` 使用 `nodes` 数组中的索引将一个 `source` 对象连接到一个 `target` 对象——布局将把它们转换为正确的引用，如下面的代码所示。每个链接还包含一个
    `count` 对象，我们将用它来定义其强度。'
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We create a new `force` layout with `d3.layout.force()`; just like the `chord`
    layout, it isn't a function either. We feed in the data with `.nodes()` and `.links()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `d3.layout.force()` 创建一个新的 `force` 布局；就像 `chord` 布局一样，它也不是一个函数。我们通过 `.nodes()`
    和 `.links()` 提供数据。
- en: Gravity pulls the graph towards the center of the image; we defined its strength
    with `.gravity()`. We tell the `force` layout the size of our picture with `.size()`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重力将图表拉向图像的中心；我们使用`.gravity()`定义了其强度。我们告诉`force`布局我们图片的大小使用`.size()`。
- en: No calculation happens until `force.start()` is called, but we need the results
    to define a few scales for later.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 直到调用`force.start()`之前，不会发生任何计算，但我们需要结果来定义一些后续的刻度。
- en: 'There are a few more parameters to play with: overall `.friction()` (the smallest
    `.linkDistance()` value the nodes stabilize to), `.linkStrength()` for link stretchiness,
    and `.charge()` for attraction between nodes. Play with them.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个参数可以调整：整体的`.friction()`（节点稳定到的最小的`.linkDistance()`值），`.linkStrength()`用于链接的弹性，以及`.charge()`用于节点之间的吸引力。玩一玩它们。
- en: '`nodes` members look like this now:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodes`成员现在看起来是这样的：'
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`weight` tells us how many links connect with this node, `px` and `py` are
    its previous positions, and `x` and `y` are the current position.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`weight`告诉我们有多少链接与这个节点相连，`px`和`py`是它的前一个位置，而`x`和`y`是当前的位置。'
- en: '`links` members are a lot simpler:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`links`成员要简单得多：'
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Both `source` and `target` objects are a direct reference to the correct node.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`和`target`对象是直接引用到正确节点的。'
- en: Now that the layout made its first calculation step, we have the data to define
    some scales;
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在布局已经完成了第一步计算，我们有数据来定义一些刻度；
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''re going to use the `weight` scale for node sizes, `distance` for link
    lengths, and `given` to scale nodes for the highlighting effect:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`weight`刻度来调整节点大小，`distance`来调整链接长度，以及`given`来调整节点以实现突出显示效果：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We use `.linkDistance()` to dynamically define link lengths according to the
    `.count` property. To put the change in effect, we restart the layout with `force.start()`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.linkDistance()`根据`.count`属性动态定义链接长度。为了使更改生效，我们使用`force.start()`重新启动布局。
- en: 'Finally! Time to put some ink on paper—well, pixels on screen:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后！是时候在纸上（或者说屏幕上的像素）画一些东西了：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Links are simple—go through the list of links and draw a `line`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 链接很简单——遍历链接列表并画一条`line`。
- en: 'Draw a circle for every node and give it the right size and color. The strange
    `nick_` class will help us with the highlighting we''re doing in the two mouse
    event listeners:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个节点画一个圆圈，并给它正确的尺寸和颜色。奇怪的`nick_`类将帮助我们完成在两个鼠标事件监听器中进行的突出显示：
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We add tooltips with the familiar `helpers.tooltip` function and `force.drag`
    will automatically make the nodes draggable:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用熟悉的`helpers.tooltip`函数添加工具提示，而`force.drag`将自动使节点可拖动：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After all that work, we still have to do the updating on every tick of the
    `force` layout animation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些工作后，我们仍然需要在`force`布局动画的每一帧更新：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: On a `tick` event, we move every `link` endpoint and `node` to its new position.
    Simple.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tick`事件上，我们将每个`link`端点和`node`移动到它们的新位置。很简单。
- en: 'Time to define the two highlighting functions we mentioned earlier:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候定义我们之前提到的两个突出显示函数了：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `highlight` function will grow all connected nodes according to how much
    karma they've gotten from the node we're touching with the mouse. It starts by
    setting the `given` object's domain, then goes through the `uniques` list, resizes
    corresponding nodes using the `given` scale for size, and uses `nick_id` to find
    the nodes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`highlight`函数将根据我们从鼠标接触的节点获得的karma增长所有连接的节点。它首先设置`given`对象的域，然后遍历`uniques`列表，使用`given`刻度调整相应节点的大小，并使用`nick_id`找到节点。'
- en: The current node is left alone.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当前节点保持不变。
- en: '`dehighlight` will remove all the shenanigans we caused:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`dehighlight`将移除我们造成的所有麻烦：'
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add some styling to the HTML:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 给HTML添加一些样式：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And voilà! We get a force-directed graph of user connections.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们得到了用户连接的力导向图。
- en: 'Running this example looks silly because it spins around a lot before settling
    down. But once it stabilizes, the graph looks something like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个示例看起来很愚蠢，因为它在稳定下来之前旋转了很多。但一旦稳定，图表看起来就像这样：
- en: '![Drawing with force](img/0007_05_06.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![用力绘图](img/0007_05_06.jpg)'
- en: The graph would be more interesting if all nodes were not connected, but hovering
    one of the smaller nodes will reveal interesting connections.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有节点都不相连，图表会更有趣，但悬停在较小的节点上会揭示有趣的连接。
- en: We should have added some code to print names next to the highlighted nodes,
    but the example was long enough. Let's say that's left as an exercise for the
    reader.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本应该添加一些代码来打印出高亮节点旁边的名称，但示例已经足够长。让我们说这留作读者的练习。
- en: We will now move towards hierarchical layouts!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向层次布局！
- en: Hierarchical layouts
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层次布局
- en: All hierarchical layouts are based on an abstract hierarchy layout designed
    for representing hierarchical data—data within data within data within data within....
    You get the idea.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有分层布局都是基于一个抽象的分层布局，该布局是为了表示分层数据——数据中的数据中的数据中的数据中的数据……你明白这个意思。
- en: All the common code for the `partition`, `tree`, `cluster`, `pack`, and `treemap`
    layouts is defined in `d3.layout.hierarchy()` and they all follow similar design
    patterns. The layouts are so similar that the official documentation very obviously
    copy-pastes most of its explanations. Let's avoid that by looking at the common
    stuff first, and then we will focus on the differences.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition`、`tree`、`cluster`、`pack`和`treemap`布局的所有常见代码都定义在`d3.layout.hierarchy()`中，并且它们都遵循类似的设计模式。布局非常相似，官方文档明显地复制粘贴了大部分的解释。让我们先看看共同的东西，然后我们将专注于差异。'
- en: First of all, we need some hierarchical data. I spent an afternoon trying to
    make our karma dataset hierarchical. The result was a scheme that works well with
    three of the layouts and looks contrived for the other two. Sorry about that.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些分层数据。我花了一个下午的时间尝试将我们的karma数据集分层。结果是，这个方案与三种布局配合得很好，但看起来对另外两种布局有些牵强。对此表示歉意。
- en: It's simple really, we kill the Batman.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上很简单，我们杀死了蝙蝠侠。
- en: We'll have a root node called `karma`, which will contain the 24 users who have
    ever given karma. For the `tree` and `cluster` layouts, each of those will contain
    nodes for everyone they have given karma to. For the `partition`, `pack`, and
    `treemap` layouts, children nodes will tell us who contributed to the parent's
    karma.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个名为`karma`的根节点，它将包含所有曾经给予karma的24个用户。对于`tree`和`cluster`布局，每个都将包含他们给予karma的每个人的节点。对于`partition`、`pack`和`treemap`布局，子节点将告诉我们谁为父节点的karma做出了贡献。
- en: 'The final data structure will look like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的数据结构将看起来像这样：
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: While it could potentially go on forever, that wouldn't make sense in our case.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可能永远继续下去，但在我们的情况下这并不合理。
- en: The default accessor expects a `.children` property, but we could easily have
    done something crazy like dynamically generating a fractal structure in a custom
    accessor.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 默认访问器期望有一个`.children`属性，但我们可以轻松地做一些疯狂的事情，比如在自定义访问器中动态生成一个分形结构。
- en: As usual, there's a `.value()` accessor that helps layouts to find data in a
    node. We'll use it for the `.count` property—to check how much karma a user's
    got.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，有一个`.value()`访问器可以帮助布局在节点中找到数据。我们将使用它来设置`.count`属性——以检查用户有多少karma。
- en: To run a hierarchical layout, we call `.nodes()` with our dataset. This immediately
    returns a list of nodes that you can't get to later. For a list of connections,
    we call `.links()` with a list of our nodes. Nodes in the returned list will have
    some extra properties calculated by the layout. Most layouts tell us where to
    put something with `.x` and `.y`, then use `.dx` and `.dy` to tell us how big
    the layout should be.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行分层布局，我们调用`.nodes()`并传入我们的数据集。这立即返回一个列表，你以后无法获取到这些节点。要获取连接列表，我们调用`.links()`并传入我们的节点列表。返回列表中的节点将具有布局计算的一些额外属性。大多数布局会告诉我们如何使用`.x`和`.y`放置某个东西，然后使用`.dx`和`.dy`来告诉我们布局应该有多大。
- en: All hierarchical layouts also support sorting with `.sort()`, which takes a
    sorting function such as `d3.ascending` or `d3.descending`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 所有分层布局都支持使用`.sort()`进行排序，它接受一个排序函数，如`d3.ascending`或`d3.descending`。
- en: 'Enough theory, let''s add a data munging function to `helpers.js`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够多了，让我们向`helpers.js`添加一个数据处理函数：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Wow, there's a lot going on here. We avoided recursion because we know our data
    will never nest more than two levels deep.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这里发生了很多事情。我们避免了递归，因为我们知道我们的数据永远不会嵌套超过两层。
- en: '`tree` holds an empty root node at first. We use `helpers.uniques` to get a
    list of nicknames, then map through the array and define the children of the root
    node by counting everyone''s karma and using `helpers.bin_per_nick` to get an
    array of children.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree`最初持有一个空的根节点。我们使用`helpers.uniques`来获取昵称列表，然后遍历数组，通过计算每个人的karma值并使用`helpers.bin_per_nick`来获取子节点数组，从而定义根节点的子节点。'
- en: The code is wibbly-wobbly because we use `filter1`, `filter2`, `nick1`, and
    `nick2` for data accessors, but making this function flexible makes it useful
    in all hierarchical examples.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 代码之所以会摇摆不定，是因为我们使用了`filter1`、`filter2`、`nick1`和`nick2`作为数据访问器，但使这个函数变得灵活使其在所有分层示例中都很有用。
- en: Drawing a tree
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制一棵树
- en: The `tree` layout displays data in a tree using the tidy **Reingold-Tilford**
    tidy algorithm. We'll use it to display our dataset in a large circular tree with
    every node connected to its parent by a curvy line.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree` 布局使用整洁的 **Reingold-Tilford** 算法以树的形式显示数据。我们将用它来显示我们的数据集，以一个大圆形树的形式，每个节点通过一条曲线与其父节点相连。'
- en: 'We begin the load listener by fixating colors, turning data into a tree, and
    defining a way to draw curvy lines:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从固定颜色开始，将数据转换为树，并定义绘制曲线的方法：
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You know `fixate_colors` from before, we defined `make_tree` not a page ago,
    and we've talked about the `diagonal` generator in [Chapter 2](ch02.html "Chapter 2. A
    Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经知道 `fixate_colors`，我们定义 `make_tree` 不久前，我们已经在 [第2章](ch02.html "第2章。DOM、SVG和CSS入门")
    中讨论了 `diagonal` 生成器，*DOM、SVG和CSS入门*。
- en: '[PRE67]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We create a new tree layout by calling `d3.layout.tree()`. Defining its size
    with `.size()` and executing it with `.nodes()`. `size()` tells the layout how
    much room it's got—in this case, we're using `x` as an angle (`360` degrees) and
    `y` as a radius. Though the layout itself doesn't really care about that.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `d3.layout.tree()` 创建一个新的树布局。使用 `.size()` 定义其大小，并通过 `.nodes()` 执行它。`size()`
    告诉布局它有多少空间——在这种情况下，我们使用 `x` 作为角度（`360` 度）和 `y` 作为半径。尽管布局本身并不真正关心这一点。
- en: 'To avoid worrying about centering later on, we put a grouping element center
    stage:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免以后担心居中对齐的问题，我们放置了一个分组元素作为中心：
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'First we are going to draw the links, then the nodes and their labels:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将绘制链接，然后是节点及其标签：
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You should be familiar with this by now; go through the data and append new
    paths shaped with the `diagonal` generator:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉这个了；通过数据并使用 `diagonal` 生成器添加新的路径：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For every node in the data, we create a new grouping element and move it into
    place using `rotate` for angles and `translate` for radius positions.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据中的每个节点，我们创建一个新的分组元素，并使用 `rotate` 对角度和 `translate` 对半径位置进行移动。
- en: 'Now it''s just a matter of adding a circle and a label:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需要添加一个圆圈和一个标签：
- en: '[PRE71]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Every node is colored with the user's native color and the text is transformed
    similarly to the earlier pie and chord examples. Finally, we made leaf nodes'
    text smaller to avoid overlap.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都使用用户的原生颜色着色，文本的转换方式与早期的饼图和弦图示例类似。最后，我们将叶节点的文本缩小以避免重叠。
- en: 'After this, we will add some styling:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一些样式：
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Our tree looks like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的树看起来像这样：
- en: '![Drawing a tree](img/0007_05_08.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![绘制树](img/0007_05_08.jpg)'
- en: It's rather big, so you should try it out in the browser. Just remember, the
    inner ring is users giving karma to the outer ring.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它相当大，所以你应该在浏览器中尝试一下。只需记住，内环是用户对外环给予的karma。
- en: Showing clusters
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示集群
- en: The `cluster` layout is the same as the `tree` layout, except that leaf nodes
    line up.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster` 布局与 `tree` 布局相同，只是叶节点排列整齐。'
- en: Do you see that the **hoi** user is hanging out in the inner ring of the tree
    example? With the cluster layout they end up on the outside with the other leaf
    nodes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到那个 **hoi** 用户在树示例的内环中闲逛吗？在集群布局中，他们最终出现在外部，与其他叶节点一起。
- en: Codewise this example is the same as the last, so we won't go through it again.
    Really, the only difference is that we don't have to flip labels at certain angles.
    You can look at the code on the GitHub examples repository [https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/cluster.js](https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/cluster.js).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 代码上，这个例子与上一个相同，所以我们不会再次讲解。实际上，唯一的区别是我们不需要在特定角度翻转标签。你可以在GitHub示例存储库中查看代码 [https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/cluster.js](https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/cluster.js)。
- en: 'We end up with a very tall graph that looks something like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到一个非常高的图表，看起来像这样：
- en: '![Showing clusters](img/0007_05_09.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![显示集群](img/0007_05_09.jpg)'
- en: Partitioning a pie
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割饼图
- en: Now we're getting somewhere! The next three layouts fit our data perfectly—we're
    taking three looks at how our core users' karma is structured.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在取得进展！接下来的三个布局完美地适合我们的数据——我们正在从三个角度来看我们的核心用户的karma结构。
- en: The `partition` layout creates adjacency diagrams, where you don't draw nodes
    with links between them, but next to each other so that it looks like the children
    partition the parent.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition` 布局创建邻接图，其中你不需要在节点之间画线，而是将它们并排放置，使其看起来像子节点分割父节点。'
- en: We are going to draw a two-layer donut chart. Users will go on the first layer
    and the layer on top will show us where the karma is coming from.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一个双层甜甜圈图。用户将在第一层，顶层将显示karma的来源。
- en: 'We begin by munging the dataset and fixating colors:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对数据集进行整理并固定颜色：
- en: '[PRE73]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then use the `partition` layout:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`partition`布局：
- en: '[PRE74]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We used `.value()` to tell the layout we care about the `.count` values, and
    we'll get a better picture if we `.sort()` the output. Similarly, to the `tree`
    layout, `x` will represent angles—this time in radians—and `y` will be radii.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.value()`告诉布局我们关心`.count`值，如果我们`.sort()`输出，我们会得到更好的图像。同样，对于`tree`布局，`x`将代表角度——这次是弧度，而`y`将是半径。
- en: 'We need an `arc` generator as well, as shown in the following code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个`arc`生成器，如下面的代码所示：
- en: '[PRE75]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The generator will use each node's `.y` property for the inner radius and add
    `.dy` for the outer radius. Fiddling shows the outer layer should be thinner,
    hence we are dividing it by the tree depth.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器将使用每个节点的`.y`属性作为内半径，并添加`.dy`作为外半径。调整后显示外层应该更薄，因此我们将其除以树深度。
- en: 'Notice that there''s no accessor for `.startAngle` and `.endAngle`, which are
    stored as `.x` and `.dx`. It''s easier to just fix the data:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有`.startAngle`和`.endAngle`的访问器，它们存储为`.x`和`.dx`。直接固定数据会更简单：
- en: '[PRE76]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It is as simple as mapping the data and defining angle properties, then filtering
    the data to make sure the root isn't drawn.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像映射数据并定义角度属性，然后过滤数据以确保根节点不被绘制。
- en: We use the familiar grouping trick to center our diagram.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用熟悉的分组技巧来居中我们的图表。
- en: '[PRE77]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Preparation work is done. It''s drawing time:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作已完成。现在是绘图时间：
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'An arc is drawn for every node, color is chosen as usual:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个节点绘制一个弧，颜色选择如常：
- en: '[PRE79]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We add labels and tooltips with the functions prepared in earlier examples.
    We avoid adding labels for very thin slices so that they don''t overlap and make
    a mess. Sprinkle some CSS:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用之前准备的函数添加标签和工具提示。我们避免为非常薄的切片添加标签，以免它们重叠并造成混乱。添加一些CSS：
- en: '[PRE80]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The adjacency diagram looks like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接图看起来是这样的：
- en: '![Partitioning a pie](img/0007_05_10.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![分割饼图](img/0007_05_10.jpg)'
- en: Packing circles into circles
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将圆圈打包成圆圈
- en: The `pack` layout uses packing to visually represent hierarchies. It stuffs
    children nodes into their parents, trying to conserve space and sizing each node
    so that it's the cumulative size of its children.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack`布局使用打包来直观地表示层次结构。它将子节点塞入父节点中，试图节省空间并为每个节点指定大小，使其成为其子节点的累积大小。'
- en: Conceptually it's very similar to the `treemap` layout, so I'm going to skip
    all the code and just show you the picture. You can still see the code over at
    GitHub [https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/pack.js](https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/pack.js).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，它与`treemap`布局非常相似，所以我将跳过所有代码，只展示图片。你仍然可以在GitHub上看到代码[https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/pack.js](https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/pack.js)。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The code is rather familiar—generate a tree, fixate colors, create layout, tweak
    a few parameters, get computed nodes, draw nodes, and add tooltips. Simple.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当熟悉——生成树，固定颜色，创建布局，调整一些参数，获取计算后的节点，绘制节点，并添加工具提示。很简单。
- en: '![Packing circles into circles](img/0007_05_11.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![将圆圈打包成圆圈](img/0007_05_11.jpg)'
- en: It looks very pretty, but not too informative. Adding labels wouldn't help much
    because most nodes are too small.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来非常漂亮，但不太具有信息量。添加标签帮助不大，因为大多数节点太小。
- en: Subdividing with treemap
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用treemap细分
- en: The `treemap` layout subdivides nodes with horizontal and vertical slices, essentially
    packing children into their parents just like the `pack` layout, but using rectangles.
    As a result, node sizes on every level can be compared directly, making this one
    of the best layouts for analyzing cumulative effects of subdivisions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`treemap`布局通过水平和垂直切片来细分节点，本质上就像`pack`布局一样将子节点打包到父节点中，但使用矩形。因此，每一层的节点大小可以直接比较，这使得它成为分析细分累积效应的最佳布局之一。'
- en: We are going to have some fun with this example. Tooltips will name the parent—parents
    are almost completely obscured by the children—and mousing over a node will make
    unrelated nodes become lighter, making the graph less confusing (at least in theory).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个例子中玩得开心。工具提示将命名父节点——父节点几乎完全被子节点遮挡——将鼠标悬停在节点上会使无关的节点变亮，使图表更不容易混淆（至少在理论上）。
- en: It's also a cool effect and a great way to end this chapter on layouts.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很酷的效果，也是结束这一章布局的绝佳方式。
- en: 'We begin with the boring stuff; prepare data and fixate colors:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从无聊的事情开始；准备数据和固定颜色：
- en: '[PRE81]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Creating the `treemap` layout follows familiar patterns:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`treemap`布局遵循熟悉的模式：
- en: '[PRE82]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We added some padding with `.padding()` to give nodes room to breathe.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `.padding()` 添加了一些填充，给节点留出呼吸的空间。
- en: 'Every node will become a group element holding a rectangle. The leaves will
    also hold a label:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都将成为一个包含矩形的组元素。叶子节点也将包含标签：
- en: '[PRE83]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now for the first fun bit. Let''s fit labels into as many nodes as they can
    possibly go:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是第一个有趣的部分。让我们将标签尽可能放入尽可能多的节点中：
- en: '[PRE84]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Finally! That was some interesting code!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后！这是一些有趣的代码！
- en: We found all the leaves and started adding text. To fit labels into nodes, we
    get their size with `this.getBBox()`, then move them to the middle of the node,
    and check for fit.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了所有叶子节点，并开始添加文本。为了将标签放入节点，我们使用 `this.getBBox()` 获取它们的尺寸，然后将它们移动到节点的中间，并检查是否适合。
- en: If the label is too wide but fits vertically, we rotate it; otherwise, we remove
    the label after checking again that it doesn't fit. Making sure of the height
    is important because some nodes are very thin.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签太宽但垂直方向可以容纳，我们会将其旋转；否则，在再次确认它无法容纳后，我们会移除标签。确保高度是很重要的，因为一些节点非常细小。
- en: 'We add tooltips with `helpers.tooltip`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `helpers.tooltip` 添加工具提示：
- en: '[PRE85]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Another fun bit—partially hiding nodes from different parents:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的部分——部分隐藏来自不同父节点的节点：
- en: '[PRE86]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We used two mouse event listeners: one creates the effect, another removes
    it. The `mouseover` listener goes through all the nodes and lightens those with
    a different parent or that aren''t the parent (`d.parent.nick` and `d.nick` are
    different). The `mouseout` listener removes all changes.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个鼠标事件监听器：一个创建效果，另一个移除效果。`mouseover` 监听器遍历所有节点，使具有不同父节点或不是父节点的节点变亮（`d.parent.nick`
    和 `d.nick` 不同）。`mouseout` 监听器移除所有更改。
- en: 'After this, add some CSS:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加一些CSS：
- en: '[PRE87]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The end result looks like an abstract painting:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果看起来像一幅抽象画：
- en: '![Subdividing with treemap](img/0007_05_12.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![使用树状图细分](img/0007_05_12.jpg)'
- en: 'Touching an area with your mouse restores some sanity as shown in the following
    screenshot:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标点击区域可以恢复一些理智，如下面的截图所示：
- en: '![Subdividing with treemap](img/0007_05_13.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![使用树状图细分](img/0007_05_13.jpg)'
- en: Although, not as much sanity as we hoped.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，并没有我们期望的那么理智。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Despite the near mythical power of d3 layouts, they turn out to be nothing more
    than helpers that turn your data into a collection of coordinates.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管d3布局具有近乎神话般的力量，但它们实际上只是将你的数据转换成坐标集合的辅助工具。
- en: After going full out with these examples, we used almost every trick we've learned
    so far. We even wrote so much code that we had to make a separate library! With
    a bit of generalization, some of those functions could be layouts of their own.
    There's a whole world of community-developed layouts for various types of charts.
    The d3-plugins repository on GitHub ([https://github.com/d3/d3-plugins](https://github.com/d3/d3-plugins))
    is a good way to start exploring.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中全力以赴之后，我们几乎用到了迄今为止学到的所有技巧。我们甚至写了这么多代码，以至于不得不创建一个单独的库！通过一些泛化，其中一些函数可以成为自己的布局。对于各种类型的图表，有一个完整的社区开发的布局世界。GitHub上的d3-plugins仓库（[https://github.com/d3/d3-plugins](https://github.com/d3/d3-plugins)）是一个开始探索的好方法。
- en: You now understand what all the default layouts are up to, and I hope you're
    already thinking about using them for purposes beyond the original developers'
    wildest dreams.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了所有默认布局的目的，我希望你已经开始考虑将它们用于原始开发者最疯狂的梦想之外的目的。
