- en: Chapter 5. Layouts – d3's Black Magic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of us look at the Internet for inspiration and code samples. You find something
    that looks great, look at the code, and your eyes glaze over. It doesn't make
    any sense.
  prefs: []
  type: TYPE_NORMAL
- en: The usual culprit is d3's reliance on layouts for anything remotely complicated.
    The black magic of taking some data, calling a function, and voilà—visualization!
    This elegance makes layouts look deceptively difficult, but they make things a
    lot easier when you get a hang of them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll go in, guns blazing, with everything we've learned so
    far to create 11 visualizations of the same dataset.
  prefs: []
  type: TYPE_NORMAL
- en: What are layouts and why should you care
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d3 layouts are modules that transform data into drawing rules. The simplest
    layout might only transform an array of objects into coordinates, like a scale.
  prefs: []
  type: TYPE_NORMAL
- en: But we usually use layouts for more complex visualizations—drawing a force-directed
    graph or a tree, for instance. In these cases, layouts help us to separate calculating
    coordinates from putting pixels on a page. This not only makes our code cleaner,
    but it also lets us reuse the same layouts for vastly different visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Theory is boring, let's dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, d3 comes with 12 built-in layouts that cover most common visualizations.
    They can be split roughly into normal and hierarchical layouts. The normal layouts
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pie`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chord`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`force`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The hierarchical layouts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`partition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tree`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cluster`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`treemap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see how they behave, we're going to make an example for each type. We'll
    start with the humble pie chart and histogram, then progress to force-directed
    graphs and fancy trees. We're using the same dataset for all examples, so that
    we can get a feel of how different presentations affect the perception of data.
  prefs: []
  type: TYPE_NORMAL
- en: These are the last examples in this book, so we're going to make them particularly
    magnificent. That's going to create a lot of code, so every time we come up with
    something reusable, we'll put it in a `helpers.js` file as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an empty `helper.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We're going to add functions as members of this global object. Add the following
    line to the HTML right before including the normal code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's also agree that all examples start with a drawing area and fetching the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example code will go in the `d3.json` load listener.
  prefs: []
  type: TYPE_NORMAL
- en: The dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dataset we'll be playing with has been scraped from my favorite IRC channel's
    log going back to late 2011\. The channel's special feature is the karma bot.
  prefs: []
  type: TYPE_NORMAL
- en: When someone does something we like, we give them karma with `nick++` and the
    bot counts it as a vote for that person. Just like on Reddit, karma is supposed
    to measure how much the community likes someone, but it's really just about who
    is most active.
  prefs: []
  type: TYPE_NORMAL
- en: The karma is what we're interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the dataset at [https://raw.github.com/Swizec/d3.js-book-examples/master/ch5/data/karma_matrix.json](https://raw.github.com/Swizec/d3.js-book-examples/master/ch5/data/karma_matrix.json).
    The dataset consists of objects representing instances of giving karma. Each looks
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every object tells us at what time (`time`) somebody (`from`) gave karma to
    (`to`) somebody else. To deal with the cruft often tacked onto nicknames—for instance,
    `smotko` is `smotko-nexus` from his phone—only the first four letters of the nickname
    were considered when scraping the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: This creates a clean dataset for us to work with. You can think of it as a list
    of edges in a graph, where users are nodes and `to` and `from` create a directed
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: Time to draw!
  prefs: []
  type: TYPE_NORMAL
- en: Using the histogram layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to use the `histogram` layout to create a bar chart of the karma
    people have received. The layout itself will handle everything from collecting
    values into bins, to calculating heights, widths, and the positions of the bars.
  prefs: []
  type: TYPE_NORMAL
- en: Histograms usually represent a probability distribution over a continuous numerical
    domain, but nicknames are ordinal. To bend the `histogram` layout to our will,
    we have to turn nicknames into numbers—we'll use a scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it feels like this could be useful in other examples, we''ll put the
    code in `helpers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These are two simple functions. `uniques` goes through the data and returns
    a list of unique nicknames. We help it with the `nick` accessor. `nick_id` creates
    an ordinal scale we'll be using to convert nicknames into numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can tell the histogram how to handle our data with `nick_id`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using `d3.layout.histogram()` we create a new histogram and use `.bins()` to
    define the upper threshold for each bin. Given `[1,2,3]`, values under `1` go
    in the first bin, values between `1` and `2` in the second, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `.value()` accessor tells the histogram how to find values in our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to specify bins is by specifying the number of bins you want and
    letting the histogram uniformly divide a continuous numerical input domain into
    bins. For such domains, you can even make probability histograms by setting `.frequency()`
    to `false`. You can limit the range of considered bins with `.range()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we used the layout as a function on our data to get an array of objects
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Bin width is in the `dx` property, `x` is the horizontal position and `y` is
    the height. We access elements in bins with normal array functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using this data to draw a bar chart should be easy by now. We'll define a scale
    for each dimension, label both axes, and place some rectangles for bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things easier, we begin with some margins. Remember, all this code
    goes in the data load listener we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And two scales.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using a log scale for the vertical axis will make the graph easier to read despite
    the huge karma variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, put a vertical axis on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a grouping element for every bar and its label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving the group into position, as shown in the following code, means less
    work when positioning the bar and its label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the group is in place, we can put the bar a pixel from the group''s
    edge. All bars will be `histogram[0].dx` wide and we''ll calculate heights using
    the `y` position of each datum and the total graph height. Lastly, we create the
    labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We move labels to the bottom of the graph, rotate them by 60 degrees to avoid
    overlap, and set their text to the `.to` property of the datum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some CSS styling to the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our bar chart looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the histogram layout](img/0007_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, the whole graph wouldn't fit in the book. Run the example.
  prefs: []
  type: TYPE_NORMAL
- en: Delicious pie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous bar chart reveals that **HairyFotr** has the most karma by far.
    Let's find out who's making him so popular.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the pie chart layout to cut the karma of **HairyFotr** into
    slices, showing how much karma he gets from the others. After filtering the dataset
    for karma going to **HairyFotr**, we have to categorize entries by givers, and
    finally feed them into the pie chart layout to generate a pie chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `histogram` layout to put data into bins depending on the `.from`
    property. Let''s add a function to `helpers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `uniques` and `nick_id` functions, `bin_per_nick` takes the data
    and a `nick` accessor, and returns histogram data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now do this in pie chart''s data listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Entries in the `per_nick` variable will tell us exactly how much karma **HairyFotr**
    got from someone.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bake a pie, we call the `pie` layout and give it a value accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `pie` layout is now full of slice objects, each holding the `startAngle`
    and `endAngle` values and the original value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entries look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We could have specified a `.sort()` function to change how slices are organized
    and a `.startAngle()` or `.endAngle()` function to limit the pie's size.
  prefs: []
  type: TYPE_NORMAL
- en: All that's left to do now is drawing a pie chart. We'll need an `arc` generator,
    just as the ones in [Chapter 2](ch02.html "Chapter 2. A Primer on DOM, SVG, and
    CSS"), *A Primer on DOM, SVG*, and CSS and some color to tell slices apart.
  prefs: []
  type: TYPE_NORMAL
- en: Finding 24 distinct colors that look great together is hard; lucky for us, `@ponywithhiccups`
    jumped to the challenge and made the pick. Thank you!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add these colors to `helpers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `color` scale is an ordinal scale without a domain. To make sure nicknames
    always get the same color, a function in `helpers.js` will help us fixate the
    domain, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the `arc` generator and fixate the colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A group element will hold each arc and its label as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To make positioning simpler, we move every group to the center of the pie chart.
    Creating slices works the same as in [Chapter 2](ch02.html "Chapter 2. A Primer
    on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We get the color for a slice with `d.data[0].from`—the original dataset is in
    `.data` and all the `.from` properties in it are the same. That's what we grouped
    by.
  prefs: []
  type: TYPE_NORMAL
- en: Labels take a bit more work. They need to be rotated into place and sometimes
    flipped so that they don't appear upside-down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Labeling an arc will be handy later as well, so let''s make a general function
    in `helpers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We're using partial application to generate a function operating on a d3 selection.
    This means we can use it with `.call()`, while still defining our own parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We'll give `arc_labels` a `text` accessor and a `radius` accessor, and it will
    return a function we can use with `.call()` on a selection to make labels appear
    in just the right places. The meaty part appends a text element, tweaks its `text-anchor`
    element, depending on whether we're going to flip it, and rotates the element
    into a particular position with the help of a `tickAngle` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the contents of the `tickAngle` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`helpers.tickAngle` calculates the middle angle between `d.startAngle` and
    `d.endAngle` and transforms the result from radians to degrees so that SVG can
    understand it.'
  prefs: []
  type: TYPE_NORMAL
- en: This is basic trigonometry, so I won't go into details, but your favorite high
    schooler should be able to explain the math.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `arc_labels` back in the load listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And our delicious pie is done as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Delicious pie](img/0007_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, the smallest values could do with some grouping under other, but you
    can play around with that on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Showing popularity through time with stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'D3''s official docs say:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The stack layout takes a two-dimensional array of data and computes a baseline;
    the baseline is then propagated to the above layers, so as to produce a stacked
    graph."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not clear at all, but I am hard pressed to come up with better. The `stack`
    layout calculates where one layer ends and another begins. An example should help.
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing popularity through time with stack](img/0007_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We're going to make a layered timeline of karma, stretching as far back as 2011,
    with the width of each layer telling us how much karma went to a user at a certain
    time. This timeline is called a **streamgraph**.
  prefs: []
  type: TYPE_NORMAL
- en: To label layers, we're going to create a `mouseover` behavior that highlights
    a layer and shows a tooltip with the user's nickname. By fiddling until the graph
    looked pretty, I discovered that we should bin data into 12-day slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin the binning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To parse timestamps into date objects, we specified a format for strings like
    `2012-01-25 15:32:15`. Then, we used this format to find the earliest and latest
    time with `d3.extent`. Telling `d3.time.days()` to go from start to finish with
    a step of 12 days creates a list of bins.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `histogram` layout to munge our dataset into a more useful form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You already know what `helpers.bin_per_nick` does.
  prefs: []
  type: TYPE_NORMAL
- en: To bin data into time slots, we mapped through each layer of the `nick` accessors
    and turned it into a two-property object. The `.to` property tells us whom the
    layer represents, and `.values` is a histogram of time slots where entries tell
    us how much karma the user got in a certain 12-day period.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for a `stack` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`d3.layout.stack()` creates a new `stack` layout. We told it how to order layers
    with `.order(''inside-out'')` (you should also try `default` and `reverse`) and
    decided how the final graph looks with `.offset(''wiggle'')`. `wiggle` minimizes
    change in slope. Other options include `silhouette`, `zero`, and `expand`. Try
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we told the layout how to find values with the `.values()` accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `layers` array is now filled with objects like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`values` is an array of arrays. Entries in the outer array are time bins that
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The important parts of this array are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x` is the horizontal position, `y` is the thickness, and `y0` is the baseline.
    `d3.layout.stack` will always return these.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start drawing, we need some margins and two scales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The tricky thing was finding the vertical scale's domain. We found it by going
    through each value of every layer, looking for the maximum `d.y0+d.y` value—baseline
    plus thickness.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use an `area` path generator for the layers;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Nothing too fancy, the baselines define bottom edges and adding the thickness
    gives the top edge. Fiddling determined that both should be pushed down by 100
    pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s draw an axis first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Same as usual—we defined an axis, called it on a selection, and let d3 do its
    thing. We only made it prettier with a custom `.tickFormat()` function and used
    `.ticks()` to say we want a new tick every two months.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, now for the streamgraph, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Not much is going on. We used the `area` generator to draw each layer, defined
    colors with `helpers.color`, and called a `tooltip` function, which we'll define
    in `helpers.js` later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing popularity through time with stack](img/0007_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks pretty, but it is useless. Let''s add that `tooltip` function to `helpers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We defined event listeners with a `.tooltip` namespace so that we can define
    multiple listeners on the same events.
  prefs: []
  type: TYPE_NORMAL
- en: The `mouseover` function will highlight streams and create tooltips, `mousemove`
    will move tooltips, and `mouseout` will put everything back to normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the three listeners inside the inner function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That's the simple part of `mouseover`. It selects the current area and changes
    its class to `highlighted`. That will make it lighter and add a red outline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same function, add the meaty part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It is longer and with a dash of magic, but not scary at all!
  prefs: []
  type: TYPE_NORMAL
- en: First we find the mouse's position, then create a group element, and position
    it down and to the right of the mouse. We add a text element to the group and
    call SVG's `getBBox()` function on its node. This gives us the text element's
    bounding box and helps us size the background rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we remove the text because it''s covered by the background and add
    it again. We might be able to avoid all this trouble by using divs, but I wanted
    to show you pure SVG tooltips. Hence, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `mousemove` listener in the following code is much simpler. It just finds
    the `#nicktool` element and moves it to follow the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `mouseout` function selects the current path, removes its `highlighted`
    styling, and removes the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: Voila! Tooltips
  prefs: []
  type: TYPE_NORMAL
- en: 'Very rudimentary—they don''t understand edges and they won''t break any hearts
    with their looks, but they get the job done. Let''s add some CSS to the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And now we have a potentially useful streamgraph on our hands.
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing popularity through time with stack](img/0007_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Highlighting friends with chord
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've seen how much karma people have and when they got it, but there's another
    gem hiding in the data—connections. We can visualize who is a friend of whom using
    the `chord` layout.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to draw a chord diagram—a circular diagram of connections between
    users. Chord diagrams are often used in genetics and have even appeared on covers
    of magazines ([http://circos.ca/intro/published_images/](http://circos.ca/intro/published_images/)).
  prefs: []
  type: TYPE_NORMAL
- en: Ours is going to have an outer ring showing how much karma users give out and
    chords showing where that karma is going.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a matrix of connections for the chord diagram, and then we''ll
    go the familiar route of path generators and adding elements. The matrix code
    will be useful later, so let''s put it in `helpers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We begin with the familiar `uniques` list and the `nick_id` scale, then create
    a zero matrix, and loop through the data to increase connection counts in cells.
    Rows are *from whom*, columns are *to whom*—if the fifth cell in the first row
    holds `10`, the first user has given ten karma to the fifth user. This is called
    an **adjacency matrix**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the load listener, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to need `uniques` for labels and it would be nice to have the
    `innerRadius` and `outerRadius` variables handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to make the `chord` layout do our bidding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It is a little different from others. The `chord` layout takes data via the
    `.matrix()` method and can't be called as a function.
  prefs: []
  type: TYPE_NORMAL
- en: We started with `d3.layout.chord()` and put some `.padding()` method between
    groups which improves readability. To improve readability further, everything
    is sorted. `.sortGroups` sorts groups on the edge, `.sortSubgroups` sorts chord
    attachments in groups, and `.sortChords` sorts chord drawing order so that smaller
    chords overlap bigger ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we feed data into the layout with `.matrix()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We add a centered group element so that all our coordinates are relative to
    the center from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing the diagram happens in three steps—arcs, labels, and chords, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the outer ring. We used `chord.groups` to get group data from
    the layout, created a new grouping element for every chord group, and then added
    an arc. We use `arc_labels` from the pie example to add the labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Even though the radius is constant, we have to define it as a function using
    the following code because we didn't make `arc_labels` flexible enough for constants.
    Shame on us!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We got chord data from `chord.chords` and used a `chord path` generator to draw
    the chords. We pick colors with `d.target.index` because the graph looks better,
    but chord colors are *not* informative.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add some CSS to make chords easier to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And our diagram looks perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Highlighting friends with chord](img/0007_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It looks pretty but unintuitive. We spent hours bickering on IRC before we figured
    it out.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, chord colors don't mean anything! They just make it easier to
    distinguish chords. Furthermore, this graph shows how much karma everyone is *giving*.
  prefs: []
  type: TYPE_NORMAL
- en: From my arc's size you can see I've given about 30 percent of the karma ever
    given on this channel. I might be too generous.
  prefs: []
  type: TYPE_NORMAL
- en: The width of chords touching my arc tells you how much of that karma is going
    to whom.
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of each chord, it's exactly the same. Chord width tells you
    how much karma that user has given me. Chords are bidirectional connections between
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with force
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `force` layout is the most complicated of the non-hierarchical layouts.
    It lets you draw complex graphs using physical simulations—force-directed graphs
    if you will. Everything you draw will have built-in animation.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to draw a graph of connections between users. Every user will be
    a node, the size of which will correspond to the user's karma. Links between nodes
    will tell us who is giving karma to whom.
  prefs: []
  type: TYPE_NORMAL
- en: To make things clearer, we're going to add tooltips and make sure mousing over
    a node highlights the connected nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the chord example, we begin with a matrix of connections. We aren''t
    going to feed this directly to the `force` layout, but we will use it to create
    the kind of data it enjoys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `force` layout expects an array of nodes and links. Let''s make them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We're defining the bare minimum of what we need, and the layout will calculate
    all the hard stuff.
  prefs: []
  type: TYPE_NORMAL
- en: '`nodes` tell us who they represent and `links` connect a `source` object to
    a `target` object with an index into the `nodes` array—the layout will turn them
    into proper references as shown in the following code. Every link also contains
    a `count` object that we''ll use to define its strength.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We create a new `force` layout with `d3.layout.force()`; just like the `chord`
    layout, it isn't a function either. We feed in the data with `.nodes()` and `.links()`.
  prefs: []
  type: TYPE_NORMAL
- en: Gravity pulls the graph towards the center of the image; we defined its strength
    with `.gravity()`. We tell the `force` layout the size of our picture with `.size()`.
  prefs: []
  type: TYPE_NORMAL
- en: No calculation happens until `force.start()` is called, but we need the results
    to define a few scales for later.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more parameters to play with: overall `.friction()` (the smallest
    `.linkDistance()` value the nodes stabilize to), `.linkStrength()` for link stretchiness,
    and `.charge()` for attraction between nodes. Play with them.'
  prefs: []
  type: TYPE_NORMAL
- en: '`nodes` members look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`weight` tells us how many links connect with this node, `px` and `py` are
    its previous positions, and `x` and `y` are the current position.'
  prefs: []
  type: TYPE_NORMAL
- en: '`links` members are a lot simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Both `source` and `target` objects are a direct reference to the correct node.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the layout made its first calculation step, we have the data to define
    some scales;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use the `weight` scale for node sizes, `distance` for link
    lengths, and `given` to scale nodes for the highlighting effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We use `.linkDistance()` to dynamically define link lengths according to the
    `.count` property. To put the change in effect, we restart the layout with `force.start()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally! Time to put some ink on paper—well, pixels on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Links are simple—go through the list of links and draw a `line`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Draw a circle for every node and give it the right size and color. The strange
    `nick_` class will help us with the highlighting we''re doing in the two mouse
    event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We add tooltips with the familiar `helpers.tooltip` function and `force.drag`
    will automatically make the nodes draggable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After all that work, we still have to do the updating on every tick of the
    `force` layout animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: On a `tick` event, we move every `link` endpoint and `node` to its new position.
    Simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to define the two highlighting functions we mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `highlight` function will grow all connected nodes according to how much
    karma they've gotten from the node we're touching with the mouse. It starts by
    setting the `given` object's domain, then goes through the `uniques` list, resizes
    corresponding nodes using the `given` scale for size, and uses `nick_id` to find
    the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The current node is left alone.
  prefs: []
  type: TYPE_NORMAL
- en: '`dehighlight` will remove all the shenanigans we caused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some styling to the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And voilà! We get a force-directed graph of user connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this example looks silly because it spins around a lot before settling
    down. But once it stabilizes, the graph looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing with force](img/0007_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The graph would be more interesting if all nodes were not connected, but hovering
    one of the smaller nodes will reveal interesting connections.
  prefs: []
  type: TYPE_NORMAL
- en: We should have added some code to print names next to the highlighted nodes,
    but the example was long enough. Let's say that's left as an exercise for the
    reader.
  prefs: []
  type: TYPE_NORMAL
- en: We will now move towards hierarchical layouts!
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical layouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All hierarchical layouts are based on an abstract hierarchy layout designed
    for representing hierarchical data—data within data within data within data within....
    You get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: All the common code for the `partition`, `tree`, `cluster`, `pack`, and `treemap`
    layouts is defined in `d3.layout.hierarchy()` and they all follow similar design
    patterns. The layouts are so similar that the official documentation very obviously
    copy-pastes most of its explanations. Let's avoid that by looking at the common
    stuff first, and then we will focus on the differences.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need some hierarchical data. I spent an afternoon trying to
    make our karma dataset hierarchical. The result was a scheme that works well with
    three of the layouts and looks contrived for the other two. Sorry about that.
  prefs: []
  type: TYPE_NORMAL
- en: It's simple really, we kill the Batman.
  prefs: []
  type: TYPE_NORMAL
- en: We'll have a root node called `karma`, which will contain the 24 users who have
    ever given karma. For the `tree` and `cluster` layouts, each of those will contain
    nodes for everyone they have given karma to. For the `partition`, `pack`, and
    `treemap` layouts, children nodes will tell us who contributed to the parent's
    karma.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final data structure will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: While it could potentially go on forever, that wouldn't make sense in our case.
  prefs: []
  type: TYPE_NORMAL
- en: The default accessor expects a `.children` property, but we could easily have
    done something crazy like dynamically generating a fractal structure in a custom
    accessor.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, there's a `.value()` accessor that helps layouts to find data in a
    node. We'll use it for the `.count` property—to check how much karma a user's
    got.
  prefs: []
  type: TYPE_NORMAL
- en: To run a hierarchical layout, we call `.nodes()` with our dataset. This immediately
    returns a list of nodes that you can't get to later. For a list of connections,
    we call `.links()` with a list of our nodes. Nodes in the returned list will have
    some extra properties calculated by the layout. Most layouts tell us where to
    put something with `.x` and `.y`, then use `.dx` and `.dy` to tell us how big
    the layout should be.
  prefs: []
  type: TYPE_NORMAL
- en: All hierarchical layouts also support sorting with `.sort()`, which takes a
    sorting function such as `d3.ascending` or `d3.descending`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough theory, let''s add a data munging function to `helpers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Wow, there's a lot going on here. We avoided recursion because we know our data
    will never nest more than two levels deep.
  prefs: []
  type: TYPE_NORMAL
- en: '`tree` holds an empty root node at first. We use `helpers.uniques` to get a
    list of nicknames, then map through the array and define the children of the root
    node by counting everyone''s karma and using `helpers.bin_per_nick` to get an
    array of children.'
  prefs: []
  type: TYPE_NORMAL
- en: The code is wibbly-wobbly because we use `filter1`, `filter2`, `nick1`, and
    `nick2` for data accessors, but making this function flexible makes it useful
    in all hierarchical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tree` layout displays data in a tree using the tidy **Reingold-Tilford**
    tidy algorithm. We'll use it to display our dataset in a large circular tree with
    every node connected to its parent by a curvy line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin the load listener by fixating colors, turning data into a tree, and
    defining a way to draw curvy lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You know `fixate_colors` from before, we defined `make_tree` not a page ago,
    and we've talked about the `diagonal` generator in [Chapter 2](ch02.html "Chapter 2. A
    Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We create a new tree layout by calling `d3.layout.tree()`. Defining its size
    with `.size()` and executing it with `.nodes()`. `size()` tells the layout how
    much room it's got—in this case, we're using `x` as an angle (`360` degrees) and
    `y` as a radius. Though the layout itself doesn't really care about that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid worrying about centering later on, we put a grouping element center
    stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'First we are going to draw the links, then the nodes and their labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be familiar with this by now; go through the data and append new
    paths shaped with the `diagonal` generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: For every node in the data, we create a new grouping element and move it into
    place using `rotate` for angles and `translate` for radius positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s just a matter of adding a circle and a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Every node is colored with the user's native color and the text is transformed
    similarly to the earlier pie and chord examples. Finally, we made leaf nodes'
    text smaller to avoid overlap.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we will add some styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tree looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing a tree](img/0007_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's rather big, so you should try it out in the browser. Just remember, the
    inner ring is users giving karma to the outer ring.
  prefs: []
  type: TYPE_NORMAL
- en: Showing clusters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cluster` layout is the same as the `tree` layout, except that leaf nodes
    line up.
  prefs: []
  type: TYPE_NORMAL
- en: Do you see that the **hoi** user is hanging out in the inner ring of the tree
    example? With the cluster layout they end up on the outside with the other leaf
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Codewise this example is the same as the last, so we won't go through it again.
    Really, the only difference is that we don't have to flip labels at certain angles.
    You can look at the code on the GitHub examples repository [https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/cluster.js](https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/cluster.js).
  prefs: []
  type: TYPE_NORMAL
- en: 'We end up with a very tall graph that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing clusters](img/0007_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Partitioning a pie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we're getting somewhere! The next three layouts fit our data perfectly—we're
    taking three looks at how our core users' karma is structured.
  prefs: []
  type: TYPE_NORMAL
- en: The `partition` layout creates adjacency diagrams, where you don't draw nodes
    with links between them, but next to each other so that it looks like the children
    partition the parent.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to draw a two-layer donut chart. Users will go on the first layer
    and the layer on top will show us where the karma is coming from.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by munging the dataset and fixating colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the `partition` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We used `.value()` to tell the layout we care about the `.count` values, and
    we'll get a better picture if we `.sort()` the output. Similarly, to the `tree`
    layout, `x` will represent angles—this time in radians—and `y` will be radii.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need an `arc` generator as well, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The generator will use each node's `.y` property for the inner radius and add
    `.dy` for the outer radius. Fiddling shows the outer layer should be thinner,
    hence we are dividing it by the tree depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that there''s no accessor for `.startAngle` and `.endAngle`, which are
    stored as `.x` and `.dx`. It''s easier to just fix the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: It is as simple as mapping the data and defining angle properties, then filtering
    the data to make sure the root isn't drawn.
  prefs: []
  type: TYPE_NORMAL
- en: We use the familiar grouping trick to center our diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Preparation work is done. It''s drawing time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'An arc is drawn for every node, color is chosen as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We add labels and tooltips with the functions prepared in earlier examples.
    We avoid adding labels for very thin slices so that they don''t overlap and make
    a mess. Sprinkle some CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The adjacency diagram looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Partitioning a pie](img/0007_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Packing circles into circles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pack` layout uses packing to visually represent hierarchies. It stuffs
    children nodes into their parents, trying to conserve space and sizing each node
    so that it's the cumulative size of its children.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually it's very similar to the `treemap` layout, so I'm going to skip
    all the code and just show you the picture. You can still see the code over at
    GitHub [https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/pack.js](https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/pack.js).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code is rather familiar—generate a tree, fixate colors, create layout, tweak
    a few parameters, get computed nodes, draw nodes, and add tooltips. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: '![Packing circles into circles](img/0007_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It looks very pretty, but not too informative. Adding labels wouldn't help much
    because most nodes are too small.
  prefs: []
  type: TYPE_NORMAL
- en: Subdividing with treemap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `treemap` layout subdivides nodes with horizontal and vertical slices, essentially
    packing children into their parents just like the `pack` layout, but using rectangles.
    As a result, node sizes on every level can be compared directly, making this one
    of the best layouts for analyzing cumulative effects of subdivisions.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to have some fun with this example. Tooltips will name the parent—parents
    are almost completely obscured by the children—and mousing over a node will make
    unrelated nodes become lighter, making the graph less confusing (at least in theory).
  prefs: []
  type: TYPE_NORMAL
- en: It's also a cool effect and a great way to end this chapter on layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the boring stuff; prepare data and fixate colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the `treemap` layout follows familiar patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We added some padding with `.padding()` to give nodes room to breathe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every node will become a group element holding a rectangle. The leaves will
    also hold a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the first fun bit. Let''s fit labels into as many nodes as they can
    possibly go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Finally! That was some interesting code!
  prefs: []
  type: TYPE_NORMAL
- en: We found all the leaves and started adding text. To fit labels into nodes, we
    get their size with `this.getBBox()`, then move them to the middle of the node,
    and check for fit.
  prefs: []
  type: TYPE_NORMAL
- en: If the label is too wide but fits vertically, we rotate it; otherwise, we remove
    the label after checking again that it doesn't fit. Making sure of the height
    is important because some nodes are very thin.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add tooltips with `helpers.tooltip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Another fun bit—partially hiding nodes from different parents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We used two mouse event listeners: one creates the effect, another removes
    it. The `mouseover` listener goes through all the nodes and lightens those with
    a different parent or that aren''t the parent (`d.parent.nick` and `d.nick` are
    different). The `mouseout` listener removes all changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, add some CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result looks like an abstract painting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subdividing with treemap](img/0007_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Touching an area with your mouse restores some sanity as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subdividing with treemap](img/0007_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although, not as much sanity as we hoped.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the near mythical power of d3 layouts, they turn out to be nothing more
    than helpers that turn your data into a collection of coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: After going full out with these examples, we used almost every trick we've learned
    so far. We even wrote so much code that we had to make a separate library! With
    a bit of generalization, some of those functions could be layouts of their own.
    There's a whole world of community-developed layouts for various types of charts.
    The d3-plugins repository on GitHub ([https://github.com/d3/d3-plugins](https://github.com/d3/d3-plugins))
    is a good way to start exploring.
  prefs: []
  type: TYPE_NORMAL
- en: You now understand what all the default layouts are up to, and I hope you're
    already thinking about using them for purposes beyond the original developers'
    wildest dreams.
  prefs: []
  type: TYPE_NORMAL
