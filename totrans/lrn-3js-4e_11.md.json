["```js\nimport { EffectComposer } from \n  'three/examples/jsm/postprocessing/EffectComposer'\nimport { RenderPass } from \n  'three/examples/jsm/postprocessing/RenderPass.js'\nimport { ShaderPass } from \n  'three/examples/jsm/postprocessing/ShaderPass.js'\nimport { BloomPass } from \n  'three/examples/jsm/postprocessing/BloomPass.js'\nimport { GlitchPass } from \n  'three/examples/jsm/postprocessing/GlitchPass.js'\nimport { RGBShiftShader } from \n  'three/examples/jsm/shaders/RGBShiftShader.js'\nimport { DotScreenShader } from \n  'three/examples/jsm/shaders/DotScreenShader.js'\nimport { CopyShader } from \n  'three/examples/jsm/shaders/CopyShader.js'\n```", "```js\nconst composer = new EffectComposer(renderer)\n```", "```js\nconst renderPass = new RenderPass(scene, camera); \ncomposer.addPass(renderPass);\n```", "```js\nconst effect1 = new ShaderPass(DotScreenShader)\neffect1.uniforms['scale'].value = 10\neffect1.enabled = false\nconst effect2 = new ShaderPass(RGBShiftShader)\neffect2.uniforms['amount'].value = 0.015\neffect2.enabled = false\nconst composer = new EffectComposer(renderer)\ncomposer.addPass(new RenderPass(scene, camera))\ncomposer.addPass(effect1)\ncomposer.addPass(effect2)\n```", "```js\nconst render = () => { \nrequestAnimationFrame(render); \ncomposer.render();\n}\n```", "```js\nconst effectCopy = new ShaderPass(CopyShader)\nconst renderedSceneComposer = new EffectComposer(renderer)\nrenderedSceneComposer.addPass(new RenderPass(scene, \n  camera))\nrenderedSceneComposer.addPass(new ShaderPass\n  (GammaCorrectionShader))\nrenderedSceneComposer.addPass(effectCopy)\nrenderedSceneComposer.renderToScreen = false\nconst texturePass = new TexturePass\n  (renderedSceneComposer.renderTarget2.texture)\n```", "```js\nconst filmpass = new FilmPass()\nconst filmpassComposer = new EffectComposer(renderer)\nfilmpassComposer.addPass(texturePass)\nfilmpassComposer.addPass(filmpass)\n```", "```js\neffectFilm.uniforms.grayscale.value = controls.grayscale; \neffectFilm.uniforms.nIntensity.value = controls.\n  noiseIntensity; \neffectFilm.uniforms.sIntensity.value = controls.\n  scanlinesIntensity; \neffectFilm.uniforms.sCount.value = controls.scanlinesCount;\n```", "```js\nconst bloomPass = new BloomPass()\nconst effectCopy = new ShaderPass(CopyShader)\nbloomPassComposer = new EffectComposer(renderer)\nbloomPassComposer.addPass(texturePass)\nbloomPassComposer.addPass(bloomPass)\nbloomPassComposer.addPass(effectCopy)\n```", "```js\nconst dotScreenPass = new DotScreenPass()\nconst dotScreenPassComposer = new EffectComposer(renderer)\ndotScreenPassComposer.addPass(texturePass)\ndotScreenPassComposer.addPass(dotScreenPass)\n```", "```js\nconst width = window.innerWidth || 2\nconst height = window.innerHeight || 2\nconst halfWidth = width / 2\nconst halfHeight = height / 2\nconst render = () => {\n  renderer.autoClear = false\n  renderer.clear()\n  renderedSceneComposer.render()\n  renderer.setViewport(0, 0, halfWidth, halfHeight)\n  filmpassComposer.render()\n  renderer.setViewport(halfWidth, 0, halfWidth, halfHeight)\n  dotScreenPassComposer.render()\n  renderer.setViewport(0, halfHeight, halfWidth, \n    halfHeight)\n  bloomPassComposer.render()\n  renderer.setViewport(halfWidth, halfHeight, halfWidth, \n    halfHeight)\n  copyComposer.render()\n  requestAnimationFrame(() => render())\n}\n```", "```js\nconst sceneEarth = new THREE.Scene()\nconst sceneMars = new THREE.Scene()\nconst sceneBG = new THREE.Scene()\n```", "```js\nsceneBG.background = new THREE.TextureLoader().load\n ('/assets/textures/bg/starry-deep-outer-space-galaxy.jpg')\nconst earthAndLight = addEarth(sceneEarth)\nsceneEarth.translateX(-16)\nsceneEarth.scale.set(1.2, 1.2, 1.2)\nconst marsAndLight = addMars(sceneMars)\nsceneMars.translateX(12)\nsceneMars.translateY(6)\nsceneMars.scale.set(0.2, 0.2, 0.2)\n```", "```js\nvar composer = new EffectComposer(renderer)\ncomposer.renderTarget1.stencilBuffer = true\ncomposer.renderTarget2.stencilBuffer = true\ncomposer.addPass(bgRenderPass)\ncomposer.addPass(earthRenderPass)\ncomposer.addPass(marsRenderPass)\ncomposer.addPass(marsMask)\ncomposer.addPass(effectColorify)\ncomposer.addPass(clearMask)\ncomposer.addPass(earthMask)\ncomposer.addPass(effectSepia)\ncomposer.addPass(clearMask)\ncomposer.addPass(effectCopy)\n```", "```js\nconst bgRenderPass = new RenderPass(sceneBG, camera)\nconst earthRenderPass = new RenderPass(sceneEarth, camera)\nearthRenderPass.clear = false\nconst marsRenderPass = new RenderPass(sceneMars, camera)\nmarsRenderPass.clear = false\n```", "```js\nconst marsMask = new MaskPass(sceneMars, camera)\nconst effectColorify = new ShaderPass(ColorifyShader)\neffectColorify.uniforms['color'].value.setRGB(0.5, 0.5, 1)\nconst clearMask = new ClearMaskPass()\n```", "```js\nconst params = { \n   focus: 10,\n   aspect: camera.aspect, \n   aperture: 0.0002,\n   maxblur: 1\n};\nconst renderPass = new RenderPass(scene, camera);\nconst bokehPass = new BokehPass(scene, camera, params) \nbokehPass.renderToScreen = true;\nconst composer = new EffectComposer(renderer); \ncomposer.addPass(renderPass); \ncomposer.addPass(bokehPass);\n```", "```js\nexport const CustomGrayScaleShader = {\n  uniforms: {\n    tDiffuse: { type: 't', value: null },\n    rPower: { type: 'f', value: 0.2126 },\n    gPower: { type: 'f', value: 0.7152 },\n    bPower: { type: 'f', value: 0.0722 }\n  },\n  // 0.2126 R + 0.7152 G + 0.0722 B\n  // vertexshader is always the same for postprocessing \n     steps\n  vertexShader: [\n    'varying vec2 vUv;',\n    'void main() {',\n    'vUv = uv;',\n    'gl_Position = projectionMatrix * modelViewMatrix * \n      vec4( position, 1.0 );',\n    '}'\n  ].join('\\n'),\n  fragmentShader: [\n    // pass in our custom uniforms\n    'uniform float rPower;',\n    'uniform float gPower;',\n    'uniform float bPower;',\n    // pass in the image/texture we'll be modifying\n    'uniform sampler2D tDiffuse;',\n    // used to determine the correct texel we're working on\n    'varying vec2 vUv;',\n    // executed, in parallel, for each pixel\n    'void main() {',\n    // get the pixel from the texture we're working with \n       (called a texel)\n    'vec4 texel = texture2D( tDiffuse, vUv );',\n    // calculate the new color\n    'float gray = texel.r*rPower + texel.g*gPower + \n      texel.b*bPower;',\n    // return this new color\n    'gl_FragColor = vec4( vec3(gray), texel.w );',\n    '}'\n  ].join('\\n')\n}\n```", "```js\n  vertexShader: [\n    'varying vec2 vUv;',\n    'void main() {',\n    'vUv = uv;',\n    'gl_Position = projectionMatrix * modelViewMatrix * \n      vec4( position, 1.0 );',\n    '}'\n  ].join('\\n'),\n```", "```js\n  'uniform float rPower;',\n  'uniform float gPower;',\n  'uniform float bPower;',\n  'uniform sampler2D tDiffuse;',\n  'varying vec2 vUv;',\n```", "```js\nuniforms: {\n\"tDiffuse\": { type: \"t\", value: null },\n\"rPower\":   { type: \"f\", value: 0.2126 },\n\"gPower\":   { type: \"f\", value: 0.7152 },\n\"bPower\":   { type: \"f\", value: 0.0722 }\n},\n```", "```js\n\"void main() {\",\n\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\"float gray = texel.r*rPower + texel.g*gPower + \n  texel.b*bPower;\", \"gl_FragColor = vec4( vec3(gray), \n    texel.w );\"\n```", "```js\nconst effectCopy = new ShaderPass(CopyShader)\neffectCopy.renderToScreen = true\nconst grayScaleShader = new ShaderPass\n  (CustomGrayScaleShader)\nconst gammaCorrectionShader = new ShaderPass\n  (GammaCorrectionShader)\nconst composer = new EffectComposer(renderer)\ncomposer.addPass(new RenderPass(scene, camera))\ncomposer.addPass(grayScaleShader)\ncomposer.addPass(gammaCorrectionShader)\ncomposer.addPass(effectCopy)\n```", "```js\nshaderPass.uniforms.rPower.value = ...; \nshaderPass.uniforms.gPower.value = ...; \nshaderPass.uniforms.bPower.value = ...;\n```", "```js\nuniforms: {\n  \"tDiffuse\": { type: \"t\", value: null },\n  \"bitSize\":    { type: \"i\", value: 4 }\n}\n```", "```js\n  fragmentShader: [\n    'uniform int bitSize;',\n    'uniform sampler2D tDiffuse;',\n    'varying vec2 vUv;',\n    'void main() {',\n    'vec4 texel = texture2D( tDiffuse, vUv );',\n    'float n = pow(float(bitSize),2.0);',\n    'float newR = floor(texel.r*n)/n;',\n    'float newG = floor(texel.g*n)/n;',\n    'float newB = floor(texel.b*n)/n;',\n    'gl_FragColor = vec4( vec3(newR,newG,newB), 1.0);',\n    '}'\n  ].join('\\n')\n```"]