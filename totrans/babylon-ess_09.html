<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Create and Play Animations</h1></div></div></div><p>In the previous chapters, you learned everything that is required to create cool, beautiful, and complete 3D applications. This is the last chapter and the last thing that you need to learn is how to animate objects in your scene. Then, finally, you will get a fully dynamic scene.</p><p>The Babylon.js framework provides a way to create animations without managing them with code. For example, you want to create a rotation animation that will affect five objects (nodes) in your scene; Babylon.js will allow you to create an animation object that you can share easily between your five nodes. In this chapter, we'll cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating animations using Babylon.js</li><li class="listitem" style="list-style-type: disc">Smooth animations using easing functions</li><li class="listitem" style="list-style-type: disc">Importing and managing animated models</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec37"/>Creating animations using Babylon.js</h1></div></div></div><p>For this first topic, let's discuss how to simply animate a box with code and how to create an animation using the Babylon.js tools such as the <code class="literal">BABYLON.Animation</code> class. You'll quickly understand the importance of using the provided tools instead of handling animations with code.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec68"/>Animating an object with code</h2></div></div></div><p>Let's start with the following scene (a plane and a box):</p><p>
</p><div><img src="img/image_09_001.png" alt="Animating an object with code"/></div><p>
</p><p>Let's animate the box to turn around its center (x = 0, y = 0, and z = 0). The process should be to increment a value (angle) in time and set the new position of the box.</p><p>Typically, (<em>x = Radius*Cos(angle)</em>, <em>y = 0</em>, and <em>z = Radius*Sin(angle)</em>).</p><p>To perform this action, you can call a <code class="literal">.registerBeforeRender</code> function on the scene. This function takes an anonymous function as the parameter and this anonymous function will be automatically called for every frame, as follows:</p><pre class="programlisting">var angle = 0.0;&#13;
var radius = 10.0;&#13;
scene.registerBeforeRender(() =&gt; {&#13;
  angle += 0.01; // Increment the angle&#13;
  // Set the new position of the box&#13;
  box.position.x = radius * Math.cos(angle);&#13;
  box.position.z = radius * Math.sin(angle);&#13;
});</pre><p>This function is pretty simple; however, it is applied only to the box. What if you want to animate another object by sharing the same code? The solution is simple; just pass the node as a parameter to a function that will register a new function at each call before render, as follows:</p><pre class="programlisting">var createAnimation = function(node) {&#13;
  var angle = 0.0;&#13;
  var radius = 10.0;&#13;
  scene.registerBeforeRender(() =&gt; {&#13;
    angle += 0.01; // Increment the angle&#13;
    // Set the new position of the box&#13;
    node.position.x = radius * Math.cos(angle);&#13;
    node.position.z = radius * Math.sin(angle);&#13;
  });&#13;
}</pre><p>As you can see, it is not necessarily a problem to manage the animations through code. The real problem occurs when you have to synchronize the animation with time (manage the speed of animation), stop or pause animations, and so on. These functions require you to create a complete manager and it is not necessary what you want to do.</p><p>The next sub-topic will show you how to use the animation manager of Babylon.js and don't worry about the time, stop and pause functions, and so on.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec69"/>Using the animation manager of Babylon.js</h2></div></div></div><p>Let's take the same scene and create a simple animation only using the animation manager of Babylon.js. You need to understand only one thing: the frame keys of an animation.</p><p>To create an animation, just use the <code class="literal">BABYLON.Animation</code> class and attach it to a node (or several nodes). The <code class="literal">BABYLON.Animation</code> class isn't difficult to understand, it takes a name, a property to animate on a node (and not necessarily a property of a node), number of frames per second, data type, and loop mode, as shown in the following snippet:</p><pre class="programlisting">var simpleAnimation = new BABYLON.Animation(&#13;
  "simpleAnimation", // Name of the animation&#13;
  "rotation", // The property to modify (node.rotation)&#13;
  1, // Frames per second&#13;
  BABYLON.Animation.ANIMATIONTYPE_VECTOR3, // The type of property&#13;
  BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE // The loop mode&#13;);</pre><p>The <code class="literal">rotation</code> parameter says that the animation manager will animate the <code class="literal">.rotation</code> property of the object attached to the animation. A rotation is of the <code class="literal">BABYLON.Vector3</code> type, this is the reason why the data type is <code class="literal">BABYLON.Animation.ANIMATIONTYPE_VECTOR3</code>. Finally, we want the animation to loop.</p><p>According to the property you are animating (<em>rotation</em> in the previous example that is a <code class="literal">BABYLON.Vector3</code> object), you have to provide a valid data type which can be one of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ANIMATIONTYPE_FLOAT</code>: When the property is of the <code class="literal">float</code> type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ANIMATIONTYPE_VECTOR2</code>: When the property is of the <code class="literal">BABYLON.Vector2</code> type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ANIMATIONTYPE_VECTOR3</code>: When the property is of the <code class="literal">BABYLON.Vector3</code> type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ANIMATIONTYPE_QUATERNION</code>: When the property is of the <code class="literal">BABYLON.Quaternion</code> type. A mathematical object that can be used to represent the rotation of a node (<code class="literal">node.rotationQuaternion</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ANIMATIONTYPE_MATRIX</code>: When the property is of the <code class="literal">BABYLON.Matrix</code> type.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ANIMATIONTYPE_COLOR3</code>: When the property is of the <code class="literal">BABYLON.Color3</code> type.</li></ul></div><p>In this case, we use the <code class="literal">Vector3</code> data type as the <code class="literal">.rotation</code> property is <code class="literal">BABYLON.Vector3</code>.</p><p>The next step consists of creating an array of keys. The keys (or key frames) represent the state of the animated property at specific frames. In the previously created animation, the number of frames per second was set to <code class="literal">1</code>. Then, each second, a key, in the array of keys, is reached. The keys of an animation is simply an array of objects, objects each composed of two properties: the frame number and, according to the animated property, the associated value (of type <code class="literal">float</code>, <code class="literal">BABYLON.Vector2</code>, or <code class="literal">BABYLON.Vector3</code>, and so on.), as follows:</p><pre class="programlisting">{&#13;
  frame: number;&#13;
  value: any;&#13;
}</pre><p>Let's create two keys that will translate the box from the position (<code class="literal">x = 0</code>, <code class="literal">y = 2.5</code>, and <code class="literal">z = 0</code>) to (<code class="literal">x = 10</code>, <code class="literal">y = 10</code>, and <code class="literal">z = 10</code>) at frame 20, as follows:</p><pre class="programlisting">var keys = [&#13;
{&#13;
  frame: 0,&#13;
  value: new BABYLON.Vector3(0, 0, 0)&#13;
},&#13;
{&#13;
  frame: 20,&#13;
  value: new BABYLON.Vector3(10, 10, 10)&#13;
}&#13;
];</pre><p>If the number of frames per second is set to <code class="literal">1</code>, the second key (<code class="literal">frame = 20</code>) means that the box position will be at (<code class="literal">x = 10</code>, <code class="literal">y = 10</code>, and <code class="literal">z = 10</code>) 20 seconds later.</p><p>Let's set the keys for the <code class="literal">simpleAnimation</code> animation manager, as follows:</p><pre class="programlisting">simpleAnimation.setKeys(keys);</pre><p>Finally, let's attach the animation manager to the box and start the animation in the scene, as follows:</p><pre class="programlisting">// Add animation to the box&#13;
// Every BABYLON.Node object has the ".animations" property&#13;
box.animations.push(simpleAnimation);&#13;
// Start animation&#13;
scene.beginAnimation(&#13;
  box, // Start animation(s) of the box&#13;
  0, // Start key. Here 0&#13;
  20, // End key. Here 20&#13;
  true, // Loop the animation&#13;
  1, // Speed ratio. Controls the speed of animation&#13;
  () =&gt; { // Callback. Called when animation finished&#13;
    console.log("Finished");&#13;
}&#13;);</pre><p>The result looks similar to the following at the beginning:</p><p>
</p><div><img src="img/image_09_002.png" alt="Using the animation manager of Babylon.js"/></div><p>
</p><p>Finally, once the animation has finished, the result looks like:</p><p>
</p><div><img src="img/image_09_003.png" alt="Using the animation manager of Babylon.js"/></div><p>
</p><p>To reproduce the previous example (the box that turns around the center), the solution is pretty simple; just add 360 keys that represent every degree of a circle, as follows:</p><pre class="programlisting">// Create animation&#13;
var complexAnimation = new BABYLON.Animation(&#13;
  "boxAnimationComplex",&#13;
  "position",&#13;
  60, // 60 frames per second&#13;
  BABYLON.Animation.ANIMATIONTYPE_VECTOR3,&#13;
  BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE&#13;);&#13;
// Create keys&#13;
var complexKeys = [];&#13;
for (var i=0; i &lt; 360; i++) {&#13;
  // Transform the degrees into radians&#13;
  var angle = BABYLON.Tools.ToRadians(i);&#13;
  complexKeys.push({&#13;
    frame: i,&#13;
    value: new BABYLON.Vector3(10 * Math.cos(angle),&#13;
    2.5,&#13;
    10 * Math.sin(angle))&#13;
  });&#13;
}&#13;
// Set the keys&#13;
complexAnimation.setKeys(complexKeys);&#13;
// Finally run the animation(s)&#13;
scene.beginAnimation(this._box, 0, 360, false, 1.0, () =&gt; {&#13;
  console.log("Animation Finished");&#13;
});</pre><p>To control your animations (start, pause, restart, and stop), the <code class="literal">.beginAnimation</code> function returns an object of the <code class="literal">BABYLON.Animatable</code> type. The returned object is created on the fly and allows you to control your animations. Let's consider the same example as earlier:</p><pre class="programlisting">var anim = scene.beginAnimation(this._box, 0, 360, false, 1.0, () =&gt; {&#13;
  console.log("Animation Finished");&#13;
});&#13;
// Pause animation&#13;
anim.pause();&#13;
// Start the animation (when stopped or paused)&#13;
anim.start();&#13;
// Restart animation&#13;
anim.restart();&#13;
// Stop animation&#13;
anim.stop();&#13;
// Go to a specific frame&#13;
anim.goToFrame(180);</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec70"/>Create a simple animation</h2></div></div></div><p>The first example, with only two frames, can be heavy as I know that you'll quickly create a helper, once and for all. Babylon.js thought about this and provides a static <code class="literal">CreateAndStartAnimation</code> function that creates two frames and starts the animation for you. Let's create the same animation only using the following function:</p><pre class="programlisting">var anim: BABYLON.Animation = BABYLON.Animation.CreateAndStartAnimation(&#13;
  "quickAnimation", // name of the animation&#13;
  box, // The mesh to animate&#13;
  "position", // The property to animate&#13;
  1, // frames per second&#13;
  20, // number of frames of the animation&#13;
  new BABYLON.Vector3(0, 0, 0), // The start value&#13;
  new BABYLON.Vector3(10, 10, 10), // The end value&#13;
  BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE // The loop mode&#13;);</pre><p>As you can guess, this method is used by Babylon.js to create <code class="literal">BABYLON.InterpolateValueAction</code> (<a class="link" href="ch07.html" title="Chapter 7. Defining Actions on Objects">Chapter 7</a>, <em>Defining Actions on Objects</em>).</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec71"/>Managing events</h2></div></div></div><p>An advanced use of the Babylon.js animations is to call a function when a specific frame is reached. The <code class="literal">BABYLON.AnimationEvent</code> class exists to allow you to attach one or more events to a specific frame. For example, consider the previous example (<code class="literal">complexAnimation</code>), as follows:</p><pre class="programlisting">var event = new BABYLON.AnimationEvent(&#13;
  180, // The frame when the callback will be called&#13;
  () =&gt; { // The function executed when the current frame is 180&#13;
    console.log("My event was called!");&#13;
  },&#13;
  false // Only once? False, we want to call the callback every ti  me// the frame is reached&#13;);&#13;
// Add the event to the animation&#13;
complexAnimation.addEvent(event);</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec38"/>Using easing functions to smooth animations</h1></div></div></div><p>One of the advanced features of the Babylon.js animations management is to use easing functions to smooth well and add behaviors to your animations.</p><p>To take a quick look at the appearance of the easing functions (we do not necessarily remember every type of easing functions), you should follow this link (<a class="ulink" href="http://easings.net/en">http://easings.net/en</a>).</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec72"/>Applying an easing function to an animation</h2></div></div></div><p>To apply an easing function to an animation, the method only consists of customizing an already created animation. You'll just have to call the <code class="literal">.setEasingFunction</code> method for an animation with an easing function as the parameter.</p><p>The available easing functions are (with the associated curve in time) as shown in the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Circle ease: <code class="literal">BABYLON.CircleEase()</code></li></ul></div><p>
</p><div><img src="img/image_09_004.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Back ease: <code class="literal">BABYLON.BackEase(amplitude)</code></li></ul></div><p>
</p><div><img src="img/image_09_005.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Bounce ease: <code class="literal">BABYLON.BounceEase(bounces, bounciness)</code></li></ul></div><p>
</p><div><img src="img/image_09_006.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cubic ease: <code class="literal">BABYLON.CubicEase()</code></li></ul></div><p>
</p><div><img src="img/image_09_007.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Elastic ease: <code class="literal">BABYLON.ElasticEase(oscillations, springiness)</code></li></ul></div><p>
</p><div><img src="img/image_09_008.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exponential ease: <code class="literal">BABYLON.ExponentialEase(exponent)</code></li></ul></div><p>
</p><div><img src="img/image_09_009.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Quadratic ease:<code class="literal">BABYLON.QuadraticEase()</code></li></ul></div><p>
</p><div><img src="img/image_09_010.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Quartic ease: <code class="literal">BABYLON.QuarticEase()</code></li></ul></div><p>
</p><div><img src="img/image_09_011.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Quintic ease: <code class="literal">BABYLON.QuinticEase()</code></li></ul></div><p>
</p><div><img src="img/image_09_013.png" alt="Applying an easing function to an animation"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sine ease: <code class="literal">BABYLON.SineEase()</code></li></ul></div><p>
</p><div><img src="img/image_09_012.png" alt="Applying an easing function to an animation"/></div><p>
</p><p>Let's start with the following simple example (animate the .x property of the box's rotation using a circle easing function):</p><pre class="programlisting">// Create and set easing function (circle ease)&#13;
var ease = new BABYLON.CircleEase();&#13;
easingAnimation.setEasingFunction(ease);</pre><p>That's all, the animation will now follow the formula of the circle easing function, as shown in the following:</p><pre class="programlisting">// Create animation&#13;
var easingAnimation = new BABYLON.Animation(&#13;
  "easingAnimation", &#13;
  "rotation.x", // Modify the .x property of rotation&#13;
  10, // 10 frames per second&#13;
  BABYLON.Animation.ANIMATIONTYPE_VECTOR3,&#13;
  BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE&#13;);&#13;
// Create keys&#13;
var simpleKeys = [&#13;
  {&#13;
    frame: 0,&#13;
    value: 0&#13;
  },&#13;
  {&#13;
    frame: 20,&#13;
    value: Math.PI&#13;
  },&#13;
  {&#13;
    frame: 40,&#13;
    value: 0&#13;
  }&#13;
];&#13;
// Set keys&#13;
easingAnimation.setKeys(simpleKeys);&#13;
// Push animation&#13;
this._box.animations.push(easingAnimation);&#13;
// Create and set easing function (circle ease)&#13;
var ease = new BABYLON.CircleEase();&#13;
easingAnimation.setEasingFunction(ease);&#13;
// Finally, start the animation(s) of the box&#13;
this._scene.beginAnimation(box, 0, 40, true, 1.0, () =&gt; {&#13;
  console.log("Animation Finished");&#13;
});</pre><p>As it is hard to represent an animation by taking screenshots, you can try the different easing functions by yourself. The method is the same for all the easing functions, except that several easing function constructors will need some arguments for more customization.</p><p>Now, let's modify the behavior of the easing function. An easing function consists of modes, as shown in the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">In</code>, when the animation starts (enters): <code class="literal">BABYLON.EasingFunction.EASINGMODE_EASEIN</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Out</code>, when the animation is completed (exits): <code class="literal">BABYLON.EasingFunction.EASINGMODE_EASEOUT</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">In &amp; Out</code>, when the animation starts and finishes (both enter and exit): <code class="literal">BABYLON.EasingFunction.EASINGMODE_EASEINOUT</code></li></ul></div><p>By default, the easing mode is set to <code class="literal">In</code> (<code class="literal">BABYLON.EasingFunction.EASINGMODE_EASEIN</code>). The website <a class="ulink" href="http://easings.net/en">http://easings.net/en</a> shows exactly how the easing functions look in these three modes.</p><p>To specify the easing mode, just call the <code class="literal">.setEasingMode</code> method on an animation, as follows:</p><pre class="programlisting">// Create and set easing function (circle ease)&#13;
var ease = new BABYLON.CircleEase();&#13;
ease.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);&#13;
easingAnimation.setEasingFunction(ease);</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec73"/>Creating your own easing function</h2></div></div></div><p>For the last sub-topic about easing functions, let's discuss how to create your own easing function if it is not available in Babylon.js. The process is really simple (except the possible difficult mathematical formula(s) associated with your easing function).</p><p>Just create a class that inherits from the <code class="literal">BABYLON.EasingFunction</code> class that implements the <code class="literal">BABYLON.IEasingFunction</code> interface. The only thing to do is to implement the <code class="literal">.easeInCore(gradient: number)</code> function that takes the interpolated value as the parameter.</p><p>Let's create an example with a Power easing function, as follows:</p><pre class="programlisting">export class PowerEase extends BABYLON.EasingFunction&#13;
{&#13;
  constructor(public power: number = 2) {&#13;
    // Call constructor of BABYLON.EasingFunction&#13;
    super();&#13;
  }&#13;
  public easeInCore(gradient: number): number {&#13;
    var y = Math.max(0.0, this.power);&#13;
    return Math.pow(gradient, y);&#13;
  }&#13;
}&#13;
Somewhere in your code:&#13;
// Create and set easing function (circle ease)&#13;
var customEase = new BABYLON.PowerEase(4);&#13;
customEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);&#13;
easingAnimation.setEasingFunction(customEase);</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec39"/>Importing and managing animated models</h1></div></div></div><p>To finish this chapter with a cool demo, let's discuss how to animate characters or 3D models, in general.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec74"/>How 3D animated models work</h2></div></div></div><p>If you remember, each vertex of a 3D model is computed to be projected on the screen by a vertex shader. In fact, the animated 3D models (such as a character) are also animated with the associated hierarchy of bones (the hierarchy is called <strong>Skeleton</strong>). Animated 3D models are also called <strong>Skinned Meshes</strong>. In 3D engines, the bones are invisible nodes that are animated (<code class="literal">BABYLON.Animation</code>) to be sent to the vertex shader associated with the 3D model. In other words, the transformation of each bone is sent to the vertex shader and is applied to the associated vertices.</p><p>To go further in the theory, the vertex shader contains the following two additional buffers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The bones' matrices weights (Vector4, represents the <em>intensity</em> of the influence of each bone on the current vertex).</li><li class="listitem" style="list-style-type: disc">The bones' matrices indices (Vector4, until four bone influences per vertex) work like the indices buffer, but for bones. In other words, for each vertex, which bones influence the vertex (indices in the array of bones' transformations).</li></ul></div><div><div><h3 class="title"><a id="note13"/>Note</h3><p>
<strong>Note:</strong> The common buffers for static 3D models are the positions (required), indices (required), normals (not required), UVs (texture coordinates, not required), and colors (not required).</p></div></div><p>Finally, for each vertex, the formula (in GLSL) is as follows:</p><pre class="programlisting">uniform mat4 bones[NUMBER_OF_BONES]; // Sent by Babylon.js&#13;
mat4 boneTransform1 = bones[matricesIndices[0]] * matricesWeights[0];&#13;
mat4 boneTransform2 = bones[matricesIndices[1]] * matricesWeights[1];&#13;
mat4 boneTransform3 = bones[matricesIndices[2]] * matricesWeights[2];&#13;
mat4 boneTransform4 = bones[matricesIndices[3]] * matricesWeights[3];&#13;
mat4 finalTransform = transformedVertex * (&#13;
  boneTransform1 + boneTransform2 +&#13;
    boneTransform3 + boneTransform4&#13;);</pre><p>When artists export their 3D models (animated with the tools provided by the modeling software), the Babylon.js exporters (3ds Max and Blender) explicitly write the bones' weights' buffers and the bones' matrices indices buffers in the exported file, which arrays of numbers. In conclusion, for animated 3D models, you don't have to specify the animations through code, the exporters can do everything for you. Let's wait until the next sub-topic to learn how to animate the 3D models.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec75"/>Importing and playing animations of an animated 3D model</h2></div></div></div><p>To import an animated 3D model, you have to use the <code class="literal">BABYLON.SceneLoader</code> class for the static 3D models (<a class="link" href="ch03.html" title="Chapter 3. Create, Load, and Draw 3D Objects on the Screen">Chapter 3</a>, <em>Create, Load, and Draw 3D Objects on the Screen</em>) to import an animated 3D model. In fact, the <code class="literal">.Load</code> (and <code class="literal">.Append</code>) function automatically loads the animated 3D models with the associated skeletons (hierarchy of nodes) with the difference that the <code class="literal">.ImportMesh</code> function's callback provides the loaded meshes, particle systems, and skeletons, as follows:</p><pre class="programlisting">(meshes: AbstractMesh [], particleSystems: ParticleSystem[], skeletons: Skeleton[]) =&gt; void;</pre><p>Concretely, as the animated nodes are the skeletons' bones, the target of the <code class="literal">.beginAnimation</code> function is only the skeleton associated with your animated 3D model and not the node itself, as follows:</p><pre class="programlisting">// myAnimated3DModel is a BABYLON.Mesh;&#13;
var skeleton = myAnimated3DModel.skeleton; // get the skeleton&#13;
scene.beginAnimation(&#13;
  skeleton, // Target to animate&#13;
  0, // The start frame&#13;
  150, // The end frame&#13;
  true, // Loop ?&#13;
  1.0, // Speed ratio&#13;
  () =&gt; { // Animation end callback&#13;
    console.log("Animation of skeleton finished!");&#13;
  }&#13;);</pre><p>Let's start an example (available in the example files) using the <code class="literal">.ImportMesh</code> function, as shown in the following snippet:</p><pre class="programlisting">// Import an animated 3D model&#13;
BABYLON.SceneLoader.ImportMesh(&#13;
  "", // Names of the specific&#13;
  "./", // The root URL&#13;
  "dude.babylon", // The name of the scene containing the meshes&#13;
  scene, // The scene where to add the meshes&#13;
  (meshes, particleSystems, skeletons) =&gt; { // callback success&#13;
    // Simply start the animations of the skeleton associated&#13;
    // To the mesh&#13;
    this._scene.beginAnimation(skeletons[0], 0, 150, true, 1.0);&#13;
  }&#13;);</pre><div><div><h3 class="title"><a id="note14"/>Note</h3><p>
<strong>Note:</strong> An animated 3D model can contain multiple meshes. This is the reason the <code class="literal">ImportMesh</code> function can return an array of multiple meshes and only one skeleton in the array of skeletons.</p></div></div><p>The result (the man is walking and the animation played from frame 0 to 150) is as shown in the following image:</p><p>
</p><div><img src="img/image_09_014.png" alt="Importing and playing animations of an animated 3D model"/></div><p>
</p><p>Using the <code class="literal">.Load</code> function, the method is pretty different. As the success callback provides only the loaded scene, you'll have to find the skeletons stored in the scene. To do this, simple use the <code class="literal">.getSkeletonByName</code> function on the scene, as follows:</p><pre class="programlisting">BABYLON.SceneLoader.Append(&#13;
  "./", // The root url&#13;
  "dude.babylon", // The name of the scene&#13;
  scene, // The scene where to append&#13;
  (scene) =&gt; { // The success callback&#13;
    // Get the skeleton&#13;
    var skeleton = this._scene.getSkeletonByName("Skeleton0");&#13;
    // Simply animate the skeleton&#13;
    scene.beginAnimation(skeleton, 0, 150, true, 1.0);&#13;
  }&#13;);</pre><p>The result with the <code class="literal">dude.babylon</code> scene using the <code class="literal">.Load</code> function is as shown in the following image:</p><p>
</p><div><img src="img/image_09_015.png" alt="Importing and playing animations of an animated 3D model"/></div><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec40"/>Summary</h1></div></div></div><p>Creating animations using Babylon.js can really make your scenes more alive. As you can see, these features are also pretty simple to use, following the principle of Babylon.js: the KISS principle (Keep It Simple, Stupid).</p><p>Now, at the end of this book, you are ready to work with the artists and combine all the learned features of Babylon.js. Using post-processes, manage and customize materials, create and manage animations, load scenes, manage actions, and so on!</p><p>To go further, you can have a look at the new features (recently released) such as the materials library (a library of specific easy-to-use materials like the standard material, such as water, terrain material, PBR, lava, and so on!). One of the new features should be the procedural textures automatically handled by Babylon.js such as fire, ground, grass, and so on. Also, to go further, you can take a look at the particle systems and shadows generator for specific projects that need to create some smoke or fire, and more beautiful (but more expansive) scenes.</p><p>Have fun with Babylon.js!</p></div></body></html>