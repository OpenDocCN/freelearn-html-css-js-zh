- en: Chapter 5. Create Collisions on Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters introduced the 3D programming basics and Babylon.js. You
    can easily create and customize your scenes using the materials and meshes provided
    by your designer as you now understand the complete workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, let''s play with the gameplay itself and create interactions
    with objects in the scene by creating collisions and physics simulations. Collisions
    are important to add realism to your scenes if you want to walk without crossing
    the walls. Moreover, to make the scenes more alive, let''s introduce the physics
    simulation with Babylon.js and finally, see how easy it is to integrate these
    two notions in your scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking collisions in a scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulatating physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking collisions in a scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from the concept, configuring and checking collisions in a scene can
    be done without mathematical notations. We all have the notion of gravity and
    ellipsoid, even if the *ellipsoid* word is not necessarily familiar.
  prefs: []
  type: TYPE_NORMAL
- en: How collisions work in Babylon.js?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the following scene (a camera, light, plane, and box):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How collisions work in Babylon.js?](img/image_05_001-1024x496.png)'
  prefs: []
  type: TYPE_IMG
- en: The goal is to prevent the currently active camera of the scene from crossing
    the objects in the scene. In other words, we want the camera to stay above the
    plane and stop moving forward if it collides with the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform these actions, the collisions system provided by Babylon.js uses
    a **collider**. A collider can be represented by the `bounding box` of a simple
    object and it looks similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How collisions work in Babylon.js?](img/image_05_002-1024x492.png)'
  prefs: []
  type: TYPE_IMG
- en: For information, a bounding box simply represents the minimum and maximum positions
    of a mesh's vertices and it is computed automatically by Babylon.js.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [Chapter 3](ch03.html "Chapter 3. Create, Load, and Draw 3D
    Objects on the Screen"), *Create, Load, and Draw 3D Objects on the Screen*, the meshes
    are composed of vertices that are linked together using the index buffer to finally
    build triangles; to be precise, the collisions are based on these triangles and
    are automatically managed/computed by Babylon.js. This means that you have to
    do nothing that is particularly tricky to configure collisions with objects.
  prefs: []
  type: TYPE_NORMAL
- en: To resume, all the collisions are based on the triangles of each mesh in order
    to determine whether the camera should be blocked or not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll also see that the physics engines use the same kind of collider to simulate
    physics for simple meshes (bounding boxes).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the complicated part is for the designer. They must optimize all
    their meshes to work well with the collisions. This means that they must split
    the big meshes into multiple or submeshes thanks to their 3D modeler.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when rendering the scene, the collision system of Babylon.js will test
    whether the collisions should be tested for each mesh in the scene according to
    the global position of the camera. This is how 3D engines tend to optimize collisions
    as the main problem is that the collisions are computed in the CPU side.
  prefs: []
  type: TYPE_NORMAL
- en: For example, some 3D engines offer a way to configure collisions on meshes by
    giving a particular type of collision; even if the mesh is complex, you can choose
    whether you want to use a bounding box as collider (to save the CPU performances)
    or directly use the triangles of the mesh (realistic collisions).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring collisions in a scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's practice with the Babylon.js collisions engine itself. You'll see that
    the engine is particularly well-hidden as you only have to enable checks on the
    scene and objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, configure the scene in order to enable the collisions and then wake
    the engine up. If the following property is `false`, all the next properties will
    be ignored by Babylon.js and the collisions engine will be in the *stand by* mode.
    Then, it''s easy to enable or disable the collisions in a scene without modifying
    more properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, configure the camera to check the collisions. The collisions engine will
    check collisions for all the rendered cameras that have collisions enabled. Here,
    we have only one camera to configure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, set the `.checkCollisions `property of each mesh to `true` to activate
    collisions (here, the plane and box), as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, the collisions engine will check the collisions in the scene for the camera
    on both plane and box meshes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You guessed right , if you want to enable collisions only on the plane and
    want the camera to move across the box, you''ll have to set the `.checkCollisions`
    property of the box to `false`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Configure gravity and ellipsoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Gravity**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, the camera checks the collision on the plane and the
    box; however, this is not submitted to a famous force named **the gravity**. To
    enrich the collisions in your scene, you can apply the gravity force, for example,
    to go down from the stairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, enable the gravity on the camera by setting the `.applyGravity` property
    to `true`, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, customize the gravity direction by setting `BABYLON.Vector3` to the
    `.gravity` property of your scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the gravity in space should be as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Don't hesitate to play with the values in order to adjust the gravity to your
    scene referential.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ellipsoid**'
  prefs: []
  type: TYPE_NORMAL
- en: The last parameter to enrich the collisions in your scene is the camera's ellipsoid.
    The ellipsoid represents the camera's dimensions in the scene. In other words,
    it adjusts the collisions according to the x, y, and z axes of the ellipsoid (an
    ellipsoid is represented by `BABYLON.Vector3`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the camera must measure 1.8 m (y axis) and the minimum distance
    to collide with the x (sides) and z (forward) axes must be 1 m. Then, the ellipsoid
    must be (`x = 1`, `y = 1.8`, and `z = 1`). Simply, set the  `.ellipsoid` property
    of the camera, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default value of the camera's ellipsoids is (`x = 0.5`, `y = 1.0`, and `z
    = 0.5`)
  prefs: []
  type: TYPE_NORMAL
- en: As for the gravity, don't hesitate to adjust the `x`, `y`, and `z` according
    to your scene scale.
  prefs: []
  type: TYPE_NORMAL
- en: Simulate physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physics simulation is pretty different from the collisions system since it does
    not occur on the cameras but on the objects of the scene itself. In other words,
    if physics is enabled (and configured) on a box, the box will interact with other
    meshes in the scene and try to represent the real physical movements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's take a sphere in the air. If you apply physics to the sphere,
    the sphere will fall until it collides with another mesh and according to the
    given parameters, it will bounce and roll in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example files reproduce the behavior of a sphere that falls on the box in
    the middle of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Enable physics in Babylon.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Babylon.js, physics simulations can be only done using plugins. Two plugins
    are available for use: the Cannon.js framework and the Oimo.js framework. These
    two frameworks are included in the Babylon.js GitHub repository in the `dist` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each scene has its own physics simulations system and can be enabled by the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The  `.enablePhysics(gravity, plugin)` function takes the following two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The gravity force of the scene to apply on objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plugin to use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oimo.js: `new BABYLON.OimoJSPlugin()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannon.js: `new BABYLON.CannonJSPlugin()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To disable physics in a scene, simply call the `.disablePhysicsEngine()` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Impostors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the physics simulations are enabled in a scene, you can configure the physics
    properties (or physics states) of the scene meshes. To configure the physics properties
    of a mesh, the `BABYLON.Mesh` class provides a `setPhysicsState(impostor, options)` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`impostor`: Each kind of mesh has its own impostor according to its form. For
    example, a box will tend to slip while a sphere will roll. There are several types
    of impostors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: These options define the values used in physics equations. It counts
    the mass, friction, and restitution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider a box named `box` with a mass of `1` and set its physics properties,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That's all, the box is now configured to interact with other configured meshes
    by following the physics equations. Let's imagine that the box is in the air and
    will fall until it collides with another configured mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a sphere named `sphere` with a mass of `2` and set its physics
    properties, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that the sphere, which is a particular kind of mesh, has its own
    impostor (`SphereImpostor`). In contrast to the box, the physics equations of
    the plugin will make the sphere roll, while the box will slip on other meshes.
  prefs: []
  type: TYPE_NORMAL
- en: According to their masses, if the box and sphere collide, then the sphere will
    tend to push the box harder .
  prefs: []
  type: TYPE_NORMAL
- en: 'The following impostors are available in Babylon.js:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The box impostor: `BABYLON.PhysicsEngine.BoxImpostor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sphere impostor: `BABYLON.PhysicsEngine.SphereImpostor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plane impostor: `BABYLON.PhysicsEngine.PlaneImpostor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cylinder impostor: `BABYLON.PhysicsEngine.CylinderImpostor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, in Babylon.js, the box, plane, and cylinder impostors are the same
    according to the Cannon.js and Oimo.js plugins. It exists other kinds of physics
    bodies that are not yet supported (but maybe soon) in the physics engine of Babylon.js;
    for example, the soft bodies (such as a flag which is deformed due to the wind)
    and the liquid bodies (simulating the behavior of an object on a water surface
    according to its mass and the water's properties, such as clear or watery). Only
    rigid bodies are supported here at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the `impostor` parameter, the `options` parameter is the same.
    You can customize the physics state of a mesh by providing the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The mass**: This is the mass of the mesh in the world. The heavier the mesh
    is, the harder it is to stop its movement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The friction**: This represents the force opposed to the meshes in contact.
    In other words, this represents how the mesh is slippery. To give you an order,
    The value of the friction for the ice is equal to `1.0`. We can determine that
    the friction is in the  `[0, 1]` range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The restitution**: This represents how the mesh will bounce on others. Consider
    a ping-pong ball and its table; if the table''s material is a carpet, the restitution
    will be small. However, if the table''s material is a glass, the restitution will
    be maximum. A real interval for the restitution is in `[0, 1]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the example files, these parameters are set and if you play with them, you'll
    see that these three parameters are linked together in the physics equations.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a force to a mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At any moment, you can apply a new force or impulse to a configured mesh. Let's
    take an explosion for example, a box is located at the (`x = 0`, `y = 0`, and
    `z = 0`) coordinates and an explosion takes place above the box at the  (`x =
    0`, `y = -5`, and `z = 0`) coordinates. In real life, the box would be pushed
    up; this action is possible by calling a `applyImpulse(force, contactPoint)` function
    provided by the `BABYLON.Mesh` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the mesh is configured with its options and impostor, you can call this
    function at any moment to apply a force to the object. The parameters for this
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`force`: This represents the force in the x, y, and z axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact point`: This represents the origin of the force located in the `x`,
    `y`, and `z` axes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the explosion generates a force only on `y` (why not?), which
    is equal to `10` (`10` is an arbitrary value) and has its origin at the  (`x =
    0`, `y = -5`, and `z = 0`) coordinates, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once the impulse is applied to the mesh (only once), the box is pushed up and
    it will fall according to its physics parameters (mass, friction, and restitution).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring in Blender and 3ds Max
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going back to the 3D software such as Blender and 3ds Max that are used by the
    artists, it's also possible to configure collisions and physics simulations.
  prefs: []
  type: TYPE_NORMAL
- en: Collisions in Blender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from this scene, the collisions are easy to configure, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collisions in Blender](img/image_05_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For [Chapter 3](ch03.html "Chapter 3. Create, Load, and Draw 3D Objects on
    the Screen"), *Create, Load, and Draw 3D Objects on the Screen*, let''s zoom on
    the Babylon.js properties, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collisions in Blender](img/image_05_004.png)'
  prefs: []
  type: TYPE_IMG
- en: First, click on the options button (at the top) and for the selected object,
    which is the cube here, enable the collisions by checking the **Check Collisions** check
    box. For every mesh, check the checkbox to enable the collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s configure the camera in Blender. Select the camera in the scene,
    click on the camera''s options (at the top), and check the **Enable Collisions** and
    **Apply Gravity** check boxes if you want to apply gravity on your camera, as
    shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collisions in Blender](img/image_05_005.png)'
  prefs: []
  type: TYPE_IMG
- en: To configure the camera's ellipsoid, a `BABYLON.Vector3` dialog is available
    under the two check boxes. You can configure the `x`, `y`, and `z` values of the
    camera's ellipsoid in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you want to apply gravity to your camera, the last parameter to
    configure is the scene''s gravity. First, click on the scene menu (at the top)
    and modify the gravity values. In Blender, the `y` and `z` axes are switched,
    therefore, the `z`-axis of the gravity in Blender corresponds to the `y`-axis
    in Babylon.js, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collisions in Blender](img/image_05_006.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now export the Blender project and test it; the gravity will be applied
    and the camera will check the collisions on the cube and plane.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring physics simulations in Blender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As for the collisions system, you can configure the meshes in Blender in order
    to simulate physics. You''ll find the notions of impostor, mass, friction, and
    restitution, and all these parameters can be configured in Blender. Once you select
    a mesh, click on the physics options (at the top) and click on the **Rigid Body** button
    (only rigid bodies are supported), as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring physics simulations in Blender](img/image_05_007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on the button, more options will appear. Some of these options
    are relative to Blender; however, only some of them will interest us, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring physics simulations in Blender](img/image_05_008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll find the three parameters (options): the mass, friction, and bounciness
    (bounciness represents the restitution). In Blender, the impostor is called shape and
    you''ll find the same impostors: Box and Sphere.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring collisions in 3ds Max
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As for Blender, you can configure collisions in 3ds Max. To enable collisions
    on an object, simply open the Babylon properties of the mesh, as shown in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring collisions in 3ds Max](img/image_05_009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To enable collisions on the mesh, simply check the **Check collisions** check
    box, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring collisions in 3ds Max](img/image_05_010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As for Blender, you have to also configure the camera to check the collisions
    and apply gravity (or not). As for the mesh, open the Babylon properties of the
    camera and check the **Check collisions** and **Apply gravity** check boxes. You
    can also configure the camera''s ellipsoid on the `x`, `y`, and `z` axes in the
    same order, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring collisions in 3ds Max](img/image_05_011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, open the Babylon properties of the 3ds Max scene to configure the
    gravity if you want to apply gravity to the camera, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring collisions in 3ds Max](img/image_05_012.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring physics simulations in 3ds Max
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 3ds Max, the physics properties are located in the Babylon mesh properties
    in contrast to Blender. Simply select a mesh and open the Babylon properties.
    You''ll find the same notions of impostor, mass, friction, and restitution, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring physics simulations in 3ds Max](img/image_05_013.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are now ready to configure the collisions for your scene and simulate physics.
    Whether by code or by artists, you can understand the pipeline in order to make
    your scenes more alive. Don''t hesitate to manipulate the example files. There
    are three important functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createScene()`: This creates the meshes and materials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createCollisions()`: This configures the collisions on scene, camera, and
    meshes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createPhysics()`: This configures the physics properties of meshes and applies
    impulses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, it's time to make your scenes more alive by adding audio
    tracks to it. You'll be able to add sounds, spatialized or not, to your scenes
    whether by code or by artists with the help of the sound support in 3ds Max and
    Blender.
  prefs: []
  type: TYPE_NORMAL
