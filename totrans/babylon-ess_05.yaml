- en: Chapter 5. Create Collisions on Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。在对象上创建碰撞
- en: The previous chapters introduced the 3D programming basics and Babylon.js. You
    can easily create and customize your scenes using the materials and meshes provided
    by your designer as you now understand the complete workflow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了3D编程基础和Babylon.js。你现在理解了完整的流程，可以轻松地使用设计师提供的材料和网格创建和自定义你的场景。
- en: 'In this chapter, let''s play with the gameplay itself and create interactions
    with objects in the scene by creating collisions and physics simulations. Collisions
    are important to add realism to your scenes if you want to walk without crossing
    the walls. Moreover, to make the scenes more alive, let''s introduce the physics
    simulation with Babylon.js and finally, see how easy it is to integrate these
    two notions in your scenes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们来玩一下游戏本身，通过创建碰撞和物理模拟与场景中的对象进行交互。如果你想在场景中行走而不穿越墙壁，碰撞对于增加场景的真实感非常重要。此外，让我们通过Babylon.js引入物理模拟，并最终看看将这两个概念集成到场景中有多容易：
- en: Checking collisions in a scene
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查场景中的碰撞
- en: Simulatating physics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟物理
- en: Checking collisions in a scene
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查场景中的碰撞
- en: Starting from the concept, configuring and checking collisions in a scene can
    be done without mathematical notations. We all have the notion of gravity and
    ellipsoid, even if the *ellipsoid* word is not necessarily familiar.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念出发，配置和检查场景中的碰撞可以不使用数学符号。我们都有重力和椭球体的概念，即使“椭球体”这个词不一定熟悉。
- en: How collisions work in Babylon.js?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Babylon.js中碰撞是如何工作的？
- en: 'Let''s start with the following scene (a camera, light, plane, and box):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下场景开始（一个相机、光源、平面和盒子）：
- en: '![How collisions work in Babylon.js?](img/image_05_001-1024x496.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![在Babylon.js中碰撞是如何工作的？](img/image_05_001-1024x496.png)'
- en: The goal is to prevent the currently active camera of the scene from crossing
    the objects in the scene. In other words, we want the camera to stay above the
    plane and stop moving forward if it collides with the box.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是防止场景中当前活动的相机穿越场景中的对象。换句话说，我们希望相机保持在平面上方，并在与盒子碰撞时停止前进。
- en: 'To perform these actions, the collisions system provided by Babylon.js uses
    a **collider**. A collider can be represented by the `bounding box` of a simple
    object and it looks similar to the following image:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这些操作，Babylon.js提供的碰撞系统使用一个**碰撞器**。一个碰撞器可以用简单对象的`边界框`来表示，它看起来类似于以下图片：
- en: '![How collisions work in Babylon.js?](img/image_05_002-1024x492.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![在Babylon.js中碰撞是如何工作的？](img/image_05_002-1024x492.png)'
- en: For information, a bounding box simply represents the minimum and maximum positions
    of a mesh's vertices and it is computed automatically by Babylon.js.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了信息，边界框简单地表示网格顶点的最小和最大位置，并且由Babylon.js自动计算。
- en: As explained in [Chapter 3](ch03.html "Chapter 3. Create, Load, and Draw 3D
    Objects on the Screen"), *Create, Load, and Draw 3D Objects on the Screen*, the meshes
    are composed of vertices that are linked together using the index buffer to finally
    build triangles; to be precise, the collisions are based on these triangles and
    are automatically managed/computed by Babylon.js. This means that you have to
    do nothing that is particularly tricky to configure collisions with objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](ch03.html "第3章。在屏幕上创建、加载和绘制3D对象")中所述，“创建、加载和绘制3D对象在屏幕上”，网格由通过索引缓冲区连接在一起的顶点组成，最终构建成三角形；更确切地说，碰撞是基于这些三角形，并由Babylon.js自动管理/计算。这意味着你不需要做任何特别复杂的事情来配置对象的碰撞。
- en: To resume, all the collisions are based on the triangles of each mesh in order
    to determine whether the camera should be blocked or not.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，所有碰撞都是基于每个网格的三角形，以确定是否应该阻止相机。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll also see that the physics engines use the same kind of collider to simulate
    physics for simple meshes (bounding boxes).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到物理引擎使用相同类型的碰撞器来模拟简单网格（边界框）的物理。
- en: In this case, the complicated part is for the designer. They must optimize all
    their meshes to work well with the collisions. This means that they must split
    the big meshes into multiple or submeshes thanks to their 3D modeler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，复杂的工作在于设计师。他们必须优化所有网格以与碰撞良好配合。这意味着他们必须借助3D模型器将大网格分割成多个或子网格。
- en: In fact, when rendering the scene, the collision system of Babylon.js will test
    whether the collisions should be tested for each mesh in the scene according to
    the global position of the camera. This is how 3D engines tend to optimize collisions
    as the main problem is that the collisions are computed in the CPU side.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在渲染场景时，Babylon.js 的碰撞系统将根据相机的全局位置测试场景中每个网格是否应该进行碰撞测试。这就是 3D 引擎倾向于优化碰撞的原因，因为主要问题在于碰撞是在
    CPU 端计算的。
- en: For example, some 3D engines offer a way to configure collisions on meshes by
    giving a particular type of collision; even if the mesh is complex, you can choose
    whether you want to use a bounding box as collider (to save the CPU performances)
    or directly use the triangles of the mesh (realistic collisions).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一些 3D 引擎提供了一种通过提供特定类型的碰撞来配置网格碰撞的方法；即使网格很复杂，你也可以选择是否想要使用边界框作为碰撞体（以节省 CPU 性能）或直接使用网格的三角形（实现真实碰撞）。
- en: Configuring collisions in a scene
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置场景中的碰撞
- en: Let's practice with the Babylon.js collisions engine itself. You'll see that
    the engine is particularly well-hidden as you only have to enable checks on the
    scene and objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 Babylon.js 的碰撞引擎本身来练习。你会发现引擎特别隐藏，因为你只需要在场景和对象上启用检查。
- en: 'Firstly, configure the scene in order to enable the collisions and then wake
    the engine up. If the following property is `false`, all the next properties will
    be ignored by Babylon.js and the collisions engine will be in the *stand by* mode.
    Then, it''s easy to enable or disable the collisions in a scene without modifying
    more properties, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，配置场景以启用碰撞，然后唤醒引擎。如果以下属性为 `false`，则 Babylon.js 将忽略所有后续属性，并且碰撞引擎将处于 *待机* 模式。然后，可以很容易地在场景中启用或禁用碰撞，而无需修改更多属性，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, configure the camera to check the collisions. The collisions engine will
    check collisions for all the rendered cameras that have collisions enabled. Here,
    we have only one camera to configure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，配置相机以检查碰撞。碰撞引擎将检查所有已启用碰撞的渲染相机。在这里，我们只需要配置一个相机：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To finish, set the `.checkCollisions `property of each mesh to `true` to activate
    collisions (here, the plane and box), as shown in the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成，将每个网格的 `.checkCollisions` 属性设置为 `true` 以激活碰撞（这里指的是平面和盒子），如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, the collisions engine will check the collisions in the scene for the camera
    on both plane and box meshes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，碰撞引擎将检查场景中平面和盒子网格上的碰撞。
- en: 'You guessed right , if you want to enable collisions only on the plane and
    want the camera to move across the box, you''ll have to set the `.checkCollisions`
    property of the box to `false`, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想在平面上启用碰撞，并希望相机穿过盒子，你必须将盒子的 `.checkCollisions` 属性设置为 `false`，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Configure gravity and ellipsoid
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置重力和椭球体
- en: '**Gravity**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**重力**'
- en: In the previous section, the camera checks the collision on the plane and the
    box; however, this is not submitted to a famous force named **the gravity**. To
    enrich the collisions in your scene, you can apply the gravity force, for example,
    to go down from the stairs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，相机检查了平面和盒子的碰撞；然而，这并没有提交给一个著名的力，即 **重力**。为了丰富场景中的碰撞，你可以应用重力力，例如，从楼梯上下来。
- en: 'First, enable the gravity on the camera by setting the `.applyGravity` property
    to `true`, as shown in the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过将 `.applyGravity` 属性设置为 `true` 来在相机上启用重力，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, customize the gravity direction by setting `BABYLON.Vector3` to the
    `.gravity` property of your scene, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将 `BABYLON.Vector3` 设置为场景的 `.gravity` 属性来自定义重力方向，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Of course, the gravity in space should be as shown in the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，空间中的重力应该如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Don't hesitate to play with the values in order to adjust the gravity to your
    scene referential.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不要犹豫，尝试调整值以调整重力到你的场景参考系。
- en: '**Ellipsoid**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**椭球体**'
- en: The last parameter to enrich the collisions in your scene is the camera's ellipsoid.
    The ellipsoid represents the camera's dimensions in the scene. In other words,
    it adjusts the collisions according to the x, y, and z axes of the ellipsoid (an
    ellipsoid is represented by `BABYLON.Vector3`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是用来丰富场景中碰撞的相机椭球体。椭球体表示相机在场景中的尺寸。换句话说，它根据椭球体的 x、y 和 z 轴调整碰撞（椭球体由 `BABYLON.Vector3`
    表示）。
- en: 'For example, the camera must measure 1.8 m (y axis) and the minimum distance
    to collide with the x (sides) and z (forward) axes must be 1 m. Then, the ellipsoid
    must be (`x = 1`, `y = 1.8`, and `z = 1`). Simply, set the  `.ellipsoid` property
    of the camera, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，相机必须测量 1.8 米（y 轴）并且与 x（侧面）和 z（前方）轴的最小碰撞距离必须是 1 米。然后，椭球体必须设置为（`x = 1`，`y =
    1.8`，和 `z = 1`）。简单来说，设置相机的 `.ellipsoid` 属性，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default value of the camera's ellipsoids is (`x = 0.5`, `y = 1.0`, and `z
    = 0.5`)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的椭球体的默认值是（`x = 0.5`，`y = 1.0`，和 `z = 0.5`）
- en: As for the gravity, don't hesitate to adjust the `x`, `y`, and `z` according
    to your scene scale.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 至于重力，不要犹豫，根据场景的比例调整 `x`、`y` 和 `z`。
- en: Simulate physics
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟物理
- en: Physics simulation is pretty different from the collisions system since it does
    not occur on the cameras but on the objects of the scene itself. In other words,
    if physics is enabled (and configured) on a box, the box will interact with other
    meshes in the scene and try to represent the real physical movements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 物理模拟与碰撞系统有很大不同，因为它不是发生在相机上，而是发生在场景本身的物体上。换句话说，如果一个盒子启用了（并且配置了）物理，那么这个盒子将会与场景中的其他网格交互，并尝试表示真实的物理运动。
- en: For example, let's take a sphere in the air. If you apply physics to the sphere,
    the sphere will fall until it collides with another mesh and according to the
    given parameters, it will bounce and roll in the scene.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个空中的球体。如果你将物理定律应用于球体，球体将会落下，直到它与另一个网格碰撞，根据给定的参数，它将在场景中弹跳和滚动。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The example files reproduce the behavior of a sphere that falls on the box in
    the middle of the scene.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例文件重现了场景中间的盒子上的球体落下的行为。
- en: Enable physics in Babylon.js
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Babylon.js 中启用物理
- en: 'In Babylon.js, physics simulations can be only done using plugins. Two plugins
    are available for use: the Cannon.js framework and the Oimo.js framework. These
    two frameworks are included in the Babylon.js GitHub repository in the `dist` folder.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Babylon.js 中，物理模拟只能通过插件来完成。目前有两个可用的插件：Cannon.js 框架和 Oimo.js 框架。这两个框架包含在 Babylon.js
    的 GitHub 仓库中的 `dist` 文件夹内。
- en: 'Each scene has its own physics simulations system and can be enabled by the
    following lines:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景都有自己的物理模拟系统，可以通过以下行来启用：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The  `.enablePhysics(gravity, plugin)` function takes the following two arguments:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`.enablePhysics(gravity, plugin)` 函数接受以下两个参数：'
- en: The gravity force of the scene to apply on objects
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景中作用在对象上的重力力
- en: 'The plugin to use:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用的插件：
- en: Oimo.js: `new BABYLON.OimoJSPlugin()`
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Oimo.js: `new BABYLON.OimoJSPlugin()`'
- en: Cannon.js: `new BABYLON.CannonJSPlugin()`
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cannon.js: `new BABYLON.CannonJSPlugin()`'
- en: 'To disable physics in a scene, simply call the `.disablePhysicsEngine()` function,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在场景中禁用物理，只需调用 `.disablePhysicsEngine()` 函数，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Impostors
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟器
- en: Once the physics simulations are enabled in a scene, you can configure the physics
    properties (or physics states) of the scene meshes. To configure the physics properties
    of a mesh, the `BABYLON.Mesh` class provides a `setPhysicsState(impostor, options)` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在场景中启用了物理模拟，就可以配置场景网格的物理属性（或物理状态）。要配置网格的物理属性，`BABYLON.Mesh` 类提供了一个 `setPhysicsState(impostor,
    options)` 函数。
- en: 'The parameters are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '`impostor`: Each kind of mesh has its own impostor according to its form. For
    example, a box will tend to slip while a sphere will roll. There are several types
    of impostors.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`impostor`：每种网格类型都有其对应的模拟器，根据其形状。例如，一个盒子可能会滑动，而一个球体会滚动。有几种类型的模拟器。'
- en: '`options`: These options define the values used in physics equations. It counts
    the mass, friction, and restitution.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这些选项定义了在物理方程中使用的值。包括质量、摩擦和恢复。'
- en: 'Let''s consider a box named `box` with a mass of `1` and set its physics properties,
    as shown in the following snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个质量为 `1` 的名为 `box` 的盒子，并设置其物理属性，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's all, the box is now configured to interact with other configured meshes
    by following the physics equations. Let's imagine that the box is in the air and
    will fall until it collides with another configured mesh.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了，现在盒子已经配置好了，可以通过物理方程与其它配置好的网格进行交互。让我们想象一下，盒子在空中，将会落下直到与另一个配置好的网格碰撞。
- en: 'Now, let''s take a sphere named `sphere` with a mass of `2` and set its physics
    properties, as shown in the following snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个质量为 `2` 的名为 `sphere` 的球体，并设置其物理属性，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You'll notice that the sphere, which is a particular kind of mesh, has its own
    impostor (`SphereImpostor`). In contrast to the box, the physics equations of
    the plugin will make the sphere roll, while the box will slip on other meshes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，球体，作为一种特殊的网格，有自己的模拟器（`SphereImpostor`）。与盒子相比，插件的物理方程将使球体滚动，而盒子将在其他网格上滑动。
- en: According to their masses, if the box and sphere collide, then the sphere will
    tend to push the box harder .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们的重量，如果盒子和球体相撞，那么球体将倾向于更强烈地推动盒子。
- en: 'The following impostors are available in Babylon.js:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Babylon.js 中可用的模拟器如下：
- en: 'The box impostor: `BABYLON.PhysicsEngine.BoxImpostor`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒子模拟器：`BABYLON.PhysicsEngine.BoxImpostor`
- en: 'The sphere impostor: `BABYLON.PhysicsEngine.SphereImpostor`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球体模拟器：`BABYLON.PhysicsEngine.SphereImpostor`
- en: 'The plane impostor: `BABYLON.PhysicsEngine.PlaneImpostor`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面模拟器：`BABYLON.PhysicsEngine.PlaneImpostor`
- en: 'The cylinder impostor: `BABYLON.PhysicsEngine.CylinderImpostor`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆柱形模拟器：`BABYLON.PhysicsEngine.CylinderImpostor`
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In fact, in Babylon.js, the box, plane, and cylinder impostors are the same
    according to the Cannon.js and Oimo.js plugins. It exists other kinds of physics
    bodies that are not yet supported (but maybe soon) in the physics engine of Babylon.js;
    for example, the soft bodies (such as a flag which is deformed due to the wind)
    and the liquid bodies (simulating the behavior of an object on a water surface
    according to its mass and the water's properties, such as clear or watery). Only
    rigid bodies are supported here at the moment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在 Babylon.js 中，根据 Cannon.js 和 Oimo.js 插件，盒子、平面和圆柱形模拟器是相同的。Babylon.js 的物理引擎中还存在其他尚未支持（但可能很快就会支持）的物理体类型；例如，软体（如因风而变形的旗帜）和流体体（根据物体的质量和水的特性，如清澈或水状，模拟物体在水表面的行为）。目前只支持刚体。
- en: 'Regardless of the `impostor` parameter, the `options` parameter is the same.
    You can customize the physics state of a mesh by providing the following parameters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 无论 `impostor` 参数如何，`options` 参数都是相同的。您可以通过提供以下参数来自定义网格的物理状态：
- en: '**The mass**: This is the mass of the mesh in the world. The heavier the mesh
    is, the harder it is to stop its movement.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**：这是网格在世界的质量。网格越重，停止其运动就越困难。'
- en: '**The friction**: This represents the force opposed to the meshes in contact.
    In other words, this represents how the mesh is slippery. To give you an order,
    The value of the friction for the ice is equal to `1.0`. We can determine that
    the friction is in the  `[0, 1]` range.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩擦系数**：这表示与网格接触的阻力。换句话说，这表示网格的滑溜程度。为了给您一个顺序，冰的摩擦系数等于 `1.0`。我们可以确定摩擦系数在 `[0,
    1]` 范围内。'
- en: '**The restitution**: This represents how the mesh will bounce on others. Consider
    a ping-pong ball and its table; if the table''s material is a carpet, the restitution
    will be small. However, if the table''s material is a glass, the restitution will
    be maximum. A real interval for the restitution is in `[0, 1]`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复系数**：这表示网格将如何反弹到其他物体上。考虑乒乓球及其桌面；如果桌面的材料是地毯，恢复系数将很小。然而，如果桌面的材料是玻璃，恢复系数将是最大的。恢复系数的实际范围是
    `[0, 1]`。'
- en: In the example files, these parameters are set and if you play with them, you'll
    see that these three parameters are linked together in the physics equations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例文件中，这些参数被设置，如果您玩弄它们，您会看到这三个参数在物理方程中相互关联。
- en: Applying a force to a mesh
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对网格施加力
- en: At any moment, you can apply a new force or impulse to a configured mesh. Let's
    take an explosion for example, a box is located at the (`x = 0`, `y = 0`, and
    `z = 0`) coordinates and an explosion takes place above the box at the  (`x =
    0`, `y = -5`, and `z = 0`) coordinates. In real life, the box would be pushed
    up; this action is possible by calling a `applyImpulse(force, contactPoint)` function
    provided by the `BABYLON.Mesh` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，您都可以向配置好的网格施加新的力或冲量。以爆炸为例，一个盒子位于坐标 (`x = 0`, `y = 0`, `z = 0`)，爆炸发生在盒子上方坐标
    (`x = 0`, `y = -5`, `z = 0`)。在现实生活中，盒子会被推上去；通过调用 `BABYLON.Mesh` 类提供的 `applyImpulse(force,
    contactPoint)` 函数，这个动作是可能的。
- en: 'Once the mesh is configured with its options and impostor, you can call this
    function at any moment to apply a force to the object. The parameters for this
    are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网格配置了其选项和模拟器，您就可以在任何时刻调用此函数来对对象施加力。此函数的参数如下：
- en: '`force`: This represents the force in the x, y, and z axes'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`force`：这表示 x、y 和 z 轴上的力'
- en: '`contact point`: This represents the origin of the force located in the `x`,
    `y`, and `z` axes.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`接触点`：这表示力在 x、y 和 z 轴上的起点。'
- en: 'For example, the explosion generates a force only on `y` (why not?), which
    is equal to `10` (`10` is an arbitrary value) and has its origin at the  (`x =
    0`, `y = -5`, and `z = 0`) coordinates, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，爆炸只在`y`轴上产生力（为什么不呢？），其值为`10`（`10`是一个任意值），并且其原点位于坐标（`x = 0`，`y = -5`，`z =
    0`），如下所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once the impulse is applied to the mesh (only once), the box is pushed up and
    it will fall according to its physics parameters (mass, friction, and restitution).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对网格应用了冲量（只应用一次），箱子将被推起，并会根据其物理参数（质量、摩擦和恢复）下落。
- en: Configuring in Blender and 3ds Max
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Blender中配置
- en: Going back to the 3D software such as Blender and 3ds Max that are used by the
    artists, it's also possible to configure collisions and physics simulations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 回到艺术家使用的3D软件，如Blender和3ds Max，也可以配置碰撞和物理模拟。
- en: Collisions in Blender
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blender中的碰撞
- en: 'Starting from this scene, the collisions are easy to configure, as shown in
    the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个场景开始，碰撞的配置变得容易，如下面的截图所示：
- en: '![Collisions in Blender](img/image_05_003.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Blender中的碰撞](img/image_05_003.png)'
- en: 'For [Chapter 3](ch03.html "Chapter 3. Create, Load, and Draw 3D Objects on
    the Screen"), *Create, Load, and Draw 3D Objects on the Screen*, let''s zoom on
    the Babylon.js properties, as shown in the following image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[第3章](ch03.html "第3章。在屏幕上创建、加载和绘制3D对象"), *在屏幕上创建、加载和绘制3D对象*，让我们聚焦于Babylon.js属性，如下面的图像所示：
- en: '![Collisions in Blender](img/image_05_004.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Blender中的碰撞](img/image_05_004.png)'
- en: First, click on the options button (at the top) and for the selected object,
    which is the cube here, enable the collisions by checking the **Check Collisions** check
    box. For every mesh, check the checkbox to enable the collisions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，点击选项按钮（在顶部），然后对于选中的对象，在这里是立方体，通过勾选**检查碰撞**复选框来启用碰撞。对于每个网格，勾选复选框以启用碰撞。
- en: 'Now, let''s configure the camera in Blender. Select the camera in the scene,
    click on the camera''s options (at the top), and check the **Enable Collisions** and
    **Apply Gravity** check boxes if you want to apply gravity on your camera, as
    shown in the following image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Blender中配置相机。在场景中选择相机，点击相机选项（在顶部），如果你想要应用重力，请勾选**启用碰撞**和**应用重力**复选框，如下面的图像所示：
- en: '![Collisions in Blender](img/image_05_005.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Blender中的碰撞](img/image_05_005.png)'
- en: To configure the camera's ellipsoid, a `BABYLON.Vector3` dialog is available
    under the two check boxes. You can configure the `x`, `y`, and `z` values of the
    camera's ellipsoid in the same order.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置相机的椭球体，两个复选框下方有一个`BABYLON.Vector3`对话框可用。你可以按照相同的顺序配置相机椭球的`x`、`y`和`z`值。
- en: 'Finally, if you want to apply gravity to your camera, the last parameter to
    configure is the scene''s gravity. First, click on the scene menu (at the top)
    and modify the gravity values. In Blender, the `y` and `z` axes are switched,
    therefore, the `z`-axis of the gravity in Blender corresponds to the `y`-axis
    in Babylon.js, as shown in the following image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想为相机应用重力，最后要配置的参数是场景的重力。首先，点击场景菜单（在顶部）并修改重力值。在Blender中，`y`轴和`z`轴是互换的，因此，Blender中重力的`z`轴对应于Babylon.js中的`y`轴，如下面的图像所示：
- en: '![Collisions in Blender](img/image_05_006.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Blender中的碰撞](img/image_05_006.png)'
- en: You can now export the Blender project and test it; the gravity will be applied
    and the camera will check the collisions on the cube and plane.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以导出Blender项目并测试它；重力将被应用，相机将检查立方体和平面的碰撞。
- en: Configuring physics simulations in Blender
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Blender中配置物理模拟
- en: 'As for the collisions system, you can configure the meshes in Blender in order
    to simulate physics. You''ll find the notions of impostor, mass, friction, and
    restitution, and all these parameters can be configured in Blender. Once you select
    a mesh, click on the physics options (at the top) and click on the **Rigid Body** button
    (only rigid bodies are supported), as shown in the following image:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 至于碰撞系统，你可以在Blender中配置网格以模拟物理。你会找到模拟者、质量、摩擦和恢复等概念，并且所有这些参数都可以在Blender中配置。一旦选择了一个网格，点击物理选项（在顶部）并点击**刚体**按钮（只支持刚体），如下面的图像所示：
- en: '![Configuring physics simulations in Blender](img/image_05_007.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![在Blender中配置物理模拟](img/image_05_007.png)'
- en: 'Once you click on the button, more options will appear. Some of these options
    are relative to Blender; however, only some of them will interest us, as shown
    in the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击按钮，将出现更多选项。其中一些选项与Blender相关；然而，只有其中一些会吸引我们的注意，如下所示：
- en: '![Configuring physics simulations in Blender](img/image_05_008.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![在Blender中配置物理模拟](img/image_05_008.png)'
- en: 'You''ll find the three parameters (options): the mass, friction, and bounciness
    (bounciness represents the restitution). In Blender, the impostor is called shape and
    you''ll find the same impostors: Box and Sphere.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您将找到三个参数（选项）：质量、摩擦和弹性（弹性表示恢复）。在Blender中，模拟者被称为形状，您将找到相同的模拟者：盒子和球体。
- en: Configuring collisions in 3ds Max
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在3ds Max中配置碰撞
- en: 'As for Blender, you can configure collisions in 3ds Max. To enable collisions
    on an object, simply open the Babylon properties of the mesh, as shown in the
    following image:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Blender，您也可以在3ds Max中配置碰撞。要启用对象的碰撞，只需打开网格的Babylon属性，如图所示：
- en: '![Configuring collisions in 3ds Max](img/image_05_009.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![在3ds Max中配置碰撞](img/image_05_009.png)'
- en: 'To enable collisions on the mesh, simply check the **Check collisions** check
    box, as shown in the following image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要在网格上启用碰撞，只需勾选以下图像所示的**检查碰撞**复选框：
- en: '![Configuring collisions in 3ds Max](img/image_05_010.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![在3ds Max中配置碰撞](img/image_05_010.png)'
- en: 'As for Blender, you have to also configure the camera to check the collisions
    and apply gravity (or not). As for the mesh, open the Babylon properties of the
    camera and check the **Check collisions** and **Apply gravity** check boxes. You
    can also configure the camera''s ellipsoid on the `x`, `y`, and `z` axes in the
    same order, as shown in the following image:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Blender，您还必须配置相机以检查碰撞并应用重力（或不应用）。对于网格，打开相机的Babylon属性并勾选**检查碰撞**和**应用重力**复选框。您还可以以相同的顺序在`x`、`y`和`z`轴上配置相机的椭球体，如图所示：
- en: '![Configuring collisions in 3ds Max](img/image_05_011.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![在3ds Max中配置碰撞](img/image_05_011.png)'
- en: 'Finally, open the Babylon properties of the 3ds Max scene to configure the
    gravity if you want to apply gravity to the camera, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开3ds Max场景的Babylon属性，以配置重力，如果您想将重力应用于相机，操作如下：
- en: '![Configuring collisions in 3ds Max](img/image_05_012.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![在3ds Max中配置碰撞](img/image_05_012.png)'
- en: Configuring physics simulations in 3ds Max
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在3ds Max中配置物理模拟
- en: 'In 3ds Max, the physics properties are located in the Babylon mesh properties
    in contrast to Blender. Simply select a mesh and open the Babylon properties.
    You''ll find the same notions of impostor, mass, friction, and restitution, as
    shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与Blender不同，在3ds Max中，物理属性位于Babylon网格属性中。只需选择一个网格并打开Babylon属性，您会发现与以下截图所示相同的概念：模拟者、质量、摩擦和恢复，如下所示：
- en: '![Configuring physics simulations in 3ds Max](img/image_05_013.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![在3ds Max中配置物理模拟](img/image_05_013.png)'
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'You are now ready to configure the collisions for your scene and simulate physics.
    Whether by code or by artists, you can understand the pipeline in order to make
    your scenes more alive. Don''t hesitate to manipulate the example files. There
    are three important functions, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以配置场景的碰撞并模拟物理。无论是通过代码还是通过艺术家，您都可以理解流程，以便使您的场景更加生动。不要犹豫去操作示例文件。有三个重要的函数，如下所示：
- en: '`createScene()`: This creates the meshes and materials'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createScene()`: 此函数创建网格和材质'
- en: '`createCollisions()`: This configures the collisions on scene, camera, and
    meshes'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createCollisions()`: 此函数配置场景、相机和网格上的碰撞'
- en: '`createPhysics()`: This configures the physics properties of meshes and applies
    impulses'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createPhysics()`: 此函数配置网格的物理属性并应用冲量'
- en: In the next chapter, it's time to make your scenes more alive by adding audio
    tracks to it. You'll be able to add sounds, spatialized or not, to your scenes
    whether by code or by artists with the help of the sound support in 3ds Max and
    Blender.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，是时候通过添加音频轨道使您的场景更加生动了。您可以通过代码或借助3ds Max和Blender中的声音支持，由艺术家帮助，为您的场景添加声音，无论是有空间化的还是无空间化的。
