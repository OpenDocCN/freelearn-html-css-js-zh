- en: Chapter 2. A Feed Reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first project, Task Manager, we explored some of the basics of Sencha
    Architect. We also covered some of the ways to store, edit, and display data in
    Sencha Touch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will explore three new areas:'
  prefs: []
  type: TYPE_NORMAL
- en: The NavigationView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading remote data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating complex layouts with Sencha XTemplate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter we will build an RSS reader to grab news feeds from a list
    of sites and display the contents of those feeds in a complex pattern of columns
    and rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Feed Reader](img/8901OS_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The newsreader will also build on the Sencha Touch `NavigationView` component
    to automate a number of helpful navigation elements for touch devices.
  prefs: []
  type: TYPE_NORMAL
- en: The basic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our basic application will start off much the same way as our previous application:'
  prefs: []
  type: TYPE_NORMAL
- en: A `NavigationView` component to hold all our view components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list to display feeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A store to hold the list data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model to describe the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A form to add items to the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will spend most of our time setting up `NavigationView` and a much briefer
    time covering the additional components, since these are very similar to what
    we did in [Chapter 1](ch01.html "Chapter 1. A Simple Task List"), *A Simple Task
    List*.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of NavigationView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. A Simple Task List"), *A Simple Task List*,
    we manually coded a Back button into our Details view. The Back button was hidden
    by default and only displayed when an item in the list was clicked on and the
    Details view appeared. The Back button returned our user to the main list of tasks
    and then hid itself until it was needed again.
  prefs: []
  type: TYPE_NORMAL
- en: In our new Feed Reader application, we will use `NavigationView`, which handles
    all of this functionality automatically. `NavigationView` functions similar to
    a card layout where a number of panels can be hidden or displayed based on the
    active item for the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, unlike a card layout, where the items are typically declared when
    the layout is created, `NavigationView` typically adds items dynamically using
    the `push()` function to add panels and other items for display. For example,
    let''s assume we have a `NavigationView` component called `MainView` that contains
    a list view with a list of items. We also have a details panel called `Details`.
    When the user clicks on an item in the list, we can call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code will push a copy of our Details view onto `NavigationView` (`MainView`).
    `NavigationView` will use an animation transition to slide the new Details panel
    into place, automatically create the Back button for us, and then set the title
    of our Navigation bar to `Something Cool`. It also handles all of the behind-the-scenes
    code for taking us back to our main list when the Back button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: This makes `NavigationView` a very handy component to serve as the foundation
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by creating a new Sencha Touch application in Sencha Architect.
    For this application we are going to target the iPad tablet sized screen. This
    will give us more room to create an interesting display. We will also show you
    how to adjust the screen for iPhone and mobile phone users on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Use the **Size** menu at the bottom of the design area to select iPad as our
    screen size and drag a **NavigationView** object from the toolbox onto the iPad
    image in our display area. In the **Config** section, set **userAlias** to **MainView**
    so that we can reference it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add a **List** view to **MainView** and give it a **Store**
    (with a **LocalStorage** proxy) and **Model**, just as we did in [Chapter 1](ch01.html
    "Chapter 1. A Simple Task List"), *A Simple Task List*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a model and configure it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `userClassName` to `Feed`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add three fields:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` as `int`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` as `string`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url` as `string`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, add the store and configure it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `LocalStorage` proxy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `userClassName` to `FeedStore`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `storeId` to `FeedStore`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `model` to `Feed`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally configure the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `title` to `Feed Bag`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `itemTpl` to `<div>{name}</div>`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `id` to `FeedList`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `store` to `FeedStore`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![An overview of NavigationView](img/8901OS_02_2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Adding the form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our form is pretty simple this time (and to add a bit of variety) we are
    going to use a sheet to display our form. The sheet can be set to slide in from
    the top, bottom, or sides of the screen. It can also be set to pop in from the
    center.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we do not want the sheet to be a child of our **MainView** container;
    we only want to create it when we need it, not when the application launches.
    To do this, we drag the **Sheet** object over to **Project Inspector** and drop
    it on the **Views** icon. This will create **Sheet** as a separate view from our
    **MainView** container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the sheet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `userClassName` to `AddSheet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `enter` to `top`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `exit` to `bottom`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `stretch` to `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `stretchY` to `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next we will add a **Form Panel** object to our sheet with the following items:
    a **Container**, two **Text Field,** and two **Button** objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The container is simply a place to give the user some instructions. Set the
    **html** attribute to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the two text fields as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For **Field 1**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `id` to `name`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `name` to `name`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `label` to `Name`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `margin` to `3 0 3 0`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For **Field 2**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `id` to `url`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `name` to `url`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `label` to `URL`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `margin` to `3 0 3 0`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure the two buttons like so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For **Button 1**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `id` to `SaveButton`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `text` to `Save`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `margin` to `10`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For **Button 2**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `id` to `CancelButton`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `text` to `Cancel`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `margin` to `10`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we need to add tap listeners for our two buttons. In the **Event** section
    of **Config** for each button, click on the **+** button and select **Basic Event
    Binding**. When the menu appears, choose **tap**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the form](img/8901OS_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the Cancel button, our tap function is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Inside the function, `this` refers to our Sheet view. The code travels down
    into the sheet to find the form and then clears out all the field values. The
    sheet then hides itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Save button works much the same way as the one from our previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We move down from the Sheet view (`this`) to get our form panel. We then get
    the values from our form and find our store. Next, a new Feed record is created
    using the model manager and populated with the values from our form. Finally,
    we add the record to the store, sync the store to save it, and then hide the sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a way to show the sheet for adding Feed items.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the navigation view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our **MainView** component, we need to add a **Navigation Bar** object to
    the **Config** section using the **+** button next to **Navigation Bar**. This
    navigation bar will display our Back button and our titles. It will also give
    us a place to put the Add button that will show our sheet for adding feed items.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to change any configuration options for the navigation bar,
    so just drag a new **Button** object onto it for our Add button. Set the button''s
    configuration like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `align` to `right`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `text` to `Add`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `id` to `addButton`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we need to add a tap event listener like we did with our other buttons.
    The code for our tap event needs to create a new instance of `AddSheet` and display
    it. It also has to do a bit of thinking before it creates the sheet to make sure
    that there is no sheet that is existing already.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is call `Ext.getCmp` to see if there is already an existing
    sheet. This is because we set up our Save and Cancel buttons to hide the sheet,
    which does not destroy it. It's still a part of the application (still in memory),
    but it is not being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: If we have used the Add button previously, then `Ext.getCmp` will return a valid
    component. This is what we are checking on line two with `!Ext.isDefined(sheet)`.
    If the sheet is not defined yet (not created), we use `Ext.create('MyApp.view.AddSheet');`
    to make our sheet and then add it to the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have a valid component for our sheet and then we can
    just call `sheet.show();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application should now be able to add and display new Feed items to the
    list. Test the application to make sure everything is in working order by using
    Safari to open the `app.html` file in the folder where your project is saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back to the navigation view](img/8901OS_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next we need to add the logic for our MainView navigation view that will allow
    us to display a nice layout page for each of our feeds.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a controller to the project by dragging it onto the **Controllers** section
    of **Project Inspector**. You can find it in **Toolbox** under **Behaviors**.
    Set the **userClassName** property of the controller to `FeedController`.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to add a **Reference** property in the controller for **mainView**.
    Click on the **Add** button next to **Reference** and set the **ref** property
    to **mainView** and **Selector** to **MainView** (the selector needs to match
    our **userAlias** instance for the main navigation view).
  prefs: []
  type: TYPE_NORMAL
- en: Adding this reference will allow us to easily grab our MainView navigation by
    calling `this.getMainView()` anywhere inside the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Wait, shouldn''t it be getmainView instead of getMainView?**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that should be pointed out in this example is that when the
    reference is created, Sencha automatically creates a "getter" function for the
    referenced component. Even though our reference has a lowercase `m`, the `getMainView`
    function changes this to uppercase, `M`. Given the case sensitive nature of JavaScript,
    this automatic case switch can lead to quite a bit of hair pulling and colorful
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our reference, we need to add an action to perform when the
    user taps on the list of feeds. Click on the **+** button next to **Actions**
    and set the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `controlQuery` to `#FeedList`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `targetType` to `Ext.dataview.List`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `fn` to `onListItemTap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `name` to `itemtap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we need to double-click on the **itemtap** action to bring up our code
    editor. This is the code that will be fired when the list is tapped. Notice that
    the function is already set up to pass us a number of useful items including the
    dataview itself and the record for the item the user tapped on. We will set this
    action to call another function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will pass along the record `name` and `url` to our new `createFeedDetailsView`
    function using `record.get()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at our **Code** view for the controller, it should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that Sencha has set up our `FeedController` function to extend the
    main `Ext.app.Contoller` component. This means it inherits all of the basic functions
    for the `Ext.app.Contoller` component.
  prefs: []
  type: TYPE_NORMAL
- en: In the `config` section, we see our reference set up in the `refs` section.
    The `controls` section tells the controller which component to listen to (`#FeedList`),
    which event to listen for (`itemtap`), and which function to call when the event
    happens (`onListItemTap`).
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do here is create the code for our `createFeedDetailsView`
    function. This code needs to use the URL to grab the RSS feed, create a new view,
    and push it onto the main navigation view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do that, there are a few things that we need to consider: how do
    we get the data from the remote source and how can we format it in an easy-to-use
    structure (JSON)?'
  prefs: []
  type: TYPE_NORMAL
- en: To answer these questions, we need to have a better understanding of how Sencha
    Touch communicates with external servers, and some of the limitations involved
    in these types of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the data from a remote source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For security reasons, JavaScript (and thus Sencha Touch) is not allowed to make
    AJAX requests to other domains. This means that if your application resides on
    `myCoolApp.com` and you make an AJAX request to the RSS feed at [boingboing.net](http://boingboing.net),
    it will be denied.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is the **Same Origin Policy**, which states that certain
    browser functions like cookies and AJAX requests can't be shared between different
    servers. The reasoning being that JavaScript executes within the browser on the
    end user's computer. This gives JavaScript some unique abilities to interact with
    the user without having to constantly be in contact with a web server. Once the
    web browser loads the initial JavaScript files, they are stored on the user's
    machine until the cache is cleared. This means the application can continue to
    function when offline.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we all know, with great power comes great responsibility. The ability
    to run remote code on a user's computer can lead to people doing very bad things.
    AJAX requests in particular are problematic because they can happen without any
    direct request from the user.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, cross-domain AJAX requests in JavaScript are a very bad idea.
    While it may be easy enough to determine that your own code has honorable intentions,
    unchecked code from another domain can be potentially hostile.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you would like to learn more about same origin policy, this Wikipedia article
    is a good place to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the JSONP proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can get around the same origin policy by using Sencha''s JSONP proxy component
    to send the request. This component injects `<script>` tags containing the proxy
    URL directly into the DOM to get around the cross-domain limitation. The script
    tag looks like a regular JavaScript embed tag, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The response gets included as if it were any other JavaScript include. The JSONP
    proxy uses the `callback` function (which is generated automatically) to process
    this data and send it back to the proxy. The one caveat here is that the response
    has to be in JSON in order for the `callback` function to correctly process it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A full explanation of cross-site scripting issues can be found here: [http://en.wikipedia.org/wiki/Cross-site_scripting](http://en.wikipedia.org/wiki/Cross-site_scripting)
    and an overview of the JSONP proxy component can be found here: [http://docs.sencha.com/touch/2-0/#!/api/Ext.data.proxy.JsonP](http://docs.sencha.com/touch/2-0/#!/api/Ext.data.proxy.JsonP).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to another issue that we will run into with RSS feeds: they
    are formatted in XML instead of JSON. Since we need the JSONP store for cross-site
    requests and a JSON-encoded response for our `callback` function to process, XML
    won''t work for us without a bit more fiddling.'
  prefs: []
  type: TYPE_NORMAL
- en: This basically gives us two options. The first option would be to use another
    programming language to write something that would make the proxy request for
    us. This would include languages such as PHP, Ruby, ASP, and Perl, which run on
    the local server along with our application and are not under the same security
    restrictions as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: A local proxy would receive the request from our store along with the variables
    and make a request to the remote server with our variables. The remote server
    would then send the request back to our local proxy that would then pass it back
    to the store in whatever format we need. This is a fine enough way to accomplish
    the task, but it is also overkill for our simple application. Don't worry, we
    will get to the overkill later on.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a second option called **YQL**, the **Yahoo** **Query** **Language**,
    which we will be using in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Yahoo Query Language (YQL)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Yahoo Query Language** (**YQL**) was developed as a way to search open
    data sources in a language similar to **Structured Query Language** (**SQL**),
    a standard language for dealing with database information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical SQL request might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This would grab all the records in the `users` table where the last name was
    `Scalzi`. The `*` character tells our query to grab all the data for the record.
  prefs: []
  type: TYPE_NORMAL
- en: 'A YQL request is similar in structure and might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This request would return the RSS feed data from [boingboing.net](http://boingboing.net).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'YQL has access to a tremendous number of open data sources. To read up on the
    sources and get a better idea of what is possible in YQL, go to: [http://developer.yahoo.com/yql/](http://developer.yahoo.com/yql/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can get information from our data source, we need to figure out
    how to have it sent in a format our Sencha Touch application can understand.
  prefs: []
  type: TYPE_NORMAL
- en: One of the bonuses we get with YQL is that our results can be set up to return
    in a number of different formats, including the JSON format we want for our application.
    Before we set up the YQL query for our application we should take a look at the
    actual JSON that gets returned from the query. We can do this using the YQL console.
  prefs: []
  type: TYPE_NORMAL
- en: The YQL console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The YQL console (located at: [http://developer.yahoo.com/yql/console/](http://developer.yahoo.com/yql/console/))
    offers an easy way to test the various YQL commands and immediately see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The YQL console](img/8901OS_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter the the query shown in the previous screenshot into the console, select
    JSON, and click on the **TEST** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get back the results as a large bundle of JSON starting with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `cbfunc` header is the callback function our JSONP store is going to use
    to process the response. We don't need to worry about this since the store deals
    with it automatically. The first piece of information we need is the `count` parameter
    listed inside the `query` array. We can reference this in our code as `query.count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further down in the results you will see the actual items we need to use for
    our dataview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since these results are nested down in the `query` array, we will need to tell
    the store to set our `rootProperty` property as `query.results.item`. This `item`
    array holds the 30 listings returned by our query.
  prefs: []
  type: TYPE_NORMAL
- en: When these items are part of the store we will have access to each of the individual
    pieces by name. For example, `title` from the previous code will give us `Minecraft
    heads to consoles` and `creator.content` will give us `Rob Beschizza`. All of
    this data will be accessible in the item template of our dataview.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to set up a data model to grab the pieces of information you
    are interested in. For our purposes, we will be using the following data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we need to map some of the more deeply nested items such as `encoded.content`
    and `creator.content`. This model will give us all of the data items we need for
    our view.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how it all fits together.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, back at the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you remember, back in our `FeedController` function we had a tap handler
    that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We now need to set up the `createFeedDetailsView` function and get it to create
    our data store for connecting to the YQL server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new function by clicking on the **+** button next to **functions**
    and setting the **Config** value for **fn** to `createFeedDetailsView`. Then add
    two **params**: `name` and `url`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the code editor, we want our function to grab the name and URL that we passed
    from our tap function and create a new data store. We will then load the store
    and use it to feed data into a new dataview. Lastly, we will push this new dataview
    onto our main navigation view for display.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first line sets up our URL to the main connection point for the YQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We then set up our variables using the format required by YQL. This includes
    a query string (`q`) and a format type for the return value, which will be JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we convert our variables into a Query String and add them to our URL
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a new dataview to our main navigation view. We will create
    the actual view in the next section, but for now we can in put the code to display
    it here like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This creates the `details` view using `MyApp.view.FeedDetails` (a view we will
    add a bit later) and set up the store for it with our `newURL` string that we
    created at the beginning of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Our `reader` configuration is set for `json` and the `rootProperty` and `totalProperty`
    configurations are set to the default values that get returned from the YQL server
    for each of those attributes. `rootProperty` tells the reader where to start looking
    for results and `totalProperty` tells the reader how many results we have gotten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we load our store and add the new dataview to our main navigation
    panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the store code in place, it's time to create the dataview for
    `MyApp.view.FeedDetails`, which is needed to display the feed data.
  prefs: []
  type: TYPE_NORMAL
- en: The details dataview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Sencha Touch, it's very easy to think of a dataview as just a fancy
    list. However, that tends to lock people into the list aspects of the dataview
    while ignoring the possibility of more complex layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a newspaper-style layout is a great use of a dataview. The layout
    is a collection of articles with titles, dates, authors, and content. However
    it sidesteps the standard concept of a list and replaces it with a more visually
    interesting layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The details dataview](img/8901OS_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A newspaper-style layout works well on a larger tablet-sized screen, but it
    would be difficult to read on a smaller phone screen. We need a way to change
    the layout of our application based on the user's device.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for us, not only does Sencha Touch understand the difference between
    devices, it also leverages the power of the HTML5 standard, which also understands
    different platforms and devices.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover how Sencha Touch manages the different devices in a later chapter.
    For now, we are going to use CSS media queries to load different style sheets
    based on the device. Before we get too deeply into that, we need to create the
    dataview and the XTemplate.
  prefs: []
  type: TYPE_NORMAL
- en: An **XTemplate** is basically an HTML template with a few extra bells and whistles.
    The XTemplate takes the data you supply and uses it to fill out the template by
    substituting any value in curly braces, with the corresponding value from your
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that you have an XTemplate that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the XTemplate will search your data for a variable called `name`
    and insert it into the template where we have `{name}`. You can use these curly
    braces to reference any of the fields in a data record.
  prefs: []
  type: TYPE_NORMAL
- en: The XTemplate also offers us the opportunity to add logic (the "if...then" statements,
    simple math, and more) to the HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create one for our dataview to see how it all fits together.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new dataview in Sencha Architect and set `userAlias` to `feeddetails`
    and `userClassName` to `FeedDetails`. Set the store configuration to use our `FeedItemStore`
    we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Next we need to create an `itemTpl` XTemplate. You should see a listing for
    **itemTpl** underneath the new **FeedDetails** dataview in the **Project Inspector**
    and if you select it, the **Code** editor will show the default **itemTpl** for
    editing.
  prefs: []
  type: TYPE_NORMAL
- en: Our `itemTpl` will need to account for any missing data in the RSS feed (RSS
    feeds are often missing things such as descriptions, icons, and other elements).
    We also need to translate the dates into something Sencha Touch understands, and
    we need to loop through some of the nested array elements returned by our YQL
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the full template first, and then we will go through the different
    sections to cover what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our first section looks to see if we have a thumbnail for the article using
    `<tpl if="thumbnail">`. If we do, then we style the article container with a class
    of `hasThumbnail`, if not, we just use the basic `<article>` tag. This will let
    us do different things with CSS depending on if we have the thumbnail or not.
  prefs: []
  type: TYPE_NORMAL
- en: Next we begin constructing our header section, creating a `<div>` tag with a
    class of `headline` that contains our `thumbnail` and `title` variables for the
    article. We also check to see if we have a `thumbnail` and then loop through the
    data for thumbnails (using `<tpl for="thumbnail">`) to gain access to the individual
    elements (`height`, `width`, `url`) in the `thumbnail` array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we close out the headline `div` tag and add our author/creator and the
    date to our template. RSS feeds can use either author or creator to refer to the
    person who wrote the article. We use `<tpl if="creator">` and `<tpl elseif="author">`
    to make sure we get one or the other if they are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then check to see if we have a date and convert it to a format we like using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have also wrapped the date inside an HTML5 `<time>` element,
    which provides contextual data to the browser, allowing features such as localization,
    visual timelines, and adding events to calendars. We set `datetime` to a format
    the browser understands, and then we set the displayed date and time to something
    a bit more user friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Next we format our description and content. The description is pretty straight
    forward, but the content is a slightly different matter.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the size of the device, we may not want to show the full content
    div, just the shorter description div. We can set our CSS to only show the `<div
    class="description">` or the `<div class="content">` block, depending on the device.
    However, the content element is also optional, so if we have no content we need
    to show the description in the `<div class="content">` block instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more complicated, the content returned by our YQL query is a
    nested array with two elements: a content definition link, which we can ignore,
    and the actual content that we want. To do this, we loop through the content and
    count the loops using the built-in `xindex` variable to add the second data element
    to our XTemplate (`{.}` is the current data element in the loop).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally we close out our XTemplate with a footer and a link to the original
    article.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at some other XTemplate options in later chapters, or you
    can see a full list of the options in the online documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.sencha.com/touch/2-0/#!/api/Ext.XTemplate](http://docs.sencha.com/touch/2-0/#!/api/Ext.XTemplate)'
  prefs: []
  type: TYPE_NORMAL
- en: And now, the CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our container currently exists, the display would not be very interesting.
    It's just simple blocks of data one after another. While this is fine for small
    devices such as phones, it's a bit dull for larger tablet displays.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to address this by creating these three separate CSS files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`feedbag.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feedbag-tablet-portrait.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feedback-tablet-landscape.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will link these files in our `app.html` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first file, `feedbag.css`, contains all of our default styles for colors,
    font sizes, and so on. It also contains the small phone screen styles, which only
    show our image and header in the list view.
  prefs: []
  type: TYPE_NORMAL
- en: 'This set of styles gets overridden by the next file, which contains our portrait
    styles for tablet computers (minimum device width: 700 px). This file uses the
    same styles from the previous file, but organizes our content into two columns
    of blocks. It also displays the description block in the list view.'
  prefs: []
  type: TYPE_NORMAL
- en: The last file is used for tablet devices in landscape orientation. As before,
    it will override some of the styles in the previous files to further enhance the
    layout. In this case, we will float all of the blocks and set them to different
    widths to give the layout a more organic feel.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than dig through the entire CSS file, we want to focus on the last file,
    as it is the most complex of the files—`feedback-tablet-landscape.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this CSS file, we will take a series of steps to get to this layout, starting
    from a grid of 12 items and modifying the widths and heights to give us a more
    fluid layout. Take a look at the following figure to see what we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![And now, the CSS](img/8901OS_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In `feedback-tablet-landscape.css` our first block of CSS looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can fit three blocks of content across the screen in landscape mode, so we
    set each item to a default width of 33 percent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next block of CSS uses the nth-of-type selector to change the sizes of
    some of our item blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This rather complicated looking CSS says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We are only looking at items tagged with `div.x-dataview-item` (which are our
    item blocks).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want `nth-of-type(12n+2)`, which in this case means that we are looking at
    everything in blocks of 12 items (`12n`). Of those 12 items, we want to apply
    this style to the second (`+2`) of those items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also want to do the same thing for the 8th member of our set of twelve (`nth-of-type(12n+8)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our two items, we want to set the width to 66 percent (twice our normal
    article width).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By dealing with these items in blocks of 12 we end up with a more random and
    natural feel to our layout, rather than if we had simply set every third item
    to a wider size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two styles ensure that we don''t end up with one or two items dangling
    off the end of our layout. First we give our last item in the list a width of
    99 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if our last item is the last in a row of three, we don''t want it
    to have a 99 percent width as this would push it down a row and make things look
    weird. It should just be the regular size (33 percent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `12n+7` (the seventh item and the twelfth) items are the only two items
    in our set of twelve that may end up as the last item in a row of three.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use `!important` in our CSS to make sure that our `width` definition overrides
    any other `width` values that might be applied by other (parent) classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also don''t want it to be 99 percent if it''s the last item in a row with
    only two items. In this case, the last item just needs to have a width of 66 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, just to give us a break in the vertical rhythm of the layout, we make
    the first item in the set of 12 be twice as tall as the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: While these types of CSS selectors can seem a bit daunting at first, they offer
    a wide range of layout options beyond the standard Sencha Touch options.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the other two style sheets, you'll see that the styles get much
    simpler. The `feedbag-tablet-portrait.css` file is a simple two-column layout,
    while the plain `feedbag.css` file is a one-column layout with description content
    blocks hidden, for small devices such as iPhones. It would be possible to further
    customize the layouts based on device, or screen pixel density, but we'll leave
    that as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the support files for this chapter, we have also added a details view called
    `FeedItem.js`, which is a simple panel that is called from the controller when
    an item in our dataview is clicked on. The panel is pushed onto the navigation
    view in the same way as our feed details view. The panel contains a simple XTemplate
    loaded from the record passed in the tap function. If you explore this code, you
    will also see that we added a bit of animation to make the transition slicker.
  prefs: []
  type: TYPE_NORMAL
- en: This type of application can easily be modified to serve as a mobile version
    for any website with an RSS feed. You can also use the additional data in the
    RSS feed to add more information to the display, or modify the look and feel through
    CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic application setup for the Feed Reader application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating data to use a remote data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential issues with making Ajax requests to a remote server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the YQL system to query data from the web and return it as JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a complex XTemplate for our dataview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CSS styles and selectors to create a visually interesting and adaptable
    dataview display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will take a look at using a compiled Sencha Touch application
    to take advantage of features that are beyond a standard web based application.
  prefs: []
  type: TYPE_NORMAL
