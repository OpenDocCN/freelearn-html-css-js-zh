<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Writing a Blog Application with Node.js and AngularJS</h1></div></div></div><p class="calibre7">In this chapter, we are going to build a blog application by using Node.js and AngularJS. Our system will support adding, editing, and removing articles, so there will be a control panel. The MongoDB or MySQL database will handle the storing of the information and the Express framework will be used as the site base. It will deliver the JavaScript, CSS, and the HTML to the end user, and will provide an API to access the database. We will use AngularJS to build the user interface and control the client-side logic in the administration page.</p><p class="calibre7">This chapter will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">AngularJS fundamentals</li><li class="listitem">Choosing and initializing a database</li><li class="listitem">Implementing the client-side part of an application with AngularJS</li></ul></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec24" class="calibre1"/>Exploring AngularJS</h1></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre8">AngularJS</strong></span><a id="id94" class="calibre1"/> is an open source, client-side JavaScript framework developed by <a id="id95" class="calibre1"/>Google. It's full of features and is really well documented. It has almost become a standard framework in the development of single-page applications. The official site of <a id="id96" class="calibre1"/>AngularJS, <a class="calibre1" href="http://angularjs.org">http://angularjs.org</a>, provides a well-structured documentation. As the framework is widely used, there is a lot of material in the form of articles and video tutorials. As a JavaScript library, it collaborates pretty well with Node.js. In this chapter, we will build a simple blog with a control panel.</p><p class="calibre7">Before we start developing our application, let's first take a look at the framework. AngularJS gives us very good control over the data on our page. We don't have to think about selecting elements from the DOM and filling them with values. Thankfully, due to the available data-binding, we may update the data in the JavaScript part and see the change in the HTML part. This is also true for the reverse. Once we change something in the HTML part, we get the new values in the JavaScript part. The framework has a powerful dependency injector. There <a id="id97" class="calibre1"/>are predefined classes in order to perform AJAX requests and manage routes.</p><p class="calibre7">You could also read <span class="strong"><em class="calibre9">Mastering Web Development with AngularJS</em></span> by Peter Bacon Darwin and Pawel Kozlowski, published by Packt Publishing.</p></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS">
<div class="book" title="Bootstrapping AngularJS applications"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec11" class="calibre1"/>Bootstrapping AngularJS applications</h2></div></div></div><p class="calibre7">To bootstrap an <a id="id98" class="calibre1"/>AngularJS application, we need to add the <code class="email">ng-app</code> attribute to some of our HTML tags. It is important that we pick the right one. Having <code class="email">ng-app</code> somewhere means that all the child nodes will be processed by the framework. It's common practice to put that attribute on the <code class="email">&lt;html&gt;</code> tag. In the following code, we have a simple HTML page containing ng-app:</p><div class="informalexample"><pre class="programlisting">&lt;html ng-app&gt;
    &lt;head&gt;
        &lt;script src="angular.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        ...
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">Very often, we will apply a value to the attribute. This will be a module name. We will do this while developing the control panel of our blog application. Having the freedom to place <code class="email">ng-app</code> wherever we want means that we can decide which part of our markup will be controlled by AngularJS. That's good, because if we have a giant HTML file, we really don't want to spend resources parsing the whole document. Of course, we may bootstrap our logic manually, and this is needed when we have more than one AngularJS application on the page.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS">
<div class="book" title="Using directives and controllers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec12" class="calibre1"/>Using directives and controllers</h2></div></div></div><p class="calibre7">In AngularJS, we can implement <a id="id99" class="calibre1"/>the Model-View-Controller pattern. The controller <a id="id100" class="calibre1"/>acts as glue between the data (model) and the user interface (view). In the context of the framework, the controller is just a simple function. For example, the following HTML code illustrates that a controller is just a simple function:</p><div class="informalexample"><pre class="programlisting">&lt;html ng-app&gt;
    &lt;head&gt;
        &lt;script src="angular.min.js"&gt;&lt;/script&gt;
        &lt;script src="HeaderController.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header ng-controller="HeaderController"&gt;
            &lt;h1&gt;{{title}}&lt;/h1&gt;
        &lt;/header&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">In <code class="email">&lt;head&gt;</code> of the page, we are adding the minified version of the library and <code class="email">HeaderController.js</code>; a file that will host the code of our controller. We also set an <code class="email">ng-controller</code> attribute in the HTML markup. The definition of the controller is as follows:</p><div class="informalexample"><pre class="programlisting">function HeaderController($scope) {
  $scope.title = "Hello world";
}</pre></div><p class="calibre7">Every controller has its <a id="id101" class="calibre1"/>own area of influence. That area is called the scope. In our <a id="id102" class="calibre1"/>case, <code class="email">HeaderController</code> defines the <code class="email">{{title}}</code> variable. AngularJS has a wonderful dependency-injection system. Thankfully, due to this mechanism, the <code class="email">$scope</code> argument is automatically initialized and passed to our function. The <code class="email">ng-controller</code> attribute is called the directive, that is, an attribute, which has meaning to AngularJS. There are a lot of directives that we can use. That's maybe one of the strongest points of the framework. We can implement complex logic directly inside our templates, for example, data binding, filtering, or modularity.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS">
<div class="book" title="Data binding"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec13" class="calibre1"/>Data binding</h2></div></div></div><p class="calibre7">Data binding<a id="id103" class="calibre1"/> is a <a id="id104" class="calibre1"/>process of automatically updating the view once the model is changed. As we mentioned earlier, we can change a variable in the JavaScript part of the application and the HTML part will be automatically updated. We don't have to create a reference to a DOM element or attach event listeners. Everything is handled by the framework. Let's continue and elaborate on the previous example, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;header ng-controller="HeaderController"&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;a href="#" ng-click="updateTitle()"&gt;change title&lt;/a&gt;
&lt;/header&gt;</pre></div><p class="calibre7">A link is added and it contains the <code class="email">ng-click</code> directive. The <code class="email">updateTitle</code> function is a function defined in the controller, as seen in the following code snippet:</p><div class="informalexample"><pre class="programlisting">function HeaderController($scope) {
  $scope.title = "Hello world";
  $scope.updateTitle = function() {
    $scope.title = "That's a new title.";
  }
}</pre></div><p class="calibre7">We don't care about the <a id="id105" class="calibre1"/>DOM element and where the <code class="email">{{title}}</code> variable is. We<a id="id106" class="calibre1"/> just change a property of <code class="email">$scope </code>and everything works. There are, of course, situations where we will have the <code class="email">&lt;input&gt;</code> fields and we want to bind their values. If that's the case, then the <code class="email">ng-model</code> directive can be used. We can see this as follows:</p><div class="informalexample"><pre class="programlisting">&lt;header ng-controller="HeaderController"&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;a href="#" ng-click="updateTitle()"&gt;change title&lt;/a&gt;
  &lt;input type="text" ng-model="title" /&gt;
&lt;/header&gt;</pre></div><p class="calibre7">The data in the input field is bound to the same <code class="email">title</code> variable. This time, we don't have to edit the controller. AngularJS automatically changes the content of the <code class="email">h1</code> tag.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS">
<div class="book" title="Encapsulating logic with modules"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch03lvl2sec14" class="calibre1"/>Encapsulating logic with modules</h2></div></div></div><p class="calibre7">It's great that we have <a id="id107" class="calibre1"/>controllers. However, it's not a good practice to place<a id="id108" class="calibre1"/> everything into globally defined <a id="id109" class="calibre1"/>functions. That's why it is good to use the module system. The following code shows how a module is defined:</p><div class="informalexample"><pre class="programlisting">angular.module('HeaderModule', []);</pre></div><p class="calibre7">The first parameter is the name of the module and the second one is an array with the module's dependencies. By dependencies, we mean other modules, services, or something custom that we can use inside the module. It should also be set as a value of the <code class="email">ng-app</code> directive. The code so far could be translated to the following code snippet:</p><div class="informalexample"><pre class="programlisting">angular.module('HeaderModule', [])
.controller('HeaderController', function($scope) {
  $scope.title = "Hello world";
  $scope.updateTitle = function() {
    $scope.title = "That's a new title.";
  }
});</pre></div><p class="calibre7">So, the first line defines a module. We can chain the different methods of the module and one of them is the <code class="email">controller</code> method. Following this approach, that is, putting our code inside a module, <a id="id110" class="calibre1"/>we will be encapsulating logic. This is a sign of <a id="id111" class="calibre1"/>good architecture. And of course, with a<a id="id112" class="calibre1"/> module, we have access to different features such as filters, custom directives, and custom services.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS">
<div class="book" title="Preparing data with filters"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec15" class="calibre1"/>Preparing data with filters</h2></div></div></div><p class="calibre7">The filters are very <a id="id113" class="calibre1"/>handy when we want to prepare our data, prior to be displayed to the user. Let's say, for example, that we need to mention our title in uppercase once it reaches a length of more than 20 characters:</p><div class="informalexample"><pre class="programlisting">angular.module('HeaderModule', [])
.filter('customuppercase', function() {
  return function(input) {
    if(input.length &gt; 20) {
      return input.toUpperCase();
    } else {
      return input;
    }
  };
})
.controller('HeaderController', function($scope) {
  $scope.title = "Hello world";
  $scope.updateTitle = function() {
    $scope.title = "That's a new title.";
  }
});</pre></div><p class="calibre7">That's the definition of the custom filter called <code class="email">customuppercase</code>. It receives the input and performs a simple check. What it returns, is what the user sees at the end. Here is how this filter could be used in HTML:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;{{title | customuppercase}}&lt;/h1&gt;</pre></div><p class="calibre7">Of course, we may add more than one filter per variable. There are some predefined filters to limit the length, such as the JavaScript to JSON conversion or, for example, date formatting.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS">
<div class="book" title="Dependency injection"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch03lvl2sec16" class="calibre1"/>Dependency injection</h2></div></div></div><p class="calibre7">Dependency management<a id="id114" class="calibre1"/> can be very tough sometimes. We may split <a id="id115" class="calibre1"/>everything into different modules/components. They have nicely written APIs and they are very well documented. However, very soon, we may realize that we need to create a lot of objects. Dependency injection solves this problem by providing what we need, on the fly. We already saw this in action. The <code class="email">$scope</code> parameter passed to our controller, is actually created by the <code class="email">injector</code> of AngularJS. To get something as a dependency, we need to define it somewhere and let the framework know about it. We do this as follows:</p><div class="informalexample"><pre class="programlisting">angular.module('HeaderModule', [])
.factory("Data", function() {
  return {
    getTitle: function() {
      return "A better title.";
    }
  }
})
.controller('HeaderController', function($scope, Data) {
  $scope.title = Data.getTitle();
  $scope.updateTitle = function() {
    $scope.title = "That's a new title.";
  }
});</pre></div><p class="calibre7">The <code class="email">Module</code> class has a method called <code class="email">factory</code>. It registers a new service that could later be used as a dependency. The function returns an object with only one method, <code class="email">getTitle</code>. Of course, the name of the service should match the name of the controller's parameter. Otherwise, AngularJS will not be able to find the dependency's source.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS">
<div class="book" title="The model in the context of AngularJS"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch03lvl2sec17" class="calibre1"/>The model in the context of AngularJS</h2></div></div></div><p class="calibre7">In the well known <a id="id116" class="calibre1"/>Model-View-Controller pattern, the model is the part that stores the data in the application. AngularJS doesn't have a specific workflow to define models. The <code class="email">$scope</code> variable could be considered a model. We keep the data in properties attached to the current scope. Later, we can use the <code class="email">ng-model</code> directive and bind a property to the DOM element. We already saw how this works in the previous sections. The framework may not provide the usual form of a model, but it's made like that so that we can write our own implementation. The fact that AngularJS works with plain JavaScript <a id="id117" class="calibre1"/>objects, makes this task easily doable.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Writing a Blog Application with Node.js and AngularJS">
<div class="book" title="Exploring AngularJS">
<div class="book" title="Final words on AngularJS"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch03lvl2sec18" class="calibre1"/>Final words on AngularJS</h2></div></div></div><p class="calibre7">AngularJS<a id="id118" class="calibre1"/> is one of the leading frameworks, not only because it is made by Google, but also because it's really flexible. We could use just a small piece of it or build a solid architecture using the giant collection of features.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Selecting and initializing the database"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec25" class="calibre1"/>Selecting and initializing the database</h1></div></div></div><p class="calibre7">To build a blog application, we need a <a id="id119" class="calibre1"/>database that will store the published articles. In most cases, the <a id="id120" class="calibre1"/>choice of the database depends on the current project. There are factors such as performance and scalability and we should keep them in mind. In order to have a better look at the possible solutions, we will have a look at the two of the most popular databases: <span class="strong"><strong class="calibre8">MongoDB</strong></span> <a id="id121" class="calibre1"/>and <a id="id122" class="calibre1"/>
<span class="strong"><strong class="calibre8">MySQL</strong></span>. The first one is a NoSQL type of database. According to the Wikipedia entry (<a class="calibre1" href="http://en.wikipedia.org/wiki/NoSQL">http://en.wikipedia.org/wiki/NoSQL</a>) on NoSQL databases:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre13"><span class="strong"><em class="calibre9">"A NoSQL or Not Only SQL database provides a mechanism for storage and retrieval of data that is modeled in means other than the tabular relations used in relational databases."</em></span></p></blockquote></div><p class="calibre7">In other words, it's simpler than a SQL database, and very often stores information in the key value type. Usually, such solutions are used when handling and storing large amounts of data. It is also a very popular approach when we need flexible schema or when we want to use JSON. It really depends on what kind of system we are building. In some cases, MySQL could be a better choice, while in some other cases, MongoDB. In our example blog, we're going to use both.</p><p class="calibre7">In order to do this, we will need a layer that connects to the database server and accepts queries. To make things a bit more interesting, we will create a module that has only one API, but can switch between the two database models.</p></div>

<div class="book" title="Selecting and initializing the database">
<div class="book" title="Using NoSQL with MongoDB"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec19" class="calibre1"/>Using NoSQL with MongoDB</h2></div></div></div><p class="calibre7">Let's start with <a id="id123" class="calibre1"/>MongoDB. Before we start storing information, we <a id="id124" class="calibre1"/>need a MongoDB server running. It can be downloaded from the official<a id="id125" class="calibre1"/> page of the database <a class="calibre1" href="https://www.mongodb.org/downloads">https://www.mongodb.org/downloads</a>.</p><p class="calibre7">We are not going to handle the communication with the database manually. There is a driver specifically developed for Node.js. It's called <code class="email">mongodb</code> and we should include it in our <code class="email">package.json</code> file. After successful installation via <code class="email">npm install</code>, the driver will be available in our scripts. We can check this as follows:</p><div class="informalexample"><pre class="programlisting">"dependencies": {
  "mongodb": "1.3.20"
}</pre></div><p class="calibre7">We will stick to the Model-View-Controller architecture and the database-related operations in a model called <code class="email">Articles</code>. We can see this as follows:</p><div class="informalexample"><pre class="programlisting">var crypto = require("crypto"),
    type = "mongodb",
    client = require('mongodb').MongoClient,
    mongodb_host = "127.0.0.1",
    mongodb_port = "27017",
    collection;
    
module.exports = function() {
    if(type == "mongodb") {
        return {
            add: function(data, callback) { ... },
            update: function(data, callback) { ... },
            get: function(callback) { ... },
            remove: function(id, callback) { ... }
        }
    } else {
        return {
            add: function(data, callback) { ... },
            update: function(data, callback) { ... },
            get: function(callback) { ... },
            remove: function(id, callback) { ... }
        }
    }
}</pre></div><p class="calibre7">It starts with defining a few dependencies and settings for the MongoDB connection. Line number one requires the <code class="email">crypto</code> module. We will use it to generate unique IDs for every article. The <code class="email">type</code> variable defines which database is currently accessed. The third line initializes the MongoDB driver. We will use it to communicate with the database server. After that, we set the host and port for the connection and at the end a global <code class="email">collection</code> variable, which will keep a reference to the collection with the articles. In MongoDB, the collections are<a id="id126" class="calibre1"/> similar to the tables in MySQL. The next logical step is to establish a database <a id="id127" class="calibre1"/>connection and perform the needed operations, as follows:</p><div class="informalexample"><pre class="programlisting">connection = 'mongodb://';
connection += mongodb_host + ':' + mongodb_port;
connection += '/blog-application';
client.connect(connection, function(err, database) {
  if(err) {
    throw new Error("Can't connect");
  } else {
    console.log("Connection to MongoDB server successful.");
      collection = database.collection('articles');
    }
}); </pre></div><p class="calibre7">We pass the host and the port, and the driver is doing everything else. Of course, it is a good practice to handle the error (if any) and throw an exception. In our case, this is especially needed because without the information in the database, the frontend has nothing to show. The rest of the module contains methods to add, edit, retrieve, and delete records:</p><div class="informalexample"><pre class="programlisting">return {
  add: function(data, callback) {
    var date = new Date();
    data.id = crypto.randomBytes(20).toString('hex');
    data.date = date.getFullYear() + "-" + date.getMonth() + "-" + date.getDate();
    collection.insert(data, {}, callback || function() {});
  },
  update: function(data, callback) {
    collection.update(
            {ID: data.id}, 
            data, 
            {}, 
            callback || function(){ }
        ); 
    },
    get: function(callback) {
        collection.find({}).toArray(callback);
    },
    remove: function(id, callback) {
        collection.findAndModify(
            {ID: id}, 
            [], 
            {}, 
            {remove: true}, 
            callback
        );
    }
}</pre></div><p class="calibre7">The <code class="email">add</code> and <code class="email">update</code> methods accept the <code class="email">data</code> parameter. That's a simple JavaScript object. For example, see the following code:</p><div class="informalexample"><pre class="programlisting">{
  title: "Blog post title",
  text: "Article's text here ..."
}</pre></div><p class="calibre7">The records are <a id="id128" class="calibre1"/>identified by an automatically generated unique <code class="email">id</code>. The <code class="email">update</code> method needs it in order to find out which record to edit. All the methods also <a id="id129" class="calibre1"/>have a callback. That's important, because the module is meant to be used as a black box, that is, we should be able to create an instance of it, operate with the data, and at the end continue with the rest of the application's logic.</p></div></div>

<div class="book" title="Selecting and initializing the database">
<div class="book" title="Using MySQL"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec20" class="calibre1"/>Using MySQL</h2></div></div></div><p class="calibre7">We're going to use an <a id="id130" class="calibre1"/>SQL type of database with MySQL. We will add a few more lines of code to the already working <code class="email">Articles.js</code> model. The idea is to have a class that supports the two databases like two different options. At the end, we should be able to switch from one to the other, by simply changing the value of a variable. Similar to MongoDB, we need to first install the database to be able use it. The <a id="id131" class="calibre1"/>official download page is <a class="calibre1" href="http://www.mysql.com/downloads">http://www.mysql.com/downloads</a>.</p><p class="calibre7">MySQL requires another Node.js module. It should be added again to the <code class="email">package.json</code> file. We can see the module as follows:</p><div class="informalexample"><pre class="programlisting">"dependencies": {
  "mongodb": "1.3.20",
  "mysql": "2.0.0"
}</pre></div><p class="calibre7">Similar to the <a id="id132" class="calibre1"/>MongoDB solution, we need to firstly connect to the server. To do so, we need to know the values of the <span class="strong"><strong class="calibre8">host</strong></span>, <span class="strong"><strong class="calibre8">username</strong></span>, and <span class="strong"><strong class="calibre8">password</strong></span> fields. And because the data is organized in databases, a name of the database. In MySQL, we put our data into different databases. So, the following code defines the needed variables:</p><div class="informalexample"><pre class="programlisting">var mysql = require('mysql'),
    mysql_host = "127.0.0.1",
    mysql_user = "root",
    mysql_password = "",
    mysql_database = "blog_application",
    connection;</pre></div><p class="calibre7">The previous example leaves the <span class="strong"><strong class="calibre8">password</strong></span> field empty but we should set the proper value of our system. The MySQL database requires us to define a table and its fields before we start saving data. So, the following code is a short dump of the table used in this chapter:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE IF NOT EXISTS `articles` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` longtext NOT NULL,
  `text` longtext NOT NULL,
  `date` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;</pre></div><p class="calibre7">Once we have a database and its table set, we can continue with the database connection, as follows:</p><div class="informalexample"><pre class="programlisting">connection = mysql.createConnection({
    host: mysql_host,
    user: mysql_user,
    password: mysql_password
});
connection.connect(function(err) {
    if(err) {
        throw new Error("Can't connect to MySQL.");
    } else {
        connection.query("USE " + mysql_database, function(err, rows, fields) {
            if(err) {
                throw new Error("Missing database.");
            } else {
                console.log("Successfully selected database.");
            }
        })
    }
});</pre></div><p class="calibre7">The driver provides a method to connect to the server and execute queries. The first executed query selects the database. If everything is ok, you should see <span class="strong"><strong class="calibre8">Successfully selected database</strong></span> as an output in your console. Half of the job is done. What we should do now is replicate the methods returned in the first MongoDB implementation. We need to do this because when we switch to the MySQL usage, the code using the class will not work. And by replicating them we mean that they should have the same names and should accept the same arguments. </p><p class="calibre7">If we do everything correctly, at the end our application will <a id="id133" class="calibre1"/>support two types of databases. And all we have to do is change the value of the <code class="email">type</code> variable:</p><div class="informalexample"><pre class="programlisting">return {
    add: function(data, callback) {
        var date = new Date();
        var query = "";
        query += "INSERT INTO articles (title, text, date) VALUES (";
        query += connection.escape(data.title) + ", ";
        query += connection.escape(data.text) + ", ";
        query += "'" + date.getFullYear() + "-" + date.getMonth() + "-" + date.getDate() + "'";
        query += ")";
        connection.query(query, callback);
    },
    update: function(data, callback) {
        var query = "UPDATE articles SET ";
        query += "title=" + connection.escape(data.title) + ", ";
        query += "text=" + connection.escape(data.text) + " ";
        query += "WHERE id='" + data.id + "'";
        connection.query(query, callback);
    },
    get: function(callback) {
        var query = "SELECT * FROM articles ORDER BY id DESC";
        connection.query(query, function(err, rows, fields) {
            if(err) {
                throw new Error("Error getting.");
            } else {
                callback(rows);
            }
        });
    },
    remove: function(id, callback) {
        var query = "DELETE FROM articles WHERE id='" + id + "'";
        connection.query(query, callback);
    }
}</pre></div><p class="calibre7">The code is a<a id="id134" class="calibre1"/> little longer than the one generated in the first MongoDB variant. That's because we needed to construct MySQL queries from the passed data. Keep in mind that we have to escape the information, which comes to the module. That's why we use <code class="email">connection.escape()</code>. With these lines of code, our model is completed. Now we can add, edit, remove, or get data. Let's continue with the part that shows the articles to our users.</p></div></div>
<div class="book" title="Developing the client side with Angular"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>Developing the client side with Angular</h1></div></div></div><p class="calibre7">Let's assume that there is <a id="id135" class="calibre1"/>some data in the database and we are ready to<a id="id136" class="calibre1"/> present it to the users. So far, we have only developed the model, which is the class that takes care of the access to the information. In the previous chapter of this book, we learned about Express. To simplify the process, we will use it again here. We need to first update the <code class="email">package.json</code> file and include that in the framework, as follows:</p><div class="informalexample"><pre class="programlisting">"dependencies": {
  "express": "3.4.6",
  "jade": "0.35.0",
  "mongodb": "1.3.20",
  "mysql": "2.0.0"
}</pre></div><p class="calibre7">We are also adding<span class="strong"><strong class="calibre8"> Jade</strong></span>, because we are going to use it as a template language. The writing of markup in plain HTML is not very efficient nowadays. By using the template engine, we can split the data and the HTML markup, which makes our application much better structured. Jade's syntax is kind of similar to HTML. We can write tags without the need to close them:</p><div class="informalexample"><pre class="programlisting">body
  p(class="paragraph", data-id="12").
    Sample text here
  footer
    a(href="#").
      my site</pre></div><p class="calibre7">The preceding code snippet is transformed to the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
  &lt;p data-id="12" class="paragraph"&gt;Sample text here&lt;/p&gt;
  &lt;footer&gt;&lt;a href="#"&gt;my site&lt;/a&gt;&lt;/footer&gt;
&lt;/body&gt;</pre></div><p class="calibre7">Jade relies on the indentation in the content to distinguish the tags.</p><p class="calibre7">Let's start with the <a id="id137" class="calibre1"/>project structure, as seen in the following<a id="id138" class="calibre1"/> screenshot:</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Developing the client side with Angular" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We placed our already written class, <code class="email">Articles.js</code>, inside the <code class="email">models</code> directory. The public directory will contain CSS styles, and all the necessary client-side JavaScript: the AngularJS library, the AngularJS router module, and our custom code.</p><p class="calibre7">We will skip some of the explanations about the following code, because we already covered that in the previous chapter. Our <code class="email">index.js</code> file looks as follows:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var app = express();
var articles = require("./models/Articles")();

app.set('views', __dirname + '/views');
app.set('view engine', 'jade');
app.use(express.static(__dirname + '/public'));

app.use(function(req, res, next) {
    req.articles = articles;
    next();
});

app.get('/api/get', require("./controllers/api/get"));
app.get('/', require("./controllers/index"));

app.listen(3000);
console.log('Listening on port 3000');</pre></div><p class="calibre7">At the beginning, <a id="id139" class="calibre1"/>we require the Express framework and our model. Maybe<a id="id140" class="calibre1"/> it's better to initialize the model inside the controller, but in our case this is not necessary. Just after that, we set up some basic options for Express and define our own middleware. It has only one job to do and that is to attach the model to the request object. We are doing this because the request object is passed to all the route handlers. In our case, these handlers are actually the controllers. So, <code class="email">Articles.js</code> becomes accessible everywhere via the <code class="email">req.articles</code> property. At the end of the script, we placed two routes. The second one catches the usual requests that come from the users. The first one, <code class="email">/api/get</code>, is a bit more interesting. We want to build our frontend on top of AngularJS. So, the data that  is stored in the database should not enter the Node.js part but on the client side where we use Google's framework. To make this possible, we will create routes/controllers to get, add, edit, and delete records. Everything will be controlled by HTTP requests performed by AngularJS. In other words, we need an API.</p><p class="calibre7">Before we start using Angular, let's take a look at the <code class="email">/controllers/api/get.js</code> controller:</p><div class="informalexample"><pre class="programlisting">module.exports = function(req, res, next) {
  req.articles.get(function(rows) {
    res.send(rows);
  });
}</pre></div><p class="calibre7">The main job is done by our model and the response is handled by Express. It's nice because if we pass a JavaScript object, as we did, (<code class="email">rows</code> is actually an array of objects) the framework sets the response headers automatically. To test the result, we could run the application with <code class="email">node index.js</code> and open <code class="email">http://localhost:3000/api/get</code>. If we don't have any records in the database, we will get an empty array. If not, the stored articles will be returned. So, that's the URL, which we should hit from within the AngularJS controller in order to get the information.</p><p class="calibre7">The code of the <code class="email">/controller/index.js</code> controller is also just a few lines. We can see the code as follows:</p><div class="informalexample"><pre class="programlisting">module.exports = function(req, res, next) {  
  res.render("list", { app: "" });
}</pre></div><p class="calibre7">It simply renders <a id="id141" class="calibre1"/>the list view, which is stored in the<code class="email"> list.jade</code> file. That <a id="id142" class="calibre1"/>file should be saved in the <code class="email">/views directory</code>. But before we see its code, we will check another file, which acts as a base for all the pages. Jade has a nice feature <a id="id143" class="calibre1"/>called<code class="email"> </code>
<span class="strong"><em class="calibre9">blocks</em></span>. We may define different partials and combine them into one template. The following is our<code class="email"> layout.jade</code> <code class="email">file</code>:</p><div class="informalexample"><pre class="programlisting">doctype html
html(ng-app="#{app}")
  head
    title Blog
    link(rel='stylesheet', href='/style.css')    
    script(src='/angular.min.js')
    script(src='/angular-route.min.js')
  body
    block content</pre></div><p class="calibre7">There is only one variable passed to this template, which is <code class="email">#{app}</code>. We will need it later to initialize the administration's module. The <code class="email">angular.min.js </code>and <code class="email">angular-route.min.js</code> files should be downloaded from the official AngularJS site, and placed in the <code class="email">/public</code> directory. The body of the page contains a block placeholder called<code class="email"> content,</code> which we will later fill with the list of the articles. The following is the <code class="email">list.jade</code> file:</p><div class="informalexample"><pre class="programlisting">extends layout
block content
  .container(ng-controller="BlogCtrl")
    section.articles
      article(ng-repeat="article in articles")
       h2 
         {{article.title}}
         br
          small published on {{article.date}}
        p {{article.text}}
  script(src='/blog.js')</pre></div><p class="calibre7">The two lines in the beginning combine both the templates into one page. The Express framework transforms the Jade template into HTML and serves it to the browser of the user. From there, the client-side JavaScript takes control. We are using the<code class="email"> ng-controller</code> directive saying that the <code class="email">div</code> element will be controlled by an AngularJS controller called <code class="email">BlogCtrl.</code> The same class should have variable,<code class="email"> articles</code>, filled with the information from the database<code class="email">.</code> <code class="email">ng-repeat</code> goes through the array and displays the content to the users<code class="email">.</code> The <code class="email">blog.js</code> class holds the code of the controller:</p><div class="informalexample"><pre class="programlisting">function BlogCtrl($scope, $http) {
  $scope.articles = [
    { title: "", text: "Loading ..."}
  ];
  $http({method: 'GET', url: '/api/get'})
  .success(function(data, status, headers, config) {
    $scope.articles = data;
    })
    .error(function(data, status, headers, config) {
      console.error("Error getting articles.");
  });
}</pre></div><p class="calibre7">The controller has <a id="id144" class="calibre1"/>two dependencies. The first one<code class="email">,</code> <code class="email">$scope,</code> points to the <a id="id145" class="calibre1"/>current view. Whatever we assign as a property there is available as a variable in our HTML markup. Initially, we add only one element, which doesn't have a title, but has text. It is shown to indicate that we are still loading the articles from the database. The second dependency,<code class="email"> $http</code>, provides an API in order to make HTTP requests. So, all we have to do is query<code class="email"> /api/get</code>, fetch the data, and pass it to the <code class="email">$scope</code> dependency. The rest is done by AngularJS and its magical two-way data binding. To make the application a little more interesting, we will add a search field, as follows:</p><div class="informalexample"><pre class="programlisting">// views/list.jade
header
  .search
    input(type="text", placeholder="type a filter here", ng-model="filterText")
  h1 Blog
  hr</pre></div><p class="calibre7">The <code class="email">ng-model</code> directive, binds the value of the input field to a variable inside our <code class="email">$scope</code> dependency. However, this time, we don't have to edit our controller and can simply apply the same variable as a filter to the<code class="email"> ng-repeat</code>:</p><div class="informalexample"><pre class="programlisting">article(ng-repeat="article in articles | filter:filterText")</pre></div><p class="calibre7">As a result, the articles shown will be filtered based on the user's input. Two simple additions, but<a id="id146" class="calibre1"/> something really valuable is on the page. The filters of <a id="id147" class="calibre1"/>AngularJS can be very powerful.</p></div>
<div class="book" title="Implementing a control panel"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec27" class="calibre1"/>Implementing a control panel</h1></div></div></div><p class="calibre7">The control panel <a id="id148" class="calibre1"/>is the place where we will manage the articles of the blog. Several things should be made in the backend before continuing with the user interface. They are as follows:</p><div class="informalexample"><pre class="programlisting">app.set("username", "admin");
app.set("password", "pass");
app.use(express.cookieParser('blog-application'));
app.use(express.session());</pre></div><p class="calibre7">The previous lines of code should be added to <code class="email">/index.js</code>. Our administration should be protected, so the first two lines define our credentials. We are using Express as data storage, simply creating key-value pairs. Later, if we need the username we can get it with <code class="email">app.get("username")</code>. The next two lines enable session support. We need that because of the login process.</p><p class="calibre7">We added a <a id="id149" class="calibre1"/>middleware, which attaches the articles to the <code class="email">request</code> object. We will do the same with the current user's status, as follows:</p><div class="informalexample"><pre class="programlisting">app.use(function(req, res, next) {
    if((
        req.session &amp;&amp; 
        req.session.admin === true
    ) || (
        req.body &amp;&amp;
        req.body.username === app.get("username") &amp;&amp;
        req.body.password === app.get("password")
    )) {
        req.logged = true;
        req.session.admin = true;
    };
    next();
});</pre></div><p class="calibre7">Our <code class="email">if</code> statement is a little long, but it tells us whether the user is logged in or not. The first part checks whether there is a session created and the second one checks whether the user submitted a form with the correct username and password. If these expressions are <code class="email">true</code>, then we attach a variable, <code class="email">logged</code>, to the<code class="email"> request</code> object and create a session that will be valid during the following requests.</p><p class="calibre7">There is only one thing that we need in the main application's file. A few routes that will handle the control panel operations. In the following code, we are defining them along with the needed route handler:</p><div class="informalexample"><pre class="programlisting">var protect = function(req, res, next) {
    if(req.logged) {
        next();
    } else {
        res.send(401, 'No Access.');
    }
}
app.post('/api/add', protect, require("./controllers/api/add"));
app.post('/api/edit', protect, require("./controllers/api/edit"));
app.post('/api/delete', protect , require("./controllers/api/delete"));
app.all('/admin', require("./controllers/admin"));</pre></div><p class="calibre7">The three <a id="id150" class="calibre1"/>routes, which start with <code class="email">/api</code>, will use the model <code class="email">Articles.js</code> to add, edit, and remove articles from the database. These operations should be protected. We will add a middleware function that takes care of this. If the <code class="email">req.logged</code> variable is not available, it simply responds with a <code class="email">401 - Unauthorized</code> status code. The last route, <code class="email">/admin</code>, is a little different because it shows a login form instead. The following is the controller to create new articles:</p><div class="informalexample"><pre class="programlisting">module.exports = function(req, res, next) {
  req.articles.add(req.body, function() {
    res.send({success: true});
  });
}</pre></div><p class="calibre7">We transfer most of the logic to the frontend, so again, there are just a few lines. What is interesting here is that we pass <code class="email">req.body</code> directly to the model. It actually contains the data submitted by the user. The following code, is how the <code class="email">req.articles.add</code> method looks for the MongoDB implementation:</p><div class="informalexample"><pre class="programlisting">add: function(data, callback) {
  data.ID = crypto.randomBytes(20).toString('hex');
  collection.insert(data, {}, callback || function() {});
}</pre></div><p class="calibre7">And the MySQL implementation is as follows:</p><div class="informalexample"><pre class="programlisting">add: function(data, callback) {
    var date = new Date();
    var query = "";
    query += "INSERT INTO articles (title, text, date) VALUES (";
    query += connection.escape(data.title) + ", ";
    query += connection.escape(data.text) + ", ";
    query += "'" + date.getFullYear() + "-" + date.getMonth() + "-" + date.getDate() + "'";
    query += ")";
    connection.query(query, callback);
}</pre></div><p class="calibre7">In both the <a id="id151" class="calibre1"/>cases, we need <code class="email">title</code> and <code class="email">text</code> in the passed data object. Thankfully, due to Express' <code class="email">bodyParser</code> middleware, this is what we have in the <code class="email">req.body</code> object. We can directly forward it to the model. The other route handlers are almost the same:</p><div class="informalexample"><pre class="programlisting">// api/edit.js
module.exports = function(req, res, next) {
  req.articles.update(req.body, function() {
    res.send({success: true});
  });
}</pre></div><p class="calibre7">What we changed is the method of the <code class="email">Articles.js</code> class. It is not <code class="email">add</code> but <code class="email">update</code>. The same technique is applied in the route to delete an article. We can see it as follows:</p><div class="informalexample"><pre class="programlisting">// api/delete.js
module.exports = function(req, res, next) {
  req.articles.remove(req.body.id, function() {
    res.send({success: true});
  });
}</pre></div><p class="calibre7">What we need <a id="id152" class="calibre1"/>for deletion is not the whole body of the request but only the unique ID of the record. Every API method sends <code class="email">{success: true}</code> as a response. While we are dealing with API requests, we should always return a response. Even if something goes wrong.</p><p class="calibre7">The last thing in the Node.js part, which we have to cover, is the controller responsible for the user interface of the administration panel, that is, the. <code class="email">/controllers/admin.js</code> file:</p><div class="informalexample"><pre class="programlisting">module.exports = function(req, res, next) {
  if(req.logged) {
    res.render("admin", { app: "admin" });
  } else {
    res.render("login", { app: "" });
  }
}</pre></div><p class="calibre7">There are two templates that are rendered: <code class="email">/views/admin.jade</code> and <code class="email">/views/login.jade</code>. Based on the variable, which we set in <code class="email">/index.js</code>, the script decides which one to show. If the user is not logged in, then a login form is sent to the browser, as follows:</p><div class="informalexample"><pre class="programlisting">extends layout
block content
  .container
    header
      h1 Administration
     hr
    section.articles
      article
        form(method="post", action="/admin")
        span Username:
        br
        input(type="text", name="username")
        br
        span Password:
        br
        input(type="password", name="password")
        br
        br
        input(type="submit", value="login")</pre></div><p class="calibre7">There is no <a id="id153" class="calibre1"/>AngularJS code here. All we have is the good old HTML form, which submits its data via POST to the same URL—<code class="email">/admin</code>. If the username and password are correct, the <code class="email">.logged</code> variable is set to <code class="email">true</code> and the controller renders the other template:</p><div class="informalexample"><pre class="programlisting">extends layout
block content
  .container
    header
      h1 Administration
      hr
      a(href="/") Public
      span  | 
      a(href="#/") List
      span  | 
      a(href="#/add") Add
    section(ng-view)
  script(src='/admin.js')</pre></div><p class="calibre7">The control panel needs several views to handle all the operations. AngularJS has a great router module, which works with hashtags-type URLs, that is, URLs such as <code class="email">/admin#/add</code>. The same module requires a placeholder for the different partials. In our case, this is a <code class="email">section</code> tag. The <code class="email">ng-view</code> attribute tells the framework that this is the element prepared for that logic. At the end of the template, we are adding an external file, which keeps the whole client-side JavaScript code that is needed by the control panel.</p><p class="calibre7">While the client-side part of the applications needs only loading of the articles, the control panel requires a lot more functionalities. It is good to use the modular system of AngularJS. We need the routes and views to change, so the <code class="email">ngRoute</code> module is needed as a dependency. This module is not added in the main <code class="email">angular.min.js</code> build. It is placed in the <code class="email">angular-route.min.js</code> file. The following code shows how our module starts:</p><div class="informalexample"><pre class="programlisting">var admin = angular.module('admin', ['ngRoute']);
admin.config(['$routeProvider', 
  function($routeProvider) {
    $routeProvider
    .when('/', {})
    .when('/add', {})
    .when('/edit/:id', {})
    .when('/delete/:id', {})
    .otherwise({
          redirectTo: '/'
      });
  }
]);</pre></div><p class="calibre7">We configured the router by mapping URLs to specific routes. At the moment, the routes are just empty objects, but we will fix that shortly. Every controller will need to make HTTP requests to the Node.js part of the application. It will be nice if we have such a service and use it all over our code. We can see an example as follows:</p><div class="informalexample"><pre class="programlisting">admin.factory('API', function($http) {
  var request = function(method, url) {
    return function(callback, data) {
      $http({method: method, url: url, data: data})
      .success(callback)
        .error(function(data, status, headers, config) {
          console.error("Error requesting '" + url + "'.");
      });
    }
  }
  return {
    get: request('GET', '/api/get'),
    add: request('POST', '/api/add'),
    edit: request('POST', '/api/edit'),
    remove: request('POST', '/api/delete')
  }
});</pre></div><p class="calibre7">One of the best things about AngularJS is that it works with plain JavaScript objects. There are no unnecessary abstractions and no extending or inheriting special classes. We are using the <code class="email">.factory</code> method to create a simple JavaScript object. It has four methods that can be called: <code class="email">get</code>, <code class="email">add</code>, <code class="email">edit</code>, and <code class="email">remove</code>. Each one of them calls a function, which is defined in the helper method <code class="email">request</code>. The service has only one dependency, <code class="email">$http</code>. We already know this <a id="id154" class="calibre1"/>module; it handles HTTP requests nicely. The URLs that we are going to query are the same ones that we defined in the Node.js part.</p><p class="calibre7">Now, let's create a controller that will show the articles currently stored in the database. First, we should replace the empty route object <code class="email">.when('/', {})</code> with the following object:</p><div class="informalexample"><pre class="programlisting">.when('/', {
  controller: 'ListCtrl',
  template: '\
    &lt;article ng-repeat="article in articles"&gt;\
      &lt;hr /&gt;\
      &lt;strong&gt;{{article.title}}&lt;/strong&gt;&lt;br /&gt;\
       (&lt;a href="#/edit/{{article.id}}"&gt;edit&lt;/a&gt;)\
       (&lt;a href="#/delete/{{article.id}}"&gt;remove&lt;/a&gt;)\
      &lt;/article&gt;\
  '
})</pre></div><p class="calibre7">The object has to contain a controller and a template. The template is nothing more than a few lines of HTML markup. It looks a bit like the template used to show the articles on the client side. The difference is the links used to edit and delete. JavaScript doesn't allow new lines in the string definitions. The backward slashes at the end of the lines prevent syntax errors, which will eventually be thrown by the browser. The following is the code for the controller. It is defined, again, in the module:</p><div class="informalexample"><pre class="programlisting">admin.controller('ListCtrl', function($scope, API) {
  API.get(function(articles) {
    $scope.articles = articles;
  });
});</pre></div><p class="calibre7">And here is the <a id="id155" class="calibre1"/>beauty of the AngularJS dependency injection. Our custom-defined service <code class="email">API</code> is automatically initialized and passed to the controller. The <code class="email">.get</code> method fetches the articles from the database. Later, we send the information to the current <code class="email">$scope</code> dependency and the two-way data binding does the rest. The articles are shown on the page.</p><p class="calibre7">The work with AngularJS is so easy that we could combine the controller to add and edit in one place. Let's store the route object in an external variable, as follows:</p><div class="informalexample"><pre class="programlisting">var AddEditRoute = {
  controller: 'AddEditCtrl',
    template: '\
      &lt;hr /&gt;\
      &lt;article&gt;\
        &lt;form&gt;\
       &lt;span&gt;Title&lt;/spna&gt;&lt;br /&gt;\
       &lt;input type="text" ng-model="article.title"/&gt;&lt;br /&gt;\
        &lt;span&gt;Text&lt;/spna&gt;&lt;br /&gt;\
        &lt;textarea rows="7" ng-model="article.text"&gt;&lt;/textarea&gt;\
        &lt;br /&gt;&lt;br /&gt;\
        &lt;button ng-click="save()"&gt;save&lt;/button&gt;\
        &lt;/form&gt;\
      &lt;/article&gt;\
  '
};</pre></div><p class="calibre7">And later, assign it to the both the routes, as follows:</p><div class="informalexample"><pre class="programlisting">.when('/add', AddEditRoute)
.when('/edit/:id', AddEditRoute)</pre></div><p class="calibre7">The template is just a <a id="id156" class="calibre1"/>form with the necessary fields and a button, which calls the <code class="email">save</code> method in the controller. Notice that we bound the input field and the text area to variables inside the <code class="email">$scope</code> dependency. This comes in handy because we don't need to access the DOM to get the values. We can see this as follows:</p><div class="informalexample"><pre class="programlisting">admin.controller(
  'AddEditCtrl', 
  function($scope, API, $location, $routeParams) {
    var editMode = $routeParams.id ? true : false;
    if(editMode) {
      API.get(function(articles) {
        articles.forEach(function(article) {
          if(article.id == $routeParams.id) {
            $scope.article = article;
          }
        });
      });
    }
    $scope.save = function() {
      API[editMode ? 'edit' : 'add'](function() {
        $location.path('/');
      }, $scope.article);	
    }
})</pre></div><p class="calibre7">The controller receives four dependencies. We already know about <code class="email">$scope</code> and <code class="email">API</code>. The <code class="email">$location</code> dependency is used when we want to change the current route, or, in other words, to forward the user to another view. The <code class="email">$routeParams</code> dependency is needed to fetch parameters from the URL. In our case, <code class="email">/edit/:id</code> is a route with a variable inside. Inside the code, the <code class="email">id</code> is available in <code class="email">$routeParams.id</code>. The adding and editing of articles uses the same form. So, with a simple check, we know what the user is currently doing. If the user is in the edit mode, then we fetch the article based on the provided <code class="email">id</code> and fill the form. Otherwise, the fields are empty and new records will be created.</p><p class="calibre7">The deletion of an article<a id="id157" class="calibre1"/> can be done by using a similar approach, which is adding a route object and defining a new controller. We can see the deletion as follows:</p><div class="informalexample"><pre class="programlisting">.when('/delete/:id', {
  controller: 'RemoveCtrl',
  template: ' '
})</pre></div><p class="calibre7">We don't need a template in this case. Once the article is deleted from the database, we will forward the user to the list page. We have to call the <code class="email">remove</code> method of the API. Here is how the <code class="email">RemoveCtrl</code> controller looks like:</p><div class="informalexample"><pre class="programlisting">admin.controller(
  'RemoveCtrl', 
  function($scope, $location, $routeParams, API) {
    API.remove(function() {
      $location.path('/');
    }, $routeParams);
  }
);</pre></div><p class="calibre7">The preceding code depicts same dependencies like in the previous controller. This time, we simply forward the <code class="email">$routeParams</code> dependency to the API. And because it is a plain JavaScript object, everything works as expected.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec28" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we built a simple blog by writing the backend of the application in Node.js. The module for database communication, which we wrote, can work with the MongoDB or MySQL database and store articles. The client-side part and the control panel of the blog were developed with AngularJS. We then defined a custom service using the built-in HTTP and routing mechanisms.</p><p class="calibre7">Node.js works well with AngularJS, mainly because both are written in JavaScript. We found out that AngularJS is built to support the developer. It removes all those boring tasks such as DOM element referencing, attaching event listeners, and so on. It's a great choice for the modern client-side coding stack.</p><p class="calibre7">In the next chapter, we will see how to program a real-time chat with Socket.IO, one of the popular solutions covering the WebSockets communication.</p></div></body></html>