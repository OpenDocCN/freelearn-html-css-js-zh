["```js\nconst vertices = [\n  -0.5,  0.5, 0,\n  -0.5, -0.5, 0,\n   0.5, -0.5, 0,\n   0.5,  0.5, 0\n];\n\nconst positionBuffer = gl.createBuffer();\n```", "```js\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n```", "```js\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n```", "```js\ngl.bindBuffer(gl.ARRAY_BUFFER, null);\n```", "```js\n// Set up the buffers for the square\nfunction initBuffers() {\n  /*\n    V0                    V3\n    (-0.5, 0.5, 0)        (0.5, 0.5, 0)\n    X---------------------X\n    |                     |\n    |                     |\n    |       (0, 0)        |\n    |                     |\n    |                     |\n    X---------------------X\n    V1                    V2\n    (-0.5, -0.5, 0)       (0.5, -0.5, 0)\n  */\n  const vertices = [\n    -0.5, 0.5, 0,\n    -0.5, -0.5, 0,\n    0.5, -0.5, 0,\n    0.5, 0.5, 0\n  ];\n\n  // Indices defined in counter-clockwise order\n  indices = [0, 1, 2, 0, 2, 3];\n\n  // Setting up the VBO\n  squareVertexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), \n   gl.STATIC_DRAW);\n\n  // Setting up the IBO\n  squareIndexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), \n   gl.STATIC_DRAW);\n\n  // Clean\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\ngl.bindBuffer(gl.ARRAY_BUFFER, myBuffer);\n```", "```js\ngl.vertexAttribPointer(index, size, type, normalize, stride, offset);\n```", "```js\ngl.drawArrays(mode, first, count)\n```", "```js\ngl.drawElements(mode, count, type, offset)\n```", "```js\n// Global variables that are set and used\n// across the application\nlet gl,\n  program,\n  squareVertexBuffer,\n  squareIndexBuffer,\n  indices;\n```", "```js\n// Given an id, extract the content's of a shader script\n// from the DOM and return the compiled shader\nfunction getShader(id) {\n  const script = document.getElementById(id);\n  const shaderString = script.text.trim();\n\n  // Assign shader depending on the type of shader\n  let shader;\n  if (script.type === 'x-shader/x-vertex') {\n    shader = gl.createShader(gl.VERTEX_SHADER);\n  }\n  else if (script.type === 'x-shader/x-fragment') {\n    shader = gl.createShader(gl.FRAGMENT_SHADER);\n  }\n  else {\n    return null;\n  }\n\n  // Compile the shader using the supplied shader code\n  gl.shaderSource(shader, shaderString);\n  gl.compileShader(shader);\n\n  // Ensure the shader is valid\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(gl.getShaderInfoLog(shader));\n    return null;\n  }\n\n  return shader;\n}\n```", "```js\n// Create a program with the appropriate vertex and fragment shaders\nfunction initProgram() {\n  const vertexShader = getShader('vertex-shader');\n  const fragmentShader = getShader('fragment-shader');\n\n  // Create a program\n  program = gl.createProgram();\n  // Attach the shaders to this program\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error('Could not initialize shaders');\n  }\n\n  // Use this program instance\n  gl.useProgram(program);\n  // We attach the location of these shader values to the program \n  // instance for easy access later in the code\n  program.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n}\n```", "```js\n// Set up the buffers for the square\nfunction initBuffers() {\n  /*\n    V0                    V3\n    (-0.5, 0.5, 0)        (0.5, 0.5, 0)\n    X---------------------X\n    |                     |\n    |                     |\n    |       (0, 0)        |\n    |                     |\n    |                     |\n    X---------------------X\n    V1                    V2\n    (-0.5, -0.5, 0)       (0.5, -0.5, 0)\n  */\n  const vertices = [\n    -0.5, 0.5, 0,\n    -0.5, -0.5, 0,\n    0.5, -0.5, 0,\n    0.5, 0.5, 0\n  ];\n\n  // Indices defined in counter-clockwise order\n  indices = [0, 1, 2, 0, 2, 3];\n\n  // Setting up the VBO\n  squareVertexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), \n   gl.STATIC_DRAW);\n\n  // Setting up the IBO\n  squareIndexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), \n   gl.STATIC_DRAW);\n\n  // Clean\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\n// We call draw to render to our canvas\nfunction draw() {\n  // Clear the scene\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n  // Use the buffers we've constructed\n  gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexBuffer);\n  gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, \n   false, 0, 0);\n  gl.enableVertexAttribArray(program.aVertexPosition);\n\n  // Bind IBO\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);\n\n  // Draw to the scene using triangle primitives\n  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, \n   0);\n\n  // Clean\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\n// Entry point to our application\nfunction init() {\n  // Retrieve the canvas\n  const canvas = utils.getCanvas('webgl-canvas');\n\n  // Set the canvas to the size of the screen\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n\n  // Retrieve a WebGL context\n  gl = utils.getGLContext(canvas);\n  // Set the clear color to be black\n  gl.clearColor(0, 0, 0, 1);\n\n  // Call the functions in an appropriate order\n  initProgram();\n  initBuffers();\n  draw();\n}\n```", "```js\n/*\n  V0                    V3\n  (-0.5, 0.5, 0)        (0.5, 0.5, 0)\n  X---------------------X\n  |                     |\n  |                     |\n  |       (0, 0)        |\n  |                     |\n  |                     |\n  X---------------------X\n  V1                    V2\n  (-0.5, -0.5, 0)       (0.5, -0.5, 0)\n*/\n```", "```js\n// Global variables that are set and used\n// across the application\nlet gl,\n  program,\n  squareVAO,\n  squareIndexBuffer,\n  indices;\n```", "```js\n// Set up the buffers for the square\nfunction initBuffers() {\n  /*\n    V0                    V3\n    (-0.5, 0.5, 0)        (0.5, 0.5, 0)\n    X---------------------X\n    |                     |\n    |                     |\n    |       (0, 0)        |\n    |                     |\n    |                     |\n    X---------------------X\n    V1                    V2\n    (-0.5, -0.5, 0)       (0.5, -0.5, 0)\n  */\n  const vertices = [\n    -0.5, 0.5, 0,\n    -0.5, -0.5, 0,\n    0.5, -0.5, 0,\n    0.5, 0.5, 0\n  ];\n\n  // Indices defined in counter-clockwise order\n  indices = [0, 1, 2, 0, 2, 3];\n\n // Create VAO instance\n  squareVAO = gl.createVertexArray();\n\n  // Bind it so we can work on it\n  gl.bindVertexArray(squareVAO);\n\n  const squareVertexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), \n   gl.STATIC_DRAW);\n\n  // Provide instructions for VAO to use data later in draw\n  gl.enableVertexAttribArray(program.aVertexPosition);\n  gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, \n   false, 0, 0); \n  // Setting up the IBO\n  squareIndexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), \n   gl.STATIC_DRAW);\n\n  // Clean\n gl.bindVertexArray(null);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\n// We call draw to render to our canvas\nfunction draw() {\n  // Clear the scene\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n // Bind the VAO\n  gl.bindVertexArray(squareVAO);\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);\n\n  // Draw to the scene using triangle primitives\n  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, \n   0);\n\n  // Clean\n gl.bindVertexArray(null);  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\ngl.drawElements(mode, count, type, offset)\n```", "```js\nfunction initBuffers() {\n  const vertices = [\n    -0.5, -0.5, 0,\n    -0.25, 0.5, 0,\n    0.0, -0.5, 0,\n    0.25, 0.5, 0,\n    0.5, -0.5, 0\n  ];\n\n  indices = [0, 1, 2, 0, 2, 3, 2, 3, 4];\n\n  // Create VAO\n  trapezoidVAO = gl.createVertexArray();\n\n  // Bind VAO\n  gl.bindVertexArray(trapezoidVAO);\n\n  const trapezoidVertexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, trapezoidVertexBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), \n   gl.STATIC_DRAW);\n  // Provide instructions to VAO\n  gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, \n   false, 0, 0);\n  gl.enableVertexAttribArray(program.aVertexPosition);\n\n  trapezoidIndexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trapezoidIndexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), \n   gl.STATIC_DRAW);\n\n  // Clean\n  gl.bindVertexArray(null);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\nlet gl,\n  canvas,\n  program,\n  indices,\n  trapezoidVAO,\n  trapezoidIndexBuffer,\n  // Global variable that captures the current rendering mode type\n renderingMode = 'TRIANGLES';\n```", "```js\nfunction draw() {\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n  // Bind VAO\n  gl.bindVertexArray(trapezoidVAO);\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trapezoidIndexBuffer);\n\n  // Depending on the rendering mode type, we will draw differently\n  switch (renderingMode) {\n    case 'TRIANGLES': {\n      indices = [0, 1, 2, 2, 3, 4];\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new \n       Uint16Array(indices), gl.STATIC_DRAW);\n      gl.drawElements(gl.TRIANGLES, indices.length, \n       gl.UNSIGNED_SHORT, \n       0);\n      break;\n    }\n    case 'LINES': {\n      indices = [1, 3, 0, 4, 1, 2, 2, 3];\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new \n       Uint16Array(indices), gl.STATIC_DRAW);\n      gl.drawElements(gl.LINES, indices.length, gl.UNSIGNED_SHORT, \n       0);\n      break;\n    }\n    case 'POINTS': {\n      indices = [1, 2, 3];\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new \n       Uint16Array(indices), gl.STATIC_DRAW);\n      gl.drawElements(gl.POINTS, indices.length, gl.UNSIGNED_SHORT, \n       0);\n      break;\n    }\n    case 'LINE_LOOP': {\n      indices = [2, 3, 4, 1, 0];\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new \n       Uint16Array(indices), gl.STATIC_DRAW);\n      gl.drawElements(gl.LINE_LOOP, indices.length, \n       gl.UNSIGNED_SHORT, 0);\n      break;\n    }\n    case 'LINE_STRIP': {\n      indices = [2, 3, 4, 1, 0];\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new \n       Uint16Array(indices), gl.STATIC_DRAW);\n      gl.drawElements(gl.LINE_STRIP, indices.length, \n       gl.UNSIGNED_SHORT, 0);\n      break;\n    }\n    case 'TRIANGLE_STRIP': {\n      indices = [0, 1, 2, 3, 4];\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new \n       Uint16Array(indices), gl.STATIC_DRAW);\n      gl.drawElements(gl.TRIANGLE_STRIP, indices.length, \n       gl.UNSIGNED_SHORT, 0);\n      break;\n    }\n    case 'TRIANGLE_FAN': {\n      indices = [0, 1, 2, 3, 4];\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new \n       Uint16Array(indices), gl.STATIC_DRAW);\n      gl.drawElements(gl.TRIANGLE_FAN, indices.length, \n       gl.UNSIGNED_SHORT, 0);\n      break;\n    }\n  }\n\n  // Clean\n  gl.bindVertexArray(null);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, trapezoidIndexBuffer);\n```", "```js\nfunction initBuffers() {\n  const vertices = [\n    1.5, 0, 0,\n    -1.5, 1, 0,\n    -1.5, 0.809017, 0.587785,\n    -1.5, 0.309017, 0.951057,\n    -1.5, -0.309017, 0.951057,\n    -1.5, -0.809017, 0.587785,\n    -1.5, -1, 0,\n    -1.5, -0.809017, -0.587785,\n    -1.5, -0.309017, -0.951057,\n    -1.5, 0.309017, -0.951057,\n    -1.5, 0.809017, -0.587785\n  ];\n\n  indices = [\n    0, 1, 2,\n    0, 2, 3,\n    0, 3, 4,\n    0, 4, 5,\n    0, 5, 6,\n    0, 6, 7,\n    0, 7, 8,\n    0, 8, 9,\n    0, 9, 10,\n    0, 10, 1\n  ];\n\n  // Create VAO\n  coneVAO = gl.createVertexArray();\n\n  // Bind VAO\n  gl.bindVertexArray(coneVAO);\n\n  const coneVertexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, coneVertexBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), \n   gl.STATIC_DRAW);\n\n  // Configure instructions\n  gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, \n   false, 0, 0);\n  gl.enableVertexAttribArray(program.aVertexPosition);\n\n  coneIndexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, coneIndexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), \n   gl.STATIC_DRAW);\n\n  // Set the global variables based on the parameter type\n  if (coneVertexBuffer === \n    gl.getParameter(gl.ARRAY_BUFFER_BINDING)) {\n    vboName = 'coneVertexBuffer';\n  }\n  if (coneIndexBuffer === \n    gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING)) {\n    iboName = 'coneIndexBuffer';\n  }\n\n  vboSize = gl.getBufferParameter(gl.ARRAY_BUFFER, gl.BUFFER_SIZE);\n  vboUsage = gl.getBufferParameter(gl.ARRAY_BUFFER, \n   gl.BUFFER_USAGE);\n\n  iboSize = gl.getBufferParameter(gl.ELEMENT_ARRAY_BUFFER, \n   gl.BUFFER_SIZE);\n  iboUsage = gl.getBufferParameter(gl.ELEMENT_ARRAY_BUFFER, \n   gl.BUFFER_USAGE);\n\n  try {\n    isVerticesVbo = gl.isBuffer(vertices);\n  }\n  catch (e) {\n    isVerticesVbo = false;\n  }\n\n  isConeVertexBufferVbo = gl.isBuffer(coneVertexBuffer);\n\n  // Clean\n  gl.bindVertexArray(null);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n}\n```", "```js\nfunction initBuffers() {\n  const vertices = [\n    1.5, 0, 0,\n    -1.5, 1, 0,\n    -1.5, 0.809017, 0.587785,\n    -1.5, 0.309017, 0.951057,\n    -1.5, -0.309017, 0.951057,\n    -1.5, -0.809017, 0.587785,\n    -1.5, -1, 0,\n    -1.5, -0.809017, -0.587785,\n    -1.5, -0.309017, -0.951057,\n    -1.5, 0.309017, -0.951057,\n    -1.5, 0.809017, -0.587785\n  ];\n\n  indices = [\n    0, 1, 2,\n    0, 2, 3,\n    0, 3, 4,\n    0, 4, 5,\n    0, 5, 6,\n    0, 6, 7,\n    0, 7, 8,\n    0, 8, 9,\n    0, 9, 10,\n    0, 10, 1\n  ];\n\n  // ...\n}\n```", "```js\n{\n  \"vertices\": [\n    1.5, 0, 0,\n    -1.5, 1, 0,\n    -1.5, 0.809017, 0.587785,\n    -1.5, 0.309017, 0.951057,\n    -1.5, -0.309017, 0.951057,\n    -1.5, -0.809017, 0.587785,\n    -1.5, -1, 0,\n    -1.5, -0.809017, -0.587785,\n    -1.5, -0.309017, -0.951057,\n    -1.5, 0.309017, -0.951057,\n    -1.5, 0.809017, -0.587785\n  ],\n  \"indices\": [\n    0, 1, 2,\n    0, 2, 3,\n    0, 3, 4,\n    0, 4, 5,\n    0, 5, 6,\n    0, 6, 7,\n    0, 7, 8,\n    0, 8, 9,\n    0, 9, 10,\n    0, 10, 1\n  ]\n}\n```", "```js\nconst model = { vertices: [0, 0, 0, 1, 1, 1], indices: [0, 1] };\n```", "```js\ntypeof(model); // outputs \"object\"\n```", "```js\nmodel.vertices // outputs the vertices\nmodel.indices // outputs the indices\n```", "```js\nconst text = JSON.stringify(model);\nalert(text);\n```", "```js\nconst model2 = JSON.parse(text);\ntypeof(model2); // outputs \"object\"\nmodel2.vertices; // outputs vertices\n```", "```js\n// Given a path to a file, load the assets asynchronously\nfunction load(filePath) {\n  // We return the promise so that, if needed, you can know when \n  // `load` has resolved\n  return fetch(filePath)\n  // Convert to a valid json\n  .then(res => res.json())\n  // Handle the parsed JSON data\n  .then(data => {\n    // Handle data\n  })\n  .catch(error => {\n    // Handle error\n  });\n}\n```", "```js\n// Given a path to a file, load the assets asynchronously\nfunction load(filePath) {\n  // We return the promise so that, if needed, you can know when\n  // `load` has resolved\n  return fetch(filePath)\n  // Convert to a valid json\n  .then(res => res.json())\n  // Handle the parsed JSON data\n  .then(data => {\n    model = data;\n\n    // Create VAO\n    vao = gl.createVertexArray();\n\n    // Bind VAO\n    gl.bindVertexArray(coneVAO);\n\n    const modelVertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, modelVertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new \n     Float32Array(model.vertices), gl.STATIC_DRAW);\n\n    // Configure instructions\n    gl.enableVertexAttribArray(program.aVertexPosition);\n    gl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, \n     false, 0, 0);\n\n    modelIndexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, modelIndexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new \n     Uint16Array(model.indices), gl.STATIC_DRAW);\n\n    // Clean\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  })\n  // Display into the console if there are any errors\n  .catch(console.error);\n}\n```", "```js\n--allow-file-access-from-files \n```", "```js\n'use strict';\n\n// A set of utility functions for /common operations across our \n// application\nconst utils = {\n\n  // Find and return a DOM element given an ID\n  getCanvas(id) {\n    // ...\n  },\n\n  // Given a canvas element, return the WebGL2 context\n  getGLContext(canvas) {\n    // ...\n  },\n\n  // Given a canvas element, expand it to the size of the window\n  // and ensure that it automatically resizes as the window changes\n  autoResizeCanvas(canvas) {\n    const expandFullScreen = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    };\n    expandFullScreen();\n    window.addEventListener('resize', expandFullScreen);\n  },\n\n  // Given a WebGL context and an id for a shader script,\n  // return a compiled shader\n  getShader(gl, id) {\n    const script = document.getElementById(id);\n    if (!script) {\n      return null;\n    }\n\n    const shaderString = script.text.trim();\n\n    let shader;\n    if (script.type === 'x-shader/x-vertex') {\n      shader = gl.createShader(gl.VERTEX_SHADER);\n    }\n    else if (script.type === 'x-shader/x-fragment') {\n      shader = gl.createShader(gl.FRAGMENT_SHADER);\n    }\n    else {\n      return null;\n    }\n\n    gl.shaderSource(shader, shaderString);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      console.error(gl.getShaderInfoLog(shader));\n      return null;\n    }\n\n    return shader;\n  }\n\n};\n```", "```js\nfunction init() {\n  const canvas = utils.getCanvas('webgl-canvas');\n // Handle automatic resizing\n utils.autoResizeCanvas(canvas);\n\n  // Retrieve a valid WebGL2 context\n  gl = utils.getGLContext(canvas);\n  gl.clearColor(0, 0, 0, 1);\n  gl.enable(gl.DEPTH_TEST);\n\n  initProgram();\n  // We are no longer blocking the render until `load` has \n  // resolved, as we're not returning a Promise.\n  load();\n  render();\n}\n```", "```js\nfunction initProgram() {\n // Retrieve shaders based on the shader script IDs\n  const vertexShader = utils.getShader(gl, 'vertex-shader');\n  const fragmentShader = utils.getShader(gl, 'fragment-shader');\n\n  program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error('Could not initialize shaders');\n  }\n\n  gl.useProgram(program);\n\n  program.aVertexPosition = gl.getAttribLocation(program, \n   'aVertexPosition');\n  program.uProjectionMatrix = gl.getUniformLocation(program, \n   'uProjectionMatrix');\n  program.uModelViewMatrix = gl.getUniformLocation(program, \n   'uModelViewMatrix');\n}\n```"]