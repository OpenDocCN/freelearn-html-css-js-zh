<html><head></head><body>
		<div id="_idContainer095">
			<h1 id="_idParaDest-368" class="chapter-number"><a id="_idTextAnchor376"/>14</h1>
			<h1 id="_idParaDest-369"><a id="_idTextAnchor377"/> Error Handling in Node.js</h1>
			<p>Node.js applications require solid and consistent control over errors. Most applications are built using many dependencies or heavily rely on asynchronous operations (network, disk, and so on), which makes error management <span class="No-Break">more complex.</span></p>
			<p>In this chapter, we will learn about the different types of errors that we can encounter in a Node.js application and how to handle them properly. We will also learn how to throw custom errors and how to capture and resume the application from any kind of error, including the ones that occur in <span class="No-Break">Express applications.</span></p>
			<p>We will also learn how to manage a graceful shutdown when the service crashes, how to use exit codes according to the situation, and how to prevent <span class="No-Break">zombie processes.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>How to throw <span class="No-Break">custom errors</span></li>
				<li>How to capture and recover from any kind <span class="No-Break">of error</span></li>
				<li>How to manage application and user errors <span class="No-Break">in Express</span></li>
				<li>How to manage a graceful shutdown when the <span class="No-Break">service crashes</span></li>
				<li>How to prevent <span class="No-Break">zombie processes</span></li>
				<li>How to use exit codes to indicate the reason why the application was <span class="No-Break">shut down</span></li>
			</ul>
			<h1 id="_idParaDest-370"><a id="_idTextAnchor378"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><span class="No-Break">.</span></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/VPXV1L1epIk"><span class="No-Break">https://youtu.be/VPXV1L1epIk</span></a></p>
			<h1 id="_idParaDest-371"><a id="_idTextAnchor379"/>Exploring the types of errors</h1>
			<p>As we learned in the first chapter, Node.js<a id="_idIndexMarker852"/> is a single-threaded application. This means that if an error occurs and we don’t properly handle it, the application will crash. This is why it is important to handle <span class="No-Break">errors properly.</span></p>
			<p>There are two main types of errors in Node.js: <strong class="bold">syntax</strong> errors and <span class="No-Break"><strong class="bold">runtime</strong></span><span class="No-Break"> errors.</span></p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor380"/>Syntax errors</h2>
			<p>Syntax errors are thrown<a id="_idIndexMarker853"/> when the code<a id="_idIndexMarker854"/> is parsed and it is not valid. These errors are thrown by the JavaScript engine, and they are usually easy to fix. Many IDEs and code editors can detect these errors and highlight them in the code editor, so you can fix them before running the application. In our case, we have been using StandardJS as a linter (which is a tool that helps us detect syntax errors and enforce a consistent code style) in <span class="No-Break">previous chapters.</span></p>
			<p>This is an example of a <span class="No-Break">syntax error:</span></p>
			<pre class="source-code">
executeThisFunction()</pre>			<p>The previous code will throw a <strong class="source-inline">ReferenceError</strong> error because the <strong class="source-inline">executeThisFunction</strong> function is not defined. This error can be easily fixed by defining <span class="No-Break">the function:</span></p>
			<pre class="console">
executeThisFunction()
ReferenceError: executeThisFunction is not defined
    at file:///file.js:1:1
    at ModuleJob.run (node:internal/modules/esm/module_job:192:25)
    at async DefaultModuleLoader.import (node:internal/modules/esm/loader:228:24)
    at async loadESM (node:internal/process/esm_loader:40:7)
    at async handleMainPromise (node:internal/modules/run_main:66:12)</pre>			<h2 id="_idParaDest-373"><a id="_idTextAnchor381"/>Runtime errors</h2>
			<p>Runtime errors are<a id="_idIndexMarker855"/> also known as <strong class="bold">operational</strong> errors. These errors<a id="_idIndexMarker856"/> are thrown when<a id="_idIndexMarker857"/> the application is running and are not related to the syntax of the code. These errors can be thrown by the application itself or by the dependencies that the application <span class="No-Break">is using.</span></p>
			<p>There are many ways to generate runtime errors, such as by accessing a property of an undefined object, calling a function that does not exist, trying to read a file that does not exist, trying to connect to a database that is not available, and trying to access a network resource that is <span class="No-Break">not available.</span></p>
			<p>As you can see, there are many ways to generate runtime errors. This is why it is important to handle them properly. If we don’t handle them, the application will crash and it will stop working. So, while coding the application, it is very important to keep in mind the possible runtime errors that can be thrown and how to <span class="No-Break">handle them.</span></p>
			<p>Some errors can be recovered and others not, depending on the type of error. For example, if we have a REST API application and the database is not available, we could recover from this error by returning a <strong class="source-inline">503</strong> HTTP status code and a message to the client. You will be always in charge of deciding whether the error can be recovered or not and how to <span class="No-Break">handle it.</span></p>
			<p>Now that we know the types of errors that can be thrown in Node.js applications, let’s see how to throw meaningful errors in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-374"><a id="_idTextAnchor382"/>Throwing meaningful errors</h1>
			<p>When an error occurs, it is important<a id="_idIndexMarker858"/> that it is meaningful. This means that the error should contain enough information to understand what happened and, potentially, how to <span class="No-Break">fix it.</span></p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor383"/>The error object</h2>
			<p>The error object is an instance<a id="_idIndexMarker859"/> of the <strong class="source-inline">Error</strong> class. This class has a constructor that accepts a message as a parameter. This message will be used to describe the error. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
const myError = new Error('This is an error message')
throw myError</pre>			<p>Here is the output of the <span class="No-Break">previous code:</span></p>
			<pre class="console">
file:///file.js:1
const myError = new Error('This is an error message')
                ^
Error: This is an error message
    at file:///file.js:1:17
    at ModuleJob.run (node:internal/modules/esm/module_job:192:25)
    at async DefaultModuleLoader.import (node:internal/modules/esm/loader:228:24)
    at async loadESM (node:internal/process/esm_loader:40:7)
    at async handleMainPromise (node:internal/modules/run_main:66:12)
Node.js v20.11.0</pre>			<p>As you can see, the error message is displayed in the output. This is the message that we passed to the constructor of the <strong class="source-inline">Error</strong> class. If you compare it with <strong class="source-inline">ReferenceError: executeThisFunction is not defined</strong>, we can see that the error message is not very descriptive and that we are using a generic <span class="No-Break">error class.</span></p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor384"/>Custom errors</h2>
			<p>You can create your own custom errors<a id="_idIndexMarker860"/> by extending the <strong class="source-inline">Error</strong> class. This is useful when you want to create your own <strong class="source-inline">Error</strong> classes and add more information to the error object. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
class NotEnoughSleep extends Error {
  constructor (message) {
    super(message)
    this.requireSleep = true
    this.isRecoverable = true
  }
}
throw new NotEnoughSleep('Looks like you need more sleep')</pre>			<p>If we run the previous code, we will get the <span class="No-Break">following output:</span></p>
			<pre class="console">
file:///file.js:9
  throw new NotEnoughSleep('Looks like you need more sleep')
NotEnoughSleep [Error]: Looks like you need more sleep
    at file:///file.js:9:9
    at ModuleJob.run (node:internal/modules/esm/module_job:192:25)
    at async DefaultModuleLoader.import (node:internal/modules/esm/loader:228:24)
    at async loadESM (node:internal/process/esm_loader:40:7)
    at async handleMainPromise (node:internal/modules/run_main:66:12) {
  requireSleep: true,
  isRecoverable: true
}</pre>			<p>As you can see, the error message <strong class="source-inline">Looks like you need more sleep</strong> is displayed in the output, as well as the class name, <strong class="source-inline">NotEnoughSleep</strong>. Additionally, we have added two properties to the error object: <strong class="source-inline">requireSleep</strong> and <strong class="source-inline">isRecoverable</strong>. These properties are created by us, and we can create as many as we need and be as specific as we want. These properties<a id="_idIndexMarker861"/> can be used to add more information to the error object, so we can handle the error properly using these properties in a <span class="No-Break"><strong class="source-inline">try</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">catch</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
try {
  throw new NotEnoughSleep("Looks like you need more sleep");
} catch (error) {
  if (error.isRecoverable) {
    console.log("You are lucky, because you can recover from this error");
  }
  if (error.requireSleep) {
    console.log("Please, go to sleep!");
  }
}</pre>			<p>Here is the output of the <span class="No-Break">previous code:</span></p>
			<pre class="console">
You are lucky, because you can recover from this error
Please, go to sleep!</pre>			<p>As you can see, we have used the <strong class="source-inline">isRecoverable</strong> and <strong class="source-inline">requireSleep</strong> properties to handle the error. This is a very simple example, but you can add more properties to the error object to handle<a id="_idIndexMarker862"/> the <span class="No-Break">error properly.</span></p>
			<p>In the next section, we are going to learn how to capture and recover from any kind of error while <span class="No-Break">using Express.</span></p>
			<h1 id="_idParaDest-377"><a id="_idTextAnchor385"/>Managing errors in Express</h1>
			<p>In the previous chapters, we learned<a id="_idIndexMarker863"/> how to create a REST API application using Express and we saw how to handle errors in Express applications, but in this section, we are going to refresh the concepts and <span class="No-Break">extend them.</span></p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor386"/>Error-handling middleware</h2>
			<p>Express has a built-in error-handling middleware<a id="_idIndexMarker864"/> that can be used to handle errors<a id="_idIndexMarker865"/> in a centralized way. This middleware is executed when an error occurs in the application. This middleware is executed after all the other middleware and routes have been executed. It is executed only when an error occurs, so it is important to add it at the end of the middleware chain, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
import express from 'express'
const app = express()
// Other middlewares...
app.use((err, req, res, next) =&gt; {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
// Route handler...</pre>			<h2 id="_idParaDest-379"><a id="_idTextAnchor387"/>Custom errors</h2>
			<p>If you are building a REST<a id="_idIndexMarker866"/> API application, you<a id="_idIndexMarker867"/> could add a property to the error object to indicate the HTTP status code that should be returned to the client. This way, you can handle the error properly in the error-handling middleware and return the proper HTTP status code to the client. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
class NotFoundError extends Error {
  constructor (message) {
    super(message)
    this.statusCode = 404
  }
}
try {
  throw new NotFoundError('The resource was not found')
} catch (error) {
  console.log(error.statusCode)
  res.status(error.statusCode).send(error.message)
}</pre>			<p>As you can see, we can use the <strong class="source-inline">statusCode</strong> property to return the proper HTTP status code to the client. This is a very simple example but you can add more properties to the error object to handle the <span class="No-Break">error properly.</span></p>
			<p>Now that we know how to handle errors, it is time to learn how to gracefully shut down the application when the application cannot recover from <span class="No-Break">an error.</span></p>
			<h1 id="_idParaDest-380"><a id="_idTextAnchor388"/>Gracefully shutting down the application</h1>
			<p>Throughout the book, we have learned<a id="_idIndexMarker868"/> how to handle errors using <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> blocks, error-first callbacks, <strong class="source-inline">catch</strong> for promises, and also events to handle errors but, sometimes, we need to handle <span class="No-Break">errors globally.</span></p>
			<p>Node.js provides a way to handle errors globally and gracefully shut down the application when an error occurs: using <strong class="source-inline">process.on()</strong>. You can also use <strong class="source-inline">process.exit()</strong> to exit the application with a specific exit code. This is useful in CI/CD pipelines, to indicate whether or not the application was shut down because of an error, and also in <span class="No-Break">productive environments.</span></p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor389"/>Events</h2>
			<p>There are many events<a id="_idIndexMarker869"/> that can be used<a id="_idIndexMarker870"/> to handle <span class="No-Break">errors globally:</span></p>
			<ul>
				<li><strong class="source-inline">uncaughtException</strong>: This event is emitted when an uncaught <span class="No-Break">exception occurs</span></li>
				<li><strong class="source-inline">unhandledRejection</strong>: This event is emitted when an unhandled <span class="No-Break">rejection occurs</span></li>
				<li><strong class="source-inline">exit</strong>: This event is emitted when the Node.js process is about <span class="No-Break">to exit</span></li>
				<li><strong class="source-inline">SIGINT</strong> and <strong class="source-inline">SIGTERM</strong>: These events are emitted when the Node.js process receives  <span class="No-Break">these signals</span></li>
			</ul>
			<p>Many other events can be used to handle errors globally but these are the most common ones. In the following example, we combine some scenarios to handle <span class="No-Break">errors globally:</span></p>
			<pre class="source-code">
const events = ['uncaughtException','unhandledRejection', 'exit', 'SIGINT'];
events.forEach(event =&gt; {
  process.on(event, (error) =&gt; {
    console.log(`This is an ${event} that we track!`)
  })
})
setTimeout(() =&gt; {
  throw new Error('Exception!')
}, 10000)
setTimeout(() =&gt; {
  Promise.reject(new Error('Rejection!'))
}, 20000)</pre>			<p>If you run the previous code, you will see<a id="_idIndexMarker871"/> that the application will be shut down<a id="_idIndexMarker872"/> after 20 seconds because of the unhandled rejection, but  the uncaught exception was eventually caught and the process continues running. Also, if you press <em class="italic">Ctrl</em> + <em class="italic">C</em> at any time, the application will be shut down because of the <span class="No-Break"><strong class="source-inline">SIGINT</strong></span><span class="No-Break"> signal.</span></p>
			<p>In the following example, we can see that the <strong class="source-inline">exit</strong> event is always triggered when we are closing the Node.js application. So, it is quite common to use this event to perform some actions before the application is <span class="No-Break">shut down:</span></p>
			<pre class="console">
This is an uncaughtException that we track!
This is an unhandledRejection that we track!
This is an exit that we track!</pre>			<p>Take into account that the <strong class="source-inline">exit</strong> event is not only triggered when an error occurs but also when the application is closed gracefully and does not support <span class="No-Break">asynchronous operations.</span></p>
			<p>In the next section, we will learn how to use exit codes to indicate the reason why the application was shut down. This is very useful in CI/CD pipelines to indicate whether the application was shut down because of an error <span class="No-Break">or not.</span></p>
			<h2 id="_idParaDest-382"><a id="_idTextAnchor390"/>Exit codes</h2>
			<p>Exit codes are used to indicate the reason<a id="_idIndexMarker873"/> that the application was shut down, as well as whether<a id="_idIndexMarker874"/> or not the application was shut down because of an error and whether the application was shut down gracefully <span class="No-Break">or not.</span></p>
			<p>If the exit code is <strong class="source-inline">0</strong>, it means that the application was shut down gracefully. If the exit code is different from <strong class="source-inline">0</strong>, it means that the application was shut down because of an error. By default, when there is nothing to do in the application, Node.js will exit with the exit code <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
			<p>By using <strong class="source-inline">process.exit()</strong>, we can indicate the exit code that we want to use. For example, if we want to indicate that the application was shut down because of an error, we can use <strong class="source-inline">process.exit(1)</strong>. If we want to indicate that the application was shut down gracefully, we can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">process.exit(0)</strong></span><span class="No-Break">.</span></p>
			<p>Some processes might finish correctly in terms of execution but use an error code. For example, when we run and complete application tests, if any test fails, the exit code will be different from <strong class="source-inline">0</strong>. That way, the execution output will be an error that can prevent CI from continuing to execute <span class="No-Break">the pipeline.</span></p>
			<p>In the next section, we will learn how to prevent zombie processes while using the process library to handle <span class="No-Break">errors globally.</span></p>
			<h2 id="_idParaDest-383"><a id="_idTextAnchor391"/>Avoiding zombie processes</h2>
			<p>I love zombie movies<a id="_idIndexMarker875"/> but I don’t like zombie<a id="_idIndexMarker876"/> processes. A zombie process is a process that is running in the background and is not doing anything. These kinds of processes eat resources from the host machine, and they can be a huge problem in certain scenarios such as <span class="No-Break">low-capability devices.</span></p>
			<p>Using <strong class="source-inline">process.on()</strong> can be dangerous because it can prevent the Node.js process from exiting. This is why it is important to use <strong class="source-inline">process.exit()</strong> to exit the application with a specific exit code <span class="No-Break">when needed.</span></p>
			<p>Let’s see an example. If we don’t use <strong class="source-inline">process.exit()</strong>, the application will not exit and it will be running forever, even if an error occurs while executing a function that is <span class="No-Break">not defined:</span></p>
			<pre class="source-code">
process.on('uncaughtException', (error) =&gt; {
  console.log('We are not going to exit the application!')
})
setInterval(() =&gt; {
    executeThisFunction()
}, 1000)</pre>			<p>This is shown in the <span class="No-Break">following output:</span></p>
			<pre class="console">
We are not going to exit the application!
We are not going to exit the application!
We are not going to exit the application!
We are not going to exit the application!
We are not going to exit the application!</pre>			<p>We can prevent that by adding <strong class="source-inline">process.exit()</strong> to exit the application with a specific <span class="No-Break">exit code:</span></p>
			<pre class="source-code">
process.on("uncaughtException", (error) =&gt; {
  console.log("Now, exit the application!");
  process.exit(1);
});
setInterval(() =&gt; {
  executeThisFunction();
}, 1000);</pre>			<p>The output will be <span class="No-Break">as follows:</span></p>
			<pre class="console">
Now, exit the application!</pre>			<p>As you can see, the application<a id="_idIndexMarker877"/> was shut down<a id="_idIndexMarker878"/> because we used <strong class="source-inline">process.exit()</strong> to exit the application with a specific exit code. If we don’t use <strong class="source-inline">process.exit()</strong>, the application will be running forever, making it a <span class="No-Break">zombie process.</span></p>
			<h1 id="_idParaDest-384"><a id="_idTextAnchor392"/>Summary</h1>
			<p>In this chapter, we learned about the types of errors that can be thrown in Node.js applications. We saw how to throw custom errors and how to capture and  recover from any kind <span class="No-Break">of error.</span></p>
			<p>Additionally, we reviewed how to manage application and user errors in Express. We also learned how to manage a graceful shutdown when the <span class="No-Break">service crashed.</span></p>
			<p>Finally, we learned how to prevent <span class="No-Break">zombie processes.</span></p>
			<p>In the next chapter, we are going to learn more about security, including how to protect our application by applying the best practices available and how to evaluate CVEs and <span class="No-Break">security vulnerabilities.</span></p>
			<h1 id="_idParaDest-385"><a id="_idTextAnchor393"/>Further reading</h1>
			<ul>
				<li><em class="italic">Express</em> | <em class="italic">Health Checks and Graceful </em><span class="No-Break"><em class="italic">Shutdown</em></span><span class="No-Break">: </span><a href="https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html"><span class="No-Break">https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html</span></a></li>
				<li><em class="italic">Express</em> | <em class="italic">Error </em><span class="No-Break"><em class="italic">Handling</em></span><span class="No-Break">: </span><a href="https://expressjs.com/en/guide/error-handling.html"><span class="No-Break">https://expressjs.com/en/guide/error-handling.html</span></a></li>
				<li>Node.js docs | <em class="italic">Error </em><span class="No-Break"><em class="italic">API</em></span><span class="No-Break">: </span><a href="https://nodejs.org/dist/latest-v20.x/docs/api/errors.html"><span class="No-Break">https://nodejs.org/dist/latest-v20.x/docs/api/errors.html</span></a></li>
				<li><em class="italic">Bash command line exit codes </em><span class="No-Break"><em class="italic">demystified</em></span><span class="No-Break">: </span><a href="https://www.redhat.com/sysadmin/exit-codes-demystified"><span class="No-Break">https://www.redhat.com/sysadmin/exit-codes-demystified</span></a></li>
			</ul>
		</div>
	</body></html>