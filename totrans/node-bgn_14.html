<html><head></head><body>
		<div><h1 id="_idParaDest-368" class="chapter-number"><a id="_idTextAnchor376"/>14</h1>
			<h1 id="_idParaDest-369"><a id="_idTextAnchor377"/> Error Handling in Node.js</h1>
			<p>Node.js applications require solid and consistent control over errors. Most applications are built using many dependencies or heavily rely on asynchronous operations (network, disk, and so on), which makes error management more complex.</p>
			<p>In this chapter, we will learn about the different types of errors that we can encounter in a Node.js application and how to handle them properly. We will also learn how to throw custom errors and how to capture and resume the application from any kind of error, including the ones that occur in Express applications.</p>
			<p>We will also learn how to manage a graceful shutdown when the service crashes, how to use exit codes according to the situation, and how to prevent zombie processes.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>How to throw custom errors</li>
				<li>How to capture and recover from any kind of error</li>
				<li>How to manage application and user errors in Express</li>
				<li>How to manage a graceful shutdown when the service crashes</li>
				<li>How to prevent zombie processes</li>
				<li>How to use exit codes to indicate the reason why the application was shut down</li>
			</ul>
			<h1 id="_idParaDest-370"><a id="_idTextAnchor378"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a>.</p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/VPXV1L1epIk">https://youtu.be/VPXV1L1epIk</a></p>
			<h1 id="_idParaDest-371"><a id="_idTextAnchor379"/>Exploring the types of errors</h1>
			<p>As we learned in the first chapter, Node.js<a id="_idIndexMarker852"/> is a single-threaded application. This means that if an error occurs and we don’t properly handle it, the application will crash. This is why it is important to handle errors properly.</p>
			<p>There are two main types of errors in Node.js: <strong class="bold">syntax</strong> errors and <strong class="bold">runtime</strong> errors.</p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor380"/>Syntax errors</h2>
			<p>Syntax errors are thrown<a id="_idIndexMarker853"/> when the code<a id="_idIndexMarker854"/> is parsed and it is not valid. These errors are thrown by the JavaScript engine, and they are usually easy to fix. Many IDEs and code editors can detect these errors and highlight them in the code editor, so you can fix them before running the application. In our case, we have been using StandardJS as a linter (which is a tool that helps us detect syntax errors and enforce a consistent code style) in previous chapters.</p>
			<p>This is an example of a syntax error:</p>
			<pre class="source-code">
executeThisFunction()</pre>			<p>The previous code will throw a <code>ReferenceError</code> error because the <code>executeThisFunction</code> function is not defined. This error can be easily fixed by defining the function:</p>
			<pre class="console">
executeThisFunction()
ReferenceError: executeThisFunction is not defined
    at file:///file.js:1:1
    at ModuleJob.run (node:internal/modules/esm/module_job:192:25)
    at async DefaultModuleLoader.import (node:internal/modules/esm/loader:228:24)
    at async loadESM (node:internal/process/esm_loader:40:7)
    at async handleMainPromise (node:internal/modules/run_main:66:12)</pre>			<h2 id="_idParaDest-373"><a id="_idTextAnchor381"/>Runtime errors</h2>
			<p>Runtime errors are<a id="_idIndexMarker855"/> also known as <strong class="bold">operational</strong> errors. These errors<a id="_idIndexMarker856"/> are thrown when<a id="_idIndexMarker857"/> the application is running and are not related to the syntax of the code. These errors can be thrown by the application itself or by the dependencies that the application is using.</p>
			<p>There are many ways to generate runtime errors, such as by accessing a property of an undefined object, calling a function that does not exist, trying to read a file that does not exist, trying to connect to a database that is not available, and trying to access a network resource that is not available.</p>
			<p>As you can see, there are many ways to generate runtime errors. This is why it is important to handle them properly. If we don’t handle them, the application will crash and it will stop working. So, while coding the application, it is very important to keep in mind the possible runtime errors that can be thrown and how to handle them.</p>
			<p>Some errors can be recovered and others not, depending on the type of error. For example, if we have a REST API application and the database is not available, we could recover from this error by returning a <code>503</code> HTTP status code and a message to the client. You will be always in charge of deciding whether the error can be recovered or not and how to handle it.</p>
			<p>Now that we know the types of errors that can be thrown in Node.js applications, let’s see how to throw meaningful errors in the next section.</p>
			<h1 id="_idParaDest-374"><a id="_idTextAnchor382"/>Throwing meaningful errors</h1>
			<p>When an error occurs, it is important<a id="_idIndexMarker858"/> that it is meaningful. This means that the error should contain enough information to understand what happened and, potentially, how to fix it.</p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor383"/>The error object</h2>
			<p>The error object is an instance<a id="_idIndexMarker859"/> of the <code>Error</code> class. This class has a constructor that accepts a message as a parameter. This message will be used to describe the error. Here is an example:</p>
			<pre class="source-code">
const myError = new Error('This is an error message')
throw myError</pre>			<p>Here is the output of the previous code:</p>
			<pre class="console">
file:///file.js:1
const myError = new Error('This is an error message')
                ^
Error: This is an error message
    at file:///file.js:1:17
    at ModuleJob.run (node:internal/modules/esm/module_job:192:25)
    at async DefaultModuleLoader.import (node:internal/modules/esm/loader:228:24)
    at async loadESM (node:internal/process/esm_loader:40:7)
    at async handleMainPromise (node:internal/modules/run_main:66:12)
Node.js v20.11.0</pre>			<p>As you can see, the error message is displayed in the output. This is the message that we passed to the constructor of the <code>Error</code> class. If you compare it with <code>ReferenceError: executeThisFunction is not defined</code>, we can see that the error message is not very descriptive and that we are using a generic error class.</p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor384"/>Custom errors</h2>
			<p>You can create your own custom errors<a id="_idIndexMarker860"/> by extending the <code>Error</code> class. This is useful when you want to create your own <code>Error</code> classes and add more information to the error object. Here is an example:</p>
			<pre class="source-code">
class NotEnoughSleep extends Error {
  constructor (message) {
    super(message)
    this.requireSleep = true
    this.isRecoverable = true
  }
}
throw new NotEnoughSleep('Looks like you need more sleep')</pre>			<p>If we run the previous code, we will get the following output:</p>
			<pre class="console">
file:///file.js:9
  throw new NotEnoughSleep('Looks like you need more sleep')
NotEnoughSleep [Error]: Looks like you need more sleep
    at file:///file.js:9:9
    at ModuleJob.run (node:internal/modules/esm/module_job:192:25)
    at async DefaultModuleLoader.import (node:internal/modules/esm/loader:228:24)
    at async loadESM (node:internal/process/esm_loader:40:7)
    at async handleMainPromise (node:internal/modules/run_main:66:12) {
  requireSleep: true,
  isRecoverable: true
}</pre>			<p>As you can see, the error message <code>Looks like you need more sleep</code> is displayed in the output, as well as the class name, <code>NotEnoughSleep</code>. Additionally, we have added two properties to the error object: <code>requireSleep</code> and <code>isRecoverable</code>. These properties are created by us, and we can create as many as we need and be as specific as we want. These properties<a id="_idIndexMarker861"/> can be used to add more information to the error object, so we can handle the error properly using these properties in a <code>try</code>/<code>catch</code> block:</p>
			<pre class="source-code">
try {
  throw new NotEnoughSleep("Looks like you need more sleep");
} catch (error) {
  if (error.isRecoverable) {
    console.log("You are lucky, because you can recover from this error");
  }
  if (error.requireSleep) {
    console.log("Please, go to sleep!");
  }
}</pre>			<p>Here is the output of the previous code:</p>
			<pre class="console">
You are lucky, because you can recover from this error
Please, go to sleep!</pre>			<p>As you can see, we have used the <code>isRecoverable</code> and <code>requireSleep</code> properties to handle the error. This is a very simple example, but you can add more properties to the error object to handle<a id="_idIndexMarker862"/> the error properly.</p>
			<p>In the next section, we are going to learn how to capture and recover from any kind of error while using Express.</p>
			<h1 id="_idParaDest-377"><a id="_idTextAnchor385"/>Managing errors in Express</h1>
			<p>In the previous chapters, we learned<a id="_idIndexMarker863"/> how to create a REST API application using Express and we saw how to handle errors in Express applications, but in this section, we are going to refresh the concepts and extend them.</p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor386"/>Error-handling middleware</h2>
			<p>Express has a built-in error-handling middleware<a id="_idIndexMarker864"/> that can be used to handle errors<a id="_idIndexMarker865"/> in a centralized way. This middleware is executed when an error occurs in the application. This middleware is executed after all the other middleware and routes have been executed. It is executed only when an error occurs, so it is important to add it at the end of the middleware chain, like so:</p>
			<pre class="source-code">
import express from 'express'
const app = express()
// Other middlewares...
app.use((err, req, res, next) =&gt; {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
// Route handler...</pre>			<h2 id="_idParaDest-379"><a id="_idTextAnchor387"/>Custom errors</h2>
			<p>If you are building a REST<a id="_idIndexMarker866"/> API application, you<a id="_idIndexMarker867"/> could add a property to the error object to indicate the HTTP status code that should be returned to the client. This way, you can handle the error properly in the error-handling middleware and return the proper HTTP status code to the client. Here is an example:</p>
			<pre class="source-code">
class NotFoundError extends Error {
  constructor (message) {
    super(message)
    this.statusCode = 404
  }
}
try {
  throw new NotFoundError('The resource was not found')
} catch (error) {
  console.log(error.statusCode)
  res.status(error.statusCode).send(error.message)
}</pre>			<p>As you can see, we can use the <code>statusCode</code> property to return the proper HTTP status code to the client. This is a very simple example but you can add more properties to the error object to handle the error properly.</p>
			<p>Now that we know how to handle errors, it is time to learn how to gracefully shut down the application when the application cannot recover from an error.</p>
			<h1 id="_idParaDest-380"><a id="_idTextAnchor388"/>Gracefully shutting down the application</h1>
			<p>Throughout the book, we have learned<a id="_idIndexMarker868"/> how to handle errors using <code>try</code>/<code>catch</code> blocks, error-first callbacks, <code>catch</code> for promises, and also events to handle errors but, sometimes, we need to handle errors globally.</p>
			<p>Node.js provides a way to handle errors globally and gracefully shut down the application when an error occurs: using <code>process.on()</code>. You can also use <code>process.exit()</code> to exit the application with a specific exit code. This is useful in CI/CD pipelines, to indicate whether or not the application was shut down because of an error, and also in productive environments.</p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor389"/>Events</h2>
			<p>There are many events<a id="_idIndexMarker869"/> that can be used<a id="_idIndexMarker870"/> to handle errors globally:</p>
			<ul>
				<li><code>uncaughtException</code>: This event is emitted when an uncaught exception occurs</li>
				<li><code>unhandledRejection</code>: This event is emitted when an unhandled rejection occurs</li>
				<li><code>exit</code>: This event is emitted when the Node.js process is about to exit</li>
				<li><code>SIGINT</code> and <code>SIGTERM</code>: These events are emitted when the Node.js process receives  these signals</li>
			</ul>
			<p>Many other events can be used to handle errors globally but these are the most common ones. In the following example, we combine some scenarios to handle errors globally:</p>
			<pre class="source-code">
const events = ['uncaughtException','unhandledRejection', 'exit', 'SIGINT'];
events.forEach(event =&gt; {
  process.on(event, (error) =&gt; {
    console.log(`This is an ${event} that we track!`)
  })
})
setTimeout(() =&gt; {
  throw new Error('Exception!')
}, 10000)
setTimeout(() =&gt; {
  Promise.reject(new Error('Rejection!'))
}, 20000)</pre>			<p>If you run the previous code, you will see<a id="_idIndexMarker871"/> that the application will be shut down<a id="_idIndexMarker872"/> after 20 seconds because of the unhandled rejection, but  the uncaught exception was eventually caught and the process continues running. Also, if you press <em class="italic">Ctrl</em> + <em class="italic">C</em> at any time, the application will be shut down because of the <code>SIGINT</code> signal.</p>
			<p>In the following example, we can see that the <code>exit</code> event is always triggered when we are closing the Node.js application. So, it is quite common to use this event to perform some actions before the application is shut down:</p>
			<pre class="console">
This is an uncaughtException that we track!
This is an unhandledRejection that we track!
This is an exit that we track!</pre>			<p>Take into account that the <code>exit</code> event is not only triggered when an error occurs but also when the application is closed gracefully and does not support asynchronous operations.</p>
			<p>In the next section, we will learn how to use exit codes to indicate the reason why the application was shut down. This is very useful in CI/CD pipelines to indicate whether the application was shut down because of an error or not.</p>
			<h2 id="_idParaDest-382"><a id="_idTextAnchor390"/>Exit codes</h2>
			<p>Exit codes are used to indicate the reason<a id="_idIndexMarker873"/> that the application was shut down, as well as whether<a id="_idIndexMarker874"/> or not the application was shut down because of an error and whether the application was shut down gracefully or not.</p>
			<p>If the exit code is <code>0</code>, it means that the application was shut down gracefully. If the exit code is different from <code>0</code>, it means that the application was shut down because of an error. By default, when there is nothing to do in the application, Node.js will exit with the exit code of <code>0</code>.</p>
			<p>By using <code>process.exit()</code>, we can indicate the exit code that we want to use. For example, if we want to indicate that the application was shut down because of an error, we can use <code>process.exit(1)</code>. If we want to indicate that the application was shut down gracefully, we can use <code>process.exit(0)</code>.</p>
			<p>Some processes might finish correctly in terms of execution but use an error code. For example, when we run and complete application tests, if any test fails, the exit code will be different from <code>0</code>. That way, the execution output will be an error that can prevent CI from continuing to execute the pipeline.</p>
			<p>In the next section, we will learn how to prevent zombie processes while using the process library to handle errors globally.</p>
			<h2 id="_idParaDest-383"><a id="_idTextAnchor391"/>Avoiding zombie processes</h2>
			<p>I love zombie movies<a id="_idIndexMarker875"/> but I don’t like zombie<a id="_idIndexMarker876"/> processes. A zombie process is a process that is running in the background and is not doing anything. These kinds of processes eat resources from the host machine, and they can be a huge problem in certain scenarios such as low-capability devices.</p>
			<p>Using <code>process.on()</code> can be dangerous because it can prevent the Node.js process from exiting. This is why it is important to use <code>process.exit()</code> to exit the application with a specific exit code when needed.</p>
			<p>Let’s see an example. If we don’t use <code>process.exit()</code>, the application will not exit and it will be running forever, even if an error occurs while executing a function that is not defined:</p>
			<pre class="source-code">
process.on('uncaughtException', (error) =&gt; {
  console.log('We are not going to exit the application!')
})
setInterval(() =&gt; {
    executeThisFunction()
}, 1000)</pre>			<p>This is shown in the following output:</p>
			<pre class="console">
We are not going to exit the application!
We are not going to exit the application!
We are not going to exit the application!
We are not going to exit the application!
We are not going to exit the application!</pre>			<p>We can prevent that by adding <code>process.exit()</code> to exit the application with a specific exit code:</p>
			<pre class="source-code">
process.on("uncaughtException", (error) =&gt; {
  console.log("Now, exit the application!");
  process.exit(1);
});
setInterval(() =&gt; {
  executeThisFunction();
}, 1000);</pre>			<p>The output will be as follows:</p>
			<pre class="console">
Now, exit the application!</pre>			<p>As you can see, the application<a id="_idIndexMarker877"/> was shut down<a id="_idIndexMarker878"/> because we used <code>process.exit()</code> to exit the application with a specific exit code. If we don’t use <code>process.exit()</code>, the application will be running forever, making it a zombie process.</p>
			<h1 id="_idParaDest-384"><a id="_idTextAnchor392"/>Summary</h1>
			<p>In this chapter, we learned about the types of errors that can be thrown in Node.js applications. We saw how to throw custom errors and how to capture and  recover from any kind of error.</p>
			<p>Additionally, we reviewed how to manage application and user errors in Express. We also learned how to manage a graceful shutdown when the service crashed.</p>
			<p>Finally, we learned how to prevent zombie processes.</p>
			<p>In the next chapter, we are going to learn more about security, including how to protect our application by applying the best practices available and how to evaluate CVEs and security vulnerabilities.</p>
			<h1 id="_idParaDest-385"><a id="_idTextAnchor393"/>Further reading</h1>
			<ul>
				<li><em class="italic">Express</em> | <em class="italic">Health Checks and Graceful </em><em class="italic">Shutdown</em>: <a href="https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html">https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html</a></li>
				<li><em class="italic">Express</em> | <em class="italic">Error </em><em class="italic">Handling</em>: <a href="https://expressjs.com/en/guide/error-handling.html">https://expressjs.com/en/guide/error-handling.html</a></li>
				<li>Node.js docs | <em class="italic">Error </em><em class="italic">API</em>: <a href="https://nodejs.org/dist/latest-v20.x/docs/api/errors.html">https://nodejs.org/dist/latest-v20.x/docs/api/errors.html</a></li>
				<li><em class="italic">Bash command line exit codes </em><em class="italic">demystified</em>: <a href="https://www.redhat.com/sysadmin/exit-codes-demystified">https://www.redhat.com/sysadmin/exit-codes-demystified</a></li>
			</ul>
		</div>
	</body></html>