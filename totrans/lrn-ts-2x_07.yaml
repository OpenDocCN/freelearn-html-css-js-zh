- en: Functional Programming with TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TypeScript 进行函数式编程
- en: JavaScript has been a multi-paradigm programming language since its inception
    back in 1995\. It allows us to take advantage of an object-oriented programming
    style, but it also allows us to take advantage of a **functional programming**
    (**FP**) style. The same can be said about TypeScript. However, TypeScript is
    even better suited to FP than JavaScript because, as we will learn in this chapter,
    static type systems and type inference are very important in FP languages, such
    as the ML family of programming languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1995 年问世以来，JavaScript 就是一种多范式编程语言。它允许我们利用面向对象编程风格的优势，同时也允许我们利用函数式编程（**FP**）风格的优势。同样，TypeScript
    也是如此。然而，TypeScript 比JavaScript 更适合 FP（函数式编程），因为，正如我们将在本章中学习的，静态类型系统和类型推断在 FP（函数式编程）语言（如
    ML 编程语言家族）中非常重要。
- en: The JavaScript and TypeScript ecosystems have experienced a significant increase
    in interest in FP over the last 3 or 4 years. I believe that the cause of this
    increase in interest is the success of React. React is a library used to build
    user interfaces developed by Facebook, which is highly influenced by some core
    FP concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去 3 或 4 年中，JavaScript 和 TypeScript 生态系统对 FP（函数式编程）的兴趣显著增加。我相信这种兴趣增加的原因是 React
    的成功。React 是由 Facebook 开发的一个用于构建用户界面的库，它深受一些核心 FP（函数式编程）概念的影响。
- en: We will learn more about React toward the end of this book, but, for now, we
    will focus on learning how to use some basic FP techniques with TypeScript on
    its own and with some small FP libraries such as `Immutable.js` and `Ramda`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的末尾更多地了解 React，但就目前而言，我们将专注于学习如何仅使用 TypeScript 以及一些小的 FP（函数式编程）库（如 `Immutable.js`
    和 `Ramda`）来使用一些基本的 FP（函数式编程）技术。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Pure functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: Side effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用
- en: Immutability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Function arity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数阶数
- en: Higher-order functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Function composition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: Function partial application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数部分应用
- en: Currying and Pointfree style
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化和无点风格
- en: Pipes and sequences
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道和序列
- en: Category theory
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别论
- en: FP concepts
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FP 概念
- en: FP receives its name from the way we build applications when we use it as our
    preferred programming paradigm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将函数式编程作为首选编程范式时，FP（函数式编程）的名字来源于我们构建应用程序的方式。
- en: In a programming paradigm such as object-oriented programming, the main building
    blocks that we use to create an application are objects (objects are declared
    using classes). However, in FP we use functions as the main building block in
    our applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程等编程范式中，我们用来创建应用程序的主要构建块是对象（对象使用类声明）。然而，在 FP（函数式编程）中，我们使用函数作为应用程序中的主要构建块。
- en: Each new programming paradigm introduces a series of concepts and ideas associated
    with it. Some of these concepts are universal and are also of interest while learning
    a different programming paradigm. In object-oriented programming, we have concepts
    such as inheritance, encapsulation, and polymorphism. In FP we have concepts such
    as higher-order functions, function partial application, immutability, and referential
    transparency. We will try to learn about some of these concepts in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每种新的编程范式都会引入一系列与之相关的概念和思想。其中一些概念是通用的，在学习不同的编程范式时也很有兴趣。在面向对象编程中，我们有诸如继承、封装和多态等概念。在
    FP（函数式编程）中，我们有高阶函数、函数部分应用、不可变性和引用透明性等概念。我们将尝试在本章中了解一些这些概念。
- en: 'Michael Feathers, the author of the SOLID acronym and many other well-known
    software engineering principles, once wrote:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克尔·费思，SOLID 简称的作者以及许多其他著名的软件工程原则的作者，曾写道：
- en: '"Object-oriented programming makes code understandable by encapsulating moving
    parts. Functional Programming makes code understandable by minimizing moving parts."'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '"面向对象编程通过封装移动部分使代码易于理解。函数式编程通过最小化移动部分使代码易于理解。"'
- en: The preceding quote mentions <q>moving parts</q>; we should understand these
    moving parts as state changes (also known as state mutations). In object-oriented
    programming, we use encapsulation to prevent objects from being aware of the state
    mutations of other objects. In FP we try to avoid dealing with a mutable state
    instead of encapsulating it. FP reduces the number of places in which state changes
    take place within an application and tries to move these places into the boundaries
    of the application to try to keep application's core stateless.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的引用提到了<q>移动部件</q>；我们应该将这些移动部件理解为状态变化（也称为状态突变）。在面向对象编程中，我们使用封装来防止对象意识到其他对象的状态变化。在FP中，我们试图避免处理可变状态，而不是封装它。FP减少了应用程序中状态变化发生的地方的数量，并试图将这些地方移动到应用程序的边界内，以尝试保持应用程序的核心无状态。
- en: 'A mutable state is bad because it makes the behavior of our code harder to
    predict. Take, for example, the following function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可变状态是坏的，因为它使我们的代码的行为更难以预测。以以下函数为例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code snippet declared a function named `isIndexPage`. This function
    can be used to check whether the current page is the root page in a web application
    based on the current path.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段声明了一个名为`isIndexPage`的函数。这个函数可以用来检查当前页面是否是Web应用程序中的根页面，基于当前路径。
- en: The path is some data that changes all the time, so we can consider it a piece
    of state. If we try to predict the result of invoking the `isIndexPage`, we will
    need to know the current state. The problem is that we could wrongly assume that
    the state has not changed since the last known state. We can solve this problem
    by transforming the function into a pure function, as we will learn in the following
    section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是不断变化的数据，因此我们可以将其视为状态的一部分。如果我们尝试预测调用`isIndexPage`的结果，我们需要知道当前状态。问题是，我们可能会错误地假设状态自上次已知状态以来没有改变。我们可以通过将函数转换为纯函数来解决这个问题，正如我们将在下一节中学习的那样。
- en: Pure functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'FP introduces some concepts and principles that will help us to improve the
    predictability of our code. Let''s look at one of these core concepts: **pure
    functions**.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FP引入了一些概念和原则，这将帮助我们提高代码的可预测性。让我们看看这些核心概念之一：**纯函数**。
- en: A function can be considered pure when it returns a value computed using only
    the arguments passed to it. Also, a pure function avoids mutating its arguments
    or any other external variables. As a result, a pure function always returns the
    same value given the same arguments, independently of when it is invoked.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数仅使用传递给它的参数计算返回值时，可以认为它是纯函数。此外，纯函数避免修改其参数或任何其他外部变量。因此，纯函数在给定相同的参数时，无论何时调用，总是返回相同的值。
- en: 'The `isIndexPage` function declared in the preceding section is not a pure
    function because it accesses the `pathname` variable and it has not been passed
    as an argument to the function. We can transform the preceding function into a
    pure function by rewriting it as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中声明的`isIndexPage`函数不是一个纯函数，因为它访问了`pathname`变量，并且它没有被作为参数传递给函数。我们可以通过以下方式重写前面的函数，将其转换为纯函数：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though this is a basic example, we can easily perceive that the newer version
    is much easier to predict. Pure functions help us to make our code easier to understand,
    maintain, and test.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个基本的例子，我们很容易就能感知到新版本要容易预测得多。纯函数帮助我们使代码更容易理解、维护和测试。
- en: Imagine that we wanted to write a unit test for the impure version of the `isIndexPage`
    function. We would encounter some problems when trying to test because the function
    uses the `window.location` object. We could overcome this issue using a mocking
    framework, but it would add a lot of complexity to our unit tests just because
    we didn't use a pure function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为`isIndexPage`函数的不纯版本编写单元测试。在尝试测试时，我们会遇到一些问题，因为该函数使用了`window.location`对象。我们可以使用模拟框架来克服这个问题，但这会为我们的单元测试增加很多复杂性，仅仅因为我们没有使用纯函数。
- en: 'On the other hand, testing the pure version of the `isIndexPage` function would
    be straightforward:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，测试`isIndexPage`函数的纯版本将会简单直接：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we understand how FP helps us to write better code by avoiding state
    mutations, we can learn about side effects and referential transparency.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了FP如何通过避免状态突变来帮助我们编写更好的代码，我们可以学习关于副作用和引用透明度。
- en: Side effects
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用
- en: In the preceding section, we learned that a pure function returns a value that
    can be computed using only the arguments passed to it. A pure function also avoids
    mutating its arguments or any other external variable that is not passed to the
    function as an argument. In FP terminology, it is common to say that a pure function
    is a function that has no side effects. This means that when we invoke a pure
    function, we can expect that the function is not going to interfere (via a state
    mutation) with any other component in our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到一个纯函数只返回一个值，这个值可以通过传递给它的参数来计算得出。纯函数还避免了修改其参数或任何未作为参数传递给函数的外部变量。在函数式编程（FP）术语中，通常说一个纯函数是一个没有副作用（side
    effects）的函数。这意味着当我们调用一个纯函数时，我们可以预期该函数不会通过状态修改来干扰我们应用程序中的任何其他组件。
- en: Some programming languages, such as Haskell, can ensure that an application
    is free of side effects using its type system. TypeScript has fantastic interoperability
    with JavaScript, but the downside of this, compared to a more isolated language
    such as Haskell, is that the type system is not able to guarantee that our application
    is free of side effects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言，如 Haskell，可以通过其类型系统确保应用程序没有副作用。TypeScript 与 JavaScript 的互操作性非常好，但与像 Haskell
    这样更隔离的语言相比，其缺点是类型系统无法保证我们的应用程序没有副作用。
- en: If you like the idea of your JavaScript applications being free of side effects,
    you can try open source projects such as [https://github.com/bodil/eslint-config-cleanjs](https://github.com/bodil/eslint-config-cleanjs).
    The project is an ESLint configuration that aims to restrict you to a subset of
    JavaScript that is as close to an idealized pure functional language as possible.
    Unfortunately, at the time of writing, there were no similar tools available that
    were specifically designed for TypeScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢你的 JavaScript 应用程序没有副作用的想法，你可以尝试开源项目，如 [https://github.com/bodil/eslint-config-cleanjs](https://github.com/bodil/eslint-config-cleanjs)。该项目是一个
    ESLint 配置，旨在限制你使用尽可能接近理想化纯函数式语言的 JavaScript 子集。不幸的是，在撰写本文时，没有可用的类似工具专门为 TypeScript
    设计。
- en: Referential transparency
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明性
- en: Referential transparency is another concept closely related to pure functions
    and side effects. A function is pure when it is free of side effects. An expression
    is said to be referentially transparent when it can be replaced with its corresponding
    value without changing the application's behavior.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性是另一个与纯函数和副作用密切相关的概念。一个函数在无副作用时是纯的。当一个表达式可以被其对应值替换而不改变应用程序的行为时，我们说它是引用透明的。
- en: A pure function is a referentially transparent expression. An expression that
    is not referentially transparent is known as referentially opaque.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是一个引用透明（referentially transparent）的表达式。一个非引用透明的表达式被称为引用不透明（referentially
    opaque）。
- en: Immutability
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: Immutability refers to the inability to change the value of a variable after
    a value has been assigned to it. Purely FP languages include immutable implementations
    of common data structures. For example, when we add an element to an array, we
    are mutating the original array. However, if we use an immutable array, and we
    try to add a new element to it, the original array will not be mutated, and we
    will add the new item to a copy of it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性指的是在给变量赋值后无法更改其值的能力。纯函数式语言包括常见数据结构的不可变实现。例如，当我们向数组添加一个元素时，我们正在修改原始数组。然而，如果我们使用不可变数组，并尝试向其中添加新元素，原始数组将不会被修改，我们将新项目添加到其副本中。
- en: In JavaScript and TypeScript, we can use the `Immutable.js` library to enjoy
    immutable data structures.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 和 TypeScript 中，我们可以使用 `Immutable.js` 库来享受不可变的数据结构。
- en: Functions as first-class citizens
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: It is common to find mentions of functions as <q>first-class citizens</q> in
    FP literature. We say that a function is a <q>"first-class citizen"</q> when it
    can do everything that a variable can do. This means that functions can be passed
    to other functions as an argument or to be returned by another function. Functions
    can also be assigned to variables. Both JavaScript and TypeScript treat functions
    as <q>"first-class citizens"</q>.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）文献中，经常提到函数作为 <q>一等公民</q> 的概念。当我们说一个函数是 <q>"一等公民"</q> 时，意味着它可以做任何变量能做的事情。这意味着函数可以作为参数传递给其他函数，或者由其他函数返回。函数也可以被分配给变量。JavaScript
    和 TypeScript 都将函数视为 <q>"一等公民"</q>。
- en: Lambda expressions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'Lambda expressions are just expressions that can be used to declare anonymous
    functions (functions without a name). Before the ES6 specification, the only way
    to assign a function as a value to a variable was using a function expression:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式只是可以用来声明匿名函数（无名称的函数）的表达式。在 ES6 规范之前，将函数作为值赋给变量的唯一方法是使用函数表达式：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The ES6 specification introduced the arrow function syntax:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 规范引入了箭头函数语法：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please refer to [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml), *Working
    with Functions*, and [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime,* to learn more about arrow functions and function
    expressions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第 3 章](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml)，*与函数一起工作*，和[第 6 章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml)，*理解运行时*，以了解更多关于箭头函数和函数表达式的信息。
- en: Function arity
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数的元数
- en: 'The arity of a function is the number of arguments that the function takes.
    A unary function is a function that only takes one argument:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的元数是指函数接受的参数数量。单一函数是只接受一个参数的函数：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unary functions are very important in FP because they facilitate the usage of
    the function composition pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单一函数在函数式编程（FP）中非常重要，因为它们促进了函数组合模式的运用。
- en: We will learn more about the function composition pattern later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更深入地了解函数组合模式。
- en: 'A **binary function** is a function that takes two arguments:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**二元函数**是接受两个参数的函数：'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Functions with two or more arguments are also important because some of the
    most common FP patterns and techniques (for example, partial application and currying)
    have been designed to transform functions that allow multiple arguments into unary
    functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接受两个或更多参数的函数也很重要，因为一些最常用的函数式编程模式和技巧（例如，部分应用和柯里化）被设计成将接受多个参数的函数转换为单一参数函数。
- en: We will learn more about partial application and currying later in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更深入地了解部分应用和柯里化。
- en: 'There are also functions with three (**ternary function**) or more arguments.
    However, functions that accept a variable number of arguments, known as **variadic
    functions**, are particularly interesting in FP:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样也存在接受三个（**三元函数**）或更多参数的函数。然而，在函数式编程中，接受可变数量参数的函数（称为**可变参数函数**）尤其有趣：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Higher-order functions
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'A higher-order function is a function that does at least one of the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数至少执行以下操作之一：
- en: Takes one or more functions as arguments
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个或多个函数作为参数
- en: Returns a function as its result
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数作为其结果
- en: Higher-order functions are one of the most powerful tools that we can use to
    write JavaScript in an FP style. Let's see some examples.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是我们可以使用来以函数式编程风格编写 JavaScript 的最强大的工具之一。让我们看看一些例子。
- en: 'The following code snippet declares a function named `addDelay`. The function
    creates a new function that waits a given number of microseconds before printing
    a message in the console. The function is considered a higher-order function because
    it takes a function as one of its arguments:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `addDelay` 的函数。该函数创建了一个新的函数，该函数在控制台打印消息之前等待给定数量的微秒。该函数被认为是一个高阶函数，因为它将其参数之一作为一个函数：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code snippet declares a function named `addDelay`. The function
    adds a delay in microseconds to the execution of another function that is passed
    as an argument. The function is considered a higher-order function because it
    returns a function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `addDelay` 的函数。该函数将延迟微秒数添加到作为参数传递的另一个函数的执行中。该函数被认为是一个高阶函数，因为它返回一个函数：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code snippet declares a function named `addDelay`. The function
    creates a new function that adds a delay in microseconds to the execution of another
    function that is passed as an argument. The function is considered a higher-order
    function because it takes a function as an argument and returns a function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `addDelay` 的函数。该函数创建了一个新的函数，该函数将延迟微秒数添加到作为参数传递的另一个函数的执行中。该函数被认为是一个高阶函数，因为它接受一个函数作为参数并返回一个函数：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Higher-order functions are an effective technique to abstract a solution for
    a common problem. The preceding example demonstrates how we can use a higher-order
    function (`addDelay`) to add a delay to another function (`sayHello`). This allows
    us to abstract the delay functionality and keep the `sayHello` function or other
    functions agnostic of the implementation details of the delay functionality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是抽象常见问题解决方案的有效技术。前面的例子演示了我们可以如何使用高阶函数（`addDelay`）向另一个函数（`sayHello`）添加延迟。这允许我们抽象延迟功能，并保持`sayHello`函数或其他函数对延迟功能的实现细节无感知。
- en: The benefits of FP
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程（FP）的好处
- en: 'Writing TypeScript code using an FP style has many benefits, among which we
    can highlight the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FP风格编写TypeScript代码有许多好处，其中我们可以强调以下几点：
- en: '**Testable code**: If we try to write our functions pure functions, we will
    be able to write unit tests extremely easily.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试的代码**：如果我们尝试编写纯函数，我们将能够非常容易地编写单元测试。'
- en: '**Code is easy to reason about**: FP can seem hard to understand for developers
    with a lack of experience in FP. However, when an application is implemented correctly
    using the FP paradigm, the results are very small functions (often one-line functions)
    and very declarative APIs that can be reasoned about with ease.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码易于推理**：对于缺乏FP经验的开发者来说，FP可能很难理解。然而，当应用程序正确地使用FP范式实现时，结果是非常小的函数（通常是单行函数）和非常声明性的API，这些API可以轻松地进行推理。'
- en: '**Concurrency**: Most of our functions are stateless, and our entities are
    mostly stateless. We push state out of the core of our application, which makes
    our applications much more likely to be able to support many concurrent operations
    and be more scalable.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：我们的大多数函数都是无状态的，我们的实体也大多是状态无关的。我们将状态推离应用程序的核心，这使得我们的应用程序更有可能支持许多并发操作，并且更具可扩展性。'
- en: '**Caching**: Strategies for caching results become much simpler when we can
    predict the output of a function given its arguments.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：当我们可以预测给定函数的输出时，缓存结果的策略会变得简单得多。'
- en: Is TypeScript a FP language?
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript是一种FP语言吗？
- en: The answer to this question is yes, but only partially. TypeScript is a multi-paradigm
    programming language and, as a result, it includes many influences from both object-oriented
    programming languages and FP languages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是肯定的，但只是部分如此。TypeScript是一种多范式编程语言，因此它包括了来自面向对象编程语言和FP语言的许多影响。
- en: However, if we focus on TypeScript as an FP language, we can observe that it
    is not a purely FP language because, for example, the TypeScript compiler doesn't
    enforce our code to be free of side effects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将TypeScript视为一种FP语言，我们可以观察到它并不是一种纯粹的FP语言，因为例如，TypeScript编译器并不强制我们的代码无副作用。
- en: Not being a purely FP language should not be interpreted as something negative.
    TypeScript provides us with an extensive set of features and allows us to take
    advantage of some of the best features of both the world of object-oriented programming
    languages and the world of FP languages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不是一个纯粹的FP语言不应被解读为负面的事情。TypeScript为我们提供了一套广泛的功能，并允许我们利用面向对象编程语言和FP语言世界中的最佳功能。
- en: FP techniques
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FP技术
- en: Now that we have learned about the most common FP concepts, it is time to learn
    about the most common FP techniques and patterns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了最常见的FP概念，是时候学习最常见的FP技术和模式了。
- en: Composition
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: '**Functional composition** is a technique or pattern that allows us to combine
    multiple functions to create a more complex function.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能组合**是一种技术或模式，它允许我们将多个函数组合起来创建一个更复杂的函数。'
- en: 'The following code snippet declares a function used to trim a string and a
    function used to transform a piece of text in uppercase text:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个用于修剪字符串的函数和一个用于将文本转换为上档文本的函数：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can create a function that performs both the preceding operations by composing
    them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个函数，通过组合执行前面的操作：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The variable `trimAndCapitalize` is a function that invokes the `trim` function
    using `s` as its argument and passes its return to the `capitalize` function.
    We can invoke the `trimAndCapitalize` function as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`trimAndCapitalize`是一个函数，它使用`s`作为其参数调用`trim`函数，并将返回值传递给`capitalize`函数。我们可以如下调用`trimAndCapitalize`函数：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The composition of two functions `f(x)` and `g(x)` is defined as `f(g(x))`,
    and that is exactly what we have done in the `trimAndCapitalize` function. However,
    such a behavior can be abstracted using a higher-order function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数 `f(x)` 和 `g(x)` 的组合定义为 `f(g(x))`，这正是我们在 `trimAndCapitalize` 函数中所做的。然而，这种行为可以通过高阶函数来抽象化：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can then use the preceding function to compose two given functions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用上述函数来组合两个给定的函数：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can invoke the `trimAndCapitalize` function as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样调用 `trimAndCapitalize` 函数：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One important thing to note is that the result of the `g` function is passed
    as the argument of the `f` function. This means that `f` can only take one argument
    (it must be a unary function), and its type must match the return type of the
    `g` function. A more correct definition of the `compose` function would be something
    like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要注意，那就是 `g` 函数的结果被传递为 `f` 函数的参数。这意味着 `f` 只能接受一个参数（它必须是一元函数），并且其类型必须与
    `g` 函数的返回类型相匹配。`compose` 函数的一个更正确的定义可能如下所示：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also compose `composed` functions:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以组合 `composed` 函数：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, we can declare a higher-order function to compose three functions
    in one call:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在一次调用中声明一个高阶函数来组合三个函数：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also create a helper that allows us to compose an unlimited number of
    functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个辅助函数，允许我们组合无限数量的函数：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Functional composition is an extremely powerful technique, but it can be hard
    to put into practice in certain scenarios, for example, when our functions are
    not unary functions. However, there are other techniques that can help in those
    scenarios.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是一种极其强大的技术，但在某些场景中可能难以实施，例如，当我们的函数不是一元函数时。然而，还有一些其他技术可以帮助在这些场景中。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例都包含在配套源代码中。
- en: Partial application
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: '**Partial application** is an FP technique that allows us to pass the arguments
    required by a function at different points in time.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分应用** 是一种函数式编程技术，允许我们在不同的时间点传递函数所需的参数。'
- en: This technique can feel like a weird idea at first glance because most software
    engineers are used to the idea of applying (also known as invoking) a function
    at one unique point in time (complete application), as opposed to applying a function
    at multiple points in time (partial application).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在第一眼看起来可能像是一个奇怪的想法，因为大多数软件工程师都习惯了在单一独特的时间点应用（也称为调用）一个函数（完整应用）的想法，而不是在多个时间点应用一个函数（部分应用）。
- en: 'The following code snippet implements a function that doesn''t support partial
    application and invokes it (providing all the required arguments) at one single
    point in time:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了一个不支持部分应用的功能，并在一个单一的时间点调用它（提供所有所需的参数）：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code snippet implements the preceding function as a higher-order
    function to allow us to provide the required arguments at different points in
    time:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了上述函数作为一个高阶函数，以便我们可以在不同的时间点提供所需的参数：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see in the preceding code snippet, the first and the second arguments
    are provided at a different point in time. However, it cannot be considered an
    example of function partial application because the two functions are unary functions,
    and we have provided one argument at a time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，第一个和第二个参数是在不同的时间点提供的。然而，这不能被视为函数部分应用的例子，因为这两个函数是一元函数，我们一次提供了一个参数。
- en: 'We can also write a function that allows both its complete and partial application:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编写一个允许其完全应用和部分应用的功能：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding example can be considered an example of partial application because
    we can apply the function with all its arguments (complete application) or some
    of them (partial application).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例可以被视为部分应用的例子，因为我们既可以应用带有所有参数的函数（完整应用），也可以应用其中的一些参数（部分应用）。
- en: 'Now that we know how function partial application works, let''s focus on why
    it is useful. In the preceding *Composition* section, we learned how to compose
    two functions named `trim` and `capitalize` into a third function named `trimAndCapitalize`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数部分应用的工作原理，让我们来关注一下它为什么是有用的。在先前的 *组合* 部分，我们学习了如何将名为 `trim` 和 `capitalize`
    的两个函数组合成一个名为 `trimAndCapitalize` 的第三个函数：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Function composition works very well with unary functions but not so well with
    binary or ternary functions. We are going to declare the following function to
    demonstrate this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合与一元函数配合得很好，但与二元或三元函数配合得不是很好。我们将声明以下函数来演示这一点：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding function can be used to replace a substring in given string.
    Unfortunately, the function cannot be used with compose with ease because it is
    not a unary function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数可以用来替换给定字符串中的子串。不幸的是，该函数不能与组合操作轻松地一起使用，因为它不是一个一元函数：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, we can implement the function in a way that allows us to apply the
    function partially:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以以允许我们部分应用函数的方式实现该函数：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can then use the compose function without problems:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以无问题地使用组合函数。
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Thanks to our knowledge of function partial application, we can use compose
    with ease, without having to worry about the arity of the functions. However,
    enabling partial application requires a significant amount of manual boilerplate.
    In the next section, we will learn how an FP technique known as currying can help
    us to solve this problem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们对函数部分应用的知识，我们可以轻松地使用组合，而无需担心函数的arity。然而，启用部分应用需要大量的手动样板代码。在下一节中，我们将学习一种称为
    currying 的 FP 技术如何帮助我们解决这个问题。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: Currying
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Currying
- en: '**Currying** is an FP technique that allows us to use partial application without
    having to worry about partial application while we write our functions. Currying
    is the process of taking a function that takes multiple arguments and transforming
    it into a chain of unary functions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Currying** 是一种 FP 技术，它允许我们在编写函数时无需担心部分应用。Currying 是将接受多个参数的函数转换成一系列一元函数的过程：'
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding function is a higher-order function that allows us to abstract
    our functions from the partial application functionality:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数是一个高阶函数，它允许我们抽象出函数的部分应用功能：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `curry2` function allows us to transform a binary function into two unary
    functions. The `curry2` function is a higher-order function and can be used with
    any binary function. For example, in the preceding code snippet, we passed the
    add function to the `curry2` function, but the following example passes the multiply
    function to the `curry2` function instead:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`curry2` 函数允许我们将二元函数转换成两个一元函数。`curry2` 函数是一个高阶函数，并且可以与任何二元函数一起使用。例如，在先前的代码片段中，我们将加法函数传递给了
    `curry2` 函数，但下面的例子中将乘法函数传递给了 `curry2` 函数：'
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding *Partial application* section, we learned how to use partial
    application to use compose with functions that are not unary. We declared the
    following function named `replace` and then passed it to the `compose` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 *部分应用* 部分，我们学习了如何使用部分应用来使用组合函数，这些函数不是一元的。我们声明了以下名为 `replace` 的函数，并将其传递给了
    `compose` 函数：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can declare a function named `curry3` that transforms a ternary function
    into a chain of three unary functions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明一个名为 `curry3` 的函数，该函数将三元函数转换成一系列三个一元函数：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then use the `curry3` function to rewrite the `replace` function in
    a way that is agnostic of the function partial application implementation details:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `curry3` 函数以不关心函数部分应用实现细节的方式重写 `replace` 函数：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Please note that the entire example is included in the companion source code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: Pipes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'A pipe is a function or operator that allows us to pass the output of a function
    as the input of another. JavaScript and TypeScript don''t support piles natively
    (as an operator), but we can implement our pipes using the following function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一个函数或运算符，允许我们将一个函数的输出作为另一个函数的输入。JavaScript 和 TypeScript 不原生支持管道（作为一个运算符），但我们可以使用以下函数来实现我们的管道：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are going to use the `curry3`, `trim`, `capitalize`, and `replace` functions
    that we declared previously in this chapter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在本章中先前声明的 `curry3`、`trim`、`capitalize` 和 `replace` 函数：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can then use the pipe function to declare a new function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用管道函数声明一个新的函数：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `pipe` function ensures that the output of the `trim` function is passed
    to the `capitalize` function. The return of the `capitalize` function is then
    passed to the `replace` function, which has been already partially applied.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe` 函数确保 `trim` 函数的输出被传递给 `capitalize` 函数。然后，`capitalize` 函数的返回值被传递给已经部分应用的
    `replace` 函数。'
- en: 'There is an official proposal to add a new operator to JavaScript known as
    the pipeline operator (|>). This operator will allow us to implement a pipe as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个官方提案要为JavaScript添加一个名为管道操作符（|>）的新操作符。此操作符将允许我们像以下这样实现管道：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Please refer to the pipeline operator proposal: [https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator).
    Please note that the entire example is included in the companion source code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅管道操作符提案：[https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)。请注意，整个示例包含在配套源代码中。
- en: Pointfree style
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无点风格
- en: Tacit programming, also known as **pointfree style**, is a programming style
    in which function declarations do not declare the arguments (or <q>points</q>)
    on which they operate.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式编程，也称为**无点风格**，是一种编程风格，其中函数声明不声明它们操作的参数（或<q>点</q>）。
- en: 'The following code snippet declares a few functions that are used to determine
    whether a person is eligible to vote in elections:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一些函数，这些函数用于确定一个人是否有资格参加选举：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code snippet didn''t use any of the FP techniques that we have
    already learned in this chapter. The following code snippet implements an alternative
    solution for the same problem, using techniques such as partial application. This
    code snippet declares two functions named `both` and `either` that can be used
    to determine whether a variable matches the requirements specified by some or
    both functions, provided to these functions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段没有使用我们在本章中学到的任何FP技术。下面的代码片段实现了相同问题的替代解决方案，使用了诸如偏应用等技巧。此代码片段声明了两个名为`both`和`either`的函数，可以用来确定一个变量是否匹配由提供给这些函数的某些或所有函数指定的要求：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As we can see, the functions `isCitizen` and `isEligibleToVote` take some functions
    as arguments, but they don''t mention which data they expect as arguments. For
    example, we could write the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，函数`isCitizen`和`isEligibleToVote`接受一些函数作为参数，但它们没有提及它们期望哪些数据作为参数。例如，我们可以编写以下代码：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, we could write the following instead:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以这样写：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This style, in which we avoid referencing the function arguments, is known
    as pointfree style, and it has some advantages over more conventional function
    declaration styles:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种避免引用函数参数的风格被称为无点风格，它比更传统的函数声明风格有一些优势：
- en: It makes programs simpler and more concise. This isn't always a good thing,
    but it can be.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使程序更简单、更简洁。这并不总是好事，但有时是。
- en: It makes algorithms easier to understand by focusing only on the functions being
    combined; we get a better sense of what's going on without the data arguments
    getting in the way.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过仅关注组合的函数来简化算法的理解；我们可以在数据参数干扰的情况下更好地理解正在发生的事情。
- en: It forces us to think more about the how the data is used than about which data
    is being used.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它迫使我们更多地思考数据的使用方式，而不是使用哪些数据。
- en: It helps us think about our functions as generic building blocks that can work
    with different kinds of data, rather than thinking about them as operations on
    a kind of data.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助我们将函数视为通用的构建块，可以与不同类型的数据一起工作，而不是将它们视为对某种数据进行的操作。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: Recursion
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'A function that calls itself is known as a **recursive function**. The following
    function is a recursive function that allows us to calculate the factorial of
    a given number *n*. The factorial is the product of all positive integers less
    than or equal to *n*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 自调用的函数被称为**递归函数**。以下是一个递归函数，它允许我们计算给定数字*n*的阶乘。阶乘是所有小于或等于*n*的正整数的乘积：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can invoke the preceding function as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下这样调用前面的函数：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Category theory
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别论
- en: FP has a reputation for being difficult to learn and understand because of its
    mathematical background. FP languages and design patterns are influenced by concepts
    that originated in many different mathematical fields. However, we can highlight
    **category theory** as one of the most significant fields of influence. We can
    think about category theory as an alternative to set theory, which defines the
    theory behind a series of data structures or objects known as **algebraic data
    types**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many algebraic data types, and understanding all their properties
    and rules that they must implement requires a significant amount of time and effort.
    The following diagram illustrates the relationships between some of the most common
    algebraic data types:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/435b9b31-f36a-47ba-8301-2a4b400592b6.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: The arrows in the diagram indicate that a given algebraic data type must implement
    the specification of some other algebraic data types. For example, the `Monad`
    type must implement the specifications of the `Applicative` and `Chain` types.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The open source project `fantasy – land` declares a specification for some of
    these algebraic data types, while the open source project `ramda – fantasy` implements
    the specifications in a way that is compatible with `Ramda`, which is a popular
    FP library that we will explore later in this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The algebraic data type specifications can be implemented in many ways. For
    example, the fnctor specification can be implemented by a `Maybe` or an `Either`
    data type. Both types implement the `Functor` specification but can also implement
    other specifications, such as the monad or the applicative specification.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes which specifications (listed in the top row)
    are implemented by one of the algebraic data type implementations (left row) in
    the `ramda – fantasy` project:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Setoid** | **Semigroup** | **Functor** | **Applicative** | **Monad**
    | **Foldable** | **ChainRec** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| **Either** | ✓ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| **Future** | ✕ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| **Identity** | ✓ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| **IO** | ✕ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| **Maybe** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| **Reader** | ✕ | ✕ | ✓ | ✓ | ✓ | ✕ | ✕ |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| **Tuple** | ✓ | ✓ | ✓ | ✕ | ✕ | ✕ | ✕ |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| **State** | ✕ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: 'Understanding category theory and all these data types and specifications is
    beyond the scope of this book. However, in this chapter, we are going to learn
    the basics of two of the most common algebraic data types: the `Functor` and the
    `Monad`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the `fantasy – land` project at [https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)
    and the `ramda – fantasy` project at [https://github.com/ramda/ramda-fantasy](https://github.com/ramda/ramda-fantasy)
    to learn more about algebraic data types.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Functor
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Functor` is an object that holds a value and implements a method named `map`.
    The following code snippet declares a class named `Container`. This class can
    be considered a `Functor`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Functor` 是一个包含值并实现名为 `map` 的方法的对象。以下代码片段声明了一个名为 `Container` 的类。这个类可以被认为是一个
    `Functor`：'
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can use the container as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用容器：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At this point, it might feel like a `Functor` is not very useful because we
    have implemented the most basic version possible. The next two sections implement
    two functors known as `Maybe` and `Either`. These two functors are much more useful
    and should demonstrate that functors are a powerful tool.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能觉得 `Functor` 并不是非常有用，因为我们已经实现了最基本版本。接下来的两个部分将实现两个名为 `Maybe` 和 `Either`
    的已知 `Functor`。这两个 `Functor` 要有用得多，应该能证明 `Functor` 是一个强大的工具。
- en: Applicative
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Applicative
- en: 'An `Applicative` is a `Functor` that implements a method named of:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicative` 是一个实现名为 `of` 的方法的 `Functor`：'
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can use the `Applicative` as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用 `Applicative`：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Please note that the entire example is included in the companion source code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: Maybe
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maybe
- en: 'The following `Maybe` data type is a `Functor` and an `Applicative`, which
    means it contains a value and implements the map method. The main difference with
    the preceding implementation of `Functor` is that in the `Maybe Functor`, the
    value contained by the data type is optional:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `Maybe` 数据类型是一个 `Functor` 和一个 `Applicative`，这意味着它包含一个值并实现了 map 方法。与前面实现的
    `Functor` 的主要区别在于，在 `Maybe Functor` 中，数据类型包含的值是可选的：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can see in the preceding implementation of the `map` method, the mapping
    function is only applied if the `Maybe` data type contains a value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面 `map` 方法的实现中看到的，只有当 `Maybe` 数据类型包含值时，映射函数才会应用。
- en: 'To demonstrate how to use the `Maybe` type and why it is useful, we are going
    to declare a function to fetch the latest TypeScript news in [www.reddit.com](http://www.reddit.com):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用 `Maybe` 类型以及为什么它是有用的，我们将声明一个函数来获取 [www.reddit.com](http://www.reddit.com)
    上的最新 TypeScript 新闻：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding code snippet uses the fetch API to send an HTTP request. This
    is an asynchronous operation, which explains why the snippet creates a promise
    instance. When the operations are completed successfully, the response is returned
    as a `Maybe` instance. When the operations are completed unsuccessfully, an empty
    `Maybe` instance is returned.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用 fetch API 发送 HTTP 请求。这是一个异步操作，这也是为什么代码片段创建了一个 promise 实例。当操作成功完成时，响应以
    `Maybe` 实例的形式返回。当操作未成功完成时，返回一个空的 `Maybe` 实例。
- en: 'The following code snippet demonstrates how we can use the `fetchNews` function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何使用 `fetchNews` 函数：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding code snippet uses `fetchNews` to fetch a list of posts about TypeScript
    from Reddit. If the request is completed successfully, the `fetchNews` function
    returns the HTTP response wrapped in a `MayBe` instance. We then use the `map`
    method to find the list of posts within the response. The nice thing about using
    a `MayBe` instance is that mapping logic is only executed if there is an actual
    response, so we don't need to worry about potential null or undefined errors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用 `fetchNews` 从 Reddit 获取 TypeScript 相关的帖子列表。如果请求成功完成，`fetchNews` 函数将返回一个包装在
    `MayBe` 实例中的 HTTP 响应。然后我们使用 `map` 方法来查找响应中的帖子列表。使用 `MayBe` 实例的好处是，只有当实际有响应时，映射逻辑才会执行，所以我们不需要担心潜在的
    null 或 undefined 错误。
- en: Please note that the preceding example uses some browser APIs, which means that
    we need to add `dom` to the `lib` field in our `tsconfig.json` file. This will
    prevent compilation errors such as Cannot find name *console*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的例子使用了一些浏览器 API，这意味着我们需要在我们的 `tsconfig.json` 文件中将 `dom` 添加到 `lib` 字段中。这将防止出现无法找到名称
    *console* 的编译错误。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: Either
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Either
- en: 'The `Either` algebraic data type is the union of the `Just` and `Nothing` types:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 代数数据类型是 `Just` 和 `Nothing` 类型的并集：'
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Just` type is a `Functor` used to represent a non-nullable value:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Just` 类型是一个 `Functor`，用于表示非空值：'
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `Nothing` type represents the lack of a value:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing` 类型表示值的缺失：'
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following code snippet is an implementation of the `fetchNews` function
    that we declared in the preceding section. The main difference this time is that
    we will return an instance of `Just` if the HTTP request is completed successfully
    and an instance of `Nothing` if the HTTP request is not completed successfully:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是我们之前章节中声明的`fetchNews`函数的实现。这次的主要区别是，如果HTTP请求成功完成，我们将返回一个`Just`实例，如果HTTP请求没有成功完成，我们将返回一个`Nothing`实例：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we try to use `map` on an `Either` instance, we will get a compilation error:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在一个`Either`实例上使用`map`，我们将得到一个编译错误：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can use a type guard to ensure that we are accessing a `Nothing` instance
    when the request fails and a `Just` instance if the request was completed without
    errors:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类型守卫来确保在请求失败时访问一个`Nothing`实例，如果请求无错误完成，则访问一个`Just`实例：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The good thing about using Either is that the compiler forces us to use a type
    guard. This means that using an Either can lead to increased type safety when
    dealing with potential failures in operations.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Either`的好处是编译器强制我们使用类型守卫。这意味着使用`Either`可以在处理操作中的潜在失败时提高类型安全性。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例都包含在配套的源代码中。
- en: Monad
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态
- en: We are going to finish our introduction to algebraic data types by learning
    about monads. A `Monad` is a `Functor`, but it also implements the `Applicative`
    and `Chain` specifications.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过学习关于模态的内容来完成对代数数据类型的介绍。`Monad`是一个`Functor`，但它还实现了`Applicative`和`Chain`规范。
- en: 'We can transform the previously declared `Maybe` data type into a `Monad` by
    adding two extra methods named `join` and `chain`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加两个额外的方法`join`和`chain`将之前声明的`Maybe`数据类型转换为`Monad`：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `Maybe` data type was already a `Functor` and an `Applicative`, but now
    it is also a `Monad`. The following code snippet showcases how we can use it:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe`数据类型已经是一个`Functor`和一个`Applicative`，但现在它也是一个`Monad`。以下代码片段展示了我们如何使用它：'
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding code snippet demonstrates how the `join` and `chain` methods work.
    As we can see, they are very useful when we have a `Functor` of a `Functor`, and
    we want to access the contained value. The `chain` method is just a one-step shortcut
    for the two operations, `join` and `map`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段展示了`join`和`chain`方法的工作方式。正如我们所见，当我们在一个`Functor`的`Functor`中，并且想要访问包含的值时，它们非常有用。`chain`方法只是`join`和`map`这两个操作的简化一步。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例都包含在配套的源代码中。
- en: Real-world FP
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际世界的FP
- en: In this section, we are going to explore some open source libraries that can
    be useful while working in a real-world FP application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些在实际的FP应用程序中可能有用的开源库。
- en: Immutable.js
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Immutable.js
- en: 'As we have learned in this chapter, one of the main ideas in FP is minimizing
    the number of places in which state is mutated in our application. However, in
    JavaScript, objects are not immutable, which we can lead us to mutate the application''s
    state by mistake. For example, we could try to sort an array using the following
    function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章所学，函数式编程（FP）中的一个主要思想是在我们的应用程序中尽量减少状态发生变异的地方的数量。然而，在JavaScript中，对象不是不可变的，这可能会让我们不小心变异应用程序的状态。例如，我们可以尝试使用以下函数对数组进行排序：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding function could lead to issues because the `sort` method mutates
    the original array. This example is a demonstration of what is known as an implicit
    mutation. We mutated the application's state, but we didn't do it explicitly.
    `Immutable.js` helps us to make all the mutations in our application explicit.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数可能会导致问题，因为`sort`方法会变异原始数组。这个例子是关于所谓的隐式变异的演示。我们变异了应用程序的状态，但没有明确地这样做。`Immutable.js`帮助我们使应用程序中的所有变异都变得明确。
- en: 'We can install `immutable` using `npm`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`npm`安装`immutable`：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: No type definitions are required because they are already included in the `immutable`
    package.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要类型定义，因为它们已经包含在`immutable`包中。
- en: 'The following code snippet demonstrates how to transform objects into immutable
    objects and how to work with them. The immutable API includes methods such as
    `set`, `mergeDeep`, or `updateIn` that allow us to work with basic objects and
    nested objects:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将对象转换为不可变对象以及如何使用它们。不可变API包括`set`、`mergeDeep`或`updateIn`等方法，允许我们处理基本对象和嵌套对象：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Please note that the entire example is included in the companion source code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例都包含在配套的源代码中。
- en: These immutable objects cannot be mutated. The methods return new copies of
    the original objects, instead of mutating them. Immutable uses some smart algorithms
    and data structures to share some memory between objects and to be as efficient
    as possible when comparing them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不可变对象不能被修改。方法返回原始对象的新副本，而不是修改它们。不可变使用一些智能算法和数据结构在对象之间共享一些内存，并在比较它们时尽可能高效。
- en: Ramda
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ramda
- en: In a real-world application, we don't need to create our own our FP utilities
    (for example, compose or curry functions). We can use existing JavaScript libraries
    that already implement these helpers and many others. One of these libraries is
    `Ramda`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们不需要创建自己的函数式编程工具（例如，组合或柯里化函数）。我们可以使用已经实现这些辅助函数和许多其他函数的现有JavaScript库。其中之一就是
    `Ramda`。
- en: 'We can install `Ramda` using `npm`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用 `npm` 安装 `Ramda`:'
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`Ramda` includes helper functions to implement function composition, currying,
    and many more FP techniques, and its API is influenced by the pointfree style.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ramda` 包含用于实现函数组合、柯里化和许多其他函数式编程技术的辅助函数，并且其API受到无参数风格的影响。'
- en: 'The following code snippet re-implements the example that we used earlier in
    this chapter in the *Currying* section but uses the `Ramda` implementations of
    compose and currying, instead of using custom implementations:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段重新实现了本章 *柯里化* 部分中使用的示例，但使用了 `Ramda` 的组合和柯里化实现，而不是使用自定义实现：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Please note that the entire example is included in the companion source code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: React and MobX
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 和 MobX
- en: Earlier in the chapter, we learned that FP reduces the number of places in which
    state changes take place within an application and tries to move these places
    into the boundaries of the application to try to keep application's core stateless.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们了解到函数式编程减少了应用程序中状态变化发生的位置数量，并试图将这些位置移动到应用程序的边界内，以尝试保持应用程序的核心状态无状态。
- en: '`React` and `MobX` are two popular open source libraries that can be used to
    build user interfaces. These libraries are highly influenced by FP and try to
    prevent state mutations by using pure functions and immutable objects (powered
    by libraries such as `Immutable.js`). However, state mutations must take place
    at some point. That is the main role of `MobX`, a library that allows us to manage
    the state in a `React` application.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`React` 和 `MobX` 是两个流行的开源库，可用于构建用户界面。这些库深受函数式编程的影响，并试图通过使用纯函数和不可变对象（由如 `Immutable.js`
    这样的库提供支持）来防止状态修改。然而，状态修改必须在某个时刻发生。这就是 `MobX` 的主要作用，这是一个允许我们在 `React` 应用程序中管理状态的库。'
- en: In a `MobX` application, a new state should only be generated within one of
    the application's components, known as a `Store`. This is a very clear example
    of an FP architecture because it pushes all the state mutations in the entire
    application to one unique location.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MobX` 应用程序中，新的状态应该只在一个称为 `Store` 的应用程序组件内生成。这是一个非常清晰的函数式编程架构示例，因为它将整个应用程序中的所有状态修改推到了一个唯一的位置。
- en: Please refer to [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml), *Frontend
    Development with React and TypeScript*, to learn more about `React` and `MobX`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第11章](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml)，*使用React和TypeScript进行前端开发*，以了解更多关于
    `React` 和 `MobX` 的信息。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by learning some of the main FP concepts, including
    concepts such as pure functions, higher-order functions, and immutability.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习一些主要的函数式编程（FP）概念开始本章，包括纯函数、高阶函数和不可变性等概念。
- en: We also learned some of the main FP techniques, including techniques such as
    functional composition, function partial application, and currying.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了主要的函数式编程技术，包括函数组合、函数部分应用和柯里化等技术。
- en: Later, we learned what category theory is and how to work with some algebraic
    data types.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了范畴论是什么以及如何处理一些代数数据类型。
- en: Finally, we learned about some FP libraries that can help us to put some of
    these techniques and concepts into practice in a real-world application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了一些可以帮助我们在实际应用中实现这些技术和概念的函数式编程库。
- en: In the next chapter, we will learn how to work with decorators.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用装饰器。
