- en: Functional Programming with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has been a multi-paradigm programming language since its inception
    back in 1995\. It allows us to take advantage of an object-oriented programming
    style, but it also allows us to take advantage of a **functional programming**
    (**FP**) style. The same can be said about TypeScript. However, TypeScript is
    even better suited to FP than JavaScript because, as we will learn in this chapter,
    static type systems and type inference are very important in FP languages, such
    as the ML family of programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript and TypeScript ecosystems have experienced a significant increase
    in interest in FP over the last 3 or 4 years. I believe that the cause of this
    increase in interest is the success of React. React is a library used to build
    user interfaces developed by Facebook, which is highly influenced by some core
    FP concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about React toward the end of this book, but, for now, we
    will focus on learning how to use some basic FP techniques with TypeScript on
    its own and with some small FP libraries such as `Immutable.js` and `Ramda`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying and Pointfree style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes and sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FP concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FP receives its name from the way we build applications when we use it as our
    preferred programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: In a programming paradigm such as object-oriented programming, the main building
    blocks that we use to create an application are objects (objects are declared
    using classes). However, in FP we use functions as the main building block in
    our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Each new programming paradigm introduces a series of concepts and ideas associated
    with it. Some of these concepts are universal and are also of interest while learning
    a different programming paradigm. In object-oriented programming, we have concepts
    such as inheritance, encapsulation, and polymorphism. In FP we have concepts such
    as higher-order functions, function partial application, immutability, and referential
    transparency. We will try to learn about some of these concepts in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Michael Feathers, the author of the SOLID acronym and many other well-known
    software engineering principles, once wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Object-oriented programming makes code understandable by encapsulating moving
    parts. Functional Programming makes code understandable by minimizing moving parts."'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding quote mentions <q>moving parts</q>; we should understand these
    moving parts as state changes (also known as state mutations). In object-oriented
    programming, we use encapsulation to prevent objects from being aware of the state
    mutations of other objects. In FP we try to avoid dealing with a mutable state
    instead of encapsulating it. FP reduces the number of places in which state changes
    take place within an application and tries to move these places into the boundaries
    of the application to try to keep application's core stateless.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mutable state is bad because it makes the behavior of our code harder to
    predict. Take, for example, the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet declared a function named `isIndexPage`. This function
    can be used to check whether the current page is the root page in a web application
    based on the current path.
  prefs: []
  type: TYPE_NORMAL
- en: The path is some data that changes all the time, so we can consider it a piece
    of state. If we try to predict the result of invoking the `isIndexPage`, we will
    need to know the current state. The problem is that we could wrongly assume that
    the state has not changed since the last known state. We can solve this problem
    by transforming the function into a pure function, as we will learn in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FP introduces some concepts and principles that will help us to improve the
    predictability of our code. Let''s look at one of these core concepts: **pure
    functions**.'
  prefs: []
  type: TYPE_NORMAL
- en: A function can be considered pure when it returns a value computed using only
    the arguments passed to it. Also, a pure function avoids mutating its arguments
    or any other external variables. As a result, a pure function always returns the
    same value given the same arguments, independently of when it is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isIndexPage` function declared in the preceding section is not a pure
    function because it accesses the `pathname` variable and it has not been passed
    as an argument to the function. We can transform the preceding function into a
    pure function by rewriting it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Even though this is a basic example, we can easily perceive that the newer version
    is much easier to predict. Pure functions help us to make our code easier to understand,
    maintain, and test.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we wanted to write a unit test for the impure version of the `isIndexPage`
    function. We would encounter some problems when trying to test because the function
    uses the `window.location` object. We could overcome this issue using a mocking
    framework, but it would add a lot of complexity to our unit tests just because
    we didn't use a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, testing the pure version of the `isIndexPage` function would
    be straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how FP helps us to write better code by avoiding state
    mutations, we can learn about side effects and referential transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we learned that a pure function returns a value that
    can be computed using only the arguments passed to it. A pure function also avoids
    mutating its arguments or any other external variable that is not passed to the
    function as an argument. In FP terminology, it is common to say that a pure function
    is a function that has no side effects. This means that when we invoke a pure
    function, we can expect that the function is not going to interfere (via a state
    mutation) with any other component in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages, such as Haskell, can ensure that an application
    is free of side effects using its type system. TypeScript has fantastic interoperability
    with JavaScript, but the downside of this, compared to a more isolated language
    such as Haskell, is that the type system is not able to guarantee that our application
    is free of side effects.
  prefs: []
  type: TYPE_NORMAL
- en: If you like the idea of your JavaScript applications being free of side effects,
    you can try open source projects such as [https://github.com/bodil/eslint-config-cleanjs](https://github.com/bodil/eslint-config-cleanjs).
    The project is an ESLint configuration that aims to restrict you to a subset of
    JavaScript that is as close to an idealized pure functional language as possible.
    Unfortunately, at the time of writing, there were no similar tools available that
    were specifically designed for TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Referential transparency is another concept closely related to pure functions
    and side effects. A function is pure when it is free of side effects. An expression
    is said to be referentially transparent when it can be replaced with its corresponding
    value without changing the application's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: A pure function is a referentially transparent expression. An expression that
    is not referentially transparent is known as referentially opaque.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutability refers to the inability to change the value of a variable after
    a value has been assigned to it. Purely FP languages include immutable implementations
    of common data structures. For example, when we add an element to an array, we
    are mutating the original array. However, if we use an immutable array, and we
    try to add a new element to it, the original array will not be mutated, and we
    will add the new item to a copy of it.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript and TypeScript, we can use the `Immutable.js` library to enjoy
    immutable data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class citizens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common to find mentions of functions as <q>first-class citizens</q> in
    FP literature. We say that a function is a <q>"first-class citizen"</q> when it
    can do everything that a variable can do. This means that functions can be passed
    to other functions as an argument or to be returned by another function. Functions
    can also be assigned to variables. Both JavaScript and TypeScript treat functions
    as <q>"first-class citizens"</q>.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda expressions are just expressions that can be used to declare anonymous
    functions (functions without a name). Before the ES6 specification, the only way
    to assign a function as a value to a variable was using a function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The ES6 specification introduced the arrow function syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml), *Working
    with Functions*, and [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime,* to learn more about arrow functions and function
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Function arity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The arity of a function is the number of arguments that the function takes.
    A unary function is a function that only takes one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unary functions are very important in FP because they facilitate the usage of
    the function composition pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the function composition pattern later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **binary function** is a function that takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Functions with two or more arguments are also important because some of the
    most common FP patterns and techniques (for example, partial application and currying)
    have been designed to transform functions that allow multiple arguments into unary
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about partial application and currying later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also functions with three (**ternary function**) or more arguments.
    However, functions that accept a variable number of arguments, known as **variadic
    functions**, are particularly interesting in FP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A higher-order function is a function that does at least one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes one or more functions as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a function as its result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions are one of the most powerful tools that we can use to
    write JavaScript in an FP style. Let's see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a function named `addDelay`. The function
    creates a new function that waits a given number of microseconds before printing
    a message in the console. The function is considered a higher-order function because
    it takes a function as one of its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet declares a function named `addDelay`. The function
    adds a delay in microseconds to the execution of another function that is passed
    as an argument. The function is considered a higher-order function because it
    returns a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet declares a function named `addDelay`. The function
    creates a new function that adds a delay in microseconds to the execution of another
    function that is passed as an argument. The function is considered a higher-order
    function because it takes a function as an argument and returns a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Higher-order functions are an effective technique to abstract a solution for
    a common problem. The preceding example demonstrates how we can use a higher-order
    function (`addDelay`) to add a delay to another function (`sayHello`). This allows
    us to abstract the delay functionality and keep the `sayHello` function or other
    functions agnostic of the implementation details of the delay functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of FP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing TypeScript code using an FP style has many benefits, among which we
    can highlight the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testable code**: If we try to write our functions pure functions, we will
    be able to write unit tests extremely easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code is easy to reason about**: FP can seem hard to understand for developers
    with a lack of experience in FP. However, when an application is implemented correctly
    using the FP paradigm, the results are very small functions (often one-line functions)
    and very declarative APIs that can be reasoned about with ease.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: Most of our functions are stateless, and our entities are
    mostly stateless. We push state out of the core of our application, which makes
    our applications much more likely to be able to support many concurrent operations
    and be more scalable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Strategies for caching results become much simpler when we can
    predict the output of a function given its arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is TypeScript a FP language?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The answer to this question is yes, but only partially. TypeScript is a multi-paradigm
    programming language and, as a result, it includes many influences from both object-oriented
    programming languages and FP languages.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we focus on TypeScript as an FP language, we can observe that it
    is not a purely FP language because, for example, the TypeScript compiler doesn't
    enforce our code to be free of side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Not being a purely FP language should not be interpreted as something negative.
    TypeScript provides us with an extensive set of features and allows us to take
    advantage of some of the best features of both the world of object-oriented programming
    languages and the world of FP languages.
  prefs: []
  type: TYPE_NORMAL
- en: FP techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned about the most common FP concepts, it is time to learn
    about the most common FP techniques and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional composition** is a technique or pattern that allows us to combine
    multiple functions to create a more complex function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a function used to trim a string and a
    function used to transform a piece of text in uppercase text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a function that performs both the preceding operations by composing
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `trimAndCapitalize` is a function that invokes the `trim` function
    using `s` as its argument and passes its return to the `capitalize` function.
    We can invoke the `trimAndCapitalize` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The composition of two functions `f(x)` and `g(x)` is defined as `f(g(x))`,
    and that is exactly what we have done in the `trimAndCapitalize` function. However,
    such a behavior can be abstracted using a higher-order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the preceding function to compose two given functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the `trimAndCapitalize` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'One important thing to note is that the result of the `g` function is passed
    as the argument of the `f` function. This means that `f` can only take one argument
    (it must be a unary function), and its type must match the return type of the
    `g` function. A more correct definition of the `compose` function would be something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compose `composed` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can declare a higher-order function to compose three functions
    in one call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a helper that allows us to compose an unlimited number of
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Functional composition is an extremely powerful technique, but it can be hard
    to put into practice in certain scenarios, for example, when our functions are
    not unary functions. However, there are other techniques that can help in those
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Partial application** is an FP technique that allows us to pass the arguments
    required by a function at different points in time.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique can feel like a weird idea at first glance because most software
    engineers are used to the idea of applying (also known as invoking) a function
    at one unique point in time (complete application), as opposed to applying a function
    at multiple points in time (partial application).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet implements a function that doesn''t support partial
    application and invokes it (providing all the required arguments) at one single
    point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet implements the preceding function as a higher-order
    function to allow us to provide the required arguments at different points in
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, the first and the second arguments
    are provided at a different point in time. However, it cannot be considered an
    example of function partial application because the two functions are unary functions,
    and we have provided one argument at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write a function that allows both its complete and partial application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example can be considered an example of partial application because
    we can apply the function with all its arguments (complete application) or some
    of them (partial application).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how function partial application works, let''s focus on why
    it is useful. In the preceding *Composition* section, we learned how to compose
    two functions named `trim` and `capitalize` into a third function named `trimAndCapitalize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Function composition works very well with unary functions but not so well with
    binary or ternary functions. We are going to declare the following function to
    demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function can be used to replace a substring in given string.
    Unfortunately, the function cannot be used with compose with ease because it is
    not a unary function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can implement the function in a way that allows us to apply the
    function partially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the compose function without problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to our knowledge of function partial application, we can use compose
    with ease, without having to worry about the arity of the functions. However,
    enabling partial application requires a significant amount of manual boilerplate.
    In the next section, we will learn how an FP technique known as currying can help
    us to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Currying** is an FP technique that allows us to use partial application without
    having to worry about partial application while we write our functions. Currying
    is the process of taking a function that takes multiple arguments and transforming
    it into a chain of unary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is a higher-order function that allows us to abstract
    our functions from the partial application functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `curry2` function allows us to transform a binary function into two unary
    functions. The `curry2` function is a higher-order function and can be used with
    any binary function. For example, in the preceding code snippet, we passed the
    add function to the `curry2` function, but the following example passes the multiply
    function to the `curry2` function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding *Partial application* section, we learned how to use partial
    application to use compose with functions that are not unary. We declared the
    following function named `replace` and then passed it to the `compose` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can declare a function named `curry3` that transforms a ternary function
    into a chain of three unary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `curry3` function to rewrite the `replace` function in
    a way that is agnostic of the function partial application implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pipe is a function or operator that allows us to pass the output of a function
    as the input of another. JavaScript and TypeScript don''t support piles natively
    (as an operator), but we can implement our pipes using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use the `curry3`, `trim`, `capitalize`, and `replace` functions
    that we declared previously in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the pipe function to declare a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `pipe` function ensures that the output of the `trim` function is passed
    to the `capitalize` function. The return of the `capitalize` function is then
    passed to the `replace` function, which has been already partially applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an official proposal to add a new operator to JavaScript known as
    the pipeline operator (|>). This operator will allow us to implement a pipe as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the pipeline operator proposal: [https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator).
    Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Pointfree style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tacit programming, also known as **pointfree style**, is a programming style
    in which function declarations do not declare the arguments (or <q>points</q>)
    on which they operate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a few functions that are used to determine
    whether a person is eligible to vote in elections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet didn''t use any of the FP techniques that we have
    already learned in this chapter. The following code snippet implements an alternative
    solution for the same problem, using techniques such as partial application. This
    code snippet declares two functions named `both` and `either` that can be used
    to determine whether a variable matches the requirements specified by some or
    both functions, provided to these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the functions `isCitizen` and `isEligibleToVote` take some functions
    as arguments, but they don''t mention which data they expect as arguments. For
    example, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we could write the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This style, in which we avoid referencing the function arguments, is known
    as pointfree style, and it has some advantages over more conventional function
    declaration styles:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes programs simpler and more concise. This isn't always a good thing,
    but it can be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes algorithms easier to understand by focusing only on the functions being
    combined; we get a better sense of what's going on without the data arguments
    getting in the way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It forces us to think more about the how the data is used than about which data
    is being used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps us think about our functions as generic building blocks that can work
    with different kinds of data, rather than thinking about them as operations on
    a kind of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function that calls itself is known as a **recursive function**. The following
    function is a recursive function that allows us to calculate the factorial of
    a given number *n*. The factorial is the product of all positive integers less
    than or equal to *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Category theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FP has a reputation for being difficult to learn and understand because of its
    mathematical background. FP languages and design patterns are influenced by concepts
    that originated in many different mathematical fields. However, we can highlight
    **category theory** as one of the most significant fields of influence. We can
    think about category theory as an alternative to set theory, which defines the
    theory behind a series of data structures or objects known as **algebraic data
    types**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many algebraic data types, and understanding all their properties
    and rules that they must implement requires a significant amount of time and effort.
    The following diagram illustrates the relationships between some of the most common
    algebraic data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/435b9b31-f36a-47ba-8301-2a4b400592b6.png)'
  prefs: []
  type: TYPE_IMG
- en: The arrows in the diagram indicate that a given algebraic data type must implement
    the specification of some other algebraic data types. For example, the `Monad`
    type must implement the specifications of the `Applicative` and `Chain` types.
  prefs: []
  type: TYPE_NORMAL
- en: The open source project `fantasy – land` declares a specification for some of
    these algebraic data types, while the open source project `ramda – fantasy` implements
    the specifications in a way that is compatible with `Ramda`, which is a popular
    FP library that we will explore later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The algebraic data type specifications can be implemented in many ways. For
    example, the fnctor specification can be implemented by a `Maybe` or an `Either`
    data type. Both types implement the `Functor` specification but can also implement
    other specifications, such as the monad or the applicative specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes which specifications (listed in the top row)
    are implemented by one of the algebraic data type implementations (left row) in
    the `ramda – fantasy` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Setoid** | **Semigroup** | **Functor** | **Applicative** | **Monad**
    | **Foldable** | **ChainRec** |'
  prefs: []
  type: TYPE_TB
- en: '| **Either** | ✓ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| **Future** | ✕ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| **Identity** | ✓ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| **IO** | ✕ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| **Maybe** | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| **Reader** | ✕ | ✕ | ✓ | ✓ | ✓ | ✕ | ✕ |'
  prefs: []
  type: TYPE_TB
- en: '| **Tuple** | ✓ | ✓ | ✓ | ✕ | ✕ | ✕ | ✕ |'
  prefs: []
  type: TYPE_TB
- en: '| **State** | ✕ | ✕ | ✓ | ✓ | ✓ | ✕ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: 'Understanding category theory and all these data types and specifications is
    beyond the scope of this book. However, in this chapter, we are going to learn
    the basics of two of the most common algebraic data types: the `Functor` and the
    `Monad`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the `fantasy – land` project at [https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)
    and the `ramda – fantasy` project at [https://github.com/ramda/ramda-fantasy](https://github.com/ramda/ramda-fantasy)
    to learn more about algebraic data types.
  prefs: []
  type: TYPE_NORMAL
- en: Functor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Functor` is an object that holds a value and implements a method named `map`.
    The following code snippet declares a class named `Container`. This class can
    be considered a `Functor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: At this point, it might feel like a `Functor` is not very useful because we
    have implemented the most basic version possible. The next two sections implement
    two functors known as `Maybe` and `Either`. These two functors are much more useful
    and should demonstrate that functors are a powerful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `Applicative` is a `Functor` that implements a method named of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `Applicative` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following `Maybe` data type is a `Functor` and an `Applicative`, which
    means it contains a value and implements the map method. The main difference with
    the preceding implementation of `Functor` is that in the `Maybe Functor`, the
    value contained by the data type is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding implementation of the `map` method, the mapping
    function is only applied if the `Maybe` data type contains a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to use the `Maybe` type and why it is useful, we are going
    to declare a function to fetch the latest TypeScript news in [www.reddit.com](http://www.reddit.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet uses the fetch API to send an HTTP request. This
    is an asynchronous operation, which explains why the snippet creates a promise
    instance. When the operations are completed successfully, the response is returned
    as a `Maybe` instance. When the operations are completed unsuccessfully, an empty
    `Maybe` instance is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how we can use the `fetchNews` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet uses `fetchNews` to fetch a list of posts about TypeScript
    from Reddit. If the request is completed successfully, the `fetchNews` function
    returns the HTTP response wrapped in a `MayBe` instance. We then use the `map`
    method to find the list of posts within the response. The nice thing about using
    a `MayBe` instance is that mapping logic is only executed if there is an actual
    response, so we don't need to worry about potential null or undefined errors.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the preceding example uses some browser APIs, which means that
    we need to add `dom` to the `lib` field in our `tsconfig.json` file. This will
    prevent compilation errors such as Cannot find name *console*.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Either` algebraic data type is the union of the `Just` and `Nothing` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Just` type is a `Functor` used to represent a non-nullable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Nothing` type represents the lack of a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet is an implementation of the `fetchNews` function
    that we declared in the preceding section. The main difference this time is that
    we will return an instance of `Just` if the HTTP request is completed successfully
    and an instance of `Nothing` if the HTTP request is not completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to use `map` on an `Either` instance, we will get a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a type guard to ensure that we are accessing a `Nothing` instance
    when the request fails and a `Just` instance if the request was completed without
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The good thing about using Either is that the compiler forces us to use a type
    guard. This means that using an Either can lead to increased type safety when
    dealing with potential failures in operations.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to finish our introduction to algebraic data types by learning
    about monads. A `Monad` is a `Functor`, but it also implements the `Applicative`
    and `Chain` specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transform the previously declared `Maybe` data type into a `Monad` by
    adding two extra methods named `join` and `chain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Maybe` data type was already a `Functor` and an `Applicative`, but now
    it is also a `Monad`. The following code snippet showcases how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet demonstrates how the `join` and `chain` methods work.
    As we can see, they are very useful when we have a `Functor` of a `Functor`, and
    we want to access the contained value. The `chain` method is just a one-step shortcut
    for the two operations, `join` and `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world FP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to explore some open source libraries that can
    be useful while working in a real-world FP application.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have learned in this chapter, one of the main ideas in FP is minimizing
    the number of places in which state is mutated in our application. However, in
    JavaScript, objects are not immutable, which we can lead us to mutate the application''s
    state by mistake. For example, we could try to sort an array using the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function could lead to issues because the `sort` method mutates
    the original array. This example is a demonstration of what is known as an implicit
    mutation. We mutated the application's state, but we didn't do it explicitly.
    `Immutable.js` helps us to make all the mutations in our application explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install `immutable` using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: No type definitions are required because they are already included in the `immutable`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how to transform objects into immutable
    objects and how to work with them. The immutable API includes methods such as
    `set`, `mergeDeep`, or `updateIn` that allow us to work with basic objects and
    nested objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: These immutable objects cannot be mutated. The methods return new copies of
    the original objects, instead of mutating them. Immutable uses some smart algorithms
    and data structures to share some memory between objects and to be as efficient
    as possible when comparing them.
  prefs: []
  type: TYPE_NORMAL
- en: Ramda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real-world application, we don't need to create our own our FP utilities
    (for example, compose or curry functions). We can use existing JavaScript libraries
    that already implement these helpers and many others. One of these libraries is
    `Ramda`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install `Ramda` using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`Ramda` includes helper functions to implement function composition, currying,
    and many more FP techniques, and its API is influenced by the pointfree style.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet re-implements the example that we used earlier in
    this chapter in the *Currying* section but uses the `Ramda` implementations of
    compose and currying, instead of using custom implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: React and MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in the chapter, we learned that FP reduces the number of places in which
    state changes take place within an application and tries to move these places
    into the boundaries of the application to try to keep application's core stateless.
  prefs: []
  type: TYPE_NORMAL
- en: '`React` and `MobX` are two popular open source libraries that can be used to
    build user interfaces. These libraries are highly influenced by FP and try to
    prevent state mutations by using pure functions and immutable objects (powered
    by libraries such as `Immutable.js`). However, state mutations must take place
    at some point. That is the main role of `MobX`, a library that allows us to manage
    the state in a `React` application.'
  prefs: []
  type: TYPE_NORMAL
- en: In a `MobX` application, a new state should only be generated within one of
    the application's components, known as a `Store`. This is a very clear example
    of an FP architecture because it pushes all the state mutations in the entire
    application to one unique location.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml), *Frontend
    Development with React and TypeScript*, to learn more about `React` and `MobX`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by learning some of the main FP concepts, including
    concepts such as pure functions, higher-order functions, and immutability.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned some of the main FP techniques, including techniques such as
    functional composition, function partial application, and currying.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we learned what category theory is and how to work with some algebraic
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about some FP libraries that can help us to put some of
    these techniques and concepts into practice in a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to work with decorators.
  prefs: []
  type: TYPE_NORMAL
