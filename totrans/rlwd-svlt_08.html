<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-120"><a id="_idTextAnchor121"/>8</h1>
<h1 id="_idParaDest-121"><a id="_idTextAnchor122"/>Context versus Stores</h1>
<p>A Svelte application can be composed of one or many Svelte components. A Svelte component can be seen as a standalone unit, encapsulating its own reactive data and logic. In the previous chapter, we learned how two Svelte components – in particular, components in a parent and child relationship – communicate and pass data between each other. In this chapter, however, we are going to explore communication and passing data between components beyond the parent and <span class="No-Break">child relationship.</span></p>
<p>Svelte provides two primitives to pass data across Svelte components – Svelte context and Svelte stores. Svelte context allows you to pass data from an ancestor to all children, while Svelte stores use the observer pattern to allow you to access reactive data across multiple unrelated <span class="No-Break">Svelte components.</span></p>
<p>In the coming five chapters, we are going to explore the different use cases of Svelte context and Svelte stores. In this chapter, we will cover what Svelte context and Svelte <span class="No-Break">stores are.</span></p>
<p>We will talk about when to use Svelte context and/or Svelte stores and the considerations for choosing them. We will then proceed with an example of a combination of both Svelte context and Svelte stores – a Svelte <span class="No-Break">context store.</span></p>
<p>By the end of this chapter, you’ll be proficient in using Svelte stores and Svelte context in your Svelte application. You will also understand when to use <span class="No-Break">them effectively.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Defining Svelte context and <span class="No-Break">Svelte stores</span></li>
<li>When to use Svelte context and <span class="No-Break">Svelte stores</span></li>
<li>Creating dynamic context using <span class="No-Break">Svelte stores</span></li>
</ul>
<h1 id="_idParaDest-122"><a id="_idTextAnchor123"/>Defining Svelte context</h1>
<p>When you need <a id="_idIndexMarker290"/>to pass data from a parent component to a child component, the first thing you should think of is <span class="No-Break">using props:</span></p>
<pre class="source-code">
&lt;Component props={value} /&gt;</pre> <p>What if you need to pass data from a parent component to a grandchild component? You could pass data as props from the parent component to the child component, and then from the child component to the <span class="No-Break">grandchild component:</span></p>
<pre class="source-code">
&lt;!-- Parent.svelte --&gt;
&lt;Child props={value} /&gt;
&lt;!-- Child.svelte --&gt;
&lt;script&gt;
  export let props;
&lt;/script&gt;
&lt;GrandChild props={props} /&gt;</pre> <p>What if you <a id="_idIndexMarker291"/>need to pass data from a parent component to a <span class="No-Break">great-grandchild component?</span></p>
<p>You could follow a process similar to what we did in the preceding code, passing the data through layers of components to reach the <span class="No-Break">great-grandchild component.</span></p>
<p>This <a id="_idIndexMarker292"/>approach is called <em class="italic">prop drilling</em>. It is akin to drilling a hole through layers of components via props. This is frowned upon in most cases due to the <span class="No-Break">following reasons:</span></p>
<ul>
<li>It is hard to trace where the data <span class="No-Break">comes from.</span><p class="list-inset">Whenever you want to trace where the data comes from in the child component, you may endlessly trace up through layers of the parent component, jumping through different Svelte <span class="No-Break">component files.</span></p><p class="list-inset">This slows you down and makes it harder to reason with the <span class="No-Break">data flow.</span></p></li>
<li>It is hard to trace where the data <span class="No-Break">leads to.</span><p class="list-inset">The data that’s passed down through props into the child component is not to be used by the child component directly, but to be passed through it to its child component. You would have to step through the layer of components to find out where the data is finally <span class="No-Break">being used.</span></p><p class="list-inset">You may lose sight of where the data goes and have less confidence in making changes to the data that’s <span class="No-Break">passed down.</span></p></li>
<li>It is hard to restructure the <span class="No-Break">component hierarchy.</span><p class="list-inset">When <a id="_idIndexMarker293"/>you add a new component in between the layers, you need to make sure to still pass the props through the new component from its parent to <span class="No-Break">its children.</span></p><p class="list-inset">When you move the components around, you need to make sure the child component still gets the props it needs by checking the chain of <span class="No-Break">parent components.</span></p></li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Keeping this in mind, when the component tree is small and simple, even with its drawback, passing props around may still be the simplest way to pass data from a parent to its <span class="No-Break">child components.</span></p>
<p>So, what is the alternative to <em class="italic">prop drilling</em>? <span class="No-Break">Svelte context.</span></p>
<p>Svelte context is a method that provides data to all child components, no matter how many levels down the component tree <span class="No-Break">they are.</span></p>
<p>A <a id="_idIndexMarker294"/>component tree is<a id="_idIndexMarker295"/> like a family tree for components. You have a parent component at the top, and one level down its child components, and one more level down is the child components of the <span class="No-Break">child components:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 8.1: Component tree diagram" height="420" src="image/B18887_08_01.jpg" width="711"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Component tree diagram</p>
<p>In the <a id="_idIndexMarker296"/>preceding <a id="_idIndexMarker297"/>component tree diagram, the top-left node represents where <strong class="source-inline">setContext</strong> is called, and all shaded nodes under the node can access the context value using <strong class="source-inline">getContext</strong>. To set a context value in a component, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">setContext()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { setContext } from 'svelte';
  setContext("key", value);
&lt;/script&gt;</pre> <p>All its child components and child components’ child components will be able to read the context value <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">getContext()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { getContext } from 'svelte';
  const value = getContext("key");
&lt;/script&gt;</pre> <p>If you paid attention to the preceding snippets, you may have noticed that we have been using strings as the context key when setting and reading context. However, you might wonder whether it is possible to use other data types as the context key. Let’s look <span class="No-Break">into this.</span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Using an object as a context key</h2>
<p>What is the underlying mechanism of <span class="No-Break">Svelte context?</span></p>
<p>Svelte context<a id="_idIndexMarker298"/> is implemented using a JavaScript <strong class="source-inline">Map</strong>, which means you can set values and read values out of Svelte context using a key, the same way you would with a <span class="No-Break">JavaScript map.</span></p>
<p>This also means that you can set more than one key to <span class="No-Break">Svelte context:</span></p>
<pre class="source-code">
&lt;script&gt;
  setContext("item", item);
  setContext("order", order);
&lt;/script&gt;</pre> <p>You just need to make sure you read them out using the same key you set the <span class="No-Break">context with.</span></p>
<p>As I mentioned earlier, Svelte context is implemented using a JavaScript <strong class="source-inline">Map</strong>, and the keys of a <strong class="source-inline">Map</strong> can be of any type, including functions, objects, or any primitives; you are not constrained to using just a <strong class="source-inline">String</strong> <span class="No-Break">key value:</span></p>
<pre class="source-code">
&lt;script&gt;
  const object = {};
  setContext(object, value);
&lt;/script&gt;</pre> <p>And just as how JavaScript <strong class="source-inline">Map</strong> works, if you set a context using an object, then you would need to use the same object instance to read the value out of the <span class="No-Break">Svelte context.</span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor125"/>Changing the context value</h2>
<p>One thing <a id="_idIndexMarker299"/>to take note of when using <strong class="source-inline">setContext</strong> and <strong class="source-inline">getContext</strong> is that these functions need to be called during component initialization. Read<a href="B18887_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> to recap on what component <span class="No-Break">initialization is.</span></p>
<p>If we can call <strong class="source-inline">setContext</strong> after component initialization, then this leads us to the next question – how would we change the <span class="No-Break">context value?</span></p>
<p>Look at the <span class="No-Break">following snippet:</span></p>
<pre class="source-code">
&lt;script&gt;
  let itemId = 123;
  setContext("itemid", itemId);
  itemId = 456;
&lt;/script&gt;</pre> <p>When<a id="_idIndexMarker300"/> calling <strong class="source-inline">setContext</strong> in line 3, we are passing the value of the <strong class="source-inline">itemId</strong> variable to the <strong class="source-inline">setContext</strong> function. Reassigning the <strong class="source-inline">itemId</strong> variable in line 5 would not make the context <span class="No-Break">value change.</span></p>
<p>This is how JavaScript works. If you call a function with a primitive-type variable, then the value of the variable is being passed in, and reassigning the variable outside of the function would not change the value of the variable that’s read from inside <span class="No-Break">the function.</span></p>
<p>How about passing an object as a context value? Let’s see how <span class="No-Break">that works:</span></p>
<pre class="source-code">
&lt;script&gt;
  let item = { id: 123 };
  setContext("item", item);
  item.id = 456;
&lt;/script&gt;</pre> <p>In JavaScript, objects are passed by reference. This means that the Svelte context and the <strong class="source-inline">item</strong> variable outside of the <strong class="source-inline">setContext</strong> function are referring to the same object. Mutating the object modifies the same referenced object and thus the changes can be seen when reading the <span class="No-Break">Svelte context:</span></p>
<pre class="source-code">
&lt;script&gt;
  const item = getContext("item");
&lt;/script&gt;
{item.id}</pre> <p>However, you <a id="_idIndexMarker301"/>may have noticed that after you render <strong class="source-inline">{item.id}</strong> onto the DOM, the value shown in the DOM does not change when you mutate it in the <span class="No-Break">parent component.</span></p>
<p>This does not mean <strong class="source-inline">item.id</strong> has not changed. If you try to print out <strong class="source-inline">item.id</strong> on an interval, you will notice that <strong class="source-inline">item.id</strong> has changed, but the value in the DOM remains <span class="No-Break">the same:</span></p>
<pre class="source-code">
const item = getContext("item");
setInterval(() =&gt; {
  console.log(item.id);
}, 1000);</pre> <p>Why would <span class="No-Break">this happen?</span></p>
<p>Svelte tracks variable mutations and reassignments within a Svelte component and instruments operations to update the DOM to reflect the changes. However, what this means is that changes that happen outside of the component are not tracked, and therefore the DOM does not reflect <span class="No-Break">such changes.</span></p>
<p>So, what should we do to make Svelte aware of changes to a variable outside of <span class="No-Break">the component?</span></p>
<p>This is where the Svelte store <span class="No-Break">comes in.</span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor126"/>Defining the Svelte store</h1>
<p>To understand <a id="_idIndexMarker302"/>why Svelte reactivity is limited within a Svelte component, we must first understand how Svelte’s <span class="No-Break">reactivity works.</span></p>
<p>Unlike some other frameworks, Svelte reactivity works during build time. As Svelte compiles a Svelte component into JavaScript, Svelte looks at each variable and tracks the variable to see when the <span class="No-Break">variable changes.</span></p>
<p>Instead of tracking all the variables throughout the application, Svelte limits itself to only analyzing and compiling one file at a time. This allows Svelte to compile multiple Svelte component files in parallel but also means that a Svelte component would not be aware of variable changes that happen in <span class="No-Break">other files.</span></p>
<p>A common situation where a variable change is not tracked is when the variable is defined in a separate file and imported into the <span class="No-Break">current component.</span></p>
<p>In the following <a id="_idIndexMarker303"/>code snippet, the <strong class="source-inline">quantity</strong> variable is imported from a separate file. Svelte will not track any changes to the <strong class="source-inline">quantity</strong> variable that may have occurred in <span class="No-Break">that file:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { quantity } from './item';
&lt;/script&gt;
&lt;p&gt;Quantity: {quantity}&lt;/p&gt;</pre> <p>If you attempt to modify the variable outside of the Svelte component, then Svelte is not able to track that. So, Svelte has no idea when you modify the variable and therefore will not be able to update the DOM when <span class="No-Break">that happens.</span></p>
<p>To make Svelte aware of the changes outside of the component and update the DOM accordingly, we will need to design a mechanism at runtime that will notify Svelte whenever a <span class="No-Break">variable changes.</span></p>
<p>For this, we can draw inspiration from the <strong class="bold">observer pattern</strong>. The observer pattern is a design pattern that lets you define a subscription mechanism to notify multiple objects when an <span class="No-Break">event happens.</span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>Using the observer pattern</h2>
<p>Here, instead of<a id="_idIndexMarker304"/> just importing the <strong class="source-inline">quantity</strong> variable, I am also importing a <strong class="source-inline">subscribe</strong> function, which we will <span class="No-Break">define later:</span></p>
<pre class="source-code">
import { quantity, subscribe } from './item';</pre> <p>The idea of the <strong class="source-inline">subscribe</strong> function is such that we can subscribe to know when <span class="No-Break"><strong class="source-inline">quantity</strong></span><span class="No-Break"> changes.</span></p>
<p>Here, we assume that <strong class="source-inline">subscribe</strong> takes in a callback function, which will be called whenever <strong class="source-inline">quantity</strong> changes. The callback function takes in a parameter that gives us the latest value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">quantity</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import { quantity, subscribe } from './item';
subscribe((newQuantity) =&gt; { ... });</pre> <p>So, now, although Svelte still cannot track changes to the <strong class="source-inline">quantity</strong> variable outside of the component, we can use the <strong class="source-inline">subscribe</strong> function to tell Svelte when <span class="No-Break">that happens.</span></p>
<p>As an example <a id="_idIndexMarker305"/>of how to tell Svelte this, we can define another variable called <strong class="source-inline">_quantity</strong> that initializes to be the same value <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">quantity</strong></span><span class="No-Break">.</span></p>
<p>Whenever <strong class="source-inline">quantity</strong> changes, the callback function that’s passed into the <strong class="source-inline">subscribe</strong> function should be called with the new <strong class="source-inline">quantity</strong> value. We will use this as an opportunity to update <strong class="source-inline">_quantity</strong> to the new <span class="No-Break"><strong class="source-inline">quantity</strong></span><span class="No-Break"> value:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { quantity, subscribe } from './item';
  let _quantity = quantity;
  subscribe((newQuantity) =&gt; { _quantity = newQuantity; });
&lt;/script&gt;
&lt;p&gt;Quantity: {_quantity}&lt;/p&gt;</pre> <p>Since the <strong class="source-inline">_quantity</strong> variable is defined within the component, and we update the value of the variable within the component (in the <strong class="source-inline">_quantity = newQuantity</strong> statement), Svelte can track the update of <strong class="source-inline">_quantity</strong>. And since the <strong class="source-inline">_quantity</strong> variable tracks the changes of the <strong class="source-inline">quantity</strong> variable itself, you can see that the DOM updates whenever <span class="No-Break"><strong class="source-inline">quantity</strong></span><span class="No-Break"> changes.</span></p>
<p>However, all of this depends on the <strong class="source-inline">subscribe</strong> function, which would call the callback function whenever the value of <span class="No-Break"><strong class="source-inline">quantity</strong></span><span class="No-Break"> changes.</span></p>
<p>So, let’s see how we can define the <span class="No-Break"><strong class="source-inline">subscribe</strong></span><span class="No-Break"> function.</span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor128"/>Defining the subscribe function</h2>
<p>There are multiple ways of defining the <span class="No-Break"><strong class="source-inline">subscribe</strong></span><span class="No-Break"> function.</span></p>
<p>Here, we <a id="_idIndexMarker306"/>are going to use an array and name it <strong class="source-inline">subscribers</strong> so that we can keep track of all the functions being called with <strong class="source-inline">subscribe</strong>. Then, when we attempt to update the value of <strong class="source-inline">quantity</strong>, we will iterate through the <strong class="source-inline">subscribers</strong> array to get each of the subscriber functions and call them <a id="_idIndexMarker307"/>one <span class="No-Break">by one:</span></p>
<pre class="source-code">
let subscribers = [];
function subscribe(fn) {
  subscribers.push(fn);
}
function notifySubscribers(newQuantity) {
  subscribers.forEach(fn =&gt; {
    fn(newQuantity);
  });
}</pre> <p>As an example, here, we want to update <strong class="source-inline">quantity</strong> to <strong class="source-inline">20</strong>. To make sure that the subscribers are notified of the changes, we call <strong class="source-inline">notifySubscribers</strong> with the updated value at the same time so that each <strong class="source-inline">subscribers</strong> is notified with the latest value <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">quantity</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
quantity = 20;
notifySubscribers(quantity);</pre> <p>Take your time when connecting the implementation of the <strong class="source-inline">subscribe</strong> and <strong class="source-inline">notifySubscribers</strong> functions in the preceding code back to the Svelte component code in the previous section. You will see that whenever we call <strong class="source-inline">notifySubscribers</strong>, the callback function that’s passed into the <strong class="source-inline">subscribe</strong> function will be called. <strong class="source-inline">_quantity</strong> will be updated, and the value in the DOM will <span class="No-Break">be updated.</span></p>
<p>So, it doesn’t matter if you are modifying <strong class="source-inline">quantity</strong> outside the Svelte component, so long as you call the <strong class="source-inline">notifySubscribers</strong> function. With the new value of <strong class="source-inline">quantity</strong>, Svelte will update the DOM elements to reflect the latest value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">quantity</strong></span><span class="No-Break">.</span></p>
<p>With the observer pattern, we are now able to define and update variables across <span class="No-Break">Svelte components.</span></p>
<p>You will see this pattern a lot in Svelte. Svelte encapsulates the idea of <strong class="source-inline">subscribe</strong> and <strong class="source-inline">notifySubscribers</strong> into a concept called a Svelte store. So, let’s explore what it means to be a Svelte store and explore what first-class support Svelte is providing for <span class="No-Break">Svelte stores.</span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>Defining a Svelte store</h2>
<p>A Svelte store is <a id="_idIndexMarker308"/>any object that follows the Svelte <span class="No-Break">store contract.</span></p>
<p>This means that any object that follows the Svelte store contract can be referred to as a Svelte store. As a Svelte store, there are a few syntactic sugars and built-in functions that come <span class="No-Break">with it.</span></p>
<p>Before we get ahead of ourselves, let’s take a look at what a Svelte store <span class="No-Break">contract is.</span></p>
<p>The Svelte store contract requires an object to have a <strong class="source-inline">subscribe</strong> method and an optional <span class="No-Break"><strong class="source-inline">set</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
const store = {
  subscribe() {},
  set() {},
};</pre> <p>I have not told you about the specific requirements for the <strong class="source-inline">subscribe</strong> and <strong class="source-inline">set</strong> methods, but I hope you can see the similarity in the <strong class="source-inline">subscribe</strong> and <strong class="source-inline">set</strong> methods in the Svelte store contract to the <strong class="source-inline">subscribe</strong> and <strong class="source-inline">notifySubscribers</strong> functions illustrated in the <span class="No-Break">previous section.</span></p>
<p>But something is missing here. Where do we place the store value, or the corresponding <strong class="source-inline">quantity</strong> variable from the <span class="No-Break">previous section?</span></p>
<p>Well, the store value is not part of the Svelte store contract, and we will soon <span class="No-Break">explain why.</span></p>
<p>Let’s continue with our requirements for the <strong class="source-inline">subscribe</strong> and <span class="No-Break"><strong class="source-inline">set</strong></span><span class="No-Break"> methods:</span></p>
<ul>
<li>The <strong class="source-inline">subscribe</strong> method has to return a function to unsubscribe from <span class="No-Break">the store.</span><p class="list-inset">This allows the subscriber to stop receiving updates of the latest <span class="No-Break">store value.</span></p><p class="list-inset">For example, if we use an array to keep track of the subscriber functions being called with the <strong class="source-inline">subscribe</strong> function, then we can use the returned function from <strong class="source-inline">subscribe</strong> to remove the subscriber function from the array since the <strong class="source-inline">subscriber</strong> function<a id="_idIndexMarker309"/> is no longer needed to receive any new updates from <span class="No-Break">the store:</span></p><pre class="source-code">
const subscribers = [];
const store = {
  subscribe(fn) {
    // add the fn to the list of subscribers
    subscribers.push(fn);
    // return a function to remove the fn from the list of subscribers
    return () =&gt; {
      subscribers.splice(subscribers.indexOf(fn), 1);
    };
  }
};</pre></li> <li>When the <strong class="source-inline">subscribe</strong> method is being called with a function, the function must be called immediately and synchronously with the <span class="No-Break">store value.</span><p class="list-inset">If the function is not called immediately, the store value is assumed to <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">undefined</strong></span><span class="No-Break">:</span></p><pre class="source-code">
let storeValue = 10;
const store = {
  subscribe(fn) {
    // immediately call the function with the store value
    fn(storeValue);
    // ...
  },
};</pre><p class="list-inset">This requirement means that to read the store value out from the Svelte store, you will need to use the <span class="No-Break"><strong class="source-inline">subscribe</strong></span><span class="No-Break"> method:</span></p><pre class="source-code">let storeValue;
store.subscribe((value) =&gt; {
  storeValue = value;
});
console.log(storeValue);</pre><p class="list-inset">In the <a id="_idIndexMarker310"/>preceding snippet, you can see that if the callback function that’s passed into the <strong class="source-inline">subscribe</strong> method is not being called immediately and synchronously, then immediately in the next statement where we console out the value of <strong class="source-inline">storeValue</strong>, you will see that the value of <strong class="source-inline">storeValue</strong> <span class="No-Break">remains </span><span class="No-Break"><strong class="source-inline">undefined</strong></span><span class="No-Break">.</span></p></li> <li>The <strong class="source-inline">set</strong> method of a Svelte store takes in a new store value and <span class="No-Break">returns nothing:</span><pre class="source-code">
store.set(newValue);</pre><p class="list-inset">The <strong class="source-inline">set</strong> method is supposed to update the value of the store. Naturally, we would implement the <strong class="source-inline">set</strong> method such that it will notify all the store subscribers of the latest <span class="No-Break">store value:</span></p><pre class="source-code">const store = {
  // ...
  set(newValue) {
    // notify subscribers with new store value
    for(const subscriber of subscribers) {
      subscriber(newValue);
    }
  },
};</pre></li> </ul>
<p>With that, we’ve <a id="_idIndexMarker311"/>gone through the requirements of a Svelte store contract. Along the way, we’ve also seen snippets of code on implementing each requirement of a Svelte store. By putting them together, we will have a <span class="No-Break">Svelte store.</span></p>
<p>Creating a Svelte store is such a common use case that Svelte has provided a few built-in functions to help us with <span class="No-Break">creating one.</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>Creating Svelte stores with built-in functions</h2>
<p>Svelte <a id="_idIndexMarker312"/>provides a sub-package that exports a few built-in functions for Svelte stores. You can import them from the <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">svelte/store'</strong></span><span class="No-Break"> package.</span></p>
<p>Here is the list of built-in Svelte <span class="No-Break">store functions:</span></p>
<ul>
<li><strong class="source-inline">readable()</strong> helps create a readable Svelte store. Since the <strong class="source-inline">set</strong> method in a Svelte contract is optional, a readable store is a store that does not implement the <span class="No-Break"><strong class="source-inline">set</strong></span><span class="No-Break"> method.</span><p class="list-inset">To update the store value, the <strong class="source-inline">readable()</strong> function takes in a callback function that will be called when the store is being subscribed, and the callback function is called with a <strong class="source-inline">set</strong> function that can be used to update the <span class="No-Break">store value:</span></p><pre class="source-code">
const store = readable(initialValue, (set) =&gt; {
  // update store value
  set(newValue);
});</pre><p class="list-inset">The <strong class="source-inline">set</strong> function in the callback function can be called numerous times. In the following example, we are calling the <strong class="source-inline">set</strong> function every second to update the store value to the <span class="No-Break">latest timestamp:</span></p><pre class="source-code">const store = readable(Date.now(), (set) =&gt; {
  setInterval(() =&gt; {
    // update store value to the current timestamp
    set(Date.now());
  }, 1000);
});</pre></li> <li><strong class="source-inline">writable()</strong> helps <a id="_idIndexMarker313"/>create a writable Svelte store. This is similar to the readable store, except it implements the <span class="No-Break"><strong class="source-inline">set</strong></span><span class="No-Break"> method:</span><pre class="source-code">
const store = writable(initialValue);
store.set(newValue);</pre></li> <li><strong class="source-inline">derived()</strong> creates a new Svelte store, deriving from <span class="No-Break">existing stores.</span><p class="list-inset">We will explore <strong class="source-inline">derived()</strong> in more detail in the next chapter when we talk about creating <span class="No-Break">custom stores.</span></p></li>
</ul>
<p>With <strong class="source-inline">readable()</strong>, <strong class="source-inline">writable()</strong>, and <strong class="source-inline">derived()</strong>, you can easily create a new Svelte store without having to implement the Svelte store <span class="No-Break">contract yourself.</span></p>
<p>So, we have built-in methods to create a Svelte store, but do we have any built-in methods for using Svelte stores? Let’s <span class="No-Break">find out.</span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Auto-subscribing to a Svelte store</h2>
<p>Since all Svelte <a id="_idIndexMarker314"/>stores follow the Svelte store contract, all Svelte stores have the <strong class="source-inline">subscribe</strong> method and, optionally, the <strong class="source-inline">set</strong> method. We can use the <strong class="source-inline">store.subscribe()</strong> method to subscribe to the latest store value, and <strong class="source-inline">store.set()</strong> to update the <span class="No-Break">store value:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let storeValue;
  onMount(() =&gt; {
    // use `subscribe` to subscribe to latest store value
    const unsubscribe = store.subscribe(newStoreValue =&gt; {
      storeValue = newStoreValue;
    });
    return () =&gt; unsubscribe();
  });
  function update(newValue) {
    // use `set` to update store value
    store.set(newValue);
  }
&lt;/script&gt;
&lt;p&gt;{storeValue}&lt;/p&gt;</pre> <p>When <a id="_idIndexMarker315"/>using a Svelte store in a Svelte component, we only subscribe to the Svelte store when needed (usually as we mount the Svelte component). In the preceding snippet, we subscribe to the store exactly after the Svelte component is mounted by calling the <strong class="source-inline">store.subscribe</strong> method inside an <span class="No-Break"><strong class="source-inline">onMount</strong></span><span class="No-Break"> callback.</span></p>
<p>It is important to unsubscribe from new store value changes when it is no longer necessary. This is usually when we unmount and destroy the Svelte component. In the preceding snippet, we return a function in an <strong class="source-inline">onMount</strong> callback, which will be called when the component is unmounted. In the function, we call the <strong class="source-inline">unsubscribe</strong> function return from the <span class="No-Break"><strong class="source-inline">store.subscribe</strong></span><span class="No-Break"> method.</span></p>
<p>This is in accordance with the Svelte store contract, where the <strong class="source-inline">store.subscribe</strong> method has to return a function to unsubscribe from <span class="No-Break">the store.</span></p>
<p>In a Svelte component, we need to remember to call <strong class="source-inline">store.subscribe</strong> during <strong class="source-inline">onMount</strong>, and remember to clean up by calling <strong class="source-inline">unsubscribe</strong> <span class="No-Break">during </span><span class="No-Break"><strong class="source-inline">onDestroy</strong></span><span class="No-Break">.</span></p>
<p>This can <a id="_idIndexMarker316"/>become verbose, so Svelte provides a way to auto-subscribe to a Svelte store in a <span class="No-Break">Svelte component.</span></p>
<p>When you have a variable that references a store in a Svelte component, you can auto-subscribe to the store and access the value of the store through the <strong class="source-inline">$</strong> prefixed variable name of the <span class="No-Break">store variable.</span></p>
<p>For example, let’s say you have a Svelte store variable named <strong class="source-inline">count</strong>, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { writable } from 'svelte/store';
  const count = writable();
&lt;/script&gt;</pre> <p>In this case, you can auto-subscribe to the <strong class="source-inline">count</strong> Svelte store and access the store value <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">$count</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { writable } from 'svelte/store';
  const count = writable();
  console.log($count);
&lt;/script&gt;</pre> <p>This is equivalent to subscribing to the store and assigning the latest store value to the <strong class="source-inline">$count</strong> variable, However, when doing it this way, you no longer need to explicitly call the <strong class="source-inline">count.subscribe</strong> method to subscribe to the store and call the <strong class="source-inline">unsubscribe</strong> function to unsubscribe <span class="No-Break">from it.</span></p>
<p>If you paid attention to the code, you may have noticed that we did not declare the <strong class="source-inline">$count</strong> variable at all. However, it is magically available, automatically declared by Svelte as Svelte builds the Svelte <span class="No-Break">component code.</span></p>
<p>This also assumes that whenever you are using the variable that starts with <strong class="source-inline">$</strong>, the variable without the <strong class="source-inline">$</strong> prefix is assumed to be a <span class="No-Break">Svelte store.</span></p>
<p>Also, because of how Svelte auto declares the <strong class="source-inline">$</strong> prefixed variable, it disallows any declaration of any variable with a variable name starting with the <strong class="source-inline">$</strong> <span class="No-Break">sign.</span></p>
<p>What <a id="_idIndexMarker317"/>happens if I assign a new value to the <strong class="source-inline">$</strong> prefixed variable? Doing so is equivalent to calling the <strong class="source-inline">set</strong> method of <span class="No-Break">the store:</span></p>
<pre class="source-code">
$count = 123;
// is equivalent to
count.set(123);</pre> <p>So, now that we’ve learned about the Svelte context and Svelte store, let’s discuss when we should use a Svelte context and/or a <span class="No-Break">Svelte store.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor132"/>Choosing between a Svelte context and a Svelte store</h1>
<p>The <a id="_idIndexMarker318"/>Svelte context and Svelte store are designed for very different <span class="No-Break">use cases.</span></p>
<p>Here’s a recap: the Svelte context helps pass data from a parent component to all descendent components, while a Svelte store helps make data reactive across multiple <span class="No-Break">Svelte components.</span></p>
<p>Although both the Svelte context and Svelte store are meant to pass data across Svelte components, they are designed for different use cases. So, choosing when to use a Svelte context and Svelte store is never an <span class="No-Break">either-or situation.</span></p>
<p>You can use either a Svelte context, a Svelte store, or both to pass the same data across <span class="No-Break">Svelte components.</span></p>
<p>To decide which one to use, I’ve come up with a 2x2 <span class="No-Break">decision matrix:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context, or both" height="466" src="image/B18887_08_02.jpg" width="782"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context, or both</p>
<p>In this 2x2 decision matrix, there are two dimensions: local-global <span class="No-Break">and static-reactive.</span></p>
<p>Depending on the kind of data you are passing, the data should fall into one of the four quadrants. Then, we can decide on the best way of passing the data <span class="No-Break">across components.</span></p>
<p>So, let’s take a closer look at what each <span class="No-Break">dimension means.</span></p>
<p>In the <a id="_idIndexMarker319"/>local-global dimension, we determine whether the data should have the same value globally across the entire application or have separate local versions among components that are close to <span class="No-Break">each other.</span></p>
<p>For example, language preference data falls into being global instead of local. There tends to be only one piece of language preference data throughout the entire application so that the language preference is consistent in <span class="No-Break">the application.</span></p>
<p>On the other hand, chart settings in a dashboard of charts could be local data. Multiple Svelte components, such as chart axis, chart data, and chart grid, within the same chart share the same data, yet different charts could have different chart settings. There’s no one single piece of data throughout the entire application. So, in this case, it is more toward local in the <span class="No-Break">local-global dimension.</span></p>
<p>If the data is going to be global throughout the entire application, the data can be declared in a JavaScript module and imported from anywhere within <span class="No-Break">the application:</span></p>
<pre class="source-code">
// language-preference.js
export const languagePreference = ...;</pre> <p>On the other hand, if the data is going to be local, the data can be declared as a Svelte context. This allows the child component to get different values, depending on where the <a id="_idIndexMarker320"/>component lives in the component <span class="No-Break">tree hierarchy:</span></p>
<pre class="source-code">
&lt;!-- Chart.svelte --&gt;
&lt;script&gt;
  import { setContext } from 'svelte';
  setContext('chart', ...);
&lt;/script&gt;
&lt;!-- ChartAxis.svelte --&gt;
&lt;script&gt;
  import { getContext } from 'svelte';
  // chartSettings depending on which chart it falls under
  const chartSettings = getContext('chart');
&lt;/script&gt;</pre> <p>In the static-reactive dimension, we determine whether the data should be static, meaning it wouldn’t change through the life cycle of the application, or should be dynamic, where the value of the data will change as the user interacts with <span class="No-Break">the application.</span></p>
<p>An example of static data would be the theme of an application. The value of the data could be determined based on dynamic conditions, but once the value is determined at the start of the application, the value does not change throughout the application life cycle. The application theme is a good example of such a scenario. Usually, the theme of an application is determined at the start as the application loads, and the theme stays throughout <span class="No-Break">the application.</span></p>
<p>On the other hand, an example of dynamic data would be chart data. Chart data is dynamic and can be changed throughout the application’s <span class="No-Break">life cycle.</span></p>
<p>If the data is going to be static throughout the application’s life cycle, then the data can be declared using a normal <span class="No-Break">JavaScript variable:</span></p>
<pre class="source-code">
let theme = 'dark';</pre> <p>However, if the <a id="_idIndexMarker321"/>data is going to be dynamic, and needs to be reactive across multiple components, the data should be declared as a <span class="No-Break">Svelte store:</span></p>
<pre class="source-code">
import { writable } from 'svelte/store';
let chartData = writable();</pre> <p>If we combine the two dimensions, we get <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Static global</strong>: The data<a id="_idIndexMarker322"/> is declared as a normal JavaScript variable in a JavaScript module and exported for Svelte components <span class="No-Break">to import</span></li>
<li><strong class="bold">Dynamic global</strong>: The <a id="_idIndexMarker323"/>data is declared as a Svelte store in a JavaScript module and exported for Svelte components <span class="No-Break">to import</span></li>
<li><strong class="bold">Static local</strong>: The<a id="_idIndexMarker324"/> data is declared as a Svelte context with a normal JavaScript variable as the Svelte <span class="No-Break">context value</span></li>
<li><strong class="bold">Dynamic local</strong>: The data<a id="_idIndexMarker325"/> is declared as a Svelte context with the Svelte store as the Svelte <span class="No-Break">context value</span></li>
</ul>
<p>With that, we’ve seen how we can use a Svelte context and a Svelte store individually, but when we pass dynamic local data across Svelte components, we use both a Svelte context and Svelte <span class="No-Break">store together.</span></p>
<p>So, how do you combine both a Svelte context and a Svelte store? Let’s <span class="No-Break">find out.</span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>Passing dynamic context using a Svelte store</h2>
<p>To make <a id="_idIndexMarker326"/>Svelte context data dynamic and reactive <a id="_idIndexMarker327"/>across components, we need to pass a Svelte store as the Svelte context data instead of a normal <span class="No-Break">JavaScript variable.</span></p>
<p>This is very similar to importing a Svelte store from a JavaScript module, except we are not importing the Svelte store; instead, we are sending the Svelte store through the <span class="No-Break">Svelte context.</span></p>
<p>To begin, we <a id="_idIndexMarker328"/>are creating a Svelte store, and passing the Svelte store into <span class="No-Break">the context:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { writable } from 'svelte/store';
  import { setContext } from 'svelte';
  // declare a Svelte store
  let data = writable(0);
  setContext('data', data);
&lt;/script&gt;</pre> <p>Note that <a id="_idIndexMarker329"/>we are passing the store into the Svelte context directly, instead of passing the <span class="No-Break">store value.</span></p>
<p>In the child component, we can read the value out from the context <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">getContext()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { getContext } from 'svelte';
  const data = getContext('data');
&lt;/script&gt;</pre> <p>Since <strong class="source-inline">data</strong> is a Svelte store, we can reference the Svelte store value using the <strong class="source-inline">$</strong> <span class="No-Break">prefixed variable:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { getContext } from 'svelte';
  const data = getContext('data');
&lt;/script&gt;
&lt;p&gt;{$data}&lt;/p&gt;</pre> <p>To test whether the reactivity works, we can set a new value to the <strong class="source-inline">data</strong> store in the <span class="No-Break">parent component:</span></p>
<pre class="source-code">
&lt;script&gt;
  let data = writable(0);
  setContext('data', data);
  function update() {
    $data = 123;
  }
&lt;/script&gt;</pre> <p>This <a id="_idIndexMarker330"/>goes both ways. If you attempt to update the <a id="_idIndexMarker331"/>store value from the child component, the store value in the parent component will be updated too. Since you are getting the same store value through the context in all the children components, any component using the same store will be updated <span class="No-Break">as well.</span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor134"/>Summary</h1>
<p>In this chapter, we learned what Svelte context and Svelte <span class="No-Break">store are.</span></p>
<p>Although both Svelte context and Svelte store are meant for sharing data across multiple Svelte components, they are designed and used for <span class="No-Break">different reasons.</span></p>
<p>Svelte context is meant for sharing the same data across all descendant components in the component tree, while Svelte store is meant for sharing reactivity across <span class="No-Break">Svelte components.</span></p>
<p>Then, we explored the decision matrix on when to use a Svelte context, when to use a Svelte store, and when to <span class="No-Break">use both.</span></p>
<p>This chapter served as an introduction to the Svelte context and the Svelte store. By now, you should have a good understanding of what they are and how they work, and feel confident in knowing when to use them. As we move forward, we will explore practical use cases that involve Svelte context and Svelte store, allowing you to apply these powerful concepts effectively in <span class="No-Break">real-world scenarios.</span></p>
<p>In the next chapter, we will dive deeper into the topic of the Svelte store and look at how to create a <span class="No-Break">custom one.</span></p>
</div>
</div></body></html>