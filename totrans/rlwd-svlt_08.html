<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-120"><a id="_idTextAnchor121"/>8</h1>
<h1 id="_idParaDest-121"><a id="_idTextAnchor122"/>Context versus Stores</h1>
<p>A Svelte application can be composed of one or many Svelte components. A Svelte component can be seen as a standalone unit, encapsulating its own reactive data and logic. In the previous chapter, we learned how two Svelte components – in particular, components in a parent and child relationship – communicate and pass data between each other. In this chapter, however, we are going to explore communication and passing data between components beyond the parent and child relationship.</p>
<p>Svelte provides two primitives to pass data across Svelte components – Svelte context and Svelte stores. Svelte context allows you to pass data from an ancestor to all children, while Svelte stores use the observer pattern to allow you to access reactive data across multiple unrelated Svelte components.</p>
<p>In the coming five chapters, we are going to explore the different use cases of Svelte context and Svelte stores. In this chapter, we will cover what Svelte context and Svelte stores are.</p>
<p>We will talk about when to use Svelte context and/or Svelte stores and the considerations for choosing them. We will then proceed with an example of a combination of both Svelte context and Svelte stores – a Svelte context store.</p>
<p>By the end of this chapter, you’ll be proficient in using Svelte stores and Svelte context in your Svelte application. You will also understand when to use them effectively.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Defining Svelte context and Svelte stores</li>
<li>When to use Svelte context and Svelte stores</li>
<li>Creating dynamic context using Svelte stores</li>
</ul>
<h1 id="_idParaDest-122"><a id="_idTextAnchor123"/>Defining Svelte context</h1>
<p>When you need <a id="_idIndexMarker290"/>to pass data from a parent component to a child component, the first thing you should think of is using props:</p>
<pre class="source-code">
&lt;Component props={value} /&gt;</pre> <p>What if you need to pass data from a parent component to a grandchild component? You could pass data as props from the parent component to the child component, and then from the child component to the grandchild component:</p>
<pre class="source-code">
&lt;!-- Parent.svelte --&gt;
&lt;Child props={value} /&gt;
&lt;!-- Child.svelte --&gt;
&lt;script&gt;
  export let props;
&lt;/script&gt;
&lt;GrandChild props={props} /&gt;</pre> <p>What if you <a id="_idIndexMarker291"/>need to pass data from a parent component to a great-grandchild component?</p>
<p>You could follow a process similar to what we did in the preceding code, passing the data through layers of components to reach the great-grandchild component.</p>
<p>This <a id="_idIndexMarker292"/>approach is called <em class="italic">prop drilling</em>. It is akin to drilling a hole through layers of components via props. This is frowned upon in most cases due to the following reasons:</p>
<ul>
<li>It is hard to trace where the data comes from.<p class="list-inset">Whenever you want to trace where the data comes from in the child component, you may endlessly trace up through layers of the parent component, jumping through different Svelte component files.</p><p class="list-inset">This slows you down and makes it harder to reason with the data flow.</p></li>
<li>It is hard to trace where the data leads to.<p class="list-inset">The data that’s passed down through props into the child component is not to be used by the child component directly, but to be passed through it to its child component. You would have to step through the layer of components to find out where the data is finally being used.</p><p class="list-inset">You may lose sight of where the data goes and have less confidence in making changes to the data that’s passed down.</p></li>
<li>It is hard to restructure the component hierarchy.<p class="list-inset">When <a id="_idIndexMarker293"/>you add a new component in between the layers, you need to make sure to still pass the props through the new component from its parent to its children.</p><p class="list-inset">When you move the components around, you need to make sure the child component still gets the props it needs by checking the chain of parent components.</p></li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">Keeping this in mind, when the component tree is small and simple, even with its drawback, passing props around may still be the simplest way to pass data from a parent to its child components.</p>
<p>So, what is the alternative to <em class="italic">prop drilling</em>? Svelte context.</p>
<p>Svelte context is a method that provides data to all child components, no matter how many levels down the component tree they are.</p>
<p>A <a id="_idIndexMarker294"/>component tree is<a id="_idIndexMarker295"/> like a family tree for components. You have a parent component at the top, and one level down its child components, and one more level down is the child components of the child components:</p>
<div><div><img alt="Figure 8.1: Component tree diagram" height="420" src="img/B18887_08_01.jpg" width="711"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Component tree diagram</p>
<p>In the <a id="_idIndexMarker296"/>preceding <a id="_idIndexMarker297"/>component tree diagram, the top-left node represents where <code>setContext</code> is called, and all shaded nodes under the node can access the context value using <code>getContext</code>. To set a context value in a component, you can use <code>setContext()</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import { setContext } from 'svelte';
  setContext("key", value);
&lt;/script&gt;</pre> <p>All its child components and child components’ child components will be able to read the context value through <code>getContext()</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import { getContext } from 'svelte';
  const value = getContext("key");
&lt;/script&gt;</pre> <p>If you paid attention to the preceding snippets, you may have noticed that we have been using strings as the context key when setting and reading context. However, you might wonder whether it is possible to use other data types as the context key. Let’s look into this.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Using an object as a context key</h2>
<p>What is the underlying mechanism of Svelte context?</p>
<p>Svelte context<a id="_idIndexMarker298"/> is implemented using a JavaScript <code>Map</code>, which means you can set values and read values out of Svelte context using a key, the same way you would with a JavaScript map.</p>
<p>This also means that you can set more than one key to Svelte context:</p>
<pre class="source-code">
&lt;script&gt;
  setContext("item", item);
  setContext("order", order);
&lt;/script&gt;</pre> <p>You just need to make sure you read them out using the same key you set the context with.</p>
<p>As I mentioned earlier, Svelte context is implemented using a JavaScript <code>Map</code>, and the keys of a <code>Map</code> can be of any type, including functions, objects, or any primitives; you are not constrained to using just a <code>String</code> key value:</p>
<pre class="source-code">
&lt;script&gt;
  const object = {};
  setContext(object, value);
&lt;/script&gt;</pre> <p>And just as how JavaScript <code>Map</code> works, if you set a context using an object, then you would need to use the same object instance to read the value out of the Svelte context.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor125"/>Changing the context value</h2>
<p>One thing <a id="_idIndexMarker299"/>to take note of when using <code>setContext</code> and <code>getContext</code> is that these functions need to be called during component initialization. Read<a href="B18887_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> to recap on what component initialization is.</p>
<p>If we can call <code>setContext</code> after component initialization, then this leads us to the next question – how would we change the context value?</p>
<p>Look at the following snippet:</p>
<pre class="source-code">
&lt;script&gt;
  let itemId = 123;
  setContext("itemid", itemId);
  itemId = 456;
&lt;/script&gt;</pre> <p>When<a id="_idIndexMarker300"/> calling <code>setContext</code> in line 3, we are passing the value of the <code>itemId</code> variable to the <code>setContext</code> function. Reassigning the <code>itemId</code> variable in line 5 would not make the context value change.</p>
<p>This is how JavaScript works. If you call a function with a primitive-type variable, then the value of the variable is being passed in, and reassigning the variable outside of the function would not change the value of the variable that’s read from inside the function.</p>
<p>How about passing an object as a context value? Let’s see how that works:</p>
<pre class="source-code">
&lt;script&gt;
  let item = { id: 123 };
  setContext("item", item);
  item.id = 456;
&lt;/script&gt;</pre> <p>In JavaScript, objects are passed by reference. This means that the Svelte context and the <code>item</code> variable outside of the <code>setContext</code> function are referring to the same object. Mutating the object modifies the same referenced object and thus the changes can be seen when reading the Svelte context:</p>
<pre class="source-code">
&lt;script&gt;
  const item = getContext("item");
&lt;/script&gt;
{item.id}</pre> <p>However, you <a id="_idIndexMarker301"/>may have noticed that after you render <code>{item.id}</code> onto the DOM, the value shown in the DOM does not change when you mutate it in the parent component.</p>
<p>This does not mean <code>item.id</code> has not changed. If you try to print out <code>item.id</code> on an interval, you will notice that <code>item.id</code> has changed, but the value in the DOM remains the same:</p>
<pre class="source-code">
const item = getContext("item");
setInterval(() =&gt; {
  console.log(item.id);
}, 1000);</pre> <p>Why would this happen?</p>
<p>Svelte tracks variable mutations and reassignments within a Svelte component and instruments operations to update the DOM to reflect the changes. However, what this means is that changes that happen outside of the component are not tracked, and therefore the DOM does not reflect such changes.</p>
<p>So, what should we do to make Svelte aware of changes to a variable outside of the component?</p>
<p>This is where the Svelte store comes in.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor126"/>Defining the Svelte store</h1>
<p>To understand <a id="_idIndexMarker302"/>why Svelte reactivity is limited within a Svelte component, we must first understand how Svelte’s reactivity works.</p>
<p>Unlike some other frameworks, Svelte reactivity works during build time. As Svelte compiles a Svelte component into JavaScript, Svelte looks at each variable and tracks the variable to see when the variable changes.</p>
<p>Instead of tracking all the variables throughout the application, Svelte limits itself to only analyzing and compiling one file at a time. This allows Svelte to compile multiple Svelte component files in parallel but also means that a Svelte component would not be aware of variable changes that happen in other files.</p>
<p>A common situation where a variable change is not tracked is when the variable is defined in a separate file and imported into the current component.</p>
<p>In the following <a id="_idIndexMarker303"/>code snippet, the <code>quantity</code> variable is imported from a separate file. Svelte will not track any changes to the <code>quantity</code> variable that may have occurred in that file:</p>
<pre class="source-code">
&lt;script&gt;
  import { quantity } from './item';
&lt;/script&gt;
&lt;p&gt;Quantity: {quantity}&lt;/p&gt;</pre> <p>If you attempt to modify the variable outside of the Svelte component, then Svelte is not able to track that. So, Svelte has no idea when you modify the variable and therefore will not be able to update the DOM when that happens.</p>
<p>To make Svelte aware of the changes outside of the component and update the DOM accordingly, we will need to design a mechanism at runtime that will notify Svelte whenever a variable changes.</p>
<p>For this, we can draw inspiration from the <strong class="bold">observer pattern</strong>. The observer pattern is a design pattern that lets you define a subscription mechanism to notify multiple objects when an event happens.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>Using the observer pattern</h2>
<p>Here, instead of<a id="_idIndexMarker304"/> just importing the <code>quantity</code> variable, I am also importing a <code>subscribe</code> function, which we will define later:</p>
<pre class="source-code">
import { quantity, subscribe } from './item';</pre> <p>The idea of the <code>subscribe</code> function is such that we can subscribe to know when <code>quantity</code> changes.</p>
<p>Here, we assume that <code>subscribe</code> takes in a callback function, which will be called whenever <code>quantity</code> changes. The callback function takes in a parameter that gives us the latest value of <code>quantity</code>:</p>
<pre class="source-code">
import { quantity, subscribe } from './item';
subscribe((newQuantity) =&gt; { ... });</pre> <p>So, now, although Svelte still cannot track changes to the <code>quantity</code> variable outside of the component, we can use the <code>subscribe</code> function to tell Svelte when that happens.</p>
<p>As an example <a id="_idIndexMarker305"/>of how to tell Svelte this, we can define another variable called <code>_quantity</code> that initializes to be the same value as <code>quantity</code>.</p>
<p>Whenever <code>quantity</code> changes, the callback function that’s passed into the <code>subscribe</code> function should be called with the new <code>quantity</code> value. We will use this as an opportunity to update <code>_quantity</code> to the new <code>quantity</code> value:</p>
<pre class="source-code">
&lt;script&gt;
  import { quantity, subscribe } from './item';
  let _quantity = quantity;
  subscribe((newQuantity) =&gt; { _quantity = newQuantity; });
&lt;/script&gt;
&lt;p&gt;Quantity: {_quantity}&lt;/p&gt;</pre> <p>Since the <code>_quantity</code> variable is defined within the component, and we update the value of the variable within the component (in the <code>_quantity = newQuantity</code> statement), Svelte can track the update of <code>_quantity</code>. And since the <code>_quantity</code> variable tracks the changes of the <code>quantity</code> variable itself, you can see that the DOM updates whenever <code>quantity</code> changes.</p>
<p>However, all of this depends on the <code>subscribe</code> function, which would call the callback function whenever the value of <code>quantity</code> changes.</p>
<p>So, let’s see how we can define the <code>subscribe</code> function.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor128"/>Defining the subscribe function</h2>
<p>There are multiple ways of defining the <code>subscribe</code> function.</p>
<p>Here, we <a id="_idIndexMarker306"/>are going to use an array and name it <code>subscribers</code> so that we can keep track of all the functions being called with <code>subscribe</code>. Then, when we attempt to update the value of <code>quantity</code>, we will iterate through the <code>subscribers</code> array to get each of the subscriber functions and call them <a id="_idIndexMarker307"/>one by one:</p>
<pre class="source-code">
let subscribers = [];
function subscribe(fn) {
  subscribers.push(fn);
}
function notifySubscribers(newQuantity) {
  subscribers.forEach(fn =&gt; {
    fn(newQuantity);
  });
}</pre> <p>As an example, here, we want to update <code>quantity</code> to <code>20</code>. To make sure that the subscribers are notified of the changes, we call <code>notifySubscribers</code> with the updated value at the same time so that each <code>subscribers</code> is notified with the latest value for <code>quantity</code>:</p>
<pre class="source-code">
quantity = 20;
notifySubscribers(quantity);</pre> <p>Take your time when connecting the implementation of the <code>subscribe</code> and <code>notifySubscribers</code> functions in the preceding code back to the Svelte component code in the previous section. You will see that whenever we call <code>notifySubscribers</code>, the callback function that’s passed into the <code>subscribe</code> function will be called. <code>_quantity</code> will be updated, and the value in the DOM will be updated.</p>
<p>So, it doesn’t matter if you are modifying <code>quantity</code> outside the Svelte component, so long as you call the <code>notifySubscribers</code> function. With the new value of <code>quantity</code>, Svelte will update the DOM elements to reflect the latest value of <code>quantity</code>.</p>
<p>With the observer pattern, we are now able to define and update variables across Svelte components.</p>
<p>You will see this pattern a lot in Svelte. Svelte encapsulates the idea of <code>subscribe</code> and <code>notifySubscribers</code> into a concept called a Svelte store. So, let’s explore what it means to be a Svelte store and explore what first-class support Svelte is providing for Svelte stores.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>Defining a Svelte store</h2>
<p>A Svelte store is <a id="_idIndexMarker308"/>any object that follows the Svelte store contract.</p>
<p>This means that any object that follows the Svelte store contract can be referred to as a Svelte store. As a Svelte store, there are a few syntactic sugars and built-in functions that come with it.</p>
<p>Before we get ahead of ourselves, let’s take a look at what a Svelte store contract is.</p>
<p>The Svelte store contract requires an object to have a <code>subscribe</code> method and an optional <code>set</code> method:</p>
<pre class="source-code">
const store = {
  subscribe() {},
  set() {},
};</pre> <p>I have not told you about the specific requirements for the <code>subscribe</code> and <code>set</code> methods, but I hope you can see the similarity in the <code>subscribe</code> and <code>set</code> methods in the Svelte store contract to the <code>subscribe</code> and <code>notifySubscribers</code> functions illustrated in the previous section.</p>
<p>But something is missing here. Where do we place the store value, or the corresponding <code>quantity</code> variable from the previous section?</p>
<p>Well, the store value is not part of the Svelte store contract, and we will soon explain why.</p>
<p>Let’s continue with our requirements for the <code>subscribe</code> and <code>set</code> methods:</p>
<ul>
<li>The <code>subscribe</code> method has to return a function to unsubscribe from the store.<p class="list-inset">This allows the subscriber to stop receiving updates of the latest store value.</p><p class="list-inset">For example, if we use an array to keep track of the subscriber functions being called with the <code>subscribe</code> function, then we can use the returned function from <code>subscribe</code> to remove the subscriber function from the array since the <code>subscriber</code> function<a id="_idIndexMarker309"/> is no longer needed to receive any new updates from the store:</p><pre class="source-code">
const subscribers = [];
const store = {
  subscribe(fn) {
    // add the fn to the list of subscribers
    subscribers.push(fn);
    // return a function to remove the fn from the list of subscribers
    return () =&gt; {
      subscribers.splice(subscribers.indexOf(fn), 1);
    };
  }
};</pre></li> <li>When the <code>subscribe</code> method is being called with a function, the function must be called immediately and synchronously with the store value.<p class="list-inset">If the function is not called immediately, the store value is assumed to be <code>undefined</code>:</p><pre class="source-code">
let storeValue = 10;
const store = {
  subscribe(fn) {
    // immediately call the function with the store value
    fn(storeValue);
    // ...
  },
};</pre><p class="list-inset">This requirement means that to read the store value out from the Svelte store, you will need to use the <code>subscribe</code> method:</p><pre class="source-code">let storeValue;
store.subscribe((value) =&gt; {
  storeValue = value;
});
console.log(storeValue);
subscribe</strong> method is not being called immediately and synchronously, then immediately in the next statement where we console out the value of <code>storeValue</code>, you will see that the value of <code>storeValue</code> remains <code>undefined</code>.</pre></li> <li>The <code>set</code> method of a Svelte store takes in a new store value and returns nothing:<pre class="source-code">
store.set(newValue);</pre><p class="list-inset">The <code>set</code> method is supposed to update the value of the store. Naturally, we would implement the <code>set</code> method such that it will notify all the store subscribers of the latest store value:</p><pre class="source-code">const store = {
  // ...
  set(newValue) {
    // notify subscribers with new store value
    for(const subscriber of subscribers) {
      subscriber(newValue);
    }
  },
};</pre></li> </ul>
<p>With that, we’ve <a id="_idIndexMarker311"/>gone through the requirements of a Svelte store contract. Along the way, we’ve also seen snippets of code on implementing each requirement of a Svelte store. By putting them together, we will have a Svelte store.</p>
<p>Creating a Svelte store is such a common use case that Svelte has provided a few built-in functions to help us with creating one.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>Creating Svelte stores with built-in functions</h2>
<p>Svelte <a id="_idIndexMarker312"/>provides a sub-package that exports a few built-in functions for Svelte stores. You can import them from the <code>'</code><code>svelte/store'</code> package.</p>
<p>Here is the list of built-in Svelte store functions:</p>
<ul>
<li><code>readable()</code> helps create a readable Svelte store. Since the <code>set</code> method in a Svelte contract is optional, a readable store is a store that does not implement the <code>set</code> method.<p class="list-inset">To update the store value, the <code>readable()</code> function takes in a callback function that will be called when the store is being subscribed, and the callback function is called with a <code>set</code> function that can be used to update the store value:</p><pre class="source-code">
const store = readable(initialValue, (set) =&gt; {
  // update store value
  set(newValue);
});</pre><p class="list-inset">The <code>set</code> function in the callback function can be called numerous times. In the following example, we are calling the <code>set</code> function every second to update the store value to the latest timestamp:</p><pre class="source-code">const store = readable(Date.now(), (set) =&gt; {
  setInterval(() =&gt; {
    // update store value to the current timestamp
    set(Date.now());
  }, 1000);
});</pre></li> <li><code>writable()</code> helps <a id="_idIndexMarker313"/>create a writable Svelte store. This is similar to the readable store, except it implements the <code>set</code> method:<pre class="source-code">
const store = writable(initialValue);
store.set(newValue);</pre></li> <li><code>derived()</code> creates a new Svelte store, deriving from existing stores.<p class="list-inset">We will explore <code>derived()</code> in more detail in the next chapter when we talk about creating custom stores.</p></li>
</ul>
<p>With <code>readable()</code>, <code>writable()</code>, and <code>derived()</code>, you can easily create a new Svelte store without having to implement the Svelte store contract yourself.</p>
<p>So, we have built-in methods to create a Svelte store, but do we have any built-in methods for using Svelte stores? Let’s find out.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Auto-subscribing to a Svelte store</h2>
<p>Since all Svelte <a id="_idIndexMarker314"/>stores follow the Svelte store contract, all Svelte stores have the <code>subscribe</code> method and, optionally, the <code>set</code> method. We can use the <code>store.subscribe()</code> method to subscribe to the latest store value, and <code>store.set()</code> to update the store value:</p>
<pre class="source-code">
&lt;script&gt;
  import { onMount } from 'svelte';
  let storeValue;
  onMount(() =&gt; {
    // use `subscribe` to subscribe to latest store value
    const unsubscribe = store.subscribe(newStoreValue =&gt; {
      storeValue = newStoreValue;
    });
    return () =&gt; unsubscribe();
  });
  function update(newValue) {
    // use `set` to update store value
    store.set(newValue);
  }
&lt;/script&gt;
&lt;p&gt;{storeValue}&lt;/p&gt;</pre> <p>When <a id="_idIndexMarker315"/>using a Svelte store in a Svelte component, we only subscribe to the Svelte store when needed (usually as we mount the Svelte component). In the preceding snippet, we subscribe to the store exactly after the Svelte component is mounted by calling the <code>store.subscribe</code> method inside an <code>onMount</code> callback.</p>
<p>It is important to unsubscribe from new store value changes when it is no longer necessary. This is usually when we unmount and destroy the Svelte component. In the preceding snippet, we return a function in an <code>onMount</code> callback, which will be called when the component is unmounted. In the function, we call the <code>unsubscribe</code> function return from the <code>store.subscribe</code> method.</p>
<p>This is in accordance with the Svelte store contract, where the <code>store.subscribe</code> method has to return a function to unsubscribe from the store.</p>
<p>In a Svelte component, we need to remember to call <code>store.subscribe</code> during <code>onMount</code>, and remember to clean up by calling <code>unsubscribe</code> during <code>onDestroy</code>.</p>
<p>This can <a id="_idIndexMarker316"/>become verbose, so Svelte provides a way to auto-subscribe to a Svelte store in a Svelte component.</p>
<p>When you have a variable that references a store in a Svelte component, you can auto-subscribe to the store and access the value of the store through the <code>$</code> prefixed variable name of the store variable.</p>
<p>For example, let’s say you have a Svelte store variable named <code>count</code>, as shown here:</p>
<pre class="source-code">
&lt;script&gt;
  import { writable } from 'svelte/store';
  const count = writable();
&lt;/script&gt;</pre> <p>In this case, you can auto-subscribe to the <code>count</code> Svelte store and access the store value through <code>$count</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import { writable } from 'svelte/store';
  const count = writable();
  console.log($count);
&lt;/script&gt;</pre> <p>This is equivalent to subscribing to the store and assigning the latest store value to the <code>$count</code> variable, However, when doing it this way, you no longer need to explicitly call the <code>count.subscribe</code> method to subscribe to the store and call the <code>unsubscribe</code> function to unsubscribe from it.</p>
<p>If you paid attention to the code, you may have noticed that we did not declare the <code>$count</code> variable at all. However, it is magically available, automatically declared by Svelte as Svelte builds the Svelte component code.</p>
<p>This also assumes that whenever you are using the variable that starts with <code>$</code>, the variable without the <code>$</code> prefix is assumed to be a Svelte store.</p>
<p>Also, because of how Svelte auto declares the <code>$</code> prefixed variable, it disallows any declaration of any variable with a variable name starting with the <code>$</code> sign.</p>
<p>What <a id="_idIndexMarker317"/>happens if I assign a new value to the <code>$</code> prefixed variable? Doing so is equivalent to calling the <code>set</code> method of the store:</p>
<pre class="source-code">
$count = 123;
// is equivalent to
count.set(123);</pre> <p>So, now that we’ve learned about the Svelte context and Svelte store, let’s discuss when we should use a Svelte context and/or a Svelte store.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor132"/>Choosing between a Svelte context and a Svelte store</h1>
<p>The <a id="_idIndexMarker318"/>Svelte context and Svelte store are designed for very different use cases.</p>
<p>Here’s a recap: the Svelte context helps pass data from a parent component to all descendent components, while a Svelte store helps make data reactive across multiple Svelte components.</p>
<p>Although both the Svelte context and Svelte store are meant to pass data across Svelte components, they are designed for different use cases. So, choosing when to use a Svelte context and Svelte store is never an either-or situation.</p>
<p>You can use either a Svelte context, a Svelte store, or both to pass the same data across Svelte components.</p>
<p>To decide which one to use, I’ve come up with a 2x2 decision matrix:</p>
<div><div><img alt="Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context, or both" height="466" src="img/B18887_08_02.jpg" width="782"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context, or both</p>
<p>In this 2x2 decision matrix, there are two dimensions: local-global and static-reactive.</p>
<p>Depending on the kind of data you are passing, the data should fall into one of the four quadrants. Then, we can decide on the best way of passing the data across components.</p>
<p>So, let’s take a closer look at what each dimension means.</p>
<p>In the <a id="_idIndexMarker319"/>local-global dimension, we determine whether the data should have the same value globally across the entire application or have separate local versions among components that are close to each other.</p>
<p>For example, language preference data falls into being global instead of local. There tends to be only one piece of language preference data throughout the entire application so that the language preference is consistent in the application.</p>
<p>On the other hand, chart settings in a dashboard of charts could be local data. Multiple Svelte components, such as chart axis, chart data, and chart grid, within the same chart share the same data, yet different charts could have different chart settings. There’s no one single piece of data throughout the entire application. So, in this case, it is more toward local in the local-global dimension.</p>
<p>If the data is going to be global throughout the entire application, the data can be declared in a JavaScript module and imported from anywhere within the application:</p>
<pre class="source-code">
// language-preference.js
export const languagePreference = ...;</pre> <p>On the other hand, if the data is going to be local, the data can be declared as a Svelte context. This allows the child component to get different values, depending on where the <a id="_idIndexMarker320"/>component lives in the component tree hierarchy:</p>
<pre class="source-code">
&lt;!-- Chart.svelte --&gt;
&lt;script&gt;
  import { setContext } from 'svelte';
  setContext('chart', ...);
&lt;/script&gt;
&lt;!-- ChartAxis.svelte --&gt;
&lt;script&gt;
  import { getContext } from 'svelte';
  // chartSettings depending on which chart it falls under
  const chartSettings = getContext('chart');
&lt;/script&gt;</pre> <p>In the static-reactive dimension, we determine whether the data should be static, meaning it wouldn’t change through the life cycle of the application, or should be dynamic, where the value of the data will change as the user interacts with the application.</p>
<p>An example of static data would be the theme of an application. The value of the data could be determined based on dynamic conditions, but once the value is determined at the start of the application, the value does not change throughout the application life cycle. The application theme is a good example of such a scenario. Usually, the theme of an application is determined at the start as the application loads, and the theme stays throughout the application.</p>
<p>On the other hand, an example of dynamic data would be chart data. Chart data is dynamic and can be changed throughout the application’s life cycle.</p>
<p>If the data is going to be static throughout the application’s life cycle, then the data can be declared using a normal JavaScript variable:</p>
<pre class="source-code">
let theme = 'dark';</pre> <p>However, if the <a id="_idIndexMarker321"/>data is going to be dynamic, and needs to be reactive across multiple components, the data should be declared as a Svelte store:</p>
<pre class="source-code">
import { writable } from 'svelte/store';
let chartData = writable();</pre> <p>If we combine the two dimensions, we get the following:</p>
<ul>
<li><strong class="bold">Static global</strong>: The data<a id="_idIndexMarker322"/> is declared as a normal JavaScript variable in a JavaScript module and exported for Svelte components to import</li>
<li><strong class="bold">Dynamic global</strong>: The <a id="_idIndexMarker323"/>data is declared as a Svelte store in a JavaScript module and exported for Svelte components to import</li>
<li><strong class="bold">Static local</strong>: The<a id="_idIndexMarker324"/> data is declared as a Svelte context with a normal JavaScript variable as the Svelte context value</li>
<li><strong class="bold">Dynamic local</strong>: The data<a id="_idIndexMarker325"/> is declared as a Svelte context with the Svelte store as the Svelte context value</li>
</ul>
<p>With that, we’ve seen how we can use a Svelte context and a Svelte store individually, but when we pass dynamic local data across Svelte components, we use both a Svelte context and Svelte store together.</p>
<p>So, how do you combine both a Svelte context and a Svelte store? Let’s find out.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>Passing dynamic context using a Svelte store</h2>
<p>To make <a id="_idIndexMarker326"/>Svelte context data dynamic and reactive <a id="_idIndexMarker327"/>across components, we need to pass a Svelte store as the Svelte context data instead of a normal JavaScript variable.</p>
<p>This is very similar to importing a Svelte store from a JavaScript module, except we are not importing the Svelte store; instead, we are sending the Svelte store through the Svelte context.</p>
<p>To begin, we <a id="_idIndexMarker328"/>are creating a Svelte store, and passing the Svelte store into the context:</p>
<pre class="source-code">
&lt;script&gt;
  import { writable } from 'svelte/store';
  import { setContext } from 'svelte';
  // declare a Svelte store
  let data = writable(0);
  setContext('data', data);
&lt;/script&gt;</pre> <p>Note that <a id="_idIndexMarker329"/>we are passing the store into the Svelte context directly, instead of passing the store value.</p>
<p>In the child component, we can read the value out from the context through <code>getContext()</code>:</p>
<pre class="source-code">
&lt;script&gt;
  import { getContext } from 'svelte';
  const data = getContext('data');
&lt;/script&gt;</pre> <p>Since <code>data</code> is a Svelte store, we can reference the Svelte store value using the <code>$</code> prefixed variable:</p>
<pre class="source-code">
&lt;script&gt;
  import { getContext } from 'svelte';
  const data = getContext('data');
&lt;/script&gt;
&lt;p&gt;{$data}&lt;/p&gt;</pre> <p>To test whether the reactivity works, we can set a new value to the <code>data</code> store in the parent component:</p>
<pre class="source-code">
&lt;script&gt;
  let data = writable(0);
  setContext('data', data);
  function update() {
    $data = 123;
  }
&lt;/script&gt;</pre> <p>This <a id="_idIndexMarker330"/>goes both ways. If you attempt to update the <a id="_idIndexMarker331"/>store value from the child component, the store value in the parent component will be updated too. Since you are getting the same store value through the context in all the children components, any component using the same store will be updated as well.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor134"/>Summary</h1>
<p>In this chapter, we learned what Svelte context and Svelte store are.</p>
<p>Although both Svelte context and Svelte store are meant for sharing data across multiple Svelte components, they are designed and used for different reasons.</p>
<p>Svelte context is meant for sharing the same data across all descendant components in the component tree, while Svelte store is meant for sharing reactivity across Svelte components.</p>
<p>Then, we explored the decision matrix on when to use a Svelte context, when to use a Svelte store, and when to use both.</p>
<p>This chapter served as an introduction to the Svelte context and the Svelte store. By now, you should have a good understanding of what they are and how they work, and feel confident in knowing when to use them. As we move forward, we will explore practical use cases that involve Svelte context and Svelte store, allowing you to apply these powerful concepts effectively in real-world scenarios.</p>
<p>In the next chapter, we will dive deeper into the topic of the Svelte store and look at how to create a custom one.</p>
</div>
</div></body></html>