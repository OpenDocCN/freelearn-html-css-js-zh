<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Creating Grids</h1></div></div></div><p>There are several different routes to take when creating basic site layouts, and in many cases, developers may decide to use CSS grids.</p><p>A classic example for those using CSS pre-processors, is of course, the SASS grid system, <strong>Bourbon Neat</strong>—a great <a id="id294" class="indexterm"/>package, spoiled by the need to install Ruby. We can easily fix this in PostCSS, by using one of several plugins available, without the need for extra dependencies. In this chapter, we'll take a look at what's available, and work through some examples, using a plugin for creating grids within PostCSS.</p><p>We will cover a number of topics throughout this chapter, which will include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing the basic principles of using CSS grids</li><li class="listitem" style="list-style-type: disc">Exploring the grid plugins available for use within PostCSS</li><li class="listitem" style="list-style-type: disc">Working through some simple examples using Bourbon Neat</li><li class="listitem" style="list-style-type: disc">Replicating pure SCSS examples using the PostCSS plugin, PostCSS-Neat</li><li class="listitem" style="list-style-type: disc">Adding responsive capabilities using the PostCSS-media-minmax plugin</li></ul></div><p>Let's get cracking…!</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Introducing grid design</h1></div></div></div><p>The principles of using <a id="id295" class="indexterm"/>grids in design are not new, they date from the Second World War, with a number of graphic designers questioning the design of conventional page layouts, in favor of designing a system that provided a flexible, yet coherent, layout.</p><p>The same principles have been transferred to the web, starting with plain HTML, and CSS-based designs, before newer frameworks took over and helped to make construction easier.</p><p>It doesn't matter how the design is constructed, we can of course use HTML and CSS, or we might favor the image template approach (using packages such as <code class="literal">PhotoShop</code>), particularly if responsibility for designing the front end falls with a different team.</p><p>These are perfectly acceptable methods, but require a lot of manual effort—in this age of web design, time is critical; we can instead make use of newer frameworks (such as SASS, Bourbon Neat, or <a id="id296" class="indexterm"/>Bootstrap) to create our grids, as shown in this example (which uses plain SASS):</p><div><img src="img/BO5194_06_01.jpg" alt="Introducing grid design"/></div><p>We can see this type of layout in action, if we go ahead and extract the <code class="literal">Tutorial28</code> folder from the code download that accompanies this book, then review it using a browser. We will see this grid appear, the <code class="literal">style.css</code> file used by this demo was created using the online SASS <a id="id297" class="indexterm"/>playground, Sassmeister at: <a class="ulink" href="http://www.sassmeister.com">http://www.sassmeister.com</a>.</p><p>Much of the code used in this demo centers around each column width and the overall .wrapper container; if you take a look at the code, you will notice that there are no static values for column widths. There are a couple of static values, but their sizes are not critical to the overall effect.</p><p>The key to our demo working centers around this block of CSS styling:</p><div><img src="img/BO5194_06_02.jpg" alt="Introducing grid design"/></div><p>Here, we're using SASS's interpolation to first build our media query (to make it responsive), followed by styles for a series of columns that form our grid. When compiled, it creates a number <a id="id298" class="indexterm"/>of styles that apply to each part of our grid:</p><div><img src="img/BO5194_06_03.jpg" alt="Introducing grid design"/></div><p>It's a simple matter of matching up the style with the number shown on the grid. If we want to change the widths, we simply need to increase the number of columns, and our <code class="literal">for</code> statement will automatically calculate a new set of values at the next compilation.</p><p>Okay, enough chitchat: time, I think, for a demo! Throughout this chapter, we will work through the principles of migrating from some basic examples using SASS, through to using Bourbon Neat, before converting to using PostCSS plugins. We always have to start somewhere, so let's begin with automating our compilation process using SASS.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Automating the compilation process</h2></div></div></div><p>"Installing <a id="id299" class="indexterm"/>SASS?" I hear you ask Why, when this book is about PostCSS?</p><p>I hear you, it's a good question: there is logic, though, in this madness—let me explain all:</p><p>While we are installing SASS, we're not going to use the standard route to installing it; instead, we're going to use the <code class="literal">gulp-sass</code> plugin. This allows us to make the initial switch to using a <code class="literal">gulp</code> file; this puts us one step further on down the route to converting our processes to use PostCSS. The use of a <code class="literal">gulp</code> file provides a convenient framework where we can switch <a id="id300" class="indexterm"/>components in, or out, while we transition to using PostCSS.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>In <a class="link" href="ch12.html" title="Chapter 12. Mixing Preprocessors">Chapter 12</a>, <em>Mixing Preprocessors</em>, we will see how PostCSS works well with other preprocessors, as a basis for adopting a consistent approach to compiling code.</p></div></div><p>So, without further ado, let's make a start on installing the <code class="literal">gulp-sass</code> plugin, before putting it to work:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start by firing up a Node.js command prompt session, then changing the working folder to our project area.</li><li class="listitem">At the prompt, go ahead and enter this command, then press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install gulp-sass --save-dev</strong>
</pre></div><p>Don't close the window, we will need it shortly!</p></li><li class="listitem">Node will go away and install <code class="literal">gulp-sass</code>; it returns to the prompt when the installation is completed.</li><li class="listitem">With the plugin installed, we now need to compile our code—go ahead and extract a copy of the <code class="literal">Tutorial29</code> folder to our project area.</li><li class="listitem">Copy the contents of the <code class="literal">sass – pre-compile</code> folder to the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">We also need to add the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from the <code class="literal">Tutorial29</code> folder to the root of our project area.</li><li class="listitem">Revert back to the Node.js window we had earlier, then at the prompt, enter <code class="literal">gulp</code> and press <em>Enter</em>.</li><li class="listitem">The files will now compile—once completed, copy them into the <code class="literal">css</code> folder within the <code class="literal">Tutorial29</code> folder.</li><li class="listitem">Try previewing the results of our work in a browser; if all is well, we should see something akin to this screenshot:<div><img src="img/BO5194_06_04.jpg" alt="Automating the compilation process"/></div></li></ol></div><p>Right, we now have <a id="id301" class="indexterm"/>automatic support for compiling in place; "What next?" I hear you ask. We're one step closer, in that our code can now be compiled automatically:</p><div><img src="img/BO5194_06_05.jpg" alt="Automating the compilation process"/></div><p>However, manual effort is still required to construct our grid! Let's start to change that now, there are several frameworks available that we can use, but in my view, one of the cleanest is SASS's Bourbon Neat. We'll use this as the basis for our next few exercises, before migrating to use the PostCSS version of this framework.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Adding support for Bourbon Neat</h2></div></div></div><p>For the uninitiated, SASS's grid capability is provided by the Bourbon Neat add-on (available from <a class="ulink" href="http://neat.bourbon.io/">http://neat.bourbon.io/</a>). For the purposes of our exercise, we're going to use the Node versions of the framework—this requires two installations to be completed, so let's go ahead and do that now:</p><div><ol class="orderedlist arabic"><li class="listitem">If you still have <a id="id302" class="indexterm"/>it open, revert back to the Node.js command prompt session from the previous demo; otherwise, open a new one and change the working folder to our project area.</li><li class="listitem">At the prompt, enter these two commands in turn, pressing <em>Enter</em> after each:<div><pre class="programlisting"><strong>npm install node-bourbon --save-dev</strong>
<strong>npm install node-neat --save-dev</strong>
</pre></div></li><li class="listitem">Both plugins will have installed correctly when we see a result akin to this screenshot:<div><img src="img/BO5194_06_06.jpg" alt="Adding support for Bourbon Neat"/></div></li><li class="listitem">With the plugins now installed, we need to modify our <code class="literal">gulp</code> file—go ahead and add this at line 5:<div><pre class="programlisting">var neat = require('node-neat').includePaths;</pre></div></li><li class="listitem">Next, leave a line, then add the code as shown, at line 7:<div><pre class="programlisting">var paths = {
  scss: 'src/*.scss'
};</pre></div></li><li class="listitem">The original SASS task can be replaced with this new task:<div><pre class="programlisting">gulp.task('styles', function () {
  return gulp.src(paths.scss)
  .pipe(sass({
    includePaths: require('node-neat').includePaths
  }))
  .pipe(gulp.dest('dest/'));
});</pre></div></li><li class="listitem">The reference to SASS in the default task is now incorrect—go ahead and change it to: <code class="literal">gulp.task('default', ['styles']);</code></li><li class="listitem">Finally, change this line as indicated:<div><pre class="programlisting">var watcher = gulp.watch('src/*.scss', ['styles']);</pre></div></li><li class="listitem">We're now ready to test our compilation process—go ahead and extract a copy of the contents of <code class="literal">style – pre-compile.scss</code> from the code download and save it to the <code class="literal">src</code> folder.</li><li class="listitem">At this point, we can run <code class="literal">gulp</code> from a Node.js command prompt. If this works okay, we should get a <code class="literal">style.css</code> file appear in the <code class="literal">dest</code> folder. If we open it up, we should <a id="id303" class="indexterm"/>see some compiled styles, as follows, that prove Neat is installed and working:<div><pre class="programlisting">@media only screen and (min-width: 30rem) {
  .wrapper {
    width: 95%;
    max-width: 72rem; }
  .col-1 {
    width: 8.33333%; }</pre></div></li></ol></div><p>At this point, we now have a working compilation process, and we're good to go with building a working site! For now, don't worry too much about the individual styles in the compiled <code class="literal">test.css</code> file, we will cover this in more detail over the next few pages. Let's put our new compilation process into practice and assemble a working example, so that we can see the grid facility in action.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Creating an example with Bourbon Neat</h1></div></div></div><p>Constructing a <a id="id304" class="indexterm"/>site using Bourbon Neat is a simple process, it does not require any special markup on our web page; the effort is all within the compiled style sheet.</p><p>To prove this, we'll construct a simple web page that could easily be part of any website—I've used a Japanese theme as the basis for my page, but the principles we will use can apply to any site. You'll see that (with the exception of the standard SASS style of code used) there are only three instances where we have used Bourbon Neat-specific code.</p><p>Let's make a start:</p><div><ol class="orderedlist arabic"><li class="listitem">From the code download that accompanies this book, go ahead and extract a copy of <code class="literal">Tutorial30</code>, and save it to the root of our project area.</li><li class="listitem">Copy the contents of the <code class="literal">sample site – pre-compile</code> from within the <code class="literal">Tutorial30</code> folder to the <code class="literal">src</code> folder within our project area. Go ahead and rename it as <code class="literal">sample.scss</code>.</li><li class="listitem">Next, fire up a Node.js command prompt, then change the working folder to our project area.</li><li class="listitem">At the prompt, enter <code class="literal">gulp</code>, then press <em>Enter</em>—Node.js will compile the code; if all is well, we should see two compiled style sheets and a source map in the <code class="literal">dest</code> folder.</li><li class="listitem">Go ahead <a id="id305" class="indexterm"/>and copy the contents of the <code class="literal">dest</code> folder into the <code class="literal">css</code> folder at the root of the <code class="literal">Tutorial30</code> folder.</li></ol></div><p>If we try previewing the results of our work, we should see a stylish page appear, with our Japanese theme:</p><div><img src="img/BO5194_06_07.jpg" alt="Creating an example with Bourbon Neat"/></div><p>The demo <a id="id306" class="indexterm"/>covers a couple of key points and useful tricks, so let's dive in and work through them in more detail.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Exploring our demo in more detail</h2></div></div></div><p>At this point, be surprised to hear that, our first tip is not directly related to SASS or even Bourbon Neat, but to the color scheme!</p><p>"Why", I hear you ask, "are we talking about the color scheme first?" There is a good reason for this: we've used variables to reference our colors, but could equally have used SASS functions to create the values. We've already covered this back in <a class="link" href="ch05.html" title="Chapter 5. Managing Colors, Images, and Fonts">Chapter 5</a>, <em>Managing Colors, Images and Fonts</em>, where we covered the use of the <code class="literal">postcss-color-function</code> plugin to build these values; we will use it again later in this chapter.</p><p>The real tip here, though, is using a nifty applet by Lokesh Dhakar, called <strong>Color Thief</strong> (hosted at <a class="ulink" href="http://lokeshdhakar.com/projects/color-thief/">http://lokeshdhakar.com/projects/color-thief/</a>). We can simply drag and drop our header image in and get a full swatch of suitable colors:</p><div><img src="img/BO5194_06_08.jpg" alt="Exploring our demo in more detail"/></div><p>The only downside is that it doesn't provide the color values; we can get these from the page's source instead.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>If your preference is to use RGB(A) colors instead, then a site such as <strong>Color Hexa</strong> (<a class="ulink" href="http://colorhexa.com">http://colorhexa.com</a>) will be a great help.</p></div></div><p>The key to our demo is at lines 33, 63 and 69-these are Bourbon Neat mixins that control the format of the outer container (line 33):</p><div><img src="img/BO5194_06_09.jpg" alt="Exploring our demo in more detail"/></div><p>They also control the <a id="id307" class="indexterm"/>format of each of the two content areas within (lines 63 and 69):</p><div><img src="img/BO5194_06_10.jpg" alt="Exploring our demo in more detail"/></div><p>When compiled, the <code class="literal">outer-container</code> mixin adds a <code class="literal">max-width</code> of 72% to the <code class="literal">.wrapper</code> class controlling the main section, while the <code class="literal">span-columns()</code> mixins add <code class="literal">float</code>, <code class="literal">display</code>, <code class="literal">width</code>, and <code class="literal">margin-right</code> attributes to each element, like this:</p><div><img src="img/BO5194_06_11.jpg" alt="Exploring our demo in more detail"/></div><p>In addition to the <code class="literal">outer-container()</code> and <code class="literal">span-columns()</code> mixins, the demo uses percentage values as much as possible, where <code class="literal">rem</code> or <code class="literal">pixel</code> values have been specified, then maintaining a cohesive design when resizing these elements is less critical.</p><p>We will, however, make some improvements later in this chapter, when we improve the responsive capabilities of our demo. For now, let's continue with our transition, and introduce the use of <a id="id308" class="indexterm"/>PostCSS plugins into our process.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Exploring the grid plugins in PostCSS</h1></div></div></div><p>Throughout this <a id="id309" class="indexterm"/>chapter we've used SASS with Bourbon Neat to produce our grids. It's a perfectly valid option to use, but is not the only one available. We might have preferred to work with something like Bootstrap or the Semantic Grid System instead; it's ultimately down to our personal choice as to which grid system we use, based on our preferences and requirements.</p><p>Up until now, we've focused on using Neat. This is largely due to familiarity and ease of use. There will come a point, though, when we need to make the transition to using PostCSS—the beauty is that there is a dedicated plugin available for using Neat within PostCSS, at <a class="ulink" href="https://github.com/jo-asakura/postcss-neat">https://github.com/jo-asakura/postcss-neat</a>. It's not the only grid system plugin available for PostCSS, so let's take a moment to cover the others that can be used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Grid</code>: Downloadable from https://github.com/andyjansson/postcss-grid, this plugin splits some of the configuration between PostCSS and the stylesheet, which helps to simplify the calculations required for formatting each column.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Lost</code>: Available from <a class="ulink" href="https://github.com/corysimmons/lost">https://github.com/corysimmons/lost</a>, it describes itself as the Autoprefixer for grid systems; it provides support for most preprocessors, such as Less, SASS, or Stylus.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Simple-grid</code>: From <a class="ulink" href="https://github.com/admdh/postcss-simple-grid">https://github.com/admdh/postcss-simple-grid</a>, this plugin takes a different route: all of the configuration is done in CSS, not within the task configuration.</li></ul></div><p>Without further ado, it's time for us to make the transition—let's make a start by getting the plugin installed and configured for use.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Transitioning to using PostCSS-Neat</h1></div></div></div><p>Making the <a id="id310" class="indexterm"/>transition to PostCSS is relatively straightforward. We need, of course,to update our compilation process to remove links to SASS, and introduce our PostCSS plugin. </p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>The transition process will be completed over this and the next two sections.</p></div></div><p>In terms of changing the CSS, it's a little more complicated, as we have to work out how many columns are required for each grid block. Fortunately, our example is relatively straightforward, as we numbered the original blocks with the appropriate column count, so we can use that as a basis for changing our CSS.</p><p>Let's make a start with <a id="id311" class="indexterm"/>updating our compilation process:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start by extracting a copy of the <code class="literal">Tutorial31</code> folder from the code download that accompanies this book. Save it to the root of our project area.</li><li class="listitem">From the <code class="literal">Tutorial31</code> folder, go ahead and extract copies of <code class="literal">package.json</code> and <code class="literal">gulpfile.js</code> files. Save these to the root of our project area.</li><li class="listitem">Next, we need to install the <code class="literal">postcss-neat</code> plugin. For this, fire up a Node.js command prompt, then change the working folder to our project area.</li><li class="listitem">At the prompt, go ahead and enter this command, then press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install postcss-neat --save-dev</strong>
</pre></div></li><li class="listitem">Node will go away and install our plugin—the plugin is installed, when we see this confirmation:<div><img src="img/BO5194_06_12.jpg" alt="Transitioning to using PostCSS-Neat"/></div></li></ol></div><p>We now have a plugin installed and configured for use. Before we create a test to confirm it works OK, let's take a quick look at our gulp file, at the root of our project area.</p><p>If you were expecting a complex configuration, then I'm sorry to disappoint you—it's even easier than installing Bourbon and Neat using the normal method outlined on their site! Our gulp file contains the requisite variable calls to each plugin at the start, with a watch facility at the end of the file. The section of interest to us is this:</p><div><pre class="programlisting">gulp.task('neat', function () {
  var processors = [
    require('autoprefixer-core')({ browsers: ['last 1 version'] }),
    require('postcss-neat')(/* { options } */)
  ];
  return gulp.src('src/*.css')
    .pipe(require('gulp-postcss')(processors))
    .pipe(gulp.dest('dest/'));
});</pre></div><p>This setup should satisfy most scenarios, with a default of 12 columns; if there is a need to override it, we can do so by <a id="id312" class="indexterm"/>specifying the appropriate option in our configuration object:</p><div><pre class="programlisting">postcss([
  ...
  require('postcss-neat')({
    neatMaxWidth: '128em'
  })
  ...
])</pre></div><p>We will use this option later in this chapter in the <em>Testing our configuration section</em>, when we build our test example.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>For a full list of the attributes that can be modified, head over to <a class="ulink" href="https://github.com/jo-asakura/postcss-neat#custom-settings">https://github.com/jo-asakura/postcss-neat#custom-settings</a>.</p></div></div><p>We have a basic configuration now in place, but hold on...it looks a little short! The sharp-eyed among you should notice that we've included additional options in the <code class="literal">gulp</code> files in previous exercises, such as creating source maps or minifying our CSS files. Let's fix that now, by amending our gulp file to include these missing options. Everything will then be in place, ready for when we create our example site.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec58"/>Refining our task list</h2></div></div></div><p>Our <code class="literal">gulp</code> file, as it <a id="id313" class="indexterm"/>stands, is perfectly usable, but isn't really as useful as it could be—there are a handful of tasks we've built into previous exercises, but which of these are missing here.</p><p>A perfect example is the addition of source maps, but how about minifying our code too? Let's take a moment to refine our task list, and add in the missing tasks:</p><div><ol class="orderedlist arabic"><li class="listitem">The first task is to add in some variables that will act as references for the various plugins we will use—this goes in immediately after the last <code class="literal">var</code> statement, at the top of our <code class="literal">gulp</code> file:<div><pre class="programlisting">var cssnano = require('cssnano');
var sourcemaps = require('gulp-sourcemaps');
var rename = require('gulp-rename');
var stylelint = require('stylelint');
var reporter = require('postcss-reporter');</pre></div></li><li class="listitem">The first task to add in is a facility to lint our styles:<div><pre class="programlisting">gulp.task("lint-styles", ['neat'], function() {
  return gulp.src("dest/css/*.css")
    .pipe(postcss([ stylelint({
      "rules": {
        "color-no-invalid-hex": 2,
        "declaration-colon-space-before": [2, "never"],
        "indentation": [2, 2],
        "number-leading-zero": [2, "always"]
      }
    }),
    reporter({
      clearMessages: true,
    })
  ]))
});</pre></div></li><li class="listitem">With our styles <a id="id314" class="indexterm"/>checked for accuracy and consistency, we can now minify our code. Add the following block:<div><pre class="programlisting">gulp.task('rename', ['lint-styles'], function () {
  return gulp.src('dest/css/*.css')
    .pipe(postcss([ cssnano() ]))
    .pipe(rename('style.css'))
    .pipe(gulp.dest("dest/css"));
});</pre></div></li><li class="listitem">The next step is to add a source map option:<div><pre class="programlisting">gulp.task('sourcemap', ['rename'], function () {
  return gulp.src('dest/css/*.css')
    .pipe(sourcemaps.init())
    .pipe(sourcemaps.write('maps/'))
    .pipe(gulp.dest("dest/css"));
});</pre></div></li><li class="listitem">With the additions to our <code class="literal">gulp</code> file, we need to adjust the main default task to call these additional tasks:<div><pre class="programlisting">gulp.task('default', ['neat', 'lint-styles', 'rename', 'sourcemap']);</pre></div></li><li class="listitem">We have a watch facility in place, but it knows nothing about these extra tasks; let's add them in now:<div><pre class="programlisting">var watcher = gulp.watch('src/*.css', ['default',  'lint-styles', 'rename', 'sourcemap']);</pre></div></li></ol></div><p>We now have a working <code class="literal">gulp</code> file, that includes all of the configuration tasks required for our exercise—let's put it <a id="id315" class="indexterm"/>to the test by compiling some example code, to confirm it all works as expected.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec59"/>Testing our configuration</h2></div></div></div><p>A key part of our process is <a id="id316" class="indexterm"/>testing our <code class="literal">gulp</code> file to ensure it works; not only should it run all of the required tasks, but in the correct order, and produce the expected results. Although we've reused existing code for our gulp file, we've made some major changes to our <code class="literal">gulp</code> file—let's take a moment to test it is working, using the code from our previous demo.</p><p>To get our demo working under PostCSS, we need to make some changes to our code:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start by resaving the <code class="literal">style.scss</code> file (from within the <code class="literal">css</code> folder in the <code class="literal">Tutorial31</code> folder) as a plain CSS file, and not a SASS stylesheet, we've removed the use of SASS from our previous demo, making the use of the <code class="literal">.scss</code> extension redundant.</li><li class="listitem">Next, we used a <code class="literal">.wrapper</code> class in our previous demo. This needs to be modified as indicated:<div><pre class="programlisting">.wrapper {
  @neat-outer-container;
  margin: 0 auto;
}</pre></div></li><li class="listitem">Our <code class="literal">col-*</code> class rules need to change too. In place of the static percentages from the old demo, we're going to replace them with this:<div><pre class="programlisting">.col-1 { @neat-span-columns 1; }
.col-2 { @neat-span-columns 2; }
.col-3 { @neat-span-columns 3; }
.col-4 { @neat-span-columns 4; }
.col-5 { @neat-span-columns 5; }
.col-6 { @neat-span-columns 6; }
.col-7 { @neat-span-columns 7; }
.col-8 { @neat-span-columns 8; }
.col-9 { @neat-span-columns 9; }
.col-10 { @neat-span-columns 10;}
.col-11 { @neat-span-columns 11; }
.col-12 { @neat-span-columns 12; }</pre></div></li><li class="listitem">Our code is now ready, so go ahead and copy the <code class="literal">style.css</code> file into the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">Next, fire up a Node.js command prompt, then change the working folder to our project area.</li><li class="listitem">At the command prompt, enter <code class="literal">gulp</code> then press <em>Enter</em>.</li><li class="listitem">If all is well, we should see a compiled <code class="literal">style.css</code> file appear in the <code class="literal">dest</code> folder. If we open <a id="id317" class="indexterm"/>it up, we should see a number of styles displayed that relate to each column, such as is shown in this screenshot:<div><img src="img/BO5194_06_13.jpg" alt="Testing our configuration"/></div></li><li class="listitem">If we try previewing the demo in a browser, we should see something akin to this screenshot. Notice how similar it is to the original version, which we built in SASS:<div><img src="img/BO5194_06_14.jpg" alt="Testing our configuration"/></div></li></ol></div><p>The demo that we've constructed is nearly identical to the original version. This proves that we have a working capability, which we can use to build our sites. The changes we made to our code are very simple, we added a <code class="literal">@neat-outer-container </code>to define how wide our site should be, followed by multiple instances of <code class="literal">@neat-span-columns</code>, to define how many columns each element should span.</p><p>Let's put some of this new knowledge to constructing something a little more useful, in the form of an example <a id="id318" class="indexterm"/>site with content. We'll reuse the example site page we created earlier in the chapter, and work through converting it for use with PostCSS plugins.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Creating a site using Neat and PostCSS</h1></div></div></div><p>Remember our <a id="id319" class="indexterm"/>demo with a Japanese theme from earlier, in <em>Creating an example with Bourbon Neat?</em> It's a simple demo, using Bourbon Neat to help create <a id="id320" class="indexterm"/>our grid. The downside, though, is, of course, the dependency on SASS!</p><p>Well, we can fix that: PostCSS has a plugin available that mimics Bourbon Neat, but is written entirely in JavaScript, so there is no dependency on SASS. It's easy to install and use, over the next few pages, we'll work through the changes required to switch to this plugin.</p><p>First though, let's get it set up:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll begin by extracting a copy of the <code class="literal">Tutorial32</code> folder from the code download that accompanies this book. Save this to the root of our project area.</li><li class="listitem">Copy the <code class="literal">sample pre-compile.css</code> file to the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">Copy the <code class="literal">gulpfile.js</code>, <code class="literal">samplesite.html</code> and <code class="literal">package.json</code> files to the root of our project area. These should replace any existing versions that are present.</li><li class="listitem">Next, we need to install two plugins, although we've covered using <code class="literal">postcss-css-variables</code> earlier in the book, installing them will ensure the right references are added to the <code class="literal">package.json</code> file. Go ahead and fire up a Node.js command prompt, then change the working folder to our project area.</li><li class="listitem">At the command prompt, enter these two statements in turn, pressing <em>Enter</em> between each one:<div><pre class="programlisting"><strong>npm install postcss-css-variables --save-dev</strong>
<strong>npm install postcss-nested</strong>
</pre></div></li><li class="listitem">When both plugins are installed, go ahead and enter <code class="literal">gulp</code>, then press <em>Enter</em> to fire off a compilation of our style sheet.</li><li class="listitem">If all is well, we should see two style sheets and a source <code class="literal">map</code> folder appear in the <code class="literal">dest</code> folder. Copy these to the <code class="literal">css</code> folder at the root of our project area.</li><li class="listitem">If we fire up a copy of <code class="literal">samplesite.html</code>, we should see our demo appear as before, but this time without the dependency on SASS:<div><img src="img/BO5194_06_15.jpg" alt="Creating a site using Neat and PostCSS"/></div></li></ol></div><p>Do you notice any difference <a id="id321" class="indexterm"/>to our SASS-only version of this demo, from earlier? Hopefully not; while it may not be pixel-identical to the original, it is not far from it! However, it does show that with a little ingenuity, it is possible to make the transition to using <a id="id322" class="indexterm"/>PostCSS and still maintain the same results. It will require a few changes to your code and processes, so let's take a look at these in more detail, starting with the style sheet.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Making the change to PostCSS</h2></div></div></div><p>Making the switch <a id="id323" class="indexterm"/>requires changes in both the <code class="literal">gulp</code> task file and style sheet. These are not to change how the page will look, but to maintain the same theme from the original demo. The key changes made to the style sheet are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">_reset.scss</code> partial style sheet that we import will no longer work, as we are removing the reliance on SASS. To maintain its use, a compiled version was created using the online playground at Sassmeister (<a class="ulink" href="http://www.sassmeister.com">http://www.sassmeister.com</a>); we can then link to it from our markup page.</li><li class="listitem" style="list-style-type: disc">If you take a peek at the source version of <code class="literal">sample.css</code>, you will see a <code class="literal">:root</code> block at the top of the file; this replaces the <code class="literal">import</code> statements we used. This block can be used to store any variables used, and we will cover this in more detail when we explore the changes made to our <code class="literal">gulp</code> task file.</li><li class="listitem" style="list-style-type: disc">We no longer needed the following three statements; they are used to debug the SASS version of Bourbon Neat, and were then removed:<div><pre class="programlisting">$visual-grid: true;
$visual-grid-color: #E6F6FF;
$visual-grid-opacity: 0.4;</pre></div></li><li class="listitem" style="list-style-type: disc">We're using PostCSS equivalents for all of the variable statements. The SASS versions were modified using search and replace from <code class="literal">$...</code> to <code class="literal">var(--….)</code>, where the ... represents the variable name.</li><li class="listitem" style="list-style-type: disc">Our original code had a number of references to <code class="literal">Bourbon</code> mixins which had to be updated. We used the same search and replace principle, this time changing <code class="literal">@include outer…</code> to <code class="literal">@neat-outer…</code> throughout the code.</li><li class="listitem" style="list-style-type: disc">To keep things simple, we manually calculated any instance where <code class="literal">$body-line-height</code> was referenced, and replaced the calculation with the result. We could have stayed with using calculations, but it would have required the use of another plugin <a id="id324" class="indexterm"/>which would have been overkill for their limited use in our code.</li><li class="listitem" style="list-style-type: disc">We also adjusted the width of the main area in our page; it's a minor quirk, but required to ensure we had two areas side by side, and not one above the other!</li></ul></div><p>In addition to altering our style sheet, we also had to make some changes to the <code class="literal">gulp</code> task file. They center around replacing the main compilation task and adding in additional tasks to manage production and minification of our source files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We added in the rename, lint-styles, and sourcemap tasks covered in earlier demos. These already worked well, and required no modification.</li><li class="listitem" style="list-style-type: disc">We stripped out the original styles task, and replaced it with this:<div><img src="img/BO5194_06_16.jpg" alt="Making the change to PostCSS"/></div><p>This time, we're calling them <code class="literal">nested()</code>, <code class="literal">cssvariables()</code> and Neat plugins. These are referenced used variables and are added in at the top of our <code class="literal">gulp</code> file.</p></li><li class="listitem" style="list-style-type: disc">Our final change is at the end of the <code class="literal">gulp</code> file, where we had to adjust the default and watcher tasks to include the additional tasks that we added to our <code class="literal">gulp</code> file.</li></ul></div><p>At this stage, do we have a <a id="id325" class="indexterm"/>working demo ready for use? Well, not quite, but let's try resizing our demo:</p><div><img src="img/BO5194_06_17.jpg" alt="Making the change to PostCSS"/></div><p>Hmm, what's happened to our content? It doesn't look great, does it? We can easily fix it though; it just requires the addition of some media queries to reorganize how our content is displayed on the screen. Let's dive in and take a look at what is needed to get our demo looking better at smaller sizes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Adding responsive capabilities</h1></div></div></div><p>Although Bourbon <a id="id326" class="indexterm"/>does add a degree of responsivity to our code, it's not quite enough for our needs. If we try resizing our demo, it soon becomes apparent that the elements don't quite go where we would want them, to say the least!</p><p>The quickest way to see just how the design looks when resized for smaller devices is to use Google Chrome. Press <em>Shift</em> <code class="literal">+ </code>
<em>Ctrl</em>
<code class="literal"> + </code>
<em>I</em> to enable Chrome's developer tools:</p><div><img src="img/BO5194_06_18.jpg" alt="Adding responsive capabilities"/></div><p>The design works well when viewed at 1280px x 1024px, but this soon changes if we change the available viewing <a id="id327" class="indexterm"/>estate to suit an Apple iPhone 6 at 375px by 627px:</p><div><img src="img/BO5194_06_19.jpg" alt="Adding responsive capabilities"/></div><p>See what I mean? It just doesn't look right, does it? Fortunately, it's easy to fix using PostCSS, so let's dive in and see what is required to get our design working again.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Correcting the design</h2></div></div></div><p>Getting our design to <a id="id328" class="indexterm"/>work properly for smaller devices such as iPhones is easy when working with PostCSS: we can use the <code class="literal">postcss-media-minmax</code> plugin available from <a class="ulink" href="https://github.com/postcss/postcss-media-minmax">https://github.com/postcss/postcss-media-minmax</a>.</p><p>"How can PostCSS help us though?", I hear you ask. Easy, the point at which most people trip up when working with media queries is in setting the breakpoints, or determining where our designs break at specific sizes. The <code class="literal">postcss-media-minmax</code> plugin helps to make the text a little more human; after all, if a design works when the size is greater than or equal to an amount, why not say that in our code?</p><p>To see what I mean, let's get stuck into fixing our code. For simplicity, we will focus entirely on resizing our content for an iPhone 6, using 375px by 627px as our breakpoint (as determined by using Google Chrome's Responsive Design view). We will continue exactly where we left off from the previous demo:</p><div><ol class="orderedlist arabic"><li class="listitem">We first need to install the <code class="literal">postcss-media-minmax</code> plugin—to do this, fire up a Node.js command prompt session, then at the prompt add this command and press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install postcss-media-minmax --save-dev</strong>
</pre></div></li><li class="listitem">Next, open up a copy of the <code class="literal">sample.css</code> file from within the <code class="literal">src</code> folder in our project area. We'll add the media query first, adjusted to ensure we catch the right breakpoint:<div><pre class="programlisting">/* media queries */
@media screen and (width &gt;= 370px) and (width &lt;= 630px) {

}</pre></div></li><li class="listitem">Immediately inside the query, go ahead and add this rule. We don't want to resize below <code class="literal">375px</code> as a minimum:<div><pre class="programlisting">  body {
    min-width: 375px;
  }</pre></div></li><li class="listitem">The header image text needs to be resized to a smaller space, and we can also reduce it in size and move it over to the left a little:<div><pre class="programlisting">  header {
    width: 50%;
    font-size: 2rem;
    margin-left: 45%;
  }</pre></div></li><li class="listitem">The <code class="literal">#alpha</code> content area (or menu) has automatically resized itself, but the main content area (<code class="literal">#beta</code>) is too wide; let's resize it down to fit. Our area won't cope with all of the text, so we'll add an overflow attribute, and set it to hide text outside the viewable area:<div><pre class="programlisting">  #beta {
    margin-right: 2.35765160%;
    width: 55.1748%;
    overflow: auto;
  }</pre></div></li><li class="listitem">At this point, we need to install the <code class="literal">postcss-media-minmax</code> plugin, so fire up a Node,js command prompt and change the working folder to our project area.</li><li class="listitem">At the prompt, enter this command, then press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install postcss-media-minmax --save-dev</strong>
</pre></div></li><li class="listitem">When the <a id="id329" class="indexterm"/>plugin is installed, enter <code class="literal">gulp</code> at the command prompt, and press <em>Enter</em>.</li><li class="listitem">PostCSS will now compile the code, and if all is well, we should see updated style sheet and source <code class="literal">map</code> files appear in the <code class="literal">dest</code> folder.</li><li class="listitem">Go ahead and copy these into the <code class="literal">css</code> folder in the <code class="literal">Tutorial32</code> folder, then try previewing the results in a browser.</li></ol></div><p>If all is well, we should see something akin to the following screenshot, when enabling Chrome's Responsive Design view, and switching the Device setting to Apple iPhone 6:</p><div><img src="img/BO5194_06_20.jpg" alt="Correcting the design"/></div><p>The changes we've made to our code are simple, and limited to supporting iPhones. This is just the tip of the iceberg, though: there is so much more we can do!</p><p>For example, instead of specifying an exact width value as our <code class="literal">min-width</code> attribute (or for the width of #beta, for that matter), we could consider using <code class="literal">@neat-span-columns</code> to provide this value for us. Of course, we can't limit ourselves to one media query, we need to ensure we have enough media queries to cater for the devices we need to support.</p><p>This does not mean that we <a id="id330" class="indexterm"/>need to have a 1:1 relationship between a query and a device. Provided we design our queries carefully, we can set existing ones to cover several devices. Ultimately, though, the principle is still the same, but instead of using the standard colon notation, we can use the easier to read <code class="literal">&gt;=</code> or <code class="literal">&lt;=</code> symbols to define the breakpoint range when working with queries using PostCSS.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Summary</h1></div></div></div><p>For many developers or designers, using grid-based development forms a key part of their working process. Many will be familiar with the likes of Bootstrap or Bourbon Neat; we can easily replicate the same functionality within PostCSS. Let's take a moment to review what we've covered throughout this chapter.</p><p>We kicked off with a brief introduction to using grid-based development, before swiftly moving on to beginning the transition process to using PostCSS. Our first stop was a look at automating the compilation process so we can make the switch to using Gulp.</p><p>Next up, we then took a look at making the switch from using pure SASS to using the SASS-based grid system, Bourbon Neat; we covered how easy it is for Bourbon to build the structure of our grid system with minimal effort.</p><p>We then moved on to exploring the plugin options available from within PostCSS, before making the transition to using the <code class="literal">postcss-neat</code> plugin. We then explored how easy it is to refine our Gulp task process, by adding in tasks that we introduced from earlier in the book, to help build up a process that more closely represents real-world development. To confirm the process works, we performed a test using an adapted version of the original demo from Bourbon Neat, before moving on to converting our Japanese-themed demo to using PostCSS equivalent plugins. We then rounded out the chapter with a brief look at refining the responsive capabilities within our design, to ensure it works better on smaller devices.</p><p>Phew, it may not seem like much, but we certainly covered a lot over the last few pages! But, as always, we continue apace: in the next chapter, we'll really get animated (sorry, pun intended!), with a look at how PostCSS can help with animating content.</p></div></body></html>