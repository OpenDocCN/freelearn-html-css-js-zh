- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing Node.js Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main attractions of Node.js is the massive ecosystem of external
    third-party libraries. **Node.js modules** are libraries or a set of functions
    you want to include in your application. Most modules will provide an API to expose
    functionality. The **npm** registry is where most Node.js modules are stored,
    where there are over a million Node.js modules available.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will first cover how to consume existing Node.js modules from the
    **npm** registry for use within your applications using the **npm** **command-line**
    **interface** ( **CLI** ).
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you’ll learn how to develop and publish your own Node.js
    module to the **npm** registry. There will also be an introduction to using the
    **ECMAScript Modules** ( **ESM** ) syntax, which is available in all currently
    supported versions of Node.js. The recipes in this chapter build upon each other,
    so it’s recommended you work through them in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Node.js modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaffolding a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing module code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ESM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will require you to have Node.js, preferably the most recent Node.js
    22 release, installed. You should also have the **npm** CLI installed, which comes
    bundled with Node.js. Both **node** and **npm** should be in your path in your
    shell ( or terminal).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to install Node.js with **Node Version Manager** ( **nvm**
    ). It is a tool that enables you to easily switch Node.js versions on most Unix-like
    platforms. If you’re using Windows, you can install Node.js from [https://nodejs.org/en/](https://nodejs.org/en/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm which versions of Node.js and **npm** are installed by typing
    the following command into your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The **npm** CLI is the default package manager bundled with Node.js, and we’ll
    be using the bundled **npm** CLI in this chapter to install and publish modules.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **npm** CLI is bundled with Node.js as the default package manager. npm,
    Inc. is also the name of the company that owns the **npm** registry ( [https://npmjs.org/](https://npmjs.org/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Note that as we will be downloading and publishing modules to the **npm** registry,
    this chapter will require internet access.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Node.js modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to consume **npm** modules from the
    public **npm** registry using the **npm** CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Yarn** is a popular alternative package manager for JavaScript and was created
    as an alternative to the **npm** CLI in 2016. When Yarn was released, **npm**
    did not have the **package-lock.json** feature to guarantee consistency of which
    specific versions of modules would be installed. This was one of the key features
    of Yarn. At the time of writing, the Yarn CLI offers a similar user experience
    to what the **npm** CLI provides. Yarn maintains a registry that is a reverse
    proxy to the **npm** registry. For more information about Yarn, check out their
    *Get Started* guide: [https://yarnpkg.com/getting-started](https://yarnpkg.com/getting-started)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, we first need to create a new directory to work in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a file where we can attempt to execute the imported module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’re going to set up a project and install the **express**
    module, a commonly used web framework for Node.js and often one of the first modules
    newcomers to the runtime learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll need to initialize a new project. Do this by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will need to step through the utility to answer the questions in the command-line
    utility. If you are unsure, you can just hit *Enter* to accept the defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **npm init** command should have generated a **package.json** file in your
    project directory. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can install our module. To install the **express** module, type the
    following command while in your project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we look at the **package.json** file again, we should see that the module
    has been added to a **dependencies** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, observe that both a **node_modules** directory and a **package-lock.json**
    file have now been created in your project directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can open our **require-express.js** file. We only need to add the following
    line to test whether we can import and use the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is expected that the program executes and immediately terminates after requiring
    the **express** module. Should the module not have been installed successfully,
    we would have seen an error like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now successfully downloaded a third-party module from the **npm** registry
    and imported it into our application so that it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe made use of both **npm** , the CLI bundled with Node.js, and the
    **npm** public registry to download the **express** third-party module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command of the recipe was **npm init** . This command initializes
    a new project in the current working directory. By default, running this command
    will open a CLI utility that will ask for some properties about your project.
    The following table defines the requested properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| Package name | Specifies the name of the project. It must be unique when
    publishing to the **npm** registry. A name can be prefixed by a scope; for example,
    **@organization/package** . |'
  prefs: []
  type: TYPE_TB
- en: '| Version | The initial version of the project. It is typical of Node.js modules
    to follow the Semantic Versioning standard. The default value is **1.0.0** . |'
  prefs: []
  type: TYPE_TB
- en: '| Description | A brief description of your project to help users understand
    what your project does and its purpose. |'
  prefs: []
  type: TYPE_TB
- en: '| Entry point | The entry point file of your Node.js application or module.
    It’s the path to the main file that will be executed when your module is required
    by another application. The default value is **index.js** . |'
  prefs: []
  type: TYPE_TB
- en: '| Test command | Used to define the command to be run when executing **npm
    test** or **npm run test** . Typically, this will be the command that executes
    your test suite. |'
  prefs: []
  type: TYPE_TB
- en: '| Git repository | Specifies the location of your project’s source code repository.
    This is helpful for contributors and users who want to access the code, report
    issues, or contribute. |'
  prefs: []
  type: TYPE_TB
- en: '| Keywords | Keywords relating to your project. |'
  prefs: []
  type: TYPE_TB
- en: '| Author | A list of the author(s) of the project. |'
  prefs: []
  type: TYPE_TB
- en: '| License | Indicates the license type under which the project is distributed.
    This is important for users to understand how they are permitted to use and share
    your project. |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Table detailing default properties of the package.json file
  prefs: []
  type: TYPE_NORMAL
- en: 'The only properties that are mandatory are the package name and version. It
    is also possible to skip the CLI utility and accept all defaults by typing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to configure default answers using the **npm config** command.
    This can be achieved with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the **npm init** command completes, it will generate a **package.json**
    file in your current working directory. The **package.json** file does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It lists the packages that your project depends on, acting as a *blueprint*
    or set of instructions as to which dependencies need to be installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a mechanism for you to specify the versions of a package that your
    project can use – based on the Semantic Versioning specification ( [https://semver.org/](https://semver.org/)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next step of the recipe, we used the **npm install express** command
    to install the **express** module. The command reaches out to the **npm** registry
    to download the latest version of the module with the **express** name identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when supplying a module name, the **npm install** command will
    look for a module with that name and download it from the public **npm** registry.
    But it is also possible to pass the **npm install** command other parameters,
    such as a GitHub URL, and the command will install the content available at the
    URL. For more information, refer to the **npm** CLI documentation: [https://docs.npmjs.com/cli/v10/commands/npm-install](https://docs.npmjs.com/cli/v10/commands/npm-install)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: When the **install** command completes, it will put the module contents into
    a **node_modules** directory. If there isn’t one in the current project, but there
    is **package.json** , the command will also create a **node_modules** directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the contents of the **node_modules** directory, you will notice
    that more than just the **express** module is present. This is because **express**
    has dependencies, and their dependencies may also have dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When installing a module, you’re potentially, and often, installing a whole
    tree of modules. The following output shows a snippet of the structure of a **node_modules**
    directory from the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the **npm list** command to list the contents of your **node_modules**
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: You may also notice that a **package-lock.json** file has been created. Files
    of the **package-lock.json** type were introduced in **npm** version 5. The difference
    between **package-lock.json** and **package.json** is that a **package-lock.json**
    file defines specific versions of all modules in the **node_modules** tree.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the way dependencies are installed, two developers with the same **package.json**
    file may experience different results when running **npm install** . This is mainly
    because a **package.json** file can specify acceptable module ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our recipe, we installed the latest version of **express**
    , and this resulted in the following range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The **^** character indicates that it will allow all versions above v4.18.2
    to be installed, but not v5.x.x. If v4.18.3 were to be released in the time between
    when developer A and developer B run the **npm install** command, then it is likely
    that developer A will get v4.18.2 and developer B will get v4.18.3.
  prefs: []
  type: TYPE_NORMAL
- en: If the **package-lock.json** file is shared between the developers, they will
    be guaranteed the installation of the same version of **express** and the same
    versions of all the dependencies of **express** .
  prefs: []
  type: TYPE_NORMAL
- en: The **npm** CLI can also generate a **npm-shrinkwrap.json** file using the **npm
    shrinkwrap** command. The **npm-shrinkwrap.json** file is identical in structure
    and serves a similar purpose to the **package-lock.json** file. The **package-lock.json**
    file cannot be published to the registry, whereas the **npm-shrinkwrap.json**
    can. Typically, when publishing an **npm** module, you’ll want to not include
    the **npm-shrinkwrap.json** file as it would prevent the module from receiving
    transitive dependency updates.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of **npm-shrinkwrap.json** in a package means that all installs
    of that package will generate the same dependencies. The **npm-shrinkwrap.json**
    file is useful for ensuring consistency across installations in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final step of the recipe, we imported the **express** module to test
    whether it was installed and accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is the same way in which you import Node.js core modules. The
    module-loading algorithm will first check to see whether you’re requiring a core
    Node.js module; it will then look in the **node_modules** folder to find the module
    with that name.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use **require()** to import files by passing a path,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve learned a bit about consuming Node.js modules, we’re going to
    look at development dependencies, global modules, and the considerations you should
    make when consuming Node.js modules.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding development dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In **package.json** , you can distinguish between development dependencies and
    regular dependencies. **Development dependencies** are typically used for tooling
    that supports you in developing your application.
  prefs: []
  type: TYPE_NORMAL
- en: Development dependencies should not be required to run your application. Having
    a distinction between dependencies that are required for your application to run
    and dependencies that are required to develop your application is particularly
    useful when it comes to deploying your application. Your production application
    deployment can omit development dependencies, which makes the resulting production
    application smaller. A very common use of development dependencies is for linting
    and formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a development dependency, you need to supply the **install** command
    with the **--save-dev** parameter. For example, to install **semistandard** ,
    we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The **--save-exact** parameter pins the exact version in your **package.json**
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that there is a separate section for development dependencies that
    have been created in **package.json** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then execute the installed **semistandard** executable with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Installing global modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to globally install Node.js modules. Typically, the type of
    modules you’ll install globally are binaries or a program that you want to be
    accessible in your terminal. To globally install a module, you pass the **--global**
    command to the **install** command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not install **lolcatjs** into your **node_modules** folder. Instead,
    it will be installed into the **bin** directory of your Node.js installation.
    To see where it was installed, you can use the **which** command (or **where**
    on Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The **bin** directory is likely to already be in your path because that is
    where the **node** and **npm** binaries are stored. Therefore, any executable
    program that is globally installed will also be made available in your shell.
    Now, you should be able to call the **lolcatjs** module from your shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In **npm** v5.2, **npm** added the **npx** command to their CLI. This command
    allows you to execute a global module without having it globally installed on
    your system. You could execute the **lolcatjs** module without storing it with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In general, **npx** should be sufficient for most modules that you wish to execute.
    Using **npx** can be preferable as it enables you to run packages without polluting
    your global namespace. It can also help when you need to execute different versions
    of a package on a per-project basis as it avoids any global version conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Responsibly consuming modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll likely want to leverage the Node.js module ecosystem in your applications.
    Modules provide solutions and implementations of common problems and tasks, so
    reusing existing code can save you time when developing your applications.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in the recipe, simply pulling in the web framework, **express** pulled
    in over 80 other modules. Pulling in this number of modules adds risk, especially
    if you’re using these modules for production workloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many considerations you should make when choosing a Node.js module
    to include in your application. The following three considerations should be made
    in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security** : Can you depend on the module to fix security vulnerabilities?
    [*Chapter 9*](B19212_09.xhtml#_idTextAnchor274) will go into more detail about
    how to check for known security issues in your modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Licenses** : If you link with open source libraries and then distribute the
    software, your software needs to be compliant with the licenses of the linked
    libraries. Licenses can vary from restrictive/protective to permissive. In GitHub,
    you can navigate to the license file, and it will give you a basic overview of
    what the license permits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – GitHub license information](img/B19212_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – GitHub license information
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintenance** : You’ll also need to consider how well maintained the module
    is. Many modules publish their source code to GitHub and have their bug reports
    viewable as GitHub issues. From viewing their issues and how/when the maintainers
    are responding to bug reports, you should be able to get some insight into how
    maintained the module is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Scaffolding a module* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing module code* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Publishing a module* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapters 6* and *9*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaffolding a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll be scaffolding our first module; that is, we will set
    up a typical file and directory structure for our module and learn how to initialize
    our project with the **npm** CLI. We’ll also create a GitHub repository to store
    our module code. GitHub is a hosting provider that allows users to store their
    **Git** -based repositories, where Git is a **version control** **system** ( **VCS**
    ).
  prefs: []
  type: TYPE_NORMAL
- en: The module we’re going to make will expose an API that converts the temperature
    in Fahrenheit to Celsius and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will require you to have a GitHub account ( [https://github.com/join](https://github.com/join)
    ) to publish source code and an **npm** account ( [https://www.npmjs.com/signup](https://www.npmjs.com/signup)
    ) to publish your module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll be using the **npm** CLI to initialize our **temperature-converter**
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a GitHub repository to store our module code. To do this, you can
    click **+** | **New repository** from the GitHub navigation bar or navigate to
    [https://github.com/new](https://github.com/new) . Specify the repository name
    as **temperature-converter** . Note that the repository name does not have to
    match the module name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While you’re here, it’s also recommended to add the default **.gitignore**
    file for Node.js and add the license file that matches the license field in **package.json**
    . You should expect to see the following GitHub **user interface** ( **UI** )
    for creating a new repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The GitHub Create a new repository interface](img/B19212_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The GitHub Create a new repository interface
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A **.gitignore** file informs Git which files to omit, or ignore, in a project.
    GitHub provides a default **.gitignore** file per language or runtime. GitHub’s
    default **.gitignore** file for Node.js is visible at [https://github.com/github/gitignore/blob/master/Node.gitignore](https://github.com/github/gitignore/blob/master/Node.gitignore)
    . Note that **node_modules** is automatically added to **.gitignore** . The **package.json**
    file instructs which modules need to be installed for a project, and it is typically
    expected that each developer would run the **npm install** command on their development
    environment rather than have the **node_modules** directory committed to source
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the repository is initialized, we can clone the repository using the Git
    CLI in our shell. Enter the following command to clone the repository, substituting
    the reference to the repository with your GitHub username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It’s preferred to use **Secure Shell** ( **SSH** ) to clone the repository.
    If you have not set up your SSH keys for GitHub, then you should follow the steps
    at [https://docs.github.com/en/authentication/connecting-to-github-with-ssh](https://docs.github.com/en/authentication/connecting-to-github-with-ssh)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the newly cloned directory and observe the files present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also run the **git status** and **git log** commands to see what state
    we’re in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we’ve created our repository and have a copy locally to work from, we can
    initialize our module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use *Enter* to accept defaults or complete the values as follows. The
    command will create a **package.json** file for you. Open the file and expect
    to see output like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **README.md** file and add, and then save, some simple text. For example,
    you can add a simple heading in **Markdown** format: **#** **temperature-converter**
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we’re going to commit these changes with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When this is successful, you should see output like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now seen how to use the Git and **npm** CLI to initialize our **temperature-converter**
    module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To kick off our project, we begin by setting up a GitHub repository, which serves
    as a central hub for storing and managing our code base. This involves creating
    a new repository on GitHub, where we’ll store our module code under a specified
    name – in this case, **temperature-converter** . Additionally, we take the opportunity
    to include a **.gitignore** file, which informs Git of files to exclude from version
    control and add a license file, defining how others can use our code.
  prefs: []
  type: TYPE_NORMAL
- en: Once our repository is established, we clone it locally using the Git CLI. Cloning
    creates a copy of the repository on our local machine, allowing us to work on
    the code base offline and push changes back to the remote repository when ready.
    We navigate into the cloned directory to inspect its contents and review the repository’s
    status and history using **git status** and **git log** .
  prefs: []
  type: TYPE_NORMAL
- en: With our local setup ready, we initialize our module using **npm** . The **npm
    init** command guides us through creating a **package.json** file, which contains
    essential metadata about our project, such as its name, version, and dependencies.
    This file serves as a blueprint for our module and ensures consistency across
    different environments.
  prefs: []
  type: TYPE_NORMAL
- en: To finalize our initial setup, we commit our changes to the repository. This
    involves staging the **package.json** and **README.md** files, committing them
    with a descriptive message, and pushing the changes to the remote repository on
    GitHub. This step ensures that our project’s history is well documented and that
    our latest changes are published.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Git is a powerful tool that is commonly used for source control of software.
    If you’re unfamiliar with Git, GitHub provides an interactive guide for you to
    learn at [https://guides.github. com/introduction/flow/](https://guides.github.com/introduction/flow/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we specified the module version as v0.1.0 to adhere to Semantic
    Versioning. Let’s look at this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Semantic Versioning** , often abbreviated to **SemVer** , is a well-known
    standard for versioning. Node.js itself tries to adhere to Semantic Versioning
    as much as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Semantic version numbers are in the form of **X.Y.Z** , where the following
    applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**X** represents the major version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Y** represents the minor version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z** represents the patch version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Briefly, Semantic Versioning states that you increment the major version, the
    first value, when you make breaking API changes. The second number, the minor
    version, is incremented when new features have been added in a backward-compatible
    (or non-breaking) manner. The patch version, or the third number, is for bug fixes
    and non-breaking and non-additive updates.
  prefs: []
  type: TYPE_NORMAL
- en: The major version 0 is reserved for initial development, and it is acceptable
    to make breaking changes up until v1 is released. It is often disputed what the
    initial version should be. In the recipe, we started with version v0.1.0 to allow
    us the freedom to make breaking changes in early development without having to
    increment the major version number.
  prefs: []
  type: TYPE_NORMAL
- en: Following Semantic Versioning is commonplace in the Node.js module ecosystem.
    The **npm** CLI takes this into account by allowing **semver** ranges in **package.json**
    – refer to the *There’s more…* section of the *Consuming Node.js modules* recipe
    or visit [https://docs.npmjs.com/files/package.json#dependencies](https://docs.npmjs.com/files/package.json#dependencies)
    for more information on **npm** version ranges.
  prefs: []
  type: TYPE_NORMAL
- en: The **npm** CLI provides an API to support Semantic Versioning. The **npm version**
    command can be supplied with **major** , **minor** , or **patch** to increment
    the appropriate version numbers in your **package.json** file. There are further
    arguments that can be passed to the **npm** version command, including support
    for pre-versions – refer to [https://docs.npmjs.com/cli/version](https://docs.npmjs.com/cli/version)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Writing module code* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Publishing a module* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing module code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’re going to start writing our module code. The module we
    will write will expose two APIs that will be used to convert the supplied temperature
    from Fahrenheit to Celsius and vice versa. We’ll also install a popular code formatter
    to keep our module code consistent and add some simple test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you’re in the **temperature-converter** folder and that **package.json**
    is present, indicating that we have an initialized project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also need to create the first JavaScript file for our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, we’ll try testing importing and using the module, so let’s create two
    files ready for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to start this recipe by installing a code formatter to keep our
    module code styling consistent. By the end of this recipe, we will have created
    our first Node.js module.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add **semistandard** as a code formatter for our module. When
    we know that other users are going to be consuming or contributing to our modules,
    it’s important to have consistently formatted code for consistency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the initial implementation of this module, we will expose two APIs – one
    to be used to convert from Fahrenheit to Celsius which we will name **fahrenheitToCelsius()**
    , and another to be used for the opposite conversion named **celsiusToFahrenheit()**
    . We’ll be using the known mathematical formula for converting between the two
    temperature measures. Start by opening **index.js** and adding the following to
    define the **fahrenheitToCelsius()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the accompanying **celsiusToFahrenheit()** function to do the
    reverse conversion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll add the key line to the bottom of our file that makes the two functions
    available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can test if our small program works from the command line with the
    following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a simple test file for our module. We’ll use the core **assert**
    module to implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that we are requiring the module and testing the two temperature conversion
    functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can run our test file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s define **npm run lint** and **npm run test** scripts to run our
    linter and tests respectively. Open the **package.json** file and replace the
    **scripts** property with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run the linter with **npm** **run lint** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you had any lint issues, **semistandard** would alert you to these. They
    can be fixed by running the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also run our tests with the **npm** **test** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we’ve implemented, linted, and tested our code, we can commit the updates
    with Git and push our module code to GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now created our first module that exposes two APIs and added a test case
    for good measure.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To ensure consistency and readability in our module’s code base, we begin by
    incorporating a popular code formatter, **semistandard** , as part of our development
    workflow. This ensures that our code follows a standardized style, making it easier
    for other developers to understand and collaborate on our project.
  prefs: []
  type: TYPE_NORMAL
- en: With **semistandard** installed as a development dependency, we proceed to implement
    the core functionality of our module. We define two conversion functions, **fahrenheitToCelsius()**
    and **celsiusToFahrenheit()** , leveraging well-known mathematical formulas for
    temperature conversion. These functions are encapsulated within our **index.js**
    file, making them accessible for use within our module.
  prefs: []
  type: TYPE_NORMAL
- en: To expose these conversion functions externally, we add an **export** statement
    at the bottom of our file, allowing other modules to import and utilize them as
    needed. This establishes a clear interface for interacting with our module’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: To validate the correctness of our implementation, we create a simple test file,
    **test.js** , using Node.js’s built-in **assert** module. This file contains test
    cases for each conversion function, ensuring that they produce the expected results
    under various input conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Upon running the test file, we confirm that all tests pass, indicating that
    our module’s functionality behaves as intended. We then enhance our development
    workflow by defining **npm** scripts for linting and testing, streamlining the
    process of code formatting and validation.
  prefs: []
  type: TYPE_NORMAL
- en: Running **npm run lint** checks our code base for adherence to coding standards,
    while **npm test** executes our test suite to verify the correctness of our implementation.
    Any deviations from the coding standards or failing tests are highlighted for
    resolution. It is possible to create as many custom scripts as is suitable for
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The **npm** CLI supports many shortcuts. For example, **npm install** can be
    shortened to **npm i** . The **npm test** command can be shortened to **npm t**
    . The **npm run-script** command can be shortened to **npm run** . For more details,
    refer to the **npm** CLI documentation: [https://docs.npmjs.com/cli-documentation/cli](https://docs.npmjs.com/cli-documentation/cli)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with our code base implemented, validated, and organized, we commit
    our changes using Git and push them to our GitHub repository. This ensures that
    our project’s history is well documented and that our latest updates are available
    to collaborators.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Publishing a module* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19212_08.xhtml#_idTextAnchor243)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will walk you through how to prepare and publish your module to
    the **npm** registry. Publishing your module to the **npm** registry will make
    it available for other developers to find and include in their applications. This
    is how the **npm** ecosystem operates: developers will author and publish modules
    to **npm** for other developers to consume and reuse in their Node.js application.'
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we will be publishing the **temperature-converter** module that
    we created in the *Writing module code* recipe of this chapter to the **npm**
    registry. Specifically, we’ll be publishing our module to a scoped namespace,
    so you can expect your module to be available at **@npmusername/temperature-converter**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe relies on the *Writing module code* recipe of this chapter. We will
    be publishing the **temperature-converter** module that we created in that recipe
    to the **npm** registry. You can obtain the module code from the *Writing module
    code* recipe from the GitHub repository at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter05/temperature-converter](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter05/temperature-converter)
    .
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also will require you to have an **npm** account. Go to [https://www.npmjs.com/signup](https://www.npmjs.com/signup)
    to sign up for an account. Keep note of your **npm** username.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will walk through the process of publishing a module to the **npm**
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have signed up for an **npm** account, you can authorize your **npm**
    client with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s update the **README.md** file that was automatically created for us when
    we initialized the GitHub repository in the *Scaffolding a module* recipe. Having
    an appropriate and clear **README.md** file is important so that users who stumble
    upon the module can understand what it does and whether it suits their use case.
    Open the **README.md** file in your editor and update the following, remembering
    to change the **npm** username to your own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]js'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const { fahrenheitToCelsius, celsiusToFahrenheit }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: = require('@npmusername/temperature-converter');
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const celsius = fahrenheitToCelsius(100);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: console.log(`100°F is ${celsius}°C`);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const fahrenheit = celsiusToFahrenheit(37);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: console.log(`37°C is ${fahrenheit}°F`);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]sh'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ npm run test
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **README** file we’ve just created is written using Markdown. The **.md**
    or **.MD** ending indicates that it is a Markdown file. Markdown is a documentation
    syntax that is commonly used across GitHub. To learn more about Markdown, check
    out GitHub’s guide at [https://guides.github.com/features/mastering-markdown/](https://guides.github.com/features/mastering-markdown/)
    . Many of the popular editors have plugins available so that you can render Markdown
    in your editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update the name of our module in the **package.json** file
    to match our scoped module name. Let’s also make this version **1.0.0** of the
    module. You can either manually edit **package.json** or rerun the **npm init**
    command to overwrite it with any new values. Remember to change the **npm** username
    to your own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is ideal to keep your public GitHub repository up to date. Typically, module
    authors will create a tag on GitHub that matches the version that is pushed to
    **npm** . This can act as an audit trail for users wishing to see the source code
    of the module at a particular version, without having to download it via **npm**
    . However, please note that nothing is enforcing that the code you publish to
    **npm** must match the code you publish to GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’re ready to publish our module to the **npm** registry using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can check that your publish was successful by navigating to [https://www.npmjs.com/package/@npmusername/temperature-converter](https://www.npmjs.com/package/@npmusername/temperature-converter)
    . Expect to see the following information about your module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – npm module information on npmjs.com](img/B19212_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – npm module information on npmjs.com
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first authenticated our local **npm** client using the **npm login** command.
    The **npm** client provides the ability to set up access controls so that certain
    users can publish to specific modules or scopes.
  prefs: []
  type: TYPE_NORMAL
- en: The **npm login** command identifies who you are and where you’re entitled to
    publish. It is also possible to log out using **npm logout** .
  prefs: []
  type: TYPE_NORMAL
- en: 'The command that did the actual publishing to the registry was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The **npm publish** command attempts to publish the package at the location
    identified by the **name** field in the **package.json** file. In the recipe,
    we published it to a scoped package – specifically, we used our own username’s
    scope. Scoped packages help to avoid naming conflicts. It is possible to publish
    your package to the global scope by not passing it a named scope – but you’re
    likely to run into name conflicts if your package has a common name.
  prefs: []
  type: TYPE_NORMAL
- en: We also passed the **--access=public** flag. When publishing to a scoped package,
    we explicitly need to indicate that we want the module to be public. The **npm**
    CLI allows you to publish your modules as either public or private for scoped
    packages. To publish a module privately, you need to have a paid **npm** account.
    Note that the **--access=public** flag is not required when publishing to the
    global scope because all modules in the global namespace are public.
  prefs: []
  type: TYPE_NORMAL
- en: The **npm publish** command packaged up our module code and uploaded it to the
    **npm** registry. Because the **package.json** file generated from the **npm init**
    command is generated with consistent properties, **npm** can extract and render
    that information on the module’s page. As shown in the recipe, **npm** automatically
    populated the **README** file, version, and GitHub links in the UI based on the
    information in our **package.json** file.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll consider prepublish scripts and the **.npmignore** file and look
    at how to publish to private registries.
  prefs: []
  type: TYPE_NORMAL
- en: Using prepublish scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **npm** CLI supports a **prepublishOnly** script. This script will only
    run before the module is packaged and published. This is useful for catching mistakes
    before publishing. Should a mistake be made, it may be necessary to publish a
    second version to correct this mistake, causing potentially avoidable inconvenience
    to your module consumers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a **prepublishOnly** script to our module. Our **prepublishOnly**
    script will just run our **lint** script for now. Add a **prepublishOnly** script
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, module authors will include rerunning their test suite in their
    **prepublishOnly** scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Using .npmignore and package.json “files” properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with a **.gitignore** file, which specifies which files should not be tracked
    or committed to a repository, **.npmignore** omits the files listed in it from
    the package. Files of the **.npmignore** type are not mandatory, and if you do
    not have one but do have a **.gitignore** file, then **npm** will omit the files
    and directories matched by the **.gitignore** file. The **.npmignore** file will
    override **.gitignore** if such a file exists.
  prefs: []
  type: TYPE_NORMAL
- en: The types of files and directories that are often added to **.npmignore** files
    are test files. If you have a particular large test suite in terms of size, then
    you should consider excluding these files by adding them to your **.npmignore**
    file. Users consuming your module do not tend to need the test suite bundled into
    their applications – excluding these and other superfluous files reduces the size
    of your module for all consumers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **.npmignore** file that excludes just the **test** directory would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Remember that once the **.npmignore** file is created, it will be considered
    the **source of truth** ( **SOT** ) of which files should be ignored from the
    **npm** package. It’s worth going through your **.gitignore** file and ensuring
    items that you’ve added there are also added to **.npmignore** .
  prefs: []
  type: TYPE_NORMAL
- en: In the **package.json** file, you can also define a **"files"** property that
    allows you to specify an array of file paths or patterns that should be included
    when the package is published. Rather than an exclusion list, this acts as an
    inclusion list for what is published.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you have a Node.js module containing various utility functions,
    but you only want to expose the main functionality and documentation, you can
    specify “ **files": ["lib/", "docs/", "README.md"]** in your **package.json**
    file. This ensures that only the files within the specified directories and the
    **README.md** file are included when users install your package, while all other
    internal files or directories are excluded from the published package.'
  prefs: []
  type: TYPE_NORMAL
- en: Providing an allow list by defining **"files"** in the **package.json** file
    rather than an exclusion list with **.npmignore** may be preferable as it removes
    the risk of forgetting to exclude a file in the **.** **npmignore** file.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that your package includes only the desired files upon publication,
    you can execute the **npm pack** command in your local environment. This command
    creates a tarball in your current working directory, mirroring the process used
    for publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: While TypeScript and other transpilers are not covered in detail in this book,
    it is typical when publishing to **npm** to only publish the output files, such
    as JavaScript files, and not the source files, such as TypeScript files. This
    practice ensures that the package consumers receive only the necessary files to
    run the module. To achieve this, you can use the **.npmignore** file or the **"files"**
    property in **package.json** to exclude source files and include only the compiled
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Private registries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **npm** CLI supports being configured to point to a **private registry**
    . A private registry is a registry that has been set up with some form of access
    control. Typically, these are set up by businesses and organizations that wish
    to keep some of their code off the public registry, potentially due to policy
    restrictions determined by their business. This enables the business to share
    its modules among members of the same organization while adhering to the business
    policy. Equally, a private registry can be used as a caching mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change which registry you’re pointing to with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see which registry you’re pointing to with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that these both use the **npm config** command. You can list all your
    **npm config** settings with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'A **.npmrc** file is a configuration file for **npm** that can be used to set
    various **npm** configurations globally or on a per-project basis. This file allows
    you to persistently configure **npm** settings, such as registry URLs and authentication
    tokens. For example, to point **npm** to a private registry, you can add the following
    line to a **.** **npmrc** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other configurable settings and customizations in this file;
    refer to the **npm** documentation for more information: [https://docs.npmjs.com/cli/v10/configuring-npm/npmrc](https://docs.npmjs.com/cli/v10/configuring-npm/npmrc)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Using ECMAScript modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ESM represents the official standard for packaging JavaScript code for reuse.
    ESM was introduced in **ECMAScript 2015** ( **ES6** ) to bring a unified module
    system to the JavaScript language, a featu re that was absent and in much demand
    for years. Unlike **CommonJS** ( **CJS** ) modules, which were adopted by Node.js
    for server-side development, ESM provides a way to statically analyze code for
    imports and exports, allowing for optimizations such as tree shaking, which eliminates
    unused code.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of ESM into the Node.js ecosystem marked a significant milestone,
    offering developers the benefits of a standardized module system that is compatible
    across different environments, including browsers, where modules can be natively
    loaded without the need for bundling tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring Node.js to use ESM involves understanding and setting up project
    structures to accommodate the new syntax and module resolution strategy. By default,
    Node.js treats **.js** files as CJS modules, but with the inclusion of a **"type":
    "module"** entry in a project’s **package.json** file, Node.js switches to treating
    files with the **.js** extension as ESM.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, developers can use the **.mjs** extension for JavaScript files
    intended to be treated as modules. This setup phase is crucial as it lays the
    foundation for importing and exporting modules using the **import** and **export**
    keywords, respectively, moving away from the **require** and **module.exports**
    syntax of CJS. The enablement of ESM in Node.js not only aligns server-side development
    with frontend practices but also opens new possibilities for code sharing and
    modularization across the JavaScript ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core ESM support is enabled by default and designated with stable status
    in all currently supported Node.js versions. However, some individual ESM capabilities
    remain experimental.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a mini-project that calculates various geometric
    shapes’ areas and perimeters. This recipe will serve as an introduction to using
    ESM in Node.js and demonstrate the use of named and default exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, ensure you’re using Node.js 22 and create a directory to work
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also prepare some files for our geometric shape modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll create modules for calculating the area and perimeter
    of geometric shapes such as circles and rectangles. We will also create a utility
    for rounding.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to initialize our module. For this recipe, we’ll just accept
    the defaults:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as we plan to use ESM syntax throughout, we should set the **"type": "module"**
    entry in the **package.json** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a *circle module* . This module will use a default **export**
    statement for the main function – which is to calculate the area. It will also
    expose a function to calculate the circumference of the circle as a named export.
    Add the following code to **circle.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are making use of the **Math** namespace object for the value of
    Pi.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we’ll create a *rectangle module* ( **rectangle.js** ). This module will
    export area and perimeter functions but this time using only named exports. Add
    the following code to **rectangle.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll implement a small *mathematical utility* . We’ll just add one function
    that rounds values. Create a file called **mathUtils.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to **mathUtils.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we’ll implement the *main module* ( **index.js** ). This module will
    import and use the functions from the geometry modules and the utility module.
    This module will demonstrate the various ways in which we can import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This module demonstrates importing a default export without braces, named exports
    with braces, and importing all named exports from a module as an object using
    the **import *** **as** syntax.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute your application by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see calculated metrics for a circle and a rectangle, showcasing how
    to use both default and named exports in a modular Node.js application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This project illustrates the flexibility and efficiency of using ESM for organizing
    and structuring JavaScript code in Node.js projects. Through the example of calculating
    geometric shapes’ metrics, we’ve seen how to properly use default and named exports
    to make our code modular and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tutorial is structured around the concept of modular programming using ESM
    in a Node.js environment. The primary goal of the recipe is to demonstrate how
    ESM can be leveraged to build a well-organized, maintainable, and scalable project.
    We achieve this through the development of a small application designed to calculate
    the area and perimeter of geometric shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is initiated as a standard Node.js application with a **package.json**
    file. By setting **"type": "module"** in the **package.json** file, we instruct
    Node.js to treat files with the **.js** extension as ESM files.'
  prefs: []
  type: TYPE_NORMAL
- en: The geometry calculations are divided into separate modules for each shape.
    This modular approach demonstrates the concept of single responsibility, where
    each module is tasked with a specific set of functionalities related to a particular
    geometric shape. This approach will be familiar to those who have worked with
    other **object-oriented programming** ( **OOP** ) languages such as Java.
  prefs: []
  type: TYPE_NORMAL
- en: For the circle module ( **circle.js** ), we implemented functions to calculate
    the area (exposed as the default export) and circumference (exposed as a named
    export) of a circle. The use of a default export for the primary function illustrates
    how to expose a module’s main functionality, while named exports tend to be used
    for secondary functions.
  prefs: []
  type: TYPE_NORMAL
- en: For the rectangle module ( **rectangle.js** ), we only included named exports
    for functions calculating the area and perimeter of a rectangle. The use of named
    exports highlights how multiple related functionalities can be grouped within
    a single module and exported individually.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced a utility module ( **mathUtils.js** ) to perform rounding operations.
    This module’s existence emphasizes the utility of having shared functionalities
    abstracted into their modules, making them reusable across a project.
  prefs: []
  type: TYPE_NORMAL
- en: The main module, **index.js** , serves as the entry point to the application.
    It dynamically imports the geometry modules and the utility module, using their
    functionalities to perform calculations based on user input or predefined values.
    While a simplified example, it demonstrates how to import both default and named
    exports from modules, highli ghting the versatility of ESM in handling various
    export types.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CJS remains widely used in Node.js applications due to its long history in the
    vast ecosystem of **npm** modules. ESM is being increasingly adopted for new projects
    due to its native browser support, module optimization capabilities, and alignment
    with the ECMAScript standard.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these differences is critical for developers navigating the Node.js
    and wider JavaScript ecosystem, especially when working on applications and projects
    that may require integrating both module types.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the current state of Node.js development, developers often have to navigate
    both module systems. Therefore, some recipes in subsequent chapters of this book
    will utilize the ESM syntax. In some cases, this is required due to certain **npm**
    modules now exclusively supporting ESM.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between CJS and ESM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The differences between CJS and ESM in Node.js are foundational to understanding
    how to effectively use modules in JavaScript applications. Let’s take a closer
    look at these:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CJS** | **ESM** |'
  prefs: []
  type: TYPE_TB
- en: '| Uses **require()** for importing modules and **module.exports** or **exports**
    for exporting. | Uses the **import** and **export** statements for importing and
    exporting modules. |'
  prefs: []
  type: TYPE_TB
- en: '| Loads modules synchronously. | Supports asynchronous loading, allowing for
    dynamic **import()** statements. |'
  prefs: []
  type: TYPE_TB
- en: '| Supports non-static, runtime module resolution allowing for conditional imports
    based on runtime conditions. | Static structure enables **import** / **export**
    statements to be analyzed at compile time, leading to potential optimizations
    by JavaScript engines. |'
  prefs: []
  type: TYPE_TB
- en: '| CJS modules can use ESM through dynamic **import()** statements or by creating
    wrapper modules, but attention is required to avoid issues such as the dual package
    hazard. | ESM can import CJS modules using default imports. |'
  prefs: []
  type: TYPE_TB
- en: '| Exports are copied upon import, meaning changes to the exported value after
    import are not reflected in the importing module. | Supports live bindings, allowing
    imported values to update if they change in the exporting module. |'
  prefs: []
  type: TYPE_TB
- en: '| Does not support **top-level await** as it relies on synchronous module loading.
    | Enables Top-level Await, enabling modules to wait for asynchronous operations
    before proceeding. |'
  prefs: []
  type: TYPE_TB
- en: '| Typically uses the **.js** extension, although an explicit **.cjs** extension
    may be used. | While **.js** can be used (with **"type": "module"** in **package.json**
    ), the **.mjs** extension can be used to explicitly mark files as ESM. |'
  prefs: []
  type: TYPE_TB
- en: '| Modules have their own scope but share a global object. | Modules are executed
    in **strict mode** by default and have their own scope, with a more isolated environment.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 5.2 – Key differences between CJS and ESM modules
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability with CJS modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the crucial aspects of adopting ESM modules in Node.js projects is understanding
    how they can interoperate with the traditional CJS module system. Given the vast
    ecosystem of existing Node.js packages and applications that use CJS, it is essential
    to grasp how to work with both module systems in a single project. This section
    explores the mechanisms and practices for achieving interoperability between ESM
    and CJS modules, ensuring a smooth transition and integration process.
  prefs: []
  type: TYPE_NORMAL
- en: 'ESM can import CJS modules using the **import** statement, thanks to Node.js’s
    built-in interoperability support. However, because CJS modules are not statically
    analyzable in the same way as ESM, there are some nuances to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default imports** : When importing a CJS module in an ESM file, the entire
    module’s exports are treated as a single default export. This means you cannot
    use named imports directly from a CJS module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Dynamic imports** : You can dynamically import CJS modules using the **import()**
    function. This approach returns a **Promise** that resolves with the CJS module’s
    exports, allowing for asynchronous module loading:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Exporting ESM modules for use in CJS** : When it comes to using ESM modules
    in CJS code, the process is somewhat more constrained due to the synchronous nature
    of CJS’s **require()** function, which does not support ESM’s asynchronous module
    loading. However, there are workarounds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One common approach is to create a CJS wrapper module that dynamically imports
    the ESM module and then exports its functionalities. This requires using asynchronous
    patterns such as **async** , **await** , or promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Projects that offer both ESM and CJS entry points need to be aware of the dual
    package hazard, where a single package loaded in both formats might lead to state
    issues or duplicated instances.
  prefs: []
  type: TYPE_NORMAL
- en: When producing a module, it is recommended that you document if your package
    or application supports both ESM and CJS, with guidance on how consumers can import
    it into their projects. Should you dual publish, it is also recommended that you
    thoroughly test your module in both ESM and CJS environments to catch any interoperability
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js now offers Experimental support for loading ES modules using **require()**
    with the **--experimental-require-module** flag. This feature enables CommonJS
    modules to load ES modules under specific conditions, such as when the file has
    a **.mjs** extension or when **"type": "module"** is set in the nearest package.json.
    However, if the module or its dependencies contain top-level await, the **ERR_REQUIRE_ASYNC_MODULE**
    error will be thrown, requiring **import()** for asynchronous modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality is designed to improve interoperability between CommonJS
    and ES modules, but as an experimental feature, it may change in future Node.js
    versions. For more information, visit: [https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require](https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics in ECMAScript Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Advancing your understanding of ESM within Node.js involves exploring more
    complex features and strategies that can optimize and enhance the functionality
    of your applications. There are some further advanced topics you can explore for
    benefits and considerations for developers working with ESM:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic import expressions** : Dynamic imports allow you to load modules
    on an as-needed basis, using the **import()** function that returns a **Promise**
    . This feature is particularly useful for reducing initial load times and optimizing
    resource utilization in applications by splitting the code into smaller chunks
    that are loaded only when required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module caching and preloading** : Node.js caches imported modules to avoid
    reloading them each time they are required in the application, enhancing performance.
    Preloading modules involves loading modules before they are needed, potentially
    speeding up application startup by reducing delays associated with loading modules
    at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tree shaking** : Tree shaking is a term commonly associated with static code
    analysis tools and bundlers (such as **Webpack** ). It refers to the elimination
    of unused code from a final bundle. For tree shaking to be effective, modules
    must use static **import** and **export** statements, as this allows the bundler
    to determine which exports are used and which can be safely removed, leading to
    smaller and more efficient bundles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module resolution customization** : It is also possible to customize module
    resolution by configuring how import specifiers are resolved to actual module
    files. Node.js provides an experimental feature named **customization hooks**
    , which allows you to customize module resolution and loading by registering a
    file that exports hooks. For more information, refer to the Node.js API documentation
    for the feature: [https://nodejs.org/api/module.html#customization-hooks](https://nodejs.org/api/module.html#customization-hooks)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Scaffolding a module* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing module code* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19212_08.xhtml#_idTextAnchor243)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
