- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Developing Node.js Modules
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 Node.js 模块
- en: One of the main attractions of Node.js is the massive ecosystem of external
    third-party libraries. **Node.js modules** are libraries or a set of functions
    you want to include in your application. Most modules will provide an API to expose
    functionality. The **npm** registry is where most Node.js modules are stored,
    where there are over a million Node.js modules available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的一个主要吸引力是庞大的外部第三方库生态系统。**Node.js 模块**是您想要包含在应用程序中的库或一系列函数。大多数模块将提供一个
    API 来暴露功能。**npm** 注册处是大多数 Node.js 模块存储的地方，那里有超过一百万个可用的 Node.js 模块。
- en: This chapter will first cover how to consume existing Node.js modules from the
    **npm** registry for use within your applications using the **npm** **command-line**
    **interface** ( **CLI** ).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先介绍如何使用 **npm** **命令行** **界面** ( **CLI** ) 从 **npm** 注册处消费现有的 Node.js 模块，以便在您的应用程序中使用。
- en: Later in this chapter, you’ll learn how to develop and publish your own Node.js
    module to the **npm** registry. There will also be an introduction to using the
    **ECMAScript Modules** ( **ESM** ) syntax, which is available in all currently
    supported versions of Node.js. The recipes in this chapter build upon each other,
    so it’s recommended you work through them in order.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，您将学习如何开发和发布您自己的 Node.js 模块到 **npm** 注册处。还将介绍如何使用 **ECMAScript Modules**
    ( **ESM** ) 语法，该语法在所有当前支持的 Node.js 版本中可用。本章中的菜谱是相互关联的，因此建议您按顺序完成它们。
- en: 'This chapter will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下菜谱：
- en: Consuming Node.js modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费 Node.js 模块
- en: Scaffolding a module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭建模块
- en: Writing module code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写模块代码
- en: Publishing a module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布模块
- en: Using ESM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ESM
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will require you to have Node.js, preferably the most recent Node.js
    22 release, installed. You should also have the **npm** CLI installed, which comes
    bundled with Node.js. Both **node** and **npm** should be in your path in your
    shell ( or terminal).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '本章将要求您安装 Node.js，最好是最新版本的 Node.js 22，并且您应该已经安装了与 Node.js 捆绑的 **npm** CLI。**node**
    和 **npm** 应该在您的 shell（或终端）路径中。 '
- en: Important note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is recommended to install Node.js with **Node Version Manager** ( **nvm**
    ). It is a tool that enables you to easily switch Node.js versions on most Unix-like
    platforms. If you’re using Windows, you can install Node.js from [https://nodejs.org/en/](https://nodejs.org/en/)
    .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用 **Node Version Manager** ( **nvm** ) 安装 Node.js。这是一个工具，它使您能够在大多数类 Unix
    平台上轻松切换 Node.js 版本。如果您使用的是 Windows，您可以从 [https://nodejs.org/en/](https://nodejs.org/en/)
    安装 Node.js。
- en: 'You can confirm which versions of Node.js and **npm** are installed by typing
    the following command into your terminal:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端中输入以下命令来确认已安装的 Node.js 和 **npm** 版本：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The **npm** CLI is the default package manager bundled with Node.js, and we’ll
    be using the bundled **npm** CLI in this chapter to install and publish modules.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm** CLI 是 Node.js 默认的包管理器，并且我们将在本章中使用捆绑的 **npm** CLI 来安装和发布模块。'
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **npm** CLI is bundled with Node.js as the default package manager. npm,
    Inc. is also the name of the company that owns the **npm** registry ( [https://npmjs.org/](https://npmjs.org/)
    ).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm** CLI 作为默认的包管理器捆绑在 Node.js 中。npm, Inc. 也是拥有 **npm** 注册处的公司的名称（[https://npmjs.org/](https://npmjs.org/)）。'
- en: Note that as we will be downloading and publishing modules to the **npm** registry,
    this chapter will require internet access.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们将从 **npm** 注册处下载和发布模块，因此本章将需要互联网访问。
- en: Consuming Node.js modules
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费 Node.js 模块
- en: In this recipe, we are going to learn how to consume **npm** modules from the
    public **npm** registry using the **npm** CLI.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 **npm** CLI 从公共 **npm** 注册处消费 **npm** 模块。
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**Yarn** is a popular alternative package manager for JavaScript and was created
    as an alternative to the **npm** CLI in 2016. When Yarn was released, **npm**
    did not have the **package-lock.json** feature to guarantee consistency of which
    specific versions of modules would be installed. This was one of the key features
    of Yarn. At the time of writing, the Yarn CLI offers a similar user experience
    to what the **npm** CLI provides. Yarn maintains a registry that is a reverse
    proxy to the **npm** registry. For more information about Yarn, check out their
    *Get Started* guide: [https://yarnpkg.com/getting-started](https://yarnpkg.com/getting-started)
    .'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Yarn** 是一个流行的 JavaScript 包管理器，于 2016 年创建，作为对 **npm** CLI 的替代。当 Yarn 发布时，**npm**
    没有提供 **package-lock.json** 功能来保证安装特定模块版本的稳定性。这是 Yarn 的一个关键特性。在撰写本文时，Yarn CLI 提供了与
    **npm** CLI 相似的使用体验。Yarn 维护了一个注册表，它是 **npm** 注册表的反向代理。有关 Yarn 的更多信息，请查看他们的 *入门*
    指南：[https://yarnpkg.com/getting-started](https://yarnpkg.com/getting-started)
    。'
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started, we first need to create a new directory to work in:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们首先需要创建一个新的工作目录：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will also need a file where we can attempt to execute the imported module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个文件，我们可以尝试在其中执行导入的模块：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this section, we’re going to set up a project and install the **express**
    module, a commonly used web framework for Node.js and often one of the first modules
    newcomers to the runtime learn.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置一个项目并安装 **express** 模块，这是一个常用的 Node.js 网络框架，也是新用户学习运行时经常学习的第一个模块之一。
- en: 'First, we’ll need to initialize a new project. Do this by typing the following:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要初始化一个新的项目。通过输入以下内容来完成此操作：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will need to step through the utility to answer the questions in the command-line
    utility. If you are unsure, you can just hit *Enter* to accept the defaults.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要逐步通过实用程序来回答命令行实用程序中的问题。如果您不确定，可以简单地按 *Enter* 键接受默认值。
- en: 'The **npm init** command should have generated a **package.json** file in your
    project directory. It should look like this:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**npm init** 命令应该在您的项目目录中生成了一个 **package.json** 文件。它应该看起来像这样：'
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can install our module. To install the **express** module, type the
    following command while in your project directory:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以安装我们的模块。要在项目目录中安装 **express** 模块，请输入以下命令：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we look at the **package.json** file again, we should see that the module
    has been added to a **dependencies** field:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次查看 **package.json** 文件，我们应该会看到模块已经被添加到了 **dependencies** 字段中：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Also, observe that both a **node_modules** directory and a **package-lock.json**
    file have now been created in your project directory.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，请注意，现在在您的项目目录中已经创建了一个 **node_modules** 目录和一个 **package-lock.json** 文件。
- en: 'Now, we can open our **require-express.js** file. We only need to add the following
    line to test whether we can import and use the module:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以打开我们的 **require-express.js** 文件。我们只需要添加以下行来测试我们是否可以导入并使用该模块：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is expected that the program executes and immediately terminates after requiring
    the **express** module. Should the module not have been installed successfully,
    we would have seen an error like the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期程序在引入 **express** 模块后立即执行并终止。如果模块没有成功安装，我们会看到以下错误：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve now successfully downloaded a third-party module from the **npm** registry
    and imported it into our application so that it can be used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功从 **npm** 注册表中下载了一个第三方模块并将其导入到我们的应用程序中，以便可以使用它。
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The recipe made use of both **npm** , the CLI bundled with Node.js, and the
    **npm** public registry to download the **express** third-party module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本使用了 **npm**（Node.js 中的 CLI 打包工具）和 **npm** 公共注册表来下载 **express** 第三方模块。
- en: 'The first command of the recipe was **npm init** . This command initializes
    a new project in the current working directory. By default, running this command
    will open a CLI utility that will ask for some properties about your project.
    The following table defines the requested properties:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一步是 **npm init** 命令。此命令在当前工作目录中初始化一个新的项目。默认情况下，运行此命令将打开一个 CLI 工具，它会询问一些关于您项目的信息。以下表格定义了请求的属性：
- en: '| **Property** | **Definition** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **定义** |'
- en: '| Package name | Specifies the name of the project. It must be unique when
    publishing to the **npm** registry. A name can be prefixed by a scope; for example,
    **@organization/package** . |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 指定项目的名称。在发布到 **npm** 注册表时，名称必须是唯一的。名称可以由一个作用域前缀；例如，**@organization/package**
    。|'
- en: '| Version | The initial version of the project. It is typical of Node.js modules
    to follow the Semantic Versioning standard. The default value is **1.0.0** . |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 项目的初始版本。Node.js模块通常遵循语义化版本控制标准。默认值是**1.0.0**。'
- en: '| Description | A brief description of your project to help users understand
    what your project does and its purpose. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | 对你的项目的简要描述，以帮助用户了解你的项目做什么以及其目的。 |'
- en: '| Entry point | The entry point file of your Node.js application or module.
    It’s the path to the main file that will be executed when your module is required
    by another application. The default value is **index.js** . |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 入口点 | 你的Node.js应用程序或模块的入口点文件。它是当你的模块被另一个应用程序要求时将被执行的主文件的路径。默认值是**index.js**。'
- en: '| Test command | Used to define the command to be run when executing **npm
    test** or **npm run test** . Typically, this will be the command that executes
    your test suite. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 测试命令 | 用于定义在执行**npm test**或**npm run test**时运行的命令。通常，这将是你执行测试套件的命令。 |'
- en: '| Git repository | Specifies the location of your project’s source code repository.
    This is helpful for contributors and users who want to access the code, report
    issues, or contribute. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Git仓库 | 指定你的项目源代码仓库的位置。这对于想要访问代码、报告问题或贡献的开发者和用户很有帮助。 |'
- en: '| Keywords | Keywords relating to your project. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 关键词 | 与你的项目相关的关键词。 |'
- en: '| Author | A list of the author(s) of the project. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 作者 | 项目作者列表。 |'
- en: '| License | Indicates the license type under which the project is distributed.
    This is important for users to understand how they are permitted to use and share
    your project. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 许可证 | 指示项目分发的许可类型。这对于用户了解他们如何使用和分享你的项目很重要。'
- en: Table 5.1 – Table detailing default properties of the package.json file
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – 表格详细说明了package.json文件的默认属性
- en: 'The only properties that are mandatory are the package name and version. It
    is also possible to skip the CLI utility and accept all defaults by typing the
    following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 必须的属性只有包名和版本。也可以跳过CLI实用程序，通过输入以下内容接受所有默认值：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is possible to configure default answers using the **npm config** command.
    This can be achieved with the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**npm config**命令配置默认答案。这可以通过以下命令实现：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the **npm init** command completes, it will generate a **package.json**
    file in your current working directory. The **package.json** file does the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦**npm init**命令完成，它将在你的当前工作目录中生成一个**package.json**文件。该**package.json**文件执行以下操作：
- en: It lists the packages that your project depends on, acting as a *blueprint*
    or set of instructions as to which dependencies need to be installed
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它列出了你的项目所依赖的包，作为一个*蓝图*或一系列指令，说明需要安装哪些依赖项
- en: Provides a mechanism for you to specify the versions of a package that your
    project can use – based on the Semantic Versioning specification ( [https://semver.org/](https://semver.org/)
    )
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一种机制，让你可以指定你的项目可以使用的包的版本——基于语义化版本控制规范（[https://semver.org/](https://semver.org/)）。
- en: In the next step of the recipe, we used the **npm install express** command
    to install the **express** module. The command reaches out to the **npm** registry
    to download the latest version of the module with the **express** name identifier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步骤中，我们使用了**npm install express**命令来安装**express**模块。该命令会连接到**npm**注册表，下载具有**express**名称标识符的模块的最新版本。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'By default, when supplying a module name, the **npm install** command will
    look for a module with that name and download it from the public **npm** registry.
    But it is also possible to pass the **npm install** command other parameters,
    such as a GitHub URL, and the command will install the content available at the
    URL. For more information, refer to the **npm** CLI documentation: [https://docs.npmjs.com/cli/v10/commands/npm-install](https://docs.npmjs.com/cli/v10/commands/npm-install)
    .'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当提供模块名称时，**npm install**命令会查找具有该名称的模块，并从公共**npm**注册表下载它。但也可以传递其他参数给**npm
    install**命令，例如GitHub URL，然后命令会安装该URL上可用的内容。有关更多信息，请参阅**npm** CLI文档：[https://docs.npmjs.com/cli/v10/commands/npm-install](https://docs.npmjs.com/cli/v10/commands/npm-install)。
- en: When the **install** command completes, it will put the module contents into
    a **node_modules** directory. If there isn’t one in the current project, but there
    is **package.json** , the command will also create a **node_modules** directory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当**安装**命令完成后，它将模块内容放入一个**node_modules**目录中。如果当前项目中没有，但有**package.json**，该命令也会创建一个**node_modules**目录。
- en: If you look at the contents of the **node_modules** directory, you will notice
    that more than just the **express** module is present. This is because **express**
    has dependencies, and their dependencies may also have dependencies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 **node_modules** 目录的内容，您会注意到除了 **express** 模块之外还有其他内容。这是因为 **express**
    有依赖项，它们的依赖项也可能有依赖项。
- en: 'When installing a module, you’re potentially, and often, installing a whole
    tree of modules. The following output shows a snippet of the structure of a **node_modules**
    directory from the recipe:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装一个模块时，您实际上和经常是在安装一个整个模块树。以下输出显示了配方中 **node_modules** 目录结构的一个片段：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can also use the **npm list** command to list the contents of your **node_modules**
    directory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 **npm list** 命令来列出您的 **node_modules** 目录的内容。
- en: You may also notice that a **package-lock.json** file has been created. Files
    of the **package-lock.json** type were introduced in **npm** version 5. The difference
    between **package-lock.json** and **package.json** is that a **package-lock.json**
    file defines specific versions of all modules in the **node_modules** tree.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可能注意到已创建了一个 **package-lock.json** 文件。**package-lock.json** 类型的文件是在 **npm**
    版本 5 中引入的。**package-lock.json** 与 **package.json** 的区别在于 **package-lock.json**
    文件定义了 **node_modules** 树中所有模块的特定版本。
- en: Due to the way dependencies are installed, two developers with the same **package.json**
    file may experience different results when running **npm install** . This is mainly
    because a **package.json** file can specify acceptable module ranges.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖项的安装方式，两个具有相同 **package.json** 文件的开发者运行 **npm install** 时可能会遇到不同的结果。这主要是因为
    **package.json** 文件可以指定可接受的模块范围。
- en: 'For example, in our recipe, we installed the latest version of **express**
    , and this resulted in the following range:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的配方中，我们安装了 **express** 的最新版本，这导致了以下范围：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The **^** character indicates that it will allow all versions above v4.18.2
    to be installed, but not v5.x.x. If v4.18.3 were to be released in the time between
    when developer A and developer B run the **npm install** command, then it is likely
    that developer A will get v4.18.2 and developer B will get v4.18.3.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**^** 字符表示它将允许安装所有高于 v4.18.2 的版本，但不能安装 v5.x.x。如果开发者在运行 **npm install** 命令之间发布了
    v4.18.3，那么开发者 A 很可能得到 v4.18.2，而开发者 B 将得到 v4.18.3。'
- en: If the **package-lock.json** file is shared between the developers, they will
    be guaranteed the installation of the same version of **express** and the same
    versions of all the dependencies of **express** .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者在之间共享 **package-lock.json** 文件，他们将确保安装相同版本的 **express** 以及 **express**
    所有依赖项的相同版本。
- en: The **npm** CLI can also generate a **npm-shrinkwrap.json** file using the **npm
    shrinkwrap** command. The **npm-shrinkwrap.json** file is identical in structure
    and serves a similar purpose to the **package-lock.json** file. The **package-lock.json**
    file cannot be published to the registry, whereas the **npm-shrinkwrap.json**
    can. Typically, when publishing an **npm** module, you’ll want to not include
    the **npm-shrinkwrap.json** file as it would prevent the module from receiving
    transitive dependency updates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm** CLI 还可以使用 **npm shrinkwrap** 命令生成 **npm-shrinkwrap.json** 文件。**npm-shrinkwrap.json**
    文件的结构与 **package-lock.json** 文件相同，并且具有类似的作用。**package-lock.json** 文件不能发布到注册表，而
    **npm-shrinkwrap.json** 可以。通常，当发布 **npm** 模块时，您可能不想包含 **npm-shrinkwrap.json**
    文件，因为它会阻止模块接收传递依赖项更新。'
- en: The presence of **npm-shrinkwrap.json** in a package means that all installs
    of that package will generate the same dependencies. The **npm-shrinkwrap.json**
    file is useful for ensuring consistency across installations in production environments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包中存在 **npm-shrinkwrap.json** 文件，这意味着该包的所有安装都将生成相同的依赖项。**npm-shrinkwrap.json**
    文件对于确保生产环境中的安装一致性非常有用。
- en: 'In the final step of the recipe, we imported the **express** module to test
    whether it was installed and accessible:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方的最后一步，我们导入了 **express** 模块来测试它是否已安装并可访问：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that this is the same way in which you import Node.js core modules. The
    module-loading algorithm will first check to see whether you’re requiring a core
    Node.js module; it will then look in the **node_modules** folder to find the module
    with that name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与您导入 Node.js 核心模块的方式相同。模块加载算法将首先检查您是否正在请求一个核心 Node.js 模块；然后它将在 **node_modules**
    文件夹中查找具有该名称的模块。
- en: 'It is also possible to use **require()** to import files by passing a path,
    such as the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 **require()** 通过传递路径来导入文件，如下所示：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There’s more…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now that we’ve learned a bit about consuming Node.js modules, we’re going to
    look at development dependencies, global modules, and the considerations you should
    make when consuming Node.js modules.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些关于消费 Node.js 模块的知识，我们将探讨开发依赖、全局模块以及消费 Node.js 模块时应考虑的因素。
- en: Understanding development dependencies
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解开发依赖
- en: In **package.json** , you can distinguish between development dependencies and
    regular dependencies. **Development dependencies** are typically used for tooling
    that supports you in developing your application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **package.json** 中，你可以区分开发依赖和常规依赖。**开发依赖**通常用于支持你开发应用程序的工具。
- en: Development dependencies should not be required to run your application. Having
    a distinction between dependencies that are required for your application to run
    and dependencies that are required to develop your application is particularly
    useful when it comes to deploying your application. Your production application
    deployment can omit development dependencies, which makes the resulting production
    application smaller. A very common use of development dependencies is for linting
    and formatting.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 开发依赖不应该被要求运行你的应用程序。在区分运行应用程序所需的依赖和开发应用程序所需的依赖时，这一点尤其有用，尤其是在部署应用程序时。你的生产应用程序部署可以省略开发依赖，这使得生成的生产应用程序更小。开发依赖的一个非常常见的用途是用于代码检查和格式化。
- en: 'To install a development dependency, you need to supply the **install** command
    with the **--save-dev** parameter. For example, to install **semistandard** ,
    we can use the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装开发依赖，你需要向 **install** 命令提供 **--save-dev** 参数。例如，要安装 **semistandard**，我们可以使用以下命令：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The **--save-exact** parameter pins the exact version in your **package.json**
    file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**--save-exact** 参数将锁定 **package.json** 文件中的确切版本。'
- en: 'Observe that there is a separate section for development dependencies that
    have been created in **package.json** :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 **package.json** 中为开发依赖创建了一个单独的部分：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can then execute the installed **semistandard** executable with the following
    command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令执行已安装的 **semistandard** 可执行文件：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Installing global modules
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装全局模块
- en: 'It is possible to globally install Node.js modules. Typically, the type of
    modules you’ll install globally are binaries or a program that you want to be
    accessible in your terminal. To globally install a module, you pass the **--global**
    command to the **install** command as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能全局安装 Node.js 模块。通常，你将全局安装的模块类型是二进制文件或你希望在终端中可访问的程序。要全局安装一个模块，你需要在 **install**
    命令中传递 **--global** 命令，如下所示：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will not install **lolcatjs** into your **node_modules** folder. Instead,
    it will be installed into the **bin** directory of your Node.js installation.
    To see where it was installed, you can use the **which** command (or **where**
    on Windows):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会将 **lolcatjs** 安装到你的 **node_modules** 文件夹中。相反，它将被安装到你的 Node.js 安装目录下的 **bin**
    文件夹中。要查看安装位置，你可以使用 **which** 命令（或在 Windows 上使用 **where**）：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The **bin** directory is likely to already be in your path because that is
    where the **node** and **npm** binaries are stored. Therefore, any executable
    program that is globally installed will also be made available in your shell.
    Now, you should be able to call the **lolcatjs** module from your shell:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**bin** 目录很可能已经包含在你的路径中，因为那里存储了 **node** 和 **npm** 的二进制文件。因此，任何全局安装的可执行程序也将可在你的
    shell 中使用。现在，你应该能够从你的 shell 中调用 **lolcatjs** 模块：'
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In **npm** v5.2, **npm** added the **npx** command to their CLI. This command
    allows you to execute a global module without having it globally installed on
    your system. You could execute the **lolcatjs** module without storing it with
    the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **npm** v5.2 中，**npm** 向他们的 CLI 添加了 **npx** 命令。这个命令允许你执行全局模块，而无需在系统中全局安装它。你可以使用以下命令执行
    **lolcatjs** 模块，而无需将其存储：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In general, **npx** should be sufficient for most modules that you wish to execute.
    Using **npx** can be preferable as it enables you to run packages without polluting
    your global namespace. It can also help when you need to execute different versions
    of a package on a per-project basis as it avoids any global version conflicts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**npx** 应该足够用于大多数你希望执行的模块。使用 **npx** 可能更可取，因为它允许你运行包而不污染全局命名空间。它还可以在基于项目的每个包上执行不同版本时有所帮助，因为它避免了任何全局版本冲突。
- en: Responsibly consuming modules
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负责任地消费模块
- en: You’ll likely want to leverage the Node.js module ecosystem in your applications.
    Modules provide solutions and implementations of common problems and tasks, so
    reusing existing code can save you time when developing your applications.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会希望利用Node.js模块生态系统来构建您的应用程序。模块提供了常见问题和任务的解决方案和实现，因此重用现有代码可以在开发应用程序时节省您的时间。
- en: As you saw in the recipe, simply pulling in the web framework, **express** pulled
    in over 80 other modules. Pulling in this number of modules adds risk, especially
    if you’re using these modules for production workloads.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在菜谱中看到的，简单地引入网络框架**express**就引入了超过80个其他模块。引入这么多模块会增加风险，尤其是如果您正在使用这些模块进行生产工作负载。
- en: 'There are many considerations you should make when choosing a Node.js module
    to include in your application. The following three considerations should be made
    in particular:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择将Node.js模块包含到您的应用程序中时，您应该考虑许多因素。以下三个因素尤其需要注意：
- en: '**Security** : Can you depend on the module to fix security vulnerabilities?
    [*Chapter 9*](B19212_09.xhtml#_idTextAnchor274) will go into more detail about
    how to check for known security issues in your modules.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：您能否依赖该模块来修复安全漏洞？[第9章](B19212_09.xhtml#_idTextAnchor274)将更详细地介绍如何检查您模块中的已知安全问题。'
- en: '**Licenses** : If you link with open source libraries and then distribute the
    software, your software needs to be compliant with the licenses of the linked
    libraries. Licenses can vary from restrictive/protective to permissive. In GitHub,
    you can navigate to the license file, and it will give you a basic overview of
    what the license permits:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可**：如果您与开源库链接然后分发软件，您的软件需要遵守链接库的许可。许可可能从限制性/保护性到宽容性不等。在GitHub上，您可以导航到许可文件，它将为您提供关于许可允许内容的简要概述：'
- en: '![Figure 5.1 – GitHub license information](img/B19212_05_01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – GitHub许可信息](img/B19212_05_01.jpg)'
- en: Figure 5.1 – GitHub license information
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – GitHub许可信息
- en: '**Maintenance** : You’ll also need to consider how well maintained the module
    is. Many modules publish their source code to GitHub and have their bug reports
    viewable as GitHub issues. From viewing their issues and how/when the maintainers
    are responding to bug reports, you should be able to get some insight into how
    maintained the module is.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护**：您还需要考虑该模块的维护情况。许多模块将源代码发布到GitHub，并将错误报告作为GitHub问题公开。通过查看这些问题以及维护者如何/何时响应错误报告，您应该能够了解该模块的维护情况。'
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Scaffolding a module* recipe in this chapter
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*构建模块框架*菜谱
- en: The *Writing module code* recipe in this chapter
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*编写模块代码*菜谱
- en: The *Publishing a module* recipe in this chapter
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*发布模块*菜谱
- en: '*Chapters 6* and *9*'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第6章*和*第9章*'
- en: Scaffolding a module
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模块框架
- en: In this recipe, we’ll be scaffolding our first module; that is, we will set
    up a typical file and directory structure for our module and learn how to initialize
    our project with the **npm** CLI. We’ll also create a GitHub repository to store
    our module code. GitHub is a hosting provider that allows users to store their
    **Git** -based repositories, where Git is a **version control** **system** ( **VCS**
    ).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建我们的第一个模块；也就是说，我们将为我们的模块设置一个典型的文件和目录结构，并学习如何使用**npm** CLI初始化我们的项目。我们还将创建一个GitHub仓库来存储我们的模块代码。GitHub是一个托管提供商，允许用户存储基于**Git**的仓库，其中Git是一个**版本控制系统**（**VCS**）。
- en: The module we’re going to make will expose an API that converts the temperature
    in Fahrenheit to Celsius and vice versa.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要制作的模块将提供一个API，该API可以将华氏温度转换为摄氏温度，反之亦然。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will require you to have a GitHub account ( [https://github.com/join](https://github.com/join)
    ) to publish source code and an **npm** account ( [https://www.npmjs.com/signup](https://www.npmjs.com/signup)
    ) to publish your module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将要求您拥有GitHub账户（[https://github.com/join](https://github.com/join)）以发布源代码，以及**npm**账户（[https://www.npmjs.com/signup](https://www.npmjs.com/signup)）以发布您的模块。
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this recipe, we’ll be using the **npm** CLI to initialize our **temperature-converter**
    module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用**npm** CLI来初始化我们的**temperature-converter**模块。
- en: Let’s create a GitHub repository to store our module code. To do this, you can
    click **+** | **New repository** from the GitHub navigation bar or navigate to
    [https://github.com/new](https://github.com/new) . Specify the repository name
    as **temperature-converter** . Note that the repository name does not have to
    match the module name.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 GitHub 仓库来存储我们的模块代码。为此，您可以从 GitHub 导航栏点击 **+** | **New repository**，或者导航到
    [https://github.com/new](https://github.com/new) 。指定仓库名称为 **temperature-converter**
    。请注意，仓库名称不必与模块名称匹配。
- en: 'While you’re here, it’s also recommended to add the default **.gitignore**
    file for Node.js and add the license file that matches the license field in **package.json**
    . You should expect to see the following GitHub **user interface** ( **UI** )
    for creating a new repository:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在这里时，还建议添加 Node.js 的默认 **.gitignore** 文件和与 **package.json** 中的许可字段匹配的许可文件。您应该会看到以下
    GitHub **用户界面** ( **UI** ) 用于创建新仓库：
- en: '![Figure 5.2 – The GitHub Create a new repository interface](img/B19212_05_02.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – GitHub 创建新仓库界面](img/B19212_05_02.jpg)'
- en: Figure 5.2 – The GitHub Create a new repository interface
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – GitHub 创建新仓库界面
- en: Important note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A **.gitignore** file informs Git which files to omit, or ignore, in a project.
    GitHub provides a default **.gitignore** file per language or runtime. GitHub’s
    default **.gitignore** file for Node.js is visible at [https://github.com/github/gitignore/blob/master/Node.gitignore](https://github.com/github/gitignore/blob/master/Node.gitignore)
    . Note that **node_modules** is automatically added to **.gitignore** . The **package.json**
    file instructs which modules need to be installed for a project, and it is typically
    expected that each developer would run the **npm install** command on their development
    environment rather than have the **node_modules** directory committed to source
    control.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **.gitignore** 文件会通知 Git 在项目中忽略哪些文件。GitHub 为每种语言或运行时提供默认的 **.gitignore**
    文件。GitHub 为 Node.js 提供的默认 **.gitignore** 文件可在[https://github.com/github/gitignore/blob/master/Node.gitignore](https://github.com/github/gitignore/blob/master/Node.gitignore)
    上查看。请注意，**node_modules** 会自动添加到 **.gitignore** 中。**package.json** 文件指示需要为项目安装哪些模块，并且通常期望每个开发者都会在自己的开发环境中运行
    **npm install** 命令，而不是将 **node_modules** 目录提交到源代码控制。
- en: 'Now the repository is initialized, we can clone the repository using the Git
    CLI in our shell. Enter the following command to clone the repository, substituting
    the reference to the repository with your GitHub username:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在仓库已初始化，我们可以使用 shell 中的 Git CLI 来克隆仓库。输入以下命令来克隆仓库，用您的 GitHub 用户名替换对仓库的引用：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Important note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It’s preferred to use **Secure Shell** ( **SSH** ) to clone the repository.
    If you have not set up your SSH keys for GitHub, then you should follow the steps
    at [https://docs.github.com/en/authentication/connecting-to-github-with-ssh](https://docs.github.com/en/authentication/connecting-to-github-with-ssh)
    .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用 **Secure Shell** ( **SSH** ) 来克隆仓库。如果您尚未为 GitHub 设置 SSH 密钥，那么您应该遵循[https://docs.github.com/en/authentication/connecting-to-github-with-ssh](https://docs.github.com/en/authentication/connecting-to-github-with-ssh)
    中的步骤。
- en: 'Change into the newly cloned directory and observe the files present:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到新克隆的目录并观察现有文件：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also run the **git status** and **git log** commands to see what state
    we’re in:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以运行 **git status** 和 **git log** 命令来查看我们的状态：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we’ve created our repository and have a copy locally to work from, we can
    initialize our module:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的仓库，并在本地有一个副本来工作，我们可以初始化我们的模块：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can use *Enter* to accept defaults or complete the values as follows. The
    command will create a **package.json** file for you. Open the file and expect
    to see output like the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 *Enter* 接受默认值或按以下方式完成值。该命令将为您创建一个 **package.json** 文件。打开文件，您应该会看到以下输出：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open the **README.md** file and add, and then save, some simple text. For example,
    you can add a simple heading in **Markdown** format: **#** **temperature-converter**
    .'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **README.md** 文件并添加一些简单的文本，然后保存。例如，您可以在 **Markdown** 格式中添加一个简单的标题：**#** **temperature-converter**
    。
- en: 'Now, we’re going to commit these changes with the following commands:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下命令提交这些更改：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When this is successful, you should see output like the following:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当这成功时，您应该会看到以下输出：
- en: '[PRE28]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’ve now seen how to use the Git and **npm** CLI to initialize our **temperature-converter**
    module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 Git 和 **npm** CLI 初始化我们的 **temperature-converter** 模块。
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: To kick off our project, we begin by setting up a GitHub repository, which serves
    as a central hub for storing and managing our code base. This involves creating
    a new repository on GitHub, where we’ll store our module code under a specified
    name – in this case, **temperature-converter** . Additionally, we take the opportunity
    to include a **.gitignore** file, which informs Git of files to exclude from version
    control and add a license file, defining how others can use our code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动我们的项目，我们首先设置一个GitHub仓库，它作为存储和管理我们的代码库的中心枢纽。这涉及到在GitHub上创建一个新的仓库，我们将在此存储我们的模块代码，指定名称为**temperature-converter**。此外，我们抓住机会包括一个**.gitignore**文件，该文件通知Git排除哪些文件不进行版本控制，并添加一个许可文件，定义他人如何使用我们的代码。
- en: Once our repository is established, we clone it locally using the Git CLI. Cloning
    creates a copy of the repository on our local machine, allowing us to work on
    the code base offline and push changes back to the remote repository when ready.
    We navigate into the cloned directory to inspect its contents and review the repository’s
    status and history using **git status** and **git log** .
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的仓库建立起来，我们使用Git CLI在本地克隆它。克隆会在我们的本地机器上创建仓库的副本，使我们能够离线工作在代码库上，并在准备好时将更改推送到远程仓库。我们进入克隆的目录以检查其内容，并使用**git
    status**和**git log**来审查仓库的状态和历史。
- en: With our local setup ready, we initialize our module using **npm** . The **npm
    init** command guides us through creating a **package.json** file, which contains
    essential metadata about our project, such as its name, version, and dependencies.
    This file serves as a blueprint for our module and ensures consistency across
    different environments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的本地设置准备就绪后，我们使用**npm**初始化我们的模块。**npm init**命令引导我们创建一个**package.json**文件，该文件包含关于我们的项目的基本元数据，例如其名称、版本和依赖项。此文件作为我们模块的蓝图，并确保在不同环境中的一致性。
- en: To finalize our initial setup, we commit our changes to the repository. This
    involves staging the **package.json** and **README.md** files, committing them
    with a descriptive message, and pushing the changes to the remote repository on
    GitHub. This step ensures that our project’s history is well documented and that
    our latest changes are published.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的初始设置，我们将更改提交到仓库中。这涉及到暂存**package.json**和**README.md**文件，用描述性消息提交它们，并将更改推送到GitHub上的远程仓库。这一步确保了我们的项目历史记录得到良好的记录，并且我们的最新更改已发布。
- en: Important note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Git is a powerful tool that is commonly used for source control of software.
    If you’re unfamiliar with Git, GitHub provides an interactive guide for you to
    learn at [https://guides.github. com/introduction/flow/](https://guides.github.com/introduction/flow/)
    .
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Git是一个强大的工具，通常用于软件的源代码控制。如果你对Git不熟悉，GitHub提供了一个交互式指南，你可以通过[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)来学习。
- en: There’s more…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the recipe, we specified the module version as v0.1.0 to adhere to Semantic
    Versioning. Let’s look at this in more detail.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们指定了模块版本为v0.1.0，以遵循语义化版本控制。让我们更详细地看看这一点。
- en: '**Semantic Versioning** , often abbreviated to **SemVer** , is a well-known
    standard for versioning. Node.js itself tries to adhere to Semantic Versioning
    as much as possible.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义化版本控制**，通常缩写为**SemVer**，是一个广为人知的版本控制标准。Node.js本身尽可能地遵循语义化版本控制。'
- en: 'Semantic version numbers are in the form of **X.Y.Z** , where the following
    applies:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 语义化版本号的形式为**X.Y.Z**，以下适用：
- en: '**X** represents the major version'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X**代表主版本'
- en: '**Y** represents the minor version'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y**代表次要版本'
- en: '**Z** represents the patch version'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z**代表补丁版本'
- en: Briefly, Semantic Versioning states that you increment the major version, the
    first value, when you make breaking API changes. The second number, the minor
    version, is incremented when new features have been added in a backward-compatible
    (or non-breaking) manner. The patch version, or the third number, is for bug fixes
    and non-breaking and non-additive updates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，语义化版本控制指出，当你进行破坏性API更改时，增加主版本，即第一个值。第二个数字，即次要版本，是在向后兼容（或非破坏性）方式中添加新功能时增加的。补丁版本，即第三个数字，用于错误修复和非破坏性、非增量更新。
- en: The major version 0 is reserved for initial development, and it is acceptable
    to make breaking changes up until v1 is released. It is often disputed what the
    initial version should be. In the recipe, we started with version v0.1.0 to allow
    us the freedom to make breaking changes in early development without having to
    increment the major version number.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 主版本号0保留用于初始开发，并且直到v1发布之前进行破坏性更改是可以接受的。关于初始版本应该是什么版本，常常存在争议。在菜谱中，我们以v0.1.0版本开始，这样我们就可以在早期开发中进行破坏性更改，而无需增加主版本号。
- en: Following Semantic Versioning is commonplace in the Node.js module ecosystem.
    The **npm** CLI takes this into account by allowing **semver** ranges in **package.json**
    – refer to the *There’s more…* section of the *Consuming Node.js modules* recipe
    or visit [https://docs.npmjs.com/files/package.json#dependencies](https://docs.npmjs.com/files/package.json#dependencies)
    for more information on **npm** version ranges.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循语义版本控制是Node.js模块生态系统中的常见做法。**npm** CLI通过允许在**package.json**中使用**semver**范围来考虑这一点
    – 参考本章中**消费Node.js模块**菜谱的*更多内容…*部分或访问[https://docs.npmjs.com/files/package.json#dependencies](https://docs.npmjs.com/files/package.json#dependencies)以获取有关**npm**版本范围的更多信息。
- en: The **npm** CLI provides an API to support Semantic Versioning. The **npm version**
    command can be supplied with **major** , **minor** , or **patch** to increment
    the appropriate version numbers in your **package.json** file. There are further
    arguments that can be passed to the **npm** version command, including support
    for pre-versions – refer to [https://docs.npmjs.com/cli/version](https://docs.npmjs.com/cli/version)
    for more information.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm** CLI提供了一个API来支持语义版本控制。**npm version**命令可以与**major**、**minor**或**patch**一起使用，以在您的**package.json**文件中增加适当的版本号。还可以向**npm**版本命令传递其他参数，包括对预版本的支持
    – 参考文档[https://docs.npmjs.com/cli/version](https://docs.npmjs.com/cli/version)以获取更多信息。'
- en: See also
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Writing module code* recipe in this chapter
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的**编写模块代码**菜谱
- en: The *Publishing a module* recipe in this chapter
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的**发布模块**菜谱
- en: Writing module code
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模块代码
- en: In this recipe, we’re going to start writing our module code. The module we
    will write will expose two APIs that will be used to convert the supplied temperature
    from Fahrenheit to Celsius and vice versa. We’ll also install a popular code formatter
    to keep our module code consistent and add some simple test cases.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将开始编写我们的模块代码。我们将编写的模块将公开两个API，用于将提供的温度从华氏度转换为摄氏度，反之亦然。我们还将安装一个流行的代码格式化工具，以保持我们的模块代码一致性，并添加一些简单的测试用例。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you’re in the **temperature-converter** folder and that **package.json**
    is present, indicating that we have an initialized project directory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您位于**temperature-converter**文件夹中，并且存在**package.json**，表示我们有一个初始化的项目目录。
- en: 'We’ll also need to create the first JavaScript file for our module:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的模块创建第一个JavaScript文件：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Later, we’ll try testing importing and using the module, so let’s create two
    files ready for that:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将尝试测试导入和使用模块，因此让我们创建两个文件以备使用：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We’re going to start this recipe by installing a code formatter to keep our
    module code styling consistent. By the end of this recipe, we will have created
    our first Node.js module.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个菜谱开始安装一个代码格式化工具，以保持我们的模块代码风格一致。到这个菜谱结束时，我们将创建我们的第一个Node.js模块。
- en: 'First, let’s add **semistandard** as a code formatter for our module. When
    we know that other users are going to be consuming or contributing to our modules,
    it’s important to have consistently formatted code for consistency:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将**semistandard**添加为我们的模块的代码格式化工具。当知道其他用户将消费或贡献我们的模块时，保持代码格式的一致性非常重要：
- en: '[PRE31]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the initial implementation of this module, we will expose two APIs – one
    to be used to convert from Fahrenheit to Celsius which we will name **fahrenheitToCelsius()**
    , and another to be used for the opposite conversion named **celsiusToFahrenheit()**
    . We’ll be using the known mathematical formula for converting between the two
    temperature measures. Start by opening **index.js** and adding the following to
    define the **fahrenheitToCelsius()** function:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于此模块的初始实现，我们将公开两个API – 一个用于将华氏度转换为摄氏度，我们将命名为**fahrenheitToCelsius()**，另一个用于相反的转换，命名为**celsiusToFahrenheit()**。我们将使用已知的数学公式来转换这两种温度单位。首先打开**index.js**并添加以下内容以定义**fahrenheitToCelsius()**函数：
- en: '[PRE32]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can add the accompanying **celsiusToFahrenheit()** function to do the
    reverse conversion:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加相应的**celsiusToFahrenheit()**函数来进行反向转换：
- en: '[PRE33]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we’ll add the key line to the bottom of our file that makes the two functions
    available:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在文件的底部添加关键行，使两个函数可用：
- en: '[PRE34]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can test if our small program works from the command line with the
    following commands:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令从命令行测试我们的小程序是否工作：
- en: '[PRE35]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s create a simple test file for our module. We’ll use the core **assert**
    module to implement this:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的模块创建一个简单的测试文件。我们将使用核心的 **assert** 模块来实现这个：
- en: '[PRE36]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Observe that we are requiring the module and testing the two temperature conversion
    functions.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们正在导入模块并测试这两个温度转换函数。
- en: 'Now, we can run our test file:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的测试文件：
- en: '[PRE37]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let’s define **npm run lint** and **npm run test** scripts to run our
    linter and tests respectively. Open the **package.json** file and replace the
    **scripts** property with the following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义 **npm run lint** 和 **npm run test** 脚本来分别运行我们的代码检查器和测试。打开 **package.json**
    文件，并将 **scripts** 属性替换为以下内容：
- en: '[PRE38]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now run the linter with **npm** **run lint** :'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 **npm run lint** 运行我们的代码检查器：
- en: '[PRE39]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you had any lint issues, **semistandard** would alert you to these. They
    can be fixed by running the following:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果有任何代码检查问题，**semistandard** 会提醒你。这些问题可以通过运行以下命令来解决：
- en: '[PRE40]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also run our tests with the **npm** **test** command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用 **npm test** 命令运行我们的测试：
- en: '[PRE41]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we’ve implemented, linted, and tested our code, we can commit the updates
    with Git and push our module code to GitHub:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经实现了、进行了代码检查和测试，我们可以使用 Git 提交更新并将模块代码推送到 GitHub：
- en: '[PRE42]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ve now created our first module that exposes two APIs and added a test case
    for good measure.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个模块，它公开了两个 API，并添加了一个测试用例作为良好习惯。
- en: How it works…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To ensure consistency and readability in our module’s code base, we begin by
    incorporating a popular code formatter, **semistandard** , as part of our development
    workflow. This ensures that our code follows a standardized style, making it easier
    for other developers to understand and collaborate on our project.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的模块代码库的一致性和可读性，我们首先将流行的代码格式化工具 **semistandard** 纳入我们的开发工作流程。这确保了我们的代码遵循标准化的样式，使得其他开发者更容易理解和协作我们的项目。
- en: With **semistandard** installed as a development dependency, we proceed to implement
    the core functionality of our module. We define two conversion functions, **fahrenheitToCelsius()**
    and **celsiusToFahrenheit()** , leveraging well-known mathematical formulas for
    temperature conversion. These functions are encapsulated within our **index.js**
    file, making them accessible for use within our module.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已将 **semistandard** 作为开发依赖项安装，我们继续实现模块的核心功能。我们定义了两个转换函数，**fahrenheitToCelsius()**
    和 **celsiusToFahrenheit()**，利用已知的温度转换数学公式。这些函数封装在我们的 **index.js** 文件中，使得它们可以在模块内部使用。
- en: To expose these conversion functions externally, we add an **export** statement
    at the bottom of our file, allowing other modules to import and utilize them as
    needed. This establishes a clear interface for interacting with our module’s functionality.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将转换函数公开给外部使用，我们在文件的底部添加了一个 **export** 语句，允许其他模块根据需要导入和使用它们。这为与我们的模块功能交互提供了一个清晰的接口。
- en: To validate the correctness of our implementation, we create a simple test file,
    **test.js** , using Node.js’s built-in **assert** module. This file contains test
    cases for each conversion function, ensuring that they produce the expected results
    under various input conditions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证实现的正确性，我们创建了一个简单的测试文件 **test.js**，使用 Node.js 内置的 **assert** 模块。此文件包含每个转换函数的测试用例，确保它们在各种输入条件下产生预期的结果。
- en: Upon running the test file, we confirm that all tests pass, indicating that
    our module’s functionality behaves as intended. We then enhance our development
    workflow by defining **npm** scripts for linting and testing, streamlining the
    process of code formatting and validation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试文件后，我们确认所有测试都通过，这表明我们的模块功能按预期运行。然后，我们通过定义用于代码格式化和验证的 **npm** 脚本来增强我们的开发工作流程。
- en: Running **npm run lint** checks our code base for adherence to coding standards,
    while **npm test** executes our test suite to verify the correctness of our implementation.
    Any deviations from the coding standards or failing tests are highlighted for
    resolution. It is possible to create as many custom scripts as is suitable for
    your project.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 **npm run lint** 会检查我们的代码库是否符合编码标准，而 **npm test** 则执行我们的测试套件以验证实现的正确性。任何偏离编码标准或失败的测试都会被突出显示以便解决。我们可以为项目创建尽可能多的自定义脚本。
- en: Important note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The **npm** CLI supports many shortcuts. For example, **npm install** can be
    shortened to **npm i** . The **npm test** command can be shortened to **npm t**
    . The **npm run-script** command can be shortened to **npm run** . For more details,
    refer to the **npm** CLI documentation: [https://docs.npmjs.com/cli-documentation/cli](https://docs.npmjs.com/cli-documentation/cli)
    .'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm** CLI支持许多快捷方式。例如，**npm install**可以缩短为**npm i**。**npm test**命令可以缩短为**npm
    t**。**npm run-script**命令可以缩短为**npm run**。有关更多详细信息，请参阅**npm** CLI文档：[https://docs.npmjs.com/cli-documentation/cli](https://docs.npmjs.com/cli-documentation/cli)。'
- en: Finally, with our code base implemented, validated, and organized, we commit
    our changes using Git and push them to our GitHub repository. This ensures that
    our project’s history is well documented and that our latest updates are available
    to collaborators.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们的代码库实现、验证和组织完成后，我们使用Git提交我们的更改并将它们推送到我们的GitHub仓库。这确保了我们的项目历史记录得到良好记录，并且我们的最新更新可供协作者获取。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Publishing a module* recipe in this chapter
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的“发布模块”菜谱
- en: '[*Chapter 8*](B19212_08.xhtml#_idTextAnchor243)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19212_08.xhtml#_idTextAnchor243)'
- en: Publishing a module
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布模块
- en: 'This recipe will walk you through how to prepare and publish your module to
    the **npm** registry. Publishing your module to the **npm** registry will make
    it available for other developers to find and include in their applications. This
    is how the **npm** ecosystem operates: developers will author and publish modules
    to **npm** for other developers to consume and reuse in their Node.js application.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将指导你如何准备和发布你的模块到**npm**注册表。将你的模块发布到**npm**注册表将使其可供其他开发者查找并包含到他们的应用程序中。这就是**npm**生态系统的运作方式：开发者将编写和发布模块到**npm**，供其他开发者消费和重用在他们的Node.js应用程序中。
- en: In the recipe, we will be publishing the **temperature-converter** module that
    we created in the *Writing module code* recipe of this chapter to the **npm**
    registry. Specifically, we’ll be publishing our module to a scoped namespace,
    so you can expect your module to be available at **@npmusername/temperature-converter**
    .
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将发布我们在这个章节的“编写模块代码”菜谱中创建的**温度转换器**模块到**npm**注册表。具体来说，我们将把我们的模块发布到一个作用域命名空间中，因此你可以预期你的模块将在**@npmusername/temperature-converter**处可用。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe relies on the *Writing module code* recipe of this chapter. We will
    be publishing the **temperature-converter** module that we created in that recipe
    to the **npm** registry. You can obtain the module code from the *Writing module
    code* recipe from the GitHub repository at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter05/temperature-converter](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter05/temperature-converter)
    .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱依赖于本章的“编写模块代码”菜谱。我们将把在该菜谱中创建的**温度转换器**模块发布到**npm**注册表。你可以从GitHub仓库[https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter05/temperature-converter](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition/tree/main/Chapter05/temperature-converter)中的“编写模块代码”菜谱获取模块代码。
- en: This recipe also will require you to have an **npm** account. Go to [https://www.npmjs.com/signup](https://www.npmjs.com/signup)
    to sign up for an account. Keep note of your **npm** username.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱还需要你有一个**npm**账户。前往[https://www.npmjs.com/signup](https://www.npmjs.com/signup)注册账户。注意记录你的**npm**用户名。
- en: How to do it…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: This recipe will walk through the process of publishing a module to the **npm**
    registry.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将指导将模块发布到**npm**注册表的过程。
- en: 'Once you have signed up for an **npm** account, you can authorize your **npm**
    client with the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你注册了**npm**账户，你可以使用以下命令授权你的**npm**客户端：
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s update the **README.md** file that was automatically created for us when
    we initialized the GitHub repository in the *Scaffolding a module* recipe. Having
    an appropriate and clear **README.md** file is important so that users who stumble
    upon the module can understand what it does and whether it suits their use case.
    Open the **README.md** file in your editor and update the following, remembering
    to change the **npm** username to your own:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新在“搭建模块框架”菜谱中初始化GitHub仓库时自动为我们创建的**README.md**文件。拥有一个适当且清晰的**README.md**文件很重要，这样偶然发现该模块的用户可以了解它做什么以及它是否适合他们的用例。在你的编辑器中打开**README.md**文件，并更新以下内容，记得将**npm**用户名改为你自己的：
- en: '[PRE44]js'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE44]js'
- en: const { fahrenheitToCelsius, celsiusToFahrenheit }
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const { fahrenheitToCelsius, celsiusToFahrenheit }
- en: = require('@npmusername/temperature-converter');
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: = require('@npmusername/temperature-converter');
- en: const celsius = fahrenheitToCelsius(100);
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const celsius = fahrenheitToCelsius(100);
- en: console.log(`100°F is ${celsius}°C`);
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: console.log(`100°F is ${celsius}°C`);
- en: const fahrenheit = celsiusToFahrenheit(37);
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const fahrenheit = celsiusToFahrenheit(37);
- en: console.log(`37°C is ${fahrenheit}°F`);
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: console.log(`37°C is ${fahrenheit}°F`);
- en: '[PRE45]sh'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE45]sh'
- en: $ npm run test
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ npm run test
- en: '[PRE46]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Important note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **README** file we’ve just created is written using Markdown. The **.md**
    or **.MD** ending indicates that it is a Markdown file. Markdown is a documentation
    syntax that is commonly used across GitHub. To learn more about Markdown, check
    out GitHub’s guide at [https://guides.github.com/features/mastering-markdown/](https://guides.github.com/features/mastering-markdown/)
    . Many of the popular editors have plugins available so that you can render Markdown
    in your editor.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的 **README** 文件是使用 Markdown 编写的。**.md** 或 **.MD** 后缀表示它是一个 Markdown 文件。Markdown
    是一种在 GitHub 上广泛使用的文档语法。要了解更多关于 Markdown 的信息，请查看 GitHub 的指南：[https://guides.github.com/features/mastering-markdown/](https://guides.github.com/features/mastering-markdown/)。许多流行的编辑器都有可用的插件，这样你就可以在你的编辑器中渲染
    Markdown。
- en: 'Now, we need to update the name of our module in the **package.json** file
    to match our scoped module name. Let’s also make this version **1.0.0** of the
    module. You can either manually edit **package.json** or rerun the **npm init**
    command to overwrite it with any new values. Remember to change the **npm** username
    to your own:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在 **package.json** 文件中更新我们的模块名称，以匹配我们的范围模块名称。让我们也将这个模块版本设为 **1.0.0**。你可以手动编辑
    **package.json**，或者重新运行 **npm init** 命令来用任何新值覆盖它。记得将 **npm** 用户名改为你自己的：
- en: '[PRE47]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is ideal to keep your public GitHub repository up to date. Typically, module
    authors will create a tag on GitHub that matches the version that is pushed to
    **npm** . This can act as an audit trail for users wishing to see the source code
    of the module at a particular version, without having to download it via **npm**
    . However, please note that nothing is enforcing that the code you publish to
    **npm** must match the code you publish to GitHub:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持你的公共 GitHub 仓库是最新的是很理想的。通常，模块作者会在 GitHub 上创建一个与推送到 **npm** 的版本匹配的标签。这可以作为用户查看特定版本的模块源代码的审计跟踪，而无需通过
    **npm** 下载它。然而，请注意，没有任何东西强制要求你发布到 **npm** 的代码必须与你发布到 GitHub 的代码匹配：
- en: '[PRE48]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we’re ready to publish our module to the **npm** registry using the following
    command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用以下命令将我们的模块发布到 **npm** 注册表：
- en: '[PRE49]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can check that your publish was successful by navigating to [https://www.npmjs.com/package/@npmusername/temperature-converter](https://www.npmjs.com/package/@npmusername/temperature-converter)
    . Expect to see the following information about your module:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过导航到 [https://www.npmjs.com/package/@npmusername/temperature-converter](https://www.npmjs.com/package/@npmusername/temperature-converter)
    来检查你的发布是否成功。你可能会看到以下关于你的模块的信息：
- en: '![Figure 5.3 – npm module information on npmjs.com](img/B19212_05_03.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – npmjs.com 上的 npm 模块信息](img/B19212_05_03.jpg)'
- en: Figure 5.3 – npm module information on npmjs.com
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – npmjs.com 上的 npm 模块信息
- en: How it works…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first authenticated our local **npm** client using the **npm login** command.
    The **npm** client provides the ability to set up access controls so that certain
    users can publish to specific modules or scopes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 **npm login** 命令认证了我们的本地 **npm** 客户端。**npm** 客户端提供了设置访问控制的能力，以便某些用户可以发布到特定的模块或范围。
- en: The **npm login** command identifies who you are and where you’re entitled to
    publish. It is also possible to log out using **npm logout** .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm login** 命令标识了你是谁以及你有什么权利发布。你也可以使用 **npm logout** 命令登出。'
- en: 'The command that did the actual publishing to the registry was the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 实际发布到注册表的命令如下：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The **npm publish** command attempts to publish the package at the location
    identified by the **name** field in the **package.json** file. In the recipe,
    we published it to a scoped package – specifically, we used our own username’s
    scope. Scoped packages help to avoid naming conflicts. It is possible to publish
    your package to the global scope by not passing it a named scope – but you’re
    likely to run into name conflicts if your package has a common name.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm publish** 命令尝试将包发布到 **package.json** 文件中 **name** 字段指定的位置。在配方中，我们将其发布到了一个范围包中——具体来说，我们使用了我们自己的用户名范围。范围包有助于避免命名冲突。你可以通过不传递一个命名范围来将你的包发布到全局范围，但如果你有一个常见的包名，你可能会遇到命名冲突。'
- en: We also passed the **--access=public** flag. When publishing to a scoped package,
    we explicitly need to indicate that we want the module to be public. The **npm**
    CLI allows you to publish your modules as either public or private for scoped
    packages. To publish a module privately, you need to have a paid **npm** account.
    Note that the **--access=public** flag is not required when publishing to the
    global scope because all modules in the global namespace are public.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递了**--access=public**标志。当发布到范围包时，我们需要明确表示我们希望该模块是公开的。**npm** CLI允许您将范围包的模块发布为公开或私有。要私有发布模块，您需要有一个付费的**npm**账户。请注意，当发布到全局作用域时，不需要**--access=public**标志，因为全局命名空间中的所有模块都是公开的。
- en: The **npm publish** command packaged up our module code and uploaded it to the
    **npm** registry. Because the **package.json** file generated from the **npm init**
    command is generated with consistent properties, **npm** can extract and render
    that information on the module’s page. As shown in the recipe, **npm** automatically
    populated the **README** file, version, and GitHub links in the UI based on the
    information in our **package.json** file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm publish**命令打包了我们的模块代码并将其上传到**npm**注册表。由于从**npm init**命令生成的**package.json**文件具有一致的属性，**npm**可以提取并在此模块页面上呈现该信息。如图所示，**npm**根据我们的**package.json**文件中的信息自动填充了**README**文件、版本和GitHub链接。'
- en: There’s more…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Next, we’ll consider prepublish scripts and the **.npmignore** file and look
    at how to publish to private registries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑预发布脚本和**.npmignore**文件，并查看如何发布到私有注册表。
- en: Using prepublish scripts
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用预发布脚本
- en: The **npm** CLI supports a **prepublishOnly** script. This script will only
    run before the module is packaged and published. This is useful for catching mistakes
    before publishing. Should a mistake be made, it may be necessary to publish a
    second version to correct this mistake, causing potentially avoidable inconvenience
    to your module consumers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm** CLI支持**prepublishOnly**脚本。此脚本仅在模块打包和发布之前运行。这有助于在发布前捕获错误。如果发生错误，可能需要发布第二个版本来纠正此错误，这可能会给您的模块消费者带来潜在的避免不便。'
- en: 'Let’s add a **prepublishOnly** script to our module. Our **prepublishOnly**
    script will just run our **lint** script for now. Add a **prepublishOnly** script
    as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的模块中添加一个**prepublishOnly**脚本。我们的**prepublishOnly**脚本现在只是运行我们的**lint**脚本。以下是如何添加**prepublishOnly**脚本：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Typically, module authors will include rerunning their test suite in their
    **prepublishOnly** scripts:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模块作者会在他们的**prepublishOnly**脚本中包括重新运行他们的测试套件：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using .npmignore and package.json “files” properties
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用.npmignore和package.json的“files”属性
- en: As with a **.gitignore** file, which specifies which files should not be tracked
    or committed to a repository, **.npmignore** omits the files listed in it from
    the package. Files of the **.npmignore** type are not mandatory, and if you do
    not have one but do have a **.gitignore** file, then **npm** will omit the files
    and directories matched by the **.gitignore** file. The **.npmignore** file will
    override **.gitignore** if such a file exists.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与指定哪些文件不应被跟踪或提交到存储库的**.gitignore**文件一样，**.npmignore**省略了其中列出的文件。**.npmignore**类型的文件不是必需的，如果您没有它但有**.gitignore**文件，那么**npm**将省略与**.gitignore**文件匹配的文件和目录。如果存在这样的文件，**.npmignore**文件将覆盖**.gitignore**。
- en: The types of files and directories that are often added to **.npmignore** files
    are test files. If you have a particular large test suite in terms of size, then
    you should consider excluding these files by adding them to your **.npmignore**
    file. Users consuming your module do not tend to need the test suite bundled into
    their applications – excluding these and other superfluous files reduces the size
    of your module for all consumers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 常常添加到**.npmignore**文件中的文件和目录类型是测试文件。如果您在大小方面有一个特别大的测试套件，那么您应该考虑通过将它们添加到您的**.npmignore**文件中来排除这些文件。使用您的模块的用户通常不需要将测试套件捆绑到他们的应用程序中——排除这些和其他多余的文件可以减少所有消费者模块的大小。
- en: 'A **.npmignore** file that excludes just the **test** directory would look
    like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一个仅排除**test**目录的**.npmignore**文件看起来如下：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Remember that once the **.npmignore** file is created, it will be considered
    the **source of truth** ( **SOT** ) of which files should be ignored from the
    **npm** package. It’s worth going through your **.gitignore** file and ensuring
    items that you’ve added there are also added to **.npmignore** .
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一旦创建了 **.npmignore** 文件，它将被视为 **.npm** 包中应忽略哪些文件的 **真实来源**（**SOT**）。值得检查您的
    **.gitignore** 文件，并确保您添加到那里的项目也添加到 **.npmignore** 中。
- en: In the **package.json** file, you can also define a **"files"** property that
    allows you to specify an array of file paths or patterns that should be included
    when the package is published. Rather than an exclusion list, this acts as an
    inclusion list for what is published.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **package.json** 文件中，您还可以定义一个 **"files"** 属性，允许您指定在发布包时应包含的文件路径或模式数组。这不仅仅是一个排除列表，它还充当了发布内容的包含列表。
- en: 'For instance, if you have a Node.js module containing various utility functions,
    but you only want to expose the main functionality and documentation, you can
    specify “ **files": ["lib/", "docs/", "README.md"]** in your **package.json**
    file. This ensures that only the files within the specified directories and the
    **README.md** file are included when users install your package, while all other
    internal files or directories are excluded from the published package.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果您有一个包含各种实用函数的 Node.js 模块，但只想公开主要功能和相关文档，您可以在您的 **package.json** 文件中指定
    “ **files": ["lib/", "docs/", "README.md"]**。这确保了当用户安装您的包时，只包含指定目录中的文件以及 **README.md**
    文件，而所有其他内部文件或目录都将从发布的包中排除。'
- en: Providing an allow list by defining **"files"** in the **package.json** file
    rather than an exclusion list with **.npmignore** may be preferable as it removes
    the risk of forgetting to exclude a file in the **.** **npmignore** file.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **package.json** 文件中通过定义 **"files"** 而不是使用 **.npmignore** 文件中的排除列表来提供允许列表可能更可取，因为它消除了忘记在
    **.npmignore** 文件中排除文件的风险。
- en: To ensure that your package includes only the desired files upon publication,
    you can execute the **npm pack** command in your local environment. This command
    creates a tarball in your current working directory, mirroring the process used
    for publishing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的包在发布时只包含所需的文件，您可以在本地环境中执行 **npm pack** 命令。此命令在当前工作目录中创建一个tarball，反映了发布过程中使用的流程。
- en: Important note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While TypeScript and other transpilers are not covered in detail in this book,
    it is typical when publishing to **npm** to only publish the output files, such
    as JavaScript files, and not the source files, such as TypeScript files. This
    practice ensures that the package consumers receive only the necessary files to
    run the module. To achieve this, you can use the **.npmignore** file or the **"files"**
    property in **package.json** to exclude source files and include only the compiled
    output.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TypeScript和其他转换器在本书中没有详细介绍，但在发布到 **npm** 时，通常只发布输出文件，例如JavaScript文件，而不是源文件，例如TypeScript文件。这种做法确保包消费者只接收到运行模块所需的必要文件。为了实现这一点，您可以使用
    **.npmignore** 文件或 **package.json** 中的 **"files"** 属性来排除源文件，并仅包含编译后的输出。
- en: Private registries
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有注册表
- en: The **npm** CLI supports being configured to point to a **private registry**
    . A private registry is a registry that has been set up with some form of access
    control. Typically, these are set up by businesses and organizations that wish
    to keep some of their code off the public registry, potentially due to policy
    restrictions determined by their business. This enables the business to share
    its modules among members of the same organization while adhering to the business
    policy. Equally, a private registry can be used as a caching mechanism.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm** CLI 支持配置为指向 **私有注册表**。私有注册表是一种设置了某种形式的访问控制的注册表。通常，这些是由希望将其部分代码保留在公共注册表之外的企业和组织设置的。这可能是因为业务政策限制。这使得企业能够在遵守业务政策的同时，在其组织成员之间共享模块。同样，私有注册表也可以用作缓存机制。'
- en: 'You can change which registry you’re pointing to with the following command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令更改您指向的注册表：
- en: '[PRE54]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can see which registry you’re pointing to with the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令查看您指向的注册表：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that these both use the **npm config** command. You can list all your
    **npm config** settings with the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个都使用了 **npm config** 命令。您可以使用以下命令列出您所有的 **npm config** 设置：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A **.npmrc** file is a configuration file for **npm** that can be used to set
    various **npm** configurations globally or on a per-project basis. This file allows
    you to persistently configure **npm** settings, such as registry URLs and authentication
    tokens. For example, to point **npm** to a private registry, you can add the following
    line to a **.** **npmrc** file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**.npmrc** 文件是 **npm** 的配置文件，可用于全局或按项目设置各种 **npm** 配置。此文件允许您持久地配置 **npm** 设置，例如注册表
    URL 和身份验证令牌。例如，要将 **npm** 指向私有注册表，您可以将以下行添加到 **.** **npmrc** 文件中：'
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There are many other configurable settings and customizations in this file;
    refer to the **npm** documentation for more information: [https://docs.npmjs.com/cli/v10/configuring-npm/npmrc](https://docs.npmjs.com/cli/v10/configuring-npm/npmrc)
    .'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中还有许多其他可配置设置和自定义选项；有关更多信息，请参阅 **npm** 文档：[https://docs.npmjs.com/cli/v10/configuring-npm/npmrc](https://docs.npmjs.com/cli/v10/configuring-npm/npmrc)。
- en: Using ECMAScript modules
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ECMAScript 模块
- en: ESM represents the official standard for packaging JavaScript code for reuse.
    ESM was introduced in **ECMAScript 2015** ( **ES6** ) to bring a unified module
    system to the JavaScript language, a featu re that was absent and in much demand
    for years. Unlike **CommonJS** ( **CJS** ) modules, which were adopted by Node.js
    for server-side development, ESM provides a way to statically analyze code for
    imports and exports, allowing for optimizations such as tree shaking, which eliminates
    unused code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ESM 代表了包装 JavaScript 代码以供重用的官方标准。ESM 在 **ECMAScript 2015**（**ES6**）中引入，以将统一的模块系统带给
    JavaScript 语言，这是多年来缺失且需求迫切的功能。与 Node.js 用于服务器端开发的 **CommonJS**（**CJS**）模块不同，ESM
    提供了一种静态分析代码导入和导出的方法，允许进行诸如摇树优化等优化，从而消除未使用的代码。
- en: The introduction of ESM into the Node.js ecosystem marked a significant milestone,
    offering developers the benefits of a standardized module system that is compatible
    across different environments, including browsers, where modules can be natively
    loaded without the need for bundling tools.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ESM 引入 Node.js 生态系统标志着重要的里程碑，为开发者提供了跨不同环境（包括浏览器）兼容的标准化模块系统的优势，在这些环境中，模块可以原生加载，无需捆绑工具。
- en: 'Configuring Node.js to use ESM involves understanding and setting up project
    structures to accommodate the new syntax and module resolution strategy. By default,
    Node.js treats **.js** files as CJS modules, but with the inclusion of a **"type":
    "module"** entry in a project’s **package.json** file, Node.js switches to treating
    files with the **.js** extension as ESM.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '配置 Node.js 以使用 ESM 涉及理解和设置项目结构以适应新的语法和模块解析策略。默认情况下，Node.js 将 **.js** 文件视为 CJS
    模块，但通过在项目的 **package.json** 文件中包含一个 **"type": "module"** 条目，Node.js 将切换为将具有 **.js**
    扩展名的文件视为 ESM。'
- en: Alternatively, developers can use the **.mjs** extension for JavaScript files
    intended to be treated as modules. This setup phase is crucial as it lays the
    foundation for importing and exporting modules using the **import** and **export**
    keywords, respectively, moving away from the **require** and **module.exports**
    syntax of CJS. The enablement of ESM in Node.js not only aligns server-side development
    with frontend practices but also opens new possibilities for code sharing and
    modularization across the JavaScript ecosystem.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，开发者可以使用 **.mjs** 扩展名来为打算作为模块处理的 JavaScript 文件。这个设置阶段至关重要，因为它为使用 **import**
    和 **export** 关键字导入和导出模块奠定了基础，从而远离 CJS 的 **require** 和 **module.exports** 语法。在
    Node.js 中启用 ESM 不仅使服务器端开发与前端实践保持一致，而且为 JavaScript 生态系统中的代码共享和模块化开辟了新的可能性。
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The core ESM support is enabled by default and designated with stable status
    in all currently supported Node.js versions. However, some individual ESM capabilities
    remain experimental.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 核心ESM支持默认启用，并在所有当前支持的 Node.js 版本中指定为稳定状态。然而，一些单个ESM功能仍然是实验性的。
- en: In this recipe, we will create a mini-project that calculates various geometric
    shapes’ areas and perimeters. This recipe will serve as an introduction to using
    ESM in Node.js and demonstrate the use of named and default exports.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个计算各种几何形状面积和周长的迷你项目。这个食谱将作为在 Node.js 中使用 ESM 的介绍，并演示命名和默认导出的使用。
- en: 'To get started, ensure you’re using Node.js 22 and create a directory to work
    in:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请确保您正在使用 Node.js 22 并创建一个工作目录：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We will also prepare some files for our geometric shape modules:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为我们的几何形状模块准备一些文件：
- en: '[PRE59]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe, we’ll create modules for calculating the area and perimeter
    of geometric shapes such as circles and rectangles. We will also create a utility
    for rounding.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建用于计算圆形和矩形等几何形状面积和周长的模块。我们还将创建一个用于四舍五入的实用工具。
- en: 'First, we need to initialize our module. For this recipe, we’ll just accept
    the defaults:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要初始化我们的模块。对于这个菜谱，我们只需接受默认值：
- en: '[PRE60]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, as we plan to use ESM syntax throughout, we should set the **"type": "module"**
    entry in the **package.json** file:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，由于我们计划在整个项目中使用ESM语法，我们应该在**package.json**文件中设置**"type": "module"**条目：'
- en: '[PRE61]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let’s create a *circle module* . This module will use a default **export**
    statement for the main function – which is to calculate the area. It will also
    expose a function to calculate the circumference of the circle as a named export.
    Add the following code to **circle.js** :'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个**圆形模块**。此模块将使用默认的**导出**语句来导出主函数——即计算面积。它还将公开一个用于计算圆周长的函数作为命名导出。将以下代码添加到**circle.js**：
- en: '[PRE62]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we are making use of the **Math** namespace object for the value of
    Pi.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们正在使用**Math**命名空间对象来获取π的值。
- en: 'Next, we’ll create a *rectangle module* ( **rectangle.js** ). This module will
    export area and perimeter functions but this time using only named exports. Add
    the following code to **rectangle.js** :'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个**矩形模块**（**rectangle.js**）。此模块将导出面积和周长函数，但这次只使用命名导出。将以下代码添加到**rectangle.js**：
- en: '[PRE63]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we’ll implement a small *mathematical utility* . We’ll just add one function
    that rounds values. Create a file called **mathUtils.js** :'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个小型的**数学实用工具**。我们只需添加一个四舍五入值的函数。创建一个名为**mathUtils.js**的文件：
- en: '[PRE64]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add the following code to **mathUtils.js** :'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到**mathUtils.js**：
- en: '[PRE65]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, we’ll implement the *main module* ( **index.js** ). This module will
    import and use the functions from the geometry modules and the utility module.
    This module will demonstrate the various ways in which we can import:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现**主模块**（**index.js**）。此模块将导入并使用来自几何模块和实用工具模块的函数。此模块将展示我们可以以各种方式导入：
- en: '[PRE66]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This module demonstrates importing a default export without braces, named exports
    with braces, and importing all named exports from a module as an object using
    the **import *** **as** syntax.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模块演示了如何使用不带花括号的默认导出、带花括号的命名导出，以及使用**import *** **as**语法将模块的所有命名导出作为对象导入。
- en: 'Execute your application by running the following:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来执行你的应用程序：
- en: '[PRE67]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You should see calculated metrics for a circle and a rectangle, showcasing how
    to use both default and named exports in a modular Node.js application.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能看到圆和矩形的计算度量，展示了如何在模块化的Node.js应用程序中使用默认和命名导出。
- en: This project illustrates the flexibility and efficiency of using ESM for organizing
    and structuring JavaScript code in Node.js projects. Through the example of calculating
    geometric shapes’ metrics, we’ve seen how to properly use default and named exports
    to make our code modular and reusable.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目展示了在Node.js项目中使用ESM（模块化）来组织和结构化JavaScript代码的灵活性和效率。通过计算几何形状的度量示例，我们看到了如何正确使用默认和命名导出，使我们的代码模块化和可重用。
- en: How it works…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The tutorial is structured around the concept of modular programming using ESM
    in a Node.js environment. The primary goal of the recipe is to demonstrate how
    ESM can be leveraged to build a well-organized, maintainable, and scalable project.
    We achieve this through the development of a small application designed to calculate
    the area and perimeter of geometric shapes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的结构围绕在Node.js环境中使用ESM（模块化）进行模块化编程的概念。本菜谱的主要目标是展示如何利用ESM构建一个组织良好、易于维护和可扩展的项目。我们通过开发一个小型应用程序来实现这一点，该应用程序旨在计算几何形状的面积和周长。
- en: 'The project is initiated as a standard Node.js application with a **package.json**
    file. By setting **"type": "module"** in the **package.json** file, we instruct
    Node.js to treat files with the **.js** extension as ESM files.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '项目以具有**package.json**文件的标准Node.js应用程序启动。通过在**package.json**文件中将**"type": "module"**设置为，我们指示Node.js将具有**.js**扩展名的文件视为ESM文件。'
- en: The geometry calculations are divided into separate modules for each shape.
    This modular approach demonstrates the concept of single responsibility, where
    each module is tasked with a specific set of functionalities related to a particular
    geometric shape. This approach will be familiar to those who have worked with
    other **object-oriented programming** ( **OOP** ) languages such as Java.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 几何计算被划分为针对每个形状的独立模块。这种模块化方法展示了单一责任的概念，即每个模块负责与特定几何形状相关的一组特定功能。这种方法对于那些使用过其他
    **面向对象编程** ( **OOP** ) 语言（如 Java）的人来说将很熟悉。
- en: For the circle module ( **circle.js** ), we implemented functions to calculate
    the area (exposed as the default export) and circumference (exposed as a named
    export) of a circle. The use of a default export for the primary function illustrates
    how to expose a module’s main functionality, while named exports tend to be used
    for secondary functions.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于圆模块（ **circle.js** ），我们实现了计算圆面积（作为默认导出）和周长（作为命名导出）的函数。使用默认导出主要函数说明了如何展示模块的主要功能，而命名导出通常用于次要功能。
- en: For the rectangle module ( **rectangle.js** ), we only included named exports
    for functions calculating the area and perimeter of a rectangle. The use of named
    exports highlights how multiple related functionalities can be grouped within
    a single module and exported individually.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩形模块（ **rectangle.js** ），我们只包含了计算矩形面积和周长的函数的命名导出。使用命名导出突出了如何在单个模块中将多个相关功能分组并单独导出。
- en: We introduced a utility module ( **mathUtils.js** ) to perform rounding operations.
    This module’s existence emphasizes the utility of having shared functionalities
    abstracted into their modules, making them reusable across a project.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个实用模块（ **mathUtils.js** ）来执行舍入操作。这个模块的存在强调了将共享功能抽象到模块中的实用性，使它们在整个项目中可重用。
- en: The main module, **index.js** , serves as the entry point to the application.
    It dynamically imports the geometry modules and the utility module, using their
    functionalities to perform calculations based on user input or predefined values.
    While a simplified example, it demonstrates how to import both default and named
    exports from modules, highli ghting the versatility of ESM in handling various
    export types.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 主要模块 **index.js** 作为应用程序的入口点。它动态导入几何模块和实用模块，使用它们的函数根据用户输入或预定义值执行计算。虽然这是一个简化的例子，但它展示了如何从模块中导入默认和命名导出，突出了
    ESM 在处理各种导出类型方面的多功能性。
- en: There’s more…
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: CJS remains widely used in Node.js applications due to its long history in the
    vast ecosystem of **npm** modules. ESM is being increasingly adopted for new projects
    due to its native browser support, module optimization capabilities, and alignment
    with the ECMAScript standard.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: CJS 由于在庞大的 **npm** 模块生态系统中拥有悠久的历史，因此在 Node.js 应用程序中仍然被广泛使用。由于原生浏览器支持、模块优化能力和与
    ECMAScript 标准的一致性，ESM 正在越来越多地被用于新项目。
- en: Understanding these differences is critical for developers navigating the Node.js
    and wider JavaScript ecosystem, especially when working on applications and projects
    that may require integrating both module types.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些差异对于在 Node.js 和更广泛的 JavaScript 生态系统中导航的开发者至关重要，尤其是在处理可能需要集成两种模块类型的应用程序和项目时。
- en: Important note
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the current state of Node.js development, developers often have to navigate
    both module systems. Therefore, some recipes in subsequent chapters of this book
    will utilize the ESM syntax. In some cases, this is required due to certain **npm**
    modules now exclusively supporting ESM.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前 Node.js 开发状态下，开发者通常必须导航这两个模块系统。因此，本书后续章节中的一些食谱将使用 ESM 语法。在某些情况下，这是由于某些 **npm**
    模块现在仅支持 ESM。
- en: Differences between CJS and ESM
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CJS 和 ESM 之间的差异
- en: 'The differences between CJS and ESM in Node.js are foundational to understanding
    how to effectively use modules in JavaScript applications. Let’s take a closer
    look at these:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中，CJS 和 ESM 之间的差异是理解如何在 JavaScript 应用程序中有效使用模块的基础。让我们更深入地看看这些：
- en: '| **CJS** | **ESM** |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| **CJS** | **ESM** |'
- en: '| Uses **require()** for importing modules and **module.exports** or **exports**
    for exporting. | Uses the **import** and **export** statements for importing and
    exporting modules. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 使用 **require()** 导入模块，使用 **module.exports** 或 **exports** 导出。 | 使用 **import**
    和 **export** 语句导入和导出模块。 |'
- en: '| Loads modules synchronously. | Supports asynchronous loading, allowing for
    dynamic **import()** statements. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 同步加载模块。 | 支持异步加载，允许使用动态 **import()** 语句。 |'
- en: '| Supports non-static, runtime module resolution allowing for conditional imports
    based on runtime conditions. | Static structure enables **import** / **export**
    statements to be analyzed at compile time, leading to potential optimizations
    by JavaScript engines. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 支持非静态、运行时模块解析，允许根据运行时条件进行条件导入。 | 静态结构使得**import**/**export**语句可以在编译时进行分析，从而可能导致JavaScript引擎进行潜在优化。
    |'
- en: '| CJS modules can use ESM through dynamic **import()** statements or by creating
    wrapper modules, but attention is required to avoid issues such as the dual package
    hazard. | ESM can import CJS modules using default imports. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| CJS模块可以通过动态的**import()**语句或通过创建包装模块来使用ESM，但需要注意避免双重包风险等问题。 | ESM可以使用默认导入来导入CJS模块。
    |'
- en: '| Exports are copied upon import, meaning changes to the exported value after
    import are not reflected in the importing module. | Supports live bindings, allowing
    imported values to update if they change in the exporting module. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 导出在导入时被复制，这意味着导入后对导出值的更改不会反映在导入模块中。 | 支持活绑定，允许导入的值在导出模块中更改时更新。 |'
- en: '| Does not support **top-level await** as it relies on synchronous module loading.
    | Enables Top-level Await, enabling modules to wait for asynchronous operations
    before proceeding. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 不支持**顶层await**，因为它依赖于同步模块加载。 | 启用顶层await，允许模块在继续之前等待异步操作。 |'
- en: '| Typically uses the **.js** extension, although an explicit **.cjs** extension
    may be used. | While **.js** can be used (with **"type": "module"** in **package.json**
    ), the **.mjs** extension can be used to explicitly mark files as ESM. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 通常使用**.js**扩展名，尽管也可以显式使用**.cjs**扩展名。 | 虽然**.js**可以用于（在**package.json**中设置**"type":
    "module"**），但**.mjs**扩展名可以用来显式标记文件为ESM。 |'
- en: '| Modules have their own scope but share a global object. | Modules are executed
    in **strict mode** by default and have their own scope, with a more isolated environment.
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 模块有自己的作用域但共享一个全局对象。 | 模块默认以**严格模式**执行，并拥有自己的作用域，具有更隔离的环境。 |'
- en: Table 5.2 – Key differences between CJS and ESM modules
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 – CJS和ESM模块之间的关键差异
- en: Interoperability with CJS modules
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与CJS模块的互操作性
- en: One of the crucial aspects of adopting ESM modules in Node.js projects is understanding
    how they can interoperate with the traditional CJS module system. Given the vast
    ecosystem of existing Node.js packages and applications that use CJS, it is essential
    to grasp how to work with both module systems in a single project. This section
    explores the mechanisms and practices for achieving interoperability between ESM
    and CJS modules, ensuring a smooth transition and integration process.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js项目中采用ESM模块的一个关键方面是理解它们如何与传统CJS模块系统互操作。鉴于现有的大量Node.js包和应用都使用CJS，掌握如何在单个项目中同时处理这两种模块系统至关重要。本节探讨了实现ESM和CJS模块之间互操作性的机制和实践，确保平稳过渡和集成过程。
- en: 'ESM can import CJS modules using the **import** statement, thanks to Node.js’s
    built-in interoperability support. However, because CJS modules are not statically
    analyzable in the same way as ESM, there are some nuances to be aware of:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ESM可以使用**import**语句导入CJS模块，这得益于Node.js内置的互操作性支持。然而，由于CJS模块不能像ESM那样进行静态分析，因此需要注意一些细微差别：
- en: '**Default imports** : When importing a CJS module in an ESM file, the entire
    module’s exports are treated as a single default export. This means you cannot
    use named imports directly from a CJS module:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认导入**：在ESM文件中导入CJS模块时，整个模块的导出被视为单个默认导出。这意味着您不能直接从CJS模块中直接使用命名导入：'
- en: '[PRE68]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**Dynamic imports** : You can dynamically import CJS modules using the **import()**
    function. This approach returns a **Promise** that resolves with the CJS module’s
    exports, allowing for asynchronous module loading:'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态导入**：您可以使用**import()**函数动态导入CJS模块。这种方法返回一个**Promise**，该Promise解析为CJS模块的导出，允许异步模块加载：'
- en: '[PRE69]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Exporting ESM modules for use in CJS** : When it comes to using ESM modules
    in CJS code, the process is somewhat more constrained due to the synchronous nature
    of CJS’s **require()** function, which does not support ESM’s asynchronous module
    loading. However, there are workarounds.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将ESM模块导出以供CJS使用**：当在CJS代码中使用ESM模块时，由于CJS的**require()**函数是同步的，因此这个过程受到一定程度的限制，该函数不支持ESM的异步模块加载。然而，存在一些解决方案。'
- en: 'One common approach is to create a CJS wrapper module that dynamically imports
    the ESM module and then exports its functionalities. This requires using asynchronous
    patterns such as **async** , **await** , or promises:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是创建一个CJS包装模块，该模块动态导入ESM模块，然后导出其功能。这需要使用异步模式，如**async**、**await**或promises：
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Projects that offer both ESM and CJS entry points need to be aware of the dual
    package hazard, where a single package loaded in both formats might lead to state
    issues or duplicated instances.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 提供ESM和CJS入口点的项目需要意识到双重包风险，即以两种格式加载的单个包可能会导致状态问题或实例重复。
- en: When producing a module, it is recommended that you document if your package
    or application supports both ESM and CJS, with guidance on how consumers can import
    it into their projects. Should you dual publish, it is also recommended that you
    thoroughly test your module in both ESM and CJS environments to catch any interoperability
    issues.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建模块时，建议您记录您的包或应用程序是否支持ESM和CJS，并提供有关消费者如何将其导入其项目的指南。如果您同时发布，还建议您在ESM和CJS环境中彻底测试您的模块，以捕获任何互操作性问题。
- en: 'Important Note:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: 'Node.js now offers Experimental support for loading ES modules using **require()**
    with the **--experimental-require-module** flag. This feature enables CommonJS
    modules to load ES modules under specific conditions, such as when the file has
    a **.mjs** extension or when **"type": "module"** is set in the nearest package.json.
    However, if the module or its dependencies contain top-level await, the **ERR_REQUIRE_ASYNC_MODULE**
    error will be thrown, requiring **import()** for asynchronous modules.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'Node.js现在通过使用带有**--experimental-require-module**标志的**require()**来提供对加载ES模块的实验性支持。此功能允许在特定条件下加载ES模块，例如当文件具有**.mjs**扩展名或当最近的package.json中设置**"type":
    "module"**时。然而，如果模块或其依赖项包含顶层await，将抛出**ERR_REQUIRE_ASYNC_MODULE**错误，需要**import()**来处理异步模块。'
- en: 'This functionality is designed to improve interoperability between CommonJS
    and ES modules, but as an experimental feature, it may change in future Node.js
    versions. For more information, visit: [https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require](https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require)
    .'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能旨在提高CommonJS和ES模块之间的互操作性，但作为一个实验性特性，它可能在未来的Node.js版本中发生变化。更多信息，请访问：[https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require](https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require)。
- en: Advanced topics in ECMAScript Modules
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ECMAScript Modules的高级主题
- en: 'Advancing your understanding of ESM within Node.js involves exploring more
    complex features and strategies that can optimize and enhance the functionality
    of your applications. There are some further advanced topics you can explore for
    benefits and considerations for developers working with ESM:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中提高对ESM的理解涉及探索更复杂的功能和策略，这些功能和策略可以优化和增强您应用程序的功能。您可以探索一些更高级的主题，以了解ESM开发者的好处和考虑因素：
- en: '**Dynamic import expressions** : Dynamic imports allow you to load modules
    on an as-needed basis, using the **import()** function that returns a **Promise**
    . This feature is particularly useful for reducing initial load times and optimizing
    resource utilization in applications by splitting the code into smaller chunks
    that are loaded only when required.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态导入表达式**：动态导入允许您根据需要加载模块，使用返回**Promise**的**import()**函数。这个特性特别有用，可以通过将代码拆分成更小的块，只在需要时加载，来减少初始加载时间并优化应用程序的资源利用。'
- en: '**Module caching and preloading** : Node.js caches imported modules to avoid
    reloading them each time they are required in the application, enhancing performance.
    Preloading modules involves loading modules before they are needed, potentially
    speeding up application startup by reducing delays associated with loading modules
    at runtime.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块缓存和预加载**：Node.js缓存导入的模块以避免在每次需要时重新加载它们，从而提高性能。预加载模块涉及在需要之前加载模块，可能通过减少与运行时加载模块相关的延迟来加快应用程序的启动速度。'
- en: '**Tree shaking** : Tree shaking is a term commonly associated with static code
    analysis tools and bundlers (such as **Webpack** ). It refers to the elimination
    of unused code from a final bundle. For tree shaking to be effective, modules
    must use static **import** and **export** statements, as this allows the bundler
    to determine which exports are used and which can be safely removed, leading to
    smaller and more efficient bundles.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摇树优化**：摇树优化是一个与静态代码分析工具和打包器（如 **Webpack**）相关的术语。它指的是从最终包中消除未使用的代码。为了使摇树优化有效，模块必须使用静态
    **导入** 和 **导出** 语句，因为这允许打包器确定哪些导出被使用，哪些可以安全地删除，从而生成更小、更高效的包。'
- en: '**Module resolution customization** : It is also possible to customize module
    resolution by configuring how import specifiers are resolved to actual module
    files. Node.js provides an experimental feature named **customization hooks**
    , which allows you to customize module resolution and loading by registering a
    file that exports hooks. For more information, refer to the Node.js API documentation
    for the feature: [https://nodejs.org/api/module.html#customization-hooks](https://nodejs.org/api/module.html#customization-hooks)
    .'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块解析自定义**：也可以通过配置如何解析导入指定符到实际模块文件来自定义模块解析。Node.js 提供了一个名为 **自定义钩子** 的实验性功能，允许你通过注册一个导出钩子的文件来自定义模块解析和加载。有关更多信息，请参阅该功能的
    Node.js API 文档：[https://nodejs.org/api/module.html#customization-hooks](https://nodejs.org/api/module.html#customization-hooks)。'
- en: See also
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Scaffolding a module* recipe in this chapter
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *搭建模块* 菜谱
- en: The *Writing module code* recipe in this chapter
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *编写模块代码* 菜谱
- en: '[*Chapter 8*](B19212_08.xhtml#_idTextAnchor243)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19212_08.xhtml#_idTextAnchor243)'
