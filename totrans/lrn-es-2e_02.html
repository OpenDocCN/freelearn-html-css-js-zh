<html><head></head><body>
        

                            
                    <h1 class="header-title">Knowing Your Library</h1>
                
            
            
                
<p class="mce-root">ES6/ES7/ES8 has added lots of new properties and methods to built-in JavaScript objects. These new functionalities aim to help developers avoid using hacks and error-prone techniques to do various operations related to numbers, strings, and arrays.</p>
<p>From the last chapter, you now know a decent amount of background details about JavaScript, how it works, its fundamentals, and basic stuff such as hoisting, scoping variables, and immutability. Now let's move on and take a look at some topics which you'll end up using practically all the time in your code.</p>
<p class="mce-root">In this chapter, we'll cover:</p>
<ul>
<li class="mce-root">The new properties and methods of the <kbd>Number</kbd>, <kbd>Object</kbd>, <kbd>Math</kbd>, and <kbd>Array</kbd> objects</li>
<li class="mce-root">Representing numeric constants as binary or octal</li>
<li class="mce-root">Creating multiline strings and the new methods of the <kbd>String</kbd> object</li>
<li class="mce-root">Maps and sets</li>
<li class="mce-root">Using array buffers and typed arrays</li>
<li>How to iterate properly over arrays using some built-in methods</li>
<li>String padding, and more!</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with numbers</h1>
                
            
            
                
<p>ES6, ES2016 (ES7), and ES2017 (ES8) bring new ways of creating numbers and new properties to the <kbd>Number</kbd> object to make working with numbers easier. The <kbd>Number</kbd> object was enhanced greatly in ES6 to make it easier to create mathematically rich applications and prevent the common misconceptions that caused the errors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The binary notation</h1>
                
            
            
                
<p>Earlier, there was no native way to represent numeric constants as binary. But now, you can prefix numeric constants using the <kbd>0b</kbd> token to make JavaScript interpret them as binary.<br/>
Here is an example:</p>
<pre>let a = 0b00001111;<br/>let b = 15;<br/>console.log(a === b);<br/>console.log(a);</pre>
<p>The output is as follows:</p>
<pre><strong>true</strong><br/><strong>15</strong></pre>
<p>Here, <kbd>0b00001111</kbd> is a binary representation of <kbd>15</kbd>, base 10 decimal.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The octal notation</h1>
                
            
            
                
<p>The octal notation is a number system where we use only eight digits, that is, from 0 to 7. You can represent a number in octal format with JavaScript if you like.</p>
<p>Earlier, to represent a numeric constant as octal, we needed to prefix the numeric constant using <kbd>0</kbd>. For example, take a look at the following:</p>
<pre>const a = 017;<br/>const b = 15;<br/>console.log(a === b);<br/>console.log(a);</pre>
<p>The output is as follows:</p>
<pre><strong>true</strong><br/><strong>15</strong></pre>
<p>But often, programmers new to JavaScript, get confused with octal representations and decimal numbers with <kbd>0</kbd> at the front. For example, they think <kbd>017</kbd> is the same as <kbd>17</kbd>. Therefore, to remove this confusion, JavaScript now allows us to prefix numeric constants using <kbd>00</kbd> to make JavaScript interpret them as octal.<br/>
Here is an example to demonstrate this:</p>
<pre>const a = 0017;<br/>const b = 15;<br/>console.log(a === b);<br/>console.log(a);</pre>
<p>The output is as follows:</p>
<pre><strong>true</strong><br/><strong>15</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Number.isInteger(number) method</h1>
                
            
            
                
<p>JavaScript numbers are stored as 64-bit, floating-point numbers. So integers in JavaScript are floating-point numbers without a decimal fraction or a decimal fraction with all 0's.</p>
<p>In ES5, there was no built-in way to check whether a number is an integer or not. There exists a new method to the <kbd>Number</kbd> object called <kbd>isInteger()</kbd>, which takes a number and returns <kbd>true</kbd> or <kbd>false</kbd>, depending on whether the number is an integer or not.<br/>
Here is an example:</p>
<pre>let a = 17.0;<br/>let b = 1.2;<br/>console.log(Number.isInteger(a));<br/>console.log(Number.isInteger(b));</pre>
<p>The output is as follows:</p>
<pre><strong>true</strong><br/><strong>false</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Number.isNaN(value) method</h1>
                
            
            
                
<p><kbd>The Number.isNaN</kbd> function returns <kbd>true</kbd> <em>if and only if</em><strong> </strong>the value equals <kbd>NaN</kbd>. Otherwise, in every other case, it returns <kbd>false</kbd>. That means it will <em>not</em> try to typecast something which is not a number, to a number (which usually results in <kbd>NaN</kbd> being returned).</p>
<p>Check the following example:</p>
<pre>let a = "NaN";<br/>let b = NaN;<br/>let c = "hello";<br/>let d = 12;<br/>console.log(Number.isNaN(a)); // false<br/>console.log(Number.isNaN(b)); // true<br/>console.log(Number.isNaN(c)); // false<br/>console.log(Number.isNaN(d)); // false</pre>
<p>Here you can see that the <kbd>Number.isNaN()</kbd> method returns <kbd>true</kbd> only if the passed value is exactly <kbd>NaN</kbd>.<br/>
<br/>
You might ask, why not use <kbd>==</kbd> or the <kbd>===</kbd> operator instead of the <kbd>Number.isNaN(value)</kbd> method? The <kbd>NaN</kbd> value is the only value that is not equal to itself, that is, the expression <kbd>NaN==NaN</kbd> or <kbd>NaN===NaN</kbd> will return <kbd>false</kbd>.</p>
<p>If you declare <kbd>x = NaN</kbd>, then <kbd>x</kbd> is not equal to itself!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">isNaN versus Number.isNaN</h1>
                
            
            
                
<p>To me, a method called <kbd>isNaN</kbd> should intuitively return <kbd>false</kbd> only on numbers and <kbd>true</kbd> on everything else. That is exactly what the <kbd>isNaN()</kbd> global method does. However, if you're looking to compare a value to <kbd>NaN</kbd> (which you cannot do with <kbd>===</kbd> or <kbd>==</kbd>), then <kbd>Number.isNaN</kbd> is your choice.</p>
<p>For example:</p>
<pre>isNaN(' '); // false =&gt; because Number(' ') is equal to 0 (a number)<br/>isNaN(true); // false =&gt; because Number(true) is equal to 1 (a number)</pre>
<p>In short, <kbd>isNaN</kbd> also tries to perform type conversion. That is why some developers consider it broken.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Number.isFinite(number) method</h1>
                
            
            
                
<p>The global <kbd>isFinite()</kbd> function takes a value and checks whether it's a finite number or not. But unfortunately, it also returns <kbd>true</kbd> for values that convert to a <kbd>Number</kbd> type.</p>
<p>The <kbd>Number.isFinite()</kbd> method resolves the issue of the <kbd>window.isFinite()</kbd> function. Here is an example to demonstrate this:</p>
<pre>console.log(isFinite(10)); // true <br/>console.log(isFinite(NaN)); // false<br/>console.log(isFinite(null)); // true<br/>console.log(isFinite([])); // true<br/>console.log(Number.isFinite(10)); // true<br/>console.log(Number.isFinite(NaN)); // false<br/>console.log(Number.isFinite(null)); // false<br/>console.log(Number.isFinite([])); // false</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Number.isSafeInteger(number) method</h1>
                
            
            
                
<p>JavaScript numbers are stored as 64-bit floating-point numbers, following the international IEEE 754 standard. This format stores numbers in 64 bits, where the number (the fraction) is stored in 0 to 51 bits, the exponent in 52 to 62 bits, and the sign in the last bit.<br/>
So in JavaScript, safe integers are those numbers that do not need to be rounded to some other integer to fit in with the IEEE 754 representation. Mathematically, numbers from -(2<sup>53</sup>-1) to (2<sup>53</sup>-1) are considered as safe integers.<br/>
Here is an example to demonstrate this:</p>
<pre>console.log(Number.isSafeInteger(156));<br/>console.log(Number.isSafeInteger('1212'));<br/>console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER));<br/>console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1));<br/>console.log(Number.isSafeInteger(Number.MIN_SAFE_INTEGER));<br/>console.log(Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1));</pre>
<p>The output is as follows:</p>
<pre><strong>true</strong><br/><strong>false</strong><br/><strong>true</strong><br/><strong>false</strong><br/><strong>true</strong><br/><strong>false</strong></pre>
<p>Here, <kbd>Number.MAX_SAFE_INTEGER</kbd> and <kbd>Number.MIN_SAFE_INTEGER</kbd> are constant values, introduced in ES6, representing (253-1) and -(253-1) respectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Number.EPSILON property</h1>
                
            
            
                
<p>JavaScript uses binary floating-point representation with the result that computers fail to accurately represent numbers such as 0.1, 0.2, 0.3, and so on. When your code is executed, numbers such as 0.1 are rounded to the nearest number in that format, which results in a small rounding error.<br/>
Consider this example:</p>
<pre>console.log(0.1 + 0.2 == 0.3);<br/>console.log(0.9 - 0.8 == 0.1);<br/>console.log(0.1 + 0.2);<br/>console.log(0.9 - 0.8);</pre>
<p>The output is as follows:</p>
<pre><strong>false</strong><br/><strong>false</strong><br/><strong>0.30000000000000004</strong><br/><strong>0.09999999999999998</strong></pre>
<p>The <kbd>Number.EPSILON</kbd> property was introduced in ES6, and has a value of approximately 2<sup>-52</sup>. This value represents a reasonable margin of error when comparing floating-point numbers. Using this number, we can create a custom function to compare floating-point numbers by ignoring the minimal rounding errors. The following example code:</p>
<pre>function epsilonEqual(a, b) {<br/>  return Math.abs(a - b) &lt; Number.EPSILON;<br/>}<br/>console.log(epsilonEqual(0.1 + 0.2, 0.3));<br/>console.log(epsilonEqual(0.9 - 0.8, 0.1));</pre>
<p>The output is as follows:</p>
<pre><strong>true</strong><br/><strong>true</strong></pre>
<p>Here, <kbd>epsilonEqual()</kbd> is the custom function that we build to compare whether the two values are equal or not. Now, the output is as expected.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Doing math</h1>
                
            
            
                
<p>ES6 and above add a lot of new methods to the <kbd>Math</kbd> object, related to trigonometry, arithmetic, and miscellaneous. This lets developers use native methods instead of external math libraries. Native methods are optimized for performance and have better decimal precision.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trigonometry-related operations</h1>
                
            
            
                
<p>Often there is a need to use mathematical functions related to trigonometry, exponential, logarithmic, and so on. JavaScript provides native methods for that to make our work easy.</p>
<p>The following example code, which shows all trigonometry-related methods that are added to the <kbd>Math</kbd> object:</p>
<pre>console.log(Math.sinh(0)); //hyberbolic sine of a value<br/>console.log(Math.cosh(0)); //hyberbolic cosine of a value<br/>console.log(Math.tanh(0)); //hyberbolic tangent of a value<br/>console.log(Math.asinh(0)); //inverse hyperbolic sine of a value<br/>console.log(Math.acosh(1)); //inverse hyperbolic cosine of a value<br/>console.log(Math.atanh(0)); //inverse hyperbolic tangent of a value<br/>console.log(Math.hypot(2, 2, 1));//Pythagoras theorem</pre>
<p>The output is as follows:</p>
<pre><strong>0</strong><br/><strong>1</strong><br/><strong>0</strong><br/><strong>0</strong><br/><strong>0</strong><br/><strong>0</strong><br/><strong>3</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Arithmetic-related operations</h1>
                
            
            
                
<p>Just as we discussed earlier, JavaScript also exposes some functions to perform logarithmic and exponential calculations, which are quite handy in a lot of situations (especially when you're creating games).</p>
<p>The following example code, which shows all arithmetic-related methods added to the <kbd>Math</kbd> object:</p>
<pre>console.log(Math.log2(16)); //log base 2<br/>console.log(Math.log10(1000)); //log base 10<br/>console.log(Math.log1p(0)); //same as log(1 + value)<br/>console.log(Math.expm1(0)); //inverse of Math.log1p()<br/>console.log(Math.cbrt(8)); //cube root of a value</pre>
<p>The output is as follows:</p>
<pre><strong>4</strong><br/><strong>3</strong><br/><strong>0</strong><br/><strong>0</strong><br/><strong>2</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Exponential operator</h1>
                
            
            
                
<p>ES7 introduced a new way to perform an exponential calculation with JavaScript, that is, with a new <kbd>**</kbd> operator. If you're coming from a Python background, you should immediately be able to relate to this. A single asterisk denotes multiplication; however, two together denote an exponential. <kbd>a**b</kbd> means <kbd>a</kbd> raised to the power <kbd>b</kbd>. Take a look at the following example:</p>
<pre>const a = 5**5;<br/>const b = Math.pow(5, 5);<br/>console.log(a);<br/>console.log(a == b);</pre>
<p>The output is as follows:</p>
<pre class="mce-root"><strong>3125</strong><br/><strong>true</strong></pre>
<p><kbd>Math.pow</kbd> was earlier used to perform an exponential calculation. Now, <kbd>a**b</kbd> means multiply <kbd>a</kbd> <kbd>b</kbd> times with itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Miscellaneous math methods</h1>
                
            
            
                
<p>Apart from the day-to-day math methods and operators we looked at earlier, there are some <em>boring</em> methods as well, which are not really used all the time. However, if you're trying to build the next online scientific calculator, here is a list of functions you should be aware of.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Math.imul(number1, number2) function</h1>
                
            
            
                
<p>The <kbd>Math.imul()</kbd> function takes two numbers as 32-bit integers and multiplies them. It returns the lower 32 bits of the result. This is the only native way to do 32-bit integer multiplication in JavaScript.<br/>
Here is an example to demonstrate this:</p>
<pre>console.log(Math.imul(590, 5000000)); //32-bit integer multiplication<br/>console.log(590 * 5000000); //64-bit floating-point multiplication</pre>
<p>The output is as follows:</p>
<pre><strong>-1344967296</strong><br/><strong>2950000000</strong></pre>
<p>Here, when multiplication was done, it produced a number so large it couldn't be stored in 32 bits; therefore, the lower bits were lost.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Math.clz32(number) function</h1>
                
            
            
                
<p>The <kbd>Math.clz32()</kbd> function returns the number of leading zero bits in the 32-bit representation of a number.<br/>
Here is an example to demonstrate this:</p>
<pre>console.log(Math.clz32(7));<br/>console.log(Math.clz32(1000));<br/>console.log(Math.clz32(295000000));</pre>
<p>The output is as follows:</p>
<pre><strong>29</strong><br/><strong>22</strong><br/><strong>3</strong></pre>
<p>The <kbd>Math.clz32()</kbd> function is usually used in DSP algorithms to normalize samples in sound and video processing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Math.sign(number) function</h1>
                
            
            
                
<p>The <kbd>Math.sign()</kbd> function returns the sign of a number, indicating whether the number is negative, positive, or zero.<br/>
Here is an example to demonstrate this:</p>
<pre>console.log(Math.sign(11));<br/>console.log(Math.sign(-11));<br/>console.log(Math.sign(0));</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>-1</strong><br/><strong>0</strong></pre>
<p>From the preceding code, we can see that the <kbd>Math.sign()</kbd> function returns <kbd>1</kbd> if the number is positive, <kbd>-1</kbd> if the number is negative, and <kbd>0</kbd> if the number is zero.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Math.trunc(number) function</h1>
                
            
            
                
<p>The <kbd>Math.trunc()</kbd> function returns the integer part of a number by removing any fractional digit. Here is an example to demonstrate this:</p>
<pre>console.log(Math.trunc(11.17));<br/>console.log(Math.trunc(-1.112));</pre>
<p>The output is as follows:</p>
<pre><strong>11</strong><br/><strong>-1</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Math.fround(number) function</h1>
                
            
            
                
<p>The <kbd>Math.fround()</kbd> function rounds a number to a 32-bit floating point value.<br/>
Here is an example to demonstrate this:</p>
<pre>console.log(Math.fround(0));<br/>console.log(Math.fround(1));<br/>console.log(Math.fround(1.137));<br/>console.log(Math.fround(1.5));</pre>
<p>The output is as follows:</p>
<pre><strong>0</strong><br/><strong>1</strong><br/><strong>1.1369999647140503</strong><br/><strong>1.5</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with strings</h1>
                
            
            
                
<p>ES6/ES7/ES8 provides new ways of creating strings and adds new properties to the global <kbd>String</kbd> object and to its instances to make working with strings easier. <strong>Strings</strong> in JavaScript lacked features and capabilities when compared with programming languages such as Python and Ruby; therefore, ES6 enhanced strings to change that.</p>
<p>Before we get into new string features, let's revise JavaScript's internal character encoding and escape sequences. In the Unicode character set, every character is represented by a base 10 decimal number called a code point. A code unit is a fixed number of bits in memory to store a code point. An encoding schema determines the length of code unit. A code unit is 8 bits if the UTF-8 encoding schema is used or 16 bits if the UTF-16 encoding schema is used. If a code point doesn't fit in a code unit, it is split into multiple code units, that is, multiple characters in a sequence representing a single character.</p>
<p>JavaScript interpreters by default interpret JavaScript source code as a sequence of UTF-16 code units. If the source code is written in the UTF-8 encoding schema then there are various ways to tell the JavaScript interpreter to interpret it as a sequence of UTF-8 code units. JavaScript strings are always a sequence of UTF-16 code points.</p>
<p>Any Unicode character with a code point less than 65,536 can be escaped in a JavaScript string or source code using the hexadecimal value of its code point, prefixed with <kbd>\u</kbd>. Escapes are six characters long. They require exactly four characters following <kbd>\u</kbd>. If the hexadecimal character code is only one, two, or three characters long, you'll need to pad it with leading zeroes. Here is an example to demonstrate this:</p>
<pre>const \u0061 = "\u0061\u0062\u0063";<br/>console.log(a); //Output is "abc"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The repeat(count) method</h1>
                
            
            
                
<p>The <kbd>repeat()</kbd> method of a string constructs and returns a new string which contains the specified number of copies on which it was called, concatenated together. Here is an example to demonstrate this:</p>
<pre>console.log("a".repeat(6)); //Output "aaaaaa"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The includes(string, index) method</h1>
                
            
            
                
<p>The <kbd>includes()</kbd> method is used to find whether one string may be found in another string, returning <kbd>true</kbd> or <kbd>false</kbd> as appropriate. Here is an example to demonstrate this:</p>
<pre>const str = "Hi, I am a JS Developer";<br/>console.log(str.includes("JS")); //Output "true"</pre>
<p>It takes an optional second parameter representing the position in the string at which to begin searching. Here is an example to demonstrate this:</p>
<pre>const str = "Hi, I am a JS Developer";<br/>console.log(str.includes("JS", 13)); // Output "false"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The startsWith(string, index) method</h1>
                
            
            
                
<p>The <kbd>startsWith()</kbd> method is used to find whether a string begins with the characters of another string, returning <kbd>true</kbd> or <kbd>false</kbd> as appropriate. Here is an example to demonstrate this:</p>
<pre>const str = "Hi, I am a JS Developer";<br/>console.log(str.startsWith('Hi, I am')); //Output "true"</pre>
<p>It takes an optional second parameter representing the position in the string at which to begin searching. Here is an example to demonstrate this:</p>
<pre>const str = "Hi, I am a JS Developer";<br/>console.log(str.startsWith('JS Developer', 11)); //Output "true"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The endsWith(string, index) function</h1>
                
            
            
                
<p>The <kbd>endsWith()</kbd> method is used to find whether a string ends with the characters of another string, returning <kbd>true</kbd> or <kbd>false</kbd> as appropriate. It also takes an optional second parameter representing the position in the string that is assumed as the end of the string. Here is an example to demonstrate this:</p>
<pre>const str = "Hi, I am a JS Developer";<br/>console.log(str.endsWith("JS Developer")); //Output "true"<br/>console.log(str.endsWith("JS", 13)); //Output "true"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The indexOf(string) function</h1>
                
            
            
                
<p>Personally, 99% of the time, I use <kbd>indexOf</kbd> instead of <kbd>startsWith</kbd> or <kbd>endsWith</kbd>, <kbd>includes</kbd> , mainly because I'm very used to it and it's very intuitive. This method will return you the position of your <em>first occurrence of</em><strong> </strong>a substring passed, in the given string. If not present, it'll return <kbd>-1</kbd>. For instance:</p>
<pre>const string = <strong>"this</strong> is an interesting book and this book is quite good as well.";<br/>console.log(string.indexOf("this"))
The output for the preceding code is: <br/><strong>0</strong></pre>
<p>This is because the substring is found at the 0<sup>th</sup> position of the bigger string. If the substring is not present in the string, <kbd>indexOf</kbd> returns <kbd>-1</kbd>.</p>
<p>Can you come up with a replacement for the <kbd>startsWith</kbd> method in terms of <kbd>indexOf</kbd>? The following is the answer!</p>
<pre>const string = "this is a sentence.";<br/>console.log(string.startsWith("this")); // true =&gt; starts with "this"<br/>console.log(string.indexOf("this") == 0); // true =&gt; starts with "this"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The lastIndexOf(string)</h1>
                
            
            
                
<p>The <kbd>lastIndexOf</kbd> method does pretty much what <kbd>indexOf</kbd> does, but it will start your search for the substring from the last. So, <kbd>indexOf</kbd> returns the position of the first occurrence of the substring and <kbd>lastIndexOf</kbd> returns the last occurrence of the substring:</p>
<pre>const string = "this is an interesting book and <br/><strong>                this</strong> book is quite good as well.";<br/>console.log(string.lastIndexOf("this"))</pre>
<p>The output from this is:</p>
<pre><strong>32</strong></pre>
<p>Although it might be a bit cumbersome to replace the <kbd>endsWith</kbd> string method with <kbd>lastIndexOf</kbd>, I still highly recommend you to give it a try and attempt to code it yourself. Once you're ready with your solution, check the following answer:</p>
<pre>const string = "this is an interesting book and <br/>                this book is quite good as well";<br/>console.log(string.endsWith("well")); // true<br/>console.log(string.lastIndexOf("well") + "well".length == string.length); // true</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The padStart(length [, padString])</h1>
                
            
            
                
<p>ES2017 (ES8) provides the <kbd>padStart()</kbd> method, which pads the given string with another given string to make the original string of the required length. The padding is done from the start of the string.</p>
<p>If no <kbd>padString</kbd> is passed, spaces are assumed by default. Take a look at the following examples:</p>
<pre>'normal'.padStart(7);<br/>'1'.padStart(3, '0');<br/>'My Awesome String'.padStart(20, '*');<br/>''.padStart(10, '*');<br/>'Hey!'.padStart(13, 'But this is long');</pre>
<p>The outputs of each line will be:</p>
<pre><strong>" normal"</strong><br/><strong>"001"</strong><br/><strong>"****My Awesome String"</strong><br/><strong>"**********"</strong><br/><strong>"But this Hey!"</strong></pre>
<p>Note that the length supplied in the <kbd>padStart</kbd> function will be the maximum length of the whole string. If the original string is already larger than the <kbd>padStart</kbd> supplied length, then no padding is applied at all.</p>
<p>Similarly, as in the last example, if <kbd>padString</kbd> is longer than the required padding, <kbd>padString</kbd> is trimmed down, starting from leftmost portion, to the required length.</p>
<p>A possible use case for this could be:</p>
<pre>for(let i=1;i&lt;=100;i++) {<br/>   console.log(`Test case ${(i+"").padStart(3, "0")}`);<br/>}</pre>
<p>Can you guess the output for the following? Here's the answer:</p>
<pre><strong>Test case 001</strong><br/><strong>Test case 002</strong><br/><strong>Test case 003</strong><br/><strong>....</strong><br/><strong>...</strong><br/><strong>Test case 010</strong><br/><strong>Test case 011</strong><br/><strong>...</strong><br/><strong>..</strong><br/><strong>Test case 100</strong></pre>
<p>This solution is tricky to achieve without the <kbd>padStart</kbd> function. You'll have to manually keep track of numbers somehow and realize when to append however many numbers of zero. Try to brainstorm an alternate solution without <kbd>padStart</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The padEnd(length [, padString])</h1>
                
            
            
                
<p><kbd>padEnd</kbd> is similar to <kbd>padStart</kbd>. The difference, as the function name says, is that it'll append the supplied padding string to the end of the string.</p>
<p>Consider the following examples again:</p>
<pre>'normal'.padEnd(7);<br/>'1'.padEnd(3, '0');<br/>'My Awesome String'.padEnd(20, '*');<br/>''.padEnd(10, '*');<br/>'Hey!'.padEnd(13, 'But this is long');</pre>
<p>The output for this is:</p>
<pre><strong>"normal "</strong><br/><strong>"100"</strong><br/><strong>"My Awesome String***"</strong><br/><strong>"**********"</strong><br/><strong>"Hey!But this "</strong></pre>
<p>You can also use <kbd>padStart</kbd> and <kbd>padEnd</kbd> together, like:<kbd>"1".padStart(5, "*").padEnd(10, "*")</kbd> , to produce <kbd>****1****</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Template strings</h1>
                
            
            
                
<p><strong>Template strings</strong> are just a new literal for creating strings, which makes various things easier. They provide features such as embedded expressions, multiline strings, string interpolation, string formatting, string tagging, and so on. They are always processed and converted to a normal JavaScript string on runtime; therefore, they can be used wherever we use normal strings.</p>
<p>Template strings are written using backticks instead of single or double quotes. Here is an example of a simple template string:</p>
<pre>let str1 = `hello!!!`; //template string<br/>let str2 = "hello!!!";<br/>console.log(str1 === str2); //output "true"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Expressions</h1>
                
            
            
                
<p>Template strings also bring something called "expressions" to JavaScript. Earlier, there was no other choice than merely concatenating strings together. For example, to embed expressions within normal strings, you would do something like this:</p>
<pre>var a = 20;<br/>var b = 10;<br/>var c = "JavaScript";<br/>var str = "My age is " + (a + b) + " and I love " + c;<br/>console.log(str);</pre>
<p class="mce-root">The output is as follows:</p>
<pre class="mce-root"><strong>My age is 30 and I love JavaScript</strong></pre>
<p>However, now template strings make it much easier to embed expressions in strings. Template strings can contain expressions in them. The expressions are placed in placeholders indicated by a dollar sign and curly brackets, that is, <kbd>${expressions}</kbd>. The resolved value of expressions in the placeholders and the text between them is passed to a function to resolve the template string to a normal string. The default function just concatenates the parts into a single string. If we use a custom function to process the string parts, then the template string is called a <strong>tagged template string</strong> and the custom function is called a <strong>tag function</strong>.<br/>
Here is an example that shows how to embed expressions in a template string:</p>
<pre>const a = 20;<br/>const b = 10;<br/>const c = "JavaScript";<br/>const str = `My age is ${a+b} and I love ${c}`;<br/>console.log(str);</pre>
<p>The output is as follows:</p>
<pre><strong>My age is 30 and I love JavaScript</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Tagged template literals</h1>
                
            
            
                
<p>Let's create a tagged template string, that is, process the template string literal using a function. Let's implement the tag function to do the same thing as the default function. Here is an example to demonstrate this:</p>
<pre>const tag = function(strings, aPLUSb, aSTARb) {<br/>  // strings is: ['a+b equals', 'and a*b equals']<br/>  // aPLUSb is: 30<br/>  // aSTARb is: 200<br/>  return 'SURPRISE!';<br/>};<br/><br/>const a = 20;<br/>const b = 10;<br/><br/>let str = tag `a+b equals ${a+b} and a*b equals ${a*b}`;<br/>console.log(str);</pre>
<p class="mce-root">The output is as follows:</p>
<pre><strong>SURPRISE!</strong></pre>
<p>What just happened? Using a tag function, whatever you return is the final value assigned to the variable. The first argument, strings, contains all the <em>static</em> strings in your template literal, as an array. The elements are separated whenever an expression is found. Further arguments are the dynamic values you receive after resolving the expressions inside the template literal.</p>
<p>So, if you modify the <kbd>aPLUSb</kbd> variable inside the <kbd>tag</kbd> function, then in the final result the value will be updated. Here's what I mean:</p>
<pre>const tag = function(strings, aPLUSb, aSTARb) {<br/>  // strings is: ['a+b equals', 'and a*b equals']<br/>  // aPLUSb is: 30<br/>  // aSTARb is: 200<br/>  aPLUSb = 200;<br/>  aSTARb = 30;<br/>  return `a+b equals ${aPLUSb} and a*b equals ${aSTARb}`;<br/>};<br/><br/>const a = 20;<br/>const b = 10;<br/>&gt;<br/>let str = tag `a+b equals ${a+b} and a*b equals ${a*b}`;<br/>console.log(str);</pre>
<p>Now the output is:</p>
<pre><strong>a+b equals 200 and a*b equals 30</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Multiline strings</h1>
                
            
            
                
<p>Template strings provide a new way to create strings that contain multiple lines of text.<br/>
In ES5, we need to use the <kbd>\n</kbd> newline character to add new line breaks. Here is an example to demonstrate this:</p>
<pre>console.log("1\n2\n3");</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong></pre>
<p>In ES6, using a multiline string, we can simply write:</p>
<pre>console.log(`1<br/>2<br/>3`);</pre>
<p>The output is as follows:</p>
<pre><strong>1</strong><br/><strong>2</strong><br/><strong>3</strong></pre>
<p>In the preceding code, we simply included new lines where we needed to place <kbd>\n</kbd>. While converting the template string to the normal string, the new lines are converted to <kbd>\n</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Raw strings</h1>
                
            
            
                
<p>A <strong>raw string</strong> is a normal string in which escaped characters aren't interpreted. We can create a raw string using a template string. We can get a raw version of a template string using the <kbd>String.raw</kbd> tag function. Here is an example to demonstrate this:</p>
<pre>let s = String.raw `xy\n${ 1 + 1 }z`;<br/>console.log(s);</pre>
<p>The output is as follows:</p>
<pre><strong> xy\n2z</strong></pre>
<p>Here <kbd>\n</kbd> is not interpreted as a newline character. Instead, it is a raw string consisting of two characters, that is, <kbd>\</kbd> and <kbd>n</kbd>. The length of variable <kbd>s</kbd> would be <kbd>6</kbd>. If you create a tagged function and you want to return the raw string, then use the raw property of the first argument.</p>
<p>The raw property is an array that holds raw versions of the strings of the first argument. Here is an example to demonstrate this:</p>
<pre>let tag = function(strings, ...values) {<br/>  return strings.raw[0]<br/>};<br/>let str = tag `Hello \n World!!!`;<br/>console.log(str);</pre>
<p>The output is as follows:</p>
<pre><strong>Hello \n World!!!</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Escape sequence problem with template literals</h1>
                
            
            
                
<p>Tagged templates are awesome! However, there are certain rules for escape sequences (if used) inside a template literal:</p>
<ul>
<li>Anything starting with <kbd>\u</kbd> will be regarded as a Unicode escape sequence</li>
<li>Anything starting with <kbd>\x</kbd> will be regarded as a hexadecimal escape sequence</li>
<li>Anything starting with <kbd>\</kbd> and then a digit will be regarded as an octal escape sequence</li>
</ul>
<p>Therefore, as of now, even with tagged templates, you cannot make use of languages such as LaTeX with template strings because of the syntax of these languages.</p>
<p>LaTeX is a document preparation system usually used to write complicated equations, math formulas, and so on. Using an escape sequence such as <em>`E &amp;= \frac{mc^2}{\sqrt{1-\frac{v^2}{c^2}}}`</em> would result in a fancy formula:<br/>
<img class="fm-editor-equation" height="52" src="img/a3cc77b2-f6be-40e0-b50d-49bcf2a6aea1.png" style="color: #333333;font-size: 1em" width="93"/>.</p>
<p>ES2018 that is the ES9 spec aims to resolve this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Arrays</h1>
                
            
            
                
<p>There are some new properties added to the global <kbd>Array</kbd> object and to its instances to make working with arrays easier. Arrays in JavaScript lacked features and capabilities when compared with programming languages such as Python and Ruby. Let's take a look at some popular methods associated with arrays and their use cases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Array.from(iterable, mapFunc, this) method</h1>
                
            
            
                
<p>The <kbd>Array.from()</kbd> method creates a new array instance from an iterable object. The first argument is a reference to the iterable object. The second argument is optional and is a callback (known as the <strong>Map function</strong>) that is called for every element of the iterable object. The third argument is also optional and is the value of this inside the Map function.</p>
<p>Here is an example to demonstrate this:</p>
<pre>let str = "0123";<br/>let arr = Array.from(str, value =&gt; parseInt(value) * 5);<br/>console.log(arr);</pre>
<p>The output is:</p>
<pre> <strong>[0, 5, 10, 15]</strong>.</pre>
<p><kbd>Array.from</kbd> would be extremely useful in converting an "array-like" structure to the actual array. For example, when working with the <strong>Document Object Model</strong> (<strong>DOM</strong>) (discussed in <a href="e281222c-b2ee-434a-a2ca-fc2648d01e3f.xhtml">Chapter 10</a>, <em>Storage APIs in JavaScript</em>), quite often, when you get hold of a lot of elements in the DOM tree, you'd like to use methods such as <kbd>forEach</kbd> on them. However, since methods such as<kbd>forEach</kbd> only exist for actual arrays, you cannot use them. But, once you convert that to an actual array with the <kbd>Array.from</kbd> method, you're good to go. A dummy example would be like this:</p>
<pre>const arr = document.querySelectorAll('div');<br/>/* arr.forEach( item =&gt; console.log(item.tagName) ) */ // =&gt; wrong<br/>Array.from(arr).forEach( item =&gt; console.log(item.tagName) ); <br/>// correct</pre>
<p><kbd>arr.forEach</kbd> is wrong, as <kbd>arr</kbd> is not actually an array. It is "array-like" in structure (more on this later).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Array.of(values…) method</h1>
                
            
            
                
<p>The <kbd>Array.of()</kbd> method is an alternative to the <kbd>Array</kbd> constructor for creating arrays. When using the <kbd>Array</kbd> constructor, if we pass only one argument, that too a number, then the <kbd>Array</kbd> constructor constructs an empty array with the array length property equal to the passed number instead of creating an array of one element with that number in it. Therefore the <kbd>Array.of()</kbd> method was introduced to resolve this issue.</p>
<p>Here is an example to demonstrate this:</p>
<pre>let arr1 = Array(2);<br/>let arr2 = Array.of(2);<br/>console.log(arr1);<br/>console.log(arr2);</pre>
<p>The output is as follows:</p>
<pre><strong>[undefined, undefined]</strong><br/><strong>[2]</strong></pre>
<p>You should use <kbd>Array.of()</kbd> instead of an <kbd>Array</kbd> constructor when you are constructing a new array instance dynamically, that is when you don't know the type of values and the number of elements.</p>
<p>Instead of browser showing [undefined, undefined], your browser might show [undefined x 2] or [empty x 2] as the output.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The fill(value, startIndex, endIndex) method</h1>
                
            
            
                
<p>The <kbd>fill()</kbd> method of an array fills all the elements of the array from <kbd>startIndex</kbd> to <kbd>endIndex</kbd> (not including <kbd>endIndex</kbd>) with a given value. Remember that the <kbd>startIndex</kbd> and <kbd>endIndex</kbd> arguments are optional; therefore, if they are not provided then the whole array is filled with the given value.</p>
<p>If only <kbd>startIndex</kbd> is provided then <kbd>endIndex</kbd> defaults to the length of the array minus 1. If <kbd>startIndex</kbd> is negative then it's treated as the length of the array plus <kbd>startIndex</kbd>. If <kbd>endIndex</kbd> is negative, it is treated as the length of the array plus <kbd>endIndex</kbd>.</p>
<p>Here is an example to demonstrate this:</p>
<pre>let arr1 = [1, 2, 3, 4];<br/>let arr2 = [1, 2, 3, 4];<br/>let arr3 = [1, 2, 3, 4];<br/>let arr4 = [1, 2, 3, 4];<br/>let arr5 = [1, 2, 3, 4];<br/>arr1.fill(5);<br/>arr2.fill(5, 1, 2);<br/>arr3.fill(5, 1, 3);<br/>arr4.fill(5, -3, 2);<br/>arr5.fill(5, 0, -2);<br/>console.log(arr1);<br/>console.log(arr2);<br/>console.log(arr3);<br/>console.log(arr4);<br/>console.log(arr5);</pre>
<p>The output is as follows:</p>
<pre><strong>[5,5,5,5]</strong><br/><strong>[1,5,3,4]</strong><br/><strong>[1,5,5,4]</strong><br/><strong>[1,5,3,4]</strong><br/><strong>[5,5,3,4]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The includes() method</h1>
                
            
            
                
<p>The <kbd>includes()</kbd> method returns <kbd>true</kbd> if a certain supplied element exists in an array, and returns <kbd>false</kbd> if it doesn't exist in that array. </p>
<p>This is simple enough to understand with just an example:</p>
<pre>const arr = [0, 1, 1, 2, 3, 5, 8, 13];<br/>arr.includes(0); // true<br/>arr.includes(13); // true<br/>arr.includes(21); // false</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The includes() versus the indexOf() method</h1>
                
            
            
                
<p>Just like for strings, <kbd>indexOf</kbd> exists for arrays as well and as you expect, it'll return the position of the element in the array. Take a look:</p>
<pre>const arr = ['apple', 'mango', 'banana'];<br/>console.log(arr.indexOf('apple')); // 0<br/>console.log(arr.indexOf('mango')); // 1<br/>console.log(arr.indexOf('apple') &gt;= 0); // true =&gt; apple exists<br/>console.log(arr.includes('apple')); // true =&gt; apple exists<br/>console.log(arr.indexOf('pineapple') &gt;= 0); // false =&gt; pineapple  <br/>                                            // doesn't exists<br/>console.log(arr.includes('pineapple')); // false =&gt; pineapple doesn't <br/>                                        //exists</pre>
<p>So what's the difference? There's not really a difference unless we talk about <kbd>NaN</kbd> and all that weird stuff. For instance:</p>
<pre>const arr = ['Some elements I like', NaN, 1337, true, false, 0017];<br/>console.log(arr.includes(NaN)); // true<br/>console.log(arr.indexOf(NaN) &gt;= 0); // false =&gt; indexOf says there is <br/>                                    //no NaN element in array</pre>
<p>This is because, under the hood, <kbd>indexOf</kbd> uses the equality check (<kbd>===</kbd>), which obviously fails on <kbd>NaN</kbd> , as discussed earlier. Therefore, <kbd>includes</kbd> is a better choice in the case of arrays.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The find(testingFunc) method</h1>
                
            
            
                
<p>The <kbd>+</kbd> method of an array returns an array element if it satisfies the provided testing function. Otherwise, it returns undefined.</p>
<p>The <kbd>find()</kbd> method takes two arguments; that is, the first argument is the testing function and the second argument is the value of this in the testing function. The second argument is optional.</p>
<p>The testing function has three parameters: the first parameter is the array element being processed, the second parameter is the index of the current element being processed, and the third parameter is the array on which <kbd>find()</kbd> is called.</p>
<p>The testing function needs to return <kbd>true</kbd> to satisfy a value. The <kbd>find()</kbd> method returns the first element which satisfies the provided testing function.</p>
<p>Here is an example to demonstrate the <kbd>find()</kbd> method:</p>
<pre>const x = 12;<br/>const arr = [11, 12, 13];<br/>const result = arr.find( (value, index, array) =&gt; value == x )<br/>console.log(result); //Output "12"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The findIndex(testingFunc) method</h1>
                
            
            
                
<p>The <kbd>findIndex()</kbd> method is similar to the <kbd>find()</kbd> method. The <kbd>findIndex()</kbd> method returns the index of the satisfied array element instead of the element itself. Take a look at this example:</p>
<pre>const x = 12;<br/>const arr = [11, 12, 13];<br/>const result = arr.findIndex( (value, index, array) =&gt; value == x );<br/>console.log(result); </pre>
<p>The output is <kbd>1</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The copyWithin(targetIndex, startIndex, endIndex) function</h1>
                
            
            
                
<p>The <kbd>copyWithin()</kbd> method of an array is used to copy the sequence of values of the array to a different position in the array.</p>
<p>The <kbd>copyWithin()</kbd> method takes three arguments: the first argument represents the target index to which copy elements the second argument represents the index position from which start copying and the third argument represents the index, that is, where copying elements  should end.</p>
<p>The third argument is optional and if not provided then it defaults to <em>length-1,</em> where length is the length of the array. If <kbd>startIndex</kbd> is negative then it's calculated as <em>length+startIndex</em>. Similarly, if <kbd>endIndex</kbd> is negative then it's calculated as <em>length+endIndex</em>.</p>
<p>Here is an example to demonstrate this:</p>
<pre>const arr1 = [1, 2, 3, 4, 5];<br/>const arr2 = [1, 2, 3, 4, 5];<br/>const arr3 = [1, 2, 3, 4, 5];<br/>const arr4 = [1, 2, 3, 4, 5];<br/>arr1.copyWithin(1, 2, 4);<br/>arr2.copyWithin(0, 1);<br/>arr3.copyWithin(1, -2);<br/>arr4.copyWithin(1, -2, -1);<br/>console.log(arr1);<br/>console.log(arr2);<br/>console.log(arr3);<br/>console.log(arr4);</pre>
<p>The output is as follows:</p>
<pre><strong>[1,3,4,4,5]</strong><br/><strong>[2,3,4,5,5]</strong><br/><strong>[1,4,5,4,5]</strong><br/><strong>[1,4,3,4,5]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The entries(), keys(), and values() methods</h1>
                
            
            
                
<p>The <kbd>entries()</kbd> method of an array returns an iterable object that contains the key/value pairs for each index of the array. Similarly, the <kbd>keys()</kbd> method of an array returns an iterable object that contains keys for each of the indexes in the array.</p>
<p>Similarly, the <kbd>values()</kbd> method of an array returns an iterable object that contains values of the array. The iterable object returned by the <kbd>entries()</kbd> method stores the key/value pairs in the form of arrays.</p>
<p>The iterable object returned by these functions is not an array.</p>
<p>Here is an example to demonstrate this:</p>
<pre>const arr = ['a', 'b', 'c'];<br/>const entries = arr.entries();<br/>const keys = arr.keys();<br/>const values = arr.values();<br/>console.log(...entries);<br/>console.log(...keys);<br/>console.log(...values);</pre>
<p>The output is as follows:</p>
<pre><strong>0,a 1,b 2,c</strong><br/><strong>0 1 2</strong><br/><strong>a b c</strong></pre>
<div><kbd>arr.values()</kbd> is still very experimental and not implemented in most browsers at the time of writing (November 2017).</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Array iteration</h1>
                
            
            
                
<p>You'll find yourself iterating over arrays most of the time during development: arrays from REST APIs, arrays from user input, arrays from here, arrays from there. Therefore, it is essential to get hands-on with some important tools you can use to iterate over arrays.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The map() method</h1>
                
            
            
                
<p>The <kbd>map()</kbd> method creates and returns a new array and passes every element of that array to the supplied function. Take a look at this example:</p>
<pre>const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br/>const squaredNums = arr.map( num =&gt; num**2 );<br/>console.log(squaredNums);</pre>
<p>The output is:</p>
<pre><strong>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</strong></pre>
<p>In the preceding function, when you run <kbd>map</kbd> on <kbd>arr</kbd>, every value is passed one by one into the supplied function. The value is contained as <kbd>num</kbd>. Since we're using the ES6 arrow function notation, everything looks extremely concise and neat.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The filter() method</h1>
                
            
            
                
<p>The <kbd>filter()</kbd> method creates a new array containing only the elements of a given array which pass a test defined by the programmer.</p>
<p>For example:</p>
<pre>const arr = ['Mike', 'John', 'Mehul', 'Rahul', 'Akshay', 'Deep','Om', 'Ryan'];<br/>const namesWithOnly4Letters = arr.filter( name =&gt; name.length == 4 );<br/>console.log(namesWithOnly4Letters);</pre>
<p>The output is:</p>
<pre><strong>["Mike", "John", "Deep", "Ryan"]</strong></pre>
<p>As you can see, in the filter our supplied function always returns a Boolean. Whenever the inside function returns <kbd>true</kbd>, that particular element is included in <kbd>namesWithOnly4Letters</kbd>. Whenever it returns <kbd>false</kbd>, it is not.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">forEach() method</h1>
                
            
            
                
<p>The <kbd>forEach()</kbd> method calls the given function for every element in the array. It is different from the <kbd>map</kbd> function because <kbd>map</kbd> creates a copy of the original array on the basis of what you return from the <kbd>map</kbd> function. But <kbd>foreach</kbd> simply runs a function on every element. It doesn't care about what you return from the function.</p>
<p>Take a look at this:</p>
<pre>const arr = [1, 2, 3, 4];<br/>arr.forEach( (value, index) =&gt; console.log(`arr[${index}] = ${value}`) );</pre>
<p>The output is as follows:</p>
<pre><strong>arr[0] = 1</strong><br/><strong>arr[1] = 2</strong><br/><strong>arr[2] = 3</strong><br/><strong>arr[3] = 4</strong></pre>
<p>Clearly, when you want to just do a bunch of operations with the elements of an array, use <kbd>forEach</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">some() method</h1>
                
            
            
                
<p>The <kbd>some()</kbd> method will check if any element in a given array passes a supplied test (with a function). If it finds an element which passes the test, it'll stop there and will not run further (and will return <kbd>true</kbd>). Otherwise, it'll return <kbd>false</kbd>.</p>
<p>Here's an example:</p>
<pre>const arr = [1, 3, 5, 7, 9, 10, 11];<br/>const isAnyElementEven = arr.some( elem =&gt; { <br/>   console.log('Checking '+elem); <br/>   return elem % 2 == 0<br/>});<br/>console.log(isAnyElementEven); // true</pre>
<p>The output is as follows:</p>
<pre><strong>Checking 1</strong><br/><strong>Checking 3</strong><br/><strong>Checking 5</strong><br/><strong>Checking 7</strong><br/><strong>Checking 9</strong><br/><strong>Checking 10</strong><br/><strong>true</strong></pre>
<p>Notice that it stops at <kbd>10</kbd> once the test is passed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Collections</h1>
                
            
            
                
<p>A <strong>collection</strong> is an object that stores multiple elements as a single unit. ES6 introduced various new collection objects to provide better ways of storing and organizing data.</p>
<p>The array was the only collection object available in ES5. Now we have ArrayBuffers, SharedArrayBuffers, Typed Arrays, Sets, and Maps, which are built in collection objects.</p>
<p>Let's explore the different collection objects provided in JavaScript.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ArrayBuffer</h1>
                
            
            
                
<p>Elements of arrays can be of any type, such as strings, numbers, objects, and so on. Arrays can grow dynamically. The problem with arrays is that they are slow in terms of execution time and occupy more memory. This causes issues while developing applications that require too much computation and deal with plenty of numbers. Therefore array buffers were introduced to tackle this issue.</p>
<p>An <strong>array buffer</strong> is a collection of 8-bit blocks in memory. Every block is an array buffer element. The size of an array buffer needs to be decided while creating it; therefore, it cannot grow dynamically. Array buffers can only store numbers. All blocks are initialized to the number 0 on the creation of an array buffer.</p>
<p>An array buffer object is created using the <kbd>ArrayBuffer</kbd> constructor:</p>
<pre>const buffer = new ArrayBuffer(80); //80 bytes size</pre>
<p>Reading from and writing values into an <kbd>ArrayBuffer</kbd> object can be done using a <kbd>DateView</kbd> object. It's not compulsory that only 8 bits are used to represent a number. We can use 8, 16, 32, and 64 bits to represent a number. Here is an example, which shows how to create a <kbd>DateView</kbd> object and read/write to an <kbd>ArrayBuffer</kbd> object:</p>
<pre>const buffer = new ArrayBuffer(80);<br/>const view = new DataView(buffer);<br/>view.setInt32(8,22,false);<br/>const number = view.getInt32(8,false);<br/>console.log(number); //Output "22"</pre>
<p>Here we created a <kbd>DataView</kbd> object using the <kbd>DataView</kbd> constructor. A <kbd>DataView</kbd> object provides several methods to read and write numbers into an <kbd>ArrayBuffer</kbd> object. Here we used the <kbd>setInt32()</kbd> method, which uses 32 bits to store a provided number. All the methods of a <kbd>DataView</kbd> object that are used to write data to an <kbd>ArrayBuffer</kbd> object take three arguments. The first argument represents the offset, that is, the byte we want to write the number to. The second argument is the number to be stored. And the third argument is a Boolean type that represents the endian of the number like <kbd>false</kbd> represents a big-endian.</p>
<p>Similarly, all the methods of a <kbd>DataView</kbd> object that are used to read data from an <kbd>ArrayBuffer</kbd> object take two arguments. The first argument is the offset and the second argument represents the endian used.</p>
<p>Here are other functions for storing numbers provided by a <kbd>DataView</kbd> object:</p>
<ul>
<li><kbd>setInt8</kbd>: Uses 8 bits to store a number. It takes a signed integer (-ve or +ve).</li>
<li><kbd>setUint8</kbd>: Uses 8 bits to store a number. It takes an unsigned integer (+ve).</li>
<li><kbd>setInt16</kbd>: Uses 16 bits to store a number. It takes a signed integer.</li>
<li><kbd>setUint16</kbd>: Uses 16 bits to store a number. It takes an unsigned integer.</li>
<li><kbd>setInt32</kbd>: Uses 32 bits to store a number. It takes a signed integer.</li>
<li><kbd>setUint32</kbd>: Uses 32 bits to store a number. It takes an unsigned integer.</li>
<li><kbd>setFloat32</kbd>: Uses 32 bits to store a number. It takes a signed decimal number.</li>
<li><kbd>setFloat64</kbd>: Uses 64 bits to store a number. It takes a signed decimal number.</li>
</ul>
<p>Here are other functions for retrieving stored numbers by a <kbd>DataView</kbd> object:</p>
<ul>
<li><kbd>getInt8</kbd>: Reads 8 bits. Returns a signed integer number.</li>
<li><kbd>getUint8</kbd>: Reads 8 bits. Returns an unsigned integer number.</li>
<li><kbd>getInt16</kbd>: Reads 16 bits. Returns a signed integer number.</li>
<li><kbd>getUint16</kbd>: Reads 16 bits. Returns an unsigned integer number.</li>
<li><kbd>getInt32</kbd>: Reads 32 bits. Returns a signed integer number.</li>
<li><kbd>getUint32</kbd>: Reads 32 bits. Returns an unsigned integer number.</li>
<li><kbd>getFloat32</kbd>: Reads 32 bits. Returns a signed decimal number.</li>
<li><kbd>getFloat64</kbd>: Reads 64 bits. Returns a signed decimal number.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Typed arrays</h1>
                
            
            
                
<p>We saw how to read and write numbers in array buffers. But the method was very cumbersome because we had to call a function every time. Typed arrays let us read and write to an <kbd>ArrayBuffer</kbd> object just like we do for normal arrays.</p>
<p>A <strong>typed array</strong> acts as a wrapper for an <kbd>ArrayBuffer</kbd> object and treats data from an <kbd>ArrayBuffer</kbd> object as a sequence of n-bit numbers. The <kbd>n</kbd> value depends on how we created the typed array.</p>
<p>Next is a code example that demonstrates how to create an <kbd>ArrayBuffer</kbd> object and read/write to it using a typed array:</p>
<pre>const buffer = new ArrayBuffer(80);<br/>const typed_array = new Float64Array(buffer);<br/>typed_array[4] = 11;<br/>console.log(typed_array.length);<br/>console.log(typed_array[4]);</pre>
<p>The output is:</p>
<pre><strong>10</strong><br/><strong>11</strong></pre>
<p>Here we created a typed array using the <kbd>Float64Array</kbd> constructor. It, therefore, treats data in <kbd>ArrayBuffer</kbd> as a sequence of 64-bit signed decimal numbers. Here the <kbd>ArrayBuffer</kbd> object size was 640 bits; therefore, only 10 64-bit numbers can be stored.</p>
<p>Similarly, there are other typed array constructors to represent data in <kbd>ArrayBuffer</kbd> as a sequence of different bit numbers. Here is the list:</p>
<ul>
<li><kbd>Int8Array</kbd>: Represents 8-bit signed integers</li>
<li><kbd>Uint8Array</kbd>: Represents 8-bit unsigned integers</li>
<li><kbd>Int16Array</kbd>: Represents 16-bit signed integers</li>
<li><kbd>Uint16Array</kbd>: Represents 16-bit unsigned integers</li>
<li><kbd>Int32Array</kbd>: Represents 32-bit signed integers</li>
<li><kbd>Uint32Array</kbd>: Represents 32-bit unsigned integers</li>
<li><kbd>Float32Array</kbd>: Represents 32-bit signed decimal number</li>
<li><kbd>Float64Array</kbd>: Represents 64-bit signed decimal number</li>
</ul>
<p>Typed arrays provide all the methods that are also provided by normal JavaScript arrays. They also implement the iterable protocol; therefore, they can be used as an iterable object.</p>
<p>We'll need to use typed arrays in Chapter 12 - Shared memory and Atomics</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Set</h1>
                
            
            
                
<p>A <strong>Set </strong>is a collection of unique values of any data type. The values in a Set are arranged in insertion order. A Set is created using the <kbd>Set</kbd> constructor. Here is an example:</p>
<pre>const set1 = new Set();<br/>const set2 = new Set("Hello!!!");</pre>
<p>Here <kbd>set1</kbd> is an empty Set, whereas <kbd>set2</kbd> was created using values of an iterable object, that is, the characters of a string and the string, was not empty; therefore, <kbd>set2</kbd> is non-empty. The following example code demonstrates various operations that can be done on a Set:</p>
<pre>let set = new Set("Hello!!!");<br/>set.add(12); //add 12<br/>console.log(set.has("!")); //check if value exists<br/>console.log(set.size);<br/>set.delete(12); //delete 12<br/>console.log(...set);<br/>set.clear(); //delete all values</pre>
<p>The output is as follows:</p>
<pre><strong>true<br/>6<br/>H e l o !</strong></pre>
<p>Here we added nine items to the <kbd>Set</kbd> object but the size was only six because the Set automatically deletes duplicate values. The characters <kbd>l</kbd> and <kbd>!</kbd> were repeated multiple times. The <kbd>Set</kbd> object also implements the iterable protocol so they can be used as an iterable object.</p>
<p>Sets are used when you want to maintain a collection of values and check if a value exists instead of retrieving a value. For example, Sets can be used as an alternative to an array if you only use the <kbd>indexOf()</kbd> method of the array in your code to check if a value exists.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WeakSet</h1>
                
            
            
                
<p>Here are the differences between <kbd>Set</kbd> and <kbd>WeakSet</kbd> objects:</p>
<ul>
<li>A <kbd>Set</kbd> can store primitive types and object references whereas a <kbd>WeakSet</kbd> object can only store object references</li>
<li>One important features <kbd>WeakSet</kbd> objects is that if there is no other reference to an object stored in a <kbd>WeakSet</kbd> object then they are garbage-collected</li>
<li>Lastly, a <kbd>WeakSet</kbd> object is not enumerable: that is, you cannot find its size; it also doesn't implement the iterable protocol</li>
</ul>
<p>Apart from these three differences, <kbd>WeakSet</kbd> behaves exactly the same way as <kbd>Set</kbd>. Everything else apart from these three differences is same between a <kbd>Set</kbd> and <kbd>WeakSet</kbd> object.</p>
<p>A <kbd>WeakSet</kbd> object is created using the <kbd>WeakSet</kbd> constructor. You cannot pass an iterable object as an argument to a <kbd>WeakSet</kbd> object.</p>
<p>Here is an example to demonstrate <kbd>WeakSet</kbd>:</p>
<pre>let weakset = new WeakSet();<br/>(function(){ <br/>   let a = {}; <br/>   weakset.add(a);<br/>})();  //here 'a' is garbage collected from weakset<br/>console.log(weakset.size); //output "undefined"<br/>console.log(...weakset); //Exception is thrown<br/>weakset.clear(); //Exception, no such function</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Map</h1>
                
            
            
                
<p>A <strong>Map</strong> is a collection of key/value pairs. Keys and values of a Map can be of any data type. Key/value pairs are arranged in insertion order. A <kbd>Map</kbd> object is created using the <kbd>Map</kbd> constructor.</p>
<p>Here is an example, which demonstrates how to create a <kbd>Map</kbd> object and do various operations on it:</p>
<pre>let map = new Map();<br/>let o = {n: 1};<br/>map.set(o, "A"); //add<br/>map.set("2", 9);<br/>console.log(map.has("2")); //check if key exists<br/>console.log(map.get(o)); //retrieve value associated with key<br/>console.log(...map);<br/>map.delete("2"); //delete key and associated value<br/>map.clear(); //delete everything<br/>//create a map from iterable object<br/>let map_1 = new Map([[1, 2], [4, 5]]);<br/>console.log(map_1.size); //number of keys</pre>
<p>The output is as follows:</p>
<pre><strong>true<br/>A<br/>[object Object],A 2,9<br/>2</strong></pre>
<p>While creating a <kbd>Map</kbd> object from an iterable object, we need to make sure that the values returned by the iterable object are arrays, each of length <kbd>2</kbd>; that is, index <kbd>0</kbd> is the key and index <kbd>1</kbd> is the value.</p>
<p>If we try to add a key that already exists then it's overwritten. <kbd>Map</kbd> objects also implement the iterable protocol and can therefore also be used as an iterable object. While iterating Maps using the iterable protocol, they return arrays with key/value pairs as you can see in the preceding example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WeakMap</h1>
                
            
            
                
<p><kbd>WeakMap</kbd>, as the name suggests, is an object in which keys are weakly referenced to the key/value pairs. That means that values can be anything. The keys are weakly referenced as keys are objects.</p>
<p>Here are the differences between <kbd>Map</kbd> and <kbd>WeakMap</kbd> objects:</p>
<ul>
<li>Keys of a <kbd>Map</kbd> object can be of primitive types or object references but keys in a <kbd>WeakMap</kbd> object can only be object references</li>
<li>One of the important features of a  <kbd>WeakMap</kbd> object is that if there is no other reference to an object that is referenced by a key then the key is garbage-collected</li>
<li>Lastly, a  <kbd>WeakMap</kbd> object is not enumerable, that is, you cannot find its size and it doesn't implement the iterable protocol</li>
</ul>
<p>In every other particular, apart from these three differences <kbd>Map</kbd> and <kbd>WeakMap</kbd> objects are similar.</p>
<p><kbd>WeakMap</kbd> is created using a <kbd>WeakMap</kbd> constructor. Here is an example that demonstrates its usage:</p>
<pre>let weakmap = new WeakMap();<br/><br/>(function(){ <br/>  let o = {n: 1}; <br/>  weakmap.set(o, "A");<br/>})();  // here 'o' key is garbage collected<br/><br/>let s = {m: 1};<br/>weakmap.set(s, "B");<br/>console.log(weakmap.get(s));<br/>console.log(...weakmap); // exception thrown<br/>weakmap.delete(s);<br/>weakmap.clear(); // Exception, no such function<br/>let weakmap_1 = new WeakMap([[{}, 2], [{}, 5]]); //this works<br/>console.log(weakmap_1.size); //undefined</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Objects</h1>
                
            
            
                
<p><strong>Objects</strong> have existed in JavaScript for a long time. They form the backbone of JavaScript, as almost every data type can be associated with <em>objects.</em> (<kbd>new String()</kbd>, <kbd>new Number()</kbd>, <kbd>new Boolean()</kbd>, and so on). You'll often find yourself working and manipulating objects all the time when working with web applications or JavaScript in general.</p>
<p>ES6, ES2016 (ES7), and ES2017 (ES8) introduce a lot of new properties and methods associated with objects. Let us take a look at them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object.values()</h1>
                
            
            
                
<p>ES8 introduced the <kbd>Object.values()</kbd> method so that a programmer can retrieve all the values of an object as an array. This was earlier possible by manually iterating over every property of the object and storing its value in the array.</p>
<p>Here's an example:</p>
<pre>const obj = {<br/>    book: "Learning ES2017 (ES8)",<br/>    author: "Mehul Mohan",<br/>    publisher: "Packt",<br/>    useful: true<br/>};<br/>console.log(Object.values(obj));</pre>
<p>The output will be:</p>
<pre><strong>["Learning ES2017 (ES8)", "Mehul Mohan", "Packt", true]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Object.entries()</h1>
                
            
            
                
<p><kbd>Object.entries()</kbd> can be used to convert an object into a key/value pair in the form of an array. That means your object will be converted into a 2D array (at the simplest level), with each element being another array containing a key and value. Take a look at this:</p>
<pre>const obj = {<br/>    book: "Learning ES2017 (ES8)",<br/>    author: "Mehul Mohan",<br/>    publisher: "Packt",<br/>    useful: true<br/>};<br/>console.log(Object.entries(obj));</pre>
<p>The output will be:</p>
<pre><strong>[["book","Learning ES2017 (ES8)"],["author","Mehul Mohan"],["publisher","Packt"],["useful",true]]</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The __proto__ property</h1>
                
            
            
                
<p>JavaScript objects have an internal <kbd>[[prototype]]</kbd> property that references the object's prototype, that is, the object it inherits: the <strong>prototypal inheritance model</strong>, which JavaScript uses. To read the property, we had to use <kbd>Object.getPrototypeof()</kbd> and to create a new object with a given prototype, we had to use the <kbd>Object.create()</kbd> method. A <kbd>[[prototype]]</kbd> property cannot be directly read or be modified.</p>
<p>Inheriting was cumbersome due to the nature of the <kbd>[[prototype]]</kbd> property; therefore, some browsers added a special <kbd>__proto__</kbd> property in objects, which is an accessor property that exposes the internal <kbd>[[prototype]]</kbd> property and makes working with prototypes easier. The <kbd>__proto__</kbd> property was not standardized in ES5, but due to its popularity, it was standardized in later versions.</p>
<p>Here is an example to demonstrate this:</p>
<pre>//In ES5<br/>var x = {prop1: 12};<br/>var y = Object.create(x, {prop2: {value: 13}});<br/>console.log(y.prop1); //Output "12"<br/>console.log(y.prop2); //Output "13"<br/>console.log(x); // Output: {prop1: 12}<br/>console.log(y); // Output: {prop2: 13}<br/><br/>//In ES6 onwards<br/>let a = {prop1: 12, __proto__: {prop2: 13}};<br/>console.log(a.prop1); //Output "12"<br/>console.log(a.prop2); //Output "13"<br/>console.log(a); // Output: {prop1: 12}<br/>console.log(a.__proto__); // Output: {prop2: 13}</pre>
<p>Carefully observe:</p>
<ul>
<li>In the ES5 example, object <kbd>y</kbd> <em>inherits</em> from object <kbd>x</kbd>; therefore, when you simply use <kbd>console.log</kbd> on the object <kbd>y</kbd>, the properties it inherits from object <kbd>x</kbd> are not visible directly (or rather they are hidden). However, when you try to access <kbd>y.prop2</kbd>, JavaScript doesn't find it on object <kbd>y</kbd>, so it looks on the <kbd>__proto__</kbd> chain (which is how JavaScript is built to work) and finds that there is, in fact, a reference available for <kbd>prop2</kbd> on the proto chain. However, it was not possible to edit that directly in ES5.</li>
<li>With ES6/ES7/ES8/ES.next and onwards, you can directly add values to the prototype chain of the object.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Object.is(value1, value2) method</h1>
                
            
            
                
<p>The <kbd>Object.is()</kbd> method determines whether two values are equal or not. It is similar to the <kbd>===</kbd> operator but there are some special cases for the <kbd>Object.is()</kbd> method. Here is an example that demonstrates special cases:</p>
<pre>console.log(Object.is(0, -0));<br/>console.log(0 === -0);<br/>console.log(Object.is(NaN, 0/0));<br/>console.log(NaN === 0/0);<br/>console.log(Object.is(NaN, NaN));<br/>console.log(NaN ===NaN);</pre>
<p>The output is as follows:</p>
<pre><strong>false</strong><br/><strong>true</strong><br/><strong>true</strong><br/><strong>false</strong><br/><strong>true</strong><br/><strong>false</strong></pre>
<p>Here's a handy table you might want to look at for the differences between 0, ==, ===,<strong> </strong>and Object.is<strong>:</strong></p>
<div><img height="556" src="img/7c77be8d-f28d-4aa9-ab30-825303628f2b.png" width="520"/></div>
<p>While it might seem intuitive that <kbd>Object.is</kbd> can compare if two given objects are same, that is not the case. <kbd>x = {foo: 1}</kbd> and <kbd>y = {foo: 1}</kbd> are <em>not</em> same for all three operators (<kbd>==</kbd>, <kbd>===</kbd>, and <kbd>Object.is</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Object.setPrototypeOf(object, prototype) method</h1>
                
            
            
                
<p>The <kbd>Object.setPrototypeOf()</kbd> method is just another way to assign the <kbd>[[prototype]]</kbd> property of an object, which we have just discussed. You can either use this method or directly work with the <kbd>__proto__</kbd> property. However, working with a method is a cleaner and easier-to-read approach. Here is an example to demonstrate this:</p>
<pre>let x = {x: 12};<br/>let y = {y: 13};<br/>Object.setPrototypeOf(y, x);<br/>console.log(y.x); //Output "12"<br/>console.log(y.y); //Output "13"</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Object.assign(targetObj, sourceObjs…) method</h1>
                
            
            
                
<p>The <kbd>Object.assign()</kbd> method is used is used to copy the values of all enumerable own properties from one or more source objects to a target object. This method will return <kbd>targetObj</kbd>. Here is an example which demonstrates this:</p>
<pre>let x = {x: 12};<br/>let y = {y: 13, __proto__: x};<br/>let z = {z: 14, get b() {return 2;}, q: {}};<br/>Object.defineProperty(z, "z", {enumerable: false});<br/>let m = {};<br/>Object.assign(m, y, z);<br/>console.log(m.y);<br/>console.log(m.z);<br/>console.log(m.b);<br/>console.log(m.x);<br/>console.log(m.q == z.q);</pre>
<p>The output is as follows:</p>
<pre><strong>13</strong><br/><strong>undefined</strong><br/><strong>2</strong><br/><strong>undefined</strong><br/><strong>true</strong></pre>
<p>Here is a list of important things to keep in mind while using the <kbd>Object.assign()</kbd> method:</p>
<ul>
<li>It invokes getters on the sources and setters on the target.</li>
<li>It just assigns values of the properties of the source to the new or existing properties of the target.</li>
<li>It doesn't copy the <kbd>[[prototype]]</kbd> property of sources.</li>
<li>JavaScript property names can be strings or symbols. <kbd>Object.assign()</kbd> copies both.</li>
<li>Property definitions are not copied from sources; therefore, you need to use <kbd>Object.getOwnPropertyDescriptor()</kbd> instead.</li>
<li>It ignores copying keys with null and undefined values.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Object.getOwnPropertyDescriptors()</h1>
                
            
            
                
<p>Introduced in ES8, the <kbd>Object.getOwnPropertyDescriptors()</kbd> method will return all the property descriptors for a given object. What does that mean exactly? Let's take a look:</p>
<pre>const details = { <br/>  get food1() { return 'tasty'; },<br/>  get food2() { return 'bad'; }<br/>};<br/>Object.getOwnPropertyDescriptors(details);</pre>
<p>The output produced is:</p>
<pre><strong>{</strong><br/><strong>    food1: {</strong><br/><strong>        configurable: true,</strong><br/><strong>        enumerable: true,</strong><br/><strong>        get: function food1(){}, //the getter function</strong><br/><strong>        set: undefined</strong><br/><strong>    },</strong><br/><strong>    food2: {</strong><br/><strong>        configurable: true,</strong><br/><strong>        enumerable: true,</strong><br/><strong>        get: function food2(){}, //the getter function</strong><br/><strong>        set: undefined</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<p>The <kbd>get()</kbd> function fires when you try to access the property (but when you also want to do a bunch of stuff first). So, when you do <kbd>details.food1</kbd>, <kbd>tasty</kbd> is returned.</p>
<p>The practical usage of this is mostly in <strong>Decorators</strong> (which is a whole new topic) and creating a shallow clone, as shown here:</p>
<pre>const x = { foo: 1, __proto__: { bar: 2 } };<br/>const y = Object.create( <br/>  Object.getPrototypeOf(x), <br/>  Object.getOwnPropertyDescriptors(x) <br/>);<br/>console.log(y.__proto__); // { bar: 2 }</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about new features added in ES8, ES7, and ES6 for working with numbers, strings, arrays, and objects. We saw how arrays impact performance in math-rich applications and how array buffers can be used instead. We also walked through the new collection objects provided by ES8.</p>
<p>In the next chapter, we will take a look at the Symbols and Iteration protocol, and we will also explore the <kbd>yield</kbd> keyword and generators. A lot of exciting and cutting-edge stuff is coming your way! Hold tight!</p>
<p class="mce-root"/>


            

            
        
    </body></html>