<html><head></head><body>
        

                            
                    <h1 class="header-title">Client Patterns</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Modeling concurrency with dependent futures</li>
<li class="mce-root">Backend For Frontend</li>
<li>Consistent RPC with HTTP and JSON</li>
<li>Using gRPC </li>
<li>Using Thrift</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>When building a service-oriented architecture, it's easy to get stuck thinking about the most general way to represent the domain entities and behaviors that are controlled by a particular service. The truth is, we rarely use services in general ways—we usually combine calls to multiple services and use the responses to create a new, aggregate response body. We often make service calls in ways that resemble how we used to aggregate data from a database, so we have to think about relationships between disparate types in our system and how best to model data dependencies.</p>
<p>We also want to make client development easy. When designing general-purpose APIs, it's easy to get stuck thinking about the right way to do things (if you've ever heard someone critique an API design as not being RESTful, this might sound familiar) instead of thinking about the easy way to do things. A service isn't much good if a client needs to make dozens of calls to it in order to get the data they need. When designing systems that involve microservices, it's essential to think about data aggregation from the client's perspective.</p>
<p>Clients have to think about more than just the services they are invoking, but often they have to consider what instance of those services they want to configure themselves to invoke. It's common to have staging or testing environments, and these get much more complicated in the microservices architectures. </p>
<p>In this chapter, we'll discuss techniques for modeling dependent service calls and aggregating responses from various services to create client-specific APIs. We'll also discuss managing different microservices environments and making RPC consistent with JSON and HTTP, as well as the gRPC and Thrift binary protocols.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modeling concurrency with dependent futures</h1>
                
            
            
                
<p>We saw in a previous recipe that we can use asynchronous methods to make service calls that are handled in separate threads. This is essential because blocking on network I/O would severely limit the number of incoming requests our service would be able to handle. A service that blocks on the network I/O would only be able to handle a relatively small number of requests per process, requiring us to spend more resources on horizontal scaling. In the example we used, the message service needed to call the social graph service for two users, the sender, and the recipient of a message, and make sure that the two users followed each other before allowing a message to be sent. We modified our request methods to return the <kbd>CompletableFuture</kbd> instances that wrapped the response, and then waited on all of the results to finish before verifying that the sender and recipient of the message had a symmetric following relationship. This model works fine when you're making multiple requests that are not dependent (you do not need the response from one request to make the subsequent request). In this situation, where we have dependent service calls, we need a better way to model that dependency.</p>
<p>In our <kbd>pichat</kbd> application, we need to render a screen that lists information about users we follow. In order to do that, we need to call the social-graph service to get a list of users and then call the users service to get details such as the display name and avatar for each user. This use case involves making dependent service calls. We need an effective way of modeling this kind of service invocation while still scheduling asynchronous operations in ways that allow them to be run in separate threads of execution. </p>
<p>In this recipe, we'll demonstrate this by using composition of <kbd>CompletableFuture</kbd> as well as Java 8 streams to model dependent service invocations. We'll create a sample client application that calls a social service to get a list of users that the logged in user follows, and then calls the user service to get details for each user.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In order to model dependent asynchronous service calls, we'll take advantage of two features in Java 8. Streams are useful for processing data, so we'll use them in our example to extract usernames from a list of followings and map a function to each element. Java 8's <kbd>CompletableFuture</kbd> can be composed, which allows us to naturally express dependencies between futures. </p>
<p>In this recipe, we'll create a simple client application that calls the social service for a list of users that the current user follows. For each user returned, the application will get user details from the users service. We'll build this example as a command-line application for easy demonstration purposes, but it could just as well be another microservice, or a web or mobile client. </p>
<p>In order to build a command-line application that has all of the capabilities of a Spring Boot application, we're going to cheat a little and just implement <kbd>CommandLineRunner</kbd> and call <kbd>System.exit(0);</kbd> in the <kbd>run()</kbd> method.  </p>
<p>Before we start building our application, we'll outline the responses from our hypothetical social service and users service services. We can mimic these services by just hosting the appropriate JSON response on a local web server. We'll use ports <kbd>8000</kbd> and <kbd>8001</kbd> for the social service and users service, respectively. The social service has an endpoint, <kbd>/followings/:username</kbd>, that returns a JSON object with a list of followings for the specified username. The JSON response will look like the following snippet:</p>
<pre>{<br/>  "username": "paulosman",<br/>  "followings": [<br/>    "johnsmith",<br/>    "janesmith",<br/>    "petersmith"<br/>  ]<br/>}</pre>
<p>The users service has an endpoint called <kbd>/users/:username</kbd>, which will return a JSON representation of the user's details, including the username, full name, and avatar URL:</p>
<pre>{<br/>  "username": "paulosman",<br/>  "full_name": "Paul Osman",<br/>  "avatar_url": "http://foo.com/pic.jpg"<br/>}</pre>
<p>Now that we have our services and we've outlined the responses we expect from each, let's go ahead and build our client application by performing the following steps:</p>
<ol>
<li>Create a new Java/Gradle application called <kbd>UserDetailsClient</kbd> with the following <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="color: black;padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle<br/>        -plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>    compile group: 'org.springframework.boot', <br/>    name: 'spring-boot-starter-web'<br/>}</pre>
<ol start="2">
<li>Create a package called <kbd>com.packtpub.microservices.ch04.user.models</kbd> and a new class called <kbd>UserDetails</kbd>. We'll use this class to model our response from the users service:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch04.user.models;<br/><br/>import com.fasterxml.jackson.annotation.JsonProperty;<br/><br/>public class UserDetails {<br/>    private String username;<br/><br/>    @JsonProperty("display_name")<br/>    private String displayName;<br/><br/>    @JsonProperty("avatar_url")<br/>    private String avatarUrl;<br/><br/>    public UserDetails() {}<br/><br/>    public UserDetails(String username, String displayName, <br/>    String avatarUrl) {<br/>        this.username = username;<br/>        this.displayName = displayName;<br/>        this.avatarUrl = avatarUrl;<br/>    }<br/><br/>    public String getUsername() {<br/>        return username;<br/>    }<br/><br/>    public void setUsername(String username) {<br/>        this.username = username;<br/>    }<br/><br/>    public String getDisplayName() {<br/>        return displayName;<br/>    }<br/><br/>    public void setDisplayName(String displayName) {<br/>        this.displayName = displayName;<br/>    }<br/><br/>    public String getAvatarUrl() {<br/>        return avatarUrl;<br/>    }<br/><br/>    public void setAvatarUrl(String avatarUrl) {<br/>        this.avatarUrl = avatarUrl;<br/>    }<br/><br/>    public String toString() {<br/>        return String.format("[UserDetails: %s, %s, %s]", username, <br/>        displayName, avatarUrl);<br/>    }<br/>}</pre>
<ol start="3">
<li>Create another class in the <kbd>com.packtpub.microservices.ch04.user.models</kbd> package called <kbd>Followings</kbd>. This will be used to model the response from the social service:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.user.models;<br/><br/>import java.util.List;<br/><br/>public class Followings {<br/>    private String username;<br/>    private List&lt;String&gt; followings;<br/><br/>    public Followings() {}<br/><br/>    public Followings(String username, List&lt;String&gt; followings) {<br/>        this.username = username;<br/>        this.followings = followings;<br/>    }<br/><br/>    public String getUsername() {<br/>        return username;<br/>    }<br/><br/>    public void setUsername(String username) {<br/>        this.username = username;<br/>    }<br/><br/>    public List&lt;String&gt; getFollowings() {<br/>        return followings;<br/>    }<br/><br/>    public void setFollowings(List&lt;String&gt; followings) {<br/>        this.followings = followings;<br/>    }<br/><br/>    public String toString() {<br/>        return String.format("[Followings for username: %s - %s]", <br/>        username, followings);<br/>    }<br/>}</pre>
<ol start="4">
<li>Create a service representation for calling our social service. Predictably enough, we'll call it <kbd>SocialService</kbd> and put it in the <kbd>com.packtpub.microservices.ch04.user.services</kbd> package:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch04.user.services;<br/><br/>import com.packtpub.microservices.models.Followings;<br/>import org.springframework.boot.web.client.RestTemplateBuilder;<br/>import org.springframework.scheduling.annotation.Async;<br/>import org.springframework.stereotype.Service;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>import java.util.concurrent.CompletableFuture;<br/><br/>@Service<br/>public class SocialService {<br/><br/>    private final RestTemplate restTemplate;<br/><br/>    public SocialService(RestTemplateBuilder restTemplateBuilder) {<br/>        this.restTemplate = restTemplateBuilder.build();<br/>    }<br/><br/>    @Async<br/>    public CompletableFuture&lt;Followings&gt; <br/>    getFollowings(String username) {<br/>        String url = String.format("http://localhost:8000/followings/<br/>        %s", username);<br/>        Followings followings = restTemplate.getForObject(url, <br/>        Followings.class);<br/>        return CompletableFuture.completedFuture(followings);<br/>    }<br/>}</pre>
<ol start="5">
<li>Create a service representation for our users service. Appropriately, we'll call the class <kbd>UserService</kbd> in the same package:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.services;<br/><br/>import com.packtpub.microservices.models.Followings;<br/>import com.packtpub.microservices.models.UserDetails;<br/>import org.springframework.boot.web.client.RestTemplateBuilder;<br/>import org.springframework.scheduling.annotation.Async;<br/>import org.springframework.stereotype.Service;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>import java.util.concurrent.CompletableFuture;<br/><br/>@Service<br/>public class UserService {<br/>    private final RestTemplate restTemplate;<br/><br/>    public UserService(RestTemplateBuilder restTemplateBuilder) {<br/>        this.restTemplate = restTemplateBuilder.build();<br/>    }<br/><br/>    @Async<br/>    public CompletableFuture&lt;UserDetails&gt; <br/>    getUserDetails(String username) {<br/>        String url = String.format("http://localhost:8001/users/<br/>        %s", username);<br/>        UserDetails userDetails = restTemplate.getForObject(url, <br/>        UserDetails.class);<br/>        return CompletableFuture.completedFuture(userDetails);<br/>    }<br/>}</pre>
<ol start="6">
<li>We now have classes to model the responses from our services, and service objects to represent the services we're going to invoke. It's time to tie it all together by creating our main class, which will call these two services in a dependent manner, using the composability of futures to model the dependency. Create a new class called <kbd>UserDetailsClient</kbd>, as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch04.user;<br/><br/>import com.packtpub.microservices.models.Followings;<br/>import com.packtpub.microservices.models.UserDetails;<br/>import com.packtpub.microservices.services.SocialService;<br/>import com.packtpub.microservices.services.UserService;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.boot.CommandLineRunner;<br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/><br/>import java.util.List;<br/>import java.util.concurrent.CompletableFuture;<br/>import java.util.concurrent.Future;<br/>import java.util.stream.Collectors;<br/><br/>@SpringBootApplication<br/>public class UserDetailsClient implements CommandLineRunner {<br/><br/>    public UserDetailsClient() {}<br/><br/>    @Autowired<br/>    private SocialService socialService;<br/><br/>    @Autowired<br/>    private UserService userService;<br/><br/>    public CompletableFuture&lt;List&lt;UserDetails&gt;&gt; <br/>    getFollowingDetails(String username) {<br/>        return socialService.getFollowings(username).thenApply(f -&gt;<br/>                f.getFollowings().stream().map(u -&gt;userService.<br/>                getUserDetails(u)).map(CompletableFuture::join).<br/>                collect(Collectors.toList()));<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(UserDetailsClient.class, args);<br/>    }<br/><br/>    @Override<br/>    public void run(String... args) throws Exception {<br/>        Future&lt;List&lt;UserDetails&gt;&gt; users = getFollowingDetails<br/>        ("paulosman");<br/>        System.out.println(users.get());<br/>        System.out.println("Heyo");<br/>        System.exit(0);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The magic really happens in the following method:</p>
<pre style="padding-left: 60px">CompletableFuture&lt;List&lt;UserDetails&gt;&gt; getFollowingDetails(String username) <br/>{<br/>  return socialService.getFollowings(username).thenApply(<br/>    f -&gt; f.getFollowings().stream().map(u -&gt;<br/>      userService.getUserDetails(u)).map(<br/>        CompletableFuture::join).collect(Collectors.toList()));<br/>}</pre>
<p>Recall that the <kbd>getFollowings</kbd> method in <kbd>SocialService</kbd> returns <kbd>CompletableFuture&lt;Followings&gt;</kbd>. <kbd>CompletableFuture</kbd> has a method, called <kbd>thenApply</kbd>, that takes the eventual result of the future (<kbd>Followings</kbd>) and applies it to be passed in the Lambda. In this case, we're taking <kbd>Followings</kbd> and using the Java 8 Stream API to call map on the list of usernames returned by the social service. The map applies each username to a function that calls <kbd>getUserDetails</kbd> on <kbd>UserService</kbd>. The <kbd>CompletableFuture::join</kbd> method is used to turn <kbd>List&lt;Future&lt;T&gt;&gt;</kbd> into <kbd>Future&lt;List&lt;T&gt;&gt;</kbd>, which is a common operation when performing these kinds of dependent service invocations. Finally, we collect the results and return them as a list. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Backend for frontend</h1>
                
            
            
                
<p>When software shifted from desktop and web-based applications to mobile applications, distributed architectures became much more prevalent. It became a focus for many organizations to build a platform instead of just a product. This approach places a much larger emphasis on APIs that a product can expose to clients as well as third-party partners. As APIs became a given for any web-based application, it became popular to try to build client applications (mobile or JavaScript) on the same API used to provide functionality to the third-party partners. The idea is that if you exposed one well-designed, general-purpose API, you would have everything you need to build any kind of application. The general architecture looked like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/35eb08b6-09ec-4a77-ada8-ceaef3f92fea.png" style="width:35.42em;height:21.50em;"/></p>
<p>The flaw in this approach is that it assumes that the needs of your first-party (mobile and web) and third-party (partner) applications are always going to be aligned, and this is rarely the case. More often than not, you want to encourage certain kinds of functionality in the third-party integrations and a different set of functionality in first-party clients. Additionally, you want to be much more tolerant (encouraging, even) of changes in first-party clients—your client applications will evolve and constantly be changing their API requirements. Finally, you cannot anticipate all of the possible use cases third-party partners will have for your API, so a general-purpose design is beneficial, but you will be able to anticipate the needs of your mobile and web applications, and being too general in your API design can often hamper your product's needs. A good example of this is a server-side website that is rewritten as a single-page JavaScript application. With a general-purpose API, this kind of project can result in page views that require dozens of <kbd>XMLHttpRequests</kbd> to render a single page view. </p>
<p><strong>Backend For Frontend</strong> (<strong>BFF</strong>) is an architectural pattern that involves creating separate, <strong>bespoke APIs</strong> for different classes of client applications. Instead of a single API layer in your architecture, separate BFF layers can be developed depending on how many categories of client applications you want to support. How you categorize clients is completely up to the needs of your business. You may decide to have a single BFF layer for all mobile clients, or you may divide them into an iOS BFF and an Android BFF. Similarly, you may choose to have a separate BFF layer for your web application and your third-party partners (what used to be the primary driver for your single API):</p>
<div><img src="img/76cb2cdd-9224-4315-bb96-ef2fd73f4b8c.png"/></div>
<p>In this system, each category of client makes requests to its own BFF layer, which can then aggregate calls to downstream services and build a cohesive, bespoke API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In order to design and build a BFF layer, we should first design the API. In fact, we've already done this. In the previous recipe, we demonstrated using <kbd>CompletableFuture</kbd> to asynchronously make a request to our systems, social service and then for each user returned, make asynchronous requests to the user-details-service to fetch certain user profile information. This is a great use case for a BFF layer for our mobile apps. Imagine that our mobile app has a screen that shows a list of users that the user follows, with basic information such as their avatar, username, and display name. Since the social graph information (the list of users the user is following) and the user profile information (avatar, username, and display name) are the responsibility of two separate services, it's cumbersome to require our mobile clients to aggregate calls to these services to render a following page. Instead, we can create a mobile BFF layer that handles this aggregation and returns a convenient response to the client. Our request endpoint would be as follows:</p>
<pre>GET /users/:user_id/following</pre>
<p>And the response body we expect to get back should be as follows:</p>
<pre>{<br/>  "username": "paulosman",<br/>  "followings": [<br/>    {<br/>      "username": "friendlyuser",<br/>      "display_name": "Friendly User",<br/>      "avatar_url": "http://example.com/pic.jpg"<br/>    },<br/>    {<br/>      ...<br/>    }<br/>  ]<br/>}</pre>
<p>As we can see, the BFF will return a response with all of the information we need to render a following screen in our mobile app:</p>
<ol>
<li>Create a new Gradle/Java project called <kbd>bff-mobile</kbd> with the following <kbd>build.gradle</kbd> file:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'org.springframework.boot', <br/>        name: 'spring-boot-gradle-plugin', <br/>        version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>    compile group: 'org.springframework.boot', <br/>    name: 'spring-boot-starter-web'<br/>}</pre>
<ol start="2">
<li>Create a new package called <kbd>com.packtpub.microservices.mobilebff</kbd> and a new class called <kbd>Main</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.mobilebff;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/><br/>@SpringBootApplication<br/>public class Main {<br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Main.class, args);<br/>    }<br/>}</pre>
<ol start="3">
<li>Create a new package called <kbd>com.packtpub.microservices.ch04.mobilebff.models</kbd> and a new class called <kbd>User</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.mobilebff.models;<br/><br/>import com.fasterxml.jackson.annotation.JsonProperty;<br/><br/>public class User {<br/>    private String username;<br/><br/>    @JsonProperty("display_name")<br/>    private String displayName;<br/><br/>    @JsonProperty("avatar_url")<br/>    private String avatarUrl;<br/><br/>    public User() {}<br/><br/>    public User(String username, String displayName, <br/>    String avatarUrl) {<br/>        this.username = username;<br/>        this.displayName = displayName;<br/>        this.avatarUrl = avatarUrl;<br/>    }<br/><br/>    public String getUsername() {<br/>        return username;<br/>    }<br/><br/>    public void setUsername(String username) {<br/>        this.username = username;<br/>    }<br/><br/>    public String getDisplayName() {<br/>        return displayName;<br/>    }<br/><br/>    public void setDisplayName(String displayName) {<br/>        this.displayName = displayName;<br/>    }<br/><br/>    public String getAvatarUrl() {<br/>        return avatarUrl;<br/>    }<br/><br/>    public void setAvatarUrl(String avatarUrl) {<br/>        this.avatarUrl = avatarUrl;<br/>    }<br/><br/>    public String toString() {<br/>        return String.format(<br/>                "[User username:%s, displayName:%s, avatarUrl:%s]",<br/>                username, displayName, avatarUrl);<br/>    }<br/>}</pre>
<ol start="4">
<li>Create another model, called <kbd>Followings</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.mobilebff.models;<br/><br/>import java.util.List;<br/><br/>public class Followings {<br/>    private String username;<br/><br/>    private List&lt;String&gt; followings;<br/><br/>    public Followings() {}<br/><br/>    public Followings(String username, List&lt;String&gt; followings) {<br/>        this.username = username;<br/>        this.followings = followings;<br/>    }<br/><br/>    public String getUsername() {<br/>        return username;<br/>    }<br/><br/>    public void setUsername(String username) {<br/>        this.username = username;<br/>    }<br/><br/>    public List&lt;String&gt; getFollowings() {<br/>        return followings;<br/>    }<br/><br/>    public void setFollowings(List&lt;String&gt; followings) {<br/>        this.followings = followings;<br/>    }<br/>}</pre>
<ol start="5">
<li>The last model we'll create is called <kbd>HydratedFollowings</kbd>. This is similar to the <kbd>Followings</kbd> model, but instead of storing the list of users as a string, it contains a list of the <kbd>User</kbd> objects:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.mobilebff.models;<br/><br/>import java.util.List;<br/><br/>public class HydratedFollowings {<br/>    private String username;<br/><br/>    private List&lt;User&gt; followings;<br/><br/>    public HydratedFollowings() {}<br/><br/>    public HydratedFollowings(String username, List&lt;User&gt; <br/>    followings) {<br/>        this.username = username;<br/>        this.followings = followings;<br/>    }<br/><br/>    public String getUsername() {<br/>        return username;<br/>    }<br/><br/>    public void setUsername(String username) {<br/>        this.username = username;<br/>    }<br/><br/>    public List&lt;User&gt; getFollowings() {<br/>        return followings;<br/>    }<br/><br/>    public void setFollowings(List&lt;User&gt; followings) {<br/>        this.followings = followings;<br/>    }<br/>}</pre>
<ol start="6">
<li>Create the service clients. Create a new package called <kbd>com.packtpub.microservices.ch04.mobilebff.services</kbd> and a new class called <kbd>SocialGraphService</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.mobilebff.services;<br/><br/>import com.packtpub.microservices.ch04.mobilebff.models.Followings;<br/>import org.springframework.boot.web.client.RestTemplateBuilder;<br/>import org.springframework.scheduling.annotation.Async;<br/>import org.springframework.stereotype.Service;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>import java.util.concurrent.CompletableFuture;<br/><br/>@Service<br/>public class SocialGraphService {<br/><br/>    private final RestTemplate restTemplate;<br/><br/>    public SocialGraphService(RestTemplateBuilder <br/>    restTemplateBuilder) {<br/>        this.restTemplate = restTemplateBuilder.build();<br/>    }<br/><br/>    @Async<br/>    public CompletableFuture&lt;Followings&gt; <br/>    getFollowing(String username) {<br/>        String url = String.format("http://localhost:4567/followings/<br/>        %s", username);<br/>        Followings followings = restTemplate.getForObject(url, <br/>        Followings.class);<br/>        return CompletableFuture.completedFuture(followings);<br/>    }<br/>}</pre>
<ol start="7">
<li>Create a new class, called <kbd>UsersService</kbd>, that will serve as a client for our users service:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.mobilebff.services;<br/><br/>import com.packtpub.microservices.ch04.mobilebff.models.User;<br/>import org.springframework.boot.web.client.RestTemplateBuilder;<br/>import org.springframework.scheduling.annotation.Async;<br/>import org.springframework.stereotype.Service;<br/>import org.springframework.web.client.RestTemplate;<br/><br/>import java.util.concurrent.CompletableFuture;<br/><br/>@Service<br/>public class UsersService {<br/><br/>    private final RestTemplate restTemplate;<br/><br/>    public UsersService(RestTemplateBuilder restTemplateBuilder) {<br/>        this.restTemplate = restTemplateBuilder.build();<br/>    }<br/><br/>    @Async<br/>    public CompletableFuture&lt;User&gt; getUserDetails(String username) {<br/>        String url = String.format("http://localhost:4568/users/<br/>        %s", username);<br/>        User user = restTemplate.getForObject(url, User.class);<br/>        return CompletableFuture.completedFuture(user);<br/>    }<br/>}</pre>
<ol start="8">
<li>Let's tie it all together by creating our controller that exposes the endpoint. This code will look familiar if you completed the previous recipe, since we're using exactly the same pattern to model dependent asynchronous service invocations. Create a package called <kbd>com.packtpub.microservices.ch04.mobilebff.controllers</kbd> and a new class called <kbd>UsersController</kbd>:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.mobilebff.controllers;<br/><br/>import com.packtpub.microservices.ch04.mobilebff.models.HydratedFollowings;<br/>import com.packtpub.microservices.ch04.mobilebff.models.User;<br/>import com.packtpub.microservices.ch04.mobilebff.services.SocialGraphService;<br/>import com.packtpub.microservices.ch04.mobilebff.services.UsersService;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import java.util.List;<br/>import java.util.concurrent.CompletableFuture;<br/>import java.util.concurrent.ExecutionException;<br/>import java.util.stream.Collectors;<br/><br/>@RestController<br/>public class UsersController {<br/><br/>    @Autowired<br/>    private SocialGraphService socialGraphService;<br/><br/>    @Autowired<br/>    private UsersService userService;<br/><br/>    @RequestMapping(path = "/users/{username}/followings", <br/>    method = RequestMethod.GET)<br/>    public HydratedFollowings getFollowings(@PathVariable String username) <br/>    throws ExecutionException, InterruptedException {<br/>        CompletableFuture&lt;List&lt;User&gt;&gt; users = socialGraphService.getFollowing<br/>        (username).thenApply(f -&gt; f.getFollowings().stream().map(<br/>                        u -&gt; userService.getUserDetails(u)).map(<br/>                                CompletableFuture::join).collect(Collectors.toList()));<br/>        return new HydratedFollowings(username, users.get());<br/>    }<br/>}</pre>
<ol start="9">
<li>That's it! Run the application and make a <kbd>GET</kbd> request to <kbd>/users/username/followings</kbd>. You should get back a fully-hydrated JSON response with the user's username and details for each of the users the user follows.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Consistent RPC with HTTP and JSON</h1>
                
            
            
                
<p>When building multiple microservices, consistency and conventions between services start to make a real impact. When problems arise in a microservice architecture, you can end up spending time debugging many services—being able to make certain assumptions about the nature of a particular service interface can save a lot of time and mental energy. Having a consistent way of doing RPC also allows you to codify certain concerns into libraries that can be easily shared between services. Things such as authentication, how headers should be interpreted, what information is included in a response body, and how to request paginated responses can be made simpler by having a consistent approach. Additionally, the way that errors are reported should be made as consistent as possible. </p>
<p>Because the microservice architectures commonly consist of services written in different programming languages by different teams, any efforts toward consistent RPC semantics will have to be implemented, probably as libraries, in as many languages as you have used to build services. This can be cumbersome, but is well worth the effort for the consistency clients can assume when speaking to a variety of services.</p>
<p>In this recipe, we'll focus on services written in Java using Spring Boot. We'll write a custom serializer to present resources and collections of resources in a consistent manner, including pagination information. We'll then modify our message service to use our new serializer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In this recipe, we'll create a wrapper class to represent collections of resources with pagination information. We'll also use the <kbd>JsonRootName</kbd> annotation from the <kbd>jackson</kbd> library to make single-resource representations consistent. The following code should be added to the message service, which was introduced in a previous recipe:</p>
<ol>
<li>Create a new class called <kbd>ResourceCollection</kbd>. This class will be a regular POJO with fields to represent the page number, a list of items, and a URL that can be used to access the next page in a collection:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch04.message.models;<br/><br/>import com.fasterxml.jackson.annotation.JsonProperty;<br/>import com.fasterxml.jackson.annotation.JsonRootName;<br/><br/>import java.util.List;<br/><br/>@JsonRootName("result")<br/>public class ResourceCollection&lt;T&gt; {<br/><br/>    private int page;<br/><br/>    @JsonProperty("next_url")<br/>    private String nextUrl;<br/><br/>    private List&lt;T&gt; items;<br/><br/>    public ResourceCollection(List&lt;T&gt; items, int page, String nextUrl) {<br/>        this.items = items;<br/>        this.page = page;<br/>        this.nextUrl = nextUrl;<br/>    }<br/><br/>    public int getPage() {<br/>        return page;<br/>    }<br/><br/>    public void setPage(int pageNumber) {<br/>        this.page = page;<br/>    }<br/><br/>    public String getNextUrl() {<br/>        return nextUrl;<br/>    }<br/><br/>    public void setNextUrl(String nextUrl) {<br/>        this.nextUrl = nextUrl;<br/>    }<br/><br/>    public List&lt;T&gt; getItems() {<br/>        return items;<br/>    }<br/><br/>    public void setItems(List&lt;T&gt; items) {<br/>        this.items = items;<br/>    }<br/>}</pre>
<ol start="2">
<li>Create or modify the <kbd>Message</kbd> model. We're using the <kbd>JsonRootName</kbd> annotation here to wrap the <kbd>Message</kbd> representation in a single JSON object with the <kbd>item</kbd> key. In order to have consistent representations, we should add these to all models that our services expose as a resource:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.message.models;<br/><br/>import com.fasterxml.jackson.annotation.JsonRootName;<br/><br/>@JsonRootName("item")<br/>public class Message {<br/>    private String id;<br/>    private String toUser;<br/>    private String fromUser;<br/>    private String body;<br/><br/>    public Message(String id, String toUser, String fromUser, String body) {<br/>        this.id = id;<br/>        this.toUser = toUser;<br/>        this.fromUser = fromUser;<br/>        this.body = body;<br/>    }<br/><br/>    public String getId() {<br/>        return id;<br/>    }<br/><br/>    public void setId(String id) {<br/>        this.id = id;<br/>    }<br/><br/>    public String getToUser() {<br/>        return toUser;<br/>    }<br/><br/>    public void setToUser(String toUser) {<br/>        this.toUser = toUser;<br/>    }<br/><br/>    public String getFromUser() {<br/>        return fromUser;<br/>    }<br/><br/>    public void setFromUser(String fromUser) {<br/>        this.fromUser = fromUser;<br/>    }<br/><br/>    public String getBody() {<br/>        return body;<br/>    }<br/><br/>    public void setBody(String body) {<br/>        this.body = body;<br/>    }<br/>}</pre>
<ol start="3">
<li>The following controller returns a list of messages and a specific message. We wrap the list of messages in the <kbd>ResourceCollection</kbd> class that we created previously: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch04.message.controllers;<br/><br/>import com.packtpub.microservices.ch04.message.models.Message;<br/>import com.packtpub.microservices.ch04.message.models.ResourceCollection;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import javax.servlet.http.HttpServletRequest;<br/>import java.util.List;<br/>import java.util.stream.Collectors;<br/>import java.util.stream.Stream;<br/><br/>@RestController<br/>public class MessageController {<br/><br/>    @RequestMapping(value = "/messages", method = RequestMethod.GET)<br/>    public ResourceCollection&lt;Message&gt; messages(@RequestParam(name="page", required=false, defaultValue="1") int page,<br/>                                       HttpServletRequest request) {<br/>        List&lt;Message&gt; messages = Stream.of(<br/>                new Message("1234","paul", "veronica", "hello!"),<br/>                new Message("5678","meghann", "paul", "hello!")<br/>        ).collect(Collectors.toList());<br/><br/>        String nextUrl = String.format("%s?page=%d", request.getRequestURI(), page + 1);<br/><br/>        return new ResourceCollection&lt;&gt;(messages, page, nextUrl);<br/>    }<br/><br/>    @RequestMapping(value = "/messages/{id}", method = RequestMethod.GET)<br/>    public Message message(@PathVariable("id") String id) {<br/>        return new Message(id, "paul", "veronica", "hi dad");<br/>    }<br/>}</pre>
<ol start="4">
<li>If you test requesting a collection of items by making a request to <kbd>/messages</kbd>, the following JSON should now be returned:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">{<br/>    "result": {<br/>        "page": 1,<br/>        "items": [<br/>            {<br/>                "id": "1234",<br/>                "toUser": "paul",<br/>                "fromUser": "veronica",<br/>                "body": "hello!"<br/>            },<br/>            {<br/>                "id": "5678",<br/>                "toUser": "meghann",<br/>                "fromUser": "paul",<br/>                "body": "hello!"<br/>            }<br/>        ],<br/>        "next_url": "/messages?page=2"<br/>    }<br/>}</pre>
<ol start="5">
<li>The following JSON should be returned for a single resource:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">{<br/>    "item": {<br/>        "id": "123",<br/>        "toUser": "paul",<br/>        "fromUser": "veronica",<br/>        "body": "hi dad"<br/>    }<br/>}</pre>
<p>Having some standardization for how resources or lists of resources are represented can greatly simplify working with services in a microservices architecture. Doing this with JSON and HTTP involves a fair amount of manual work however, which can be abstracted away. In the next recipes, we'll explore using Thrift and gRPC, two alternatives to HTTP/JSON for RPC.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Thrift</h1>
                
            
            
                
<p>JSON and HTTP are simple, straightforward solutions for data transportation and definition that should serve the purposes of many microservice architectures. If you want type safety and often better performance, however, it can be worthwhile to look at binary solutions such as Thrift or gRPC.</p>
<p><strong>Apache Thrift</strong> is an <strong>interface definition language</strong> (<strong>IDL</strong>) and binary transport protocol invented at Facebook. It allows you to specify APIs by defining the structs (which are similar to objects in most languages) and exceptions that your service exposes. Thrift interfaces defined in the IDL are used to generate code in a supported language that is then used to manage the RPC calls. Supported languages include C, C++, Python, Ruby, and Java. </p>
<p>The benefits of a binary protocol such as Thrift are primarily improved performance and type safety. Depending on the JSON library used, serializing and deserializing large JSON payloads can be quite expensive and JSON does not have any type system that clients can use when handling responses. Additionally, because Thrift includes an IDL that can be used to generate code in any supported language, it's easy to let Thrift handle the generation of both client and server code, cutting down the amount of manual work needing to be done.</p>
<p>Because Apache Thrift doesn't use HTTP as the transport layer, services that export Thrift interfaces start their own Thrift server. In this recipe, we'll define the IDL for our message service and use Thrift to generate the handler code. We'll then create the server boilerplate that handles starting the service, listening on a specified port, and so on. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new Gradle/Java project with the following <kbd>build.gradle</kbd> file:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        maven {<br/>            url "https://plugins.gradle.org/m2/"<br/>        }<br/>    }<br/>    dependencies {<br/>        classpath "gradle.plugin.org.jruyi.gradle:thrift-gradle-plugin:0.4.0"<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.jruyi.thrift'<br/>apply plugin: 'application'<br/><br/>mainClassName = 'com.packtpub.microservices.ch04.MessageServiceServer'<br/><br/>compileThrift {<br/>    recurse true<br/><br/>    generator 'html'<br/>    generator 'java', 'private-members'<br/>}<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.apache.thrift', name: 'libthrift', version: '0.11.0'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<ol start="2">
<li>Create a directory called <kbd>src/main/thrift</kbd> and a file called <kbd>service.thrift</kbd>. This is the IDL file for our service. We'll define a <kbd>MessageException</kbd> exception, the actual <kbd>Message</kbd> object, and a <kbd>MessageService</kbd> interface. For more information on the specific syntax of Thrift IDL files, the Thrift project website has good documentation (<a href="https://thrift.apache.org/docs/idl">https://thrift.apache.org/docs/idl</a>). To keep things simple, we'll just define a single method in our service that returns a list of messages for a specific user:</li>
</ol>
<pre style="padding-left: 60px">namespace java com.packtpub.microservices.ch04.thrift<br/><br/>exception MessageException {<br/>    1: i32 code,<br/>    2: string description<br/>}<br/><br/>struct Message {<br/>    1: i32 id,<br/>    2: string from_user,<br/>    3: string to_user,<br/>    4: string body<br/>}<br/><br/>service MessageService {<br/>    list&lt;Message&gt; inbox(1: string username) throws (1:MessageException e)<br/>}</pre>
<ol start="3">
<li>Running the assembled Gradle task will generate the code for the preceding IDL. We'll now create the implementation of our <kbd>MessageService</kbd> class. This will extend the autogenerated interface from the preceding IDL. For simplicity's sake, our <kbd>MessageService</kbd> implementation will not connect to any database but instead will use a static, hardcoded representation of inboxes that will be built in the constructor:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch04.thrift;<br/><br/>import com.packtpub.microservices.ch04.thrift.Message;<br/>import com.packtpub.microservices.ch04.thrift.MessageException;<br/>import com.packtpub.microservices.ch04.thrift.MessageService;<br/>import org.apache.thrift.TException;<br/><br/>import java.util.HashMap;<br/>import java.util.List;<br/>import java.util.Map;<br/>import java.util.stream.Collectors;<br/>import java.util.stream.Stream;<br/><br/>public class MessageServiceImpl implements MessageService.Iface {<br/><br/>    private Map&lt;String, List&lt;Message&gt;&gt; messagesRepository;<br/><br/>    MessageServiceImpl() {<br/>        // populate our mock repository with some sample messages<br/>        messagesRepository = new HashMap&lt;&gt;();<br/>        messagesRepository.put("usertwo", Stream.of(<br/>            new Message(1234, "userone", "usertwo", "hi"),<br/>            new Message(5678, "userthree", "usertwo", "hi")<br/>        ).collect(Collectors.toList()));<br/>        messagesRepository.put("userone", Stream.of(<br/>            new Message(1122, "usertwo", "userone", "hi"),<br/>            new Message(2233, "userthree", "userone", "hi")<br/>        ).collect(Collectors.toList()));<br/>    }<br/><br/>    @Override<br/>    public List&lt;Message&gt; inbox(String username) throws TException {<br/>        if (!messagesRepository.containsKey(username))<br/>            throw new MessageException(100, "Inbox is empty");<br/>        return messagesRepository.get(username);<br/>    }<br/>}</pre>
<ol start="4">
<li>Create the server. Create a new class called <kbd>MessageServiceServer</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch04.thrift;<br/><br/>import com.packtpub.microservices.ch04.thrift.MessageService;<br/>import org.apache.thrift.server.TServer;<br/>import org.apache.thrift.server.TSimpleServer;<br/>import org.apache.thrift.transport.TServerSocket;<br/>import org.apache.thrift.transport.TServerTransport;<br/>import org.apache.thrift.transport.TTransportException;<br/><br/>public class MessageServiceServer {<br/><br/>    private TSimpleServer server;<br/><br/>    private void start() throws TTransportException {<br/><br/>        TServerTransport serverTransport = new TServerSocket(9999);<br/>        server = new TSimpleServer(new TServer.Args(serverTransport)<br/>                .processor(new MessageService.Processor&lt;&gt;(new MessageServiceImpl())));<br/>        server.serve();<br/>    }<br/><br/>    private void stop() {<br/>        if (server != null &amp;&amp; server.isServing())<br/>            server.stop();<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        MessageServiceServer service = new MessageServiceServer();<br/>        try {<br/>            if (args[1].equals("start"))<br/>                service.start();<br/>            else if (args[2].equals("stop"))<br/>                service.stop();<br/>        } catch (TTransportException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</pre>
<p>Your service is now built and uses Apache Thrift for RPC. As a further exercise, you can experiment with using the same IDL to generate client code that can be used to call this service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using gRPC</h1>
                
            
            
                
<p><strong>gRPC</strong> is an RPC framework originally invented at Google. Unlike Thrift, gRPC makes use of existing technologies, specifically <strong>protocol buffers</strong>, for its IDL and HTTP/2 for its transport layer. After having completed the previous recipe, aspects of gRPC will feel similar to aspects of Thrift. Instead of the Thrift IDL, types and services are defined in a <kbd>.proto</kbd> file. The <kbd>.proto</kbd> file can then be used to generate code using the protocol buffer's compiler. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new Gradle/Java project with the following <kbd>build.gradle</kbd> file. Of note here is that we're installing and configuring the <kbd>protobuf</kbd> Gradle plugin, which will allow us to generate code from <kbd>protobuf</kbd> files using Gradle, and we're listing the required <kbd>protobuf</kbd> libraries as dependencies. Finally, we have to tell our IDE where to look for generated classes:</li>
</ol>
<pre style="color: black;padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.3'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'com.google.protobuf'<br/>apply plugin: 'application'<br/><br/>mainClassName = 'com.packtpub.microservices.ch04.grpc.MessageServer'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>def grpcVersion = '1.10.0'<br/><br/>dependencies {<br/>    compile group: 'com.google.api.grpc', name: 'proto-google-common-protos', version: '1.0.0'<br/>    compile group: 'io.grpc', name: 'grpc-netty', version: grpcVersion<br/>    compile group: 'io.grpc', name: 'grpc-protobuf', version: grpcVersion<br/>    compile group: 'io.grpc', name: 'grpc-stub', version: grpcVersion<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}<br/><br/>protobuf {<br/>    protoc {<br/>        artifact = 'com.google.protobuf:protoc:3.5.1-1'<br/>    }<br/>    plugins {<br/>        grpc {<br/>            artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}"<br/>        }<br/>    }<br/>    generateProtoTasks {<br/>        all()*.plugins {<br/>            grpc {}<br/>        }<br/>    }<br/>}<br/><br/>// Inform IDEs like IntelliJ IDEA, Eclipse or NetBeans about the generated code.<br/>sourceSets {<br/>    main {<br/>        java {<br/>            srcDirs 'build/generated/source/proto/main/grpc'<br/>            srcDirs 'build/generated/source/proto/main/java'<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>Create a new directory called <kbd>src/main/proto</kbd> and a new file called <kbd>message_service.proto</kbd>. This will be our definition of <kbd>protobuf</kbd> for our service. Like in the last recipe, we'll keep it simple by only exposing one method that returns a list of messages for a specified user:</li>
</ol>
<pre style="padding-left: 60px">option java_package = "com.packtpub.microservices.ch04.grpc";<br/><br/>message Username {<br/>    required string username = 1;<br/>}<br/><br/>message Message {<br/>    required string id = 1;<br/>    required string from_user = 2;<br/>    required string to_user = 3;<br/>    required string body = 4;<br/>}<br/><br/>message InboxReply {<br/>    repeated Message messages = 1;<br/>}<br/><br/>service MessageService {<br/>    rpc inbox(Username) returns (InboxReply) {}<br/>}</pre>
<ol start="3">
<li>Implement the actual service. In order to do this, we need to create a new class called <kbd>MessageServer</kbd> with all the necessary boilerplate for starting and stopping our server. We'll also create an inner class called <kbd>MessageService</kbd> that extends the generated <kbd>MessageServiceGrpc.MessageServiceImplBase</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch04.grpc;<br/><br/>import io.grpc.Server;<br/>import io.grpc.ServerBuilder;<br/>import io.grpc.stub.StreamObserver;<br/><br/>import java.io.IOException;<br/><br/>public class MessageServer {<br/><br/>    private final int port;<br/>    private final Server server;<br/><br/>    private MessageServer(int port) throws IOException {<br/>        this(ServerBuilder.forPort(port), port);<br/>    }<br/><br/>    private MessageServer(ServerBuilder&lt;?&gt; serverBuilder, int port) {<br/>        this.port = port;<br/>        this.server = serverBuilder.addService(new MessageService()).build();<br/>    }<br/><br/>    public void start() throws IOException {<br/>        server.start();<br/>        Runtime.getRuntime().addShutdownHook(new Thread() {<br/>            @Override<br/>            public void run() {<br/>                // Use stderr here since the logger may has been reset by its JVM shutdown hook.<br/>                System.err.println("*** shutting down gRPC server since JVM is shutting down");<br/>                MessageServer.this.stop();<br/>                System.err.println("*** server shut down");<br/>            }<br/>        });<br/>    }<br/><br/>    public void stop() {<br/>        if (server != null) {<br/>            server.shutdown();<br/>        }<br/>    }<br/><br/>    private void blockUntilShutdown() throws InterruptedException {<br/>        if (server != null) {<br/>            server.awaitTermination();<br/>        }<br/>    }<br/><br/>    private static class MessageService extends MessageServiceGrpc.MessageServiceImplBase {<br/>        public void inbox(MessageServiceOuterClass.Username request,<br/>                          StreamObserver&lt;MessageServiceOuterClass.InboxReply&gt; responseObserver) {<br/>            MessageServiceOuterClass.InboxReply reply = MessageServiceOuterClass.InboxReply.newBuilder().addMessages(<br/>                MessageServiceOuterClass.Message.newBuilder()<br/>                    .setId("1234")<br/>                    .setFromUser("Paul")<br/>                    .setToUser("Veronica")<br/>                    .setBody("hi")<br/>            ).addMessages(<br/>                MessageServiceOuterClass.Message.newBuilder()<br/>                    .setId("5678")<br/>                    .setFromUser("FooBarUser")<br/>                    .setToUser("Veronica")<br/>                    .setBody("Hello again")<br/>            ).build();<br/>            responseObserver.onNext(reply);<br/>            responseObserver.onCompleted();<br/>        }<br/>    }<br/><br/>    public static void main(String[] args) throws Exception {<br/>        MessageServer server = new MessageServer(8989);<br/>        server.start();<br/>        server.blockUntilShutdown();<br/>    }<br/>}</pre>


            

            
        
    </body></html>