- en: Using Iterators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES8 and earlier versions introduced new object interfaces and loops for iteration.
    The addition of the new iteration protocols opens up a new world of algorithms
    and abilities for JavaScript. We will start the chapter by introducing the symbols
    and various properties of the `Symbol` object. We will also learn how execution
    stacks are created for the nested function calls, their impacts, and how to optimize
    their performance and memory usage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Although symbols are a separate topic to iterators, we will still be covering
    symbols in this chapter, because to implement the iterable protocol, you need
    to use symbols.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Using symbols as the object property keys
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the iteration protocols in objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using the `generator` object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `for…of` loop for iterating
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tail call optimization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbols – primitive data type
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Symbols** are a primitive type that was first introduced in ES6\. A symbol
    is a unique and immutable value. Here is an example that shows how to create a
    symbol:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Symbols don't have a literal form; therefore, we need to use the `Symbol()`
    function to create a symbol. The `Symbol()` function returns a unique symbol every
    time it is called.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Symbol()` function takes an optional string parameter that represents
    the description of the symbol. A description of a symbol can be used for debugging,
    but not to access the symbol itself. Two symbols with the same description are
    not equal at all. Here is an example to demonstrate this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding example, we can also say that a symbol is a string-like value
    that can't clash with any other value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The typeof operator
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `typeof` operator is used to determine the type of value a particular variable/constant
    is held for `Symbol`, `typeof` outputs `symbol`. Here is an example to demonstrate
    the same:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `typeof` operator is the only way to identify whether a variable holds
    a symbol.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The new operator
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You cannot apply the `new` operator to the `Symbol()` function. The `Symbol()`
    function detects whether it's being used as a constructor, and if `true`, it then
    throws an exception.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But the JavaScript engine can use the `Symbol()` function internally as a constructor to
    wrap a symbol in an object. Therefore, `s` will be equal to object(s).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: All primitive types introduced from ES6 onward will not allow their constructors
    to be invoked manually.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Using symbols as the object property keys
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until ES5, the JavaScript object property keys had to be string type. But since
    ES6, the JavaScript object property keys can be strings or symbols. Here is an
    example that demonstrates how to use a symbol as an object property key:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the preceding code, you can see that in order to create or retrieve a property
    key using symbols, you need to use the `[]` token. We saw the `[]` token while
    discussing the computed property names in [Chapter 2](1240cafe-4f1d-4e0f-bc46-6c2ed8bb3efe.xhtml),
    *Knowing Your Library*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: To access a symbol property key, we need the symbol. In the previous example,
    both `s1` and `s2` hold the same symbol value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The Object.getOwnPropertySymbols() method
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Object.getOwnPropertyNames()` method cannot retrieve the symbol properties.
    Therefore, ES6 introduced `Object.getOwnPropertySymbols()` to retrieve an array
    of symbol properties of an object. Here is an example to demonstrate this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the previous example, you can see that the `Object.getOwnPropertySymbols()` method
    can also retrieve the non-enumerable symbol properties.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The `in` operator can find the symbol properties in an object, whereas the `for…in`
    loop and `Object.getOwnPropertyNames()` cannot find the symbol properties in an
    object for the sake of backward compatibility.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The Symbol.for(string) method
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Symbol` object maintains a registry of the key/value pairs, where the key
    is the symbol description, and the value is the symbol. Whenever we create a symbol
    using the `Symbol.for()` method, it gets added to the registry and the method
    returns the symbol. If we try to create a symbol with a description that already
    exists, then the existing symbol will be retrieved.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using the `Symbol.for()` method instead of the `Symbol()`
    method to create symbols is that while using the `Symbol.for()` method, you don''t
    have to worry about making the symbol available globally, because it''s always
    available globally. Here is an example to demonstrate this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Well-known symbols
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to your own symbols, ES6 comes up with a built-in set of symbols,
    known as well-known symbols. Here is a list of properties, referencing some important
    built-in symbols:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol.iterator`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.match`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.search`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.replace`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.split`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.hasInstanceSymbol.species`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.unscopables`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.isContcatSpreadable`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.toPrimitive`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will come across the use of these symbols in various chapters of this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: When referring to the well-known symbols in the text, we usually prefix them
    using the `@@` notation. For example, the `Symbol.iterator` symbol is referred
    to as the `@@iterator` method. This is done to make it easier to refer to these
    symbols in the text.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The iteration protocol
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An iteration protocol is a set of rules that an object needs to follow for implementing
    the interface. When this protocol is used, a loop or a construct can iterate over
    a group of values of the object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has two iteration protocols known as the **iterator**** protocol**
    and the **iterable protocol**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The iterator protocol
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any object that implements the iterator protocol is known as an **iterator**.
    According to the iterator protocol, an object needs to provide a `next()` method
    that returns the next item in the sequence of a group of items.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you look closely, you''ll realize that the `next` method inside the `obj`
    object is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This can be written as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This clearly tells us that we''ll increment `nextIndex` and send the next element
    from the `array` in the object `obj` if a new element exists there. When there''s
    no element left, we return `{ done: true }`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The iterable protocol
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any object that implements the **iterable protocol** is known as an iterable.
    According to the iterable protocol, an object needs to provide the `@@iterator`
    method; that is, it must have the `Symbol.iterator` symbol as a property key.
    The `@@iterator` method must return an iterator object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is all well and good, but what is the use of doing it?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding two code blocks show you how to implement the iterable protocol
    on your own. However, things such as **arrays** come with the iterable protocol
    (that is, their `__proto__` chain implements the `Symbol.iterator` method), which
    is implemented by default thus saving a developer''s time. Let''s take a look
    at an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Based on what we've learned so far, what do you think the output should be?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let us now take a look at generators, which are more or less, similar to iterators.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Generator function
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `generator` is a normal function, but instead of returning a single value,
    it returns multiple values one by one. Calling a `generator` function doesn't
    execute its body immediately, but rather returns a new instance of the `generator`
    object (that is, an object that implements both, iterable and iterator protocols).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Every `generator` object holds a new execution context of the `generator` function.
    When we execute the `next()` method of the `generator` object, it executes the
    `generator` function's body until the `yield` keyword is encountered. It returns
    the yielded value and pauses the function. When the `next()` method is called
    again, it resumes the execution and then returns the next yielded value. The `done`
    property is `true` when the `generator` function doesn't yield any value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'A `generator` function is written using the `function*` expression. Here is
    an example to demonstrate this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is an expression following the `yield` keyword. The value of the expression
    is what is returned by the `generator` function via the iterable protocol. If
    we omit the expression, then `undefined` is returned. The value of the expression
    is what we call, the yielded value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass an optional argument to the `next()` method. This argument
    becomes the value returned by the `yield` statement, where the `generator` function
    is currently paused. Here is an example to demonstrate this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s the explanation of this output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: On the first `generator.next()` call, `yield 12` is called and the value `12`
    is returned.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the second `generator.next(5)` call, the previous yield (which was stored
    in `const a`) gets the passed value (that is, `5`), and then the second yield
    (`a + 1`). Then, `yield 5 + 1` is called and the value `6` is returned (careful:
    `a` is not `12` here).'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the third `generator.next(11)` call, `const b` becomes `11`, and then because
    it's the sum of  *11 + 2*, `13` is yielded.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is followed till the last process, that is, until the line `Final Line`,
    as mentioned in the example.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As `yield` finally returns a value and its `done` status, after executing `yield
    c + 3`, there is apparently no value to yield. Hence, the value returned is `undefined`
    and `done` is `true`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The return(value) method
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can end a `generator` function any time before it has yielded all the values
    by using the `return()` method of the `generator` object. The `return()` method
    takes an optional argument, representing the final value to return.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example demonstrating this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The throw(exception) method
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can manually trigger an exception inside a `generator` function using the
    `throw()` method of the `generator` object. You must pass an exception to the
    `throw()` method that you want to throw. Here is an example to demonstrate this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, you can see that the exception is thrown where the
    function was last paused. After the exception is handled, the `throw()` method
    continues execution, and returns the next yielded value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The yield* keyword
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `yield*` keyword inside a `generator` function takes an iterable object
    as the expression and iterates it to yield its values. Here is an example to demonstrate
    this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The for…of loop
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been iterating over an iterable object using the `next()`
    method, which is a cumbersome task. ES6 introduced the `for…of` loop to make this
    easier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for…of` loop was introduced to iterate over the values of an iterable
    object. Here is an example to demonstrate this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tail call optimization
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a function call is made, an execution stack is created in the stack
    memory to store the variables of the function. **Tail call optimization** basically
    means that you reuse the allocated stack in memory if there's no information in
    that stack that is required later in the code execution sequence.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Why tail call optimization?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a function call is made inside another function call, a new execution
    stack is created for the inner function call. However, the problem is that the
    inner function execution stack takes up some extra memory--that is, it stores
    an extra address, representing where to resume the execution when this function
    finishes executing. Switching and creating the execution stacks also takes some
    additional CPU time. This problem is not noticeable when there are a couple  of hundred,
    nested levels of calls, but it''s noticeable when there are thousands or more
    nested levels of calls--that is, the JavaScript engines throw the `RangeError:
    Maximum call stack size exceeded` exception. You might have, at some point, experienced
    the `RangeError` exception while creating a recursive function.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: A tail call is a function call that is performed optionally at the very end
    of a function with the `return` statement. If a tail call leads to the same function
    call again and again, then it's called a **tail-recursion**, which is a special
    case of recursion. What's special about tail calls is that there is a way to actually
    prevent the extra CPU-time and memory usage while making the tail calls, and that
    is by reusing the stack of the out function, instead of creating a new execution
    stack. Reusing the execution stack while making a tail call is called tail call
    optimization.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript supports tail call optimization in specific browsers if the script
    is written in the `"use strict"` mode. Let''s see an example of a tail call:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, the `_add()` call in the `add1()` function is a tail call, as it's the
    final action of the `add1()` function. However, the `_add()` call in the `add2()`
    function is not a tail call, as it's not the final act; adding `0` to the result
    of `_add()` is the final act.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The `_add()` call in `add1()` doesn't create a new execution stack. Instead,
    it reuses the `add1()` function's execution stack; in other words, the tail call
    optimization occurs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Tail call optimization spec is **not actively** being developed for Chrome and
    is only implemented in Safari as of now. Hence, you can only use TCO in Safari.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Converting non-tail calls into tail calls
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As tail calls are optimized, you must use tail calls whenever possible, instead
    of non-tail calls. You can optimize your code by converting the non-tail calls
    into tail calls.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of this, which is similar to the previous one:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the previous code, the `_add()` call was not a tail call, and therefore,
    two execution stacks were created. We can convert it into a tail call in this
    way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we omitted the use of the `result` variable and instead lined up the function
    call with the `return` statement. There are many other similar strategies to convert
    non-tail calls into tail calls.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a new way of creating the object property keys using
    symbols. We saw the iterator and iterable protocols and learned how to implement
    these protocols in custom objects. Then, we learned how to iterate over an iterable
    object using the `for…of` loop. Finally, we ended the chapter by learning what
    tail calls are, and how they are optimized.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一种使用符号创建对象属性键的新方法。我们了解了迭代器和可迭代协议，并学习了如何在自定义对象中实现这些协议。然后，我们学习了如何使用`for…of`循环遍历可迭代对象。最后，我们通过学习尾调用及其优化来结束本章。
- en: In the next chapter, we will learn about how to do asynchronous programming
    with Promises and the recently launched async/await feature in ES8, which makes
    asynchronous code look much more like synchronous code. Let's go!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Promises以及ES8中最近推出的async/await特性进行异步编程，这使得异步代码看起来更像是同步代码。让我们开始吧！
