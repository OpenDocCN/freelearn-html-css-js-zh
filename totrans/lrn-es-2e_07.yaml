- en: Proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxies are used to define the custom behavior of the fundamental operations
    on objects. Proxies are already available in programming languages such as C#,
    C++, and Java, but JavaScript has never had proxies. ES6 introduced the Proxy
    API, which lets us create proxies. In this chapter, we will look at proxies, their
    usage, and proxy traps. Due to the benefits of proxies, developers are using them
    increasingly and, therefore, it's important to learn about proxies in depth, with
    examples, which we will do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating proxies using the Proxy API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what proxies are and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercepting various operations on the objects using traps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different kinds of available traps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some use cases of proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxies in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A proxy acts like a wrapper for an object and defines the custom behavior for
    the fundamental operations on the object. Some fundamental operations on the objects
    are property lookup, property assignment, constructor invocation, enumeration,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Think of it as a basic way of intercepting the operation you do with an object
    and its associated properties. For example, calling out a property value by writing
    `<objectname>.propertyName` should technically just echo out the property value,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to take a step back and inject your control right before the
    echoing part, but right after the calling part? Here's where proxies come in.
  prefs: []
  type: TYPE_NORMAL
- en: Once an object is wrapped using a proxy, all the operations that are supposed
    to be done on the object should now be done on the proxy object, so that the custom
    behavior can take place.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology for proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some important terms that are used while studying proxies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target:** This is the object that is wrapped by a proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traps:** These are functions that intercept various operations on the `target`
    object, and define the custom behavior for those operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler:** This is an object that holds the traps. A handler is attached
    to a proxy object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Proxy API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ES6 Proxy API provides the proxy constructor to create proxies. The proxy
    constructor takes two arguments, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target:** This is the object that will be wrapped by the proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler:** This is an object that contains the traps for the `target` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A trap can be defined for every possible operation on the `target` object.
    If a trap is not defined, then the default action takes place on the target. Here
    is a code example that shows how to create a proxy, and does various operations
    on the `target` object. In this example, we have not defined any traps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the age property of the `target` object can be accessed
    via the `proxy` object. When we added the name property to the `proxy` object,
    it was actually added to the `target` object.
  prefs: []
  type: TYPE_NORMAL
- en: As there was no trap attached to the property assignment, the `proxy.name` assignment
    resulted in the default behavior--that is, simply assigning the value to the property.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can say that a proxy is just a wrapper for a `target` object, and traps
    can be defined to change the default behavior of operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many developers don''t keep a reference variable for the `target` object, so
    use of the proxy is not mandatory for accessing the object. Keep a reference for
    the handler only when you need to reuse it for multiple proxies. Here is how to
    rewrite the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Proxy traps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different traps for the different operations that can be performed
    on an object. Some of the traps need to return values. There are some rules you
    need to follow when returning values. The returned values are intercepted by the
    proxy to filter and/or check if the returned values obey the rules. If a trap
    doesn't obey rules while returning a value, then the proxy throws the `TypeError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `this` inside a trap is always a reference to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the various kinds of traps.
  prefs: []
  type: TYPE_NORMAL
- en: The get(target, property, receiver) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The get trap is executed when we retrieve a property value using the dot or
    bracket notation, or the `Reflect.get()` method. It takes three parameters--that
    is, the `target` object, the property name, and the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'It must return a value that represents the property value. Here is a code example,
    which shows how to use the get trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, as you might''ve figured out, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the output, you will get the following without proxies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the get trap looks for the property in the `target` object
    and, if it finds it, then returns the `property` value. Otherwise, it returns
    a string indicating that it was not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The receiver parameter is the reference of the object whose property we intend
    to access. Consider this example to better understand the value of the receiver
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `{age: 13}` here is `ProxyObject`, `{ age: 12 }` is the normal object.'
  prefs: []
  type: TYPE_NORMAL
- en: Here `obj` inherits the `proxy` object. Therefore, when the name property was
    not found in the `obj` object, it was searched for in the `proxy` object. As the
    `proxy` object had a get trap, it provided a value.
  prefs: []
  type: TYPE_NORMAL
- en: So, the value of the receiver parameter when we access the name property via
    the `obj.name` expression is `obj`, and when we access the name property via `proxy.name` the
    expression is `proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the receiver parameter is decided in the same way for all other
    traps also.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for using get trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated when using the get trap:'
  prefs: []
  type: TYPE_NORMAL
- en: The value returned for a property must be the same as the value of the `target`
    object property if the `target` object property is a non-writable, non-configurable
    data property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value returned for a property must be `undefined` if the `target` object
    property is a non-configurable accessor property that has `undefined` as its [[Get]]
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set(target, property, value, receiver) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The set trap is invoked when we set the value of a property using the assignment
    operator, or the `Reflect.set()` method. It takes four parameter-- that is, the
    `target` object, the property name, the new property value, and the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: The set trap must return `true` if the assignment was successful. Otherwise,
    it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the set trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Rules for using set trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated when using the set trap:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `target` object property is a non-writable, non-configurable data property,
    then it will return as `false`--that is, you cannot change the property value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `target` object property is a non-configurable accessor property that
    has `undefined` as its [[Set]] attribute, then it will return as `false`--that
    is, you cannot change the property value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The has(target, property) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The has trap is executed when we check if a property exists or not, using the
    `in` operator. It takes two parameters--that is, the `target` object and the property
    name. It must return a Boolean value that indicates whether the property exists
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the has trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Rules for using has trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated when using the has trap:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot return `false` if the property exists as a non-configurable and is
    its own property of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot return `false` if the property exists as an own property of the `target`
    object and the `target` object is not-extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The isExtensible(target) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `isExtensible` trap is executed when we check if the object is extensible
    or not, using the `Object.isExtensible()` method. It takes only one parameter--that
    is, the `target` object. It must return a Boolean value indicating whether the
    object is extensible or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the `isExtensible` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Rule for using isExtensible trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This rule shouldn''t be violated when using the `isExtensible` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot return `false` if the target is extensible. Similarly, you cannot
    return `true` if the target is non-extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getPrototypeOf(target) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `getPrototypeOf` trap is executed when we retrieve the value of the internal
    [[prototype]] property, using either the `Object.getPrototypeOf()` method or the
    `__proto__` property. It takes only one parameter--that is, the `target` object.
  prefs: []
  type: TYPE_NORMAL
- en: It must return an object or null value. The null value indicates that the object
    doesn't inherit anything else and is the end of the inheritance chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the `getPrototypeOf` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Rules for using getPrototypeOf trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated when using the `getPrototypeOf` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: It must either return an object or return a null value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target is not-extensible, then this trap must return the actual prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setPrototypeOf(target, prototype) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `setPrototypeOf` trap is executed when we set the value of the internal
    [[prototype]] property, using either the `Object.setPrototypeOf()` method or the
    `__proto__` property. It takes two parameters--that is, the `target` object and
    value of the property to be assigned.
  prefs: []
  type: TYPE_NORMAL
- en: This trap will return a Boolean, indicating whether it has successfully set
    the prototype or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the `setPrototypeOf` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Rule for using setPrototypeOf trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This rule shouldn''t be violated when using the `setPrototypeOf` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: You must return `false` if the target is not-extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preventExtensions(target) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `preventExtensions` trap is executed when we prevent the addition of new
    properties using the `Object.preventExtensions()` method. It takes only one parameter--that
    is, the `target` object.
  prefs: []
  type: TYPE_NORMAL
- en: It must return a Boolean, indicating whether it has successfully prevented the
    extension of the object or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the `preventExtensions`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Rule for using preventExtensions trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This rule shouldn''t be violated when using the `preventExtensions` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: This trap can return `true` only if the target is non-extensible or it has made
    the target non-extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getOwnPropertyDescriptor(target, property) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `getOwnPropertyDescriptor` trap is executed when we retrieve the descriptor
    of a property by using the `Object.getOwnPropertyDescriptor()` method. It takes
    two parameters--that is, the `target` object and the name of the property.
  prefs: []
  type: TYPE_NORMAL
- en: This trap must return a `descriptor` object or `undefined`. The `undefined`
    value is returned if the property doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the `getOwnPropertyDescriptor`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Rules for using getOwnPropertyDescriptor trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated when using the `getOwnPropertyDescriptor`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: This trap must either return an object or return an `undefined` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot return the `undefined` value if the property exists as a non-configurable
    own property of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot return the `undefined` value if the property exists as an own property
    of the `target` object and the `target` object is not-extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to return `undefined` if the property does not exist as an own
    property of the `target` object and the `target` object is not-extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot make the configurable property of the returned descriptor object
    `false` if the property exists as an own property of the `target` object, or if
    it exists as a configurable own property of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defineProperty(target, property, descriptor) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `defineProperty` trap is executed when we define a property using the `Object.defineProperty()`
    method. It takes three parameters--that is, the `target` object, the property
    name, and the `descriptor` object.
  prefs: []
  type: TYPE_NORMAL
- en: This trap should return a Boolean indicating whether it has successfully defined
    the property or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the `defineProperty` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Rule for using defineProperty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This rule shouldn''t be violated when using the `defineProperty` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: It must return `false` if the `target` object is not-extensible, and the property
    doesn't yet exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deleteProperty(target, property) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `deleteProperty` trap is executed when we delete a property using either
    the delete operator or the `Reflect.deleteProperty()` method. It takes two parameters--that
    is, the `target` object and the property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This trap must return a Boolean, indicating whether the property was deleted
    successfully or not. Here is a code example that demonstrates how to use the `deleteProperty`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Rule for deleteProperty trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This rule shouldn''t be violated when using the `deleteProperty` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: This trap must return `false` if the property exists as a non-configurable own
    property of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ownKeys(target) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ownKeys` trap is executed when we retrieve the own property keys using
    the `Reflect.ownKeys()`, `Object.getOwnPropertyNames()`, `Object. getOwnPropertySymbols()` and
    the `Object.keys()` methods. It takes only one parameter--that is, the `target`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Reflect.ownKeys()` method is similar to the `Object.getOwnPropertyNames()`
    method--that is, they both return the enumerable and non-enumerable property keys
    of an object.
  prefs: []
  type: TYPE_NORMAL
- en: They also both ignore the inherited properties. The only difference is that
    the `Reflect. ownKeys()` method returns both the symbol and string keys, whereas
    the `Object. getOwnPropertyNames()` method returns only the string keys.
  prefs: []
  type: TYPE_NORMAL
- en: The `Object.getOwnPropertySymbols()` method returns the enumerable and non-enumerable
    properties whose keys are symbols. It ignores the inherited properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `Object.keys()` method is similar to the `Object.getOwnPropertyNames()`
    method, but the only difference is that the `Object.keys()` method returns the
    enumerable properties only.
  prefs: []
  type: TYPE_NORMAL
- en: The `ownKeys` trap must return an array, representing the own property keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example which demonstrates how to use the `ownKeys` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the values of the array returned by the `ownKeys` trap
    are filtered by the proxy, based on what the caller expected. For example, the
    `Object.getOwnPropertySymbols()` caller expected an array of symbols. Therefore,
    the proxy removed the strings from the returned array.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for using ownKeys trap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated when using the `ownKeys` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: The elements of the returned array must either be a string or symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned array must contain the keys of all the non-configurable own properties
    of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `target` object is not-extensible, then the returned array must contain
    all the keys of the own properties and of the `target` object, and no other values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The apply(target, thisValue, arguments) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the target is a function, then calling the proxy will execute the `apply`
    trap. The `apply` trap is also executed for the function's `apply()` and `call()`
    methods, and the `Reflect.apply()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The apply trap takes three parameters. The first parameter is the `target` object
    and the third parameter is an array, representing the arguments of the function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is the same as the value of `this` of the `target` function--that
    is, it's the same as the value of `this` of the target function if the target
    function would have been invoked without the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates how to use the apply trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The construct(target, arguments) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the target is a function, then calling the target as a constructor using
    the `new` operator or the `Reflect.construct()` method will execute the construct
    trap.
  prefs: []
  type: TYPE_NORMAL
- en: The construct trap takes two parameters. The first parameter is the `target`
    object and the second parameter is an array, representing the arguments of the
    constructor call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `construct` trap must return an object, representing the newly created
    instance. Here is a code example that demonstrates how to use the `construct`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Proxy.revocable(target, handler) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A revocable proxy is a proxy that can be revoked (that is, switched off).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create revocable proxies we have to use the `Proxy.revocable()` method.
    The `Proxy.revocable()` method is not a constructor. This method also takes the
    same arguments as the `Proxy` constructor, but, instead of returning a revocable
    proxy instance directly, it returns an object with two properties, which are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`proxy`: This is the revocable `proxy` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`revoke`: When this function is called, it revokes the proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once a revocable `proxy` is revoked, any attempts to use it will throw a `TypeError`
    exception. Here is an example to demonstrate how to create a revocable `proxy`
    and `revoke` it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Use case of revocable proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the revocable proxies instead of the regular proxies. You can use
    it when you pass a proxy to a function that runs asynchronously or in parallel,
    so that you can revoke it when you don't want the function to be able to use that
    proxy anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The uses of proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several uses of proxies. Here are some main use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating virtualized objects, such as remote objects, persistent objects, and
    more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lazy creation of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparent logging, tracing, profiling, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded domain specific languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generically interposing abstractions in order to enforce access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what proxies are and how to use them. We saw the
    various traps available with examples. We also saw different rules that need to
    be followed by different traps. This chapter explained everything about the Proxy
    API in JavaScript in depth. Finally, we saw some use cases of proxies. In the
    next chapter, we will walk through object-oriented programming and the ES6 classes.
  prefs: []
  type: TYPE_NORMAL
