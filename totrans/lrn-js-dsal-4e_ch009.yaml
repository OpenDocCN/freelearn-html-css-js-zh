- en: 8 Dictionaries and Hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Before you begin: Join our book community on Discord**'
  prefs: []
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we delved into the world of sets, focusing on their
    ability to efficiently store unique values. Building upon this foundation, we
    will now explore two more data structures designed for storing distinct elements:
    dictionaries and hashes.'
  prefs: []
  type: TYPE_NORMAL
- en: While sets prioritize the value itself as the primary element, dictionaries
    and hashes take a different approach. Both structures store data as key-value
    pairs, allowing us to associate a unique key with a corresponding value. This
    pairing is fundamental to how dictionaries and hashes work.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a subtle yet important distinction in implementation. Dictionaries,
    as we will soon discover, adhere to a strict rule of one value per key. Hashes,
    on the other hand, offer some flexibility in handling multiple values associated
    with the same key, opening up additional possibilities for data organization and
    retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash table data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling collisions in hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JavaScript native `Map`, `WeakMap`, and `WeakSet` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dictionary data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have explored, a set is a collection of unique elements, ensuring that
    no duplicates exist within the structure. In contrast, a **dictionary** is designed
    to store pairs of keys and values. This pairing enables us to utilize keys as
    identifiers to efficiently locate specific elements.
  prefs: []
  type: TYPE_NORMAL
- en: While dictionaries share similarities with sets, there is a crucial distinction
    in the type of data they store. Sets maintain a collection of key-key pairs, where
    both elements of the pair are identical. Dictionaries, on the other hand, house
    key-value pairs, associating each unique key with a corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that dictionaries are known by various names in different
    contexts, including **maps**, **symbol tables**, and **associative arrays**. These
    terms highlight the fundamental purpose of dictionaries: to establish associations
    between keys and values, facilitating efficient data retrieval and organization.'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, dictionaries are frequently employed to store the reference
    addresses of objects. These addresses serve as unique identifiers for objects
    residing in memory. To visualize this concept, consider opening the *Chrome Developer
    Tools* and navigating to the **Memory** tab. Running a snapshot will reveal a
    list of objects along with their respective address references, typically displayed
    in the format *@<number>*. The following screenshot illustrates how dictionaries
    can be used to associate keys with these memory addresses, enabling efficient
    object retrieval and manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory tab of a browser displaying the memory allocation for address references](img/file59.png)'
  prefs: []
  type: TYPE_IMG
- en: Memory tab of a browser displaying the memory allocation for address references
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will also cover some examples of how to use the dictionary
    data structure in real world projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Dictionary class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the `Set` class, **ECMAScript 2015** (ES6) introduced the `Map`
    class, a fundamental data structure often referred to as a dictionary in programming.
    This native implementation serves as the basis for the custom dictionary class
    we will develop in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `Dictionary` class we will construct draws heavily from the design principles
    of the JavaScript Map implementation. As we explore its structure and functionality,
    you will observe striking similarities to the `Set` class. However, a key distinction
    lies in the data storage mechanism. Instead of storing only values, as in a Set,
    our dictionary class will accommodate key-value pairs. This modification allows
    us to associate unique keys with their corresponding values, thereby unlocking
    the full power and versatility of dictionaries as a data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation will reside in the src/08-dictionary-hash/dictionary.js
    file. We will start by defining the `Dictionary` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We utilize an object (`{}`) to store elements within the `#items` private property.
    The keys of this object represent the unique keys, while the corresponding values
    can be anything. We will also keep track of the number of elements in the set
    with the property `size`.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal scenario, a dictionary would seamlessly store keys of the string
    type alongside values of any type, whether they are primitive values like numbers
    or strings, or more complex objects. However, JavaScript's dynamically typed nature
    introduces a potential challenge. Since we cannot guarantee that keys will consistently
    be strings, we must implement a mechanism to transform any object passed as a
    key into a string format. This transformation simplifies the process of searching
    for and retrieving values within our Dictionary class, enhancing its overall functionality.
    The same logic can also be applied to the Set class we explored in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we do not have this issue in the TypeScript implementation, as we
    can define the type of the key as string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To achieve this key transformation, we require a function that can reliably
    convert objects into strings. As a default option, we will leverage the `#elementToString`
    method we have defined earlier this book in previous data structures. This function
    provides a reusable solution for stringifying keys, making it adaptable to any
    data structure we create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This method efficiently converts data into a string representation. If the data
    is a complex object (excluding `null`), it utilizes `JSON.stringify()` to produce
    a **JSON** string. Otherwise, it leverages the `toString` method to ensure a string
    conversion for any other data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the methods that will empower our dictionary/map data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(key, value)`: inserts a new key-value pair into the dictionary. If the
    specified key already exists, its associated value will be updated with the new
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(key)`: removes the entry corresponding to the provided key from the
    dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasKey(key)`: determines whether a given key is present in the dictionary,
    returning `true` if it exists and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(key)`: retrieves the value associated with the specified key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: empties the dictionary, removing all key-value pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()`: returns the count of key-value pairs currently stored in the dictionary,
    similar to the length property of an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty()`: checks if the dictionary is empty, returning `true` if the size
    is zero and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keys()`: generates an array containing all the keys present in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()`: produces an array containing all the values stored in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach(callbackFn)`: iterates over each key-value pair in the dictionary.
    The `callbackFn` function, which accepts a key and a value as parameters, is executed
    for each entry. This iteration process can be terminated if the callback function
    returns `false`, mirroring the behavior of the `every` method in the `Array` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement each of these methods in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying whether a key exists in the dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first method we will implement is the `hasKey(key)` method. This method
    is fundamental, as it will be utilized in other methods like `set` and `remove`.
    Let''s examine its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In JavaScript, object keys are inherently strings. Therefore, if a complex object
    is provided as a key, we must convert it to a string representation. To achieve
    this, the `#elementToString` method is invoked consistently, ensuring that keys
    are always treated as strings within our dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The `hasKey` method checks if there is a value associated with the given key
    within the items table (the underlying storage for our dictionary). If the corresponding
    position in the table is not `null` or `undefined`, indicating the presence of
    a value, the method returns `true`. Otherwise, if no value is found, the method
    returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: And now that we have this method, we can proceed with the implementation of
    the methods for adding and removing values.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a key and value in the dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will implement the `set` method in our `Dictionary` class. The `set`
    method serves a dual purpose: it can both add a new key-value pair to the dictionary
    and update the value of an existing key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method accepts a `key` and a `value` as input. If both the key and value
    are valid (not `null` or `undefined`), the method proceeds to convert the key
    into a string representation. This is a crucial step because JavaScript object
    keys can only be strings. This conversion is handled internally by the private
    `#elementToString` method, ensuring consistency and reliability across all key
    types. With the key in string form, the method then stores the value within the
    dictionary's internal storage (`#items`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method communicates its success by returning `true`, signaling
    that the key-value pair was successfully inserted or updated and we increment
    its size. If either the key or value is invalid (`null` or `undefined`), the method
    returns `false`, signaling that the insertion or update operation failed.
  prefs: []
  type: TYPE_NORMAL
- en: Removing and clearing all values from the dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The delete method''s primary function is to remove a key-value pair from the
    dictionary based on the provided key. It ensures the integrity of the dictionary
    by checking for the key''s existence before attempting removal and updating the
    size accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We start by verifying if the provided key exists within the dictionary. This
    is achieved by calling the `has` method, which checks the dictionary's underlying
    storage for the presence of the specified key. This check is crucial to prevent
    errors that might arise from trying to delete a non-existent entry.
  prefs: []
  type: TYPE_NORMAL
- en: If the key is found, the `delete` operator in JavaScript is employed to remove
    the corresponding key-value pair from the dictionary's internal data structure
    (`#items`). Following the successful removal of the entry, the dictionary's internal
    size counter (`#size`) is decremented by one to accurately reflect the change
    in the number of stored elements.
  prefs: []
  type: TYPE_NORMAL
- en: As a last step, the method signals the outcome of the operation by returning
    `true` to indicate that the key existed and was successfully deleted, and `false`
    to indicate that the key was not found and no deletion occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we want to remove all the elements from the set, we can use the `clear`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This effectively discards all previous key-value pairs and creates a fresh,
    empty container for future additions. And we also reset the `#size` property back
    to 0 to accurately reflect that the set now contains no elements.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the size and checking if it is empty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next method we will implement is the size method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method simply returns the size property we are using to keep count.
  prefs: []
  type: TYPE_NORMAL
- en: 'And to determine if the dictionary is empty, we implement the `isEmpty()` method,
    following a pattern consistent with other data structures we have covered in this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method directly compares the private `#size` property to 0\. The property
    `#size` is meticulously maintained to always reflect the number of elements in
    the set.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a value from the dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To search for a specific key within our dictionary and retrieve its associated
    value, we utilize the `get` method. This method streamlines the process of accessing
    stored data by encapsulating the necessary logic and is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon receiving a `key` as input, the `get` method first transforms it into
    a string representation using the private `#elementToString` function. Next, the
    method directly accesses the corresponding value from the dictionary''s internal
    storage (`#items`). This is achieved by using the stringified key to index into
    the #items object, which presumably holds the key-value pairs. The value associated
    with the given key, if found, is then returned by the method.'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving all the values and all the keys from the dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explore how to retrieve all values and keys from our custom dictionary
    class in JavaScript. We will start by declaring the method `values`, which will
    retrieve all the values stored in the Dictionary class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method is quite straightforward. It leverages the built-in `Object.values()`
    function, which takes an object (in this case, our private `#items` storage) and
    returns an array containing all of its values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `keys` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `keys` method uses the `Object.keys()` function. This function,
    when given an object, returns an array of all the string-based keys (property
    names) in that object. Since we ensure that all keys are strings in our dictionary
    implementation, this works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, these methods have good performance. However, for exceptionally
    large dictionaries, iterating directly over the `#items` object might be slightly
    more efficient in some JavaScript engines. Let's see how we can achieve this in
    the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating each value-pair of the dictionary with forEach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus far, we have not implemented a method that facilitates iteration through
    each value stored within our data structures. We will now introduce the `forEach`
    method for the `Dictionary` class, with the added benefit that this behavior can
    also be applied to other data structures we have previously constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `forEach` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `forEach` method is designed to iterate over every key-value pair within
    our dictionary, applying a provided callback function to each entry. For each
    key-value pair, the provided `callbackFn` function is executed, receiving the
    value and key as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We use a `for...in` loop for iterating over object properties. However, to ensure
    that we only process the dictionary's own properties (and not inherited ones from
    its prototype chain), a safeguard is employed. The `hasOwnProperty` method checks
    whether a property belongs directly to the object. In this case, it verifies if
    the current `key` in the loop is an actual key within the `#items` object, the
    dictionary's underlying storage. Then, we apply the provided callback function
    to each entry, retrieving the value from the dictionary and passing the key as
    an argument to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our data structure, let's test it!
  prefs: []
  type: TYPE_NORMAL
- en: Using the Dictionary class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine we are building a simple language learning program. We want to store
    translations for frequently-used words and phrases to help users quickly look
    up meanings in different languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this example can be found in the file `src/08-dictionary-hash/01-using-dictionary-class.js`.
    Let''s start by creating the dictionary and adding some values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We use `set` to populate the dictionary with key-value pairs representing word
    translations. The keys are words in English, and the values are their Portuguese
    translations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a function so the user can interact with it to retrieve
    the translation of a particular word or phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `translateWord` function takes a `word` as input. It uses `hasKey` to check
    if the word exists in the dictionary. If the word is found, it retrieves the translation
    using the `get` method and prints it. If not found, it displays a "no translation
    found" message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try this function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check all translations available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And alls words we have transactions available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And in case we would like to print the dictionary, we can use the `forEach`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have a very similar implementation of the native JavaScript
    Map class,
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript Map class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 2015 introduced a Map class as part of the JavaScript API. We developed
    our Dictionary class based on the ES2015 Map class.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, a Map is a collection of key-value pairs, similar to a dictionary
    or hash table in other programming languages. However, unlike plain JavaScript
    objects, a Map offers several key advantages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Map class allows keys of any data type, including objects, functions, or
    even other Map objects. In contrast, object keys are automatically converted to
    strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Map class maintains the order in which key-value pairs were inserted, making
    iteration predictable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily get the number of entries using the size property, whereas with
    objects, we typically need to use `Object.keys(obj).length`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Map class natively supports iteration using `for...of` loops, making it
    more convenient to work with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the methods and features available in the native
    Map class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(key, value)`: adds or updates a key-value pair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(key)`: retrieves the value associated with the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has(key)`: checks if a key exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete(key)`: removes a key-value pair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: returns the number of entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: removes all entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach(callbackFn)`: iterates over all entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we would like to rewrite our translation application example, can we simply
    replace `Dictionary` with `Map` and the code would still work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The other methods, such as `get`, check the `size`, `has`, `values` and `forEach`
    would also work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing our custom `Dictionary` class has proven to be an enlightening
    educational endeavor, granting us a deeper understanding of the inner mechanisms
    of map data structures. While the built-in JavaScript Map class offers efficiency
    and convenience for most everyday scenarios, the experience of creating our own
    dictionary equips us with valuable knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript also supports a weak version of the Map and Set classes: `WeakMap`
    and `WeakSet`. Let''s briefly take a look at them.'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript WeakMap and WeakSet classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the standard `Map` and `Set` classes, JavaScript offers two specialized
    collection types known as `WeakMap` and `WeakSet`. These classes provide a unique
    way to manage object references and can be particularly useful in scenarios where
    memory management is a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to a `Map`, a `WeakMap` stores key-value pairs. However, the keys in
    a `WeakMap` *must* be *objects*, and the references to these keys are weak. This
    means that if the only reference to an object is its presence as a key in a `WeakMap`,
    the JavaScript garbage collector can remove that object from memory.
  prefs: []
  type: TYPE_NORMAL
- en: A `WeakSet` functions like a `Set`, storing a collection of unique values. However,
    it can only store `objects`, and the references to these objects are weak. Similar
    to `WeakMap`, if an object's only reference is its presence in a `WeakSet`, it
    can be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: '`WeakMap` and `WeakSet` also have fewer methods than their regular counterparts.
    They lack `size`, `clear`, and iteration methods (like `forEach` and `keys()`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a real-world scenario where we would use these classes. Imagine
    we are designing a program that provides a Person class. We want to store some
    sensitive private data associated with each person instance, like their social
    security number (or tax id) or medical records. However, we do not want to clutter
    the object itself with these properties, and we want to ensure they can be garbage
    collected when the Person object is no longer needed. Here is the code to exemplify
    this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A `WeakMap` is created to store the private data. The key is the `Person` object
    itself (`this`). Inside the `Person` `constructor`, we use `privateData.set(this,
    { ... })` to associate private data with the newly created person object (`this`).
    The `getSSN` method retrieves the private SSN data using `privateData.get(this)`.
    Note the **optional chaining** (`?.`) to safely handle cases where the `Person`
    object might no longer exist (and this way we do not get a *null pointer* error).
  prefs: []
  type: TYPE_NORMAL
- en: Why use a `WeakMap` instead of a `Map` here? When a Person object becomes inaccessible
    (no references to it remain), the garbage collector can remove the reference of
    the object and the associated private data in the `WeakMap`, preventing memory
    leaks. This can be considered a good practice for managing sensitive or temporary
    data that does not need to outlive the objects it is associated with.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern also could be used to implement private properties in JavaScript
    classes before the hash (#) notation was introduced to JavaScript private properties.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we understand the map or dictionary data structure, let's take it to
    the next level with hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: The hash table data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **hash table** data structure, also known as **hash map**, is a hash implementation
    of the dictionary or map data structures. A hash table is also a collection of
    key-value pairs. The key is a unique identifier, and the value is the data you
    want to associate with that key. Hash tables achieve their speed by using a **hash
    function**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how hash tables work:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hash Function*: a hash function takes a key as input and produces a unique
    numerical value called a **hash code** (or **hash value**). This hash code is
    like a fingerprint of the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storage (buckets/slots)*: the hash table internally consists of an array (or
    similar structure like a linked list) with fixed-size buckets or slots. Each bucket
    can store one or more key-value pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Insertion*: when you insert a key-value pair:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash function is applied to the key to get its hash code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash code is used to determine the index (bucket) where the key-value pair
    should be stored.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The pair is placed in that bucket.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Retrieval*: when you want to retrieve a value, you provide and key and:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash function is applied to the key again, producing the same hash code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash code is used to directly access the bucket where the value should be
    stored.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The value is found (hopefully) in that bucket.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hash tables are present in many different places. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Databases: used for indexing data for fast retrieval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Caches: store recently accessed data for quick lookups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Symbol Tables: in compilers, used to store information about variables and
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the most classical examples for a hash table is an email address book.
    For example, whenever we want to send an email, we look up the person''s name
    and retrieve their email address. The following image exemplifies this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A hash table used to store email addresses based on the contact name](img/file60.png)'
  prefs: []
  type: TYPE_IMG
- en: A hash table used to store email addresses based on the contact name
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will use a hash function which will simply sum up the ASCII
    values of each character of the key length. This is called a **lose-lose hash**
    function, which is very simple function that can lead into different issues that
    we will explore in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Let's translate this diagram into a source code by creating a `HashTable` class
    in the new topic so we can dive into this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HashTable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our hash table implementation will be located in the `src/08-dictionary-hash/hash-table.js`
    file. We begin by defining the `HashTable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This initial step simply initializes the private `#table` array, which will
    serve as the underlying storage for our key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will equip our `HashTable` class with three essential methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`put(key, value)`: this method either adds a new key-value pair to the hash
    table or updates the value associated with an existing key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`remove(key)`: this method removes the value and its corresponding key from
    the hash table based on the provided key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get(key)`: this method retrieves the value associated with a specific key
    from the hash table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To enable the functionality of these methods, we also need to create a crucial
    component: the hash function. This function will play a vital role in determining
    the storage location of each key-value pair within the hash table, making it a
    cornerstone of our implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the lose-lose hash function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before implementing the core `put`, `remove`, and `get` methods, we must first
    establish a `hash` method. This method is fundamental, as it will determine the
    storage location of key-value pairs within the hash table. The code is presented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hash` method acts as a wrapper around the `loseLoseHashCode` method, forwarding
    the provided `key` as its parameter. This wrapper design serves a strategic purpose:
    it allows for future flexibility in modifying the hash function without impacting
    other areas of our code that utilize the hash code. The `loseLoseHashCode` method
    is where the actual hash calculation takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Within `loseLoseHashCode`, we begin by checking if the key is already a string.
    If not, we convert it into a string using the `#elementToString` method we created
    in previous chapters to ensure consistent handling of keys.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we calculate a hash value by summing the ASCII values of each character
    in the key string. It leverages two powerful array methods, `split` and `reduce`,
    to achieve this efficiently. It first splits the string into an array of individual
    characters. Then, it uses the reduce method to iterate over these characters,
    accumulating their ASCII values into a single hash value. For each character,
    we retrieve its ASCII value using the `charCodeAt` method and add it to the hash
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to avoid working with potentially large numbers that might not fit
    within a numeric variable, we apply a *modulo* operation (the remainder after
    dividing one number by another) to the hash value using an arbitrary divisor (in
    this case, 37). This ensures that the resulting hash code falls within a manageable
    range, optimizing storage and retrieval within the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our hash function, we can start diving into the next methods.
  prefs: []
  type: TYPE_NORMAL
- en: Putting a key and a value in the hash table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having established our `hash` function, we can now proceed to implement the
    `put` method. This method mirrors the functionality of the `set` method in the
    `Dictionary` class, with a slight difference in naming convention to align with
    customary practice in other programming languages. The `put` method is presented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `put` method facilitates the insertion or updating of key-value pairs within
    the hash table. It first validates the provided key and value, ensuring that neither
    is `null` or `undefined`. This check prevents the storage of incomplete or meaningless
    data within the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: If both the `key` and value are deemed valid, we proceed to calculate the hash
    code for the given key. This hash code, determined by the `hash` function, will
    serve as the index for storing the value in the underlying `#table` array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the put method returns `true` to indicate that the key-value pair was
    successfully inserted or updated. Conversely, if either the key or value is invalid,
    the method returns `false`, signifying that the operation was not successful.
  prefs: []
  type: TYPE_NORMAL
- en: Once a value is present in the table, we can try to retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a value from the hash table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Retrieving a value from the `HashTable` instance is a straightforward process,
    facilitated by the `get` method. This method enables us to efficiently access
    data stored within the hash table based on its associated key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We start by validating the input key, ensuring it is not `null` or `undefined`.
    If the key is indeed valid, we proceed to determine its position within the hash
    table using the previously defined `hash` function. This function transforms the
    key into a numerical hash code, which directly corresponds to the index of the
    value in the underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging this calculated index, the method accesses the corresponding element
    in the table array and returns its value. This provides a seamless way to retrieve
    data from the hash table, as the `hash` function eliminates the need for linear
    search and directly points to the desired value's location.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that in our `HashTable` implementation, we have included
    input validation to ensure the provided keys and values are not invalid (`null`
    or `undefined`). This is a recommended practice that can be applied to all data
    structures we have developed thus far in this book. By proactively validating
    inputs, we enhance the robustness and reliability of our data structures, preventing
    errors and unexpected behavior caused by incorrect or incomplete data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Finally, let''s turn our attention to the remaining method in our class: the
    `remove` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a value from the hash table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final method we will implement for our `HashTable` is the `remove` method,
    designed to eliminate a key-value pair based on the provided key. This method
    is essential for maintaining a dynamic and adaptable hash table structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To successfully remove a value, we first need to identify its location within
    the hash table. This is achieved by obtaining the hash code corresponding to the
    given key using the `hash` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we retrieve the value pair stored at the calculated hash position. If
    this value pair is not `null` or `undefined`, indicating that the key exists within
    the hash table, we proceed to remove it. This is accomplished by utilizing the
    JavaScript `delete` operator, which effectively eliminates the key-value pair
    from the hash table's internal storage.
  prefs: []
  type: TYPE_NORMAL
- en: To provide feedback on the operation's success, we return `true` if the removal
    was successful (meaning the key existed and was deleted) and `false` if the key
    was not found in the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that, as an alternative to using the delete operator, we
    could also assign `null` or `undefined` to the corresponding hash position to
    indicate its vacancy. This approach would still effectively remove the key-value
    association from the hash table while potentially offering a different strategy
    for managing empty slots within the array.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the implementation of our class is complete, let's see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HashTable class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s illustrate how our `HashTable` class can be employed to create an email
    address book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can gain insights into the internal structure of our hash table by inspecting
    the hash codes generated for specific keys. For instance, we can observe the hash
    values calculated for "Gandalf," "John," and "Tyrion" using the hash method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The resulting hash codes (19, 29, and 16, respectively) reveal how the hash
    table distributes these keys into different positions within its underlying array.
    This distribution is crucial for efficient storage and retrieval of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the `HashTable` data structure with these
    values in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A hash table with three contacts](img/file61.png)'
  prefs: []
  type: TYPE_IMG
- en: A hash table with three contacts
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s put our `get` method to the test. By executing the following code,
    we can verify its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since "Gandalf" is a key that exists within our `HashTable`, the get method
    successfully retrieves and outputs its associated value, "gandalf@email.com".
    However, when we attempt to retrieve a value for "Loiane," a non-existent key,
    the `get` method returns undefined, indicating that the key is not present in
    the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s remove "Gandalf" from the `HashTable` using the `remove` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After removing "Gandalf," calling `hash.get('Gandalf')` now results in `undefined`.
    This confirms that the entry has been successfully deleted, and the key no longer
    exists within the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, different keys can result in identical hash values, a phenomenon
    known as a **collision**. Let's delve into how we can effectively manage collisions
    within our hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Collisions between keys in a hash table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In certain scenarios, distinct keys may produce identical hash values. We refer
    to this phenomenon as a collision, as it leads to attempts to store multiple key-value
    pairs at the same index within the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s review at the following email address book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the collision concept, let''s examine the output generated by
    evoking the `addressBook.hash` method for each name mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that multiple keys share the same hash values:'
  prefs: []
  type: TYPE_NORMAL
- en: Nathan and Sargeras both have a hash value of 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jack and Athelstan both have a hash value of 7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jonathan, Jamie, Sue, and Aethelwulf all share a hash value of 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What happens within the hash table after adding all the contacts? Which values
    are ultimately retained? To answer these questions, let''s introduce a `toString`
    method to inspect the hash table''s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `toString` method provides a string representation of the hash table's contents.
    Since we cannot directly determine which positions in the underlying array contain
    values, we utilize `Object.keys` to retrieve an array of keys from the `#table`
    object. We then iterate through these keys, constructing a formatted string that
    displays each key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon invoking `console.log(hashTable.toString())`, we observe the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In his example, Jonathan, Jamie, Sue, and Aethelwulf all share the same hash
    value of 5\. Due to the nature of our current hash table implementation, Aethelwulf,
    being the last added, occupies position 5\. The values for Jonathan, Jamie, and
    Sue have been overwritten. Similar overwriting occurs for keys with other colliding
    hash values.
  prefs: []
  type: TYPE_NORMAL
- en: Losing values due to collisions is undesirable in a hash table. The purpose
    of this data structure is to preserve all key-value pairs. To address this issue,
    we need collision resolution techniques. There are several approaches, including
    **separate chaining**, **linear probing**, and **double hashing**, we will explore
    the first two in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Handling collisions with separate chaining technique
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Separate chaining is a widely used technique to handle collisions in hash tables.
    Instead of storing a single value at each index (bucket) of the hash table, separate
    chaining allows each bucket to hold a *linked list* (or another similar data structure)
    of values. When a collision occurs (multiple keys hash to the same index), the
    new key-value pair is simply appended to the linked list at that index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize this concept, let''s consider the code used for testing in the
    previous section. If we were to apply separate chaining and represent the resulting
    structure diagrammatically, the output would resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A hash table with separate chaining technique](img/file62.png)'
  prefs: []
  type: TYPE_IMG
- en: A hash table with separate chaining technique
  prefs: []
  type: TYPE_NORMAL
- en: In this representation, position 5 would contain a linked list with four elements,
    while positions 7 and 10 would each hold linked lists with two elements. Positions
    4, 8, and 9 would each house linked lists with a single element. This illustrates
    how separate chaining effectively handles collisions by storing multiple key-value
    pairs in linked lists within the same bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some advantages of using the separate chaining technique:'
  prefs: []
  type: TYPE_NORMAL
- en: Handles collisions gracefully by not overwriting data when collisions occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation is relatively straightforward to code compared to other collision
    resolution techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists have dynamic size and can grow as needed, accommodating more collisions
    without requiring a hash table resize.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As long as the chains (linked lists) remain relatively short, search, insertion,
    and deletion operations remain efficient (close to *O(1)* in the average case),
    meaning it has satisfactory performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And as any technique, it also has some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Extra memory overhead as linked lists require additional memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the worst case, if many keys hash to the same index, the linked list could
    become long, impacting performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the practical application of separate chaining, let''s create
    a new data structure called `HashTableSeparateChaining`. This implementation will
    focus primarily on the put, get, and remove methods, showcasing how separate chaining
    enhances collision handling within a hash table. To implement separate chaining
    in our hash table, we begin with the following code, housed within the `src/08-dictionary-hash/hash-table-separate-chaining.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This initial code snippet accomplishes two key tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: It imports the `LinkedList` class from another file (`../06-linked-list/linked-list.js`)
    we previously created in *Chapter 6, Linked Lists*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also defines the `HashTableSeparateChaining` class, which will encapsulate
    our hash table functionality. The class has a private property `#table`, initialized
    as an empty array. This array will serve as the backbone of our hash table, with
    each element acting as a bucket that can potentially store a linked list of key-value
    pairs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subsequent steps will involve filling in the core methods (`put`, `get`,
    and `remove`) that leverage linked lists to efficiently handle collisions and
    manage key-value pairs within the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: Putting a key and a value with separate chaining technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s implement the first method, the put method using the separate chaining
    technique as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The put method in our `HashTableSeparateChaining` class is responsible for inserting
    or updating key-value pairs. Its first step is to validate the input, ensuring
    both the key and value are not `null` or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compute the hash code (index) using the hash function. This index determines
    the bucket where the key-value pair should be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then check if the bucket at the calculated index is empty. If it is, a new
    `LinkedList` is created to store values at this index. This is the core of separate
    chaining: using linked lists to accommodate multiple values that hash to the same
    index.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the key-value pair, encapsulated as an object `{key, value}`, is appended
    to the linked list at the specified index. If the key already exists in the linked
    list, its associated value is updated. The method returns `true` upon successful
    insertion or update, and `false` if the key or value is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a value with separate chaining technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s implement the get method to retrieve a value from our `HashTableSeparateChaining`
    class based on a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we first hash the provided key to determine its corresponding
    index in the hash table. We then access the linked list stored at that index.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a linked (`linkedList != null`), we iterate through its elements
    using a `forEach` loop, passing a callback. For each element in the linked list,
    we compare its key property to the input key. If we find a match, we return the
    corresponding value property of that element.
  prefs: []
  type: TYPE_NORMAL
- en: If the key is not found within the linked list, or if the linked list at the
    calculated index is empty, the method returns `undefined` to indicate that the
    key was not present in the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: By incorporating the linked list structure and traversal, this `get` method
    effectively handles potential collisions caused by multiple keys hashing to the
    same index, ensuring that we retrieve the correct value even in the presence of
    collisions.
  prefs: []
  type: TYPE_NORMAL
- en: The LinkedList forEach method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since our previous `LinkedList` class lacked a `forEach` method, we will need
    to add it for the efficient traversal required in the `HashTableSeparateChaining`
    class's get method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `forEach` method for the `LinkedList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `current` variable keeps track of the current node in the list. It starts
    at the head of the list (`this.#head`). The loop continues as long as there are
    nodes left to process (`current is not null`). In each iteration, the provided
    `callback` function is called, passing the element stored in the current node
    and its index as arguments. The `current` variable is updated to the next node
    in the list, moving the iteration forward.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a value with separate chaining technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing a value from the `HashTableSeparateChaining` instance presents a slight
    variation compared to the previous `remove` method we implemented. Due to the
    utilization of linked lists, we now need to specifically target and remove the
    element from the relevant linked list within the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the implementation of the `remove` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We begin by calculating the hash code (`index`) for the given key, similar to
    the `get` method. It then retrieves the linked list stored at that index. If the
    linked list exists (`linkedList != null`), we define a comparison function (`compareFunction`)
    that will be used to identify the element to be removed. This function compares
    the keys of two objects (`a` and `b`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `indexOf` method of the linked list to find the index of the
    element we want to remove. The `indexOf` method takes the element to search for
    (`{key}`) and the comparison function as arguments. If the element is found, `indexOf`
    returns its index; otherwise, it returns -1.
  prefs: []
  type: TYPE_NORMAL
- en: If the element is found (`toBeRemovedIndex >= 0`), we remove it from the linked
    list using the `removeAt` method, which removes the element at the specified index.
  prefs: []
  type: TYPE_NORMAL
- en: After removing the element, we check if the linked list is now empty. If it
    is, we set the corresponding bucket in the hash table (`this.#table[index]`) to
    `undefined`, effectively removing the empty linked list. Finally, we return `true`
    to indicate successful removal.
  prefs: []
  type: TYPE_NORMAL
- en: If the key is not found within the linked list, or if the linked list at the
    calculated index is empty, we return `false`, signaling that the key was not present
    in the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: By incorporating linked list removal logic, this enhanced `remove` method seamlessly
    integrates with the separate chaining approach, enabling efficient removal of
    key-value pairs even in the presence of collisions. Next, let's delve into a different
    technique to handle collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling collisions with the linear probing technique
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linear Probing is another technique to handle collisions in hash tables, differing
    from separate chaining in its approach to storing multiple key-value pairs with
    the same hash code.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using linked lists, linear probing directly stores all key-value
    pairs in the hash table array itself. When a collision occurs, linear probing
    sequentially searches for the next available empty slot in the array, starting
    from the original hash index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A hash table with linear probing technique](img/file63.png)'
  prefs: []
  type: TYPE_IMG
- en: A hash table with linear probing technique
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a scenario where our hash table already contains several values.
    When adding a new key-value pair, we calculate the hash for the new key. If the
    corresponding position in the table is vacant, we can directly insert the value
    at that index. However, if the position is occupied, we initiate a *linear probe*.
    We increment the index by one and check the next position. This process continues
    until we find an available slot or determine that the table is full.
  prefs: []
  type: TYPE_NORMAL
- en: Linear probing offers a simple and space-efficient collision resolution mechanism.
    However, it can lead to clustering, where consecutive occupied slots decrease
    performance as the table fills up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate linear probing in practice, we will develop a new data structure
    called `HashTableLinearProbing`. This class will reside in the `src/08-dictionary-hash/hash-table-linear-probing.js`
    file. We begin by defining the basic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This initial structure mirrors the `HashTable` class, with a private property
    `#table` initialized as an empty array to store key-value pairs. However, we will
    override the `put`, `get`, and `remove` methods to incorporate the linear probing
    technique for collision resolution. This modification will fundamentally alter
    how the hash table handles situations where multiple keys hash to the same index,
    demonstrating a distinct approach compared to separate chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Putting a key and a value with linear probing technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s implement the first of our three core methods: the `put` method.
    This method is responsible for inserting or updating key-value pairs within the
    hash table, incorporating the linear probing technique for collision resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We start by ensuring that both the key and value are valid (not `null`). We
    then calculate the hash code for the key, which determines the initial position
    where the value should be stored.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the initial position is already occupied, the linear probing process
    begins. The method enters a while loop that continues if the current index is
    occupied by a value. Inside the loop, it first checks if the `key` at the current
    index matches the provided `key`. If so, the value is updated, and `true` is returned.
    Otherwise, the index is incremented, and the process wraps around to the beginning
    of the table if necessary, continuing the search for an empty slot.
  prefs: []
  type: TYPE_NORMAL
- en: Once an empty slot is found, the key-value pair is stored at that index, and
    `true` is returned to indicate a successful insertion. If either the key or value
    is invalid, the method returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: In some programming languages, we need to define the size of the array. One
    of the concerns of using linear probing is when the array is out of unoccupied
    positions. When the algorithm reaches the end of the array, it needs to loop back
    to its beginning and continue iterating its elements - and if necessary, we also
    need to create a new bigger array and copy the elements to the new array. In JavaScript,
    we benefit from the dynamic nature of arrays, which can grow automatically as
    needed. Therefore, we do not have to explicitly manage the table's size or worry
    about running out of space. This simplifies our implementation and allows the
    hash table to adapt to the amount of data being stored.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s simulate the insertion process within our hash table using linear probing
    to handle collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Ygritte***: the hash value for "Ygritte" is 4\. Since the hash table is
    initially empty, we can directly insert it at position 4.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Jonathan***: the hash value is 5, and position 5 is available, so we insert
    "Jonathan" there.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Jamie***: this also hashes to 5, but position 5 is now occupied. We probe
    to position 6 (5 + 1), which is empty, and insert "Jamie" there.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Jack***: the hash value is 7, and position 7 is empty, so we insert "Jack"
    without any collisions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Jasmine***: the hash value is 8, and position 8 is available, so "Jasmine"
    is inserted.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Jake: The hash value is 9, and position 9 is open, allowing us to insert "Jake"
    without collision.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Nathan***: with a hash value of 10 and an empty position 10, "Nathan" is
    inserted smoothly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Athelstan***: this also hashes to 7, but position 7 is occupied by "Jack."
    We probe linearly to positions 8, 9, 10 (all occupied), and finally insert "Athelstan"
    at the first available position, 11.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Sue***: hashing to 5, we find positions 5 through 11 occupied. We continue
    probing and insert "Sue" at position 12.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Aethelwulf***: similarly hashing to 5, we probe past occupied positions
    and insert "Aethelwulf" at position 13.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Sargeras***: the hash value is 10, and positions 10 to 13 are occupied.
    We probe further and insert "Sargeras" at position 14.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This simulation highlights how linear probing resolves collisions by systematically
    searching for the next available slot in the hash table array. While effective,
    it is important to note that linear probing can lead to clustering, which can
    potentially impact the performance of subsequent insertions and retrievals.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's review how to retrieve a value.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a value with linear probing technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that our hash table contains elements, let''s implement the get method
    to retrieve values based on their corresponding keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve a value, we first need to determine its location within the hash
    table. We use the hash function to calculate the initial index for the given key.
    If the key exists within the hash table, its value should be located either at
    the initial index or somewhere further along due to potential collisions.
  prefs: []
  type: TYPE_NORMAL
- en: If the initial index is not empty (`this.#table[index] != null`), we need to
    verify whether the element at that position matches the key we are searching for.
    If the keys match, we return the corresponding value immediately.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the keys do not match, it is possible that the desired value has
    been displaced due to linear probing. We enter a `while` loop to iterate through
    subsequent positions in the table, incrementing the index and wrapping around
    if necessary. The loop continues until either the key is found, or an empty slot
    is encountered, signaling that the key does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: If, after iterating through the table, the index points to an empty slot (`undefined`
    or `null`), it means the key was not found, and the method returns `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's review how to remove values using the linear probing technique.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a value with linear probing technique
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing a value from a hash table using linear probing presents a unique challenge
    compared to other data structures. In linear probing, elements are not necessarily
    stored at the index directly calculated from their hash value due to potential
    collisions. Simply deleting the element at the hash index could disrupt the probing
    sequence and render other elements inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, we need a strategy that maintains the integrity of the probe
    sequence while still removing the desired key-value pair. There are two primary
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Soft deletion, also known as tombstone marking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hard deletion and rehashing the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the soft deletion method, instead of physically removing the element, we
    mark it as *deleted* using a special value (often called a tombstone or flag).
    This value indicates that the slot was previously occupied but is now available
    for reuse. This method is simple to implement, however, this will gradually deteriorate
    the hash table''s efficiency, as searching for key-values will become slower over
    time. This method also requires additional logic to handle tombstones during insertion
    and search operations. The following diagram demonstrates the process of the search
    operation with soft deletion method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear probing removal with soft deletion](img/file64.png)'
  prefs: []
  type: TYPE_IMG
- en: Linear probing removal with soft deletion
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach, hard deletion, involves physically removing the deleted
    element and then rehashing all subsequent elements in the probe sequence. This
    ensures that the probe sequence remains intact for future searches. In this method,
    there are no wasted spaces due to tombstones and it maintains an optimal probe
    sequence. However, it can be computationally expensive, especially for large hash
    tables or frequent deletions. This implementation is also more complex than soft
    deletion. When searching for a key, this approach prevents finding an empty spot,
    but if it is necessary to move elements, this means we will need to shift key-values
    within the hash table. The following diagram exemplifies this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear probing removal with rehashing](img/file65.png)'
  prefs: []
  type: TYPE_IMG
- en: Linear probing removal with rehashing
  prefs: []
  type: TYPE_NORMAL
- en: 'Both approaches have their pros and cons. For this chapter, we will implement
    the second approach (rehashing: move one or more elements to a backward position).
    To check the implementation of the lazy deletion approach (`HashTableLinearProbingLazy`
    class), please refer to the source code of this book. The download link for the
    source code is mentioned in the Preface of the book, or it can also be accessed
    at [http://github.com/loiane/javascript-datastructures-algorithms](http://github.com/loiane/javascript-datastructures-algorithms).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's see the code for the remove method next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the remove method with rehashing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `remove` method in our hash table closely resembles the `get` method but
    with a crucial difference. Instead of simply retrieving the value, it deletes
    the entire key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the `get` method, upon finding the key, we returned its value. However, in
    `remove`, we use the `delete` operator to eliminate the element from the hash
    table. This could be at the original hash position or a different one due to previous
    collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The challenge arises because we do not know if other elements with the same
    hash value were placed elsewhere due to a collision. If we simply delete the found
    element, we might leave gaps in the probe sequence, leading to errors when searching
    for those displaced elements. To address this, we introduce a helper method, `#verifyRemoveSideEffect`.
    This method is responsible for managing the potential side effects of removing
    an element. Its purpose is to move any collided elements backward in the probe
    sequence to fill the newly created empty spot, ensuring the integrity of the hash
    table''s structure. This process is also known as rehashing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin by initializing several variables: the `key` to be removed, the `removedPosition`
    where the key-value pair was located, the `size` of the hash table array, and
    an `index` variable to iterate through the table. The index starts at the position
    immediately after the removed element (`removedPosition + 1`).'
  prefs: []
  type: TYPE_NORMAL
- en: The core of the method lies in a `while` loop that continues as long as there
    are elements in the table to examine. In each iteration, the `key` and its hash
    value are extracted from the element at the current `index`.
  prefs: []
  type: TYPE_NORMAL
- en: A crucial condition, `currentHash <= removedPosition`, is then evaluated. This
    checks if the element's original hash value (before linear probing) falls within
    the range of indices from the start of the table up to the `removedPosition`.
    If this condition holds `true`, it implies that the element was originally placed
    further down the probe sequence due to a collision with the removed element. To
    rectify this, the element at the current `index` is moved back to the now-empty
    `removedPosition`. Its original position is then cleared, and the `removedPosition`
    is updated to the current `index`. This ensures that subsequent elements in the
    probe sequence are also considered for repositioning.
  prefs: []
  type: TYPE_NORMAL
- en: The process repeats, incrementing the index and wrapping around if the end of
    the table is reached, until all potentially affected elements have been checked
    and repositioned if necessary. By meticulously evaluating the hash values and
    repositioning elements, we guarantee that the probe sequence remains intact after
    a removal, ensuring the continued functionality and efficiency of the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simplified implementation, as we could add validations for edge cases
    and optimize the performance. However, this code demonstrates the core logic of
    how to manage the side effects of removing an element in a hash table with linear
    probing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's simulate the removal of "Jonathan" from the hash table we created earlier
    to demonstrate the process of linear probing with deletion and the subsequent
    side effect verification.
  prefs: []
  type: TYPE_NORMAL
- en: '***Locating and removing Jonathan***: we find "Jonathan" at position 5 (hash
    value 5) and remove it, leaving position 5 empty. Now, we need to assess the side
    effects of this removal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Evaluating Jamie***: we move to position 6, where "Jamie" (also with hash
    value 5) is stored. Since Jamie''s hash value is less than or equal to the removed
    position (5), we recognize that Jamie was originally placed here due to a collision.
    We copy Jamie to position 5 and delete the entry at position 6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Skipping Jack and Jasmine***: we continue to positions 7 and 8, where "Jack"
    (hash value 7) and "Jasmine" (hash value 8) are stored. Since their hash values
    are greater than both the removed position (5) and the current position (6), we
    determine that they were not affected by Jonathan''s removal and should remain
    in their current positions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We repeat this evaluation for positions 9 through 11, finding no elements that
    need repositioning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Repositioning Sue***: at position 12, we find "Sue" (hash value 5). Since
    the hash value is less than or equal to the removed position (5), we copy Sue
    to position 6 (the originally vacated position) and delete the entry at position
    12.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Repositioning Aethelwulf and Sargeras***: we continue this process for positions
    13 and 14, finding that both "Aethelwulf" (hash value 5) and "Sargeras" (hash
    value 10) need to be moved back. Aethelwulf is copied to position 12, and Sargeras
    is copied to position 13.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following these steps, the remove method, along with the `#verifyRemoveSideEffect`
    helper function, ensures that the removal of "Jonathan" does not leave any gaps
    in the probe sequence. All elements are repositioned as necessary to maintain
    the integrity and searchability of the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: In our examples, we deliberately employed the lose-lose hash function to highlight
    the occurrence of collisions and illustrate the mechanisms for resolving them.
    However, in practical scenarios, it is crucial to utilize more robust hash functions
    to minimize collisions and optimize hash table performance. We will delve into
    better hash function options in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating better hash functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A well-designed hash function strikes a balance between performance and collision
    avoidance. It should be fast to calculate for efficient insertion and retrieval
    of elements, while also minimizing the likelihood of collisions, where different
    keys produce the same hash code. While numerous implementations exist online,
    we can also craft our own custom hash function to suit specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'One alternative to the lose-lose hash function is the `djb2` hash function,
    known for its simplicity and relatively good performance. Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After transforming the `key` to a string, the key string is split into an array
    of individual characters. The `reduce` method is then employed to iterate over
    these characters, accumulating their ASCII values. Starting with an initial value
    of 5381 (a prime number that is the most common found in this algorithm), the
    reducer multiplies the accumulator by 33 (used as a magical number) and sums the
    result with the ASCII code of each character, effectively generating a sum of
    these codes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use the remainder of the division of the total by another random
    prime number (1013), greater than the size we think the hash table instance can
    have. In our scenario, let's consider 1000 as the size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the insertion scenario from the linear probing section, but
    this time using the `djb2HashCode` function instead of `loseloseHashCode`. The
    resulting hash codes for the same set of keys would be:'
  prefs: []
  type: TYPE_NORMAL
- en: 807 - Ygritte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 288 - Jonathan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 962 - Jamie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 619 - Jack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 275 - Jasmine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 877 - Jake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 223 - Nathan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 925 - Athelstan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 502 - Sue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 149 - Aethelwulf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 711 - Sargeras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notably, we observe no collisions in this scenario. This is due to the improved
    distribution of hash values provided by the `djb2HashCode` function compared to
    the simplistic `loseloseHashCode`.
  prefs: []
  type: TYPE_NORMAL
- en: While not the absolute best hash function available, `djb2HashCode` is widely
    recognized and recommended within the programming community for its simplicity,
    effectiveness, and relatively good performance in many use cases. Its ability
    to significantly reduce collisions in this example underscores the importance
    of selecting an appropriate hash function for your specific data and application
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a solid grasp of hash tables, let's revisit the concept of
    sets and explore how we can leverage hashing to enhance their implementation and
    create a powerful data structure known as a **hash set**.
  prefs: []
  type: TYPE_NORMAL
- en: The hash set data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **hash set** is a collection of unique values (no duplicates allowed). It
    combines the characteristics of a mathematical set with the efficiency of hash
    tables. Like hash tables, hash sets use a hash function to calculate a hash code
    for each element (value) we want to store. This hash code determines the index
    (bucket) where the value should be placed in an underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse the code we created in this chapter to create the hash set data
    structure as well, but with one important detail: we would need to check for duplicate
    values before the insertion operation.'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using hash sets are that it is guaranteed that all values in
    the set are unique. In JavaScript, the native Set class is considered a hash set
    data structure as well. For example, we could use a hash set to store all the
    English words (without their definitions).
  prefs: []
  type: TYPE_NORMAL
- en: Maps and TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing data structures like maps or hash maps in TypeScript can significantly
    benefit from the language's static typing capabilities. By explicitly defining
    types for variables and method parameters, we enhance code clarity, reduce the
    risk of runtime errors, and enable better tooling support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the TypeScript signature for our `HashTable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this TypeScript implementation, we introduce a generic type parameter `<V>`
    to represent the type of values stored in the hash table. This allows us to create
    hash tables that hold values of any specific type (for example: `HashTable<string>`,
    `HashTable<number>`, and so on). The `table` property is typed as an array of
    the generic type `V[]`, indicating that it stores an array of values of the specified
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A significant advantage of using TypeScript becomes evident in the `loseLoseHashCode`
    method. Since the `key` parameter is explicitly typed as a `string`, we no longer
    need to check its type within the method. The type system guarantees that only
    strings will be passed as keys, eliminating the need for redundant checks, and
    streamlining the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: By leveraging TypeScript's type system, we enhance the robustness, maintainability,
    and readability of our hash table implementation, making it easier to reason about
    and work within larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the efficiency of maps and hash maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s review the efficiency of each method by reviewing the Big O notation
    in terms of time of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Dictionary** | **Hash Table** | **Separate Chaining** | **Linear
    Probing** |'
  prefs: []
  type: TYPE_TB
- en: '| `put(key, value)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
  prefs: []
  type: TYPE_TB
- en: '| `get(key)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
  prefs: []
  type: TYPE_TB
- en: '| `remove(key)` | *O(1)* | *O(1)* | *O(1)** | *O(1)** |'
  prefs: []
  type: TYPE_TB
- en: For the `Dictionary` class, all operations are generally *O(1)* in the average
    case due to direct access to the underlying object using the stringified key.
  prefs: []
  type: TYPE_NORMAL
- en: For the `HashMap` class, similar to the dictionary, all operations are typically
    *O(1)* in the average case, assuming a good hash function. However, it lacks collision
    handling, so collisions will cause data loss or overwrite existing entries.
  prefs: []
  type: TYPE_NORMAL
- en: For the `HashTableSeparateChaining`, in the average case, all operations are
    still *O(1)*. Separate chaining effectively handles collisions, so even with some
    collisions, the linked lists at each index are likely to remain short. In the
    worst case (all keys hash to the same index), the performance degrades to *O(n)*
    as you need to traverse the entire linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the `HashTableLinearProbing`, the average case complexity is also
    *O(1)* if the hash table is sparsely populated (low load factor). However, as
    the load factor increases and collisions become more frequent, linear probing
    can lead to clustering, where multiple keys are placed in consecutive slots. This
    can degrade the worst-case performance to *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reviewing the execution time, the quality of the hash function significantly
    affects performance. A good hash function minimizes collisions, keeping performance
    closer to *O(1)*. In often cases, separate chaining tends to handle collisions
    more gracefully than linear probing, especially at higher load factors. In a hash
    table, the **load factor** is a crucial metric that measures how full the table
    is. It is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Load Factor = (Number of Elements in the Table) / (Total Number of Buckets)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s review the space complexity of each data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Structure** | **Space Complexity** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | *O(n)* | The space used grows linearly with the number of key-value
    pairs stored. Each pair occupies space in the underlying object. |'
  prefs: []
  type: TYPE_TB
- en: '| HashTable | *O(n)* | The array has a fixed size, but you still need space
    for each stored key-value pair. Unused slots also consume space, especially if
    there are few collisions. |'
  prefs: []
  type: TYPE_TB
- en: '| Separate Chaining | *O(n + m)* | *n* is the number of elements, and *m* is
    the number of buckets. In addition to the space for elements, each bucket holds
    a linked list, which adds memory overhead. |'
  prefs: []
  type: TYPE_TB
- en: '| Linear Probing | *O(n)* | Similar to the simple hash table, but linear probing
    tends to use space more efficiently than separate chaining as there are no linked
    lists. |'
  prefs: []
  type: TYPE_TB
- en: Which data structure should we use?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we store 100 elements in a hash table with 150 buckets:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Dictionary***: space usage is proportional to 100 elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***HashTable*** (no collision handling): space usage is still for 100 elements,
    plus potentially wasted space in the remaining 50 empty buckets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***HashTableSeparateChaining***: space usage is for 100 elements, plus the
    overhead of the linked lists in each bucket (which could vary depending on how
    many collisions there are).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***HashTableLinearProbing***: space usage is likely closer to 100 elements,
    as it tries to fill the array more densely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the day, it all depends on the scenario we are working with.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put our knowledge into practice with some exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will resolve one exercise from **LeetCode** using the map data structure
    to transform integer numbers to roman numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are many fun exercises available in LeetCode that we should
    be able to resolve with the concepts we learned in this chapter. Below are some
    additional suggestions you can try to resolve, and you can also find the solution
    along with the explanation within the source code from this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Two Sum: given an array of integers, find two numbers that add up to a
    target sum. This is a classic problem that introduces you to using a hash map
    to store complements and quickly find matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '242\. Valid Anagram: determine if two strings are anagrams of each other (contain
    the same characters but in a different order). Hash maps are useful for counting
    character frequencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '705\. Design HashSet: implement the hash set data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '706\. Design HashMap: implement the hash map data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '13\. Roman to Integer: similar to the problem we will resolve, but the other
    way around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer to Roman
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exercise we will resolve the is the *12\. Integer to Roman* problem available
    at [https://leetcode.com/problems/integer-to-roman/description/](https://leetcode.com/problems/integer-to-roman/description/).
  prefs: []
  type: TYPE_NORMAL
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function function intToRoman(num: number): string, which
    receives a numerical input and returns its corresponding Roman numeral representation
    as a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore a solution using a map data structure to facilitate the conversion
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: At the heart of this function lies the `romanMap`, which acts as a dictionary,
    associating Roman numeral symbols with their corresponding integer values. This
    map includes both standard Roman numerals (M, D, C) and special combinations for
    subtraction (CM, XC). The arrangement of keys in descending order of value is
    crucial for the greedy algorithm employed in the conversion process so we do not
    need to sort the data structure before the conversion process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize an empty string, `result`, to accumulate the Roman numeral
    characters. It then enters a loop that iterates through the keys of the `romanMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, a nested `while` loop repeatedly checks if the input number
    (`num`) is greater than or equal to the integer value of the current Roman numeral.
    If so, the Roman numeral is appended to the `result` string, and its integer value
    is subtracted from `num`. This process continues until `num` becomes smaller than
    the value of the Roman numeral, indicating that we need to move on to the next
    smaller numeral in the map.
  prefs: []
  type: TYPE_NORMAL
- en: By iteratively selecting the largest possible Roman numeral that fits the remaining
    input value, the function constructs the Roman numeral representation in a *greedy*
    manner. Once the entire `romanMap` has been traversed, the function returns the
    completed result string, which now holds the accurate Roman numeral equivalent
    of the original input integer.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of this function is *O(1)*. It iterates over a fixed set
    of Roman numeral symbols (13 symbols in total). For each symbol, it performs a
    series of subtractions and concatenations. The number of operations is bounded
    by the number of symbols and the maximum value of the input number, but since
    the set of symbols and their values are constant, the operations do not scale
    with the input size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The space complexity is also *O(1)*. The `romanMap` object is a constant and
    its size does not change with the input, so it contributes a constant space overhead.
    The result string grows based on the number of Roman numeral characters needed
    to represent the input number. However, since the maximum number of characters
    needed to represent any integer in Roman numerals is fixed (for example: 3999
    is MMMCMXCIX), this also contributes a constant space overhead. No additional
    data structures are used that scale with the input size.'
  prefs: []
  type: TYPE_NORMAL
- en: We could also use the native `Map` class to store the `romanMap` key-value pairs,
    however, in the `for` loop, we would need to extract they keys and sort them first.
    The `Map` class does not guarantee the order of keys, so we would need to extract
    and sort the keys before iterating, which adds overhead. So, in this case, the
    simplest data structure works in our favour for a more performant solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we explored the world of dictionaries, mastering the techniques
    to add, remove, and retrieve elements, while also understanding how they differ
    from sets. We delved into the concept of hashing, learning how to construct hash
    tables (or hash maps) and implement fundamental operations like insertion, deletion,
    and retrieval. Moreover, we learned how to craft hash functions and examined two
    distinct techniques for handling collisions: separate chaining and linear probing.'
  prefs: []
  type: TYPE_NORMAL
- en: We also explored JavaScript's built-in `Map` class, as well as the specialized
    `WeakMap` and `WeakSet` classes, which offer unique capabilities for memory management.
    Through a variety of practical examples and a LeetCode exercise, we solidified
    our understanding of these data structures and their applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equipped with this knowledge, we are now prepared to tackle the concept of
    **recursion** in the next chapter, paving the way for our exploration of another
    essential data structure: **trees**.'
  prefs: []
  type: TYPE_NORMAL
