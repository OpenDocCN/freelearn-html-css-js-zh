- en: Chapter 3. Using Iterators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用迭代器
- en: ES6 introduces new object interfaces and loops for iteration. The addition of
    the new iteration protocols opens up a new world of algorithms and abilities for
    JavaScript. We will start the chapter by introducing the symbols and various properties
    of the `Symbol` object. We will also learn how the execution stacks are created
    for the nested function calls, their impacts, and how to optimize their performance
    and memory usage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了新的对象接口和循环用于迭代。新迭代协议的添加为JavaScript打开了算法和能力的新世界。我们将从介绍符号和`Symbol`对象的各个属性开始本章。我们还将学习嵌套函数调用的执行栈是如何创建的，它们的影响，以及如何优化它们的性能和内存使用。
- en: Although symbols are a separate topic to iterators, we will still be covering
    symbols in this chapter because to implement the iterable protocol, you need to
    use symbols.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管符号是迭代器的一个独立主题，但我们仍将在本章中介绍符号，因为要实现迭代协议，你需要使用符号。
- en: 'In this chapter, we''ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using symbols as the object property keys
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号作为对象属性键
- en: Implementing the iteration protocols in the objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象中实现迭代协议
- en: Creating and using the generator objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用生成器对象
- en: Using the `for…of` loop for iterating
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for...of`循环进行迭代
- en: The tail call optimization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: The ES6 symbols
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6符号
- en: 'ES6 symbols are the new primitive type introduced in ES6\. A symbol is a unique
    and immutable value. Here is an example code, which shows how to create a symbol:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ES6符号是ES6中引入的新原始类型。符号是一个唯一且不可变的值。以下是一个示例代码，展示了如何创建一个符号：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Symbols don't have a literal form; therefore, we need to use the `Symbol()`
    function to create a symbol. The `Symbol()` function returns a unique symbol every
    time it is called.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 符号没有字面形式；因此，我们需要使用`Symbol()`函数来创建一个符号。每次调用`Symbol()`函数时，它都会返回一个唯一的符号。
- en: 'The `Symbol()` function takes an optional string parameter that represents
    the description of the symbol. A description of a symbol can be used for debugging,
    but not to access the symbol itself. Two symbols with the same description are
    not equal at all. Here is an example to demonstrate this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol()`函数接受一个可选的字符串参数，表示符号的描述。符号的描述可用于调试，但不能用于访问符号本身。具有相同描述的两个符号完全不等于彼此。以下是一个示例来演示这一点：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding example, we can also say that a symbol is a *string-like*
    value that can't collide with any other value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们也可以说，符号是一个类似字符串的值，它不会与其他任何值冲突。
- en: The "typeof" operator
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"typeof"运算符'
- en: 'The `typeof` operator outputs `"symbol"` when applied on a variable, holding
    a symbol. Here is an example to demonstrate this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于包含符号的变量时，`typeof`运算符输出`"symbol"`。以下是一个示例来演示这一点：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `typeof` operator is the only way to identify whether a variable is
    holding a symbol.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`typeof`运算符是唯一识别变量是否包含符号的方法。
- en: The "new" operator
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"new"运算符'
- en: 'You cannot apply the `new` operator on the `Symbol()` function. The `Symbol()`
    function detects if it''s being used as an constructor, and if `true`, it then
    throws an exception. Here is an example to demonstrate this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在`Symbol()`函数上应用`new`运算符。`Symbol()`函数会检测它是否被用作构造函数，如果是，则抛出异常。以下是一个示例来演示这一点：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But the JavaScript engine can internally use the `Symbol()` function as an constructor
    to wrap a symbol in an object. Therefore, "`s`" will be equal to `Object(s)`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但JavaScript引擎可以内部使用`Symbol()`函数作为构造函数来包装一个符号。因此，"`s`"将等于`Object(s)`。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the primitive types that are introduced from ES6 onwards will not allow
    their constructors to be invoked manually.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从ES6开始引入的所有原始类型都不会允许手动调用它们的构造函数。
- en: Using symbols as property keys
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用符号作为属性键
- en: 'Till ES5, the JavaScript object property keys had to be string type. But in
    ES6, the JavaScript object property keys can be strings or symbols. Here is an
    example that demonstrates how to use a symbol as an object property key:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 直到ES5，JavaScript对象属性键必须是字符串类型。但在ES6中，JavaScript对象属性键可以是字符串或符号。以下是一个示例，演示如何使用符号作为对象属性键：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the preceding code, you can see that in order to create or retrieve a property
    key using symbols, you need to use the `[]` token. We saw the `[]` token while
    discussing the computed property names in [Chapter 2](ch02.html "Chapter 2. Knowing
    Your Library"), *Knowing Your Library*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，你可以看到，为了使用符号创建或检索属性键，你需要使用`[]`标记。我们在讨论[第2章](ch02.html "第2章。了解你的库")中的计算属性名称时看到了`[]`标记，即*了解你的库*。
- en: To access a symbol property key, we need the symbol. In the previous example,
    both `s1` and `s2` hold the same symbol value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问符号属性键，我们需要符号。在前面示例中，`s1` 和 `s2` 都持有相同的符号值。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The primary reason for introducing symbols in ES6 was so that it can be used
    as a key for object property, and prevent the accidental collision of the property
    keys.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中引入符号的主要原因是使其可以作为对象属性的键使用，并防止属性键的意外冲突。
- en: The Object.getOwnPropertySymbols() method
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertySymbols()` 方法'
- en: 'The `Object.getOwnPropertyNames()` method cannot retrieve the symbol properties.
    Therefore, ES6 introduced `Object.getOwnPropertySymbols()` to retrieve an array
    of symbol properties of an object. Here is an example to demonstrate this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertyNames()` 方法不能检索符号属性。因此，ES6 引入了 `Object.getOwnPropertySymbols()`
    来检索对象符号属性数组。以下是一个示例来演示这一点：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the previous example, you can see that the `Object.getOwnPropertySymbols()`
    method can also retrieve the non-enumerable symbol properties.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，你可以看到 `Object.getOwnPropertySymbols()` 方法也可以检索不可枚举的符号属性。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `in` operator can find the symbol properties in an object, whereas the `for…in`
    loop and `Object.getOwnPropertyNames()` cannot find the symbol properties in an
    object for the sake of backward compatibility.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 操作符可以在对象中找到符号属性，而 `for…in` 循环和 `Object.getOwnPropertyNames()` 由于向后兼容性原因不能在对象中找到符号属性。'
- en: The Symbol.for(string) method
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Symbol.for(string)` 方法'
- en: The `Symbol` object maintains a registry of the key/value pairs, where the key
    is the symbol description, and the value is the symbol. Whenever we create a symbol
    using the `Symbol.for()` method, it gets added to the registry and the method
    returns the symbol. If we try to create a symbol with a description that already
    exists, then the existing symbol will be retrieved.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol` 对象维护一个键/值对的注册表，其中键是符号描述，值是符号。每次我们使用 `Symbol.for()` 方法创建符号时，它都会被添加到注册表中，并且该方法返回符号。如果我们尝试使用已存在的描述创建符号，那么将检索现有的符号。'
- en: 'The advantage of using the `Symbol.for()` method instead of the `Symbol()`
    method to create symbols is that while using the `Symbol.for()` method, you don''t
    have to worry about making the symbol available globally, because its always available
    globally. Here is an example to demonstrate this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Symbol.for()` 方法而不是 `Symbol()` 方法创建符号的优势在于，在使用 `Symbol.for()` 方法时，你不必担心使符号在全局范围内可用，因为它始终在全局范围内可用。以下是一个示例来演示这一点：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The well-known symbols
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已知符号
- en: 'In addition to your own symbols, ES6 comes up with a built-in set of symbols,
    known as the **well-known** symbols. Here is a list of properties, referencing
    some important built-in symbols:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你自己的符号外，ES6 还提供了一套内置的符号，称为**已知符号**。以下是一个属性列表，引用了一些重要的内置符号：
- en: '`Symbol.iterator`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.iterator`'
- en: '`Symbol.match`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.match`'
- en: '`Symbol.search`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.search`'
- en: '`Symbol.replace`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.replace`'
- en: '`Symbol.split`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.split`'
- en: '`Symbol.hasInstance`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.hasInstance`'
- en: '`Symbol.species`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.species`'
- en: '`Symbol.unscopables`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.unscopables`'
- en: '`Symbol.isContcatSpreadable`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.isContcatSpreadable`'
- en: '`Symbol.toPrimitive`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.toPrimitive`'
- en: '`Symbol.toStringTag`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.toStringTag`'
- en: You will come across the use of these symbols in various chapters of this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书的各个章节中遇到这些符号的使用。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While referring to the well-known symbols in the text, we usually prefix them
    using the `@@` notation. For example, the `Symbol.iterator` symbol is referred
    to as the `@@iterator` method. This is done to make it easier to refer to the
    well-known symbols in the text.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用文本中的已知符号时，我们通常使用 `@@` 符号作为前缀。例如，`Symbol.iterator` 符号被称为 `@@iterator` 方法。这样做是为了使在文本中引用已知符号更容易。
- en: The iteration protocols
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代协议
- en: An iteration protocol is a set of rules that an object needs to follow for implementing
    the interface, which when used, a loop or a construct can iterate over a group
    of values of the object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代协议是一组规则，对象需要遵循这些规则以实现接口，当使用这些规则时，循环或构造可以遍历对象的一组值。
- en: ES6 introduces two new iteration protocols known as the **iterable protocol**,
    and the iterator protocol.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 引入了两种新的迭代协议，称为**可迭代协议**和迭代器协议。
- en: The iterator protocol
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器协议
- en: Any object that implements the iterator protocol is known as an iterator. According
    to the iterator protocol, an object needs to provide a `next()` method that returns
    the next item in the sequence of a group of items.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现迭代器协议的对象都称为迭代器。根据迭代器协议，一个对象需要提供一个 `next()` 方法，该方法返回一组项目序列中的下一个项目。
- en: 'Here is an example to demonstrate this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示此点的例子：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Every time the `next()` method is called, it returns an object with two properties:
    `value` and `done`. Let''s see what these two properties represent:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `next()` 方法时，它返回一个具有两个属性的对象：`value` 和 `done`。让我们看看这两个属性代表什么：
- en: 'The `done` property: This returns `true` if the iterator has finished iterating
    over the collection of values. Otherwise, this returns as `false`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done` 属性：如果迭代器已经遍历完值集合，则返回 `true`。否则，返回 `false`。'
- en: 'The `value` property: This holds the value of the current item in the collection.
    It is omitted when the `done` property is `true`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` 属性：持有集合中当前项的值。当 `done` 属性为 `true` 时，该值被省略。'
- en: The iterable protocol
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可迭代协议
- en: Any object that implements the iterable protocol is known as an iterable. According
    to the iterable protocol, an object needs to provide the `@@iterator` method;
    that is, it must have the `Symbol.iterator` symbol as a property key. The `@@iterator`
    method must return an iterator object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现可迭代协议的对象都称为可迭代对象。根据可迭代协议，一个对象需要提供 `@@iterator` 方法；也就是说，它必须具有 `Symbol.iterator`
    符号作为属性键。`@@iterator` 方法必须返回一个迭代器对象。
- en: 'Here is an example to demonstrate this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示此点的例子：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Generators
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: A generator function is like a normal function, but instead of returning a single
    value, it returns multiple values one by one. Calling a generator function doesn't
    execute its body immediately, but rather returns a new instance of the generator
    object (that is, an object that implements both, iterable and iterator protocols).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数就像一个普通函数一样，但它不是返回单个值，而是逐个返回多个值。调用生成器函数不会立即执行其主体，而是返回一个生成器对象的新实例（即实现迭代器和可迭代协议的对象）。
- en: Every generator object holds a new execution context of the generator function.
    When we execute the `next()` method of the generator object, it executes the generator
    function's body until the `yield` keyword is encountered. It returns the yielded
    value, and pauses the function. When the `next()` method is called again, it resumes
    the execution, and then returns the next yielded value. The `done` property is
    true when the generator function doesn't yield any more value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生成器对象都持有生成器函数的新执行上下文。当我们执行生成器对象的 `next()` 方法时，它会执行生成器函数的主体，直到遇到 `yield` 关键字。它返回产生值，并暂停函数。当再次调用
    `next()` 方法时，它继续执行，然后返回下一个产生值。当生成器函数不再产生任何值时，`done` 属性为 `true`。
- en: 'A generator function is written using the `function*` expression. Here is an
    example to demonstrate this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数使用 `function*` 表达式编写。以下是一个演示此点的例子：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is an expression following the `yield` keyword. The value of the expression
    is what returned by the generator function via the iterable protocol. If we omit
    the expression, then `undefined` is returned. The value of the expression is what
    we call as the yielded value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `yield` 关键字之后有一个表达式。该表达式的值是通过可迭代协议由生成器函数返回的。如果我们省略该表达式，则返回 `undefined`。该表达式的值就是我们所说的产生值。
- en: 'We can also pass an optional argument to the `next()` method. This argument
    becomes the value returned by the `yield` statement, where the generator function
    is currently paused. Here is an example to demonstrate this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向 `next()` 方法传递一个可选参数。这个参数成为生成器函数暂停时 `yield` 语句返回的值。以下是一个演示此点的例子：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The return(value) method
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`return(value)` 方法'
- en: You can anytime end a generator function before it has yielded all the values
    using the `return()` method of the generator object. The `return()` method takes
    an optional argument, representing the final value to return.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用生成器对象的 `return()` 方法在任何时候结束生成器函数，即使它还没有产生所有值。`return()` 方法接受一个可选参数，表示要返回的最终值。
- en: 'Here is an example demonstrating this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示此点的例子：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The throw(exception) method
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`throw(exception)` 方法'
- en: 'You can manually trigger an exception inside a generator function using the
    `throw()` method of the generator object. You must pass an exception to the `throw()`
    method that you want to throw. Here is an example to demonstrate this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用生成器对象的 `throw()` 方法在生成器函数内部手动触发异常。您必须向 `throw()` 方法传递您想要抛出的异常。以下是一个演示此点的例子：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, you can see that the exception is thrown where the
    function was paused the last time. After the exception is handled, the `throw()`
    method continuous execution, and returns the next yielded value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到异常是在函数上次暂停的地方抛出的。在异常被处理后，`throw()`方法继续执行，并返回下一个产生的值。
- en: The "yield*" keyword
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “yield*”关键字
- en: 'The `yield*` keyword inside a generator function takes an iterable object as
    the expression and iterates it to yield its values. Here is an example to demonstrate
    this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数内部的`yield*`关键字将一个可迭代对象作为表达式并迭代它以产生其值。以下是一个演示此功能的示例：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The "for…of" loop
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “for…of”循环
- en: Until now, we were iterating over an iterable object using the `next()` method,
    which is a cumbersome task. ES6 introduced the `for…of` loop to make this task
    easier.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`next()`方法迭代可迭代对象，这是一个繁琐的任务。ES6引入了`for…of`循环来简化这个任务。
- en: 'The `for…of` loop was introduced to iterate over the values of an iterable
    object. Here is an example to demonstrate this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`for…of`循环被引入来迭代可迭代对象的值。以下是一个演示此功能的示例：'
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The tail call optimization
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: Whenever a function call is made, an execution stack is created in the stack
    memory to store the variables of the function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每当进行函数调用时，都会在栈内存中创建一个执行栈来存储函数的变量。
- en: 'When a function call is made inside another function call, a new execution
    stack is created for the inner function call. But the problem is that the inner
    function execution stack takes up some extra memory, that is, it stores an extra
    address, representing where to resume the execution when this function finishes
    executing. Switching and creating the execution stacks also takes some additional
    CPU time. This problem is not noticeable when there are a couple or hundreds of
    nested levels of calls, but it''s noticeable when there are thousands or more
    of the nested levels of calls, that is, the JavaScript engines throw the `RangeError:
    Maximum call stack size exceeded` exception. You might have, at some point, experienced
    the `RangeError` exception while creating a recursive function.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '当在另一个函数调用内部进行函数调用时，会为内部函数调用创建一个新的执行栈。但问题是，内部函数执行栈会占用一些额外的内存，即它存储了一个额外的地址，表示当此函数执行完毕时如何恢复执行。切换和创建执行栈也会消耗一些额外的CPU时间。当有少量或几百层嵌套调用时，这个问题并不明显，但当有数千或更多层嵌套调用时，这个问题就明显了，即JavaScript引擎会抛出`RangeError:
    Maximum call stack size exceeded`异常。你可能在创建递归函数时遇到过`RangeError`异常。'
- en: A **tail call** is a function call, performed optionally at the very end of
    a function with the `return` statement. If a tail call leads to the same function
    call again and again, then it's called as a **tail-recursion**, which is a special
    case of recursion. What's special about tail calls is that there is a way to actually
    prevent the extra CPU-time and memory usage while making the tail calls, which
    is to reuse the stack of the out function, instead of creating a new execution
    stack thereby saving the CPU time and the extra memory usage. Reusing the execution
    stack while making a tail call is called as the **tail call optimization**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**尾调用**是一种函数调用，它可选地出现在函数的`return`语句的末尾。如果一个尾调用反复调用同一个函数，那么它被称为**尾递归**，这是递归的一个特例。尾调用的特别之处在于，有一种方法可以在进行尾调用时实际上防止额外的CPU时间和内存使用，那就是重用外函数的栈，而不是创建一个新的执行栈，从而节省CPU时间和额外的内存使用。在执行尾调用时重用执行栈被称为**尾调用优化**。'
- en: 'ES6 adds the support for a tail call optimization if the script is written
    in the `"use` `strict"` mode. Let''s see an example of a tail call:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ES6在脚本以`"use strict"`模式编写时增加了对尾调用优化的支持。让我们看看一个尾调用的例子：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the `_add()` call in the `add1()` function is a tail call, as it's the
    final action of the `add1()` function. But the `_add()` call in the `add2()` function
    is not a tail call, as it's not the final action, which is adding `0` to the result
    of `_add()` is the final action.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`add1()`函数中的`_add()`调用是一个尾调用，因为它是`add1()`函数的最终操作。但`add2()`函数中的`_add()`调用不是尾调用，因为它不是最终操作，将`0`添加到`_add()`的结果才是最终操作。
- en: The `_add()` call in `add1()` doesn't create a new execution stack. Instead,
    it reuses the `add1()` function's execution stack; in other words, the tail call
    optimization occurs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`add1()`函数中的`_add()`调用不会创建一个新的执行栈。相反，它重用了`add1()`函数的执行栈；换句话说，发生了尾调用优化。'
- en: Converting the non-tail calls into the tail calls
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将非尾调用转换为尾调用
- en: As the tail calls are optimized, you must use the tail calls whenever possible,
    instead of the non-tail calls. You can optimize your code by converting the non-tail
    calls into the tail calls.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尾调用得到了优化，因此你必须在可能的情况下使用尾调用，而不是非尾调用。你可以通过将非尾调用转换为尾调用来优化你的代码。
- en: 'Let''s see an example of converting a non-tail call into a tail call, which
    is similar to the previous:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将非尾调用转换为尾调用的一个例子，这与之前的例子类似：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous code, the `_add()` call was not a tail call and therefore,
    two execution stacks were created. We can convert it into a tail call in this
    way:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`_add()`调用不是一个尾调用，因此创建了两个执行栈。我们可以这样将其转换为尾调用：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we omitted the use of the `result` variable and instead, we lined up the
    function call with the `return` statement. Similarly, there are many other strategies
    to convert the non-tail calls into the tail calls.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们省略了`result`变量的使用，而是将函数调用与`return`语句并排排列。同样，还有许多其他策略可以将非尾调用转换为尾调用。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned a new way of creating the object property keys using
    symbols. We saw the iterator and iterable protocols, and learned how to implement
    these protocols in the custom objects. Then, we learned how to iterate over an
    iterable object using the `for…of` loop. Finally, we ended the chapter by learning
    what tail calls are, and how they are optimized in ES6.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一种使用符号创建对象属性键的新方法。我们看到了迭代器和可迭代协议，并学习了如何在自定义对象中实现这些协议。然后，我们学习了如何使用`for…of`循环遍历可迭代对象。最后，我们通过学习尾调用是什么以及它们在ES6中的优化来结束本章。
- en: In the next chapter, we will learn what Promises are, and how to write a better
    asynchronous code using Promises.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习什么是Promise，以及如何使用Promise编写更好的异步代码。
