- en: Chapter 3. Using Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 introduces new object interfaces and loops for iteration. The addition of
    the new iteration protocols opens up a new world of algorithms and abilities for
    JavaScript. We will start the chapter by introducing the symbols and various properties
    of the `Symbol` object. We will also learn how the execution stacks are created
    for the nested function calls, their impacts, and how to optimize their performance
    and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Although symbols are a separate topic to iterators, we will still be covering
    symbols in this chapter because to implement the iterable protocol, you need to
    use symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using symbols as the object property keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the iteration protocols in the objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using the generator objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `for…of` loop for iterating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tail call optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ES6 symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 symbols are the new primitive type introduced in ES6\. A symbol is a unique
    and immutable value. Here is an example code, which shows how to create a symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Symbols don't have a literal form; therefore, we need to use the `Symbol()`
    function to create a symbol. The `Symbol()` function returns a unique symbol every
    time it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Symbol()` function takes an optional string parameter that represents
    the description of the symbol. A description of a symbol can be used for debugging,
    but not to access the symbol itself. Two symbols with the same description are
    not equal at all. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding example, we can also say that a symbol is a *string-like*
    value that can't collide with any other value.
  prefs: []
  type: TYPE_NORMAL
- en: The "typeof" operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `typeof` operator outputs `"symbol"` when applied on a variable, holding
    a symbol. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the `typeof` operator is the only way to identify whether a variable is
    holding a symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The "new" operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You cannot apply the `new` operator on the `Symbol()` function. The `Symbol()`
    function detects if it''s being used as an constructor, and if `true`, it then
    throws an exception. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But the JavaScript engine can internally use the `Symbol()` function as an constructor
    to wrap a symbol in an object. Therefore, "`s`" will be equal to `Object(s)`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the primitive types that are introduced from ES6 onwards will not allow
    their constructors to be invoked manually.
  prefs: []
  type: TYPE_NORMAL
- en: Using symbols as property keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Till ES5, the JavaScript object property keys had to be string type. But in
    ES6, the JavaScript object property keys can be strings or symbols. Here is an
    example that demonstrates how to use a symbol as an object property key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, you can see that in order to create or retrieve a property
    key using symbols, you need to use the `[]` token. We saw the `[]` token while
    discussing the computed property names in [Chapter 2](ch02.html "Chapter 2. Knowing
    Your Library"), *Knowing Your Library*.
  prefs: []
  type: TYPE_NORMAL
- en: To access a symbol property key, we need the symbol. In the previous example,
    both `s1` and `s2` hold the same symbol value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary reason for introducing symbols in ES6 was so that it can be used
    as a key for object property, and prevent the accidental collision of the property
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: The Object.getOwnPropertySymbols() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Object.getOwnPropertyNames()` method cannot retrieve the symbol properties.
    Therefore, ES6 introduced `Object.getOwnPropertySymbols()` to retrieve an array
    of symbol properties of an object. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From the previous example, you can see that the `Object.getOwnPropertySymbols()`
    method can also retrieve the non-enumerable symbol properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `in` operator can find the symbol properties in an object, whereas the `for…in`
    loop and `Object.getOwnPropertyNames()` cannot find the symbol properties in an
    object for the sake of backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The Symbol.for(string) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Symbol` object maintains a registry of the key/value pairs, where the key
    is the symbol description, and the value is the symbol. Whenever we create a symbol
    using the `Symbol.for()` method, it gets added to the registry and the method
    returns the symbol. If we try to create a symbol with a description that already
    exists, then the existing symbol will be retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using the `Symbol.for()` method instead of the `Symbol()`
    method to create symbols is that while using the `Symbol.for()` method, you don''t
    have to worry about making the symbol available globally, because its always available
    globally. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The well-known symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to your own symbols, ES6 comes up with a built-in set of symbols,
    known as the **well-known** symbols. Here is a list of properties, referencing
    some important built-in symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol.iterator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.match`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.search`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.replace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.split`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.hasInstance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.species`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.unscopables`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.isContcatSpreadable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.toPrimitive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol.toStringTag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will come across the use of these symbols in various chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While referring to the well-known symbols in the text, we usually prefix them
    using the `@@` notation. For example, the `Symbol.iterator` symbol is referred
    to as the `@@iterator` method. This is done to make it easier to refer to the
    well-known symbols in the text.
  prefs: []
  type: TYPE_NORMAL
- en: The iteration protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An iteration protocol is a set of rules that an object needs to follow for implementing
    the interface, which when used, a loop or a construct can iterate over a group
    of values of the object.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 introduces two new iteration protocols known as the **iterable protocol**,
    and the iterator protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any object that implements the iterator protocol is known as an iterator. According
    to the iterator protocol, an object needs to provide a `next()` method that returns
    the next item in the sequence of a group of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time the `next()` method is called, it returns an object with two properties:
    `value` and `done`. Let''s see what these two properties represent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `done` property: This returns `true` if the iterator has finished iterating
    over the collection of values. Otherwise, this returns as `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `value` property: This holds the value of the current item in the collection.
    It is omitted when the `done` property is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterable protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any object that implements the iterable protocol is known as an iterable. According
    to the iterable protocol, an object needs to provide the `@@iterator` method;
    that is, it must have the `Symbol.iterator` symbol as a property key. The `@@iterator`
    method must return an iterator object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generator function is like a normal function, but instead of returning a single
    value, it returns multiple values one by one. Calling a generator function doesn't
    execute its body immediately, but rather returns a new instance of the generator
    object (that is, an object that implements both, iterable and iterator protocols).
  prefs: []
  type: TYPE_NORMAL
- en: Every generator object holds a new execution context of the generator function.
    When we execute the `next()` method of the generator object, it executes the generator
    function's body until the `yield` keyword is encountered. It returns the yielded
    value, and pauses the function. When the `next()` method is called again, it resumes
    the execution, and then returns the next yielded value. The `done` property is
    true when the generator function doesn't yield any more value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generator function is written using the `function*` expression. Here is an
    example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There is an expression following the `yield` keyword. The value of the expression
    is what returned by the generator function via the iterable protocol. If we omit
    the expression, then `undefined` is returned. The value of the expression is what
    we call as the yielded value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass an optional argument to the `next()` method. This argument
    becomes the value returned by the `yield` statement, where the generator function
    is currently paused. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The return(value) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can anytime end a generator function before it has yielded all the values
    using the `return()` method of the generator object. The `return()` method takes
    an optional argument, representing the final value to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example demonstrating this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The throw(exception) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can manually trigger an exception inside a generator function using the
    `throw()` method of the generator object. You must pass an exception to the `throw()`
    method that you want to throw. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you can see that the exception is thrown where the
    function was paused the last time. After the exception is handled, the `throw()`
    method continuous execution, and returns the next yielded value.
  prefs: []
  type: TYPE_NORMAL
- en: The "yield*" keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `yield*` keyword inside a generator function takes an iterable object as
    the expression and iterates it to yield its values. Here is an example to demonstrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The "for…of" loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we were iterating over an iterable object using the `next()` method,
    which is a cumbersome task. ES6 introduced the `for…of` loop to make this task
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for…of` loop was introduced to iterate over the values of an iterable
    object. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The tail call optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a function call is made, an execution stack is created in the stack
    memory to store the variables of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function call is made inside another function call, a new execution
    stack is created for the inner function call. But the problem is that the inner
    function execution stack takes up some extra memory, that is, it stores an extra
    address, representing where to resume the execution when this function finishes
    executing. Switching and creating the execution stacks also takes some additional
    CPU time. This problem is not noticeable when there are a couple or hundreds of
    nested levels of calls, but it''s noticeable when there are thousands or more
    of the nested levels of calls, that is, the JavaScript engines throw the `RangeError:
    Maximum call stack size exceeded` exception. You might have, at some point, experienced
    the `RangeError` exception while creating a recursive function.'
  prefs: []
  type: TYPE_NORMAL
- en: A **tail call** is a function call, performed optionally at the very end of
    a function with the `return` statement. If a tail call leads to the same function
    call again and again, then it's called as a **tail-recursion**, which is a special
    case of recursion. What's special about tail calls is that there is a way to actually
    prevent the extra CPU-time and memory usage while making the tail calls, which
    is to reuse the stack of the out function, instead of creating a new execution
    stack thereby saving the CPU time and the extra memory usage. Reusing the execution
    stack while making a tail call is called as the **tail call optimization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 adds the support for a tail call optimization if the script is written
    in the `"use` `strict"` mode. Let''s see an example of a tail call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `_add()` call in the `add1()` function is a tail call, as it's the
    final action of the `add1()` function. But the `_add()` call in the `add2()` function
    is not a tail call, as it's not the final action, which is adding `0` to the result
    of `_add()` is the final action.
  prefs: []
  type: TYPE_NORMAL
- en: The `_add()` call in `add1()` doesn't create a new execution stack. Instead,
    it reuses the `add1()` function's execution stack; in other words, the tail call
    optimization occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the non-tail calls into the tail calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the tail calls are optimized, you must use the tail calls whenever possible,
    instead of the non-tail calls. You can optimize your code by converting the non-tail
    calls into the tail calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of converting a non-tail call into a tail call, which
    is similar to the previous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the `_add()` call was not a tail call and therefore,
    two execution stacks were created. We can convert it into a tail call in this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we omitted the use of the `result` variable and instead, we lined up the
    function call with the `return` statement. Similarly, there are many other strategies
    to convert the non-tail calls into the tail calls.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a new way of creating the object property keys using
    symbols. We saw the iterator and iterable protocols, and learned how to implement
    these protocols in the custom objects. Then, we learned how to iterate over an
    iterable object using the `for…of` loop. Finally, we ended the chapter by learning
    what tail calls are, and how they are optimized in ES6.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn what Promises are, and how to write a better
    asynchronous code using Promises.
  prefs: []
  type: TYPE_NORMAL
