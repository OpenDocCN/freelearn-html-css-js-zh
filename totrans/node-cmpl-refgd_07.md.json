["```js\nconst logger = require('morgan'); \n.. \napp.use(logger('dev')); \n```", "```js\napp.use(logger(process.env.REQUEST_LOG_FORMAT || 'dev')); \n```", "```js\n$ REQUEST_LOG_FORMAT=common npm start\n\n> notes@0.0.0 start /Users/david/chap07/notes\n> node ./bin/www\n::1 - - [12/Feb/2016:05:51:21 +0000] \"GET / HTTP/1.1\" 304 -\n::1 - - [12/Feb/2016:05:51:21 +0000] \"GET /vendor/bootstrap/css/bootstrap.min.css HTTP/1.1\" 304 -\n::1 - - [12/Feb/2016:05:51:21 +0000] \"GET /stylesheets/style.css HTTP/1.1\" 304 -\n::1 - - [12/Feb/2016:05:51:21 +0000] \"GET /vendor/bootstrap/js/bootstrap.min.js HTTP/1.1\" 304 -  \n```", "```js\n// create a write stream (in append mode) \nvar accessLogStream = fs.createWriteStream(__dirname + '/access.log', {flags: 'a'}) \n\n// setup the logger \napp.use(morgan('combined', {stream: accessLogStream})); \n```", "```js\n$ npm install rotating-file-stream --save  \n```", "```js\nconst fs = require('fs-extra');\n...\nconst rfs = require('rotating-file-stream');\nvar logStream;\n// Log to a file if requested\nif (process.env.REQUEST_LOG_FILE) {\n  (async () => {\n    let logDirectory = path.dirname(process.env.REQUEST_LOG_FILE); \n    await fs.ensureDir(logDirectory);\n    logStream = rfs(process.env.REQUEST_LOG_FILE, {\n        size: '10M',     // rotate every 10 MegaBytes written\n        interval: '1d',  // rotate daily\n        compress: 'gzip' // compress rotated files\n    });\n  })().catch(err => { console.error(err); });\n}\n.. \napp.use(logger(process.env.REQUEST_LOG_FORMAT || 'dev', { \n    stream: logStream ? logStream : process.stdout \n})); \n```", "```js\n$ DEBUG=express:* npm start  \n```", "```js\nconst debug = require('debug')('module-name'); \n.. \ndebug('some message'); \n.. \ndebug(`got file ${fileName}`); \n```", "```js\nconst error = require('debug')('notes:error'); \n\nprocess.on('uncaughtException', function(err) { \n  error(\"I've crashed!!! - \"+ (err.stack || err)); \n}); \n.. \nif (app.get('env') === 'development') { \n  app.use(function(err, req, res, next) { \n    // util.log(err.message); \n    res.status(err.status || 500); \n    error((err.status || 500) +' '+ error.message); \n    res.render('error', { \n      message: err.message, \n      error: err \n    }); \n  }); \n} \n.. \napp.use(function(err, req, res, next) { \n  // util.log(err.message); \n  res.status(err.status || 500); \n  error((err.status || 500) +' '+ error.message); \n  res.render('error', { \n    message: err.message, \n    error: {} \n  }); \n}); \n```", "```js\n(node:4796) UnhandledPromiseRejectionWarning: Unhandled promise rejection \n```", "```js\nimport util from 'util';\n...\nprocess.on('unhandledRejection', (reason, p) => {\n  error(`Unhandled Rejection at: ${util.inspect(p)} reason: ${reason}`);\n});\n```", "```js\nnotes:error Unhandled Rejection at: Promise {\n  notes:error <rejected> TypeError: model(...).keylist is not a function\n  ... full stack trace\n} reason: TypeError: model(...).keylist is not a function +3s\n```", "```js\n$ mv app.js app.mjs\n```", "```js\nimport fs from 'fs-extra';\nimport url from 'url';\nimport express from 'express';\nimport hbs from 'hbs';\nimport path from 'path';\nimport util from 'util';\nimport favicon from 'serve-favicon';\nimport logger from 'morgan';\nimport cookieParser from 'cookie-parser';\nimport bodyParser from 'body-parser';\nimport DBG from 'debug';\nconst debug = DBG('notes:debug'); \nconst error = DBG('notes:error'); \nimport { router as index } from './routes/index';\n// const users = require('./routes/users');\nimport { router as notes } from './routes/notes'; \n\n// Workaround for lack of __dirname in ES6 modules\nconst __dirname = path.dirname(new URL(import.meta.url).pathname);\n\nconst app = express();\n\nimport rfs from 'rotating-file-stream';\n```", "```js\nexport default app;\n```", "```js\nconst moduleName = require('moduleName');  // in CommonJS modules\nimport moduleName from 'moduleName';       // in ES6 modules\n```", "```js\nconst debug = require('debug')('notes:debug'); \nconst error = require('debug')('notes:error'); \n```", "```js\n$ mv bin/www bin/www.mjs\n```", "```js\nimport app from '../app.mjs';\nimport DBG from 'debug';\nconst debug = DBG('notes:server-debug'); \nconst error = DBG('notes:server-error'); \nimport http from 'http';\n```", "```js\n$ cd models\n$ mv Note.js Note.mjs\n$ mv notes-memory.js notes-memory.mjs\n```", "```js\nexport default class Note {\n  ...\n}\n```", "```js\nimport Note from './Note';\n\nvar notes = [];\n\nasync function crupdate(key, title, body) {\n  notes[key] = new Note(key, title, body);\n  return notes[key];\n}\n\nexport function create(key, title, body) { return crupdate(key, title, body); }\nexport function update(key, title, body) { return crupdate(key, title, body); }\n\nexport async function read(key) {\n  if (notes[key]) return notes[key];\n  else throw new Error(`Note ${key} does not exist`);\n}\n\nexport async function destroy(key) {\n  if (notes[key]) {\n    delete notes[key];\n  } else throw new Error(`Note ${key} does not exist`);\n}\n\nexport async function keylist() { return Object.keys(notes); }\nexport async function count() { return notes.length; }\nexport async function close() { }\n\n```", "```js\n$ cd routes\n$ mv index.js index.mjs\n$ mv notes.js notes.mjs\n```", "```js\nimport util from 'util';\nimport express from 'express';\nimport * as notes from '../models/notes-memory';\n\nexport const router = express.Router();\n```", "```js\nimport { router } from './routes/index';\n```", "```js\nimport { router as index } from './routes/index';\nimport { router as notes } from './routes/notes'; \n```", "```js\nexport default class Note {\n   ...\n   get JSON() { \n      return JSON.stringify({ \n        key: this.key, title: this.title, body: this.body \n      }); \n   }\n\n   static fromJSON(json) { \n       var data = JSON.parse(json); \n       var note = new Note(data.key, data.title, data.body); \n       return note; \n   } \n}\n```", "```js\nconst note = new Note(\"key\", \"title\", \"body\"); \nconst json = note.JSON;    // produces JSON text\nconst newnote = Note.fromJSON(json); // produces new Note instance\n```", "```js\nimport fs from 'fs-extra';\nimport path from 'path';\nimport util from 'util';\nimport Note from './Note';\nimport DBG from 'debug';\nconst debug = DBG('notes:notes-fs');\nconst error = DBG('notes:error-fs');\n\nasync function notesDir() { \n    const dir = process.env.NOTES_FS_DIR || \"notes-fs-data\"; \n    await fs.ensureDir(dir);\n    return dir;\n} \n\nfunction filePath(notesdir, key) { return path.join(notesdir, `${key}.json`); } \n\nasync function readJSON(notesdir, key) { \n    const readFrom = filePath(notesdir, key); \n    var data = await fs.readFile(readFrom, 'utf8');\n    return Note.fromJSON(data);\n}\n```", "```js\n$ npm install fs-extra --save \n```", "```js\nasync function crupdate(key, title, body) { \n    var notesdir = await notesDir();\n    if (key.indexOf('/') >= 0) \n        throw new Error(`key ${key} cannot contain '/'`); \n    var note = new Note(key, title, body); \n    const writeTo = filePath(notesdir, key); \n    const writeJSON = note.JSON; \n    await fs.writeFile(writeTo, writeJSON, 'utf8');\n    return note;\n}\n\nexport function create(key, title, body) { return crupdate(key, title, body); }\nexport function update(key, title, body) { return crupdate(key, title, body); }\n```", "```js\nexport async function read(key) { \n    var notesdir = await notesDir();\n    var thenote = await readJSON(notesdir, key);\n    return thenote; \n}\n```", "```js\nexport async function destroy(key) { \n    var notesdir = await notesDir();\n    await fs.unlink(filePath(notesdir, key)); \n}\n```", "```js\nexport async function keylist() { \n    var notesdir = await notesDir();\n    var filez = await fs.readdir(notesdir);\n    if (!filez || typeof filez === 'undefined') filez = []; \n    var thenotes = filez.map(async fname => { \n        var key = path.basename(fname, '.json');\n        var thenote = await readJSON(notesdir, key);\n        return thenote.key; \n    }); \n    return Promise.all(thenotes); \n}\n```", "```js\nexport async function count() { \n    var notesdir = await notesDir();\n    var filez = await fs.readdir(notesdir); \n    return filez.length;\n}\n\nexport async function close() { }\n```", "```js\nconst path  = require('path'); \nconst notes = require(process.env.NOTES_MODEL  \n                  ? path.join('..', process.env.NOTES_MODEL)  \n                  : '../models/notes-memory'); \n```", "```js\nvar NotesModule;\n\nasync function model() {\n  if (NotesModule) return NotesModule;\n  NotesModule = await import(`../models/notes-${process.env.NOTES_MODEL}`);\n  return NotesModule;\n}\n\nexport async function create(key, title, body) { \n    return (await model()).create(key, title, body); \n}\nexport async function update(key, title, body) { \n    return (await model()).update(key, title, body); \n}\nexport async function read(key) { return (await model()).read(key); }\nexport async function destroy(key) { return (await model()).destroy(key); }\nexport async function keylist() { return (await model()).keylist(); }\nexport async function count() { return (await model()).count(); }\nexport async function close() { return (await model()).close(); }\n```", "```js\nexport async function methodName(args) { \n    return (await model()).methodName(args); \n}\n```", "```js\nexport function methodName(args) {\n    return model().then(notes => { return notes.*methodName*(args); });\n}\n```", "```js\nimport util from 'util';\nimport express from 'express';\nimport * as notes from '../models/notes';\n\nexport const router = express.Router();\n```", "```js\n\"start-fs\": \"DEBUG=notes:* NOTES_MODEL=fs node --experimental-modules ./bin/www.mjs\", \n```", "```js\n$ DEBUG=notes:* npm run start-fs\n\n> notes@0.0.0 start-fs /Users/david/chap07/notes\n> NOTES_MODEL=models/notes-fs node --experimental-modules./bin/www.mjs\n\n  notes:server Listening on port 3000 +0ms\n  notes:fs-model keylist dir=notes-fs-data files=[  ] +4s  \n```", "```js\n\"server1\": \"NOTES_MODEL=fs PORT=3001 node --experimental-modules./bin/www.mjs\", \n\"server2\": \"NOTES_MODEL=fs PORT=3002 node --experimental-modules./bin/www.mjs\", \n```", "```js\n$ npm install level@2.1.x --save\n```", "```js\nimport fs from 'fs-extra';\nimport path from 'path';\nimport util from 'util';\nimport Note from './Note';\nimport level from 'level';\nimport DBG from 'debug';\nconst debug = DBG('notes:notes-level'); \nconst error = DBG('notes:error-level'); \n\nvar db;\n\nasync function connectDB() { \n    if (typeof db !== 'undefined' || db) return db;\n    db = await level(\n        process.env.LEVELDB_LOCATION || 'notes.level', { \n            createIfMissing: true, \n            valueEncoding: \"json\" \n    }); \n    return db;\n} \n```", "```js\nasync function crupdate(key, title, body) { \n    const db = await connectDB();\n    var note = new Note(key, title, body); \n    await db.put(key, note.JSON);\n    return note;\n}\n\nexport function create(key, title, body) {\n    return crupdate(key, title, body);\n}\n\nexport function update(key, title, body) {\n    return crupdate(key, title, body);\n}\n```", "```js\nexport async function read(key) {\n    const db = await connectDB();\n    var note = Note.fromJSON(await db.get(key));\n    return new Note(note.key, note.title, note.body);\n}\n```", "```js\nexport async function destroy(key) { \n    const db = await connectDB();\n    await db.del(key);\n}\n```", "```js\nexport async function keylist() { \n    const db = await connectDB();\n    var keyz = [];\n    await new Promise((resolve, reject) => { \n        db.createKeyStream()\n        .on('data', data => keyz.push(data)) \n        .on('error', err => reject(err)) \n        .on('end', () => resolve(keyz));\n    }); \n    return keyz;\n}\n\nexport async function count() { \n    const db = await connectDB();\n    var total = 0;\n    await new Promise((resolve, reject) => { \n        db.createKeyStream()\n        .on('data', data => total++) \n        .on('error', err => reject(err)) \n        .on('end', () => resolve(total));\n    }); \n    return total;\n}\n\nexport async function close() {\n    var _db = db;\n    db = undefined;\n    return _db ? _db.close() : undefined;\n}\n```", "```js\n\"start-level\": \"DEBUG=notes:* NOTES_MODEL=level node --experimental-modules ./bin/www.mjs\",\n```", "```js\n$ DEBUG=notes:* npm run start-level\n> notes@0.0.0 start /Users/david/chap07/notes\n> node ./bin/www\n\n  notes:server Listening on port 3000 +0ms \n```", "```js\n$ npm install sqlite3@3.x --save\n```", "```js\nCREATE TABLE IF NOT EXISTS notes (\n    notekey VARCHAR(255),\n    title VARCHAR(255),\n    body TEXT\n);\n```", "```js\n$ sqlite3 chap07.sqlite3 \nSQLite version 3.21.0 2017-10-24 18:55:49\nEnter \".help\" for usage hints.\nsqlite> CREATE TABLE IF NOT EXISTS notes (\n ...> notekey VARCHAR(255),\n ...> title VARCHAR(255),\n ...> body TEXT\n ...> );\nsqlite> .schema notes\nCREATE TABLE notes (\n notekey VARCHAR(255),\n title VARCHAR(255),\n body TEXT\n);\nsqlite> ^D\n$ ls -l chap07.sqlite3 \n-rwx------ 1 david staff 8192 Jan 14 20:40 chap07.sqlite3  \n```", "```js\n\"sqlite3-setup\": \"sqlite3 chap07.sqlite3 --init models/schema-sqlite3.sql\", \n```", "```js\n$ npm run sqlite3-setup\n\n> notes@0.0.0 sqlite3-setup /Users/david/chap07/notes\n> sqlite3 chap07.sqlite3 --init models/schema-sqlite3.sql \n\n-- Loading resources from models/schema-sqlite3.sql\n\nSQLite version 3.10.2 2016-01-20 15:27:19\nEnter \".help\" for usage hints.\nsqlite> .schema notes\nCREATE TABLE notes (\n    notekey VARCHAR(255),\n    title   VARCHAR(255),\n    body    TEXT\n);\nsqlite> ^D\n```", "```js\nimport util from 'util';\nimport Note from './Note';\nimport sqlite3 from 'sqlite3';\nimport DBG from 'debug';\nconst debug = DBG('notes:notes-sqlite3'); \nconst error = DBG('notes:error-sqlite3'); \n\nvar db; // store the database connection here \n\nasync function connectDB() { \n    if (db) return db; \n    var dbfile = process.env.SQLITE_FILE || \"notes.sqlite3\"; \n    await new Promise((resolve, reject) => {\n        db = new sqlite3.Database(dbfile, \n            sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE, \n            err => { \n                if (err) return reject(err); \n                resolve(db);\n        });\n    });\n    return db;\n}\n```", "```js\nexport async function create(key, title, body) { \n    var db = await connectDB();\n    var note = new Note(key, title, body); \n    await new Promise((resolve, reject) => { \n        db.run(\"INSERT INTO notes ( notekey, title, body) \"+ \n            \"VALUES ( ?, ? , ? );\", [ key, title, body ], err => { \n                if (err) return reject(err); \n                resolve(note); \n        }); \n    });\n    return note;\n}\n\nexport async function update(key, title, body) { \n    var db = await connectDB();\n    var note = new Note(key, title, body); \n    await new Promise((resolve, reject) => { \n        db.run(\"UPDATE notes \"+ \n            \"SET title = ?, body = ? WHERE notekey = ?\", \n            [ title, body, key ], err => { \n                if (err) return reject(err); \n                resolve(note); \n        }); \n    });\n    return note;\n}\n```", "```js\nexport async function read(key) {\n  var db = await connectDB();\n  var note = await new Promise((resolve, reject) => {\n    db.get(\"SELECT * FROM notes WHERE notekey = ?\", [key], (err,row) => {\n        if (err) return reject(err);\n        const note = new Note(row.notekey, row.title, row.body);\n        resolve(note);\n     });\n  });\n  return note;\n}\n```", "```js\nexport async function destroy(key) {\n  var db = await connectDB();\n  return await new Promise((resolve, reject) => {\n    db.run(\"DELETE FROM notes WHERE notekey = ?;\", [key], err => {\n        if (err) return reject(err);\n        resolve();\n    });\n  });\n}\n```", "```js\nexport async function keylist() {\n    var db = await connectDB();\n    var keyz = await new Promise((resolve, reject) => {\n        var keyz = [];\n        db.all(\"SELECT notekey FROM notes\", (err, rows) => {\n                if (err) return reject(err);\n                resolve(rows.map(row => row.notekey ));\n            });\n    });\n    return keyz;\n}\n```", "```js\nexport async function count() {\n    var db = await connectDB();\n    var count = await new Promise((resolve, reject) => {\n        db.get(\"select count(notekey) as count from notes\",(err, row) \n        => {\n                if (err) return reject(err);\n                resolve(row.count);\n            });\n    });\n    return count;\n}\n\nexport async function close() {\n    var _db = db;\n    db = undefined;\n    return _db ? new Promise((resolve, reject) => {\n            _db.close(err => {\n                if (err) reject(err);\n                else resolve();\n            });\n        }) : undefined;\n}\n```", "```js\n\"start-sqlite3\": \"SQLITE_FILE=chap07.sqlite3 NOTES_MODEL=sqlite3 node --experimental-modules ./bin/www.mjs\",\n```", "```js\n$ DEBUG=notes:* npm run start-sqlite3\n\n> notes@0.0.0 start-sqlite3 /Users/david/chap07/notes\n> SQLITE_FILE=chap07.sqlite3 NOTES_MODEL=models/notes-sqlite3 node ./bin/www.mjs\n\n  notes:server Listening on port 3000 +0ms\n  notes:sqlite3-model Opened SQLite3 database chap07.sqlite3 +5s  \n```", "```js\n\"server1-sqlite3\": \"SQLITE_FILE=chap07.sqlite3 NOTES_MODEL=sqlite3 PORT=3001 node ./bin/www.mjs\", \n\"server2-sqlite3\": \"SQLITE_FILE=chap07.sqlite3 NOTES_MODEL=sqlite3 PORT=3002 node ./bin/www.mjs\", \n```", "```js\n$ sqlite3 chap07.sqlite3 \nSQLite version 3.10.2 2016-01-20 15:27:19\nEnter \".help\" for usage hints.\nsqlite> select * from notes;\nhithere|Hi There||ho there what there\nhimom|Hi Mom||This is where we say thanks  \n```", "```js\n$ npm install sequelize@4.31.x --save\n$ npm install js-yaml@3.10.x --save\n```", "```js\nimport fs from 'fs-extra';\nimport util from 'util';\nimport jsyaml from 'js-yaml';\nimport Note from './Note';\nimport Sequelize from 'sequelize';\nimport DBG from 'debug';\nconst debug = DBG('notes:notes-sequelize'); \nconst error = DBG('notes:error-sequelize'); \n\nvar SQNote; \nvar sequlz;\n\nasync function connectDB() { \n  if (typeof sequlz === 'undefined') {\n    const YAML = await fs.readFile(process.env.SEQUELIZE_CONNECT,'utf8');\n    const params = jsyaml.safeLoad(YAML, 'utf8'); \n    sequlz = new Sequelize(params.dbname, params.username,\n                           params.password, params.params); \n  }\n  if (SQNote) return SQNote.sync(); \n  SQNote = sequlz.define('Note', { \n        notekey: { type: Sequelize.STRING, primaryKey: true, unique: \n        true }, \n        title: Sequelize.STRING, \n        body: Sequelize.TEXT \n  }); \n  return SQNote.sync();\n}\n```", "```js\nexport async function create(key, title, body) { \n    const SQNote = await connectDB();\n    const note = new Note(key, title, body); \n    await SQNote.create({ notekey: key, title: title, body: body });\n    return note;\n}\n\nexport async function update(key, title, body) { \n    const SQNote = await connectDB();\n    const note = await SQNote.find({ where: { notekey: key } }) \n    if (!note) { throw new Error(`No note found for ${key}`); } else { \n        await note.updateAttributes({ title: title, body: body });\n        return new Note(key, title, body);\n    } \n}\n```", "```js\nexport async function read(key) { \n    const SQNote = await connectDB();\n    const note = await SQNote.find({ where: { notekey: key } }) \n    if (!note) { throw new Error(`No note found for ${key}`); } else { \n        return new Note(note.notekey, note.title, note.body); \n    } \n}\n```", "```js\nexport async function destroy(key) { \n    const SQNote = await connectDB();\n    const note = await SQNote.find({ where: { notekey: key } }) \n    return note.destroy(); \n}\n```", "```js\nexport async function keylist() { \n    const SQNote = await connectDB();\n    const notes = await SQNote.findAll({ attributes: [ 'notekey' ] });\n    return notes.map(note => note.notekey); \n}\n```", "```js\nexport async function count() { \n    const SQNote = await connectDB();\n    const count = await SQNote.count();\n    return count; \n}\n\nexport async function close() {\n    if (sequlz) sequlz.close();\n    sequlz = undefined;\n    SQNote = undefined;\n}\n```", "```js\nsequlz = new Sequelize(params.dbname, params.username, params.password, params.params); \n```", "```js\ndbname: notes \nusername: \npassword: \nparams: \n    dialect: sqlite \n    storage: notes-sequelize.sqlite3 \n```", "```js\ndbname: notes \nusername: .. user name \npassword: .. password \nparams: \n    host: localhost \n    port: 3306 \n    dialect: mysql \n```", "```js\n$ npm install mysql@2.x --save\n```", "```js\n\"start-sequelize\": \"SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize node  --experimental-modules ./bin/www.mjs\" \n```", "```js\n$ DEBUG=notes:* npm run start-sequelize\n\n> notes@0.0.0 start-sequelize /Users/david/chap07/notes\n> SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize node --experimental-modules./bin/www.mjs\n\n  notes:server Listening on port 3000 +0ms \n```", "```js\n\"server1-sequelize\": \"SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize PORT=3001 node --experimental-modules ./bin/www.mjs\", \n\"server2-sequelize\": \"SEQUELIZE_CONNECT=models/sequelize-sqlite.yaml NOTES_MODEL=sequelize PORT=3002 node --experimental-modules ./bin/www.mjs\",\n```", "```js\n$ mkdir data\n$ mongod --dbpath data\n```", "```js\n$ mongo\nMongoDB shell version: 3.0.8\nconnecting to: test\nWelcome to the MongoDB shell.\nFor interactive help, type \"help\".\nFor more comprehensive documentation, see\n  http://docs.mongodb.org/\nQuestions? Try the support group\n  http://groups.google.com/group/mongodb-user\n> db.foo.save({ a: 1});\nWriteResult({ \"nInserted\" : 1 })\n> db.foo.find();\n{ \"_id\" : ObjectId(\"56c0c98673f65b7988a96a77\"), \"a\" : 1 }\n> \nbye\n```", "```js\n$ npm install mongodb@3.x --save\n```", "```js\nimport util from 'util';\nimport Note from './Note';\nimport mongodb from 'mongodb'; \nconst MongoClient = mongodb.MongoClient;\nimport DBG from 'debug';\nconst debug = DBG('notes:notes-mongodb'); \nconst error = DBG('notes:error-mongodb'); \n\nvar client;\n\nasync function connectDB() { \n    if (!client) client = await MongoClient.connect(process.env.MONGO_URL);\n    return { \n        db: client.db(process.env.MONGO_DBNAME), \n        client: client\n    };\n}\n```", "```js\n(async () => {\n  const client = await MongoClient.connect(process.env.MONGO_URL);\n  const db = client.db(process.env.MONGO_DBNAME);\n  // perform database operations using db object\n  client.close();\n})();\n```", "```js\nexport async function create(key, title, body) { \n    const { db, client } = await connectDB();\n    const note = new Note(key, title, body); \n    const collection = db.collection('notes'); \n    await collection.insertOne({ notekey: key, title, body });\n    return note;\n}\n\nexport async function update(key, title, body) { \n    const { db, client } = await connectDB();\n    const note = new Note(key, title, body); \n    const collection = db.collection('notes'); \n    await collection.updateOne({ notekey: key }, { $set: { title, body } });\n    return note;\n}\n```", "```js\nexport async function read(key) { \n    const { db, client } = await connectDB();\n    const collection = db.collection('notes');\n    const doc = await collection.findOne({ notekey: key });\n    const note = new Note(doc.notekey, doc.title, doc.body);\n    return note; \n}\n```", "```js\nexport async function destroy(key) { \n    const { db, client } = await connectDB();\n    const collection = db.collection('notes'); \n    await collection.findOneAndDelete({ notekey: key });\n}\n```", "```js\nexport async function keylist() { \n    const { db, client } = await connectDB();\n    const collection = db.collection('notes'); \n    const keyz = await new Promise((resolve, reject) => { \n        var keyz = []; \n        collection.find({}).forEach( \n            note => { keyz.push(note.notekey); }, \n            err => { \n                if (err) reject(err); \n                else resolve(keyz); \n            } \n        ); \n    }); \n    return keyz;\n}\n```", "```js\nexport async function count() { \n    const { db, client } = await connectDB();\n    const collection = db.collection('notes');\n    const count = await collection.count({});\n    return count;\n}\n\nexport async function close() {\n    if (client) client.close();\n    client = undefined;\n}\n```", "```js\n\"start-mongodb\": \"MONGO_URL=mongodb://localhost/ MONGO_DBNAME=chap07 NOTES_MODEL=mongodb node --experimental-modules ./bin/www.mjs\", \n```", "```js\n$ DEBUG=notes:* npm run start-mongodb\n> notes@0.0.0 start-mongodb /Users/david/chap07/notes\n> MONGO_URL=mongodb://localhost/ MONGO_DBNAME=chap07 NOTES_MODEL=mongodb node --experimental-modules ./bin/www\n\n  notes:server Listening on port 3000 +0ms \n```", "```js\n\"server1-mongodb\": \"MONGO_URL=mongodb://localhost/ MONGO_DBNAME=chap07 NOTES_MODEL=mongodb PORT=3001 node --experimental-modules ./bin/www.mjs\", \n\"server2-mongodb\": \"MONGO_URL=mongodb://localhost/ MONGO_DBNAME=chap07 NOTES_MODEL=mongodb PORT=3002 node --experimental-modules ./bin/www.mjs\",\n```"]