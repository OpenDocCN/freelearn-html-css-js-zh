["```js\nconst animationRate = 30; // 30 ms\n\nlet initialTime, elapsedTime;\n\nfunction animate(deltaT) {\n  // calculate object positions based on deltaT\n}\n\nfunction onFrame() {\n  const currentTime = new Date().getTime();\n  elapsedTime = currentTime - initialTime;\n  if (elapsedTime < animationRate) return; // come back later\n  animate(elapsedTime);\n  initialTime = currentTime;\n}\n\nfunction startAnimation() {\n  setInterval(onFrame, animationRate / 1000);\n}\n```", "```js\nconst animationRate = 30; // 30 ms\nconst deltaPosition = 0.1;\n\nfunction animate(deltaP) {\n  // Calculate object positions based on deltaP\n}\n\nfunction onFrame() {\n  animate(deltaPosition);\n}\n\nfunction startAnimation() {\n  setInterval(onFrame, animationRate / 1000);\n}\n```", "```js\nconst animationRate = 30; // 30 ms\nconst deltaPosition = 0.1;\n\nlet initialTime, elapsedTime;\n\nfunction animate(delta) {\n  // Calculate object positions based on delta\n}\n\nfunction onFrame() {\n  const currentTime = new Date().getTime();\n  elapsedTime = currentTime - initialTime;\n  if (elapsedTime < animationRate) return; // come back later!\n  let steps = Math.floor(elapsedTime / animationRate);\n  while (steps > 0) {\n    animate(deltaPosition);\n    steps -= 1;\n  }\n  initialTime = currentTime;\n}\n\nfunction startAnimation() {\n  initialTime = new Date().getTime();\n  setInterval(onFrame, animationRate / 1000);\n}\n```", "```js\ntransforms.calculateModelView();\ntransforms.push();\n\nif (object.alias === 'sphere') {\n  const sphereTransform = transforms.modelViewMatrix;\n  mat4.translate(sphereTransform, sphereTransform, [0, 0, spherePosition]);\n}\nelse if (object.alias === 'cone') {\n  const coneTransform = transforms.modelViewMatrix;\n  mat4.translate(coneTransform, coneTransform, [conePosition, 0, 0]);\n}\n\ntransforms.setMatrixUniforms();\ntransforms.pop();\n```", "```js\nfunction draw() {\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  transforms.updatePerspective(); \n  try {\n    gl.uniform1i(program.uUpdateLight, fixedLight);\n\n    scene.traverse(object => {\n      transforms.calculateModelView();\n      transforms.push();\n\n      if (object.alias === 'sphere') {\n const sphereTransform = transforms.modelViewMatrix;\n        mat4.translate(sphereTransform, sphereTransform, [0, 0, \n         spherePosition]);\n      }\n else if (object.alias === 'cone') {\n const coneTransform = transforms.modelViewMatrix;\n        mat4.translate(coneTransform, coneTransform, [conePosition, \n         0, 0]);\n      }\n\n transforms.setMatrixUniforms();\n      transforms.pop(); \n      gl.uniform4fv(program.uMaterialDiffuse, object.diffuse);\n      gl.uniform4fv(program.uMaterialSpecular, object.specular);\n      gl.uniform4fv(program.uMaterialAmbient, object.ambient);\n      gl.uniform1i(program.uWireframe, object.wireframe);\n\n      // Bind VAO\n      gl.bindVertexArray(object.vao);\n\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);\n\n      if (object.wireframe) {\n        gl.drawElements(gl.LINES, object.indices.length, \n         gl.UNSIGNED_SHORT, 0);\n      }\n      else {\n        gl.drawElements(gl.TRIANGLES, object.indices.length, \n         gl.UNSIGNED_SHORT, 0);\n      }\n\n      // Clean\n      gl.bindVertexArray(null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    });\n  }\n  catch (error) {\n    console.error(error);\n  }\n}\n```", "```js\nlet\n  gl, scene, program, camera, transforms,\n  elapsedTime, initialTime,\n  fixedLight = false,\n  balls = [],\n  sceneTime = 0,\n  animationRate = 15,\n  gravity = 9.8,\n  ballsCount = 50;\n```", "```js\nfunction load() {\n  scene.add(new Floor(80, 2));\n  for (let i = 0; i < ballsCount; i++) {\n    balls.push(new BouncingBall());\n    scene.load('/common/models/geometries/ball.json', `ball${i}`);\n  }\n}\n```", "```js\nfunction onFrame() {\n  elapsedTime = (new Date).getTime() - initialTime;\n  if (elapsedTime < animationRate) return;\n\n  let steps = Math.floor(elapsedTime / animationRate);\n  while (steps > 0) {\n    animate();\n    steps -= 1;\n  }\n\n  initialTime = (new Date).getTime();\n}\n\nfunction render() {\n  initialTime = (new Date).getTime();\n  setInterval(onFrame, animationRate / 1000);\n}\n```", "```js\nfunction animate() {\n  balls.forEach(ball => ball.update(sceneTime));\n  sceneTime += 33 / 1000;\n  draw();\n}\n```", "```js\nfunction draw() {\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n transforms.updatePerspective(); \n  try {\n    gl.uniform1i(program.uUpdateLight, fixedLight);\n\n    scene.traverse(object => {\n      transforms.calculateModelView();\n transforms.push();\n\n if (~object.alias.indexOf('ball')) {\n const index = parseInt(object.alias.substring(4, 8));\n const ballTransform = transforms.modelViewMatrix;\n mat4.translate(ballTransform, ballTransform, balls[index].position);\n object.diffuse = balls[index].color;\n }\n\n transforms.setMatrixUniforms();\n transforms.pop(); \n      gl.uniform4fv(program.uMaterialDiffuse, object.diffuse);\n      gl.uniform4fv(program.uMaterialSpecular, object.specular);\n      gl.uniform4fv(program.uMaterialAmbient, object.ambient);\n\n      gl.uniform1i(program.uWireframe, object.wireframe);\n      gl.uniform1i(program.uPerVertexColor, object.perVertexColor);\n\n      // Bind\n      gl.bindVertexArray(object.vao);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);\n\n      if (object.wireframe) {\n        gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT, \n         0);\n      }\n      else {\n        gl.drawElements(gl.TRIANGLES, object.indices.length, \n         gl.UNSIGNED_SHORT, 0);\n      }\n\n      // Clean\n      gl.bindVertexArray(null);\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    });\n  }\n  catch (error) {\n    console.error(error);\n  }\n}\n```", "```js\nlet\n  gl, scene, program, camera, transforms,\n  elapsedTime, initialTime,\n  fixedLight = false,\n  balls = [],\n  sceneTime = 0,\n  animationRate = 15,\n  gravity = 9.8,\n  ballsCount = 50;\n```", "```js\nfunction load() {\n  scene.add(new Floor(80, 2));\n  for (let i = 0; i < ballsCount; i++) {\n    balls.push(new BouncingBall());\n    scene.load('/common/models/geometries/ball.json', `ball${i}`);\n  }\n}\n```", "```js\nfunction generatePosition() {\n  return [\n    Math.floor(Math.random() * 50) - Math.floor(Math.random() * \n     50),\n    Math.floor(Math.random() * 30) + 50,\n    Math.floor(Math.random() * 50)\n  ];\n}\n```", "```js\nfunction load() {\n  scene.add(new Floor(80, 2));\n  scene.add(new Axis(82));\n  scene.load('/common/models/geometries/ball.json', 'ball');\n}\n```", "```js\n// Create program variable that maps the uniform uTranslation\ngl.uniform3fv(program.uTranslation, [0, 0, 0]);\n\n// Create program variable that maps the uniform uTranslate\ngl.uniform1i(program.uTranslate, false);\n```", "```js\n// Transformed vertex position\nvec3 vecPosition = aVertexPosition;\nif (uTranslate) {\n  vecPosition += uTranslation;\n}\n```", "```js\nvec4 vertex = uModelViewMatrix * vec4(vecPosition, 1.0);\n```", "```js\ngl.uniform3fv(program.uTranslation, ball.position);\n```", "```js\ngl.uniform1i(program.uTranslate, true);\n```", "```js\ntransforms.setMatrixUniforms();\n```", "```js\nfunction interpolate() {\n  const [X0, Y0, Z0] = initialPosition;\n  const [X1, Y1, Z1] = finalPosition;\n\n  const dX = (X1 - X0) / incrementSteps;\n  const dY = (Y1 - Y0) / incrementSteps;\n  const dZ = (Z1 - Z0) / incrementSteps;\n\n  for (let i = 0; i < incrementSteps; i++) {\n    position.push([X0 + (dX * i), Y0 + (dY * i), Z0 + (dZ * i)]);\n  }\n}\n```"]