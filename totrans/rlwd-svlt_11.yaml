- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Renderless Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A renderless component is an advanced concept in Svelte that allows developers
    to create reusable components without rendering any HTML elements within the component
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is particularly useful when leveraging Svelte to render on a
    canvas or in a 3D context, where the rendering of an HTML template by Svelte is
    not required. Instead, the canvas and **Web Graphics Library** (**WebGL**) offer
    an imperative API to produce graphics on the canvas. With the renderless component
    technique, it becomes possible to design components that enable users to describe
    the canvas declaratively, allowing the component to translate it into imperative
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case for a renderless component is to create components that only
    manage states and behaviors, leaving the parent component control over what should
    actually be rendered. This will come in handy when developing a component library
    and you want to make it easy for users to customize how your component looks and
    lets you have control over the state and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will utilize Svelte context to create our renderless component.
    If you are new to Svelte context, please refer to [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121),
    where we explain its meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we will explore the concept of renderless components and subsequently
    build techniques to create them. As we develop our renderless component, we will
    share a few examples of renderless components.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, you should possess the ability to employ the renderless
    component technique to convert imperative APIs into declarative components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics discussed in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What are renderless components?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building renderless components with Svelte context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code used in this chapter on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: What are renderless components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A renderless component, as its name implies, is a type of component that does
    not render any HTML elements of its own.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder, what’s the purpose of a component that doesn’t render anything?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, despite not rendering HTML, there are still several useful things that
    a component can do, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accepting props, processing their values, and triggering side effects as
    their values change**: Even though the prop values are not used directly in the
    template, they are still reactive. You can write reactive statements with props
    in the component and have them run whenever the prop values change. You can see
    this in the following example code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Even though the `title` and `description` props are not used in the template,
    both `title` and `description` are used in a reactive statement. Whenever the
    `title` or `description` props change, the reactive statement in line 4 will rerun
    and update the title of the document.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Setting the document title, updating the cookie value, and modifying context
    are good examples of side effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`onMount` and `onDestroy`, still run even if no elements are mounted and destroyed
    in the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<slot>``<slot>` element that allows the user of the component to pass in child
    elements or components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the following `Parent` component, we render a `default` slot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, the user of the `Parent` component can pass in child elements or components
    under the `Parent` component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Parent` component can pass data to the child components or elements through
    two avenues – setting context data and setting slot props.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about setting slot props in [*Chapter 4*](B18887_04.xhtml#_idTextAnchor064).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getContext()` to retrieve the context value set by its parent component. Depending
    on the type of context value provided by the parent, we can use the context value
    to communicate with the parent or inform it about the existence of the child component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Writing declarative canvas components* section later in the chapter,
    you will see an example of such a technique.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Throughout the upcoming sections, we will challenge ourselves by creating components
    that perform only the operations listed in the preceding list, without rendering
    any HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore two use cases for renderless components, which
    are turning reusable renderless components and declarative descriptions into imperative
    instructions. Let’s take an in-depth look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring reusable renderless components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first use case for renderless components involves creating components that
    solely focus on the logic of the component. These components are not your typical
    ones, such as buttons or text inputs. Instead, think of components with slightly
    complex logic, such as carousels, tabs, or drop-down menus. Although the logic
    of a carousel component is relatively standard, its appearance can vary significantly
    based on where and how it is used.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we create a reusable carousel component that can look different
    based on where it is used?
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to create a carousel component that only contains the carousel
    logic, without any specific styling or HTML structure. Then, the consumer of the
    component can decide how the carousel should look by passing in their own styling
    and HTML structure. This allows for greater flexibility and customization, making
    the component more versatile and reusable in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the carousel component could accept props such as `items`, which
    would determine the list of items in the carousel. The carousel component could
    render a `slot` element that takes in slot props such as `currentIndex` and `setIndex`,
    which would be the index of the currently active item and the function to set
    the index. This allows the carousel component to manage the carousel item cycling
    logic, while leaving the consumer of the carousel component to determine the actual
    carousel styling and structure.
  prefs: []
  type: TYPE_NORMAL
- en: By separating the carousel logic from the specific styling and structure, we
    can create a more modular and reusable component that can be used in various contexts,
    without having to rewrite the same logic over and over again. This is the power
    of renderless components – they allow us to create components that focus solely
    on their core functionality, without being tied to any specific rendering or styling
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, before we proceed, it’s essential to clarify when not to use a renderless
    component to create a carousel. If you require a fully functional carousel component,
    including the design and style, a renderless component may not be suitable for
    your needs, as its main purpose is to handle the logic and behavior of the carousel
    without dictating its appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the decision to create a renderless component for a carousel depends
    on your specific needs and goals. Consider your project requirements and design
    preferences before deciding on the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will show you step by step how we can build a renderless
    carousel component.
  prefs: []
  type: TYPE_NORMAL
- en: Example – building a renderless carousel component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A carousel component is a UI component that displays a set of items in a loop.
    It allows users to view a collection of items in a slideshow-like format. A carousel
    component is usually found on websites such as e-commerce platforms, news portals,
    and social media platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: An example of a carousel component](img/B18887_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: An example of a carousel component'
  prefs: []
  type: TYPE_NORMAL
- en: We will create a renderless carousel component that accepts a list of items
    through props named `items`. The carousel component will render a `slot` element
    to allow customization of its appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `slot` element will take in a few slot props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`currentIndex`: This represents the index of the currently displayed item in
    the carousel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentItem`: This represents the currently displayed item in the carousel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setCurrentIndex`: This is a function that can be used to update the current
    index of the carousel. It can be used to implement custom navigation controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next` and `prev`: These `slot` props are functions that can be used to navigate
    to the next or previous item in the carousel. They can be used to implement custom
    navigation controls or respond to user input, such as clicks or swipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These `slot` props allow the consumer to decide how to use them to build their
    own carousel UI.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the appropriate `slot` props for the carousel component, we consider
    the essential states and functions required for users to build their own carousel
    UI. In this case, the key states are `currentIndex` and `currentItem`, while the
    necessary functions to interact with the carousel UI include `setCurrentIndex`,
    `next`, and `prev`, which are helpful to implement custom navigation controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a carousel UI is one that displays the current item and has buttons
    to navigate forward and backward through the carousel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we use the `currentItem`, `next`, and `prev`
    slot props to build a simple carousel UI. We decide how to use the `slot` props
    and control the structure and styling of the HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a carousel UI is displaying a list of item numbers at the
    bottom of it, enabling the user to quickly jump to a selected item by clicking
    on its number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I used Svelte’s `{#each}` block to create a list of buttons,
    labeled with a different index number. Each of the buttons has a click event listener
    that sets the current index of the carousel to the index number of the button.
    When you click on the button, the carousel will jump to the item at the index
    that is specified by the button.
  prefs: []
  type: TYPE_NORMAL
- en: The second carousel UI is different from the first carousel UI, and you can
    create and style a totally different carousel UI. You can see that the appearance
    of the carousel UI is entirely up to the user. The renderless carousel component
    focuses on the carousel logic and allows the user to decide on the UI structure
    and styling.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s explore how to write the carousel component.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a renderless carousel component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we decided on the props of our `Carousel` component,
    `items`, and decided that it should have a default `<slot>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this information, let’s create the structure of our `Carousel` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the `<slot>` element will be the only element
    we will have in our `Carousel` component. This `<slot>` element is needed; otherwise,
    the child elements inside the `<Carousel>` component, indicated in the following
    code snippet, will be ignored and discarded if there’s no `<slot>` element in
    the `Carousel` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `<slot>` element, we define the following `slot` props – `currentIndex`,
    `currentItem`, `setCurrentIndex`, `prev`, and `next`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, these `slot` props are not defined in our `Carousel` component yet,
    so let’s define them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize `currentIndex` to `0` at the start of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`setCurrentIndex` is used to update `currentIndex` to the value being passed
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`currentItem` will be the item in the `items` array at the index position of
    `currentIndex`. Here, I’ll use the reactive statements so that we will have a
    new `currentItem` slot prop whenever the `items` array or `currentIndex` changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `prev` and `next` functions will be used to set `currentIndex`,
    based on its current value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, I used `% items.length` so that the index is always
    within the bounds of the length of the `items` array. This way, we ensure that
    the carousel can loop back to the beginning of the `items` array after reaching
    the end, creating a seamless looping effect for the user.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it. If you add all the preceding code snippets to the `Carousel`
    component, you’ll have a working renderless component. The full code is available
    on GitHub at[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel)
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a renderless component is not hard; it doesn’t take us much time to
    create a renderless `Carousel` component. The key here is to figure out the props
    for our renderless component, then figure out the `slot` props needed, and finally,
    create a default `<slot>` element with the `slot` props.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let’s have an exercise to create a reusable renderless component
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1 – a renderless autocomplete component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An autocomplete component is an input with an auto-suggest dropdown that shows
    a list of matching options as a user types in the input. It helps users quickly
    and easily find and select an option from a large set of choices. autocomplete
    components are commonly used in search bars, forms, and other areas where users
    need to enter data quickly and accurately.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we’ll create a renderless autocomplete component.
  prefs: []
  type: TYPE_NORMAL
- en: The autocomplete component will take in only one prop, a `search` function,
    which takes in a search value and returns `Promise`, which resolves to an array
    of string results.
  prefs: []
  type: TYPE_NORMAL
- en: What about the slot props that our renderless `Autocomplete` component would
    provide?
  prefs: []
  type: TYPE_NORMAL
- en: 'We need three states for our autocomplete component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: To represent the current value in the input box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searching`: A Boolean value to represent whether the autocomplete currently
    searches for results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suggestions`: An array of autocomplete results returned from the `search`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a user to interact with the `Autocomplete` component, we need two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setValue`: To update the value of the input box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectSuggestion`: To select the suggestion and apply it to the input box'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the preceding three states and two functions will be the `slot` props for
    our `Autocomplete` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how the `Autocomplete` component could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we use the `Autocomplete` component to render
    an autocomplete textbox, with an `<input>` element and an `<ul>` element in the
    default slot.
  prefs: []
  type: TYPE_NORMAL
- en: The `<input>` element uses the `value` and `setValue` slot props to access and
    modify `value`, held by the `Autocomplete` component.
  prefs: []
  type: TYPE_NORMAL
- en: The `<ul>` element uses the `suggestions` slot prop to showcase the list of
    suggestions provided by the `Autocomplete` component and the `selectSuggestion`
    slot props are used in the `click` event handler of the `<li>` element to select
    the chosen suggestion and apply it to the textbox.
  prefs: []
  type: TYPE_NORMAL
- en: A sample solution can be found at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at the second use case for a renderless component.
  prefs: []
  type: TYPE_NORMAL
- en: Turning a declarative description into imperative instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second use case for a renderless component involves allowing users to describe
    their needs declaratively and then translating them into imperative instructions.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this use case is when working with a canvas or WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a canvas, to create a red rectangle with a green border, you
    would need to use imperative APIs to create and style the rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Step by step, we instruct the canvas context to set `fillStyle` and `strokeStyle`
    and then draw a rectangle, based on the fill color and stroke color set.
  prefs: []
  type: TYPE_NORMAL
- en: When interacting with the canvas in an imperative manner, the code focuses on
    how to do things rather than what to do. This can result in code that is difficult
    to read and maintain, with a lot of low-level details that can make it hard to
    see the bigger picture.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if you write code declaratively, you describe what you want to happen,
    rather than how it should happen. This makes the code more expressive and easier
    to read, as well as more flexible and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the example of the red rectangle, we can create a Svelte component
    that handles drawing the rectangle on the canvas. Instead of manually coding the
    instructions to draw the rectangle, we can simply describe how we want it to appear
    on the canvas through the component. The component then takes care of rendering
    the rectangle on the canvas for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of code that describes the same rectangle through a Svelte
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we see a `Rectangle` component nested within
    a `Canvas` component. The `Rectangle` component has its fill, stroke, *x* position,
    *y* position, width, and height specified.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram illustrates how the `Rectangle` component from the preceding
    code renders a red square with a green border.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: A red square with a green border](img/B18887_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: A red square with a green border'
  prefs: []
  type: TYPE_NORMAL
- en: Even though explicit instructions to draw on the canvas are nowhere to be seen
    in the code, we can visualize a rectangle being drawn on the canvas based on the
    `Rectangle` component. This rectangle, with a width and height of 100 px each,
    is positioned 10 px from the left and 10 px from the top, filled with a red color
    and a green border.
  prefs: []
  type: TYPE_NORMAL
- en: By creating a renderless component that handles the low-level canvas instructions,
    we can separate the logic of drawing the rectangle from the specifics of how it
    should be rendered. This allows for more flexibility in how the rectangle is displayed
    on the canvas, as well as easier maintenance of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, by allowing a user to describe their needs declaratively, we create
    a more intuitive and user-friendly interface to work with the canvas and other
    low-level technologies. This can lead to faster development times and a more enjoyable
    development experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you an example of how declaratively describing a canvas is much
    faster than instructing it imperatively. If I want to animate the size of the
    rectangle, rather than coding the animation manually using imperative APIs, I
    can simply animate the `height` and `width` variables'' value, just like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Although the use of `setInterval` may not be the best to create an animation,
    the preceding code snippet attempts to demonstrate how easy it is to change the
    height and width of the rectangle in the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, we update `height` and `width` on every interval.
    We pass `height` and `width` into the `Rectangle` component. As you can see, the
    height and width of the rectangle on the canvas increases by 10 px every 100 ms.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if we were to animate it imperatively, we would have to clear the
    canvas and redraw a rectangle with a new height and width on each interval. These
    implementation details are now abstracted away in the declarative component, making
    it easier to reason about the animation and modify it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, using renderless components to handle low-level imperative tasks can
    greatly improve the readability, maintainability, and flexibility of our code,
    while also making it more accessible and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we implement the `Canvas` and the `Rectangle` component shown in
    the preceding code snippet? Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: Writing declarative Canvas components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with the `Canvas` component.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the component structure of the `Carousel` component in the previous
    section, the `Canvas` component will render a `<slot>` element to insert all the
    child components.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what’s different is that it will also render a `<canvas>` element,
    which is what we will interact with and draw on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we bind the reference of the `<canvas>` element
    to the variable named `canvas`. After the `<canvas>` element is mounted onto the
    DOM, we get the drawing context of the `<canvas>` element and assign it to the
    variable named `ctx`.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall the previous code example, we placed the `<Rectangle>` component
    inside the `<Canvas>` component to draw a rectangle onto the canvas. The `<Rectangle>`
    component does not receive any data or slot props from the `<Canvas>` component.
    So, how does the `<Rectangle>` component inform the `<Canvas>` component that
    it is a child of the `<Canvas>` component? How does the `<Canvas>` component communicate
    with the `<Rectangle>` component to know what to draw and how to draw on its `<``canvas>`
    element?
  prefs: []
  type: TYPE_NORMAL
- en: If you recall [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121), we introduced
    Svelte context as a mechanism to set data and make it available to child components.
    Svelte context allows parent components to share data and functions with the child
    components without explicitly passing them as props.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Svelte context for communication between the `<Canvas>` and `<``Rectangle>`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<Canvas>` component can set the context with the drawing context, `ctx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `<Rectangle>` component is rendered as a child of the `<Canvas>` component,
    it can access the context set by the `<Canvas>` component and retrieve the `ctx`
    variable. In `onMount`, `<Rectangle>` retrieves the drawing context of the `<canvas>`
    element and draws a rectangle on the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The reason we pass a function that returns `ctx` instead of directly passing
    `ctx` in the context is that the `ctx` value is only available in `onMount` after
    the `<canvas>` element is mounted onto the DOM, yet `setContext` has to be called
    during component initialization, which is before `onMount`. In the `<Rectangle>`
    component, you should only call `getCtx()`within `onMount` to retrieve the latest
    value of `ctx`.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging Svelte context, the `<Canvas>` and `<Rectangle>` components can
    maintain a clear and efficient communication channel. The `<Canvas>` component
    creates the canvas and provides the drawing context, while the `<Rectangle>` component
    accesses the canvas and performs the drawing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the `<Rectangle>` component, we need to redraw the rectangle whenever
    the *x* or *y* positions or the width and height dimensions change. To do that,
    we will use a reactive statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding reactive statement, the `draw` function is rerun whenever the
    `x`, `y`, `width`, or `height` values change. By using this approach, the `<Rectangle>`
    component can efficiently update its appearance in response to changes in position
    or dimensions, ensuring that the rendered rectangle always reflects the latest
    state.
  prefs: []
  type: TYPE_NORMAL
- en: However, you might notice that it doesn’t work as expected. You’ll see that
    the new rectangle is drawn on top of the old rectangle. This is because we need
    to clear the canvas before drawing another rectangle. We cannot do that with our
    `draw` function, as it would lead to undesirable results if we have more than
    one `<Rectangle>` component. Each component would clear the canvas before drawing
    its own rectangle, resulting in only the last `<Rectangle>` component being visible.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this issue, we need the `<Canvas>` component to clear the canvas before
    redrawing all the child rectangles. This function can be called whenever any of
    the child rectangle components request an update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us define a `redrawCanvas` function in the `<Canvas>` component to redraw
    the canvas. In the `redrawCanvas` function, we first clear the canvas through
    `ctx.clearRect()`. Here is the update code for the `<``Canvas>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `redrawCanvas` function, we want to redraw all the rectangles after we
    clear the canvas. But how do we do that? One idea is that instead of providing
    the drawing context, `ctx`, to all the child components and letting the components
    decide when and how to draw on the canvas, we could provide a function for the
    components to register their `draw` functions. This way, the `<Canvas>` component
    can call the `draw` functions when it needs to redraw the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `<Canvas>` component, we change the `getCtx` function into `registerDrawFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `redrawCanvas` function, we loop through the `drawFunctions`
    registered from child components and call them with the drawing context, `ctx`.
    This way, we don’t need to provide `ctx` through Svelte context, yet the child
    components can get the latest `ctx` in their `draw` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us register our `draw` function in the `<``Rectangle>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the `onMount` callback, we register the `draw` function of the `<Rectangle>`
    component through Svelte context. When the component is destroyed and removed
    from the DOM, the `<Rectangle>` component unregisters itself and calls the `redrawCanvas`
    function. This ensures that the `<Canvas>` component is updated, and the canvas
    is cleared of the removed rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, by calling the `redrawCanvas` function in a reactive statement whenever
    `x`, `y`, `height`, or `width` changes, the `<Rectangle>` component ensures that
    its position and dimensions are accurately reflected on the canvas. This way,
    the `<Canvas>` component always maintains an up-to-date visual representation
    of its child components.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `<Canvas>` component has full control over redrawing the entire canvas,
    and the `<Rectangle>` components can register their `draw` functions with the
    `<Canvas>` component. This approach ensures that the canvas is always cleared
    before redrawing and allows multiple `<Rectangle>` components to coexist without
    interfering with each other’s drawings.
  prefs: []
  type: TYPE_NORMAL
- en: We now have functional `<Canvas>` and `<Rectangle>` components. Throughout the
    process of creating these components, we have transformed imperative canvas operations
    into more manageable, declarative components.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate communication between parent and child components, we utilized
    Svelte context as the communication channel. As demonstrated in the preceding
    code snippets, the parent `<Canvas>` component maintains a list of `draw` functions
    from its child components, enabling it to invoke them as needed. This general
    pattern can be applied to parent components that need to track and call methods
    from their child components.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the code we’ve written is functional, it may still require some refinements.
    To access the full working code, including any additional features or optimizations
    necessary for a polished and comprehensive implementation, please visit the GitHub
    repository: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas%0D).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2 – expanding shape components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we challenge you to create additional shape components to
    expand the capabilities of your existing `<``Canvas>` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of shapes you can create include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `<Circle>` component that takes in `x`, `y`, `radius`, and `color` as props.
    The component should draw a circle on the canvas at the given coordinates and
    with the specified radius and color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `<Line>` component that takes in `x1`, `y1`, `x2`, `y2`, and `color` as props.
    The component should draw a line on the canvas between the two sets of coordinates
    with the specified color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other shape components, such as `<Ellipse>` and `<Triangle>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may need to refer to the Canvas API documentation to learn how to draw different
    shapes.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for the `<Circle>` and `<Line>` components at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have delved into the concept of renderless components
    in Svelte and explored their various use cases. Understanding renderless components
    equips you with a new toolset to create reusable components. A renderless component
    emphasizes reusability by focusing on the core logic, state, and behavior, leaving
    the visual presentation flexible for customization.
  prefs: []
  type: TYPE_NORMAL
- en: By using slot props, we demonstrated how to build a renderless component that
    is reusable and gives users control over its appearance, while maintaining the
    component logic and transforming imperative operations into declarative Svelte
    components.
  prefs: []
  type: TYPE_NORMAL
- en: We also presented practical examples of transforming imperative operations into
    declarative Svelte components. We demonstrated how to create `<Canvas>` and `<Rectangle>`
    components that draw a rectangle on a canvas, which can change in size dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how Svelte stores and animations can be
    combined to create fluid, animated applications.
  prefs: []
  type: TYPE_NORMAL
- en: Renderless Components
  prefs: []
  type: TYPE_NORMAL
