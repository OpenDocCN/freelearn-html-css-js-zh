- en: 8\. Dependency Injection in TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. TypeScript 中的依赖注入
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to **Dependency Injection** (**DI**) in TypeScript.
    It demonstrates how to implement the DI design pattern. You will also see some
    common use cases for the DI pattern, including ones from libraries such as Angular
    and Nest.js. This chapter will teach you how to build a simple Angular application
    that uses DI. You will also learn some basics of InversifyJS and how to use it
    in your TypeScript applications. By the end of this chapter, you will be able
    to build a calculator application that utilizes DI using InversifyJS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍 TypeScript 中的 **依赖注入**（**DI**）。它演示了如何实现 DI 设计模式。您还将看到一些 DI 模式的常见用例，包括来自
    Angular 和 Nest.js 等库的用例。本章将教会您如何构建一个简单的 Angular 应用程序，该程序使用 DI。您还将学习 InversifyJS
    的基础知识以及如何在您的 TypeScript 应用程序中使用它。到本章结束时，您将能够使用 InversifyJS 构建一个利用 DI 的计算器应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A design pattern is a general, repeatable way to solve a commonly recurring
    problem in software design. It is not just code that you can paste and use in
    your own code, but a guideline to writing code. It is usually not tied to any
    specific language, so a given pattern can be transformed from language to language,
    with its implementation changed to match the desired language and environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是一种通用的、可重复的解决软件设计中常见问题的方法。它不仅仅是您可以粘贴并用于您自己的代码的代码，而是一种编写代码的指南。它通常与任何特定语言无关，因此给定的模式可以从一种语言转换到另一种语言，其实现根据所需的语言和环境进行更改。
- en: Design patterns can usually be used in many different situations and help you
    solve a lot of different problems. For example, if you want to make sure you only
    have one active connection to a database, you may want to use the Singleton design
    pattern, which basically ensures that only a single instance of something exists,
    or if you want to write an ORM tool (an object-relational mapping tool, for abstracting
    away a database) that allows the use of multiple databases, you may want to use
    the Adapter design pattern, which allows the ORM tool to talk to multiple types
    of database drivers using a "common language."
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常可以用于许多不同的场景，并帮助您解决许多不同的问题。例如，如果您想确保只有一个活动连接到数据库，您可能想使用 Singleton 设计模式，它基本上确保只有一个实例存在，或者如果您想编写一个
    ORM 工具（一个对象关系映射工具，用于抽象数据库），允许使用多个数据库，您可能想使用 Adapter 设计模式，它允许 ORM 工具使用“通用语言”与多种类型的数据库驱动程序进行通信。
- en: Using design patterns can speed up development, since they are battle-tested
    through decades of prior usages, in a variety of problems. Furthermore, if working
    in a team, it is easier to explain a solution to a given problem compared with
    conventional methods. Design patterns serve as a sort of "common language."
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计模式可以加快开发速度，因为它们通过数十年的先前使用在各种问题中得到了实战检验。此外，如果在一个团队中工作，与常规方法相比，解释给定的解决方案更容易。设计模式充当一种“通用语言”。
- en: Note that when beginning to learn the concepts of design patterns, it may be
    difficult to wrap your head around them, and you may find it harder to solve problems
    with them than without them. This is because it's not straightforward to spot
    when a specific design pattern fits a given problem, especially when you don't
    have experience using it, or don't understand either the pattern or the problem
    completely. There are also some patterns that are commonly easier to understand
    than others (for example, the Singleton pattern is easier to understand than the
    Adapter pattern).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当开始学习设计模式的概念时，可能很难理解它们，您可能会发现使用它们解决问题比不使用它们更困难。这是因为很难确定特定的设计模式是否适合给定的问题，尤其是当您没有使用它的经验，或者不完全理解该模式或问题时。还有一些模式比其他模式更容易理解（例如，Singleton
    模式比 Adapter 模式更容易理解）。
- en: Furthermore, if you're just beginning to use a design pattern, its usefulness
    may not be apparent until further down the project lifetime, where you might actually
    want to add features that you may have not initially thought of or even just fix
    bugs. Lastly, it's important to note that not every problem can be solved using
    a design pattern, and using the wrong one may entail more issues than it solves.
    Also, not every problem requires a design pattern – you can add as many patterns
    as you want to a "Hello World" program, but their usefulness will be doubtful.
    So, it's important to take a step back and see whether using it really fits the
    problem you're trying to solve.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你刚开始使用设计模式，其有用性可能直到项目生命周期的后期才会显现，那时你可能实际上想要添加你最初没有考虑到的功能，或者只是修复一些错误。最后，需要注意的是，并不是所有问题都可以通过设计模式来解决，使用错误的设计模式可能会带来比解决的问题更多的问题。同样，并不是每个问题都需要设计模式——你可以在“Hello
    World”程序中添加尽可能多的模式，但它们的有用性是可疑的。因此，重要的是退一步，看看使用它是否真的适合你试图解决的问题。
- en: The DI Design Pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入设计模式
- en: DI is a technique whereby one object supplies the dependencies of another object.
    A dependency of an object is *anything* required in order to perform its operation
    in the application. Before diving into an explanation of what DI is, let's try
    to understand the fundamental element in the preceding definition with an example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是一种技术，其中一个对象提供另一个对象的依赖。对象的依赖是指为了在应用程序中执行其操作所需的任何东西。在深入解释DI之前，让我们通过一个例子来尝试理解前定义中的基本元素。
- en: 'Let''s say we have two classes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个类：
- en: '![Figure 8.1: A simple class dependency'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：简单的类依赖关系'
- en: '](img/B14508_08_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_08_01.jpg]'
- en: 'Figure 8.1: A simple class dependency'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：简单的类依赖关系
- en: As shown in the preceding diagram, Class A uses some properties/methods of Class
    B. Thus, we can say that `ClassB` is a dependency of `ClassA`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，类A使用了类B的一些属性/方法。因此，我们可以说`ClassB`是`ClassA`的依赖。
- en: Let's look at a more real-world example (albeit simplified). Most websites,
    whether social media websites, government websites for disbursal of services,
    or e-commerce platforms, require a user to register in order to use the services
    offered by the website. Imagine you are developing one such website. You require
    a `UserRegistrationService` class to gather user details, save them in a database,
    a file, or any other repository, and then send an email to the user informing
    them of a successful registration.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更实际的例子（尽管是简化的）。大多数网站，无论是社交媒体网站、政府网站提供的服务，还是电子商务平台，都需要用户注册才能使用网站提供的服务。想象一下，你正在开发这样一个网站。你需要一个`UserRegistrationService`类来收集用户详细信息，将它们保存到数据库、文件或其他存储库中，然后向用户发送一封电子邮件，告知他们注册成功。
- en: 'Your website''s method for handling the registration process would therefore
    probably look something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你网站处理注册流程的方法可能看起来像这样：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This service has two primary responsibilities – saving the user''s details
    to persistent storage and sending them an email. For now, you are not concerned
    with whether the details are stored in a database, SaaS, or a file. In the same
    vein, you are not concerned if the registration email is automated or done manually.
    Thus, we just want to get *some* `UserRepository`, and *some* `EmailService`,
    as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务有两个主要职责——将用户的详细信息保存到持久存储中，并向他们发送电子邮件。目前，你不必关心这些详细信息是存储在数据库中、SaaS中还是文件中。同样，你也不必关心注册电子邮件是自动化的还是手工完成的。因此，我们只想得到一些`UserRepository`和一些`EmailService`，如图所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As mentioned, we don''t care about their implementation, or even creating them;
    we want someone else to do that, so our implementation of `UserRegistrationService`
    could look something like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不在乎它们的实现，甚至不关心创建它们；我们希望别人来做这件事，因此我们的`UserRegistrationService`实现可能看起来像这样：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we don't know what the actual implementation behind `UserRepository`
    or `EmailService` is; we just know their structure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不知道`UserRepository`或`EmailService`的实际实现是什么；我们只知道它们的结构。
- en: Now, if we change how users are saved, for example, deciding to migrate from
    a file to a MySQL database, or if we change our email provider from Mailchimp
    to SendGrid, the `UserRegistrationService` class stays intact and should still
    function as before as long as any implementation thereof conforms to the same
    `UserRepository` and `EmailService` interfaces (for example, have the same structure
    – same method signatures, with the same parameters, and so on) and provide the
    same functionality as described previously.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们改变用户保存的方式，例如，决定从文件迁移到MySQL数据库，或者如果我们改变我们的电子邮件提供商从Mailchimp到SendGrid，`UserRegistrationService`类保持不变，并且只要任何实现都符合相同的`UserRepository`和`EmailService`接口（例如，具有相同的结构——相同的方法签名，相同的参数等），并且提供与之前描述相同的函数性，它应该仍然像以前一样正常工作。
- en: For example, in the following code snippets, notice both the file-based and
    the MySQL-based implementations, implement `UserRepository`, which is the only
    thing that `UserRegistrationService` is aware of.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码片段中，注意基于文件和基于MySQL的实现都实现了`UserRepository`，这是`UserRegistrationService`所知道的唯一东西。
- en: 'The file-based implementation is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的实现如下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The MySQL-based implementation is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基于MySQL的实现如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To put it simply, DI allows us to separate the *what* from the *how*. The dependent
    class only needs to know *how* to interact with *a user repository* – by calling
    a method called `save`, with a single parameter of the `User` type), as well as
    with *an email sender* – by calling a method called `sendEmail` that takes in
    two parameters; a *to* email address, of the `string` type, a second parameter
    for the email's subject, also of the `string` type, and an optional third parameter
    for the email's body (also of the `string` type).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，DI允许我们将*什么*与*如何*分开。依赖类只需要知道如何与*用户仓库*交互——通过调用一个名为`save`的方法，该方法接受一个`User`类型的单个参数），以及与*邮件发送者*交互——通过调用一个名为`sendEmail`的方法，该方法接受两个参数；一个*收件人*电子邮件地址，为`string`类型，第二个参数为电子邮件的主题，也为`string`类型，以及一个可选的第三个参数用于电子邮件的正文（也为`string`类型）。
- en: Then, these services can handle the *what should (actually) be done* portion
    – saving the user's details to a file, to a MySQL database, or an entirely different
    thing, and then sending the email automatically using an SaaS service, queuing
    them for manual sending later, or anything else.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些服务可以处理*应该（实际上）做什么*的部分——将用户的详细信息保存到文件、MySQL数据库或完全不同的地方，然后自动使用SaaS服务发送电子邮件，排队等待稍后手动发送，或做任何其他事情。
- en: 'Going back to the dependency chart, in this example, the dependencies are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回到依赖关系图，在这个例子中，依赖关系如下：
- en: '![Figure 8.2: UserRegistrationService dependencies'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：UserRegistrationService依赖关系'
- en: '](img/B14508_08_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_08_02.jpg)'
- en: 'Figure 8.2: UserRegistrationService dependencies'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：UserRegistrationService依赖关系
- en: 'Another benefit of having used DI here is that it simplifies testing our implementations
    separately from their dependencies. For example, when testing the `registerUser`
    method of `UserRegistrationService`, we only want to test the `registerUser` method;
    we don''t care about how its dependencies behave in production (we will test these
    separately). We can just mock them with any implementation while testing to have
    them behave how we want. Remember that the whole point of DI is that we don''t
    care about what the dependencies do and how they do it, as long as they conform
    to the agreed-upon interface – `UserRepository` and `EmailService` in this case.
    Here is how we would test the `registerUser` method in code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用依赖注入（DI）的另一个好处是它简化了从依赖关系中单独测试我们的实现。例如，当测试`UserRegistrationService`的`registerUser`方法时，我们只想测试`registerUser`方法；我们不在乎其在生产中依赖项的行为（我们将单独测试这些）。我们可以在测试时用任何实现来模拟它们，使它们按我们的意愿行事。记住，DI的整个目的就是我们不关心依赖项做什么以及它们是如何做的，只要它们符合约定的接口——在这个例子中是`UserRepository`和`EmailService`。以下是我们在代码中测试`registerUser`方法的方式：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though the preceding examples only demonstrate classes, dependencies can
    be of any type – classes, functions, plain objects, and even simple constants
    (depending on the language and specific implementation).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子只展示了类，但依赖项可以是任何类型——类、函数、普通对象，甚至是简单的常量（取决于语言和特定实现）。
- en: 'For example, if `UserRegistrationService` were to require a constant value,
    for example, a salt to hash the user''s password with, it would be provided in
    the constructor, too, as another argument, as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`UserRegistrationService`需要常数，例如，用于与用户密码散列的盐，它也会在构造函数中提供，作为另一个参数，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The following sections will be using decorators, covered in *Chapter 7\. Decorators*.
    Please make sure that you have read and understood them before continuing, as
    decorators are an essential part of how all DI libraries covered next are built
    on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将使用装饰器，这些装饰器在*第7章*中有所介绍。请在继续之前确保您已经阅读并理解了它们，因为装饰器是所有接下来介绍的DI库构建的基础的重要组成部分。
- en: Another concept related to DI is `UserRepository` abstraction over the `MySqlUserRepository`
    implementation), in IoC, the concern is to let the consumer decide what should
    be done by the component/library. For example, in our implementation of `UserRegistrationService`
    above, we used IoC, since we allow how the user's details are sent, as well as
    how an email is sent by the consumer, to be specified. In the application's case,
    it could decide whether it wanted to use `FileUserRepository` or `MySqlUserRepository`,
    and in the test code we decided that both of them should do nothing. This was
    also decided at the consumer (test code) level.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与DI相关的另一个概念是`UserRepository`抽象，它覆盖了`MySqlUserRepository`实现），在IoC中，关注的是让消费者决定组件/库应该做什么。例如，在我们上面的`UserRegistrationService`实现中，我们使用了IoC，因为我们允许指定用户详情的发送方式以及消费者发送电子邮件的方式。在应用程序的情况下，它可以决定是否想要使用`FileUserRepository`或`MySqlUserRepository`，而在测试代码中我们决定它们都应该不执行任何操作。这也是在消费者（测试代码）级别做出的决定。
- en: To summarize, DI concerns itself with letting a class know about abstractions
    over implementations, while IoC's concerns revolve around letting the consumer
    decide about the implementation(s) that should be used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，DI关注的是让一个类了解实现之上的抽象，而IoC的关注点在于让消费者决定应该使用哪些实现。
- en: Some popular frameworks, both in the frontend as well as the backend, have embraced
    DI as a core part of their framework – the most popular ones are Angular in frontend
    development and Nest.js in the backend. DI allows applications built on top of
    these frameworks to be very robust and flexible, especially in large applications
    due to the nature of DI, which allows the creation of classes (and other dependencies)
    to be separated from their usage.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的框架，无论是前端还是后端，都将DI作为其框架的核心部分——最流行的是前端开发中的Angular和后端开发中的Nest.js。DI使得构建在这些框架之上的应用程序非常健壮和灵活，尤其是在大型应用程序中，因为DI的性质允许将类的创建（以及其他依赖项）与其使用分离。
- en: DI in Angular
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular中的DI
- en: Another actual real-world example of DI can be found in the Angular framework
    – a modern framework for building frontend applications using TypeScript. Angular
    has its own implementation for a DI library. Furthermore, the Angular framework
    itself, as well as apps built on it, heavily relies on this DI implementation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实际的现实世界中的DI例子可以在Angular框架中找到——这是一个使用TypeScript构建前端应用程序的现代框架。Angular有一个自己的DI库实现。此外，Angular框架本身以及基于它的应用程序，都严重依赖于这个DI实现。
- en: Let's take a look at a simple Angular app and see how DI makes it straightforward
    to build an easy-to-maintain, scalable application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的Angular应用程序，看看DI如何使构建易于维护、可扩展的应用程序变得简单。
- en: An Angular app is made up of several `NgModule`, each of which is usually a
    logical part of an app – this can be a feature, a UI components library, or anything
    else. Each `NgModule` can have two types of "things:"
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular应用程序由几个`NgModule`组成，每个`NgModule`通常是应用程序的一个逻辑部分——这可以是功能、UI组件库或其他任何东西。每个`NgModule`可以有两种类型的“东西”：
- en: Declarations (`Component` and `Directive`)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明（`Component`和`Directive`）
- en: Providers (usually `Service`)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供者（通常是`Service`）
- en: '*Declarations* are what constitute the UI of the app, things such as the `WelcomeMessageComponent`
    class (shown in the following snippet), which takes in `name` as an input (using
    the `@Input` decorator, which is kind of like passing in parameters to a function
    or a constructor of a class, just with components), and displays it in an HTML
    `h1` tag (an HTML tag to display a main header):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明*构成了应用程序的UI，例如`WelcomeMessageComponent`类（如下面的片段所示），它接受`name`作为输入（使用`@Input`装饰器，这有点像向函数或类的构造函数传递参数，只是针对组件），并在HTML
    `h1`标签（用于显示主要标题的HTML标签）中显示它：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code will yield the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '![Figure 8.3: Displayed output of rendering WelcomeMessageComponent'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：渲染WelcomeMessageComponent的显示输出'
- en: with "John" passed in to the name input
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将"John"传递给名称输入
- en: '](img/B14508_08_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_08_03.jpg](img/B14508_08_03.jpg)'
- en: 'Figure 8.3: Displayed output of rendering WelcomeMessageComponent with "John"
    passed in to the name input'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：将"John"传递给名称输入时的WelcomeMessageComponent渲染输出
- en: Providers are usually services, which hold the main logic of the app and are
    usually used for anything that's not specifically related to the UI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者通常是服务，它们持有应用程序的主要逻辑，通常用于与UI无关的任何事物。
- en: 'For example, you could have a `UsersService` class that handles fetching a
    list of users from a backend, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有一个`UsersService`类，它负责从后端获取用户列表，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code has a `UsersService` class that has a single method – `getUsers()`,
    which returns a static array of `User` objects. Note that we wrap our static array
    with `of()`, which takes a static value and wraps it in an `Observable`, so we
    can later change the behavior of this method to asynchronously return data (for
    example, from a remote endpoint, as we'll see next).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中有一个`UsersService`类，它只有一个方法——`getUsers()`，该方法返回一个静态的`User`对象数组。请注意，我们用`of()`包装我们的静态数组，它接受一个静态值并将其包装在一个`Observable`中，这样我们就可以稍后更改此方法的行为，使其异步返回数据（例如，从远程端点，如我们将在下一节中看到）。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An observable is an asynchronous stream of data, basically allowing data to
    be passed between "publishers" and "subscribers." This data can be a one-time
    operation, such as with an HTTP call, can have multiple emits (for example, emit
    an increasing number from 1 through 10, in sequence, every 1 second), or can even
    be infinite (for example, emitting an event every time the user clicks a specific
    button). It is part of the Observer pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象是一个异步的数据流，基本上允许数据在“发布者”和“订阅者”之间传递。这些数据可以是一次性操作，例如使用HTTP调用，可以有多个发射（例如，按顺序每秒发射从1到10的递增数字），甚至可以是无限的（例如，每次用户点击特定的按钮时都会发射一个事件）。它是观察者模式的一部分。
- en: 'We would then use `UsersService` in our `UsersList` component, which displays
    the users in a list, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在`UsersList`组件中使用`UsersService`，该组件以列表形式显示用户，如下所示：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we create a simple component, `UsersListComponent`, that displays a list
    of users, which it gets from `UsersService` that's *injected* into it at creation
    time by the Angular DI.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个简单的组件，`UsersListComponent`，它显示用户列表，它从`UsersService`获取用户，该服务在创建时通过Angular
    DI注入到其中。
- en: 'Once the service is injected, we call `getUsers()` and store the returned `Observable`
    in a `users$` member so we can later access it from the template, which utilizes
    the `async` pipe to tell Angular to subscribe to the `Observable` and update the
    template when its underlying value changes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务被注入，我们就调用`getUsers()`并将返回的`Observable`存储在`users$`成员变量中，这样我们就可以稍后从模板中访问它，该模板利用`async`管道告诉Angular订阅`Observable`并在其基础值变化时更新模板：
- en: '![Figure 8.4: The output from running the app'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：运行应用程序的输出'
- en: '](img/B14508_08_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_08_04.jpg)'
- en: 'Figure 8.4: The output from running the app'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：运行应用程序的输出
- en: We won't dive into Angular's template engine or change detection mechanisms
    – those are two big topics in themselves – but you can refer to the Angular documentation
    for more information on that. Instead, let's focus on what's going on with regard
    to DI – notice that we asked for a `UsersService` object in the `UsersListComponents`
    constructor; we didn't specify that we wanted to get a specific instance of the
    service and so on, just that we want one. This is very powerful, since this offloads
    the logic of how and where this service is instantiated to a dedicated place (the
    `NgModule`) and opens up a lot of possibilities. We could test the component more
    easily (by providing a fake `UsersService`), or even just replace the `UsersService`
    implementation at runtime with another one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨Angular的模板引擎或变更检测机制——这些本身都是两个很大的主题——但你可以参考Angular文档以获取更多相关信息。相反，让我们专注于DI方面的情况——注意我们在`UsersListComponents`构造函数中请求了一个`UsersService`对象；我们没有指定我们想要获取服务的特定实例，等等，只是我们想要一个。这非常强大，因为它将如何以及在哪里实例化此服务的逻辑卸载到一个专门的地方（`NgModule`），并打开了很多可能性。我们可以更容易地测试组件（通过提供一个假的`UsersService`），甚至可以在运行时用另一个实现替换`UsersService`。
- en: 'Angular providers can also require other providers; for example, we could have
    a generic HTTP client service that knows how to make HTTP calls, and then inject
    that into our `UsersService`, which can focus on more high-level details such
    as the endpoint, which it needs to use in order to fetch the users. In fact, Angular
    has such an HTTP service built in, called `HttpClient`. You can use it and fix
    the mock implementation we had for the users with a real one, utilizing DI further
    as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供者也可以要求其他提供者；例如，我们可以有一个通用的 HTTP 客户端服务，该服务知道如何进行 HTTP 调用，然后将其注入到我们的
    `UsersService` 中，这样我们的 `UsersService` 就可以专注于更高级别的细节，例如端点，它需要使用该端点来获取用户信息。实际上，Angular
    内置了一个这样的 HTTP 服务，称为 `HttpClient`。您可以使用它，并使用真实的实现来修复我们之前为用户创建的模拟实现，如以下示例所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we ask for an `HttpClient` and use its `get()` method to make a `GET`
    request to the `/api/users` endpoint in our site, which should return an array
    of `User` objects – that is, objects with a property called `name`, with a `string`
    type.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们请求一个 `HttpClient` 并使用其 `get()` 方法向我们的网站中的 `/api/users` 端点发起一个 `GET` 请求，该端点应返回一个
    `User` 对象数组——即具有名为 `name` 的 `string` 类型属性的对象。
- en: This replaces the mock implementation we had earlier with a more real-world
    use case by calling an external endpoint instead of returning a static list of
    users.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过调用外部端点而不是返回静态的用户列表，用更贴近现实世界的用例替换了我们之前使用的模拟实现。
- en: Again, notice that we just asked for an `HttpClient` interface again. We don't
    care about how it's implemented (this could involve using `XMLHttpRequest`, `fetch`,
    or even another underlying library), as long as it conforms to the `HttpClient` interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们再次请求了一个 `HttpClient` 接口。我们不在乎它是如何实现的（这可能涉及使用 `XMLHttpRequest`、`fetch`
    或甚至另一个底层库），只要它符合 `HttpClient` 接口即可。
- en: You may have noticed that the path that we request from `HttpClient` is a relative
    one. This works if our backend is on the same domain as our frontend (for example,
    [https://example.com](https://example.com) is our website and [https://example.com/api/users](https://example.com/api/users)
    would return the users). However, if we want to move our backend to a different
    server, this will break our website. In the next exercise, we will fix this, using
    Angular's DI mechanism and by adding `HttpInterceptor`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们从 `HttpClient` 请求的路径是相对路径。如果我们的后端与前端位于同一域名下（例如，[https://example.com](https://example.com)
    是我们的网站，[https://example.com/api/users](https://example.com/api/users) 将返回用户信息），则这种方式是可行的。然而，如果我们想将后端迁移到不同的服务器，这将破坏我们的网站。在下一个练习中，我们将通过使用
    Angular 的依赖注入机制并添加 `HttpInterceptor` 来解决这个问题。
- en: '`HttpInterceptor` is an interface Angular provides that we can implement in
    order to "hook," or even change network requests, either on their way out (the
    request), or on their way back (the response), before any other consumer "sees"
    the response. This will work wherever `HttpClient` is used in the application,
    without requiring any more code modifications in other services that use `HttpClient`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpInterceptor` 是 Angular 提供的一个接口，我们可以实现它来“钩子”或甚至更改网络请求，无论是在请求的途中（请求）还是在返回的途中（响应），在任何其他消费者“看到”响应之前。这将适用于应用程序中任何使用
    `HttpClient` 的地方，而无需在其他使用 `HttpClient` 的服务中进行任何更多的代码修改。'
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The example discussed in this section is the basis of our next exercise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的示例是我们下一个练习的基础。
- en: 'Exercise 8.01: Adding HttpInterceptor to an Angular App'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.01：向 Angular 应用添加 HttpInterceptor
- en: 'In this exercise, we''ll add `HttpInterceptor` to our existing Angular application,
    which we built in the preceding section, to allow our backend service to sit on
    a different domain from our frontend application. This allows the two applications
    to be separated completely, and very easily, without requiring any extra changes
    in the rest of the application. Here are the steps to complete this exercise:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向我们在上一节中构建的现有 Angular 应用程序添加 `HttpInterceptor`，以便我们的后端服务可以位于与前端应用程序不同的域名上。这使得两个应用程序可以完全且非常容易地分离，而无需对应用程序的其他部分进行任何额外更改。以下是完成此练习的步骤：
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before you begin, make sure you run `npm install` in the `exercise-starter`
    directory. The code files for this exercise can be found here: [https://packt.link/avWRA](https://packt.link/avWRA).
    This repository contains two folders, `exercise-starter` and `exercise-solution`.
    The former contains the template files that you can use to code along with this
    exercise, whereas the latter contains the final code of this exercise for your
    reference.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保在`exercise-starter`目录中运行`npm install`。本练习的代码文件可以在此处找到：[https://packt.link/avWRA](https://packt.link/avWRA)。此存储库包含两个文件夹，`exercise-starter`和`exercise-solution`。前者包含您可以使用来与该练习一起编码的模板文件，而后者包含本练习的最终代码，供您参考。
- en: Start by cloning the application we have written so far in this section. This
    can be found at [https://packt.link/JAgZ7](https://packt.link/JAgZ7).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本节中已编写的应用程序开始克隆。这可以在[https://packt.link/JAgZ7](https://packt.link/JAgZ7)找到。
- en: 'Create a class, `ApiHttpInterceptor`, in a new file, `api-http.interceptor.ts`,
    and save the file in the `exercise-starter`/`src/app/interceptors/` folder. This
    file implements the `HttpInterceptor` interface (imported from `@angular/common/http`).
    Be sure to mark it with the `@Injectable` decorator so that Angular knows it''s
    a service that can be used in DI:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的文件`api-http.interceptor.ts`中创建一个名为`ApiHttpInterceptor`的类，并将其保存在`exercise-starter/src/app/interceptors/`文件夹中。此文件实现了`HttpInterceptor`接口（从`@angular/common/http`导入）。务必使用`@Injectable`装饰器标记它，以便Angular知道它是一个可以在DI中使用的服务：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Angular will call the `intercept()` method of `ApiHttpInterceptor` when a request
    is made by any `HttpClient`. We get the request (`req`) and `HttpHandler` (`next`),
    which we need to call when we're finished to let Angular call any other `HttpInterceptor`
    in the chain.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当任何`HttpClient`发起请求时，Angular将调用`ApiHttpInterceptor`的`intercept()`方法。我们获取请求（`req`）和`HttpHandler`（`next`），当我们完成时需要调用它们，以便Angular调用链中的任何其他`HttpInterceptor`。
- en: 'Update the code to change the URL path:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新代码以更改URL路径：
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code checks the URL path. For each request, if it's issued to
    a relative path, starting with `/api`, the code changes it. It does so by looking
    at the `url` property of `HttpRequest`. If the URL doesn't start with `/api`,
    you don't need to do anything, just call `next.handle()` with the original request.
    Otherwise, clone the original request with a new URL, and then call `next.handle()`
    with the new request. This is the request that will actually be sent out. We're
    using [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
    here, a free service that has some predefined endpoints we can use to get data
    from, for testing purposes. In an actual application, this would be your backend
    service's endpoint.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码检查URL路径。对于每个请求，如果它是一个以`/api`开头的相对路径，代码会将其更改。它是通过查看`HttpRequest`的`url`属性来做到这一点的。如果URL不以`/api`开头，您不需要做任何事情，只需使用原始请求调用`next.handle()`。否则，使用新的URL克隆原始请求，然后使用新的请求调用`next.handle()`。这是实际发送出去的请求。我们在这里使用[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)，这是一个免费服务，它有一些预定义的端点，我们可以用来获取测试数据。在实际应用中，这将是你后端服务的端点。
- en: Lastly, we also need to register this interceptor in our `AppModule` so that
    it can know what interceptors to inject into `HttpClient`. We do this by adding
    `ApiHttpInterceptor`, which we created as a provider, and we tell Angular to use
    it when looking for `HTTP_INTERCEPTORS` – this is the DI symbol that Angular uses
    when it asks for all the interceptors it needs to use when making a network request
    via the `HttpClient` service.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们还需要在我们的`AppModule`中注册此拦截器，以便它知道要注入到`HttpClient`中的拦截器。我们通过添加我们创建的提供者`ApiHttpInterceptor`来实现这一点，并告诉Angular在查找`HTTP_INTERCEPTORS`时使用它——这是Angular在通过`HttpClient`服务进行网络请求时请求所有所需拦截器的DI符号。
- en: 'Open the `app.module.ts` file present in the `exercise-starter/src/app` folder
    and update it with the code given here:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`exercise-starter/src/app`文件夹中的`app.module.ts`文件，并使用此处提供的代码进行更新：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the new app by running `npm start -- --open` in the `exercise-starter`
    directory. Your default browser should open up at `http://localhost:4200`, and
    you should see a list of 10 users:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`exercise-starter`目录中运行`npm start -- --open`来运行新应用程序。您的默认浏览器应该在`http://localhost:4200`打开，并且您应该看到一个包含10个用户的列表：
- en: '![Figure 8.5: Output of the exercise'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：练习输出'
- en: '](img/B14508_08_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_08_05.jpg)'
- en: 'Figure 8.5: Output of the exercise'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：练习输出
- en: 'If you open the DevTools, you should see only one request to the `users` endpoint,
    which is for [https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)
    (and not [http://localhost:4200/users](http://localhost:4200/users)):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开开发者工具，你应该只看到对 `users` 端点的单个请求，这是对 [https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)（而不是
    [http://localhost:4200/users](http://localhost:4200/users)）的请求：
- en: '![Figure 8.6: Requests to the users endpoint'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6：对用户端点的请求'
- en: '](img/B14508_08_06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_08_06.jpg)'
- en: 'Figure 8.6: Requests to the users endpoint'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：对用户端点的请求
- en: Notice that our `UsersService` didn't change at all here (and you can imagine
    the benefits if we had dozens of services like it), but it is still working as
    expected from its point of view.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的 `UsersService` 完全没有改变（你可以想象如果我们有几十个这样的服务，会有什么好处），但它仍然按照预期工作。
- en: All the code explained in this section and the exercise is just some examples
    of how DI comes into play in Angular. However, there is much more. You can register
    any value as a dependency to be injected (not just classes). You can control the
    instantiation of the providers to be Singletons for the entire app, creating a
    new instance for every `NgModule` or even for every `Component` instance. You
    can also create them using some more complex logic via factories and more. You
    have just scratched the surface of the very powerful DI library that Angular offers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本节和练习中解释的所有代码只是 DI 在 Angular 中应用的几个示例。然而，还有更多。你可以将任何值注册为依赖项进行注入（不仅仅是类）。你可以控制提供者的实例化，使其在整个应用程序中为单例，为每个
    `NgModule` 或甚至每个 `Component` 实例创建一个新实例。你还可以通过工厂和更多复杂逻辑来创建它们。你只是刚刚触及了 Angular 提供的非常强大的
    DI 库的表面。
- en: DI in Nest.js
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nest.js 中的依赖注入
- en: Another framework to look at, also heavily inspired by Angular's architecture,
    is Nest.js, which also heavily utilizes DI. Nest.js is a framework for building
    backend applications using Node.js and TypeScript. Like Angular, Nest.js also
    has `Modules` (equivalent to Angular's `NgModule`), and `Providers`. It also has
    `Controller`, which handles incoming requests from clients and returns responses.
    These are similar to Angular's components – both are what the consumers see. In
    Angular, `Component` and `Directive` make up the UI, and in Nest.js, `Controller`
    makes up the API to be consumed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得关注的框架，其架构也深受 Angular 影响，是 Nest.js，它也大量使用了依赖注入（DI）。Nest.js 是一个用于使用 Node.js
    和 TypeScript 构建后端应用的框架。与 Angular 类似，Nest.js 也拥有 `Modules`（相当于 Angular 的 `NgModule`）和
    `Providers`。它还包含 `Controller`，用于处理来自客户端的请求并返回响应。这些与 Angular 的组件类似——两者都是用户所看到的。在
    Angular 中，`Component` 和 `Directive` 构成了 UI，而在 Nest.js 中，`Controller` 构成了可消费的 API。
- en: 'We won''t dive into Nest.js'' architecture, but here''s a small example of
    a couple of things that it leverages DI for:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨 Nest.js 的架构，但这里有一个简单的例子，展示了它如何利用依赖注入（DI）：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a simple "Hello World" controller, which, for a `GET` request to `/hello/foo`,
    will return `{ message: "Hello foo" }`. A controller is a container for endpoints
    under a given prefix (so in this case, any request that starts with `"/hello"`
    will end up going to this controller), and the `@Get` decorator around the `getByUserName()`
    function tells Nest.js to call that method when a `GET` method is performed to
    the given path (the paths of the individual methods/decorators are concatenated
    to those of the controller) – `"/hello/:username"` in this case (anything starting
    with a `:` is a placeholder for dynamic content. In this case, `:username` is
    the placeholder, and we can get it by using the `Param` decorator, giving it the
    placeholder''s name).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个简单的 "Hello World" 控制器，对于 `/hello/foo` 的 `GET` 请求，将返回 `{ message: "Hello
    foo" }`。控制器是在给定前缀下的端点容器（因此在这种情况下，任何以 `"/hello"` 开头的请求都将最终到达这个控制器），而 `@Get` 装饰器围绕
    `getByUserName()` 函数告诉 Nest.js 当对给定路径执行 `GET` 方法时调用该方法（方法/装饰器的路径将与控制器的路径连接）——在这种情况下是
    `"/hello/:username"`（以 `:` 开头的任何内容都是动态内容的占位符。在这种情况下，`:username` 是占位符，我们可以通过使用
    `Param` 装饰器来获取它，给它占位符的名称）。'
- en: Notice that we get `HelloService` in the constructor, similar to Angular, via
    DI. We also get the username param from the `Param` decorator, which also leverages
    DI behind the scenes to get the current `Request` object. Lastly, the framework
    is responsible for creating both `HelloService` and `HelloController` for us;
    we don't need to do so ourselves. This, like in Angular, makes testing `HelloController`
    easy, since you can just fake `HelloService` in your tests with a mock implementation
    to either assert or modify the behavior of the controller. This is a very simple
    example, but you can imagine `HelloService` replaced with something like an authentication
    service, or an ORM tool for accessing the database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll cover InversifyJS – an IoC container for TypeScript
    (and JavaScript) applications. Unlike Angular, which is only for the frontend,
    or Nest.js, which is only for the backend, and which are both frameworks that
    dictate what your application's architecture will be (at least at some level),
    InversifyJS is a generic library that only does IoC and allows you to use DI in
    any application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: InversifyJS
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: InversifyJS is an implementation of an IoC container (inversion of control,
    which DI is part of) for TypeScript (and JavaScript) applications. It is one of
    many implementations and, as we've seen above, some frameworks come with their
    own DI solution, such as Angular or Nest.js.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Other alternatives to InversifyJS for general-purpose projects include `TypeDI`
    and `TSyringe`, as well as `typescript-ioc`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea in InversifyJS, as in most other implementations for an IoC container,
    is to have one place that defines all the concrete implementations of functionality,
    and the rest of the app only depends on abstractions (for example, interfaces).
    This greatly reduces coupling, and changing one implementation to another doesn't
    affect the entire app or require lots of code changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Coupling is about how tightly integrated/dependent two components (usually classes)
    are, in the sense that if we change one of them, how likely is the other to break
    without applicable changes to it too? The more tightly integrated/connected two
    components are to one another, the more coupled they are, and vice versa.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, changing one class should not require changes in others. In such cases,
    the classes are considered decoupled (or loosely coupled).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: To make InversifyJS work, we first need to add a `typeof` and `instanceof` operators.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, since InverisfyJS works through decorators, you need to enable
    them by setting `experimentalDecorators` and `emitDecoratorMetadata` to `true`
    in your project''s `tsconfig.json` file (note the **bold** lines):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'There are additional requirements in order for InversifyJS to work, but all
    modern browsers and Node.js versions should be able to use it without further
    polyfills. For more details, visit the following link: [https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md](https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使InversifyJS正常工作，还有一些额外的要求，但所有现代浏览器和Node.js版本都应该能够使用它而无需进一步的多重填充。有关更多详细信息，请访问以下链接：[https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md](https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md)。
- en: Just as with Angular and Nest.js' DI containers (`NgModule` and `Module`, respectively),
    InversifyJS also needs to know how to resolve dependencies. This is generally
    configured in a single place, usually in a file named `inversify.config.ts` in
    the root of the project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Angular和Nest.js的DI容器（分别对应`NgModule`和`Module`）一样，InversifyJS也需要知道如何解析依赖。这通常在单个位置配置，通常在项目的根目录下名为`inversify.config.ts`的文件中。
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is the recommendation, but this file can be placed anywhere and named anything,
    or split into multiple files; for example, for separating the registration of
    classes of different features or domains, similar to `NgModules` in Angular or
    `Modules` in Nest.js.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是推荐的做法，但此文件可以放在任何地方，命名为任何名称，或者拆分为多个文件；例如，为了分离不同功能或域的类的注册，类似于Angular中的`NgModules`或Nest.js中的`Modules`。
- en: This file should be the only place in the application where there is coupling.
    The rest of the app should only be dependent on abstractions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件应该是应用程序中唯一存在耦合的地方。应用程序的其余部分应仅依赖于抽象。
- en: These abstractions will usually be interfaces, but you can also depend on a
    specific implementation, or a `class` (which can then be injected with a compatible
    subclass).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象通常会是接口，但你也可以依赖于一个特定的实现，或者一个`类`（然后可以注入一个兼容的子类）。
- en: In addition, since interfaces in TypeScript only exist at compile time (see
    *Chapter 7*, *Inheritance and Interfaces*), InversifyJS also requires a runtime
    abstraction token to know what to resolve.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于TypeScript中的接口仅在编译时存在（见*第7章*，*继承和接口*），InversifyJS也需要一个运行时抽象令牌来知道要解析什么。
- en: 'Exercise 8.02: "Hello World" Using InversifyJS'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：使用InversifyJS的“Hello World”
- en: 'In this exercise, we''ll create a simple "hello world" application using InversifyJS.
    We''ll implement all the basic building blocks for a typical use case. Perform
    the following steps to implement this exercise:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用InversifyJS创建一个简单的“Hello World”应用程序。我们将实现典型用例的所有基本构建块。按照以下步骤实现此练习：
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://packt.link/bXSTd](https://packt.link/bXSTd).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://packt.link/bXSTd](https://packt.link/bXSTd)找到。
- en: 'First, create the abstraction for our logger using an `interface` in a new
    file called `logger.interface.ts` in the `src` folder. This is what consumers
    will reference later:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src`文件夹中创建一个名为`logger.interface.ts`的新文件，使用`interface`创建我们日志记录器的抽象。这是消费者稍后将要引用的内容：
- en: '[PRE16]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, create a concrete implementation for `Logger`. This implementation is
    what the consumers of the code will get injected with when they require `Logger`
    later on:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为`Logger`创建一个具体实现。当消费者稍后需要`Logger`时，他们将获得此实现注入的代码：
- en: '[PRE17]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `ConsoleLogger` implements `Logger`. This ensures that we write a
    compatible implementation to what our consumers expect, and that they don't break
    at runtime. In addition, the `@injectable` decorator is used to indicate to InversifyJS
    that this implementation can be used *as a dependency*, and also that it can be
    injected to *other dependencies*. This is how we make InversifyJS aware that `ConsoleLogger`
    is something that it should be aware of.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`ConsoleLogger`实现了`Logger`。这确保了我们编写了一个与消费者期望兼容的实现，并且它们在运行时不会出错。此外，`@injectable`装饰器用于向InversifyJS指示此实现可以作为依赖项使用，并且也可以注入到其他依赖项中。这是我们让InversifyJS意识到`ConsoleLogger`是它应该知道的东西的方式。
- en: 'Create a new file called `types.ts` in the `src` folder. Then, define an injection
    token that consumers can rely on later to ask InversifyJS to inject whatever implementation
    is behind it at runtime:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个名为`types.ts`的新文件。然后，定义一个注入令牌，消费者可以在以后依赖它来请求InversifyJS在运行时注入其背后的任何实现：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this exercise, we'll stick with the recommended approach of creating a `TYPES`
    object that resolves to a `Symbol` for each type (using an injection token is
    required in most DI libraries in TypeScript, since interfaces don't exist at runtime,
    so InversifyJS can't rely on them).
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将坚持使用推荐的创建一个`TYPES`对象的方法，该对象解析为每个类型的`Symbol`（在TypeScript的大多数DI库中需要使用注入令牌，因为接口在运行时不存在，所以InversifyJS不能依赖于它们）。
- en: Note
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If your target environment doesn't support **symbols**, you can instead use
    a plain string. Just ensure that you don't have the same string registered for
    multiple types.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的目标环境不支持**symbols**，你可以改用普通字符串。只需确保不要为多个类型注册相同的字符串。
- en: 'Create a new file called `ioc.config.ts` in the `src` folder. Then, configure
    the IoC container using the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个名为`ioc.config.ts`的新文件。然后，使用以下代码配置IoC容器：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a consumer for the logger in a new file called `main.ts` in the `src`
    folder. Notice that we use the `@inject` decorator to tell InversifyJS that we
    want the `Logger` type:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个名为`main.ts`的新文件，为logger创建一个消费者。注意，我们使用`@inject`装饰器来告诉InversifyJS我们想要`Logger`类型：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The interface type annotation is just for TypeScript to be able to type check
    the `logger` instance, but since interfaces only exist at compile time, this is
    irrelevant for runtime, in which the argument passed to `@inject` is what matters.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口类型注解只是为了TypeScript能够对`logger`实例进行类型检查，但由于接口仅在编译时存在，这在运行时是不相关的，传递给`@inject`的参数才是关键。
- en: 'Now, run the app by executing `npm start` in the parent directory. You should
    get the following output on your console:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在父目录中执行`npm start`来运行应用。你应该在你的控制台看到以下输出：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Of course, for such a simple example, it would have been better to just have
    a single line as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于这样一个简单的例子，最好只使用一行代码如下：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: However, in more complex applications, and even simple ones, DI can help, especially
    if the application is expected to be actively maintained, with the addition of
    features and the fixing of bugs happening all the time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更复杂的应用中，甚至在简单的应用中，DI可以帮助，特别是如果应用预计将积极维护，不断添加功能和修复错误。
- en: In the next activity, you will be tasked with creating a more complex app to
    demonstrate how DI can help us develop applications while keeping best practices
    in mind to make the app easy to maintain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，你将负责创建一个更复杂的应用来展示DI如何帮助我们开发应用，同时保持最佳实践以使应用易于维护。
- en: 'Activity 8.01: DI-Based Calculator'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：基于DI的计算器
- en: As a TypeScript developer, you are tasked with creating a calculator. Like any
    calculator, you need your app to do the four basic math operations of addition
    (+), subtraction (-), multiplication (*), and division (/).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为TypeScript开发者，你的任务是创建一个计算器。像任何计算器一样，你需要你的应用能够执行四个基本的数学运算：加法(+), 减法(-), 乘法(*)和除法(/)。
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To keep things simple and focused solely on DI, you won't be adding support
    for additional operators (for example, power (^)), or support the order of operations,
    so your calculator will just walk through the expression from left to right and
    perform the relevant operation. For example, the expression (`13+5*3-7` will result
    in `47` and not the mathematically correct `21`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单并专注于DI，你不会添加对其他操作符（例如，幂(^)）的支持，也不会支持运算符的优先级，因此你的计算器将只从左到右遍历表达式并执行相关操作。例如，表达式(`13+5*3-7`)将得到`47`，而不是数学上正确的`21`。
- en: To complete this activity, you will have to implement InversifyJS and utilize
    IoC to provide the math operators that the calculator can operate on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个活动，你必须实现InversifyJS并利用IoC来提供计算器可以操作的计算运算符。
- en: You can start with the starter project and build it up by following the high-level
    steps provided here. This activity will challenge the skills that you have developed
    not only in this chapter but also in preceding ones. Hence, feel free to glance
    at the solution to debug any issues you may have with your implementation or code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从入门项目开始，按照这里提供的高级步骤逐步构建。这项活动将挑战你在本章以及之前章节中开发的所有技能。因此，如果你在实现或代码中遇到任何问题，可以自由地查看解决方案进行调试。
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This activity is based on the last section, on InversifyJS, so be sure you understand
    it fully before moving on to this one. You can find both the activity starter
    and solution at [https://packt.link/Pt3Vq](https://packt.link/Pt3Vq). The `activity-starter`
    folder contains the template files you can use to code along with this activity.
    The `activity-solution` folder contains the files representing the solution of
    this activity.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动基于最后一节，即InversifyJS，因此在继续进行之前，请确保您完全理解它。您可以在[https://packt.link/Pt3Vq](https://packt.link/Pt3Vq)找到活动启动器和解决方案。`activity-starter`文件夹包含您可以用于与该活动一起编码的模板文件。`activity-solution`文件夹包含代表此活动解决方案的文件。
- en: 'Perform the following steps to implement this activity:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此活动：
- en: You will have to start off by creating the basic building block of your calculator
    – an operator defined via an interface.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将不得不从创建计算器的基本构建块开始——通过接口定义的运算符。
- en: Then, create operators for addition, subtraction, multiplication, and division.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建加法、减法、乘法和除法运算符。
- en: For the preceding two steps, note that you need to create the requisite abstract
    interface and injection token.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于前面的两个步骤，请注意，您需要创建必要的抽象接口和注入令牌。
- en: Implement a calculator class that uses these operators via InversifyJS. This
    file represents your main app. You might need to map all expression parts and
    parse them. For this, you can refer to the `maths.ts` file placed in the `src/utils`
    folder, which creates and exports two such functions – `tryParseNumberString`
    and `tryParseOperatorSymbol`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个使用InversifyJS的运算符的计算器类。此文件代表您的应用程序。您可能需要映射所有表达式部分并解析它们。为此，您可以参考位于`src/utils`文件夹中的`maths.ts`文件，该文件创建并导出两个这样的函数——`tryParseNumberString`和`tryParseOperatorSymbol`。
- en: Configure the IoC container (present in the `src/ioc.config.ts` file) so that
    `Calculator` can receive `AddOperator`, `SubtractOperator`, and so on when it
    asks for `TYPES.AddOperator`, for example. You can simplify the `ioc.config.ts`
    file further by using barrels. The code for this can be found in the `operator/index.ts`
    file. You can use the code in the aforementioned file to configure and then simplify
    your IoC container.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置IoC容器（位于`src/ioc.config.ts`文件中），以便当`Calculator`请求`TYPES.AddOperator`等时，它可以接收`AddOperator`、`SubtractOperator`等。您可以通过使用barrels进一步简化`ioc.config.ts`文件。相关代码可以在`operator/index.ts`文件中找到。您可以使用上述文件中的代码来配置并简化您的IoC容器。
- en: Create the `main.ts` file that will kick-start your calculator.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main.ts`文件，该文件将启动您的计算器。
- en: 'After solving the preceding steps, the expected output should look like the following:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在解决前面的步骤之后，预期的输出应如下所示：
- en: '[PRE23]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Bonus Steps:**'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**附加步骤：**'
- en: 'As a bonus, let''s say that you want some reporting on the operations performed
    in the calculator. You can add logging (console- and file-based) easily without
    too many changes:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为附加内容，假设您想要对计算器中执行的操作进行一些报告。您可以轻松地添加日志记录（基于控制台和文件），而无需太多更改：
- en: For console-based logging, you need to add a logger via DI that the calculator
    will write to on every expression evaluation. You can follow the given sequence
    to do so. First, you need to define the `Logger` interface. Then, create the console-based
    implementation of `Logger`. Next, create an injection token for it and register
    it in our container. Then, use the logger in the code for the main calculator
    app.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于基于控制台的日志记录，您需要通过依赖注入（DI）添加一个日志记录器，计算器将在每次表达式评估时写入该日志记录器。您可以按照以下步骤进行操作。首先，您需要定义`Logger`接口。然后，创建基于控制台的`Logger`实现。接下来，创建一个注入令牌并将其注册到我们的容器中。然后，在主计算器应用程序的代码中使用该日志记录器。
- en: Now, let's say we want to replace our console-based logger with a file-based
    one, which will persist across runs so that we can track the calculator's evaluation history.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设我们想要将基于控制台的日志记录器替换为基于文件的日志记录器，这样它就可以在运行之间持久化，以便我们可以跟踪计算器的评估历史。
- en: To do this, you first need to create a `FileLogger` class that implements `Logger`
    in a new file in the `src/logger` folder. Then, you need to make a single-line
    change in the `ioc.config.ts` file, which you used for console-based logging.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，您首先需要在`src/logger`文件夹中创建一个新文件，创建一个实现`Logger`的`FileLogger`类。然后，您需要在用于基于控制台的日志记录的`ioc.config.ts`文件中进行单行更改。
- en: 'For console-based logging, use this command:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于基于控制台的日志记录，使用以下命令：
- en: '[PRE24]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For file-based logging, use this command:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于基于文件的日志记录，使用以下命令：
- en: '[PRE25]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, note that you will have to correctly import all `Logger` interfaces
    across all files.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，请注意，您必须正确地在所有文件中导入所有`Logger`接口。
- en: 'The output for the console-based logger is as follows:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于控制台的日志记录器的输出如下：
- en: '[PRE26]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output for the file-based logger is as follows:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于文件的记录器的输出如下：
- en: '![Figure 8.7: Final output of the file-based logger in activity-starter/src/tmp/calculator.log,
    after changing the app to use it'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.7：将应用程序更改为使用基于文件的记录器后，activity-starter/src/tmp/calculator.log文件中的最终输出]'
- en: '](img/B14508_08_07.jpg)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_08_07.jpg)'
- en: 'Figure 8.7: Final output of the file-based logger in activity-starter/src/tmp/calculator.log,
    after changing the app to use it'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：将应用程序更改为使用基于文件的记录器后，activity-starter/src/tmp/calculator.log文件中的最终输出
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor421).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过[这个链接](B14508_Solution_ePub.xhtml#_idTextAnchor421)找到这个活动的解决方案。
- en: The solution to this activity (`activity-solution`) also includes unit tests
    for everything, so you can see how easy testing is when IoC is used as well as
    check that your own implementation passes the tests. In addition, `activity-solution`
    also includes a file that creates a `ConfigurationService` to supply `FileLogger`
    with a dynamic `loggerPath`, with implementations for an in-memory one, or an
    environment variables-based one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案（`activity-solution`）还包括针对所有内容的单元测试，因此您可以了解当使用IoC时测试是多么简单，以及检查您的实现是否通过测试。此外，`activity-solution`还包括一个创建`ConfigurationService`的文件，该服务为`FileLogger`提供动态的`loggerPath`，包括内存中的实现或基于环境变量的实现。
- en: There is a lot more ground to cover on InversifyJS. However, this chapter serves
    as a good start. We encourage you to take a look at the official documentation
    to learn more about what it can offer and to see further examples, including factories,
    container modules, and middlewares. However, these topics are beyond the scope
    of this chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在InversifyJS方面还有更多内容需要探讨。然而，本章提供了一个良好的起点。我们鼓励您查看官方文档，以了解更多它所能提供的内容，并查看更多示例，包括工厂、容器模块和中间件。然而，这些主题超出了本章的范围。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter equipped you first with the fundamentals of DI in TypeScript by
    explaining how you can implement the DI design pattern and by taking you through
    a number of use cases. You also learned how to build a basic Angular app using
    DI.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先通过解释如何实现依赖注入设计模式以及通过一系列用例向您展示，使您了解了TypeScript中依赖注入的基础知识。您还学习了如何使用依赖注入构建基本的Angular应用程序。
- en: This chapter also introduced some basics of InversifyJS and explained how to
    use it in your applications. You have seen how easy it is to add or change dependencies
    without breaking the code for other consumers, along with the power of IoC and
    DI to replace one implementation with another in a very simple manner, for all
    consumers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了InversifyJS的一些基础知识，并解释了如何在应用程序中使用它。您已经看到，在不破坏其他消费者的代码的情况下添加或更改依赖项是多么容易，以及IoC和DI如何以非常简单的方式替换一种实现为另一种实现，对所有消费者来说都是如此。
- en: Of course, there's a lot more to this topic in general than this chapter covered.
    However, this chapter serves as a good start in getting up and running with DI
    in TypeScript. In the next chapter, you will learn about generics in TypeScript.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于这个主题的内容远不止本章所涵盖的。然而，本章为在TypeScript中使用依赖注入（DI）提供了一个良好的起点。在下一章中，你将学习TypeScript中的泛型。
