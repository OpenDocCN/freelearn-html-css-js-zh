- en: Chapter 6. Google Maps JavaScript Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. Google Maps JavaScript库
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Drawing shapes on the map
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上绘制形状
- en: Calculating the length/area of polylines and polygons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算多边形和多边形的长度/面积
- en: Encoding coordinates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码坐标
- en: Searching for and showing nearby places
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索并显示附近的地点
- en: Finding places with the autocomplete option
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动完成选项查找地点
- en: Adding drag zoom to the map
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加拖动缩放
- en: Creating custom popups / infoboxes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义弹出窗口/信息框
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter delves into the additional JavaScript libraries that are part of
    the Google Maps JavaScript API. These libraries are not added to your application
    by default when you reference the Google Maps API; however, these can be added
    manually.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了Google Maps JavaScript API的一部分附加JavaScript库。当你引用Google Maps API时，这些库默认不会添加到你的应用程序中；然而，这些库可以手动添加。
- en: 'These libraries are classified into the following six categories:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库被分为以下六个类别：
- en: '`drawing`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawing`'
- en: '`geometry`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometry`'
- en: '`places`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`places`'
- en: '`panoramio`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panoramio`'
- en: '`visualization`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visualization`'
- en: '`weather`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather`'
- en: The last three libraries in the preceding list—`panoramio`, `visualization`,
    and `weather`—have been discussed thoroughly in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*, with respect to their related topics
    and usages. In this chapter, we will learn in detail about `Drawing` and `Geometry`
    libraries. We will also use two external libraries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列表中的最后三个库——`panoramio`、`visualization`和`weather`——在[第2章](ch02.html "第2章。添加栅格图层")中已经详细讨论过，*添加栅格图层*，涉及它们的相关主题和用法。在本章中，我们将详细了解`Drawing`和`Geometry`库。我们还将使用两个外部库。
- en: The intention of these libraries, as extensions to the core API, is to ensure
    that the Google Maps JavaScript API is self-sufficient in order to provide all
    of the tasks that it offers to accomplish. That means, without these extra libraries,
    you can develop using the API without any problem.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库的目的是作为核心API的扩展，确保Google Maps JavaScript API能够自给自足，以提供它所提供的所有任务。这意味着，没有这些额外库，你也可以使用API进行开发而不会遇到任何问题。
- en: In addition, these libraries are somehow autonomous. They have very well-defined
    and designed objectives and boundaries, so adding them will provide additional
    functionality, but removing them will not take away any functionality from the
    core API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些库在某种程度上是自主的。它们有非常明确和精心设计的目标和边界，因此添加它们将提供额外的功能，但移除它们不会从核心API中移除任何功能。
- en: This optionality of the extra libraries definitely accounts for faster loads
    of the API. Unless you request these libraries explicitly, they are not loaded.
    This componential structure lets you have the option of including the cost of
    loading these libraries or not.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这额外的库的可选性确实解释了API加载速度的加快。除非你明确请求这些库，否则它们不会被加载。这种组件化结构让你可以选择是否包含加载这些库的成本。
- en: This chapter will first deal with the `drawing` library, which will enable you
    to draw vector overlays on top of your base maps. Then, it will deal with the
    `geometry` library and get the properties of the vector overlays, such as the
    length and areas. Finally, the `places` library will explain in detail how to
    search for places and show the details of these places in the Google Maps JavaScript
    API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先处理`drawing`库，这将使你能够在基础地图上绘制矢量覆盖。然后，它将处理`geometry`库，获取矢量覆盖的属性，如长度和面积。最后，`places`库将详细解释如何在Google
    Maps JavaScript API中搜索地点并显示这些地点的详细信息。
- en: Drawing shapes on the map
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在地图上绘制形状
- en: You have probably explored vector overlays in *Chapter 3, Adding Vector Layers*.
    Without getting into details, you can add markers, lines, and polygons programmatically
    using the Google Maps JavaScript API. But if you wanted to draw these vector overlays—not
    programmatically, but with mouse clicks or touch gestures, like in AutoCAD or
    ArcGIS for Desktop—what would you do?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经探索了*第3章，添加矢量图层*中的矢量覆盖。不深入细节，你可以使用Google Maps JavaScript API编程添加标记、线和多边形。但如果你想要绘制这些矢量覆盖——不是通过编程，而是通过鼠标点击或触摸手势，就像在AutoCAD或ArcGIS
    for Desktop中一样——你会怎么做？
- en: The `drawing` library handles this job, enables you to draw vector shapes as
    per your preference, and shows them on top of your base maps.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawing`库处理这项工作，使你能够根据你的偏好绘制矢量形状，并在基础地图上显示它们。'
- en: In this recipe, we will go over the details of how to draw shapes, deal with
    their extensive set of options, and how to handle their specific events.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将详细介绍如何绘制形状、处理它们广泛的选项以及如何处理它们特定的事件。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first recipe of [Chapter 1](ch01.html "Chapter 1. Google Maps JavaScript
    API Basics"), *Google Maps JavaScript API Basics*, will do our work. We will alter
    the Google Maps API bootstrap URL to have this recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 章 [第 1 节](ch01.html "第 1 节. Google Maps JavaScript API 基础")的配方 *Google Maps
    JavaScript API 基础* 将完成我们的工作。我们将修改 Google Maps API 引导 URL 以包含此配方。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show how you can have the drawing control and draw some
    shapes using that control:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示了您如何获得绘图控制并使用该控制绘制一些形状：
- en: 'Alter the Google Maps API bootstrap URL adding the `libraries` parameter:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加 `libraries` 参数修改 Google Maps API 引导 URL：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `drawingManager` object:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `drawingManager` 对象：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enable the drawing functionality:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用绘图功能：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![How to do it...](img/8825OT_06_01.jpg)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/8825OT_06_01.jpg)'
- en: In the previous screenshot, you can see the varieties of shapes you can draw
    by clicking on the buttons in the top-left corner.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到通过点击左上角按钮可以绘制的各种形状。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Adding the drawing functionality to your application using the Google Maps
    JavaScript API is easy. First, you have to include the `libraries` parameter to
    your Google Maps JavaScript API URL with the `drawing` value inside to include
    the `drawing` library into your application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Google Maps JavaScript API 将绘图功能添加到您的应用程序中非常简单。首先，您必须将 `libraries` 参数包含在
    Google Maps JavaScript API URL 中，并在其中包含 `drawing` 值以将 `drawing` 库包含到您的应用程序中：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, you can use the `drawing` library's supported functions and objects in
    addition to the standard Google Maps JavaScript API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以使用 `drawing` 库支持的函数和对象，以及标准的 Google Maps JavaScript API。
- en: 'To draw your vector shapes, it is necessary to have a `DrawingManager` object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制矢量形状，您必须有一个 `DrawingManager` 对象：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Having a `DrawingManager` object, you have all your drawing functionalities,
    but you have to attach it to the current map instance in order to make use of
    it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个 `DrawingManager` 对象，您就拥有了所有的绘图功能，但您必须将其附加到当前地图实例上才能使用它：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After this, you will see a drawing control containing the marker, polyline,
    rectangle, circle, and polygon drawing buttons. By using these buttons, you can
    draw any vector overlay you want. In the toolset, you can also see a pan tool
    to go out of the drawing mode to use the pan and zoom controls. If you want to
    draw a vector shape again, press the related button (marker, polyline, and so
    on) and draw on the map.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，您将看到一个包含标记、折线、矩形、圆形和多边形绘图按钮的绘图控制。通过使用这些按钮，您可以绘制任何想要的矢量叠加。在工具集中，您还可以看到一个平移工具，用于退出绘图模式以使用平移和缩放控制。如果您想再次绘制矢量形状，请按相关按钮（标记、折线等）并在地图上绘制。
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Until this point, having the drawing functionality is so simple that you can
    implement it by adding two lines of code. However, there is an extensive set of
    options you can make use of, which are related to the `DrawingManager` object
    and vector shapes you draw. It's worth going over them, because they enrich your
    drawing experience in your application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，拥有绘图功能非常简单，您可以通过添加两行代码来实现它。然而，有一系列广泛的选项可供使用，这些选项与 `DrawingManager` 对象和您绘制的矢量形状相关。了解它们是值得的，因为它们可以丰富您在应用程序中的绘图体验。
- en: The settings of `DrawingManager` can be modified either in its initialization
    or through its `setOptions` method. All the settings that pertain to the `DrawingManager`
    class are properties of the `DrawingManagerOptions` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 `DrawingManager` 的初始化过程中或通过其 `setOptions` 方法修改 `DrawingManager` 的设置。所有与
    `DrawingManager` 类相关的设置都是 `DrawingManagerOptions` 类的属性。
- en: 'Let''s alter our recipe to include the `DrawingManager` options:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的配方以包含 `DrawingManager` 选项：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `drawingControl` property enables or disables the drawing control seen
    in the map UI:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawingControl` 属性可以启用或禁用在地图 UI 中看到的绘图控制：'
- en: '![There''s more...](img/8825OT_06_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/8825OT_06_02.jpg)'
- en: Setting the `drawingControl` property to `false` will hide the drawing control.
    Its default is `true`; therefore, although it is not included in our original
    recipe code, it is shown in the map.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `drawingControl` 属性设置为 `false` 将会隐藏绘图控制。其默认值为 `true`；因此，尽管它没有包含在我们的原始配方代码中，但它显示在地图上。
- en: It is important to note that the drawing functionality comes with attaching
    the `DrawingManager` class to the map.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，绘图功能是通过将 `DrawingManager` 类附加到地图上实现的。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Therefore, hiding the drawing control is not related to the drawing functionality.
    In fact, you can create your own user controls to use `DrawingManager` instead
    of the standard drawing controls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，隐藏绘图控制与绘图功能无关。实际上，您可以使用自己的用户控件来使用`DrawingManager`而不是标准绘图控件。
- en: The drawing control has its own options embedded in the `drawingControlOptions`
    property. Remember from [Chapter 4](ch04.html "Chapter 4. Working with Controls"),
    *Working with Controls*, that you can position your controls at the predefined
    places in the Google Maps UI whether they be the default controls or the controls
    you actually develop.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图控制在其`drawingControlOptions`属性中嵌入了自己的选项。记住从[第4章](ch04.html "第4章。使用控件")，*使用控件*，您可以在Google
    Maps UI中预定义的位置放置您的控件，无论是默认控件还是您实际开发的控件。
- en: 'The `drawingControl` property is no exception. You can position `drawingControl`
    by using the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawingControl`属性也不例外。您可以使用以下代码片段来定位`drawingControl`：'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code is reflected in the map UI in the following manner:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在地图UI中的反映方式如下：
- en: '![There''s more...](img/8825OT_06_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/8825OT_06_03.jpg)'
- en: Notice that the `drawingControl` property is placed at the bottom center, as
    we have mentioned in the `position` property of the `drawingControlOptions` property.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`drawingControl`属性被放置在底部中央，正如我们在`drawingControlOptions`属性的`position`属性中提到的。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Complete listing for google.maps.ControlPosition**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**google.maps.ControlPosition的完整列表**'
- en: 'The complete listing for control positions can be found in the Google Maps
    JavaScript API reference documentation at the following link:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 控制位置的完整列表可以在以下链接的Google Maps JavaScript API参考文档中找到：
- en: '[https://developers.google.com/maps/documentation/javascript/reference](https://developers.google.com/maps/documentation/javascript/reference)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/maps/documentation/javascript/reference](https://developers.google.com/maps/documentation/javascript/reference)'
- en: 'Apart from the `position` property, you can also select which type of shape
    you would like to draw, in other words, which buttons you would like to include
    in `drawingControl`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`position`属性之外，您还可以选择您想要绘制的形状类型，换句话说，您想要包含在`drawingControl`中的按钮：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have apparently selected three drawing shape types listed in an array in
    the `drawingModes` property:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然选择了在`drawingModes`属性中列出的数组中的三种绘图形状类型：
- en: Marker
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记
- en: Polygon
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形
- en: Polyline
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多段线
- en: 'These are reflected in the `drawingControl` property:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在`drawingControl`属性中体现出来：
- en: '![There''s more...](img/8825OT_06_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/8825OT_06_04.jpg)'
- en: 'By default, all vector shape buttons are available in `drawingControl`. This
    means that, in addition to the three types listed in our example, the following
    shapes are also available:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有矢量形状按钮都在`drawingControl`中可用。这意味着，除了我们示例中列出的三种类型之外，以下形状也是可用的：
- en: Rectangle
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形
- en: Circle
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形
- en: If you have followed the recipe up to this point, you may have realized that
    at the start of your application you can zoom and pan your map as usual. Then,
    you have to click a vector overlay button in the `drawingControl` property to
    start drawing your shape.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经按照这个步骤做到这里，您可能已经意识到，在您的应用程序开始时，您可以像往常一样缩放和拖动地图。然后，您必须点击`drawingControl`属性中的矢量覆盖按钮来开始绘制形状。
- en: 'However, you can change this programmatically through a setting. For instance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以通过设置来更改这一点。例如：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `drawingMode` property takes the vector shape type `google.maps.drawing.OverlayType`,
    as the API implies, as its data type and sets that vector shape type so that it
    can be drawn. In our example, when the user clicks on the map, they immediately
    start drawing the `POLYGON` vector overlays.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawingMode`属性采用矢量形状类型`google.maps.drawing.OverlayType`作为其数据类型，并设置该矢量形状类型以便可以绘制。在我们的示例中，当用户点击地图时，他们立即开始绘制`POLYGON`矢量覆盖。'
- en: 'But what happens if it becomes necessary to change the `drawingMode` programmatically
    in the program flow? Luckily, there is a solution to this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果程序流程中需要程序化地更改`drawingMode`，会发生什么呢？幸运的是，有一个解决方案：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Setting the property to `null` makes the `drawingMode` property turn to its
    default value, allowing the end user to use the Google Maps JavaScript UI as usual.
    This means that clicking on the map does not draw any vector shape overlay.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性设置为`null`会使`drawingMode`属性变为默认值，允许最终用户像往常一样使用Google Maps JavaScript UI。这意味着点击地图不会绘制任何矢量形状覆盖。
- en: 'You can also use the `setOptions` method of `drawingManager` for the same purpose:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`drawingManager`的`setOptions`方法达到相同的目的：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Until now, we have dealt with the `drawingManager` and `drawingControl` property
    options. But what about the shapes and their styles that we will draw? As you
    may have expected, you can set the properties of the vector shapes you draw in
    `google.maps.drawing.DrawingManagerOptions`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了`drawingManager`和`drawingControl`属性选项。但我们将要绘制的形状及其样式怎么办？正如您所预期的，您可以在`google.maps.drawing.DrawingManagerOptions`中设置您绘制的矢量形状的属性：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now draw our shapes as shown in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以绘制如下所示的形状：
- en: '![There''s more...](img/8825OT_06_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/8825OT_06_05.jpg)'
- en: You may have observed that the styles of the polyline and polygon shapes have
    changed completely. The polylines have become red in color, because their `strokeColor`
    property is set as `red`, whereas the `strokeColor` property for polygons is set
    as `blue`, their `fillColor` as `yellow`, and their `opacity` being near transparent—`0.2`—so
    that you can see the base map through them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经观察到多边形和折线形状的样式已经完全改变。折线变成了红色，因为它们的`strokeColor`属性被设置为`red`，而多边形的`strokeColor`属性被设置为`blue`，它们的`fillColor`为`yellow`，透明度接近透明——`0.2`——这样您就可以通过它们看到基础地图。
- en: 'For each vector overlay type, there is an `options` property for `drawingManager`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种矢量覆盖类型，`drawingManager`都有一个`options`属性：
- en: '`markerOptions`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markerOptions`'
- en: '`polylineOptions`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polylineOptions`'
- en: '`polygonOptions`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polygonOptions`'
- en: '`circleOptions`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circleOptions`'
- en: '`rectangleOptions`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rectangleOptions`'
- en: There is a bunch of interesting properties for vector overlays, most of them
    being common for all overlay types. We have already touched on the stroke and
    fill properties for customizing the styles according to your taste.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矢量覆盖，有许多有趣的属性，其中大多数对所有覆盖类型都是通用的。我们已涉及根据您的喜好自定义样式的线条和填充属性。
- en: 'For instance, you can try the `editable` and `draggable` properties, which
    are worth commenting on:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以尝试`editable`和`draggable`属性，这些属性值得注意：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code snippet makes the polygons drawn on Google Maps UI editable,
    as shown in the following screenshot (you have to go out of polyline drawing mode
    by clicking the pan button in the drawing control):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使得在谷歌地图UI上绘制的多边形可编辑，如下面的截图所示（您必须通过在绘图控制中点击平移按钮退出多边形绘图模式）：
- en: '![There''s more...](img/8825OT_06_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/8825OT_06_06.jpg)'
- en: 'Observe the white dots that represent the nodes (`LatLng` objects) comprising
    the entire polygon. You can change the location of these dots by clicking and
    dragging the dots; this will allow you to change the shape of the polygon, as
    shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 观察代表构成整个多边形的节点（`LatLng`对象）的白点。您可以通过点击和拖动这些点来改变这些点的位置；这将允许您改变多边形的形状，如下面的截图所示：
- en: '![There''s more...](img/8825OT_06_07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/8825OT_06_07.jpg)'
- en: You may have spotted that the white dot located in the middle of the south edge
    has been dragged downwards, and thus, the shape of the polygon has changed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到位于南边缘中间的白点已被向下拖动，因此多边形的形状已经改变。
- en: 'In addition to changing the original shape, you can also drag the shape, as
    shown in the following screenshots:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了改变原始形状外，您还可以拖动形状，如下面的截图所示：
- en: '![There''s more...](img/8825OT_06_08.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/8825OT_06_08.jpg)'
- en: As you can see, the shape has moved to the east in the second screenshot.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在第二张截图中，形状已经向东移动。
- en: '![There''s more...](img/8825OT_06_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/8825OT_06_09.jpg)'
- en: When the `draggable` property is set to `true` and your mouse is on the shape,
    you can drag your shape wherever you want on the map.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当`draggable`属性设置为`true`并且鼠标位于形状上时，您可以将形状拖动到地图上的任何位置。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Complete listing for google.maps.drawing.DrawingManager properties**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**google.maps.drawing.DrawingManager属性完整列表**'
- en: 'The complete listing for the `DrawingManager` properties and related options
    can be found in the Google Maps JavaScript API reference documentation at the
    following link:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawingManager`属性和相关选项的完整列表可以在以下链接的谷歌地图JavaScript API参考文档中找到：'
- en: '[https://developers.google.com/maps/documentation/javascript/reference#DrawingManager](https://developers.google.com/maps/documentation/javascript/reference#DrawingManager)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/maps/documentation/javascript/reference#DrawingManager](https://developers.google.com/maps/documentation/javascript/reference#DrawingManager)'
- en: '`DrawingManager` is not limited to its properties and options; it also has
    some events associated with it. These events are fired when you finish drawing
    a shape:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawingManager`不仅限于其属性和选项；它还有一些与之相关的事件。这些事件在您完成绘制形状时触发：'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may notice that the type of the event is `polygoncomplete`, and there is
    a callback function taking the polygon, which has been completed, as an argument.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到事件的类型是`polygoncomplete`，并且有一个回调函数接受一个参数，即已经完成的多边形。
- en: 'There is an event for every type of shape:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每种形状类型都有一个事件：
- en: '`markercomplete`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markercomplete`'
- en: '`linestringcomplete`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linestringcomplete`'
- en: '`polygoncomplete`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polygoncomplete`'
- en: '`rectanglecomplete`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rectanglecomplete`'
- en: '`circlecomplete`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circlecomplete`'
- en: 'There is one additional event type that covers all of these shape types:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种额外的事件类型涵盖了所有这些形状类型：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding event behaves in the same way as the previous example. Instead
    of the `shapecomplete` pattern there is an `overlaycomplete` argument for the
    event. This event is particularly useful for all the shape events, regardless
    of their type. However, being a generic event for all shapes, you can also get
    the shape type from `event.type`, and you can get the reference for the shape
    drawn from `event.overlay`. Utilizing these, you can have conditional statements
    for different shape types in one event handler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个事件的行为与上一个示例相同。而不是`shapecomplete`模式，事件有一个`overlaycomplete`参数。这个事件对于所有形状类型特别有用。然而，作为一个针对所有形状的通用事件，你也可以从`event.type`获取形状类型，并从`event.overlay`获取绘制形状的引用。利用这些，你可以在一个事件处理器中为不同的形状类型设置条件语句。
- en: Calculating the length/area of polylines and polygons
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算折线和多边形的长度/面积
- en: As described in the first recipe of this chapter—*Drawing shapes on the map*—you
    can draw your shapes as per your taste. But how about getting some information
    about these shapes, for instance, information about their length and area?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章第一道菜谱所述——*在地图上绘制形状*——你可以根据你的喜好绘制形状。但关于这些形状的信息，例如，它们的长度和面积信息，你了解多少呢？
- en: The Google Maps JavaScript API places the opportunity to gather this information
    in the `geometry` library. From this library, you can access the static utility
    functions that give information on the length/area calculations and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API在`geometry`库中提供了收集这些信息的机会。从这个库中，你可以访问静态实用函数，这些函数提供了长度/面积计算等信息。
- en: This recipe will show us how to get the length and area information of the arbitrary
    shapes drawn.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将展示如何获取绘制形状的长度和面积信息。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Having a sneak preview at the *Drawing shapes on the map* recipe will ease your
    work, as much detail on drawing shapes and their background is needed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看*在地图上绘制形状*的菜谱之前，可以让你更容易地工作，因为需要很多关于绘制形状及其背景的细节。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can view the area and length information of your shapes by carrying out
    the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下步骤查看你形状的面积和长度信息：
- en: 'Add the `drawing` and `geometry` libraries to the bootstrap URL:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`drawing`和`geometry`库添加到bootstrap URL中：
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a `drawingManager` object with the following settings:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下设置创建一个`drawingManager`对象：
- en: '[PRE18]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Enable the drawing functionality:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用绘图功能：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add an event listener for the completion of your polygons:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的多边形完成添加事件监听器：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add an event listener for the completion of your polylines:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的折线添加事件监听器：
- en: '[PRE21]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![How to do it...](img/8825OT_06_10.jpg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/8825OT_06_10.jpg)'
- en: As shown in the preceding screenshot, you can view the area and length information
    in the console window.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，你可以在控制台窗口中查看面积和长度信息。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To use the `drawing` and `geometry` utilities in the Google Maps JavaScript
    API, we have added two libraries—`drawing` and `geometry`—to the Google Maps JavaScript
    API bootstrap URL at the top of the code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Google Maps JavaScript API中的`drawing`和`geometry`实用工具，我们在代码顶部的Google Maps
    JavaScript API bootstrap URL中添加了两个库——`drawing`和`geometry`：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to note that you can add multiple libraries with a comma separating
    each list, as in this case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你可以通过逗号分隔每个列表来添加多个库，就像在这个例子中一样。
- en: 'We have added the `drawingManager` object, after the usual mapping details,
    in the `initMap()` function itself. In this `drawingManager` object, we set the
    properties so that we can only draw polylines and polygons:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`initMap()`函数本身中添加了`drawingManager`对象，在常规地图细节之后。在这个`drawingManager`对象中，我们设置了属性，以便我们只能绘制折线和多边形：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We do not need any marker drawing as there will be no length and area information
    related to markers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要任何标记绘制，因为没有与标记相关的长度和面积信息。
- en: 'At the start of the application, we implied that the users can use standard
    mapping controls (zoom, pan, and so on) instead of drawing shapes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开始时，我们暗示用户可以使用标准地图控件（缩放、平移等）而不是绘制形状：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This control on the user input is particularly useful in professional applications,
    because even if the application is the sole drawing application, users may need
    to specify their drawing areas by using the pan and zoom controls first hand.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对用户输入的控制特别适用于专业应用程序，因为即使应用程序是唯一的绘图应用程序，用户也可能需要首先使用平移和缩放控件来指定他们的绘图区域。
- en: 'We have placed the `drawingControl` object at the bottom center of the map
    UI:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `drawingControl` 对象放置在地图 UI 的底部中央：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is up to you where to place `drawingControl`; we just selected `BOTTOM_CENTER`
    as an example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自行决定将 `drawingControl` 放置在哪里；我们只是选择了 `BOTTOM_CENTER` 作为示例。
- en: 'We have finally attached the `drawingManager` object to the map instance to
    enable the functionality:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将 `drawingManager` 对象附加到地图实例上以启用功能：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After all this setting up, users can open their application and draw polylines
    and polygons as per their wish. But, how do we get the length and area info of
    their shapes?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些设置后，用户可以打开他们的应用程序，并根据他们的意愿绘制多边形和多段线。但是，我们如何获取他们形状的长度和面积信息呢？
- en: 'We have to add event handlers to be aware that they have finished drawing shapes.
    The calculation of the length and area must be performed for every polygon and
    polyline. Therefore, we have used the `polygoncomplete` and `polylinecomplete`
    events. First, let''s perform the calculations for the polygons:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加事件处理器来确保他们已经完成了形状的绘制。对于每个多边形和多段线，都必须执行长度和面积的计算。因此，我们使用了 `polygoncomplete`
    和 `polylinecomplete` 事件。首先，让我们对多边形进行计算：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `polygoncomplete` event handler that gets fired when the users finish
    drawing each of their polygons, we first get the path of the polygon they draw:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户完成绘制每个多边形时触发的 `polygoncomplete` 事件处理器中，我们首先获取他们所绘制的多边形的路径：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `getPath()` method returns an `MVCArray` of the object of type `LatLng`
    being latitude and longitude pairs comprising the polygon itself. For instance,
    for an imaginary polygon that we have drawn, calling `polygon.getPath().getArray().toString();`
    gives the following result:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPath()` 方法返回一个 `MVCArray`，该对象为 `LatLng` 类型，包含构成多边形的经纬度对。例如，对于我们所绘制的想象中的多边形，调用
    `polygon.getPath().getArray().toString();` 会得到以下结果：'
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is now clear that the imaginary polygon that is drawn comprises four latitude
    and longitude pairs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经很清楚，所绘制的想象中的多边形由四个经纬度对组成。
- en: 'Why did we need the path of the polygons? We needed it because the `computeArea()`
    function that we use does not take the polygon, but its path as an argument:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要多边形的路径？我们需要它是因为我们使用的 `computeArea()` 函数不接受多边形，而是接受其路径作为参数：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What does this `spherical` namespace stand for?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `spherical` 命名空间代表什么？
- en: As you have observed, maps are 2D surfaces. However, the Earth's surface is
    not. To reflect the Earth's surface on a 2D canvas, projections are used. However,
    this reflection is not as smooth as it first seems. It comes with a cost; distortion
    of the Earth's shapes and properties occurs. To handle these side effects, spherical
    geometry calculations are needed, and `google.maps.geometry.spherical` exists
    exactly for this purpose.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所观察到的，地图是二维表面。然而，地球的表面不是。为了在二维画布上反映地球表面，需要使用投影。然而，这种反映并不像最初看起来那么平滑。它伴随着代价；地球的形状和属性会发生扭曲。为了处理这些副作用，需要球面几何计算，而
    `google.maps.geometry.spherical` 正好就是为了这个目的而存在的。
- en: When you call the `computeArea()` or `computeLength()` method, the area calculations
    are performed as if the shapes are warped to the Earth's surface, taking the earth
    curvature into account.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用 `computeArea()` 或 `computeLength()` 方法时，面积计算会像将形状扭曲到地球表面一样进行，考虑到地球的曲率。
- en: 'The unit of the return values of the two methods is meters. We have converted
    them to square kilometers and kilometers respectively in order to have more meaningful
    values while printing them in the console window:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法的返回值单位是米。我们将它们转换为平方千米和千米，以便在控制台窗口打印时具有更有意义的值：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The event handlers for the `polygoncomplete` and `polylinecomplete` events are
    identical, except in `polylinecomplete`, where there is no area calculation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`polygoncomplete` 和 `polylinecomplete` 事件的处理器在 `polylinecomplete` 中是相同的，除了在
    `polylinecomplete` 中没有面积计算。'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There''s a strong possibility that having the length and area information attached
    to the shapes would be nice. You can extend the `Polygon` and `Polyline` JavaScript
    classes to have them. But bear in mind that extending JavaScript objects may lead
    to unexpected errors; you may clobber a different library''s object extension.
    Therefore, think twice before extending the JavaScript classes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有很大的可能性，将长度和面积信息附加到形状上会很方便。你可以扩展 `Polygon` 和 `Polyline` JavaScript 类来实现这一点。但请记住，扩展
    JavaScript 对象可能会导致意外的错误；你可能会覆盖不同库的对象扩展。因此，在扩展 JavaScript 类之前请三思：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Having extended the `Polygon` and `Polyline` classes, you can call the `getArea()`
    and `getLength()` methods directly from their objects:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展了 `Polygon` 和 `Polyline` 类之后，你可以直接从它们的对象中调用 `getArea()` 和 `getLength()` 方法：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Drawing shapes on the map* recipe in this chapter
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *在地图上绘制形状* 菜单
- en: Encoding coordinates
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码坐标
- en: The polylines and polygons that you draw using the Google Maps JavaScript API
    consist of arrays of `LatLng` objects in latitude and longitude pairs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 Google Maps JavaScript API 绘制的折线和多边形由经纬度对的 `LatLng` 对象数组组成。
- en: The length of these arrays increases substantially, especially when you have
    shapes with too many nodes, in the case of long polylines or polygons that have
    too much detail.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组的长度显著增加，尤其是在你有太多节点的形状，例如长折线或具有过多细节的多边形的情况下。
- en: Dealing with these arrays (that can be retrieved by the `getPath()` methods
    of polylines and polygons) is a major problem, especially when you have to save
    the shape to a DB. Serializing and deserializing lengthy arrays is frequently
    hulky.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些数组（可以通过折线和多边形的 `getPath()` 方法检索）是一个主要问题，尤其是在你必须将形状保存到数据库中时。序列化和反序列化长数组通常是笨重的。
- en: However, you can compress the paths of the shapes with Google's **polyline encoding
    algorithm**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用 Google 的 **polyline 编码算法**压缩形状的路径。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Detailed information on Google''s polyline encoding algorithm**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于 Google polyline 编码算法的详细信息**'
- en: 'You can find detailed information about the polyline encoding algorithm at
    the following link:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到有关 polyline 编码算法的详细信息：
- en: '[https://developers.google.com/maps/documentation/utilities/polylinealgorithm](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/maps/documentation/utilities/polylinealgorithm](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)'
- en: By using the `geometry` library, you can encode and decode the paths of polylines
    and polygons.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `geometry` 库，你可以编码和解码折线和多边形的路径。
- en: This recipe will show you how to encode and decode the paths of the polylines
    and polygons.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将向你展示如何编码和解码折线和多边形的路径。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It would be handy to have a quick glance at the first recipe—*Drawing shapes
    on the map*—of this chapter, as it covers every detail on how to draw a shape
    using the Google Maps JavaScript API.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看本章的第一个菜谱——*在地图上绘制形状*——将很有帮助，因为它涵盖了使用 Google Maps JavaScript API 绘制形状的每一个细节。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the steps you can use to view the encoded and decoded versions of
    your paths:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以使用的步骤来查看你路径的编码和解码版本：
- en: 'Add the `geometry` and `drawing` libraries to the bootstrap URL:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `geometry` 和 `drawing` 库添加到 bootstrap URL：
- en: '[PRE34]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Organize your HTML so that you can view the original, encoded, and decoded
    coordinates of your shapes in a `div` element:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组织你的 HTML，以便你可以在一个 `div` 元素中查看形状的原始、编码和解码坐标：
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Keep a reference to the `loggingDiv div` element in your `initMap()` function:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `initMap()` 函数中保留对 `loggingDiv div` 元素的引用：
- en: '[PRE36]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a `polylinecomplete` event handler in your `initMap()` function after
    creating `drawingManager` and attaching it to the map instance:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 `drawingManager` 并将其附加到地图实例之后，在你的 `initMap()` 函数中创建一个 `polylinecomplete`
    事件处理程序：
- en: '[PRE37]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![How to do it...](img/8825OT_06_11.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/8825OT_06_11.jpg)'
- en: You can view the original, encoded, and decoded versions of your paths as shown
    in the preceding screenshot.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看你路径的原始、编码和解码版本，如前一个屏幕截图所示。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `polylinecomplete` event is fired when you finish drawing your polyline.
    You can get the `MVCArray` of the object of type `LatLng` that comprises your
    polyline in the following manner:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成绘制折线时，会触发 `polylinecomplete` 事件。你可以以下方式获取包含你的折线的 `LatLng` 对象类型的 `MVCArray`：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Having the path object at hand, you can encode it easily by using the `encodePath()`
    method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有路径对象后，你可以通过使用 `encodePath()` 方法轻松地进行编码：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `encodePath()` method takes either the `MVCArray` of the object of type
    `LatLng` objects or an array of `LatLng` objects. So, here in our recipe, this
    will also be possible:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodePath()`方法接受`LatLng`对象类型的对象`MVCArray`或`LatLng`对象的数组。因此，在我们的食谱中，这也将是可能的：'
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `encodePath()` method returns a string that is perfectly fit for saving
    to a DB and potentially saves a considerable amount of time that would be spent
    serializing and deserializing operations:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodePath()`方法返回一个适合保存到数据库的字符串，并且可以节省大量用于序列化和反序列化操作的时间：'
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Without encoding, the `coords` array would look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行编码，`coords`数组将看起来像这样：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Encoding polylines and polygons is not a one-way operation. You can decode
    the encoded coordinate pairs as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对折线和多边形进行编码不是单向操作。你可以按照以下方式解码编码的坐标对：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `decodePath()` method takes encoded coordinates in the form of a string
    and returns an array of `LatLng` objects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodePath()`方法接受以字符串形式的编码坐标，并返回一个`LatLng`对象的数组。'
- en: Searching for and showing nearby places
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索并显示附近的地点
- en: Google Maps is not only about beautiful base maps with an immense cartographic
    quality or regularly updated satellite images. In your daily life, not as a programmer
    but as an ordinary user of Google Maps, you will have no doubt used Google Maps
    to search for places; be it The Metropolitan Museum of Arts in New York, or a
    commonplace *farmacia* in Rome.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps不仅仅是具有巨大制图质量的美丽基础地图或定期更新的卫星图像。在日常生活中，你作为Google Maps的普通用户，无疑已经使用Google
    Maps搜索过地点；无论是纽约的大都会艺术博物馆，还是罗马的普通*药房*。
- en: This information is in Google Maps, but how can you reach and serve this information
    through the Google Maps JavaScript API?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息在Google Maps中，但如何通过Google Maps JavaScript API访问并提供服务呢？
- en: The `places` library is there exactly for this purpose, and it enables you to
    look for places by using certain search parameters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`places`库正是为此目的而存在的，它使你能够使用某些搜索参数来查找地点。'
- en: You can perform nearby searches where place results would be near the location
    that you have provided, most commonly, the user's location. You can search within
    a radius, or you can just specify a search string. You can even request for additional
    details, such as related photos, review ratings, phone numbers, and opening hours
    for particular places.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进行附近的搜索，地点结果将靠近你提供的位置，最常见的是用户的位置。你可以在一定范围内搜索，或者只需指定一个搜索字符串。你甚至可以请求额外的详细信息，例如相关照片、评论评分、电话号码和特定地点的营业时间。
- en: This recipe will focus on nearby searches by using the `places` library of the
    Google Maps JavaScript API.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将专注于使用Google Maps JavaScript API的`places`库进行附近的搜索。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will make use of the `drawing` library, therefore, it is advised
    to go over the first recipe—*Drawing shapes on the map*—of this chapter and refresh
    your understanding on the subject matter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将使用`drawing`库，因此建议回顾本章的第一食谱——*在地图上绘制形状*——并刷新对该主题的理解。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can draw a circle, search for places within this circle with a keyword,
    and get detailed information on each of the places by following the ensuing steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以绘制一个圆，使用关键词在这个圆内搜索地点，并按照以下步骤获取每个地点的详细信息：
- en: 'Add the `drawing` and `places` libraries to the bootstrap URL:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`drawing`和`places`库添加到bootstrap URL：
- en: '[PRE44]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the `circles` and `markers` global variables to push and pop the respective
    overlays outside the `initMap()` function:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`circles`和`markers`全局变量添加到在`initMap()`函数外部推送和弹出相应的覆盖物：
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a `popup` global variable to hold the value of the `infoWindow` object:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`popup`全局变量来保存`infoWindow`对象：
- en: '[PRE46]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Initialize the `circles` and `markers` arrays and the `infoWindow` object in
    the `initMap()` function:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initMap()`函数中初始化`circles`和`markers`数组以及`infoWindow`对象：
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a `circlecomplete` event handler in your `initMap()` function after
    creating the `drawingManager` object and attaching it to the map instance (items
    from number 6 to number 12 will be in this event handler):'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`drawingManager`对象并将其附加到地图实例后，在`initMap()`函数中创建一个`circlecomplete`事件处理器（从第6项到第12项的内容将在这个事件处理器中）：
- en: '[PRE48]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the `circlecomplete` event handler, set `drawingMode` to `null`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`circlecomplete`事件处理器内部，将`drawingMode`设置为`null`：
- en: '[PRE49]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the latest drawn circle to the `circles` array and then reverse the order
    inside the array:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最新绘制的圆添加到`circles`数组中，然后反转数组内的顺序：
- en: '[PRE50]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Pop the previous circle and set its map handle to null so that only the last
    drawn circle is shown:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出之前的圆圈并将它的地图句柄设置为 null，以便只显示最后绘制的圆圈：
- en: '[PRE51]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Clear all previously drawn markers:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除之前绘制的标记：
- en: '[PRE52]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create nearby search settings, setting the location as the circle center and
    the radius as the circle radius. Also, add a `keyword` property to return the
    places containing that keyword:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建附近的搜索设置，将位置设置为圆心，将半径设置为圆的半径。此外，添加一个 `keyword` 属性以返回包含该关键字的地点：
- en: '[PRE53]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Get the handle for the `PlacesService` service object:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 `PlacesService` 服务对象的句柄：
- en: '[PRE54]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Send the request with a callback function:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用回调函数发送请求：
- en: '[PRE55]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Outside the `initMap()` function, create a callback function for the `nearbySearch`
    request, using the following code snippet:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initMap()` 函数外部，为 `nearbySearch` 请求创建一个回调函数，使用以下代码片段：
- en: '[PRE56]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a function to create a marker per the places result (the steps from
    number 15 to number 17 will be in this function):'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来根据地点结果创建标记（从第 15 步到第 17 步将在该函数中执行）：
- en: '[PRE57]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create the marker inside the `pinpointResult()` function:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pinpointResult()` 函数内部创建标记：
- en: '[PRE58]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add a click event handler to the marker so that when it is clicked, the `infoWindow`
    object pops up:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向标记添加点击事件处理程序，以便当它被点击时，`infoWindow` 对象弹出：
- en: '[PRE59]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Push the marker to the `markers` array:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标记推送到 `markers` 数组：
- en: '[PRE60]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![How to do it...](img/8825OT_06_12.jpg)'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/8825OT_06_12.jpg)'
- en: As shown in the preceding screenshot, you can draw a circle, search for places
    within this circle with a keyword, and get detailed information on each of the
    places found.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，您可以绘制一个圆圈，使用关键字搜索此圆圈内的地点，并获取每个找到的地点的详细信息。
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The steps for this recipe require you to work a bit longer; however, the essence
    is simple. For a moment, forget about the details on the `circles` and `markers`
    arrays and the related logic; just concentrate on the nearby search:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的步骤需要您多花一点时间；然而，本质是简单的。暂时忘记 `circles` 和 `markers` 数组以及相关的逻辑细节；只需专注于附近的搜索：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the `circlecomplete` event handler (this is fired after we finish drawing
    our circle), we place a `nearbyPlacesRequest` object. This object should be of
    the type `google.maps.places.PlaceSearchRequest`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `circlecomplete` 事件处理程序（在我们完成绘制圆圈后触发）中，我们放置一个 `nearbyPlacesRequest` 对象。此对象应该是
    `google.maps.places.PlaceSearchRequest` 类型。
- en: The `location` property sets the `LatLng` object that should be the center of
    the search for the places. Usually, in nearby searches, this property is set as
    per the user's location. But for this recipe, we have tied it to the drawn circles'
    centers, as you can draw and search multiple times as per your needs.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`location` 属性设置应该作为地点搜索中心的 `LatLng` 对象。通常，在附近的搜索中，此属性根据用户的位置设置。但在此配方中，我们将其绑定到绘制的圆圈中心，因为您可以按照需要绘制和搜索多次。'
- en: The distance from `location` is set by the `radius` property so that the places
    are returned within this distance from the center of the circle. In our recipe,
    we have set the radius of the circle drawn.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `radius` 属性设置 `location` 的距离，以便返回位于圆心一定距离内的地点。在我们的配方中，我们设置了绘制的圆的半径。
- en: Lastly, the `keyword` property filters the places so that the ones containing
    the keyword will be returned. Note that all the information not only includes
    the name or type of the place, but also the address and reviews, which will be
    matched against the keyword. So, be prepared for a place that is a cafeteria whose
    reviews include the keyword "pizza" in return of this request.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`keyword` 属性过滤地点，以便返回包含关键字的地点。请注意，所有信息不仅包括地点的名称或类型，还包括地址和评论，这些将与关键字匹配。因此，请准备好返回一个包含关键字
    "pizza" 的自助餐厅的评论。
- en: 'After preparing the request parameters, the next step is to send the request.
    First, we create a `PlacesService` object, taking our current map instance as
    a parameter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好请求参数后，下一步是发送请求。首先，我们创建一个 `PlacesService` 对象，将当前的地图实例作为参数：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'By using the `placesService` object, we can send our request:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `placesService` 对象，我们可以发送我们的请求：
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `nearbySearch` method takes two parameters, the first parameter being our
    old request parameters embedded in the `nearbyPlacesRequest` object and the second
    parameter being the callback function that returns the results. In our recipe,
    the second parameter is the `resultsCallback` function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearbySearch` 方法接受两个参数，第一个参数是我们嵌入在 `nearbyPlacesRequest` 对象中的旧请求参数，第二个参数是返回结果的回调函数。在我们的配方中，第二个参数是
    `resultsCallback` 函数：'
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This callback function takes two arguments here (in fact, it has a third parameter,
    which is related to search pagination): the array of the places found in the search
    and the service status. In the callback function, we first check if the service
    status is OK or not. Then we iterate through `results`, which is an array of the
    `PlaceResult` class type, to create the markers and fill in the `infoWindow` objects
    for each returned place.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调函数在这里接受两个参数（实际上，它还有一个与搜索分页相关的第三个参数）：搜索中找到的地点数组和服务状态。在回调函数中，我们首先检查服务状态是否正常。然后我们遍历
    `results`，它是一个 `PlaceResult` 类型的数组，为每个返回的地点创建标记并填充 `infoWindow` 对象。
- en: 'We can create an associated marker for each place, as seen in the following
    code snippet:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个地点创建一个关联的标记，如下面的代码片段所示：
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `geometry` property of the `result` object embeds a `location` property,
    which is of the `LatLng` class type. This is perfectly fit for the `position`
    property of the `Marker` class.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`result` 对象的 `geometry` 属性嵌入了一个 `location` 属性，它属于 `LatLng` 类类型。这非常适合 `Marker`
    类的 `position` 属性。'
- en: 'We can reach the details of the places in our `popup` object attached in the
    `click` event handler for the marker:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在标记的 `click` 事件处理器中附加的 `popup` 对象来获取地点的详细信息：
- en: '[PRE66]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You may have observed that we are using the `name`, `vicinity`, and `rating`
    properties of the place as the content for the popup. `name` represents the name
    of the place, `vicinity` returns a portion of the address information, and the
    `rating` value is the review rating of the place, 0.0 being the lowest and 5.0
    being the highest.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们正在使用地点的 `name`、`vicinity` 和 `rating` 属性作为弹出窗口的内容。`name` 表示地点名称，`vicinity`
    返回地址信息的一部分，而 `rating` 值是地点的评论评分，0.0 是最低分，5.0 是最高分。
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The details and options for searching nearby places is not limited to the options
    presented in this recipe. We will just dig a little more here. First comes the
    `nearbyPlacesRequest` object. The properties presented inside this object are:
    `location`, `radius`, and `keyword`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索附近地点的详细信息和选项不仅限于本食谱中展示的选项。我们在这里将进一步探讨。首先，是 `nearbyPlacesRequest` 对象。该对象内部包含的属性有：`location`、`radius`
    和 `keyword`。
- en: 'However, the `PlaceSearchRequest` class, of which our object is a type, has
    much more than what we saw in this recipe. For instance, you can supply a `LatLngBounds`
    object instead of the location and radius:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的对象所属的 `PlaceSearchRequest` 类比本食谱中展示的还要多。例如，你可以提供一个 `LatLngBounds` 对象而不是位置和半径：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Please bear in mind that one option is to use `bounds`, and another option is
    to use the `location` and `radius` couple. Using one of them is compulsory for
    the `PlaceSearchRequest` class.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一个选项是使用 `bounds`，另一个选项是使用 `location` 和 `radius` 配对。对于 `PlaceSearchRequest`
    类，使用其中一个选项是强制性的。
- en: 'To filter the place results, using `keyword` is not the only solution. You
    can try the `name` property to directly match against the names of the places.
    For instance, the following code gives the places that have `Buckingham` in their
    name:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤地点结果，使用 `keyword` 并非唯一解决方案。你可以尝试使用 `name` 属性直接匹配地点名称。例如，以下代码给出了名称中包含 `Buckingham`
    的地点：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If your drawn circle is in London, it will possibly bring up Buckingham Palace
    as well as a bunch of hotels nearby.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绘制的圆圈位于伦敦，它可能会同时显示白金汉宫以及附近的一批酒店。
- en: 'You can select the type of place to be returned by using the `types` property.
    This property takes an array of types such as:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `types` 属性来选择返回的地点类型。这个属性接受一个类型数组，例如：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There is really an immense range of types that Google Maps has been covering.
    You can just insert which place type you want, from car rentals to universities,
    just as we have done.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps 已经覆盖了极其广泛的地点类型。你可以插入你想要的任何地点类型，从汽车租赁到大学，就像我们做的那样。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Complete list of place types**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**地点类型完整列表**'
- en: 'You can find the complete list of place types at:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到完整的地点类型列表：
- en: '[https://developers.google.com/places/documentation/supported_types](https://developers.google.com/places/documentation/supported_types)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[Google 地点 API 支持的地点类型](https://developers.google.com/places/documentation/supported_types)'
- en: Other than `types`, `name`, and `bounds`, there are many more properties in
    the `PlaceSearchRequest` class such as `openNow`, which is a very handy property
    to show only the places that are open at the time of the search.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `types`、`name` 和 `bounds` 之外，`PlaceSearchRequest` 类中还有许多其他属性，例如 `openNow`，这是一个非常实用的属性，可以显示在搜索时开放的地点。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Complete list of properties for the PlaceSearchRequest class**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**PlaceSearchRequest 类的完整属性列表**'
- en: 'You can find the complete list of properties for the `PlaceSearchRequest` class
    at:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到 `PlaceSearchRequest` 类的完整属性列表：
- en: '[https://developers.google.com/maps/documentation/javascript/reference#PlaceSearchRequest](https://developers.google.com/maps/documentation/javascript/reference#PlaceSearchRequest)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/maps/documentation/javascript/reference#PlaceSearchRequest](https://developers.google.com/maps/documentation/javascript/reference#PlaceSearchRequest)'
- en: Apart from the pool of options that appear while giving the request for a nearby
    search, there is also another bunch of properties in returning the results; in
    other words, the places represented by the `PlaceResult` class.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在请求附近搜索时出现的选项池之外，还有另一组属性在返回结果中；换句话说，由 `PlaceResult` 类表示的地点。
- en: 'For example, an `icon` property of the `PlaceResult` class that we can use
    in the following code block inside our `pinpointResult()` function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`PlaceResult` 类的 `icon` 属性，我们可以在以下代码块中在 `pinpointResult()` 函数内部使用：
- en: '[PRE70]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This code block will return the places together with their respective icons:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块将返回带有各自图标的地点：
- en: '![There''s more...](img/8825OT_06_13.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/8825OT_06_13.jpg)'
- en: Notice the painter's palette icon in the preceding screenshot, incorporated
    with the returned place, which is The Metropolitan Museum of Art in New York.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前一个屏幕截图中的画家调色板图标，它与返回的地点相结合，即纽约大都会艺术博物馆。
- en: 'You can also access the types to which the place belongs. The `types` property
    of the `PlaceResult` class returns the types in a string array. Therefore, the
    `Result.types` property returns the following parameters for The Metropolitan
    Museum of Art in New York:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以访问该地点所属的类型。`PlaceResult` 类的 `types` 属性返回一个字符串数组中的类型。因此，`Result.types` 属性返回以下参数，用于纽约大都会艺术博物馆：
- en: '[PRE71]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can also get information on whether a place is open or closed at the time
    of search if you change the click handler of the marker, as shown in the following
    code snippet:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改标记的点击处理程序，您还可以获取有关地点在搜索时是否开放的搜索信息，如下面的代码片段所示：
- en: '[PRE72]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Using the preceding code, you would have come up with information such as the
    following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，您可能会得到以下信息：
- en: '![There''s more...](img/8825OT_06_14.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/8825OT_06_14.jpg)'
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Complete list of properties for the PlaceResult class**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**PlaceResult 类的完整属性列表**'
- en: 'You can find the complete list of properties of the `PlaceResult` class at:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到 `PlaceResult` 类的完整属性列表：
- en: '[https://developers.google.com/maps/documentation/javascript/reference#PlaceResult](https://developers.google.com/maps/documentation/javascript/reference#PlaceResult)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/maps/documentation/javascript/reference#PlaceResult](https://developers.google.com/maps/documentation/javascript/reference#PlaceResult)'
- en: Finding places with the autocomplete option
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自动完成选项查找地点
- en: The Google Maps JavaScript API offers a variety of ways to search for places
    and additional information. You can apply nearby searches and have detailed information
    about places together with their geometry, as you have observed in the recipe
    named *Searching and showing nearby places* in this chapter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API 提供了多种搜索地点和获取额外信息的方法。您可以使用附近搜索，并获取有关地点的详细信息，包括它们的几何形状，正如您在本章中名为
    *搜索并显示附近地点* 的配方中所观察到的。
- en: How about having a text field control with an autocomplete feature for searching
    places? You can hardcode it, but there is no need to do so, as Google already
    has a feature exactly for this.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有想过使用具有自动完成功能的文本字段来控制搜索地点？您可以硬编码它，但这样做没有必要，因为 Google 已经有了一个专门为此目的的功能。
- en: In this recipe, we will go over the autocomplete feature of the `places` library
    for the Google Maps JavaScript API.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将介绍 Google Maps JavaScript API 的 `places` 库的自动完成功能。
- en: Getting ready
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will make use of the concepts related to the `places` library introduced
    in the *Searching and showing nearby places* recipe of this chapter. It is advised
    to go over this recipe to have a general understanding of places and their properties.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将使用本章中 *搜索并显示附近地点* 配方中引入的与 `places` 库相关的概念。建议您阅读此配方，以便对地点及其属性有一个整体的理解。
- en: How to do it...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can add the text field and search for places with the autocomplete feature
    by carrying out the following steps:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤添加文本字段并使用自动完成功能搜索地点：
- en: 'Insert an input HTML element that will be used as the autocomplete field:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一个用作自动完成字段的输入 HTML 元素：
- en: '[PRE73]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define the markers and pop-up variables as global outside the `initMap()` function:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initMap()`函数外部定义标记和弹出变量为全局变量：
- en: '[PRE74]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Initialize the global variables in `initMap()`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initMap()`中初始化全局变量：
- en: '[PRE75]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Get the `div` tag with its ID as `searchDiv` and push it as a custom control
    after creating the map with its `initMap()` options:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取ID为`searchDiv`的`div`标签，并在使用`initMap()`选项创建地图后将其作为自定义控件推入：
- en: '[PRE76]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Get the handle for the input element:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取输入元素的句柄：
- en: '[PRE77]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Supply the properties for the autocomplete search request:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为自动完成搜索请求提供属性：
- en: '[PRE78]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Get the `autocomplete` object by supplying the input HTML element to be used,
    namely `searchField`, and the `searchOptions`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供要使用的输入HTML元素，即`searchField`和`searchOptions`，来获取`autocomplete`对象：
- en: '[PRE79]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a `place_changed` event handler for the `autocomplete` object (steps
    9 to 11 will be in this event handler):'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`autocomplete`对象创建一个`place_changed`事件处理器（步骤9到11将在这个事件处理器中）：
- en: '[PRE80]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In the event handler, clear the previous markers first:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件处理器中，首先清除之前的标记：
- en: '[PRE81]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Get the `PlaceResult` object in response to the autocompleted search:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自动完成搜索的响应中获取`PlaceResult`对象：
- en: '[PRE82]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If the place has a geometry, call a function to create the associated marker:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果地点有几何形状，调用一个函数来创建相关的标记：
- en: '[PRE83]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Create a function for creating a marker and adding a click event handler for
    the marker:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于创建标记并为标记添加点击事件处理器的函数：
- en: '[PRE84]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '![How to do it...](img/8825OT_06_15.jpg)'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/8825OT_06_15.jpg)'
- en: You can make use of the autocomplete search features as shown in the preceding
    screenshot.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用前面截图所示的自定义搜索功能：
- en: How it works...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we first created an input element with some placeholder text
    (beware that this is not supported in older browsers) that will serve as our text
    field for searching places:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们首先创建了一个带有一些占位文本的输入元素（注意，这在不支持旧浏览器的浏览器中不受支持），它将作为我们的搜索地点的文本字段：
- en: '[PRE85]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, we added the `div` container tag as a custom control for the Google Maps
    JavaScript API to have the text field inside the Google Maps UI:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在Google Maps JavaScript API中添加了`div`容器标签作为自定义控件，以便在Google Maps UI中包含文本字段：
- en: '[PRE86]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We set the properties for the autocomplete search in an `AutocompleteOptions`
    object named `searchOptions`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为`searchOptions`的`AutocompleteOptions`对象中设置自动完成搜索的属性：
- en: '[PRE87]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the preceding code snippet, `bounds` serves to define the boundaries for
    the places to be found. Here, we are setting it to a large predefined boundary;
    you can set it to another `LatLngBounds` object of your taste.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`bounds`用于定义要找到的地点的边界。在这里，我们将其设置为一个大预定义的边界；你可以将其设置为另一个你喜欢的`LatLngBounds`对象。
- en: The `types` array is empty for this recipe; actually this array is for restricting
    the types of places to be found, whether it be a business, city, or region. In
    our example, it is empty, so our searches will return every type of `PlaceResult`
    object.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，`types`数组是空的；实际上，这个数组用于限制要找到的地点的类型，无论是商业、城市还是地区。在我们的例子中，它是空的，所以我们的搜索将返回每种类型的`PlaceResult`对象。
- en: 'We created our autocomplete object with two ingredients: `searchField` being
    the input element and `searchOptions` having the `bounds` and `types` properties:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个成分创建了我们的自动完成对象：`searchField`是输入元素，`searchOptions`具有`bounds`和`types`属性：
- en: '[PRE88]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, we create our `place_changed` event handler for our `Autocomplete` object,
    which gets fired when the user selects the `PlaceResult` provided:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们的`Autocomplete`对象创建了一个`place_changed`事件处理器，当用户选择提供的`PlaceResult`时会被触发：
- en: '[PRE89]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the event handler, we detach the marker previously mapped on the map; then,
    we call the `getPlace()` method to get the `Place` object of type `PlaceResult`
    in this context. If the place exists and if it has geometry (meaning that, a proper
    `PlaceResult` instance is found), we call the `pinpoint()` function to create
    a marker from `PlaceResult` and attach a click event handler for the marker to
    popup the associated `InfoWindow` object:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理器中，我们取消映射在地图上的标记；然后，我们调用`getPlace()`方法来获取此上下文中的`PlaceResult`类型的`Place`对象。如果该地点存在并且具有几何形状（意味着找到了合适的`PlaceResult`实例），我们调用`pinpoint()`函数从`PlaceResult`创建标记，并为标记附加一个点击事件处理器以弹出相关的`InfoWindow`对象：
- en: There's more...
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In our recipe, we set the `bounds` property in the `searchOptions` object to
    a predefined boundary:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱中，我们在`searchOptions`对象中设置`bounds`属性为一个预定义的边界：
- en: '[PRE90]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This line sets the autocomplete operation to find the searched places primarily
    within, but not limited to, the specific `LatLngBounds` object. Therefore, do
    not get surprised if you happen to give a small boundary and find results outside
    the boundary.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将自动完成操作设置为在主要但不仅限于特定`LatLngBounds`对象内查找搜索地点。因此，如果您意外地给出一个小边界并发现结果在边界之外，请不要感到惊讶。
- en: 'We''re setting the boundary to a `LatLngBounds` object, such as boundary of
    the map, and you can change it afterwards:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将边界设置为`LatLngBounds`对象，例如地图的边界，之后您可以更改它：
- en: '[PRE91]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'But what happens if you need to set the bounds to the current viewport, which
    gets updated as you pan and zoom in/out the map? There is a way, as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您需要将边界设置为当前视口，该视口在您平移和缩放地图时更新怎么办？有一种方法，如下所示：
- en: '[PRE92]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: By using this `bindTo()` function, the `bounds` property is bound to the current
    viewport boundary and gets updated when it changes.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用此`bindTo()`函数，`bounds`属性被绑定到当前视口边界，并在它更改时更新。
- en: 'Apart from the `bounds` property, there is a `types` property that we have
    set as an empty array, but it does not need to be empty to filter out the predictions
    done by our `autocompleteSearch` object:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`bounds`属性外，还有一个`types`属性，我们将其设置为空数组，但它不需要为空以过滤掉由我们的`autocompleteSearch`对象完成的预测：
- en: '[PRE93]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This renders the `autocompleteSearch` object, searching only for administrative
    regions instead of all places. So when you type `colos`, the Colosseum in Rome
    does not come up, as only administrative regions are permitted to be displayed
    in the `autocompleteSearch` object; you can observe this in the following screenshot:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染`autocompleteSearch`对象，仅搜索行政区域而不是所有地点。因此，当您输入`colos`时，罗马的斗兽场不会出现，因为只有允许在`autocompleteSearch`对象中显示的行政区域；您可以在以下屏幕截图中观察到这一点：
- en: '![There''s more...](img/8825OT_06_16.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/8825OT_06_16.jpg)'
- en: Note
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Complete list of entries for the types property in the google.maps.places.AutocompleteOptions
    class**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**google.maps.places.AutocompleteOptions 类中 `types` 属性的完整条目列表**'
- en: 'You can find the complete list of entries for the `types` property in the `AutocompleteOptions`
    class at:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到`AutocompleteOptions`类中`types`属性的完整条目列表：
- en: '[https://developers.google.com/maps/documentation/javascript/reference#AutocompleteOptions](https://developers.google.com/maps/documentation/javascript/reference#AutocompleteOptions)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/maps/documentation/javascript/reference#AutocompleteOptions](https://developers.google.com/maps/documentation/javascript/reference#AutocompleteOptions)'
- en: Adding drag zoom to the map
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将拖动缩放添加到地图
- en: Google Maps has a zoom control and the JavaScript API makes use of this control
    to offer a variety of options for programmers. It is a very useful and easy-to-use
    control. But there are other ways for zooming; for instance, by drawing an area
    of interest by dragging a box, so that the map zooms to that area.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps 有一个缩放控件，JavaScript API 利用这个控件为程序员提供各种选项。这是一个非常实用且易于使用的控件。但还有其他缩放的方法；例如，通过拖动框绘制感兴趣的区域，这样地图就会缩放到该区域。
- en: 'This functionality does not exist in the standard Google Maps JavaScript API
    and any of its libraries; you have to code it. Or, you can make use of the utility
    libraries, developed by the good guys, at the following link:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能在标准的 Google Maps JavaScript API 及其任何库中都不存在；您必须自己编写代码。或者，您可以使用以下链接中由好人开发的实用库：
- en: '[https://code.google.com/p/google-maps-utility-library-v3/wiki/Libraries](https://code.google.com/p/google-maps-utility-library-v3/wiki/Libraries)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://code.google.com/p/google-maps-utility-library-v3/wiki/Libraries](https://code.google.com/p/google-maps-utility-library-v3/wiki/Libraries)'
- en: One of their libraries, `KeyDragZoom`, is exactly for this zoom functionality,
    and we will use this library in this recipe.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的一个库，`KeyDragZoom`，正是为此缩放功能而设计的，我们将在本食谱中使用这个库。
- en: Getting ready
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You have to download the `keydragzoom.js` JavaScript source file from the following
    link (the latest release is 2.0.9 as of the time of writing this book) and place
    it in the same directory as our recipe source code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须从以下链接下载`keydragzoom.js` JavaScript 源文件（截至本书编写时，最新版本为 2.0.9），并将其放置在与我们的食谱源代码相同的目录中：
- en: '[http://google-maps-utility-library-v3.googlecode.com/svn/tags/keydragzoom/](http://google-maps-utility-library-v3.googlecode.com/svn/tags/keydragzoom/)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://google-maps-utility-library-v3.googlecode.com/svn/tags/keydragzoom/](http://google-maps-utility-library-v3.googlecode.com/svn/tags/keydragzoom/)'
- en: How to do it...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps to perform zoom by dragging a box and zooming into the area
    inside the box:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是执行通过拖动框进行缩放并放大框内区域的步骤：
- en: 'Use a reference for the `keydragzoom`.`js` file:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用对`keydragzoom`.`js`文件的引用：
- en: '[PRE94]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Enable the functionality after setting all the map-related options in the `initMap()`
    function:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initMap()` 函数中设置所有与地图相关的选项后启用此功能：
- en: '[PRE95]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '![How to do it...](img/8825OT_06_17.jpg)'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/8825OT_06_17.jpg)'
- en: You can make use of zooming by dragging a box as shown in the preceding screenshot.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过拖动一个框来使用缩放功能，如图中所示的前一个截图。
- en: How it works...
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: You can perform drag zooms either by pressing the control button and drawing
    a box, or simpler than that, holding the *Shift* key and drawing the box to zoom
    into the area inside the box.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按下控制按钮并绘制一个框来执行拖动缩放，或者更简单的方法是，按住 *Shift* 键并绘制一个框来缩放框内的区域。
- en: To do this, we first added the JavaScript source file of the drag zoom library
    in our recipe. After setting the map options and using the map instance we can
    enable the drag zoom functionality by using the `enableKeyDragZoom()` method of
    the map instance.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，我们首先在我们的配方中添加了拖动缩放库的 JavaScript 源文件。在设置地图选项并使用地图实例后，我们可以通过使用地图实例的 `enableKeyDragZoom()`
    方法来启用拖动缩放功能。
- en: This extension method is not a part of the Google Maps JavaScript API and comes
    with the `keydragzoom` library. There are a few associated options that are embedded
    under the `KeyDragZoomOptions` class.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展方法不是 Google Maps JavaScript API 的一部分，而是随 `keydragzoom` 库一起提供。有几个相关的选项嵌入在
    `KeyDragZoomOptions` 类中。
- en: 'Keep in mind that, in its simplest form, you can use the key drag zoom functionality
    by enabling it:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在其最简单形式中，您可以通过启用它来使用键拖动缩放功能：
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The only difference would be that you would have to use the *Shift* key as your
    only way because there would be no drag zoom control button.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是您必须使用 *Shift* 键作为您唯一的操作方式，因为没有拖动缩放控制按钮。
- en: 'The properties embedded in the `KeyDragZoomOptions` class are all about the
    control button that is placed below the standard zoom control:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyDragZoomOptions` 类中嵌入的属性都是关于放置在标准缩放控制按钮下方的控制按钮：'
- en: '![How it works...](img/8825OT_06_18.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8825OT_06_18.jpg)'
- en: The `visualEnabled` property sets the control to be seen or not, so if this
    property is `false`, there is no need for other properties as well. The `visualPosition`
    property sets the control position; we have placed it to the left. A detailed
    description on control positions can be found in the *Changing the position of
    controls* recipe of [Chapter 4](ch04.html "Chapter 4. Working with Controls"),
    *Working with Controls*.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`visualEnabled` 属性设置控制是否可见，因此如果此属性为 `false`，则不需要其他属性。`visualPosition` 属性设置控制位置；我们将其放置在左侧。有关控制位置的详细描述，请参阅[第4章](ch04.html
    "第4章. 使用控件")中的*更改控件位置*配方，*使用控件*。'
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Complete list of properties in the KeyDragZoomOptions class**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**KeyDragZoomOptions 类中的属性完整列表**'
- en: 'You can find the complete list of properties in the `KeyDragZoomOptions` class
    at the following link:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中找到 `KeyDragZoomOptions` 类中属性的完整列表：
- en: '[http://google-maps-utility-library-v3.googlecode.com/svn/tags/keydragzoom/2.0.9/docs/reference.html](http://google-maps-utility-library-v3.googlecode.com/svn/tags/keydragzoom/2.0.9/docs/reference.html)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://google-maps-utility-library-v3.googlecode.com/svn/tags/keydragzoom/2.0.9/docs/reference.html](http://google-maps-utility-library-v3.googlecode.com/svn/tags/keydragzoom/2.0.9/docs/reference.html)'
- en: See also
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can review the Google Maps JavaScript API controls and their use in [Chapter
    4](ch04.html "Chapter 4. Working with Controls"), *Working with Controls*
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[第4章](ch04.html "第4章. 使用控件")中查看 Google Maps JavaScript API 控件及其使用，*使用控件*。
- en: Creating custom popups/infoboxes
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义弹出窗口/信息框
- en: We have already created popups or infoboxes in [Chapter 3](ch03.html "Chapter 3. Adding
    Vector Layers"), *Adding Vector Layers*. As it is stated there, almost every mapping
    application has the ability to display information that is related to the features
    shown on it. This information can be related to a marker or a map. Instead of
    showing all the information on the map, popups or info boxes are used only when
    needed.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章](ch03.html "第3章. 添加矢量图层")中创建了弹出窗口或信息框，*添加矢量图层*。正如那里所述，几乎每个地图应用都有显示与其上显示的特征相关的信息的能力。这些信息可以与标记或地图相关。而不是在地图上显示所有信息，弹出窗口或信息框仅在需要时使用。
- en: 'The Google Maps JavaScript API has a `google.maps.InfoWindow` class to create
    a default infobox for developers. In some cases, you need custom infoboxes to
    show information. There are two ways to do this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API 有一个 `google.maps.InfoWindow` 类来为开发者创建默认的信息框。在某些情况下，您需要自定义信息框来显示信息。有两种方法可以做到这一点：
- en: The first way is to create a custom class that inherits from the `google.maps.OverlayView`
    class and fill the methods to show/hide infoboxes with custom CSS styles.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是通过创建一个继承自`google.maps.OverlayView`类的自定义类，并填充显示/隐藏信息框的方法，使用自定义CSS样式。
- en: 'The other, easier way is to use a library created for you. There is a project
    on Google Code named `google-maps-utility-library-v3` that holds the number of
    libraries extending the Google Maps JavaScript API. Here''s the link:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种更简单的方法是使用为你创建的库。在Google Code上有一个名为`google-maps-utility-library-v3`的项目，它包含扩展Google
    Maps JavaScript API的多个库。以下是链接：
- en: '[https://code.google.com/p/google-maps-utility-library-v3/wiki/Libraries](https://code.google.com/p/google-maps-utility-library-v3/wiki/Libraries)'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Google Maps Utility Library v3 库](https://code.google.com/p/google-maps-utility-library-v3/wiki/Libraries)'
- en: This project has a library named `InfoBox` that makes it possible to create
    custom infoboxes or map labels.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此项目有一个名为`InfoBox`的库，它使得创建自定义信息框或地图标签成为可能。
- en: In this recipe, we will use the previously mentioned library to create custom
    infoboxes that can be bound to a marker and a map. The same infobox shows different
    information according to its binding. We will also add a simple map label at a
    fixed place, if extra information needs to be added to the map.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用之前提到的库来创建可以绑定到标记和地图的自定义信息框。同一个信息框根据其绑定显示不同的信息。如果需要向地图添加更多信息，我们还将添加一个简单的地图标签。
- en: Getting ready
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first recipe of [Chapter 1](ch01.html "Chapter 1. Google Maps JavaScript
    API Basics"), *Google Maps JavaScript API Basics*, will do our work. We will add
    to it in this recipe.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. Google Maps JavaScript API 基础")的第一道菜谱，*Google Maps JavaScript
    API 基础*，将完成我们的工作。我们将在此菜谱中添加内容。'
- en: How to do it...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can get custom infoboxes by completing the following steps:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成以下步骤，您可以获取自定义信息框：
- en: 'First, go to the following address to get the latest `InfoBox` source code
    and save it into a file named `infobox.js` under the `lib` directory. We used
    the `/1.1.9/src/infobox_packed.js` file under the following URL:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，访问以下地址以获取最新的`InfoBox`源代码，并将其保存到`lib`目录下的`infobox.js`文件中。我们使用了以下URL下的`/1.1.9/src/infobox_packed.js`文件：
- en: '[http://google-maps-utility-library-v3.googlecode.com/svn/tags/infobox/](http://google-maps-utility-library-v3.googlecode.com/svn/tags/infobox/)'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Google Maps Utility Library v3 代码库](http://google-maps-utility-library-v3.googlecode.com/svn/tags/infobox/)'
- en: 'Then, we get the codes by creating a simple map recipe, and add the following
    code to add our library to the page:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过创建一个简单的地图配方来获取代码，并将以下代码添加到页面中，以添加我们的库：
- en: '[PRE97]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The next step is to create the contents of the infobox with the help of a `div`
    element:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用`div`元素的帮助来创建信息框的内容：
- en: '[PRE98]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now we create an object that defines the options of the infobox:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个对象来定义信息框的选项：
- en: '[PRE99]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can initialize our custom infobox in the following manner:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以以下述方式初始化我们的自定义信息框：
- en: '[PRE100]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Also, we create a JSON object that defines the options of a map label:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们创建一个JSON对象来定义地图标签的选项：
- en: '[PRE101]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, we initialize the map label and add it to the map in the following manner:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们以以下方式初始化地图标签并将其添加到地图中：
- en: '[PRE102]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create a simple marker that will be bound to the infobox:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的标记，该标记将被绑定到信息框：
- en: '[PRE103]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'When the map is ready, we will open the infobox attached to the marker:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当地图准备就绪时，我们将打开与标记绑定的信息框：
- en: '[PRE104]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We should create event listeners for the marker and map for their click events
    to show the infobox. An infobox will appear at the bottom of the marker when the
    marker is clicked or when the map is clicked on at some point:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该为标记和地图创建事件监听器，以便在它们的点击事件中显示信息框。当点击标记或在某些点上点击地图时，信息框将出现在标记的底部：
- en: '[PRE105]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can also listen to events of infoboxes. We will add a listener to the click
    event of the close button of the infobox:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以监听信息框的事件。我们将向信息框关闭按钮的点击事件添加一个监听器：
- en: '[PRE106]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Go to your local URL where your HTML file is stored in your favorite browser;
    you will see a popup with an infobox below. If you click on the map, you will
    see the coordinates of the mouse click inside the infobox, or if you click on
    the marker, you will see the infobox with the contents related to the marker.
    There is also a fixed map label at the top right of the map with some content;
    it says **Custom Map Label**.![How to do it...](img/8825OT_06_19.jpg)
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在最喜欢的浏览器中存储HTML文件的本地URL；您将看到一个带有信息框的弹出窗口。如果您点击地图，您将在信息框内看到鼠标点击的坐标，或者如果您点击标记，您将看到与标记相关的内容的信息框。地图的右上角还有一个固定的地图标签，其中包含一些内容；它说**自定义地图标签**。![如何操作...](img/8825OT_06_19.jpg)
- en: You can get your custom infobox as shown in the preceding screenshot.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以获取您自定义的信息框，如图中所示的前一个屏幕截图。
- en: How it works...
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using libraries in your web applications is common. The use of libraries saves
    development and debugging time for developers. Compared to your limited cases,
    libraries are tested in different environments for different cases.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Web应用程序中使用库是常见的。库的使用为开发者节省了开发和调试时间。与您有限的案例相比，库在不同的环境中针对不同的案例进行了测试。
- en: As stated earlier, you can also write your own custom class to show custom infoboxes
    or map labels, but this is not a suggested way to discover America from the beginning.
    We used the library named `InfoBox`, which is written for this purpose. The documentation
    of this library is similar to the Google Maps JavaScript API documentation (found
    at [http://google-maps-utility-library-v3.googlecode.com/svn/tags/infobox/1.1.9/docs/reference.html](http://google-maps-utility-library-v3.googlecode.com/svn/tags/infobox/1.1.9/docs/reference.html)).
    The latest version of the library is 1.1.9 at the time this book was being written.
    Please update the library if there is a new version when you are using it.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您也可以编写自己的自定义类来显示自定义信息框或地图标签，但这并不是一开始就发现美洲大陆的建议方法。我们使用了名为`InfoBox`的库，它是为此目的编写的。该库的文档类似于Google
    Maps JavaScript API文档（可在[http://google-maps-utility-library-v3.googlecode.com/svn/tags/infobox/1.1.9/docs/reference.html](http://google-maps-utility-library-v3.googlecode.com/svn/tags/infobox/1.1.9/docs/reference.html)找到）。在本书编写时，该库的最新版本是1.1.9。如果您使用的是新版本，请更新库。
- en: The `InfoBox` library is built on the Google Maps JavaScript API base class
    named `google.maps.OverlayView`, which is used for adding extra layers or views
    to the map.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfoBox`库建立在Google Maps JavaScript API的基类`google.maps.OverlayView`之上，用于向地图添加额外的图层或视图。'
- en: As expected, there is a need for content, which is defined in the `div` elements.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，需要内容，这些内容在`div`元素中定义。
- en: '[PRE107]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `InfoBox` library can be initialized to show an infobox with its constructor,
    with a parameter created from the `InfoBoxOptions` class, as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfoBox`库可以通过其构造函数初始化，使用从`InfoBoxOptions`类创建的参数显示信息框，如下所示：'
- en: '[PRE108]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `InfoBox` library can be initialized to create a map label with its constructor
    with a parameter created from the `InfoBoxOptions` class, as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfoBox`库可以通过其构造函数初始化，使用从`InfoBoxOptions`类创建的参数创建地图标签，如下所示：'
- en: '[PRE109]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The parameters for the `InfoBoxOption` class are explained in the following
    list:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfoBoxOption`类的参数在以下列表中解释：'
- en: '**content**: This can be a string or an HTML element. In our example, we used
    HTML `div` elements to create a beautiful decorated infobox. You can use the `CSS`
    style elements to create your custom infobox.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**content**：这可以是一个字符串或一个HTML元素。在我们的例子中，我们使用了HTML `div`元素来创建一个漂亮的装饰信息框。您可以使用`CSS`样式元素来创建您自定义的信息框。'
- en: '**pixelOffset**: This is the offset in pixels from the top-left corner of the
    infobox. In this recipe, we want to center the infobox, so we used half the width
    of the infobox.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pixelOffset**：这是信息框从左上角起像素偏移量。在这个食谱中，我们想要使信息框居中，所以我们使用了信息框宽度的一半。'
- en: '**boxStyle**: This defines the CSS styles used for the infobox. The `background`
    style property used in this recipe shows the upper-headed arrow image. This image
    is a customized image to be placed in the middle of the infobox. The names of
    the `width` and `opacity` style properties suggest how they are used.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**boxStyle**：这定义了用于信息框的CSS样式。在这个食谱中使用的`background`样式属性显示了上箭头图像。这是一个放置在信息框中间的定制图像。`width`和`opacity`样式属性的名称暗示了它们的使用方式。'
- en: '**closeBoxMargin**: This is used to define where the close box will be placed
    in the CSS margin style value. In this recipe, we used the upper-headed arrow
    at the top of the infobox, so we must move the close box below the arrow image.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**closeBoxMargin**：用于定义关闭框在CSS边距样式值中的位置。在本食谱中，我们使用了信息框顶部的向上箭头，因此我们必须将关闭框移动到箭头图像下方。'
- en: '**closeBoxURL**: This is the image URL of the close box. Google''s standard
    close box image is used here. If you do not want to add a close box, set this
    property to empty.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**closeBoxURL**：这是关闭框的图像URL。这里使用的是Google的标准关闭框图像。如果您不想添加关闭框，请将此属性设置为空。'
- en: '**pane**: This is the pane where the infobox will appear. If you are using
    it as an infobox, then use `floatPane`. If you are using it as a map label, use
    `mapPane`.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pane**：这是信息框将出现的面板。如果您将其用作信息框，则使用`floatPane`。如果您将其用作地图标签，则使用`mapPane`。'
- en: '**position**: This is the geographic location of the infobox or map label defined
    in the objects created from `google.maps.LatLng class`.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**position**：这是由`google.maps.LatLng`类创建的对象中定义的信息框或地图标签的地理位置。'
- en: '**enableEventPropagation**: This is used to propagate the events. If you are
    using the `InfoBox` class for map labels, you don''t need to get the events of
    the label. The map''s events are more important in this case.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**enableEventPropagation**：用于传播事件。如果您使用`InfoBox`类作为地图标签，则不需要获取标签的事件。在这种情况下，地图的事件更为重要。'
- en: 'It doesn''t matter whether it is an infobox or map label, you can show `InfoBox`
    objects with the `open()` method. If there isn''t an anchor point, such as a marker,
    it only gets one parameter as a map; otherwise you should add the second parameter
    as an anchor object. Two usage examples are as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是信息框还是地图标签，您都可以使用`open()`方法显示`InfoBox`对象。如果没有锚点，例如标记，它只接受一个地图参数；否则，您应该添加第二个参数作为锚点对象。以下有两个用法示例：
- en: '[PRE110]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: If you need to change the position of the infobox like in the event handlers,
    you should use the `setPosition()` method of the class. This method gets objects
    created from the `google.maps.LatLng` class.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更改信息框的位置，如事件处理程序中所示，您应使用类的`setPosition()`方法。此方法获取由`google.maps.LatLng`类创建的对象。
- en: '[PRE111]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The events used in this recipe were the topic of [Chapter 5](ch05.html "Chapter 5. Understanding
    Google Maps JavaScript API Events"), *Understanding Google Maps JavaScript API
    Events*. We did not go into detail, but for some purposes, there are also events
    of the `InfoBox` class to handle. The following code block will listen to the
    clicking of the close button that will result in the closing of the infobox. The
    event handler of the listener will log only a message to the console for demonstration:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中使用的活动是[第5章](ch05.html "第5章。理解Google Maps JavaScript API事件")*理解Google Maps
    JavaScript API事件*的主题。我们没有深入探讨，但对于某些目的，`InfoBox`类的活动也需要处理。下面的代码块将监听关闭按钮的点击，这将导致信息框的关闭。监听器的事件处理程序将只向控制台记录一条消息以供演示：
- en: '[PRE112]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: As you can see, in the preceding code, the Google Maps JavaScript API has a
    lot of potential that can be extracted with the help of extra libraries. The Google
    Maps JavaScript API gives you the base, and you can build whatever you want on
    it.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在前面的代码中，Google Maps JavaScript API具有许多潜力，可以通过额外的库来提取。Google Maps JavaScript
    API为您提供了基础，您可以在其上构建任何您想要的东西。
- en: See also
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1,](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics") *Google Maps JavaScript API Basics*
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。Google Maps JavaScript API基础知识")*Google Maps JavaScript
    API基础知识*中的*在自定义DIV元素中创建简单地图*食谱'
- en: The *Getting the coordinates of a mouse click* recipe in [Chapter 5,](ch05.html
    "Chapter 5. Understanding Google Maps JavaScript API Events") *Understanding Google
    Maps JavaScript API Events*
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。理解Google Maps JavaScript API事件")*理解Google Maps JavaScript
    API事件*中的*获取鼠标点击坐标*食谱'
