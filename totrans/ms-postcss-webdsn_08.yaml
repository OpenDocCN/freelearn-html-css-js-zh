- en: Chapter 8. Creating PostCSS Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins, plugins…we can't escape them; by now, you will have seen that they
    are an essential part of developing within PostCSS. Its modular nature is built
    entirely around plugins, and is how we can streamline our processing through selective
    use of these plugins.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll cover the anatomy of a PostCSS plugin and take a look
    at some pre-built examples, before embarking on the construction of a simple plugin
    that we can then test and submit for inclusion in the PostCSS system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover a number of topics throughout this chapter, which will include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering how plugins can be used to extend PostCSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the architecture of a standard plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a PostCSS plugin using the plugin boilerplate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building some example plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and submitting your plugin for inclusion in the PostCSS plugin library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring some examples of existing plugins available for PostCSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's make a start…!
  prefs: []
  type: TYPE_NORMAL
- en: Extending PostCSS with plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A question, how many times have you worked with plugins that by themselves don't
    actually achieve anything?
  prefs: []
  type: TYPE_NORMAL
- en: I'll bet the answer won't be a high figure—and no, I'm not including those plugins
    that claim to perform an operation, yet don't seem to work for some reason! The
    power of PostCSS lies not in the core system, but the plugins that we use to manipulate
    our CSS style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there are more than 200 plugins available for use within
    PostCSS—these range from extending PostCSS (such as `postcss-nested` or `postcss-mixins`),
    to manipulating colors (such as `postcss-color-hcl` or `postcss-rgba-hex`), to
    plugins that cater for future CSS syntax (such as adding `@extend` support).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full list is available at [https://github.com/postcss/postcss/blob/master/docs/plugins.md](https://github.com/postcss/postcss/blob/master/docs/plugins.md),
    or via the searchable catalogue hosted at [http://www.postcss.parts](http://www.postcss.parts).
  prefs: []
  type: TYPE_NORMAL
- en: To date, we've used a fair number of plugins throughout our examples—we've configured
    them for use, but there is still an element of *black box* about them, where we
    don't always know how the insides work. It's time to change that. As a first step,
    let's briefly meet the toolset that helps make plugins possible, the PostCSS API.
  prefs: []
  type: TYPE_NORMAL
- en: Any plugin created for PostCSS will have been constructed using the API. The
    key to this API will be the `Node` and `Container` methods, which can be used
    to manipulate content once the `postcss` object has been initialized in the plugin.
    We will explore these in more detail throughout this chapter, but before doing
    so, it makes sense to explore the architecture of a PostCSS plugin first, so let's
    have a look and see what makes one tick.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the architecture of a standard plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a PostCSS plugin is a straightforward process—the beauty of PostCSS
    is that we as developers are free to design and construct any plugin we desire;
    it does mean that not every plugin will be of the same quality as others!
  prefs: []
  type: TYPE_NORMAL
- en: 'This aside, the recommended way to construct any PostCSS plugin is to use the
    boilerplate code, which is available from [https://github.com/postcss/postcss-plugin-boilerplate](https://github.com/postcss/postcss-plugin-boilerplate);
    we can see an example of it in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dissecting the architecture of a standard plugin](img/BO5194_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we explore the source code for any PostCSS plugin hosted in GitHub, there
    will be a host of different files present; not all of them will be the same for
    each different plugin!
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, if we delve in deeper, there are some files we would expect to
    see as part of the architecture of any plugin; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.js`: This contains the main functionality for each plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`: This is used to configure and manage locally installed NPM
    packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test.js`: This contains the tests required to ensure the plugin works as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore these in more detail, beginning with `index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring index.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The crux of any plugin centers around `index.js`—we start with a reference
    to PostCSS (as a dependency for our plugin); this is followed by the exports function,
    which exposes functionality to anyone using the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discovering package.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next up, we have `package.json`—this is used to configure and manage locally
    installed Node packages; given that PostCSS is based on Node.js, we will see something
    akin to this for any plugin installed as part of the PostCSS ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first section contains some basic details about the plugin name, description,
    and version. If we look through the `package.json` file, it's not difficult to
    spot a number of keywords in capitals—at first glance, one might be mistaken for
    thinking that it renders as invalid JSON.
  prefs: []
  type: TYPE_NORMAL
- en: There is a reason for this—one of the steps for using this boilerplate plugin
    is to run a script that will replace these keywords with information; the script
    will transform this into valid JSON. This is something we will cover in more detail
    later, in the *Creating a transition plugin* section. For now, assume that this
    file will be converted to valid JSON during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we then store the name of the author, the plugin''s license, and
    where we can get the source or file bugs relating to the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This section is the most critical—the dependencies section stores details of
    any dependencies, when used in production; the `devDependencies` section takes
    care of dependencies when working in a development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A key guideline given by the PostCSS team is that every plugin should be tested—this
    should always be a given, to help ensure we are creating something that is solid
    and not likely to cause issues for our users. A part of the boilerplate code contains
    a suitable test script for this purpose, so let's take a quick look at it now.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring test.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third element that is key to any plugin is the test—this should be stored
    in `test.js`, and will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will cover this part in more detail later in this chapter, in the *Testing
    and submitting a plugin* section—for now, let's get stuck in to creating a PostCSS-based
    plugin. We'll start with a quick look at the API, before diving into creating
    a plugin that applies a specific font stack based on a chosen font, and adds updated
    declarations if one of those fonts needs to be imported into our site.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the framework in place, we can then build up our plugin using the PostCSS
    API; this contains a number of classes, modules, and methods that we can use.
    The key function in the API is of course `postcss`—this is the main entry point
    for PostCSS and is required for all plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a quick look through what else is available in the API, beginning
    with the Vendor module.
  prefs: []
  type: TYPE_NORMAL
- en: The Vendor module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This module contains helpers for working with vendor prefixes—we can initiate
    it using this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The module contains two methods, as shown in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Module | Format | Value returned |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `vendor.prefix` | String | The vendor prefix extracted from an input string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `vendor.unprefixed` | String | The input string stripped of its vendor prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The List module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This module contains helpers to safely split lists of CSS values, whilst preserving
    parentheses and quotes. We can initiate it using this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The module contains two methods, as shown in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Module | Format | Designed to split |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `list.space` | String | Space-separated values (such as those for background,
    border-radius, and other shorthand properties):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `list.comma` | String | Comma-separated values (such as those for transition-*
    and background properties):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Classes available in the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the PostCSS object has been defined as a dependency in our plugin, we
    can begin to manipulate its contents—for this purpose, there are a number of classes
    available to assist, as shown in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name of class | Role within plugin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Processor` | Creates a Processor instance, initializes any plugins, then
    uses this instance on CSS files as specified in the configuration. |'
  prefs: []
  type: TYPE_TB
- en: '| `LazyResult` | Acts as a promise proxy for the result of PostCSS transformations.Promises
    are a key part of working with Node.js—if you are not familiar with this concept,
    take a look at [https://www.promisejs.org/](https://www.promisejs.org/) for a
    detailed explanation. |'
  prefs: []
  type: TYPE_TB
- en: '| `Result` | Provides the result of any PostCSS transformations. |'
  prefs: []
  type: TYPE_TB
- en: '| `Warning` | Allows a user to manage a warning within the plugin. |'
  prefs: []
  type: TYPE_TB
- en: '| `CssSyntaxError` | Allows a user to retrieve any errors for broken CSS, generated
    by the CSS parser. |'
  prefs: []
  type: TYPE_TB
- en: '| `Input` | Represents the source CSS being manipulated by PostCSS plugins.
    |'
  prefs: []
  type: TYPE_TB
- en: Nodes available in the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, we cannot manipulate content from within a PostCSS plugin without
    having access to each CSS node—the API contains a group of useful nodes to help
    with parsing and manipulating content:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Node | Represents |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Root` | A CSS file and its parsed nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `AtRule` | An `@`-based rule in CSS, such as `@media print {…}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Rule` | A CSS rule, containing a selector and declaration block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Declaration` | A CSS declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Comment` | A comment between declarations or statements (in both rules and
    `@`-rules):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Methods available in the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A key role of a plugin is to navigate through each node to help determine if
    it should perform some action; the API contains a number of methods to assist
    with parsing nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method group | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Nodes | These methods are for working with each CSS node—this includes methods
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node.type`: returns a string representing the node type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node.parent`: returns the parent node as a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node.next()` or `node.prev()`: returns the next or previous child of a node''s
    parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details are available at [https://github.com/postcss/postcss/blob/master/docs/api.md#nodes-common-methods](https://github.com/postcss/postcss/blob/master/docs/api.md#nodes-common-methods)
    |
  prefs: []
  type: TYPE_NORMAL
- en: '| Containers | These methods contain methods for working with children in a
    container node—this includes methods such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`container.nodes`: returns an array containing the container''s children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.first`: return the container''s first child node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container.last`: return the container''s last child node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details are available at [https://github.com/postcss/postcss/blob/master/docs/api.md#containers-common-methods](https://github.com/postcss/postcss/blob/master/docs/api.md#containers-common-methods)
    |
  prefs: []
  type: TYPE_NORMAL
- en: The main site contains details and examples of all of the methods and classes
    available within the API—it is worth taking time to familiarize yourself with
    the options available.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Details for each method or class are available on the PostCSS API page at [https://github.com/postcss/postcss/blob/master/docs/api.md](https://github.com/postcss/postcss/blob/master/docs/api.md)
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, enough with theory: on we go! Let''s change tack and put some of what
    we''ve just learnt to good use by constructing a couple of plugins for PostCSS.
    These will use a real mix of the API commands that we''ve briefly looked at earlier
    in this chapter; our first demo centers around a shorthand plugin for creating
    transition statements within CSS rules in a style sheet, so let''s get stuck in
    and see how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an transition plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea for this plugin is not new; it's loosely based on the `postcss-transform-shortcut`
    plugin by Jonathan Neal, available from [https://github.com/jonathantneal/postcss-transform-shortcut](https://github.com/jonathantneal/postcss-transform-shortcut).
    The concept is not necessarily a shorter means to create transition statements,
    but it makes it easier by allowing authors to specify values independently. These
    are then automatically inserted into the correct order within the transition declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this plugin is also available on GitHub, at [https://github.com/alexlibby/postcss-transition-shortcut](https://github.com/alexlibby/postcss-transition-shortcut);
    the NPM package is also available at [https://www.npmjs.com/package/postcss-transition-shortcut](https://www.npmjs.com/package/postcss-transition-shortcut).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive in and take a look at how it is put together, in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by installing Git—this is required for installing the plugin boilerplate.
    To do this, browse to [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git),
    and follow the instructions for your platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Node.js command prompt, then change the working folder to our project
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the prompt, enter this command then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Git will clone the `postcss-plugin-boilerplate` repository to our project area,
    as shown in this screenshot:![Creating an transition plugin](img/BO5194_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The plugin boilerplate includes a script to automatically generate the skeleton
    for our plugin—go ahead and run this command in the prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will show a series of prompts for various bits of information. Go ahead and
    fill in appropriate responses, similar to that shown in this screenshot. Note
    that it is not obligatory to have a GitHub account, as the information is simply
    added to the `package.json` file; if you spend any time developing plugins in
    the future, then it is recommended that you go ahead and create one:![Creating
    an transition plugin](img/BO5194_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the plugin folder has been created, we can remove the `postcss-plugin-boilerplate`
    folder from the project root folder, as this is no longer needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see something akin to this screenshot, when browsing
    the contents of our plugin folder:![Creating an transition plugin](img/BO5194_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we can now add the code for our plugin into `index.js`—to do
    this, open up a copy of the file from within the `postcss-transition-shortcut`
    plugin from within our project area, and alter the code as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this stage we will have a working plugin—the proof, though (to quote an
    old English saying), is in the pudding: does the plugin work as we expect? Well,
    there''s no better way to find out than by trying it out, so let''s set up a quick
    demo to confirm it works as expected. Before we do so, though, there is one important
    point I need to make, which concerns the generation of PostCSS plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test for our plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sharp-eyed amongst you will notice though that if we don't specify one of
    the four values for our transition plugin, then the code at present won't use
    the default; hopefully an update will come in a future version of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'This aside, the process for testing our plugin uses the AVA test runner, available
    from [https://github.com/sindresorhus/ava](https://github.com/sindresorhus/ava).
    The framework for the test is already created within the plugin boilerplate, which
    leaves us to add the test code to test.js file. Let''s take a peek at what''s
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by installing the AVA test runner—for this, fire up a Node.js command
    prompt, and change the working folder to the root of our plugin folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the prompt, enter these commands, pressing *Enter* after each—the first
    installs AVA, with the second adding it to our `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open a new file in your text editor of choice—go ahead and add the following
    highlighted lines to `test.js`, within the plugin folder we created in the previous
    exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, fire up a Node.js command prompt, then change the working directory to
    our plugin project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, enter `npm test` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AVA will perform the test, which is then linted using ESLint. If all is well,
    we should see the results shown in this screenshot—assuming nothing was amiss
    with the test:![Creating a test for our plugin](img/BO5194_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All good so far, right—at this point, we're OK to create a simple demo to prove
    plugin works…or are we? Well, the test shows a pass, so the code should be OK.
    But further down there are a ton of errors displayed, similar to this screenshot—what
    gives?
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a test for our plugin](img/BO5194_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The test has passed, yet the tests would seem to indicate otherwise; a look
    further down reveals yet more errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a test for our plugin](img/BO5194_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This raises some important points about testing, so let's cover these before
    continuing with our demo.
  prefs: []
  type: TYPE_NORMAL
- en: Correcting the errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main error, or `Exported linebreaks to be ''LF''…`, is a simple one to
    fix—it''s being caused by Sublime Text being set to use Windows as the default
    line endings setting. Assuming we''re using Sublime Text, let''s go ahead and
    deal with that error:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up Sublime Text, then open `index.js` from our plugin folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on View | Line Endings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the selected option to **Unix**, and save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 to 3 for `test.js`—once done, close both files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we re-run the test, we should see a significant drop in listed errors—there
    will be some left for us to fix in `index.js` and `test.js`, similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Correcting the errors](img/BO5194_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the errors are self-explanatory—the two that are less obvious are `Expected
    indentation of X spaces…` and `Line X exceeds the maximum line length…`. We can
    fix the first by replacing all instances of tabs with four individual spaces per
    tab. The second error is simple to fix—simply split the line of code into two
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: We need to work through all of the remaining errors, as far as possible—these
    won't entirely be the same for your version of the plugin, but some will be similar.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you come across any errors where you want to understand the reason behind
    the error, take a look at [https://jslinterrors.com/](https://jslinterrors.com/)—it's
    a great source for defining what an error means!
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we''ve cleared most of the errors, we should be left with just one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Correcting the errors](img/BO5194_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Is this an error we should fix, and therefore can clear from the report? The
    simple answer is that it depends—it highlights an important point about using
    linting for code, so let's take a moment to cover this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the final error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last error shown in the report presents some challenges—the code is valid,
    yet ESLint flags the error. The reason for this is that it has found an assignment
    expression within a while statement initializer; it is treated as a possible mistake
    in the code and *may* have unintended effects on the code.
  prefs: []
  type: TYPE_NORMAL
- en: In some respects, it can be treated as a warning, and not necessarily as an
    error. Prior to July 2013 we could have configured our test to ignore this, but
    changes made to ESLint since that date mean that this error cannot be cleared
    without reworking the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you would like to understand more about the causes of this error, then please
    refer to [http://jslinterrors.com/unexpected-assignment-expression/](http://jslinterrors.com/unexpected-assignment-expression/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our instance, the code is valid and will not cause any errors—it leaves
    us with several options as to what we can do going forward:'
  prefs: []
  type: TYPE_NORMAL
- en: We can simply ignore the error and carry on—it's not great that the test fails,
    but in this case it won't cause any harm to our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can switch off the test for it, so that while this condition is not tested,
    the test will at least show a 100% pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can look to alter the code to design out the error/warning—this is the ideal
    solution, but it may be a longer term route, depending on the nature of the changes
    we need to make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, we''re going to switch off the test for this error—we can do this
    by editing the `.eslintrc` file from within our plugin, and set the value in square
    brackets to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clearing the final error](img/BO5194_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will work in the short term, but with a view to revisiting the code to
    design out the ambiguity at some point in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a test using the plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our plugin in place, let''s test it out—for this, we need a couple of
    files from the code download that accompanies this book; the files are available
    in the `T43 – building a transition shortcut plugin` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and extract copies of `gulpfile.js` and `package.json`, then save them
    to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, add the following CSS styles, saving it as `style.css` in the
    `src` folder in our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fire up a Node.js command prompt, then change the working directory to our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, enter `gulp` then press *Enter*—PostCSS will go away and compile
    the source style sheet. If all is well, we should see the compiled results of
    our style sheet in the `dest` folder of our project area:![Performing a test using
    the plugin](img/BO5194_08_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this stage, we've run the test for our plugin—we go one step further, and
    add our plugin to a test runner service such as Travis CI (at [https://travis-ci.org](https://travis-ci.org)).
    Although this is a mandatory part of the process for creating any PostCSS plugin,
    there is a fairly steep learning curve, and anyone working on Windows may run
    into difficulties! If you are a Windows user, you will have to make `test.js`
    executable via the command line—this requires prior knowledge of using Git, which
    is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we'll skip past the Travis CI part of the process—the plugin is sufficiently
    straightforward that the local testing with `test.js` will suffice. Let's change
    tack—our plugin contains a number of useful concepts in PostCSS, so let's explore
    how it is put together in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting our plugin in detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The inspiration for this plugin is twofold—at the time of writing, PostCSS doesn't
    have a great number of animation-based plugins, and it borrows the same concept
    used in the `postcss-transform-shortcut plugin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the ubiquitous call to initialize PostCSS as a dependency for
    our plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we initialize `postcss.plugin`, to expose functionality within our
    plugin to the ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At present, our plugin doesn''t contain any options, so it will be set as blank;
    if we had had some options set, then these will be stored in the options array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A key part of our plugin is to set some default options—we need to have some
    default values set, if we don''t specify one or more values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Up next comes the crux of our plugin—it returns the result of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We walk through each rule using `css.walkRules`—it sets up a number of variables
    and an array; we also set a search string that will be used to find any instance
    of our transition properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we find a suitable instance of our property, we then clone it, adding the
    property name `transition` before it. We then work through each of up to four
    properties that may be set, joining them together into the final transition declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on. Our first example was a straightforward plugin; although it
    does need some further development (as indicated in *Testing our plugin*), it
    still serves a useful purpose. In our next example, we''ll take a different approach:
    we will use an existing plugin as a basis for our new version. This plugin, unlike
    the first one, will not see the light of day in GitHub, though—we''ll explore
    the reasons for this, and more, as part of our next exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom font plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our next demo, we're not going to build something original, but start with
    adapting an existing plugin that is already available for PostCSS. The plugin
    we will use is `postcss-fontpath` by Seane King (available from [https://github.com/seaneking/postcss-fontpath](https://github.com/seaneking/postcss-fontpath));
    we're going to incorporate an autocomplete facility that automatically adds the
    relevant font stack, based on the name provided, and using the lists available
    at [http://www.cssfontstack.com/](http://www.cssfontstack.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '"Why do this", I hear you ask? To prove a point—it isn''t always necessary
    to re-invent the wheel; sometimes it is preferable to simply adapt something that
    exists, which doesn''t quite fit our requirements. In this instance, the code
    we''re adding will make it more useful; it will need some further development
    to allow for error-checking, but nonetheless still serves a purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A point of note—recommended practice is to use the plugin boilerplate we covered
    in the previous section. For this next exercise, we will build it manually—this
    is to show you something of the process, even though it is not one we would release
    into the wild.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, that aside, let''s get stuck in and start developing our plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by creating a folder within the root of our project area—go ahead
    and name this folder `postcss-custom-fonts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to set up the folder as a Node module, so fire up a Node.js command
    prompt and change the working folder to our plugin folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter `npm init` to start the process of creating a `package.json`
    file—use the details shown in this screenshot, at the appropriate prompt:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Building a custom font plugin](img/BO5194_08_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'With the prompt still open, go ahead and enter these commands, then press *Enter*—the
    first one is needed to install PostCSS as a dependency for our plugin, with the
    second installing `underscore.js`, as a second dependency (it''s used for the
    extend method):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep the session open—we will need it towards the end of this exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the code download that accompanies this book, we need to extract a copy
    of `index.js`—copy this to the plugin folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see something akin to this screenshot when browsing
    the contents of our plugin folder:![Building a custom font plugin](img/BO5194_08_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our plugin in place, let's test it out. For this, we need a couple of files
    from the code download that accompanies this book. Go ahead and extract copies
    of `gulpfile.js` and `package.json` from the `T42 – Building a custom font` plugin
    folder (and *not* the plugin one!), then save them to the root of our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, add the following CSS styles, saving it as `style.css` in the
    `src` folder in our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Revert back to the Node.js command prompt session we had open at the start of
    this exercise. Make sure the working folder is set to our project area before
    continuing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter `gulp` then press *Enter*—PostCSS will go away and compile
    the source style sheet. If all is well, we should see the compiled results of
    our style sheet in the `dest` folder of our project area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Building a custom font plugin](img/BO5194_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this stage, we now have a working plugin—even though this is not an original
    creation, it still highlights a number of key concepts around construction of
    PostCSS plugins. Let's take a moment to explore the functionality of our plugin
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the functionality of our plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At first glance, the code for our plugin may look complex, but in reality it
    is relatively straightforward to follow—let''s go through it in sections, beginning
    with defining instances of the `postcss` object and a `fontstacks_config` object
    we will use in the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we add a simple helper function—this is used to convert font names
    into title case; the names listed in `fontstacks_config` are case sensitive, and
    will fail if they don''t match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the start of the plugin—the first two lines are the obligatory initialization
    to make the plugin available for use, followed by defining an options object.
    We then use `_.extend` to extend the predefined values in our chosen font stack
    with those added to the configuration object when running the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then walk through each rule and node, working out if they first contain
    a font declaration, then if they contain a font name that matches one in the predefined
    font stacks. If there is a match, then the font name is converted to the appropriate
    font stack and inserted with any additional fonts specified, but which don''t
    match our font stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second half of the plugin, we perform a simpler task—we work our way
    through each rule and declaration, looking for any instances of `@font-face` in
    the code. We then define a `fontpath` variable that removes any quotes from the
    supplied values, and a `format` array to manage the different font formats available
    for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We then build up the relevant statement for each font type, before assembling
    the custom font declaration and inserting it back into the appropriate point in
    our style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our plugin has exposed some key concepts in PostCSS plugin design—the main ones
    are the use of `.WalkDecls` and `.WalkRu` `les` (or `.WalkAtRules`). I would strongly
    recommend familiarizing yourself with the API documentation at [https://github.com/postcss/postcss/blob/master/docs/api.md](https://github.com/postcss/postcss/blob/master/docs/api.md),
    which outlines all of the commands available within the API, and gives a brief
    description of their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Despite creating what should be a useful plugin, it isn't one that I would recommend
    releasing into the wild. At this point you may think I have completely lost the
    plot, but as I always say, "there's method in the madness"—there are good reasons
    for not publishing this plugin, so let's take a moment to explore why it might
    not be a sensible move to release this plugin in its current format.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the dangers of publishing this plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the last few pages, we've created what should be a useful plugin to manipulate
    custom fonts—it automatically builds up the right font stack based on pre-defined
    settings, and will fill in the appropriate `@font-face` code for us. At this point
    we should have a plugin that can be released into the wild, for anyone to use…surely?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well yes, and no—even though this plugin serves a purpose, it is not one that
    I would recommend making available…at least not yet! There are a few reasons why,
    which also help to illustrate the benefits of using the boilerplate code we covered
    earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The plugin doesn't have a `test.js` file or configuration associated with it—one
    of the requirements for releasing plugins is that each be tested, using a `test.js`
    file. Ideally we might use a service such as Travis CI to help with this, but
    this really only works if you use a Unix-based environment for development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plugin itself performs two different roles, which is not recommended—best
    practice for PostCSS plugins is to try where possible to limit the role to one
    task only. The benefits of this can be seen when using a task runner—we can pick
    and choose which plugins to use, without introducing too much extra unwanted functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture of our code is not optimal—this is primarily due to the use
    of `css.WalkRules` (line 16), and `css.WalkAtRules` (line 28). These two commands
    parse each node within the container, and call the callback function for each
    rule node and at-rule node. The difference here is that `css.WalkRules` works
    on every rule; `css.WalkAtRules` will only work on `@-`rules (such as `@font-face`).
    They are not interchangeable, which makes it very inefficient at compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we don't use the plugin boilerplate, then most of the files required for
    publishing code will not be present—these either have to be created by hand, or
    created as part of submitting to GitHub. If we use the boilerplate, then this
    will be done for us automatically, along with configuring the `package.json` file
    for us—all we need to do is add a suitable task runner such as Gulp or Grunt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One might ask why we would even consider this route, if it is likely to throw
    up issues during development—the simple answer is that it helps us understand
    something of how plugins should be built. If we're building a plugin for personal
    use only, then there is no need for some of the files or processes that we have
    to use when releasing plugins for general use.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leaving aside the intended audience for our plugins, throughout our development
    process we've used a mix of different techniques, but with one thing in common—our
    plugins have very few dependencies! This is not to be sniffed at, as clearly any
    dependencies that change may have a resulting knock-on effect for our plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'This aside, there will be times when the lack of any dependencies may require
    more development effort than is sensible (or practical)—it is at this point where
    we may need to consider using additional plugins to handle some of the processing.
    A perfect example of this is to parse a font: statement so that we can work on
    the constituent elements; there are a few others that are worthy of note:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type of parser or helper | URL of plugin source | Purpose of plugin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Selector | [https://github.com/postcss/postcss-selector-parser](https://github.com/postcss/postcss-selector-parser)
    | Manages selector strings. |'
  prefs: []
  type: TYPE_TB
- en: '| Value | [https://github.com/TrySound/postcss-value-parser](https://github.com/TrySound/postcss-value-parser)
    | Transforms CSS values and `@-`rule parameters into a tree of nodes for easy
    traversal. |'
  prefs: []
  type: TYPE_TB
- en: '| Property | [https://github.com/jedmao/postcss-resolve-prop](https://github.com/jedmao/postcss-resolve-prop)
    | Resolves a rule''s property value—this is particularly useful if multiple values
    are specified for the same property. |'
  prefs: []
  type: TYPE_TB
- en: '| Font | [https://github.com/jedmao/parse-css-font](https://github.com/jedmao/parse-css-font)
    | Parses a `font` property, and returns values for each element, such as `font-size`,
    `family`, `style`, or `lineHeigh` `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| Dimension | [https://github.com/jedmao/parse-css-dimension](https://github.com/jedmao/parse-css-dimension)
    | Parses a CSS dimension such as `number`, `length`, or `percentage`, to return
    a JavaScript object. |'
  prefs: []
  type: TYPE_TB
- en: '| Sides | [https://github.com/jedmao/parse-css-sides](https://github.com/jedmao/parse-css-sides)
    | Parses an element''s side attributes (such as `margin`, `padding`, or `border`
    properties), and returns values for all four sides as strings. |'
  prefs: []
  type: TYPE_TB
- en: '| Font helpers | [https://github.com/jedmao/postcss-font-helpers](https://github.com/jedmao/postcss-font-helpers)
    | Used to manipulate font statements in CSS—it either returns individual elements
    or a combined font object, as required. |'
  prefs: []
  type: TYPE_TB
- en: '| Margin helpers | [https://github.com/jedmao/postcss-margin-helpers](https://github.com/jedmao/postcss-margin-helpers)
    | Used to manipulate margin values for any specified element. |'
  prefs: []
  type: TYPE_TB
- en: So, should we use them? It's not obligatory by any means, but they may help
    remove some of the effort required to create our plugin. If any are used, then
    it pays to keep a close note of any changes being made to the plugins, so that
    we can correct any issues that occur promptly; after all, no-one likes a plugin
    that isn't maintained properly by the developer!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on, a key part of plugin construction is consistency; the power
    of PostCSS allows any plugin to be created, so keeping a sense of uniformity is
    essential. To help with this, the developer of PostCSS has released a set of guidelines:
    let''s dive in and take a look at these in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for plugin building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key benefits of the PostCSS ecosystem is its flexibility—it allows
    any developer to create any plugin, or adapt existing ones, as long as the license
    allows for further development!
  prefs: []
  type: TYPE_NORMAL
- en: 'To help retain a sense of consistency, the developer has issued a series of
    mandatory guidelines, which should be followed where practical:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of your plugin should clearly indicate the purpose of that plugin—for
    example, if you built one to mimic the CSS4 `:hover` pseudo-class, then `postcss-hover`
    would be a good example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is better to create a plugin that does one thing well, and not one that tries
    to perform multiple tasks at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use the `postcss.plugin` method when creating plugins—you are then hooking
    into a common plugin API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where possible, try to use asynchronous methods—you should also set a `node.source`
    for each node, so that PostCSS can generate an accurate source map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use the console when displaying errors—some PostCSS runners do not allow
    console output. Use `result.warn` instead to manage errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any plugin created and published must be tested, with documented examples (where
    possible) and a change log in English.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are writing a plugin for Node, then the postcss-plugin keyword must feature
    in the `package.json` file—this is used for feedback about the PostCSS ecosystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More details on these guidelines are available at [https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md](https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In addition, it is likely that we will use a task runner of some description,
    such as Broccoli, Grunt, or Brunch, or as in our case, Gulp. To help retain that
    consistency, the developer has issued a series of guidelines that should be followed
    where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: If your plugin uses a `config` file, then it must always be written in JavaScript,
    and set to support functions in parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using runners, always set the to and from options, even if your runner
    doesn't handle writing to disk—this is to ensure that PostCSS generates accurate
    source maps and displays better syntax errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostCSS runners must only use the publicly available asynchronous API—runners
    should not rely on undocumented methods or properties that may be removed in a
    future release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't simply display the full JavaScript stack when handling `CssSyntaxError`
    messages—not every developer is familiar with JavaScript! Instead, make sure any
    errors are handled gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any warnings that appear from `result.warnings()` should be displayed by PostCSS
    runners; this can be facilitated by using the `postcss-logs-warnings` or `postcss-messages`
    plugins if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your plugin uses the source map option, then by default this will be generated
    as an inline map by PostCSS. Runners must provide an option to save the map to
    a separate file, if required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More details on these guidelines are available at [https://github.com/postcss/postcss/blob/master/docs/guidelines/runner.md](https://github.com/postcss/postcss/blob/master/docs/guidelines/runner.md).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The guidelines provided for plugins are mandatory, but in some cases can be
    seen as a start point—for example, a change log should always be maintained, but
    it is up to the developer as to whether this is a `HISTORY.md`, `CHANGELOG.md`,
    or a GitHub Releases document. The trick here is careful planning, and to keep
    it simple—focus on the basics first, before moving onto more complex projects.
    We can then get accustomed to what must be provided as a minimum for each plugin,
    before extending it to cover task runner use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s change tack at this point: one of the guidelines we''ve covered
    states that every plugin should be tested as part of normal practice; now is a
    perfect opportunity to explore what this means in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Making the plugin available for use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key part of creating any plugin is testing—once tested, we can then decide
    if we want to release it for general use on GitHub and Node's package manager
    directory. It's not obligatory, but if we have created something that could be
    useful to others, then it is only fair that we make it available!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few steps involved in the process—they can be split into three
    groups: testing the plugin, adding the final details (in GitHub), and submitting
    it for inclusion on the PostCSS plugin directory. We''ll be using the `postcss-transition-shortcut`
    plugin that we''ve just created, as a basis for releasing it for general use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already covered the requirements for testing our plugin, so let''s explore
    the remaining steps needed to make our plugin available for general use by developers.
    The first step is to publish our plugin to a suitable repository on GitHub. This
    process falls outside of the scope of this book, but in a nutshell, the process
    for making the plugin available is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add examples of code to the `README.md` file—this should show an example of
    a source file, and what we would expect to see when that file has been processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `CHANGELOG.md` file, add the initial version number for the plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the changes need to be committed to GitHub—my preferred choice is GitHub
    Desktop, available for Windows or Mac from [https://desktop.github.com/](https://desktop.github.com/).
    For Linux users, there are several options available at [https://git-scm.com/download/gui/linux](https://git-scm.com/download/gui/linux).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we now need to publish our plugin to Node's package directory,
    NPM. The process involves adding a new user to NPM, then publishing all files
    to NPM; the details are outlined in full at [https://docs.npmjs.com/getting-started/publishing-npm-packages](https://docs.npmjs.com/getting-started/publishing-npm-packages).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the plugin has been prepared, tested and published, all that remains is
    to fork PostCSS, add your plugin to the `Plugins` section in `README.md`, and
    send a `pull` request. We can then monitor the site's Twitter feed for updates
    about our plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested, then you may like to refer to *GitHub Essentials* by
    *Achilleas Pipinellis*, available at [https://www.packtpub.com/](https://www.packtpub.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other processors, plugins play a central role in PostCSS—we can pick
    and choose what functionality we want to use; if it doesn't exist, then we are
    free to create our own version. Throughout the course of this chapter, we've covered
    some key concepts around the use of plugins, so let's take a moment to review
    what we have learnt.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off with a quick introduction to the use of plugins, which was swiftly
    followed by exploring the architecture of a standard plugin that included a look
    at some of the key files that make up a standard plugin. We then moved on to take
    a look at some of the classes, modules, and methods available as part of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we began working through the construction of an example plugin, before
    constructing a suitable test process and correcting the errors generated from
    linting the code as part of the test. We then rounded off our plugin with a look
    in more detail, to understand some of the key concepts behind how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we then covered the construction of a second plugin, but this time
    explored the manual process, and examined why this is not a recommended practice.
    We took a look at some of the issues that can arise from this practice, and why
    using the plugin boilerplate makes development easier.
  prefs: []
  type: TYPE_NORMAL
- en: We then rounded out the chapter by exploring some of the helper plugins we can
    use to simplify development, along with the recommended guidelines for development,
    and the process for making the plugin available for other developers to use in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, onwards we go: so far, we''ve used a variety of plugins throughout the
    book. There are three particular groups of plugins that are particularly useful—they
    are for fallback support, implementing shortcuts to creating CSS, and plugin packs.
    We''ll cover all three (and more) in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
