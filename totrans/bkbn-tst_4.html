<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Test Spies</h1></div></div></div><p>As we begin looking at the more complicated parts of our Backbone.js application, the process of isolating dependencies and testable behaviors can become an increasingly daunting task. To provide a little help in these areas, we will introduce Sinon.JS, which is a powerful test mock, stub, and spy library, in this chapter.</p><p>Sinon.JS<a id="id280" class="indexterm"/> allows us to artificially isolate Backbone.js components and test specific behaviors without interacting with the rest of the application. We will kick off our discussion on Sinon.JS with the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identifying some of the test limitations typically found in Backbone.js applications and testing scenarios that can benefit from test fakes</li><li class="listitem" style="list-style-type: disc">Introducing the Sinon.JS test double and assertion library</li><li class="listitem" style="list-style-type: disc">Learning how to examine application behavior with test spies</li><li class="listitem" style="list-style-type: disc">Integrating the Sinon-Chai plugin into Chai for better test assertions</li><li class="listitem" style="list-style-type: disc">Testing Backbone.js application components with test spies and other Sinon.JS utilities</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Fake it 'til you make it</h1></div></div></div><p>Ideally, we would run insulated, fast, and consistent tests on all parts of a Backbone.js application without any modifications. In actuality, these goals encounter hurdles for at least some of the real code paths in a Backbone.js application.</p><p>We want to test Backbone.js components in <em>isolation</em>, but many components have dependencies on other parts of the application. We also want the tests to run <em>quickly</em>, but many parts of a Backbone.js application can slow things down, including the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Network communication, such as persisting a model state to a remote backend datastore or a third party API</li><li class="listitem" style="list-style-type: disc">Complex DOM manipulation with Backbone.js views and templates</li><li class="listitem" style="list-style-type: disc">Timed events and DOM animations, especially those that deliberately wait (such as a slow jQuery fade)</li></ul></div><p>Finally, many events and execution paths in a Backbone.js application are non-deterministic. For example, parallel network requests and user inputs can be received by the application in any order. To deal with these issues, we sometimes have to look beyond the actual program code and fake out some parts of the application during tests. For a deeper dive into some of the common testing limitations and motivations for faking, see <em>Planning, Cheating and Faking Your Way Through JavaScript Tests</em> by <em>Christian Johansen</em> (the creator of Sinon.JS) at <a class="ulink" href="http://msdn.microsoft.com/en-us/magazine/gg649850.aspx">http://msdn.microsoft.com/en-us/magazine/gg649850.aspx</a>.</p><p>The modern techniques used to observe and/or replace program behaviors are collectively dubbed<a id="id281" class="indexterm"/> <strong>test doubles</strong>. The test doubles that we use in this book include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Spies</strong>: A test spy<a id="id282" class="indexterm"/> wraps a method under test and records inputs and outputs for later use. However, it does not change any of the underlying method functionality, as a spy is merely an observer. Test spies are useful in situations where we want to check how and when a given function is called from other parts of the application.</li><li class="listitem" style="list-style-type: disc"><strong>Stubs</strong>: A test <a id="id283" class="indexterm"/>stub is a spy that additionally replaces the functionality of a method under test with a new behavior. Stubs are quite useful for test isolation. For example, when testing a single method that normally calls other functions, we can simply "stub out" the external function calls with a preprogrammed behavior. In this manner, tests can execute the specific code under test while faking out everything else.</li><li class="listitem" style="list-style-type: disc"><strong>Mocks</strong>: Mocks<a id="id284" class="indexterm"/> are a combination of spies and stubs (observing function calls and replacing function behavior) that additionally verify expected function behavior during execution.</li></ul></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>For a good survey on test doubles, including approaches beyond the three we identified, see <em>Exploring The Continuum Of Test Doubles</em> by <em>Mark Seeman</em> (<a class="ulink" href="http://msdn.microsoft.com/en-us/magazine/cc163358.aspx">http://msdn.microsoft.com/en-us/magazine/cc163358.aspx</a>) and <em>Test Double Patterns</em> web page by <em>Gerard Meszaros</em> (<a class="ulink" href="http://xunitpatterns.com/Test%20Double%20Patterns.html">http://xunitpatterns.com/Test%20Double%20Patterns.html</a>).</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Getting to know Sinon.JS</h1></div></div></div><p>Sinon.JS <a id="id285" class="indexterm"/>is a popular test double library that provides spies, stubs, mocks, fake servers, and various helpers. We will introduce two Sinon.JS interfaces in this chapter—spies and the sandboxed test helper—and discuss the rest in <a class="link" href="ch05.html" title="Chapter 5. Test Stubs and Mocks">Chapter 5</a>, <em>Test Stubs and Mocks</em>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Spying on functions with Sinon.JS</h2></div></div></div><p>Sinon.JS provides <a id="id286" class="indexterm"/>extensible test spies that can record many different aspects of a function execution, including calling parameters, return values, and thrown exceptions. The basic developer workflow is to create a spy, hook it into a function under test, execute the function, and then verify that the spy's recorded information matches with the test expectations. In this section, we will walk through the different ways to create spies and discuss some of the most useful parts of the Sinon.JS spy API.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Anonymous spies</h3></div></div></div><p>Spies can be created as<a id="id287" class="indexterm"/> anonymous standalone functions, which are often used to test event logic in Backbone.js applications. For example, we create a Backbone.js event object and an anonymous Sinon.JS spy in the following code. The spy listens to the <code class="literal">foo</code> event, which we trigger. Then, we can inspect the spy and assert that the spy was called once and passed <code class="literal">42</code> as a parameter:</p><div><pre class="programlisting">it("calls anonymous spy on event", function () {
  var eventer = _.extend({}, Backbone.Events),
    spy = sinon.spy();

  // Set up the spy.
  eventer.on("foo", spy);
  expect(spy.called).to.be.false;

  // Fire event.
  eventer.trigger("foo", 42);

  // Check number of calls.
  expect(spy.calledOnce).to.be.true;
  expect(spy.callCount).to.equal(1);

  // Check calling arguments.
  expect(spy.firstCall.args[0]).to.equal(42);
  expect(spy.calledWith(42)).to.be.true;
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Spy assertions</h3></div></div></div><p>Sinon.JS provides assertion helpers for <a id="id288" class="indexterm"/>many spy methods and properties with the <code class="literal">sinon.assert</code> object. In the previous example, we used Chai assertions to verify the spy's recorded information. But, we could have equivalently used Sinon.JS assertions as follows:</p><div><pre class="programlisting">it("verifies anonymous spy on event", function () {
  var eventer = _.extend({}, Backbone.Events),
    spy = sinon.spy();

  eventer.on("foo", spy);
  <strong>sinon.assert.notCalled</strong>(spy);

  eventer.trigger("foo", 42);
  <strong>sinon.assert.callCount</strong>(spy, 1);
  <strong>sinon.assert.calledWith</strong>(spy, 42);
});</pre></div><p>The <code class="literal">sinon.assert</code> <a id="id289" class="indexterm"/>helpers have an advantage over most equivalent Chai assertions for the reason that the failure messages are informative and specific. For example, a failing assertion for <code class="literal">sinon.assert.calledWith(spy, 42)</code> produces the error message <code class="literal">AssertError: expected spy to be called with arguments 42</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Function spies</h3></div></div></div><p>Sinon.JS spies can wrap existing <a id="id290" class="indexterm"/>functions as well. In the following example, we wrap the function <code class="literal">divide</code> with a spy, producing <code class="literal">divAndSpy</code>. Then, we can call <code class="literal">divAndSpy</code> in any manner that we could for <code class="literal">divide</code>. We can also inspect spy properties such as <code class="literal">calledWith()</code> in the wrapped spy:</p><div><pre class="programlisting">it("calls spy wrapper on function", function () {
  var divide = function (a, b) { return a / b; },
    divAndSpy = sinon.spy(divide);

  // Call wrapped function and verify result.
  expect(divAndSpy(4, 2)).to.equal(2);

  // Now, verify spy properties.
  sinon.assert.calledOnce(divAndSpy);
  sinon.assert.calledWith(divAndSpy, 4, 2);

  // Sinon.JS doesn't have assert for returned.
  expect(divAndSpy.returned(2)).to.be.true;
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Object method spies</h3></div></div></div><p>Finally, Sinon.JS spies can wrap <a id="id291" class="indexterm"/>methods in objects. This is a particularly powerful means of spying on one method within an overall class or Backbone.js component to gather information throughout the entire execution path. The wrapped object methods contain Sinon.JS spy properties, meaning that we do not have to separately track a spy variable.</p><p>Wrapped object methods remain spies until unwrapped with the <code class="literal">restore()</code> function<a id="id292" class="indexterm"/>, which removes the spy and reinstates the original function. As an example, let us consider the following object with two methods:</p><div><pre class="programlisting">var obj = {
  multiply: function (a, b) { return a * b; },
  error: function (msg) { throw new Error(msg); }
};</pre></div><p>We can spy on <code class="literal">multiply</code> to<a id="id293" class="indexterm"/> verify its call and return values, and spy on <code class="literal">error</code> to check that it throws an expected exception. In both cases, we call the wrapped object method directly (for example, <code class="literal">obj.multiply()</code>) and then access the method spies. Finally, we need to call <code class="literal">restore()</code> at the end of the test to unwrap the spies on <code class="literal">obj</code>:</p><div><pre class="programlisting">it("calls spy on wrapped object", function () {
  // Wrap members with `sinon` directly.
  sinon.spy(obj, "multiply");
  sinon.spy(obj, "error");

  expect(obj.multiply(5, 2)).to.equal(10);   sinon.assert.calledWith(obj.multiply, 5, 2);
  expect(obj.multiply.returned(10)).to.be.true;

  try {
    obj.error("Foo");
  } catch (e) {}
  sinon.assert.threw(obj.error, "Error");

  // Have to restore after tests finish.
  obj.multiply.restore();
  obj.error.restore();
});</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Playing in the sandbox with Sinon.JS test helpers</h2></div></div></div><p>One issue with the previous example <a id="id294" class="indexterm"/>spec is that if an assertion fails before <code class="literal">restore()</code> is called, the object methods are still wrapped in the spies. If any subsequent (and otherwise passing) test tries to wrap an already wrapped method, Sinon.JS will throw an error such as <code class="literal">TypeError: Attempted to wrap &lt;function name&gt; which is already wrapped</code>.</p><p>Thus, it is important to ensure that each spy eventually calls <code class="literal">restore()</code>, regardless of whether or not the underlying test has passed. One way of achieving this is with a <code class="literal">try</code>/<code class="literal">finally</code> block in the test. Another way is to create spies in a <code class="literal">before</code> function<a id="id295" class="indexterm"/> and call <code class="literal">restore()</code> on them in an <code class="literal">after</code> function<a id="id296" class="indexterm"/>. However, the easiest and the most flexible way is to perhaps use the<a id="id297" class="indexterm"/> <code class="literal">sinon.test</code> sandbox function.</p><p>Sinon.JS provides an execution environment dubbed as a<a id="id298" class="indexterm"/> <strong>sandbox</strong> that can be configured with spies, stubs, mocks, and other fake objects (for example, fake timers and AJAX requests). Conveniently, all faked properties and methods can be unwound with a single <code class="literal">restore()</code> call on the sandbox object.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>Reviewing the Sinon.JS<a id="id299" class="indexterm"/> sandbox documentation at <a class="ulink" href="http://sinonjs.org/docs/#sandbox">http://sinonjs.org/docs/#sandbox</a> is highly recommended. There are some subtle pitfalls and surprises related to how an application execution changes within a sandbox. For example, the default sandbox will fake time and the related functions such as<a id="id300" class="indexterm"/> <code class="literal">setTimeout</code>. It means that if your code waits for 10 milliseconds before execution, it will not run until the developer <em>manually</em> advances the time in the fake <code class="literal">clock</code> object.</p></div></div><p>The <code class="literal">sinon.test</code> wrapper function <a id="id301" class="indexterm"/>takes this one step further by creating a default sandbox, which is automatically restored after the wrapped code finishes its execution. Repeating our previous object method example with <code class="literal">sinon.test</code> yields a more elegant version of the spec, in which we don't manually call <code class="literal">restore()</code> on the spies and still guarantee that the wrapped object methods are restored:</p><div><pre class="programlisting">it("calls spy with test helper", <strong>sinon.test</strong>(function () {
  <strong>// Wrap members using context (`this`) helper.</strong>
  <strong>this.spy(obj, "multiply");</strong>
  <strong>this.spy(obj, "error");</strong>

  expect(obj.multiply(5, 2)).to.equal(10);
  sinon.assert.calledWith(obj.multiply, 5, 2);
  expect(obj.multiply.returned(10)).to.be.true;

  try {
    obj.error("Foo");
  } catch (e) {}
  sinon.assert.threw(obj.error, "Error");

  <strong>// No restore is necessary.</strong>
}));</pre></div><p>While the <code class="literal">sinon.test</code> helper is a handy tool for managing Sinon.JS objects, it is not always an appropriate choice for every spec. For example, asynchronous Mocha tests are tricky because <code class="literal">sinon.test</code> can potentially restore the entire sandbox before the <code class="literal">done()</code> parameter is later called in the test code. Additionally, a side effect of using <code class="literal">sinon.test</code> is that the Mocha test reporter will no longer show the test code when clicking on a spec description in the test driver web page. The reason for this makes sense—<code class="literal">sinon.test</code> wraps the actual test <a id="id302" class="indexterm"/>function, so <code class="literal">sinon.test</code> is all that the Mocha reporter sees. It is ultimately a matter of developer intuition and experience as to when to use the <code class="literal">sinon.test</code> shortcut. In this book we use the wrapper for a subset of our synchronous Sinon.JS-based specs.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Delving into the Sinon.JS spy API</h2></div></div></div><p>Sinon.JS spies provide a<a id="id303" class="indexterm"/> fairly comprehensive set of properties and methods for inspecting execution information (see <a class="ulink" href="http://sinonjs.org/docs/#spies">http://sinonjs.org/docs/#spies</a> for a complete list). Spies can be inspected <em>generally</em> to see if an argument or return value was ever encountered during execution or <em>specifically</em> to check information for a single function call.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>The spy API</h3></div></div></div><p>A<a id="id304" class="indexterm"/>n introductory set of useful spy methods and properties includes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">spy.callCount(num)</code>: This returns<a id="id305" class="indexterm"/> the number of times the spied function was called. This is available as an assertion with <code class="literal">sinon.assert.callCount(spy, num)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">spy.called</code>: This is <code class="literal">true</code> if the function<a id="id306" class="indexterm"/> was called one or more times. Sinon.JS also provides properties to verify a few specific call counts, for example, <code class="literal">spy.calledOnce</code>. Assertion versions include <code class="literal">sinon.assert.called(spy)</code>, <code class="literal">sinon.assert.notCalled(spy)</code>, and <code class="literal">sinon.assert.calledOnce(spy)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">spy.calledWith*</code>/<code class="literal">spy.notCalledWith*</code>: Sinon.JS <a id="id307" class="indexterm"/>provides methods that<a id="id308" class="indexterm"/> can verify if a spy was sometimes/always called with expected parameters. For example, <code class="literal">spy.calledWithExactly(arg1, arg2)</code> checks whether the function was called one or more times with <code class="literal">arg1</code> and <code class="literal">arg2</code>. By contrast, <code class="literal">spy.alwaysCalledWith(arg1)</code> checks whether every function call had a first argument <code class="literal">arg1</code> and any number of additional arguments.</li><li class="listitem" style="list-style-type: disc"><code class="literal">spy.returned(obj)</code>/<code class="literal">spy.alwaysReturned(obj)</code>: This returns <code class="literal">true</code> if <code class="literal">obj</code> was returned <a id="id309" class="indexterm"/>by the function one or more times/on<a id="id310" class="indexterm"/> every call.</li></ul></div><p>Sinon.js spies also record thrown exceptions, which can be inspected with the following methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">spy.threw()</code>: This returns<a id="id311" class="indexterm"/> <code class="literal">true</code> if the function threw an exception one or more times. The <code class="literal">spy.alwaysThrew()</code> alternative returns <code class="literal">true</code> if the exception was thrown every time. Both can take optional arguments of the type string (for example, <code class="literal">"Error"</code>) or an<a id="id312" class="indexterm"/> actual error object to additionally require a type match for the exception. Assertion versions are <code class="literal">sinon.assert.threw(spy)</code> and <code class="literal">sinon.assert.alwaysThrew(spy)</code> respectively.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>The spy call API</h3></div></div></div><p>Each time a spied <a id="id313" class="indexterm"/>function is called, Sinon.JS stores a <strong>call object</strong> with relevant information in an internal array. Call objects are useful in situations where a spied function is executed many times, but only one specific call needs to be inspected.</p><p>Call objects can be accessed from a spy in various ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">spy.getCall(n)</code>: Retrieves<a id="id314" class="indexterm"/> the <em>n</em>th call object of the spy from a zero-indexed array. For example, <code class="literal">spy.getCall(1)</code> retrieves the call object from the second time the spied function was called.</li><li class="listitem" style="list-style-type: disc"><code class="literal">spy.firstCall</code>, <code class="literal">spy.secondCall</code>, <code class="literal">spy.thirdCall</code>, and <code class="literal">spy.lastCall</code>: These are <a id="id315" class="indexterm"/>helper<a id="id316" class="indexterm"/> properties<a id="id317" class="indexterm"/> that <a id="id318" class="indexterm"/>access commonly used call objects.</li></ul></div><p>Call objects provide methods and properties for the particular function call they wrap:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">spyCall.calledOn(obj)</code>: This <a id="id319" class="indexterm"/>returns <code class="literal">true</code> if <code class="literal">obj</code> was the context (<code class="literal">this</code>) variable for the call. The <code class="literal">this</code> variable's value is also available directly from the property <code class="literal">spyCall.thisValue</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">spyCall.calledWith*</code>/<code class="literal">spyCall.notCalledWith*</code>: These are spy call methods that verify if a <em>single</em> call <a id="id320" class="indexterm"/>was/was not made with specific <a id="id321" class="indexterm"/>arguments. It parallels the spy API methods, which instead check <em>all</em> the function calls and not just one. The call object also provides the specific arguments the function was called with, in the property <code class="literal">spyCall.args</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">spyCall.returnValue</code>: This is <a id="id322" class="indexterm"/>the property containing the return value for the function call.</li><li class="listitem" style="list-style-type: disc"><code class="literal">spyCall.threw()</code>: This <a id="id323" class="indexterm"/>returns <code class="literal">true</code> if the function call threw an exception. The exception object itself is available as <code class="literal">spyCall.exception</code>.</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Spicing up Chai with the Sinon.JS plugin</h1></div></div></div><p>One of the primary motivations for using the Chai library is the natural language syntax of its chained assertions. Another strong point of Chai is that it produces clear error messages on assertion failures.</p><p>Unfortunately, Sinon.JS spies create some assertion challenges within our test framework. To illustrate the issue, let's focus on the previous example that asserts that the <code class="literal">obj.multiply()</code> method (wrapped in a spy) was called with the parameters <code class="literal">5</code> and <code class="literal">2</code>.</p><p>At this point, we have encountered two ways of making assertions on Sinon.JS spies—with Chai assertions and with Sinon.JS built-in spy assertions. Starting with the first method, we can write a Chai assertion on the spy as follows:</p><div><pre class="programlisting">expect(obj.multiply.calledWith(5, 2)).to.be.true;</pre></div><p>However, a drawback of this statement is that if the assertion fails, Chai will produce the unhelpful error message <code class="literal">expected false to be true</code>.</p><p>We can get a much better error message, <code class="literal">AssertError: expected multiply to be called with arguments 5, 2</code>, if we use the Sinon.JS assert version:</p><div><pre class="programlisting">sinon.assert.calledWith(obj.multiply, 5, 2);</pre></div><p>But we then lose the naturally readable Chai dot-notation syntax.</p><p>What we really want is a code that fails with an error message resembling <code class="literal">expected multiply to have been called with arguments 5, 2</code> and an assertion that reads as follows:</p><div><pre class="programlisting">expect(obj.multiply).to.be.calledWith(5, 2);</pre></div><p>Fortunately, we <em>can</em> get the best of both the worlds—readable Chai assertions with informative library-specific failure messages—by using Chai's plugin capabilities.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Introducing and installing Chai plugins</h2></div></div></div><p>Chai supports plugins (<a class="ulink" href="http://chaijs.com/plugins">http://chaijs.com/plugins</a>) that modify and extend the Chai assertion API with <a id="id324" class="indexterm"/>contextually useful changes and failure messages. In this section, we will introduce and install the Sinon.JS adapter for Chai, giving us much more concise and <a id="id325" class="indexterm"/>ultimately useful assertions for our<a id="id326" class="indexterm"/> test doubles.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>The use of the Sinon.JS adapter is recommended but entirely optional. Although we will use the plugin in many examples throughout the rest of the book, all of our test assertions could be rewritten in equivalent statements using native Chai.</p></div></div><p>The <strong>Sinon-Chai</strong> plugin<a id="id327" class="indexterm"/> (<a class="ulink" href="http://chaijs.com/plugins/sinon-chai">http://chaijs.com/plugins/sinon-chai</a>) can be downloaded from GitHub at <a class="ulink" href="https://raw.github.com/domenic/sinon-chai/2.4.0/lib/sinon-chai.js">https://raw.github.com/domenic/sinon-chai/2.4.0/lib/sinon-chai.js</a>. At present we are using version 2.4.0. The file should be placed in the same directory (<code class="literal">test/js/lib/</code>) as our other test libraries and included along with the other libraries in the test driver web page:</p><div><pre class="programlisting">&lt;!-- JavaScript Test Libraries. --&gt;
&lt;script src="img/mocha.js"&gt;&lt;/script&gt;
&lt;script src="img/chai.js"&gt;&lt;/script&gt;
<strong>&lt;script src="img/sinon-chai.js"&gt;&lt;/script&gt;</strong>
&lt;script src="img/sinon.js"&gt;&lt;/script&gt;</pre></div><p>Sinon-Chai must be included <em>after</em> Chai and can be included before or after the Sinon.JS library. With this extra include, we are ready to start writing more readable and informative Chai assertions.</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>Other Chai plugins that may also be useful for Backbone.js application tests include the adapters for Backbone.js (<a class="ulink" href="http://chaijs.com/plugins/chai-backbone">http://chaijs.com/plugins/chai-backbone</a>) and jQuery (<a class="ulink" href="http://chaijs.com/plugins/chai-jquery">http://chaijs.com/plugins/chai-jquery</a>). The Backbone.js plugin adds assertions for Backbone.js-specific constructs such as <code class="literal">trigger</code> (for events) and <code class="literal">routes.to</code> (for routing). The jQuery plugin proxies various jQuery functions into Chai assertions, enabling statements such as <code class="literal">expect($text).to.have.html("&lt;em&gt;Edit your note!&lt;/em&gt;")</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>The Sinon.JS plugin</h2></div></div></div><p>The Sinon-Chai plugin<a id="id328" class="indexterm"/> extends Chai with several spy-related assertions, including<a id="id329" class="indexterm"/> the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Call occurrences</strong>: <code class="literal">expect(spy).to.have.been.called</code>, <code class="literal">expect(spy).to.have.been.calledOnce</code>, <code class="literal">expect(spy).to.have.been.calledTwice</code>, and <code class="literal">expect(spy).to.have.been.calledThrice</code></li><li class="listitem" style="list-style-type: disc"><strong>Call order</strong>: <code class="literal">expect(spy1).to.have.been.calledAfter(spy2)</code> and <code class="literal">expect(spy1).to.have.been.calledBefore(spy2)</code></li><li class="listitem" style="list-style-type: disc"><strong>Call arguments</strong>: <code class="literal">expect(spy).to.have.been.calledWithNew</code>, <code class="literal">expect(spy).to.have.been.calledOn(context)</code>, <code class="literal">expect(spy).to.have.been.calledWith(arg1, arg2, ...)</code>, <code class="literal">expect(spy).to.have.been.calledWithExactly(arg1, arg2, ...)</code>, and <code class="literal">expect(spy).to.have.been.calledWithMatch(arg1, arg2, ...)</code></li><li class="listitem" style="list-style-type: disc"><strong>Return values</strong>: <code class="literal">expect(spy).to.have.returned(returnVal)</code></li><li class="listitem" style="list-style-type: disc"><strong>Errors</strong>: <code class="literal">expect(spy).to.have.thrown()</code></li></ul></div><p>The plugin also adds a new assertion flag:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">always</code>: It signals<a id="id330" class="indexterm"/> that the spied function must pass the assertion for <em>every</em> function call and not just one or more function call. For example, we can convert any of the following assertions that check <em>any</em> function call into ones that check <em>every</em> call:<div><pre class="programlisting">expect(spy).to.<strong>always</strong>.have.been.calledWith(arg1, arg2, ...);
expect(spy).to.have.<strong>always</strong>.returned(returnVal);
expect(spy).to.have.<strong>always</strong>.thrown();</pre></div></li></ul></div><p>Now, we can rewrite one of our earlier test examples with Sinon-Chai assertions to read as follows:</p><div><pre class="programlisting">it("calls spy with chai plugin", sinon.test(function () {
  this.spy(obj, "multiply");
  this.spy(obj, "error");

  expect(obj.multiply(5, 2)).to.equal(10);
  <strong>expect(obj.multiply).to.have.been.calledWith(5, 2);</strong>
  <strong>expect(obj.multiply).to.have.returned(10);</strong>

  try { obj.error("Foo"); } catch (e) {}
  <strong>expect(obj.error).to.have.thrown("Error");</strong>
}));</pre></div><p>Any spy assertion failures in the previous refactored test will produce informative messages such as <code class="literal">expected multiply to have been called with arguments 5, 2</code>. Thus, the Sinon-Chai plugin allows us to keep the spy assertions in Chai's chained dot-notation format while also producing helpful failure messages.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Testing Backbone.js components with spies</h1></div></div></div><p>With our Sinon.JS <a id="id331" class="indexterm"/>spies and other utilities ready, we <a id="id332" class="indexterm"/>will begin spying on our Backbone.js application. In this section, we will introduce and test two Notes application views—the menu bar view and the single note view.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>
<strong>Working through the examples</strong>
</p><p>Reiterating a point from the previous chapter, we will present the menu bar view and single note view implementations with the code <em>first</em> and the tests <em>second</em>, to help maintain a narrative structure that properly introduces the Notes application (and to keep things brief). This is not the preferred order for actual test development.</p><p>Accordingly, while working through this chapter, we suggest that you put this book down for a moment after reading the described behavior of each component. See if you can design and implement your own tests for the sample application components. After this exercise, you can continue reading and compare your tests with the component test suites in this chapter.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>The Notes menu bar view</h2></div></div></div><p>The <a id="id333" class="indexterm"/>Notes menu bar view, <code class="literal">App.Views.NoteNav</code>, controls the <strong>Edit</strong>, <strong>View</strong>, and <strong>Delete</strong> menu bar buttons for a single note. The following screenshot illustrates the menu bar with an active <strong>View</strong> button.</p><div><img src="img/5248OS_04_01.jpg" alt="The Notes menu bar view"/><div><p>Single page menu bar view</p></div></div><p>The <code class="literal">App.Views.NoteNav</code> view<a id="id334" class="indexterm"/> coordinates incoming/outgoing events for the view, edit, and delete menu actions. For example, if the <strong>Edit</strong> button was clicked on in the previous figure, the <code class="literal">App.Views.NoteNav</code> view would emit the following custom Backbone.js events:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">nav:update:edit</code>: This causes the active HTML menu bar item to switch to a new selected action, for example, changing from <strong>View</strong> to <strong>Edit</strong>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nav:edit</code>: This is emitted to signal other Backbone.js components that the operative action (for example, view or edit) has changed. For example, the <code class="literal">App.Views.Note</code> view listens on this event and displays HTML for the appropriate corresponding action pane in its view area.</li></ul></div><p>The menu bar view is attached to the DOM list <code class="literal">#note-nav</code>, which is provided by the <code class="literal">notes/app/index.html</code> application page. The HTML for <code class="literal">#note-nav</code> can be abbreviated to the following essential parts:</p><div><pre class="programlisting">&lt;ul id="note-nav"
  class="nav region region-note"
  style="display: none;"&gt;
  &lt;li class="note-view active"&gt;View&lt;/li&gt;
  &lt;li class="note-edit"&gt;Edit&lt;/li&gt;
  &lt;li class="note-delete"&gt;Delete&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>The menu bar list <a id="id335" class="indexterm"/>is hidden by default (but shown by <code class="literal">App.Views.Note</code>). After instantiation, the <code class="literal">App.Views.NoteNav</code> view sets up various listeners and activates the proper menu bar item.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>The menu bar view</h3></div></div></div><p>Now that we <a id="id336" class="indexterm"/>have reviewed<a id="id337" class="indexterm"/> the display setup and overall functionality of the view, we can dive into the application code at <code class="literal">notes/app/js/app/views/note-nav.js</code>:</p><div><pre class="programlisting">App.Views.NoteNav = Backbone.View.extend({

  el: "#note-nav",</pre></div><p>After specifying a default <code class="literal">el</code> element to attach the view to, the view binds the user menu bar clicks to the appropriate actions (for example, edit) in <code class="literal">events</code> and sets listeners in <code class="literal">initialize</code> to update the menu bar on occurrence of external events:</p><div><pre class="programlisting">  events: {
    "click .note-view":   "clickView",
    "click .note-edit":   "clickEdit",
    "click .note-delete": "clickDelete",
  },

  initialize: function () {
    // Defaults for nav.
    this.$("li").removeClass("active");

    // Update the navbar UI for view/edit (not delete).
    this.on({
      "nav:update:view": this.updateView,
      "nav:update:edit": this.updateEdit
    });
  },</pre></div><p>The functions <code class="literal">updateView</code> and <code class="literal">updateEdit</code> switch the <code class="literal">active</code> CSS class, which visually changes the highlighted tab in the menu bar:</p><div><pre class="programlisting">  updateView: function () {
    this.$("li").not(".note-view").removeClass("active");
    this.$(".note-view").addClass("active");
  },
  updateEdit: function () {
    this.$("li").not(".note-edit").removeClass("active");
    this.$(".note-edit").addClass("active");
  },</pre></div><p>The <code class="literal">clickView</code>, <code class="literal">clickEdit</code>, and <code class="literal">clickDelete</code> functions emit the view events <a id="id338" class="indexterm"/>corresponding to the <a id="id339" class="indexterm"/>menu bar actions:</p><div><pre class="programlisting">  clickView: function () {
    this.trigger("nav:update:view nav:view");
    return false;
  },
  clickEdit: function () {
    this.trigger("nav:update:edit nav:edit");
    return false;
  },
  clickDelete: function () {
    this.trigger("nav:update:delete nav:delete");
    return false;
  }
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Testing and spying on the menu bar view</h3></div></div></div><p>The <code class="literal">App.Views.NoteNav</code> view<a id="id340" class="indexterm"/> is fairly small and essentially just <a id="id341" class="indexterm"/>proxies <a id="id342" class="indexterm"/>events and <a id="id343" class="indexterm"/>updates the menu bar UI. Our testing goals are similarly modest:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Verify that <code class="literal">App.Views.NoteNav</code> is bound to the DOM correctly, either by defaulting to <code class="literal">#note-nav</code> or via a passed <code class="literal">el</code> parameter</li><li class="listitem" style="list-style-type: disc">Check that the menu bar action events are triggered and listened to correctly</li><li class="listitem" style="list-style-type: disc">Ensure that the menu bar HTML is modified in response to appropriate actions</li></ul></div><p>With these guidelines<a id="id344" class="indexterm"/> in mind, let's step through <code class="literal">chapters/04/test/js/spec/views/note-nav.spec.js</code>, which is the suite for the menu bar view.</p><p>The suite starts out by<a id="id345" class="indexterm"/> setting up a test fixture and a view. The <code class="literal">before()</code> call creates the minimum HTML that we will need to produce a menu bar list suitable for testing the view. The <code class="literal">beforeEach()</code> function attaches <code class="literal">this.$fixture</code> to the <code class="literal">#fixtures</code> container already in the DOM and creates a new <code class="literal">App.Views.NoteNav</code> object. The <code class="literal">afterEach()</code> call removes the<a id="id346" class="indexterm"/> view <a id="id347" class="indexterm"/>and <code class="literal">after()</code> empties out the <code class="literal">#fixtures</code> container completely:</p><div><pre class="programlisting">describe("App.Views.NoteNav", function () {
  before(function () {
    this.$fixture = $(
      "&lt;ul id='note-nav'&gt;" +
        "&lt;li class='note-view'&gt;&lt;/li&gt;" +
        "&lt;li class='note-edit'&gt;&lt;/li&gt;" +
        "&lt;li class='note-delete'&gt;&lt;/li&gt;" +
      "&lt;/ul&gt;"
    );
  });

  beforeEach(function () {
    this.$fixture.appendTo($("#fixtures"));
    this.view = new App.Views.NoteNav({
      el: this.$fixture
    });
  });

  afterEach(function () {
    this.view.remove();
  });

  after(function () {
    $("#fixtures").empty();
  });</pre></div><p>The first nested suite, <code class="literal">events</code>, contains one spec that verifies if a click on a menu bar item fires the appropriate <code class="literal">nav:*</code> and <code class="literal">nav:update:*</code> events. We create three Sinon.JS spies to help us with this task:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">navSpy</code> and <code class="literal">updateSpy</code>: These objects spy on the events <code class="literal">nav:view</code> and <code class="literal">nav:update:view</code> and should be called when the <strong>View</strong> menu bar item is clicked on</li><li class="listitem" style="list-style-type: disc"><code class="literal">otherSpy</code>: This spy listens on all other potential action events and is used to check whether the other events did <em>not</em> fire</li></ul></div><p>We use the Sinon-Chai adapter extensions to make our spy assertions:</p><div><pre class="programlisting">  describe("events", function () {
    it("fires events on 'view' click", function () {
      var navSpy = sinon.spy(),
        updateSpy = sinon.spy(),
        otherSpy = sinon.spy();

      this.view.on({
        "nav:view": navSpy,
        "nav:update:view": updateSpy,
        "nav:edit nav:update:edit": otherSpy,
        "nav:delete nav:update:delete": otherSpy
      });

      this.$fixture.find(".note-view").click();

      expect(navSpy).to.have.been.calledOnce;
      expect(updateSpy).to.have.been.calledOnce;
      expect(otherSpy).to.not.have.been.called;
    });
  });</pre></div><p>The specs <a id="id348" class="indexterm"/>in the <code class="literal">menu bar display</code> suite inspect DOM content and page<a id="id349" class="indexterm"/> interactions with the <a id="id350" class="indexterm"/>view. The <a id="id351" class="indexterm"/>first spec, <code class="literal">has no active navs by default</code>, checks that the menu bar HTML has no active selection by default—which, for a Bootstrap-based navigation bar, means the absence of the <code class="literal">active</code> CSS class:</p><div><pre class="programlisting">  describe("menu bar display", function () {
    it("has no active navs by default", function () {
      // Check no list items are active.
      expect(this.view.$("li.active")).to.have.length(0);

      // Another way - manually check each list nav.
      expect($(".note-view")
        .attr("class")).to.not.include("active");
      expect($(".note-edit")
        .attr("class")).to.not.include("active");
      expect($(".note-delete")
        .attr("class")).to.not.include("active");
    });</pre></div><p>Then, the remaining specs check whether clicking on the <strong>Edit</strong> menu bar tab or firing a direct <code class="literal">nav:update:edit</code> event causes the corresponding menu bar item to be activated (via insertion of the CSS class <code class="literal">active</code>):</p><div><pre class="programlisting">    it("updates nav on 'edit' click", function () {
      $(".note-edit").click();
      expect($(".note-edit").attr("class")).to.include("active");
    });

    it("updates nav on 'edit' event", function () {
      this.view.trigger("nav:update:edit");
      expect($(".note-edit").attr("class")).to.include("active");
    });
  });
});</pre></div><p>With the <a id="id352" class="indexterm"/>previous tests, we can verify that <code class="literal">App.Views.NoteNav</code> fires <a id="id353" class="indexterm"/>appropriate events <a id="id354" class="indexterm"/>and<a id="id355" class="indexterm"/> its HTML responds to user clicks and external events.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>The Notes single note view</h2></div></div></div><p>The <code class="literal">App.Views.Note</code> view controls <a id="id356" class="indexterm"/>everything that we have encountered so far with respect to a single note. Each <code class="literal">App.Views.Note</code> object instantiates a new <code class="literal">App.Views.NoteView</code> object and refers to an external <code class="literal">App.Views.NoteNav</code> object.</p><p>The main responsibilities of the class, which we will want to verify in the tests, include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Update the appropriate viewing pane mode (for example, edit or view) in response to menu bar action events</li><li class="listitem" style="list-style-type: disc">Delete a single note model, and then clean up views and route back to the all notes list view</li><li class="listitem" style="list-style-type: disc">Require user confirmation before deleting a note</li><li class="listitem" style="list-style-type: disc">Save note model data into the backend storage in response to edit form field changes</li><li class="listitem" style="list-style-type: disc">Update the HTML display panes in response to model data changes</li></ul></div><p>We will first look at the HTML template string used by the view. It is found in our application template file, <code class="literal">notes/app/js/app/templates/templates.js</code>:</p><div><pre class="programlisting">App.Templates["template-note"] =
  "&lt;div id=\"<strong>note-pane-view</strong>\" class=\"pane\"&gt;" +
  "  &lt;div id=\"note-pane-view-content\"&gt;&lt;/div&gt;" +
  "&lt;/div&gt;" +
  "&lt;div id=\"<strong>note-pane-edit</strong>\" class=\"pane\"&gt;" +
  "  &lt;form id=\"note-form-edit\"&gt;" +
  "    &lt;input id=\"input-title\" class=\"input-block-level\"" +
  "           type=\"text\" placeholder=\"title\"" +
  "           value=\"<strong>&lt;%= title %&gt;</strong>\"&gt;" +
  "    &lt;textarea id=\"input-text\" class=\"input-block-level\"" +
  "              rows=\"15\"&gt;<strong>&lt;%= text %&gt;</strong>&lt;/textarea&gt;" +
  "  &lt;/form&gt;" +
  "&lt;/div&gt;";</pre></div><p>The template <a id="id357" class="indexterm"/>provides two <code class="literal">div</code> UI panes for action modes—<code class="literal">note-pane-view</code> for <em>viewing</em> a note and <code class="literal">note-pane-edit</code> for <em>editing</em> data. It also binds two template variables—<code class="literal">title</code> and <code class="literal">text</code>—to the editing inputs in the <code class="literal">note-form-edit</code> form.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>The single note view</h3></div></div></div><p>Getting into the<a id="id358" class="indexterm"/> application code at <code class="literal">notes/app/js/app/views/note-nav.js</code>, we start by declaring the DOM identifier and template and then set up two events—the first one saves note data on occurrence of the browser's <code class="literal">blur</code> event, and the second one prevents the editing form from doing a real HTTP page submission:</p><div><pre class="programlisting">App.Views.Note = Backbone.View.extend({

  id: "note-panes",

  template: _.template(App.Templates["template-note"]),

  events: {
    "blur   #note-form-edit": "saveNote",
    "submit #note-form-edit": function () { return false; }
  },</pre></div><p>The <code class="literal">initialize</code> function does most of the heavy lifting for the view. First, it sets <code class="literal">this.nav</code> from the parameter options and <code class="literal">this.router</code> from either options or from the external <code class="literal">app</code> application object.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>The reason we optionally take a router object from the <code class="literal">opts</code> parameter is that it makes it easier to override Backbone.js dependencies. In our tests, we will use <code class="literal">opts</code> to pass a Sinon.JS spy instead of a real router that records behavior but doesn't actually route. A different approach to this scenario (introduced in the next chapter) is to stub or mock <code class="literal">app.router</code> directly.</p></div></div><p>Then, the view <a id="id359" class="indexterm"/>sets up event listeners on various objects by calling the <a id="id360" class="indexterm"/>helper function <code class="literal">_addListeners</code>. Finally, the view object renders its Underscore.js template to HTML with model data, sets the action state, and instantiates a child <code class="literal">App.Views.NoteView</code> object to handle Markdown rendering:</p><div><pre class="programlisting">initialize: function (attrs, opts) {
    opts || (opts = {});
    this.nav = opts.nav;
    this.router = opts.router || app.router;

    // Add our custom listeners.
    this._addListeners();

    // Render HTML, update to action, and show note.
    this.$el.html(this.template(this.model.toJSON()));
    this.update(opts.action || "view");
    this.render();

    // Add in viewer child view (which auto-renders).
    this.noteView = new App.Views.NoteView({
      el: this.$("#note-pane-view-content"),
      model: this.model
    });
  },</pre></div><p>As a part of initialization, the <code class="literal">_addListeners</code> helper binds object events as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Model</strong> (<code class="literal">this.model</code>): The view removes itself when the model is destroyed. It re-renders and saves the model to the backend when the model data changes.</li><li class="listitem" style="list-style-type: disc"><strong>Menu bar view</strong> (<code class="literal">this.nav</code>): The note view listens to the menu bar nav events and calls specific action functions such as <code class="literal">viewNote()</code> when a user clicks on <strong>View</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Note view</strong> (<code class="literal">this</code>): The note view also directly listens for action state (viewing or editing) events from external Backbone.js components. For instance, the application router uses these events to activate an existing <code class="literal">App.Views.Note</code> view object and set an appropriate action state.</li></ul></div><p>Translating this <a id="id361" class="indexterm"/>into code<a id="id362" class="indexterm"/> produces the following function:</p><div><pre class="programlisting">  _addListeners: function () {
    // Model controls view rendering and existence.
    this.listenTo(this.model, {
      "destroy": function () { this.remove(); },
      "change":  function () { this.render().model.save(); }
    });

    // Navbar controls/responds to panes.
    this.listenTo(this.nav, {
      "nav:view":   function () { this.viewNote(); },
      "nav:edit":   function () { this.editNote(); },
      "nav:delete": function () { this.deleteNote(); }
    });

    // Respond to update events from router.
    this.on({
      "update:view": function () { this.render().viewNote(); },
      "update:edit": function () { this.render().editNote(); }
    });
  },</pre></div><p>The <code class="literal">render()</code> function displays the HTML for the single note view and hides any HTML content used by other views:</p><div><pre class="programlisting">  // Rendering the note is simply showing the active pane.
  // All HTML should already be rendered during initialize.
  render: function () {
    $(".region").not(".region-note").hide();
    $(".region-note").show();
    return this;
  },</pre></div><p>The <code class="literal">remove()</code> method first removes the contained <code class="literal">App.Views.NoteView</code> object and then the <code class="literal">App.Views.Note</code> object itself:</p><div><pre class="programlisting">  remove: function () {
    // Remove child, then self.
    this.noteView.remove();
    Backbone.View.prototype.remove.call(this);
  },</pre></div><p>The <code class="literal">update()</code> method takes an<a id="id363" class="indexterm"/> action string parameter (<code class="literal">"view"</code> or <code class="literal">"edit"</code>), then triggers the menu bar view to update to the new state, shows the appropriate HTML action pane, and updates the URL hash fragment:</p><div><pre class="programlisting">  update: function (action) {
    action = action || this.action || "view";
    var paneEl = "#note-pane-" + action,
      loc = "note/" + this.model.id + "/" + action;

    // Ensure menu bar is updated.
    this.nav.trigger("nav:update:" + action);

    // Show active pane.
    this.$(".pane").not(paneEl).hide();
    this.$(paneEl).show();

    // Store new action and navigate.
    if (this.action !== action) {
      this.action = action;
      this.router.navigate(loc, { replace: true });
    }
  },</pre></div><p>The next three<a id="id364" class="indexterm"/> methods—<code class="literal">viewNote()</code>, <code class="literal">editNote()</code>, and <code class="literal">deleteNote()</code>—handle the basic actions for a single note. The first two methods simply call <code class="literal">update()</code> with the appropriate action, while <code class="literal">deleteNote()</code> destroys the note model and routes back to the all notes list (that is, the application home page):</p><div><pre class="programlisting">  viewNote: function () {
    this.update("view");
  },
  editNote: function () {
    this.update("edit");
  },
  deleteNote: function () {
    if (confirm("Delete note?")) {
      this.model.destroy();
      this.router.navigate("", { trigger: true, replace: true });
    }
  },</pre></div><p>Finally, <code class="literal">saveNote()</code> takes the edit form input and updates the underlying note model:</p><div><pre class="programlisting">  saveNote: function () {
    this.model.set({
      title: this.$("#input-title").val().trim(),
      text: this.$("#input-text").val().trim()
    });
  }
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Testing the single note view</h3></div></div></div><p>Our tests for <code class="literal">App.Views.Note</code> center around the various responsibilities of the class we discussed while introducing the view. Specifically, we want to verify that the note view can update UI <a id="id365" class="indexterm"/>elements for actions (for example, view and edit), delete<a id="id366" class="indexterm"/> notes, save model data, and correctly bind events across various other Backbone.js application components.</p><p>Walking through <code class="literal">chapters/04/test/js/spec/views/note.spec.js</code>, the single note test suite, we start by creating an initial test state. In the suite-wide <code class="literal">before()</code> function, we add fixture elements for regions (of which <code class="literal">App.Views.Note</code> uses region-note), an HTML fixture for the view itself, and then stub the note model prototype's <code class="literal">save()</code> method.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>While Sinon.JS stubs are not fully introduced in this chapter, we use one here to record calls to <code class="literal">save()</code> like a spy and also to prevent the method from trying to save to a remote backend, which would throw an error in this test context.</p></div></div><div><pre class="programlisting">describe("App.Views.Note", function () {

  before(function () {
    // Regions for different views.
    $("#fixtures").append($(
      "&lt;div class='region-note' style='display: none;'&gt;&lt;/div&gt;" +
      "&lt;div class='region-notes' style='display: none;'&gt;&lt;/div&gt;"
    ));

    // App.Views.Note fixture.
    this.$fixture = $(
      "&lt;div id='note-fixture region-note'&gt;" +
        "&lt;div id='#note-pane-view-content'&gt;&lt;/div&gt;" +
      "&lt;/div&gt;"
    );

    // Any model changes will trigger a `model.save()`, which
    // won't work in the tests, so we have to fake the method.
    sinon.stub(App.Models.Note.prototype, "save");
  });</pre></div><p>In the <code class="literal">beforeEach()</code> setup method, we<a id="id367" class="indexterm"/> attach the view fixtures to the fixture container and create a spy function meant to replace our real Backbone.js router. Then, we create an <code class="literal">App.Views.Note</code> object and bind the fixtures and a new <code class="literal">App.Models.Note</code> to it. We also provide two initialization options to the <code class="literal">App.Views.Note</code> instance:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">nav</code>: We pass a raw <code class="literal">Backbone.View</code> object as a replacement for the menu bar view to proxy events through, while omitting the real view logic and DOM<a id="id368" class="indexterm"/> interaction</li><li class="listitem" style="list-style-type: disc"><code class="literal">router</code>: We pass <code class="literal">this.routerSpy</code> to record the Backbone.js routing events without actually changing our browser history/URL state<div><pre class="programlisting">beforeEach(function () {
    this.routerSpy = sinon.spy();
    this.$fixture.appendTo($("#fixtures"));

    this.view = new App.Views.Note({
      el: this.$fixture,
      model: new App.Models.Note()
    }, {
      nav: new Backbone.View(),
      router: {
        navigate: this.routerSpy
      }
    });
  });</pre></div></li></ul></div><p>It is worth noting<a id="id369" class="indexterm"/> that we inject four view dependencies (<code class="literal">el</code>, <code class="literal">model</code>, <code class="literal">nav</code>, and <code class="literal">router</code>) into <code class="literal">App.Views.Note</code> to help isolate the instance and make it testable. With this configuration, the specs in our suite could be considered partial integration tests because we are using (and testing) real Backbone.js objects beyond the view under test.</p><p>Another observation with the previous setup is that the <code class="literal">nav</code> and <code class="literal">router</code> option parameters are specifically chosen to avoid triggering the real behavior of the full application; for example, manipulating the menu bar DOM or changing the browser's URL. As we will learn in <a class="link" href="ch05.html" title="Chapter 5. Test Stubs and Mocks">Chapter 5</a>, <em>Test Stubs and Mocks</em>, this type of behavior replacement is much more concisely and appropriately performed with Sinon.JS stubs or mocks.</p><p>Moving on to the test teardown in <code class="literal">afterEach()</code>, we clear out the test fixtures and delete any view objects still around. (The specs may already have destroyed the test view object.) Finally, at the end of the suite in <code class="literal">after()</code>, we clear out the top-level fixture container and restore the <code class="literal">save()</code> method of the <code class="literal">App.Models.Note</code> class to its original state:</p><div><pre class="programlisting">  afterEach(function () {
    this.$fixture.empty();
    if (this.view) { this.view.model.destroy(); }
  });

  after(function () {
    $("#fixtures").empty();
    App.Models.Note.prototype.save.restore();
  });</pre></div><p>With our setup/teardown complete, we move on to the first nested test suite, <code class="literal">view modes and actions</code>, which verifies that the user DOM interaction and Backbone.js events can control the note view and cause it to switch between editing, viewing, and deleting modes:</p><div><pre class="programlisting">  describe("view modes and actions", function () {</pre></div><p>By default, an <code class="literal">App.Views.Note</code> view routes to the URL hash fragment <code class="literal">#note/:id/view</code> and <a id="id370" class="indexterm"/>displays the viewing mode HTML. We use our router spy to <a id="id371" class="indexterm"/>verify the suffix of the called hash fragment using the Sinon-Chai <code class="literal">calledWithMatch</code> extension. Then, we assert that only the viewing pane <code class="literal">#note-pane-view</code> is visible with a simple CSS <code class="literal">display</code> property check:</p><div><pre class="programlisting">    it("navigates / displays 'view' by default", function () {
      expect(this.routerSpy).to.be.calledWithMatch(/view$/);

      // Check CSS visibility directly. Not necessarily a best
      // practice as it uses internal knowledge of the DOM, but
      // gets us a quick check on what should be the visible
      // view pane.
      expect($("#note-pane-view")
        .css("display")).to.not.equal("none");
      expect($("#note-pane-edit")
        .css("display")).to.equal("none");
    });</pre></div><p>The next spec triggers the <code class="literal">update:edit</code> event and then verifies that this changes the URL hash fragment to <code class="literal">#note/:id/edit</code> and displays the editing pane:</p><div><pre class="programlisting">    it("navigates / displays 'edit' on event", function () {
      this.view.trigger("update:edit");
      expect(this.routerSpy).to.be.calledWithMatch(/edit$/);

      expect($("#note-pane-edit")
        .css("display")).to.not.equal("none");
      expect($("#note-pane-view")
        .css("display")).to.equal("none");
    });</pre></div><p>We test the note deletion behavior by stubbing out the <code class="literal">confirm()</code> pop up to always return <code class="literal">false</code> (preventing the actual note deletion) and then calling <code class="literal">deleteNote()</code>. We need this stub to prevent an actual browser confirmation window from popping up during our test run. Then, we use the spy properties of the stub to verify that <code class="literal">confirm()</code> was called correctly:</p><div><pre class="programlisting">    it("confirms note on delete", sinon.test(function () {
      this.stub(window, "confirm").returns(false);
      this.view.deleteNote();
      expect(window.confirm)
        .to.have.been.calledOnce.and
        .to.have.been.calledWith("Delete note?");
    }));
  });</pre></div><p>The next test suite, <code class="literal">model interaction</code>, contains a single spec that verifies that the deletion of a model <a id="id372" class="indexterm"/>causes the <code class="literal">App.Views.Note</code> object to remove itself and its<a id="id373" class="indexterm"/> contained <code class="literal">App.Views.NoteView</code> object. Accordingly, we set up spies on the <code class="literal">remove()</code> methods of both the views.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>Failure to clean up the views, models, and so on once they are no longer used can lead to memory leaks, which may have significant impact on the overall application performance. Triggering <code class="literal">App.Views.Note</code> and <code class="literal">App.Views.NoteView</code> object removals on the destruction of the underlying note model is one way of reclaiming used memory from the various components of a Backbone.js application.</p><p>At the same time, there are many other techniques to keep the memory in check. <em>Zombies! RUN!</em> (<a class="ulink" href="http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/">http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/</a>) and <em>Backbone.js And JavaScript Garbage Collection</em> (<a class="ulink" href="http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/">http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/</a>) are posts by <em>Derick Bailey</em> that provide a great introduction to Backbone.js memory management issues and solutions.</p></div></div><div><pre class="programlisting">  describe("model interaction", function () {
    afterEach(function () {
      // Wipe out to prevent any further use.
      this.view = null;
    });

    it("is removed on destroyed model", sinon.test(function () {
      this.spy(this.view, "remove"),
      this.spy(this.view.noteView, "remove");

      this.view.model.trigger("destroy");

      expect(this.view.remove).to.be.calledOnce;
      expect(this.view.noteView.remove).to.be.calledOnce;
    });
  });</pre></div><p>The last nested test suite, <code class="literal">note rendering</code>, checks that model data is correctly rendered to HTML and that rendering is triggered in response to expected application events. The first spec, <code class="literal">can render a note</code>, verifies that <code class="literal">render()</code> shows the appropriate HTML region elements and hides the rest:</p><div><pre class="programlisting">  describe("note rendering", function () {

    it("can render a note", function () {
      // Don't explicitly call `render()` because
      // `initialize()` already called it.
      expect($(".region-note")
        .css("display")).to.not.equal("none");
      expect($(".region-notes")
        .css("display")).to.equal("none");
    });</pre></div><p>The next two specs<a id="id374" class="indexterm"/> check that the <code class="literal">render()</code> method is triggered on <a id="id375" class="indexterm"/>appropriate changes. The spec <code class="literal">calls render on model events</code> verifies that <code class="literal">render()</code> is called whenever the model changes:</p><div><pre class="programlisting">    it("calls render on model events", sinon.test(function () {
      // Spy on `render` and check call/return value.
      this.spy(this.view, "render");

      this.view.model.trigger("change");

      expect(this.view.render)
        .to.be.calledOnce.and
        .to.have.returned(this.view);
    }));</pre></div><p>The final spec modifies data in the single note edit form like a user would and then triggers the <code class="literal">blur</code> event to force model change events. The spec spies on the <code class="literal">render()</code> method and checks that the rendered Markdown HTML has been updated to reflect the new data:</p><div><pre class="programlisting">    it("calls render on changed data", sinon.test(function () {
      this.spy(this.view, "render");

      // Replace form value and blur to force changes.
      $("#input-text").val("# A Heading!");
      $("#note-form-edit").blur();

      // `Note` view should have rendered.
      expect(this.view.render)
        .to.be.calledOnce.and
        .to.have.returned(this.view);

      // Check the `NoteView` view rendered the new markdown.
      expect($("#pane-text").html())
        .to.match(/&lt;h1 id=".*?"&gt;A Heading!&lt;\/h1&gt;/);
    }));
  });
});</pre></div><p>With all of the <a id="id376" class="indexterm"/>specs in this suite, we have increased confidence<a id="id377" class="indexterm"/> that the <code class="literal">App.Views.Note</code> class can emit/listen to appropriate events, clean up application objects on model deletion, and other behaviors that we earlier identified as the core responsibilities of the view.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Hooking up and running the view tests</h2></div></div></div><p>Now that we have <a id="id378" class="indexterm"/>our test suites for <code class="literal">App.Views.NoteNav</code> and <code class="literal">App.Views.Note</code>, let's wire<a id="id379" class="indexterm"/> up the test driver page <code class="literal">chapters/04/test/test.html</code>. We can re-use the same code as in <code class="literal">chapters/03/test/test.html</code>, with a few (highlighted in the ensuing code) differences, that add in the Sinon-Chai plugin, more Notes application libraries, and our new spec files:</p><div><pre class="programlisting">&lt;head&gt;
  &lt;!-- ... snipped ... --&gt;

  &lt;!-- JavaScript Test Libraries. --&gt;
  &lt;script src="img/mocha.js"&gt;&lt;/script&gt;
  &lt;script src="img/chai.js"&gt;&lt;/script&gt;
  <strong>&lt;script src="img/sinon-chai.js"&gt;&lt;/script&gt;</strong>
  &lt;script src="img/sinon.js"&gt;&lt;/script&gt;

  &lt;!-- JavaScript Core Libraries --&gt;
  &lt;!-- ... snipped ... --&gt;

  &lt;!-- JavaScript Application Libraries --&gt;
  &lt;script src="img/namespace.js"&gt;&lt;/script&gt;
  &lt;script src="img/config.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    // Test overrides (before any app components).
    App.Config = _.extend(App.Config, {
      storeName: "notes-test" // localStorage for tests.
    });
  &lt;/script&gt;
  &lt;script src="img/note.js"&gt;&lt;/script&gt;
  &lt;script src="img/notes.js"&gt;&lt;/script&gt;
  &lt;script src="img/templates.js"&gt;&lt;/script&gt;
  <strong>&lt;script src="img/note-nav.js"&gt;&lt;/script&gt;</strong>
  &lt;script src="img/note-view.js"&gt;&lt;/script&gt;
  <strong>&lt;script src="img/note.js"&gt;&lt;/script&gt;</strong>

  &lt;!-- ... snipped ... --&gt;

  &lt;!-- Tests. --&gt;
  <strong>&lt;script src="img/note-nav.spec.js"&gt;&lt;/script&gt;</strong>
  <strong>&lt;script src="img/note.spec.js"&gt;&lt;/script&gt;</strong>
&lt;/head&gt;</pre></div><p>We can run the tests by <a id="id380" class="indexterm"/>opening<a id="id381" class="indexterm"/> a browser to <code class="literal">chapters/04/test/test.html</code>. (Note that the code samples contain the additional specs that are omitted from this chapter for brevity).</p><div><img src="img/5248OS_04_02.jpg" alt="Hooking up and running the view tests"/><div><p>Test report</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>We introduced the Sinon.JS test library in this chapter and learned how to integrate spies in various testing scenarios. We investigated Chai's plugin architecture and used the Sinon-Chai adapter to write better test spy assertions. We wrote specs for the menu bar and single note Backbone.js views, completing our tests for the single note portion of the Notes application.</p><p>The next chapter continues our exploration of Sinon.JS by looking into stubs, mocks, and other useful fake testing objects. We will use these tools to fill out more parts of our Backbone.js application test collection and round out the fundamentals of writing tests with Mocha, Chai, and Sinon.JS.</p></div></body></html>