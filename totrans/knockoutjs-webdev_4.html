<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Coding &#x2013; AJAX, Binding Properties, Mapping, and Utilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Coding – AJAX, Binding Properties, Mapping, and Utilities</h1></div></div></div><p>There is an aspect of Knockout that takes repeated tasks out of the way. There is also the reality that we never expect it to do 100 percent of our work. It also makes sense that we do not have Knockout doing so much as it is not good at its core strengths. Here, we will learn how to extend our reach into Knockout and how to connect to the world outside Knockout and do even more. This chapter will focus on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with JSON</li><li class="listitem" style="list-style-type: disc">Mapping versus manual ViewModels</li><li class="listitem" style="list-style-type: disc">Working with AJAX requests</li><li class="listitem" style="list-style-type: disc">Unmapping your data</li><li class="listitem" style="list-style-type: disc">Managed mapping</li><li class="listitem" style="list-style-type: disc">Utility functions</li></ul></div><p>In this chapter, we will be learning about some of the commonly used aspects of Knockout—working with JSON and the mapping plugin. These two are simple and powerful pivots where we will extend rapid application development with Knockout.</p><div class="section" title="JSON done Knockout style"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>JSON done Knockout style</h1></div></div></div><p>JSON is the famous data packaging standard that seems to have taken over the Internet. At <a id="id150" class="indexterm"/>one time there was XML; RoR has its own packaging standard; and even Adobe had perhaps the best performing way to package and deliver data between the client and the server <a id="id151" class="indexterm"/>called <span class="strong"><strong>Action Message Format</strong></span> (<span class="strong"><strong>AMF</strong></span>). The overall winner seems to be JSON because it is simple and based on the most common development platform of all: JavaScript. If you would like <a id="id152" class="indexterm"/>more information about JSON you can visit <a class="ulink" href="http://json.org">http://json.org</a>.</p><p>To serve <a id="id153" class="indexterm"/>our purpose, let's create a file called, <code class="literal">json.html</code>. The first thing we will do is convert a <a id="id154" class="indexterm"/>ViewModel to JSON. Most modern browsers have a function called <code class="literal">JSON.stringify</code> but that is not how we do it in Knockout. There are two methods included in Knockout:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ko.toJS</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ko.toJSON</code></li></ul></div><p>The first method, <code class="literal">ko.toJS</code>, will clone the Knockout data into a plain copy that contains no<a id="id155" class="indexterm"/> Knockout-related hints or information. The second method, <code class="literal">ko.toJSON</code>, will perform the <code class="literal">ko.toJS</code> action and then convert it into a serialized JSON string according to<a id="id156" class="indexterm"/> the JSON standard. If you are using older browsers such as IE7 or older, you will need to get a copy of <a id="id157" class="indexterm"/>the <code class="literal">json2.js</code> file, available at <a class="ulink" href="https://github.com/douglascrockford/JSON-js/blob/master/json2.js">https://github.com/douglascrockford/JSON-js/blob/master/json2.js</a>.</p><p>Now enter the following code into your file:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
function VM() {
  this.colors = ko.observableArray([]);
  this.shapes = ko.observableArray([]);
  this.foodItems = ko.observableArray([
    { item: 'bread', itemDisplay: 'Bread' },
    { item: 'milk', itemDisplay: 'Milk' },
    { item: 'eggs', itemDisplay: 'Eggs' }
  ]);
  this.foods = ko.observableArray(["bread","eggs"]);
};
vm = new VM();
ko.applyBindings( vm );
&lt;/script&gt;</pre></div><p>Now we will look at our structure stored in the ViewModel. We will be using Chrome as our browser but you can use any browser with development tools that support the console command. Here is the result we got by dumping our ViewModel. Type <code class="literal">console.log(vm)</code> in the console to get the results stored in <code class="literal">vm</code>:</p><div class="mediaobject"><img src="graphics/1028OS_04_01.jpg" alt="JSON done Knockout style"/></div><p>It is plainly <a id="id158" class="indexterm"/>visible that while a full exposure of our ViewModel is there, packaged in functions. You will <a id="id159" class="indexterm"/>get used to ignoring the <code class="literal">undefined</code> item<code class="literal">,</code> when dumping stuff into the console. If you get the results expected then don't get distracted by that item.</p><p>This is where we use the two commands, which are <code class="literal">ko.toJS</code> and <code class="literal">ko.toJSON</code>. Let's start by dumping the ViewModel to the console using the structure. Type <code class="literal">console.log( ko.toJS(vm) )</code> in the console:</p><div class="mediaobject"><img src="graphics/1028OS_04_02.jpg" alt="JSON done Knockout style"/></div><p>Here, we see <code class="literal">console.log</code> versus dump. This is great, but if we wanted to send this out to an external source or store it using modern browser storage technology we would still want to package it as a JSON string in most cases. This can be achieved using the helper <code class="literal">ko.toJSON</code> method, which is what we will be doing next. You will see this time our data has been placed in the middle of special characters. This is the JSON formatting, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1028OS_04_03.jpg" alt="JSON done Knockout style"/></div><p>Now, we will create <code class="literal">json2.html</code> to pull our JSON data into our app. We will need to copy and paste the JSON into our app but we will be doing that from a separate file in the same directory as the HTML file. Name that file <code class="literal">json2.txt</code> for this example. Certainly, on a live site don't store sensitive data in a text file. In the <code class="literal">json2.txt</code> file copy the console output you got in the preceding example. This is your JSON data and it should look like this:</p><div class="informalexample"><pre class="programlisting">{"colors":[],"shapes":[],"foodItems":[{"item":"bread","itemDisplay":"Bread"},{"item":"milk","itemDisplay":"Milk"},{"item":"eggs","itemDisplay":"Eggs"}],"foods":["bread","eggs"]} </pre></div><p>While this <a id="id160" class="indexterm"/>might look <a id="id161" class="indexterm"/>good, we have an issue. JSON doesn't stand on its own feet. It needs to be inside a variable to be managed. We will change it as follows. We will use the variable, <code class="literal">myJSON</code>. We also need to surround the text in quotes. Since the JSON tends to use double quotes internally, the traditional way to handle this is to use a single quote before the data string and a single quote at the end, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">myJSON = '{"colors":[],"shapes":[],"foodItems":[{"item":"bread", "itemDisplay":"Bread"},{"item":"milk","itemDisplay":"Milk"}, {"item":"eggs","itemDisplay":"Eggs"}],"foods":["bread","eggs"]}';</pre></div><p>The following code is used for our <code class="literal">json2.html</code> file. We will use the <code class="literal">script</code> command to pull the external data into the page. It is also common for people to name such a static file <code class="literal">json2.json</code>. We are using the <code class="literal">.text</code> extension to make a point that JSON is just a text file here:</p><div class="informalexample"><pre class="programlisting">&lt;script src="json2.txt"&gt;&lt;/script&gt;
&lt;script&gt;
function VM() {
  this.colors = ko.observableArray([]);
  this.shapes = ko.observableArray([]);
  this.foodItems = ko.observableArray([]);
  this.foods = ko.observableArray([]);
};
vm = new VM();
ko.applyBindings( vm );
myData = JSON.parse(myJSON);
vm.foodItems(myData.foodItems);
vm.foods(myData.foods);
&lt;/script&gt;</pre></div><p>We start out our ViewModel this time with structure but absolutely no data. After binding the <a id="id162" class="indexterm"/>ViewModel to our data model, we convert our string of JSON data into a standard JavaScript <a id="id163" class="indexterm"/>structure. We then use the standard JavaScript to pass the arrays into the <code class="literal">foodItems</code> and the <code class="literal">foods</code> attributes of our ViewModel. While that is neat, it doesn't feel like we actually did something of value. Let's add some View code onto the page above the <code class="literal">script</code> section, as follows. This is the same code we used in the previous chapter:</p><div class="informalexample"><pre class="programlisting">Foods (&lt;span data-bind="text: foods"&gt;&lt;/span&gt;)&lt;br/&gt;
&lt;div data-bind="foreach: {data:foodItems, as: 'food'}"&gt;
  &lt;input type="checkbox" data-bind="checkedValue:$data.item, checked: $root.foods" /&gt;
  &lt;span data-bind="text: food.itemDisplay"&gt;&lt;/span&gt;&lt;br/&gt;
&lt;/div&gt;</pre></div><p>What we see is a web page that pulls the external data in and automatically populates the View for us based on that data:</p><div class="mediaobject"><img src="graphics/1028OS_04_04.jpg" alt="JSON done Knockout style"/></div></div></div>
<div class="section" title="Mapping &#x2013; first look"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Mapping – first look</h1></div></div></div><p>We have been creating manual maps of our ViewModel so far in this book. With smaller datasets this can be practical and productive. As our datasets get larger along with the need to <a id="id164" class="indexterm"/>update the data, this will become a chore that has an alternative, enjoyed by a great number of Knockout developers. This is done through a mapping plugin. Knockout is a jQuery-based library in more than one way. It is possible to build and use libraries, called plugins, for Knockout also. The most famous library is the mapping library. I have included a copy of it in the downloaded files for this book. We will be looking again at the preceding code for our example but moving it this time using the mapping plugin.</p><p>We will create a file called <code class="literal">mapping.html</code> for our code this time. We will need to include one more JavaScript file right after the Knockout call for our mapping plugin. You can find these files in the working examples folder in the ZIP download. This, in our case, should look like this: </p><div class="informalexample"><pre class="programlisting">&lt;script src="json2.txt"&gt;&lt;/script&gt;
&lt;script src="data.js"&gt;&lt;/script&gt;</pre></div><p>Create both of those files if you wish, but we suggest just copying them from the <code class="literal">done</code> folder in <a id="id165" class="indexterm"/>this chapter and making sure they are in the same folder as the <code class="literal">mapping.html</code> file.</p></div>
<div class="section" title="Connecting with AJAX remotely"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Connecting with AJAX remotely</h1></div></div></div><p>Using a <code class="literal">script</code> tag to load data is definitely not very sophisticated. We are going to improve this by <a id="id166" class="indexterm"/>creating the example again, but this time using jQuery to make our AJAX request. We will put this code in a file named <code class="literal">ajax.html</code>. We will use the same HTML code as<a id="id167" class="indexterm"/> before, but we will add a button to the form using the following lines of code:</p><div class="informalexample"><pre class="programlisting">Foods (&lt;span data-bind="text: foods"&gt;&lt;/span&gt;)
&lt;button data-bind="click: pullData"&gt;Pull Data&lt;/button&gt;&lt;br/&gt;
&lt;div data-bind="foreach: {data:foodItems, as: 'food'}"&gt;
  &lt;input type="checkbox" data-bind="checkedValue:$data.item, checked: $root.foods" /&gt;
  &lt;span data-bind="text: food.itemDisplay"&gt;&lt;/span&gt;&lt;br/&gt;
&lt;/div&gt;</pre></div><p>The <code class="literal">pullData</code> request will be a method/function that we add to our ViewModel. It will be used, at this time, to pull the data from the server and update the View in our browser. Here is the <code class="literal">script</code> section of code we will use for this example:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
function VM() {
  var self = this;
  self.foodItems = ko.observableArray([]);
  self.foods = ko.observableArray([]);
  self.pullData = function(){
    var reqAJAX = "data.json";
    jQuery.getJSON(reqAJAX).done(function(data){
      self.foodItems(data.foodItems);
      self.foods(data.foods);
    });
  };
};
vm = new VM();
ko.applyBindings( vm );
&lt;/script&gt;</pre></div><p>Please note that I am going to try to get you into the habit of using—this is a phrase I made up and like—"selfish coding". Because there is a risk of interaction with our code having the <code class="literal">this</code> value, debugging "this" issue is not <a id="id168" class="indexterm"/>fun. We have learned to use the <code class="literal">self</code> alias to make sure this does not become an issue. The <code class="literal">.done()</code> function is a chained command in jQuery to handle the completion <a id="id169" class="indexterm"/>of a good request to the server. See the jQuery documents for more handlers; you can use those docs to make your code even more fully responsive.</p><p>We have created a function/method called <code class="literal">pullData</code>. Inside the data we will use a <code class="literal">jQuery.getJSON</code> request to pull our data back from the server. We have copied the JSON structure to a file called <code class="literal">data.json</code> this time. Make sure you do not assign this to a variable; you only want the structure of the JSON as follows:</p><div class="informalexample"><pre class="programlisting">{"colors":[],"shapes":[],"foodItems":[{"item":"bread","itemDisplay":"Bread"},{"item":"milk","itemDisplay":"Milk"},{"item":"eggs","itemDisplay":"Eggs"}],"foods":["bread","eggs"]}</pre></div><p>Now let's look at our initial screen when we load the page. Here is what you should get:</p><div class="mediaobject"><img src="graphics/1028OS_04_05.jpg" alt="Connecting with AJAX remotely"/></div><p>When we click the <span class="strong"><strong>Pull Data</strong></span> button we will see the results automatically update to the following view:</p><div class="mediaobject"><img src="graphics/1028OS_04_06.jpg" alt="Connecting with AJAX remotely"/></div><p>This is already much better coding than a pure JavaScript experience for many developers. Yet, what if this form had 40 elements on the page? It would be a big block of code to set the ViewModel up for that much binding. We just learned about mapping; so what if we included the mapping plugin and reworked our code? Take a look at the following piece of code:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
var reqAJAX = "data.json";
vm = {};
jQuery.getJSON(reqAJAX).done(function(data){
  vm = ko.mapping.fromJS(data);
  vm.pullData = function(){
    reqAJAX = "data2.json";
    jQuery.getJSON(reqAJAX).done(function(data){
      ko.mapping.fromJS(data,vm);
    });
  };
  ko.applyBindings( vm );
});
&lt;/script&gt;</pre></div><p>We can see a few <a id="id170" class="indexterm"/>changes in our <a id="id171" class="indexterm"/>approach. We could have just put the filename into the <code class="literal">getJSON</code> request, but we passed it in as a variable just as a matter of how we like to code. We also created the <code class="literal">vm</code> variable to hold our ViewModel.</p><p>The AJAX has been moved outside the ViewModel while the ViewModel declaration has been moved inside the AJAX. It is inside out compared to our last example. The difference is that we see the data populate our View immediately as the page loads. We have also changed the functionality of our <code class="literal">pullData</code> function. Now, it will be used to make a second call to the server. Normally, we would not reset this source file as it would be a typical AJAX request to see whether anything was updated. Since we are not coding for a dynamic server we will just show an imitation of that scenario here by changing the name of the source for our AJAX request.</p><p>Now, when doing mapping we have to declare the mapping features before we use the <code class="literal">applyBindings</code> method. This gives us the same results as manually creating each individual binding. Again, for a simple form like this the gain is not so obvious. When we get to larger, more complex pages, the gain is amazing. Oh, also note that when we run additional calls to the server we will be updating the data. We need to pass in the ViewModel variable after our data as we map an update.</p><p>Now, we will take another look at what we get by running our code with a little more progressive AJAX. The first load looks like the pulled data from our last example:</p><div class="mediaobject"><img src="graphics/1028OS_04_07.jpg" alt="Connecting with AJAX remotely"/></div><p>We created an additional item; so when we load the update it will be obvious. The item is <span class="strong"><strong>Ice Cream</strong></span>. We also preselected this item. Here is our JSON data structure for the second load:</p><div class="informalexample"><pre class="programlisting">{"colors":[],"shapes":[],"foodItems":[{"item":"bread","itemDisplay":"Bread"},{"item":"milk","itemDisplay":"Milk"},{"item":"eggs","itemDisplay":"Eggs"},{"item":"icecream","itemDisplay":"Ice Cream"}],"foods":["bread","eggs"]}</pre></div><p>When <a id="id172" class="indexterm"/>we push the <a id="id173" class="indexterm"/>button now to pull the update this is what we should see:</p><div class="mediaobject"><img src="graphics/1028OS_04_08.jpg" alt="Connecting with AJAX remotely"/></div></div>
<div class="section" title="Unmapping your data"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Unmapping your data</h1></div></div></div><p>This is coming along good but there is something we are going to need for most AJAX-based web<a id="id174" class="indexterm"/> applications. We are going to need to store the data back on the server. Pulling the data to <a id="id175" class="indexterm"/>the browser will not be enough. We will require the ability to push the data back to the server as well. Once again, we will be using jQuery for this function. Of course, we will show the code to do this but we will approach it differently because different readers will be using different backends such as ASP.NET, ColdFusion, Node.js, PHP, Python, Ruby, and others.</p><p>This time, just modify the code in the <code class="literal">AJAX.html</code> file unless, of course, you want to create a new file. We will be adding another button to our View to connect a push data method this time:</p><div class="informalexample"><pre class="programlisting">&lt;button data-bind="click:pushData"&gt;Push Data&lt;/button&gt;</pre></div><p>We will also need to put a textbox at the end of our View code to see the data that is pulled out of our ViewModel. Create the <code class="literal">textarea</code> field to hold the results:</p><div class="informalexample"><pre class="programlisting">&lt;textarea id="unmapped"&gt;&lt;/textarea&gt;</pre></div><p>We will need to add another method to our ViewModel now:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
var reqAJAX = "data.json";
vm = {};
jQuery.getJSON(reqAJAX).done(function(data){
  vm = ko.mapping.fromJS(data);
  vm.pullData = function(){
    reqAJAX = "data2.json";
    jQuery.getJSON(reqAJAX).done(function(data){
      ko.mapping.fromJS(data,vm);
    });
  }; 
  vm.pushData = function(){
    // This next line is just to show unmapped data
    var myData = ko.toJSON(vm);
    jQuery('#unmapped').text(myData);
    /*
    jQuery.post(reqAJAX, myData ).done(function(data){
      // code here to reflect good request
      alert("Your food changes have been stored.");
    });
    */
  };
  ko.applyBindings( vm );
});
&lt;/script&gt;</pre></div><p>We saw the <a id="id176" class="indexterm"/>code that <a id="id177" class="indexterm"/>would be used to send a request back to the server. We are assuming in this example that our server was able to respond to the URL in the <code class="literal">reqAJAX</code> variable and handle data coming into the server. If not, all you would need to do is set that variable to the target that can take data. The data is being sent in this case in the <code class="literal">POST</code> form of data. This would be the same as a form using the <code class="literal">POST</code> method.</p><p>You should see all we did was add the ability to pull the results back out as a variable named <code class="literal">myData</code>. If we ran the code again, pulled data, and set the selections to just eggs and ice cream, we would be able to test the data being pushed back to the server. Notice we have the jQuery command to push the <code class="literal">myData</code> results to the <code class="literal">textarea</code> field. Here are the results we see:</p><div class="mediaobject"><img src="graphics/1028OS_04_09.jpg" alt="Unmapping your data"/></div><p>We have what seems to be an issue with extra data. We don't have to manage that but it is not hard to fix. The issue occurs because when data is mapped it creates extra details internally. These come back out when unmapping the data. You can leave that if you choose or you can fix it using the following code. We will write a <code class="literal">console.log</code> command that will dump the structure to the console. We also need to change <code class="literal">myData</code> to return the JavaScript structure.</p><p>If we look at our developer tools console for our browser we will see the following structure for our dump. Then we will use <code class="literal">JSON.stringify()</code> to make it ready for AJAX:</p><div class="informalexample"><pre class="programlisting">var myData = ko.toJS(vm);
console.log(myData);
delete myData.__ko_mapping__;
myData = JSON.stringify(myData);
jQuery('#unmapped').text(myData);</pre></div><p>We see the <a id="id178" class="indexterm"/>change to <a id="id179" class="indexterm"/>the <code class="literal">myData</code> variable and the console log to manage the dump. The extra detail in the console log is part of the <code class="literal">__ko_mapping__</code> data structure. Using the JavaScript delete command, we can trim it right off our results. Some functions are showing, but when we use the <code class="literal">stringify</code> function, it does not pull them. Here is what we get now:</p><div class="informalexample"><pre class="programlisting">{"colors":[],"shapes":[],"foodItems":[{"item":"bread","itemDisplay":"Bread"},{"item":"milk","itemDisplay":"Milk"},{"item":"eggs","itemDisplay":"Eggs"},{"item":"icecream","itemDisplay":"Ice Cream"}],"foods":["eggs","icecream"]}</pre></div><p>Now we are doing meaningful AJAX interaction. You may want to send even less structure back to the server than we did here. There is the option of trimming even more data to keep things as compact as possible.</p><p>Oh, for a live app, <span class="emphasis"><em>remember</em></span> to remove the console log and the <code class="literal">textarea</code> field. Don't say I taught you to leave those in a real world web page!</p></div>
<div class="section" title="Merging mapped data"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Merging mapped data</h1></div></div></div><p>There are times you may want to pull data into your ViewModel from multiple sources. When<a id="id180" class="indexterm"/> doing this you can create a map for each source. If the source variables have the same name they will overwrite the existing variables. As long as the base variable is a different name it will merge them into the ViewModel. Do this as follows:</p><div class="informalexample"><pre class="programlisting">myViewModel = ko.mapping.fromJS(firstData, firstMap);
ko.mapping.fromJS(nextData, nextMap, myViewModel);</pre></div><p>What you get is a combination of the <code class="literal">firstData</code> JavaScript structure, mapped with <code class="literal">firstMap</code>, combined with the <code class="literal">nextData</code> JavaScript structure, and with the <code class="literal">nextMap</code> mapping. If there are any duplicate base structures in <code class="literal">nextData</code>, they will override the same structures in the existing <code class="literal">firstData</code> JavaScript structure.</p></div>
<div class="section" title="Mapping options"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Mapping options</h1></div></div></div><p>There are times when you are loading data into a page application that doesn't need to be <a id="id181" class="indexterm"/>changed. This is just static data and making it observable spends extra processor time and memory resources for no gain. When passing data into the mapping handler, you can set which items are mapped as observable items, using the following lines of code:</p><div class="informalexample"><pre class="programlisting">var data = {
  a: "a",
  b: [{ b1: "v1" }, { b2: "v2" }],
  c: true
};
var result = ko.mapping.fromJS(data, { observe: "a" });
var result2 = ko.mapping.fromJS(data, { observe: "a", copy: "b" }); //will be faster to map.</pre></div><p>The results we get from the <code class="literal">result</code> and <code class="literal">result2</code> variables will be the same. Why? This is because when we declare the <code class="literal">observe</code> items the other items are assumed to be copied items. If a single item is passed in we can declare it outside an array, as we did with <code class="literal">a</code>. If multiple items are passed in we would declare them in an array, as <code class="literal">["a","c"]</code>. This would make both <code class="literal">a</code> and <code class="literal">c</code> observable items.</p><p>If we just wanted to declare an item to copy we would pass in the copy and that is the only item that would be directly copied. We also have the ability to ignore items from being copied in during the mapping using <code class="literal">ignore</code>, of course.</p></div>
<div class="section" title="Utility functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Utility functions</h1></div></div></div><p>There are a <a id="id182" class="indexterm"/>number of functions in <code class="literal">ko.utils</code>. Let's start by looking at the special array methods in standard Knockout.</p><div class="section" title="ko.utils.arrayFilter()"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>ko.utils.arrayFilter()</h2></div></div></div><p>The <code class="literal">ko.utils.arrayFilter</code> function allows us to filter items in an array. We are going to run these as straight code <a id="id183" class="indexterm"/>examples. We will create a sample JSON file and load it via <a id="id184" class="indexterm"/>AJAX to keep the focus on learning the methods and not waste time creating an example code set. We will create a page called <code class="literal">utility.html</code> for these pieces of code and run the filtering code from there. Our markup for this example is here:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;arrayFilter() : staff under 35&lt;/h3&gt;
&lt;ul data-bind="foreach: youngStaff"&gt;
  &lt;li&gt;&lt;span data-bind="text: age() + ' ' + firstName()"&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>Our <code class="literal">script</code> code is as follows. We will be adding more for each example as we go, but here are the basics for the utility examples:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
var vm = {};
jQuery.getJSON('utility.json').done(function(data){
  vm = ko.mapping.fromJS( data );
  vm.youngStaff = ko.computed(function(){
    return ko.utils.arrayFilter(vm.arr(), function(item){
      if(item.age() &lt; 35) { return true; }
      return false;
    });
  });
  ko.applyBindings(vm);
});
&lt;/script&gt;</pre></div><p>We set our <a id="id185" class="indexterm"/>mapping <a id="id186" class="indexterm"/>using the data and then we begin adding our custom features. These could be custom functions or computed values. Lastly, after adding all our customizations to the mapping we apply our bindings.</p><p>In our code sample we showed you how to use <code class="literal">arrayFilter</code>. The <code class="literal">arrayFilter</code> function will pass in the items one at a time and will include the ones in the result set in which we send out a true value to let it know that it should be included. </p><p>Here is the JSON we will use for our examples. We will show the whole dataset here. Note that the JSON is also in our <code class="literal">done</code> folder under the <code class="literal">utility.json</code> file if you do not want to type it in. Normally, I would suggest typing in these examples to strengthen your skills on the topic:</p><div class="informalexample"><pre class="programlisting">{"arr":[{"firstName":"James","lastName":"Donald","age":23,"phone":[]},{"firstName":"Adam","lastName":"Thomas","age":46,"phone":[]},{"firstName":"Michelle","lastName":"Ingram","age":32,"phone":[]},{"firstName":"Edward","lastName":"Adams","age":63,"phone":[]},{"firstName":"Veronica","lastName":"Wesson","age":54,"phone":[]},{"firstName":"Greg","lastName":"Simons","age":46,"phone":[]}],"color_1":["red","green","blue","orange"],"color_2":["red","blue","orange","purple"]}</pre></div><p>Also, we used the following dataset to create our JSON. We just called the <code class="literal">JSON.stringify</code> method on the dataset. Here is the code:</p><div class="informalexample"><pre class="programlisting">{
  arr : [
    { "firstName": "James", "lastName": "Donald", "age": 23, "phone": [] },
    { "firstName": "Adam", "lastName": "Thomas", "age": 46, "phone": [] },
    { "firstName": "Michelle", "lastName": "Ingram", "age": 32, "phone": [] },
    { "firstName": "Edward", "lastName": "Adams", "age": 63, "phone": [] },
    { "firstName": "Veronica", "lastName": "Wesson", "age": 54, "phone": [] },
    { "firstName": "Greg", "lastName": "Simons", "age": 46, "phone": [] }
  ],
  color_1 : [ "red","green","blue","orange" ],
  color_2 : [ "red","blue","orange","purple" ]
}</pre></div><p>We still need to include <a id="id187" class="indexterm"/>our jQuery, Knockout, and Knockout mapping JavaScript files. When you <a id="id188" class="indexterm"/>get all these pulled together with the preceding code, this is what you should see in your browser:</p><div class="mediaobject"><img src="graphics/1028OS_04_10.jpg" alt="ko.utils.arrayFilter()"/></div><p>We see that our filtered results only return two of the six items. This is because only two of them were less than 35. What is even more fun is that this data is dynamically wired into the View model. If the arrays change by adding or removing items the screen will update automatically. This is just not wired into jQuery so it's a great addition. Also, if a value within an array item changes, say one of the ages, then the filter here will automatically know to add, remove, or leave the item in the view list.</p></div><div class="section" title="ko.utils.arrayFirst()"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>ko.utils.arrayFirst()</h2></div></div></div><p>The <code class="literal">ko.utils.arrayFirst</code> method <a id="id189" class="indexterm"/>will pass items into the function to be searched until a match is found or declared. It will only <a id="id190" class="indexterm"/>return one item from the array. Here is the View code to add for this example:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;arrayFirst() : first found over 45&lt;/h3&gt;
( &lt;span data-bind="text: firstRetire().age()"&gt;&lt;/span&gt; )</pre></div><p>Here is the logic to add to understand our <code class="literal">arrayFirst</code> utility command. Add it before the binding is set in our script:</p><div class="informalexample"><pre class="programlisting">vm.firstRetire = ko.computed(function(){
  return ko.utils.arrayFirst(vm.arr(), function(item){
    if(item.age() &gt; 45) return true;
    return false;
  });
}); // arrayFirst</pre></div><p>Like the last <a id="id191" class="indexterm"/>utility <a id="id192" class="indexterm"/>method, the results are triggered by the true value coming back out. The difference in this example is that the first true value will be the only one ever returned. Here is a screenshot of our results:</p><div class="mediaobject"><img src="graphics/1028OS_04_11.jpg" alt="ko.utils.arrayFirst()"/></div></div><div class="section" title="ko.utils.arrayMap()"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>ko.utils.arrayMap()</h2></div></div></div><p>The <code class="literal">ko.utils.arrayMap</code> method allows creation of a flattened array. What this means is that sometimes we have an array of structures <a id="id193" class="indexterm"/>and want just a particular item for the whole structure to be pulled back into a simple <a id="id194" class="indexterm"/>array. Here is the markup code:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;arrayMap() : till retirment&lt;/h3&gt;
&lt;ul data-bind="foreach: tillRetire"&gt;
  &lt;li&gt;&lt;span data-bind="text: $data"&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>Here is the script code we need to add for this example. We will not return true or false style results this time. We will return a value that will, in this case, create a simple value array:</p><div class="informalexample"><pre class="programlisting">vm.tillRetire = ko.computed(function(){
  return ko.utils.arrayMap(vm.arr(),function(item){
    return 65 - item.age() + ' years till retirement.';
  })
}); // arrayMap()</pre></div><p>This is the screen result you will see with our dataset:</p><div class="mediaobject"><img src="graphics/1028OS_04_12.jpg" alt="ko.utils.arrayMap()"/></div><p>It is possible to actually modify the structure that is being passed into the process by modifying the item. This is because normally, structures and arrays are passed in by setting a reference to the source structure in memory. This means even though the name item is <a id="id195" class="indexterm"/>what is <a id="id196" class="indexterm"/>coming in, the item points to the original structure in the ViewModel. Here is another method we could have used if we wanted to modify the original structure within the ViewModel:</p><div class="informalexample"><pre class="programlisting">vm.tillRetire2 = ko.computed(function(){
  ko.utils.arrayMap(vm.arr(),function(item){
    item.yearsLeft = 65 - item.age() + ' years till retirement.';
  })
}); // arrayMap()</pre></div><p>The results would be a value nested within the ViewModel array collection, but the value would not be observed or computed. This means while it may work, it will not work with all the features of Knockout. So it should be tested carefully before trying this. If in doubt, avoid this approach to avoid unplanned features. Oh, you could also delete item fields, so beware that you are editing the original structure and anything connected is at risk if you manually change these things.</p></div><div class="section" title="ko.utils.arrayGetDistinctValues ()"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>ko.utils.arrayGetDistinctValues ()</h2></div></div></div><p>The <code class="literal">ko.utils.arrayGetDistinctValues</code> method allows you to take an array and remove duplicate values, leaving only distinct items. This<a id="id197" class="indexterm"/> time we will be dealing with a result set that is an array, so again in the View we will be <a id="id198" class="indexterm"/>using the foreach method on our <code class="literal">data-bind</code> attribute:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;arrayMap() : All ages sorted&lt;/h3&gt;
&lt;ul data-bind="foreach: allYears"&gt;
  &lt;li&gt;&lt;span data-bind="text: $data"&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;arrayGetDistinctValues() : Unique ages&lt;/h3&gt;
&lt;ul data-bind="foreach: uniqueYears"&gt;
  &lt;li&gt;&lt;span data-bind="text: $data"&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>You may have noticed that we are inserting two segments this time. This is because <code class="literal">arrayGetDistintValues</code> modifies another array. We need the array it is going to modify. What we will do is create an array of all the ages using our <code class="literal">arrayMap</code> method, and then create another result with only the distinct values in it. In our script code, we again need to set <code class="literal">arrayGetDistinctValues</code> before the <code class="literal">applyBindings</code> command:</p><div class="informalexample"><pre class="programlisting">vm.allYears = ko.computed(function(){
  return allYears = ko.utils.arrayMap(vm.arr(),function(item){
    return item.age();
  });
}); // arrayMap()
vm.uniqueYears = ko.computed(function(){
  return ko.utils.arrayGetDistinctValues(vm.allYears().sort(),vm);
}); // arrayGetDistinctValues()</pre></div><p>Here is a screenshot of both sets of results:</p><div class="mediaobject"><img src="graphics/1028OS_04_13.jpg" alt="ko.utils.arrayGetDistinctValues ()"/></div><p>The first <a id="id199" class="indexterm"/>set was sorted in the call to the unique value set. This is something to watch out for as it can be<a id="id200" class="indexterm"/> confusing when something like this happens. We included it here for some food for thought and to illustrate, again, the need to be aware that you might be performing a command on the original set of data. If you were to follow best practice you might sort the results of the unique years, if that was your goal, rather than sorting the input data within the method. This is also an example of where an external variable is visible even though the sort call happened within the method arguments.</p></div><div class="section" title="ko.utils.arrayForEach()"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>ko.utils.arrayForEach()</h2></div></div></div><p>The <code class="literal">ko.utils.arrayForEach</code> method will allow you to loop through an array. This can be great for doing totals or other logic<a id="id201" class="indexterm"/> pulled from a summary of looking at individual objects. You could return all workers with <a id="id202" class="indexterm"/>children, for instance. While the most ideal place may be to do this coming from the database, this does not make it the only place it can ever be done. It is good practice to review where and why we do things to make sure our apps are performing and can scale as much as needed.</p><p>Our View code this time will be using a non-array value so we will not be using a foreach method. The reason we bring that up again here is if you use a wrong method your page will fail to run correctly. Often, the issue is as simple as trying to call an array method on a non-array property of the ViewModel. This is the kind of routine<a id="id203" class="indexterm"/> issue that <a id="id204" class="indexterm"/>can challenge any developer. Here is the View code:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;arrayForEach() : total ages&lt;/h3&gt;
Total Age: &lt;span data-bind="text: totalAge"&gt;&lt;/span&gt;</pre></div><p>Just in case you missed me saying this somewhere in this book, let me make a point. In Knockout, a little bit of code has a lot of power. Here is the code for our total age processing:</p><div class="informalexample"><pre class="programlisting">  vm.totalAge = ko.computed(function(){
    var years = 0;
    ko.utils.arrayForEach(vm.arr(), function(item){
      years += item.age();
    });
    return years;
  }); // arrayForEach();</pre></div><p>And of course, we get a total of the ages in our screenshot as follows:</p><div class="mediaobject"><img src="graphics/1028OS_04_14.jpg" alt="ko.utils.arrayForEach()"/></div></div><div class="section" title="ko.utils.compareArrays()"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>ko.utils.compareArrays()</h2></div></div></div><p>This allows you to compare arrays and return a collection, showing all items from both arrays. If the <a id="id205" class="indexterm"/>item did not exist in the second collection it will be shown as deleted. If the item is in the second set but not in the first set it will be shown as added. The <a id="id206" class="indexterm"/>return set will also show the index of the item where it exists.</p><p>Here is our View code for the last array example on <code class="literal">compareArrays</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;compareArrays() : 2 Color Arrays&lt;/h3&gt;
&lt;ul data-bind="foreach: diff"&gt;
  &lt;li&gt;&lt;span data-bind="text: $data.value + ' was ' + $data.status"&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>Our script code is once again simple, and hopefully by working through coding each of these by <a id="id207" class="indexterm"/>hand, they have become more natural to you also. Here is the <code class="literal">script</code> code:</p><div class="informalexample"><pre class="programlisting">vm.diff = ko.computed(function(){
  return ko.utils.compareArrays(vm.color_1(),vm.color_2());
}); // compareArrays()</pre></div><p>Here is the <a id="id208" class="indexterm"/>screenshot of our code running:</p><div class="mediaobject"><img src="graphics/1028OS_04_15.jpg" alt="ko.utils.compareArrays()"/></div><p>We wanted to include a console log from the browser developer tools as we thought Chrome showed the structure nicely:</p><div class="mediaobject"><img src="graphics/1028OS_04_16.jpg" alt="ko.utils.compareArrays()"/></div></div></div>
<div class="section" title="Purifying our computations"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Purifying our computations</h1></div></div></div><p>Now we are going to redo the <code class="literal">script</code> section of code using <code class="literal">pureComputed</code> versus <code class="literal">computed</code>. The <a id="id209" class="indexterm"/>term <code class="literal">pureComputed</code> was inspired by the concept of pure functions as a style of <a id="id210" class="indexterm"/>programming. It is nothing you need to understand to use so don't get caught up with the semantics of the name as there is no practical win as far as learning how these pure computations benefit us here.</p><p>When Knockout has something watching, a <a id="id211" class="indexterm"/>computed item is called a subscriber. Thus, it is considered to be a subscriber dependency. If we use the <code class="literal">pureComputed</code> method versus the <code class="literal">computed</code> method, Knockout will not calculate the value when there are no subscribers. This, of course, adds more speed to our processes by reducing calculations that aren't needed and unnecessary code from running. It is also another way to avoid any chance of memory issues.</p><p>When there are no subscribers, a pure computed observable is considered to be <span class="strong"><strong>sleeping</strong></span>. When there are subscribers it is considered to be <span class="strong"><strong>listening</strong></span>. The term listening is a bit odd for <a id="id212" class="indexterm"/>me as to me it would be <span class="strong"><strong>responding</strong></span>. It does make sense though, because it is a computing <a id="id213" class="indexterm"/>method. So it does need to listen to the values it is using to compute with. If any of those values change it needs to recalculate its results.</p><p>Here is the updated script code moved to the better <code class="literal">pureComputed</code> method:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
var vm = {};
jQuery.getJSON('utility.json').done(function(data){
  vm = ko.mapping.fromJS( data );
  vm.youngStaff = ko.pureComputed(function(){
    return ko.utils.arrayFilter(vm.arr(), function(item){
      if(item.age() &lt; 35) { return true; }
      return false;
    });
  });
  vm.firstRetire = ko.pureComputed(function(){
    return ko.utils.arrayFirst(vm.arr(), function(item){
      if(item.age() &gt; 45) return true;
      return false;
    });
  }); // arrayFirst
  vm.tillRetire = ko.pureComputed(function(){
    return ko.utils.arrayMap(vm.arr(),function(item){
      return 65 - item.age() + ' years till retirement.';
    })
  }); // arrayMap()
  vm.tillRetire2 = ko.pureComputed(function(){
    ko.utils.arrayMap(vm.arr(),function(item){
      item.yearsLeft = 65 –I tem.age() + ' years till retirement.';
    })
  }); // arrayMap()
  vm.allYears = ko.pureComputed(function(){
    return allYears = ko.utils.arrayMap(vm.arr(),function(item){
      return item.age();
    });
  }); // arrayMap()
  vm.uniqueYears = ko.pureComputed(function(){
    return ko.utils.arrayGetDistinctValues(vm.allYears().sort(),vm);
  }); // arrayGetDistinctValues()
  vm.totalAge = ko.pureComputed(function(){
    var years = 0;
    ko.utils.arrayForEach(vm.arr(), function(item){
      years += item.age();
    });
    return years;
  }); // arrayForEach();
  vm.diff = ko.pureComputed(function(){
    return ko.utils.compareArrays(vm.color_1(),vm.color_2());
  }); // compareArrays()
  ko.applyBindings(vm);
});
&lt;/script&gt;</pre></div><p>If you want to <a id="id214" class="indexterm"/>know how <a id="id215" class="indexterm"/>many dependencies an item has, you can look at the <code class="literal">getDependenciesCount</code> method. Type the following into your console in your browser developer tools:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vm.allYears.getDependenciesCount()</strong></span>
</pre></div><p>This will show you how many items are subscribing to the <code class="literal">allYears</code> computed method. There is also a function that will tell us the number of items that are subscribing to the <code class="literal">allYears</code> calculation method, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>vm.allYears.getSubscriptionsCount()</strong></span>
</pre></div></div>
<div class="section" title="Coding documents for computed observables"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Coding documents for computed observables</h1></div></div></div><p>We have included the following documents about observables just for reference here. While these were available online on the KnockoutJS site, it seemed like a good idea to include them here so you don't have to keep jumping between the website and the book.</p><p>A <a id="id216" class="indexterm"/>computed observable can be constructed using one of the following forms.</p><div class="section" title="Form 1"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Form 1</h2></div></div></div><p>The <code class="literal">ko.computed( evaluator [, targetObject, options] )</code> form supports <a id="id217" class="indexterm"/>the most common case of creating a computed observable. It has the following attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">evaluator</code>: This is a <a id="id218" class="indexterm"/>function that is used to evaluate the computed observable's current value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">targetObject</code>: If given, it <a id="id219" class="indexterm"/>defines the value of <code class="literal">this</code> whenever Knockout invokes your callback functions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">options</code>: This is <a id="id220" class="indexterm"/>an object with further properties for the computed observable. See the full list in the following section.</li></ul></div></div><div class="section" title="Form 2"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Form 2</h2></div></div></div><p>The <code class="literal">ko.computed( options )</code> parameter, is a single parameter form for creating a <a id="id221" class="indexterm"/>computed observable that accepts a JavaScript object with any of the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">read</code>: This is a<a id="id222" class="indexterm"/> required function and used to evaluate the computed observable's current value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">write</code>: This is <a id="id223" class="indexterm"/>an optional function and if given, this makes the computed observable writable. This function receives values that other code is trying to write to your computed observable. It's up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</li><li class="listitem" style="list-style-type: disc"><code class="literal">owner</code>: This is<a id="id224" class="indexterm"/> an optional function and, if given, it defines the value of <code class="literal">this</code> whenever Knockout invokes your <code class="literal">read</code> or <code class="literal">write</code> callbacks.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pure</code>: This is <a id="id225" class="indexterm"/>optional and if this is true, the computed observable will be set up as <code class="literal">purecomputed observable</code>. This option is an alternative to the <code class="literal">ko.pureComputed</code> constructor.</li><li class="listitem" style="list-style-type: disc"><code class="literal">deferEvaluation</code>: This is <a id="id226" class="indexterm"/>optional and if this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">disposeWhen</code>: This is <a id="id227" class="indexterm"/>an optional function and if given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">disposeWhenNodeIsRemoved</code>: This is an optional function. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by <a id="id228" class="indexterm"/>Knockout. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.</li></ul></div></div><div class="section" title="Form 3"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Form 3</h2></div></div></div><p>The <code class="literal">ko.pureComputed( evaluator [, targetObject] )</code> form constructs <code class="literal">pure computed observable</code> using the given evaluator function and optional object to <a id="id229" class="indexterm"/>use for <code class="literal">this</code>. Unlike <code class="literal">ko.computed</code>, this method doesn't accept an <code class="literal">options</code> <a id="id230" class="indexterm"/>parameter.</p></div><div class="section" title="Form 4"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Form 4</h2></div></div></div><p>The <code class="literal">ko.pureComputed( options )</code> form constructs a pure computed observable using <a id="id231" class="indexterm"/>an <code class="literal">options</code> object. This accepts the <code class="literal">read</code>, <code class="literal">write</code>, and <code class="literal">owner</code> options described <a id="id232" class="indexterm"/>previously.</p></div></div>
<div class="section" title="Using a computed observable"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Using a computed observable</h1></div></div></div><p>A computed <a id="id233" class="indexterm"/>observable provides the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dispose()</code>: This <a id="id234" class="indexterm"/>manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won't be cleaned.</li><li class="listitem" style="list-style-type: disc"><code class="literal">extend(extenders)</code>: This <a id="id235" class="indexterm"/>applies the given extenders to the computed observable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getDependenciesCount()</code>: This returns the current number of dependencies of the <a id="id236" class="indexterm"/>computed observable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getSubscriptionsCount()</code>: This <a id="id237" class="indexterm"/>returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">isActive()</code>: This<a id="id238" class="indexterm"/> returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</li><li class="listitem" style="list-style-type: disc"><code class="literal">peek()</code>: This returns the<a id="id239" class="indexterm"/> current value of the computed observable without creating a dependency.</li><li class="listitem" style="list-style-type: disc"><code class="literal">subscribe( callback [,callbackTarget, event] )</code>: This registers <code class="literal">manual subscription</code><a id="id240" class="indexterm"/> to be notified of changes to the computed observable.</li></ul></div></div>
<div class="section" title="Using the computed context"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Using the computed context</h1></div></div></div><p>During the <a id="id241" class="indexterm"/>execution of a computed observable's evaluator function, you can access <code class="literal">ko.computedContext</code> to get information about the current computed property. It provides the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isInitial()</code>: This is a<a id="id242" class="indexterm"/> function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For <code class="literal">pure</code> computed observables, <code class="literal">isInitial()</code> is always undefined.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getDependenciesCount()</code>: This returns the number of dependencies of the computed<a id="id243" class="indexterm"/> observable <a id="id244" class="indexterm"/>detected so far during the current evaluation.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>The <code class="literal">ko.computedContext.getDependenciesCount()</code> function is equivalent to calling <code class="literal">getDependenciesCount()</code> on the computed observable itself. The reason that it also exists on <code class="literal">ko.computedContext</code> is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</p></div></div></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Summary</h1></div></div></div><p>This chapter opens up a whole load of features and options to make web style coding powerful and elegant. Learning to let a library handle things for you is hard for some but that perspective is ironic as we are programming computers for others to let our work manage things for them. This chapter has added several valuable skills and options to our knowledge and experience:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have learned to integrate data management in Knockout using JSON as an alternate way to pass data in and out.</li><li class="listitem" style="list-style-type: disc">We have seen the incredible power of mapping to make our code another magnitude of elegant using Knockout.</li><li class="listitem" style="list-style-type: disc">We have been introduced to the basics of using AJAX with Knockout.</li><li class="listitem" style="list-style-type: disc">We have learned how to use utility functions for more advanced collection features, and again with less lines of code.</li><li class="listitem" style="list-style-type: disc">Lastly, we learned how to improve the performance of our ViewModel using pure oriented compute functions (with a bonus clip of compute documents from the KnockoutJS online documents).</li></ul></div><p>In our next chapter we will be looking at another way of packaging things to make our code shorter, more approachable, and more sustainable. Templates were once the domain of backend servers. The next chapter will show you why you need to do less on the backend and more on the frontend than ever before!</p></div></body></html>