- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we’ve learned how we can use Node.js to build applications.
    As with all software, you must take certain precautions to ensure the application
    you’re building is secure.
  prefs: []
  type: TYPE_NORMAL
- en: First, you should ensure that you’ve adopted any Node.js releases that contain
    security fixes. For this reason, where possible, you should aim to be on the latest
    release of a given Node.js release line.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover some of the key aspects of Node.js web application security.
    The later recipes demonstrate some of the common attacks on web applications,
    including **cross-site scripting** ( **XSS** ) and **cross-site request forgery**
    ( **CSRF** ) attacks. They will showcase how to prevent and mitigate the risk
    of some of these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting dependency vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication with Fastify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening headers with Helmet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anticipating malicious input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing JSON pollution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guarding against XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have Node.js installed, preferably the latest version of Node.js
    22, and access to an editor and browser of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the recipes, we’ll be installing modules from the **npm** registry
    – therefore, an internet connection will be required.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the recipes in this chapter is available in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    , in the *Chapter* *09* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting dependency vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we’ve leveraged modules from the **npm** registry to form
    a foundation for the applications we build. We’ve learned how the vast module
    ecosystem enables us to focus on application logic and not have to reinvent common
    technical solutions repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: This ecosystem is key to Node.js’s success. However, it does lead to large,
    nested dependency trees within our applications. Not only must we be concerned
    with the security of the application code that we write ourselves, but we must
    also consider the security of the code included in the modules in our dependency
    tree. Even the most mature and popular modules and frameworks may contain security
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll demonstrate how to detect vulnerabilities in a project’s
    dependency tree.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we’ll create a directory named **audit-deps** where we can
    install some Node.js modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need to add any further code as we’ll be focusing on learning how to
    audit the dependencies using the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll install some modules from the **npm** registry and scan
    them for vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s install an old version of the **express** module. We’ve intentionally
    chosen an old version with known vulnerabilities to demonstrate how to audit our
    dependencies. This version of Express.js is not recommended for use in production
    applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the **npm** output detects eight known vulnerabilities in this
    version of Express.js.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As the output suggests, run the **$ npm audit** command for more details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe the output of the **$ npm audit** command, as shown in the following
    screenshot. The output lists the individual vulnerabilities, along with further
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – npm audit output for express@4.16.0](img/B19212_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – npm audit output for express@4.16.0
  prefs: []
  type: TYPE_NORMAL
- en: 'We can follow the GitHub links specified in the console output to navigate
    to the advisory for the particular vulnerability. This will open a web page detailing
    an overview of the vulnerability and remediation actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Example npm vulnerability advisory](img/B19212_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Example npm vulnerability advisory
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to automatically fix the vulnerabilities by using the **$ npm audit
    fix** command. This will attempt to update any dependencies to fixed versions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when we rerun the **$ npm audit** command, we’ll get the following output,
    indicating that there are no longer any known vulnerabilities being detected in
    our module dependency tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we’ve learned how to use **$ npm audit** to scan for vulnerabilities
    in our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **$ npm audit** command has been available since **npm** version 6. The
    command submits a report of the dependencies in our application and compares it
    with a database of known vulnerabilities. The **$ npm audit** command will audit
    direct, development, bundled, and optional dependencies. However, it does not
    audit peer dependencies. The command requires both a **package.json** file and
    a **package-lock.json** file to be present; otherwise, it will fail. The audit
    automatically runs when a package is installed with the **$ npm** **install**
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations consider **$ npm audit** to be a precautionary measure to
    protect their applications against known security vulnerabilities. For this reason,
    it is common to add the **$ npm audit** command to your **continuous integration**
    ( **CI** ) testing. The **$ npm audit** command reports an error code of **1**
    when a vulnerability is found; this error code can be leveraged to indicate a
    failed test.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used the **$ npm audit fix** command to automatically update
    our dependencies to fixed versions. This command will only upgrade dependencies
    to later minor or patch versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should a vulnerability only be fixed in a new major version, **npm** will output
    a warning indicating the fix is available via **npm audit fix --force** , as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – npm audit output showing breaking change resolution](img/B19212_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – npm audit output showing breaking change resolution
  prefs: []
  type: TYPE_NORMAL
- en: Fixes that require updates to a new major release will not be automatically
    fixed by the **$ npm audit fix** command as you may need to update your application
    code to accommodate the breaking change in the dependency. It is possible to override
    this behavior and force **npm** to update all dependencies, even if they include
    breaking changes, using the **$ npm audit fix --force** command. However, in the
    case of a breaking change, it would be prudent to review the individual module
    vulnerabilities and manually update the modules one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, a patched version of a dependency may not be available. In this
    case, **npm** will inform you that a manual review is required. During this manual
    review, it’s worthwhile trying to determine whether your application is susceptible
    to the vulnerability. Some vulnerabilities will only apply to the use of certain
    APIs, so if you’re not using those APIs in your application, you may be able to
    discount the specific vulnerability. If the vulnerability applies to your application
    and there’s no patched version of the dependency available, you should consider
    patching it within your application’s **node_modules** , if possible. A common
    approach to achieve this is using the **patch-package** ( [https://www.npmjs.com/package/patch-package](https://www.npmjs.com/package/patch-package)
    ) module from **npm** .
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In general, it’s worthwhile keeping your application’s dependencies as up-to-date
    as possible to ensure you have the latest available bugs and security fixes. Tools
    such as **Dependabot** ( [https://dependabot.com/](https://dependabot.com/) )
    can help keep your dependencies up to date by automating updates on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Note that **npm audit** works by comparing your dependency tree against a database
    of known vulnerabilities. Having **npm audit** return no known vulnerabilities
    doesn’t mean your dependencies aren’t vulnerable – there could, and likely are,
    unreported or unknown vulnerabilities in your tree. There are also commercial
    services that provide module dependency vulnerability auditing services. Some
    of these, such as **Snyk** ( [https://snyk.io/](https://snyk.io/) ), maintain
    their own weakness and vulnerability databases, which may contain a different
    set of known issues to audit your dependencies against.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are additional options available when using **npm audit** so that you
    can tailor it to your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**--audit-level <level>** : Allows you to specify the minimum vulnerability
    level that **npm audit** should report on. The levels include **info** , **low**
    , **moderate** , **high** , and **critical** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--dry-run** : Simulates the action of fixing vulnerabilities without applying
    any changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--force** : Forces vulnerable dependencies to be updated, bypassing certain
    checks such as peer dependency compatibility. This option should be used with
    caution as it can lead to dependency conflicts or introduce breaking changes within
    your project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--json** : Outputs the audit results in JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--package-lock-only** : Restricts the audit to project dependencies defined
    in the **package-lock.json** or **npm-shrinkwrap.json** files, without requiring
    an actual install.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--no-package-lock** : Ignores the project’s **package-lock.json** or **npm-shrinkwrap.json**
    files during the audit. This can be useful when you want to audit the state of
    the **node_modules** directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--omit** and **--include** : Allow you to configure which types of dependencies
    (development, optional, or peer dependencies) to exclude or include in the audit
    process, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to using **npm audit** , you can leverage GitHub’s Dependabot to
    enhance your project’s security and keep your dependencies up to date. Dependabot
    automates the process of checking for vulnerabilities and creating pull requests
    to update your dependencies. It continuously monitors your project’s dependencies
    and alerts you if it detects any vulnerabilities. Dependabot can automatically
    open pull requests to update outdated dependencies to their latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: By integrating Dependabot with your GitHub repository, you can ensure that your
    project stays current with the latest security patches and updates, reducing the
    risk of potential vulnerabilities. Please refer to [https://docs.github.com/en/code-security/dependabot](https://docs.github.com/en/code-security/dependabot)
    for GitHub guidelines on enabling and using Dependabot.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **npm** documentation for **npm** **audit** : [https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities](https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Consuming Node.js modules* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication with Fastify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many web applications require a login system. Often, users of a website have
    different privileges, and to determine which resources they can access, they must
    first be identified through authentication.
  prefs: []
  type: TYPE_NORMAL
- en: This is typically achieved by setting up a session, which is a temporary information
    exchange between a user and a device. Sessions enable the server to store user-specific
    information, which can be used to manage access and maintain the user’s state
    across multiple requests.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll implement an authentication layer for a Fastify server.
    Please refer to [*Chapter 6*](B19212_06.xhtml#_idTextAnchor178) for more information
    on Fastify.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a Fastify server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project directory named **fastify-auth** to work in and initialize
    the project with **npm** . We’ll also create some files and subdirectories that
    we’ll use later in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need to install several modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the **server.js** file. This will configure an initial
    Fastify server that we’ll extend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **routes/index.js** to create a base router that will
    handle an HTTP **GET** request on **/** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **views/index.ejs** to create an **Embedded JavaScript**
    ( **EJS** ) template. For now, this will just be a simple welcome page template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the server with the following command and navigate to **http://localhost:3000**
    in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should expect to see a web page titled **Authenticating with Fastify** .
    Stop the server using *Ctrl* + *C* .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a simple Fastify server, we can start implementing the authentication
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll add a login system to our Fastify server using the **@fastify/cookie**
    and **@** **fastify/session** modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll create a separate router to handle authentication, as well as an EJS
    template that will contain our HTML login form. Let’s create those files now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create our HTML login form using an EJS template. The HTML form
    will have two fields: **username** and **password** . This template will expect
    to be passed a value named **fail** . When the fail value is **true** , the **Login
    Failed.** message will be rendered. Add the following code to **views/login.ejs**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to build our authentication router. We’ll do this in the **routes/auth.js**
    file. The authentication router will contain route handlers for the **/login**
    and **/logout** endpoints. The **/login** endpoint will require both an HTTP **GET**
    and an HTTP **POST** handler. The HTTP **POST** handler for the **/login** endpoint
    will receive and parse the form data (username and password) to validate the user
    credentials. Add the following to **routes/auth.js** to create the authentication
    router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to update our **routes/index.js** file so that we can pass the
    user data from the session to the EJS template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the imports for **@fastify/cookie** and **@fastify/session** alongside
    the other imports in the **server.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the **auth** router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register the plugins with the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register **authRoutes** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to **http://localhost:3000** in your browser. Expect to see the following
    web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Web page depicting “Authentication with Fastify”](img/B19212_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Web page depicting “Authentication with Fastify”
  prefs: []
  type: TYPE_NORMAL
- en: Click **Login** ; you’ll be directed to the HTML login form. Supply a random
    username and password and click **Login** . Since this doesn’t match our hardcoded
    values, we expect to see the **Login** **Failed.** message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s try the hardcoded values. Supply a username of **beth** and a password
    of **badpassword** and click **Login** . The login process should be successful.
    You will redirect back to the **/** endpoint, where there will be a **Hello**
    **beth!** message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, let’s try and log out. Click the **Logout** link. This should redirect
    you back to the same endpoint, but the **Hello beth!** message will be removed
    as the session has ended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe introduced the **@fastify/cookie** and **@fastify/session** modules
    and how we can use them to build a simple login functionality. Now, let’s see
    how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we built a login system using the **@fastify/cookie** and **@**
    **fastify/session** modules.
  prefs: []
  type: TYPE_NORMAL
- en: First, we imported and registered the **@fastify/session** plugin in the Fastify
    application (in the **server.js** file). This plugin injects a session object
    into every request object. Before the user is authenticated, the session value
    will be an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When registering the **@fastify/session** plugin, we provided the following
    configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secret** : Used to sign the session ID cookie, ensuring its integrity and
    preventing tampering. It must be at least 32 characters long for security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie.httpOnly** : Configures the session cookie. Note that **httpOnly:
    true** makes the cookie inaccessible to client-side JavaScript, enhancing security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SaveUninitialized** : Prevents saving unmodified sessions to the store, reducing
    storage usage and improving performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resave** : Prevents resaving unchanged sessions, reducing unnecessary write
    operations to the session store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full list of configuration options is available in the **@fastify/session**
    API documentation at [https://github.com/fastify/session?tab=readme-ov-file#api](https://github.com/fastify/session?tab=readme-ov-file#api)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe’s demo application, the login hyperlink on the web page redirects
    the user to the **/auth/login** endpoint. The route handler for this endpoint
    was declared in a separate authentication router ( **routes/auth.js** ). This
    route renders the **views/login.ejs** template, which contains the HTML login
    form.
  prefs: []
  type: TYPE_NORMAL
- en: When the user enters their username and password in the form and clicks **Submit**
    , the browser encodes the values and sets them as the request body. Our HTML form
    had its method set to HTTP **POST** ( **method="post"** ), which instructs the
    browser to send an HTTP **POST** request when the form is submitted. The **action**
    attribute in our HTML form was set to **login** , which instructs the browser
    that the HTTP **POST** request should be sent to the **/** **auth/login** endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In **routes/auth.js** , we registered a handler for HTTP **POST** requests to
    the **/login** endpoint. This handler extracts the username and password from
    the request body and checks whether they match any user in our hardcoded array
    of users. If the credentials are valid, it saves the user information in the session
    and renders the **index.ejs** template with the user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the username and password don’t match, our HTTP **POST** **/auth/login**
    route handler renders the **views/login.ejs** template with the **{ fail : true
    }** value. This instructs the **views/login.ejs** template to render the **Login**
    **Failed.** message.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t store passwords in plain text in production applications! You’d typically
    validate the supplied username and password against credentials stored in a secure
    database, with the password being stored in a hashed form. Refer to the *There’s
    more…* section of this recipe on hashing with **bcrypt** .
  prefs: []
  type: TYPE_NORMAL
- en: When the authentication process is successful, we set the **req.session.user**
    value to the supplied username and redirect the authenticated user back to the
    **/** endpoint. At this point, the **@fastify/session** middleware creates a session
    identifier and sets the **Set-Cookie** HTTP header on the request. The **Set-Cookie**
    header is set to the session key name and session identifier.
  prefs: []
  type: TYPE_NORMAL
- en: The **@fastify/session** plugin defaults to using an in-process storage mechanism
    to store the session tokens. However, these tokens are not expired, which means
    our process will continue to be populated with more and more tokens. This could
    eventually result in degraded performance or crash our process. Again, in production,
    you’d typically use a session store. The **@fastify/session** plugin is based
    on the **express-session** list of compatible session stores at [https://github.com/expressjs/session#compatible-session-stores](https://github.com/expressjs/session#compatible-session-stores)
    .
  prefs: []
  type: TYPE_NORMAL
- en: When the request is redirected to **/** , it now has the **Set-Cookie** HTTP
    header set. The **@fastify/session** middleware recognizes the session key name
    and extracts the session identifier. From this identifier, **@fastify/session**
    can query session storage for any associated state. In this case, the state is
    the user object that we assign to the **req.session** object in **auth.js** .
  prefs: []
  type: TYPE_NORMAL
- en: The **req.session.user** value is passed through to the updated **views/index.ejs**
    template. This template contains logic such that when a **req.session.user** value
    is present, it will render the **Hello beth!** string. The logic in the template
    also switches between showing the **Login** or **Logout** link, depending on whether
    the user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking **Logout** sends an HTTP **GET** request to the **/auth/logout** endpoint.
    This endpoint sets **req.session** to **null** , which ends the session and removes
    session data from the session store. Our browser may continue to store and send
    the invalid session cookie until it expires, but with no valid match in the session
    store, the server will ignore the session and consider the user unauthenticated.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following sections will cover secure session cookies and a simple example
    of how to hash a password.
  prefs: []
  type: TYPE_NORMAL
- en: Secure session cookies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Session cookies can be marked with a **Secure** attribute. The **Secure** attribute
    forces the browser to not use HTTP to send cookies back to the server. This is
    to avoid **man-in-the-middle** ( **MITM** ) attacks. In production applications,
    HTTPS and secure cookies should be used. But in development, it’s easier to use
    HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: It’s typical for a production environment to apply SSL encryption at the load
    balancer layer. A load balancer is a technology in an application architecture
    that’s responsible for boosting the efficiency of the application by distributing
    a set of tasks over a set of resources – for example, distributing login requests
    to servers.
  prefs: []
  type: TYPE_NORMAL
- en: We can configure our Fastify server to communicate with a load balancer over
    HTTP but still support **Secure** cookies using the appropriate cookie settings.
    In production, the **Secure** option for cookies should be set to true.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing with bcrypt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passwords should never be stored in plain text and should instead be stored
    in a hashed form. Passwords are transformed into a hashed form using a **hashing
    function** . Hashing functions use an algorithm to transform a value into unrecognizable
    data. The transformation is one-way, meaning it’s unlikely to be possible to determine
    the value from the hash. A website will validate a user’s password input by applying
    the hashing function to the supplied password and comparing it to the stored hash.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing is typically combined with a technique called **salting** . Salting
    is where a unique value, referred to as the *salt* , is appended to the password
    before the hash is generated. This helps to protect against brute-force attacks
    and makes it more difficult to crack the password.
  prefs: []
  type: TYPE_NORMAL
- en: '**bcrypt** ( [https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt)
    ) is a popular module that’s used to hash passwords in Node.js. The following
    example demonstrates how to generate a hash with a salt using the **bcrypt** module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create and initialize a directory named **hashing-with-bcrypt** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, install the **bcrypt** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our program will expect the password to be supplied as an argument. Add the
    following to **hash.js** to extract the argument value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in **hash.js** , import the **bcrypt** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must define the number of salt rounds. Here, **bcrypt** will generate
    a salt using the specified number of rounds. The higher the number of rounds,
    the more secure the hash will be. However, it will also take longer to generate
    and validate the hash in your application. In this example, we’ll set the number
    of salt rounds to **10** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to call the **bcrypt** module’s **hash()** method. We supply
    this method with the plain text password, the number of salt rounds, and the callback
    function to be executed once the hash has been generated. Our callback will output
    the hashed form of the password using **conosle.log()** . Add the following to
    **hash.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a real application, you’d expect to include your logic to persist the hash
    to a database within the callback function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the program with the following command. You should expect a unique hash
    to be generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each time this script is run, a new unique hash will be generated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s learn how we can validate the password. We’ll create a program
    that expects both the password and the hash as arguments. The program will compare
    the password and hash using the **bcrypt.compare()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that **res** will be **true** when the password and hash match and **false**
    when they don’t.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the **validate-password.js** program. The first argument should be the
    same password you supplied to the **hash.js** program. The second argument should
    be the hash that your **hash.js** program created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the argument values should be wrapped in single quotes to ensure the
    literal values are preserved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This demonstrates how we can use the **bcrypt** module to create a hash, as
    well as how to validate a value against an existing hash.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Implementing authentication with hooks* recipe in [*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Guarding against cross-site scripting* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preventing cross-site request forgery* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening headers with Helmet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js is a lightweight web framework, so certain measures that are typically
    taken to better secure applications are not implemented by the core framework.
    One of the precautionary measures we can take is to set certain security-related
    HTTP headers on requests. Sometimes, this is referred to as *hardening* the headers
    of our HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: The **Helmet** module ( [https://github.com/helmetjs/helmet](https://github.com/helmetjs/helmet)
    ) provides a middleware to set security-related headers on our HTTP requests,
    saving time on manual configuration. Helmet sets HTTP headers to reasonable and
    secure defaults, which can then be extended or customized as needed. In this recipe,
    we’ll learn how to use the Helmet module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll be extending an Express.js application so that it can use the Helmet
    module. So, first, we must create a basic Express.js server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory named **express-helmet** and initialize the project with
    **npm** . We’ll also install the **express** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we’ve created our base Express.js application, we’re ready to move
    on to the steps to complete this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to learn how to use the Helmet module to harden
    the HTTP headers of our Express.js application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the Express.js web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s inspect the headers that our Express.js application returns. We
    can do this using the *cURL* tool. In a second terminal window, enter the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a response similar to the following that lists the HTTP headers
    returned on the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the **X-Powered-By:** **Express** header.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s start hardening these headers with the **helmet** module. Install
    the **helmet** module with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to import the **helmet** middleware in the **app.js** file. Do this
    by adding the following line just below the **express** import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to instruct the Express.js application to use the **helmet**
    middleware. Below the **const app = express();** line, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, restart the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the *cURL* request again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we can see that many additional headers are returned on the
    request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the **X-Powered-By** header has been removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, we’ve added the **helmet** middleware to our Express.js server and
    observed the changes it makes to the HTTP headers returned from our request.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **helmet** module configures some of the HTTP headers on our requests based
    on its security defaults. In this recipe, we applied the **helmet** middleware
    to our Express.js server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **helmet** module removes the **X-Powered-By: Express** header so that
    discovering the server is Express-based becomes more difficult. The reason that
    we’ve obfuscated this is to protect against attackers trying to exploit Express.js-oriented
    security vulnerabilities, slowing them down in determining the type of server
    being used in the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, **helmet** injects the following headers into our request, along
    with the appropriate defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Header** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Content-Security-Policy** | Helps mitigate against XSS attacks by allowing
    a policy to be defined that can control which resources the user agent is allowed
    to load |'
  prefs: []
  type: TYPE_TB
- en: '| **Cross-Origin-Opener-Policy** | Ensures that a top-level document can only
    interact with documents from the same origin |'
  prefs: []
  type: TYPE_TB
- en: '| **Cross-Origin-Resource-Policy** | Restricts resources so that they can only
    be accessed by same-origin documents |'
  prefs: []
  type: TYPE_TB
- en: '| **Origin-Agent-Cluster** | Ensures a document is isolated in a separate agent
    cluster to prevent data leaks between different origins |'
  prefs: []
  type: TYPE_TB
- en: '| **Referrer-Policy** | Controls how much referrer information is included
    with requests sent from a site |'
  prefs: []
  type: TYPE_TB
- en: '| **Strict-Transport-Security** | Instructs browsers to only allow the website
    to be accessed using HTTPS |'
  prefs: []
  type: TYPE_TB
- en: '| **X-Content-Type-Options** | Indicates that the MIME types configured in
    the **Content-Type** headers must be adhered to |'
  prefs: []
  type: TYPE_TB
- en: '| **X-DNS-Prefetch-Control** | Controls DNS prefetching |'
  prefs: []
  type: TYPE_TB
- en: '| **X-Download-Options** | Disables the option to open a file on download |'
  prefs: []
  type: TYPE_TB
- en: '| **X-Frame-Options** | Indicates whether a browser can render a page in a
    **<frame>** , **<iframe>** , **<embed>** , or **<object>** HTML element |'
  prefs: []
  type: TYPE_TB
- en: '| **X-Permitted-Cross-Domain-Policies** | Instructs the browser on how to handle
    requests over a cross-domain |'
  prefs: []
  type: TYPE_TB
- en: '| **X-XSS-Protection** | Instructs the browser to stop page loading when a
    reflected XSS attack is detected |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: HTTP headers injected by Helmet and their use'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **helmet** module sets the injected HTTP headers to sensible secure defaults.
    However, they can be customized. For example, you could manually set the value
    of **Referrer-Policy** to the **no-referrer** header using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Additional HTTP headers can also be set using the **helmet** module. For more
    information, please refer to the Helmet documentation ( [https://helmetjs.github.io/](https://helmetjs.github.io/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other popular web frameworks can also integrate the **helmet** middleware
    via the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Koa.js** : [https://www.npmjs.com/package/koa-helmet](https://www.npmjs.com/package/koa-helmet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fastify** : [https://www.npmjs.com/package/@fastify/helmet](https://www.npmjs.com/package/@fastify/helmet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **helmet** middleware simply modifies the response headers to appropriate
    defaults. To demonstrate what **helmet** is doing under the covers, we can try
    injecting the same HTTP headers using the Node.js core **http** module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called **http-app** and create a **server.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the **server.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerun the *cURL* command and observe that the headers have been injected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These steps demonstrate how to manually inject HTTP security headers using the
    Node.js core **http** module, replicating the functionality provided by the **helmet**
    middleware. This example illustrates how **helmet** enhances security by setting
    various HTTP headers that mitigate common vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Guarding against cross-site scripting* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preventing cross-site request forgery* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anticipating malicious input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the easiest groups of vulnerabilities that hackers exploit is injection
    attacks, with SQL injection attacks being particularly common. SQL injection attacks
    are where an attacker injects malicious SQL into an application to delete, distort,
    or expose data stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: If an application accepts input in any form, you need to take necessary precautions
    to ensure that malicious inputs cannot exploit your application.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter pollution is a type of injection attack where the HTTP parameters
    of a web application’s HTTP endpoints are injected with specific malicious input.
    HTTP parameter pollution can be used to expose internal data or even cause a **denial
    of service** ( **DoS** ) attack, where an attacker tries to interrupt a resource
    and render it inaccessible to the resource’s intended users.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll look at how we can protect an HTTP server against parameter
    pollution attacks. Parameter pollution attacks are where malicious input is injected
    into URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll learn how to protect an Express.js server against an
    HTTP parameter pollution attack. But first, we must create this Express.js server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory named **express-input** for this recipe and initialize
    the project with **npm** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to install the Express.js module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to **server.js** . This will create an Express.js server
    that is susceptible to an HTTP parameter pollution attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the **asyncWork()** function is for demonstrational purposes only.
    In a real application, you could expect some asynchronous tasks to happen, such
    as a query to be made to a database or external service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we’ve created a vulnerable server, we’re ready to start this recipe,
    where we’ll demonstrate how to exploit this vulnerability and learn how to mitigate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve created an Express.js server that responds to the **/** request
    and handles a single parameter, **msg** . The Express.js server returns the **msg**
    value we pass it but in uppercase form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a second terminal window, we should test that the server is working as expected
    by sending a request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s see what happens when we pass the **msg** parameter twice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we go back to our first terminal window, we’ll see that the server
    has crashed with the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, it’s possible to cause the server to crash just by sending duplicate parameters.
    This makes it fairly easy for a perpetrator to launch an effective DoS attack.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The error message states **.toUpperCase is not a function** . The **toUpperCase()**
    function is available on **String.prototype** . This means that the value we call
    this function on is not of the **String.prototype** type, resulting in **TypeError**
    . This happened because the multiple **msg** values have been transformed into
    an array. To protect against this, we should add some logic so that we always
    take the last value of **msg** when multiple values are specified. Let’s add this
    logic to a copy of **server.js** , which we’ll name **fixed-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following two lines to our **asyncWork()** callback function within
    the HTTP **GET** request handler. The first line extracts the value of **req.query.msg**
    to a variable named **msg** . The second line will use the **array.pop()** method
    to override the value of **msg** with the final element of **Array** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the following line needs to be updated so that it references the **msg**
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the fixed server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s retry our request, where we pass the **msg** parameter twice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our logic to always set the **msg** variable to the last value is working. Observe
    that the server no longer crashes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, we’ve learned how URL parameters can be exploited to cause DoS attacks
    and how we can add logic to our code to guard against these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Injection attacks are made possible when inputs aren’t sanitized appropriately.
    In this recipe, we wrongly assumed that the **msg** parameter would only ever
    be a string.
  prefs: []
  type: TYPE_NORMAL
- en: Many Node.js web frameworks support duplicate parameters in URLs, despite there
    being no specification on how these should be handled.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js depends on the **qs** module for URL parameter handling. The **qs**
    module’s approach to handling multiple parameters of the same name is to convert
    the duplicate names into an array. As demonstrated in this recipe, this conversion
    results in code breakages and unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, our server crashed because it was trying to call the **toUpperCase()**
    function on an **Array** global object, which doesn’t exist on that type. This
    means that attackers have a very easily exploitable method of disabling servers
    by supplying malformed/malicious input. Other than enabling DoS-style attacks,
    not sanitizing and validating input parameters can lead to XSS attacks. XSS attacks
    will be covered in more detail in the *Guarding against XSS attacks* recipe of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js **Buffer** objects can be exploited by attackers if used incorrectly
    in application code. **Buffer** objects represent a fixed-length series of bytes
    and are a subclass of JavaScript’s **Uint8Array()** class. In many cases, you’ll
    be interacting with **Buffer** objects via higher-level APIs, such as using **fs.readFile()**
    to read files. However, in cases where you need to interact with binary data directly,
    you may use **Buffer** objects since they provide low-level fine-grained APIs
    for data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: In past years, a lot of attention was brought to the unsafe uses of Node.js’s
    **Buffer** constructor. Earlier concerns about using the **Buffer** constructor
    were regarding it not zero-filling new **Buffer** instances, leading to the risk
    of sensitive data being exposed via memory.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: All of the following examples were created via the Node.js REPL. The Node.js
    REPL can be started by entering **$ node** in your terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Node.js 6, calling **new Buffer(int)** would create a new **Buffer** object
    but not override any existing memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The security implications of this were recognized. By not overwriting the data
    when we initialize a new **Buffer** object, we could accidentally expose some
    of the previous memory. In the worst cases, this could expose sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in versions of Node.js later than version 8, calling **Buffer(int)**
    will result in a zero-filled **Buffer** object of **int** size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling **new Buffer(int)** is still deprecated and as of Node.js 22, using
    this constructor will emit a deprecation warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is because there are still security risks associated with using the new
    **Buffer(int)** constructor. Let’s demonstrate that risk now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that our application accepted some user input in JSON form and we created
    a **new Buffer()** object from one of the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that this works as expected (ignoring the deprecation warning).
    Calling **Buffer(string)** creates a new **Buffer** object containing the string
    value. Now, let’s see what happens if we set **msg** to a number rather than a
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This has created a **Buffer** object of size **10** . So, an attacker could
    pass any value via the **msg** property, and a **Buffer** object of that size
    would be created. A simple DoS attack could be launched by the attacker by supplying
    large integer values on each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deprecation warning recommends using **Buffer.from(req.body.string)** instead.
    Upon passing the **Buffer.from()** method, a number will throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This helps protect our code from unexpected input. To create a new **Buffer**
    object of a given size, you should use the **Buffer.alloc(int)** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a **Buffer.allocUnsafe()** constructor. The **Buffer.allocUnsafe()**
    constructor provides similar behavior to that seen in Node.js versions before
    Node.js 7, where the memory wasn’t entirely zero-filled on initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: For the reasons mentioned earlier, use the **Buffer.allocUnsafe()** constructor
    with caution.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Preventing JSON pollution* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Guarding against cross-site scripting* in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preventing cross-site request forgery* in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing JSON pollution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript language allows all **Object** attributes to be altered. In a
    JSON pollution attack, an attacker leverages this ability to override built-in
    attributes and functions with malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that accept JSON as user input are the most susceptible to these
    attacks. In the most severe cases, it’s possible to crash a server by just supplying
    additional values in JSON input. This can make the server vulnerable to DoS attacks
    via JSON pollution.
  prefs: []
  type: TYPE_NORMAL
- en: The key to preventing JSON pollution attacks is to validate all JSON input.
    This can be done manually or by defining a schema for your JSON to validate against.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to demonstrate a JSON pollution attack and learn
    how to protect against these attacks by validating our JSON input. Specifically,
    we’ll be using **Another JSON Schema Validator** ( **Ajv** ) to validate our JSON
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prepare for this recipe, we must create a server that’s susceptible to a
    JSON pollution attack. The server will accept **msg** and **name** as the body
    payload and respond with a message built with these values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a new directory named **json-pollution** to work in and
    initialize it with **npm** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a file named **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we’ve created our vulnerable server, we’re ready to start this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to demonstrate a JSON pollution attack and learn
    how to use a JSON schema to protect our applications from these attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll send an HTTP **POST** request to **http://localhost:3000** using
    *cURL* . We’ll supply the **curl** command with the **-X** argument to specify
    the HTTP request method and the **-d** argument to supply the data. In a second
    terminal window, send the following **cURL** request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As expected, the server responds with a greeting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s try altering the payload so that it sends an additional JSON property
    named **hasOwnProperty** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the empty reply from the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the terminal window where you’re running the server. You should see that
    it’s crashed with the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our server has crashed because the **hasOwnProperty()** function has been overridden
    by the **hasOwnProperty** value in the JSON input. We can protect against this
    by validating our JSON input using the Ajv module. So, install the Ajv module
    from **npm** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll copy our **server.js** file to a new file named **fixed-server.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to **fixed-server.js** to import the **ajv** module
    and define a JSON schema for our JSON input. Note that this code should be added
    just below the **STATUS_CODES** destructuring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The greeting function needs to be altered to validate the JSON input against
    the schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we’ve added a conditional statement that calls the **validate()** method
    within our **greeting()** function, which validates the schema.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the fixed server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retry the same request in an attempt to override the **hasOwnProperty()** method.
    Observe that it receives no response and no longer crashes the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we’ve protected our server against a JSON pollution attack by validating
    the input against a JSON schema.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we demonstrated a JSON pollution attack. To do this, we created
    a simple Express.js server that had one route handler for HTTP **POST** requests
    at **http://localhost:3000** . For each request, our **greeting()** function is
    called. The **greeting()** function parses the request data as JSON and then aggregates
    the **msg** and **name** values that were supplied as request parameters. The
    aggregated string is returned as the response to the request.
  prefs: []
  type: TYPE_NORMAL
- en: In our **server.js** file, we were using the **Object.prototype.hasOwnProperty()**
    method, which is a built-in method available on all objects. However, it was possible
    to override the **Object.prototype.hasOwnProperty()** method by passing a **hasOwnProperty**
    property in our JSON input. Because we set the **hasOwnProperty** value to **0**
    in our JSON input, the server crashed when our code attempted to call **data.hasOwnProperty()**
    – because that value had been overridden to **0** , rather than a function.
  prefs: []
  type: TYPE_NORMAL
- en: When a public-facing application accepts JSON input, it’s necessary to take
    steps in the application against JSON pollution attacks. One of the ways we covered
    for protecting applications from these attacks is by using a JSON Schema validator.
    It validated that the properties and values of our JSON input match those we expect.
    In this recipe, we used Ajv to define a schema to accomplish this. Ajv uses the
    **JSON Schema** ( [https://json-schema.org/](https://json-schema.org/) ) format
    to define object schemas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our schema required the JSON input to have a **msg** property and allow an
    optional **name** property. It also specified that both inputs must be of the
    **string** type. The **additionalProperties: false** configuration disallowed
    additional properties, causing the validation to fail when we supplied **hasOwnProperty**
    in the JSON input, making it impossible to override the **Object.prototype.hasOwnProperty**
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Anticipating malicious input* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Guarding against cross-site scripting* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preventing cross-site request forgery* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guarding against cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XSS attacks are client-side injection attacks where malicious scripts are injected
    into websites. XSS vulnerabilities are very dangerous as they can compromise trusted
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to demonstrate an XSS vulnerability and learn how
    we can protect against them. We’ll be using the **he** ( [https://www.npmjs.com/package/he](https://www.npmjs.com/package/he)
    ) **npm** module to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll create an Express.js server that’s vulnerable to an XSS
    attack. To do so, we must create the vulnerable Express.js server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a directory named **express-xss** to work in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to install **express** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file where you’ll store the Express.js server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **server.js** . This will create a server that renders
    a simple HTML web page that’s susceptible to an XSS attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we’re ready to move on to this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll learn how to exploit and mitigate XSS attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The server is emulating a service status web page. The web page accepts three
    parameters: **previous** , **token** , and **lang** . It’s common practice to
    have parameters such as these injected into URLs in real-world web applications.
    Navigate to **http://localhost:3000/?previous=/&token=TOKEN&lang=en** ; expect
    to see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Demonstrative service status web page showing “All systems are
    running.”](img/B19212_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Demonstrative service status web page showing “All systems are
    running.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can craft an XSS attack. We will craft a URL that will inject parameters
    to change the service status message to **All systems are down!** . We’re aiming
    to inject the following JavaScript via the URL parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can inject this script using the following HTTP request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the web page will show **All systems are down!** . So, visitors to our
    legitimate service status page will see a malicious message. These attacks typically
    send the malicious URL to an unsuspecting consumer of the website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Demonstrative service status web page showing “All systems are
    down!”](img/B19212_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Demonstrative service status web page showing “All systems are
    down!”
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the code that’s been injected by using the **View Page Source**
    interface in your browser. If you’re on macOS, you should be able to use the *Command*
    + *Option* + *U* shortcut to open the **View Page** **Source** interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – View Page Source showing the injected JavaScript](img/B19212_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – View Page Source showing the injected JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the application, we need to escape/sanitize the input. Copy the **server.js**
    file to a file named **fixed-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To escape or sanitize the input, we’ll use a module named **he** . Install
    **he** from the **npm** registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to add the import for **he** to **fixed-server.js** . Add the following
    line of code below the **express** module import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can set the **href** value using **he** . Alter the route handler
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the fixed server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attempt to access the malicious URL again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe that this time, we get the expected **All systems are running.** output.
    Our injection attack no longer works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Demonstrative service status web page showing “All systems are
    running.”](img/B19212_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Demonstrative service status web page showing “All systems are
    running.”
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve learned how to use the **he** module to prevent an XSS attack.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XSS attacks are client-side injection attacks where malicious scripts are injected
    into trusted websites. The general flow of an XSS attack is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Malicious input enters the application – typically via a web request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The input is rendered as dynamic content on the web page because the input hasn’t
    been sanitized appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two main types of XSS attacks are persistent XSS and reflected XSS. With
    persistent XSS attacks, malicious data is injected into a persistence layer of
    the system. For example, it could be injected into a field within a database.
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS attacks are reliant on a single interaction with the server –
    for example, sending a single HTTP request. The attack demonstrated in this recipe
    was a reflected XSS attack sent over an HTTP request containing malicious input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exploit in this recipe was due to the way the **href** value was formulated
    for the **Back** link. We started the injection process by assigning the **%22%3E%3Cscri**
    value, which, when decoded, is equal to **"><scri** . This value closes an HTML
    anchor tag and starts an HTML script element that’s ready to inject our script.
    The remaining values are set to inject the following code into the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Note that the attack wouldn’t have worked with a single parameter as many modern
    browsers have built-in XSS auditors to prevent the obvious injection of **<**
    **script>** tags.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can use Node.js’s **decodeURI()** method to decode encoded URIs. For example,
    **$ node -p "decodeURI('%22%3E%3Cscri')"** would output **"><scri** .
  prefs: []
  type: TYPE_NORMAL
- en: We fixed this vulnerability using the **he** module. We use the **he** module’s
    **encode()** function to do so. This function accepts text that’s expected to
    be HTML or XML input and returns it in escaped form. This is how we sanitize the
    input and stop the **<script>** tag from being injected into the web page.
  prefs: []
  type: TYPE_NORMAL
- en: All input to our server should be validated and sanitized before use. This includes
    indirect inputs to data stores as these may be used to conduct persistent XSS
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some other types of XSS attacks that we can still use to harm our
    server. Let’s demonstrate these attacks and learn how we can help prevent them.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol-handler XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fixed server from this recipe is still vulnerable to some other types of
    XSS. In this scenario, we’ll pretend that the status value is privileged information
    that the attacker shouldn’t be able to read.
  prefs: []
  type: TYPE_NORMAL
- en: The flow of this attack is to create a malicious data collection server that
    injects a script into the web page that obtains the information and then forwards
    it to the data collection server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we need to create a data collection server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'While still in the **express-xss** directory, create a file named **colletion-server.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following code to **collection-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can start the data collection server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a second terminal window, restart the **fixed-server.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your browser window, visit the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The web page should look the same as before, still showing the **All systems
    are running.** message. However, the XSS injection has updated the **href** value
    of the **Back** hyperlink so that it directs us to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The link starts with **javascript:** , which is a protocol handler that allows
    JavaScript execution as a URI. When this link is clicked, an HTML image element
    ( **<img>** ) is created with the **src** value set to the address of our data
    collection server. The **btoa()** function Base64 encodes the value of the status.
    Here, **,0** is appended to the end to cause the expression to evaluate to **false**
    – ensuring that the image isn’t rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click the **Back** link and check the data collection server. You’ll see that
    the status has been received, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To highlight the dangers of these attacks, imagine that this was real privileged
    data, such as credentials or tokens. By just sending a malicious link to a user
    and having them click on it, we could obtain their sensitive data via our collection
    server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The server is still vulnerable because we can still inject values into the
    **href** attribute. The safest way to avoid this is by not allowing input to determine
    the value of the **href** attribute:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s copy **fixed-server.js** to a new file and fix it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll fix this vulnerability by installing the **escape-html** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the **escape-html** module in **fixed-server.js** by replacing the **he**
    module import with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, change the **href** assignment to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start **protocol-safe-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the data collection server still running, revisit the malicious URL and
    click **Back** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ll observe that the request fails, and the data collection server doesn’t
    receive the privileged data. This is because the link to our malicious server
    has been sanitized.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered HTML encoding and modules that can be used to help escape
    HTML. Similarly, for escaping JavaScript, the **jsesc** module ( [https://www.npmjs.com/package/jsesc](https://www.npmjs.com/package/jsesc)
    ) could be used. However, embedding input into JavaScript is generally considered
    high risk, so you should evaluate your reasons for doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The browser can only show a portion of a very long URL in the address bar. This
    means that for very long URLs with many parameters, you may not see what’s appended
    to the end of the URL. This makes it more challenging to identify malicious URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your application’s typical usage doesn’t involve very long URLs, then it
    would be prudent to add some constraints to what URLs your application will accept.
    Let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the **server.js** file to a new file named **constraints-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a **validateParameters()** function that validates the URL parameters
    in the **constraints-server.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to make a call to the **validateParameters()** function in our
    request handler. Change the request handler to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start **constraints-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test by navigating to the following URLs, all of which should fail validation
    checks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter&lang=en&extra=value**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http://localhost:3000/?previous=characters&token=sixteencharacter&lang=abc**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following URL should work as it satisfies all of the constraints:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**http://localhost:3000/?previous=sixteencharacter&token=sixteencharacter&lang=en**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any user input should be escaped and validated where possible to help prevent
    XSS injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Anticipating malicious input* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preventing JSON pollution* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preventing cross-site request forgery* in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing cross-site request forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSRF is an attack where a malicious web application causes a user’s web browser
    to execute an action on another trusted web application where the user is logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to learn how to secure an Express.js server against
    CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Browser security has improved significantly in recent years. It’s very difficult
    to replicate a CSRF attack on any modern browser. However, as there are still
    many users on older browsers, it’s important to understand how these attacks work
    and how to protect against them. In this recipe, we’ll replicate a CSRF attack
    on the same domain. Please refer to the *Developers: Get Ready for New SameSite=None;
    Secure Cookie Settings* ( [https://blog.chromium.org/2019/10/developers-get-ready-for-new.html](https://blog.chromium.org/2019/10/developers-get-ready-for-new.html)
    ) Chromium blog, which covers some of the updates that have been made to Google
    Chrome to prevent CSRF attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a directory named **express-csrf** for this recipe and initializing
    the project with **npm** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named **server.js** . This will contain our server, which is
    vulnerable to CSRF attacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **server.js** , import the required modules and register the **express-session**
    middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in **server.js** , we need to define the routes for our server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following to **server.js** to start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we’re ready to start this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we’ll create a malicious web page that can replicate a CSRF attack. After
    that, we’ll learn how to protect our Express.js server against these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your steps should be formatted like so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to **http://localhost:3000** in your browser and expect to see the
    following HTML login form. Enter **beth** as the username and **badpassword**
    as the password. Then, click **Submit** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Social Media Account – Login](img/B19212_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Social Media Account – Login
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged in, you should be taken to the **Settings** page of the demo social
    media profile. Notice that there’s a single field to update your email. Try updating
    the email to something else. You should see that the update is reflected after
    clicking **Update** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Social Media Account – Settings](img/B19212_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Social Media Account – Settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’re going to create our malicious web page. Create a file named **csrf-server.js**
    . This is where we’ll build our malicious web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to create the malicious web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a second terminal window, start the **csrf-server.js** server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In a real CSRF attack, we’d expect the attack to come from a different domain
    to the vulnerable server. However, due to advances in web browser security, many
    CSRF attacks are prevented by the browser. For this recipe, we’ll demonstrate
    the attack on the same domain. Note that CSRF attacks are still possible today,
    particularly as many users may be using older browsers that don’t have the latest
    security features to protect against CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **http://localhost:3001** in your browser. Expect to see the following
    output showing a single button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Malicious CSRF web page showing a suspicious “Click this to
    win!” button](img/B19212_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Malicious CSRF web page showing a suspicious “Click this to win!”
    button
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Click this to win!** button. By clicking the button, an HTTP **POST**
    request is sent to **http://localhost:3000/update** , with a body containing the
    **attacker@example.com** email. By clicking this button, the HTTP **POST** request
    has been sent to the real website’s server, leveraging the cookie stored in the
    browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to the social media profile page and refresh it. We’ll see that the
    attacker has managed to update the email address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – The Social Media Account – Settings page showing that the email
    has been updated to attacker@example.com](img/B19212_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – The Social Media Account – Settings page showing that the email
    has been updated to attacker@example.com
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s fix the server so that it isn’t susceptible to CSRF attacks. First,
    copy the **server.js** file to a file named **fixed-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To fix the server, we need to add some additional configuration to the **express-session**
    middleware. Change the **express-session** configuration to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the addition of the **{ cookie : { sameSite : true }}** configuration.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, having stopped the original server, start **fixed-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return to **http://localhost:3000** and log in again with the same credentials
    as before. Then, in a second browser tab, visit **http://127.0.0.1:3001** ( **csrf-server.js**
    should still be running) and click the button again. Note that you must navigate
    using **http://127.0.0.1:3001** rather than **http://localhost:3001** ; otherwise,
    the request will be considered as coming from the same domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You’ll find that this time, clicking the button will not update the email on
    the **Social Media Account - Settings** page. If we open **Chrome DevTools** |
    **Console** , we’ll even see a **403 (Forbidden)** error, confirming that our
    change has prevented the attack:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The Chrome DevTools window showing 403 (Forbidden) on our CSRF
    request](img/B19212_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – The Chrome DevTools window showing 403 (Forbidden) on our CSRF
    request
  prefs: []
  type: TYPE_NORMAL
- en: This recipe has demonstrated a simple CSRF attack and the associated risks.
    We mitigated the vulnerability by supplying additional configuration using the
    **express-session** middleware.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we demonstrated a simple CSRF attack. The attacker crafted a
    malicious site to leverage a cookie from a social media website to update a user’s
    email to their own. This is a dangerous vulnerability as once an attacker has
    updated the email to their own, they can end up with control over the account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mitigate this vulnerability, we passed the **express-session** middleware
    the **{ cookie : { sameSite : true }}** configuration. The **SameSite** attribute
    of the cookie header can be set to the following three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**none** : The cookie can be shared and sent in all contexts, including cross-origin
    requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lax** : This allows the cookie to be shared with HTTP **GET** requests initiated
    by third-party websites, but only when it results in top-level navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**strict** : Cookies can only be sent through a request in a first-party context
    – if the cookie matches the current site URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting the **{ sameSite : true }** configuration option in the **express-session**
    middleware configuration equates to setting the **Set-Cookie : SameSite** attribute
    to **strict** mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the header of the request in this recipe would show a **Set-Cookie**
    header similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some older browsers don’t support the **Set-Cookie SameSite** header attribute.
    A strategy for dealing with these cases is to generate an anti-CSRF token. These
    anti-CSRF tokens are stored in the user session, which means the attacker would
    need access to the session itself to carry out the attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a module named **csurf** to help implement anti-CSRF tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the **express-csrf** directory, copy **fixed-server.js** to a new
    file named **csurf-server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the **csurf** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to import and initialize the **csurf** module in the **csruf-server.js**
    file. Add the following lines below the **express-session** import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to alter the HTTP **GET** request handler so that it uses the
    **csrf** middleware. We can achieve this by supplying it as the second parameter
    to the **get()** method of the **/account** route handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the HTML template, we generate and inject **csrfToken** using the **req.csrfToken()**
    method of the request object. We inject the token into the HTML template as a
    hidden field named **_csrf** . The **csrf** middleware looks for a token with
    that name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to update the **post()** method of our **/update** route handler
    so that it can use the **csrf** middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon an HTTP **POST** request, the **csrf** middleware will check the body of
    a request for the token stored in the **_csrf** field. The middleware then validates
    the supplied token with the token stored in the user’s session.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to **http://localhost:3000** and log in with the same username and
    password that we used in this recipe. Click on **View Page Source** on the **Social
    Media Account - Settings** page. You should see the following HTML showing the
    hidden **_csrf** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should be able to update the email as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **csurf** middleware helps mitigate the risk of CSRF attacks in older browsers
    that don’t support the **Set-Cookie:SameSite** attribute. However, our servers
    could still be vulnerable to more complex CSRF attacks, even when using the **csurf**
    middleware. The attacker could use XSS to obtain the CSRF token, and then craft
    a CSRF attack using the **_csrf** token. However, this is best-effort mitigation
    in the absence of support for the **Set-Cookie:SameSite** attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Slowing an attacker down by making the attack they have to create more complex
    is an effective way of reducing risk. Many attackers will try to exploit many
    websites at a time – if they experience a website that takes significantly longer
    to exploit, in the interest of time, they will often just move on to another website.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Authentication with Fastify* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Hardening headers with Helmet* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Anticipating malicious input* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preventing JSON pollution* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Guarding against cross-site scripting* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Diagnosing issues with Chrome DevTools* recipe in [*Chapter 12*](B19212_12.xhtml#_idTextAnchor388)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
