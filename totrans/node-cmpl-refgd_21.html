<html><head></head><body><div><h1 class="header-title">Building a Microservice</h1>
                
            
            
                
<p>Now that we've seen some examples of building microservices using some tools, let's dig deeper and create a microservice from scratch using these tools. To accomplish our goal, we'll first use Hydra, and then, we'll create our microservice using the Seneca approach.</p>
<p>There are many microservices we could create, but some are more interesting than others. More specifically, a microservice that you can use in several applications is obviously more useful.</p>
<p>Let's create an image processing microservice. We'll start with a simple thumbnail service, and then we'll evolve to make some simple image transformations. We'll be covering how to:</p>
<p class="mce-root"/>
<ul>
<li>Use external modules to manipulate images</li>
<li>Build our microservice in Hydra and Seneca</li>
</ul>
<p>The microservice name is very important, as it gives identity. Let's name it <em>imagini</em>, the Latin name for image.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using Hydra</h1>
                
            
            
                
<p>As you may remember, Hydra has a scaffolding command that helps to bootstrap our service quickly. Let's use it, and prepare our base layout. Run <kbd>yo fwsp-hydra</kbd> and answer the questions. You can leave most of them as default. Depending on the versions you'll use, you should get something similar to the lines shown here:</p>
<pre>fwsp-hydra generator v0.3.1   yeoman-generator v2.0.2   yo v2.0.1<br/>? Name of the service (`-service` will be appended automatically) imagini<br/>? Your full name? Diogo Resende<br/>? Your email address? dresende@thinkdigital.pt<br/>? Your organization or username? (used to tag docker images) dresende<br/>? Host the service runs on?<br/>? Port the service runs on? 3000<br/>? What does this service do? Image thumbnail and manipulation<br/>? Does this service need auth? No<br/>? Is this a hydra-express service? Yes<br/>? Set up a view engine? No<br/>? Set up logging? No<br/>? Enable CORS on serverResponses? No<br/>? Run npm install? No<br/>   create imagini-service/specs/test.js<br/>   create imagini-service/specs/helpers/chai.js<br/>   create imagini-service/.editorconfig<br/>   create imagini-service/.eslintrc<br/>   create imagini-service/.gitattributes<br/>   create imagini-service/.nvmrc<br/>   create imagini-service/.gitignore<br/>   create imagini-service/package.json<br/>   create imagini-service/README.md<br/>   create imagini-service/imagini-service.js<br/>   create imagini-service/config/sample-config.json<br/>   create imagini-service/config/config.json<br/>   create imagini-service/scripts/docker.js<br/>   create imagini-service/routes/imagini-v1-routes.js<br/><br/>Done!<br/><br/>'cd imagini-service' then 'npm install' and 'npm start'</pre>
<p>Well, let's do just that. Let's enter our service folder and install dependencies. If you then start it using <kbd>npm start</kbd>, and open the browser and point it to our service, you should get something like this:</p>
<div><img src="img/672ee99e-88f7-492b-8fb9-51911bb98bd6.png" width="1313" height="532"/></div>
<p>Not surprising, because Hydra created a different base route. To enable versioning and having different services running on the same HTTP backend, Hydra scaffolding created a route under the <kbd>/v1/imagini</kbd> prefix. Remember, we scaffolded Hydra with Express integration, so many of the terms we discussed earlier will be the same here:</p>
<div><img src="img/d30631d7-7ea1-42aa-a7d7-d7631ed28220.png" width="1464" height="631"/></div>
<p>Before we pick our previous code and integrate into Hydra, we need to add our Sharp dependency to <kbd>package.json</kbd>. Look up the <kbd>dependencies</kbd> property and add <kbd>sharp</kbd>. You should end up with something along these lines:</p>
<pre>(…)<br/>"dependencies": {<br/>    "sharp"                : "^0.19.0",<br/>    "body-parser"          : "^1.18.2",<br/>    "fwsp-config"          : "1.1.5",<br/>    "hydra-express"        : "1.5.5",<br/>    "fwsp-server-response" : "2.2.6"<br/>},<br/>(…)</pre>
<p>Now, run <kbd>npm install</kbd> to install Sharp. Then, open the <kbd>imagini-v1-routes.js</kbd> file, which is under the <kbd>routes</kbd> folder. Basically, what it does is get a handler for Hydra and Express, prepare a generic JSON server response (that's what the <kbd>fwsp-server-response</kbd> module is), create an Express router, attach the <kbd>/</kbd> route, and then export it.</p>
<p>We'll keep this structure for now. I refactored the file as I'm a bit picky about indentation and quotes. I added our image route parameter and added the image upload route. I changed our previous route code to drop the <kbd>/uploads</kbd> route prefix, and use the new <kbd>sendOk</kbd> and <kbd>sendError</kbd> functions you see in the preceding code:</p>
<pre>/**<br/> * @name          imagini-v1-api<br/> * @description   This module packages the Imagini API.<br/> */<br/>"use strict";<br/><br/>const fs             = require("fs");<br/>const path           = require("path");<br/>const sharp          = require("sharp");<br/>const bodyparser     = require("body-parser");<br/>const hydraExpress   = require("hydra-express");<br/>const ServerResponse = require("fwsp-server-response");<br/>const hydra          = hydraExpress.getHydra();<br/>const express        = hydraExpress.getExpress();<br/><br/>let serverResponse = new ServerResponse();<br/><br/>express.response.sendError = function (err) {<br/>    serverResponse.sendServerError(this, { result : { error : err }});<br/>};<br/><br/>express.response.sendOk = function (result) {<br/>    serverResponse.sendOk(this, { result });<br/>};<br/><br/>let api = express.Router();<br/><br/>api.param("image", (req, res, next, image) =&gt; {<br/>    if (!image.match(/\.(png|jpg)$/i)) {<br/>        return res.sendError("invalid image type/extension");<br/>    }<br/><br/>    req.image     = image;<br/>    req.localpath = path.join(__dirname, "../uploads", req.image);<br/><br/>    return next();<br/>});<br/><br/>api.post("/:image", bodyparser.raw({<br/>    limit : "10mb",<br/>    type  : "image/*"<br/>}), (req, res) =&gt; {<br/>    let fd  = fs.createWriteStream(req.localpath, {<br/>        flags    : "w+",<br/>        encoding : "binary"<br/>    });<br/><br/>    fd.end(req.body);<br/><br/>    fd.on("close", () =&gt; {<br/>        res.sendOk({ size: req.body.length });<br/>    });<br/>});<br/><br/>module.exports = api;</pre>
<p>Then, we restart our microservice, create the <kbd>uploads</kbd> folder under the <kbd>imagini-service</kbd> folder, and try to upload an image. Like before, I used <kbd>curl</kbd> to test it:</p>
<pre><strong>curl -X POST -H 'Content-Type: image/png' \</strong><br/><strong>    --data-binary @example.png \</strong><br/><strong>    http://localhost:3000/v1/imagini/example.png</strong></pre>
<p>As expected, I received a JSON response with our <kbd>size</kbd> property:</p>
<pre>{<br/>    "statusCode"        : 200,<br/>    "statusMessage"     : "OK",<br/>    "statusDescription" : "Request succeeded without error",<br/>    "result" : {<br/>        "size" : 55543<br/>    }<br/>}</pre>
<p>We can have our uploaded file in our <kbd>uploads</kbd> folder. We're getting there; just two more routes:</p>
<pre>api.head("/:image", (req, res) =&gt; {<br/>    fs.access(req.localpath, fs.constants.R_OK , (err) =&gt; {<br/>        if (err) {<br/>            return res.sendError("image not found");<br/>        }<br/><br/>        return res.sendOk();<br/>    });<br/>});</pre>
<p>Our check route is very similar. We just changed the return methods to use the methods  defined previously:</p>
<pre>api.get("/:image", (req, res) =&gt; {<br/>    fs.access(req.localpath, fs.constants.R_OK , (err) =&gt; {<br/>        if (err) {<br/>            return res.sendError("image not found");<br/>        }<br/><br/>        let image     = sharp(req.localpath);<br/>        let width     = +req.query.width;<br/>        let height    = +req.query.height;<br/>        let blur      = +req.query.blur;<br/>        let sharpen   = +req.query.sharpen;<br/>        let greyscale = [ "y", "yes", "true", "1", <br/>        "on"].includes(req.query.greyscale);<br/>        let flip      = [ "y", "yes", "true", "1", <br/>        "on"].includes(req.query.flip);<br/>        let flop      = [ "y", "yes", "true", "1", <br/>        "on"].includes(req.query.flop);<br/><br/>        if (width &gt; 0 &amp;&amp; height &gt; 0) {<br/>            image.ignoreAspectRatio();<br/>        }<br/><br/>        if (width &gt; 0 || height &gt; 0) {<br/>            image.resize(width || null, height || null);<br/>        }<br/><br/>        if (flip)        image.flip();<br/>        if (flop)        image.flop();<br/>        if (blur &gt; 0)    image.blur(blur);<br/>        if (sharpen &gt; 0) image.sharpen(sharpen);<br/>        if (greyscale)   image.greyscale();<br/><br/>        res.setHeader("Content-Type", "image/" + <br/>        path.extname(req.image).substr(1));<br/><br/>        image.pipe(res);<br/>    });<br/>});</pre>
<p>Our image download method is equally similar. For this route, we're not using the JSON responses, and instead just return our image directly. This allows us to try it out on our browser:</p>
<div><img src="img/51b105b0-6312-4f0c-993d-f8f9a716acdb.png" width="1470" height="732"/></div>
<p>We just migrated our service from Express to Hydra. Not much of a difference, but Hydra gives you a more robust layout, about which we'll find out more later on. Let's take a look at our third framework: Seneca.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using Seneca</h1>
                
            
            
                
<p>Remember that routing on this framework is all about patterns. Let's keep it simple for now and use a role property to indicate what we want to do (upload, check, or download).</p>
<p>By default, every message should be JSON-encoded, so we'll encode the image in <kbd>base64</kbd> to pass it as a string inside the JSON messages to upload and download.</p>
<p>Create a folder for our Seneca service, and then create a child folder called <kbd>uploads</kbd>. Then, install <kbd>seneca</kbd> and <kbd>sharp</kbd> on that folder by running the following command:</p>
<pre><strong>npm install seneca sharp --save</strong></pre>
<p>Then, create a file called <kbd>imagini.js</kbd> with the following content:</p>
<pre>const seneca  = require("seneca");<br/>const sharp   = require("sharp");<br/>const path    = require("path");<br/>const fs      = require("fs");<br/>const service = seneca();<br/><br/>service.add("role:upload,image:*,data:*", function (msg, next) {<br/>    let filename = path.join(__dirname, "uploads", msg.image);<br/>    let data = Buffer.from(msg.data, "base64");<br/><br/>    fs.writeFile(filename, data, (err) =&gt; {<br/>        if (err) return next(err);<br/><br/>        return next(null, { size : data.length });<br/>    });<br/>});<br/><br/>service.listen(3000);</pre>
<p>What this does is initiate a simple service with a route for uploading. Since we're receiving all the image content directly on an object property, I used <kbd>fs.writeFile</kbd>. It's a simpler method and gives me an error whether something incorrect happens, which we can pass on to the route response.</p>
<p>I also used <kbd>Buffer.from</kbd> to convert our image data, which we'll be uploading in <kbd>base64</kbd>.</p>
<p>So, let's just start it as we did with the others. I included the same <kbd>example.png</kbd> image and used <kbd>curl</kbd> to test this out.</p>
<pre>curl -H "Content-Type: application/json" \<br/>--data '{"role":"upload","image":"example.png","data":"'"$( base64 example.png)"'"}' \<br/>http://localhost:3000/act</pre>
<p>Seneca promptly replied with the following:</p>
<pre>{"size":55543}</pre>
<p>This is the image size. Notice I'm taking advantage of bash interpolation (variable substitution) to directly convert the image file to <kbd>base64</kbd> and pass it to <kbd>curl</kbd>, which then sends that JSON piece of data to our service:</p>
<pre>service.add("role:check,image:*", function (msg, next) {<br/>    let filename = path.join(__dirname, "uploads", msg.image);<br/><br/>    fs.access(filename, fs.constants.R_OK , (err) =&gt; {<br/>        return next(null, { exists : !err });<br/>    });<br/>});</pre>
<p>Our check route is very similar. Instead of just replying with an HTTP 404 response code, we reply with a stringified JSON object with a boolean property exists, which will indicate if the image was found.</p>
<p>Here, we are checking for our image using <kbd>curl</kbd>:</p>
<pre>curl -H "Content-Type: application/json" \<br/>    --data '{"role":"check","image":"example.png"}' \<br/>    http://localhost:3000/act</pre>
<p>We will respond with the following:</p>
<pre>{"exists":true}</pre>
<p>If you change the image name, it will respond with <kbd>false</kbd>:</p>
<pre>service.add("role:download,image:*", function (msg, next) {<br/>    let filename = path.join(__dirname, "uploads", msg.image);<br/><br/>    fs.access(filename, fs.constants.R_OK , (err) =&gt; {<br/>        if (err) return next(err);<br/><br/>        let image     = sharp(filename);<br/>        let width     = +msg.width;<br/>        let height    = +msg.height;<br/>        let blur      = +msg.blur;<br/>        let sharpen   = +msg.sharpen;<br/>        let greyscale = !!msg.greyscale;<br/>        let flip      = !!msg.flip;<br/>        let flop      = !!msg.flop;<br/><br/>        if (width &gt; 0 &amp;&amp; height &gt; 0) {<br/>            image.ignoreAspectRatio();<br/>        }<br/><br/>        if (width &gt; 0 || height &gt; 0) {<br/>            image.resize(width || null, height || null);<br/>        }<br/><br/>        if (flip)        image.flip();<br/>        if (flop)        image.flop();<br/>        if (blur &gt; 0)    image.blur(blur);<br/>        if (sharpen &gt; 0) image.sharpen(sharpen);<br/>        if (greyscale)   image.greyscale();<br/><br/>        image.toBuffer().then((data) =&gt; {<br/>            return next(null, { data: data.toString("base64") });<br/>        });<br/>    });<br/>});</pre>
<p>Our downloaded route has some changes:</p>
<ul>
<li>Instead of query parameters, we check directly on <kbd>msg</kbd>. One noticeable advantage is that we have types and not just strings, so we can use Boolean and numbers directly.</li>
<li>Instead of returning the image in binary, so that we could just open in the browser, we convert it to <kbd>base64</kbd> and pass it on the JSON response.</li>
</ul>
<p>We need some tools to test this on the command line. Since I use JSON a lot, I have <kbd>jq</kbd> installed. I strongly recommend you install it too and take a look at the tutorials. It will make your life easier. Using the <kbd>base64</kbd> command we previously used to encode, we can decode the content and pipe the data to a local file:</p>
<div><img src="img/56304604-8a9b-4348-aa91-aabae4cea60d.png" width="1353" height="509"/></div>
<p>We can then open the folder and see the image is there. Notice I added <kbd>greyscale</kbd> and resized the image just by passing two more JSON parameters:</p>
<div><img src="img/4bab2ee8-a612-4623-81f9-a264129362f7.png" width="1530" height="862"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Plugins</h1>
                
            
            
                
<p>In the spirit of Seneca, we should make a plugin for our <kbd>imagini</kbd> service. Let's split our code into two parts:</p>
<ul>
<li>The <kbd>imagini</kbd> plugin, a service that manipulates images</li>
<li>A Seneca microservice, which exposes the <kbd>imagini</kbd> plugin, and possibly others later on</li>
</ul>
<p>There's lot of room for improvement on our code, starting with code we repeated constantly. It's important to detect repetitions while our service is still very small.</p>
<p>The most repeated part is the local filename. This is actually something you might want to configure when starting the service, so let's change that to a function. Start by changing our <kbd>imagini.js</kbd> file to be a plugin. Clear all content and write this code:</p>
<pre>const sharp   = require("sharp");<br/>const path    = require("path");<br/>const fs      = require("fs");<br/><br/>module.exports = function (settings = { path: "uploads" }) {<br/>    // plugin code goes here<br/>};</pre>
<p>This is the basis of our plugin. We're loading the modules we need, but not Seneca, because our plugin will have access to the service directly. Seneca itself will load the plugin by calling our exported function. Following the idea of being able to configure the local image folder, we define an optional <kbd>settings</kbd> parameter, which will default to an object with the property <kbd>path</kbd> equal to <kbd>uploads</kbd>, which is the folder we've been using so far.</p>
<p>Now, let's add the content of our plugin, inside the preceding function:</p>
<pre>const localpath = (image) =&gt; {<br/>    return path.join(settings.path, image);<br/>}</pre>
<p>We start by defining a function that will convert our image parameter to the local path. We can actually reduce the function to be written in one single line:</p>
<pre>const localpath = (image) =&gt; (path.join(settings.path, image));</pre>
<p>Then, let's create another function that will check whether we have access to a local file, and return a Boolean (if it exists or not) and the filename we provided:</p>
<pre>const access = (filename, next) =&gt; {<br/>    fs.access(filename, fs.constants.R_OK , (err) =&gt; {<br/>        return next(!err, filename);<br/>    });<br/>};</pre>
<p>We can use this for our image check, and for our image download. This way, we can improve or even cache the results for greater performance, avoiding excessive filesystem hits. Our image check route can now be written in a very concise way:</p>
<pre>this.add("role:check,image:*", (msg, next) =&gt; {<br/>    access(localpath(msg.image), (exists) =&gt; {<br/>        return next(null, { exists : exists });<br/>    });<br/>});</pre>
<p>Notice that we're referring to the <kbd>this</kbd> object. Our Seneca service will call our plugin function and reference itself to <kbd>this</kbd>. Again, we can write it in a more concise way:</p>
<pre>this.add("role:check,image:*", (msg, next) =&gt; {<br/>    access(localpath(msg.image), (exists) =&gt; (next(null, { exists })));<br/>});</pre>
<p>Our upload route is fairly simple and has no changes:</p>
<pre>this.add("role:upload,image:*,data:*", (msg, next) =&gt; {<br/>    let data = Buffer.from(msg.data, "base64");<br/><br/>    fs.writeFile(localpath(msg.image), data, (err) =&gt; {<br/>        return next(err, { size : data.length });<br/>    });<br/>});</pre>
<p>The download route uses our previously created helper functions to avoid storing our local filename. We also made some tweaks to how <kbd>width</kbd> and <kbd>height</kbd> were treated:</p>
<pre>this.add("role:download,image:*", (msg, next) =&gt; {<br/>    access(localpath(msg.image), (exists, filename) =&gt; {<br/>        if (!exists) return next(new Error("image not found"));<br/><br/>        let image     = sharp(filename);<br/>        let width     = +msg.width || null;<br/>        let height    = +msg.height || null;<br/>        let blur      = +msg.blur;<br/>        let sharpen   = +msg.sharpen;<br/>        let greyscale = !!msg.greyscale;<br/>        let flip      = !!msg.flip;<br/>        let flop      = !!msg.flop;<br/><br/>        if (width &amp;&amp; height) image.ignoreAspectRatio();<br/>        if (width || height) image.resize(width, height);<br/>        if (flip)            image.flip();<br/>        if (flop)            image.flop();<br/>        if (blur &gt; 0)        image.blur(blur);<br/>        if (sharpen &gt; 0)     image.sharpen(sharpen);<br/>        if (greyscale)       image.greyscale();<br/><br/>        image.toBuffer().then((data) =&gt; {<br/>            return next(null, { data: data.toString("base64") });<br/>        });<br/>    });<br/>});</pre>
<p>There are actually a lot of variables we're using where we could just check the message parameter instead. We can rewrite our download function and get one-third reduction:</p>
<pre>this.add("role:download,image:*", (msg, next) =&gt; {<br/>    access(localpath(msg.image), (exists, filename) =&gt; {<br/>        if (!exists) return next(new Error("image not found"));<br/><br/>        let image     = sharp(filename);<br/>        let width     = +msg.width || null;<br/>        let height    = +msg.height || null;<br/><br/>        if (width &amp;&amp; height) image.ignoreAspectRatio();<br/>        if (width || height) image.resize(width, height);<br/>        if (msg.flip)        image.flip();<br/>        if (msg.flop)        image.flop();<br/>        if (msg.blur &gt; 0)    image.blur(blur);<br/>        if (msg.sharpen &gt; 0) image.sharpen(sharpen);<br/>        if (msg.greyscale)   image.greyscale();<br/><br/>        image.toBuffer().then((data) =&gt; {<br/>            return next(null, { data: data.toString("base64") });<br/>        });<br/>    });<br/>});</pre>
<p>In the end, you should have an <kbd>imagini.js</kbd> file with the following content:</p>
<pre>const sharp   = require("sharp");<br/>const path    = require("path");<br/>const fs      = require("fs");<br/><br/>module.exports = function (settings = { path: "uploads" }) {<br/>    const localpath = (image) =&gt; (path.join(settings.path, image));<br/>    const access    = (filename, next) =&gt; {<br/>        fs.access(filename, fs.constants.R_OK , (err) =&gt; {<br/>            return next(!err, filename);<br/>        });<br/>    };<br/><br/>    this.add("role:check,image:*", (msg, next) =&gt; {<br/>        access(localpath(msg.image), (exists) =&gt; (next(null, { exists })));<br/>    });<br/><br/>    this.add("role:upload,image:*,data:*", (msg, next) =&gt; {<br/>        let data = Buffer.from(msg.data, "base64");<br/><br/>        fs.writeFile(localpath(msg.image), data, (err) =&gt; {<br/>            return next(err, { size : data.length });<br/>        });<br/>    });<br/><br/>    this.add("role:download,image:*", (msg, next) =&gt; {<br/>        access(localpath(msg.image), (exists, filename) =&gt; {<br/>            if (!exists) return next(new Error("image not found"));<br/><br/>            let image     = sharp(filename);<br/>            let width     = +msg.width || null;<br/>            let height    = +msg.height || null;<br/><br/>            if (width &amp;&amp; height) image.ignoreAspectRatio();<br/>            if (width || height) image.resize(width, height);<br/>            if (msg.flip)        image.flip();<br/>            if (msg.flop)        image.flop();<br/>            if (msg.blur &gt; 0)    image.blur(blur);<br/>            if (msg.sharpen &gt; 0) image.sharpen(sharpen);<br/>            if (msg.greyscale)   image.greyscale();<br/><br/>            image.toBuffer().then((data) =&gt; {<br/>                return next(null, { data: data.toString("base64") });<br/>            });<br/>        });<br/>    });<br/>};</pre>
<p>We just need to create our Seneca service and use our plugin. This is actually very straightforward. Create a file called <kbd>seneca.js</kbd>, and add the following:</p>
<pre>const seneca  = require("seneca");<br/>const service = seneca();<br/><br/>service.use("./imagini.js", { path: __dirname + "/uploads" });<br/><br/>service.listen(3000);</pre>
<p>What the code does, line by line, is as follows:</p>
<ol>
<li>Loads the <kbd>seneca</kbd> module</li>
<li>Creates a Seneca <kbd>service</kbd></li>
<li>Loads the <kbd>imagini.js</kbd> plugin and passes our desired path</li>
<li>Starts <kbd>service</kbd> on port <kbd>3000</kbd></li>
</ol>
<p>That's it, our service is now a plugin and could be used by any Seneca service! You should now start our <kbd>service</kbd> by running the new file and not <kbd>imagini.js</kbd> directly:</p>
<pre><strong>node seneca</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>As you can see, writing a service does not change much between frameworks. Our code is very similar, with minor changes. Seneca is stricter about message format and content, so we used <kbd>base64</kbd> to encode our image inside the JSON message. Other than that, everything is the same.</p>
<p>You get the advantage of being able to choose everything about the service, but you need to write a lot of code. To facilitate the task, Hydra might be a good start for an initial set of plugins.</p>
<p>For other tools such as Seneca, some aspects of the microservice (for instance, the communication using JSON messages and service composition) are already packed. This comes at the price of a stricter service definition.</p>
<p>In the next chapter, we will discuss the security of our three service versions, and how we can store state.</p>


            

            
        
    </div>



  </body></html>