- en: Designing Our API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的API
- en: 'In the last few chapters, we have followed a TDD approach to implement our
    Create User endpoint. However, a user directory application needs to do much more:
    retrieve, edit, delete, and search for users. In this chapter, we want you to
    practice what you''ve learned and implement these endpoints yourself.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们遵循TDD方法来实现我们的创建用户端点。然而，用户目录应用程序需要做更多的事情：检索、编辑、删除和搜索用户。在本章中，我们希望你们练习所学到的知识，并自己实现这些端点。
- en: 'To help you design an API that is easy to use, we will outline some principles
    of API design. Specifically, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你设计一个易于使用的API，我们将概述一些API设计原则。具体来说，我们将：
- en: Discuss what **REST** is, and what it is not
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论REST是什么，以及它不是什么
- en: Learn to design our API to be **consistent**, **fast**, **intuitive**, and **simple**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何设计我们的API以使其**一致**、**快速**、**直观**和**简单**
- en: Understand the different types of consistency: **Common**, **Local**, **Transversal**,
    **Domain**, and **Perennial**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同类型的致性：**通用**、**本地**、**跨域**、**领域**和**永久**
- en: What it means to be RESTful
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful的含义
- en: When you read about APIs, you'll undoubtedly come across the terms **SOAP**,
    **RCP**, **REST**, and nowadays also **GRPC** and **GraphQL**. The status quo
    at the time of writing is that all APIs should be "RESTful," and any APIs that
    are not RESTful are considered subpar. This is a common misconception, which stems
    from the fact that many misunderstand what REST actually is. Therefore, we start
    this chapter by examining what REST is, what it is not, why it may not always
    be practical to use it, and why our API will *not* be RESTful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读关于API的内容时，你无疑会遇到**SOAP**、**RCP**、**REST**等术语，如今还有**GRPC**和**GraphQL**。在撰写本文时，现状是所有API都应该“RESTful”，任何非RESTful的API都被认为是不够好的。这是一个常见的误解，它源于许多人实际上对REST的理解有误。因此，我们从这个章节开始，检查REST是什么，它不是什么，为什么它可能并不总是实用的，以及为什么我们的API将**不会**是RESTful的。
- en: What is REST?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是REST？
- en: REST stands for **representational state transfer**, and is a set of *architectural
    styles* that dictates the manners and patterns in which you construct your API. REST
    is nothing new; you are probably already well attuned to it because that's how
    the World Wide Web is structured, so don't let the terminology alienate you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: REST代表**表征状态转移**，是一组*架构风格*，它规定了构建你的API的方式和模式。REST并不是什么新东西；你可能已经非常熟悉它，因为这就是万维网的结构，所以不要让术语让你感到陌生。
- en: 'There are six requirements for REST:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: REST有六个要求：
- en: '**Client-server**: Defines a clear **separation of concerns** (**SoC**) between
    client and server. The client should provide the user interface, while the server
    provides the data.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器**：定义了客户端和服务器之间清晰的**关注点分离**（**SoC**）。客户端应提供用户界面，而服务器提供数据。'
- en: '**S****tateless**: No transient information about the client should be held
    on the server. In other words, the server should not persist client sessions;
    if sessions need to be persisted, it must be done on the client. Any requests
    that arrive at the server must contain all the information required to process
    that request.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：服务器不应持有关于客户端的任何临时信息。换句话说，服务器不应持久化客户端会话；如果需要持久化会话，必须在客户端完成。到达服务器的任何请求都必须包含处理该请求所需的所有信息。'
- en: This is not to say that servers cannot store *any* state; servers can still
    persist *resource state* inside databases. But servers should not store temporary
    *application state* in memory.
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这并不是说服务器不能存储**任何**状态；服务器仍然可以在数据库中持久化**资源状态**。但服务器不应在内存中存储临时的**应用程序状态**。
- en: The importance of this constraint will become apparent in [Chapter 18](5d093a43-720f-4ea8-aac0-b64b13f96d12.xhtml), *Robust
    Infrastructure with Kubernetes*, when we deploy our application as a **cluster**
    of **load-balanced** servers. By being stateless, requests can be fulfilled by
    any of the servers in the cluster, and servers can be restarted without losing
    information. It is this constraint that allows for the scalability of our application.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个约束的重要性将在[第18章](5d093a43-720f-4ea8-aac0-b64b13f96d12.xhtml)，“使用Kubernetes的鲁棒基础设施”中变得明显，当我们把我们的应用程序作为**负载均衡**服务器的**集群**部署时。由于是无状态的，请求可以由集群中的任何服务器来满足，服务器可以重启而不会丢失信息。正是这个约束使得我们的应用程序具有可扩展性。
- en: However, this constraint does have its drawbacks, because the client must repeatedly
    send authentication information (for instance, a **JSON Web Token**, or **JWT**)
    with each request, increase the bandwidth used.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这个约束确实有其缺点，因为客户端必须反复在每个请求中发送认证信息（例如，**JSON Web Token**，或**JWT**），这会增加使用的带宽。
- en: '**Cacheable**: If a response is going to be the same given the same request,
    then that response should be cached by the client and/or any intermediaries. A RESTful
    architecture requires that the response message *must* include an indication of
    whether the response should be cached, or not, and if so, for how long.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存性**：如果给定相同的请求，响应将是相同的，那么该响应应该由客户端和/或任何中间件缓存。RESTful架构要求响应消息必须包含指示是否应该缓存响应或不应缓存，以及如果应该缓存，则缓存多长时间的指示。'
- en: This constraint could be beneficial as it helps reduce bandwidth usage, and
    can reduce the load on the server, freeing it up to service more requests.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此约束可能有益，因为它有助于减少带宽使用，并且可以减少服务器负载，使其能够处理更多请求。
- en: '**Layered system**: Many applications, especially Node.js applications, are
    **reverse proxied** by a web server (for instance, **NGINX**). This means that
    before a request reaches our application, it may pass through layers consisting
    of web server(s), load balancers (for instance, **HAProxy**), and/or a **caching
    server** (for instance, **Varnish**).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：许多应用程序，尤其是Node.js应用程序，由一个网络服务器**反向代理**（例如，**NGINX**）。这意味着在请求到达我们的应用程序之前，它可能通过由网络服务器（例如，**HAProxy**）、负载均衡器（例如，**Varnish**）和/或缓存服务器（例如，**Varnish**）组成的层。'
- en: The layered system constraint dictates that the client should not know about
    these layers; in simpler terms, the client should not have to care about the implementation
    of the server.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分层系统约束规定客户端不应了解这些层；用简单的话说，客户端不需要关心服务器的实现。
- en: '**Code on demand**: An optional constraint that allows the server to return
    code for the client to execute. For example, the server may send back custom JavaScript
    code, **Java applets**, or **Flash** applications. This can be viewed as an extension
    to the client-server constraint, as it ensures that the client doesn''t need to
    implement code specific for that server, which would otherwise couple the client
    and server together.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需代码**：一个可选约束，允许服务器返回客户端执行的代码。例如，服务器可能发送回自定义JavaScript代码、**Java小程序**或**Flash**应用程序。这可以被视为客户端-服务器约束的扩展，因为它确保客户端不需要实现针对该服务器的特定代码，否则这将耦合客户端和服务器。'
- en: '**Uniform interface**: An **interface** is a shared boundary that is used to
    exchange information between two components. An interface is important as it decouples
    the server from the clients; as long as both adhere to the same interface, they
    can be developed independently.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：一个**接口**是用于在两个组件之间交换信息的共享边界。接口很重要，因为它将服务器与客户端解耦；只要两者都遵守相同的接口，它们就可以独立开发。'
- en: 'The uniform interface constraint specifies rules on how this interface should
    be structured, and is further subdivided into four sub-constraints (a.k.a. **interface
    constraints**):'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 统一接口约束规定了该接口应该如何构建的规则，并且进一步细分为四个子约束（也称为**接口约束**）：
- en: '**Identification of resources**: a unit of data that is stored on the server
    is called a **resource**. The resource is an abstract entity, such as a person
    or a product. This constraint requires that our API assign an identifier to every
    resource. Otherwise, the client won''t be able to interact with it.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的识别**：存储在服务器上的数据单元称为**资源**。资源是一个抽象实体，例如人或产品。此约束要求我们的API为每个资源分配一个标识符。否则，客户端将无法与之交互。'
- en: 'When using REST with HTTP, this constraint is fulfilled by the use of *Uniform
    Resource* *Locators*, or *URLs*. For example, product #58 should be accessible
    through the URL `api.myapp.com/users/58/`.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用HTTP中的REST时，此约束通过使用*统一资源定位器*或*URLs*得到满足。例如，产品#58应通过URL `api.myapp.com/users/58/`
    访问。
- en: '**Manipulation of resources through representations**: You can represent a
    resource in different formats, such as XML or JSON. These are different **representations**
    of the same resource.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过表示形式操作资源**：您可以使用不同的格式表示资源，例如XML或JSON。这些都是同一资源的不同**表示**。'
- en: If a client wishes to manipulate a resource in some way, this constraint requires
    the client to send a full or partial representation of the desired state of the
    resource.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果客户端希望以某种方式操作资源，此约束要求客户端发送资源所需状态的完整或部分表示。
- en: As an extension to this, the server should also indicate to the client which
    representations it is willing to accept, and which representation it is sending
    back. When using REST with HTTP, this is done through the `Accept` and `Content-Type`
    headers, respectively.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为这一点的扩展，服务器还应向客户端指示它愿意接受哪些表示形式，以及它正在发送回哪些表示形式。当使用HTTP进行REST时，这是通过`Accept`和`Content-Type`头部分别完成的。
- en: '**Self-descriptive messages**: The response from the server should contain
    all the information the client requires to process it properly.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自描述消息**：服务器的响应应包含客户端正确处理所需的所有信息。'
- en: '**Hypermedia as the engine of application state **(**HATEOAS**): This requires
    the server response to include a list of actions that the client can take after
    receiving the response.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用程序状态引擎**（**HATEOAS**）：这要求服务器响应包括客户端在收到响应后可以采取的操作列表。'
- en: In order to apply the "RESTful" label to an API, it must adhere to *all* the
    constraints except code on demand (which is optional).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将“RESTful”标签应用于一个API，它必须遵守除了代码按需（这是可选的）之外的所有约束。
- en: What REST is not
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST不是什么
- en: 'Before we discuss which REST constraint we should follow and which ones we
    should not, let''s underline one very important distinction: REST is an *architectural
    style*, and does not impose low-level implementation details.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论我们应该遵循哪些REST约束以及哪些不应该遵循之前，让我们强调一个非常重要的区别：REST是一种**架构风格**，并不强加低级实现细节。
- en: REST is a generic set of rules/patterns that you can apply to any API. We commonly
    use it to structure HTTP APIs, because HTTP is the protocol of the World Wide
    Web; however, the HTTP protocol and its verbs are in no way tied to REST.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一套通用的规则/模式，你可以将其应用于任何API。我们通常用它来构建HTTP API，因为HTTP是万维网的协议；然而，HTTP协议及其动词与REST没有任何关联。
- en: Having said that, Roy Fielding, the author of the REST specification, was also
    the chief architect of the HTTP/1.1 specification, and so the REST style fits
    very well with an HTTP implementation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，REST规范的作者Roy Fielding也是HTTP/1.1规范的首席架构师，因此REST风格非常适合HTTP实现。
- en: Should my API be RESTful?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的API应该是RESTful的吗？
- en: I n the preceding section, I mentioned that our API will *not* be RESTful; let
    me explain why. While almost all constraints of REST make sense for modern APIs,
    HATEOAS does not.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我提到我们的API将**不是**RESTful；让我解释一下原因。虽然REST的几乎所有约束对现代API都有意义，但HATEOAS却没有。
- en: Roy Fielding outlined the REST constraints in his doctoral dissertation paper
    titled *Architectural Styles and the Design of Network-based Software Architectures*,
    which you can access at [www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).
    This was back in the year 2000, before search engines such as Yahoo!, Lycos, Infoseek, AltaVista,
    Ask Jeeves, and Google became prominent. The HATEOAS constraint made sense then,
    as it allows website visitors to use the list of links to navigate from any one
    page to any other page.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding在他的博士论文《架构风格和网络软件架构设计》中概述了REST约束，该论文的标题为*Architectural Styles and
    the Design of Network-based Software Architectures*，您可以在[www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)找到。这是在2000年，在像Yahoo!、Lycos、Infoseek、AltaVista、Ask
    Jeeves和Google这样的搜索引擎变得突出之前。当时HATEOAS约束是有意义的，因为它允许网站访客使用链接列表从任何一页导航到任何其他页面。
- en: However, the HATEOAS constraint makes less sense for APIs. Developers who are
    looking to use our API today are likely to refer to the API documentation on our
    project's website, rather than infer it from the server response. They're also
    likely to hardcode URLs into their application code, rather than obtaining them
    from links provided by the server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，HATEOAS约束对于API来说意义不大。今天想要使用我们的API的开发者可能会参考我们项目网站上的API文档，而不是从服务器响应中推断出来。他们也可能将URL硬编码到他们的应用程序代码中，而不是从服务器提供的链接中获取它们。
- en: In other words, HATEOAS makes sense for human users, but is not so great for
    code. In fact, strictly abiding by the HATEOAS constraint would mean our response
    must include information that is not useful to the application. This will increase
    network latency without providing any tangible benefits.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，HATEOAS对于人类用户是有意义的，但对于代码来说并不那么好。事实上，严格遵循HATEOAS约束意味着我们的响应必须包含对应用程序无用的信息。这将增加网络延迟，而不会提供任何实质性的好处。
- en: Therefore, our API will, by design, not comply with the HATEOAS constraint.
    Thus, we cannot call our API RESTful.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的API将按照设计不遵守HATEOAS约束。因此，我们不能称我们的API为RESTful。
- en: This can be confusing because many APIs that claim to be RESTful in fact aren't
    (how many APIs have you used that actually return a list of endpoints with each
    request? I'd guess none). The lesson to take away is that we should analyze each
    REST constraint against our API, apply those that make sense, but understand that
    an API doesn't have to be RESTful to be "good."
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会令人困惑，因为许多声称是RESTful的API实际上并不是（你使用过多少API实际上会在每次请求中返回端点列表？我猜没有）。我们应该吸取的教训是，我们应该将每个REST约束与我们的API进行分析，应用那些有意义的，但也要理解API不一定要是RESTful才能是“好”的。
- en: Designing our API
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的API
- en: An application programming interface, or API, is the interface through which
    end users can interact with our application. For an API to work, both the client
    and the API server must agree on some form of mutually agreed convention, or contract;
    for a specific type of requests, the client can expect the API to reply with a
    specific type of response. But to have a "good" API, this contract must also be
    **consistent**, **intuitive**, and **simple**. Now, let's tackle each criterion
    one at a time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口，或API，是最终用户与我们应用程序交互的接口。为了使API工作，客户端和API服务器必须就某种共同约定的形式或合同达成一致；对于特定类型的请求，客户端可以期望API以特定类型的响应进行回复。但是，为了有一个“好”的API，这个合同也必须是**一致**的、**直观**的，并且**简单**。现在，让我们逐个解决每个标准。
- en: Consistent
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性
- en: 'The principle of consistency is very important in API design. Arnaud Lauret,
    the author of the book *The Design of Everyday APIs*, elegantly outlined four
    different types of consistency in his blog post *The four levels of consistency
    in API design* ([restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/](http://restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/)),
    which we''ve summarized here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性原则在API设计中非常重要。Arnaud Lauret，书籍《日常API设计》的作者，在他的博客文章《API设计的四个一致性层级》（[restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/](http://restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/))中优雅地概述了四种不同类型的一致性，我们在这里进行了总结：
- en: '**Common**: Being consistent with the world'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共同**: 与世界保持一致'
- en: '**Local**: Being consistent within the same API'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部**: 在同一API内保持一致'
- en: '**Transversal**: Being consistent across different APIs by the same organization'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**横切性**: 同一组织下的不同API保持一致性'
- en: '**Domain**: Being consistent with a specific domain'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域**: 与特定领域保持一致'
- en: I have made one addition to this list—**perennial consistency***—*or being consistency *across
    time*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经向这个列表增加了一个条目——**持久一致性**——*或跨时间的一致性*。
- en: Let's examine each one individually.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查每个。
- en: Common consistency
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共同一致性
- en: As Lauret explained, common consistency is "being consistent with the world."
    This means our API should conform to well-established and/or authoritative standards;
    or if none are available, to the community consensus.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如Lauret所解释，共同的共识是“与世界保持一致”。这意味着我们的API应该符合已建立的和/或权威的标准；如果没有，则符合社区共识。
- en: If an API is not consistent with the world, it forces developers to learn a
    new way of thinking. This may require a sizable time investment, which may deter
    the user from trying the API in the first place. Therefore, having common consistency
    will likely improve developer experience, and may even drive up the API's adoption
    rate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个API与世界不一致，它将迫使开发者学习一种新的思维方式。这可能需要大量的时间投入，这可能会阻止用户首先尝试使用API。因此，拥有共同的共识可能会提高开发者的体验，甚至可能提高API的采用率。
- en: For an HTTP API, the obvious standard to adopt is the HTTP/1.1 specification.
    This is a standard sanctioned by the **World Wide Web Consortium** (**W3C**),
    the authoritative international standards organization for the World Wide Web.
    So, let's see how we can design our API to conform to that standard.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTTP API，显然应该采用HTTP/1.1规范。这是一个由**万维网联盟**（**W3C**）批准的标准，它是万维网的权威国际标准组织。那么，让我们看看我们如何设计我们的API以符合这个标准。
- en: Sending the correct HTTP status code
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送正确的HTTP状态码
- en: 'The HTTP specification dictates that any response must have a three-digit status
    code that allows programs to determine the nature of the response. These codes
    allow a program to process the response efficiently:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP规范规定，任何响应都必须有一个三位数的状态码，允许程序确定响应的性质。这些代码允许程序有效地处理响应：
- en: '| Status code | Class of response | Description |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 响应类别 | 描述 |'
- en: '| `1xx` | Informational | The request was received but not yet fully processed.
    The client doesn''t need to do anything. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `1xx` | 信息性 | 请求已接收但尚未完全处理。客户端不需要做任何事情。|'
- en: '| `2xx` | Success | The request was successfully received, understood, and
    accepted. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `2xx` | 成功 | 请求已成功接收、理解并被接受。|'
- en: '| `3xx` | Redirection | The resource has moved, either temporarily or permanently.
    The client needs to take further actions to complete the request. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `3xx` | 重定向 | 资源已移动，无论是临时还是永久。客户端需要采取进一步的操作来完成请求。|'
- en: '| `4xx` | Client error | The request is syntactically and/or semantically incorrect,
    and the server was unable (or refused) to process it. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `4xx` | 客户端错误 | 请求在语法和/或语义上不正确，服务器无法（或拒绝）处理它。|'
- en: '| `5xx` | Server error | The request is likely to be valid, but there was an
    error on the server. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `5xx` | 服务器错误 | 请求可能是有效的，但服务器出现了错误。|'
- en: You can find the original Status Code Definitions from the W3C at [w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
    The current list of valid HTTP Status Codes is maintained by the **Internet Assigned
    Numbers Authority** (**IANA**); you can find the full list at [iana.org/assignments/http-status-codes](https://www.iana.org/assignments/http-status-codes).
    Personally, I use [httpstatuses.com](https://httpstatuses.com/), which for me
    is easier on the eye.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在W3C的[httpstatuses.com](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)找到原始的状态码定义。当前有效的HTTP状态码列表由**互联网数字分配机构**（**IANA**）维护；您可以在[iana.org/assignments/http-status-codes](https://www.iana.org/assignments/http-status-codes)找到完整的列表。我个人使用[httpstatuses.com](https://httpstatuses.com/)，对我来说它更易于阅读。
- en: We have already followed these standards for our Create User endpoint. For instance,
    we respond with a `415 Unsupported Media Type` error status code when the request
    payload is not JSON; Express will automatically respond with a `404 Not Found`
    error if the client tries to hit an endpoint that is not implemented.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遵循了这些标准来处理我们的创建用户端点。例如，当请求有效负载不是JSON时，我们响应`415 不支持的媒体类型`错误状态码；如果客户端尝试访问未实现的端点，Express将自动响应`404
    未找到`错误。
- en: 'According to IANA, there are currently 62 assigned HTTP status codes. Most
    developers won''t be able to memorize all 62\. Thus, many APIs restrict the number
    of status codes they send back. We will do the same, and limit our API to using
    only the following nine status codes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IANA，目前有62个分配的HTTP状态码。大多数开发者无法记住所有62个。因此，许多API限制了它们发送回的状态码数量。我们将这样做，并将我们的API限制在仅使用以下九个状态码：
- en: '`200 OK`: Generic successful operation.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK`：通用的成功操作。'
- en: '`201 Created`: Successful operation where a resource, such as a user, is created.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201 已创建`：成功操作，创建了一个资源，如用户。'
- en: '`400 Bad Request`: When the request is syntactically or semantically incorrect.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 错误请求`：当请求在语法或语义上不正确时。'
- en: '`401 Unauthorized`: When the request lacks authentication credentials so the
    server cannot determine who is sending the request. The client should resend the
    request with these credentials.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 未授权`：当请求缺少认证凭据，服务器无法确定发送请求者时。客户端应带有这些凭据重新发送请求。'
- en: '`403 Forbidden`: The server understands the request but does not authorize
    it.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403 禁止`：服务器理解请求但未授权。'
- en: '`404 Not Found`: The resource is not found, or the endpoint path is invalid.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404 未找到`：资源未找到，或端点路径无效。'
- en: '`409 Conflict`: The resource has been modified after the client last retrieved
    it. The client should request a new version of the resource and decide whether
    it''d like to send the request again.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`409 冲突`：客户端上次检索资源后，资源已被修改。客户端应请求资源的新版本，并决定是否再次发送请求。'
- en: '`415 Unsupported Media Type`: The payload given for this endpoint is in an
    unsupported format, for example, sending an XML payload when the server only accepts
    JSON.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`415 不支持的媒体类型`：此端点的有效负载格式不受支持，例如，当服务器只接受JSON时发送XML有效负载。'
- en: '`500 Internal Server`: The request is most likely to be valid, but there''s
    an error on the server.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500 内部服务器错误`：请求可能是有效的，但服务器出现了错误。'
- en: Using HTTP methods
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP方法
- en: 'The HTTP specification also dictated that HTTP requests must contain a verb,
    and laid out rules for which verbs can be used for what types of request:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP规范还规定，HTTP请求必须包含一个动词，并规定了哪些动词可以用于哪些类型的请求：
- en: '`GET`: Requests the retrieval of a resource.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：请求检索资源。'
- en: '`POST`: Requests where the server decides how to process the data. The URL
    specifies the resource that is to handle this request.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：服务器决定如何处理数据的请求。URL 指定要处理此请求的资源。'
- en: '`PUT`: Requests for the entity to be stored under the specified URL.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：请求在指定的 URL 下存储实体。'
- en: '`PATCH`: Requests for partial changes to be made to an existing resource.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：请求对现有资源进行部分更改。'
- en: '`DELETE`: Requests for the resource to be deleted.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：请求删除资源。'
- en: '`HEAD`: Requests for the metadata of a resource.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`：请求资源的元数据。'
- en: '`OPTIONS`: Requests for information from the server regarding what requests
    are allowed.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`：请求服务器有关允许哪些请求的信息。'
- en: Furthermore, `GET`, `HEAD`, `OPTIONS`, and `TRACE` are considered to be **safe**
    methods, which means they must not modify the representation of any resources.
    Other verbs, such as `POST`, `PUT`, and `DELETE`, are expected to modify resources
    and should be considered *unsafe* methods.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`GET`、`HEAD`、`OPTIONS` 和 `TRACE` 被认为是**安全**方法，这意味着它们不得修改任何资源的表示。其他动词，如 `POST`、`PUT`
    和 `DELETE`，预期会修改资源，应被视为*不安全*方法。
- en: 'There''s also the related concept of **idempotency**. An idempotent HTTP method
    is one that can be repeated multiple times but still produces the same outcome
    as if only a single request was sent. For example, `DELETE` is an idempotent method,
    because deleting a resource multiple times has the same effect as deleting it
    once. *All safe methods are also idempotent*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个相关的概念是**幂等性**。幂等的 HTTP 方法是可以重复多次但仍会产生与只发送单个请求相同的结果的 HTTP 方法。例如，`DELETE`
    是一个幂等方法，因为多次删除资源的效果与只删除一次相同。*所有安全方法也都是幂等的*：
- en: '| Method | Safe | Idempotent |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 安全 | 幂等 |'
- en: '| `CONNECT` | ✗ | ✗ |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `CONNECT` | ✗ | ✗ |'
- en: '| `DELETE` | ✗ | ✓ |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | ✗ | ✓ |'
- en: '| `GET` | ✓ | ✓ |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | ✓ | ✓ |'
- en: '| `HEAD` | ✓ | ✓ |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | ✓ | ✓ |'
- en: '| `OPTIONS` | ✓ | ✓ |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | ✓ | ✓ |'
- en: '| `POST` | ✗ | ✗ |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | ✗ | ✗ |'
- en: '| `PUT` | ✗ | ✓ |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | ✗ | ✓ |'
- en: '| `PATCH` | ✗ | ✗ |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | ✗ | ✗ |'
- en: '| `TRACE` | ✓ | ✓ |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `TRACE` | ✓ | ✓ |'
- en: 'Even if we conform to the HTTP specifications, there are still multiple ways
    to update a resource: using `POST`, `PUT` or `PATCH`. Therefore, when there is
    ambiguity in how to interpret a standard, we should turn to community consensus.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们遵守 HTTP 规范，更新资源仍有多种方式：使用 `POST`、`PUT` 或 `PATCH`。因此，当对标准的解释存在歧义时，我们应该转向社区共识。
- en: We are going to use a set of project guidelines published by Elsewhen, a digital
    product studio in London. It has over 17,500 stars on GitHub and can be accessed
    at [github.com/elsewhencode/project-guidelines](https://github.com/elsewhencode/project-guidelines).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由伦敦的数字产品工作室 Elsewhen 发布的一系列项目指南。它在 GitHub 上有超过 17,500 个星标，可通过 [github.com/elsewhencode/project-guidelines](https://github.com/elsewhencode/project-guidelines)
    访问。
- en: 'The part of the guidelines on HTTP methods is reproduced here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重现了指南中关于 HTTP 方法的部分：
- en: '`GET`: To retrieve a representation of a resource.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：检索资源的表示。'
- en: '`POST`: To create new resources and sub-resources.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：创建新资源和子资源。'
- en: '`PUT`: To update existing resources.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：更新现有资源。'
- en: '`PATCH`: To update existing resources. It only updates the fields that were
    supplied, leaving the others alone.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：对现有资源进行部分更改的请求。它只更新提供的字段，其他字段保持不变。'
- en: '`DELETE`: To delete existing resources.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除现有资源。'
- en: So although we could update a resource by sending a `POST` request, we will
    limit `POST` requests only to the creation of resources.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我们可以通过发送 `POST` 请求来更新资源，但我们只将 `POST` 请求限制在资源的创建上。
- en: Following the guidelines, we will also structure our API paths using the `/<collection>/<id>` structure,
    where `<collection>` is a class of resources (for instance, users, products, or
    articles), and `<id>` is the identifier for a particular resource within that
    collection (for instance, a particular user).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循指南，我们还将使用 `/<collection>/<id>` 结构来构建我们的 API 路径，其中 `<collection>` 是资源类别（例如，用户、产品或文章），而
    `<id>` 是该集合中特定资源的标识符（例如，特定用户）。
- en: We will use plural nouns to name our collection to make the URL more consistent
    and easier to read. In other words, we will use `/users` and `/users/<id>`, instead
    of `/user` and `/user/<id>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用复数名词来命名我们的集合，以使 URL 更一致且易于阅读。换句话说，我们将使用 `/users` 和 `/users/<id>`，而不是 `/user`
    和 `/user/<id>`。
- en: Putting it all together, we get the following table, which details the actions
    that should be performed for each resource and HTTP method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下表格，其中详细说明了针对每个资源应执行的操作和 HTTP 方法。
- en: '| Resource | `GET` | `POST` | `PUT` | `PATCH` | `DELETE` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | `GET` | `POST` | `PUT` | `PATCH` | `DELETE` |'
- en: '| `/users` | Retrieve a list of users | Create new user | Error | Error | Error
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `/users` | 获取用户列表 | 创建新用户 | 错误 | 错误 | 错误 |'
- en: '| `/users/<id>` | Retrieve user | Error | Update user object (completely);
    error if user does not exists | Update user object (partially); error if user
    does not exists | Delete user object; error if user does not exists |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `/users/<id>` | 获取用户 | 错误 | 更新用户对象（完全）；如果用户不存在则错误 | 更新用户对象（部分）；如果用户不存在则错误
    | 删除用户对象；如果用户不存在则错误 |'
- en: Using ISO formats
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ISO格式
- en: 'For things such as units, we should use formats provided by the **International
    Organization for Standardization** (**ISO**) whenever possible:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诸如单位之类的项目，我们应尽可能使用国际标准化组织（**ISO**）提供的格式：
- en: '**Date/time**: UNIX timestamps (in milliseconds) to represent times, and ISO
    8601 complete date format to represent dates ([iso.org/iso-8601-date-and-time-format.html](https://www.iso.org/iso-8601-date-and-time-format.html))'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期/时间**: 使用UNIX时间戳（以毫秒为单位）表示时间，以及ISO 8601完整日期格式表示日期([iso.org/iso-8601-date-and-time-format.html](https://www.iso.org/iso-8601-date-and-time-format.html))'
- en: '**Currencies**: ISO 4217 currency codes ([iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html))'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**货币**: ISO 4217货币代码([iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html))'
- en: '**Countries**: Either ISO 3166-1 alpha-2, ISO 3166-1 alpha-3, or ISO 3166-1
    numeric codes ([iso.org/iso-3166-country-codes.html](https://www.iso.org/iso-3166-country-codes.html))'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**国家**: 可以是ISO 3166-1 alpha-2、ISO 3166-1 alpha-3或ISO 3166-1数字代码([iso.org/iso-3166-country-codes.html](https://www.iso.org/iso-3166-country-codes.html))'
- en: '**Languages**: ISO 639-2 codes ([iso.org/iso-639-language-codes.html](https://www.iso.org/iso-639-language-codes.html))'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言**: ISO 639-2代码([iso.org/iso-639-language-codes.html](https://www.iso.org/iso-639-language-codes.html))'
- en: Local consistency
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地一致性
- en: Local consistency means being consistent within the same API. In other words,
    if a developer has worked with one part of your API (for instance, creating a
    user), he/she should be able to work with other parts of the API using the same
    conventions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本地一致性意味着在同一API内部保持一致性。换句话说，如果一个开发者已经与你的API的一部分（例如，创建用户）合作过，他/她应该能够使用相同的约定来处理API的其他部分。
- en: Naming convention
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名约定
- en: 'For example, we should follow a consistent set of naming conventions for all
    our URLs. Specifically, we will do the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们应该遵循一致的命名约定来命名所有我们的URL。具体来说，我们将执行以下操作：
- en: Use kebab-case for URLs
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用短横线命名法（kebab-case）为URL命名
- en: Use camelCase for parameters in the query string, for example, `/users/12?fields=name,coverImage,avatar`
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询字符串中的参数使用驼峰命名法（camelCase），例如，`/users/12?fields=name,coverImage,avatar`
- en: For nested resources, structure them like so: `/resource/id/sub-resource/id`,
    for example, `/users/21/article/583`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于嵌套资源，应按如下结构组织：`/resource/id/sub-resource/id`，例如，`/users/21/article/583`
- en: 'For our non-CRUD endpoints, the URL naming convention should follow a `/verb-noun` structure:
    we should use `/search-articles` instead of `/articles-search`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的非CRUD端点，URL命名约定应遵循`/动词-名词`结构：我们应该使用`/search-articles`而不是`/articles-search`。
- en: Consistent data exchange format
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致的数据交换格式
- en: This may sound obvious, but we should use either use plain text or **JavaScript
    Object Notation** (**JSON**) as the format for data exchange. You shouldn't use
    JSON for one endpoint and XML for another endpoint, for example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能很明显，但我们应该使用纯文本或**JavaScript对象表示法**（**JSON**）作为数据交换的格式。你不应该在一个端点使用JSON，而在另一个端点使用XML，例如。
- en: Error response payload
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误响应负载
- en: 'Error response payloads should follow a consistent structure. For instance,
    the payload should be a JSON object with an array of error objects, each containing
    three fields:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应负载应遵循一致的格式。例如，负载应是一个包含错误对象的JSON对象数组，每个对象包含三个字段：
- en: '`code`: A numeric error code, to be used by the program'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code`: 一个数字错误代码，供程序使用'
- en: '`message`: A short, human-readable summary of the error'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`: 错误的简短、可读性强的摘要'
- en: '`description`: An optional longer, more detailed description of the error'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 错误的可选更详细描述'
- en: Every error payload must follow this format. This allows developers to write
    a single function that can process all error messages.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个错误负载都必须遵循此格式。这允许开发者编写一个可以处理所有错误消息的单个函数。
- en: Transversal consistency
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉一致性
- en: Transversal consistency is being consistent across different APIs within the
    same organization. The reason for this is similar to those for local consistency.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉一致性是指在同一组织内的不同API之间保持一致性。原因与本地一致性类似。
- en: Domain consistency
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域一致性
- en: Domain consistency is being consistent with a specific domain.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 领域一致性是指与特定领域保持一致。
- en: For example, if you're developing a scientific publications directory, you should
    conduct some research in order to acquire knowledge and norms that are specific
    to this domain. For example, you should know that a scientific publication may
    be identified with a **PubMed Identifier** (**PMID**), PMCID, Manuscript ID, or **Digital
    Object Identifier** (**DOI**), so your API's response object should include fields
    that contain these different identifiers, or at least allow users to search for
    articles based on these IDs. This is consistent with the norms of the scientific
    domain.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在开发一个科学出版物目录，你应该进行一些研究以获取特定于这个领域的知识和规范。例如，你应该知道科学出版物可能被识别为**PubMed标识符**（**PMID**）、PMCID、稿件ID或**数字对象标识符**（**DOI**），因此你的API响应对象应包含包含这些不同标识符的字段，或者至少允许用户根据这些ID搜索文章。这与科学领域的规范一致。
- en: 'Another example is to allow for filters that are consistent with the domain.
    Continuing with the scientific publication directory example, there are usually
    a few categories of scientific publications: original/primary research, reviews,
    editorials/opinions, short reports, clinical case studies, methods, meta-analysis,
    dissertations, conference proceedings, and so on. Allowing users to filter by
    these categories would be another example of being domain consistent.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是允许使用与领域一致的过滤器。继续以科学出版物目录为例，通常有几种科学出版物类别：原始/主要研究、评论、社论/观点、简报、临床案例研究、方法、荟萃分析、学位论文、会议记录等。允许用户根据这些类别进行筛选将是另一个领域一致性的例子。
- en: Perennial consistency
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长期一致性
- en: Lastly, I've coined the term *perennial consistency* to mean being consistent
    with the past and future of the API.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我创造了“*perennial consistency*”（长期一致性）这个术语，意味着与API的过去和未来保持一致。
- en: I chose the adjective *perennial* over others such as "perpetual" or "persistent"
    because *p**erpetual* implies the API will *never* change, which is impractical; *p**ersistent* implies
    that developers should obstinately refuse to change the API even if there's a
    need to, which is not right; *p**erennial* means the API structure should stay
    the same for a long time, but not forever.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择“*perennial*”（常年的）这个形容词而不是“*perpetual*”（永久的”或“*persistent*”（持续的”），因为“*perpetual*”意味着API将“*永远*”不会改变，这是不切实际的；“*persistent*”意味着即使有必要，开发者也应该固执地拒绝更改API，这是不正确的；“*perennial*”意味着API结构应该长期保持不变，但不是永远不变。
- en: To understand why perennial consistency is important, we must first understand
    what happens when we introduce a breaking (backward-incompatible) change to our
    API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么长期一致性很重要，我们首先必须了解当我们对API引入破坏性（向后不兼容）更改时会发生什么。
- en: Breaking changes in APIs
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API中的破坏性更改
- en: 'If we are developing a library and want to introduce a breaking change, we
    can simply bump the major version and publish it. Developers can freely choose if,
    and when, they want to migrate. However, the process is not so trivial for APIs
    because for the following reasons:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在开发一个库并想引入破坏性更改，我们只需简单地增加主版本号并发布即可。开发者可以自由选择是否以及何时迁移。然而，对于API来说，这个过程并不那么简单，原因如下：
- en: For every version of the API, the API provider must serve and maintain a different
    instance of the service. This can be a huge overhead.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于API的每个版本，API提供者必须维护一个不同的服务实例。这可能会造成巨大的开销。
- en: Different versions of the API would still use the same set of data, so you must
    design a data structure that is compatible with all versions. Sometimes, this
    may require you to have redundant fields in your data.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的不同版本仍将使用相同的数据集，因此你必须设计一个与所有版本兼容的数据结构。有时，这可能需要你在数据中包含冗余字段。
- en: If the changes are too drastic, developers may keep using the older version,
    possibly prolonging the period for which you must support the older API.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果更改过于剧烈，开发者可能会继续使用旧版本，这可能会延长你必须支持旧API的期限。
- en: 'Breaking changes are also bad for developer experience because for the following
    reasons:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏性更改对开发者体验也不好，原因如下：
- en: Developers are often given a limited period of time to update their code to
    conform to the newer version, before the older version is dropped.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在旧版本被淘汰之前，开发者通常被给予一个有限的时间段来更新他们的代码以符合新版本。
- en: Third-party libraries that depend on your API would also have to update their
    code. But if maintainers lack the time or willingness to migrate, it could lead
    to an accumulation of outdated libraries.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于你的API的第三方库也必须更新它们的代码。但如果维护者缺乏时间或意愿进行迁移，可能会导致过时库的积累。
- en: For these reasons, breaking changes should be avoided as much as possible. When
    you design your API, take care not to just think about the current requirements,
    but also any possible future needs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，应尽可能避免破坏性变更。当你设计API时，要注意不仅要考虑当前的需求，还要考虑任何可能的未来需求。
- en: This does not contradict the *you aren't gonna need it* (YAGNI) principle. You're
    not going to *implement* a feature you may not need. You are just going to think
    ahead, so you can plan ahead.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不与“你不需要它”（YAGNI）原则相矛盾。你不会去实现你可能不需要的功能。你只是在提前思考，以便可以提前规划。
- en: Future-proofing your URL
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的URL提供未来保障
- en: One way of achieving perennial consistency is to design future-proof URLs. For
    example, if we're building a social network where every user must belong to an
    organization, we can identify a user with a URL structure similar to `/orgs/<org-id>/users/<user-id>`.
    But if we think ahead, there may be a time in the future where our platform needs
    to cater for users belonging to multiple organizations; in that case, the URL
    structure we proposed would not support this.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 实现永久一致性的一种方法是为你的URL设计未来保障。例如，如果我们正在构建一个社交网络，其中每个用户都必须属于一个组织，我们可以使用类似于`/orgs/<org-id>/users/<user-id>`的URL结构来标识用户。但如果我们向前看，未来可能会有这样的时刻，我们的平台需要为属于多个组织的用户提供支持；在这种情况下，我们提出的URL结构将不支持这一点。
- en: Therefore, we should design our URL to simply include the user's ID (that is, `/users/<user-id>`).
    Then, to associate a user with an organization, we can implement the concept of
    membership, and structure the membership URL to have the structure `/orgs/<org-id>/members/<member-id>`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该设计我们的URL，使其简单地包含用户的ID（即，`/users/<user-id>`）。然后，为了将用户与组织关联起来，我们可以实现成员资格的概念，并将成员资格URL的结构设计为`/orgs/<org-id>/members/<member-id>`。
- en: Future-proofing your data structure
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的数据结构提供未来保障
- en: Another way to ensure perennial consistency is to future-proof your data structure.
    For instance, if we want to store a user's name, we could simply specify a `name` property
    of type string. This may work for now, but in the future, we may want to distinguish
    between first, middle, and last names. We may even want to implement sorting and
    filtering based on first or last names. Thinking even further ahead, many people,
    especially from Asian countries, have both an English and non-English name, and
    so we might even want to allow users to provide their names in multiple languages.
    Structuring your name property as a string wouldn't work!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 确保永久一致性的另一种方法是为你数据结构提供未来保障。例如，如果我们想存储用户的姓名，我们可以简单地指定一个类型为字符串的`name`属性。这可能现在有效，但将来，我们可能想要区分名、中名和姓。我们甚至可能想要根据名或姓实现排序和过滤。进一步思考，许多人，尤其是来自亚洲国家的人，既有英文名也有非英文名，所以我们甚至可能希望允许用户用多种语言提供他们的姓名。将姓名属性作为字符串来结构化是不行的！
- en: 'This is why our user schema specifies an object as the data structure for the
    `name` property. This allows us to add more properties to the object without breaking
    existing code. For example, our profile object may eventually evolve into something
    like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们的用户模式指定了一个对象作为`name`属性的数结构。这允许我们在不破坏现有代码的情况下向对象添加更多属性。例如，我们的配置文件对象最终可能会演变成如下所示：
- en: '[PRE0]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Versioning
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: 'But if a breaking change cannot be avoided, then we must abide by semantic
    versioning (semver) and increase the major version of our API. But where do we
    store the version data? There are generally two approaches:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果无法避免破坏性的变更，那么我们必须遵守语义版本控制（semver）并增加API的主版本号。但版本数据存储在哪里呢？通常有两种方法：
- en: 'In the URL (for instance, `/v2/users`): This is by far the easiest to explain
    and implement, but it''s semantically incorrect. This is because URLs should be
    used to locate a resource; if we add versioning information to the URL, it''d
    imply that the resource itself is versioned, not the API.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URL中（例如，`/v2/users`）：这到目前为止最容易解释和实现，但从语义上讲是不正确的。这是因为URL应该用于定位资源；如果我们向URL中添加版本信息，那么这会暗示资源本身是版本化的，而不是API。
- en: 'As part of the `Accept` header (for instance, `Accept: application/vnd.hobnob.api.v2+json`):
    The `vnd` prefix in the MIME type denotes that this is a vendor-specific MIME
    type; here, we are using it to specify the API version we want. The `+json` denotes
    that the reply could be parsed as JSON. This is the most semantically correct
    approach, but it also requires more effort to explain to end users.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '作为`Accept`头的一部分（例如，`Accept: application/vnd.hobnob.api.v2+json`）：MIME类型中的`vnd`前缀表示这是一个供应商特定的MIME类型；在这里，我们用它来指定我们想要的API版本。`+json`表示回复可以被解析为JSON。这是最语义化的方法，但也需要更多的努力向最终用户解释。'
- en: The URL approach is more practical; the `Accept` header approach is more semantic.
    Neither one is "better" than the other. Pick the one that makes sense for you
    and your audience.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: URL方法更为实用；`Accept`头方法更为语义化。两者没有“更好”之分。选择对你和你的受众都有意义的方法。
- en: 'When making a breaking change, apart from increasing the version of your API,
    make sure you also:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行重大更改时，除了增加API版本号外，还确保你做了以下事情：
- en: Provide a grace period whenever possible, that is, a deprecation period where both
    the legacy and new versions run concurrently, in order to allow developers time
    to migrate to the newer version
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，提供一段宽限期，即降级期，在此期间，旧版和新版同时运行，以便开发者有时间迁移到新版本。
- en: Provide deprecation warnings in advance, including the date when the older API
    version will no longer be supported and the date when it will become unavailable
    altogether
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提前提供降级警告，包括旧API版本将不再支持的确切日期以及它将完全不可用的日期
- en: Provide a clear list of all breaking changes
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供所有重大更改的清晰列表
- en: Provide clear instructions on how to migrate to the newer version
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供如何迁移到新版本的清晰说明
- en: Intuitive
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直观
- en: 'When we interact with everyday objects, we have an expectation of how they
    are going to work. This is known in design as affordance. For example, if you
    see a handle on a door, it should be instinctive to you that you should be pulling
    on the handle; conversely, a flat rectangular piece of metal (called a finger
    plate) attached to the door implies it should be pushed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与日常物品互动时，我们对它们的工作方式有一个预期。这在设计中被称为“可用性”。例如，如果你看到一个门把手，你应该本能地知道你应该拉门把手；相反，一个平面的长方形金属片（称为“指板”）固定在门上意味着它应该被推：
- en: '![](img/b44fd0e3-0b25-43a0-8504-d5a6449a6f32.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b44fd0e3-0b25-43a0-8504-d5a6449a6f32.jpg)'
- en: (Left) Adding a handle to the side of the door that is meant to be pushed is
    an example of bad design, as the handle is for pulling, not pushing. (Right) The
    handle already suggests that the door is meant to be pulled, so the "Pull" label
    is unnecessary here. This image is taken from `chriselyea.com/wp-content/uploads/2010/01/PushPullDoors.jpg` (dead
    link).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: （左）在门的一侧添加一个用于推的门把手是设计不良的例子，因为门把手是用于拉的，而不是推的。（右）门把手已经暗示了门是用于拉的，所以这里的“拉”标签是不必要的。此图片来自`chriselyea.com/wp-content/uploads/2010/01/PushPullDoors.jpg`（已失效链接）。
- en: This concept of affordance is universal to all design, including API design. Likewise,
    an API should be self-explanatory and as obvious as possible.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可用性的概念适用于所有设计，包括API设计。同样，API应该是自我解释的，尽可能明显。
- en: Users don't want to learn new behaviors. Users don't want to read the documentation
    in order to use your platform. The best case scenario is that your API is so intuitive
    that they only need to refer to the documentation once in a while.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不想学习新的行为。用户不想阅读文档来使用你的平台。最佳情况是，你的API如此直观，以至于他们只需要偶尔查阅文档。
- en: On the other hand, if your API is unintuitive, then a user may still try it
    out, but they may feel the learning curve is too high and use an alternative platform
    instead.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的API不够直观，用户可能仍然会尝试使用它，但他们可能会觉得学习曲线太高，转而使用其他平台。
- en: 'This also touches on the previous point made about consistency: if it is commonly
    consistent, then users will feel more familiar with using your API.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这也涉及到之前提到的关于一致性的观点：如果它通常是连贯的，那么用户在使用你的API时会感到更加熟悉。
- en: Being intuitive simply means making things obvious. We should follow the** Principle
    of Least Astonishment **(**POLA**), which states that *"the result of performing
    some operation should be obvious, consistent, and predictable, based upon the
    name of the operation and other clues."*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 直观仅仅意味着使事物明显。我们应该遵循**最小惊讶原则**（**POLA**），该原则指出：“执行某些操作的结果应该是显而易见、一致和可预测的，基于操作名称和其他线索。”
- en: Here, we outline a few things we can do to make sure our API is as intuitive
    as possible.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们概述了一些我们可以做的事情，以确保我们的API尽可能直观。
- en: URLs for humans
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适合人类的URL
- en: Related endpoints should be grouped. For example, the Instagram API groups endpoints
    into user-, media-, tags-, and location-related endpoints, each under `api.instagram.com/v1/{group}/`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 相关端点应分组。例如，Instagram API将端点分组为用户、媒体、标签和位置相关的端点，每个端点都在`api.instagram.com/v1/{group}/`下。
- en: This makes it easy for the consumer of the endpoint to immediately be able to
    deduce the intended function of the endpoint, without having to refer to the documentation.
    The function of the endpoint should be obvious to the consumer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得端点的消费者能够立即推断出端点的预期功能，而无需查阅文档。端点的功能应该对消费者显而易见。
- en: For example, it's immediately obvious that `/users/:user-id/media/recent` is
    an endpoint that retrieves the most recent media objects of a user.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`/users/:user-id/media/recent`这个端点很明显是用来检索用户最近媒体对象的。
- en: Favor verbosity and explicitness
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倾向于详尽和明确
- en: When in doubt, always favor verbosity and explicitness over implicitness, as
    it can cut out the ambiguity in the API. For example, use `userId` instead of `uid`,
    which some may interpret as "unique ID."
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，始终倾向于详尽和明确而不是隐晦，因为这可以消除API中的歧义。例如，使用`userId`而不是`uid`，有些人可能会将其解释为“唯一ID”。
- en: Keep It Simple Stupid (KISS)
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单至上（KISS）
- en: Last but not least, a good API must be simple.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，一个好的API必须是简单的。
- en: One of the main reasons for having an API is to abstract the implementation
    details away from the end user. You should not expose internal functions to the
    end user because it will add unnecessary complexity to your API—users will have
    more documentation to read, even if 90% of it is irrelevant to what they want
    to do.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个API的主要原因是将实现细节从最终用户抽象出来。您不应该向最终用户公开内部函数，因为这会给您的API增加不必要的复杂性——用户将需要阅读更多的文档，即使其中90%与他们想要做的事情无关。
- en: The rule is to think about what are the minimum set of functions that can be
    exposed, but still allow a typical user to perform all the necessary functions.
    For example, when a new user signs up, a profile is automatically created for
    them, and so there's no need to expose the internal `createProfile` function as
    the `/POST profile` endpoint, as a typical user will never call it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是考虑最小的一组可以公开的功能，但仍然允许典型用户执行所有必要的功能。例如，当新用户注册时，会自动为他们创建一个个人资料，因此没有必要将内部`createProfile`函数作为`/POST
    profile`端点公开，因为典型用户永远不会调用它。
- en: '"When in doubt, leave it out" is a good adage to remember; it''s often easier
    to add to an API than to remove features that some developers (albeit a very small
    percentage) are already using.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: “当有疑问时，就把它留在外面”是一个值得记住的格言；通常向API添加功能比移除一些开发者（尽管比例很小）已经使用的功能要容易。
- en: A toddler won't cry if you don't buy them a new toy they didn't ask for, but
    try to take away a toy they are playing with, and you may find your ears ringing
    for a while.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个蹒跚学步的孩子如果没得到他们没要求的玩具不会哭，但如果你试图拿走他们正在玩的玩具，你可能会发现你的耳朵会嗡嗡响一段时间。
- en: Completing our API
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的API
- en: 'In the previous chapters, we have shown you how to write unit, integration,
    and E2E tests as part of a TDD process. In this chapter, we''ve outlined the factors
    you should consider when designing an API. Now, we pass the baton to you to implement
    the rest of the API. Specifically, you should implement the following requirements:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们向您展示了如何在TDD过程中编写单元、集成和端到端测试。在本章中，我们概述了在设计API时应考虑的因素。现在，我们将接力棒传给您，以实现API的其余部分。具体来说，您应该实现以下要求：
- en: Delete
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: User must provide a user ID to delete
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须提供一个用户ID以进行删除
- en: Search
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索
- en: Defaults to the last 10 users who have registered
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认为最后注册的10个用户
- en: Create
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: User must provide an email address and password
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须提供一个电子邮件地址和密码
- en: User may optionally provide a profile; otherwise, an empty profile will be created
    for them
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以选择提供个人资料；否则，将为他们创建一个空的个人资料
- en: Retrieve
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索
- en: When a user provides a user ID of another user, the profile of that user should
    be returned
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户提供一个其他用户的用户ID时，应返回该用户的个人资料
- en: Update
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: When a user provides a user ID and a complete user object, we should replace
    the old user object with the new one
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户提供一个用户ID和完整的用户对象时，我们应该用新的用户对象替换旧的用户对象
- en: When a user provides a user ID and a partial user object, we should merge the
    partial object into the existing object
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户提供一个用户ID和部分用户对象时，我们应该将部分对象合并到现有对象中
- en: 'Remember to also follow our existing conventions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 记得也要遵循我们现有的约定：
- en: All request data must be transmitted in JSON format
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有请求数据必须以JSON格式传输
- en: All response data payloads must be in JSON format or plain text
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有响应数据负载必须以JSON格式或纯文本格式
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a look at how to design and structure our API so that
    it is consistent, intuitive, and simple for our end users. We then left you to
    apply these principles as you implement the CRUD and search endpoints. In the
    next chapter, we will learn how to deploy our API on a cloud server, so that it's
    available to the world!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何设计和构建我们的API，使其对最终用户来说保持一致性、直观性和简单性。然后，我们将这些原则留给你，在你实现CRUD和搜索端点时应用。在下一章中，我们将学习如何将我们的API部署到云服务器上，使其对全世界都可用！
