- en: Designing Our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last few chapters, we have followed a TDD approach to implement our
    Create User endpoint. However, a user directory application needs to do much more:
    retrieve, edit, delete, and search for users. In this chapter, we want you to
    practice what you''ve learned and implement these endpoints yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you design an API that is easy to use, we will outline some principles
    of API design. Specifically, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss what **REST** is, and what it is not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to design our API to be **consistent**, **fast**, **intuitive**, and **simple**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the different types of consistency: **Common**, **Local**, **Transversal**,
    **Domain**, and **Perennial**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What it means to be RESTful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you read about APIs, you'll undoubtedly come across the terms **SOAP**,
    **RCP**, **REST**, and nowadays also **GRPC** and **GraphQL**. The status quo
    at the time of writing is that all APIs should be "RESTful," and any APIs that
    are not RESTful are considered subpar. This is a common misconception, which stems
    from the fact that many misunderstand what REST actually is. Therefore, we start
    this chapter by examining what REST is, what it is not, why it may not always
    be practical to use it, and why our API will *not* be RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: What is REST?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST stands for **representational state transfer**, and is a set of *architectural
    styles* that dictates the manners and patterns in which you construct your API. REST
    is nothing new; you are probably already well attuned to it because that's how
    the World Wide Web is structured, so don't let the terminology alienate you.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six requirements for REST:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server**: Defines a clear **separation of concerns** (**SoC**) between
    client and server. The client should provide the user interface, while the server
    provides the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S****tateless**: No transient information about the client should be held
    on the server. In other words, the server should not persist client sessions;
    if sessions need to be persisted, it must be done on the client. Any requests
    that arrive at the server must contain all the information required to process
    that request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not to say that servers cannot store *any* state; servers can still
    persist *resource state* inside databases. But servers should not store temporary
    *application state* in memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The importance of this constraint will become apparent in [Chapter 18](5d093a43-720f-4ea8-aac0-b64b13f96d12.xhtml), *Robust
    Infrastructure with Kubernetes*, when we deploy our application as a **cluster**
    of **load-balanced** servers. By being stateless, requests can be fulfilled by
    any of the servers in the cluster, and servers can be restarted without losing
    information. It is this constraint that allows for the scalability of our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, this constraint does have its drawbacks, because the client must repeatedly
    send authentication information (for instance, a **JSON Web Token**, or **JWT**)
    with each request, increase the bandwidth used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cacheable**: If a response is going to be the same given the same request,
    then that response should be cached by the client and/or any intermediaries. A RESTful
    architecture requires that the response message *must* include an indication of
    whether the response should be cached, or not, and if so, for how long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This constraint could be beneficial as it helps reduce bandwidth usage, and
    can reduce the load on the server, freeing it up to service more requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Layered system**: Many applications, especially Node.js applications, are
    **reverse proxied** by a web server (for instance, **NGINX**). This means that
    before a request reaches our application, it may pass through layers consisting
    of web server(s), load balancers (for instance, **HAProxy**), and/or a **caching
    server** (for instance, **Varnish**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The layered system constraint dictates that the client should not know about
    these layers; in simpler terms, the client should not have to care about the implementation
    of the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Code on demand**: An optional constraint that allows the server to return
    code for the client to execute. For example, the server may send back custom JavaScript
    code, **Java applets**, or **Flash** applications. This can be viewed as an extension
    to the client-server constraint, as it ensures that the client doesn''t need to
    implement code specific for that server, which would otherwise couple the client
    and server together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: An **interface** is a shared boundary that is used to
    exchange information between two components. An interface is important as it decouples
    the server from the clients; as long as both adhere to the same interface, they
    can be developed independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The uniform interface constraint specifies rules on how this interface should
    be structured, and is further subdivided into four sub-constraints (a.k.a. **interface
    constraints**):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Identification of resources**: a unit of data that is stored on the server
    is called a **resource**. The resource is an abstract entity, such as a person
    or a product. This constraint requires that our API assign an identifier to every
    resource. Otherwise, the client won''t be able to interact with it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using REST with HTTP, this constraint is fulfilled by the use of *Uniform
    Resource* *Locators*, or *URLs*. For example, product #58 should be accessible
    through the URL `api.myapp.com/users/58/`.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Manipulation of resources through representations**: You can represent a
    resource in different formats, such as XML or JSON. These are different **representations**
    of the same resource.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a client wishes to manipulate a resource in some way, this constraint requires
    the client to send a full or partial representation of the desired state of the
    resource.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As an extension to this, the server should also indicate to the client which
    representations it is willing to accept, and which representation it is sending
    back. When using REST with HTTP, this is done through the `Accept` and `Content-Type`
    headers, respectively.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Self-descriptive messages**: The response from the server should contain
    all the information the client requires to process it properly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypermedia as the engine of application state **(**HATEOAS**): This requires
    the server response to include a list of actions that the client can take after
    receiving the response.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to apply the "RESTful" label to an API, it must adhere to *all* the
    constraints except code on demand (which is optional).
  prefs: []
  type: TYPE_NORMAL
- en: What REST is not
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss which REST constraint we should follow and which ones we
    should not, let''s underline one very important distinction: REST is an *architectural
    style*, and does not impose low-level implementation details.'
  prefs: []
  type: TYPE_NORMAL
- en: REST is a generic set of rules/patterns that you can apply to any API. We commonly
    use it to structure HTTP APIs, because HTTP is the protocol of the World Wide
    Web; however, the HTTP protocol and its verbs are in no way tied to REST.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, Roy Fielding, the author of the REST specification, was also
    the chief architect of the HTTP/1.1 specification, and so the REST style fits
    very well with an HTTP implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Should my API be RESTful?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I n the preceding section, I mentioned that our API will *not* be RESTful; let
    me explain why. While almost all constraints of REST make sense for modern APIs,
    HATEOAS does not.
  prefs: []
  type: TYPE_NORMAL
- en: Roy Fielding outlined the REST constraints in his doctoral dissertation paper
    titled *Architectural Styles and the Design of Network-based Software Architectures*,
    which you can access at [www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).
    This was back in the year 2000, before search engines such as Yahoo!, Lycos, Infoseek, AltaVista,
    Ask Jeeves, and Google became prominent. The HATEOAS constraint made sense then,
    as it allows website visitors to use the list of links to navigate from any one
    page to any other page.
  prefs: []
  type: TYPE_NORMAL
- en: However, the HATEOAS constraint makes less sense for APIs. Developers who are
    looking to use our API today are likely to refer to the API documentation on our
    project's website, rather than infer it from the server response. They're also
    likely to hardcode URLs into their application code, rather than obtaining them
    from links provided by the server.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, HATEOAS makes sense for human users, but is not so great for
    code. In fact, strictly abiding by the HATEOAS constraint would mean our response
    must include information that is not useful to the application. This will increase
    network latency without providing any tangible benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, our API will, by design, not comply with the HATEOAS constraint.
    Thus, we cannot call our API RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: This can be confusing because many APIs that claim to be RESTful in fact aren't
    (how many APIs have you used that actually return a list of endpoints with each
    request? I'd guess none). The lesson to take away is that we should analyze each
    REST constraint against our API, apply those that make sense, but understand that
    an API doesn't have to be RESTful to be "good."
  prefs: []
  type: TYPE_NORMAL
- en: Designing our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application programming interface, or API, is the interface through which
    end users can interact with our application. For an API to work, both the client
    and the API server must agree on some form of mutually agreed convention, or contract;
    for a specific type of requests, the client can expect the API to reply with a
    specific type of response. But to have a "good" API, this contract must also be
    **consistent**, **intuitive**, and **simple**. Now, let's tackle each criterion
    one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The principle of consistency is very important in API design. Arnaud Lauret,
    the author of the book *The Design of Everyday APIs*, elegantly outlined four
    different types of consistency in his blog post *The four levels of consistency
    in API design* ([restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/](http://restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/)),
    which we''ve summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common**: Being consistent with the world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local**: Being consistent within the same API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transversal**: Being consistent across different APIs by the same organization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain**: Being consistent with a specific domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have made one addition to this list—**perennial consistency***—*or being consistency *across
    time*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine each one individually.
  prefs: []
  type: TYPE_NORMAL
- en: Common consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Lauret explained, common consistency is "being consistent with the world."
    This means our API should conform to well-established and/or authoritative standards;
    or if none are available, to the community consensus.
  prefs: []
  type: TYPE_NORMAL
- en: If an API is not consistent with the world, it forces developers to learn a
    new way of thinking. This may require a sizable time investment, which may deter
    the user from trying the API in the first place. Therefore, having common consistency
    will likely improve developer experience, and may even drive up the API's adoption
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: For an HTTP API, the obvious standard to adopt is the HTTP/1.1 specification.
    This is a standard sanctioned by the **World Wide Web Consortium** (**W3C**),
    the authoritative international standards organization for the World Wide Web.
    So, let's see how we can design our API to conform to that standard.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the correct HTTP status code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTTP specification dictates that any response must have a three-digit status
    code that allows programs to determine the nature of the response. These codes
    allow a program to process the response efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Status code | Class of response | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `1xx` | Informational | The request was received but not yet fully processed.
    The client doesn''t need to do anything. |'
  prefs: []
  type: TYPE_TB
- en: '| `2xx` | Success | The request was successfully received, understood, and
    accepted. |'
  prefs: []
  type: TYPE_TB
- en: '| `3xx` | Redirection | The resource has moved, either temporarily or permanently.
    The client needs to take further actions to complete the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `4xx` | Client error | The request is syntactically and/or semantically incorrect,
    and the server was unable (or refused) to process it. |'
  prefs: []
  type: TYPE_TB
- en: '| `5xx` | Server error | The request is likely to be valid, but there was an
    error on the server. |'
  prefs: []
  type: TYPE_TB
- en: You can find the original Status Code Definitions from the W3C at [w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
    The current list of valid HTTP Status Codes is maintained by the **Internet Assigned
    Numbers Authority** (**IANA**); you can find the full list at [iana.org/assignments/http-status-codes](https://www.iana.org/assignments/http-status-codes).
    Personally, I use [httpstatuses.com](https://httpstatuses.com/), which for me
    is easier on the eye.
  prefs: []
  type: TYPE_NORMAL
- en: We have already followed these standards for our Create User endpoint. For instance,
    we respond with a `415 Unsupported Media Type` error status code when the request
    payload is not JSON; Express will automatically respond with a `404 Not Found`
    error if the client tries to hit an endpoint that is not implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to IANA, there are currently 62 assigned HTTP status codes. Most
    developers won''t be able to memorize all 62\. Thus, many APIs restrict the number
    of status codes they send back. We will do the same, and limit our API to using
    only the following nine status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200 OK`: Generic successful operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201 Created`: Successful operation where a resource, such as a user, is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400 Bad Request`: When the request is syntactically or semantically incorrect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401 Unauthorized`: When the request lacks authentication credentials so the
    server cannot determine who is sending the request. The client should resend the
    request with these credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403 Forbidden`: The server understands the request but does not authorize
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404 Not Found`: The resource is not found, or the endpoint path is invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`409 Conflict`: The resource has been modified after the client last retrieved
    it. The client should request a new version of the resource and decide whether
    it''d like to send the request again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`415 Unsupported Media Type`: The payload given for this endpoint is in an
    unsupported format, for example, sending an XML payload when the server only accepts
    JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500 Internal Server`: The request is most likely to be valid, but there''s
    an error on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTTP specification also dictated that HTTP requests must contain a verb,
    and laid out rules for which verbs can be used for what types of request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Requests the retrieval of a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Requests where the server decides how to process the data. The URL
    specifies the resource that is to handle this request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Requests for the entity to be stored under the specified URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: Requests for partial changes to be made to an existing resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Requests for the resource to be deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: Requests for the metadata of a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: Requests for information from the server regarding what requests
    are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, `GET`, `HEAD`, `OPTIONS`, and `TRACE` are considered to be **safe**
    methods, which means they must not modify the representation of any resources.
    Other verbs, such as `POST`, `PUT`, and `DELETE`, are expected to modify resources
    and should be considered *unsafe* methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also the related concept of **idempotency**. An idempotent HTTP method
    is one that can be repeated multiple times but still produces the same outcome
    as if only a single request was sent. For example, `DELETE` is an idempotent method,
    because deleting a resource multiple times has the same effect as deleting it
    once. *All safe methods are also idempotent*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Safe | Idempotent |'
  prefs: []
  type: TYPE_TB
- en: '| `CONNECT` | ✗ | ✗ |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | ✗ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | ✗ | ✗ |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | ✗ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | ✗ | ✗ |'
  prefs: []
  type: TYPE_TB
- en: '| `TRACE` | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: 'Even if we conform to the HTTP specifications, there are still multiple ways
    to update a resource: using `POST`, `PUT` or `PATCH`. Therefore, when there is
    ambiguity in how to interpret a standard, we should turn to community consensus.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a set of project guidelines published by Elsewhen, a digital
    product studio in London. It has over 17,500 stars on GitHub and can be accessed
    at [github.com/elsewhencode/project-guidelines](https://github.com/elsewhencode/project-guidelines).
  prefs: []
  type: TYPE_NORMAL
- en: 'The part of the guidelines on HTTP methods is reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: To retrieve a representation of a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: To create new resources and sub-resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: To update existing resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: To update existing resources. It only updates the fields that were
    supplied, leaving the others alone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: To delete existing resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So although we could update a resource by sending a `POST` request, we will
    limit `POST` requests only to the creation of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Following the guidelines, we will also structure our API paths using the `/<collection>/<id>` structure,
    where `<collection>` is a class of resources (for instance, users, products, or
    articles), and `<id>` is the identifier for a particular resource within that
    collection (for instance, a particular user).
  prefs: []
  type: TYPE_NORMAL
- en: We will use plural nouns to name our collection to make the URL more consistent
    and easier to read. In other words, we will use `/users` and `/users/<id>`, instead
    of `/user` and `/user/<id>`.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together, we get the following table, which details the actions
    that should be performed for each resource and HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: '| Resource | `GET` | `POST` | `PUT` | `PATCH` | `DELETE` |'
  prefs: []
  type: TYPE_TB
- en: '| `/users` | Retrieve a list of users | Create new user | Error | Error | Error
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/users/<id>` | Retrieve user | Error | Update user object (completely);
    error if user does not exists | Update user object (partially); error if user
    does not exists | Delete user object; error if user does not exists |'
  prefs: []
  type: TYPE_TB
- en: Using ISO formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For things such as units, we should use formats provided by the **International
    Organization for Standardization** (**ISO**) whenever possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date/time**: UNIX timestamps (in milliseconds) to represent times, and ISO
    8601 complete date format to represent dates ([iso.org/iso-8601-date-and-time-format.html](https://www.iso.org/iso-8601-date-and-time-format.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Currencies**: ISO 4217 currency codes ([iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Countries**: Either ISO 3166-1 alpha-2, ISO 3166-1 alpha-3, or ISO 3166-1
    numeric codes ([iso.org/iso-3166-country-codes.html](https://www.iso.org/iso-3166-country-codes.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Languages**: ISO 639-2 codes ([iso.org/iso-639-language-codes.html](https://www.iso.org/iso-639-language-codes.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Local consistency means being consistent within the same API. In other words,
    if a developer has worked with one part of your API (for instance, creating a
    user), he/she should be able to work with other parts of the API using the same
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Naming convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For example, we should follow a consistent set of naming conventions for all
    our URLs. Specifically, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use kebab-case for URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use camelCase for parameters in the query string, for example, `/users/12?fields=name,coverImage,avatar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For nested resources, structure them like so: `/resource/id/sub-resource/id`,
    for example, `/users/21/article/583`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our non-CRUD endpoints, the URL naming convention should follow a `/verb-noun` structure:
    we should use `/search-articles` instead of `/articles-search`.'
  prefs: []
  type: TYPE_NORMAL
- en: Consistent data exchange format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This may sound obvious, but we should use either use plain text or **JavaScript
    Object Notation** (**JSON**) as the format for data exchange. You shouldn't use
    JSON for one endpoint and XML for another endpoint, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Error response payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error response payloads should follow a consistent structure. For instance,
    the payload should be a JSON object with an array of error objects, each containing
    three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`code`: A numeric error code, to be used by the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: A short, human-readable summary of the error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: An optional longer, more detailed description of the error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every error payload must follow this format. This allows developers to write
    a single function that can process all error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Transversal consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transversal consistency is being consistent across different APIs within the
    same organization. The reason for this is similar to those for local consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Domain consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain consistency is being consistent with a specific domain.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you're developing a scientific publications directory, you should
    conduct some research in order to acquire knowledge and norms that are specific
    to this domain. For example, you should know that a scientific publication may
    be identified with a **PubMed Identifier** (**PMID**), PMCID, Manuscript ID, or **Digital
    Object Identifier** (**DOI**), so your API's response object should include fields
    that contain these different identifiers, or at least allow users to search for
    articles based on these IDs. This is consistent with the norms of the scientific
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is to allow for filters that are consistent with the domain.
    Continuing with the scientific publication directory example, there are usually
    a few categories of scientific publications: original/primary research, reviews,
    editorials/opinions, short reports, clinical case studies, methods, meta-analysis,
    dissertations, conference proceedings, and so on. Allowing users to filter by
    these categories would be another example of being domain consistent.'
  prefs: []
  type: TYPE_NORMAL
- en: Perennial consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, I've coined the term *perennial consistency* to mean being consistent
    with the past and future of the API.
  prefs: []
  type: TYPE_NORMAL
- en: I chose the adjective *perennial* over others such as "perpetual" or "persistent"
    because *p**erpetual* implies the API will *never* change, which is impractical; *p**ersistent* implies
    that developers should obstinately refuse to change the API even if there's a
    need to, which is not right; *p**erennial* means the API structure should stay
    the same for a long time, but not forever.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why perennial consistency is important, we must first understand
    what happens when we introduce a breaking (backward-incompatible) change to our
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking changes in APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we are developing a library and want to introduce a breaking change, we
    can simply bump the major version and publish it. Developers can freely choose if,
    and when, they want to migrate. However, the process is not so trivial for APIs
    because for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: For every version of the API, the API provider must serve and maintain a different
    instance of the service. This can be a huge overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different versions of the API would still use the same set of data, so you must
    design a data structure that is compatible with all versions. Sometimes, this
    may require you to have redundant fields in your data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the changes are too drastic, developers may keep using the older version,
    possibly prolonging the period for which you must support the older API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Breaking changes are also bad for developer experience because for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers are often given a limited period of time to update their code to
    conform to the newer version, before the older version is dropped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party libraries that depend on your API would also have to update their
    code. But if maintainers lack the time or willingness to migrate, it could lead
    to an accumulation of outdated libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, breaking changes should be avoided as much as possible. When
    you design your API, take care not to just think about the current requirements,
    but also any possible future needs.
  prefs: []
  type: TYPE_NORMAL
- en: This does not contradict the *you aren't gonna need it* (YAGNI) principle. You're
    not going to *implement* a feature you may not need. You are just going to think
    ahead, so you can plan ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Future-proofing your URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way of achieving perennial consistency is to design future-proof URLs. For
    example, if we're building a social network where every user must belong to an
    organization, we can identify a user with a URL structure similar to `/orgs/<org-id>/users/<user-id>`.
    But if we think ahead, there may be a time in the future where our platform needs
    to cater for users belonging to multiple organizations; in that case, the URL
    structure we proposed would not support this.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we should design our URL to simply include the user's ID (that is, `/users/<user-id>`).
    Then, to associate a user with an organization, we can implement the concept of
    membership, and structure the membership URL to have the structure `/orgs/<org-id>/members/<member-id>`.
  prefs: []
  type: TYPE_NORMAL
- en: Future-proofing your data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to ensure perennial consistency is to future-proof your data structure.
    For instance, if we want to store a user's name, we could simply specify a `name` property
    of type string. This may work for now, but in the future, we may want to distinguish
    between first, middle, and last names. We may even want to implement sorting and
    filtering based on first or last names. Thinking even further ahead, many people,
    especially from Asian countries, have both an English and non-English name, and
    so we might even want to allow users to provide their names in multiple languages.
    Structuring your name property as a string wouldn't work!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why our user schema specifies an object as the data structure for the
    `name` property. This allows us to add more properties to the object without breaking
    existing code. For example, our profile object may eventually evolve into something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But if a breaking change cannot be avoided, then we must abide by semantic
    versioning (semver) and increase the major version of our API. But where do we
    store the version data? There are generally two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the URL (for instance, `/v2/users`): This is by far the easiest to explain
    and implement, but it''s semantically incorrect. This is because URLs should be
    used to locate a resource; if we add versioning information to the URL, it''d
    imply that the resource itself is versioned, not the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As part of the `Accept` header (for instance, `Accept: application/vnd.hobnob.api.v2+json`):
    The `vnd` prefix in the MIME type denotes that this is a vendor-specific MIME
    type; here, we are using it to specify the API version we want. The `+json` denotes
    that the reply could be parsed as JSON. This is the most semantically correct
    approach, but it also requires more effort to explain to end users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL approach is more practical; the `Accept` header approach is more semantic.
    Neither one is "better" than the other. Pick the one that makes sense for you
    and your audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'When making a breaking change, apart from increasing the version of your API,
    make sure you also:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a grace period whenever possible, that is, a deprecation period where both
    the legacy and new versions run concurrently, in order to allow developers time
    to migrate to the newer version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide deprecation warnings in advance, including the date when the older API
    version will no longer be supported and the date when it will become unavailable
    altogether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a clear list of all breaking changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide clear instructions on how to migrate to the newer version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuitive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we interact with everyday objects, we have an expectation of how they
    are going to work. This is known in design as affordance. For example, if you
    see a handle on a door, it should be instinctive to you that you should be pulling
    on the handle; conversely, a flat rectangular piece of metal (called a finger
    plate) attached to the door implies it should be pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b44fd0e3-0b25-43a0-8504-d5a6449a6f32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Left) Adding a handle to the side of the door that is meant to be pushed is
    an example of bad design, as the handle is for pulling, not pushing. (Right) The
    handle already suggests that the door is meant to be pulled, so the "Pull" label
    is unnecessary here. This image is taken from `chriselyea.com/wp-content/uploads/2010/01/PushPullDoors.jpg` (dead
    link).
  prefs: []
  type: TYPE_NORMAL
- en: This concept of affordance is universal to all design, including API design. Likewise,
    an API should be self-explanatory and as obvious as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Users don't want to learn new behaviors. Users don't want to read the documentation
    in order to use your platform. The best case scenario is that your API is so intuitive
    that they only need to refer to the documentation once in a while.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if your API is unintuitive, then a user may still try it
    out, but they may feel the learning curve is too high and use an alternative platform
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also touches on the previous point made about consistency: if it is commonly
    consistent, then users will feel more familiar with using your API.'
  prefs: []
  type: TYPE_NORMAL
- en: Being intuitive simply means making things obvious. We should follow the** Principle
    of Least Astonishment **(**POLA**), which states that *"the result of performing
    some operation should be obvious, consistent, and predictable, based upon the
    name of the operation and other clues."*
  prefs: []
  type: TYPE_NORMAL
- en: Here, we outline a few things we can do to make sure our API is as intuitive
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: URLs for humans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Related endpoints should be grouped. For example, the Instagram API groups endpoints
    into user-, media-, tags-, and location-related endpoints, each under `api.instagram.com/v1/{group}/`.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it easy for the consumer of the endpoint to immediately be able to
    deduce the intended function of the endpoint, without having to refer to the documentation.
    The function of the endpoint should be obvious to the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it's immediately obvious that `/users/:user-id/media/recent` is
    an endpoint that retrieves the most recent media objects of a user.
  prefs: []
  type: TYPE_NORMAL
- en: Favor verbosity and explicitness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When in doubt, always favor verbosity and explicitness over implicitness, as
    it can cut out the ambiguity in the API. For example, use `userId` instead of `uid`,
    which some may interpret as "unique ID."
  prefs: []
  type: TYPE_NORMAL
- en: Keep It Simple Stupid (KISS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, a good API must be simple.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main reasons for having an API is to abstract the implementation
    details away from the end user. You should not expose internal functions to the
    end user because it will add unnecessary complexity to your API—users will have
    more documentation to read, even if 90% of it is irrelevant to what they want
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: The rule is to think about what are the minimum set of functions that can be
    exposed, but still allow a typical user to perform all the necessary functions.
    For example, when a new user signs up, a profile is automatically created for
    them, and so there's no need to expose the internal `createProfile` function as
    the `/POST profile` endpoint, as a typical user will never call it.
  prefs: []
  type: TYPE_NORMAL
- en: '"When in doubt, leave it out" is a good adage to remember; it''s often easier
    to add to an API than to remove features that some developers (albeit a very small
    percentage) are already using.'
  prefs: []
  type: TYPE_NORMAL
- en: A toddler won't cry if you don't buy them a new toy they didn't ask for, but
    try to take away a toy they are playing with, and you may find your ears ringing
    for a while.
  prefs: []
  type: TYPE_NORMAL
- en: Completing our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we have shown you how to write unit, integration,
    and E2E tests as part of a TDD process. In this chapter, we''ve outlined the factors
    you should consider when designing an API. Now, we pass the baton to you to implement
    the rest of the API. Specifically, you should implement the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User must provide a user ID to delete
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defaults to the last 10 users who have registered
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User must provide an email address and password
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: User may optionally provide a profile; otherwise, an empty profile will be created
    for them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user provides a user ID of another user, the profile of that user should
    be returned
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user provides a user ID and a complete user object, we should replace
    the old user object with the new one
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user provides a user ID and a partial user object, we should merge the
    partial object into the existing object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember to also follow our existing conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: All request data must be transmitted in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All response data payloads must be in JSON format or plain text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at how to design and structure our API so that
    it is consistent, intuitive, and simple for our end users. We then left you to
    apply these principles as you implement the CRUD and search endpoints. In the
    next chapter, we will learn how to deploy our API on a cloud server, so that it's
    available to the world!
  prefs: []
  type: TYPE_NORMAL
