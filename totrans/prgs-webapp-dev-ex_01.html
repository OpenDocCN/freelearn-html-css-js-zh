<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to Progressive Web Apps</h1>
                
            
            <article>
                
<p class="calibre2">Over 80% of 328 million active Twitter users are mobile. Twitter knew they needed their mobile experience to be faster, more reliable, and engaging. They chose to launch their default mobile experience as a <strong class="calibre4">Progressive Web Application</strong> <span class="calibre5">(<strong class="calibre4">PWA</strong>)</span> in April 2017, called Twitter Lite.</p>
<p class="calibre2">Their goals were simple, faster load times, more engagement, and lower data consumption. They were able to achieve all three when comparing general activities to the non progressive web app version:</p>
<ul class="calibre10">
<li class="calibre11">65% increase in pages per session</li>
<li class="calibre11">75% increase in Tweets sent</li>
<li class="calibre11">20% decrease in bounce rate</li>
</ul>
<div class="packt_quote2">"Twitter Lite is now the fastest, least expensive, and most reliable way to use Twitter. The web app rivals the performance of our native apps but requires less than 3% of the device storage space compared to Twitter for Android."<br class="title-page-name"/>
                                            — Nicolas Gallagher, the Engineering Lead for Twitter Lite</div>
<p class="calibre2">This is just one example of online companies reaping the rewards that PWA offers. This book should serve as a starting point to arm you with the basic knowledge and confidence to create your first PWA.</p>
<p class="calibre2">In this book, you are going to learn how to build a PWA which will be ready for production use. In case you haven't created a PWA yet, you will learn how to make a simple PWA in the first part of this chapter.</p>
<p class="calibre2">This chapter will cover PWA fundamentals and the advantages they offer over classic websites and native applications. You will also see how to upgrade an existing 2048 game web application to a PWA. You will learn how to add a web manifest and service worker to the application, enabling PWA features using a localhost web server.</p>
<p class="calibre2">The purpose of this chapter is to get a general idea of how PWAs work, why you want to deliver PWAs, and to give you the skills to easily create PWAs with basic functionalities.</p>
<p class="calibre2">This chapter will cover the following points:</p>
<ul class="calibre10">
<li class="calibre11">The purpose of PWA</li>
<li class="calibre11">PWA advantages</li>
<li class="calibre11">The basic technical requirements of a PWA</li>
<li class="calibre11">The three primary user experience PWA goals</li>
<li class="calibre11">How to upgrade an existing website and run it locally</li>
</ul>
<p class="calibre2">The web as we know it is entering its third decade of existence. Over this time, the web has gone through many changes and enhancements. While the web possesses some great superpowers, it also had its limitations that inhibited it from delivering an experience in parity with native counterparts.</p>
<p class="calibre2">PWAs are a way to apply native browser technology to create web solutions that consumers want to add to their homescreen. Meanwhile, new web APIs are progressing to fill additional gaps in functionality between web and native apps.</p>
<p class="calibre2">The great thing about a PWA is existing websites can easily be upgraded to claim the PWA status. This can unlock new features in browsers and platforms to level up any website.</p>
<p class="calibre2">About a decade ago, not only was the web disrupted, but so was desktop computing when Apple released the iPhone. This ushered in a new era of mobile first computing. That era's web technology was not prepared for this rapid shift from desktops to handheld devices.</p>
<p class="calibre2">Changing to a mobile first world requires more than just responsive design techniques; it requires a new set of native APIs, capabilities, and coding techniques. The HTML, CSS, and JavaScript specifications and browsers have evolved over the past decade, catching up to the consumer expectations of client applications.</p>
<p class="calibre2">Today, we have a very rich set of native APIs and browsers, enabling everything from geo-location to voice input and camera manipulation. There are client platforms designed to provide a rich, mobile first canvas for developers to paint engaging user experiences.</p>
<p class="calibre2">In addition to great native APIs, browsers have added new features in service workers, web manifestations, and have begun requiring HTTPS to enable modern APIs. These three technical features are the core requirements to become a PWA. However, there is much more to the art of making a good PWA. This art requires a different approach to web development.</p>
<p class="calibre2">In this book, we are going to explore the requirements of a good PWA, and how to create new and upgrade existing websites as PWAs. Along the way, we will learn how to leverage new features such as IndexedDB, multi-media, and the Fetch API to add value to our applications.</p>
<p class="calibre2">As this book progresses, you will learn how to use service workers for caching, push notifications, and background synchronization. The next chapter delves into the web manifest file. <a target="_blank" href="part0058.html#1NA0K0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 3</a>, <em class="calibre13">Making Your Website Secure</em>, covers the subtleties of upgrading to HTTPS.</p>
<p class="calibre2">This book breaks down technical and experiential requirements so that you can create a good, PWA and demonstrates this with three sample applications:</p>
<ul class="calibre10">
<li class="calibre11">The first application is a simple game, 2048. 2048 was very popular about three years ago and I still find it very addictive. Even though it's a simple game, it will demonstrate how the web can compete on an even level with common native applications.</li>
<li class="calibre11">Next, we will create a photo gallery website and see how to use service worker caching to create an application that loads instantly and runs with or without a network. <span>The application will be comparable to many popular podcast players like iTunes and Stitcher.</span></li>
<li class="calibre11">The final application is a consumer event ticket application. This application will demonstrate advanced service worker techniques like cache invalidation. I will also cover tools you can use to validate your applications and help you scaffold them for quality and consistency.</li>
</ul>
<p class="calibre2">All source code is available on GitHub, with links provided in this book. You're welcome to clone and fork these repositories. Make local copies and modify them as you wish. I would love to see how you enhance the demo applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why we needed a new way to build websites</h1>
                
            
            <article>
                
<p class="calibre2">When Apple released the iPhone in 2007, they initially intended that applications to be built using HTML. They provided an initial platform to create web applications. However, Mac developers cried put for a better native application solution and Apple answered. Apple did so with the caveat of taking 30% of the application's revenue and controlling the applications that were distributed through a closed App Store.</p>
<p class="calibre2">The closed App Store violates the openness of the web by introducing a third-party gatekeeper. This creates a layer of delay as Apple reviews your application. The review process can result in your application being censored or denied entry. The one advantage App Store offers is a sense of security and trustworthiness for consumers.</p>
<p class="calibre2">To make the App Store model interesting for Apple, they decided to take a big cut for tax-native applications. In return, Apple handles all payment and distribution infrastructure for applications. However, the web has not had a problem collecting money from consumers, nor a distribution issue.</p>
<p class="calibre2">Credit card merchant accounts typically take 2% to 3% of a transaction. Hosting has become a cheap commodity, often costing $10 or less a month for most websites.</p>
<p class="calibre2">The next perceived problem the web has suffered from is performance. Performance issues are amplified on mobile devices. Smartphones and tablets have underpowered CPUs compared to their desktop counterparts. And while more mobile devices use WiFi, cellular connections, even in the developed world, are still unreliable.</p>
<p class="calibre2">When the iPhone was first released, the web was still very static compared to what we experience today. Up to that point, the web was not a platform with animations and dynamic content.</p>
<p class="calibre2">Over the last decade, rich user experiences have become commonplace on the web with the rise of single page applications and many large frameworks. These changes have been driven in large part due to the user experiences consumers have come to expect from many native applications.</p>
<p class="calibre2">Many developers have tried to hack their way to mimicking native application experiences on mobile devices. This has led to some good progress as well as some bad experiences and coding practices.</p>
<p class="calibre2">Most bad experiences are due to a lack of awareness of the available APIs and how to use them. Poor coding techniques have also created more issues than perceived value.</p>
<p class="calibre2">A common mistake I have seen a lot is the application of server-side architecture in the browser. While outside the scope of this book, it is important to note that for a good modern web user experience, you may have to let go of preconceived notions of how to develop websites.</p>
<p class="calibre2">A prime example of misunderstanding how to use the web platform and the capability gap can be demonstrated by an interview in 2012 with Mark Zuckerberg, at a Tech Crunch event. You can check out the following link for the article: <a href="http://tcrn.ch/2hwN6HF" class="calibre9">http://tcrn.ch/2hwN6HF</a></p>
<p class="calibre2">Facebook tried to make the web its primary platform, but due to many engineering mistakes and browser/hardware limitations, they failed. At that point, they switched to native apps as a primary focus and have since created a very large, walled off community of data and interactions.</p>
<p class="calibre2">As you will see later in this book, Facebook dominates the mobile native application space. This leaves very little room for anybody else to gain screen time.</p>
<p class="calibre2">This is where PWAs can empower businesses and organizations to engage with consumers at a deeper level. This book is designed to give you the tools and knowledge to create PWAs to reach consumers for less money and effort. The web possesses several superpowers that native applications can't touch. Now, with emerging native APIs, the web surpasses native applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Real-world PWA examples</h1>
                
            
            <article>
                
<p class="calibre2">Flipkart, the Amazon of the Indian sub-continent, embraced PWA as soon as the term was first mentioned. In many ways, they are the poster child of doing a PWA the right way.</p>
<p class="calibre2">Flipkart's consumer market consists of customers almost entirely on poor mobile connections. Their mobile devices have limited storage and may or may not have a reliable 3G connection. In fact, 63% reach the site via 2G. A client application experience that loads quickly and works even when the network is absent gives Flipkart a business advantage.</p>
<p class="calibre2">The Flipkart PWA (<a href="https://developers.google.com/web/showcase/2016/flipkart" class="calibre9">https://developers.google.com/web/showcase/2016/flipkart</a>) was created by a small team of engineers in 42 days, a small investment on their part that has paid huge dividends by increasing conversions by 70%. These are just some of their published key performance indicators:</p>
<ul class="calibre10">
<li class="calibre11">Users time on the site with Flipkart lite vs previous mobile experience, 3.5 minutes vs 70 seconds</li>
<li class="calibre11">3x more time spent on site</li>
<li class="calibre11">40% higher re-engagement rate</li>
<li class="calibre11">70% greater conversion rate among those arriving via the Add to Homescreen feature</li>
<li class="calibre11">3x lower data usage</li>
</ul>
<p class="calibre2">Over 50% of the Weather Channel's mobile usage comes from the web. Reaching consumers around the world is a priority. The web offers a reliable channel to reach everyone, which often means lower powered devices. Re-engagement and the delivery of timely information, such as storm warnings, was also very important.</p>
<p class="calibre2">The Weather Channel (<a href="https://developers.google.com/web/showcase/2016/weather-channel" class="calibre9">https://developers.google.com/web/showcase/2016/weather-channel</a>) created a PWA, implementing push notifications to deliver experiences matching their native application. This upgrade enabled their team to reach 178 countries and deliver weather forecasts while improving their load time:</p>
<ul class="calibre10">
<li class="calibre11">This PWA is now available in 62 languages and 178 countries</li>
<li class="calibre11">80% improvement in load time</li>
<li class="calibre11">Based on this successful global test, the team will expand the PWA to its U.S site in 2017</li>
</ul>
<p class="calibre2">Lancôme (<a href="https://developers.google.com/web/showcase/2017/lancome" target="_blank" class="calibre9">https://developers.google.com/web/showcase/2017/lancome</a>) rebuilt their mobile web presence as a PWA and increased conversions by 17%. As they tracked mobile web usage, passing desktop, Lancôme saw their conversions drop. After considering a native application, they decided investing in the web was the right way to go.</p>
<p class="calibre2">They determined customers were not likely to download a native application, nor use it often. They knew a web presence would have to be done right, as doing so could generate more rewards. They decided to rebuild their web presence from the ground up as a PWA.</p>
<p class="calibre2">Overall benefits:</p>
<ul class="calibre10">
<li class="calibre11">84% decrease in time until the page is interactive</li>
<li class="calibre11">17% increase in conversions</li>
<li class="calibre11">15% decrease in bounce rate</li>
<li class="calibre11">51% increase in mobile sessions</li>
</ul>
<p class="calibre2">iOS improvements:</p>
<ul class="calibre10">
<li class="calibre11">53% increase in mobile sessions on iOS</li>
<li class="calibre11">10% decrease in bounce rates on iOS</li>
</ul>
<p class="calibre2">Push notification benefits:</p>
<ul class="calibre10">
<li class="calibre11">8% of consumers who tap on a push notification make a purchase</li>
<li class="calibre11">18% open rate from push notifications</li>
<li class="calibre11">12% increase in conversion rates on recovered carts via push notifications</li>
</ul>
<p class="calibre2">If you are worried about browsers that do not support PWA technology yet, take note of the iOS statistics. Lancôme is not alone; almost every company embracing PWAs have reported similar improvements on iOS. Later, you will see how to polyfill caching and the Add to Homescreen experience in your applications to achieve similar results.</p>
<p class="calibre2">These are just a few samples of major brands that have adopted PWAs and reported benefits. There are many more smaller businesses also improving because they are building web experiences customers want to use. The great thing is you can start enhancing your existing web site today using examples from this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What are PWAs?</h1>
                
            
            <article>
                
<p class="calibre2">Two years ago, a Google Chrome engineer, <em class="calibre13">Alex Russell</em>, published the landmark blog post defining PWA. You can check the post on the following link: <a href="http://bit.ly/2n1vQ2r" class="calibre9">http://bit.ly/2n1vQ2r</a></p>
<p class="calibre2">With this blog post Alex declared that web could now stand toe to toe with native applications. But it goes beyond just native capabilities being added via service workers, and the Add to Homescreen heuristic also matters when it comes to building a website.</p>
<p class="calibre2"> Another Google Chrome engineer, Chris Wilson said that Progressive Web Applications are a new level of thinking about the quality of your user experience.</p>
<p class="calibre2">What the Chrome team and other browsers want you to understand is that user experience is the most important part of your website or application. Browsers are providing you with the foundation to build great applications, but it is still up to you to make these experiences come to life.</p>
<p class="calibre2">I tend to think that there is a confidence issue web developers have compared to native application developers. There is still this perception that native rules everything. However, this is not really true. As we'll see later, there are far more accessible web pages than native applications., and there is much more room to grow your website's brand compared to a native application.</p>
<p class="calibre2">Native applications serve a purpose, and that purpose is starting to fade away. The former head of Opera, <span class="calibre5">Bruce Lawson, </span>a very popular browser on mobile devices, stated (http://bit.ly/2e5Cgry) that native apps are a bridging technology.</p>
<p class="calibre2">That's a very bold statement, comparing the web to native applications. But it's something to think about. There are often many bridging technologies that lead to the real consumable product.</p>
<p class="calibre2">For example, Netflix began by shipping DVDs in the mail. I'm sure you could still do that today, but the vast majority of Netflix members simply stream and download video content to watch. The DVDs were a mere bridging technology to get the company started and form a relationship with a very loyal customer base.</p>
<p class="calibre2">The expenses involved in distributing those DVDs became too much for them to make it their primary distribution channel. As technology improved, which led to an increase in broadband, Netflix was able to shed the bridging distribution technology and focus on the original goal of getting videos and movies the living rooms of members all over the world.</p>
<p class="calibre2">In much the same way, mobile was a brand-new platform for building application experiences. And just like desktop computing, it started with native applications, and the web eventually won them over. The web won the desktop just as mobile technology emerged, and it emerged in a big way.</p>
<p class="calibre2">PWA signify a retooling of the web to make it a mobile first platform. Your applications can run faster, work offline, and ask users for permission to be on their homescreen. Never before have we been able to deploy these experiences at this level on the web.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Peak app</h1>
                
            
            <article>
                
<p class="calibre2">Smartphone owners always lookout to download apps they think will be useful. If you are fortunate enough to have a consumer download your application, then odds are that they will delete it after one use if they find it troublesome or difficult to use.</p>
<p class="calibre2"> According to a Nielsen study (<a href="http://www.nielsen.com/us/en/insights/news/2015/so-many-apps-so-much-more-time-for-entertainment.html" class="calibre9">http://www.nielsen.com/us/en/insights/news/2015/so-many-apps-so-much-more-time-for-entertainment.html</a>) that average adult uses less than 30 apps per month. Over time the lack of using an app leads to the unused apps being purged.</p>
<p class="calibre2">Several studies estimate roughly 10% of apps are used enough times to be retained. This means even if your app is downloaded the odds are it will eventually be removed and probably never used.</p>
<p class="calibre2">Brands are spending between $8-12 in advertising to earn a single application download. This means the true customer acquisition cost is roughly $80-120. Good luck recuperating that expense.</p>
<p class="calibre2">The Apple and Google App Store's boast of 2 million or more applications. Some, dated, research shows nearly 60% of apps are never downloaded.</p>
<p class="calibre2">Apple recently made the barrier to success even higher by enforcing section 4.2.6 of their application guideline requirements. This section gives them the authority to reject and remove apps at their discretion. They have been purging apps in mass they don't consider meet these arbitrary guidelines.</p>
<p class="calibre2">Why have consumers stopped downloading applications? Space, both physical and temporal. Mobile phones and tablets only have so much disk space. Many applications now need 100 MB-1 GB of space. While a few 128 GB iPhones are sold, the typical iPhone size is 32 GB. After personal photos, videos, and music, there is little to no room for applications.</p>
<p class="calibre2">While we have become a society that can never seem to leave our mobile screens, there is still only so much time in a day. Market analysts pay close attention to what we do with our screen time. Kids watch videos and play silly games. Adults live in social media with Facebook and Snapchat owning their phones. Adults also play silly games, such as 2048.</p>
<p class="calibre2">Out of the top five applications one these App Stores, Facebook owns three. The average adult spends over 2 hours a day in the Facebook universe looking at photos and videos. Text messaging is being replaced with Facebook Messenger. Millennials are addicted to Instagram, sharing, liking, and commenting on photos and videos non-stop.</p>
<p class="calibre2">Facebook, Facebook Messenger, and Facebook-owned Instagram are the top three mobile applications. They are followed by YouTube, SnapChat, and Gmail. Two of those are owned by Google. After those applications, the distribution curve drops to nearly zero.</p>
<p class="calibre2">We, mobile consumers, have settled into usage habits and have found that the need for applications has passed.</p>
<p class="calibre2">Installing an application, even if it is free, consists of eight steps, each step losing 20% of the initial interested base. The reason Amazon implemented <strong class="calibre4">one click</strong> purchasing was to eliminate friction and increase sales.</p>
<p class="calibre2">The web is relatively frictionless. You click a link in an email or maybe search for something, clicking the best perceived result, and within a few seconds you have downloaded or installed the web page you need. Little to no friction and next to no device resources have been used.</p>
<p class="calibre2">In contrast to the distribution of app usage in a given month, the average consumer visits over 100 websites. That is roughly 20 times more variety than their application distribution. This means there is more opportunity to engage customers via the web than native applications.</p>
<p class="calibre2">The web satisfies two important consumer requirements of minimal resource investment. Very little time or disk space is needed. In fact, they do not need to uninstall your website when they clean out their device so that they can make more videos to share on Instagram.</p>
<p class="calibre2">This is where PWA have risen in importance. Companies want their icons on consumer's devices. This symbolizes a relationship and hopefully increases sales or other engagement statistics. When brand engagement is cheap for the customer, they are more likely to take the step to make you part of their daily life.</p>
<p class="calibre2">Browsers are providing the engagement platform, but you still need to meet their requirements. That is what you are going to learn in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">PWA features</h1>
                
            
            <article>
                
<p class="calibre2">Don't mistake PWAs as a specific technology. It is more of a marketing term describing the usage of modern platform features to provide a certain quality of experience. Without good user experience, the technology does not matter.</p>
<p class="calibre2">The Chrome team has identified four experience factors a PWA should offer:</p>
<ul class="calibre10">
<li class="calibre11">Fast</li>
<li class="calibre11">Reliable</li>
<li class="calibre11">Engaging</li>
<li class="calibre11">Integrated</li>
</ul>
<p class="calibre2">Research has shown that 53% of users will abandon a site if it takes longer than 3 seconds to load. Service worker caching makes page load time almost instant, but it cannot make animations faster. This requires knowledge of CSS animations and possibly JavaScript.</p>
<p class="calibre2">Applications that stutter or jump around the screen are said to be janky. If you have ever loaded a web page, for example, almost any news website, and had the content jump up or down just as you start reading, you know what I am talking about. This is a very poor user experience and can easily be avoided with proper coding practices.</p>
<p class="calibre2">Later in this book, you are going to learn about <strong class="calibre4">RAIL</strong> (<strong class="calibre4">Response, Animation, Idle, Load</strong>) and the <strong class="calibre4">PRPL</strong> (<strong class="calibre4">Push, Render, Pre-cache, and Lazy- load</strong>) patterns. These are coding best practices offered by the Chrome team because they understand how browsers work. They, and the other browsers, want the web to work for everyone.</p>
<p class="calibre2">Browser vendors are offering guidance to help developers create the class of web applications that will earn a place on customer's homescreens. This guidance starts with a mobile performance first approach.</p>
<p class="calibre2">Consumers need to have confidence in an application, and they need to know that the application is reliable. This means it should just work when called upon. To enable this, a web application should load if the device is online, offline, and anything in-between.</p>
<p class="calibre2">Service worker caching provides a proxy layer between the browser and the network. This makes the network a progressive enhancement. It also introduces a new class of programming web developers must master.</p>
<p class="calibre2">Later in this book, you are going to learn about different caching strategies and how to employ them in different scenarios to make websites just work.</p>
<p class="calibre2">Service workers open up a new layer of opportunity where web developers can add valuable features that improve performance, engagement, and data management. Service workers are designed to be extensible so future capabilities can be added. Right now, caching, push notifications, and background sync are supported, but there are many other features being debated in the W3C working groups.</p>
<p class="calibre2">Push notifications give you the ability to connect with a consumer any time you wish, increasing engagement. As shared earlier, both the Weather Channel and Lanc<span class="calibre5">ô</span>me increased engagement via push notifications.</p>
<p class="calibre2">Background sync is a channel you can now use to let your application run when the network is unavailable. When connectivity is restored, you can seamlessly synchronize with the server without disrupting the user. Their phone may even be in their pocket while your application catches up.</p>
<p class="calibre2">A web application needs to engage users enough that they will want to make it a permanent fixture on their devices. Once your web application has the minimum technical requirements—a web manifest, registered service worker with a fetch event handler, and served via HTTPS—the browser triggers native prompts for the user to add the web application to their homescreen. You will delve more deeply into this experience as this book progresses.</p>
<p class="calibre2">The web manifest, HTTPS, and service worker require different expertise to execute effectively. And in my opinion, they increase in complexity from the latter. That is why embracing PWA is often called a journey. It's something you can, and should, implement in steps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">PWA advantages</h1>
                
            
            <article>
                
<p class="calibre2">I teased you with the advantages the web has over native applications, but how do these advantages elevate the web's past native applications?</p>
<p class="calibre2">Let's borrow a demonstration from the Chrome team. An XY graph can show the differences between the web and native applications. The vertical axis represents <span class="calibre5">Capabilities</span>. The x-axis represents <span class="calibre5">Reach</span>. The reach being defined is how easy it is to discover and quickly access the application or website:</p>
<div class="cdpaligncenter"><img src="../images/00005.jpeg" class="calibre18"/></div>
<p class="calibre2">For many years, native applications enjoyed a capability advantage. They had tight native platform APIs and hooks that enabled native applications to do things that the web was not designed to do. For example, native push notifications allow brands to send messages to customers without the application being open.</p>
<p class="calibre2">However, apps are gated behind closed App Stores on Apple, Android, and even the Microsoft ecosystem. This makes finding applications very difficult. Many estimates show it takes between $8 and $12 a day to get a single app download.</p>
<p class="calibre2">The web, as I mentioned earlier, simply was not ready for this shift to mobile. There have been several APIs such as geo-location and some web notification capabilities. These APIs are not necessarily on the same level with their native counterparts.</p>
<p class="calibre2">Developers have lacked awareness of many modern APIs. Unfortunately, this lack of knowledge and confidence has caused websites to not take advantage of these capabilities.</p>
<p class="calibre2">Ten years ago, responsive design did not exist. However, today, not only do we have CSS media queries and a vast array of responsive CSS libraries, but we also have responsive images built-in to browsers. Now, websites can offer layouts and download appropriately sized images for all screen sizes without crazy hacks.</p>
<p class="calibre2">Compared to their native counterparts, websites have always been easily discoverable. You can advertise a domain in any media channel and people know how to load it. Search engines are much more sophisticated than App Stores and provide an easy interface to find just about anything. The big advantage search engines have over App Stores is the ability to deeply index web content.</p>
<p class="calibre2">Search engines index pages deep within a website and thousands upon thousands of web pages per site. App stores can only offer a single point of entry to download the app. The only <em class="calibre13">page</em> you have control of is a sales page. In that one page, you need to sell your app without the customer sampling your content and experience. Reach is and has always been the web's greatest superpower:</p>
<div class="cdpaligncenter"><img src="../images/00006.jpeg" class="calibre19"/></div>
<p class="calibre2">As the graph visualizes, the web is not only on equal footing with native applications—it exceeds native applications is most cases. Sure, there are still going to be edge cases where a native application is the best choice, but these are shrinking every time a browser adds a new feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">PWA technical requirements</h1>
                
            
            <article>
                
<p class="calibre2">At a minimum, there are three core technical requirements to be a PWA. A website must have a web manifest file, be served using HTTPS, and must register a service worker with a fetch event handler. You will dive deeper into each one of these requirements in future chapters.</p>
<p class="calibre2">The web manifest drives the Add to Homescreen experience. HTTPS provides a layer of security and trust between your application and the browser. The service worker provides the extensible backbone for event-driven functionality to execute on a separate thread from the user interface.</p>
<p class="calibre2">A PWA should also use an application shell or common HTML and CSS. This is the most common application of Chrome, which is used on just about every page on the site. If you have any experience with single page applications, you should understand what an application shell is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The application shell</h1>
                
            
            <article>
                
<p class="calibre2">A typical application shell typically contains a header, a main content area, and a footer. Of course, this can vary by application and site. The 2048 game differs because there is only one web page:</p>
<div class="cdpaligncenter"><img src="../images/00007.jpeg" class="calibre20"/></div>
<p class="calibre2">Application shells are common-place in single page applications because they dynamically render markup and data in the browser. This does not need to be the case with a PWA. The reason single page applications are so popular is their ability to create a more native-like transition experience because there is no request delay when a new page is requested.</p>
<p class="calibre2">Since a PWA can be cached locally, this does not mean you need a true application shell. If the application utilizes a cache first strategy, pages can load in a matter of milliseconds, often less than 100. This is perceived as instant by the human mind.</p>
<p class="calibre2">This does not mean you should not identify an application shell. Server and build rendering engines can use the application shell and an array of layouts to create server hosted markups. You will be exposed to this so that you can work as we build the photo gallery and podcast application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2048</h1>
                
            
            <article>
                
<p class="calibre2">A few years ago, a popular application was a simple game called 2048. The goal is to combine blocks with numbers to ultimately total 2048. Blocks are numbered in multiples of 2. You can combine adjacent blocks with the same value to create a new block with their combined value.</p>
<div class="cdpaligncenter"><img src="../images/00008.jpeg" class="calibre21"/></div>
<p class="calibre2">I wasted more time playing this game than I care to admit. It is easy to play and highly addictive. A well-crafted brew of endorphins and gameplay.</p>
<p class="calibre2">Fortunately, there were numerous open source knock-offs available on GitHub. Several were web applications. I would wager that native versions distributed through app stores were websites wrapped in a native shell, a hybrid application.</p>
<p class="calibre2">I chose a popular repository to fork for the book. The 2048 web application is simple and a perfect candidate to demonstrate how to make an exemplary PWA example:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The source code</h1>
                
            
            <article>
                
<p class="calibre2">The original application source code is available on GitHub (<a href="https://github.com/gabrielecirulli/2048" target="_blank" class="calibre9">https://github.com/gabrielecirulli/2048</a>). You can clone the repository and open it in a browser to play the game. Just be forewarned that it is addictive and could distract you from learning how to create PWAs.</p>
<p class="calibre2">I forked the repository in my GitHub profile (<a href="https://github.com/docluv/2048" target="_blank" class="calibre9">https://github.com/docluv/2048</a>). My version adds the manifest, icons, service workers, and applies some code upgrades to make the application perform better and take advantage of newer APIs and browser features. The original code was written very well, but this was for browser capabilities of 3 years ago.</p>
<p class="calibre2">Feel free to star, clone, and fork my GitHub repository to customize it to your liking. A working version of the final application created in this book is available online (<a href="https://2048.love2dev.com/" target="_blank" class="calibre9">https://2048.love2dev.com/</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The application's code structure</h1>
                
            
            <article>
                
<p class="calibre2">Let's review how the game's source code is structured. I like this project because the code is simple and demonstrates how much can be accomplished with a small amount of code in the browser.</p>
<p class="calibre2">There are three asset folders: <kbd class="calibre12">js</kbd>, <kbd class="calibre12">meta</kbd>, and <kbd class="calibre12">style</kbd>. They contain JavaScript files, images, and style sheets that are needed to render and execute the game.</p>
<p class="calibre2">You will also notice a <kbd class="calibre12">node_modules</kbd> folder. I added a local web server using <kbd class="calibre12">grunt connect</kbd>, which is a node module. The original game works just fine if you load the <kbd class="calibre12">index.html</kbd> file directly in the browser. However, due to security constraints, a service worker does not function without a web server. I will cover this in more detail shortly.</p>
<p class="calibre2">At the root-level, there are only handful of web application files:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">index.html</kbd></li>
<li class="calibre11"><kbd class="calibre12">manifest.json</kbd></li>
<li class="calibre11"><kbd class="calibre12">sw.js</kbd></li>
<li class="calibre11"><kbd class="calibre12">favicon.ico</kbd></li>
</ul>
<p class="calibre2">The nice thing about the 2048 code is that it only requires a single HTML file. The <kbd class="calibre12">manifest.json</kbd> and <kbd class="calibre12">sw.js</kbd> files add the PWA functionality we are after. The <kbd class="calibre12">favicon.ico</kbd> file is the icon loaded by the browser for the address bar:</p>
<div class="cdpaligncenter"><img src="../images/00009.jpeg" class="calibre20"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding node modules to the project</h1>
                
            
            <article>
                
<p class="calibre2">The original repository is a stand-alone game, meaning it does not require a web server to execute, just a browser. You can right-click the <kbd class="calibre12">index.html</kbd> file and choose to open it in your favorite browser. You can still do this after registering a service worker and may not notice any differences. But if you open the browser console (<em class="calibre13">F12</em> Developer Tools), you will most likely see an error.</p>
<p class="calibre2">This error can be attributed to service worker requirements. Service workers, like most new APIs supported by browsers, require HTTPS protocol. This requirement raises the default security level and gives the browsers a minimum level of trust in your site ownership.</p>
<p class="calibre2">The service worker specification relaxes this requirement for localhost addresses. Localhost is a common way to reference your local machine, which is typically a development environment. Because it is unlikely you are going to hack yourself, browsers tend to let you do what you want—except when you open files directly from the file system.</p>
<p class="calibre2">When localhost is used to load an asset, the browser is making a traditional network request, which requires a web server to respond. This means you, the user of the local machine, has gone through the effort of launching a local web server. This is not something the average consumer knows how to do.</p>
<p class="calibre2">A file, opened from the file system, is different. Anyone can send you an <kbd class="calibre12">index.html</kbd> file that loads scary code, designed to steal your identity or worse show endless loops of cat videos! By not honoring the direct file system, access browsers are protecting you from registering a malicious service worker script. Trusting a localhost web server makes development easier by avoiding the messy process of registering a localhost SSL certificate.</p>
<p class="calibre2">There are a variety of local web servers you can run. In recent years, my preference is node connect, which I execute as a Grunt task (<a href="https://love2dev.com/blog/make-a-local-web-server-with-grunt-connect/" target="_blank" class="calibre9">https://love2dev.com/blog/make-a-local-web-server-with-grunt-connect/</a>). Because connect is a node module, you can launch it directly from the command line or a custom script. There are modules for your favorite task runner, such as Gulp and so on. Besides, node is cross-platform, so everyone can use connect.</p>
<p class="calibre2">If you are familiar with installing node modules, you can skip ahead. If node and connect are new to you, this section will serve as a simple primer to get you up and running to run all the samples applications in this book on your local machine.</p>
<p class="calibre2">The first step to loading a node module is to install them from <a href="https://www.npmjs.com/" target="_blank" class="calibre9">https://www.npmjs.com/</a> or one of the emerging package manager sites. You can manage this from the command line if you like, or you can define the modules needed in a <kbd class="calibre12">package.json</kbd> file.</p>
<p class="calibre2">You can read more about the <kbd class="calibre12">package.json</kbd> format here (<a href="https://docs.npmjs.com/files/package.json" target="_blank" class="calibre9">https://docs.npmjs.com/files/package.json</a>). For our purposes, <kbd class="calibre12">grunt</kbd> and the <kbd class="calibre12">grunt-contrib-connect</kbd> module are <kbd class="calibre12">devDependencies</kbd>. You could also define a dependencies section if this were a node application.</p>
<p class="calibre2">Grunt is a task runner that gained popularity several years ago and is still my preferred task runner. Task runners, and there seems to be a new one every week, help you organize repeatable tasks into repeatable recipes. I use Grunt and custom node scripts to build and deploy my PWAs. Think about your task runner as a command-line control panel to manage your application:</p>
<pre class="calibre17">{<br class="title-page-name"/>    "name": "2048",<br class="title-page-name"/>    "version": "1.0.0",<br class="title-page-name"/>    "description": "2048 Progressive Web App",<br class="title-page-name"/>    "author": "Chris Love",<br class="title-page-name"/>    "private": true,<br class="title-page-name"/>    "devDependencies": {<br class="title-page-name"/>        "grunt": "*",<br class="title-page-name"/>        "grunt-contrib-connect": "*"<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Both Grunt and the Grunt connect module are node packages and must be downloaded in order to execute. The <kbd class="calibre12">package.json</kbd> file gives npm a configuration so it can manage your packages. This way, you can quickly set up your project on any machine without having to maintain your node dependencies as part of the source code.</p>
<p class="calibre2">If you have cloned the sample repository, you will note that the node modules were excluded from the source code. That's because they are not part of the application itself. They are a dependency and npm helps you recreate the desired environment.</p>
<p class="calibre2">To install the packages, you need to open a command line and change to your source code's folder. Next, you must execute the following command:</p>
<pre class="calibre17"><strong class="calibre1">&gt;npm install</strong></pre>
<p class="calibre2">This kicks off the npm installation process, which downloads your modules and their dependency chain. When completed, you have everything you need to run or build your application.</p>
<p class="calibre2">Next, you will need to create a <kbd class="calibre12">gruntfile.js</kbd>. This is where you tell Grunt what tasks you want to run and how you want them to run. If you want to know the details of using Grunt, visit their website (<a href="https://gruntjs.com/" target="_blank" class="calibre9">https://gruntjs.com/</a>):</p>
<pre class="calibre17">module.exports = function (grunt) {<br class="title-page-name"/>    grunt.loadNpmTasks('grunt-contrib-connect');<br class="title-page-name"/>    // Project configuration.<br class="title-page-name"/>    grunt.initConfig({<br class="title-page-name"/>        connect: {<br class="title-page-name"/>            localhost: {<br class="title-page-name"/>                options: {<br class="title-page-name"/>                    port: 15000,<br class="title-page-name"/>                    keepalive: true<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    });<br class="title-page-name"/>};</pre>
<p class="calibre2">Since we are only using the connect module, the 2048 gruntfile is very simple. You need to tell Grunt to load the connect module, then register the task to run in the <kbd class="calibre12">initConfig</kbd> function.</p>
<p class="calibre2">2048 is a very simple application, which keeps our customization to a minimum. I arbitrarily chose port 15000 to serve the application and chose to have <kbd class="calibre12">keepalive</kbd> open. There are many options you can define. More details are available on the <kbd class="calibre12">grunt-contrib-connect</kbd> npm page (<a href="https://www.npmjs.com/package/grunt-contrib-connect" target="_blank" class="calibre9">https://www.npmjs.com/package/grunt-contrib-connect</a>).</p>
<p class="calibre2">The only task left to do is start the connect web server. This is done from the command line. If you still have the command line open from when you performed the npm install, you can reuse it. If not, repeat the process of opening a command line and changing to the project's folder:</p>
<pre class="calibre17"><strong class="calibre1">&gt;grunt connect</strong><br class="title-page-name"/><strong class="calibre1">Running "connect:localhost" (connect) task</strong><br class="title-page-name"/><strong class="calibre1">Waiting forever...</strong><br class="title-page-name"/><strong class="calibre1">Started connect web server on http://localhost:15000</strong></pre>
<p class="calibre2">Execute <kbd class="calibre12">grunt connect</kbd> and you should see the preceding example output. Note that the command continues to execute. This is because it is a server, listening to requests on port 15000. You cannot execute additional commands at this prompt.</p>
<p class="calibre2">You can now load the 2048 game in your browser by entering <kbd class="calibre12">http://localhost:15000</kbd> in the address bar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding a manifest</h1>
                
            
            <article>
                
<p class="calibre2">Adding a web manifest file should be the first step in upgrading an existing website. You can create your site's manifest file in a matter of minutes. In the tooling chapter, I will review a few online resources that can help automate the process.</p>
<p class="calibre2">Registering a PWA's web manifest requires a special link element in the HTML <kbd class="calibre12">head</kbd> element. The following code shows how the 2048 manifest file is registered:</p>
<pre class="calibre17">&lt;head&gt;<br class="title-page-name"/>      ….<br class="title-page-name"/>  &lt;link rel="manifest" href="manifest.json"&gt;<br class="title-page-name"/>&lt;/head&gt;</pre>
<p class="calibre2">If you are familiar with referencing a style sheet, this syntax should look familiar. The difference is the <kbd class="calibre12">rel</kbd> attribute value being manifest. The <kbd class="calibre12">href</kbd> value points to the manifest file. You are free to name it anything, but manifest is the most common name.</p>
<p class="calibre2">The next chapter will go into more manifest file details. You can reference the project's <kbd class="calibre12">manifest.json</kbd> file to see how the 2048 game is configured. It contains the application's name, default URL, primary colors, and an array of icon image references.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding a service worker</h1>
                
            
            <article>
                
<p class="calibre2">Next, you need to register a service worker. This is done in what I call the client-side code, which is the JavaScript you are accustomed to writing. Service workers execute in a separate thread from the UI. I think about it as a background process. You still need to register the service worker for the site.</p>
<p class="calibre2">For simple registrations, like this example, my preferred method is a script block at the bottom of my site's markup. First, detect if service workers are supported. If they are, then attempt to register the site's service work. If the browser does not support service workers, skip the registration code so no exceptions occur.</p>
<p class="calibre2">Registration is done by calling the <kbd class="calibre12">navigator.serviceWorker.register</kbd> function. It accepts a single argument, which is a path to the service worker file. I will review more rules around this in later chapters.</p>
<p class="calibre2">The register function returns a promise. You can add code to log successful registration as follows:</p>
<pre class="calibre17">      &lt;script&gt;<br class="title-page-name"/>        if ('serviceWorker' in navigator) {  <br class="title-page-name"/>            navigator.serviceWorker.register('/sw.js').then(function <br class="title-page-name"/>             (registration) {    // Registration was successful                   <br class="title-page-name"/>                console.log('ServiceWorker registration successful with <br class="title-page-name"/>               scope: ', registration.scope);  <br class="title-page-name"/>            }).catch(function (err) {    // registration failed :(<br class="title-page-name"/>                console.log('ServiceWorker registration failed: ', <br class="title-page-name"/>                err);  <br class="title-page-name"/>            });<br class="title-page-name"/>        }<br class="title-page-name"/>    &lt;/script&gt;</pre>
<p class="calibre2">We will start diving into details about service workers in <a href="" target="_blank" class="calibre9">Chapter 5</a>, <em class="calibre13">The Service Worker Life Cycl</em>e. To help you understand the example code, let me introduce some service worker fundamentals. Service workers are completely asynchronous. They enter an idle or sleep state if they are not needed. They wake up or spin up completely in response to the operating system or browser firing and events.</p>
<p class="calibre2">All logic execution is a product of events. You must register event handlers to execute your service worker logic. The 2048 service worker registers event handlers for the install, activate, and fetch events.</p>
<p class="calibre2">The 2048 game service worker pre-caches the entire application in the install event. You will learn more about caching strategies in <a href="" target="_blank" class="calibre9">Chapter 6</a>, <em class="calibre13">Master the Cache API – Manage Web Assets in a Podcast Application</em>. For now, we will cache the application so it is available all the time, without any network chatter:</p>
<pre class="calibre17">self.addEventListener("install", function (event) {<br class="title-page-name"/>    console.log("Installing the service worker!");<br class="title-page-name"/>    caches.open("PRECACHE")<br class="title-page-name"/>        .then(function (cache) {<br class="title-page-name"/>            cache.addAll(cacheList);<br class="title-page-name"/>        });<br class="title-page-name"/>});</pre>
<p class="calibre2">The 2048 service worker caches assets in the install event. The application assets are defined in an array in the server worker code. The cache API provides an interface to a special storage designed specifically to persist response objects. I will defer the details to later chapters:</p>
<pre class="calibre17">var cacheList = [<br class="title-page-name"/>    "index.html",<br class="title-page-name"/>    "style/main.css",<br class="title-page-name"/>    "js/keyboard_input_manager.js",<br class="title-page-name"/>    "js/html_actuator.js",<br class="title-page-name"/>    "js/grid.js",<br class="title-page-name"/>    "js/tile.js",<br class="title-page-name"/>    "js/local_storage_manager.js",<br class="title-page-name"/>    "js/game_manager.js",<br class="title-page-name"/>    "js/application.js"<br class="title-page-name"/>];</pre>
<p class="calibre2">The service worker also has an activate and a fetch event handler. A fetch event handler must be registered before the add to homescreen feature can be triggered.</p>
<p class="calibre2">The fetch event fires when the browser requests an asset from the network. This could be an image, stylesheet, script, AJAX call, and so on. The <kbd class="calibre12">event</kbd> parameter contains the request object and can be used to check your cache to see if the asset is available:</p>
<pre class="calibre17">self.addEventListener("fetch", function (event) {<br class="title-page-name"/>    event.respondWith(<br class="title-page-name"/>        caches.match(event.request)<br class="title-page-name"/>        .then(function (response) {<br class="title-page-name"/>            if (response) {<br class="title-page-name"/>                return response;<br class="title-page-name"/>            }<br class="title-page-name"/>            return fetch(event.request);<br class="title-page-name"/>        })<br class="title-page-name"/>    );<br class="title-page-name"/>});</pre>
<p class="calibre2">Without a fetch event handler, your application cannot work offline. There is no requirement that the handler catch any requests, just that it is registered. It is a minimal check for offline capability.</p>
<p class="calibre2">In the example fetch event handler, all caches are interrogated to see if there is an existing match to the request. If so, the locally cached version is returned. If not, the request is passed to the network.</p>
<p class="calibre2">That's it; congratulations! Your website is now a PWA, at least on your local machine:</p>
<div class="cdpaligncenter"><img src="../images/00010.jpeg" class="calibre22"/></div>
<p class="calibre2">At this point, loading the 2048 localhost site in Chrome should cause an add to homescreen prompt being displayed. If not, reload the page once or twice and apply focus to the browser tab. If you are still not seeing the prompt, check the console for any error messages and debug them accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary </h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you have learned the basics of PWAs by updating a basic game website. We also reviewed what progressive websites are and why they were created.</p>
<p class="calibre2">In the next chapter, you will learn more details about the homescreen prompt experience and how to make a proper web manifest file.</p>


            </article>

            
        </section>
    </body></html>