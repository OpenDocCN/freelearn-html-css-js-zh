- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Architecting Frontend Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构前端框架
- en: 'In this chapter, we now switch focus to the frontend components of the full
    stack framework that we began building in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108).
    This is the final part of adding new features and architecting the technical design
    for the purposes of our **Componium** framework example. The frontend features
    are the most complex to design because they require a lot of domain knowledge
    of browsers, in-depth JavaScript, the ability to handle complex edge cases, and
    so on. We will cover a series of frontend topics that focus on enabling a full
    stack framework development environment. Here are some of the topics that we will
    cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们现在将重点转向我们在[*第7章*](B19014_07.xhtml#_idTextAnchor108)中开始构建的全栈框架的前端组件。这是为我们的**Componium**框架示例添加新功能和构建技术设计的最终部分。前端特性是最复杂的，因为它们需要大量的浏览器领域知识、深入的JavaScript知识、处理复杂边缘情况的能力等等。我们将涵盖一系列关注于启用全栈框架开发环境的前端主题。以下是我们将涵盖的一些主题：
- en: '**Frontend features**: We will determine the features and goals of the frontend
    components for our framework. In addition, this new frontend infrastructure needs
    to interact with the existing components of the full stack framework, such as
    the backend API routes and the testing interfaces.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端特性**: 我们将确定我们框架的前端组件的功能和目标。此外，这个新的前端基础设施需要与全栈框架的现有组件进行交互，例如后端API路由和测试接口。'
- en: '**Architectural design**: After learning more about the low-level interfaces
    of established frameworks, we will create a framework design that can offer similar
    features with low-level interfaces of its own. This includes developing a component,
    view, and routing architecture to server content to the web browser.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建筑设计**: 在深入了解现有框架的低级接口后，我们将创建一个框架设计，它能够提供与自身低级接口相似的功能。这包括开发一个组件、视图和路由架构，以向网页浏览器提供内容。'
- en: '**Frontend patterns**: Learning about common frontend patterns and optimizations
    will help us become more accustomed to working with existing frameworks and building
    new ones in the future.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端模式**: 了解常见的 frontend 模式和优化将帮助我们更习惯于使用现有的框架，并在未来构建新的框架。'
- en: It is crucial to keep in mind that we can only scratch the surface of the feature
    set that other frameworks offer out of the box. For example, we can include a
    client-side router with a component-based architecture, including reactivity in
    those components. Frameworks such as Vue.js, Angular, and Svelte, plus libraries
    such as React, required years of development to cover all edge cases and significantly
    expand the feature set. For the purposes of this chapter, we will focus on keeping
    things closer to the basics and build several technical parts from scratch. This
    should give you a good understanding of the underlying components of other full
    stack frameworks with frontend features, such as Next.js. For example, we will
    use some of the web components APIs that are built right into modern web browsers
    to enable a rich feature set in our own framework.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的是，我们只能触及其他框架提供的功能集的表面。例如，我们可以包含一个基于组件架构的客户端路由器，包括那些组件中的响应性。像Vue.js、Angular和Svelte这样的框架，以及像React这样的库，需要多年的开发来覆盖所有边缘情况并显著扩展功能集。在本章中，我们将专注于保持事物更接近基础，并从头开始构建几个技术部分。这应该能让你更好地理解具有前端特性的其他全栈框架的底层组件，例如Next.js。例如，我们将使用一些直接构建在现代网页浏览器中的Web组件API，以在我们的框架中实现丰富的功能集。
- en: Toward the end of the chapter, we shall also examine the intended workflow to
    understand the series of steps taken by a developer to utilize the framework interfaces
    to achieve specific application development goals, using our newly architected
    features.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，我们还将检查预期的流程，以了解开发者为了利用框架接口实现特定的应用开发目标而采取的一系列步骤，使用我们新构建的特性。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter are very similar to those for [*Chapter
    7*](B19014_07.xhtml#_idTextAnchor108). This chapter reuses the framework files
    that we saw in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108) with frontend components
    and interfaces. The sample application in the `tests` directory is also changed
    to showcase some of the frontend features. Locate the book’s repository at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework),
    and continue to use the code in the `chapter7` directory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求与[*第7章*](B19014_07.xhtml#_idTextAnchor108)的技术要求非常相似。本章重用了我们在[*第7章*](B19014_07.xhtml#_idTextAnchor108)中看到的框架文件，并添加了前端组件和界面。`tests`目录中的示例应用程序也进行了更改，以展示一些前端功能。在[https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework)找到本书的仓库，并继续使用`chapter7`目录中的代码。
- en: Follow the `README.md` instructions in the directory for available scripts.
    The sample app can be found in the `tests/sample` directory of the framework.
    When you start that application, it will be available on port `9000`. You can
    open it with a browser using the `http://localhost:9000/` URL. While you are jumping
    into exploring the chapter code base, it is recommended to use the debugging tools
    to trace how the elements come together. Refer to the *Debugging* section of [*Chapter
    2*](B19014_02.xhtml#_idTextAnchor030) to configure a debuggable environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录中遵循`README.md`的说明以获取可用的脚本。示例应用程序可以在框架的`tests/sample`目录中找到。当你启动该应用程序时，它将在端口`9000`上可用。你可以使用`http://localhost:9000/`
    URL通过浏览器打开它。当你开始探索章节代码库时，建议使用调试工具来追踪元素是如何组合在一起的。请参阅[*第2章*](B19014_02.xhtml#_idTextAnchor030)中的*调试*部分以配置可调试的环境。
- en: Defining the frontend framework
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义前端框架
- en: We will continue from the previous chapter by reusing the example **Componium**
    framework project. In [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), we created
    several features that allow us to interact with server-side routes, define APIs,
    and query a database. Currently, there is no way to develop frontend components
    to either consume those APIs or add visual interfaces using our framework. Without
    the frontend part of our framework, a developer needing to build an interactive
    interface, hosted using a Componium server, would need to include an external
    library and statically serve additional application files from the server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从上一章的内容开始，通过重用示例**Componium**框架项目。在[*第7章*](B19014_07.xhtml#_idTextAnchor108)中，我们创建了一些功能，使我们能够与服务器端路由交互、定义API和查询数据库。目前，还没有方法来开发前端组件以消费这些API或使用我们的框架添加视觉界面。如果没有框架的前端部分，需要构建交互式界面并使用Componium服务器托管的开发者将需要包含外部库，并从服务器静态地提供额外的应用程序文件。
- en: Therefore, we will change the lack of frontend features by creating several
    frontend features that will allow framework users to create client interfaces.
    These frontend features will mimic some of the complex features of the existing
    established frontend frameworks. For instance, our approach to reactivity features
    inside the components will include the basics, utilizing the built-in APIs from
    the browsers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将通过创建几个前端功能来弥补前端功能的不足，这些功能将允许框架用户创建客户端界面。这些前端功能将模仿现有成熟前端框架的一些复杂功能。例如，我们在组件内部实现响应式功能的方法将包括基础部分，利用浏览器内置的API。
- en: To begin this process, we will identify the goals of the features we want to
    support. After that, we will follow with a sample architecture design that will
    make those features a reality and make our framework genuinely full stack.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个过程，我们将确定我们想要支持的功能的目标。之后，我们将跟随一个示例架构设计，使这些功能成为现实，并使我们的框架真正成为全栈。
- en: Goals
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The frontend framework sets three goals that will be later supported by the
    features that we create. Overall, it is a good idea to define these goals in a
    general manner and use them as you progress with your framework project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前端框架设定了三个目标，这些目标将由我们创建的功能来支持。总的来说，在框架项目进展过程中，以一般的方式定义这些目标是一个好主意：
- en: '**Web-based interfaces**: Goal number one is to empower developers to *create
    web-based interfaces* while maintaining cohesion with the backend/server components
    of the framework. With the frontend capabilities of the framework, developers
    will have the ability to write, host, and deploy interactive client interfaces.
    These interfaces will be made possible by providing a frontend framework API to
    create components and attach those to client-based views. These client-based features
    should also be testable and debuggable, either by the built-in Componium test
    interfaces or external testing tools.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于Web的界面**：首要目标是赋予开发者创建**基于Web的界面**的能力，同时保持与框架的后端/服务器组件的连贯性。借助框架的前端能力，开发者将能够编写、托管和部署交互式客户端界面。这些界面将通过提供前端框架API来创建组件并将这些组件附加到基于客户端的视图中来实现。这些基于客户端的功能也应该可测试和可调试，无论是通过内置的Componium测试接口还是外部测试工具。'
- en: '**Enable interactivity**: A comprehensive set of APIs, both on the server-side
    and frontend side, will help *enable the interactivity* required by many of the
    framework-backed projects. The interactivity features need to enable developers
    to use familiar technologies such as HTML, CSS, and frontend JavaScript to craft
    components. The framework should also have the affordances to be able to include
    potential external libraries. For example, if someone wants to create a visualization
    within their Componium frontend application, then they should easily be able to
    include external libraries such as Three.js and D3.js.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用交互性**：一套全面的API，包括服务器端和前端，将有助于实现许多框架支持的项目所需的**交互性**。交互性功能需要使开发者能够使用熟悉的技术，如HTML、CSS和前端JavaScript来构建组件。框架还应具备包含潜在外部库的能力。例如，如果有人想在他们的Componium前端应用程序中创建可视化，那么他们应该能够轻松地包含外部库，如Three.js和D3.js。'
- en: '**Promote reusability**: We want to include a set of framework affordances
    to build complex applications. These could be applications with many frontend
    differentiated views that include a large number of nested components. These could
    also include a set of optimizations for production environments and the ability
    to manage large application code bases. Primarily, we also want to *promote the
    reusability* of code and guide developers to make intelligent decisions when building
    their applications. An easily extensible feature set can be beneficial to cover
    a lot of the potential use cases. If we get the architecture right, it will allow
    for high degrees of customizability.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进可重用性**：我们希望包括一套框架功能，以构建复杂的应用程序。这些可能包括具有许多前端区分视图的应用程序，其中包含大量嵌套组件。这些还可以包括针对生产环境的优化集和能够管理大型应用程序代码库的能力。主要的是，我们也希望**促进代码的可重用性**，并指导开发者在构建他们的应用程序时做出明智的决策。一个易于扩展的功能集可以覆盖许多潜在的使用案例。如果我们架构正确，它将允许高度的可定制性。'
- en: Learning from already existing frameworks such as Next.js, we also want to make
    sure to include some of the more modern features and offer pleasing developer
    experiences alongside those features. These could include code generation affordances,
    similar to the ones we saw in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108).
    To set the framework apart from some of the other solutions, we will also set
    a goal to use some of the newly shipped Web APIs. Taking advantage of starting
    from scratch in our project gives us a good opportunity to evaluate the latest
    developments in the browser platforms, choosing the newly available APIs. As part
    of our learning goals, we will also try to contrast the difference between our
    newly developed framework and the established mature frameworks, such as Vue.js
    and Next.js.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从已经存在的框架，如Next.js中学习，我们也想确保包括一些更现代的功能，并在这些建议功能旁边提供令人愉悦的开发者体验。这可以包括代码生成功能，类似于我们在[*第7章*](B19014_07.xhtml#_idTextAnchor108)中看到的功能。为了使框架与一些其他解决方案区分开来，我们还将设定一个目标，使用一些新推出的Web
    API。利用我们在项目从头开始的优势，我们有机会评估浏览器平台上的最新发展，选择新可用的API。作为我们的学习目标的一部分，我们还将尝试对比我们新开发的框架与成熟的框架，如Vue.js和Next.js之间的差异。
- en: With these goals in mind, let’s dive into the set of features that can back
    these goals up.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些目标的基础上，让我们深入了解可以支持这些目标的功能集。
- en: Features
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能
- en: 'The frontend goals defined in the previous section will help us guide the thought
    process behind our feature development. To support the established goals, let
    us plan out some of the technical features that developers will find useful and
    expect from the framework. Here are some substantial features that we will discuss
    in detail in this chapter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中定义的前端目标将帮助我们指导特征开发背后的思维过程。为了支持既定的目标，让我们规划一些开发人员会发现有用并期望从框架中获得的某些技术特性。在本章中，我们将详细讨论以下一些重要特性：
- en: '**Serve HTML files and content**: To support the features of the interactive
    interfaces, we will need to add the ability to serve the generated HTML output
    to browser requests. We need to ensure that we have the capabilities to serve
    static content to sustain additional JavaScript code, images, media, and other
    types of files. This feature is vital to render content on the client side in
    a web browser.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务HTML文件和内容**：为了支持交互式界面的功能，我们需要添加将生成的HTML输出服务到浏览器请求的能力。我们需要确保我们有服务静态内容的能力，以支持额外的JavaScript代码、图像、媒体和其他类型文件。这一特性对于在Web浏览器客户端渲染内容至关重要。'
- en: '**Structured application code**: We need to grant the ability to define reusable
    interactive JavaScript components with CSS/HTML templating and styling features.
    We will do this using a component-based architectural approach. The component
    architecture feature itself will enable the development of user interfaces. The
    structured application code that it can help produce will consist of independent
    and reusable bits of code that serve as the building blocks of the whole web application.
    This will support our goals of reusability and providing good application primitives,
    as it takes advantage of component paradigms, such as reactivity, composability,
    and modularity. The approach to this feature aims to have each component control
    its own state and render the interfaces based on the state.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化应用程序代码**：我们需要赋予定义可重用交互式JavaScript组件的能力，这些组件具有CSS/HTML模板和样式功能。我们将使用基于组件的架构方法来实现这一点。组件架构特性本身将启用用户界面的开发。它可以帮助产生的结构化应用程序代码将包括独立且可重用的代码块，这些代码块作为整个Web应用程序的构建块。这将支持我们的重用性和提供良好的应用程序原语的目标，因为它利用了组件范式，如响应性、可组合性和模块化。这一特性的方法旨在让每个组件控制自己的状态，并根据状态渲染界面。'
- en: Supporting the maintenance goals, the component-based approach ensures isolated
    testing and debuggability of the application code. Here, we channel some of the
    previous design decisions from other frameworks. For example, in Vue.js, components
    are structured with JavaScript logic, HTML templates, and the ability to style
    them with CSS.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 支持维护目标，基于组件的方法确保应用程序代码的隔离测试和可调试性。在这里，我们借鉴了其他框架的一些先前设计决策。例如，在Vue.js中，组件是用JavaScript逻辑、HTML模板以及使用CSS进行样式的功能来构建的。
- en: '**Composability**: Expanding on the previous point, it is important to highlight
    the composability of application code as an important feature of the framework
    we want to create. Defining a nested structure based on how the web browser internal
    DOM structure, components can then be composed together to create complex user
    interfaces. Refer to the *Components* section of [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030)
    for a recap of the importance of this feature.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合性**：在前面一点的基础上，重要的是要强调应用程序代码的可组合性是我们想要创建的框架的一个重要特性。基于网络浏览器内部DOM结构定义的嵌套结构，组件可以组合在一起以创建复杂用户界面。请参阅[*第二章*](B19014_02.xhtml#_idTextAnchor030)中的*组件*部分，以回顾这一特性的重要性。'
- en: '**Client-side router**: One of the core pieces of frontend framework organization
    that we have seen in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030) was the router.
    The routing feature set is crucial to include in our feature set because it is
    responsible for navigating between complex views of our application. From [*Chapter
    7*](B19014_07.xhtml#_idTextAnchor108), we already have an API for server-side
    routes, and the frontend router will help provide the functionality to enable
    a fast and smooth transition between different application states.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端路由器**：我们在[*第二章*](B19014_02.xhtml#_idTextAnchor030)中看到的前端框架组织核心组件之一是路由器。路由功能集对于我们的功能集至关重要，因为它负责在应用程序的复杂视图之间导航。从[*第七章*](B19014_07.xhtml#_idTextAnchor108)开始，我们已经有了一个用于服务器端路由的API，前端路由将帮助提供实现不同应用程序状态之间快速平滑过渡的功能。'
- en: The router will adhere to the existing concepts of web application navigation
    and utilize the relevant Web APIs to modify the browser’s URL and history features.
    The inclusion of the router will also be beneficial in creating a more logically
    organized code.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器将遵循现有网络应用导航的概念，并利用相关的 Web API 修改浏览器的 URL 和历史功能。路由器的加入也将有助于创建更逻辑上组织良好的代码。
- en: '`HttpClient` helper module ([angular.io/guide/understanding-communicating-with-http](http://angular.io/guide/understanding-communicating-with-http))
    to communicate with suitable backend services. This would be an excellent reinforcing
    feature for our sample project, especially if combined with some of the specific
    *Componium server*-defined routes. For example, to help enhance the developer
    experience, we can pre-generate some of the data fetching calls for the known
    endpoints and create dynamic interfaces around those, thus saving time for developers
    building with our framework.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient` 辅助模块（[angular.io/guide/understanding-communicating-with-http](http://angular.io/guide/understanding-communicating-with-http)）用于与合适的后端服务进行通信。这将是我们示例项目的绝佳增强功能，特别是如果与一些特定的
    *Componium 服务器* 定义的路线结合使用。例如，为了帮助提升开发者体验，我们可以预先生成一些已知端点的数据获取调用，并围绕这些调用创建动态接口，从而为使用我们框架的开发者节省时间。'
- en: '**Server-side rendering (SSR)**: We mentioned SSR features in other framework
    examples throughout the book. We will include these features in our example framework
    as well. The SSR methods will render the components on the server side to help
    improve the rendering performance of the applications. Given our full control
    over the developer experience of the full stack framework in this particular case,
    developing this type of functionality is easier for us. Besides the performance
    improvements, SSR is beneficial for search engine optimization purposes and general
    page loading time.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染（SSR）**：我们在本书的其他框架示例中提到了 SSR 功能。我们也将这些功能包含在我们的示例框架中。SSR 方法将在服务器端渲染组件，以帮助提高应用程序的渲染性能。鉴于我们对全栈框架的开发者体验有完全的控制权，在这种情况下开发此类功能对我们来说更容易。除了性能提升外，SSR
    对搜索引擎优化和页面加载时间也有益。'
- en: The internals of SSR include close collaboration between components pre-rendered
    on the backend and later hydrated by the frontend code. The backend routes should
    also be able to inject the state of components into the pre-rendered elements.
    The state can be static data or information fetched from external sources, such
    as a database.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SSR 的内部包括在服务器端预先渲染的组件与后来由前端代码激活的组件之间的紧密协作。后端路由还应能够将组件的状态注入到预先渲染的元素中。状态可以是静态数据或从外部来源获取的信息，例如数据库。
- en: '**Production optimizations**: As part of the commitment to empowering developers,
    the framework will also feature some optimization steps for applications running
    in production environments. This means including additional internal tooling that
    performs optimizations, such as minification, behind the scenes. These kinds of
    optimizations are also much easier to integrate within our framework because we
    have control of the server tooling.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产优化**：作为对开发者赋能承诺的一部分，该框架还将提供一些针对在生产环境中运行的应用程序的优化步骤。这意味着包括一些在幕后执行优化的附加内部工具，例如压缩。这类优化也更容易集成到我们的框架中，因为我们控制着服务器工具。'
- en: Besides code minification, we can also look into advanced JavaScript optimization
    techniques such as tree-shaking and code-splitting. Supporting static file handling,
    we can potentially optimize other media such as images. Generally, as the framework
    continues, we want to consistently work on such optimization improvements because
    it benefits all the framework’s users.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了代码压缩，我们还可以探讨一些高级的 JavaScript 优化技术，例如摇树优化（tree-shaking）和代码拆分。支持静态文件处理，我们有可能优化其他媒体，如图片。一般来说，随着框架的发展，我们希望持续地进行此类优化改进，因为这会惠及所有框架用户。
- en: The preceding list is a selected set of functionalities that should make the
    frontend feature-rich, give us a good learning opportunity, and also cover realistic
    use cases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表是应选的一组功能，这些功能应使前端功能丰富，为我们提供良好的学习机会，并涵盖实际用例。
- en: 'The following *Figure 8**.1* provides a summary of how the listed features
    interact with each other:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 *图 8.1* 总结了所列功能之间的交互方式：
- en: '![Figure 8.1: The features summarized](img/Figure_8.1_B19014.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：功能总结](img/Figure_8.1_B19014.jpg)'
- en: 'Figure 8.1: The features summarized'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：功能总结
- en: The existing server-side code will be able to serve static files that can be
    consumed by the frontend. At the same time, the server process is capable of importing
    and accessing some of the components to render them on the server side. Finally,
    the backend has a definition of client routes; these are the frontend endpoints
    that are classified as accessible by a browser to be rendered in the client.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的服务器端代码能够提供静态文件，这些文件可以被前端使用。同时，服务器进程能够导入并访问一些组件，以便在服务器端渲染它们。最后，后端定义了客户端路由；这些是浏览器可以访问并渲染在客户端的前端端点。
- en: On the frontend side, we have the *API interaction* features that communicate
    with the server or make requests to external APIs that are hosted on external
    services. Simultaneously, a client-side router tightly works with the component
    architecture to enable the user interface experience in the browser. Finally,
    we have a set of frontend optimizations that cover all of the frontend surfaces,
    ensuring the most optimized experience when deploying and running applications
    in production environments.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端方面，我们有与服务器或外部服务上托管的外部API进行交互的*API交互*功能。同时，客户端路由器与组件架构紧密协作，以实现浏览器中的用户界面体验。最后，我们有一套前端优化，涵盖了所有前端表面，确保在生产环境中部署和运行应用程序时获得最佳优化体验。
- en: With these features in mind, let us proceed to the architecture step, where
    we can explore the technical and organizational concepts that make these features
    possible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些功能，让我们继续到架构步骤，在那里我们可以探索使这些功能成为可能的技术和组织概念。
- en: Architecture
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建筑学
- en: With the required features outlined and documented, let us extend the existing
    architecture from [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108). The changes
    will be adding new functionality to the framework architecture, concentrating
    on enabling the `ClientView` abstractions and functionality, which will drive
    the feature experience behind the frontend changes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在概述并记录了所需功能后，让我们从[*第7章*](B19014_07.xhtml#_idTextAnchor108)扩展现有的架构。这些更改将向框架架构添加新功能，重点关注启用`ClientView`抽象和功能，这将推动前端更改背后的功能体验。
- en: We already have the capability to create server API endpoints. The general implementation
    of the architecture of the features will consist of introducing several new interfaces
    to the server part of the framework. The newly added frontend features will be
    situated in the `frontend` directory of the framework project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经具备了创建服务器API端点的功能。特征的架构的一般实现将包括向框架的服务器部分引入几个新的接口。新添加的前端功能将位于框架项目的`frontend`目录中。
- en: '![Figure 8.2: Componium frontend components](img/Figure_8.2_B19014.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：Componium前端组件](img/Figure_8.2_B19014.jpg)'
- en: 'Figure 8.2: Componium frontend components'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：Componium前端组件
- en: In *Figure 8**.2*, we outline an incoming request to the server powered by the
    Componium server framework. Specifically, this request is expected to respond
    with an HTML page to provide interactivity features. This is unlike the API requests
    from [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), where we would receive JSON
    or GraphQL responses with data. The request handler can still process incoming
    request objects, such that it can access properties of the request, such as the
    query parameters. It can also tweak any properties of the response object. In
    [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), we used `server.addRoute(...)`
    to add new routes. To add route handlers that provide the functionality, we will
    use a similarly structured `server.addClientView(...)` method that will have a
    similar API, but a totally different behavior. This new method is where the **client
    view** functionality from *Figure 8**.2* will take place.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.2*中，我们概述了由Componium服务器框架驱动的服务器接收到的请求。具体来说，这个请求预期会响应一个HTML页面，以提供交互功能。这与[*第7章*](B19014_07.xhtml#_idTextAnchor108)中的API请求不同，我们会收到包含数据的JSON或GraphQL响应。请求处理器仍然可以处理传入的请求对象，以便访问请求的属性，例如查询参数。它还可以调整响应对象的任何属性。在[*第7章*](B19014_07.xhtml#_idTextAnchor108)中，我们使用`server.addRoute(...)`来添加新路由。为了添加提供功能的路由处理器，我们将使用类似结构的`server.addClientView(...)`方法，它将具有类似的API，但行为完全不同。这个新方法就是*图8.2*中的**客户端视图**功能所在之处。
- en: In the Componium frontend component design, a client view can have a singular
    view and many components used within it. The concept of the client view is a server-side
    definition, while the concept of views is shared across both the server and the
    client side. Once the client view is defined, it assembles all the imported components
    and the View together and sends a response back to the browser.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Componium前端组件设计中，客户端视图可以有一个单独的视图和许多在其中使用的组件。客户端视图的概念是服务器端定义的，而视图的概念则在服务器和客户端之间共享。一旦定义了客户端视图，它将组装所有导入的组件和视图，并将响应发送回浏览器。
- en: Besides the client view interaction, the server can now also define and access
    static file directories. These static files can be directly accessed by the browser,
    and the whole directory is exposed to the web server. These static files are also
    usable by the Client Views to import additional resources into the Client Views,
    such as any media files (images, fonts, styles, etc.) or additional JavaScript
    components. The ease of access to static files simplifies how a frontend framework
    can include external media and other useful entities that can be included within
    the web application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了客户端视图交互之外，服务器现在还可以定义和访问静态文件目录。这些静态文件可以直接由浏览器访问，整个目录都暴露给Web服务器。这些静态文件也可以由客户端视图使用，将额外的资源导入客户端视图，例如任何媒体文件（图像、字体、样式等）或额外的JavaScript组件。静态文件的易于访问简化了前端框架如何包含外部媒体和其他可以在Web应用程序中包含的有用实体。
- en: In the next section, we will get a detailed look into how Client Views become
    the gateway for the frontend features and files, allowing us to create multiple
    endpoints serving HTML, CSS, and JavaScript code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细了解客户端视图如何成为前端功能和文件的大门，使我们能够创建多个端点，服务于HTML、CSS和JavaScript代码。
- en: Entry points
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口点
- en: 'To allow flexibility when creating multiple frontend Client Views, our framework
    provides a way to define multiple client endpoints:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在创建多个前端客户端视图时提供灵活性，我们的框架提供了一种定义多个客户端端点的方法：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is an example of routing the root path of our server to
    the `frameworks` view. Developers can create a `frameworks.js` file inside the
    `views` directory to map this view by the defined name. `.addClientView(...)`
    can be configured multiple times, with as many views attached to different route
    handlers. The contents of `frameworks.js` have a familiar structure to the route
    handlers from [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是路由我们的服务器根路径到`frameworks`视图的示例。开发者可以在`views`目录中创建一个`frameworks.js`文件，通过定义的名称映射此视图。`.addClientView(...)`可以配置多次，将多个视图附加到不同的路由处理器。`frameworks.js`的内容结构与路由处理器从[*第7章*](B19014_07.xhtml#_idTextAnchor108)中的结构相似：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code can be as simple as returning a paragraph tag. You can find
    other examples of more involved views in the `tests/sample/views/` directory.
    The view handler has access to the `Request` and `Response` objects of the route
    to tweak the behavior of the route or fetch additional data. We also have access
    to the `componium` variable here to access the interfaces of the framework. For
    simplicity, we will use JavaScript template literals in more complex templates.
    The framework takes care of rendering the desired HTML structures, and it also
    wraps the `<p>` tag in the preceding code in a valid HTML document.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以简单到只返回一个段落标签。你可以在`tests/sample/views/`目录中找到其他更复杂的视图示例。视图处理器可以访问路由的`Request`和`Response`对象来调整路由的行为或获取额外的数据。我们还可以访问这里的`componium`变量来访问框架的接口。为了简单起见，我们将在更复杂的模板中使用JavaScript模板字面量。框架负责渲染所需的HTML结构，并且它还将上述代码中的`<p>`标签包装在一个有效的HTML文档中。
- en: 'The other important entry point for our frontend files is static file configuration.
    To be able to resolve other types of media, the framework provides a way to mark
    certain directories of the application project as an endpoint that serves static
    files:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前端文件的其他重要入口点是静态文件配置。为了能够解析其他类型的媒体，框架提供了一种方法来标记应用程序项目中的某些目录作为提供静态文件的端点：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `.addStaticDirectory(...)` method maps the server route for `/images` to
    the `img` directory in the application project. This relies on the similar properties
    of the backend express server that we worked with in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108).
    This new static directory also works in custom routers, which are created with
    `server.createRouter(...)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`.addStaticDirectory(...)` 方法将服务器路由 `/images` 映射到应用项目的 `img` 目录。这依赖于我们之前在 [*第7章*](B19014_07.xhtml#_idTextAnchor108)
    中使用的后端 express 服务器相似的属性。这个新的静态目录在自定义路由器中也能工作，这些路由器是通过 `server.createRouter(...)`
    创建的。'
- en: We now have a way to process and render basic views and create as many of them
    as we want. We now need to enable the component-based architecture. This is what
    will allow us to produce more complex interactive components.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了处理和渲染基本视图的方法，并且可以创建任意数量的视图。我们现在需要启用基于组件的架构。这将使我们能够生成更复杂的交互式组件。
- en: Reactivity
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**反应性**'
- en: To achieve the dynamic interface features of our frontend framework, we need
    to learn more about the concepts of reactivity and reactive components. The reactivity
    concepts in application programming direct the user interface to update and respond
    to underlying data or state changes dynamically. In the context of JavaScript,
    especially in the frontend systems, we use custom-developed primitives in combination
    with browser APIs to achieve performant user interface reactivity. The reactivity
    features enable a seamless experience for web application consumers by automatically
    updating the interface whenever relevant underlying data changes. Similar to other
    programming environments, in the JavaScript world, developers rely on frameworks
    and helper libraries to enable reactivity for components in their applications.
    In fact, this reliance on external tooling in JavaScript is much stronger than
    in other languages. This is mainly due to the cross-browser and cross-engine nature
    of web page and web application development.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们前端框架的动态界面特性，我们需要更多地了解反应性和反应组件的概念。在应用程序编程中，反应性概念指导用户界面动态地更新和响应底层数据或状态变化。在
    JavaScript 的上下文中，尤其是在前端系统中，我们结合自定义开发的原语和浏览器 API 来实现性能良好的用户界面反应性。反应性功能通过在相关底层数据变化时自动更新界面，为
    Web 应用程序消费者提供无缝体验。与其他编程环境类似，在 JavaScript 世界中，开发者依赖于框架和辅助库来为他们的应用程序中的组件启用反应性。实际上，JavaScript
    中对外部工具的依赖性比其他语言要强得多。这主要是因为网页和 Web 应用程序开发的跨浏览器和跨引擎特性。
- en: The reactive programming paradigm has become very fitting in the web development
    environment, due to the asynchronous nature of JavaScript. Other contributing
    factors for the reactive paradigm fit included application requirements for real-time
    updates, complex interactivity, and making it easier to manage the state of applications.
    The user interfaces have become much more complex. These days, the expectations
    of web applications require frontend systems to be dynamic, consume real-time
    data, and be instantly responsive to user actions. Also, the existing structure
    and abstractions around a web browser’s **Document Object Model** (**DOM**) have
    compelled solutions to be based on manipulating a nested node tree of page elements.
    The reactive changes in the interface utilize the diffing algorithms to update
    the changed nodes of a component tree.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 的异步特性，反应式编程范式在 Web 开发环境中变得非常合适。对反应范式有贡献的因素还包括对实时更新、复杂交互和简化应用状态管理的需求。用户界面变得更加复杂。如今，Web
    应用程序的期望要求前端系统具有动态性、消耗实时数据，并对用户操作做出即时响应。此外，围绕 Web 浏览器的 **文档对象模型** (**DOM**) 的现有结构和抽象迫使解决方案基于操作页面元素的嵌套节点树。界面中的反应式更改利用差异算法来更新组件树中已更改的节点。
- en: Reactivity requires data binding, which is a connection between data and the
    elements of applications. In the web development world, the data would be provided
    by JavaScript interfaces, most likely dynamically loaded from some API endpoint.
    The elements would be the *HTML/DOM* structures in the browser client. The corresponding
    browser elements are automatically updated to reflect the changes when the underlying
    data updates. In [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030), in the *Framework
    building blocks* section, we highlighted the possible ways in which data binding
    can occur within these reactive components. We also saw examples of frameworks
    using one-way or two-way binding. The flow largely depends on architectural decisions,
    either allowing the elements to update when data changes or also allowing the
    elements to update the underlying data. Popular frameworks such as Vue.js and
    anything that includes React use an implementation of a *virtual DOM* tree to
    render an application’s state as the data changes. However, there are also examples
    where projects, such as those involving Svelte and Angular, use the real DOM or
    *shadow DOM* features to achieve similar functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 反应性需要数据绑定，这是数据与应用程序元素之间的连接。在Web开发世界中，数据将由JavaScript接口提供，很可能是从某些API端点动态加载的。元素将是浏览器客户端中的*HTML/DOM*结构。当底层数据更新时，相应的浏览器元素会自动更新以反映这些变化。在[*第2章*](B19014_02.xhtml#_idTextAnchor030)的*框架构建块*部分，我们强调了数据绑定在这些反应性组件中可能发生的方式。我们还看到了使用单向或双向绑定的框架示例。这种流程在很大程度上取决于架构决策，要么允许元素在数据更改时更新，要么也允许元素更新底层数据。流行的框架，如Vue.js和任何包含React的框架，都使用*虚拟DOM*树的实现来渲染应用程序的状态，以数据变化。然而，也有一些例子，如涉及Svelte和Angular的项目，使用真实DOM或*shadow
    DOM*功能来实现类似的功能。
- en: 'Similar to other frontend projects, we will introduce the concept of reactive
    components into our framework. These components will allow us to encapsulate HTML
    elements and application logic alongside them. The frontend *Componium* components
    will maintain their internal state and respond to data and interactions. To keep
    things simpler and without diving deeper into the internals of the existing frontend
    frameworks, we can build an example of basic reactivity concepts using a combination
    of Web Components and other more modern Web APIs. A practical overview of the
    component architecture will provide a good learning opportunity to understand
    the built-in browser primitives. It will also offer a good comparison and understanding
    of the complex problems that the existing frameworks solve for us:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他前端项目类似，我们将把反应性组件的概念引入我们的框架。这些组件将允许我们封装HTML元素和与之相关的应用程序逻辑。前端*Componium*组件将保持其内部状态并对数据和交互做出响应。为了使事情更简单，并且不深入现有前端框架的内部，我们可以使用Web组件和其他更现代的Web
    API的组合来构建基本反应性概念的示例。组件架构的实用概述将提供良好的学习机会，以了解内置的浏览器原语。它还将提供良好的比较和理解现有框架为我们解决复杂问题的能力：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is our newly defined `ReactiveComponent`; it has been compacted
    to fit in better in this chapter. The class starts off extending `HTMLElement`.
    This interface will help us represent HTML elements and create our own web components.
    In the `constructor` method, we have a declaration for the `state` property, which
    will keep track of the state of the component. Another important constructor call
    is `.attachShadow()`. This call attaches a Shadow DOM to the custom element and
    provides a scoped environment for the encapsulated CSS and JavaScript instructions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们新定义的`ReactiveComponent`；它已被压缩以更好地适应本章。该类从`HTMLElement`扩展开始。此接口将帮助我们表示HTML元素并创建我们自己的Web组件。在`constructor`方法中，我们声明了`state`属性，该属性将跟踪组件的状态。另一个重要的构造函数调用是`.attachShadow()`。此调用将Shadow
    DOM附加到自定义元素，并为封装的CSS和JavaScript指令提供了一个作用域环境。
- en: Additional reading
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读
- en: For a detailed low-level explanation of how Shadow DOM is structured, check
    out the MDN page at [developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解Shadow DOM的结构，请查看MDN页面[developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM)。
- en: In the `reactive` method, we configure a new `Proxy` object, which is another
    built-in Web API with properties that can help us make reactive changes to the
    state of our components. The `Proxy` methods take an object and return a new object
    that serves as a proxy for the original definition. The proxy behavior helps trigger
    updates and re-renders of a component when the object is updated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reactive`方法中，我们配置一个新的`Proxy`对象，这是另一个内置的Web API，具有可以帮助我们对我们组件的状态进行反应性更改的属性。`Proxy`方法接受一个对象并返回一个新的对象，该对象作为原始定义的代理。代理行为有助于在对象更新时触发组件的更新和重新渲染。
- en: Additional reading
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其他阅读材料
- en: 'For details on the `Proxy` interface, check out the detailed article at MDN:
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
    )'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Proxy`接口的详细信息，请参阅MDN上的详细文章：[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- en: The setter operation and the update methods will be invoked when the state changes.
    The `update()` method is overridden in the components that inherit this `ReactiveComponent`
    class. With `ReactiveComponent`, we can build a simple set of example components.
    This structure will bind the data from the component state into the rendered templates.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态改变时，将调用设置操作和更新方法。`update()`方法在继承此`ReactiveComponent`类的组件中被覆盖。使用`ReactiveComponent`，我们可以构建一组简单的示例组件。这种结构将绑定组件状态中的数据到渲染的模板中。
- en: '![Figure 8.3: A basic components example](img/Figure_8.3_B19014.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：基本组件示例](img/Figure_8.3_B19014.jpg)'
- en: 'Figure 8.3: A basic components example'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：基本组件示例
- en: '*Figure 8**.3* presents an example view of two components in action; one is
    the year tracker and the other is the month tracker. Both components have the
    option to increment the values of the appropriate dates. You can find the code
    for this working example in the `tests/basic-components/index.html` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.3* 展示了两个组件在操作中的示例视图；一个是年份跟踪器，另一个是月份跟踪器。这两个组件都有增加相应日期值的选项。您可以在`tests/basic-components/index.html`文件中找到此工作示例的代码：'
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The source of the view follows; it just includes a newly defined component
    by its name, `year-component`, wrapped in regular HTML tags. This was achieved
    by registering the custom element using the built-in Web Components interface
    – `customElements.define("year-component", YearComponent);`. The `year-component`
    component extends the preceding `ReactiveComponent` class and overrides the empty
    `update` and `template` methods, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的源代码如下；它仅包括通过其名称`year-component`定义的新组件，并用常规HTML标签包裹。这是通过使用内置的Web Components接口注册自定义元素实现的`customElements.define("year-component",
    YearComponent);`。`year-component`组件扩展了前面的`ReactiveComponent`类，并覆盖了空的`update`和`template`方法，如下所示：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The methods listed in the preceding code, such as `update()` and `template()`,
    render the data relevant to the component and define the template returned by
    the `year-component` component. We also have event handlers that change and update
    the year, using access to `this.state`. Also, note that to access the Shadow DOM
    properties of this `Year` component, we use `this.shadowRoot.querySelector`. The
    template defined in the component includes `month-component`, which is a nested
    component. It has a similar setup to the extended class of `ReactiveComponent`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中列出的方法，如`update()`和`template()`，渲染与组件相关的数据并定义由`year-component`组件返回的模板。我们还有事件处理器，用于更改和更新年份，通过访问`this.state`。此外，请注意，要访问此`Year`组件的Shadow
    DOM属性，我们使用`this.shadowRoot.querySelector`。组件中定义的模板包括`month-component`，这是一个嵌套组件。它具有与`ReactiveComponent`扩展类类似的设置。
- en: This component configuration, using the Web Components APIs and other affordances
    from the browser APIs, is a good starting point for the framework. We can use
    these patterns to achieve similar functionality in other frameworks, such as Vue.js,
    and frameworks that use React as their underlying library to structure their components.
    The interface we have has reactivity properties, the ability to compose components
    simultaneously, and the basics of templating.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件配置，使用Web Components API和其他浏览器API提供的便利性，是框架的良好起点。我们可以使用这些模式在其他框架中实现类似的功能，例如Vue.js，以及使用React作为其底层库来构建其组件的框架。我们拥有的接口具有反应性属性、同时组合组件的能力以及模板化的基础知识。
- en: In the following section, we will take this a bit further and utilize an external
    Web Component helper library to build upon this pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进一步探讨并利用外部 Web Component 辅助库来构建这个模式。
- en: Improving components
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进组件
- en: In the reactivity part of the architecture, we have described a pattern of using
    Web Components comprised of other techniques to achieve the desired feature set.
    To enhance this further, we will bring in the `lit.dev`), which will help make
    our job of managing the components much more straightforward, and our framework
    can be dependent on it. We shall use the same approach of abstractions and utilize
    the interfaces of this library to create the component features of our framework.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构的响应性部分，我们描述了一种使用由其他技术组成的 Web Components 来实现所需功能集的模式。为了进一步增强这一点，我们将引入 `lit.dev`)，这将帮助我们使管理组件的工作更加直接，并且我们的框架可以依赖于它。我们将采用相同的方法进行抽象，并利用这个库的接口来创建我们框架的组件功能。
- en: About the Lit library
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Lit 库
- en: The Lit open source library has been around for more than six years, and its
    goal is to simplify and abstract away some of the verbose tasks that deal with
    Web Components. At its core, it provides reactive state features, scoped CSS styling,
    templating, and a variety of advanced features to compose and work with frontend
    components. It works with both JavaScript and TypeScript languages and comes with
    a large variety of packages that extend its functionality. For example, Lit has
    additional tools to enable localization, animate frontend elements, and also integrate
    with React components.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Lit 开源库已经存在了六年多，其目标是简化并抽象掉一些与 Web Components 相关的冗长任务。在其核心，它提供了响应式状态功能、作用域 CSS
    样式、模板化以及一系列高级功能来组合和操作前端组件。它支持 JavaScript 和 TypeScript 语言，并附带大量扩展其功能的包。例如，Lit 有额外的工具来启用本地化、动画化前端元素，并且还可以与
    React 组件集成。
- en: The library uses the standard component life cycle, in addition to its own component
    life cycle methods to simplify certain operations, such as DOM reactivity. You
    can find the source of the project at [github.com/lit/lit](https://github.com/lit/lit)
    and [lit.dev/docs](https://lit.dev/docs).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该库除了使用标准的组件生命周期外，还使用自己的组件生命周期方法来简化某些操作，例如 DOM 响应性。您可以在 [github.com/lit/lit](https://github.com/lit/lit)
    和 [lit.dev/docs](https://lit.dev/docs) 找到项目的源代码。
- en: 'To draw a comparison with the preceding `ReactiveComponent` interfaces, let’s
    take a look at how similar the code would be to the basic components if we used
    the Lit library:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与先前的 `ReactiveComponent` 接口进行比较，让我们看看如果我们使用 Lit 库，代码会与基本组件有多相似：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code imports the `LitElement` class that we can extend. This new
    code block result looks very familiar to the code of `year-component` that we
    saw in the *Reactivity* section. However, there are some additional improvements
    we have in this component definition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码导入了我们可以扩展的 `LitElement` 类。这个新的代码块结果看起来与我们在 *响应性* 部分看到的 `year-component`
    代码非常相似。然而，在这个组件定义中我们还有一些额外的改进。
- en: 'Let’s explore a few of them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索其中的一些：
- en: First of all, we have a CSS helper interface, which allows us to declare the
    style of our component using the `static` `styles` variable.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有一个 CSS 辅助接口，它允许我们使用 `static` `styles` 变量来声明我们组件的样式。
- en: Second, the way we declare the state of the component has also changed – we
    define a `static properties` object with some extra definitions of the properties.
    These properties are used in a similar way in the template.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们声明组件状态的方式也有所改变——我们定义了一个包含一些额外属性定义的 `static properties` 对象。这些属性在模板中以类似的方式使用。
- en: This brings us to the third point – the templating is also a bit different.
    It uses the `lit-html` helpers to enable more advanced templating features and
    help us work with HTML. This helper allows us to create templating directives,
    tweak the rendering methods, and so on.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这引出了第三个要点——模板化也有所不同。它使用 `lit-html` 辅助器来启用更高级的模板化功能并帮助我们处理 HTML。这个辅助器允许我们创建模板指令，调整渲染方法，等等。
- en: Additional reading
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读
- en: Detailed documentation of all the templating features can be found at [lit.dev/docs/v3/templates/expressions](https://lit.dev/docs/v3/templates/expressions).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模板化功能的详细文档可以在 [lit.dev/docs/v3/templates/expressions](https://lit.dev/docs/v3/templates/expressions)
    找到。
- en: 'For the purposes of our sample framework, we will define our own `ComponiumComponent`
    class. This class will be available to the developers to create rich components,
    combining what we have learned from the *Reactivity* section and the Lit library.
    We can also rely on the rich functionalities of Lit templating to render the results.
    To enable this, we will load the Lit library alongside the `componium.js` framework
    file in `ClientViews`. This will expose the component interface to developer-defined
    components. To start using those interfaces, developers can import them using
    the ES6 syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们示例框架的目的，我们将定义自己的`ComponiumComponent`类。这个类将可供开发者使用，以创建丰富的组件，结合我们从*响应性*部分和Lit库中学到的知识。我们还可以依赖Lit模板的丰富功能来渲染结果。为了启用这一点，我们将加载Lit库和`componium.js`框架文件一起在`ClientViews`中。这将使组件接口暴露给开发者定义的组件。要开始使用这些接口，开发者可以使用ES6语法导入它们：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The class to extend is provided, alongside the CSS and HTML helpers to help
    construct the components. For example, if our component has interactive buttons,
    it can use the following Lit syntax to declare event handlers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了要扩展的类，以及CSS和HTML辅助工具，以帮助构建组件。例如，如果我们的组件有交互式按钮，它可以使用以下Lit语法来声明事件处理器：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `_click` event handler is a method defined on the class that extends from
    `ComponiumComponent`. If these components require any static files, they can request
    them directly by fetching them from the static routes declared by the Componium
    server. However, we can still take this one step further and use Lit and the mix
    of our framework’s interfaces to enable the complex features of SSR. There will
    be more on the concept of utilizing the existing components from a server in the
    next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`_click`事件处理器是在从`ComponiumComponent`扩展的类上定义的方法。如果这些组件需要任何静态文件，它们可以直接通过从Componium服务器声明的静态路由中获取它们来请求。然而，我们仍然可以更进一步，使用Lit和我们的框架接口的混合来启用SSR的复杂功能。关于从服务器利用现有组件的概念将在下一节中详细介绍。'
- en: SSR
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSR
- en: 'We learned about the features and benefits of SSR when we planned the frontend
    interfaces of Componium. On a technical level, SSR requires several parts of our
    framework to work really well. Here are some of them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们规划Componium的前端接口时，我们了解了SSR的功能和好处。在技术层面上，SSR需要我们框架的几个部分协同工作才能表现得非常好。以下是一些：
- en: The component architecture needs to support different rendering capabilities.
    This includes the ability to pre-render the components as HTML that can be transmitted
    over the wire to the frontend.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件架构需要支持不同的渲染能力。这包括将组件作为HTML预先渲染的能力，这些HTML可以通过网络传输到前端。
- en: Components need to be able to run consistently on both the server and the browser.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件需要在服务器和浏览器上都能一致地运行。
- en: The server-rendered components should have the ability to fetch data in both
    the client and server environments. Depending on the environment, components should
    have a similar approach to how data is requested and processed.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染的组件应该能够在客户端和服务器环境中获取数据。根据环境的不同，组件应该有类似的数据请求和处理方法。
- en: We need a server that can structure and render the components, including attaching
    a state and data to these components.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个能够结构化和渲染组件的服务器，包括将这些组件的状态和数据附加到它们上。
- en: The frontend side should be able to take the server-side state of the components
    and later hydrate them. It should be able to attach the required events.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端应该能够获取组件的服务器端状态，并在以后对其进行激活。它应该能够附加所需的事件。
- en: Luckily, with our framework and the Lib library, we have a lot of these requirements
    covered and can develop the SSR support in our framework. Using the `@lit-labs/ssr`
    package, we can define a server-side render in conjunction with our Client View
    abstractions. The modules for these features can be found in `packages/frontend/client-view.js`.
    To have a flexible feature set in our framework, we want developers to use both
    client-side-only components and a combination of server-rendered components.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，凭借我们的框架和Lib库，我们已经覆盖了这些要求中的许多，并且可以在我们的框架中开发SSR支持。使用`@lit-labs/ssr`包，我们可以在与我们的客户端视图抽象结合的同时定义服务器端渲染。这些功能的模块可以在`packages/frontend/client-view.js`中找到。为了在我们的框架中拥有灵活的功能集，我们希望开发者使用仅客户端组件和服务器端渲染组件的组合。
- en: To enable the SSR capabilities, the framework has a new `Renderer` class, which
    has the job of consolidating all the required framework code and developer-defined
    components. It does so by responding to client-side requests with a unified template
    of a valid HTML document and by injecting code from the application directory.
    To render these structures, we can use the `html` helpers from the `ssr` library.
    To understand the capabilities of the `ssr` package, check out the comprehensive
    documentation at `lit.dev/docs/ssr/overview`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 SSR 功能，该框架有一个新的 `Renderer` 类，其任务是整合所有必需的框架代码和开发者定义的组件。它是通过响应客户端请求，提供一个有效的
    HTML 文档的统一模板，并从应用程序目录中注入代码来实现的。为了渲染这些结构，我们可以使用 `ssr` 库中的 `html` 辅助函数。要了解 `ssr`
    包的功能，请查看 `lit.dev/docs/ssr/overview` 上的全面文档。
- en: These capabilities work in tandem with the Componium server rendering methods
    to output the resulting HTML to the client. Once the HTML document has been fully
    loaded in the browser, then the hydration process begins. The framework files
    load the required supporting files that will help attach the event handlers to
    our components and make them interactive.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能与 Componium 服务器端渲染方法协同工作，将生成的 HTML 输出到客户端。一旦 HTML 文档在浏览器中完全加载，则开始水合过程。框架文件加载所需的辅助文件，这些文件将帮助将事件处理器附加到我们的组件上，并使它们具有交互性。
- en: We shall examine the detailed usage of the server-side rendering features in
    the upcoming *Using the framework* section. Meanwhile, there are a few more architectural
    features left to cover before we can start using all of them together.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的 *使用框架* 部分中检查服务器端渲染功能的详细用法。同时，在我们能够一起使用所有这些功能之前，还有一些架构特性需要介绍。
- en: Client router
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端路由器
- en: At the framework planning stage, the router was highlighted as an essential
    piece of frontend infrastructure that allows an interface to transition between
    significant sections of an application. The routing implementations are very similar
    across many frontend frameworks. However, if you are really passionate about the
    routing features, the *React Router* project ([reactrouter.com](https://reactrouter.com))
    is a great project to learn from in terms of educating yourself about good routing
    abstractions, the potential pitfalls, and routing edge cases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架规划阶段，路由器被强调为前端基础设施的一个关键部分，它允许界面在应用程序的重要部分之间进行转换。许多前端框架的路由实现非常相似。然而，如果你对路由功能非常热情，*React
    Router* 项目 ([reactrouter.com](https://reactrouter.com)) 是一个很好的项目，可以从中学习关于良好的路由抽象、潜在陷阱和路由边缘情况的知识。
- en: '![Figure 8.4: A transition between the initial page (left) and the newly routed
    page (right)](img/Figure_8.4_B19014.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4：初始页面（左）与新路由页面（右）之间的转换](img/Figure_8.4_B19014.jpg)'
- en: 'Figure 8.4: A transition between the initial page (left) and the newly routed
    page (right)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：初始页面（左）与新路由页面（右）之间的转换
- en: To enable the routing functionality in our framework, we will introduce a `ComponiumRouter`
    class. In *Figure 8**.4*, we can see the routing transition between the initial
    `/client-render` page (*left*) and the newly routed page, `/page` (*right*). The
    routing happens when you click on the `this.router = new ComponiumRouter("client-render",`
    `routes, this.shadowRoot);`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的框架中启用路由功能，我们将引入一个 `ComponiumRouter` 类。在 *图 8.4* 中，我们可以看到初始 `/client-render`
    页面（*左*）与新路由页面 `/page`（*右*）之间的路由转换。路由发生在你点击 `this.router = new ComponiumRouter("client-render",
    ` `routes, this.shadowRoot);` 时。
- en: 'The router gets an identifier (`client-render`), a series of routes with the
    `routes` object, and a root element (in this case, the `this.shadowRoot` object)
    that will be used to render the routed templates. The `routes` object is defined
    as an array of objects. For example, a simple route example for *Figure 8**.4*
    would look as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器获得一个标识符（`client-render`），一系列通过 `routes` 对象定义的路由，以及一个根元素（在这种情况下，是 `this.shadowRoot`
    对象），该元素将用于渲染路由模板。`routes` 对象被定义为对象数组。例如，*图 8.4* 的简单路由示例如下所示：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `/client-render` route is one of our entry points that has Client View type
    and the `/page` route is a view we can navigate to. The router can support a richer
    feature set by accepting more complex templating structures in the `template`
    property. For example, we can use the `html` helper from the `Componium/Lit` modules
    to produce more extensive template objects in the routing definition.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`/client-render`路由是我们具有客户端视图类型的入口点之一，而`/page`路由是我们可以导航到的视图。通过在`template`属性中接受更复杂的模板结构，路由器可以支持更丰富的功能集。例如，我们可以在路由定义中使用来自`Componium/Lit`模块的`html`辅助函数来生成更广泛的模板对象。'
- en: To navigate between routes, we will rely on more built-in Web APIs in browsers.
    For instance, the components call out to `history.pushState(...)` when views need
    to be changed. Inside the `ComponiumRouter` class, the framework handles those
    `pushState` events and renders the appropriate template.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航不同路由之间，我们将依赖于浏览器中更多的内置Web API。例如，当视图需要更改时，组件会调用`history.pushState(...)`。在`ComponiumRouter`类内部，框架处理这些`pushState`事件并渲染相应的模板。
- en: Additional reading
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读
- en: 'The MDN documentation outlines all possible History API methods we can use
    in our frontend routing components. It is available here: [developer.mozilla.org/en-US/docs/Web/API/History/pushState](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: MDN文档概述了我们可以在前端路由组件中使用所有可能的History API方法。它在这里可用：[developer.mozilla.org/en-US/docs/Web/API/History/pushState](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState)。
- en: In the Lit Labs open source code base, there is another example of a component
    router. The source for it can be found at [github.com/lit/lit/tree/main/packages/labs/router](https://github.com/lit/lit/tree/main/packages/labs/router).
    It can be an excellent exercise to implement the router in the *Componium* framework.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lit Labs的开源代码库中，还有一个组件路由的例子。它的源代码可以在[github.com/lit/lit/tree/main/packages/labs/router](https://github.com/lit/lit/tree/main/packages/labs/router)找到。在*Componium*框架中实现路由可以是一个极好的练习。
- en: Optimizations
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: Part of our goals for frontend functionality was a set of optimizations to make
    the applications that our framework produces more efficient, scalable, and performant.
    We shall take a step toward that by introducing some features to optimize the
    output of our frontend components in production environments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前端功能的目标之一是一组优化，以使我们的框架产生的应用程序更加高效、可扩展和性能良好。我们将通过引入一些功能来优化生产环境中前端组件的输出，朝着这个目标迈出一步。
- en: We will introduce a new `Optimize` class, which has some functions to perform
    optimizations on the code base. The class can be found in the framework directory
    at `packages/frontend/optimize.js`. These optimizations can affect both the included/injected
    framework files and the application code. The functions of this class will activate
    when applications deploy within an envrionment that has the `NODE_ENV=production`
    variables defined, which is the common pattern for Node.js-based projects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入一个新的`Optimize`类，它包含一些对代码库进行优化的函数。这个类可以在框架目录的`packages/frontend/optimize.js`中找到。这些优化可以影响包含/注入的框架文件以及应用程序代码。当应用程序在定义了`NODE_ENV=production`变量的环境中部署时，这个类的函数会激活，这是基于Node.js项目的常见模式。
- en: 'We will utilize some existing JavaScript tooling – in this particular case,
    `esbuild` – to `minify` the framework and component code files. The `esbuild`
    tooling provides the following minification command-line API:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用一些现有的JavaScript工具——在这个特定案例中，是`esbuild`——来`minify`框架和组件代码文件。`esbuild`工具提供了以下压缩命令行API：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can use the power of `esbuild` tooling to optimize applications built with
    our framework. For example, all the components used in an application will be
    minified by the server process when required. Under the hood, the framework parses
    through the component files and runs the minification step, outputting the optimized
    files into a separate directory. We use a hidden directory called `.componium`
    as storage to save the optimized files. The framework later knows to access the
    optimized files instead of the originals.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`esbuild`工具的力量来优化使用我们框架构建的应用程序。例如，当需要时，应用程序中使用的所有组件将由服务器进程进行压缩。在底层，框架会解析组件文件并运行压缩步骤，将优化后的文件输出到单独的目录中。我们使用一个名为`.componium`的隐藏目录作为存储来保存优化后的文件。框架随后会知道访问优化后的文件而不是原始文件。
- en: To expand further improvements in the future, we can focus optimizations on
    other application files, such as images, media, and more. The introduction of
    more complex build tools is also possible. For example, we can add `rollup.js`
    to enhance the resulting output of the client-side code. We have seen example
    usages of rollup tooling in [*Chapter 3*](B19014_03.xhtml#_idTextAnchor051). `Esbuild`
    also provides additional functionality besides the minification that can be found
    at [esbuild.github.io/api](https://esbuild.github.io/api).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步扩展未来的改进，我们可以将优化重点放在其他应用程序文件上，例如图像、媒体等。引入更复杂的构建工具也是可能的。例如，我们可以添加`rollup.js`来增强客户端代码的输出结果。我们已经在[*第3章*](B19014_03.xhtml#_idTextAnchor051)中看到了rollup工具的示例用法。`Esbuild`也提供了除了最小化之外的额外功能，可以在[esbuild.github.io/api](https://esbuild.github.io/api)找到。
- en: Now, the final part to cover is the improvements in the developer experience
    for these frontend components, which we will do in the following section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要介绍的是这些前端组件的开发者体验的改进，我们将在下一节中进行说明。
- en: Developer experience
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者体验
- en: The finishing touches for our features are to include some improvements to the
    developer experience. We will do this through thorough documentation of the component
    system and by providing enhancements to the framework’s executable file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善我们的功能，我们将包括一些改进开发者体验的改进。我们将通过详细记录组件系统以及提供对框架可执行文件的增强来实现这一点。
- en: The documentation should provide clear instructions on the frontend capabilities,
    such as the definition of multiple Client Views and static file directories. The
    component structure, composability, and reactivity features also need to be described.
    For example, this could include a straightforward API to add new client routes
    and how the framework uses the Lit library to achieve the component-related features.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 文档应提供关于前端功能的清晰说明，例如多个客户端视图和静态文件目录的定义。组件结构、可组合性和响应式功能也需要进行描述。例如，这可能包括一个简单的API来添加新的客户端路由，以及框架如何使用Lit库来实现与组件相关的功能。
- en: The improvements of the framework executable include the ability to generate
    the Client View routes, Views, and Components using a scaffolding operation. In
    [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), we saw an example of generating
    new API routes; this is a very similar addition. Just as before, with the executable,
    developers will be able to quickly generate some code and start composing frontend
    user interfaces. These pre-generated components include the default property configurations
    for styles and data properties of objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 框架可执行文件的改进包括使用脚手架操作生成客户端视图路由、视图和组件的能力。在[*第7章*](B19014_07.xhtml#_idTextAnchor108)中，我们看到了生成新API路由的示例；这是一个非常相似的增加。就像之前一样，使用可执行文件，开发者将能够快速生成一些代码并开始构建前端用户界面。这些预先生成的组件包括对象样式和数据属性的默认属性配置。
- en: Overall, we will demystify as many of the frontend features as possible, focusing
    on helping developers navigate the complicated intricacies of all the technologies
    that are in play while building client-side web applications.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们将尽可能解开前端功能的神秘面纱，专注于帮助开发者导航构建客户端Web应用程序时所有技术的复杂细节。
- en: Dependencies
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'We will use several dependencies fetched from the `npm` package registry to
    achieve the level of functionality described in this chapter. Here are some notable
    ones:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用从`npm`包注册表中获取的几个依赖项来实现本章中描述的功能级别。以下是一些值得注意的依赖项：
- en: '`Esbuild`: The bundler and minifier tool used for optimization steps when the
    framework server runs in production environments. With `esbuild`, we can quickly
    optimize scripts. It includes a lot of advanced features that we can use to extend
    the end-result scripts of our framework further.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Esbuild`：在框架服务器在生产环境中运行时的优化步骤中使用的打包器和最小化工具。使用`Esbuild`，我们可以快速优化脚本。它包括许多我们可以用来进一步扩展框架最终脚本的高级功能。'
- en: '`Lit`: The library that helps us extend the existing Web Component techniques
    and provides much more advanced component features, such as enabling easier data-binding
    and simplified state management.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lit`：这个库帮助我们扩展现有的Web组件技术，并提供了更多高级的组件功能，例如简化数据绑定和简化状态管理。'
- en: '`lit-html`: Another module that is related to the Lit library, which provides
    templating features for the frontend features of our framework.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lit-html`：与Lit库相关的另一个模块，为我们的框架的前端功能提供模板功能。'
- en: '`@lit-labs/srr` and `@lit-labs/ssr-client`: These two modules enable the SSR
    features of our framework. They can render the components in the Componium server
    and are later hydrated on the frontend.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@lit-labs/srr`和`@lit-labs/ssr-client`：这两个模块启用了我们框架的SSR功能。它们可以在Componium服务器上渲染组件，并在前端进行后续的激活。'
- en: Mainly, these libraries and tools help us enrich our framework features. Our
    framework can rely on these dependencies to enable efficient project building,
    component-based architecture, dynamic content rendering, and SSR, resulting in
    a performant, maintainable, and user-friendly application. With the detailed architecture
    in place, in the following section, we will explore the developer workflow to
    create a simple client-side application with Componium’s frontend features.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，这些库和工具帮助我们丰富了框架功能。我们的框架可以依赖这些依赖项来启用高效的项目构建、基于组件的架构、动态内容渲染和SSR，从而实现性能优良、易于维护和用户友好的应用程序。在详细架构就绪之后，在下一节中，我们将探讨开发人员的工作流程，以使用Componium的前端功能创建一个简单的客户端应用程序。
- en: Using the framework
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用框架
- en: 'Now that we have the architecture in place, we can go through a scenario where
    a developer uses our frontend framework parts to build a simple frontend example
    application. In [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), we performed
    the same task to get a good outline of all the features working together to achieve
    a certain task. To follow along, ensure that you have installed the dependencies,
    and then you can start the sample app in the following directory:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了架构，我们可以通过一个场景来了解开发人员如何使用我们的前端框架组件来构建一个简单的客户端示例应用程序。在[*第7章*](B19014_07.xhtml#_idTextAnchor108)中，我们执行了相同的任务，以获得所有功能协同工作以完成特定任务的良好概述。为了跟上进度，请确保你已经安装了依赖项，然后你可以在以下目录中启动示例应用程序：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will be able to open the browser at `http://localhost:9000` to view the
    application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够打开浏览器，在`http://localhost:9000`查看应用程序。
- en: '![Figure 8.5: A sample client-side app](img/Figure_8.5_B19014.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：一个示例客户端应用程序](img/Figure_8.5_B19014.jpg)'
- en: 'Figure 8.5: A sample client-side app'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：一个示例客户端应用程序
- en: Based on *Figure 8**.4*, we want to create a page with a header called **List
    of frameworks**. We also want to list some frameworks on this page. Every framework
    entry should attach to the client-side view and show a number of star points to
    every framework. Besides the static functionality, we have buttons under each
    framework component that are able to increment a counter, in this case we label
    the counter as the number of stars for every project. The developer use case also
    includes using the SSR features to render the page from the server for performance
    and SEO purposes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*图8.4*，我们想要创建一个名为**框架列表**的页面。我们还想在这个页面上列出一些框架。每个框架条目都应该连接到客户端视图，并为每个框架显示一定数量的星星点。除了静态功能外，每个框架组件下还有按钮，可以增加计数器，在这种情况下，我们将计数器标记为每个项目的星星数量。开发人员用例还包括使用SSR功能从服务器渲染页面，以提高性能和SEO。
- en: 'To begin, our Componium framework allows us to create `ClientViews` from the
    server. We can create a client view at the root of the application in the `app.js`
    file. We can also utilize the `componium` executable here to scaffold the components:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的Componium框架允许我们从服务器创建`ClientViews`。我们可以在`app.js`文件的应用程序根目录中创建一个客户端视图。我们还可以在这里使用`componium`可执行文件来搭建组件：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code from the root of our application will establish a hosted
    route at the endpoint designated with a `/` on the Componium server. Besides providing
    the path, we also specify the name of the view and additional options for that
    view. The name of the view maps to the `views` directory in our applications.
    The `views/frameworks.js` file defines our server-side component handler:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从我们应用的根目录开始，将在Componium服务器上指定以`/`结尾的端点处建立一个托管路由。除了提供路径外，我们还指定了视图的名称以及该视图的附加选项。视图的名称映射到我们应用中的`views`目录。`views/frameworks.js`文件定义了我们的服务器端组件处理器：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To see the full version of this component, check out the `tests/sample/views/frameworks.js`
    file. The preceding code only lists one of the frameworks in the list, but the
    sample has all of the required items. Looking deeper into the code, we have access
    to the `request` and `response` objects in this exported `frameworks` function.
    This is where developers can also access the database ORM methods in this file
    to fetch the data and pre-populate the component state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此组件的完整版本，请查看`tests/sample/views/frameworks.js`文件。前面的代码仅列出了列表中的一个框架，但示例中包含了所有必需的项目。进一步查看代码，我们可以在导出的`frameworks`函数中访问`request`和`response`对象。这就是开发者也可以在此文件中访问数据库ORM方法以获取数据和预先填充组件状态的地方。
- en: 'With the defined `framework-item` components in place, we can start the application
    server and navigate to the root of the application. If we view the source of the
    file, we can see the SSR components. Partially, the source would look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`framework-item`组件之后，我们可以启动应用程序服务器并导航到应用程序的根目录。如果我们查看文件源代码，我们可以看到SSR组件。部分源代码可能如下所示：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The state of the component, including the number of stars is hydrated from
    the rendered component. If we use the following `button` element in the `framework-item`
    component, then we increase the number of starts based on the state that originated
    from the server:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的状态，包括星星的数量，是从渲染的组件中恢复的。如果我们使用`framework-item`组件中的以下`button`元素，那么我们将根据从服务器起源的状态增加星星的数量：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, with the `frameworks.js` application view created, we can now deploy
    our application to give it a test run. Here, developers should configure the `app.js`
    process to run with the `NODE_ENV=production` environment variable turned on.
    This will enable the `esbuild` optimization features, allowing the server process
    to minify our newly created components.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在创建了`frameworks.js`应用程序视图之后，我们现在可以将应用程序部署以进行测试运行。在此，开发者应配置`app.js`进程，使其在开启`NODE_ENV=production`环境变量的情况下运行。这将启用`esbuild`优化功能，允许服务器进程压缩我们新创建的组件。
- en: This example use of the framework included creating components, rendering them
    on the server side, and interacting with their state by clicking on their UI elements.
    This practical example and the routing examples from the *Client router* section
    showcase most of the features that we have developed for this initial version
    of the framework features. The following steps from here could involve finding
    ways to improve the component-based architecture, as well as finding more ways
    to add potential optimizations to the applications built with our framework.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此框架的示例用法包括创建组件、在服务器端渲染它们，并通过点击它们的UI元素与其状态交互。这个实际示例以及来自*客户端路由器*部分的路线示例展示了我们为这个框架功能的初始版本开发的大多数功能。从现在开始的下一步可能涉及找到改进基于组件的架构的方法，以及找到更多为使用我们的框架构建的应用程序添加潜在优化的方法。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on building a frontend architecture and adding frontend
    features to our existing project. Similar to the definition of server-side architecture
    in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), in this chapter, we had to
    define the goals behind the frontend features, focusing on what developers would
    like to do with our full stack framework. We have covered the topics of defining
    entry points for client routes, concepts of reactivity, complex component structures,
    SSR, routing, optimizations, and so on. The frontend feature set can be overwhelming,
    with a lot of terminology, and there is much more to learn beyond this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于构建前端架构并向现有项目添加前端功能。类似于在[*第7章*](B19014_07.xhtml#_idTextAnchor108)中对服务器端架构的定义，在本章中，我们必须定义前端功能背后的目标，关注开发者希望如何使用我们的全栈框架。我们已经涵盖了定义客户端路由的入口点、响应式概念、复杂组件结构、SSR、路由、优化等主题。前端功能集可能令人眼花缭乱，有很多术语，而且本章之外还有更多内容需要学习。
- en: If we combine all the components that we have architected in the past several
    chapters, we now end up with a framework consisting of three use cases that combine
    into a larger full stack narrative. So far, we have seen a JavaScript testing
    framework, a backend framework, and finally, a frontend framework under the same
    logical namespace.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将过去几章中我们设计的所有组件组合起来，我们现在最终得到一个包含三个用例的框架，这些用例组合成一个更大的全栈叙事。到目前为止，我们看到了一个JavaScript测试框架、一个后端框架，最后是一个位于相同逻辑命名空间下的前端框架。
- en: In the next chapter, we will focus on essential topics of framework maintenance
    by shedding light on various situations that can occur as frameworks evolve.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过揭示随着框架的发展可能出现的各种情况，重点关注框架维护的必要话题。
- en: 'Part 3: Maintaining Your Project'
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：维护你的项目
- en: In conclusion, the last two chapters give an in-depth look at the maintenance
    aspects and future of framework projects in the JavaScript programming space.
    The driving factor behind these chapters is to ensure the longevity and usability
    of the projects that developers build to guarantee the creations’ reliability
    and effectiveness. Looking over the best practices of such systems, the final
    chapter presents current and future ideas that are relevant to established and
    new projects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，最后两章深入探讨了JavaScript编程空间中框架项目的维护方面和未来。这些章节背后的推动因素是确保开发者构建的项目能够长期使用和可用，从而保证创作的可靠性和有效性。回顾这些系统的最佳实践，最后一章提出了与现有和新项目都相关的当前和未来想法。
- en: 'In this part, we cover the following chapters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们涵盖了以下章节：
- en: '[*Chapter 9*](B19014_09.xhtml#_idTextAnchor156), *Framework Maintenance*'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19014_09.xhtml#_idTextAnchor156)，*框架维护*'
- en: '[*Chapter 10*](B19014_10.xhtml#_idTextAnchor173), *Best Practices*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19014_10.xhtml#_idTextAnchor173)，*最佳实践*'
