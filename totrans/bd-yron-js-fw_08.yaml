- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecting Frontend Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we now switch focus to the frontend components of the full
    stack framework that we began building in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108).
    This is the final part of adding new features and architecting the technical design
    for the purposes of our **Componium** framework example. The frontend features
    are the most complex to design because they require a lot of domain knowledge
    of browsers, in-depth JavaScript, the ability to handle complex edge cases, and
    so on. We will cover a series of frontend topics that focus on enabling a full
    stack framework development environment. Here are some of the topics that we will
    cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frontend features**: We will determine the features and goals of the frontend
    components for our framework. In addition, this new frontend infrastructure needs
    to interact with the existing components of the full stack framework, such as
    the backend API routes and the testing interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architectural design**: After learning more about the low-level interfaces
    of established frameworks, we will create a framework design that can offer similar
    features with low-level interfaces of its own. This includes developing a component,
    view, and routing architecture to server content to the web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frontend patterns**: Learning about common frontend patterns and optimizations
    will help us become more accustomed to working with existing frameworks and building
    new ones in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is crucial to keep in mind that we can only scratch the surface of the feature
    set that other frameworks offer out of the box. For example, we can include a
    client-side router with a component-based architecture, including reactivity in
    those components. Frameworks such as Vue.js, Angular, and Svelte, plus libraries
    such as React, required years of development to cover all edge cases and significantly
    expand the feature set. For the purposes of this chapter, we will focus on keeping
    things closer to the basics and build several technical parts from scratch. This
    should give you a good understanding of the underlying components of other full
    stack frameworks with frontend features, such as Next.js. For example, we will
    use some of the web components APIs that are built right into modern web browsers
    to enable a rich feature set in our own framework.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the chapter, we shall also examine the intended workflow to
    understand the series of steps taken by a developer to utilize the framework interfaces
    to achieve specific application development goals, using our newly architected
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter are very similar to those for [*Chapter
    7*](B19014_07.xhtml#_idTextAnchor108). This chapter reuses the framework files
    that we saw in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108) with frontend components
    and interfaces. The sample application in the `tests` directory is also changed
    to showcase some of the frontend features. Locate the book’s repository at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework),
    and continue to use the code in the `chapter7` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the `README.md` instructions in the directory for available scripts.
    The sample app can be found in the `tests/sample` directory of the framework.
    When you start that application, it will be available on port `9000`. You can
    open it with a browser using the `http://localhost:9000/` URL. While you are jumping
    into exploring the chapter code base, it is recommended to use the debugging tools
    to trace how the elements come together. Refer to the *Debugging* section of [*Chapter
    2*](B19014_02.xhtml#_idTextAnchor030) to configure a debuggable environment.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the frontend framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue from the previous chapter by reusing the example **Componium**
    framework project. In [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), we created
    several features that allow us to interact with server-side routes, define APIs,
    and query a database. Currently, there is no way to develop frontend components
    to either consume those APIs or add visual interfaces using our framework. Without
    the frontend part of our framework, a developer needing to build an interactive
    interface, hosted using a Componium server, would need to include an external
    library and statically serve additional application files from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will change the lack of frontend features by creating several
    frontend features that will allow framework users to create client interfaces.
    These frontend features will mimic some of the complex features of the existing
    established frontend frameworks. For instance, our approach to reactivity features
    inside the components will include the basics, utilizing the built-in APIs from
    the browsers.
  prefs: []
  type: TYPE_NORMAL
- en: To begin this process, we will identify the goals of the features we want to
    support. After that, we will follow with a sample architecture design that will
    make those features a reality and make our framework genuinely full stack.
  prefs: []
  type: TYPE_NORMAL
- en: Goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The frontend framework sets three goals that will be later supported by the
    features that we create. Overall, it is a good idea to define these goals in a
    general manner and use them as you progress with your framework project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web-based interfaces**: Goal number one is to empower developers to *create
    web-based interfaces* while maintaining cohesion with the backend/server components
    of the framework. With the frontend capabilities of the framework, developers
    will have the ability to write, host, and deploy interactive client interfaces.
    These interfaces will be made possible by providing a frontend framework API to
    create components and attach those to client-based views. These client-based features
    should also be testable and debuggable, either by the built-in Componium test
    interfaces or external testing tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable interactivity**: A comprehensive set of APIs, both on the server-side
    and frontend side, will help *enable the interactivity* required by many of the
    framework-backed projects. The interactivity features need to enable developers
    to use familiar technologies such as HTML, CSS, and frontend JavaScript to craft
    components. The framework should also have the affordances to be able to include
    potential external libraries. For example, if someone wants to create a visualization
    within their Componium frontend application, then they should easily be able to
    include external libraries such as Three.js and D3.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Promote reusability**: We want to include a set of framework affordances
    to build complex applications. These could be applications with many frontend
    differentiated views that include a large number of nested components. These could
    also include a set of optimizations for production environments and the ability
    to manage large application code bases. Primarily, we also want to *promote the
    reusability* of code and guide developers to make intelligent decisions when building
    their applications. An easily extensible feature set can be beneficial to cover
    a lot of the potential use cases. If we get the architecture right, it will allow
    for high degrees of customizability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning from already existing frameworks such as Next.js, we also want to make
    sure to include some of the more modern features and offer pleasing developer
    experiences alongside those features. These could include code generation affordances,
    similar to the ones we saw in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108).
    To set the framework apart from some of the other solutions, we will also set
    a goal to use some of the newly shipped Web APIs. Taking advantage of starting
    from scratch in our project gives us a good opportunity to evaluate the latest
    developments in the browser platforms, choosing the newly available APIs. As part
    of our learning goals, we will also try to contrast the difference between our
    newly developed framework and the established mature frameworks, such as Vue.js
    and Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: With these goals in mind, let’s dive into the set of features that can back
    these goals up.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The frontend goals defined in the previous section will help us guide the thought
    process behind our feature development. To support the established goals, let
    us plan out some of the technical features that developers will find useful and
    expect from the framework. Here are some substantial features that we will discuss
    in detail in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serve HTML files and content**: To support the features of the interactive
    interfaces, we will need to add the ability to serve the generated HTML output
    to browser requests. We need to ensure that we have the capabilities to serve
    static content to sustain additional JavaScript code, images, media, and other
    types of files. This feature is vital to render content on the client side in
    a web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structured application code**: We need to grant the ability to define reusable
    interactive JavaScript components with CSS/HTML templating and styling features.
    We will do this using a component-based architectural approach. The component
    architecture feature itself will enable the development of user interfaces. The
    structured application code that it can help produce will consist of independent
    and reusable bits of code that serve as the building blocks of the whole web application.
    This will support our goals of reusability and providing good application primitives,
    as it takes advantage of component paradigms, such as reactivity, composability,
    and modularity. The approach to this feature aims to have each component control
    its own state and render the interfaces based on the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting the maintenance goals, the component-based approach ensures isolated
    testing and debuggability of the application code. Here, we channel some of the
    previous design decisions from other frameworks. For example, in Vue.js, components
    are structured with JavaScript logic, HTML templates, and the ability to style
    them with CSS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Composability**: Expanding on the previous point, it is important to highlight
    the composability of application code as an important feature of the framework
    we want to create. Defining a nested structure based on how the web browser internal
    DOM structure, components can then be composed together to create complex user
    interfaces. Refer to the *Components* section of [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030)
    for a recap of the importance of this feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-side router**: One of the core pieces of frontend framework organization
    that we have seen in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030) was the router.
    The routing feature set is crucial to include in our feature set because it is
    responsible for navigating between complex views of our application. From [*Chapter
    7*](B19014_07.xhtml#_idTextAnchor108), we already have an API for server-side
    routes, and the frontend router will help provide the functionality to enable
    a fast and smooth transition between different application states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router will adhere to the existing concepts of web application navigation
    and utilize the relevant Web APIs to modify the browser’s URL and history features.
    The inclusion of the router will also be beneficial in creating a more logically
    organized code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpClient` helper module ([angular.io/guide/understanding-communicating-with-http](http://angular.io/guide/understanding-communicating-with-http))
    to communicate with suitable backend services. This would be an excellent reinforcing
    feature for our sample project, especially if combined with some of the specific
    *Componium server*-defined routes. For example, to help enhance the developer
    experience, we can pre-generate some of the data fetching calls for the known
    endpoints and create dynamic interfaces around those, thus saving time for developers
    building with our framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side rendering (SSR)**: We mentioned SSR features in other framework
    examples throughout the book. We will include these features in our example framework
    as well. The SSR methods will render the components on the server side to help
    improve the rendering performance of the applications. Given our full control
    over the developer experience of the full stack framework in this particular case,
    developing this type of functionality is easier for us. Besides the performance
    improvements, SSR is beneficial for search engine optimization purposes and general
    page loading time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internals of SSR include close collaboration between components pre-rendered
    on the backend and later hydrated by the frontend code. The backend routes should
    also be able to inject the state of components into the pre-rendered elements.
    The state can be static data or information fetched from external sources, such
    as a database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Production optimizations**: As part of the commitment to empowering developers,
    the framework will also feature some optimization steps for applications running
    in production environments. This means including additional internal tooling that
    performs optimizations, such as minification, behind the scenes. These kinds of
    optimizations are also much easier to integrate within our framework because we
    have control of the server tooling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides code minification, we can also look into advanced JavaScript optimization
    techniques such as tree-shaking and code-splitting. Supporting static file handling,
    we can potentially optimize other media such as images. Generally, as the framework
    continues, we want to consistently work on such optimization improvements because
    it benefits all the framework’s users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding list is a selected set of functionalities that should make the
    frontend feature-rich, give us a good learning opportunity, and also cover realistic
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following *Figure 8**.1* provides a summary of how the listed features
    interact with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: The features summarized](img/Figure_8.1_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The features summarized'
  prefs: []
  type: TYPE_NORMAL
- en: The existing server-side code will be able to serve static files that can be
    consumed by the frontend. At the same time, the server process is capable of importing
    and accessing some of the components to render them on the server side. Finally,
    the backend has a definition of client routes; these are the frontend endpoints
    that are classified as accessible by a browser to be rendered in the client.
  prefs: []
  type: TYPE_NORMAL
- en: On the frontend side, we have the *API interaction* features that communicate
    with the server or make requests to external APIs that are hosted on external
    services. Simultaneously, a client-side router tightly works with the component
    architecture to enable the user interface experience in the browser. Finally,
    we have a set of frontend optimizations that cover all of the frontend surfaces,
    ensuring the most optimized experience when deploying and running applications
    in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: With these features in mind, let us proceed to the architecture step, where
    we can explore the technical and organizational concepts that make these features
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the required features outlined and documented, let us extend the existing
    architecture from [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108). The changes
    will be adding new functionality to the framework architecture, concentrating
    on enabling the `ClientView` abstractions and functionality, which will drive
    the feature experience behind the frontend changes.
  prefs: []
  type: TYPE_NORMAL
- en: We already have the capability to create server API endpoints. The general implementation
    of the architecture of the features will consist of introducing several new interfaces
    to the server part of the framework. The newly added frontend features will be
    situated in the `frontend` directory of the framework project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Componium frontend components](img/Figure_8.2_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Componium frontend components'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8**.2*, we outline an incoming request to the server powered by the
    Componium server framework. Specifically, this request is expected to respond
    with an HTML page to provide interactivity features. This is unlike the API requests
    from [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), where we would receive JSON
    or GraphQL responses with data. The request handler can still process incoming
    request objects, such that it can access properties of the request, such as the
    query parameters. It can also tweak any properties of the response object. In
    [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), we used `server.addRoute(...)`
    to add new routes. To add route handlers that provide the functionality, we will
    use a similarly structured `server.addClientView(...)` method that will have a
    similar API, but a totally different behavior. This new method is where the **client
    view** functionality from *Figure 8**.2* will take place.
  prefs: []
  type: TYPE_NORMAL
- en: In the Componium frontend component design, a client view can have a singular
    view and many components used within it. The concept of the client view is a server-side
    definition, while the concept of views is shared across both the server and the
    client side. Once the client view is defined, it assembles all the imported components
    and the View together and sends a response back to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the client view interaction, the server can now also define and access
    static file directories. These static files can be directly accessed by the browser,
    and the whole directory is exposed to the web server. These static files are also
    usable by the Client Views to import additional resources into the Client Views,
    such as any media files (images, fonts, styles, etc.) or additional JavaScript
    components. The ease of access to static files simplifies how a frontend framework
    can include external media and other useful entities that can be included within
    the web application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will get a detailed look into how Client Views become
    the gateway for the frontend features and files, allowing us to create multiple
    endpoints serving HTML, CSS, and JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Entry points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow flexibility when creating multiple frontend Client Views, our framework
    provides a way to define multiple client endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is an example of routing the root path of our server to
    the `frameworks` view. Developers can create a `frameworks.js` file inside the
    `views` directory to map this view by the defined name. `.addClientView(...)`
    can be configured multiple times, with as many views attached to different route
    handlers. The contents of `frameworks.js` have a familiar structure to the route
    handlers from [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code can be as simple as returning a paragraph tag. You can find
    other examples of more involved views in the `tests/sample/views/` directory.
    The view handler has access to the `Request` and `Response` objects of the route
    to tweak the behavior of the route or fetch additional data. We also have access
    to the `componium` variable here to access the interfaces of the framework. For
    simplicity, we will use JavaScript template literals in more complex templates.
    The framework takes care of rendering the desired HTML structures, and it also
    wraps the `<p>` tag in the preceding code in a valid HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important entry point for our frontend files is static file configuration.
    To be able to resolve other types of media, the framework provides a way to mark
    certain directories of the application project as an endpoint that serves static
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `.addStaticDirectory(...)` method maps the server route for `/images` to
    the `img` directory in the application project. This relies on the similar properties
    of the backend express server that we worked with in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108).
    This new static directory also works in custom routers, which are created with
    `server.createRouter(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a way to process and render basic views and create as many of them
    as we want. We now need to enable the component-based architecture. This is what
    will allow us to produce more complex interactive components.
  prefs: []
  type: TYPE_NORMAL
- en: Reactivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To achieve the dynamic interface features of our frontend framework, we need
    to learn more about the concepts of reactivity and reactive components. The reactivity
    concepts in application programming direct the user interface to update and respond
    to underlying data or state changes dynamically. In the context of JavaScript,
    especially in the frontend systems, we use custom-developed primitives in combination
    with browser APIs to achieve performant user interface reactivity. The reactivity
    features enable a seamless experience for web application consumers by automatically
    updating the interface whenever relevant underlying data changes. Similar to other
    programming environments, in the JavaScript world, developers rely on frameworks
    and helper libraries to enable reactivity for components in their applications.
    In fact, this reliance on external tooling in JavaScript is much stronger than
    in other languages. This is mainly due to the cross-browser and cross-engine nature
    of web page and web application development.
  prefs: []
  type: TYPE_NORMAL
- en: The reactive programming paradigm has become very fitting in the web development
    environment, due to the asynchronous nature of JavaScript. Other contributing
    factors for the reactive paradigm fit included application requirements for real-time
    updates, complex interactivity, and making it easier to manage the state of applications.
    The user interfaces have become much more complex. These days, the expectations
    of web applications require frontend systems to be dynamic, consume real-time
    data, and be instantly responsive to user actions. Also, the existing structure
    and abstractions around a web browser’s **Document Object Model** (**DOM**) have
    compelled solutions to be based on manipulating a nested node tree of page elements.
    The reactive changes in the interface utilize the diffing algorithms to update
    the changed nodes of a component tree.
  prefs: []
  type: TYPE_NORMAL
- en: Reactivity requires data binding, which is a connection between data and the
    elements of applications. In the web development world, the data would be provided
    by JavaScript interfaces, most likely dynamically loaded from some API endpoint.
    The elements would be the *HTML/DOM* structures in the browser client. The corresponding
    browser elements are automatically updated to reflect the changes when the underlying
    data updates. In [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030), in the *Framework
    building blocks* section, we highlighted the possible ways in which data binding
    can occur within these reactive components. We also saw examples of frameworks
    using one-way or two-way binding. The flow largely depends on architectural decisions,
    either allowing the elements to update when data changes or also allowing the
    elements to update the underlying data. Popular frameworks such as Vue.js and
    anything that includes React use an implementation of a *virtual DOM* tree to
    render an application’s state as the data changes. However, there are also examples
    where projects, such as those involving Svelte and Angular, use the real DOM or
    *shadow DOM* features to achieve similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to other frontend projects, we will introduce the concept of reactive
    components into our framework. These components will allow us to encapsulate HTML
    elements and application logic alongside them. The frontend *Componium* components
    will maintain their internal state and respond to data and interactions. To keep
    things simpler and without diving deeper into the internals of the existing frontend
    frameworks, we can build an example of basic reactivity concepts using a combination
    of Web Components and other more modern Web APIs. A practical overview of the
    component architecture will provide a good learning opportunity to understand
    the built-in browser primitives. It will also offer a good comparison and understanding
    of the complex problems that the existing frameworks solve for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is our newly defined `ReactiveComponent`; it has been compacted
    to fit in better in this chapter. The class starts off extending `HTMLElement`.
    This interface will help us represent HTML elements and create our own web components.
    In the `constructor` method, we have a declaration for the `state` property, which
    will keep track of the state of the component. Another important constructor call
    is `.attachShadow()`. This call attaches a Shadow DOM to the custom element and
    provides a scoped environment for the encapsulated CSS and JavaScript instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed low-level explanation of how Shadow DOM is structured, check
    out the MDN page at [developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM).
  prefs: []
  type: TYPE_NORMAL
- en: In the `reactive` method, we configure a new `Proxy` object, which is another
    built-in Web API with properties that can help us make reactive changes to the
    state of our components. The `Proxy` methods take an object and return a new object
    that serves as a proxy for the original definition. The proxy behavior helps trigger
    updates and re-renders of a component when the object is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading
  prefs: []
  type: TYPE_NORMAL
- en: 'For details on the `Proxy` interface, check out the detailed article at MDN:
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
    )'
  prefs: []
  type: TYPE_NORMAL
- en: The setter operation and the update methods will be invoked when the state changes.
    The `update()` method is overridden in the components that inherit this `ReactiveComponent`
    class. With `ReactiveComponent`, we can build a simple set of example components.
    This structure will bind the data from the component state into the rendered templates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: A basic components example](img/Figure_8.3_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: A basic components example'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.3* presents an example view of two components in action; one is
    the year tracker and the other is the month tracker. Both components have the
    option to increment the values of the appropriate dates. You can find the code
    for this working example in the `tests/basic-components/index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The source of the view follows; it just includes a newly defined component
    by its name, `year-component`, wrapped in regular HTML tags. This was achieved
    by registering the custom element using the built-in Web Components interface
    – `customElements.define("year-component", YearComponent);`. The `year-component`
    component extends the preceding `ReactiveComponent` class and overrides the empty
    `update` and `template` methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The methods listed in the preceding code, such as `update()` and `template()`,
    render the data relevant to the component and define the template returned by
    the `year-component` component. We also have event handlers that change and update
    the year, using access to `this.state`. Also, note that to access the Shadow DOM
    properties of this `Year` component, we use `this.shadowRoot.querySelector`. The
    template defined in the component includes `month-component`, which is a nested
    component. It has a similar setup to the extended class of `ReactiveComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: This component configuration, using the Web Components APIs and other affordances
    from the browser APIs, is a good starting point for the framework. We can use
    these patterns to achieve similar functionality in other frameworks, such as Vue.js,
    and frameworks that use React as their underlying library to structure their components.
    The interface we have has reactivity properties, the ability to compose components
    simultaneously, and the basics of templating.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will take this a bit further and utilize an external
    Web Component helper library to build upon this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Improving components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the reactivity part of the architecture, we have described a pattern of using
    Web Components comprised of other techniques to achieve the desired feature set.
    To enhance this further, we will bring in the `lit.dev`), which will help make
    our job of managing the components much more straightforward, and our framework
    can be dependent on it. We shall use the same approach of abstractions and utilize
    the interfaces of this library to create the component features of our framework.
  prefs: []
  type: TYPE_NORMAL
- en: About the Lit library
  prefs: []
  type: TYPE_NORMAL
- en: The Lit open source library has been around for more than six years, and its
    goal is to simplify and abstract away some of the verbose tasks that deal with
    Web Components. At its core, it provides reactive state features, scoped CSS styling,
    templating, and a variety of advanced features to compose and work with frontend
    components. It works with both JavaScript and TypeScript languages and comes with
    a large variety of packages that extend its functionality. For example, Lit has
    additional tools to enable localization, animate frontend elements, and also integrate
    with React components.
  prefs: []
  type: TYPE_NORMAL
- en: The library uses the standard component life cycle, in addition to its own component
    life cycle methods to simplify certain operations, such as DOM reactivity. You
    can find the source of the project at [github.com/lit/lit](https://github.com/lit/lit)
    and [lit.dev/docs](https://lit.dev/docs).
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a comparison with the preceding `ReactiveComponent` interfaces, let’s
    take a look at how similar the code would be to the basic components if we used
    the Lit library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code imports the `LitElement` class that we can extend. This new
    code block result looks very familiar to the code of `year-component` that we
    saw in the *Reactivity* section. However, there are some additional improvements
    we have in this component definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we have a CSS helper interface, which allows us to declare the
    style of our component using the `static` `styles` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the way we declare the state of the component has also changed – we
    define a `static properties` object with some extra definitions of the properties.
    These properties are used in a similar way in the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This brings us to the third point – the templating is also a bit different.
    It uses the `lit-html` helpers to enable more advanced templating features and
    help us work with HTML. This helper allows us to create templating directives,
    tweak the rendering methods, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading
  prefs: []
  type: TYPE_NORMAL
- en: Detailed documentation of all the templating features can be found at [lit.dev/docs/v3/templates/expressions](https://lit.dev/docs/v3/templates/expressions).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of our sample framework, we will define our own `ComponiumComponent`
    class. This class will be available to the developers to create rich components,
    combining what we have learned from the *Reactivity* section and the Lit library.
    We can also rely on the rich functionalities of Lit templating to render the results.
    To enable this, we will load the Lit library alongside the `componium.js` framework
    file in `ClientViews`. This will expose the component interface to developer-defined
    components. To start using those interfaces, developers can import them using
    the ES6 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The class to extend is provided, alongside the CSS and HTML helpers to help
    construct the components. For example, if our component has interactive buttons,
    it can use the following Lit syntax to declare event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `_click` event handler is a method defined on the class that extends from
    `ComponiumComponent`. If these components require any static files, they can request
    them directly by fetching them from the static routes declared by the Componium
    server. However, we can still take this one step further and use Lit and the mix
    of our framework’s interfaces to enable the complex features of SSR. There will
    be more on the concept of utilizing the existing components from a server in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: SSR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned about the features and benefits of SSR when we planned the frontend
    interfaces of Componium. On a technical level, SSR requires several parts of our
    framework to work really well. Here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: The component architecture needs to support different rendering capabilities.
    This includes the ability to pre-render the components as HTML that can be transmitted
    over the wire to the frontend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components need to be able to run consistently on both the server and the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server-rendered components should have the ability to fetch data in both
    the client and server environments. Depending on the environment, components should
    have a similar approach to how data is requested and processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a server that can structure and render the components, including attaching
    a state and data to these components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frontend side should be able to take the server-side state of the components
    and later hydrate them. It should be able to attach the required events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, with our framework and the Lib library, we have a lot of these requirements
    covered and can develop the SSR support in our framework. Using the `@lit-labs/ssr`
    package, we can define a server-side render in conjunction with our Client View
    abstractions. The modules for these features can be found in `packages/frontend/client-view.js`.
    To have a flexible feature set in our framework, we want developers to use both
    client-side-only components and a combination of server-rendered components.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the SSR capabilities, the framework has a new `Renderer` class, which
    has the job of consolidating all the required framework code and developer-defined
    components. It does so by responding to client-side requests with a unified template
    of a valid HTML document and by injecting code from the application directory.
    To render these structures, we can use the `html` helpers from the `ssr` library.
    To understand the capabilities of the `ssr` package, check out the comprehensive
    documentation at `lit.dev/docs/ssr/overview`.
  prefs: []
  type: TYPE_NORMAL
- en: These capabilities work in tandem with the Componium server rendering methods
    to output the resulting HTML to the client. Once the HTML document has been fully
    loaded in the browser, then the hydration process begins. The framework files
    load the required supporting files that will help attach the event handlers to
    our components and make them interactive.
  prefs: []
  type: TYPE_NORMAL
- en: We shall examine the detailed usage of the server-side rendering features in
    the upcoming *Using the framework* section. Meanwhile, there are a few more architectural
    features left to cover before we can start using all of them together.
  prefs: []
  type: TYPE_NORMAL
- en: Client router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the framework planning stage, the router was highlighted as an essential
    piece of frontend infrastructure that allows an interface to transition between
    significant sections of an application. The routing implementations are very similar
    across many frontend frameworks. However, if you are really passionate about the
    routing features, the *React Router* project ([reactrouter.com](https://reactrouter.com))
    is a great project to learn from in terms of educating yourself about good routing
    abstractions, the potential pitfalls, and routing edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: A transition between the initial page (left) and the newly routed
    page (right)](img/Figure_8.4_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: A transition between the initial page (left) and the newly routed
    page (right)'
  prefs: []
  type: TYPE_NORMAL
- en: To enable the routing functionality in our framework, we will introduce a `ComponiumRouter`
    class. In *Figure 8**.4*, we can see the routing transition between the initial
    `/client-render` page (*left*) and the newly routed page, `/page` (*right*). The
    routing happens when you click on the `this.router = new ComponiumRouter("client-render",`
    `routes, this.shadowRoot);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router gets an identifier (`client-render`), a series of routes with the
    `routes` object, and a root element (in this case, the `this.shadowRoot` object)
    that will be used to render the routed templates. The `routes` object is defined
    as an array of objects. For example, a simple route example for *Figure 8**.4*
    would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `/client-render` route is one of our entry points that has Client View type
    and the `/page` route is a view we can navigate to. The router can support a richer
    feature set by accepting more complex templating structures in the `template`
    property. For example, we can use the `html` helper from the `Componium/Lit` modules
    to produce more extensive template objects in the routing definition.
  prefs: []
  type: TYPE_NORMAL
- en: To navigate between routes, we will rely on more built-in Web APIs in browsers.
    For instance, the components call out to `history.pushState(...)` when views need
    to be changed. Inside the `ComponiumRouter` class, the framework handles those
    `pushState` events and renders the appropriate template.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading
  prefs: []
  type: TYPE_NORMAL
- en: 'The MDN documentation outlines all possible History API methods we can use
    in our frontend routing components. It is available here: [developer.mozilla.org/en-US/docs/Web/API/History/pushState](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState).'
  prefs: []
  type: TYPE_NORMAL
- en: In the Lit Labs open source code base, there is another example of a component
    router. The source for it can be found at [github.com/lit/lit/tree/main/packages/labs/router](https://github.com/lit/lit/tree/main/packages/labs/router).
    It can be an excellent exercise to implement the router in the *Componium* framework.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of our goals for frontend functionality was a set of optimizations to make
    the applications that our framework produces more efficient, scalable, and performant.
    We shall take a step toward that by introducing some features to optimize the
    output of our frontend components in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce a new `Optimize` class, which has some functions to perform
    optimizations on the code base. The class can be found in the framework directory
    at `packages/frontend/optimize.js`. These optimizations can affect both the included/injected
    framework files and the application code. The functions of this class will activate
    when applications deploy within an envrionment that has the `NODE_ENV=production`
    variables defined, which is the common pattern for Node.js-based projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will utilize some existing JavaScript tooling – in this particular case,
    `esbuild` – to `minify` the framework and component code files. The `esbuild`
    tooling provides the following minification command-line API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can use the power of `esbuild` tooling to optimize applications built with
    our framework. For example, all the components used in an application will be
    minified by the server process when required. Under the hood, the framework parses
    through the component files and runs the minification step, outputting the optimized
    files into a separate directory. We use a hidden directory called `.componium`
    as storage to save the optimized files. The framework later knows to access the
    optimized files instead of the originals.
  prefs: []
  type: TYPE_NORMAL
- en: To expand further improvements in the future, we can focus optimizations on
    other application files, such as images, media, and more. The introduction of
    more complex build tools is also possible. For example, we can add `rollup.js`
    to enhance the resulting output of the client-side code. We have seen example
    usages of rollup tooling in [*Chapter 3*](B19014_03.xhtml#_idTextAnchor051). `Esbuild`
    also provides additional functionality besides the minification that can be found
    at [esbuild.github.io/api](https://esbuild.github.io/api).
  prefs: []
  type: TYPE_NORMAL
- en: Now, the final part to cover is the improvements in the developer experience
    for these frontend components, which we will do in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Developer experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The finishing touches for our features are to include some improvements to the
    developer experience. We will do this through thorough documentation of the component
    system and by providing enhancements to the framework’s executable file.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation should provide clear instructions on the frontend capabilities,
    such as the definition of multiple Client Views and static file directories. The
    component structure, composability, and reactivity features also need to be described.
    For example, this could include a straightforward API to add new client routes
    and how the framework uses the Lit library to achieve the component-related features.
  prefs: []
  type: TYPE_NORMAL
- en: The improvements of the framework executable include the ability to generate
    the Client View routes, Views, and Components using a scaffolding operation. In
    [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), we saw an example of generating
    new API routes; this is a very similar addition. Just as before, with the executable,
    developers will be able to quickly generate some code and start composing frontend
    user interfaces. These pre-generated components include the default property configurations
    for styles and data properties of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we will demystify as many of the frontend features as possible, focusing
    on helping developers navigate the complicated intricacies of all the technologies
    that are in play while building client-side web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use several dependencies fetched from the `npm` package registry to
    achieve the level of functionality described in this chapter. Here are some notable
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Esbuild`: The bundler and minifier tool used for optimization steps when the
    framework server runs in production environments. With `esbuild`, we can quickly
    optimize scripts. It includes a lot of advanced features that we can use to extend
    the end-result scripts of our framework further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lit`: The library that helps us extend the existing Web Component techniques
    and provides much more advanced component features, such as enabling easier data-binding
    and simplified state management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lit-html`: Another module that is related to the Lit library, which provides
    templating features for the frontend features of our framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@lit-labs/srr` and `@lit-labs/ssr-client`: These two modules enable the SSR
    features of our framework. They can render the components in the Componium server
    and are later hydrated on the frontend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mainly, these libraries and tools help us enrich our framework features. Our
    framework can rely on these dependencies to enable efficient project building,
    component-based architecture, dynamic content rendering, and SSR, resulting in
    a performant, maintainable, and user-friendly application. With the detailed architecture
    in place, in the following section, we will explore the developer workflow to
    create a simple client-side application with Componium’s frontend features.
  prefs: []
  type: TYPE_NORMAL
- en: Using the framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the architecture in place, we can go through a scenario where
    a developer uses our frontend framework parts to build a simple frontend example
    application. In [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), we performed
    the same task to get a good outline of all the features working together to achieve
    a certain task. To follow along, ensure that you have installed the dependencies,
    and then you can start the sample app in the following directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You will be able to open the browser at `http://localhost:9000` to view the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: A sample client-side app](img/Figure_8.5_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: A sample client-side app'
  prefs: []
  type: TYPE_NORMAL
- en: Based on *Figure 8**.4*, we want to create a page with a header called **List
    of frameworks**. We also want to list some frameworks on this page. Every framework
    entry should attach to the client-side view and show a number of star points to
    every framework. Besides the static functionality, we have buttons under each
    framework component that are able to increment a counter, in this case we label
    the counter as the number of stars for every project. The developer use case also
    includes using the SSR features to render the page from the server for performance
    and SEO purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, our Componium framework allows us to create `ClientViews` from the
    server. We can create a client view at the root of the application in the `app.js`
    file. We can also utilize the `componium` executable here to scaffold the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code from the root of our application will establish a hosted
    route at the endpoint designated with a `/` on the Componium server. Besides providing
    the path, we also specify the name of the view and additional options for that
    view. The name of the view maps to the `views` directory in our applications.
    The `views/frameworks.js` file defines our server-side component handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To see the full version of this component, check out the `tests/sample/views/frameworks.js`
    file. The preceding code only lists one of the frameworks in the list, but the
    sample has all of the required items. Looking deeper into the code, we have access
    to the `request` and `response` objects in this exported `frameworks` function.
    This is where developers can also access the database ORM methods in this file
    to fetch the data and pre-populate the component state.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the defined `framework-item` components in place, we can start the application
    server and navigate to the root of the application. If we view the source of the
    file, we can see the SSR components. Partially, the source would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The state of the component, including the number of stars is hydrated from
    the rendered component. If we use the following `button` element in the `framework-item`
    component, then we increase the number of starts based on the state that originated
    from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, with the `frameworks.js` application view created, we can now deploy
    our application to give it a test run. Here, developers should configure the `app.js`
    process to run with the `NODE_ENV=production` environment variable turned on.
    This will enable the `esbuild` optimization features, allowing the server process
    to minify our newly created components.
  prefs: []
  type: TYPE_NORMAL
- en: This example use of the framework included creating components, rendering them
    on the server side, and interacting with their state by clicking on their UI elements.
    This practical example and the routing examples from the *Client router* section
    showcase most of the features that we have developed for this initial version
    of the framework features. The following steps from here could involve finding
    ways to improve the component-based architecture, as well as finding more ways
    to add potential optimizations to the applications built with our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on building a frontend architecture and adding frontend
    features to our existing project. Similar to the definition of server-side architecture
    in [*Chapter 7*](B19014_07.xhtml#_idTextAnchor108), in this chapter, we had to
    define the goals behind the frontend features, focusing on what developers would
    like to do with our full stack framework. We have covered the topics of defining
    entry points for client routes, concepts of reactivity, complex component structures,
    SSR, routing, optimizations, and so on. The frontend feature set can be overwhelming,
    with a lot of terminology, and there is much more to learn beyond this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If we combine all the components that we have architected in the past several
    chapters, we now end up with a framework consisting of three use cases that combine
    into a larger full stack narrative. So far, we have seen a JavaScript testing
    framework, a backend framework, and finally, a frontend framework under the same
    logical namespace.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on essential topics of framework maintenance
    by shedding light on various situations that can occur as frameworks evolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Maintaining Your Project'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, the last two chapters give an in-depth look at the maintenance
    aspects and future of framework projects in the JavaScript programming space.
    The driving factor behind these chapters is to ensure the longevity and usability
    of the projects that developers build to guarantee the creations’ reliability
    and effectiveness. Looking over the best practices of such systems, the final
    chapter presents current and future ideas that are relevant to established and
    new projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this part, we cover the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19014_09.xhtml#_idTextAnchor156), *Framework Maintenance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19014_10.xhtml#_idTextAnchor173), *Best Practices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
