<html><head></head><body>
        

                            
                    <h1 class="header-title">Testing and Debugging</h1>
                
            
            
                
<p>Testing is one of the most important phases of the development process. Whatever type of project you are working on, testing is key if you want to deliver applications with high quality and make your users happy.</p>
<p>Just imagine what would happen if your favorite taxi application makes your driver take you to the wrong place or the price of your trip is higher than it's supposed to be? This embarrassing bug will undoubtedly produce a series of catastrophic events that will damage the reputation of the application and, worse still, the company reputation.</p>
<p>Learning how to test our Aurelia applications and how to correctly apply the <strong>Test</strong>-<strong>Driven Development</strong> (<strong>TDD</strong>) approach will improve the quality of your applications, avoid embarrassing bugs, make your users happier, and make you a better developer. So, in this chapter, we will cover the following topics:</p>
<ul>
<li>Benefits of testing</li>
<li>TDD</li>
<li>Aurelia testing framework</li>
<li>Practicing testing</li>
<li>Debugging our code</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of testing</h1>
                
            
            
                
<p>Making <em>testing</em> part of our development process comes with a lot of benefits in every layer of our project. Before we start writing code to test our application, let's review the benefits that good testing brings to:</p>
<ul>
<li>The development team</li>
<li>The project</li>
<li>The organization</li>
<li>The users</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">For the development team</h1>
                
            
            
                
<p>If you work in a team with multiple members, you might have experienced that bad moment when a member pushes some changes and the application does not work as expected. Not only that, if the team does not have a mechanism to avoid changes that can break, someone else's code might cause conflict and decrease the quality of our applications.</p>
<p>Applying testing enables a mechanism that helps us avoid potential bugs in the code. It is recommended that you write test scripts for all the components into the application. The code coverage percentage is an indicator of how much testing the development team has written for the application. It is recommended to have a 100 percent coverage; with this, you ensure that every time someone else changes the code, you are not breaking someone else's code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">For the project</h1>
                
            
            
                
<p>If you are working in an <em>agile</em> team, you might be familiar with sprints of two weeks or maybe one month. When you work in agile teams, it is important to automate as much as you can, and automating the testing phase will help your team deliver deliverables quickly.</p>
<p>Automating testing without the need for human intervention requires your team to write tests in all the phases of the application, such as these:</p>
<ul>
<li>Unit test</li>
<li>Integration test</li>
<li>UI test</li>
<li>End-to-end test</li>
</ul>
<p>For Aurelia applications, you will learn how to write unit-test scripts and end-to-end tests. Writing tests and automating them will increase the development speed of our team.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">For the organization</h1>
                
            
            
                
<p>It is important to protect the reputation of the organization in which you are working. Testing projects in our organization as much as possible will improve its reputation and make it more reliable.</p>
<p>There are many cases where big companies have lost a large amount of money because of failures in software. All these mistakes could have been avoided if the applications had been tested before they were published to the users. For that reason, understanding the importance of good testing is key in every aspect of the organization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">For the users</h1>
                
            
            
                
<p>Nothing is worse than delivering an application to your users that does not satisfy their needs, and even worse is an application infested with bugs and is of a generally poor quality. Think carefully about what you deliver to your users. The more you code, the more satisfied your users will be.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test-Driven Development</h1>
                
            
            
                
<p>This is a development approach that changes the way developers test the code of their applications. Previously, developers implemented all the business logic of their applications and once everything was coded, they wrote the tests.</p>
<p>Writing test scripts is not an easy task; just imagine the time it takes to code all the business logic of your application, and the fact that you have to write tests for all the possible scenarios requires a lot of knowledge about the system itself and the level of complexity only increases if you are the sole developer who maintains the code. However, thankfully, there is a better way to test things out. TDD is composed of three simple phases:</p>
<div><img src="img/8288c148-ff21-4e0c-8387-d6c9ddaca46f.png" style="width:15.42em;height:17.17em;"/></div>
<p>Always remember these three colors: red, green, and blue; they represent the TDD cycle. Being in the red phase means that you have written what your piece of code is supposed to do, but the functionality is not implemented yet and the test will fail. Being in the blue phase, it means that you have implemented the code and the test now passes without any problem, but the code might be refactored. Lastly, being in the green phase means that both the code and tests were implemented and passed successfully, and the code is well formatted and easy for any developer to read.</p>
<p>Let's cover each step in further detail to get a close look at TDD phases by coding a simple example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making our code fail</h1>
                
            
            
                
<p>It is important to know that we won't use any testing framework at this point. The main goal in this section is to understand how TDD works; we have a complete tour of testing technology in the following sections in this chapter.</p>
<p>We will use TDD to create an additional function called <kbd>sum</kbd>, which will return the sum of two numbers that are passed as parameters. First, using an editor of your choice, create a new file called <kbd>testing.js</kbd> and add the following code:</p>
<pre>const assert = <strong>require('assert')</strong>;<br/><br/>function <strong>add</strong>(n1, n2) {<br/>  <strong>return 0;</strong><br/>}</pre>
<p>First, we import the <kbd>assert</kbd> module to use its <kbd>equal</kbd> function. The <kbd>equal</kbd> function expects three parameters:</p>
<ul>
<li>The current value or expression to be analyzed</li>
<li>The expected value</li>
<li>The message that should be thrown in case the current and expected value are not equal</li>
</ul>
<p>If the assertion <em>fails</em>, the program will be <em>finished</em> and you will see the reason why the assertion fails in your Terminal.</p>
<p>Once we import our <kbd>assert</kbd> module, we proceed to create our <kbd>add</kbd> function. However, this function does not perform any operation; this is because our intention is to first write the test and make it fail, and after that we will implement the logic itself in the next point. In the same <kbd>testing.js</kbd> file, append to the following code with the testing case right below the <kbd>add</kbd> function:</p>
<pre>let <strong>result</strong> = <strong>add(5, 5)</strong>;<br/>assert.equal( <strong>result,</strong> <strong>10</strong>, "Should be 10");<br/><br/>console.log("Test passed!!");</pre>
<p>Now we have our test case, which will compare the current value—<kbd>add(5, 5)</kbd>—housed into the result variable against the expected value—<kbd>10</kbd>, and if they are not equal, the <kbd>Should be 10</kbd> error message will be displayed and as the program is complete, the next expression—<kbd>console.log</kbd>—won't be executed.</p>
<p>It's time to execute our test. Using your Terminal, get into your folder where you have created the <kbd>testing.js</kbd> file and execute the following command:</p>
<pre><strong>$ node testing.js</strong></pre>
<p>If everything went wrong, you should see the following output:</p>
<pre>assert.js:81<br/>  throw new assert.AssertionError({<br/>  ^<br/><strong>AssertionError: Should be 10</strong><br/>    ...</pre>
<p>Cool! Now it's time to implement the code and pass our test.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the code</h1>
                
            
            
                
<p>Now, let's implement the code in the <kbd>add</kbd> function. We will declare a <kbd>result</kbd> variable into the function to house the addition between the two parameters passed to it. Open the <kbd>testing.js</kbd> file and apply the following changes:</p>
<pre><br/>const assert = require('assert');<br/><br/>function add(n1, n2) {<br/>  <br/>  <strong>const result = n1 + n2;</strong><br/><br/><strong>  return result;</strong><br/><br/>}<br/><br/>var result = add(5, 5);<br/>assert.equal(result, 10, "Should be 10");<br/><br/>console.log("Test passed!!");</pre>
<p>Now that we have implemented the logic for our <kbd>add</kbd> function, the next time we run the test, we expect that the <kbd>assertion.equal</kbd> function won't fail and the <kbd>Test passed!!</kbd> message will be displayed. Let's try it out. Execute the following command:</p>
<pre><strong>$ node testing.js</strong><br/><strong>  Test passed!!</strong></pre>
<p>As you can see, the test passed and now the <kbd>Test passed!!</kbd> message is displayed. By using this strategy to write the test first and then implement it, we can be 100 percent sure that our application is doing what it's supposed to do.</p>
<p>Let's follow the last step to finish our TDD flow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring our code</h1>
                
            
            
                
<p>At this point, everything is okay; we have our test and implementation written, the code is doing what we expect, and it seems that there's nothing left to do. But, as a good developer, we should look for ways to make our code more readable and reduce the lines of code. Also, the refactoring phase is used to change some weird variable names and, if possible, add comments to our code if needed.</p>
<p>Open your <kbd>testing.js</kbd> file and apply the following changes to make it more readable:</p>
<pre>var assert = require('assert');<br/><br/>function add(n1, n2) {<br/>  <strong>return n1 + n2</strong>;<br/>}<br/><br/>assert.equal(<strong>add(5, 5)</strong>, 10, "Should be 10");<br/><br/>console.log("Test passed!!");</pre>
<p>The first change is in the <kbd>add</kbd> function. As this is a simple addition operation, declaring a <kbd>result</kbd> variable is not necessary, so we return the addition result in the <kbd>return</kbd> function to make it more readable.</p>
<p>Finally, we are passing the results of the call to <kbd>add(5, 5)</kbd> into the <kbd>assert.equal</kbd> function, so it is easier to know what you are trying to test.</p>
<p>As you might see, TDD is easy to implement but a little bit hard to adopt; we (the authors :D) encourage you to adopt and use it at work. This will make your life easier and will help you become a better programmer who knows how to deliver quality software.</p>
<p>Now it's time to see what Aurelia has to offer. Keep reading!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Aurelia testing frameworks</h1>
                
            
            
                
<p>Aurelia is powered by other open source testing technologies which together help us set up a very productive development environment. Understanding the fundamentals of these technologies will give us a clear idea of how things work and will give you the knowledge to tackle any problem that may appear in the future.</p>
<p>Before we write our first Aurelia tests, let's learn about JasmineJS and KarmaJS, the most awesome frameworks that the JavaScript ecosystem could provide us for testing, and let's use the example implemented in the TDD section to understand how to write testing scripts using the Jasmine syntax and assertions helper functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning JasmineJS</h1>
                
            
            
                
<p>As is detailed in its website, Jasmine is a behavior-driven development framework for testing JavaScript code: it does not depend on any other JavaScript frameworks, it does not require a DOM, and it has a clean, obvious syntax so that you can easily write tests. Jasmine is an easy-to-learn framework, and it comes with its own assertion functions, so we don't need to install any additional assertion library, such as Chai. Let's start installing it and exploring the building blocks—suites and test cases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installation and configuration</h1>
                
            
            
                
<p>We will use the NPM tool to install Jasmine. Open your favorite Terminal and execute the following command:</p>
<pre><strong>$ npm install jasmine --global</strong></pre>
<p>The preceding instruction will install Jasmine as an executable program that you can invoke in any folder in your Terminal. We achieve this using the <kbd>--global</kbd> flag in the <kbd>npm install</kbd> command.</p>
<p>Once Jasmine is installed, we need to create our project example skeleton to practice with Jasmine. For this, we need to do the following:</p>
<ol>
<li>Create a new folder called <kbd>practice-jasmine</kbd></li>
<li>Initialize a new Jasmine project by executing the <kbd>jasmine init</kbd> command</li>
<li>Write our test script</li>
</ol>
<p>So, having the steps clear, open your Terminal and execute the following commands:</p>
<pre><strong>$ mkdir practice-jasmine</strong><br/><strong>$ cd practice-jasmine</strong><br/><strong>$</strong> <strong>jasmine init</strong></pre>
<p>Once the <kbd>jasmine init</kbd> command is executed, it will create the following folder structure for our project:</p>
<pre>└───spec <br/>    └───support<br/>      └───<strong>jasmine.json</strong><br/>        </pre>
<p>You can get the preceding tree list by installing the <kbd>tree</kbd> program and executing it into your <kbd>practice-jasmine</kbd> folder with the <kbd>tree</kbd> command.</p>
<p>As you can see in the root of the project's folder, there is a <kbd>spec</kbd> folder, where we will save all our test scripts. Right in the <kbd>spec</kbd> folder, there is a <kbd>support</kbd> folder where a <kbd>jasmine.json</kbd> file has been created for us. This file contains all the configuration that Jasmine will use to find our test scripts and then execute them. Using the editor of your choice, open the <kbd>jasmine.json</kbd> file:</p>
<pre>{<br/>  "spec_dir": "spec",<br/>  "spec_files": [<br/>   <strong> "**/*[sS]pec.js"</strong><br/>  ],<br/>  "helpers": [<br/>    "helpers/**/*.js"<br/>  ],<br/>  "stopSpecOnExpectationFailure": false,<br/>  "random": true<br/>}</pre>
<p>The important properties to consider in this file are <kbd>spec_dir</kbd>, which points to the folder that hosts our test scripts, and <kbd>spec_files</kbd>, which declares a regular expression that tells Jasmine that the files containing <kbd>spec.js</kbd> or <kbd>Spec.js</kbd> at the end of their names have to be considered as test scripts and have to be processed.</p>
<p>To validate that everything is configured correctly, execute the following command in the root <kbd>practice-jasmine</kbd> directory:</p>
<pre><strong>$ jasmine<br/></strong><br/><strong>Started</strong><br/><br/><br/><strong>No specs found</strong><br/><strong>Finished in 0.002 seconds</strong></pre>
<p>You should see the message <kbd>No specs found</kbd> displayed which means that as we didn't write any test yet, Jasmine was not able to process any test case. Also, you can see how much time Jasmine takes to execute your tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test suites</h1>
                
            
            
                
<p>Following the best practices, you have to separate your tests that are similar to be grouped in suites. For example, in our application, we will write code to manage football matches and information about teams. Both matches and teams are different domains and for that reason, we should group the tests related to the matches in a suite and repeat the same for teams.</p>
<p>Following the example where we created an <kbd>add</kbd> function, we might be implementing this function for a Calculator application, so let's use this as an example to understand Jasmine. In the <kbd>specs</kbd> folder, create the <kbd>calculator.spec.js</kbd> file and write the following code:</p>
<pre>describe("Calculator", function() {<br/><br/>   ...<br/><br/>});</pre>
<p>We have created our test suite; for that, we are using the <kbd>describe</kbd> function and we pass the name of our suite as the first parameter, in this case <kbd>Calculator</kbd>, and as the second parameter, we pass a function that will contain the code for our test cases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test cases</h1>
                
            
            
                
<p>To write the test for our applications, we need test cases that should basically consider all the possible scenarios that your app can afford. For our Calculator example, we will create test cases for the four main arithmetic operations—addition, multiplication, subtraction, and division. Test cases are created using the <kbd>it</kbd> function, as follows:</p>
<pre>describe("Calculator", function() {<br/><br/>   <strong>it("should return the addition ", function() {</strong><br/><strong>       ...</strong><br/><strong>   });</strong><br/><br/>   <strong>it("should return the substraction ", function() {</strong><br/><strong>       ...</strong><br/><strong>   });</strong><br/><br/>   <strong>it("should return the multiplication ", function() {</strong><br/><strong>       ...</strong><br/><strong>   })</strong><br/><br/>   <strong>it("should return the division ", function() {</strong><br/><strong>       ...</strong><br/><strong>   })</strong><br/><br/>});</pre>
<p>Before we continue on our trip, we should have something to test. So let's create a <kbd>Calculator</kbd> object to test out. In the same <kbd>calculator.spec.js</kbd> file, add the following code at the very beginning, before the suite declaration, as follows:</p>
<pre><strong>var Calculator = {</strong><br/><strong>  add: function(n1, n2) {</strong><br/><strong>    return n1 + n2;</strong><br/><strong>  },</strong><br/><strong>  substract: function(n1, n2) {</strong><br/><strong>    return n1 - n2;</strong><br/><strong>  },</strong><br/><strong>  multiply: function(n1, n2) {</strong><br/><strong>    return n1 * n2;</strong><br/><strong>  },</strong><br/><strong>  divide: function(n1, n2) {</strong><br/><strong>     return n1 / n2;</strong><br/><strong>  }</strong><br/><strong>}</strong><br/><br/><br/>describe("Calculator", function() {<br/>...</pre>
<p>Now that we have something to test, let's learn about how we can write assertions in our test file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Expects</h1>
                
            
            
                
<p>We test the functionality of our code by writing expects that are no more than simple assumptions that we have for our code if everything was implemented correctly. In the file we are working on, apply the following changes:</p>
<pre>...<br/><br/>describe("Calculator", function() {<br/><br/>   it("should return the addition ", function() {<br/>       <strong>expect(Calculator.add(1, 2)).toEqual(3);</strong><br/>   });<br/><br/>   it("should return the substraction ", function() {<br/>       <strong>expect(Calculator.substract(1, 2)).toEqual(-1);</strong><br/>   });<br/><br/>   it("should return the multiplication ", function() {<br/>       <strong>expect(Calculator.multiply(1, 2)).toEqual(2);</strong><br/>   })<br/><br/>    it("should return the division ", function() {<br/>      <strong> expect(Calculator.divide(1, 2)).toEqual(0.5);</strong><br/>   })<br/><br/>});</pre>
<p>We have created the expectations that we have for our code. For example, for the additional test case, we expect that the result of <kbd>add(1, 2)</kbd> returns <kbd>3</kbd>. We specify the match operation using helper functions, such as the <kbd>toEqual</kbd> function, that as its name says, won't raise any exception in case the result of calling the add function is the same as the expected value.</p>
<p>Now that we have our test script fully implemented, let's execute it and see what we get in the console. Run the following command:</p>
<pre><strong>$</strong> <strong>jasmine<br/></strong><br/><strong>Started</strong><br/><strong>....</strong><br/><br/><br/><strong>4 specs, 0 failures</strong><br/><strong>Finished in 0.006 seconds</strong></pre>
<p>Now the output displayed is that <kbd>4 specs</kbd> were found and executed without failures. It is time to see what will happen if we force a test case to fail. Replace the expect statement in the addition test case for the following expects:</p>
<pre>...<br/><br/>it("should return the addition ", function() {<br/>       <strong>expect(Calculator.add(1, 2)).toEqual(30);</strong><br/>});<br/><br/>...</pre>
<p>Once the changes are applied, run the following command to make our test fail:</p>
<pre><strong>$ jasmine</strong> <br/><br/><strong>Started </strong><br/><strong>F... </strong><br/>                                                                                 <br/><strong>Failures: </strong><br/><strong>1) Calculator should return the addition </strong><br/><strong>  Message: </strong><br/><strong>    Expected 3 to equal 30. </strong><br/><strong>  Stack: </strong><br/><strong>    Error: Expected 3 to equal 30. </strong><br/><strong>        ...</strong><br/>                                                                                 <br/><strong>4 specs, 1 failure </strong><br/><strong>Finished in 0.011 seconds </strong></pre>
<p>Let's analyze the output. The first thing to note is the following <kbd>F...</kbd> string, this means that the first test has failed and the other 3 (dots) are correct. You can also read the <kbd>Expected 3 to equal 30</kbd> message giving the reason why our test fails, and finally the test resume that shows that <kbd>4 specs</kbd> where found but just <kbd>1 failure</kbd> occurred.</p>
<p>The output for this test displays the failing test at the beginning of the <kbd>F...</kbd> string. This might be at the beginning or in another order. That is because the random property in the <kbd>jasmine.json</kbd> file is configured to be true, which means random executions. If you want to execute your tests sequentially, change the random property to false.</p>
<p>You have seen how easy it is to use the Jasmine framework to test our code. Of course, you have to learn more about it; we would really like to teach you everything about Jasmine, but that is beyond the scope of this book. We recommend you visit the official site at <a href="https://jasmine.github.io/">https://jasmine.github.io/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning KarmaJS</h1>
                
            
            
                
<p>We have explored Jasmine, which basically is a testing framework powered with a cool syntax and functions that help us write the test scripts for our application; in order to execute our test, we had to execute them manually and wait until this finished to see how many tests passed and how many failed.</p>
<p>Karma is a test runner. A test runner is a tool that is configured to look for the test scripts of our application, execute the tests automatically, and export the result of our testing. As we are creating web components with Aurelia, we will need to test our application in different browsers with different characteristics, and as web browsers are different in many ways, we need a way to test our web application in all possible browsers to ensure that our users won't face any problem with our app.</p>
<p>Karma is able to use any testing framework to implement tests. As we have learned Jasmine, we will be using it to write our test scripts, and we will be using Karma to pick up the test files, execute them, and export the results. The following illustrates the flow:</p>
<div><img src="img/3bcb21ff-e054-48b5-baa5-d1ff436bb484.png" style="width:34.17em;height:10.08em;"/></div>
<p>We will see the power of KarmaJS later in this chapter; just keep in mind that Aurelia uses Karma as its test runner for all the projects that you create using the Aurelia CLI, as discussed in <a href="" target="_blank">Chapter 1</a>, <em>Introducing Aurelia.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing karma</h1>
                
            
            
                
<p>We will use the NPM to install Karma and other dependencies. Let's start creating a practice folder called <kbd>practice-karma</kbd> and initializing our project. Run the following command:</p>
<pre><strong>$ mkdir practice-karma</strong><br/><strong>$ cd practice-karma</strong><br/><strong>$ npm init</strong></pre>
<p>We use <kbd>npm init</kbd> to create a new module; this will prompt you a bunch of questions and will create a <kbd>package.json</kbd> file similar to this:</p>
<pre>{<br/>  "name": "practice-karma",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC"<br/>}</pre>
<p>Up to now, you should have the following folder structure:</p>
<pre>practice-karma/<br/>└── package.json</pre>
<p>Now it's time to install Karma and the dependencies that we require to use Karma and Jasmine. In the <kbd>practice-karma</kbd> folder, run the following command:</p>
<pre><strong>$ npm install karma karma-jasmine jasmine-core karma-chrome-launcher --save-dev</strong></pre>
<p>The preceding command will install the dependencies required to use Karma and Jasmine, and also will add the dependencies to our <kbd>package.json</kbd> file into the <kbd>devDependencies</kbd> attribute. Open your <kbd>package.json</kbd> file, and you should see something similar to this:</p>
<pre>{<br/>  "name": "practice-karma",<br/>  "version": "1.0.0",<br/>  ...<br/>  <strong>"devDependencies": {</strong><br/><strong>    "jasmine-core": "^2.8.0",</strong><br/><strong>    "karma": "^1.7.1",</strong><br/><strong>    "karma-chrome-launcher": "^2.2.0",</strong><br/><strong>    "karma-jasmine": "^1.1.1"</strong><br/><strong>  }</strong><br/>}</pre>
<p>As we have to use the <kbd>--save-dev</kbd> flag, the dependencies are listed in the <kbd>devDependencies</kbd> attribute; if you use <kbd>--save</kbd> instead, it will list the dependencies in the <kbd>dependencies</kbd> attribute.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring Karma</h1>
                
            
            
                
<p>Now that Karma is installed, we need to configure the following:</p>
<ul>
<li>Jasmine as testing tool</li>
<li>Folders with the app code</li>
<li>Web browser launcher</li>
<li>Reporters</li>
</ul>
<p>Setting up all the preceding parameters might result in a very time-consuming task, so we will use the Karma executable to configure everything automatically. In the <kbd>practice-karma</kbd> folder, run the following command:</p>
<pre><strong>$ karma init</strong></pre>
<p>This will prompt you a bunch of questions; just press enter to accept all the default configuration, and once everything is done, a <kbd>karma.conf.js</kbd> file will be created:</p>
<pre>module.exports = function(config) {<br/>  config.set({<br/>    basePath: '',<br/>    <strong>frameworks: ['jasmine'],</strong><br/>    <strong>files: [</strong><br/><strong>    ],</strong><br/>    exclude: [<br/>    ],<br/>    preprocessors: {<br/>    },<br/>    <strong>reporters: ['progress'],</strong><br/>    port: 9876,<br/>    colors: true,<br/>    logLevel: config.LOG_INFO,<br/>    autoWatch: true,<br/>    <strong>browsers: ['Chrome'],</strong><br/>    singleRun: false,<br/>    concurrency: Infinity<br/>  })<br/>}</pre>
<p>We need to specify a pattern for the files to be utilized in the testing process. To do this, apply the following changes to the <kbd>files: []</kbd> property:</p>
<pre>...<br/>files: [<br/>   <strong>'specs/*.spec.js'</strong><br/>],<br/>...</pre>
<p>Now we have specified that every file that ends with <kbd>.spec.js</kbd> in its name will be processed by karma. Let's create the <kbd>specs</kbd> folder and inside, create the <kbd>calculator.spec.js</kbd> file:</p>
<pre><strong>$ mkdir specs</strong><br/><strong>$ touch calculator.spec.js</strong></pre>
<p>You should have a project structure similar to the following:</p>
<pre>.<br/>└── node_modules<br/>├── package.json<br/>├── karma.spec.js<br/>└── specs<br/>    └── calculator.spec.js</pre>
<p>Now it's time to test things out by creating a testing example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing example</h1>
                
            
            
                
<p>For the Calculator app example, let's create the <em>src</em> folder in the root project's folder and create the <kbd>calculator.js</kbd> file inside:</p>
<pre><strong>$ mkdir src</strong><br/><strong>$ touch src/calculator.js</strong></pre>
<p>As you can see, we are not saving our <kbd>calculator.js</kbd> file inside the <kbd>specs/</kbd> folder, so we need to configure karma to load the files present in the <kbd>src/</kbd> folder. Apply the following changes in the <kbd>karma.conf.js</kbd> file:</p>
<pre>...<br/>files: [<br/>      'specs/*.spec.js',<br/>      <strong>'src/*.js'</strong><br/>],<br/>...</pre>
<p>Now, Karma will load all the files from the <kbd>specs</kbd> and <kbd>src</kbd> folder when testing is running.</p>
<p>Let's implement the code of our <kbd>calculator.js</kbd> file. Using your editor of choice, open the <kbd>src/calculator.js</kbd> file and apply the following code:</p>
<pre>window.Calculator = {<br/><br/>  add: function(n1, n2) {<br/>    return n1 + n2;<br/>  },<br/><br/>  multiply: function(n1, n2) {<br/>    return n1 * n2;<br/>  }<br/><br/>}</pre>
<p>If you want to make a variable accessible globally, simply create it as a property of the window object. In this case, we made the <kbd>Calculator</kbd> object <strong>global</strong>.</p>
<p>Now, let's write our test case. Open the <kbd>specs/calculator.spec.js</kbd> file and apply the following code:</p>
<pre>describe("Calculator Tests", function() {<br/><br/>  it("should return 10", function() {<br/><br/>    <strong>expect(window.Calculator.add(5, 5)).toBe(10);</strong><br/>  <br/>  });<br/><br/>});</pre>
<p>The preceding code should be familiar to you if you note that we are using the Jasmine testing framework to write our tests. Now that we have everything set up and our code implemented, let's continue by launching the tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Launching the test runner</h1>
                
            
            
                
<p>Now that we have our test code and a Calculator object, it's time to launch Karma to execute our test. Open the command line and in the <kbd>practice-karma</kbd> root folder, execute the following command:</p>
<pre><strong>./node_modules/karma/.bin/karma start karma.conf.js</strong></pre>
<p>The preceding command will output a bunch of logs, while it opens a new window in your Chrome web browser and executes your test into the web page recently started. This page is opened in Chrome because it is configured in the <kbd>karma.conf.js</kbd>. Consider this example:</p>
<pre><strong>$ ./node_modules/karma/bin/karma start karma.conf.js</strong><br/><br/><strong>10 12 2017 12:12:43.049:WARN [karma]: No captured browser, open http://localhost:9876/</strong><br/><strong>10 12 2017 12:12:43.059:INFO [karma]: Karma v1.7.1 server started at http://0.0.0.0:9876/</strong><br/><strong>10 12 2017 12:12:43.060:INFO [launcher]: Launching browser Chrome with unlimited concurrency</strong><br/><strong>10 12 2017 12:12:43.086:INFO [launcher]: Starting browser Chrome</strong><br/><strong>10 12 2017 12:12:44.628:INFO [Chrome 62.0.3202 (Mac OS X 10.12.6)]: Connected on socket 8n0My3AYk-xKfu9sAAAA with id 38155723</strong><br/><strong>Chrome 62.0.3202 (Mac OS X 10.12.6): Executed 1 of 1 SUCCESS (0 secs / 0.002 secChrome 62.0.3202 (Mac OS X 10.12.6): Executed 1 of 1 SUCCESS (0.007 secs / 0.002 secs)</strong></pre>
<p>Note in the last lines that our test was executed with a successful result. The web page launched looks similar to this:</p>
<div><img src="img/5f11a98a-d0c2-4882-b77e-181eae459390.png" style="width:33.75em;height:17.67em;"/></div>
<p>As you might have noted, running the previous command might be too long to remember; to make our life easy, let's configure our <kbd>package.json</kbd> file to configure the <kbd>test</kbd> script to execute this command for us. Open the <kbd>package.json</kbd> files and apply the following changes:</p>
<pre>{<br/>  "name": "practice-karma",<br/>  ...<br/>  "scripts": {<br/>    <strong>"test": "./node_modules/karma/bin/karma start karma.conf.js"</strong><br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  "devDependencies": {<br/>   ...<br/>  }<br/>}</pre>
<p>Once configured, execute the following command to run the tests:</p>
<pre><strong>$ npm test</strong></pre>
<p>That's it. Using Karma and Jasmine will give us all the enablers we need to write robust tests for our applications. Both technologies are not limited to web development. You can use them in any Javascript project such as a backend written in Node.js. So now, it's time to see an example with a real Aurelia component. Keep reading!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing an Aurelia component</h1>
                
            
            
                
<p>In order to see a real testing example, we will create a simple application. This app will merely greet a user and display the topic currently learning. These two pieces of data, the username and topic, will be persisted as bindable entities and we will call this component <kbd>info-box</kbd>. We will develop an application similar to the following mock-up:</p>
<div><img src="img/9d76e6c9-ce5f-4a8e-9f7e-d51e7e75141f.png" style="width:31.67em;height:17.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Coding the application</h1>
                
            
            
                
<p>We will use the Aurelia CLI to generate our Aurelia application. Aurelia configures the project to work with the Karma test runner and the Jasmine testing framework and uses Chrome as the default web browser.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the application</h1>
                
            
            
                
<p>To create our application, open your Terminal and in the working directory you prefer, run the following command and accept the defaults:</p>
<pre><strong>$ au new aurelia-testapp</strong></pre>
<p>The preceding command will create a new directory called <kbd>aurelia-testapp</kbd>; let's get into this folder and launch the application by running the following command:</p>
<pre><strong>$ cd aurelia-testapp</strong><br/><strong>$ au run --watch</strong><br/><br/><strong>...</strong><br/><strong>Finished 'writeBundles'</strong><br/><strong>Application Available At: http://localhost:9000</strong><br/><strong>BrowserSync Available At: http://localhost:3001<br/></strong></pre>
<p>The preceding command will output a bunch of logs while the development server is starting and Aurelia is getting started. Head over to <kbd>http://localhost:9000</kbd>; and you should see something similar to the following:</p>
<div><img src="img/1c624d46-6a5f-40c0-a41c-6547476a532a.png" style="width:31.42em;height:19.08em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating our component</h1>
                
            
            
                
<p>To create our <kbd>info-box</kbd> component, we will use the Aurelia CLI. Stop the running application and execute the following command. This will ask you for the destination folder; press <em>Enter</em> to use <kbd>src</kbd> as default:</p>
<pre><strong>$</strong> <strong>au generate component info-box</strong><br/><br/><br/><strong>What sub-folder would you like to add it to?</strong><br/><strong>If it doesn't exist it will be created for you.</strong><br/><br/><strong>Default folder is the source folder (src).</strong><br/><br/><strong>[.]&gt;</strong><br/><strong>Created info-box in the 'src' folder</strong></pre>
<p>This command will create two files that together define the <kbd>info-box</kbd> component; these files are as listed:</p>
<ul>
<li><kbd>info-box.js</kbd>: Contains the component's view model</li>
<li><kbd>info-box.html</kbd>: Contains the HTML view template</li>
</ul>
<p>Let's implement our <kbd>info-box</kbd> component.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the info-box view model</h1>
                
            
            
                
<p>Open the <kbd>info-box.js</kbd> file and apply the following changes to declare the <kbd>username</kbd> and <kbd>topic</kbd> attributes:</p>
<pre>export class InfoBox { <br/>  constructor() {<br/>    <strong>this.username = 'Reader';</strong><br/><strong>    this.topic = 'Testing and Debugging';</strong><br/>  }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the info-box view HTML template</h1>
                
            
            
                
<p>Open the <kbd>info-box.js</kbd> file and apply the following changes to bind our attributes to the HTML template:</p>
<pre>&lt;template&gt;<br/>  &lt;h1&gt;Hello, <strong>${username}</strong>!&lt;/h1&gt;<br/>  &lt;p&gt;You are learning: &lt;b&gt;<strong>${topic}</strong> &lt;/b&gt;&lt;/p&gt;<br/>&lt;/template&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Rendering the info-box component</h1>
                
            
            
                
<p>To load and render our component, we need to import the component into the app component. Open the <kbd>app.html</kbd> file and apply the following changes:</p>
<pre>&lt;template&gt;<br/>  <strong>&lt;require from="info-box"&gt;&lt;/require&gt;<br/></strong><br/>  <strong>&lt;info-box&gt;&lt;/info-box&gt;</strong><br/>&lt;/template&gt;</pre>
<p>First, we import the <kbd>info-box</kbd> component and then use it using the <kbd>&lt;info-box&gt;</kbd> tag syntax. With changes done, launch the application again by running the <kbd>au run --watch</kbd> command:</p>
<div><img src="img/8a10e764-5b92-4b56-a943-30f0ab9dc317.png" style="width:26.83em;height:12.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the test</h1>
                
            
            
                
<p>Before we start writing our test, let's clean up the <kbd>test</kbd> folder by removing the <kbd>app.spec.js</kbd> file in the <kbd>unit</kbd> folder. Once completed, you should have something similar to folder tree:</p>
<pre>.<br/>├── aurelia-karma.js<br/>└── unit<br/>    └── setup.js</pre>
<p>In the <kbd>unit</kbd> folder, create the <kbd>info-box.spec.js</kbd> file and add the following code:</p>
<pre> import {StageComponent} from 'aurelia-testing';<br/> import {bootstrap} from 'aurelia-bootstrapper';<br/><br/> describe('Info-Box', () =&gt; {<br/><br/>   it('should render the username and topic', () =&gt; {<br/><br/>   });<br/> });</pre>
<p>First, we import two objects from the Aurelia framework that we will use to initialize our <kbd>info-box</kbd> component. Then, we declare our <kbd>Info-Box</kbd> test suite and we declare one test case.</p>
<p>Note that we are using a special syntax; instead of using <kbd>function() {}</kbd>, we are using <kbd>() =&gt; {}</kbd> ECMAScript syntax. To unit test our component, we will need to perform the following steps:</p>
<ol>
<li>Bootstrap the component</li>
<li>Test the component</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Bootstrapping the component</h1>
                
            
            
                
<p>We will need to create the component so that Jasmine will use it to apply the test. Apply the following changes in the <kbd>info-box.spec.js</kbd> file:</p>
<pre> import {StageComponent} from 'aurelia-testing';<br/> import {bootstrap} from 'aurelia-bootstrapper';<br/><br/> describe('Info-Box', () =&gt; {<br/><br/>   it('should render the username and topic', done =&gt; {<br/><br/>   <strong>  let component = StageComponent</strong><br/><strong>               .withResources('info-box')</strong><br/><strong>               .inView('&lt;info-box&gt;&lt;/info-box&gt;');</strong><br/><br/>     <strong>component</strong><br/><strong>     .create(bootstrap);</strong><br/>    <br/>   });<br/><br/> });</pre>
<p>Before we bootstrap the component, it has to be created. We use the <kbd>StageComponent</kbd> object to instantiate an Aurelia component; we specify the component by passing its name as a param of the <kbd>withResources</kbd> function. Lastly, we specify a view using the <kbd>&lt;info-box&gt;</kbd> element in the <kbd>inView</kbd> function.</p>
<p>Once we have the component skeleton defined, we call its <kbd>create</kbd> function and pass the <kbd>bootstrap</kbd> object. The <kbd>bootstrap</kbd> object contains the default configuration specified in the <kbd>main.js</kbd> file, as discussed in <a href="" target="_blank">Chapter 1</a><em>, Introducing Aurelia.<br/></em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the component</h1>
                
            
            
                
<p>Now that we have our component created, we need to test it. To do this, we rely on the done callback passed to the test function to notify Jasmine that the test is done. If we don't specify the done parameter, our test won't be executed because we execute our assertions in a promise and if we don't call it, we will get a timeout error since Jasmine won't be able to know when our test completed. Let's apply the following changes to the <kbd>info-box.spec.js</kbd> file:</p>
<pre> import {StageComponent} from 'aurelia-testing';<br/> import {bootstrap} from 'aurelia-bootstrapper';<br/><br/> describe('Info-Box', () =&gt; {<br/><br/>   it('should render the username and topic', <strong>done</strong> =&gt; {<br/>     let component = StageComponent<br/>               .withResources('info-box') <br/>               .inView('&lt;info-box&gt;&lt;/info-box&gt;');<br/><br/>     component<br/>     .create(bootstrap)<br/>     <strong>.then(() =&gt; {</strong><br/><br/><strong>       const h1 = component.element.querySelector('h1').innerHTML;</strong><br/><strong>       const pa = component.element.querySelector('p').innerHTML;</strong><br/><br/><strong>       expect(h1).toBe('Hello, Reader!');</strong><br/><strong>       expect(pa).toBe('You are learning: &lt;b&gt;Testing and Debugging &lt;/b&gt;');<br/></strong><br/><strong>       done();</strong><br/><br/><br/><strong>     })</strong><br/><strong>     .catch(e =&gt; console.log(e.toString()));</strong><br/>   });<br/> });</pre>
<p>You should be aware that if you are using Webpack, you might need to import <kbd>PLATFORM</kbd> from the <kbd>aurelia-pal</kbd> module in order to load the <kbd>info-box</kbd> resource as follows—<kbd>.withResourceS(PLATFORM.moduleName('info-box'))</kbd>. For additional Webpack considerations, visit the official site at <a href="https://aurelia.io/docs/build-systems/webpack">https://aurelia.io/docs/build-systems/webpack</a>.</p>
<p>In the <kbd>then</kbd> function, we pass our callback that will use the <kbd>component.element.querySelector</kbd> function to access the HTML elements into the <kbd>info-box</kbd> component, and we use the <kbd>innerHTML</kbd> property of the elements to access the element's values.</p>
<p>Next, we compare the values of the elements by the expected values and when all the <kbd>expect</kbd> statements are executed, we call the <kbd>done()</kbd> function to tell Jasmine we have finished this test case.</p>
<p>Lastly, a <kbd>catch</kbd> callback is passed to print any error detected in the test process. Once everything is complete, run the following command in your Terminal:</p>
<pre><strong>$ au karma</strong></pre>
<p>If everything went right, the Chrome web browser should be opened and you should see the following output in your Terminal window:</p>
<pre><strong>...</strong><br/><strong>Starting 'karma'...</strong><br/><strong>...</strong><br/><strong>Chrome 62.0.3202 (Mac OS X 10.12.6): Executed 1 of 1 SUCCESS (0 secs / 0.105 secChrome 62.0.3202 (Mac OS X 10.12.6): Executed 1 of 1 SUCCESS (0.109 secs / 0.105 secs)</strong><br/><strong>Finished 'karma</strong>'</pre>
<p>That's it! Now you know how to test Aurelia components. A little challenge for you is to apply everything learned in a TDD cycle. Have fun!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debugging our code</h1>
                
            
            
                
<p>Debugging tools are extremely important for a developer. It does not matter which programming language or framework you are using, or if you are working on either frontend or backend project. Debugging will always be present in your development process.</p>
<p>Nowadays, the web browser does more than just server pages, caching content, saving favorites, and so on. They are complete web development tools that provide awesome tools to debug our code and application performance.</p>
<p>Let's see how we can debug our code using our favorite web browser. We will use Chrome Developer Tools as an example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring our application</h1>
                
            
            
                
<p>First, we need to start our application and open it in a web browser. Let's use our <kbd>aurelia-testapp</kbd><em>:</em></p>
<pre><strong>$ cd aurelia-testapp</strong><br/><strong>$ au run --watch</strong></pre>
<p>With the application up and running, head over to <kbd>http://localhost:9000</kbd> to see the application. We will add a button and when the button is pressed, we will debug some dummy code. Open the <kbd>info-box.html</kbd> file and apply the following change:</p>
<pre>&lt;template&gt;<br/>  <br/>  <strong>&lt;button click.trigger="debugme()"&gt; Debug Me!&lt;/button&gt;</strong><br/><br/>&lt;/template&gt;</pre>
<p>Open the <kbd>info-box.js</kbd> file and apply the following changes:</p>
<pre>export class InfoBox { <br/>  <br/> <strong> debugme() {</strong><br/>    <br/><strong>    alert("YOU PRESSED THE DEBUGME BUTTON")</strong><br/><br/><strong>  }</strong><br/><br/>}</pre>
<p>Go back to your browser application, click on the Debug Me! button, and you should see the following on the screen:</p>
<div><img src="img/d5b52c1a-fb65-40fc-bc2b-35efb26d58cc.png" style="width:26.83em;height:14.08em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Debugging with Chrome Developer Tools</h1>
                
            
            
                
<p>We need to open the Chrome Developer Tools. To do this, go to the View | Developer | Developer tools option in the menu or press <em>F12</em>. You should see something like the following:</p>
<div><img src="img/67c2e18e-3cbd-47ca-b209-95e9c395d23e.png" style="width:43.83em;height:28.25em;"/></div>
<p>With this window open, let's apply a little change to our <kbd>info-box</kbd> file to tell the browser that we want to stop and debug our code:</p>
<pre>export class InfoBox { <br/>  <br/>  debugme() {<br/><br/>    <strong>debugger;</strong><br/><br/>    alert("YOU PRESSED THE DEBUGME BUTTON")<br/><br/>  }<br/><br/>}</pre>
<p>Go back to your application and click on the Debug Me! button. The <kbd>debugger;</kbd> instruction will stop the browser execution and enter into the browser debugging mode:</p>
<div><img src="img/59055109-a3b2-41c2-8af5-51fe53f119e6.png" style="width:44.83em;height:29.08em;"/></div>
<p>You can use the Developer Tools options to navigate your code, analyze variables values, add breakpoints, and so on. I personally prefer to debug my code in this way. You can try debugging code using the Node.js command line or another type of debugging. Debugging tools will vary depending on the web browser you are working on.</p>
<p>Now that we are in good shape and we know how to style and test Aurelia applications, it's time to learn how to create awesome Aurelia components. Keep reading!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we explored the benefits that good testing brings to our company, team, products, and users. Good testing will always make our products better and our users happy.</p>
<p>We learned how to apply TDD to our software development process and the importance and impact it has on the quality of our apps. You should always remember that TDD is composed of three colored phases: the red phase, which makes your test fail; the blue phase, which makes your test pass; and lastly, the green phase, which refactors and cleans your code.</p>
<p>We also learned about the testing technologies that Aurelia uses for development and learned how to use them independently. Jasmine is the testing framework and Karma is used as the test runner.</p>
<p>We practiced with a real testing example of an Aurelia component and we explored some debugging options.</p>
<p>Now that we are in good shape and know how to style and test Aurelia applications, it's time to become real experts in creating Aurelia components. So, keep reading!</p>


            

            
        
    </body></html>