<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Basic Performance Tuning" id="aid-2JTHG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Basic Performance Tuning</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Scalable infrastructure</li><li class="listitem">Setting up database access for the master/slave configuration</li><li class="listitem">Enabling JS and CSS minification</li><li class="listitem">Turning on the CDN host</li><li class="listitem">Disabling unused Liferay features</li><li class="listitem">JVM tuning</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec82"/>Introduction</h1></div></div></div><p>One of the most important aspects of successful project realization is system performance. Everybody knows that Web users often face a long wait when downloading web pages. What is the tolerable waiting time for web page download? In our opinion, a comfortable response time should be less than 2 seconds. If users have to wait more than 4 seconds, they usually go away. Performance issues is the most difficult subject in a big data portal or intranet. System architecture affects performance. Portals with a lot of images, movies, and audio should have a different architecture compared to intranets, as these portals have a lot of users who log in very often at the same time.</p><p>Fortunately, there are some general rules that help improve Liferay's performance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Scalable infrastructure with HTTP cache proxy</li><li class="listitem">Fast database</li><li class="listitem">Appropriate Java settings, such as garbage collector engine or memory settings</li><li class="listitem">Minimal number of included files, such as JS, CSS, images, and so on</li><li class="listitem"><span class="strong"><strong>Content distribution </strong></span><a id="id692" class="indexterm"/><span class="strong"><strong>network</strong></span> (<span class="strong"><strong>CDN</strong></span>) for static resources</li><li class="listitem">Liferay Portal tuning, for instance, disabling unused filters, changing properties, and so on</li></ul></div></div></div>
<div class="section" title="Scalable infrastructure"><div class="titlepage" id="aid-2KS222"><div><div><h1 class="title"><a id="ch12lvl1sec83"/>Scalable infrastructure</h1></div></div></div><p>Defining the architecture is the most important part of a successful installation. A good architecture should be fault-tolerant and have a high level of availability. To achieve this, it is necessary to cluster all the possible nodes, such as Tomcat nodes, search nodes, and so on. The second<a id="id693" class="indexterm"/> important thing is building a scalable infrastructure that lets us add new nodes.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec221"/>How to do it…</h2></div></div></div><p>In this recipe, we will try defining reference infrastructure, which can be used on production deployments. This type of infrastructure is used in our projects and works perfectly. The main parts of our environments are: squid cache, Apache servers with <code class="literal">mod_jk</code> module and software load balancers, Apache Tomcat Application Servers, Solr Cloud and Database server. The following image shows the most important parts:</p><div class="mediaobject"><img src="../Images/image00378.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Squid cache"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec78"/>Squid cache</h3></div></div></div><p>The <a id="id694" class="indexterm"/>first<a id="id695" class="indexterm"/> tier of our architecture is Squid cache (<a class="ulink" href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>). It is a caching proxy for the Web. It<a id="id696" class="indexterm"/> supports HTTP, HTTPS, and other protocols. It reduces the number of requests, which go to another tier, especially to the Liferay instance. Squid cache reads HTTP headers and decides whether a specific request can be cached and how long<a id="id697" class="indexterm"/> they can be cached. This option can be used for content<a id="id698" class="indexterm"/> that doesn't change frequently, such as images, CSS, JS, and so on. This kind of solution gives a noticeable boost to our application.</p></div><div class="section" title="Apache web server and software load balancer"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec79"/>Apache web server and software load balancer</h3></div></div></div><p>The next <a id="id699" class="indexterm"/>tier has Apache web server instances<a id="id700" class="indexterm"/> with a load balancer software. Each <a id="id701" class="indexterm"/>instance of the Apache server is connected with<a id="id702" class="indexterm"/> all Liferay nodes. This connection is established<a id="id703" class="indexterm"/> by the <code class="literal">mod_jk Tomcat-Apache</code> plugin (<a class="ulink" href="https://tomcat.apache.org/tomcat-3.3-doc/mod_jk-howto.html">https://tomcat.apache.org/tomcat-3.3-doc/mod_jk-howto.html</a>). This <a id="id704" class="indexterm"/>plugin handles the communication between Tomcat and Apache using the AJP protocol. Every Apache server instance has a load balancer configuration. The most common load balancer configuration uses the <code class="literal">mod_jk</code> plugin. The configuration is placed in the <code class="literal">workers.properties</code> file in the <code class="literal">$APACHE_HOME/conf</code> directory. The following listing shows an example of the <code class="literal">mod_jk</code> and load balancer configuration:</p><div class="informalexample"><pre class="programlisting">worker.list=node1,node2,loadbalancer
worker.template.port=8009
worker.template.type=ajp13
worker.template.ping_mode=A
worker.template.reply_timeout=60000
worker.template.socket_connect_timeout=10000

worker.node1.reference=worker.template
worker.node1.host=&lt;IP_ADDRESS&gt;

worker.node2.reference=worker.template
worker.node2.host=&lt;IP_ADDRESS&gt;

<span class="strong"><strong>worker.loadbalancer.type=lb</strong></span>
<span class="strong"><strong>worker.loadbalancer.balance_workers=node1, node2</strong></span>
<span class="strong"><strong>worker.loadbalancer.sticky_session=True</strong></span>
<span class="strong"><strong>worker.loadbalancer.retries=1</strong></span>
</pre></div><p>The first line specifies a list of workers. In our example, there are three workers: <code class="literal">node1</code>, <code class="literal">node2</code>, and <code class="literal">loadbalancer</code>. Workers with names <code class="literal">node1</code> and <code class="literal">node2</code> describe connection with Liferay (host, port, and timeout definitions).</p><p>The bold definition describes the load balancer configuration. It contains a list of workers (the <code class="literal">worker.loadbalancer.balance_workers</code> property), and specifies the sticky session policy and the number of retries if a request fails. Load balancer can be configured with the following two modes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Sticky session</strong></span>: This <a id="id705" class="indexterm"/>distributes all the requests for a specific session to a specific Liferay Portal server node.</li><li class="listitem"><span class="strong"><strong>Session replication</strong></span>: This provides a mechanism for session replication. From a <a id="id706" class="indexterm"/>business point of view, this is a great feature because it is failure-independent. If one of the nodes fail, load balancer decides to send the request to a different one. Users don't see any difference.</li></ul></div><p>From the <a id="id707" class="indexterm"/>performance tuning point of view, the<a id="id708" class="indexterm"/> best option is sticky session, because <a id="id709" class="indexterm"/>it eliminates many requests compared to session<a id="id710" class="indexterm"/> replication. In other words, sticky session reduces traffic and saves resources.</p></div><div class="section" title="Apache Tomcat Application Server"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec80"/>Apache Tomcat Application Server</h3></div></div></div><p>This tier is<a id="id711" class="indexterm"/> the heart of the <a id="id712" class="indexterm"/>application, because in this tier, the Tomcat container, with our Liferay Portal instance, is placed. In a clustered environment, it is important to properly configure Liferay Portal, because all the components must have a dedicated configuration, such as sharing documents and media files, configuring the same access to the database, and configuring cache and search index replication.</p><p>If we use the Apache <code class="literal">mod_jk</code> module, it is important to set the <code class="literal">jvmRoute</code> identifier in every Apache Tomcat instance. To do this, place the following configuration in <code class="literal">${TOMCAT_HOME}/conf/server.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="node{X}"&gt;</pre></div><p>To share documents<a id="id713" class="indexterm"/> and media files, we recommend that you use <a id="id714" class="indexterm"/>the glusterFS system (<a class="ulink" href="http://www.gluster.org/">http://www.gluster.org/</a>), which shares documents and files between nodes. There are different ways to configure documents and media working in a clustered environment, which we described in the previous chapter. We will describe other configurations in the upcoming recipes.</p></div><div class="section" title="Database server"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec81"/>Database server</h3></div></div></div><p>The database server tier is responsible for storing data on the database system. In a huge system, the <a id="id715" class="indexterm"/>database is usually one of the major <a id="id716" class="indexterm"/>bottlenecks, and database administrators often have a lot of problems with performance. In our projects, we generally use the MySQL database with master/slave configuration. The master database is responsible for writing, while the slave <a id="id717" class="indexterm"/>database is responsible for reading. Liferay<a id="id718" class="indexterm"/> provides out-of-the-box mechanisms that allow us to configure it. We will describe them in the upcoming recipes.</p></div><div class="section" title="Solr search engine server"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec82"/>Solr search engine server</h3></div></div></div><p>The last tier<a id="id719" class="indexterm"/> is an Apache Solr search<a id="id720" class="indexterm"/> engine server (<a class="ulink" href="http://lucene.apache.org/solr/">http://lucene.apache.org/solr/</a>). Solr is highly reliable, scalable, and fault-tolerant, providing<a id="id721" class="indexterm"/> distributed indexing, replication and load-balanced querying, automated failover and recovery, centralized configuration, and more. These<a id="id722" class="indexterm"/> things are possible to configure if we <a id="id723" class="indexterm"/>install Apache Zookeeper (<a class="ulink" href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a>) and Apache Solr together. Zookeeper is a centralized service that maintains configuration information, naming, and provides distributed synchronization and group services, for instance, Apache Solr. Therefore, Apache Zookeeper can be installed as a cloud solution that can eliminate single point of failure. The Zookeeper server selects a Solr node, which is a master, and gives a token.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec222"/>See also</h2></div></div></div><p>For information on clustering and configuring the environment, refer to the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <span class="emphasis"><em>Integration with the Amazon S3 cloud</em></span> recipe from <a class="link" title="Chapter 6. Documents and Media in Liferay" href="part0050.xhtml#aid-1FLS41">Chapter 6</a>, <span class="emphasis"><em>Documents and Media in Liferay</em></span></li><li class="listitem">The <span class="emphasis"><em>Solr installation and configuration</em></span> recipe from <a class="link" title="Chapter 8. Search and Content Presentation Tools" href="part0059.xhtml#aid-1O8H61">Chapter 8</a>, <span class="emphasis"><em>Search and Content Presentation Tools</em></span></li><li class="listitem">The <span class="emphasis"><em>Clustering Liferay Portal and the Configuring Liferay with the SMTP server</em></span> recipes from <a class="link" title="Chapter 11. Quick Tricks and Advanced Knowledge" href="part0080.xhtml#aid-2C9D01">Chapter 11</a>, <span class="emphasis"><em>Quick Tricks and Advanced Knowledge</em></span></li><li class="listitem">The <span class="emphasis"><em>Setting up database access for the master/slave configuration</em></span> recipe from this chapter</li></ul></div></div></div>
<div class="section" title="Setting up database access for the master/slave configuration" id="aid-2LQIK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec84"/>Setting up database access for the master/slave configuration</h1></div></div></div><p>Liferay allows<a id="id724" class="indexterm"/> us to configure<a id="id725" class="indexterm"/> two different data sources: first for writing and second for reading. This configuration, in an easy way, allows users to split writing and reading requests. This type of configuration lets us build scalable and high-performance infrastructure.</p><div class="section" title="Getting ready…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec223"/>Getting ready…</h2></div></div></div><p>As we mentioned at the beginning, we are focusing on Liferay configuration aspects. Our assumption<a id="id726" class="indexterm"/> is that you are ready to use<a id="id727" class="indexterm"/> database servers with <a id="id728" class="indexterm"/>master/slave replication. The MySql official documentation at <a class="ulink" href="https://dev.mysql.com/doc/refman/5.1/en/replication-configuration.html">https://dev.mysql.com/doc/refman/5.1/en/replication-configuration.html</a> describes how to configure replication.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec224"/>How to do it…</h2></div></div></div><p>In order to achieve our goal, open <code class="literal">portal-ext.properties</code> and configure the following settings:</p><div class="informalexample"><pre class="programlisting">jdbc.write.driverClassName=com.mysql.jdbc.Driver
jdbc.write.url=jdbc:mysql://&lt;DB_WRITE_ADDRESS&gt;/lportal?useUnicode=true&amp;characterEncoding=UTF-8&amp;useFastDateParsing=false
jdbc.write.username=&lt;USERNAME&gt;
jdbc.write.password=&lt;PASSWORD&gt;

jdbc.read.driverClassName=com.mysql.jdbc.Driver
jdbc.read.url=jdbc:mysql://&lt;DB_READ_ADDRESS&gt;/lportal?useUnicode=true&amp;characterEncoding=UTF-8&amp;useFastDateParsing=false
jdbc.read.username=&lt;USERNAME&gt;
jdbc.read.password=&lt;PASSWORD&gt;</pre></div><p>The next step is to enable the Spring configuration, which contains settings to read/write data sources. Add the following property into <code class="literal">portal-ext.properties</code>:</p><div class="informalexample"><pre class="programlisting">spring.configs=\
META-INF/base-spring.xml,\
META-INF/hibernate-spring.xml,\
META-INF/infrastructure-spring.xml,\
META-INF/management-spring.xml,\
META-INF/util-spring.xml,\
META-INF/editor-spring.xml,\
META-INF/jcr-spring.xml,\
META-INF/messaging-spring.xml,\
META-INF/scheduler-spring.xml,\
META-INF/search-spring.xml,\
META-INF/counter-spring.xml,\
META-INF/document-library-spring.xml,\
META-INF/lock-spring.xml,\
META-INF/mail-spring.xml,\
META-INF/portal-spring.xml,\
META-INF/portlet-container-spring.xml,\
META-INF/wsrp-spring.xml,\
META-INF/mirage-spring.xml,\
<span class="strong"><strong>META-INF/dynamic-data-source-spring.xml,\</strong></span>
#META-INF/shard-data-source-spring.xml,\
META-INF/ext-spring.xml</pre></div><p>At the end, restart your application server. Make sure that database replication works correctly.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec225"/>How it works…</h2></div></div></div><p>In our <a id="id729" class="indexterm"/>configuration, all write<a id="id730" class="indexterm"/> transactions will address the <code class="literal">jdbc.write.*</code> data source and read transactions will use the <code class="literal">jdbc.read.*</code> data source. In order to verify this configuration, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Shut down the master database instance (<code class="literal">jdbc.write</code>).</li><li class="listitem">Run your Liferay instance.</li><li class="listitem">Try to browse Liferay Portal and upload a new content, such as an article or file.</li><li class="listitem">In the <code class="literal">catalina.out</code> log file, there should be an appropriate error message.</li></ol><div style="height:10px; width: 1px"/></div><p>From a technical point of view, Liferay extends the <code class="literal">org.springframework.aop.TargetSource</code> Spring class, which can recognize whether the method contains a read or write operation. The rule is really simple: if a method on a service layer has the <code class="literal">@Transactional</code> annotation, then all queries go to the write data source. In other cases, queries go to the read data source.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec226"/>There's more…</h2></div></div></div><p>Some projects use Liferay with a lot of Portal instances. In this case, the term "Portal instances" means Liferay allows administrators to run more than one portal instance on a single server. Data for each portal instance can be kept separately from every other portal instance. This separation can be organized in the database tier. Each database node can store different types of data, depending on the portal instance. This separation is called database shard.</p><p>Portal instance configuration allows us to choose the shard in which data will be stored. A database shard <a id="id731" class="indexterm"/>is a horizontal partition of data in a database. Each shard is held on a separate database server instance to spread the load. To configure sharding in Liferay, follow this instruction:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">portal-ext.properties</code> file, specify an algorithm to select a new shard on portal instance creation. Use <code class="literal">ManualShardSelector</code> for shard selection via the web interface or round robin in other case. The round-robin algorithm <a id="id732" class="indexterm"/>evenly distributes the data between shards. A manual selector lets us assign each Liferay instance to the specific shard:<div class="informalexample"><pre class="programlisting">shard.selector=com.liferay.portal.dao.shard.RoundRobinShardSelector
#shard.selector=com.liferay.portal.dao.shard.ManualShardSelector</pre></div></li><li class="listitem">Next, set your shard data sources:<div class="informalexample"><pre class="programlisting">jdbc.default.driverClassName=com.mysql.jdbc.Driver
jdbc.default.url=jdbc:mysql://&lt;SERVER1&gt;/lportal?useUnicode=true&amp;characterEncoding=UTF-8&amp;useFastDateParsing=false
jdbc.default.username=&lt;USERNAME&gt;
jdbc.default.password=&lt;PASSWORD&gt;

jdbc.shard1.driverClassName=com.mysql.jdbc.Driver
jdbc.shard1.url=jdbc:mysql://&lt;SERVER2&gt;/lportal1?useUnicode=true&amp;characterEncoding=UTF-8&amp;useFastDateParsing=false
jdbc.shard1.username=&lt;USERNAME&gt;
jdbc.shard1.password=&lt;PASSWORD&gt;

jdbc.shard2.driverClassName=com.mysql.jdbc.Driver
jdbc.shard2.url=jdbc:mysql://&lt;SERVER3&gt;/lportal2?useUnicode=true&amp;characterEncoding=UTF-8&amp;useFastDateParsing=false
jdbc.shard2.username=&lt;USERNAME&gt;
jdbc.shard2.password=&lt;PASSWORD&gt;

shard.available.names=default,shard1,shard2</pre></div></li><li class="listitem">The last thing is the <code class="literal">spring.configs</code> configuration, which should look like this:<div class="informalexample"><pre class="programlisting">spring.configs=&lt;DEFAULT_CONFIGURATION&gt;,\
  META-INF/shard-data-source-spring.xml</pre></div><p>The <code class="literal">&lt;DEFAULT_CONFIGURATION&gt;</code> placeholder keeps all the original <code class="literal">spring.configs</code> configurations, which are defined in the <code class="literal">portal.porperties</code> file.</p></li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Enabling JS and CSS minification" id="aid-2MP361"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec85"/>Enabling JS and CSS minification</h1></div></div></div><p>When your web page loads in a browser, the browser sends an HTTP request to the web server for the<a id="id733" class="indexterm"/> page in the URL. Then, as the HTML is delivered, the<a id="id734" class="indexterm"/> browser parses it and looks for additional requests for images, scripts, CSS, and so on. Every time it sees a request for a new element, it sends another HTTP request to the server. In order to decrease the number of additional requests, Liferay has the following ready-to-use mechanisms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Minifier (compressor) that allows you to compress and minify your JavaScript and CSS files</li><li class="listitem">Merging JavaScript files to reduce the number of HTTP requests using <code class="literal">barebone.jsp</code> and <code class="literal">everything.jsp</code></li><li class="listitem">Merging CSS files and images for faster loading</li><li class="listitem">Enabling Gzip compression</li></ul></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec227"/>How to do it…</h2></div></div></div><p>To set Liferay's fast-load mechanisms, set the following properties in the <code class="literal">portal-ext.properties</code> file:</p><div class="informalexample"><pre class="programlisting">minifier.enabled=true
javascript.fast.load=true
theme.css.fast.load=true
theme.images.fast.load=true
layout.template.cache.enabled=true</pre></div><p>Additionally, if you use custom scripts, add them to the <code class="literal">javascript.barebone.files</code> and <code class="literal">javascript.everything.files</code> properties in the <code class="literal">portal-ext.properties</code> file. The last step is enabling Gzip compression. It is possible to do this by turning on the following property:</p><div class="informalexample"><pre class="programlisting">com.liferay.portal.servlet.filters.gzip.GZipFilter=true</pre></div><p>A better option is delegating this responsibility to Apache server, because it reduces the number of requests in the Apache Tomcat server. To enable Gzip compression on Apache server, open <code class="literal">${APACHE_HOME}/conf/httpd.conf</code> and add the following configuration:</p><div class="informalexample"><pre class="programlisting">SetOutputFilter DEFLATE
SetEnvIfNoCase Request_URI \.(?:exe|t?gz|zip|bz2|sit|rar)$ no-gzip dont-vary
SetEnvIfNoCase Request_URI \.(?:gif|jpe?g|png)$ no-gzip dont-vary</pre></div><p>Make sure that the <code class="literal">deflate</code> module is enabled. Look for the following line:</p><div class="informalexample"><pre class="programlisting">LoadModule deflate_module modules/mod_deflate.so</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec228"/>How it works…</h2></div></div></div><p>In this recipe, we were concentrating on reducing the number of requests and decreasing the size of the response. Liferay combines JS files into one file and stores it in the application <a id="id735" class="indexterm"/>server's <code class="literal">temp</code> directory. On the page, the link to this file <a id="id736" class="indexterm"/>for unauthenticated users looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="/html/js/barebone.jsp?browserId=other&amp;amp;themeId=classic&amp;amp;colorSchemeId=01&amp;amp;minifierType=js&amp;amp;minifierBundleId=javascript.barebone.files&amp;amp;languageId=en_US&amp;amp;b=6201&amp;amp;t=1414241572000" type="text/javascript"&gt;&lt;/script&gt;</pre></div><p>For authenticated users, it is very similar. Instead of <code class="literal">barebone.jsp</code>, there is the <code class="literal">everything.jsp</code> file.</p><p>If we dig deep inside the generated HTML source code, there are links to CSS files with the <code class="literal">minifierType=css</code> parameters. This parameter turns on file minification, which reduces the size of a file.</p><p>The last magic configuration is Gzip compression. If our browser sends a request with the <code class="literal">Accept-Encoding: gzip,deflate</code> header, our system returns Gzipped content. To test it, invoke the following command from your command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -I -H "Accept-Encoding: gzip,deflate" http://localhost:8080</strong></span>
</pre></div><p>In the response, there should be the <code class="literal">Content-Encoding: gzip</code> header.</p></div></div>
<div class="section" title="Turning on the CDN host" id="aid-2NNJO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec86"/>Turning on the CDN host</h1></div></div></div><p>In the previous recipe, you learned how to connect with minifying CSS and JS files and reduce the number of requests to the Liferay Portal. The next step in our configuration is reducing requests to the application server where Liferay is. The idea is that some static resources can be <a id="id737" class="indexterm"/>served by Apache server or, better, by Squid cache. Delivering static resources through the Apache server or Squid cache instead of the application server improves the response time.</p><p>Liferay supports<a id="id738" class="indexterm"/> CDN. Wikipedia defines this term as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A content delivery network or content distribution network (CDN) is a large distributed system of servers deployed in multiple data centers across the Internet. The goal of a CDN is to serve content to end-users with high availability and high performance."</em></span></p></blockquote></div><div class="section" title="Getting ready…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec229"/>Getting ready…</h2></div></div></div><p>Our idea is to use CDN domains to serve static resources and cache them in the Squid cache. The most difficult part is the Squid configuration, which caches all the static files coming from a CDN host. In this recipe, we will assume that this configuration is done, and we have a static domain for our resources, for example, <a class="ulink" href="http://static.mysite.com">http://static.mysite.com</a>
</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec230"/>How to do it…</h2></div></div></div><p>CDN configuration is very simple in Liferay. There are only two properties, which should be set in the <code class="literal">portal-ext.properties</code>. These properties are as follows:</p><div class="informalexample"><pre class="programlisting">cdn.host.http=http://static.mysite.com
cdn.host.https=https://static.mysite.com</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec231"/>How it works...</h2></div></div></div><p>After successful<a id="id739" class="indexterm"/> CDN configuration, all of the static resources are served from an external domain. When we look inside HTML sources, we see that all static resources, such as CSS files, JavaScript files, and images, come from a different domain that was defined in the <code class="literal">cdn.host.http</code> property.</p><p>In this recipe, we built our little CDN in which our Squid cache serves static resources.</p><p>In huge systems, when the intended users are spread across the globe, it is necessary to use real CDN hosts, which are large networks of servers deployed across the world. There are several companies that provide this type of service, such as Amazon, CloudFlare, Bootstrap CDN, CacheFly, OVH, and so on.</p></div></div>
<div class="section" title="Disabling unused Liferay features" id="aid-2OM4A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec87"/>Disabling unused Liferay features</h1></div></div></div><p>Everybody knows that Liferay is a big system with many functionalities. The main idea of this portal is: we give you all the features and you fit them to your needs. This topic can be divided into <a id="id740" class="indexterm"/>three parts: disabling unused servlet filters, disabling unused autologin hooks, and disabling unused features.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec232"/>How to do it…</h2></div></div></div><p>Disabling unused filters allows you to increase performance, but you have to know which filters can be disabled. It is a difficult subject for beginners. Unfortunately, we cannot give you a golden rule that covers your needs. We will only try to give some advice and information about filters that can be turned off in the <code class="literal">portal-ext.properties</code> files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">If you don't use CAS authentication, disable the <code class="literal">com.liferay.portal.servlet.filters.sso.cas.CASFilter=false</code> filter</li><li class="listitem">If you use Gzip compression on Apache server, disable the <code class="literal">com.liferay.portal.servlet.filters.gzip.GZipFilter=false</code> filter</li><li class="listitem">If you don't use NTLM authentication, disable the: <code class="literal">com.liferay.portal.servlet.filters.sso.ntlm.NtlmFilter=false</code> and <code class="literal">com.liferay.portal.servlet.filters.sso.ntlm.NtlmPostFilter=false</code> filters</li><li class="listitem">If you don't use OpenSSO authentication, disable the <code class="literal">com.liferay.portal.servlet.filters.sso.opensso.OpenSSOFilter=false</code> filter</li><li class="listitem">If you don't use SharePoint, disable the <code class="literal">com.liferay.portal.sharepoint.SharepointFilter=false</code> filter</li><li class="listitem">If you use Tomcat server to remove blank lines and whitespaces from the outputted content, disable the <code class="literal">com.liferay.portal.servlet.filters.strip.StripFilter=false</code> filter</li></ul></div><p>The next<a id="id741" class="indexterm"/> configuration is to connect with authentication systems. Liferay supports many single-sign-on systems, which are enabled by default. Remove unused <code class="literal">AutoLogin</code> hooks from the following property:</p><div class="informalexample"><pre class="programlisting">auto.login.hooks=com.liferay.portal.security.auth.CASAutoLogin,\
com.liferay.portal.security.auth.FacebookAutoLogin,\
com.liferay.portal.security.auth.NtlmAutoLogin,\
com.liferay.portal.security.auth.OpenIdAutoLogin,\
com.liferay.portal.security.auth.OpenSSOAutoLogin,\
com.liferay.portal.security.auth.RememberMeAutoLogin,\
com.liferay.portal.security.auth.SiteMinderAutoLogin</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip19"/>Tip</h3><p>If you disable the <code class="literal">auto.login.hooks</code> definition, make sure that every autologin definition is also disabled under the properties with the <code class="literal">com.liferay.portal.servlet.filters.sso</code> prefix. For instance, if you disable <code class="literal">com.liferay.portal.security.auth.NtlmAutoLogin</code>, check whether <code class="literal">com.liferay.portal.servlet.filters.sso.ntlm.NtlmFilter</code> is set as <code class="literal">false</code>.</p></div><p>The last configuration disables some features that affect the performance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">If you don't use user session tracker or this functionality is not required, disable the: <code class="literal">session.tracker.memory.enabled=false</code> property</li><li class="listitem">If you don't use the read count for document library files, disable the <code class="literal">dl.file.entry.read.count.enabled=false</code> property</li><li class="listitem">If you don't use file rank for document library files, disable the <code class="literal">dl.file.rank.enabled=false</code> property</li><li class="listitem">If you don't use the view counter for assets, disable the <code class="literal">asset.entry.increment.view.counter.enabled=false</code> property</li><li class="listitem">Disable pingbacks and trackbacks if you don't use them:<div class="informalexample"><pre class="programlisting">blogs.pingback.enabled=false
blogs.trackback.enabled=false
message.boards.pingback.enabled=false</pre></div></li></ul></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec233"/>How it works…</h2></div></div></div><p>Liferay gives<a id="id742" class="indexterm"/> users a file called <code class="literal">portal.properties</code> that can be overridden by the <code class="literal">portal-ext.properties</code> configuration file. The <code class="literal">portal.properties</code> file is located in the <code class="literal">portal-impl/src/</code> folder. This is the main tool to customize the Liferay Portal and disable unnecessary options. Every administrator and developer should study this file and try to fit portal to the project's requirements. It is hard work, because the configuration file has more than 10,000 lines. The good news is that every property has a comment.</p></div></div>
<div class="section" title="JVM tuning" id="aid-2PKKS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec88"/>JVM tuning</h1></div></div></div><p>JVM tuning is an operation that should be done after performance tests or during production. JVM configuration affects the Java application's performance. There are two necessary configurations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory settings (such as heap configuration)</li><li class="listitem">Garbage collector settings</li></ul></div><p>There are a lot of publications about JVM tuning. Thus, in this recipe, we will only mention the main aspects.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec234"/>How to do it…</h2></div></div></div><p>Every JVM setting can be set in <code class="literal">JAVA_OPTS</code> (Java Environment Options). A great place to do it is in the <code class="literal">${TOMCAT_HOME}/bin/setenv.sh</code> file.</p><p>First, let's set a proper garbage collector. The best option for portal systems is <span class="strong"><strong>Concurrent Collector</strong></span> or <span class="strong"><strong>G1</strong></span> (in Java 8). These garbage collectors perform most of their work <a id="id743" class="indexterm"/>concurrently <a id="id744" class="indexterm"/>with only a small period of stop-the-world time. These garbage collectors give the best performance. The typical setting is as follows:</p><div class="informalexample"><pre class="programlisting">JAVA_OPTS = "$JAVA_OPTS -XX:+UseParNewGC -XX:+UseConcMarkSweepGC 
-XX+CMSParallelRemarkEnabled -XX:ParallelGCThreads=8 
-XX:+CMSScavengeBeforeRemark
-XX:+CMSConcurrentMTEnabled -XX:ParallelCMSThreads=2"</pre></div><p>The following settings are connected with memory allocation. It is very hard to estimate the correct configuration. Our experience shows that the best performance is when each node has equal to or more than 8 GB RAM. Our setting looks as follows:</p><div class="informalexample"><pre class="programlisting">JAVA_OPTS = "$JAVA_OPTS -server -d64 -XX:NewSize=1024m 
-XX:MaxNewSize=1024m -Xms6144m -Xmx6144m -XX:PermSize=512m 
-XX:MaxPermSize=512m -XX:SurvivorRatio=10"</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip20"/>Tip</h3><p>Every project has a different memory characteristic. The given JVM settings form the initial configuration and should be verified by your Java engineering team.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec235"/>How it works…</h2></div></div></div><p>We mentioned<a id="id745" class="indexterm"/> that the best garbage collector for portal solutions is Concurrent Collector or G1. Let's analyze each setting in our <code class="literal">JAVA_OPTS</code> variable:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">+UseParNewGC</code>: This<a id="id746" class="indexterm"/> turns on the parallel young generation collector.</li><li class="listitem"><code class="literal">+UseConcMarkSweepGC</code>: This turns on concurrent mark-sweep collection for the old generation.</li><li class="listitem"><code class="literal">+CMSParallelRemarkEnabled</code>: This enables the garbage collector to use multiple threads during the CMS remark phase. This decreases the pauses during this phase.</li><li class="listitem"><code class="literal">ParallelGCThreads</code>: The number of threads used during parallel phases of the garbage collectors. It shouldn't be more than the number of cores (processors) on the server.</li><li class="listitem"><code class="literal">+CMSScavengeBeforeRemark</code>: This forces young space collection before CMS remark.</li><li class="listitem"><code class="literal">+CMSConcurrentMTEnabled</code>: This allows CMS to use multiple cores for concurrent phases.</li><li class="listitem"><code class="literal">ParallelCMSThreads</code>: This controls the number of threads used for the CMS (concurrent mark and sweep) garbage collector.</li></ul></div></div></div></body></html>