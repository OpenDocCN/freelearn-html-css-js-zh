<html><head></head><body>
		<div id="_idContainer263">
			<h1 id="_idParaDest-193" class="chapter-number"><a id="_idTextAnchor192"/>11</h1>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Render Postprocessing</h1>
			<p>In this chapter, we’ll look at one of the main features of Three.js that we haven’t touched upon yet: render postprocessing. With render postprocessing, you can add additional effects to your scene after it is rendered. For instance, you could add an effect that makes the scene look like it is shown on an old TV, or you could add blur and <span class="No-Break">bloom effects.</span></p>
			<p>The main points we’ll discuss in this chapter are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Setting up Three.js <span class="No-Break">for postprocessing</span></li>
				<li>Some basic postprocessing passes provided by Three.js, such as <strong class="source-inline">BloomPass</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">FilmPass</strong></span></li>
				<li>Applying effects to part of a scene <span class="No-Break">using masks</span></li>
				<li>Using <strong class="source-inline">ShaderPass</strong> to add even more basic postprocessing effects, such as sepia filters, mirror effects, and <span class="No-Break">color adjustments</span></li>
				<li>Using <strong class="source-inline">ShaderPass</strong> for various blurring effects and more <span class="No-Break">advanced filters</span></li>
				<li>Creating a custom postprocessing effect by writing a <span class="No-Break">simple shader</span></li>
			</ul>
			<p>In <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, in the <em class="italic">Introducing requestAnimationFrame</em> section, we set up a rendering loop that we’ve used throughout the book, in order to render and animate our scenes. For postprocessing, we need to make a couple of changes to this setup to allow Three.js to postprocess the final rendering. In the first section, we’ll look at how to <span class="No-Break">do this.</span></p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor194"/>Setting up Three.js for postprocessing</h1>
			<p>To set up <a id="_idIndexMarker995"/>Three.js for postprocessing, we have to make a couple of changes to our current setup, <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Create <strong class="source-inline">EffectComposer</strong>, which can be used to add <span class="No-Break">postprocessing passes.</span></li>
				<li>Configure <strong class="source-inline">EffectComposer</strong> so that it can render our scene and apply any additional <span class="No-Break">postprocessing steps.</span></li>
				<li>In the render loop, use <strong class="source-inline">EffectComposer</strong> to render the scene, apply the configured postprocessing steps, and show <span class="No-Break">the output.</span></li>
			</ol>
			<p>As <a id="_idIndexMarker996"/>always, we will show an example that you can use to experiment with and adapt for your own purposes. The first example in this chapter can be accessed from <strong class="source-inline">basic-setup.html</strong>. You can use the menu in the top-right corner to modify the properties of the postprocessing step used in this example. In this example, we will render the mushroom man from <a href="B18726_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Animation and Moving the Camera</em>, and add an RGB shift effect to it, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/Figure_11.1_B18726.jpg" alt="Figure 11.1 – Rendered using a postprocessing pass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Rendered using a postprocessing pass</p>
			<p>This effect is added after the scene is rendered by using <strong class="source-inline">ShaderPass</strong>, together with <strong class="source-inline">EffectComposer</strong>. In <a id="_idIndexMarker997"/>the menu on the right side of the screen, you can configure this effect and also enable the <span class="No-Break"><strong class="source-inline">DotScreenShader</strong></span><span class="No-Break"> effect.</span></p>
			<p>In the following sections, we’ll explain the individual steps from the previous list. </p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>Creating THREE.EffectComposer</h2>
			<p>To <a id="_idIndexMarker998"/>get <strong class="source-inline">EffectComposer</strong> to work, we first need effects that we can use with it. Three.js comes with a large number of effects and shaders you can use. In this chapter, we’ll show most of them, but for a complete overview, check<a id="_idIndexMarker999"/> out the<a id="_idIndexMarker1000"/> following two directories <span class="No-Break">on GitHub:</span></p>
			<ul>
				<li>Effect <span class="No-Break">passes: </span><a href="https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing&#13;"><span class="No-Break">https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing</span></a></li>
				<li><span class="No-Break">Shaders: </span><a href="https://github.com/mrdoob/three.js/tree/dev/examples/jsm/shaders&#13;"><span class="No-Break">https://github.com/mrdoob/three.js/tree/dev/examples/jsm/shaders</span></a></li>
			</ul>
			<p>To use these effects in your scene, you need to <span class="No-Break">import them:</span></p>
			<pre class="source-code">
import { EffectComposer } from 
  'three/examples/jsm/postprocessing/EffectComposer'
import { RenderPass } from 
  'three/examples/jsm/postprocessing/RenderPass.js'
import { ShaderPass } from 
  'three/examples/jsm/postprocessing/ShaderPass.js'
import { BloomPass } from 
  'three/examples/jsm/postprocessing/BloomPass.js'
import { GlitchPass } from 
  'three/examples/jsm/postprocessing/GlitchPass.js'
import { RGBShiftShader } from 
  'three/examples/jsm/shaders/RGBShiftShader.js'
import { DotScreenShader } from 
  'three/examples/jsm/shaders/DotScreenShader.js'
import { CopyShader } from 
  'three/examples/jsm/shaders/CopyShader.js'</pre>
			<p>In the<a id="_idIndexMarker1001"/> imports in the preceding code block, we import the main <strong class="source-inline">EffectComposer</strong> and a different number of postprocessing passes and shaders that we can use together with this <strong class="source-inline">EffectComposer</strong>. Once we’ve got these, setting up <strong class="source-inline">EffectComposer</strong> is done <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const composer = new EffectComposer(renderer)</pre>
			<p>As you can see, the only argument an effect composer takes is <strong class="source-inline">renderer</strong>. Next, we will add various passes to <span class="No-Break">this composer.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Configuring THREE.EffectComposer for postprocessing</h2>
			<p>Each <a id="_idIndexMarker1002"/>pass is executed in the sequence it is added to <strong class="source-inline">THREE.EffectComposer</strong>. The first pass that we add is <strong class="source-inline">RenderPass</strong>. This pass renders our scene using the camera provided but doesn’t output it to the <span class="No-Break">screen yet:</span></p>
			<pre class="source-code">
const renderPass = new RenderPass(scene, camera); 
composer.addPass(renderPass);</pre>
			<p>With the <strong class="source-inline">addPass</strong> function, we add <strong class="source-inline">RenderPass</strong> to <strong class="source-inline">EffectComposer</strong>. The next step is to add another pass that will take the results from <strong class="source-inline">RenderPass</strong> as its input, apply its transformation, and output its result to the screen. Not all the available passes allow for this, but the passes we’ve used in this <span class="No-Break">example do:</span></p>
			<pre class="source-code">
const effect1 = new ShaderPass(DotScreenShader)
effect1.uniforms['scale'].value = 10
effect1.enabled = false
const effect2 = new ShaderPass(RGBShiftShader)
effect2.uniforms['amount'].value = 0.015
effect2.enabled = false
const composer = new EffectComposer(renderer)
composer.addPass(new RenderPass(scene, camera))
composer.addPass(effect1)
composer.addPass(effect2)</pre>
			<p>In this<a id="_idIndexMarker1003"/> example, we’ve added two effects to <strong class="source-inline">composer</strong>. First, the scene is rendered using <strong class="source-inline">RenderPass</strong>, then <strong class="source-inline">DotScreenShader</strong> is applied, and finally, we <span class="No-Break">apply </span><span class="No-Break"><strong class="source-inline">RGBShiftShader</strong></span><span class="No-Break">.</span></p>
			<p>All we need to do now is update the render loop so that we render using <strong class="source-inline">EffectComposer</strong> instead of through the <span class="No-Break">normal </span><span class="No-Break"><strong class="source-inline">WebGLRenderer</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Updating the render loop</h2>
			<p>We just <a id="_idIndexMarker1004"/>need to make a small modification to our render loop to <a id="_idIndexMarker1005"/>use the composer instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">THREE.WebGLRenderer</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const render = () =&gt; { 
requestAnimationFrame(render); 
composer.render();
}</pre>
			<p>The only modification that we made is removing <strong class="source-inline">renderer.render(scene, camera)</strong> and replacing it with <strong class="source-inline">composer.render()</strong>. This will call the render function on <strong class="source-inline">EffectComposer</strong>, which, in turn, uses the passed-in <strong class="source-inline">THREE.WebGLRenderer</strong>, and the result is that we see the output on <span class="No-Break">the screen:</span></p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/Figure_11.2_B18726.jpg" alt="Figure 11.2 – Rendered using multiple postprocessing passes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Rendered using multiple postprocessing passes</p>
			<p class="callout-heading">Using controls after applying a render pass</p>
			<p class="callout">You can still use the normal controls to move around a scene. All of the effects that you will see in this chapter are applied after the scene is rendered. With this basic setup, we’ll look at the available postprocessing passes in the next couple <span class="No-Break">of sections.</span></p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor198"/>Postprocessing passes</h1>
			<p>Three.js comes <a id="_idIndexMarker1006"/>with a number of postprocessing passes that you can use directly <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">THREE.EffectComposer</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Use a simple GUI to experiment</p>
			<p class="callout">Most of the shaders and passes shown in this chapter can be configured. When you want to apply one yourself, it is usually easiest to just add a simple UI that allows you to play around with the properties. That way, you can see what a good setting for your specific <span class="No-Break">scenario is.</span></p>
			<p>The<a id="_idIndexMarker1007"/> following list shows all the postprocessing passes available <span class="No-Break">in Three.js:</span></p>
			<ul>
				<li><strong class="source-inline">AdaptiveToneMappingPass</strong>: This <a id="_idIndexMarker1008"/>render pass adapts the luminosity of a scene, based on the amount of light available <span class="No-Break">in it.</span></li>
				<li><strong class="source-inline">BloomPass</strong>: This<a id="_idIndexMarker1009"/> is an effect that makes lighter areas bleed into darker areas. This simulates an effect wherein the camera is overwhelmed by extremely <span class="No-Break">bright light.</span></li>
				<li><strong class="source-inline">BokehPass</strong>: This<a id="_idIndexMarker1010"/> adds a bokeh effect to the scene. With a bokeh effect, the foreground of the scene is in focus, while the rest is out <span class="No-Break">of focus.</span></li>
				<li><strong class="source-inline">ClearPass</strong>: This <a id="_idIndexMarker1011"/>spill pass clears the current <span class="No-Break">texture buffer.</span></li>
				<li><strong class="source-inline">CubeTexturePass</strong>: This <a id="_idIndexMarker1012"/>can be used to render a skybox in <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">DotScreenPass</strong>: This<a id="_idIndexMarker1013"/> applies a layer of black dots, representing the original image across <span class="No-Break">the screen.</span></li>
				<li><strong class="source-inline">FilmPass</strong>: This <a id="_idIndexMarker1014"/>simulates a TV screen by applying scanlines <span class="No-Break">and distortions.</span></li>
				<li><strong class="source-inline">GlitchPass</strong>: This<a id="_idIndexMarker1015"/> shows an electronic glitch on the screen at a random <span class="No-Break">time interval.</span></li>
				<li><strong class="source-inline">HalfTonePass</strong>: This<a id="_idIndexMarker1016"/> adds a halftone effect to the scene. With a halftone effect, the scene is rendered as a set of colored glyphs (circles, squares, and so on) of <span class="No-Break">various sizes.</span></li>
				<li><strong class="source-inline">LUTPass</strong>: With <strong class="source-inline">LUTPass</strong>, you<a id="_idIndexMarker1017"/> can apply a color correction step to the scene after it is rendered (not shown in <span class="No-Break">this chapter).</span></li>
				<li><strong class="source-inline">MaskPass</strong>: This <a id="_idIndexMarker1018"/>allows you to apply a mask to the current image. Subsequent passes are only applied to the <span class="No-Break">masked area.</span></li>
				<li><strong class="source-inline">OutlinePass</strong>: This<a id="_idIndexMarker1019"/> renders the outline of the objects in <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">RenderPass</strong>: This <a id="_idIndexMarker1020"/>renders a scene based on the scene and <span class="No-Break">camera supplied.</span></li>
				<li><strong class="source-inline">SAOPass</strong>: This <a id="_idIndexMarker1021"/>provides runtime <span class="No-Break">ambient occlusion.</span></li>
				<li><strong class="source-inline">SMAAPass</strong>: This <a id="_idIndexMarker1022"/>adds an anti-aliasing effect to <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">SSAARenderPass</strong>: This <a id="_idIndexMarker1023"/>adds anti-aliasing to <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">SSAOPass</strong>: This<a id="_idIndexMarker1024"/> provides an alternative way to perform runtime <span class="No-Break">ambient occlusion.</span></li>
				<li><strong class="source-inline">SSRPass</strong>: This<a id="_idIndexMarker1025"/> pass allows you to create <span class="No-Break">reflective objects.</span></li>
				<li><strong class="source-inline">SavePass</strong>: When<a id="_idIndexMarker1026"/> this pass is executed, it makes a copy of the current rendering step that you can use later. This pass isn’t that useful in practice, and we won’t use it in any of <span class="No-Break">our examples.</span></li>
				<li><strong class="source-inline">ShaderPass</strong>: This<a id="_idIndexMarker1027"/> allows you to pass in custom shaders for advanced or custom <span class="No-Break">postprocessing passes.</span></li>
				<li><strong class="source-inline">TAARenderPass</strong>: This<a id="_idIndexMarker1028"/> adds an anti-aliasing effect to <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">TexturePass</strong>: This <a id="_idIndexMarker1029"/>stores the current state of the composer in a texture that you can use as input for other <span class="No-Break"><strong class="source-inline">EffectComposer</strong></span><span class="No-Break"> instances.</span></li>
				<li><strong class="source-inline">UnrealBloomPass</strong>: This <a id="_idIndexMarker1030"/>is the same as <strong class="source-inline">THREE.BloomPass</strong> but with an effect similar to the effect used in the Unreal <span class="No-Break">3D engine.</span></li>
			</ul>
			<p>Let’s start <a id="_idIndexMarker1031"/>with a number of <span class="No-Break">simple passes.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Simple postprocessing passes</h2>
			<p>For simple passes, we’ll <a id="_idIndexMarker1032"/>look at what we can do with <strong class="source-inline">FilmPass</strong>, <strong class="source-inline">BloomPass</strong>, and <strong class="source-inline">DotScreenPass</strong>. For these passes, an example is available (<strong class="source-inline">multi-passes.html</strong>) that will allow you to experiment with these passes and see how they affect the original output differently. The following screenshot shows <span class="No-Break">the example:</span></p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/Figure_11.3_B18726.jpg" alt="Figure 11.3 – Three simple passes applied to a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Three simple passes applied to a scene</p>
			<p>In this <a id="_idIndexMarker1033"/>example, you can see four scenes at the same time, and in <a id="_idIndexMarker1034"/>each scene, a different postprocessing pass is added. The one in the top-left corner shows <strong class="source-inline">BloomPass</strong>, the one in the bottom-right corner shows <strong class="source-inline">DotScreenPass</strong>, and the one in the bottom-left corner shows <strong class="source-inline">FilmPass</strong>. The scene in the top-right corner shows the <span class="No-Break">original render.</span></p>
			<p>In this example, we also use <strong class="source-inline">THREE.ShaderPass</strong> and <strong class="source-inline">THREE.TexturePass</strong> to reuse the output from the original rendering as input for the other three scenes. That way, we only need to render the scene once. So, before we look at the individual passes, let’s look at these two passes, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const effectCopy = new ShaderPass(CopyShader)
const renderedSceneComposer = new EffectComposer(renderer)
renderedSceneComposer.addPass(new RenderPass(scene, 
  camera))
renderedSceneComposer.addPass(new ShaderPass
  (GammaCorrectionShader))
renderedSceneComposer.addPass(effectCopy)
renderedSceneComposer.renderToScreen = false
const texturePass = new TexturePass
  (renderedSceneComposer.renderTarget2.texture)</pre>
			<p>In this<a id="_idIndexMarker1035"/> piece of code, we set up <strong class="source-inline">EffectComposer</strong>, which will output the default scene (the one in the top-right corner). This composer has <span class="No-Break">three passes:</span></p>
			<ul>
				<li><strong class="source-inline">RenderPass</strong>: This <a id="_idIndexMarker1036"/>pass renders <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">ShaderPass</strong> with <strong class="source-inline">GammaCorrectionShader</strong>: Makes<a id="_idIndexMarker1037"/> sure that the colors of the output are correct. If, after applying effects, the color of the scene looks incorrect, this shader will <span class="No-Break">correct it.</span></li>
				<li><strong class="source-inline">ShaderPass</strong> with <strong class="source-inline">CopyShader</strong>: Renders <a id="_idIndexMarker1038"/>the output (without any further postprocessing to the screen, if we set the <strong class="source-inline">renderToScreen</strong> property <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">).</span></li>
			</ul>
			<p>If you look at the example, you can see that we show the same scene four times but with a different effect applied each time. We could also render the scene from scratch by using <strong class="source-inline">RenderPass</strong> four times, but that would be a bit of a waste, since we can just reuse the output from the first composer. To do this, we create <strong class="source-inline">TexturePass</strong> and pass in the <strong class="source-inline">composer.renderTarget2.texture</strong> value. This property contains the rendered scene as a texture, which we can pass into <strong class="source-inline">TexturePass</strong>. We can now use the <strong class="source-inline">texturePass</strong> variable as input for our other composers, without having to render the scene from scratch. Let’s look at <strong class="source-inline">FilmPass</strong> first and how we can use the results from <strong class="source-inline">TexturePass</strong> <span class="No-Break">as input.</span></p>
			<h3>Using THREE.FilmPass to create a TV-like effect</h3>
			<p>To<a id="_idIndexMarker1039"/> create <strong class="source-inline">FilmPass</strong>, we use the<a id="_idIndexMarker1040"/> following piece <span class="No-Break">of code:</span></p>
			<pre class="source-code">
const filmpass = new FilmPass()
const filmpassComposer = new EffectComposer(renderer)
filmpassComposer.addPass(texturePass)
filmpassComposer.addPass(filmpass)</pre>
			<p>The only step that <a id="_idIndexMarker1041"/>we need to take to use <strong class="source-inline">TexturePass</strong> is to add it as the first pass in our composer. Next, we can just add <strong class="source-inline">FilmPass</strong>, and the effect will be applied. <strong class="source-inline">FilmPass</strong> can take four <a id="_idIndexMarker1042"/>additional parameters, as shown in the <span class="No-Break">following list:</span></p>
			<ul>
				<li><strong class="source-inline">noiseIntensity</strong>: This property allows you to control how grainy the <span class="No-Break">scene looks.</span></li>
				<li><strong class="source-inline">scanlinesIntensity</strong>: <strong class="source-inline">FilmPass</strong> adds a number of scanlines (see <strong class="source-inline">scanLinesCount</strong>) to the scene. With this property, you can define how prominently these scanlines <span class="No-Break">are shown.</span></li>
				<li><strong class="source-inline">scanLinesCount</strong>: The number of scanlines that are shown can be controlled with <span class="No-Break">this property.</span></li>
				<li><strong class="source-inline">grayscale</strong>: If this is set to <strong class="source-inline">true</strong>, the output will be converted <span class="No-Break">to grayscale.</span></li>
			</ul>
			<p>There are actually two ways that you can pass in these parameters. In this example, we passed them in as arguments to the constructor, but you can also set them directly, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
effectFilm.uniforms.grayscale.value = controls.grayscale; 
effectFilm.uniforms.nIntensity.value = controls.
  noiseIntensity; 
effectFilm.uniforms.sIntensity.value = controls.
  scanlinesIntensity; 
effectFilm.uniforms.sCount.value = controls.scanlinesCount;</pre>
			<p>In this<a id="_idIndexMarker1043"/> approach, we use the <strong class="source-inline">uniforms</strong> property, which communicates directly with WebGL. In the <em class="italic">Using THREE.ShaderPass for custom effects</em> section, where we talk about creating a custom shader, we’ll get a bit deeper into <strong class="source-inline">uniforms</strong>; for now, all you need to know is that<a id="_idIndexMarker1044"/> this way, you can update the configuration of postprocessing passes and shaders and see the <span class="No-Break">results directly.</span></p>
			<p>The result of this pass is shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/Figure_11.4_B18726.jpg" alt="Figure 11.4 – A film effect provided by FilmPass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – A film effect provided by FilmPass</p>
			<p>The<a id="_idIndexMarker1045"/> next effect is the <a id="_idIndexMarker1046"/>bloom effect, which you can see in the top-left part of the screen in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<h3>Adding a bloom effect to the scene with THREE.BloomPass</h3>
			<p>The <a id="_idIndexMarker1047"/>effect that you see in the top-left corner is called the bloom effect. When you apply the bloom <a id="_idIndexMarker1048"/>effect, the bright areas of a scene will be made more prominent and bleed into the darker areas. The code to create <strong class="source-inline">BloomPass</strong> is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const bloomPass = new BloomPass()
const effectCopy = new ShaderPass(CopyShader)
bloomPassComposer = new EffectComposer(renderer)
bloomPassComposer.addPass(texturePass)
bloomPassComposer.addPass(bloomPass)
bloomPassComposer.addPass(effectCopy)</pre>
			<p>If you compare this with <strong class="source-inline">EffectComposer</strong>, which we used with <strong class="source-inline">FilmPass</strong>, you’ll notice that we add an additional pass, <strong class="source-inline">effectCopy</strong>. This step doesn’t add any special effects but just copies the output from the last pass to the screen. We need to add this step, since <strong class="source-inline">BloomPass</strong> doesn’t render directly to <span class="No-Break">the screen.</span></p>
			<p>The following table lists the<a id="_idIndexMarker1049"/> properties that you can set <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">BloomPass</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">strength</strong>: This is the strength of the bloom effect. The higher this is, the more bright the brighter areas are, and the more they will bleed into the <span class="No-Break">darker areas.</span></li>
				<li><strong class="source-inline">kernelSize</strong>: This is the size of the kernel. This is the size of the area that is blurred in a single step. If you set this higher, more pixels will be included to determine the effect at a <span class="No-Break">specific point.</span></li>
				<li><strong class="source-inline">sigma</strong>: With the <strong class="source-inline">sigma</strong> property, you can control the sharpness of the bloom effect. The higher the value, the more blurred the bloom effect <span class="No-Break">will look.</span></li>
				<li><strong class="source-inline">resolution</strong>: The <strong class="source-inline">resolution</strong> property defines how precisely the bloom effect is created. If you make this too low, the result will <span class="No-Break">look blocky.</span></li>
			</ul>
			<p>A better way to understand these properties is to just experiment with them by using the aforementioned example, <strong class="source-inline">multi-passes.html</strong>. The following screenshot shows the <strong class="source-inline">bloom</strong> effect with a high sigma size and <span class="No-Break">high strength:</span></p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/Figure_11.5_B18726.jpg" alt="Figure 11.5 – The bloom effect using BloomPass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – The bloom effect using BloomPass</p>
			<p>The <a id="_idIndexMarker1050"/>next <a id="_idIndexMarker1051"/>simple effects that we’ll look at are the <span class="No-Break"><strong class="source-inline">DotScreenPass</strong></span><span class="No-Break"> effects.</span></p>
			<h3>Outputting a scene as a set of dots</h3>
			<p>Using <strong class="source-inline">DotScreenPass</strong> is very <a id="_idIndexMarker1052"/>similar to using <strong class="source-inline">BloomPass</strong>. We just saw <strong class="source-inline">BloomPass</strong> in action. Let’s now look at the code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">DotScreenPass</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const dotScreenPass = new DotScreenPass()
const dotScreenPassComposer = new EffectComposer(renderer)
dotScreenPassComposer.addPass(texturePass)
dotScreenPassComposer.addPass(dotScreenPass)</pre>
			<p>With this effect, we don’t need <strong class="source-inline">effectCopy</strong> to output the result to <span class="No-Break">the screen.</span></p>
			<p><strong class="source-inline">DotScreenPass</strong> can also be <a id="_idIndexMarker1053"/>configured with a number of properties, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">center</strong>: With the <strong class="source-inline">center</strong> property, you can fine-tune the way the dots <span class="No-Break">are offset.</span></li>
				<li><strong class="source-inline">angle</strong>: The dots are aligned in a certain manner. With the <strong class="source-inline">angle</strong> properties, you can change <span class="No-Break">this alignment.</span></li>
				<li><strong class="source-inline">scale</strong>: With this, we can set the sizes of the dots to use. The lower the scale, the larger <span class="No-Break">the dots.</span></li>
			</ul>
			<p>What applies to the other shaders also applies to this shader. It’s much easier to get the right settings with experimentation, as seen in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/Figure_11.6_B18726.jpg" alt="Figure 11.6 – A dot-screen effect using DotScreenPass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – A dot-screen effect using DotScreenPass</p>
			<p>Before we<a id="_idIndexMarker1054"/> move on to the next set of simple shaders, we’ll first look at how we’ve rendered multiple scenes on the <span class="No-Break">same screen.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>Showing the output of multiple renderers on the same screen</h2>
			<p>This<a id="_idIndexMarker1055"/> section won’t go into detail on how to use postprocessing effects but will explain how to get the output of all four <strong class="source-inline">EffectComposer</strong> instances on the same screen. First, let’s look at the render loop used for <span class="No-Break">this example:</span></p>
			<pre class="source-code">
const width = window.innerWidth || 2
const height = window.innerHeight || 2
const halfWidth = width / 2
const halfHeight = height / 2
const render = () =&gt; {
  renderer.autoClear = false
  renderer.clear()
  renderedSceneComposer.render()
  renderer.setViewport(0, 0, halfWidth, halfHeight)
  filmpassComposer.render()
  renderer.setViewport(halfWidth, 0, halfWidth, halfHeight)
  dotScreenPassComposer.render()
  renderer.setViewport(0, halfHeight, halfWidth, 
    halfHeight)
  bloomPassComposer.render()
  renderer.setViewport(halfWidth, halfHeight, halfWidth, 
    halfHeight)
  copyComposer.render()
  requestAnimationFrame(() =&gt; render())
}</pre>
			<p>The first thing to notice is that we set the <strong class="source-inline">renderer.autoClear</strong> property to <strong class="source-inline">false</strong> and then explicitly call the <strong class="source-inline">clear()</strong> function in the render loop. If we don’t do this each time we call the <strong class="source-inline">render()</strong> function on a composer, the previously rendered parts of the screen will be cleared. With this approach, we only clear everything at the beginning of our <span class="No-Break">render loop.</span></p>
			<p>To <a id="_idIndexMarker1056"/>avoid having all of our composers render in the same space, we set the <strong class="source-inline">viewport</strong> function of the renderer, which is used by our composers, to a different part of the screen. This function takes four arguments: <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">width</strong>, and <strong class="source-inline">height</strong>. As you can see in the code sample, we use this function to divide the screen into four areas and make the composers render to their individual areas. Note that you can also use this approach with multiple <strong class="source-inline">scene</strong>, <strong class="source-inline">camera</strong>, and <strong class="source-inline">WebGLRenderer</strong> instances, if you want. With this setup, the render loop will render each of the four <strong class="source-inline">EffectComposer</strong> objects to their own parts of the screen. Let’s quickly look at another couple <span class="No-Break">of passes.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>Additional simple passes</h2>
			<p>If you <a id="_idIndexMarker1057"/>open the <strong class="source-inline">multi-passes-2.html</strong> example in your browser, you will see a number of additional passes <span class="No-Break">in action:</span></p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/Figure_11.7_B18726.jpg" alt="Figure 11.7 – Another set of four passes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Another set of four passes</p>
			<p>We <a id="_idIndexMarker1058"/>won’t go into too much detail here, since these passes are configured in the same way as those in the previous sections. In this example, you can see <span class="No-Break">the following:</span></p>
			<ul>
				<li>In the bottom-left corner, you can see <strong class="source-inline">OutlinePass</strong>. The outline pass can be used to draw an outline for a <span class="No-Break"><strong class="source-inline">THREE.Mesh</strong></span><span class="No-Break"> object.</span></li>
				<li>In the bottom-right corner, <strong class="source-inline">GlitchPass</strong> is shown. As the name implies, this pass provides a technical rendering <span class="No-Break">glitch effect.</span></li>
				<li>In the top-left corner, the <strong class="source-inline">UnrealBloom</strong> effect <span class="No-Break">is shown.</span></li>
				<li>In the top-right corner, <strong class="source-inline">HalftonePass</strong> is used to convert the rendering to a set <span class="No-Break">of dots.</span></li>
			</ul>
			<p>As is the case for all of the examples in this chapter, you can configure the individual properties of these passes by using the menu on <span class="No-Break">the right.</span></p>
			<p>To see <strong class="source-inline">OutlinePass</strong> correctly, you can set the scene background to black and zoom out <span class="No-Break">a bit:</span></p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/Figure_11.8_B18726.jpg" alt="Figure 11.8 – The outline pass showing the outline of the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – The outline pass showing the outline of the scene</p>
			<p>So<a id="_idIndexMarker1059"/> far we’ve seen simple effects, in the next section, we’ll look at how you can use masks to apply effects to parts of <span class="No-Break">the screen.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor202"/>Advanced EffectComposer flows using masks</h1>
			<p>In the <a id="_idIndexMarker1060"/>previous examples, we applied the postprocessing pass to a complete screen. However, Three.js also has the ability to apply passes only to a specific area. In this section, we will perform the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Create a scene to serve as a <span class="No-Break">background image.</span></li>
				<li>Create a scene containing a sphere that looks <span class="No-Break">like Earth.</span></li>
				<li>Create a scene containing a sphere that looks <span class="No-Break">like Mars.</span></li>
				<li>Create <strong class="source-inline">EffectComposer</strong>, which renders these three scenes into a <span class="No-Break">single image.</span></li>
				<li>Apply a colorify effect to the sphere rendered <span class="No-Break">as Mars.</span></li>
				<li>Apply a sepia effect to the sphere rendered <span class="No-Break">as Earth.</span></li>
			</ol>
			<p>This might sound complex, but it is actually surprisingly easy to accomplish. First, let’s look at the result that we’re aiming for in the <strong class="source-inline">masks.html</strong> example. The following screenshot shows the results of <span class="No-Break">these steps:</span></p>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="image/Figure_11.9_B18726.jpg" alt="Figure 11.9 – Use a mask to apply an effect to part of the screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Use a mask to apply an effect to part of the screen</p>
			<p>The first<a id="_idIndexMarker1061"/> thing that we need to do is set up the various scenes that we’ll <span class="No-Break">be rendering:</span></p>
			<pre class="source-code">
const sceneEarth = new THREE.Scene()
const sceneMars = new THREE.Scene()
const sceneBG = new THREE.Scene()</pre>
			<p>To create the Earth and Mars spheres, we just create the spheres with the correct material and textures and add them to their specific scenes. For the background scene, we load a texture and set it to as the background for <strong class="source-inline">sceneBG</strong>. This is shown in the following code (<strong class="source-inline">addEarth</strong> and <strong class="source-inline">addMars</strong> are just helper functions to keep the code clear; they create a simple <strong class="source-inline">THREE.Mesh</strong> from <strong class="source-inline">THREE.SphereGeometry</strong>, create some lights, and add them all <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">THREE.Scene</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
sceneBG.background = new THREE.TextureLoader().load
 ('/assets/textures/bg/starry-deep-outer-space-galaxy.jpg')
const earthAndLight = addEarth(sceneEarth)
sceneEarth.translateX(-16)
sceneEarth.scale.set(1.2, 1.2, 1.2)
const marsAndLight = addMars(sceneMars)
sceneMars.translateX(12)
sceneMars.translateY(6)
sceneMars.scale.set(0.2, 0.2, 0.2)</pre>
			<p>In this<a id="_idIndexMarker1062"/> example, we use the <strong class="source-inline">background</strong> property of a scene to add the starry background. There is an alternative way to create a background. We can use <strong class="source-inline">THREE.OrhoGraphicCamera</strong>. With <strong class="source-inline">THREE.OrthographicCamera</strong>, the size of the rendered object doesn’t change when it is closer or further away from the camera, so, by positioning a <strong class="source-inline">THREE.PlaneGeometry</strong> object directly in front of <strong class="source-inline">THREE.rhoGraphicCamera</strong>, we can create a background <span class="No-Break">as well.</span></p>
			<p>We now have got our three scenes, and we can start to set up our passes and <strong class="source-inline">EffectComposer</strong>. Let’s start by looking at the complete chain of passes, after which we’ll look at the <span class="No-Break">individual passes:</span></p>
			<pre class="source-code">
var composer = new EffectComposer(renderer)
composer.renderTarget1.stencilBuffer = true
composer.renderTarget2.stencilBuffer = true
composer.addPass(bgRenderPass)
composer.addPass(earthRenderPass)
composer.addPass(marsRenderPass)
composer.addPass(marsMask)
composer.addPass(effectColorify)
composer.addPass(clearMask)
composer.addPass(earthMask)
composer.addPass(effectSepia)
composer.addPass(clearMask)
composer.addPass(effectCopy)</pre>
			<p>To work<a id="_idIndexMarker1063"/> with masks, we need to create <strong class="source-inline">EffectComposer</strong> in a slightly different manner. We need to set the <strong class="source-inline">stencilBuffer</strong> property of the internally used render targets to <strong class="source-inline">true</strong>. A stencil buffer, a special type of buffer, is used to limit the area of rendering. So, by enabling the stencil buffer, we can use our masks. Let’s look at the first three passes that are added. These three passes render the background, the Earth scene, and the Mars scene, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const bgRenderPass = new RenderPass(sceneBG, camera)
const earthRenderPass = new RenderPass(sceneEarth, camera)
earthRenderPass.clear = false
const marsRenderPass = new RenderPass(sceneMars, camera)
marsRenderPass.clear = false</pre>
			<p>There’s nothing new here, except that we set the <strong class="source-inline">clear</strong> property of two of these passes to <strong class="source-inline">false</strong>. If we don’t do this, we’ll only see the output from the <strong class="source-inline">marsRenderPass</strong> render, since it will clear everything before it <span class="No-Break">starts rendering.</span></p>
			<p>If you look back at the code for <strong class="source-inline">EffectComposer</strong>, the next three passes are <strong class="source-inline">marsMask</strong>, <strong class="source-inline">effectColorify</strong>, and <strong class="source-inline">clearMask</strong>. First, we’ll look at how these three passes <span class="No-Break">are defined:</span></p>
			<pre class="source-code">
const marsMask = new MaskPass(sceneMars, camera)
const effectColorify = new ShaderPass(ColorifyShader)
effectColorify.uniforms['color'].value.setRGB(0.5, 0.5, 1)
const clearMask = new ClearMaskPass()</pre>
			<p>The <a id="_idIndexMarker1064"/>first of these three passes is <strong class="source-inline">MaskPass</strong>. When creating a <strong class="source-inline">MaskPass</strong> object, you pass in a scene and a camera, just as you did for <strong class="source-inline">RenderPass</strong>. A <strong class="source-inline">MaskPass</strong> object will render this scene internally, but instead of showing this on screen, it will use the rendered internal scene to create a mask. When a <strong class="source-inline">MaskPass</strong> object is added to <strong class="source-inline">EffectComposer</strong>, all of the subsequent passes will be applied only to the mask defined by <strong class="source-inline">MaskPass</strong>, until a <strong class="source-inline">ClearMaskPass</strong> step is encountered. In this example, this means that the <strong class="source-inline">effectColorify</strong> pass, which adds a blue glow, is only applied to the objects rendered <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">sceneMars</strong></span><span class="No-Break">.</span></p>
			<p>We use the same approach to apply a sepia filter to the Earth object. We first create a mask based on the Earth scene and use this mask in <strong class="source-inline">EffectComposer</strong>. After using <strong class="source-inline">MaskPass</strong>, we add the effect that we want to apply (<strong class="source-inline">effectSepia</strong> in this case), and, once we’re done with that, we add <strong class="source-inline">ClearMaskPass</strong> to remove the <span class="No-Break">mask again.</span></p>
			<p>The last step for this specific <strong class="source-inline">EffectComposer</strong> is one that we’ve already seen. We need to copy the final result to the screen, and we once again use the <strong class="source-inline">effectCopy</strong> pass for that. With this setup, we can apply the effects that we want to be a part of the total screen. Be aware, though, that these effects are applied to a part of the rendered image if the Mars scene and the Earth <span class="No-Break">scene overlap.</span></p>
			<p>The effects of both will be applied to that part of <span class="No-Break">the screen:</span></p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/Figure_11.10_B18726.jpg" alt="Figure 11.10 – When masks overlap, both effects are applied"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – When masks overlap, both effects are applied</p>
			<p>There<a id="_idIndexMarker1065"/> is one additional property that’s interesting when working with <strong class="source-inline">MaskPass</strong>, and that’s the <strong class="source-inline">inverse</strong> property. If this property is set to <strong class="source-inline">true</strong>, the mask is inverted. In other words, the effect is applied to everything but the scene passed into <strong class="source-inline">MaskPass</strong>. This is shown in the following screenshot, where we set the <strong class="source-inline">inverse</strong> property of <strong class="source-inline">earthMask</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/Figure_11.11_B18726.jpg" alt="Figure 11.11 – When masks overlap, both effects are applied"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – When masks overlap, both effects are applied</p>
			<p>Before <a id="_idIndexMarker1066"/>we move on to a discussion of <strong class="source-inline">ShaderPass</strong>, we’re going to look at two passes that provide a more advanced effect: <strong class="source-inline">BokehPass</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">SSAOPass</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>Advanced pass – bokeh</h2>
			<p>With<a id="_idIndexMarker1067"/> the <strong class="source-inline">BokehPass</strong>, you<a id="_idIndexMarker1068"/> can add a <strong class="source-inline">bokeh</strong> effect to your scene. In a bokeh effect, only part of the scene is in focus, and the rest of the scene looks blurry. To see this effect in action, you can open the <span class="No-Break"><strong class="source-inline">bokeh.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/Figure_11.12_B18726.jpg" alt="Figure 11.12 – An unfocussed bokeh effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – An unfocussed bokeh effect</p>
			<p>When you<a id="_idIndexMarker1069"/> open it, initially, the whole scene will look blurry. With the <strong class="bold">Bokeh</strong> controls on the right, you can set the focus value to the part of the scene that you want to have in focus, and play around with the <strong class="source-inline">aperture</strong> property to determine the size of the area that should be in focus. By sliding the focus, you can have the set of cubes in the foreground in focus, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/Figure_11.13_B18726.jpg" alt="Figure 11.13 – Bokeh focussed on the first set of cubes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Bokeh focussed on the first set of cubes</p>
			<p>Alternatively, if we<a id="_idIndexMarker1070"/> slide the focus further, we can focus on the <span class="No-Break">red cubes:</span></p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/Figure_11.14_B18726.jpg" alt="Figure 11.14 – Bokeh focussed on the second set of cubes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Bokeh focussed on the second set of cubes</p>
			<p>And, if we slide<a id="_idIndexMarker1071"/> the focus even further, we can focus on the set of green cubes at the far end of <span class="No-Break">the scene:</span></p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/Figure_11.15_B18726.jpg" alt="Figure 11.15 – Bokeh focussed on the third set of cubes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Bokeh focussed on the third set of cubes</p>
			<p><strong class="source-inline">BokehPass</strong> can<a id="_idIndexMarker1072"/> be used just like the other passes we’ve seen <span class="No-Break">so far:</span></p>
			<pre class="source-code">
const params = { 
   focus: 10,
   aspect: camera.aspect, 
   aperture: 0.0002,
   maxblur: 1
};
const renderPass = new RenderPass(scene, camera);
const bokehPass = new BokehPass(scene, camera, params) 
bokehPass.renderToScreen = true;
const composer = new EffectComposer(renderer); 
composer.addPass(renderPass); 
composer.addPass(bokehPass);</pre>
			<p>Achieving the <a id="_idIndexMarker1073"/>desired result might require some fine-tuning of <span class="No-Break">the properties.</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>Advance pass – ambient occlusion</h2>
			<p>In <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working with Textures</em>, we discussed using a pre-baked <strong class="bold">ambient occlusion map</strong> (<strong class="bold">aoMap</strong>) to <a id="_idIndexMarker1074"/>directly apply shadows, based on ambient lighting. Ambient occlusion<a id="_idIndexMarker1075"/> involves<a id="_idIndexMarker1076"/> the shadows and light intensity variations that you see on objects, since not all parts of an object receive the same amount of ambient light. Besides using <strong class="source-inline">aoMap</strong> on the material, it is also possible to use a pass on <strong class="source-inline">EffectComposer</strong> to get the same effect. If you open the <strong class="source-inline">ambient-occlusion.html</strong> example, you will see the result of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">SSAOPass</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/Figure_11.16_B18726.jpg" alt="Figure 11.16 – An AO pass applied"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – An AO pass applied</p>
			<p>A similar scene, without the application of an ambient occlusion filter, appears to be really flat, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/Figure_11.17_B18726.jpg" alt="Figure 11.17 – The same scene without the AO pass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – The same scene without the AO pass</p>
			<p>Note<a id="_idIndexMarker1077"/> though that if you use this, you<a id="_idIndexMarker1078"/> have to keep an eye on the overall performance of your application, since this is a very <span class="No-Break">GPU-intensive pass.</span></p>
			<p>Until now, we’ve used the standard passes provided by Three.js for our effects. Three.js also provides <strong class="source-inline">THREE.ShaderPass</strong>, which can be used for custom effects and comes with a large number of shaders that you can use and <span class="No-Break">experiment with.</span></p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/>Using THREE.ShaderPass for custom effects</h1>
			<p>With <strong class="source-inline">THREE.ShaderPass</strong>, we can <a id="_idIndexMarker1079"/>apply a large number of additional effects to our scene by passing in a custom shader. Three.js comes with a set of shaders that can be used together with this <strong class="source-inline">THREE.ShaderPass</strong>. They will be listed in this section. We’ve divided this section into three parts. </p>
			<p>The first set involves simple shaders. All of these <a id="_idIndexMarker1080"/>shaders can be viewed and configured by <a id="_idIndexMarker1081"/>opening up<a id="_idIndexMarker1082"/> the <span class="No-Break"><strong class="source-inline">shaderpass-simple.html</strong></span><span class="No-Break"> example:</span></p>
			<ul>
				<li><strong class="source-inline">BleachBypassShader</strong>: This creates a bleach bypass effect. With this effect, a silver-like overlay will be applied to <span class="No-Break">the image.</span></li>
				<li><strong class="source-inline">BlendShader</strong>: This isn’t a shader that you apply as a single postprocessing step, but it allows you to blend two textures together. You can, for instance, use this shader to smoothly blend the rendering of one scene into another (not shown <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">shaderpass-simple.html</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">BrightnessContrastShader</strong>: This allows you to change the brightness and contrast of <span class="No-Break">an image.</span></li>
				<li><strong class="source-inline">ColorifyShader</strong>: This applies a color overlay to the screen. We’ve seen this one already, in the <span class="No-Break">mask example.</span></li>
				<li><strong class="source-inline">ColorCorrectionShader</strong>: With this shader, you can change the <span class="No-Break">color distribution.</span></li>
				<li><strong class="source-inline">GammaCorrectionShader</strong>: This applies a gamma correction to the rendered scene. This uses a fixed gamma factor of 2. Note that you can also set the gamma correction directly on <strong class="source-inline">THREE.WebGLRenderer</strong> by using the <strong class="source-inline">gammaFactor</strong>, <strong class="source-inline">gammaInput</strong>, and <span class="No-Break"><strong class="source-inline">gammaOutput</strong></span><span class="No-Break"> properties.</span></li>
				<li><strong class="source-inline">HueSaturationShader</strong>: This allows you to change the hue and saturation of <span class="No-Break">the colors.</span></li>
				<li><strong class="source-inline">KaleidoShader</strong>: This adds a kaleidoscope effect to the scene that provides radial reflection around the center of <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">LuminosityShader</strong> and <strong class="source-inline">LuminostyHighPassShader</strong>: This provides a luminosity effect, where the luminosity of the scene <span class="No-Break">is shown.</span></li>
				<li><strong class="source-inline">MirrorShader</strong>: This creates a mirror effect for part of <span class="No-Break">the screen.</span></li>
				<li><strong class="source-inline">PixelShader</strong>: This creates a <span class="No-Break">pixelated effect.</span></li>
				<li><strong class="source-inline">RGBShiftShader</strong>: This shader separates the red, green, and blue components of <span class="No-Break">a color.</span></li>
				<li><strong class="source-inline">SepiaShader</strong>: This creates a sepia-like effect on <span class="No-Break">the screen.</span></li>
				<li><strong class="source-inline">SobelOperatorShader</strong>: This provides <span class="No-Break">edge detection.</span></li>
				<li><strong class="source-inline">VignetteShader</strong>: This <a id="_idIndexMarker1083"/>applies a vignette effect. This effect shows dark borders around the center of <span class="No-Break">the image.</span></li>
			</ul>
			<p>Next, we’ll look <a id="_idIndexMarker1084"/>at the shaders that provide a<a id="_idIndexMarker1085"/> couple of blur-related effects. These effects can be experimented with through<a id="_idIndexMarker1086"/> the <span class="No-Break"><strong class="source-inline">shaderpass-blurs.html</strong></span><span class="No-Break"> example:</span></p>
			<ul>
				<li><strong class="source-inline">HorizontalBlurShader</strong> and <strong class="source-inline">VerticalBlurShader</strong>: These apply a blur effect to the <span class="No-Break">complete scene.</span></li>
				<li><strong class="source-inline">HorizontalTiltShiftShader</strong> and <strong class="source-inline">VerticalTiltShiftShader</strong>: These recreate a tilt-shift effect. With the tilt-shift effect, it is possible to create scenes that look miniature by making sure that only part of the image <span class="No-Break">is sharp.</span></li>
				<li><strong class="source-inline">FocusShader</strong>: This is a simple shader that results in a sharply rendered center area with blurring along <span class="No-Break">its borders.</span></li>
			</ul>
			<p>Finally, there are a number of shaders that we won’t look at in detail; we are listing them simply for the sake of completeness. These shaders are mostly used internally, by either another shader or the shader passes that we discussed at the beginning of <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="source-inline">THREE.FXAAShader</strong>: This shader applies an anti-aliasing effect during the postprocessing phase. Use this if applying anti-aliasing during rendering is <span class="No-Break">too expensive.</span></li>
				<li><strong class="source-inline">THREE.ConvolutionShader</strong>: This shader is used internally by the <strong class="source-inline">BloomPass</strong> <span class="No-Break">render pass.</span></li>
				<li><strong class="source-inline">THREE.DepthLimitedBlurShader</strong>: This is used internally by <strong class="source-inline">SAOPass</strong> for <span class="No-Break">ambient occlusion.</span></li>
				<li><strong class="source-inline">THREE.HalftoneShader</strong>: This is used internally <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">HalftonePass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">THREE.SAOShader</strong>: This provides ambient occlusion in <span class="No-Break">shader form.</span></li>
				<li><strong class="source-inline">THREE.SSAOShader</strong>: This provides an alternative approach to ambient occlusion in <span class="No-Break">shader form.</span></li>
				<li><strong class="source-inline">THREE.SMAAShader</strong>: This provides anti-aliasing to the <span class="No-Break">rendered scene.</span></li>
				<li><strong class="source-inline">THREE.ToneMapShader</strong>: This is used internally <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">AdaptiveToneMappingPass</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">UnpackDepthRGBAShader</strong>: This can be used to visualize encoded depth values from an RGBA texture as a <span class="No-Break">visual color.</span></li>
			</ul>
			<p>If you <a id="_idIndexMarker1087"/>look through the <strong class="source-inline">Shaders</strong> directory of the Three.js distribution, you might notice a couple of other shaders that we haven’t listed in this chapter. These shaders –<strong class="source-inline">FresnelShader</strong>, <strong class="source-inline">OceanShader</strong>, <strong class="source-inline">ParallaxShader</strong>, and <strong class="source-inline">WaterRefractionShader</strong> – aren’t shaders that can be used for postprocessing, but they should be used with the <strong class="source-inline">THREE.ShaderMaterial</strong> object that we discussed in <a href="B18726_04.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Working with Three.js Materials</em>. </p>
			<p>We will start with a couple of <span class="No-Break">simple shaders.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/>Simple shaders</h2>
			<p>To <a id="_idIndexMarker1088"/>experiment with the basic shaders, we’ve created an <a id="_idIndexMarker1089"/>example where you can play around with most of the shaders and see the effects directly in the scene. You can find this example at <strong class="source-inline">shaders.html</strong>. The following screenshots show some of <span class="No-Break">the effects.</span></p>
			<p>The <strong class="source-inline">BrightnessContrastShader</strong> effect <a id="_idIndexMarker1090"/>is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/Figure_11.18_B18726.jpg" alt="Figure 11.18 – The BrightnessContractShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – The BrightnessContractShader effect</p>
			<p>The <strong class="source-inline">SobelOperatorShader</strong> effect <a id="_idIndexMarker1091"/><span class="No-Break">detects outlines:</span></p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/Figure_11.19_B18726.jpg" alt="Figure 11.19 – The SobelOperatorShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – The SobelOperatorShader effect</p>
			<p>You can create a <a id="_idIndexMarker1092"/>kaleidoscope effect <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">KaleidoShader</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/Figure_11.20_B18726.jpg" alt="Figure 11.20 – The KaleidoShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – The KaleidoShader effect</p>
			<p>You can mirror parts of <a id="_idIndexMarker1093"/>the scene <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">MirrorShader</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="image/Figure_11.21_B18726.jpg" alt="Figure 11.21 – The MirrorShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – The MirrorShader effect</p>
			<p>The <strong class="source-inline">RGBShiftShader</strong> effect<a id="_idIndexMarker1094"/> looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="image/Figure_11.22_B18726.jpg" alt="Figure 11.22 – The RGBShiftShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.22 – The RGBShiftShader effect</p>
			<p>You can play around <a id="_idIndexMarker1095"/>with the luminosity in the scene <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">LuminosityHighPassShader</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="image/Figure_11.23_B18726.jpg" alt="Figure 11.23 – The LuminosityHighPassShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.23 – The LuminosityHighPassShader effect</p>
			<p>To see the <a id="_idIndexMarker1096"/>other effects, use the menu on the right to see what they do and how they can be configured. Three.js also provides a couple of shaders that are specifically used to add blurring effects. Those are shown in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>Blurring shaders</h2>
			<p>Again in<a id="_idIndexMarker1097"/> this section, we won’t dive into the code; we’ll <a id="_idIndexMarker1098"/>just show you the results of the various blur shaders. You can experiment with these by using the <strong class="source-inline">shaders-blur.html</strong> example. The first two shaders <a id="_idIndexMarker1099"/>shown <a id="_idIndexMarker1100"/>are <strong class="source-inline">HorizontalBlurShader</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">VerticalBlurShader</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/Figure_11.24_B18726.jpg" alt="Figure 11.24 – HorizontalBlurShader and VerticalBlurShader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.24 – HorizontalBlurShader and VerticalBlurShader</p>
			<p>Another <a id="_idIndexMarker1101"/>blur-like effect is provided by <strong class="source-inline">HorizontalTiltShiftShader</strong> and <strong class="source-inline">VerticalTiltShiftShader</strong>. This<a id="_idIndexMarker1102"/> shader doesn’t <a id="_idIndexMarker1103"/>blur<a id="_idIndexMarker1104"/> the complete scene, only a small area. This provides an effect called tilt-shift. This is often used to create miniature-like scenes from normal photographs. The following screenshot shows <span class="No-Break">this effect:</span></p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/Figure_11.25_B18726.jpg" alt="Figure 11.25 – HorizontalTiltShiftShader and VerticalTiltShiftShader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.25 – HorizontalTiltShiftShader and VerticalTiltShiftShader</p>
			<p>And the <a id="_idIndexMarker1105"/>last of the<a id="_idIndexMarker1106"/> blur-like effects is provided <a id="_idIndexMarker1107"/><span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">FocusShader</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="image/Figure_11.26_B18726.jpg" alt="Figure 11.26 – FocusShader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.26 – FocusShader</p>
			<p>So far, we’ve<a id="_idIndexMarker1108"/> used the shaders provided by Three.js. However, it is<a id="_idIndexMarker1109"/> also <a id="_idIndexMarker1110"/>possible to write your own shaders for use <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">THREE.EffectComposer</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/>Creating custom postprocessing shaders</h1>
			<p>In this<a id="_idIndexMarker1111"/> section, you’ll learn how to create a custom shader that you can use in postprocessing. We’ll create two different shaders. The first one will convert the current image to a grayscale image, and the second one will convert the image to an 8-bit image by reducing the number of colors that <span class="No-Break">are available.</span></p>
			<p class="callout-heading">Vertex and fragment shaders</p>
			<p class="callout">Creating vertex and fragment shaders is <a id="_idIndexMarker1112"/>a very broad subject. In this section, we will only touch the surface of what can be done by these shaders and how they work. For more in-depth information, you can find the WebGL <a id="_idIndexMarker1113"/>specification at <a href="http://www.khronos.org/webgl/">http://www.khronos.org/webgl/</a>. An additional resource, full of examples, is<a id="_idIndexMarker1114"/> Shadertoy, available at <a href="https://www.shadertoy.com">https://www.shadertoy.com</a>, or <em class="italic">The Book of </em><span class="No-Break"><em class="italic">Shaders</em></span><span class="No-Break">: </span><a href="https://thebookofshaders.com/"><span class="No-Break">https://thebookofshaders.com/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Custom grayscale shader</h2>
			<p>To create a<a id="_idIndexMarker1115"/> custom shader for Three.js (and also for other WebGL libraries), you have to create two components: a vertex shader and a fragment shader. The vertex shader can be used to change the position of individual vertices, and the fragment shader can be used to determine the colors of individual pixels. For a postprocessing shader, we only need to implement a fragment shader, and we can keep the default vertex shader provided by Three.js. </p>
			<p>An important point to make before looking at the code is that GPUs support multiple shader pipelines. This means that the vertex shaders run in parallel on multiple vertices at the same time, and the same goes for the <span class="No-Break">fragment shaders.</span></p>
			<p>Let’s start by looking at the complete source code for the shader that applies a grayscale effect to our <span class="No-Break">image (</span><span class="No-Break"><strong class="source-inline">custom-shader.js</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
export const CustomGrayScaleShader = {
  uniforms: {
    tDiffuse: { type: 't', value: null },
    rPower: { type: 'f', value: 0.2126 },
    gPower: { type: 'f', value: 0.7152 },
    bPower: { type: 'f', value: 0.0722 }
  },
  // 0.2126 R + 0.7152 G + 0.0722 B
  // vertexshader is always the same for postprocessing 
     steps
  vertexShader: [
    'varying vec2 vUv;',
    'void main() {',
    'vUv = uv;',
    'gl_Position = projectionMatrix * modelViewMatrix * 
      vec4( position, 1.0 );',
    '}'
  ].join('\n'),
  fragmentShader: [
    // pass in our custom uniforms
    'uniform float rPower;',
    'uniform float gPower;',
    'uniform float bPower;',
    // pass in the image/texture we'll be modifying
    'uniform sampler2D tDiffuse;',
    // used to determine the correct texel we're working on
    'varying vec2 vUv;',
    // executed, in parallel, for each pixel
    'void main() {',
    // get the pixel from the texture we're working with 
       (called a texel)
    'vec4 texel = texture2D( tDiffuse, vUv );',
    // calculate the new color
    'float gray = texel.r*rPower + texel.g*gPower + 
      texel.b*bPower;',
    // return this new color
    'gl_FragColor = vec4( vec3(gray), texel.w );',
    '}'
  ].join('\n')
}</pre>
			<p class="callout-heading">An alternative way of defining shaders</p>
			<p class="callout">In <a href="B18726_04.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, we showed how to define the shaders in separate standalone files. In Three.js, most shaders follow the structure seen in the previous code fragment. Both methods can be used to define the code of <span class="No-Break">the shaders.</span></p>
			<p>As you can <a id="_idIndexMarker1116"/>see in the preceding code block, this isn’t JavaScript. When you write shaders, you write them in <a id="_idIndexMarker1117"/>the <strong class="bold">OpenGL Shading Language</strong> (<strong class="bold">GLSL</strong>), which looks a lot like the C programming language. More information on GLSL can be<a id="_idIndexMarker1118"/> found <span class="No-Break">at </span><a href="http://www.khronos.org/opengles/sdk/docs/manglsl/"><span class="No-Break">http://www.khronos.org/opengles/sdk/docs/manglsl/</span></a><span class="No-Break">.</span></p>
			<p>First, let’s look at the <span class="No-Break">vertex shader:</span></p>
			<pre class="source-code">
  vertexShader: [
    'varying vec2 vUv;',
    'void main() {',
    'vUv = uv;',
    'gl_Position = projectionMatrix * modelViewMatrix * 
      vec4( position, 1.0 );',
    '}'
  ].join('\n'),</pre>
			<p>For postprocessing, this shader doesn’t really need to do anything. The preceding code is the standard way that Three.js implements a vertex shader. It uses <strong class="source-inline">projectionMatrix</strong>, which is the projection from the camera, together with <strong class="source-inline">modelViewMatrix</strong>, which maps an object’s position into the world position, in order to determine where to render a vertex on screen. For postprocessing, the only interesting thing in this piece of code is that the <strong class="source-inline">uv</strong> value, which indicates which texel to read from a texture, is passed on to the fragment shader using the <strong class="source-inline">varying vec2 </strong><span class="No-Break"><strong class="source-inline">vUv</strong></span><span class="No-Break"> variable.</span></p>
			<p>This can<a id="_idIndexMarker1119"/> be used to get the pixel to modify in the fragment shader. Now, let’s look at the fragment shader and see what the code is doing. We will start with the following <span class="No-Break">variable declaration:</span></p>
			<pre class="source-code">
  'uniform float rPower;',
  'uniform float gPower;',
  'uniform float bPower;',
  'uniform sampler2D tDiffuse;',
  'varying vec2 vUv;',</pre>
			<p>Here, we can see four instances of the <strong class="source-inline">uniform</strong> property. The instances of the <strong class="source-inline">uniform</strong> property have values that are passed in from JavaScript to the shader, which are the same for each fragment that is processed. In this case, we pass in three floats, identified by type <strong class="source-inline">float</strong> (which are used to determine the ratio of a color to include in the final grayscale image), and a texture (<strong class="source-inline">tDiffuse</strong>) is also passed in, identified by type <strong class="source-inline">tDiffuse</strong>. This texture contains the image from the previous pass from the <strong class="source-inline">EffectComposer</strong> instance. Three.js makes sure this texture gets passed to this shader when <strong class="source-inline">tDiffuse</strong> is used as its name. We can also set the other instances of the <strong class="source-inline">uniform</strong> property from JavaScript by ourselves. Before we can use these uniforms from JavaScript, we have to define which <strong class="source-inline">uniform</strong> properties we want to expose to JavaScript. This is done as follows, at the top of the <span class="No-Break">shader file:</span></p>
			<pre class="source-code">
uniforms: {
"tDiffuse": { type: "t", value: null },
"rPower":   { type: "f", value: 0.2126 },
"gPower":   { type: "f", value: 0.7152 },
"bPower":   { type: "f", value: 0.0722 }
},</pre>
			<p>At <a id="_idIndexMarker1120"/>this point, we can receive configuration parameters from Three.js, which will provide the output of the current rendering. Let’s look at the code that will convert each pixel to a <span class="No-Break">gray pixel:</span></p>
			<pre class="source-code">
"void main() {",
"vec4 texel = texture2D( tDiffuse, vUv );",
"float gray = texel.r*rPower + texel.g*gPower + 
  texel.b*bPower;", "gl_FragColor = vec4( vec3(gray), 
    texel.w );"</pre>
			<p>What happens here is that we get the correct pixel from the passed-in texture. We do this by using the <strong class="source-inline">texture2D</strong> function, where we pass in our current image (<strong class="source-inline">tDiffuse</strong>) and the location of the pixel (<strong class="source-inline">vUv</strong>) that we want to analyze. The result is a texel (a pixel from a texture) that contains a color and an opacity (<strong class="source-inline">texel.w</strong>). Next, we use the <strong class="source-inline">r</strong>, <strong class="source-inline">g</strong>, and <strong class="source-inline">b</strong> properties of this texel to calculate a gray value. This gray value is set to the <strong class="source-inline">gl_FragColor</strong> variable, which is eventually shown on the screen. And, with that, we have our own custom shader. This shader is used in the same way that we’ve already seen a couple of times in this chapter. First, we just need to set up <strong class="source-inline">EffectComposer</strong>, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const effectCopy = new ShaderPass(CopyShader)
effectCopy.renderToScreen = true
const grayScaleShader = new ShaderPass
  (CustomGrayScaleShader)
const gammaCorrectionShader = new ShaderPass
  (GammaCorrectionShader)
const composer = new EffectComposer(renderer)
composer.addPass(new RenderPass(scene, camera))
composer.addPass(grayScaleShader)
composer.addPass(gammaCorrectionShader)
composer.addPass(effectCopy)</pre>
			<p>We<a id="_idIndexMarker1121"/> call <strong class="source-inline">composer.render()</strong> in the render loop. If we want to change the properties of this shader at runtime, we can just update the <strong class="source-inline">uniforms</strong> property that we’ve defined, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
shaderPass.uniforms.rPower.value = ...; 
shaderPass.uniforms.gPower.value = ...; 
shaderPass.uniforms.bPower.value = ...;</pre>
			<p>The result can be seen in <strong class="source-inline">custom-shaders-scene.html</strong>. The following screenshot shows <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="image/Figure_11.27_B18726.jpg" alt="Figure 11.27 – A custom grayscale filter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.27 – A custom grayscale filter</p>
			<p>Let’s <a id="_idIndexMarker1122"/>create another custom shader. This time, we’ll reduce the 24-bit output to a lower <span class="No-Break">bit count.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>Creating a custom bit shader</h2>
			<p>Normally, colors<a id="_idIndexMarker1123"/> are represented as a 24-bit value, which gives us about 16 million different colors. In the early days of computing, this wasn’t possible, and the colors were often represented as 8- or 16-bit colors. With this shader, we’ll automatically transform our 24-bit output to a color depth of 4 bits (or anything that <span class="No-Break">you want).</span></p>
			<p>Since the vertex shader is the same as in our previous example, we’ll skip the vertex shader and directly list the definition of the <span class="No-Break"><strong class="source-inline">uniforms</strong></span><span class="No-Break"> property:</span></p>
			<pre class="source-code">
uniforms: {
  "tDiffuse": { type: "t", value: null },
  "bitSize":    { type: "i", value: 4 }
}</pre>
			<p>The <strong class="source-inline">fragmentShader</strong> code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
  fragmentShader: [
    'uniform int bitSize;',
    'uniform sampler2D tDiffuse;',
    'varying vec2 vUv;',
    'void main() {',
    'vec4 texel = texture2D( tDiffuse, vUv );',
    'float n = pow(float(bitSize),2.0);',
    'float newR = floor(texel.r*n)/n;',
    'float newG = floor(texel.g*n)/n;',
    'float newB = floor(texel.b*n)/n;',
    'gl_FragColor = vec4( vec3(newR,newG,newB), 1.0);',
    '}'
  ].join('\n')</pre>
			<p>We define<a id="_idIndexMarker1124"/> two instances of the <strong class="source-inline">uniform</strong> property, which can be used to configure this shader. The first one is what Three.js uses to pass in the current screen, and the second one is defined by us as an integer (<strong class="source-inline">type:"i"</strong>) and serves as the color depth that we want to render the result in. The code itself is <span class="No-Break">very straightforward:</span></p>
			<ol>
				<li value="1">First, we get <strong class="source-inline">texel</strong> from the <strong class="source-inline">tDiffuse</strong> texture, based on the passed-in <strong class="source-inline">vUv</strong> location of <span class="No-Break">the pixel.</span></li>
				<li>We calculate the number of colors that we can have, based on the <strong class="source-inline">bitSize</strong> property, by calculating 2 to the power of <span class="No-Break"><strong class="source-inline">bitSize</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">pow(float(bitSize),2.0))</strong></span><span class="No-Break">).</span></li>
				<li>Next, we calculate the new value of the color of <strong class="source-inline">texel</strong> by multiplying this value by <strong class="source-inline">n</strong>, rounding it off (<strong class="source-inline">floor(texel.r*n)</strong>), and dividing it again <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">n</strong></span><span class="No-Break">.</span></li>
				<li>The result is set to <strong class="source-inline">gl_FragColor</strong> (red, green, and blue values and the opacity) and shown on <span class="No-Break">the screen.</span></li>
			</ol>
			<p>You <a id="_idIndexMarker1125"/>can view the result for this custom shader in the same example as our previous custom shader, <strong class="source-inline">custom-shaders-scene.html</strong>. The following screenshot shows this example, where we set the bit size to 4. This means the model is rendered in only <span class="No-Break">16 colors:</span></p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="image/Figure_11.28_B18726.jpg" alt="Figure 11.28 – A custom bit filter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.28 – A custom bit filter</p>
			<p>That’s it for this chapter <span class="No-Break">on postprocessing.</span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/>Summary</h1>
			<p>We discussed many different postprocessing options in this chapter. As you saw, creating <strong class="source-inline">EffectComposer</strong> and chaining passes together is actually very easy. You just have to keep a few things in mind. Not all passes will have an output on the screen. If you want to output to the screen, you can always use <strong class="source-inline">ShaderPass</strong> with <strong class="source-inline">CopyShader</strong>. The sequence in which you add passes to a composer is important. The effects are applied in that sequence. If you want to reuse the result from a specific <strong class="source-inline">EffectComposer</strong> instance, you can do so by using <strong class="source-inline">TexturePass</strong>. When you have more than one <strong class="source-inline">RenderPass</strong> in your <strong class="source-inline">EffectComposer</strong>, make sure to set the <strong class="source-inline">clear</strong> property to <strong class="source-inline">false</strong>. If not, you’ll only see the output from the last <strong class="source-inline">RenderPass</strong> step. If you want to only apply an effect to a specific object, you can use <strong class="source-inline">MaskPass</strong>. When you’re done with the mask, clear the mask with <strong class="source-inline">ClearMaskPass</strong>. Besides the standard passes provided by Three.js, there are also many standard shaders available. You can use these together with <strong class="source-inline">ShaderPass</strong>. Creating custom shaders for postprocessing is very easy, using the standard approach from Three.js. You only have to create a <span class="No-Break">fragment shader.</span></p>
			<p>We have now covered pretty much everything there is to know about the core of Three.js. In <a href="B18726_12.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Adding Physics and Sounds to Your Scene</em>, we’ll look at a library called Rapier.js, which you can use to extend Three.js with physics, in order to apply collisions, gravity, <span class="No-Break">and constraints.</span></p>
		</div>
	</body></html>