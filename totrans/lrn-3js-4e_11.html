<html><head></head><body>
		<div><h1 id="_idParaDest-193" class="chapter-number"><a id="_idTextAnchor192"/>11</h1>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Render Postprocessing</h1>
			<p>In this chapter, we’ll look at one of the main features of Three.js that we haven’t touched upon yet: render postprocessing. With render postprocessing, you can add additional effects to your scene after it is rendered. For instance, you could add an effect that makes the scene look like it is shown on an old TV, or you could add blur and bloom effects.</p>
			<p>The main points we’ll discuss in this chapter are as follows:</p>
			<ul>
				<li>Setting up Three.js for postprocessing</li>
				<li>Some basic postprocessing passes provided by Three.js, such as <code>BloomPass</code> and <code>FilmPass</code></li>
				<li>Applying effects to part of a scene using masks</li>
				<li>Using <code>ShaderPass</code> to add even more basic postprocessing effects, such as sepia filters, mirror effects, and color adjustments</li>
				<li>Using <code>ShaderPass</code> for various blurring effects and more advanced filters</li>
				<li>Creating a custom postprocessing effect by writing a simple shader</li>
			</ul>
			<p>In <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, in the <em class="italic">Introducing requestAnimationFrame</em> section, we set up a rendering loop that we’ve used throughout the book, in order to render and animate our scenes. For postprocessing, we need to make a couple of changes to this setup to allow Three.js to postprocess the final rendering. In the first section, we’ll look at how to do this.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor194"/>Setting up Three.js for postprocessing</h1>
			<p>To set up <a id="_idIndexMarker995"/>Three.js for postprocessing, we have to make a couple of changes to our current setup, as follows:</p>
			<ol>
				<li>Create <code>EffectComposer</code>, which can be used to add postprocessing passes.</li>
				<li>Configure <code>EffectComposer</code> so that it can render our scene and apply any additional postprocessing steps.</li>
				<li>In the render loop, use <code>EffectComposer</code> to render the scene, apply the configured postprocessing steps, and show the output.</li>
			</ol>
			<p>As <a id="_idIndexMarker996"/>always, we will show an example that you can use to experiment with and adapt for your own purposes. The first example in this chapter can be accessed from <code>basic-setup.html</code>. You can use the menu in the top-right corner to modify the properties of the postprocessing step used in this example. In this example, we will render the mushroom man from <a href="B18726_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Animation and Moving the Camera</em>, and add an RGB shift effect to it, as follows:</p>
			<div><div><img src="img/Figure_11.1_B18726.jpg" alt="Figure 11.1 – Rendered using a postprocessing pass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Rendered using a postprocessing pass</p>
			<p>This effect is added after the scene is rendered by using <code>ShaderPass</code>, together with <code>EffectComposer</code>. In <a id="_idIndexMarker997"/>the menu on the right side of the screen, you can configure this effect and also enable the <code>DotScreenShader</code> effect.</p>
			<p>In the following sections, we’ll explain the individual steps from the previous list. </p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>Creating THREE.EffectComposer</h2>
			<p>To <a id="_idIndexMarker998"/>get <code>EffectComposer</code> to work, we first need effects that we can use with it. Three.js comes with a large number of effects and shaders you can use. In this chapter, we’ll show most of them, but for a complete overview, check<a id="_idIndexMarker999"/> out the<a id="_idIndexMarker1000"/> following two directories on GitHub:</p>
			<ul>
				<li>Effect passes: <a href="https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing&#13;">https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing</a></li>
				<li>Shaders: <a href="https://github.com/mrdoob/three.js/tree/dev/examples/jsm/shaders&#13;">https://github.com/mrdoob/three.js/tree/dev/examples/jsm/shaders</a></li>
			</ul>
			<p>To use these effects in your scene, you need to import them:</p>
			<pre class="source-code">
import { EffectComposer } from 
  'three/examples/jsm/postprocessing/EffectComposer'
import { RenderPass } from 
  'three/examples/jsm/postprocessing/RenderPass.js'
import { ShaderPass } from 
  'three/examples/jsm/postprocessing/ShaderPass.js'
import { BloomPass } from 
  'three/examples/jsm/postprocessing/BloomPass.js'
import { GlitchPass } from 
  'three/examples/jsm/postprocessing/GlitchPass.js'
import { RGBShiftShader } from 
  'three/examples/jsm/shaders/RGBShiftShader.js'
import { DotScreenShader } from 
  'three/examples/jsm/shaders/DotScreenShader.js'
import { CopyShader } from 
  'three/examples/jsm/shaders/CopyShader.js'</pre>
			<p>In the<a id="_idIndexMarker1001"/> imports in the preceding code block, we import the main <code>EffectComposer</code> and a different number of postprocessing passes and shaders that we can use together with this <code>EffectComposer</code>. Once we’ve got these, setting up <code>EffectComposer</code> is done like this:</p>
			<pre class="source-code">
const composer = new EffectComposer(renderer)</pre>
			<p>As you can see, the only argument an effect composer takes is <code>renderer</code>. Next, we will add various passes to this composer.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Configuring THREE.EffectComposer for postprocessing</h2>
			<p>Each <a id="_idIndexMarker1002"/>pass is executed in the sequence it is added to <code>THREE.EffectComposer</code>. The first pass that we add is <code>RenderPass</code>. This pass renders our scene using the camera provided but doesn’t output it to the screen yet:</p>
			<pre class="source-code">
const renderPass = new RenderPass(scene, camera); 
composer.addPass(renderPass);</pre>
			<p>With the <code>addPass</code> function, we add <code>RenderPass</code> to <code>EffectComposer</code>. The next step is to add another pass that will take the results from <code>RenderPass</code> as its input, apply its transformation, and output its result to the screen. Not all the available passes allow for this, but the passes we’ve used in this example do:</p>
			<pre class="source-code">
const effect1 = new ShaderPass(DotScreenShader)
effect1.uniforms['scale'].value = 10
effect1.enabled = false
const effect2 = new ShaderPass(RGBShiftShader)
effect2.uniforms['amount'].value = 0.015
effect2.enabled = false
const composer = new EffectComposer(renderer)
composer.addPass(new RenderPass(scene, camera))
composer.addPass(effect1)
composer.addPass(effect2)</pre>
			<p>In this<a id="_idIndexMarker1003"/> example, we’ve added two effects to <code>composer</code>. First, the scene is rendered using <code>RenderPass</code>, then <code>DotScreenShader</code> is applied, and finally, we apply <code>RGBShiftShader</code>.</p>
			<p>All we need to do now is update the render loop so that we render using <code>EffectComposer</code> instead of through the normal <code>WebGLRenderer</code>.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Updating the render loop</h2>
			<p>We just <a id="_idIndexMarker1004"/>need to make a small modification to our render loop to <a id="_idIndexMarker1005"/>use the composer instead of <code>THREE.WebGLRenderer</code>:</p>
			<pre class="source-code">
const render = () =&gt; { 
requestAnimationFrame(render); 
composer.render();
}</pre>
			<p>The only modification that we made is removing <code>renderer.render(scene, camera)</code> and replacing it with <code>composer.render()</code>. This will call the render function on <code>EffectComposer</code>, which, in turn, uses the passed-in <code>THREE.WebGLRenderer</code>, and the result is that we see the output on the screen:</p>
			<div><div><img src="img/Figure_11.2_B18726.jpg" alt="Figure 11.2 – Rendered using multiple postprocessing passes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Rendered using multiple postprocessing passes</p>
			<p class="callout-heading">Using controls after applying a render pass</p>
			<p class="callout">You can still use the normal controls to move around a scene. All of the effects that you will see in this chapter are applied after the scene is rendered. With this basic setup, we’ll look at the available postprocessing passes in the next couple of sections.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor198"/>Postprocessing passes</h1>
			<p>Three.js comes <a id="_idIndexMarker1006"/>with a number of postprocessing passes that you can use directly with <code>THREE.EffectComposer</code>.</p>
			<p class="callout-heading">Use a simple GUI to experiment</p>
			<p class="callout">Most of the shaders and passes shown in this chapter can be configured. When you want to apply one yourself, it is usually easiest to just add a simple UI that allows you to play around with the properties. That way, you can see what a good setting for your specific scenario is.</p>
			<p>The<a id="_idIndexMarker1007"/> following list shows all the postprocessing passes available in Three.js:</p>
			<ul>
				<li><code>AdaptiveToneMappingPass</code>: This <a id="_idIndexMarker1008"/>render pass adapts the luminosity of a scene, based on the amount of light available in it.</li>
				<li><code>BloomPass</code>: This<a id="_idIndexMarker1009"/> is an effect that makes lighter areas bleed into darker areas. This simulates an effect wherein the camera is overwhelmed by extremely bright light.</li>
				<li><code>BokehPass</code>: This<a id="_idIndexMarker1010"/> adds a bokeh effect to the scene. With a bokeh effect, the foreground of the scene is in focus, while the rest is out of focus.</li>
				<li><code>ClearPass</code>: This <a id="_idIndexMarker1011"/>spill pass clears the current texture buffer.</li>
				<li><code>CubeTexturePass</code>: This <a id="_idIndexMarker1012"/>can be used to render a skybox in the scene.</li>
				<li><code>DotScreenPass</code>: This<a id="_idIndexMarker1013"/> applies a layer of black dots, representing the original image across the screen.</li>
				<li><code>FilmPass</code>: This <a id="_idIndexMarker1014"/>simulates a TV screen by applying scanlines and distortions.</li>
				<li><code>GlitchPass</code>: This<a id="_idIndexMarker1015"/> shows an electronic glitch on the screen at a random time interval.</li>
				<li><code>HalfTonePass</code>: This<a id="_idIndexMarker1016"/> adds a halftone effect to the scene. With a halftone effect, the scene is rendered as a set of colored glyphs (circles, squares, and so on) of various sizes.</li>
				<li><code>LUTPass</code>: With <code>LUTPass</code>, you<a id="_idIndexMarker1017"/> can apply a color correction step to the scene after it is rendered (not shown in this chapter).</li>
				<li><code>MaskPass</code>: This <a id="_idIndexMarker1018"/>allows you to apply a mask to the current image. Subsequent passes are only applied to the masked area.</li>
				<li><code>OutlinePass</code>: This<a id="_idIndexMarker1019"/> renders the outline of the objects in the scene.</li>
				<li><code>RenderPass</code>: This <a id="_idIndexMarker1020"/>renders a scene based on the scene and camera supplied.</li>
				<li><code>SAOPass</code>: This <a id="_idIndexMarker1021"/>provides runtime ambient occlusion.</li>
				<li><code>SMAAPass</code>: This <a id="_idIndexMarker1022"/>adds an anti-aliasing effect to the scene.</li>
				<li><code>SSAARenderPass</code>: This <a id="_idIndexMarker1023"/>adds anti-aliasing to the scene.</li>
				<li><code>SSAOPass</code>: This<a id="_idIndexMarker1024"/> provides an alternative way to perform runtime ambient occlusion.</li>
				<li><code>SSRPass</code>: This<a id="_idIndexMarker1025"/> pass allows you to create reflective objects.</li>
				<li><code>SavePass</code>: When<a id="_idIndexMarker1026"/> this pass is executed, it makes a copy of the current rendering step that you can use later. This pass isn’t that useful in practice, and we won’t use it in any of our examples.</li>
				<li><code>ShaderPass</code>: This<a id="_idIndexMarker1027"/> allows you to pass in custom shaders for advanced or custom postprocessing passes.</li>
				<li><code>TAARenderPass</code>: This<a id="_idIndexMarker1028"/> adds an anti-aliasing effect to the scene.</li>
				<li><code>TexturePass</code>: This <a id="_idIndexMarker1029"/>stores the current state of the composer in a texture that you can use as input for other <code>EffectComposer</code> instances.</li>
				<li><code>UnrealBloomPass</code>: This <a id="_idIndexMarker1030"/>is the same as <code>THREE.BloomPass</code> but with an effect similar to the effect used in the Unreal 3D engine.</li>
			</ul>
			<p>Let’s start <a id="_idIndexMarker1031"/>with a number of simple passes.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Simple postprocessing passes</h2>
			<p>For simple passes, we’ll <a id="_idIndexMarker1032"/>look at what we can do with <code>FilmPass</code>, <code>BloomPass</code>, and <code>DotScreenPass</code>. For these passes, an example is available (<code>multi-passes.html</code>) that will allow you to experiment with these passes and see how they affect the original output differently. The following screenshot shows the example:</p>
			<div><div><img src="img/Figure_11.3_B18726.jpg" alt="Figure 11.3 – Three simple passes applied to a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Three simple passes applied to a scene</p>
			<p>In this <a id="_idIndexMarker1033"/>example, you can see four scenes at the same time, and in <a id="_idIndexMarker1034"/>each scene, a different postprocessing pass is added. The one in the top-left corner shows <code>BloomPass</code>, the one in the bottom-right corner shows <code>DotScreenPass</code>, and the one in the bottom-left corner shows <code>FilmPass</code>. The scene in the top-right corner shows the original render.</p>
			<p>In this example, we also use <code>THREE.ShaderPass</code> and <code>THREE.TexturePass</code> to reuse the output from the original rendering as input for the other three scenes. That way, we only need to render the scene once. So, before we look at the individual passes, let’s look at these two passes, as follows:</p>
			<pre class="source-code">
const effectCopy = new ShaderPass(CopyShader)
const renderedSceneComposer = new EffectComposer(renderer)
renderedSceneComposer.addPass(new RenderPass(scene, 
  camera))
renderedSceneComposer.addPass(new ShaderPass
  (GammaCorrectionShader))
renderedSceneComposer.addPass(effectCopy)
renderedSceneComposer.renderToScreen = false
const texturePass = new TexturePass
  (renderedSceneComposer.renderTarget2.texture)</pre>
			<p>In this<a id="_idIndexMarker1035"/> piece of code, we set up <code>EffectComposer</code>, which will output the default scene (the one in the top-right corner). This composer has three passes:</p>
			<ul>
				<li><code>RenderPass</code>: This <a id="_idIndexMarker1036"/>pass renders the scene.</li>
				<li><code>ShaderPass</code> with <code>GammaCorrectionShader</code>: Makes<a id="_idIndexMarker1037"/> sure that the colors of the output are correct. If, after applying effects, the color of the scene looks incorrect, this shader will correct it.</li>
				<li><code>ShaderPass</code> with <code>CopyShader</code>: Renders <a id="_idIndexMarker1038"/>the output (without any further postprocessing to the screen, if we set the <code>renderToScreen</code> property to <code>true</code>).</li>
			</ul>
			<p>If you look at the example, you can see that we show the same scene four times but with a different effect applied each time. We could also render the scene from scratch by using <code>RenderPass</code> four times, but that would be a bit of a waste, since we can just reuse the output from the first composer. To do this, we create <code>TexturePass</code> and pass in the <code>composer.renderTarget2.texture</code> value. This property contains the rendered scene as a texture, which we can pass into <code>TexturePass</code>. We can now use the <code>texturePass</code> variable as input for our other composers, without having to render the scene from scratch. Let’s look at <code>FilmPass</code> first and how we can use the results from <code>TexturePass</code> as input.</p>
			<h3>Using THREE.FilmPass to create a TV-like effect</h3>
			<p>To<a id="_idIndexMarker1039"/> create <code>FilmPass</code>, we use the<a id="_idIndexMarker1040"/> following piece of code:</p>
			<pre class="source-code">
const filmpass = new FilmPass()
const filmpassComposer = new EffectComposer(renderer)
filmpassComposer.addPass(texturePass)
filmpassComposer.addPass(filmpass)</pre>
			<p>The only step that <a id="_idIndexMarker1041"/>we need to take to use <code>TexturePass</code> is to add it as the first pass in our composer. Next, we can just add <code>FilmPass</code>, and the effect will be applied. <code>FilmPass</code> can take four <a id="_idIndexMarker1042"/>additional parameters, as shown in the following list:</p>
			<ul>
				<li><code>noiseIntensity</code>: This property allows you to control how grainy the scene looks.</li>
				<li><code>scanlinesIntensity</code>: <code>FilmPass</code> adds a number of scanlines (see <code>scanLinesCount</code>) to the scene. With this property, you can define how prominently these scanlines are shown.</li>
				<li><code>scanLinesCount</code>: The number of scanlines that are shown can be controlled with this property.</li>
				<li><code>grayscale</code>: If this is set to <code>true</code>, the output will be converted to grayscale.</li>
			</ul>
			<p>There are actually two ways that you can pass in these parameters. In this example, we passed them in as arguments to the constructor, but you can also set them directly, as follows:</p>
			<pre class="source-code">
effectFilm.uniforms.grayscale.value = controls.grayscale; 
effectFilm.uniforms.nIntensity.value = controls.
  noiseIntensity; 
effectFilm.uniforms.sIntensity.value = controls.
  scanlinesIntensity; 
effectFilm.uniforms.sCount.value = controls.scanlinesCount;</pre>
			<p>In this<a id="_idIndexMarker1043"/> approach, we use the <code>uniforms</code> property, which communicates directly with WebGL. In the <em class="italic">Using THREE.ShaderPass for custom effects</em> section, where we talk about creating a custom shader, we’ll get a bit deeper into <code>uniforms</code>; for now, all you need to know is that<a id="_idIndexMarker1044"/> this way, you can update the configuration of postprocessing passes and shaders and see the results directly.</p>
			<p>The result of this pass is shown in the following figure:</p>
			<div><div><img src="img/Figure_11.4_B18726.jpg" alt="Figure 11.4 – A film effect provided by FilmPass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – A film effect provided by FilmPass</p>
			<p>The<a id="_idIndexMarker1045"/> next effect is the <a id="_idIndexMarker1046"/>bloom effect, which you can see in the top-left part of the screen in <em class="italic">Figure 11</em><em class="italic">.3</em>.</p>
			<h3>Adding a bloom effect to the scene with THREE.BloomPass</h3>
			<p>The <a id="_idIndexMarker1047"/>effect that you see in the top-left corner is called the bloom effect. When you apply the bloom <a id="_idIndexMarker1048"/>effect, the bright areas of a scene will be made more prominent and bleed into the darker areas. The code to create <code>BloomPass</code> is as follows:</p>
			<pre class="source-code">
const bloomPass = new BloomPass()
const effectCopy = new ShaderPass(CopyShader)
bloomPassComposer = new EffectComposer(renderer)
bloomPassComposer.addPass(texturePass)
bloomPassComposer.addPass(bloomPass)
bloomPassComposer.addPass(effectCopy)</pre>
			<p>If you compare this with <code>EffectComposer</code>, which we used with <code>FilmPass</code>, you’ll notice that we add an additional pass, <code>effectCopy</code>. This step doesn’t add any special effects but just copies the output from the last pass to the screen. We need to add this step, since <code>BloomPass</code> doesn’t render directly to the screen.</p>
			<p>The following table lists the<a id="_idIndexMarker1049"/> properties that you can set on <code>BloomPass</code>:</p>
			<ul>
				<li><code>strength</code>: This is the strength of the bloom effect. The higher this is, the more bright the brighter areas are, and the more they will bleed into the darker areas.</li>
				<li><code>kernelSize</code>: This is the size of the kernel. This is the size of the area that is blurred in a single step. If you set this higher, more pixels will be included to determine the effect at a specific point.</li>
				<li><code>sigma</code>: With the <code>sigma</code> property, you can control the sharpness of the bloom effect. The higher the value, the more blurred the bloom effect will look.</li>
				<li><code>resolution</code>: The <code>resolution</code> property defines how precisely the bloom effect is created. If you make this too low, the result will look blocky.</li>
			</ul>
			<p>A better way to understand these properties is to just experiment with them by using the aforementioned example, <code>multi-passes.html</code>. The following screenshot shows the <code>bloom</code> effect with a high sigma size and high strength:</p>
			<div><div><img src="img/Figure_11.5_B18726.jpg" alt="Figure 11.5 – The bloom effect using BloomPass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – The bloom effect using BloomPass</p>
			<p>The <a id="_idIndexMarker1050"/>next <a id="_idIndexMarker1051"/>simple effects that we’ll look at are the <code>DotScreenPass</code> effects.</p>
			<h3>Outputting a scene as a set of dots</h3>
			<p>Using <code>DotScreenPass</code> is very <a id="_idIndexMarker1052"/>similar to using <code>BloomPass</code>. We just saw <code>BloomPass</code> in action. Let’s now look at the code for <code>DotScreenPass</code>:</p>
			<pre class="source-code">
const dotScreenPass = new DotScreenPass()
const dotScreenPassComposer = new EffectComposer(renderer)
dotScreenPassComposer.addPass(texturePass)
dotScreenPassComposer.addPass(dotScreenPass)</pre>
			<p>With this effect, we don’t need <code>effectCopy</code> to output the result to the screen.</p>
			<p><code>DotScreenPass</code> can also be <a id="_idIndexMarker1053"/>configured with a number of properties, as follows:</p>
			<ul>
				<li><code>center</code>: With the <code>center</code> property, you can fine-tune the way the dots are offset.</li>
				<li><code>angle</code>: The dots are aligned in a certain manner. With the <code>angle</code> properties, you can change this alignment.</li>
				<li><code>scale</code>: With this, we can set the sizes of the dots to use. The lower the scale, the larger the dots.</li>
			</ul>
			<p>What applies to the other shaders also applies to this shader. It’s much easier to get the right settings with experimentation, as seen in the following figure:</p>
			<div><div><img src="img/Figure_11.6_B18726.jpg" alt="Figure 11.6 – A dot-screen effect using DotScreenPass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – A dot-screen effect using DotScreenPass</p>
			<p>Before we<a id="_idIndexMarker1054"/> move on to the next set of simple shaders, we’ll first look at how we’ve rendered multiple scenes on the same screen.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>Showing the output of multiple renderers on the same screen</h2>
			<p>This<a id="_idIndexMarker1055"/> section won’t go into detail on how to use postprocessing effects but will explain how to get the output of all four <code>EffectComposer</code> instances on the same screen. First, let’s look at the render loop used for this example:</p>
			<pre class="source-code">
const width = window.innerWidth || 2
const height = window.innerHeight || 2
const halfWidth = width / 2
const halfHeight = height / 2
const render = () =&gt; {
  renderer.autoClear = false
  renderer.clear()
  renderedSceneComposer.render()
  renderer.setViewport(0, 0, halfWidth, halfHeight)
  filmpassComposer.render()
  renderer.setViewport(halfWidth, 0, halfWidth, halfHeight)
  dotScreenPassComposer.render()
  renderer.setViewport(0, halfHeight, halfWidth, 
    halfHeight)
  bloomPassComposer.render()
  renderer.setViewport(halfWidth, halfHeight, halfWidth, 
    halfHeight)
  copyComposer.render()
  requestAnimationFrame(() =&gt; render())
}</pre>
			<p>The first thing to notice is that we set the <code>renderer.autoClear</code> property to <code>false</code> and then explicitly call the <code>clear()</code> function in the render loop. If we don’t do this each time we call the <code>render()</code> function on a composer, the previously rendered parts of the screen will be cleared. With this approach, we only clear everything at the beginning of our render loop.</p>
			<p>To <a id="_idIndexMarker1056"/>avoid having all of our composers render in the same space, we set the <code>viewport</code> function of the renderer, which is used by our composers, to a different part of the screen. This function takes four arguments: <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code>. As you can see in the code sample, we use this function to divide the screen into four areas and make the composers render to their individual areas. Note that you can also use this approach with multiple <code>scene</code>, <code>camera</code>, and <code>WebGLRenderer</code> instances, if you want. With this setup, the render loop will render each of the four <code>EffectComposer</code> objects to their own parts of the screen. Let’s quickly look at another couple of passes.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>Additional simple passes</h2>
			<p>If you <a id="_idIndexMarker1057"/>open the <code>multi-passes-2.html</code> example in your browser, you will see a number of additional passes in action:</p>
			<div><div><img src="img/Figure_11.7_B18726.jpg" alt="Figure 11.7 – Another set of four passes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Another set of four passes</p>
			<p>We <a id="_idIndexMarker1058"/>won’t go into too much detail here, since these passes are configured in the same way as those in the previous sections. In this example, you can see the following:</p>
			<ul>
				<li>In the bottom-left corner, you can see <code>OutlinePass</code>. The outline pass can be used to draw an outline for a <code>THREE.Mesh</code> object.</li>
				<li>In the bottom-right corner, <code>GlitchPass</code> is shown. As the name implies, this pass provides a technical rendering glitch effect.</li>
				<li>In the top-left corner, the <code>UnrealBloom</code> effect is shown.</li>
				<li>In the top-right corner, <code>HalftonePass</code> is used to convert the rendering to a set of dots.</li>
			</ul>
			<p>As is the case for all of the examples in this chapter, you can configure the individual properties of these passes by using the menu on the right.</p>
			<p>To see <code>OutlinePass</code> correctly, you can set the scene background to black and zoom out a bit:</p>
			<div><div><img src="img/Figure_11.8_B18726.jpg" alt="Figure 11.8 – The outline pass showing the outline of the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – The outline pass showing the outline of the scene</p>
			<p>So<a id="_idIndexMarker1059"/> far we’ve seen simple effects, in the next section, we’ll look at how you can use masks to apply effects to parts of the screen.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor202"/>Advanced EffectComposer flows using masks</h1>
			<p>In the <a id="_idIndexMarker1060"/>previous examples, we applied the postprocessing pass to a complete screen. However, Three.js also has the ability to apply passes only to a specific area. In this section, we will perform the following steps:</p>
			<ol>
				<li value="1">Create a scene to serve as a background image.</li>
				<li>Create a scene containing a sphere that looks like Earth.</li>
				<li>Create a scene containing a sphere that looks like Mars.</li>
				<li>Create <code>EffectComposer</code>, which renders these three scenes into a single image.</li>
				<li>Apply a colorify effect to the sphere rendered as Mars.</li>
				<li>Apply a sepia effect to the sphere rendered as Earth.</li>
			</ol>
			<p>This might sound complex, but it is actually surprisingly easy to accomplish. First, let’s look at the result that we’re aiming for in the <code>masks.html</code> example. The following screenshot shows the results of these steps:</p>
			<div><div><img src="img/Figure_11.9_B18726.jpg" alt="Figure 11.9 – Use a mask to apply an effect to part of the screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Use a mask to apply an effect to part of the screen</p>
			<p>The first<a id="_idIndexMarker1061"/> thing that we need to do is set up the various scenes that we’ll be rendering:</p>
			<pre class="source-code">
const sceneEarth = new THREE.Scene()
const sceneMars = new THREE.Scene()
const sceneBG = new THREE.Scene()</pre>
			<p>To create the Earth and Mars spheres, we just create the spheres with the correct material and textures and add them to their specific scenes. For the background scene, we load a texture and set it to as the background for <code>sceneBG</code>. This is shown in the following code (<code>addEarth</code> and <code>addMars</code> are just helper functions to keep the code clear; they create a simple <code>THREE.Mesh</code> from <code>THREE.SphereGeometry</code>, create some lights, and add them all to <code>THREE.Scene</code>):</p>
			<pre class="source-code">
sceneBG.background = new THREE.TextureLoader().load
 ('/assets/textures/bg/starry-deep-outer-space-galaxy.jpg')
const earthAndLight = addEarth(sceneEarth)
sceneEarth.translateX(-16)
sceneEarth.scale.set(1.2, 1.2, 1.2)
const marsAndLight = addMars(sceneMars)
sceneMars.translateX(12)
sceneMars.translateY(6)
sceneMars.scale.set(0.2, 0.2, 0.2)</pre>
			<p>In this<a id="_idIndexMarker1062"/> example, we use the <code>background</code> property of a scene to add the starry background. There is an alternative way to create a background. We can use <code>THREE.OrhoGraphicCamera</code>. With <code>THREE.OrthographicCamera</code>, the size of the rendered object doesn’t change when it is closer or further away from the camera, so, by positioning a <code>THREE.PlaneGeometry</code> object directly in front of <code>THREE.rhoGraphicCamera</code>, we can create a background as well.</p>
			<p>We now have got our three scenes, and we can start to set up our passes and <code>EffectComposer</code>. Let’s start by looking at the complete chain of passes, after which we’ll look at the individual passes:</p>
			<pre class="source-code">
var composer = new EffectComposer(renderer)
composer.renderTarget1.stencilBuffer = true
composer.renderTarget2.stencilBuffer = true
composer.addPass(bgRenderPass)
composer.addPass(earthRenderPass)
composer.addPass(marsRenderPass)
composer.addPass(marsMask)
composer.addPass(effectColorify)
composer.addPass(clearMask)
composer.addPass(earthMask)
composer.addPass(effectSepia)
composer.addPass(clearMask)
composer.addPass(effectCopy)</pre>
			<p>To work<a id="_idIndexMarker1063"/> with masks, we need to create <code>EffectComposer</code> in a slightly different manner. We need to set the <code>stencilBuffer</code> property of the internally used render targets to <code>true</code>. A stencil buffer, a special type of buffer, is used to limit the area of rendering. So, by enabling the stencil buffer, we can use our masks. Let’s look at the first three passes that are added. These three passes render the background, the Earth scene, and the Mars scene, as follows:</p>
			<pre class="source-code">
const bgRenderPass = new RenderPass(sceneBG, camera)
const earthRenderPass = new RenderPass(sceneEarth, camera)
earthRenderPass.clear = false
const marsRenderPass = new RenderPass(sceneMars, camera)
marsRenderPass.clear = false</pre>
			<p>There’s nothing new here, except that we set the <code>clear</code> property of two of these passes to <code>false</code>. If we don’t do this, we’ll only see the output from the <code>marsRenderPass</code> render, since it will clear everything before it starts rendering.</p>
			<p>If you look back at the code for <code>EffectComposer</code>, the next three passes are <code>marsMask</code>, <code>effectColorify</code>, and <code>clearMask</code>. First, we’ll look at how these three passes are defined:</p>
			<pre class="source-code">
const marsMask = new MaskPass(sceneMars, camera)
const effectColorify = new ShaderPass(ColorifyShader)
effectColorify.uniforms['color'].value.setRGB(0.5, 0.5, 1)
const clearMask = new ClearMaskPass()</pre>
			<p>The <a id="_idIndexMarker1064"/>first of these three passes is <code>MaskPass</code>. When creating a <code>MaskPass</code> object, you pass in a scene and a camera, just as you did for <code>RenderPass</code>. A <code>MaskPass</code> object will render this scene internally, but instead of showing this on screen, it will use the rendered internal scene to create a mask. When a <code>MaskPass</code> object is added to <code>EffectComposer</code>, all of the subsequent passes will be applied only to the mask defined by <code>MaskPass</code>, until a <code>ClearMaskPass</code> step is encountered. In this example, this means that the <code>effectColorify</code> pass, which adds a blue glow, is only applied to the objects rendered in <code>sceneMars</code>.</p>
			<p>We use the same approach to apply a sepia filter to the Earth object. We first create a mask based on the Earth scene and use this mask in <code>EffectComposer</code>. After using <code>MaskPass</code>, we add the effect that we want to apply (<code>effectSepia</code> in this case), and, once we’re done with that, we add <code>ClearMaskPass</code> to remove the mask again.</p>
			<p>The last step for this specific <code>EffectComposer</code> is one that we’ve already seen. We need to copy the final result to the screen, and we once again use the <code>effectCopy</code> pass for that. With this setup, we can apply the effects that we want to be a part of the total screen. Be aware, though, that these effects are applied to a part of the rendered image if the Mars scene and the Earth scene overlap.</p>
			<p>The effects of both will be applied to that part of the screen:</p>
			<div><div><img src="img/Figure_11.10_B18726.jpg" alt="Figure 11.10 – When masks overlap, both effects are applied"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – When masks overlap, both effects are applied</p>
			<p>There<a id="_idIndexMarker1065"/> is one additional property that’s interesting when working with <code>MaskPass</code>, and that’s the <code>inverse</code> property. If this property is set to <code>true</code>, the mask is inverted. In other words, the effect is applied to everything but the scene passed into <code>MaskPass</code>. This is shown in the following screenshot, where we set the <code>inverse</code> property of <code>earthMask</code> to <code>true</code>:</p>
			<div><div><img src="img/Figure_11.11_B18726.jpg" alt="Figure 11.11 – When masks overlap, both effects are applied"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – When masks overlap, both effects are applied</p>
			<p>Before <a id="_idIndexMarker1066"/>we move on to a discussion of <code>ShaderPass</code>, we’re going to look at two passes that provide a more advanced effect: <code>BokehPass</code> and <code>SSAOPass</code>.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>Advanced pass – bokeh</h2>
			<p>With<a id="_idIndexMarker1067"/> the <code>BokehPass</code>, you<a id="_idIndexMarker1068"/> can add a <code>bokeh</code> effect to your scene. In a bokeh effect, only part of the scene is in focus, and the rest of the scene looks blurry. To see this effect in action, you can open the <code>bokeh.html</code> example:</p>
			<div><div><img src="img/Figure_11.12_B18726.jpg" alt="Figure 11.12 – An unfocussed bokeh effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – An unfocussed bokeh effect</p>
			<p>When you<a id="_idIndexMarker1069"/> open it, initially, the whole scene will look blurry. With the <code>aperture</code> property to determine the size of the area that should be in focus. By sliding the focus, you can have the set of cubes in the foreground in focus, as follows:</p>
			<div><div><img src="img/Figure_11.13_B18726.jpg" alt="Figure 11.13 – Bokeh focussed on the first set of cubes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Bokeh focussed on the first set of cubes</p>
			<p>Alternatively, if we<a id="_idIndexMarker1070"/> slide the focus further, we can focus on the red cubes:</p>
			<div><div><img src="img/Figure_11.14_B18726.jpg" alt="Figure 11.14 – Bokeh focussed on the second set of cubes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Bokeh focussed on the second set of cubes</p>
			<p>And, if we slide<a id="_idIndexMarker1071"/> the focus even further, we can focus on the set of green cubes at the far end of the scene:</p>
			<div><div><img src="img/Figure_11.15_B18726.jpg" alt="Figure 11.15 – Bokeh focussed on the third set of cubes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Bokeh focussed on the third set of cubes</p>
			<p><code>BokehPass</code> can<a id="_idIndexMarker1072"/> be used just like the other passes we’ve seen so far:</p>
			<pre class="source-code">
const params = { 
   focus: 10,
   aspect: camera.aspect, 
   aperture: 0.0002,
   maxblur: 1
};
const renderPass = new RenderPass(scene, camera);
const bokehPass = new BokehPass(scene, camera, params) 
bokehPass.renderToScreen = true;
const composer = new EffectComposer(renderer); 
composer.addPass(renderPass); 
composer.addPass(bokehPass);</pre>
			<p>Achieving the <a id="_idIndexMarker1073"/>desired result might require some fine-tuning of the properties.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>Advance pass – ambient occlusion</h2>
			<p>In <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working with Textures</em>, we discussed using a pre-baked <code>aoMap</code> on the material, it is also possible to use a pass on <code>EffectComposer</code> to get the same effect. If you open the <code>ambient-occlusion.html</code> example, you will see the result of using <code>SSAOPass</code>:</p>
			<div><div><img src="img/Figure_11.16_B18726.jpg" alt="Figure 11.16 – An AO pass applied"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – An AO pass applied</p>
			<p>A similar scene, without the application of an ambient occlusion filter, appears to be really flat, as follows:</p>
			<div><div><img src="img/Figure_11.17_B18726.jpg" alt="Figure 11.17 – The same scene without the AO pass"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – The same scene without the AO pass</p>
			<p>Note<a id="_idIndexMarker1077"/> though that if you use this, you<a id="_idIndexMarker1078"/> have to keep an eye on the overall performance of your application, since this is a very GPU-intensive pass.</p>
			<p>Until now, we’ve used the standard passes provided by Three.js for our effects. Three.js also provides <code>THREE.ShaderPass</code>, which can be used for custom effects and comes with a large number of shaders that you can use and experiment with.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/>Using THREE.ShaderPass for custom effects</h1>
			<p>With <code>THREE.ShaderPass</code>, we can <a id="_idIndexMarker1079"/>apply a large number of additional effects to our scene by passing in a custom shader. Three.js comes with a set of shaders that can be used together with this <code>THREE.ShaderPass</code>. They will be listed in this section. We’ve divided this section into three parts. </p>
			<p>The first set involves simple shaders. All of these <a id="_idIndexMarker1080"/>shaders can be viewed and configured by <a id="_idIndexMarker1081"/>opening up<a id="_idIndexMarker1082"/> the <code>shaderpass-simple.html</code> example:</p>
			<ul>
				<li><code>BleachBypassShader</code>: This creates a bleach bypass effect. With this effect, a silver-like overlay will be applied to the image.</li>
				<li><code>BlendShader</code>: This isn’t a shader that you apply as a single postprocessing step, but it allows you to blend two textures together. You can, for instance, use this shader to smoothly blend the rendering of one scene into another (not shown in <code>shaderpass-simple.html</code>).</li>
				<li><code>BrightnessContrastShader</code>: This allows you to change the brightness and contrast of an image.</li>
				<li><code>ColorifyShader</code>: This applies a color overlay to the screen. We’ve seen this one already, in the mask example.</li>
				<li><code>ColorCorrectionShader</code>: With this shader, you can change the color distribution.</li>
				<li><code>GammaCorrectionShader</code>: This applies a gamma correction to the rendered scene. This uses a fixed gamma factor of 2. Note that you can also set the gamma correction directly on <code>THREE.WebGLRenderer</code> by using the <code>gammaFactor</code>, <code>gammaInput</code>, and <code>gammaOutput</code> properties.</li>
				<li><code>HueSaturationShader</code>: This allows you to change the hue and saturation of the colors.</li>
				<li><code>KaleidoShader</code>: This adds a kaleidoscope effect to the scene that provides radial reflection around the center of the scene.</li>
				<li><code>LuminosityShader</code> and <code>LuminostyHighPassShader</code>: This provides a luminosity effect, where the luminosity of the scene is shown.</li>
				<li><code>MirrorShader</code>: This creates a mirror effect for part of the screen.</li>
				<li><code>PixelShader</code>: This creates a pixelated effect.</li>
				<li><code>RGBShiftShader</code>: This shader separates the red, green, and blue components of a color.</li>
				<li><code>SepiaShader</code>: This creates a sepia-like effect on the screen.</li>
				<li><code>SobelOperatorShader</code>: This provides edge detection.</li>
				<li><code>VignetteShader</code>: This <a id="_idIndexMarker1083"/>applies a vignette effect. This effect shows dark borders around the center of the image.</li>
			</ul>
			<p>Next, we’ll look <a id="_idIndexMarker1084"/>at the shaders that provide a<a id="_idIndexMarker1085"/> couple of blur-related effects. These effects can be experimented with through<a id="_idIndexMarker1086"/> the <code>shaderpass-blurs.html</code> example:</p>
			<ul>
				<li><code>HorizontalBlurShader</code> and <code>VerticalBlurShader</code>: These apply a blur effect to the complete scene.</li>
				<li><code>HorizontalTiltShiftShader</code> and <code>VerticalTiltShiftShader</code>: These recreate a tilt-shift effect. With the tilt-shift effect, it is possible to create scenes that look miniature by making sure that only part of the image is sharp.</li>
				<li><code>FocusShader</code>: This is a simple shader that results in a sharply rendered center area with blurring along its borders.</li>
			</ul>
			<p>Finally, there are a number of shaders that we won’t look at in detail; we are listing them simply for the sake of completeness. These shaders are mostly used internally, by either another shader or the shader passes that we discussed at the beginning of this chapter:</p>
			<ul>
				<li><code>THREE.FXAAShader</code>: This shader applies an anti-aliasing effect during the postprocessing phase. Use this if applying anti-aliasing during rendering is too expensive.</li>
				<li><code>THREE.ConvolutionShader</code>: This shader is used internally by the <code>BloomPass</code> render pass.</li>
				<li><code>THREE.DepthLimitedBlurShader</code>: This is used internally by <code>SAOPass</code> for ambient occlusion.</li>
				<li><code>THREE.HalftoneShader</code>: This is used internally by <code>HalftonePass</code>.</li>
				<li><code>THREE.SAOShader</code>: This provides ambient occlusion in shader form.</li>
				<li><code>THREE.SSAOShader</code>: This provides an alternative approach to ambient occlusion in shader form.</li>
				<li><code>THREE.SMAAShader</code>: This provides anti-aliasing to the rendered scene.</li>
				<li><code>THREE.ToneMapShader</code>: This is used internally by <code>AdaptiveToneMappingPass</code>.</li>
				<li><code>UnpackDepthRGBAShader</code>: This can be used to visualize encoded depth values from an RGBA texture as a visual color.</li>
			</ul>
			<p>If you <a id="_idIndexMarker1087"/>look through the <code>Shaders</code> directory of the Three.js distribution, you might notice a couple of other shaders that we haven’t listed in this chapter. These shaders –<code>FresnelShader</code>, <code>OceanShader</code>, <code>ParallaxShader</code>, and <code>WaterRefractionShader</code> – aren’t shaders that can be used for postprocessing, but they should be used with the <code>THREE.ShaderMaterial</code> object that we discussed in <a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, <em class="italic">Working with Three.js Materials</em>. </p>
			<p>We will start with a couple of simple shaders.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/>Simple shaders</h2>
			<p>To <a id="_idIndexMarker1088"/>experiment with the basic shaders, we’ve created an <a id="_idIndexMarker1089"/>example where you can play around with most of the shaders and see the effects directly in the scene. You can find this example at <code>shaders.html</code>. The following screenshots show some of the effects.</p>
			<p>The <code>BrightnessContrastShader</code> effect <a id="_idIndexMarker1090"/>is as follows:</p>
			<div><div><img src="img/Figure_11.18_B18726.jpg" alt="Figure 11.18 – The BrightnessContractShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – The BrightnessContractShader effect</p>
			<p>The <code>SobelOperatorShader</code> effect <a id="_idIndexMarker1091"/>detects outlines:</p>
			<div><div><img src="img/Figure_11.19_B18726.jpg" alt="Figure 11.19 – The SobelOperatorShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – The SobelOperatorShader effect</p>
			<p>You can create a <a id="_idIndexMarker1092"/>kaleidoscope effect using <code>KaleidoShader</code>:</p>
			<div><div><img src="img/Figure_11.20_B18726.jpg" alt="Figure 11.20 – The KaleidoShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – The KaleidoShader effect</p>
			<p>You can mirror parts of <a id="_idIndexMarker1093"/>the scene with <code>MirrorShader</code>:</p>
			<div><div><img src="img/Figure_11.21_B18726.jpg" alt="Figure 11.21 – The MirrorShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – The MirrorShader effect</p>
			<p>The <code>RGBShiftShader</code> effect<a id="_idIndexMarker1094"/> looks like this:</p>
			<div><div><img src="img/Figure_11.22_B18726.jpg" alt="Figure 11.22 – The RGBShiftShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.22 – The RGBShiftShader effect</p>
			<p>You can play around <a id="_idIndexMarker1095"/>with the luminosity in the scene with <code>LuminosityHighPassShader</code>:</p>
			<div><div><img src="img/Figure_11.23_B18726.jpg" alt="Figure 11.23 – The LuminosityHighPassShader effect"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.23 – The LuminosityHighPassShader effect</p>
			<p>To see the <a id="_idIndexMarker1096"/>other effects, use the menu on the right to see what they do and how they can be configured. Three.js also provides a couple of shaders that are specifically used to add blurring effects. Those are shown in the next section.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>Blurring shaders</h2>
			<p>Again in<a id="_idIndexMarker1097"/> this section, we won’t dive into the code; we’ll <a id="_idIndexMarker1098"/>just show you the results of the various blur shaders. You can experiment with these by using the <code>shaders-blur.html</code> example. The first two shaders <a id="_idIndexMarker1099"/>shown <a id="_idIndexMarker1100"/>are <code>HorizontalBlurShader</code> and <code>VerticalBlurShader</code>:</p>
			<div><div><img src="img/Figure_11.24_B18726.jpg" alt="Figure 11.24 – HorizontalBlurShader and VerticalBlurShader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.24 – HorizontalBlurShader and VerticalBlurShader</p>
			<p>Another <a id="_idIndexMarker1101"/>blur-like effect is provided by <code>HorizontalTiltShiftShader</code> and <code>VerticalTiltShiftShader</code>. This<a id="_idIndexMarker1102"/> shader doesn’t <a id="_idIndexMarker1103"/>blur<a id="_idIndexMarker1104"/> the complete scene, only a small area. This provides an effect called tilt-shift. This is often used to create miniature-like scenes from normal photographs. The following screenshot shows this effect:</p>
			<div><div><img src="img/Figure_11.25_B18726.jpg" alt="Figure 11.25 – HorizontalTiltShiftShader and VerticalTiltShiftShader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.25 – HorizontalTiltShiftShader and VerticalTiltShiftShader</p>
			<p>And the <a id="_idIndexMarker1105"/>last of the<a id="_idIndexMarker1106"/> blur-like effects is provided <a id="_idIndexMarker1107"/>by <code>FocusShader</code>:</p>
			<div><div><img src="img/Figure_11.26_B18726.jpg" alt="Figure 11.26 – FocusShader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.26 – FocusShader</p>
			<p>So far, we’ve<a id="_idIndexMarker1108"/> used the shaders provided by Three.js. However, it is<a id="_idIndexMarker1109"/> also <a id="_idIndexMarker1110"/>possible to write your own shaders for use with <code>THREE.EffectComposer</code>.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/>Creating custom postprocessing shaders</h1>
			<p>In this<a id="_idIndexMarker1111"/> section, you’ll learn how to create a custom shader that you can use in postprocessing. We’ll create two different shaders. The first one will convert the current image to a grayscale image, and the second one will convert the image to an 8-bit image by reducing the number of colors that are available.</p>
			<p class="callout-heading">Vertex and fragment shaders</p>
			<p class="callout">Creating vertex and fragment shaders is <a id="_idIndexMarker1112"/>a very broad subject. In this section, we will only touch the surface of what can be done by these shaders and how they work. For more in-depth information, you can find the WebGL <a id="_idIndexMarker1113"/>specification at <a href="http://www.khronos.org/webgl/">http://www.khronos.org/webgl/</a>. An additional resource, full of examples, is<a id="_idIndexMarker1114"/> Shadertoy, available at <a href="https://www.shadertoy.com">https://www.shadertoy.com</a>, or <em class="italic">The Book of </em><em class="italic">Shaders</em>: <a href="https://thebookofshaders.com/">https://thebookofshaders.com/</a>.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Custom grayscale shader</h2>
			<p>To create a<a id="_idIndexMarker1115"/> custom shader for Three.js (and also for other WebGL libraries), you have to create two components: a vertex shader and a fragment shader. The vertex shader can be used to change the position of individual vertices, and the fragment shader can be used to determine the colors of individual pixels. For a postprocessing shader, we only need to implement a fragment shader, and we can keep the default vertex shader provided by Three.js. </p>
			<p>An important point to make before looking at the code is that GPUs support multiple shader pipelines. This means that the vertex shaders run in parallel on multiple vertices at the same time, and the same goes for the fragment shaders.</p>
			<p>Let’s start by looking at the complete source code for the shader that applies a grayscale effect to our image (<code>custom-shader.js</code>):</p>
			<pre class="source-code">
export const CustomGrayScaleShader = {
  uniforms: {
    tDiffuse: { type: 't', value: null },
    rPower: { type: 'f', value: 0.2126 },
    gPower: { type: 'f', value: 0.7152 },
    bPower: { type: 'f', value: 0.0722 }
  },
  // 0.2126 R + 0.7152 G + 0.0722 B
  // vertexshader is always the same for postprocessing 
     steps
  vertexShader: [
    'varying vec2 vUv;',
    'void main() {',
    'vUv = uv;',
    'gl_Position = projectionMatrix * modelViewMatrix * 
      vec4( position, 1.0 );',
    '}'
  ].join('\n'),
  fragmentShader: [
    // pass in our custom uniforms
    'uniform float rPower;',
    'uniform float gPower;',
    'uniform float bPower;',
    // pass in the image/texture we'll be modifying
    'uniform sampler2D tDiffuse;',
    // used to determine the correct texel we're working on
    'varying vec2 vUv;',
    // executed, in parallel, for each pixel
    'void main() {',
    // get the pixel from the texture we're working with 
       (called a texel)
    'vec4 texel = texture2D( tDiffuse, vUv );',
    // calculate the new color
    'float gray = texel.r*rPower + texel.g*gPower + 
      texel.b*bPower;',
    // return this new color
    'gl_FragColor = vec4( vec3(gray), texel.w );',
    '}'
  ].join('\n')
}</pre>
			<p class="callout-heading">An alternative way of defining shaders</p>
			<p class="callout">In <a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, we showed how to define the shaders in separate standalone files. In Three.js, most shaders follow the structure seen in the previous code fragment. Both methods can be used to define the code of the shaders.</p>
			<p>As you can <a id="_idIndexMarker1116"/>see in the preceding code block, this isn’t JavaScript. When you write shaders, you write them in <a id="_idIndexMarker1117"/>the <strong class="bold">OpenGL Shading Language</strong> (<strong class="bold">GLSL</strong>), which looks a lot like the C programming language. More information on GLSL can be<a id="_idIndexMarker1118"/> found at <a href="http://www.khronos.org/opengles/sdk/docs/manglsl/">http://www.khronos.org/opengles/sdk/docs/manglsl/</a>.</p>
			<p>First, let’s look at the vertex shader:</p>
			<pre class="source-code">
  vertexShader: [
    'varying vec2 vUv;',
    'void main() {',
    'vUv = uv;',
    'gl_Position = projectionMatrix * modelViewMatrix * 
      vec4( position, 1.0 );',
    '}'
  ].join('\n'),</pre>
			<p>For postprocessing, this shader doesn’t really need to do anything. The preceding code is the standard way that Three.js implements a vertex shader. It uses <code>projectionMatrix</code>, which is the projection from the camera, together with <code>modelViewMatrix</code>, which maps an object’s position into the world position, in order to determine where to render a vertex on screen. For postprocessing, the only interesting thing in this piece of code is that the <code>uv</code> value, which indicates which texel to read from a texture, is passed on to the fragment shader using the <code>varying vec2 </code><code>vUv</code> variable.</p>
			<p>This can<a id="_idIndexMarker1119"/> be used to get the pixel to modify in the fragment shader. Now, let’s look at the fragment shader and see what the code is doing. We will start with the following variable declaration:</p>
			<pre class="source-code">
  'uniform float rPower;',
  'uniform float gPower;',
  'uniform float bPower;',
  'uniform sampler2D tDiffuse;',
  'varying vec2 vUv;',</pre>
			<p>Here, we can see four instances of the <code>uniform</code> property. The instances of the <code>uniform</code> property have values that are passed in from JavaScript to the shader, which are the same for each fragment that is processed. In this case, we pass in three floats, identified by type <code>float</code> (which are used to determine the ratio of a color to include in the final grayscale image), and a texture (<code>tDiffuse</code>) is also passed in, identified by type <code>tDiffuse</code>. This texture contains the image from the previous pass from the <code>EffectComposer</code> instance. Three.js makes sure this texture gets passed to this shader when <code>tDiffuse</code> is used as its name. We can also set the other instances of the <code>uniform</code> property from JavaScript by ourselves. Before we can use these uniforms from JavaScript, we have to define which <code>uniform</code> properties we want to expose to JavaScript. This is done as follows, at the top of the shader file:</p>
			<pre class="source-code">
uniforms: {
"tDiffuse": { type: "t", value: null },
"rPower":   { type: "f", value: 0.2126 },
"gPower":   { type: "f", value: 0.7152 },
"bPower":   { type: "f", value: 0.0722 }
},</pre>
			<p>At <a id="_idIndexMarker1120"/>this point, we can receive configuration parameters from Three.js, which will provide the output of the current rendering. Let’s look at the code that will convert each pixel to a gray pixel:</p>
			<pre class="source-code">
"void main() {",
"vec4 texel = texture2D( tDiffuse, vUv );",
"float gray = texel.r*rPower + texel.g*gPower + 
  texel.b*bPower;", "gl_FragColor = vec4( vec3(gray), 
    texel.w );"</pre>
			<p>What happens here is that we get the correct pixel from the passed-in texture. We do this by using the <code>texture2D</code> function, where we pass in our current image (<code>tDiffuse</code>) and the location of the pixel (<code>vUv</code>) that we want to analyze. The result is a texel (a pixel from a texture) that contains a color and an opacity (<code>texel.w</code>). Next, we use the <code>r</code>, <code>g</code>, and <code>b</code> properties of this texel to calculate a gray value. This gray value is set to the <code>gl_FragColor</code> variable, which is eventually shown on the screen. And, with that, we have our own custom shader. This shader is used in the same way that we’ve already seen a couple of times in this chapter. First, we just need to set up <code>EffectComposer</code>, as follows:</p>
			<pre class="source-code">
const effectCopy = new ShaderPass(CopyShader)
effectCopy.renderToScreen = true
const grayScaleShader = new ShaderPass
  (CustomGrayScaleShader)
const gammaCorrectionShader = new ShaderPass
  (GammaCorrectionShader)
const composer = new EffectComposer(renderer)
composer.addPass(new RenderPass(scene, camera))
composer.addPass(grayScaleShader)
composer.addPass(gammaCorrectionShader)
composer.addPass(effectCopy)</pre>
			<p>We<a id="_idIndexMarker1121"/> call <code>composer.render()</code> in the render loop. If we want to change the properties of this shader at runtime, we can just update the <code>uniforms</code> property that we’ve defined, as follows:</p>
			<pre class="source-code">
shaderPass.uniforms.rPower.value = ...; 
shaderPass.uniforms.gPower.value = ...; 
shaderPass.uniforms.bPower.value = ...;</pre>
			<p>The result can be seen in <code>custom-shaders-scene.html</code>. The following screenshot shows this example:</p>
			<div><div><img src="img/Figure_11.27_B18726.jpg" alt="Figure 11.27 – A custom grayscale filter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.27 – A custom grayscale filter</p>
			<p>Let’s <a id="_idIndexMarker1122"/>create another custom shader. This time, we’ll reduce the 24-bit output to a lower bit count.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>Creating a custom bit shader</h2>
			<p>Normally, colors<a id="_idIndexMarker1123"/> are represented as a 24-bit value, which gives us about 16 million different colors. In the early days of computing, this wasn’t possible, and the colors were often represented as 8- or 16-bit colors. With this shader, we’ll automatically transform our 24-bit output to a color depth of 4 bits (or anything that you want).</p>
			<p>Since the vertex shader is the same as in our previous example, we’ll skip the vertex shader and directly list the definition of the <code>uniforms</code> property:</p>
			<pre class="source-code">
uniforms: {
  "tDiffuse": { type: "t", value: null },
  "bitSize":    { type: "i", value: 4 }
}</pre>
			<p>The <code>fragmentShader</code> code is as follows:</p>
			<pre class="source-code">
  fragmentShader: [
    'uniform int bitSize;',
    'uniform sampler2D tDiffuse;',
    'varying vec2 vUv;',
    'void main() {',
    'vec4 texel = texture2D( tDiffuse, vUv );',
    'float n = pow(float(bitSize),2.0);',
    'float newR = floor(texel.r*n)/n;',
    'float newG = floor(texel.g*n)/n;',
    'float newB = floor(texel.b*n)/n;',
    'gl_FragColor = vec4( vec3(newR,newG,newB), 1.0);',
    '}'
  ].join('\n')</pre>
			<p>We define<a id="_idIndexMarker1124"/> two instances of the <code>uniform</code> property, which can be used to configure this shader. The first one is what Three.js uses to pass in the current screen, and the second one is defined by us as an integer (<code>type:"i"</code>) and serves as the color depth that we want to render the result in. The code itself is very straightforward:</p>
			<ol>
				<li value="1">First, we get <code>texel</code> from the <code>tDiffuse</code> texture, based on the passed-in <code>vUv</code> location of the pixel.</li>
				<li>We calculate the number of colors that we can have, based on the <code>bitSize</code> property, by calculating 2 to the power of <code>bitSize</code> (<code>pow(float(bitSize),2.0))</code>).</li>
				<li>Next, we calculate the new value of the color of <code>texel</code> by multiplying this value by <code>n</code>, rounding it off (<code>floor(texel.r*n)</code>), and dividing it again by <code>n</code>.</li>
				<li>The result is set to <code>gl_FragColor</code> (red, green, and blue values and the opacity) and shown on the screen.</li>
			</ol>
			<p>You <a id="_idIndexMarker1125"/>can view the result for this custom shader in the same example as our previous custom shader, <code>custom-shaders-scene.html</code>. The following screenshot shows this example, where we set the bit size to 4. This means the model is rendered in only 16 colors:</p>
			<div><div><img src="img/Figure_11.28_B18726.jpg" alt="Figure 11.28 – A custom bit filter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.28 – A custom bit filter</p>
			<p>That’s it for this chapter on postprocessing.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/>Summary</h1>
			<p>We discussed many different postprocessing options in this chapter. As you saw, creating <code>EffectComposer</code> and chaining passes together is actually very easy. You just have to keep a few things in mind. Not all passes will have an output on the screen. If you want to output to the screen, you can always use <code>ShaderPass</code> with <code>CopyShader</code>. The sequence in which you add passes to a composer is important. The effects are applied in that sequence. If you want to reuse the result from a specific <code>EffectComposer</code> instance, you can do so by using <code>TexturePass</code>. When you have more than one <code>RenderPass</code> in your <code>EffectComposer</code>, make sure to set the <code>clear</code> property to <code>false</code>. If not, you’ll only see the output from the last <code>RenderPass</code> step. If you want to only apply an effect to a specific object, you can use <code>MaskPass</code>. When you’re done with the mask, clear the mask with <code>ClearMaskPass</code>. Besides the standard passes provided by Three.js, there are also many standard shaders available. You can use these together with <code>ShaderPass</code>. Creating custom shaders for postprocessing is very easy, using the standard approach from Three.js. You only have to create a fragment shader.</p>
			<p>We have now covered pretty much everything there is to know about the core of Three.js. In <a href="B18726_12.xhtml#_idTextAnchor212"><em class="italic">Chapter 12</em></a>, <em class="italic">Adding Physics and Sounds to Your Scene</em>, we’ll look at a library called Rapier.js, which you can use to extend Three.js with physics, in order to apply collisions, gravity, and constraints.</p>
		</div>
	</body></html>