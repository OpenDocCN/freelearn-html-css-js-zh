- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will explain in detail how to use all the asynchronous mechanisms
    that JavaScript offers today, including how to convert callbacks to promises and
    perform bulk asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: You will gain an in-depth understanding of all the tools at your disposal for
    managing both simple and complex asynchronous activities. We’ll begin with callbacks
    following Node.js Core conventions, then progress to effectively handling asynchronous
    operations using promises, and `async`/`await`. Toward the end of the chapter,
    we’ll employ the **Immediately Invoked Function Expression (IIFE)** pattern to
    execute asynchronous code. Additionally, we will provide a comprehensive overview
    of how to convert asynchronous operations between different handlers, including
    callbacks and promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding callbacks and how to avoid callback hell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `async` and `await` for handling asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/FHzqWr4dK7s](https://youtu.be/FHzqWr4dK7s)
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, asynchronous programming is a fundamental part of the language.
    It is the mechanism that allows us to perform operations in the background, without
    blocking the execution of the main thread. This is especially important in the
    browser, where the main thread is responsible for updating the user interface
    and responding to user actions.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, asynchronous programming is a complex topic that requires a lot of
    practice to master, but in my opinion, it requires a change in your mindset. You
    will need to start thinking about how to break down your code into small chunks
    that can be executed in the background, and how to combine them to achieve the
    desired result. You’ll encounter asynchronous programming regularly while coding
    with JavaScript. Most operations involving interactions with external resources,
    such as sending and receiving data from a server or a database and reading the
    content from a file, will necessitate its use.
  prefs: []
  type: TYPE_NORMAL
- en: Previous knowledge
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B21678_01.xhtml#_idTextAnchor015) we introduced the concept
    of the event loop, which is the mechanism that allows JavaScript to be asynchronous.
    In this chapter, we will see how to use this mechanism to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B21678_03.xhtml#_idTextAnchor056)*,* we learned how to use
    JavaScript in detail; this chapter requires a solid knowledge of functions and
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by exploring how asynchronous programming differs from conventional
    programming and how we need to adopt a different mindset.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses isomorphic JavaScript snippets, so the code can be executed
    in Node.js or in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous mindset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in mastering asynchronous programming is to change your mindset.
    You need to start thinking about your code in a non-linear way; you will think
    more about “what should happen next” rather than “what should happen first.”
  prefs: []
  type: TYPE_NORMAL
- en: When we learned about functions in [*Chapter 3*](B21678_03.xhtml#_idTextAnchor056),
    we saw that a function is *just* a piece of code that can be executed at any time.
    In this section, we will connect that piece of code to previous events, and to
    future events.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to perform asynchronous operations in JavaScript. In this
    chapter, we will focus on the most common ones, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Callbacks**: A callback is a function that is passed as an argument to another
    function, and it is executed when a certain event happens. This is the most basic
    way to perform asynchronous operations in JavaScript, and it is the foundation
    of all the other mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Promises**: ES6 introduced the concept of promises, which you can use to
    handle asynchronous operations in an advanced way because they use a state machine
    with several states (pending, fulfilled, and rejected) to keep track of operations.
    Promises have many advantages over callbacks in terms of readability, reusability,
    and overall simplicity. This is the most common way to perform asynchronous operations
    in modern JavaScript today. For more details, check out the *Mastering promises*
    section in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Async/await**: Async/await acts as a wrapper over promises to make code more
    readable (syntax sugar). Currently is the most popular way of handling asynchronous
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will explore how we can use callbacks effectively in
    our applications, the error first pattern, and other good practices to follow.
    Later on, we will explore how to wrap callbacks inside promises.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Callbacks exploit JavaScript’s capability to pass functions. There are two
    essential parts to this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: A function that is passed as an argument to another function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The passed function is executed when a certain event happens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s create a basic example to illustrate this concept. In the following code
    snippets, we will show how the callback is defined as an argument and how a function
    is passed as an argument when the execution occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will define a function (`doSomething`) that expects a function
    as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we have a function called `doSomething` that receives a function
    as an argument and executes it as the last step, this illustrates the idea that
    the callbacks are just a pattern where we expect that the next function to the
    executed is actually called as the final step (call me back when you are done
    - callback) . Let’s see how we can use this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the function is executed, the expected output will be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have a function called `nextStep` that is passed as an argument to `doSomething`.
    When `doSomething` is executed, it will print `Doing something...`, and then it
    will execute the function that was passed as an argument, which will print `Callback
    called` as the last step.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the function that is passed as an argument is
    not executed immediately , as we only want to execute them when the operation
    is complete. On the other hand, the immediate execution will require the use of
    parentheses (`doSomething(nextStep())`) and will produce a different result and
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass an anonymous function as an argument. This is the most common
    way to use callbacks, as we don’t need to define the functions previously. In
    most cases, we don’t reuse that function later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to pass a function that receives arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the callback technique is very simple, but we haven’t seen any
    asynchronous operations yet. At the end of the day, we assume that a callback
    is literally a “call me back when you are done” approach. Now, let’s see how this
    can be used to manage asynchronous operations with timers and intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Timers and intervals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two functions that are commonly used to delay the execution of a function,
    `setTimeout` and `setInterval`. Both functions receive a callback as an argument
    and execute it after a certain amount of time. Now, let’s define and use these
    functions in examples.
  prefs: []
  type: TYPE_NORMAL
- en: The `setTimeout` function is employed to defer the execution of a function by
    a specified amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how `setTimeout` works with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this code, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the callback is executed after the rest of the code, even though
    it was defined before. This is because the callback is executed asynchronously,
    which means that it is executed in the background, and the rest of the code is
    executed in the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `setTimeout` function receives two arguments. The first one is the callback,
    and the second one is the amount of time that the callback should be delayed.
    The amount of time is expressed in milliseconds, so in this case, we are delaying
    the execution of the callback by 1,000 milliseconds, which is 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: The `setInterval` function is used to execute a function repeatedly, with a
    fixed time delay between each execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how `setInterval` works with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this code, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the callback is executed every second, and it is executed in
    the background, so the rest of the code is executed in the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `setInterval` function receives two arguments. The first one is the callback,
    and the second one is the amount of time that the callback should be delayed.
    The amount of time is expressed in milliseconds, so in this case, we are delaying
    the execution of the callback by 1,000 milliseconds, which is 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: Error first callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples in the preceding sections, we saw how to use callbacks to manage
    asynchronous operations, but we didn’t see how to handle errors. In this section,
    we will see how to handle errors in callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to handle errors in callbacks is to use the error first
    pattern. This pattern consists of passing an error as the first argument of the
    callback, and the result as the second argument. Let’s see how this works with
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a function called `doSomething` that receives a callback
    as an argument. This callback receives two arguments. The first one is an error,
    and the second one is the result. In this case, we are passing an error as the
    first argument, and `null` as the second argument because an error occurred. When
    the callback is executed, we check if the first argument is an error, and if it
    is, we print `There was an error`. Otherwise, we print `Everything` `went well`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works when everything goes well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are passing `null` as the first argument as there is no error,
    and the result as the second argument. When the callback is executed, we check
    if the first argument is an error, and if it is, we print `There was an error`.
    Otherwise, we print the result, and `Everything` `went well`.
  prefs: []
  type: TYPE_NORMAL
- en: Callback hell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we saw how to use callbacks to manage asynchronous operations and
    how to handle errors with the error first pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with callbacks is that they are not very easy to read, and when
    we have a lot of nested callbacks, the code becomes very difficult to read. This
    is called callback hell, and it is a very common problem when using callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following pseudocode example, you can see how the functions are generated
    in an inclined pyramid with nested callbacks that make the code really hard to
    follow. In the following code example, observe how the functions are structured
    in an inclined pyramid with nested callbacks, making the code challenging to comprehend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is very difficult to read, and it is very easy to make
    mistakes. This is why we need a better way to manage asynchronous operations.
    There are some ways to prevent callback hell, such as using named functions instead
    of anonymous functions, but one of the most common ways to avoid callback hell
    is to use promises.
  prefs: []
  type: TYPE_NORMAL
- en: Promises are a great solution when you need to chain asynchronous operations,
    let’s explore it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A promise functions as a state machine, symbolizing the eventual success or
    failure of an asynchronous operation, along with its resultant value. It can exist
    in any of three states: pending, fulfilled, or rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: When a promise is created, it is in the pending state. When a promise is fulfilled,
    it is in the fulfilled state. When a promise is rejected, it is in the rejected
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the various states of a promise and the connections
    between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Attributions and copyright licensing by Mozilla Contributors
    is licensed under CC-BY-SA 2.5\. https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license](img/B21678_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Attributions and copyright licensing by Mozilla Contributors is
    licensed under CC-BY-SA 2.5\. [https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license](https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license)
  prefs: []
  type: TYPE_NORMAL
- en: After a promise is fulfilled or rejected, it becomes unchangeable. To manage
    fulfillment, the `then` method is employed, while the `catch` method is used to
    address the rejection of the promise.
  prefs: []
  type: TYPE_NORMAL
- en: Now that it is clear what the promises are and how the states are related, it
    is time to observe them in action. In the next section, we will explore how to
    use them and control any asynchronous flow effortlessly in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Using promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how this works with a simple example using `fetch` to make a request
    to an external **application programming interface** (**API**). This example will
    be using my simple-api project ([https://github.com/UlisesGascon/simple-api](https://github.com/UlisesGascon/simple-api)),
    which is available at [https://api.demo.foo/__/docs/](https://api.demo.foo/__/docs/)
    and is a fake online **Representational State Transfer** (**REST**) API for testing
    and fast prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the following code example, we will perform a network request and bring
    data to our application using the internet, as this operation requires network
    I/O, it is asynchronous, so we will need to use promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using the `fetch` function to make a request to the
    API. The function yields a promise, allowing us to employ the `then` method to
    manage successful fulfillment and the `catch` method to handle potential rejections.
    In this case, we are using the `then` method twice: the first time to parse the
    response as JSON, and the second time to print the result to the console. We are
    also using the `catch` method to print the error to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a promise using the `Promise` constructor, which receives a
    callback as an argument. This callback receives two arguments, `resolve` and `reject`.
    The `resolve` function is used to resolve the promise, and the `reject` function
    is used to reject the promise. Let’s see how this works with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a function called `setTimeoutPromise` that receives
    a `time` as an argument. This function returns a promise that will be resolved
    after the specified time. When the promise is resolved, we print `one second later`
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Callback hell with promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Promises are a great way to deal with the limitations that callbacks introduce
    when we need to perform multiple asynchronous operations that should be executed
    in a consecutive order.
  prefs: []
  type: TYPE_NORMAL
- en: Promises will handle errors more easily, so the readability of the code should
    be clearer and easier to maintain in long term.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we saw that callback hell is a very real thing in
    JavaScript. By now, you should be more familiar with the inclined pyramid and
    nested callbacks. Here is the snippet that we used to explain how Callback hell
    can be easily achieved in a previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see how we can solve this problem using promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is much easier to read, and it is much easier to make
    changes to. This is one of the main advantages of using promises. Now the errors
    are handled in the last `catch` method, so we don’t need to handle the errors
    in each `then` method, which makes the code much cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another advantage of using promises is that we can run multiple promises in
    parallel. Basically, we provide an array of promises and we choose a strategy
    to handle the results (`Promise.race()` or `Promise.all()`). This is a great way
    to reduce the execution time, as we are using Node.js’ abilities to manage I/O
    operations asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, we will use this function to generate a random timeout
    promise as an example of an asynchronous operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function will return a promise that will be resolved after a random time
    between 0 and 100 milliseconds. Now that we have an asynchronous function, we
    can employ various strategies to group multiple requests together based on our
    specific needs. In this instance, our goal is to initiate several requests in
    parallel and await their resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.all()`: The `all` method produces a singular promise that resolves
    once all the promises are resolved or if any of the promises are rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be something like this when all the promises are
    resolved successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `then` method will be called when all the promises are resolved,
    and it will receive an array with the results of each promise in the order they
    are being added in the promise array, not by the order in which they are resolved.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, all the promises were successfully resolved as they
    are based on timer operation. But when we relay on promises to access external
    resources like files in our system or fetching data from the Internet, then we
    need to take into account that these resources might not be always available.
    For example, if the Internet is down, then one or multiple promises can fail and
    this will make our application to crash. Obviously, this crashing situation can
    be avoided if we handle the errors using a `catch` statement, but even in that
    case, it is very important to remember that when we use this parallelism approach,
    we need to take into account that if a single promise generates an error, the
    resolved ones will be ignored just the same as if we were using a single promise.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach to `Promise.all()` is to aggregate all the requests
    but resolve the promise as soon as the first one is complete. This way, there’s
    no need to wait for the fulfillment of all requests.
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.race()`: The `race` method returns a single promise that is fulfilled
    or rejected as soon as one of the promises gets fulfilled or rejected. This can
    lead to unexpected results if not carefully managed, as the promises won’t stop
    running even if one of the promises was rejected or fulfilled already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `then` method will be called when the first promise is resolved,
    and it will receive the result of the first promise that is resolved. The other
    promises will continue running, but the `then` method will not be called again.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we saw how to handle errors using the `catch` method,
    but there is another way to handle errors: using the `reject` function. Let’s
    see how this works with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to notice that the `reject` function will not stop the execution
    of the code, so we need to `return` the function after calling the `reject` function.
  prefs: []
  type: TYPE_NORMAL
- en: The final approach is when we need to perform an action once a promise has been
    concluded, regardless of whether it was successful or rejected. It is important
    to remember that unhandled promise rejections can lead to runtime errors that
    will crash your application. We will learn more about this in [*Chapter 15*](B21678_15.xhtml#_idTextAnchor394).
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.finally()`: Sometimes, we don’t care if the promise is resolved or
    rejected; we just want to know when the promise has been resolved or rejected.
    For this case, we can use the `finally` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Chaining promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also chain promises; we can return a promise in the `then` method, and
    this promise will be resolved before calling the next `then` method. The `catch`
    method will be called if any of the promises in the chain are rejected. Let’s
    see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When the third `generatePromise` is called, it will return a promise that will
    be rejected, so the `catch` method will be called and then the last `then` won’t
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: We have been utilizing promises for some time, and the syntax can be quite verbose,
    requiring keywords such as `then` and `catch` consistently. A more advanced and
    aesthetically pleasing syntax involves using `async` and `await`. We will delve
    into this approach in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using async and await to handle asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES2017 introduced a new way to handle asynchronous code, the `async` and `await`
    keywords. These keywords are syntactic sugar for promises; they are not a new
    way to handle asynchronous code, but they make the code much easier to read and
    write.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the `async` keyword is employed to define an asynchronous function,
    while the `await` keyword is used to pause and await the resolution of a promise
    within that function. Even if you use the word `async` it doesn’t make you code
    asynchronously, that will only occur when you actually have asynchronous code
    on it (a promise). To make it more simple, we can say that in order to use `await`,
    we need to define the code block using `async`. Let’s explore more in detail how
    we can use `async`.
  prefs: []
  type: TYPE_NORMAL
- en: async
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a function is defined with the `async` keyword, it will always return
    a promise that can be handled as any regular promise. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is syntactic sugar for promises, we can build a similar function using
    promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s acquaint ourselves with `await`; we’ll be able to seamlessly combine
    both keywords and eliminate the need to use `then` or `catch`.
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how we can use the `await` keyword in order to wait for promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is much easier to read and write using `async` and
    `await`. The `await` keyword can only be used inside an `async` function. We need
    to use the `try`/`catch` block to handle the errors.
  prefs: []
  type: TYPE_NORMAL
- en: '`try`/`catch` is a mechanism provided by JavaScript that allows us to encapsulate
    certain code inside the `try` block, and handle any possible errors with the `catch`
    block. So, in the previous example, as we are doing an HTTP request we depend
    on external factors such as connectivity to the internet or the ability of the
    external server to return the information that we are asking for in our request.
    In our specific case, we are “silently failing” this error because in the `catch`
    block we only print the information about the error, but in other scenarios we
    might show an alert message in the UI or trigger a retry strategy to try to perform
    this HTTP request again. It is important to remember that If we don’t handle errors
    properly, our application might crash. We will explore this topic in detail in
    [*Chapter 15*](B21678_15.xhtml#_idTextAnchor394).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore how we can blend `async` to employ this syntactic sugar even
    in older Node.js versions.
  prefs: []
  type: TYPE_NORMAL
- en: IIFEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, we want to use the `await` keyword outside an `async` function,
    for example, when we are using the `await` keyword in the top level of a module.
    In this case, we can use an IIFE to wrap the `await` keyword inside an `async`
    function. An IIFE is a function that is executed immediately after it is created.
    It is a design pattern that is used to avoid polluting the global scope with variables
    and functions. In the subsequent example, we can observe the fundamental syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is to create an anonymous function and execute it immediately after
    it is created. In order to achieve this, we need to wrap the function between
    parentheses, and then add another pair of parentheses to execute the function:
    `(...)()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `async` and `await` inside an IIFE easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This guarantees that the code will be executed immediately after it is created,
    and we can use the `await` keyword inside the IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about asynchronous programming in JavaScript. We
    explored asynchronous APIs such as `setTimeout` and `fetch`, and we learned how
    to handle asynchronous code using callbacks, promises, and `async`/`await`. Additionally,
    we learned about the error first callback convention and how to prevent callback
    hell using named functions and promises. Finally, we learned how to manage promises,
    how to bulk operations using the `Promise.all` and `Promise.race` methods, and
    how to use the `async` and `await` keywords to handle asynchronous code in a cleaner
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about HTTP and how the modern web works using
    REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asynchronous programming in JavaScript is a broad topic that necessitates a
    considerable amount of time to master and comprehend fully. With the following
    links, you will discover valuable resources that will aid you in delving deeper
    into the subjects covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*JavaScript Promise in 100* *Seconds*: [https://www.youtube.com/watch?v=RvYYCGs45L4](https://www.youtube.com/watch?v=RvYYCGs45L4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Asynchrony: Under the Hood – Shelley Vohr – JSConf* *EU*: [https://www.youtube.com/watch?v=SrNQS8J67zc](https://www.youtube.com/watch?v=SrNQS8J67zc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*async/await in JavaScript – What, Why and How – Fun Fun* *Function:* [https://www.youtube.com/watch?v=568g8hxJJp4](https://www.youtube.com/watch?v=568g8hxJJp4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Node.js Ecosystem and Architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 2*, you will learn how to use the Node.js core libraries and third-party
    libraries by using the vast npm ecosystem ecosystem. Also, you will learn how
    to use and implement event-driven architectures in detail, and you will understand
    how to use testing and implement unit testing in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21678_05.xhtml#_idTextAnchor156), *Node.js Core Libraries*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21678_06.xhtml#_idTextAnchor171), *External Modules and npm*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21678_07.xhtml#_idTextAnchor206), *Event-Driven Architecture*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21678_08.xhtml#_idTextAnchor218), *Testing in Node.js*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
