- en: 3 Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 数组
- en: '**Before you begin: Join our book community on Discord**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**在开始之前：加入我们的 Discord 书籍社区**'
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY
    ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“学习 JavaScript 数据结构与算法”第四版下的“EARLY
    ACCESS SUBSCRIPTION”中找到“learning-javascript-dsa-4e”频道）。
- en: '![](img/file0.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess/](https://packt.link/EarlyAccess/)'
- en: An **array** is the simplest memory data structure. For this reason, all programming
    languages have a built-in array datatype. JavaScript also supports arrays natively,
    even though its first version was released without array support. In this chapter,
    we will dive into the array data structure and its capabilities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是最简单的内存数据结构。因此，所有编程语言都有内置的数组数据类型。JavaScript 也原生支持数组，尽管它的第一个版本发布时没有数组支持。在本章中，我们将深入研究数组数据结构和其功能。'
- en: An array stores values sequentially that are all the same datatype. Although
    JavaScript allows us to create arrays with values from different datatypes, we
    will follow best practices and assume that we cannot do this (most languages do
    not have this capability).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数组按顺序存储相同数据类型的值。尽管 JavaScript 允许我们创建包含不同数据类型值的数组，但我们将遵循最佳实践，并假设我们无法这样做（大多数语言都没有这种功能）。
- en: Why should we use arrays?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们应该使用数组？
- en: 'Let''s consider that we need to store the average temperature of each month
    of the year of the city that we live in. We could use something like the following
    code snippet to store this information:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们需要存储我们居住的城市每年每个月的平均温度。我们可以使用以下代码片段来存储这些信息：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, this is not the best approach. If we store the temperature for only
    one year, we could manage 12 variables. However, what if we need to store the
    average temperature for 50 years? Fortunately, this is why arrays were created,
    and we can easily represent the same information mentioned earlier as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是最佳方法。如果我们只存储一年的温度，我们可以管理 12 个变量。但是，如果我们需要存储 50 年的平均温度怎么办？幸运的是，这就是数组被创建的原因，我们可以轻松地用以下方式表示之前提到的相同信息：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also represent the `averageTemp` array graphically:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用图形表示 `averageTemp` 数组：
- en: '![Figure 3.1:](img/file9.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：](img/file9.png)'
- en: 'Figure 3.1:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：
- en: Creating and initializing arrays
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和初始化数组
- en: 'Declaring, creating, and initializing an array in JavaScript is straightforward,
    as shown in the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中声明、创建和初始化数组很简单，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以：
- en: 'Line `{1}`: declare and instantiate a new array using the keyword `new` – this
    will create an empty array.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 `{1}`：使用关键字 `new` 声明并实例化一个新的数组——这将创建一个空数组。
- en: 'Line `{2}`: create an empty array specifying the *length* of the array (how
    many elements we are planning to store in the array).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 `{2}`：指定数组的 *长度*（我们计划在数组中存储多少个元素）来创建一个空数组。
- en: 'Line `{3}`: create and initialize the array, passing the elements directly
    in the constructor.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 `{3}`：通过在构造函数中直接传递元素来创建和初始化数组。
- en: 'Line `{4}`: create an empty array assigning empty brackets (`[]`). Using the
    keyword `new` is not considered a best practice, therefore, using brackets is
    the preferred way.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 `{4}`：通过分配空括号（`[]`）创建一个空数组。使用关键字 `new` 并不是最佳实践，因此使用括号是首选方式。
- en: 'Line `{5}`: create and initialize the array using brackets as a best practice.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行 `{5}`：使用括号作为最佳实践创建和初始化数组。
- en: 'If we want to know how many elements are in the array (its size), we can use
    the `length` property. The following code will give an output of `7`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道数组中有多少个元素（其大小），我们可以使用 `length` 属性。以下代码将输出 `7`：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Accessing elements and iterating an array
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问元素和迭代数组
- en: 'To access a specific position of the array, we can also use brackets, passing
    the index of the position we would like to access. For example, let''s say we
    want to output all the elements from the `daysOfWeek` array. To do so, we need
    to loop the array and print the elements, starting from index 0 as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组的特定位置，我们也可以使用括号，传递我们想要访问的位置的索引。例如，假设我们想要输出 `daysOfWeek` 数组中的所有元素。为此，我们需要循环数组并打印元素，从索引
    0 开始如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s look at another example. Suppose that we want to find out the first
    20 numbers of the *Fibonacci* sequence. The first two numbers of the Fibonacci
    sequence are 1 and 2, and each subsequent number is the sum of the previous two
    numbers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。假设我们想找出斐波那契数列的前 20 个数字。斐波那契数列的前两个数字是 1 和 2，每个后续数字都是前两个数字的和：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the explanation for the preceding code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是对前面代码的解释：
- en: In line `{1}`, we declared and created an array.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在行 `{1}` 中，我们声明并创建了一个数组。
- en: In lines `{2}` and `{3}`, we assigned the first two numbers of the Fibonacci
    sequence to the second and third positions of the array (in JavaScript, the first
    position of the array is always referenced by 0 (zero), and since as there is
    no zero in the Fibonacci sequence, we will skip it).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在行 `{2}` 和 `{3}` 中，我们将斐波那契数列的前两个数字赋给了数组的第二个和第三个位置（在 JavaScript 中，数组的第一个位置始终通过
    0（零）引用，由于斐波那契数列中没有零，我们将跳过它）。
- en: Then, all we need to do is create the third to the 20th number of the sequence
    (as we know the first two numbers already). To do so, we can use a loop and assign
    the sum of the previous two positions of the array to the current position (line `{4}`,
    starting from index 3 of the array to the 19th index).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需要创建序列的第 3 到第 20 个数字（因为我们已经知道了前两个数字）。为此，我们可以使用循环并将数组前两个位置的值之和赋给当前位置（从数组的索引
    3 开始到第 19 个索引，行 `{4}`）。
- en: Then, to take a look at the output (line `{6}`), we just need to loop the array
    from its first position to its length (line `{5}`).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了查看输出（行 `{6}`），我们只需要从数组的第一个位置循环到其长度（行 `{5}`）。
- en: We can use `console.log` to output each index of the array (lines `{5}` and `{6}`),
    or we can also use `console.log(fibonacci)` to output the array itself.
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以使用 `console.log` 输出数组的每个索引（行 `{5}` 和 `{6}`），或者我们也可以使用 `console.log(fibonacci)`
    输出数组本身。
- en: If you would like to generate more than 20 numbers of the Fibonacci sequence,
    just change the number 20 to whatever number you like.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要生成超过 20 个斐波那契数列的数字，只需将数字 20 改为你想要的任何数字。
- en: Using the for..in loop
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 for..in 循环
- en: The benefit of using the `for..in` loop, is we do not have to keep track of
    the length of the array, as the loop will iterate through all the array indexes.
    The following code achieves the same output as the previous `for` loop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for..in` 循环的好处是，我们不需要跟踪数组长度，因为循环将遍历所有数组索引。以下代码实现了与前面的 `for` 循环相同的输出。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is another way to write the loop, and you can use the one you feel most comfortable
    with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种编写循环的另一种方式，你可以使用你感觉最舒服的一种。
- en: Using the for…of loop
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 for…of 循环
- en: 'Another approach, in case you would like to directly extract the values of
    the array, is to use the `for..of` loop as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，如果你想要直接提取数组的值，可以使用以下 `for..of` 循环：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this loop, we do not need to access each index of the array to retrieve
    the value, as the value present in each position can be accessed directly in the
    loop.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个循环，我们不需要访问数组中的每个索引来检索值，因为每个位置上的值可以直接在循环中访问。
- en: Adding elements
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加元素
- en: 'Adding and removing elements from an array is not that difficult; however,
    it can be tricky. For the examples we will create in this section, let''s consider
    that we have the following numbers array initialized with numbers from 0 to 9:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 向数组中添加和删除元素并不那么困难；然而，它可能有点棘手。对于本节中我们将创建的示例，让我们假设我们有一个初始化了从 0 到 9 的数字的数组：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Inserting an element at the end of the array
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在数组的末尾插入一个元素
- en: 'If we want to add a new element to this array (for example, the number 10),
    all we have to do is reference the last free position of the array and assign
    a value to it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向这个数组中添加一个新元素（例如，数字 10），我们只需要引用数组的最后一个空闲位置并将其赋值：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In JavaScript, an array is a mutable object. We can easily add new elements
    to it. The object will grow dynamically as we add new elements to it. In many
    other languages, such as C and Java, we need to determine the size of the array,
    and if we need to add more elements to the array, we need to create a completely
    new array; we cannot simply add new elements to it as we need them.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，数组是一个可变对象。我们可以很容易地向其中添加新元素。随着我们添加新元素，对象会动态增长。在许多其他语言中，例如 C 和
    Java，我们需要确定数组的大小，如果我们需要向数组中添加更多元素，我们需要创建一个全新的数组；我们不能简单地按需添加新元素。
- en: Using the push method
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 push 方法
- en: 'The JavaScript API also has a method called `push` that allows us to add new
    elements to the end of an array. We can add as many elements as we want as arguments
    to the push method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript API 还有一个名为 `push` 的方法，允许我们将新元素添加到数组的末尾。我们可以将任意数量的元素作为参数传递给 `push`
    方法：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output of the numbers array will be the numbers from 0 to 13.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数字数组的输出将是从 0 到 13 的数字。
- en: Inserting an element in the first position
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在第一个位置插入元素
- en: 'Suppose we need to add a new element to the array (the number `-1`) and would
    like to insert it in the first position, not the last one. To do so, first we
    need to free the first position by shifting all the elements to the right. We
    can loop all the elements of the array, starting from the last position (value
    of `length` will be the end of the array) and shifting the previous element (`i-1`)
    to the new position (`i`) to finally assign the new value we want to the first
    position (index 0). We can create a function to represent this logic or even add
    a new method directly to the Array prototype, making the `insertAtBeginning` method
    available to all array instances. The following code represents the logic described
    here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要向数组添加一个新元素（数字 `-1`）并希望将其插入到第一个位置，而不是最后一个位置。要做到这一点，首先我们需要通过将所有元素向右移动来释放第一个位置。我们可以遍历数组的所有元素，从最后一个位置（`length`
    的值将是数组的末尾）开始，将前一个元素（`i-1`）移动到新位置（`i`），最后将我们想要的新值赋给第一个位置（索引 0）。我们可以创建一个函数来表示这个逻辑，甚至可以直接添加一个新方法到
    Array 原型中，使得 `insertAtBeginning` 方法对所有数组实例都可用。以下代码表示了这里描述的逻辑：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can represent this action with the following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下图表来表示这个动作：
- en: '![Figure 3.2:](img/file10.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：](img/file10.png)'
- en: 'Figure 3.2:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：
- en: Using the unshift method
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 unshift 方法
- en: 'The JavaScript Array class also has a method called `unshift`, which inserts
    the values passed in the method''s arguments at the start of the array (the logic
    behind-the-scenes has the same behavior as the `insertAtBeginning` method):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 数组类还有一个名为 `unshift` 的方法，它将方法参数中传递的值插入到数组的开头（幕后逻辑与 `insertAtBeginning`
    方法的行为相同）：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, using the `unshift` method, we can add the value -2 and then -3 and -4 to
    the beginning of the `numbers` array. The output of this array will be the numbers
    from -4 to 13.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `unshift` 方法，我们可以将值 -2 然后是 -3 和 -4 添加到 `numbers` 数组的开头。这个数组的输出将是从 -4 到
    13 的数字。
- en: Removing elements
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除元素
- en: So far, you have learned how to add elements in the array. Let's look at how
    we can remove a value from an array.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何在数组中添加元素。让我们看看我们如何从数组中移除一个值。
- en: Removing an element from the end of the array
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数组末尾移除元素
- en: 'To remove a value from the end of an array, we can use the pop method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组的末尾移除一个值，我们可以使用 `pop` 方法：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `pop` method also returns the value that is being removed and it returns
    `undefined` in case no element is being removed (the array is empty). So, if needed,
    we can also capture the value that is being returned into a variable or into the
    console instead:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 方法也会返回被移除的值，如果没有元素被移除（数组为空），则返回 `undefined`。因此，如果需要，我们也可以将返回的值捕获到变量或控制台中：'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output of our array will be the numbers from -4 to 12 (after removing one
    number). The length (size) of our array is 17.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数组的输出将是从 -4 到 12 的数字（移除一个数字后）。我们数组的长度（大小）是 17。
- en: The `push` and `pop` methods allow an array to emulate a basic `stack` data
    structure, which is the subject of the next chapter.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`push` 和 `pop` 方法允许数组模拟基本的 `栈` 数据结构，这是下一章的主题。'
- en: Removing an element from the first position
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从第一个位置移除元素
- en: 'To manually remove a value from the beginning of the array, we can use the
    following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动从数组的开头移除一个值，我们可以使用以下代码：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can represent the previous code using the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下图表来表示前面的代码：
- en: '![Figure 3.3:](img/file11.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：](img/file11.png)'
- en: 'Figure 3.3:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：
- en: We shifted all the elements one position to the left. However, the length of
    the array is still the same (`16`), meaning we still have an extra element in
    our array (with an `undefined` value). The last time the code inside the loop
    was executed, `i+1` was a reference to a position that does not exist. In some
    languages, such as Java, C/C++, or C#, the code would throw an exception, and
    we would have to end our loop at `numbers.length -1`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有元素向左移动了一个位置。然而，数组的长度仍然是相同的（`16`），这意味着我们仍然在数组中有一个额外的元素（具有 `undefined` 值）。最后一次代码在循环中执行时，`i+1`
    是一个引用不存在位置的引用。在某些语言中，例如 Java、C/C++ 或 C#，代码将抛出异常，并且我们必须在 `numbers.length -1` 处结束我们的循环。
- en: We have only overwritten the array's original values, and we did not really
    remove the value (as the length of the array is still the same and we have this
    extra `undefined` element).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是覆盖了数组的原始值，并没有真正删除值（因为数组的长度仍然是相同的，并且我们有一个额外的 `undefined` 元素）。
- en: 'To remove the value from the array, we can also create a `removeFromBeginning`
    method with the logic described in this topic. However, to really remove the element
    from the array, we need to create a new array and copy all values other than `undefined`
    values from the original array to the new one and assign the new array to our
    variable. To do so, we can also create a `reIndex` method as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组中删除值，我们还可以创建一个 `removeFromBeginning` 方法，其中包含本主题中描述的逻辑。然而，要真正从数组中删除元素，我们需要创建一个新的数组，并将原始数组中除
    `undefined` 值之外的所有值复制到新数组中，并将新数组赋值给我们的变量。为此，我们还可以创建一个 `reIndex` 方法，如下所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code should be used only for educational purposes and should not
    be used in real projects. To remove the first element from the array, we should
    always use the `shift` method, which is presented in the next section.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 前面的代码仅用于教育目的，不应在实际项目中使用。要删除数组中的第一个元素，我们应该始终使用下一节中介绍的 `shift` 方法。
- en: Using the shift method
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 shift 方法
- en: 'To remove an element from the beginning of the array, we can use the shift method,
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组的开头删除元素，我们可以使用 `shift` 方法，如下所示：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we consider that our array has the values -4 to 12 and a length of 17 after
    we execute the previous code, the array will contain the values -3 to 12 and have
    a length of 16.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在执行前面的代码后认为我们的数组具有从 -4 到 12 的值和 17 的长度，那么数组将包含从 -3 到 12 的值，并且长度为 16。
- en: The `shift` and `unshift` methods allow an array to emulate a basic `queue`
    data structure, which is the subject of *Chapter 5, Queues and Deques.*
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`shift` 和 `unshift` 方法允许数组模拟基本的 `队列` 数据结构，这是 *第 5 章，队列和双端队列* 的主题。'
- en: Adding and removing elements from a specific position
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从特定位置添加和删除元素
- en: So far, we have learned how to add elements at the end and at the beginning
    of an array, and we have also learned how to remove elements from the beginning
    and end of an array. What if we also want to add or remove elements from any position
    in our array? How can we do this?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何在数组的末尾和开头添加元素，我们也学习了如何从数组的开头和末尾删除元素。如果我们还想从数组的任何位置添加或删除元素怎么办？我们如何做到这一点？
- en: 'We can use the `splice` method to remove an element from an array by specifying
    the position/index that we would like to delete from and how many elements we
    would like to remove, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `splice` 方法通过指定我们想要从其中删除的位置/索引以及我们想要删除多少个元素来从数组中删除一个元素，如下所示：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code will remove three elements, starting from index `5` of our array.
    This means the elements `numbers[5]`, `numbers[6]`, and `numbers[7]` will be removed
    from the numbers array. The content of our array will be `-3, -2, -1, 0, 1, 5,
    6, 7, 8, 9, 10, 11`, and `12` (as the numbers `2`, `3`, and `4` have been removed).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将从数组的 `5` 个索引处开始删除三个元素。这意味着 `numbers[5]`、`numbers[6]` 和 `numbers[7]` 将从 `numbers`
    数组中删除。我们的数组内容将是 `-3, -2, -1, 0, 1, 5, 6, 7, 8, 9, 10, 11` 和 `12`（因为数字 `2`、`3`
    和 `4` 已被删除）。
- en: As with JavaScript arrays and objects, we can also use the `delete` operator
    to remove an element from the array, for example, `delete numbers[0]`. However,
    position `0` of the array will have the value `undefined`, meaning that it would
    be the same as doing `numbers[0] = undefined` and we would need to re-index the
    array. For this reason, we should always use the `splice`, `pop`, or `shift` methods
    to remove elements.
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与 JavaScript 数组和对象一样，我们也可以使用 `delete` 操作符从数组中删除一个元素，例如，`delete numbers[0]`。然而，数组的
    `0` 位置将具有 `undefined` 的值，这意味着它将与执行 `numbers[0] = undefined` 相同，并且我们需要重新索引数组。因此，我们应该始终使用
    `splice`、`pop` 或 `shift` 方法来删除元素。
- en: 'Now, let''s say we want to insert numbers 2, 3 and 4 back into the array, starting
    from position 5\. We can again use the splice method to do this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想从位置5开始将数字2、3和4插入数组中。我们可以再次使用splice方法来完成这个操作：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first argument of the method is the index we want to remove elements from
    or insert elements into. The second argument is the number of elements we want
    to remove (in this case, we do not want to remove any, so we will pass the value
    0 (zero)). And from the third argument onward we have the values we would like
    to insert into the array (the elements 2, 3, and 4). The output will be values
    from -3 to 12 again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的第一参数是我们想要从中删除元素或插入元素的位置索引。第二个参数是我们想要删除的元素数量（在这种情况下，我们不想删除任何元素，所以我们将传递值0（零））。从第三个参数开始，我们有我们想要插入到数组中的值（元素2、3和4）。输出将再次是-3到12的值。
- en: 'Finally, let''s execute the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们执行以下代码：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output will be values from -3 to 12\. This is because we are removing three
    elements, starting from the index 5, and we are also adding the elements 2, 3,
    and 4, starting at index 5.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是从-3到12的值。这是因为我们从索引5开始删除了三个元素，并且我们也在索引5处添加了元素2、3和4。
- en: Iterator methods
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器方法
- en: JavaScript also has some built in methods as part of the Array API that are
    extremely useful in the day-to-day coding tasks. These methods accept a callback
    function that we can use to manipulate the data in the array as needed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript也有一些内置方法作为Array API的一部分，这些方法在日常编码任务中非常有用。这些方法接受一个回调函数，我们可以使用它来根据需要操作数组中的数据。
- en: 'Let''s look at these methods. Consider the following array used as a base for
    the examples in this section:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些方法。考虑以下数组作为本节示例的基础：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Iterating using the forEach method
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用forEach方法迭代
- en: 'If we need the array to be completely iterated no matter what, we can use the
    `forEach` function. It has the same result as using a `for` loop with the function''s
    code inside it, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要无论什么情况都要完全迭代数组，我们可以使用`forEach`函数。它具有与在`for`循环中包含函数代码相同的输出，如下所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Most of the times, we are only interested in using the value coming from each
    position of the array, without having to access each position as the preceding
    example. Following is a more concise example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们只对使用数组每个位置的值感兴趣，而不必像前面的例子那样访问每个位置。以下是一个更简洁的例子：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Depending on personal preference you can use this method or the traditional
    `for` loop. Performance wise, both approaches are *O(n)*, meaning linear time,
    as it will iterate through all the values of the array.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据个人喜好，你可以使用这个方法或传统的`for`循环。在性能方面，两种方法都是*O(n)*，即线性时间，因为它将遍历数组的所有值。
- en: Iterating using the every method
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用every方法迭代
- en: 'The `every` method iterates each element of the array until the function returns
    `false`. Let''s see an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`every`方法迭代数组的每个元素，直到函数返回`false`。让我们看看一个例子：'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The method will iterate through every value within the array until it finds
    a value equal or bigger than 7\. For the preceding example, it returns `false`
    as we have the value 7 within our array of numbers. If we did not have values
    bigger or equal to 7, the variable `isBelowSeven` would have the value `true`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将遍历数组中的每个值，直到找到一个等于或大于7的值。对于前面的例子，它返回`false`，因为我们数组中有7这个值。如果我们没有大于或等于7的值，变量`isBelowSeven`将具有`true`的值。
- en: 'We can rewrite this example using a for loop to understand how it works internally:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for循环重写这个例子，以了解其内部工作原理：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `break` statement will stop the loop at the moment that a value equal or
    bigger to 7 is found.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句将在找到等于或大于7的值时停止循环。'
- en: By using the `every` method, we can have more concise code to achieve the same
    result.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`every`方法，我们可以编写更简洁的代码以实现相同的结果。
- en: Iterating using the some method
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用some方法迭代
- en: 'The `some` method has the opposite behavior to the `every` method. However,
    the `some` method iterates each element of the array until the return of the function
    is `true`. Here''s an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`some`方法与`every`方法的行为相反。然而，`some`方法会迭代数组的每个元素，直到函数返回`true`。以下是一个例子：'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the first number of the array is 1, and it will return true
    right away, stopping the execution of the code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数组的第一个数字是1，它将立即返回true，停止代码的执行。
- en: 'We can rewrite the preceding code using a for loop `for` better understanding
    of the logic:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for循环`for`重写前面的代码，以更好地理解逻辑：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Searching an array
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索数组
- en: The JavaScript API provides a few different methods we can use to search or
    find elements in an array. Although we will learn how to re-create classic algorithms
    to search elements in *Chapter 15, Searching and Shuffling Algorithms*, it is
    always good to know we can use existing APIs without having to write the code
    ourselves.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript API提供了一些不同的方法，我们可以使用它们在数组中搜索或查找元素。尽管我们将学习如何重新创建经典算法来搜索数组中的元素，但在*第15章，搜索和洗牌算法*中，了解我们可以使用现有的API而不必自己编写代码总是好的。
- en: Let's take a look at the existing JavaScript methods that allows us to search
    elements in an array.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现有的JavaScript方法，这些方法允许我们在数组中搜索元素。
- en: Searching with indexOf, lastIndexOf and includes methods
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`indexOf`、`lastIndexOf`和`includes`方法进行搜索
- en: 'The methods `indexOf`, `lastIndexOf` and `includes` have a very similar sintax
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`、`lastIndexOf`和`includes`方法有非常相似的语法如下：'
- en: '`indexOf(element, fromIndex)`: searches for the `element` starting from the
    index `fromIndex`, and in case the element exists, returns its index, otherwise
    returns the value `-1`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(element, fromIndex)`：从索引`fromIndex`开始搜索`element`，如果元素存在，则返回其索引，否则返回值`-1`。'
- en: '`includes(element, fromIndex)`: searches for the `element` starting from the
    index `fromIndex`, and in case the element exists, returns `true`, otherwise returns
    `false`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`includes(element, fromIndex)`：从索引`fromIndex`开始搜索`element`，如果元素存在，则返回`true`，否则返回`false`。'
- en: 'If we try to search for a number in our `numbers` array, let''s check if the
    number 5 exists:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在我们的`numbers`数组中搜索一个数字，让我们检查数字5是否存在：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we would like to search in the entire array, we can omit the `fromIndex`,
    and by default, the index 0 will be used.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在整个数组中进行搜索，我们可以省略`fromIndex`，默认情况下将使用索引0。
- en: 'The `lastIndexOf` is similar as well, however, it will return the index of
    the last element found that matches the element we are searching. Think about
    it as a search from the end of the array towards the beginning of the array instead:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastIndexOf`也是类似的，但是它会返回找到的最后一个匹配元素的索引。把它想象成从数组的末尾向数组开头搜索：'
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method is useful when we have duplicate elements in the array.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组中有重复元素时，此方法很有用。
- en: Searching with find, findIndex and findLastIndex methods
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`find`、`findIndex`和`findLastIndex`方法进行搜索
- en: In real world tasks, we often work with more complex objects. The `find` and
    `findIndex` methods are especially useful for more complex scenarios, but it does
    not mean we cannot use them for simpler cases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的任务中，我们经常处理更复杂的对象。`find`和`findIndex`方法对于更复杂的场景特别有用，但这并不意味着我们不能在更简单的情况下使用它们。
- en: 'Both `find` and `findIndex` methods receive a callback function that will search
    for an element that satisfies the condition presented in the testing function
    (callback). Let''s start with a simple example: suppose you want to find the first
    number in the array that has a value below 7\. We can use the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`和`findIndex`方法都接收一个回调函数，该函数将搜索满足测试函数（回调）中提出的条件的元素。让我们从一个简单的例子开始：假设你想要找到数组中第一个值低于7的数字。我们可以使用以下代码：'
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are using a callback function that is an arrow function to test every element
    of the array (`value < 7`), and the first element that returns `true` will be
    returned. That is why the output is `1`, as it is the first element of the array.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个回调函数，即箭头函数来测试数组的每个元素（`value < 7`），并且第一个返回`true`的元素将被返回。这就是为什么输出是`1`，因为它是数组的第一个元素。
- en: 'The `findIndex` method is similar, however it will return the index of the
    element instead of the element itself:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`findIndex`方法类似，但是它将返回元素的索引而不是元素本身：'
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Likewise, there is also a findLastIndex method, which will return the last
    index of the element that matches the callback function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还有一个`findLastIndex`方法，它将返回匹配回调函数的元素的最后一个索引。
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, the index 5 is returned because the number 6 is the
    last element in the array lower than 7.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，返回索引5是因为数字6是数组中低于7的最后一个元素。
- en: 'Now let''s check a more complex example, closer to real life. Consider the
    following array, a collection of books:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一个更复杂的例子，更接近现实生活。考虑以下数组，一组书籍：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we need to find the book with `id` 2, we can use the find method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要查找`id`为2的书籍，我们可以使用`find`方法：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It will output `{ id: 2, title: ''Fourth Wing'' }`. If we try to find the book
    "The Hobbit," we will get the output undefined, because this book is not present
    in the array:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '它将输出`{ id: 2, title: ''Fourth Wing'' }`。如果我们尝试找到《霍比特人》这本书，我们将得到输出`undefined`，因为这本书不在数组中：'
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Suppose we would like to remove the book with `id` 3 from our array. We can
    find the index of the book first, and then use the method `splice` to remove the
    book in the given index:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从数组中移除`id`为3的书籍。我们首先找到书籍的索引，然后使用`splice`方法在给定索引处移除书籍：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And of course, it is always good to check if the book was found first (the `bookIndex`
    is different than -1) before trying to remove the book from the list to avoid
    any errors in our logic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在尝试从列表中移除书籍之前，先检查书籍是否被找到（`bookIndex`不等于-1）是一个好习惯，以避免逻辑错误。
- en: Filtering elements
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤元素
- en: 'Let''s revisit the following example one more time:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾以下示例：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `find` method returns the first element that matches the given condition.
    What if we would like to know all elements below 7 in the array? That is when
    the `filter` method comes in handy:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`方法返回第一个符合给定条件的元素。如果我们想了解数组中小于7的所有元素怎么办？这时`filter`方法就派上用场了：'
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `filter` method returns an array of all matching elements, and the output
    will be: `[1, 2, 3, 4, 5, 6]`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法返回所有匹配元素的数组，输出将是：`[1, 2, 3, 4, 5, 6]`。'
- en: Sorting elements
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序元素
- en: Throughout this book, you will learn how to write the most used sorting algorithms.
    However, JavaScript also has a sorting method available which we can use without
    having to write our own logic whenever we need to sort arrays.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将学习如何编写最常用的排序算法。然而，JavaScript也提供了一个排序方法，我们可以在需要排序数组时使用，而无需编写自己的逻辑。
- en: 'First, let''s take our numbers array and put the elements out of order (`[1,
    2, 3, ... 10]` is already sorted). To do this, we can apply the `reverse` method,
    in which the last item will be the first and vice versa, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们取我们的数字数组并将元素顺序打乱（`[1, 2, 3, ... 10]`已经是排序好的）。为此，我们可以应用`reverse`方法，其中最后一个元素将成为第一个，反之亦然，如下所示：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So now, the output for the numbers array will be [`10, 9, 8, 7, 6, 5, 4, 3,
    2, 1`]. Then, we can apply the sort method as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在数字数组的输出将是`[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`。然后，我们可以应用排序方法，如下所示：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: However, if we output the array, the result will be [`1, 10, 2, 3, 4, 5, 6,
    7, 8, 9`]. This is not ordered correctly. This is because the `sort` method in
    JavaScript sorts the elements *lexicographically*, and it assumes all the elements
    are *strings*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们输出数组，结果将是`[1, 10, 2, 3, 4, 5, 6, 7, 8, 9]`。这不是正确的顺序。这是因为JavaScript中的`sort`方法按字典顺序排序元素，并假设所有元素都是字符串。
- en: 'We can also write our own comparison function. As our array has numeric elements,
    we can write the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以编写自己的比较函数。由于我们的数组包含数字元素，我们可以编写以下代码：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code will return a negative number if `b` is bigger than `a`, a positive
    number if `a` is bigger than `b`, and 0 (zero) if they are equal. This means that
    if a negative value is returned, it implies that `a` is smaller than `b`, which
    is further used by the `sort` function to arrange the elements.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`b`大于`a`，此代码将返回一个负数，如果`a`大于`b`，则返回一个正数，如果它们相等，则返回0（零）。这意味着如果返回负值，则意味着`a`小于`b`，这进一步被`sort`函数用于排列元素。
- en: 'The previous code can be represented by the following code as well:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以用以下代码表示：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is because the `sort` function from the JavaScript Array class can receive
    a parameter called `compareFunction`, which is responsible for sorting the array.
    In our example, we declared a function that will be responsible for comparing
    the elements of the array, resulting in an array sorted in ascending order.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为JavaScript数组类的`sort`函数可以接收一个名为`compareFunction`的参数，该参数负责排序数组。在我们的例子中，我们声明了一个将负责比较数组元素的函数，结果是一个按升序排序的数组。
- en: Custom sorting
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义排序
- en: 'We can sort an array with any type of object in it, and we can also create
    a `compareFunction` to compare the elements as required. For example, suppose
    we have an object, Person, with name and age, and we want to sort the array based
    on the age of the person. We can use the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用任何类型的对象来排序数组，我们也可以创建一个`compareFunction`来比较所需的元素。例如，假设我们有一个名为Person的对象，包含姓名和年龄，我们想根据人的年龄对数组进行排序。我们可以使用以下代码：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, the output from the previous code will be Violet (18), Aelin (20),
    and Frodo (30).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，之前代码的输出将是Violet（18），Aelin（20），和Frodo（30）。
- en: Sorting Strings
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序字符串
- en: 'Suppose we have the following array:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下数组：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'What do you think would be the output? The answer is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为输出会是什么？答案是如下：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Why does `ana` come after `John` when `a` comes first in the alphabet? The answer
    is because JavaScript compares each character according to its **ASCII** value
    ([http://www.asciitable.com](http://www.asciitable.com)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `ana` 在字母表中排在 `John` 之后，尽管 `a` 排在前面？答案是 JavaScript 会根据每个字符的 **ASCII** 值进行比较（[http://www.asciitable.com](http://www.asciitable.com)）。
- en: 'For example, A, J, a, and j have the decimal ASCII values of A: 65, J: 74,
    a: 97, and j: 106\. Therefore, J has a lower value than a, and because of this,
    it comes first in the alphabet.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，A，J，a，和 j 的十进制 ASCII 值分别为 A：65，J：74，a：97，和 j：106。因此，J 的值小于 a，因此它在字母表中排在前面。
- en: 'Now, if we pass a function to the `sort` method, which contains the code to
    ignore the case of the letter, we will have the output [`"Ana", "ana", "john",
    "John"`], as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们向 `sort` 方法传递一个函数，该函数包含忽略字母大小写的代码，我们将得到以下输出：[`"Ana", "ana", "john", "John"`]：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this case, the sort function will not have any effect; it will obey the current
    order of lower and uppercase letters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，排序函数将不会有任何效果；它将遵循当前的大小写字母顺序。
- en: 'If we want lowercase letters to come first in the sorted array, then we need
    to use the `localeCompare` method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让排序后的数组中字母小写字母排在前面，那么我们需要使用 `localeCompare` 方法：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The output will be `['ana', 'Ana', 'john', 'John']`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是 `['ana', 'Ana', 'john', 'John']`。
- en: 'For accented characters, we can use the `localeCompare` method as well:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带重音的字符，我们也可以使用 `localeCompare` 方法：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The output will be `['Maeve', 'Maève']`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是 `['Maeve', 'Maève']`。
- en: Transforming an array
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换数组
- en: 'JavaScript also has support to methods that can modify the elements of the
    array or change its order. We have covered two transformative methods so far:
    `reverse` and `sort`. Let''s learn about other useful methods that can transform
    the array.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 还支持可以修改数组元素或改变其顺序的方法。到目前为止，我们已经介绍了两种转换方法：`reverse` 和 `sort`。让我们了解其他有用的可以转换数组的方法。
- en: Mapping values of an array
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射数组的值
- en: 'The `map` method is one of the most used methods in daily coding tasks when
    using JavaScript or TypeScript. Let''s see it in action:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 方法是使用 JavaScript 或 TypeScript 进行日常编码任务时最常用的方法之一。让我们看看它的实际应用：'
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Suppose we would like to find the square of each number in an array. We can
    use the map method to transform each value within the array and return an array
    with the results. For our example, the output will be: `[1, 4, 9, 16, 25, 36,
    49, 64, 81, 100]`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到数组中每个数字的平方。我们可以使用 `map` 方法转换数组中的每个值，并返回一个包含结果的数组。对于我们的例子，输出将是：`[1, 4,
    9, 16, 25, 36, 49, 64, 81, 100]`。
- en: 'We could rewrite the preceding code using a `for` loop to achieve the same
    result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `for` 循环重写前面的代码以实现相同的结果：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And this is why the map method is often used, as it saves time when we have
    to modify all the values within the array.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么 `map` 方法经常被使用的原因，因为它在我们需要修改数组中所有值时可以节省时间。
- en: Splitting into an array and joining into a string
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数组拆分并合并为字符串
- en: 'Imagine we have a CSV file with different names, delimited by a comma, and
    we would like to have each of these values and added to an array for processing
    (maybe they need to be persisted in a database by an API). We can use the String
    `split` method, which will return an array of the values:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个逗号分隔的 CSV 文件，包含不同的名称，并且我们想要将这些值添加到数组中进行处理（可能需要通过 API 保存到数据库中）。我们可以使用
    String 的 `split` 方法，它将返回一个包含这些值的数组：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And if instead of a comma separated file we need to use a semi-colon, we can
    use the `join` method of the JavaScript array class to output a single string
    with the array values:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要使用逗号分隔的文件，而是需要使用分号，我们可以使用 JavaScript 数组的 `join` 方法来输出一个包含数组值的单个字符串：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the reduce method for calculations
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `reduce` 方法进行计算
- en: 'The `reduce` method is used to calculate a value out of the array. The method
    receives a callback function with the following arguments: `accumulator` (the
    result of the calculation), the `element` of the array, the `index` and the `array`
    itself, and the second argument is the initial value. Usually, the index and the
    array are not used very often and can be omitted. Let''s see a few examples.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 方法用于从数组中计算出一个值。该方法接收一个带有以下参数的回调函数：`accumulator`（计算结果），数组的`element`，`index`以及数组本身，第二个参数是初始值。通常，索引和数组不太常用，可以省略。让我们看看几个例子。'
- en: 'The `reduce` method is often used when we want to calculate totals. For example,
    let''s say we would like to know what is the sum of all numbers in a given array:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要计算总和时，`reduce` 方法经常被使用。例如，假设我们想知道给定数组中所有数字的总和：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Where `0` is the initial value, and `acc` is the sum. We can rewrite the preceding
    code using a loop to understand the logic behind it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `0` 是初始值，`acc` 是总和。我们可以使用循环重写前面的代码来理解其背后的逻辑：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can also use the `reduce` method to find the minimum or maximum values within
    an array:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `reduce` 方法在数组中找到最小或最大值：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There is also the `reduceRight` method, which will execute the same logic, however,
    it will iterate the array from its end to the beginning.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `reduceRight` 方法，它将执行相同的逻辑，但是它将从数组的末尾开始迭代。
- en: These methods `map`, `filter`, and `reduce` are the basis of *functional programming*
    in JavaScript.
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些方法 `map`、`filter` 和 `reduce` 是 JavaScript 中 *函数式编程* 的基础。
- en: References for other JavaScript array methods
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 JavaScript 数组方法的参考
- en: JavaScript arrays are remarkably interesting because they are powerful and have
    more capabilities available than primitive arrays in other languages. This means
    that we do not need to write basic capabilities ourselves, and we can take advantage
    of these powerful features.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 数组非常有趣，因为它们功能强大，并且比其他语言中的原始数组具有更多可用功能。这意味着我们不需要自己编写基本功能，并且可以利用这些强大的功能。
- en: We have already covered many different methods within this chapter. Let's look
    at other useful methods.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经介绍了许多不同的方法。让我们看看其他有用的方法。
- en: Using the isArray method
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 isArray 方法
- en: 'In JavaScript, we can check the type of a variable or object using the `typeof`
    operator as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们可以使用 `typeof` 运算符检查变量或对象的类型，如下所示：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that both the object `{ id: 1}` and the array `[1, 2, 3]` have types as
    `object`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，对象 `{ id: 1}` 和数组 `[1, 2, 3]` 的类型都是 `object`。'
- en: 'But what if we would like to double check the type is array so we can evoke
    any specific array method? Thankfully, JavaScript also provides a method for that
    through `Array.isArray`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想再次检查类型是否为数组，以便我们可以调用任何特定的数组方法呢？幸运的是，JavaScript 也提供了一个通过 `Array.isArray`
    的方法：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This way we can always check in case we receive some data we do not know its
    type. For example, when working with JavaScript on the front-end, we often receive
    JSON objects from an API from the server. We can parse the data received into
    an object, and check if the object received is an array so we can use the methods
    we learned to find specific information:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以始终检查我们是否收到了未知类型的数据。例如，当在客户端使用 JavaScript 时，我们经常从服务器端的 API 接收 JSON 对象。我们可以将接收到的数据解析成对象，并检查接收到的对象是否为数组，这样我们就可以使用我们学到的方法来查找特定信息：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is helpful to ensure our code will not throw errors and a good practice
    when handling data structures, so we have not created ourselves within our code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于确保我们的代码不会抛出错误，并且在处理我们代码中未创建的数据结构时是一种良好的实践。
- en: Using the from method
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 from 方法
- en: 'The `Array.from` method creates a new array from an existing one. For example,
    if we want to copy the array `numbers` into a new one, we can use the following
    code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from` 方法从一个现有的数组创建一个新的数组。例如，如果我们想将数组 `numbers` 复制到一个新的数组中，我们可以使用以下代码：'
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It is also possible to pass a function so that we can determine which values
    we want to map. Consider the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以传递一个函数，这样我们就可以确定我们想要映射的值。考虑以下代码：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding code created a new array named evens, and a value true if in the
    original array the number is even, and false otherwise.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个名为 evens 的新数组，如果原始数组中的数字是偶数，则值为 true，否则为 false。
- en: 'It is important to note that the `Array.from()` method creates a new, *shallow*
    copy. Let''s see another example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`Array.from()` 方法创建了一个新的、*浅拷贝*。让我们看看另一个例子：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With the copy done, let''s modify the name of the first friend to Sam:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 复制完成后，让我们将第一个朋友的名字修改为 Sam：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The name of the first friend of the copied array also gets updated, so we have
    to be careful when using this method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 被复制的数组的第一个朋友的名字也会更新，所以在使用这个方法时我们必须小心。
- en: 'If we need to copy the array, and have different instances of its content there
    is a workaround that can be used via JSON:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要复制数组，并且有不同实例的内容，可以通过 JSON 使用一种解决方案：
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: By transforming all the content of the array into a string in JSON format, and
    then parsing this content back to the array structure, we create brand new data.
    However, depending on what we need to achieve, there are more robust ways of doing
    this.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数组的所有内容转换为 JSON 格式的字符串，然后再将此内容解析回数组结构，我们创建全新的数据。然而，根据我们需要实现的目标，还有更健壮的方法来做这件事。
- en: Using the Array.of method
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Array.of 方法
- en: 'The `Array.of` method creates a new array from the arguments passed to the
    method. For example, let''s consider the following example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.of` 方法可以从传递给方法的方法参数创建一个新的数组。例如，让我们考虑以下示例：'
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding code would be the same as performing the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码等同于执行以下操作：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can also use this method to make a copy of an existing array. The following
    is an example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这个方法来复制现有的数组。以下是一个示例：
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code is the same as using `Array.from(numbersArray)`. The difference
    here is that we are using the spread operator. The spread operator (`...`) will
    spread each of the values of the `numbersArray` into arguments.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码等同于使用 `Array.from(numbersArray)`。这里的区别在于我们使用了扩展运算符。扩展运算符（`...`）将 `numbersArray`
    的每个值展开为参数。
- en: Using the fill method
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `fill` 方法
- en: The `fill` method fills the array with a value. For example, suppose a new game
    tournament will start and we want to store all the results in an array. As the
    games are over, we can update each of the results.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill` 方法用值填充数组。例如，假设一个新的游戏锦标赛即将开始，我们想要将所有结果存储在数组中。随着比赛的结束，我们可以更新每个结果。'
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `tornamentResults` array has the length 5, meaning we have five positions.
    Each position has been initialized with the value `pending`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`tornamentResults` 数组的长度为 5，这意味着我们有五个位置。每个位置都初始化为 `pending` 值。'
- en: 'Now, suppose games 1 and 2 were a win. We can also use the `fill` method to
    populate these two positions by passing the start position (inclusive) and the
    end position (exclusive):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设比赛 1 和 2 已经获胜。我们也可以使用 `fill` 方法通过传递起始位置（包含）和结束位置（不包含）来填充这两个位置：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This method is useful as it provides a compact way to initialize arrays with
    a single value and it is often faster (in terms of the time we will spend writing
    the code) than manually looping to fill an array.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很有用，因为它提供了一种紧凑的方式来使用单个值初始化数组，并且通常比手动循环填充数组更快（在编写代码所需的时间方面）。
- en: Joining multiple arrays
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并多个数组
- en: 'Consider a scenario where you have different arrays and you need to join all
    of them into a single array. We could iterate each array and add each element
    to the final array. Fortunately, JavaScript already has a method that can do this
    for us, named the concat method, which looks as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，你拥有不同的数组，并且需要将它们全部合并成一个单一的数组。我们可以遍历每个数组，并将每个元素添加到最终的数组中。幸运的是，JavaScript
    已经有一个可以为我们完成这个任务的方法，名为 `concat` 方法，其语法如下：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can pass as many arrays and objects/elements to this array as we desire.
    The arrays will be concatenated to the specified array in the order that the arguments
    are passed to the method. In this example, zero will be concatenated to `negativeNumbers`,
    and then `positiveNumbers` will be concatenated to the resulting array. The output
    of the numbers array will be the values `[-3, -2, -1, 0, 1, 2, 3]`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向这个数组传递任意数量的数组、对象/元素。数组将按照传递给方法的参数顺序连接到指定的数组中。在这个例子中，0 将连接到 `negativeNumbers`，然后
    `positiveNumbers` 将连接到结果数组。数字数组的输出将是值 `[-3, -2, -1, 0, 1, 2, 3]`。
- en: Two-dimensional arrays
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二维数组
- en: 'At the beginning of this chapter, we used a temperature measurement example.
    We will now use this example one more time. Let''s consider that we need to measure
    the temperature hourly for a few days. Now that we already know we can use an
    array to store the temperatures, we can easily write the following code to store
    the temperatures over 2 days:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们使用了一个温度测量的例子。现在我们将再次使用这个例子。让我们考虑一下，我们需要测量几天内的每小时温度。既然我们已经知道可以使用数组来存储温度，我们可以轻松地编写以下代码来存储两天的温度：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'However, this is not the best approach; we can do better! We can use a **matrix**
    (a two-dimensional array or an *array of arrays*) to store this information, in
    which each row will represent the day, and each column will represent an hourly
    measurement of temperature, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不是最佳方法；我们可以做得更好！我们可以使用一个 **矩阵**（一个二维数组或 *数组数组*）来存储这些信息，其中每一行将代表一天，每一列将代表温度的小时测量值，如下所示：
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'JavaScript only supports one-dimensional arrays; it does not support matrices.
    However, we can implement matrices or any multi-dimensional array using an array
    of arrays, as in the previous code. The same code can also be written as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 只支持一维数组；它不支持矩阵。然而，我们可以使用数组数组实现矩阵或任何多维数组，就像前面的代码一样。同样的代码也可以写成以下形式：
- en: '[PRE72]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or, if you prefer to assign a value for each position separately, we can also
    rewrite the code as the following snippet:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你更喜欢为每个位置单独分配值，我们也可以将代码重写为以下代码片段：
- en: '[PRE73]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We specified the value of each day and hour separately. We can also represent
    this two-dimensional array as the following diagram:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分别指定了每一天和每个小时的价值。我们也可以将这个二维数组表示为以下图表：
- en: '![Figure 3.4:](img/file12.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4:](img/file12.png)'
- en: 'Figure 3.4:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3.4:'
- en: Each row represents a day, and each column represents the temperature for each
    hour of the day.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行代表一天，每一列代表一天中每个小时的温度。
- en: Another way of visualizing a two-dimensional array is thinking about an Excel
    file (or Google Sheets). We can store any kind of tabular data using a two-dimensional
    array such as chess board, theater seating and even representing images, where
    each position of the array can store the color value for each pixel.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可视化二维数组的方法是想象一个 Excel 文件（或 Google Sheets）。我们可以使用二维数组存储任何类型的表格数据，例如棋盘、剧院座位，甚至表示图像，其中数组的每个位置可以存储每个像素的颜色值。
- en: Iterating the elements of two-dimensional arrays
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历二维数组的元素
- en: 'If we want to verify the output of the matrix, we can create a generic function
    to log its output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想验证矩阵的输出，我们可以创建一个通用函数来记录其输出：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We need to loop through all the rows and columns. To do this, we need to use
    a nested `for` loop, in which the variable `i` represents rows, and `j` represents
    the columns. In this case, each `myMatrix[i]` also represents an array, therefore
    we also need to iterate each position of `myMatrix[i]` in the nested for loop.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遍历所有行和列。为此，我们需要使用嵌套的 `for` 循环，其中变量 `i` 代表行，`j` 代表列。在这种情况下，每个 `myMatrix[i]`
    也代表一个数组，因此我们还需要在嵌套的 `for` 循环中迭代 `myMatrix[i]` 的每个位置。
- en: 'We can output the contents of the `averageTemp` matrix using the following
    code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码输出 `averageTemp` 矩阵的内容：
- en: '[PRE75]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can also use the `console.table(averageTemp)` statement to output a two-dimensional
    array. This will provide a more user-friendly output, showing the tabular data
    format.
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还可以使用 `console.table(averageTemp)` 语句输出一个二维数组。这将提供更友好的用户输出，显示表格数据格式。
- en: Multi-dimensional arrays
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'We can also work with multi-dimensional arrays in JavaScript. For example,
    suppose we need to store the average temperature for multiple days and for multiple
    locations. We can use a 3D matrix to do so:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 JavaScript 中处理多维数组。例如，假设我们需要存储多个地点和多个天气条件下的多天的平均温度。我们可以使用一个三维矩阵来做到这一点：
- en: 'Dimension 1 (`i`): each day'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '维度 1 (`i`): 每天的时间'
- en: 'Dimension 2 (`j`): location'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '维度 2 (`j`): 地点'
- en: 'Dimension 3 (`z`): temperature'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '维度 3 (`z`): 温度'
- en: 'Let''s say we will only store the last 3 days, for 3 distinct locations and
    3 different weather conditions. We can represent a 3 x 3 x 3 matrix with a cube
    diagram, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只存储过去 3 天，3 个不同地点和 3 种不同的天气条件。我们可以用一个立方图表示一个 3x3x3 矩阵，如下所示：
- en: '![Figure 3.5:](img/file13.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5:](img/file13.png)'
- en: 'Figure 3.5:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3.5:'
- en: 'We can represent a 3 x 3 matrix, as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以表示一个 3x3 矩阵，如下所示：
- en: '[PRE76]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And, if we would like to output the content of this matrix, we will need to
    iterate each dimension (`i`, `j` and `z`):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，如果我们想输出这个矩阵的内容，我们需要迭代每个维度（`i`、`j` 和 `z`）：
- en: '[PRE77]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Performance wise, the preceding code is *O(nˆ3)*, cubic time, as we have three
    nested loops.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，前面的代码是 *O(nˆ3)*，即立方时间，因为我们有三个嵌套循环。
- en: We can use 3D matrices to represent medical images such as MRI scans, which
    is a series of 2D image slides of the body. Each slide is a grid if pixel, and
    combining these slides, we have a 3D representation of a scanned area of the body.
    Another usage is visualizing models for a 3D printer, or even video data (each
    frame is a 2D array of pixels, with the third dimension being time).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三维矩阵来表示医学图像，例如 MRI 扫描，这是一系列身体的二维图像幻灯片。每个幻灯片是一个像素网格，将这些幻灯片组合起来，我们就有了身体扫描区域的
    3D 表示。另一种用途是可视化 3D 打印机的模型，甚至是视频数据（每一帧都是一个二维像素数组，第三个维度是时间）。
- en: If we had a 3 x 3 x 3 x 3 matrix, we would have four nested `for` statements
    in our code and so on. You will rarely need a four-dimensional array in your career
    as a developer as it has very specialized use cases such as traffic pattern analysis.
    Two-dimensional arrays are most common in daily activities that developers will
    work on most projects.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个 3x3x3x3 矩阵，我们的代码中就会有四个嵌套的 `for` 循环，依此类推。作为开发者，你很少需要四维数组，因为它有非常专业的用途，例如交通模式分析。二维数组在开发者日常活动中最为常见，他们将在大多数项目中使用。
- en: The TypedArray class
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypedArray 类
- en: We can store any datatype in JavaScript arrays. This is because JavaScript arrays
    are not strongly typed as in other languages such as C and Java.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 JavaScript 数组中存储任何数据类型。这是因为 JavaScript 数组不像 C 和 Java 等其他语言那样是强类型。
- en: '**TypedArray** was created so that we could work with arrays with a single
    datatype. Its syntax is `let myArray = new TypedArray(length)`, where `TypedArray`
    needs to be replaced with one specific class, as defined in the following table:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypedArray** 的创建是为了让我们能够处理具有单一数据类型的数组。其语法是 `let myArray = new TypedArray(length)`，其中
    `TypedArray` 需要替换为以下表中定义的特定类：'
- en: '| **TypedArray** | **Description** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **TypedArray** | **描述** |'
- en: '| `Int8Array` | 8-bit two''s complement signed integer |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `Int8Array` | 8位二进制补码有符号整数 |'
- en: '| `Uint8Array` | 8-bit unsigned integer |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8Array` | 8位无符号整数 |'
- en: '| `Uint8ClampedArray` | 8-bit unsigned integer |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8ClampedArray` | 8位无符号整数 |'
- en: '| `Int16Array` | 16-bit two''s complement signed integer |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `Int16Array` | 16位二进制补码有符号整数 |'
- en: '| `Uint16Array` | 16-bit unsigned integer |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `Uint16Array` | 16位无符号整数 |'
- en: '| `Int32Array` | 32-bit two''s complement signed integer |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `Int32Array` | 32位二进制补码有符号整数 |'
- en: '| `Uint32Array` | 32-bit unsigned integer |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `Uint32Array` | 32位无符号整数 |'
- en: '| `Float32Array` | 32-bit IEEE floating point number |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `Float32Array` | 32位 IEEE 浮点数 |'
- en: '| `Float64Array` | 64-bit IEEE floating point number |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `Float64Array` | 64位 IEEE 浮点数 |'
- en: '| `BigInt64Array` | 64-bit big integer |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `BigInt64Array` | 64位大整数 |'
- en: '| `BigUint64Array` | 64-bit unsigned big integer |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `BigUint64Array` | 64位无符号大整数 |'
- en: 'Table 3.1:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：
- en: 'The following is an example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE78]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Typed arrays are great for working with WebGL APIs, manipulating bits, and manipulating
    files, images, and audios. Typed arrays work exactly like simple arrays, and we
    can also use the same methods and functionalities that we have learned in this
    chapter.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Typed 数组非常适合与 WebGL API 一起工作，操作位，以及操作文件、图像和音频。Typed 数组的工作方式与简单数组完全相同，我们还可以使用本章中学到的相同方法和功能。
- en: One practical example of when to use `TypedArray` is when working with **TensorFlow**
    ([https://www.tensorflow.org](https://www.tensorflow.org)), which is a library
    used to create **Machine Learning** models. TensorFlow has the concept of **Tensors**,
    which is the core data structure of TensorFlow.js. It utilizes `TypedArrays` internally
    to represent tensor data. This contributes to the efficiency and performance of
    the library, especially when dealing with large datasets or complex models.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TypedArray` 的一个实际例子是在使用 **TensorFlow** ([https://www.tensorflow.org](https://www.tensorflow.org))
    时，这是一个用于创建 **机器学习** 模型的库。TensorFlow 有 **张量** 的概念，它是 TensorFlow.js 的核心数据结构。它内部使用
    `TypedArrays` 来表示张量数据。这有助于提高库的效率和性能，尤其是在处理大型数据集或复杂模型时。
- en: Arrays in TypeScript
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 中的数组
- en: All the source code from this chapter is valid TypeScript code. The difference
    is that TypeScript will do type checking at compile time to make sure we are only
    manipulating arrays in which all values have the same datatype.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有源代码都是有效的 TypeScript 代码。区别在于 TypeScript 会在编译时进行类型检查，以确保我们只操作所有值具有相同数据类型的数组。
- en: 'Let''s review one of the previous examples mentioned earlier this chapter:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章前面提到的先前示例：
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Due to the type inference, TypeScript understands that the declaration of the
    numbers array is the same as `const numbers: number[]`. For this reason, we do
    not need to always declare the variable type explicitly if we initialize it during
    its declaration.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '由于类型推断，TypeScript 能够理解数字数组的声明与 `const numbers: number[]` 相同。因此，如果我们初始化变量时，我们不需要总是显式声明变量的类型。'
- en: 'If we go back to the sorting example of the `friends` array, we can refactor
    the code to the following in TypeScript:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到 `friends` 数组的排序示例，我们可以将 TypeScript 中的代码重构如下：
- en: '[PRE80]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'By declaring the `Friend` interface, we make sure the `compareFriend` function
    receives only objects that have the properties `name` and `age`. The friends array
    does not have an explicit type, so in this case, if we wanted, we could explicitly
    declare its type using `const friends: Friend[]`.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '通过声明 `Friend` 接口，我们确保 `compareFriend` 函数只接收具有 `name` 和 `age` 属性的对象。朋友数组没有显式的类型，因此在这种情况下，如果我们想的话，我们可以显式地使用
    `const friends: Friend[]` 声明其类型。'
- en: 'In summary, if we want to type our JavaScript variables using TypeScript, we
    simply need to use `const` or `let variableName: <type>[]` or, when using files
    with a `.js` extension, we can also have the type checking by adding the comment
    `// @ts-check` in the first line of the JavaScript file.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '总结来说，如果我们想使用 TypeScript 来编写 JavaScript 变量，我们只需使用 `const` 或 `let variableName:
    <type>[]`，或者在具有 `.js` 扩展名的文件中，我们也可以通过在 JavaScript 文件的第 一行添加注释 `// @ts-check` 来进行类型检查。'
- en: At runtime, the output will be exactly the same as if we were using pure JavaScript.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，输出将与我们使用纯 JavaScript 时完全相同。
- en: Creating a simple TODO list using arrays
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组创建简单的 TODO 列表
- en: Arrays is one of the most used data structures in general, it does not matter
    if we are using JavaScript, .NET, Java, Python, or any other language. This is
    one of the reasons most languages have native support to this data structure and
    JavaScript has an excellent API (*Application Programming Interface*) for the
    `Array` class.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是通用中最常用的数据结构之一，无论我们使用的是 JavaScript、.NET、Java、Python 还是任何其他语言。这也是大多数语言都有对这种数据结构原生支持的原因之一，JavaScript
    对 `Array` 类提供了出色的 API（应用程序编程接口）。
- en: Whenever we access the database, we will get a collection of records back, and
    we can use arrays to manage the information retrieved from the database. If we
    are using JavaScript in the frontend, and we make a call to a server API, we usually
    will get back a collection of records in **JSON** (*JavaScript Object Notation*)
    format, and we can parse the JSON into an array so we can manage and manipulate
    the data as needed so we can display it on the screen for the user.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们访问数据库时，我们都会得到一个记录集合，我们可以使用数组来管理从数据库检索到的信息。如果我们在前端使用 JavaScript，并且调用服务器 API，我们通常将以
    **JSON**（JavaScript 对象表示法）格式返回一个记录集合，我们可以将 JSON 解析成数组，以便按需管理和操作数据，这样我们就可以在屏幕上显示给用户。
- en: 'Let''s see a simple example of an HTML page using JavaScript where we can create
    tasks, complete tasks, and remove tasks. Of course, we will use arrays to manage
    our TODO list:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 HTML 页面示例，使用 JavaScript 我们可以创建任务、完成任务和删除任务。当然，我们将使用数组来管理我们的 TODO
    列表：
- en: '[PRE81]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This HTML code will help us to render a basic TODO application. Once we complete
    the development of this page, and if we open it in a browser, we will have the
    following application:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 HTML 代码将帮助我们渲染一个基本的 TODO 应用程序。一旦我们完成这个页面的开发，并在浏览器中打开它，我们将得到以下应用程序：
- en: '![](img/file14.png)Figure 3.6:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 14](img/file14.png)图 3.6：'
- en: 'Let''s check out the code used to render the task bullet point list:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查用于渲染任务项目符号列表的代码：
- en: '[PRE82]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: When we click on the **Add** button, the function `addTask` will be called.
    We will use the `trim` method to remove all the additional spaces at the beginning
    and the end of the text (`{1}`), and if the text is not empty, we will add it
    to our array (`{2}`) in the format of an object containing the text and also saying
    the task is not completed. Then we will evoke the `renderTasks` function and we
    will clear the input so we can enter more tasks.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击 **添加** 按钮，将调用 `addTask` 函数。我们将使用 `trim` 方法去除文本开头和结尾的所有额外空格（`{1}`），如果文本不为空，我们将以包含文本和表示任务未完成的对象格式将其添加到我们的数组（`{2}`）中。然后我们将调用
    `renderTasks` 函数，并清空输入，以便我们可以输入更多任务。
- en: 'Next, let''s see the `renderTasks` function:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `renderTasks` 函数：
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Every time we add a new task or remove one, we will call this `renderTasks`
    function. First, we will clear the list by rendering an empty space in the screen,
    then, for each task we have in the array (`{3}`), we will create an element in
    the HTML list, that contains a checkbox that is checked in case the task is completed,
    the task text and a button that we can use the remove task, passing the index
    of the task in the array.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们添加一个新任务或删除一个任务时，我们都会调用这个 `renderTasks` 函数。首先，我们将通过在屏幕上渲染一个空格来清除列表，然后，对于数组中的每个任务（`{3}`），我们将在
    HTML 列表中创建一个元素，该元素包含一个复选框，如果任务已完成则被选中，任务文本以及一个按钮，我们可以使用它来删除任务，传递数组中任务的索引。
- en: 'Finally, let''s check the `toggleComplete` function (which is called whenever
    the check or uncheck the checkbox) and the `removeTask` function:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们检查 `toggleComplete` 函数（在勾选或取消勾选复选框时调用）和 `removeTask` 函数：
- en: '[PRE84]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Both functions receive the `index` of the array as parameter, so we can easily
    access the task that is being toggled or removed. For the toggle, we can access
    the array position directly and mark the task as completed or not completed (`{4}`),
    and to remove the task, we can use the splice method as we learned in this chapter
    to remove the task from the array (`{5}`), and of course, whenever we make a change,
    we will render the tasks again.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都接收数组的`index`作为参数，因此我们可以轻松访问正在切换或删除的任务。对于切换，我们可以直接访问数组位置并标记任务为完成或不完成（`{4}`），要删除任务，我们可以使用本章学到的`splice`方法从数组中删除任务（`{5}`），当然，每次我们进行更改时，我们都会重新渲染任务。
- en: Arrays are everywhere, hence the importance to master this data structure.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 数组无处不在，因此掌握这种数据结构的重要性不言而喻。
- en: Exercises
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: We will resolve a few array exercises from **Hackerrank** using the concepts
    we learned in this chapter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章学到的概念解决**Hackerrank**的一些数组练习。
- en: Reversing an array
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反转数组
- en: The first exercise we will resolve the is reverse array problem available at
    [https://www.hackerrank.com/challenges/arrays-ds/problem](https://www.hackerrank.com/challenges/arrays-ds/problem).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决的第一个问题是可用的反转数组问题，链接为[https://www.hackerrank.com/challenges/arrays-ds/problem](https://www.hackerrank.com/challenges/arrays-ds/problem)。
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `reverseArray(a: number[]): number[] {}`, which
    receives an array of numbers and it is also expecting an array of numbers to be
    returned.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用JavaScript或TypeScript解决问题时，我们需要在函数`reverseArray(a: number[]): number[] {}`中添加我们的逻辑，该函数接收一个数字数组并期望返回一个数字数组。'
- en: The sample input that is given is `[1,4,3,2]` and the expected output is `[2,3,4,1]`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的示例输入是`[1,4,3,2]`，预期的输出是`[2,3,4,1]`。
- en: The logic we need to implement is to reverse the array, meaning the first element
    will become the last and so on.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的逻辑是反转数组，这意味着第一个元素将成为最后一个元素，依此类推。
- en: 'The most straightforward solution is using the existing `reverse` method:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是使用现有的`reverse`方法：
- en: '[PRE85]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This is a solution that passes all the tests and resolves the problem. However,
    if this exercise is being used in technical interviews, the interviews probably
    will ask you to try a different solution that does not include using the existing
    `reverse` method so they can evaluate how you think and communicate the resolution.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通过所有测试并解决问题的解决方案。然而，如果这个练习在技术面试中使用，面试官可能要求你尝试一个不同的解决方案，该方案不包括使用现有的`reverse`方法，这样他们就可以评估你的思考方式和沟通解决方案的能力。
- en: A second solution is to manually code reversing the array.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是手动编写代码来反转数组。
- en: '[PRE86]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We will create a brand new array, we will iterate the given array starting from
    the end (since we have to reverse it) until we reach the first index which is
    0\. Then, for each element, we will add (`push`) to the new array and we can return
    the `result`. This solution is *O(n)* as we need to iterate through the length
    of the array.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的数组，我们将从数组的末尾开始遍历给定的数组（因为我们必须反转它），直到我们达到第一个索引，即0。然后，对于每个元素，我们将将其(`push`)到新数组中，并可以返回`result`。这个解决方案是*O(n)*，因为我们需要遍历数组的长度。
- en: Speaking of *Big O notation*, as you might have noticed, we often need to iterate
    an array. Iterating an array is linear time, and accessing the elements directly
    is *O(1)*, as we can access any position of the array by accessing its index.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 说到*大O表示法*，正如你可能已经注意到的，我们经常需要遍历一个数组。遍历数组是线性时间，直接访问元素是*O(1)*，因为我们可以通过访问其索引来访问数组的任何位置。
- en: 'If you prefer to iterate the array from its beginning until its last position,
    we can use the `unshift` method:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢从数组的开始遍历到其最后一个位置，我们可以使用`unshift`方法：
- en: '[PRE87]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: However, this is one of worst solutions. Given we need to iterate the array,
    we are talking about *O(n)* complexity. The `unshift` method also has *O(n)* complexity
    as it needs to move all the existing elements already in the array, making this
    solution *O(nˆ2)*, quadratic time.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是最差的一种解决方案。考虑到我们需要遍历数组，我们谈论的是*O(n)*复杂度。`unshift`方法也有*O(n)*复杂度，因为它需要移动数组中已经存在的所有元素，这使得这个解决方案的复杂度达到*O(n²)*，即二次时间复杂度。
- en: 'Can you think of a solution that does not require iterating through all the
    array? What if we iterate only half of the array and swap the elements, meaning
    we swap the first element with the last, the second element with the second last,
    and so on:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一个不需要遍历整个数组的解决方案吗？如果我们只遍历数组的一半并交换元素，意味着我们交换第一个元素与最后一个元素，第二个元素与倒数第二个元素，依此类推：
- en: '[PRE88]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The loop of this function would run approximately *n/2* times, where `n` is
    the length of the array. In Big O notation, this would still be an algorithm of
    complexity *O(n)*, as we ignore constant factors and lower order terms, however,
    *n/2* is better than *n*, so this last solution might be slightly faster.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的循环将大约运行 *n/2* 次，其中 `n` 是数组的长度。在 Big O 表示法中，这仍然是一个复杂度为 *O(n)* 的算法，因为我们忽略了常数因子和低阶项，然而，*n/2*
    比更优，所以这个最后的解决方案可能稍微快一些。
- en: Array left rotation
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组左旋转
- en: The next exercise we will resolve is the array left rotation available at https://www.hackerrank.com/challenges/array-left-rotation/problem.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要解决的下一个练习是位于 https://www.hackerrank.com/challenges/array-left-rotation/problem
    的数组左旋转问题。
- en: 'When resolving the problem using JavaScript or TypeScript, we will need to
    add our logic inside the function `function rotLeft(a: number[], d: number): number[]
    {}` , which receives an array of numbers, a number `d` which is the number of
    left rotations and it is also expecting an array of numbers to be returned.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用 JavaScript 或 TypeScript 解决问题时，我们将在函数 `function rotLeft(a: number[], d:
    number): number[] {}` 内部添加我们的逻辑，该函数接收一个数字数组，一个数字 `d`，表示左旋转的次数，并且它还期望返回一个数字数组。'
- en: The sample input that is given is `[1,2,3,4,5]`, `d` is 2 and the expected output
    is `[3,4,5,1,2]`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的示例输入是 `[1,2,3,4,5]`，`d` 是 2，预期的输出是 `[3,4,5,1,2]`。
- en: The logic we need to implement is to remove the first element of the array and
    add it to the end of the array, doing this `d` times.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的逻辑是将数组的第一个元素移除并添加到数组的末尾，重复此操作 `d` 次。
- en: 'Let''s check with first solution:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查第一个解决方案：
- en: '[PRE89]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We are using the existing methods available in JavaScript, by removing the number
    of elements we need to rotate using the `splice` method, which returns the array
    with removed elements. Then, we are concatenating the original array with the
    array of the removed elements. Basically, we are splitting the original array
    into two arrays and swapping the order.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用现有的 JavaScript 方法，通过 `splice` 方法移除需要旋转的元素数量，来使用现有的 JavaScript 方法。然后，我们将原始数组与移除的元素数组连接起来。基本上，我们将原始数组分成两个数组并交换它们的顺序。
- en: 'The complexity of this solution is *O(n)* because:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的复杂度是 *O(n)*，因为：
- en: '`a.splice(0, d)`: this operation has a time complexity of *O(n)* because it
    needs to shift all the remaining elements of the array after removing the first
    `d` elements.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.splice(0, d)`: 这个操作的时间复杂度为 *O(n)*，因为它需要在移除前 `d` 个元素后，将数组中剩余的所有元素进行移动。'
- en: '`a.concat()`: this operation also has a time complexity of *O(n)* because it
    needs to iterate over all elements in the two arrays (the original array and the
    spliced array) to create a new array.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.concat()`: 这个操作的时间复杂度也是 *O(n)*，因为它需要遍历两个数组（原始数组和被截取的数组）的所有元素以创建一个新数组。'
- en: Since these operations are performed sequentially (not nested), the time complexities
    add up, resulting in a total time complexity of *O(n + n) = O(2n)*. However, in
    Big O notation, we drop the constants, so the final time complexity is *O(n)*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些操作是按顺序执行的（不是嵌套的），时间复杂度会累加，导致总的时间复杂度为 *O(n + n) = O(2n)*。然而，在 Big O 表示法中，我们忽略常数项，所以最终的时间复杂度是
    *O(n)*。
- en: 'Another similar solution would be as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的解决方案如下：
- en: '[PRE90]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Where we are creating a new array starting from the element at index `d` (`a.slice(d)`),
    and creating a new array by removing the number of elements we were asked to rotate
    (`a.slice(0, d)`). The spread operator (`…`) is used to unpack the elements of
    the two new arrays, and when surrounded by `[]`, we create a new array.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从索引 `d` 的元素开始创建一个新数组（`a.slice(d)`），并通过移除我们被要求旋转的元素数量（`a.slice(0, d)`）来创建一个新数组。扩展运算符（`…`）用于展开两个新数组的元素，当它被方括号包围时，我们创建一个新数组。
- en: 'Let''s review the complexity of this solution, which is also *O(n)*:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾这个解决方案的复杂度，它也是 *O(n)*：
- en: '`a.slice(d)`: this operation has a time complexity of *O(n - d)* because it
    needs to create a new array with the elements from index d to the end of the array.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.slice(d)`: 这个操作的时间复杂度为 *O(n - d)*，因为它需要创建一个包含从索引 `d` 到数组末尾的元素的新数组。'
- en: '`a.slice(0, d)`: this operation has a time complexity of *O(d)* because it
    needs to create a new array with the first d elements of the array.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.slice(0, d)`: 这个操作的时间复杂度为 *O(d)*，因为它需要创建一个包含数组前 `d` 个元素的新数组。'
- en: 'The spread operator (`...`): this operation has a time complexity of *O(n)*
    because it needs to iterate over all elements in the two arrays to create a new
    array.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展运算符（`...`）：这个操作的时间复杂度为 *O(n)*，因为它需要遍历两个数组中的所有元素以创建一个新数组。
- en: Since these operations are performed sequentially (not nested), the time complexities
    add up, resulting in a total time complexity of *O((n - d) + d + n) = O(2n)*.
    So the final time complexity is *O(n)*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些操作是顺序执行的（而不是嵌套的），时间复杂度会累加，导致总时间复杂度为 *O((n - d) + d + n) = O(2n)*。因此，最终的时间复杂度是
    *O(n)*。
- en: 'Again, during an interview, we can be asked to implement a manual solution,
    so let''s review a third possible solution:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在面试过程中，我们可能会被要求实现一个手动解决方案，所以让我们回顾第三种可能的解决方案：
- en: '[PRE91]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The outer loop will run `d` times as we need to rotate the elements. For each
    element we need to rotate, we will keep it in a temporary variable (`{1}`). Then,
    we will iterate the array and move the element in the next position to the current
    index (`{2}`). And at the end we will move the element we had stored in the temporary
    variable to the last position of the array (`{3}`). This is remarkably like the
    algorithm we created to remove an element from the first position. The difference
    here is we are not removing the element from the beginning of array and throwing
    it away, we are moving it to the end of the array.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环将运行 `d` 次，因为我们需要旋转元素。对于每个需要旋转的元素，我们将将其保存在一个临时变量中（`{1}`）。然后，我们将遍历数组，将下一个位置的元素移动到当前索引位置（`{2}`）。最后，我们将之前保存在临时变量中的元素移动到数组的最后一个位置（`{3}`）。这与我们创建的从第一个位置删除元素算法非常相似。这里的区别是我们不是从数组的开始删除元素并丢弃它，而是将其移动到数组的末尾。
- en: The time complexity of this solution is *O(n*d)*. The first solutions presented
    are likely to be faster as they are *O(n)*.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的时间复杂度是 *O(n*d)*。前面提出的解决方案可能更快，因为它们是 *O(n)*。
- en: Summary
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered the most-used data structure: arrays. We learned
    how to declare, initialize, and assign values as well as add and remove elements.
    We learned about two-dimensional and multi-dimensional arrays as well as the main
    methods of an array, which will be particularly useful when we start creating
    our own algorithms in later chapters.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了最常用的数据结构：数组。我们学习了如何声明、初始化和赋值，以及如何添加和删除元素。我们还了解了二维和多维数组，以及数组的主要方法，这些方法在我们开始创建自己的算法时将特别有用。
- en: We also learned how to make sure the array only contains values of the same
    type by using TypeScript or the TypeScript compile-time checking capability for
    JavaScript files.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何通过使用 TypeScript 或 TypeScript 对 JavaScript 文件的编译时检查能力来确保数组只包含相同类型的值。
- en: And finally, we resolved a few exercises that can be the topic of technical
    interviews and reviewed their complexity.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解决了一些可能成为技术面试主题的练习，并回顾了它们的复杂度。
- en: In the next chapter, we will learn about stacks, which can be treated as arrays
    with a special behavior.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习栈，它可以被视为具有特殊行为的数组。
