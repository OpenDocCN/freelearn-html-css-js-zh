- en: Chapter 12. Leveraging Flux Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux, first and foremost, is a set of architectural guidelines, specified as
    patterns for us to follow. While this affords the ultimate flexibility, it can
    be paralyzing sometimes, when it comes to deciding how to implement a given Flux
    component. Thankfully, there are some really good Flux libraries out there that
    provide opinionated implementations of Flux components, which remove the need
    for a lot of the boilerplate code we would have to write. The idea of this chapter
    is to look at two of these libraries, to show just how different Flux implementations
    can be. The goal isn't compliance, but rather a solid architecture that helps
    our application get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing core Flux components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to reiterate the idea that we can change the implementation
    specifics of the various Flux components in our architecture. We'll start by talking
    about the dispatcher itself, and think about the various changes that we might
    make. Then, we'll think about stores and the enhancements we might want to make
    there. Finally, we'll discuss actions and action creator functions.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the dispatcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 10, *Implementing a Dispatche* *r*, we implemented our own dispatcher
    component. The reference implementation by Facebook is perfectly fine to use,
    but it's not meant to be the de-facto component found in every production Flux
    architecture. Instead, it's meant to be a jumping off point, so we can see how
    the Flux dispatcher specification is supposed to work.
  prefs: []
  type: TYPE_NORMAL
- en: Our solution was to expose the `dispatch()` and `register()` functions from
    the dispatcher module. By doing so, we made using the dispatcher a little more
    direct in other areas of our code. There was no longer a dispatcher instance to
    think about—everything was encapsulated within the dispatcher module.
  prefs: []
  type: TYPE_NORMAL
- en: A generic Flux library might want to take this a step further and completely
    dissolve the dispatcher, which might sound nuts—it's an essential Flux component.
    However, we can still achieve the same architectural principle of the dispatcher
    without explicitly implementing this abstraction. This is the whole point of releasing
    Flux as a set of specs instead of a concrete implementation. We know conceptually
    what a Flux architecture should and should not do—we get to pick how to enforce
    these rules with our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a base store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another improvement we made in [Chapter 10](ch10.html "Chapter 10. Implementing
    a Dispatcher") , *Implementing a Dispatcher*, was to the store hierarchy. We had
    each of our stores inherit from a base class. The main reason we implemented this
    functionality was to automate the registration of the store with the dispatcher,
    which is good, because there's not much sense in a Flux store that isn't listening
    to events emitted from the dispatcher. Perhaps a Flux library should handle this
    type of base functionality for us.
  prefs: []
  type: TYPE_NORMAL
- en: We also implemented method action handlers. This was actually a function of
    the dispatcher itself in our implementation, and it was quite limiting. Perhaps
    the base store is the appropriate place for this type of functionality. Libraries
    should contain this type of generic complexity, not our application.
  prefs: []
  type: TYPE_NORMAL
- en: What's nice about inheriting base functionality with Flux stores is that this
    is where the brains of our application live. If we were to discover some generic
    state transformation behavior that applied to more than one store, having a base
    store in place makes it easy for us to factor out the common code. Maybe a Flux
    library could ship with some basic transformations in their base store that we
    would inherit from.
  prefs: []
  type: TYPE_NORMAL
- en: Creating actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constants are a great way to be explicit about actions in Flux architectures.
    The action module defines the constant, and the action creator function passes
    the constant to the dispatcher. Stores also use these constants when determining
    how to handle actions as they're dispatched. This creates an explicit tie between
    the action creator and the code in stores that respond to this action.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Implementing a Dispatcher"), *Implementing
    a Dispatcher*, we adopted a different approach. The action creator functions still
    defined constants and used them when dispatching the action. However, we made
    changes that allowed for our stores to define method handlers. So instead of one
    function that listened to the dispatcher, the stores defined methods that matched
    the constant defined for the action. This is convenient from the store's perspective,
    but it diminishes the value of having constants if they're only used by the action
    creator functions.
  prefs: []
  type: TYPE_NORMAL
- en: A Flux library could help make dispatching and handling actions a little more
    straightforward. Using constants and `switch` statements is good insofar as it
    makes what's happening explicit. We like explicitness in our Flux architecture.
    The challenge is that this approach requires diligence on the part of the programmers
    implementing the system. In other words, there's plenty of opportunity for human
    error. A Flux library could remove the error-prone aspects of dealing with constants
    in two places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another area that a Flux library could help is with asynchronous action creator
    functions. The asynchronous behavior of our application is likely to follow a
    similar pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch an action that changes the state of a store before the asynchronous
    code runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatch an action when the response arrives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatch a different action if the asynchronous behavior fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's almost like asynchronous actions have a lifecycle that could be abstracted
    into a common function by a Flux library.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation pain points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we covered the areas of Flux that might benefit from
    a custom implementation. Before we dive into `Alt.js` and Redux, we'll briefly
    talk about some of pain points with implementing Flux architectures. Asynchronous
    actions are tough to get right, in any architecture, let alone Flux. The way we
    partition our application state into stores can be a tricky design problem. If
    we get this wrong, it can be hard to recover from. Finally, we have data dependency
    challenges to think about.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching asynchronous actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in the preceding section, asynchronous action creators are difficult
    to implement. It's challenging because we usually have to let the stores know
    that this asynchronous action is about to take place so that the UI can be updated
    to reflect this. For example, when a button is clicked that sends one or more
    AJAX requests, we probably want to disable that button before actually sending
    the request, to prevent duplicate requests. The only way to do this in Flux is
    to dispatch an action, because everything is unidirectional.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries can help with this, to an extent. For example, the pre-request actions
    and success/error response actions can be somewhat abstracted into something that's
    easier to use, because that's a common pattern. However, even doing this leaves
    the issue of assembling requests to go fetch all the data that's needed for a
    given action, synchronize the responses and pass them each to the store so that
    it can transform them into something that the view needs.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe it's best if we were to leave this asynchronous problem outside the scope
    of Flux. Facebook has introduced GraphQL, for example, a language that simplifies
    building complex data from backend services and only responding with what the
    store actually needs. This is all done in one response, so we save on bandwidth
    and latency as well. This approach isn't for everyone, and so it's up to the Flux
    implementer to choose how they want to deal with asynchronicity, just as long
    as the unidirectional data-flow on the client remains intact.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Incorrectly partitioning the stores in our Flux architecture is perhaps one
    of the biggest design risks we face. What generally happens is that the stores
    are roughly balanced; then, as the system evolves, all the new features end up
    going into one store while the responsibilities of the other stores aren't clear.
    The stores become unbalanced, in other words. The store that holds onto the majority
    of the application state gets too complex to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential issue with the partitioning of our stores is that they grow
    to be too fine-grained. We don't want this to happen either. Though the state
    that's managed by individual stores is simple enough, the complexity resides in
    the dependencies between all these stores. Even if there aren't too many dependencies,
    when there's more stores to think about, it's more difficult to hold enough state
    in our heads as we're trying to reason about something. When related state is
    all in one place, it's much easier to predict what will happen.
  prefs: []
  type: TYPE_NORMAL
- en: What if a Flux library, like Redux, took a radical approach and eliminated all
    sources of confusion by only allowing a single store? This indeed prevents design
    issues like partitioning stores. Instead, as we'll see later on the chapter, Redux
    uses reducer functions to transform the state of the single store.
  prefs: []
  type: TYPE_NORMAL
- en: Using Alt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Alt.js` is a Flux library that implements a lot of the boilerplate code for
    us. It completely adheres to the Flux concepts and patterns, but let''s us focus
    on the architecture from the perspective of our application, rather than worrying
    about action constants and `switch` statements.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll touch on the core concepts of Alt before diving into
    a simple todo list example. The example is intentionally simple—you'll be able
    to map the code back to the Flux concepts you've learned about so far in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: The core ideas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main goal of the Facebook Flux package is to provide a reference implementation
    of a basic dispatcher component. This serves well as an aide to the concepts of
    Flux—actions are dispatched to stores in a synchronous, unidirectional fashion.
    As we've seen through the book, the dispatcher concept doesn't even necessarily
    need to be exposed to those who are implementing Flux. We can simplify the Flux
    abstractions and yet still fall within the constraints of a Flux architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Alt is a Flux library that's supposed to be used in production applications—it's
    not a reference implementation. Let's go over a few of it's goals as a Flux library
    before we jump into the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compliant**: Alt doesn''t borrow ideas from Flux—it''s truly meant for Flux
    systems. For example, the concept of stores, actions, and views are all relevant.
    Likewise, the principles of Flux architecture are followed closely by Alt. Things
    like synchronous update rounds and unidirectional data-flow are enforced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automates boilerplate**: Some of the more tedious programming tasks associated
    with implementing Flux are handled nicely by Alt. These include things like automatically
    creating action creator functions and action constants. Alt will also take care
    of store action handler methods for us—reducing the need for long `switch` statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No dispatcher**: There''s no dispatcher for our code to interface with. Dispatching
    actions to all the stores is taken care of behind the scenes, when we call our
    action creator functions. Things like dependency management between stores are
    handled directly within the stores themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simple application that we''re going to create will display two lists for
    the user. One list is for the todo items, the other list is for the items that
    have been completed. We''ll use two stores—one for each list. Let''s take a look
    at how we create stores using `Alt.js`. First, we have the `Todo` store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This probably doesn't look very familiar, relative to what we've seen so far
    in this book. Not to worry; we'll walk through the moving parts here now. The
    first question you probably have is—where's the state? It's not clear by looking
    at the code, but the state is any instance variables of the class. In this case,
    it's the `inputValue` string and the `todos` array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a call to `bindListeners()` with a configuration object passed
    to it. This is how Alt stores map actions to methods. You can see that we have
    methods defined that correspond to what's passed into `bindListeners()`. Lastly,
    we have the call to `createStore()`. This function instantiates the `Todo` store
    class for us, but it also hooks up the dispatch mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all there is to the store definition—it''s ready to be used by views
    that need to render it''s state. Now let''s take a look at the `Done` store, which
    follows the same approach, only with fewer moving parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that this store actually uses the `Todo` store to copy over
    item data when an item is marked as done. However, this store doesn't mutate the
    `Todo` store, as that would violate the unidirectional data-flow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These store classes aren't event emitters, so they don't explicitly emit anything
    when the state changes. For example when a todo is added, how do the views know
    that anything has changed? Since the `createTodo()` method is called automatically
    for us, the notification mechanism also happens automatically once our method
    has finished executing. We'll see more on the state change notification semantics
    momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring action creators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen how stores respond to actions being dispatched. Now we need a means
    to actually dispatch these actions. This is probably the easiest aspect of our
    Alt application. Alt can generate the functions we need, as well as the constants
    that are used by the `bindListeners()` call in our stores. Let''s take a look
    at the actions module and see how this works with Alt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will export an object with action creator functions that have the same
    names as the strings passed to `generateActions()`. And it'll generate the action
    constants used by the store. Since our action creator functions are all very similar,
    `generateActions()` has high utility. There's a lot of boilerplate code that we
    no longer have to maintain. On the other hand, there are more complex cases that
    involve asynchronous actions that need more code than this. Take a look at the
    Alt documentation for asynchronous actions if you're interested in using this
    library for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for state changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All throughout this book, we''ve added event handler functions to the change
    event emitted by our stores. With libraries like Alt, this is somewhat managed
    for us already. Let''s take a look at the main module of our application which
    uses the `AltContainer` React component to feed store data into our other React
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `AltContainer` component accepts a `stores` property. The container will
    listen to each of these stores and re-render it's children when the state of the
    any store changes. This is the only setup involved for getting our views to listen
    to stores—no manual `on()` or `listen()` calls all over the place. In the next
    section, we'll look at the `TodoList` and the `DoneList` components to see how
    they work with `AltContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering views and dispatching actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The job of the `TodoList` component is to render items from the `Todo` store.
    There are two other things this view needs to handle as well. First, there''s
    the `input` element that the user uses to enter new todo items. Second, we also
    need to mark items as done when they''re clicked, by moving them to the done list.
    These latter two responsibilities involve event handling and dispatching actions.
    Let''s take a look at the implementation of the todo list view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering why we can't just clear `e.target.value` when the **Enter**
    key is pressed. Indeed we could do this, but this would go against the nature
    of Flux where state is kept in stores. This includes transient values as they're
    being entered by the user. What if another part of the application wanted to know
    about the text input value? Well, all it needs is to depend on the `Todo` store.
    If the state wasn't there, then our code would have to query the DOM, which we
    don't want to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the done list component. This component is simpler
    than the todo list because there''s no event handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at the Redux library for implementing a
    Flux architecture. Unlike `Alt.js`, Redux doesn't aim for Flux compliance. The
    goal of Redux is to borrow the important ideas from Flux, leaving the tedious
    bits behind. Despite not implementing Flux components as specified in the official
    documentation, Redux is the go-to solution for React architectures now. Redux
    is proof that simplicity always wins over advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: The core ideas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before implementing some Redux code, let''s take a moment to look at the core
    ideas of Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No dispatcher**: This is just like `Alt.js`, which also purges the dispatcher
    concept from it''s API. The fact that these Flux libraries don''t expose a dispatcher
    component serves to illustrate the point that Flux is just a set of ideas and
    patterns, not an implementation. Both Alt and Redux dispatch actions, they just
    don''t require a dispatcher to do it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One store to rule them all**: Redux eschews the notion that a Flux architecture
    requires multiple stores. Instead, one store is used to hold the entire application
    state. At first glance, this might sound like the store would get too large and
    be too difficult to understand. This is just as likely to happen with multiple
    stores, the only difference there is that the application state is split into
    different modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispatch to the store**: When there''s only one store to worry about, we
    can make design concessions, such as treating the store and the dispatcher as
    the same concept. This is exactly what Redux does—it dispatches actions directly
    to the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pure reducers**: The idea behind multiple Flux stores is to split the application
    state into a few logically separated domains. We can still do this using Redux,
    the difference is that we separate our state into domains using reducer functions.
    These functions are responsible for transforming the state of the store when actions
    are dispatched. They''re pure because they return new data and avoid introducing
    any side-effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducers and stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're now going to implement the same simple todo application that we made using
    Alt—this time using Redux. There's a lot of overlap between the two libraries,
    particularly with the React components themselves; not much needs to change there.
    Where Redux departs from Alt and Flux in general is with it's single store, and
    the reducer functions that change it's state. With that said, we'll look at the
    store and it's reducer functions first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a module for the initial state of the the Redux store. This is
    an important first step because it provides the initial structure for the reducer
    functions that transform the store state. Let''s take a look at the initial state
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The state is a simple JavaScript object. You can see that the single store isn't
    just a tangled mess of properties, it's organized by two main properties—`Todo`
    and `Done`. This is like having multiple stores, except they're in one object.
    Something else you'll notice is that each store property is an `Immutable.js`
    data structure. The reason for this is that we need to treat the state that's
    passed into our reducer functions as immutable. This library makes enforcing immutability
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The state transformations that take place with the store state will be divided
    into two reducer functions. In fact, the two functions map to the two initial
    properties of the store: `Todo` and `Done`. Let''s look at the `Todo` reducer
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` statement that's used here should look familiar—it's the same pattern
    we've been implementing the stores throughout this book. In fact, this function
    is just like a store, with two main differences. The first difference is that
    it's a function instead of a class. This means that instead of setting state property
    values, we return the new state. The second difference is that Redux handles the
    mechanics of listening to stores and calling this reducer function. With classes,
    we have to write a lot of this code ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important that these reducer functions do not mutate the state argument.
    This is why we're using the `Immutable.js` library—to make it easier to transform
    existing state by creating new data. It's not necessary to use `Immutable.js`
    for transforming Redux store state, but it does help with code brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the `Done` reducer function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re almost done with our Redux store. At this point, we have two reducer
    functions, each in their own module. We need to tie them together using `combineReducers()`
    and `createStore()`. Let''s take a look at our store module now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `combineReducers()` function creates a new function. This
    is the main reducer function that maintains the state of the application. So instead
    of your typical Flux dispatcher that needs to handle getting actions to several
    stores, Redux actions are dispatched to this single store, and our reducer functions
    are called in response.
  prefs: []
  type: TYPE_NORMAL
- en: Redux actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you know, there's a difference between actions and action creators. Actions
    are the payloads that get sent to the various Flux stores, whereas action creators
    are responsible for creating the action payloads, and then sending them to the
    dispatcher. With Redux, action creator functions are slightly different in that
    they only create the action payloads, they don't talk directly with the dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see how the action creators are called in the following section when
    we implement the view components. But for now, here''s what our actions module
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These functions just return the data that's going to be dispatched by the store—they
    don't actually dispatch the data. The exception to this is when asynchronous actions
    are involved. In this case, we actually need to dispatch the action once the asynchronous
    values have resolved. See the official Redux documentation where there are plenty
    of asynchronous action examples.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering components and dispatching actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we have a Redux store and action creator functions. All that''s
    left to do is implement our React components and connect them to the store. We''ll
    start with the `TodoList` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The key thing to note about this module is that it's not the component class
    that's exported. Instead, we use the `connect()` function from the `react-redux`
    package. This function connects the Redux store to this view. The state from the
    store passes through the `mapStateToProps()` function, which determines how the
    React component properties are assigned. In this case, we just need to transform
    the `Immutable.js` structure into a plain JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside of the event handlers is that we need to bind their context in
    the constructor, because React doesn''t auto-bind the context for ES2015 style
    components. The handlers need access to `this.props` because it has the `dispatch()`
    function needed to dispatch our action data to the store, as well as the store
    data used to construct the action payloads. Now let''s look at the `DoneList`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this works in much the same way as the `TodoList` component.
    In fact, these components haven''t changed much relative to the Alt implementation
    of the same application. The last step is to hook up the two components with the
    Redux store, which can be accomplished using the `Provider` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about leveraging Flux libraries. In particular,
    we looked at two of the prevailing libraries that can be used to implement Flux
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter off with a discussion that was mostly a recap of the
    fundamental principles of Flux and how we implemented them throughout the previous
    chapters of this book. We then covered some of the various pain points of implementing
    Flux—like singleton dispatchers, repetitive action code, and partitioning store
    modules. These are areas that a library like `Alt.js` or Redux could address for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: We then proceeded to implement a simple todo application using the `Alt.js`
    Flux library. The idea behind Flux is to implement all the relevant Flux components
    while automating the typical arduous implementation chores behind the scenes for
    us. After this, we turned our attention to the Redux library. Redux is less concerned
    with following the Flux patterns exactly. Instead, Redux aims for simplicity while
    borrowing some of the more important Flux ideas like unidirectional data-flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover two very important aspects of any Flux architecture—functional
    and performance testing.
  prefs: []
  type: TYPE_NORMAL
