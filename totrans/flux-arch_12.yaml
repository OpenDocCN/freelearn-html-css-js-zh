- en: Chapter 12. Leveraging Flux Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。利用Flux库
- en: Flux, first and foremost, is a set of architectural guidelines, specified as
    patterns for us to follow. While this affords the ultimate flexibility, it can
    be paralyzing sometimes, when it comes to deciding how to implement a given Flux
    component. Thankfully, there are some really good Flux libraries out there that
    provide opinionated implementations of Flux components, which remove the need
    for a lot of the boilerplate code we would have to write. The idea of this chapter
    is to look at two of these libraries, to show just how different Flux implementations
    can be. The goal isn't compliance, but rather a solid architecture that helps
    our application get the job done.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Flux是一套架构指南，指定为我们遵循的模式。虽然这提供了最大的灵活性，但在决定如何实现特定的Flux组件时，有时可能会让人感到无所适从。幸运的是，有一些非常好的Flux库提供了对Flux组件有见地的实现，这减少了我们需要编写的许多样板代码。本章的目的是查看这些库中的两个，以展示Flux实现可以有多么不同。目标不是合规，而是一个稳固的架构，有助于我们的应用程序完成任务。
- en: Implementing core Flux components
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现核心Flux组件
- en: In this section, we're going to reiterate the idea that we can change the implementation
    specifics of the various Flux components in our architecture. We'll start by talking
    about the dispatcher itself, and think about the various changes that we might
    make. Then, we'll think about stores and the enhancements we might want to make
    there. Finally, we'll discuss actions and action creator functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重申我们可以改变架构中各种Flux组件的具体实现的想法。我们将从讨论分发器本身开始，并考虑我们可能做出的各种更改。然后，我们将考虑存储以及我们可能想要在那里做出的增强。最后，我们将讨论动作和动作创建函数。
- en: Customizing the dispatcher
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义分发器
- en: In Chapter 10, *Implementing a Dispatche* *r*, we implemented our own dispatcher
    component. The reference implementation by Facebook is perfectly fine to use,
    but it's not meant to be the de-facto component found in every production Flux
    architecture. Instead, it's meant to be a jumping off point, so we can see how
    the Flux dispatcher specification is supposed to work.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章，*实现分发器*，我们实现了自己的分发器组件。Facebook提供的参考实现完全可以使用，但它并不是每个生产Flux架构中默认的组件。相反，它是一个起点，这样我们可以看到Flux分发器规范应该如何工作。
- en: Our solution was to expose the `dispatch()` and `register()` functions from
    the dispatcher module. By doing so, we made using the dispatcher a little more
    direct in other areas of our code. There was no longer a dispatcher instance to
    think about—everything was encapsulated within the dispatcher module.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案是公开分发器模块中的`dispatch()`和`register()`函数。通过这样做，我们在代码的其他部分使用分发器变得更加直接。不再需要考虑分发器实例——一切都被封装在分发器模块中。
- en: A generic Flux library might want to take this a step further and completely
    dissolve the dispatcher, which might sound nuts—it's an essential Flux component.
    However, we can still achieve the same architectural principle of the dispatcher
    without explicitly implementing this abstraction. This is the whole point of releasing
    Flux as a set of specs instead of a concrete implementation. We know conceptually
    what a Flux architecture should and should not do—we get to pick how to enforce
    these rules with our implementation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的Flux库可能希望更进一步，完全取消分发器，这听起来可能有些疯狂——它是一个基本的Flux组件。然而，我们仍然可以在不明确实现这个抽象的情况下实现分发器的相同架构原则。这就是将Flux作为一套规范而不是具体实现发布出来的全部意义。我们在概念上知道Flux架构应该做什么和不应该做什么——我们有机会选择如何通过我们的实现来强制执行这些规则。
- en: Implementing a base store
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基础存储
- en: Another improvement we made in [Chapter 10](ch10.html "Chapter 10. Implementing
    a Dispatcher") , *Implementing a Dispatcher*, was to the store hierarchy. We had
    each of our stores inherit from a base class. The main reason we implemented this
    functionality was to automate the registration of the store with the dispatcher,
    which is good, because there's not much sense in a Flux store that isn't listening
    to events emitted from the dispatcher. Perhaps a Flux library should handle this
    type of base functionality for us.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章[实现分发器](ch10.html "第10章。实现分发器")中，我们做出的另一个改进是对存储层次结构的改进。我们的每个存储都继承自一个基类。我们实现这个功能的主要原因是为了自动化存储与分发器的注册，这是有益的，因为一个没有监听分发器发出的事件的Flux存储是没有意义的。也许Flux库应该为我们处理这种基础功能。
- en: We also implemented method action handlers. This was actually a function of
    the dispatcher itself in our implementation, and it was quite limiting. Perhaps
    the base store is the appropriate place for this type of functionality. Libraries
    should contain this type of generic complexity, not our application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了方法动作处理器。实际上，在我们的实现中，这是派发器本身的一个功能，而且相当受限。也许基础存储是这种功能合适的地点。库应该包含这种类型的通用复杂性，而不是我们的应用程序。
- en: What's nice about inheriting base functionality with Flux stores is that this
    is where the brains of our application live. If we were to discover some generic
    state transformation behavior that applied to more than one store, having a base
    store in place makes it easy for us to factor out the common code. Maybe a Flux
    library could ship with some basic transformations in their base store that we
    would inherit from.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flux存储继承基本功能的好处在于，这是我们应用程序的大脑所在之处。如果我们发现一些通用的状态转换行为适用于多个存储，那么有一个基础存储在位，就使我们能够轻松地将通用代码提取出来。也许Flux库可以在其基础存储中提供一些基本的转换，这样我们就可以从中继承。
- en: Creating actions
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动作
- en: Constants are a great way to be explicit about actions in Flux architectures.
    The action module defines the constant, and the action creator function passes
    the constant to the dispatcher. Stores also use these constants when determining
    how to handle actions as they're dispatched. This creates an explicit tie between
    the action creator and the code in stores that respond to this action.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是Flux架构中明确动作的绝佳方式。动作模块定义了常量，动作创建函数将常量传递给派发器。存储在确定如何处理派发的动作时也会使用这些常量。这就在动作创建器和响应此动作的存储中的代码之间建立了一个明确的联系。
- en: In [Chapter 10](ch10.html "Chapter 10. Implementing a Dispatcher"), *Implementing
    a Dispatcher*, we adopted a different approach. The action creator functions still
    defined constants and used them when dispatching the action. However, we made
    changes that allowed for our stores to define method handlers. So instead of one
    function that listened to the dispatcher, the stores defined methods that matched
    the constant defined for the action. This is convenient from the store's perspective,
    but it diminishes the value of having constants if they're only used by the action
    creator functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。实现派发器")《实现派发器》中，我们采用了不同的方法。动作创建函数仍然定义了常量，并在派发动作时使用它们。然而，我们进行了更改，允许我们的存储定义方法处理器。因此，而不是一个监听派发器的函数，存储定义了与动作定义的常量相匹配的方法。从存储的角度来看，这很方便，但如果常量只被动作创建函数使用，那么它们的价值就会降低。
- en: A Flux library could help make dispatching and handling actions a little more
    straightforward. Using constants and `switch` statements is good insofar as it
    makes what's happening explicit. We like explicitness in our Flux architecture.
    The challenge is that this approach requires diligence on the part of the programmers
    implementing the system. In other words, there's plenty of opportunity for human
    error. A Flux library could remove the error-prone aspects of dealing with constants
    in two places.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Flux库可以帮助使派发和处理动作变得更加直接。使用常量和`switch`语句是好的，因为它们使发生的事情变得明确。我们喜欢在Flux架构中保持明确性。挑战在于，这种方法要求程序员在实现系统时保持警惕。换句话说，有大量机会出现人为错误。Flux库可以消除处理常量时可能出现的错误。
- en: 'Another area that a Flux library could help is with asynchronous action creator
    functions. The asynchronous behavior of our application is likely to follow a
    similar pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Flux库可以帮助的领域是与异步动作创建函数相关。我们应用程序的异步行为可能遵循类似的模式：
- en: Dispatch an action that changes the state of a store before the asynchronous
    code runs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异步代码运行之前派发一个改变存储状态的动作
- en: Dispatch an action when the response arrives
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当响应到达时派发一个动作
- en: Dispatch a different action if the asynchronous behavior fails.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果异步行为失败，派发不同的动作。
- en: It's almost like asynchronous actions have a lifecycle that could be abstracted
    into a common function by a Flux library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎就像异步动作有一个生命周期，可以通过Flux库将其抽象成一个通用函数。
- en: Implementation pain points
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现痛点
- en: In the preceding section, we covered the areas of Flux that might benefit from
    a custom implementation. Before we dive into `Alt.js` and Redux, we'll briefly
    talk about some of pain points with implementing Flux architectures. Asynchronous
    actions are tough to get right, in any architecture, let alone Flux. The way we
    partition our application state into stores can be a tricky design problem. If
    we get this wrong, it can be hard to recover from. Finally, we have data dependency
    challenges to think about.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了Flux中可能从自定义实现中受益的领域。在我们深入探讨`Alt.js`和Redux之前，我们将简要讨论一些实现Flux架构的痛点。在任意架构中，异步动作都是难以做对的，更不用说Flux了。我们将应用程序状态划分到存储中的方式可能是一个棘手的设计问题。如果我们做错了，可能很难恢复。最后，我们还有数据依赖问题需要考虑。
- en: Dispatching asynchronous actions
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发异步动作
- en: As we discussed in the preceding section, asynchronous action creators are difficult
    to implement. It's challenging because we usually have to let the stores know
    that this asynchronous action is about to take place so that the UI can be updated
    to reflect this. For example, when a button is clicked that sends one or more
    AJAX requests, we probably want to disable that button before actually sending
    the request, to prevent duplicate requests. The only way to do this in Flux is
    to dispatch an action, because everything is unidirectional.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的，异步动作创建者难以实现。这很具挑战性，因为我们通常必须让存储知道这个异步动作即将发生，以便UI可以更新以反映这一点。例如，当点击一个发送一个或多个AJAX请求的按钮时，我们可能希望在实际上发送请求之前禁用该按钮，以防止重复请求。在Flux中，唯一的方法是分发一个动作，因为一切都是单向的。
- en: Libraries can help with this, to an extent. For example, the pre-request actions
    and success/error response actions can be somewhat abstracted into something that's
    easier to use, because that's a common pattern. However, even doing this leaves
    the issue of assembling requests to go fetch all the data that's needed for a
    given action, synchronize the responses and pass them each to the store so that
    it can transform them into something that the view needs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以在一定程度上帮助解决这个问题。例如，预请求动作和成功/错误响应动作可以抽象成更易于使用的东西，因为这是一个常见的模式。然而，即使这样做，也留下了组装请求以获取给定动作所需的所有数据、同步响应并将它们每个传递给存储以便将其转换为视图所需的内容的问题。
- en: Maybe it's best if we were to leave this asynchronous problem outside the scope
    of Flux. Facebook has introduced GraphQL, for example, a language that simplifies
    building complex data from backend services and only responding with what the
    store actually needs. This is all done in one response, so we save on bandwidth
    and latency as well. This approach isn't for everyone, and so it's up to the Flux
    implementer to choose how they want to deal with asynchronicity, just as long
    as the unidirectional data-flow on the client remains intact.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最好的办法是将这个异步问题排除在Flux的作用范围之外。例如，Facebook已经引入了GraphQL，这是一种简化从后端服务构建复杂数据并只响应存储实际需要的内容的语言。所有这些都在一个响应中完成，因此我们节省了带宽和延迟。这种方法并不适合每个人，因此Flux的实现者需要选择他们想要如何处理异步性，只要客户端的单向数据流保持完整即可。
- en: Partitioning stores
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 划分存储
- en: Incorrectly partitioning the stores in our Flux architecture is perhaps one
    of the biggest design risks we face. What generally happens is that the stores
    are roughly balanced; then, as the system evolves, all the new features end up
    going into one store while the responsibilities of the other stores aren't clear.
    The stores become unbalanced, in other words. The store that holds onto the majority
    of the application state gets too complex to maintain.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Flux架构中错误地划分存储可能是我们面临的最大设计风险之一。通常发生的情况是存储大致平衡；然后，随着系统的演变，所有的新功能最终都进入了一个存储，而其他存储的责任并不明确。换句话说，存储变得不平衡。持有大部分应用程序状态的存储变得过于复杂，难以维护。
- en: Another potential issue with the partitioning of our stores is that they grow
    to be too fine-grained. We don't want this to happen either. Though the state
    that's managed by individual stores is simple enough, the complexity resides in
    the dependencies between all these stores. Even if there aren't too many dependencies,
    when there's more stores to think about, it's more difficult to hold enough state
    in our heads as we're trying to reason about something. When related state is
    all in one place, it's much easier to predict what will happen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储分区可能存在的另一个潜在问题是它们变得过于细粒度。我们也不想看到这种情况发生。尽管由单个存储管理的状态足够简单，但复杂性在于所有这些存储之间的依赖关系。即使没有太多的依赖关系，当需要考虑更多的存储时，在试图推理某事时，我们的大脑中很难保持足够的状态。当相关状态都在一个地方时，预测会发生什么要容易得多。
- en: What if a Flux library, like Redux, took a radical approach and eliminated all
    sources of confusion by only allowing a single store? This indeed prevents design
    issues like partitioning stores. Instead, as we'll see later on the chapter, Redux
    uses reducer functions to transform the state of the single store.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Flux库，比如Redux，采取激进的措施，只允许一个存储，从而消除所有混淆的来源，会怎么样？这确实防止了设计问题，如存储分区。相反，正如我们将在本章后面看到的那样，Redux使用reducer函数来转换单个存储的状态。
- en: Using Alt
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Alt
- en: '`Alt.js` is a Flux library that implements a lot of the boilerplate code for
    us. It completely adheres to the Flux concepts and patterns, but let''s us focus
    on the architecture from the perspective of our application, rather than worrying
    about action constants and `switch` statements.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alt.js`是一个为我们实现大量模板代码的Flux库。它完全遵循Flux概念和模式，但让我们从应用架构的角度关注我们的应用，而不是担心动作常量和`switch`语句。'
- en: In this section, we'll touch on the core concepts of Alt before diving into
    a simple todo list example. The example is intentionally simple—you'll be able
    to map the code back to the Flux concepts you've learned about so far in this
    book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在深入研究简单的待办事项列表示例之前，简要介绍Alt的核心概念。示例故意很简单——你将能够将代码映射到你在本书中迄今为止学到的Flux概念。
- en: The core ideas
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心思想
- en: The main goal of the Facebook Flux package is to provide a reference implementation
    of a basic dispatcher component. This serves well as an aide to the concepts of
    Flux—actions are dispatched to stores in a synchronous, unidirectional fashion.
    As we've seen through the book, the dispatcher concept doesn't even necessarily
    need to be exposed to those who are implementing Flux. We can simplify the Flux
    abstractions and yet still fall within the constraints of a Flux architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook Flux包的主要目标是提供一个基本派发组件的参考实现。这很好地作为Flux概念的辅助——动作以同步、单向的方式派发到存储中。正如我们在书中所看到的，派发概念甚至不一定需要暴露给实现Flux的人。我们可以简化Flux抽象，同时仍然符合Flux架构的约束。
- en: Alt is a Flux library that's supposed to be used in production applications—it's
    not a reference implementation. Let's go over a few of it's goals as a Flux library
    before we jump into the code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Alt是一个旨在用于生产应用的Flux库——它不是一个参考实现。在我们深入代码之前，让我们先了解一下它作为Flux库的一些目标。
- en: '**Compliant**: Alt doesn''t borrow ideas from Flux—it''s truly meant for Flux
    systems. For example, the concept of stores, actions, and views are all relevant.
    Likewise, the principles of Flux architecture are followed closely by Alt. Things
    like synchronous update rounds and unidirectional data-flow are enforced.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性**：Alt不借鉴Flux中的想法——它真正是为Flux系统设计的。例如，存储、动作和视图的概念都相关。同样，Alt紧密遵循Flux架构的原则。像同步更新轮次和单向数据流这样的原则都得到了强制执行。'
- en: '**Automates boilerplate**: Some of the more tedious programming tasks associated
    with implementing Flux are handled nicely by Alt. These include things like automatically
    creating action creator functions and action constants. Alt will also take care
    of store action handler methods for us—reducing the need for long `switch` statements.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化模板代码**：与实现Flux相关的一些繁琐编程任务，Alt处理得很好。这包括自动创建动作创建函数和动作常量。Alt还会为我们处理存储动作处理方法——减少了对长`switch`语句的需求。'
- en: '**No dispatcher**: There''s no dispatcher for our code to interface with. Dispatching
    actions to all the stores is taken care of behind the scenes, when we call our
    action creator functions. Things like dependency management between stores are
    handled directly within the stores themselves.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有分发器**：我们的代码没有分发器与之交互。将动作分发到所有存储库是在我们调用动作创建者函数时在幕后处理的。存储库之间的依赖管理是在存储库内部直接处理的。'
- en: Creating stores
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建存储库
- en: 'The simple application that we''re going to create will display two lists for
    the user. One list is for the todo items, the other list is for the items that
    have been completed. We''ll use two stores—one for each list. Let''s take a look
    at how we create stores using `Alt.js`. First, we have the `Todo` store:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的简单应用将为用户显示两个列表。一个列表用于待办事项，另一个列表用于已完成的事项。我们将使用两个存储库——每个列表一个。让我们看看如何使用
    `Alt.js` 创建存储库。首先，我们有 `Todo` 存储库：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This probably doesn't look very familiar, relative to what we've seen so far
    in this book. Not to worry; we'll walk through the moving parts here now. The
    first question you probably have is—where's the state? It's not clear by looking
    at the code, but the state is any instance variables of the class. In this case,
    it's the `inputValue` string and the `todos` array.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在本书中迄今为止看到的内容相比，这可能看起来不太熟悉。不用担心；我们现在会逐步解释这些组件。你可能首先会问——状态在哪里？从代码中看不出来，但状态是类的任何实例变量。在这种情况下，是
    `inputValue` 字符串和 `todos` 数组。
- en: Next, we have a call to `bindListeners()` with a configuration object passed
    to it. This is how Alt stores map actions to methods. You can see that we have
    methods defined that correspond to what's passed into `bindListeners()`. Lastly,
    we have the call to `createStore()`. This function instantiates the `Todo` store
    class for us, but it also hooks up the dispatch mechanism.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个调用 `bindListeners()` 并传递一个配置对象给它。这就是 Alt 存储库如何将动作映射到方法的方式。你可以看到我们定义了与传递给
    `bindListeners()` 的内容相对应的方法。最后，我们有调用 `createStore()` 的操作。这个函数为我们实例化了 `Todo` 存储库类，同时也连接了分发机制。
- en: 'That''s all there is to the store definition—it''s ready to be used by views
    that need to render it''s state. Now let''s take a look at the `Done` store, which
    follows the same approach, only with fewer moving parts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库的定义就到这里——它已经准备好供需要渲染其状态的视图使用。现在让我们看看 `Done` 存储库，它遵循相同的做法，只是组件更少：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see here that this store actually uses the `Todo` store to copy over
    item data when an item is marked as done. However, this store doesn't mutate the
    `Todo` store, as that would violate the unidirectional data-flow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个存储库实际上使用 `Todo` 存储库在项目标记为已完成时复制项目数据。然而，这个存储库不会修改 `Todo` 存储库，因为这会违反单向数据流。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These store classes aren't event emitters, so they don't explicitly emit anything
    when the state changes. For example when a todo is added, how do the views know
    that anything has changed? Since the `createTodo()` method is called automatically
    for us, the notification mechanism also happens automatically once our method
    has finished executing. We'll see more on the state change notification semantics
    momentarily.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些存储库类不是事件发射器，因此它们在状态改变时不会显式地发射任何内容。例如，当待办事项被添加时，视图如何知道有任何变化？由于 `createTodo()`
    方法会自动为我们调用，一旦我们的方法执行完毕，通知机制也会自动发生。我们稍后会看到更多关于状态改变通知语义的内容。
- en: Declaring action creators
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明动作创建者
- en: 'We''ve seen how stores respond to actions being dispatched. Now we need a means
    to actually dispatch these actions. This is probably the easiest aspect of our
    Alt application. Alt can generate the functions we need, as well as the constants
    that are used by the `bindListeners()` call in our stores. Let''s take a look
    at the actions module and see how this works with Alt:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了存储库如何响应分发的动作。现在我们需要一种实际分发这些动作的手段。这可能是我们 Alt 应用程序中最容易的部分。Alt 可以生成我们需要的函数，以及在我们存储库中由
    `bindListeners()` 调用使用的常量。让我们看看动作模块，看看它是如何与 Alt 一起工作的：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will export an object with action creator functions that have the same
    names as the strings passed to `generateActions()`. And it'll generate the action
    constants used by the store. Since our action creator functions are all very similar,
    `generateActions()` has high utility. There's a lot of boilerplate code that we
    no longer have to maintain. On the other hand, there are more complex cases that
    involve asynchronous actions that need more code than this. Take a look at the
    Alt documentation for asynchronous actions if you're interested in using this
    library for your project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导出一个包含具有与传递给 `generateActions()` 的字符串相同名称的动作创建函数的对象。它还将生成存储使用的动作常量。由于我们的动作创建函数都非常相似，`generateActions()`
    具有很高的实用性。我们不再需要维护大量的样板代码。另一方面，还有一些更复杂的案例，涉及需要更多代码的异步动作。如果您对在项目中使用此库感兴趣，请查看 Alt
    文档中的异步动作。
- en: Listening for state changes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听状态变化
- en: 'All throughout this book, we''ve added event handler functions to the change
    event emitted by our stores. With libraries like Alt, this is somewhat managed
    for us already. Let''s take a look at the main module of our application which
    uses the `AltContainer` React component to feed store data into our other React
    components:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们都在我们的存储发出的更改事件上添加了事件处理函数。使用像 Alt 这样的库，这已经为我们管理了一部分。让我们看看我们应用程序的主要模块，它使用
    `AltContainer` React 组件将存储数据馈送到我们的其他 React 组件：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `AltContainer` component accepts a `stores` property. The container will
    listen to each of these stores and re-render it's children when the state of the
    any store changes. This is the only setup involved for getting our views to listen
    to stores—no manual `on()` or `listen()` calls all over the place. In the next
    section, we'll look at the `TodoList` and the `DoneList` components to see how
    they work with `AltContainer`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`AltContainer` 组件接受一个 `stores` 属性。容器将监听这些存储中的每一个，并在任何存储的状态发生变化时重新渲染其子组件。这是获取我们的视图监听存储的唯一设置——无需在各个地方手动调用
    `on()` 或 `listen()`。在下一节中，我们将查看 `TodoList` 和 `DoneList` 组件，看看它们是如何与 `AltContainer`
    一起工作的。'
- en: Rendering views and dispatching actions
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染视图和分发动作
- en: 'The job of the `TodoList` component is to render items from the `Todo` store.
    There are two other things this view needs to handle as well. First, there''s
    the `input` element that the user uses to enter new todo items. Second, we also
    need to mark items as done when they''re clicked, by moving them to the done list.
    These latter two responsibilities involve event handling and dispatching actions.
    Let''s take a look at the implementation of the todo list view:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoList` 组件的职责是渲染来自 `Todo` 存储的项目。这个视图还需要处理两件事。首先，有一个用户用来输入新待办事项的 `input`
    元素。其次，我们需要在点击项目时将其标记为完成，通过将其移动到完成列表中。后两个职责涉及事件处理和分发动作。让我们看看待办事项视图的实现：'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why we can't just clear `e.target.value` when the **Enter**
    key is pressed. Indeed we could do this, but this would go against the nature
    of Flux where state is kept in stores. This includes transient values as they're
    being entered by the user. What if another part of the application wanted to know
    about the text input value? Well, all it needs is to depend on the `Todo` store.
    If the state wasn't there, then our code would have to query the DOM, which we
    don't want to do.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么我们不能在按下 **Enter** 键时直接清除 `e.target.value`。确实，我们可以这样做，但这会违反 Flux 的本质，其中状态被保存在存储中。这包括用户输入时的临时值。如果应用程序的另一个部分想要了解文本输入值，它只需要依赖于
    `Todo` 存储。如果状态不存在，那么我们的代码将不得不查询 DOM，而我们不想这样做。
- en: 'Finally, let''s look at the done list component. This component is simpler
    than the todo list because there''s no event handling:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看完成列表组件。这个组件比待办事项列表更简单，因为没有事件处理：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using Redux
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux
- en: In this section, we're going to look at the Redux library for implementing a
    Flux architecture. Unlike `Alt.js`, Redux doesn't aim for Flux compliance. The
    goal of Redux is to borrow the important ideas from Flux, leaving the tedious
    bits behind. Despite not implementing Flux components as specified in the official
    documentation, Redux is the go-to solution for React architectures now. Redux
    is proof that simplicity always wins over advanced features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Redux 库来实现 Flux 架构。与 `Alt.js` 不同，Redux 并不旨在实现 Flux 兼容。Redux 的目标是借鉴
    Flux 的重要思想，而将繁琐的部分留在了后面。尽管 Redux 没有按照官方文档中指定的方式实现 Flux 组件，但现在 Redux 是 React 架构的首选解决方案。Redux
    证明了简洁性总是胜过高级功能。
- en: The core ideas
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心思想
- en: 'Before implementing some Redux code, let''s take a moment to look at the core
    ideas of Redux:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现一些Redux代码之前，让我们花一点时间来了解一下Redux的核心思想：
- en: '**No dispatcher**: This is just like `Alt.js`, which also purges the dispatcher
    concept from it''s API. The fact that these Flux libraries don''t expose a dispatcher
    component serves to illustrate the point that Flux is just a set of ideas and
    patterns, not an implementation. Both Alt and Redux dispatch actions, they just
    don''t require a dispatcher to do it.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有分发器**：这就像`Alt.js`，它也从其API中移除了分发器的概念。这些Flux库没有暴露分发器组件的事实有助于说明Flux只是一套思想和模式，而不是一个实现。Alt和Redux都分发动作，只是它们不需要分发器来完成。'
- en: '**One store to rule them all**: Redux eschews the notion that a Flux architecture
    requires multiple stores. Instead, one store is used to hold the entire application
    state. At first glance, this might sound like the store would get too large and
    be too difficult to understand. This is just as likely to happen with multiple
    stores, the only difference there is that the application state is split into
    different modules.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个存储器统治一切**：Redux摒弃了Flux架构需要多个存储器的观点。相反，使用一个存储器来保存整个应用程序状态。乍一看，这可能会让人觉得存储器会变得太大，难以理解。这种情况在多个存储器中同样可能发生，唯一的区别是应用程序状态被分割成不同的模块。'
- en: '**Dispatch to the store**: When there''s only one store to worry about, we
    can make design concessions, such as treating the store and the dispatcher as
    the same concept. This is exactly what Redux does—it dispatches actions directly
    to the store.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向存储器分发**：当只有一个存储器需要担心时，我们可以做出一些设计上的让步，比如将存储器和分发器视为同一概念。这正是Redux所做的事情——它直接向存储器分发动作。'
- en: '**Pure reducers**: The idea behind multiple Flux stores is to split the application
    state into a few logically separated domains. We can still do this using Redux,
    the difference is that we separate our state into domains using reducer functions.
    These functions are responsible for transforming the state of the store when actions
    are dispatched. They''re pure because they return new data and avoid introducing
    any side-effects.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯减法器**：多个Flux存储背后的想法是将应用程序状态分割成几个逻辑上分离的域。我们仍然可以使用Redux来实现这一点，区别在于我们使用减法函数将状态分割成域。这些函数负责在分发动作时转换存储的状态。它们是纯的，因为它们返回新的数据并避免引入任何副作用。'
- en: Reducers and stores
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减法器和存储器
- en: We're now going to implement the same simple todo application that we made using
    Alt—this time using Redux. There's a lot of overlap between the two libraries,
    particularly with the React components themselves; not much needs to change there.
    Where Redux departs from Alt and Flux in general is with it's single store, and
    the reducer functions that change it's state. With that said, we'll look at the
    store and it's reducer functions first.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现与使用Alt所制作的相同简单的待办事项应用程序——这次使用Redux。这两个库之间有很多重叠，尤其是与React组件本身；那里不需要做太多改变。Redux与Alt和Flux的一般区别在于它的单个存储器以及改变其状态的减法函数。话虽如此，我们将首先查看存储器和它的减法函数。
- en: 'We''ll create a module for the initial state of the the Redux store. This is
    an important first step because it provides the initial structure for the reducer
    functions that transform the store state. Let''s take a look at the initial state
    module:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为Redux存储的初始状态创建一个模块。这是一个重要的第一步，因为它为转换存储状态的减法函数提供了初始结构。让我们看看初始状态模块：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The state is a simple JavaScript object. You can see that the single store isn't
    just a tangled mess of properties, it's organized by two main properties—`Todo`
    and `Done`. This is like having multiple stores, except they're in one object.
    Something else you'll notice is that each store property is an `Immutable.js`
    data structure. The reason for this is that we need to treat the state that's
    passed into our reducer functions as immutable. This library makes enforcing immutability
    easy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是一个简单的JavaScript对象。你可以看到单个存储器并不是一个杂乱无章的属性集合，而是由两个主要属性——`Todo`和`Done`——组织起来的。这就像拥有多个存储器，只是它们在一个对象中。你还会注意到每个存储属性都是一个`Immutable.js`数据结构。之所以这样做，是因为我们需要将传递给我们的减法函数的状态视为不可变的。这个库使得强制不可变性变得容易。
- en: 'The state transformations that take place with the store state will be divided
    into two reducer functions. In fact, the two functions map to the two initial
    properties of the store: `Todo` and `Done`. Let''s look at the `Todo` reducer
    first:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 存储器状态发生的状态转换将被分为两个减法函数。实际上，这两个函数映射到存储器的两个初始属性：`Todo`和`Done`。让我们首先看看`Todo`减法函数：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `switch` statement that's used here should look familiar—it's the same pattern
    we've been implementing the stores throughout this book. In fact, this function
    is just like a store, with two main differences. The first difference is that
    it's a function instead of a class. This means that instead of setting state property
    values, we return the new state. The second difference is that Redux handles the
    mechanics of listening to stores and calling this reducer function. With classes,
    we have to write a lot of this code ourselves.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的 `switch` 语句应该看起来很熟悉——这是我们一直在本书中实现存储的模式。实际上，这个函数就像一个存储，有两个主要区别。第一个区别是它是一个函数而不是一个类。这意味着我们不是设置状态属性值，而是返回新状态。第二个区别是
    Redux 处理监听存储和调用此 reducer 函数的机制。使用类时，我们必须自己编写大量这样的代码。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important that these reducer functions do not mutate the state argument.
    This is why we're using the `Immutable.js` library—to make it easier to transform
    existing state by creating new data. It's not necessary to use `Immutable.js`
    for transforming Redux store state, but it does help with code brevity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这些 reducer 函数不修改状态参数非常重要。这就是为什么我们使用 `Immutable.js` 库——使通过创建新数据来转换现有状态变得更容易。对于转换
    Redux 存储状态来说，使用 `Immutable.js` 不是必需的，但它确实有助于代码简洁性。
- en: 'Now let''s look at the `Done` reducer function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `Done` reducer 函数：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''re almost done with our Redux store. At this point, we have two reducer
    functions, each in their own module. We need to tie them together using `combineReducers()`
    and `createStore()`. Let''s take a look at our store module now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了我们的 Redux 存储。到目前为止，我们有两个 reducer 函数，每个函数都在它们自己的模块中。我们需要使用 `combineReducers()`
    和 `createStore()` 将它们结合起来。现在让我们看看我们的存储模块：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the `combineReducers()` function creates a new function. This
    is the main reducer function that maintains the state of the application. So instead
    of your typical Flux dispatcher that needs to handle getting actions to several
    stores, Redux actions are dispatched to this single store, and our reducer functions
    are called in response.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`combineReducers()` 函数创建了一个新的函数。这是维护应用程序状态的主要 reducer 函数。所以，与需要处理将动作发送到多个存储的典型
    Flux 分发器不同，Redux 动作被发送到这个单一存储，并且我们的 reducer 函数会相应地被调用。
- en: Redux actions
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux 动作
- en: As you know, there's a difference between actions and action creators. Actions
    are the payloads that get sent to the various Flux stores, whereas action creators
    are responsible for creating the action payloads, and then sending them to the
    dispatcher. With Redux, action creator functions are slightly different in that
    they only create the action payloads, they don't talk directly with the dispatcher.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，动作和动作创建者之间有一个区别。动作是将要发送到各个 Flux 存储的负载，而动作创建者负责创建动作负载，然后将它们发送到分发器。在 Redux
    中，动作创建者函数略有不同，因为它们只创建动作负载，并不直接与分发器通信。
- en: 'We''ll see how the action creators are called in the following section when
    we implement the view components. But for now, here''s what our actions module
    looks like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现视图组件时，将在下一节中看到动作创建者是如何被调用的。但就目前而言，这是我们的动作模块的样子：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These functions just return the data that's going to be dispatched by the store—they
    don't actually dispatch the data. The exception to this is when asynchronous actions
    are involved. In this case, we actually need to dispatch the action once the asynchronous
    values have resolved. See the official Redux documentation where there are plenty
    of asynchronous action examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数只是返回存储将要分发的数据——它们实际上并不分发数据。例外情况是当涉及到异步操作时。在这种情况下，我们需要在异步值解决后实际分发动作。请参阅官方
    Redux 文档，其中包含大量的异步动作示例。
- en: Rendering components and dispatching actions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染组件和分发动作
- en: 'At this point, we have a Redux store and action creator functions. All that''s
    left to do is implement our React components and connect them to the store. We''ll
    start with the `TodoList` view:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了 Redux 存储和动作创建者函数。剩下要做的就是实现我们的 React 组件并将它们连接到存储。我们将从 `TodoList` 视图开始：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The key thing to note about this module is that it's not the component class
    that's exported. Instead, we use the `connect()` function from the `react-redux`
    package. This function connects the Redux store to this view. The state from the
    store passes through the `mapStateToProps()` function, which determines how the
    React component properties are assigned. In this case, we just need to transform
    the `Immutable.js` structure into a plain JavaScript object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个模块的关键点是它不是导出的组件类。相反，我们使用来自`react-redux`包的`connect()`函数。这个函数将Redux存储与这个视图连接起来。存储中的状态通过`mapStateToProps()`函数传递，该函数决定了React组件属性是如何分配的。在这种情况下，我们只需要将`Immutable.js`结构转换成普通的JavaScript对象。
- en: 'The downside of the event handlers is that we need to bind their context in
    the constructor, because React doesn''t auto-bind the context for ES2015 style
    components. The handlers need access to `this.props` because it has the `dispatch()`
    function needed to dispatch our action data to the store, as well as the store
    data used to construct the action payloads. Now let''s look at the `DoneList`
    component:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器的缺点是我们需要在构造函数中绑定它们的上下文，因为React不会自动绑定ES2015风格组件的上下文。处理器需要访问`this.props`，因为它包含用于将我们的动作数据派发到存储的`dispatch()`函数，以及用于构建动作负载的存储数据。现在让我们看看`DoneList`组件：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, this works in much the same way as the `TodoList` component.
    In fact, these components haven''t changed much relative to the Alt implementation
    of the same application. The last step is to hook up the two components with the
    Redux store, which can be accomplished using the `Provider` component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这与`TodoList`组件的工作方式非常相似。实际上，这些组件与同一应用的Alt实现相比变化不大。最后一步是将这两个组件与Redux存储连接起来，这可以通过使用`Provider`组件来完成：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about leveraging Flux libraries. In particular,
    we looked at two of the prevailing libraries that can be used to implement Flux
    architectures.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何利用Flux库。特别是，我们查看了两款流行的库，这些库可以用来实现Flux架构。
- en: We started the chapter off with a discussion that was mostly a recap of the
    fundamental principles of Flux and how we implemented them throughout the previous
    chapters of this book. We then covered some of the various pain points of implementing
    Flux—like singleton dispatchers, repetitive action code, and partitioning store
    modules. These are areas that a library like `Alt.js` or Redux could address for
    us.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的开头进行了一次讨论，主要内容是对Flux的基本原则的回顾，以及我们在本书的前几章中如何实现这些原则。然后我们讨论了实现Flux的一些痛点——如单例派发器、重复的动作代码和存储模块的分区。这些都是`Alt.js`或Redux等库可以为我们解决的问题。
- en: We then proceeded to implement a simple todo application using the `Alt.js`
    Flux library. The idea behind Flux is to implement all the relevant Flux components
    while automating the typical arduous implementation chores behind the scenes for
    us. After this, we turned our attention to the Redux library. Redux is less concerned
    with following the Flux patterns exactly. Instead, Redux aims for simplicity while
    borrowing some of the more important Flux ideas like unidirectional data-flow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续使用`Alt.js` Flux库实现了一个简单的待办事项应用。Flux背后的想法是在后台自动化所有相关的Flux组件的实现，同时自动化一些典型的繁琐实现工作。之后，我们将注意力转向Redux库。Redux不太关心严格遵循Flux模式。相反，Redux追求简洁，同时借鉴了一些重要的Flux思想，如单向数据流。
- en: In the next chapter, we'll cover two very important aspects of any Flux architecture—functional
    and performance testing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍任何Flux架构的两个非常重要的方面——功能测试和性能测试。
