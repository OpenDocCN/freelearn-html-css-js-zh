<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Using Databases and Managing Files</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accessing your database's Ti.Filesystem</li><li class="listitem" style="list-style-type: disc">DbTableChecker SQLite table existence checking</li><li class="listitem" style="list-style-type: disc">Recursively handling files using Dossier</li><li class="listitem" style="list-style-type: disc">Tuning your SQLite database for maximum performance</li><li class="listitem" style="list-style-type: disc">Data access using DbLazyProvider</li><li class="listitem" style="list-style-type: disc">NoSQL using MongloDb</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Introduction</h1></div></div></div><p>Titanium has several components designed to assist in handling your data needs. Additionally, the Titanium open source community has provided a wealth of alternative data-handling options.</p><p>The recipes in this chapter demonstrate a variety of helpful approaches to work with data while on the device. With topics ranging from file-system management to SQLite tuning, there will be an approach to assist your Enterprise data needs, no matter what your preferred approach is.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Accessing your database's Ti.Filesystem</h1></div></div></div><p>Titanium includes a powerful database API that provides easy access to the underlying platform's SQLite implementation. Having access to <code class="literal">Ti.Filesystem</code> for your app's SQLite database allows you the flexibility to handle updates, migrations, and installations more effectively.</p><p>The <code class="literal">DbFileExt</code> module<a id="id213" class="indexterm"/> provides easy access to your SQLite <code class="literal">Ti.Filesystem</code> object. The<a id="id214" class="indexterm"/> module also includes other convenient methods to help work with database files.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Getting ready</h2></div></div></div><p>Adding the<a id="id215" class="indexterm"/> <code class="literal">DbFileExt</code> module to your project is easy. Simply copy the <code class="literal">dbfileext.js</code> file into your project, as shown in the following screenshot:</p><div><img src="img/5343OT_03_01.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>How to do it…</h2></div></div></div><p>Once you've added the <code class="literal">dbfileext.js</code> file to your project, you need to use <code class="literal">require</code> to import the module into your code:</p><div><pre class="programlisting">//Create our application namespace
var my = {
  isAndroid : Ti.Platform.osname === 'android',
  dbfileext : require('dbfileext')
};</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec52"/>Finding our database Ti.Filesystem.File</h3></div></div></div><p>The <code class="literal">dbFile</code> function<a id="id216" class="indexterm"/> <a id="id217" class="indexterm"/>provides easy access to the <code class="literal">Ti.Filesystem.File</code> object for your database. Simply provide the database name you wish to access, and the associated <code class="literal">Ti.Filesystem.File</code> object will be returned:</p><div><pre class="programlisting">Var myDbFile = my.dbfileext.dbFile('testdb');</pre></div><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>If an invalid database name is provided to the <code class="literal">dbFile</code> function, a new <code class="literal">Ti.Filesystem.File</code> object will be returned. This allows you to add a database or file later. It is recommended to use the <code class="literal">exists</code> method when any operations are performed.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec53"/>Determining the database directory</h3></div></div></div><p>Determining your <a id="id218" class="indexterm"/>application's database folder can be challenging, as it differs according to the platform. Leveraging the <code class="literal">dbDirectory</code> function<a id="id219" class="indexterm"/> assists with this challenge, providing you specify the appropriate directory path based on the device your app is running on:</p><div><pre class="programlisting">my.dbfileext.dbDirectory();</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec54"/>File exist check</h3></div></div></div><p>You will <a id="id220" class="indexterm"/>often need to check if a database has been installed, before opening. The <code class="literal">DbFileExt</code> module makes this straightforward with the <code class="literal">dbExists</code> function<a id="id221" class="indexterm"/>. Simply paste in the database name and a Boolean is returned, identifying if the database has been installed:</p><div><pre class="programlisting">my.dbfileext.dbExists('testdb');</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec55"/>RemoteBackup – iOS-specific attribute</h3></div></div></div><p>With iOS 5, Apple included the ability to back up files to the iCloud service. You can enable or disable this feature on your SQLite database file through the use of the <code class="literal">dbRemoteBackup</code> function<a id="id222" class="indexterm"/>. When you provide the database name and a Boolean, you are indicating if you would like to have remote backup enabled:</p><div><pre class="programlisting">my.dbfileext.dbRemoteBackup('testdb',true);</pre></div><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>If this function is called on the Android platform, no action will be performed, as this relates to iOS-specific functionality.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec56"/>Renaming a database file</h3></div></div></div><p>The <code class="literal">DbFileExt</code> module<a id="id223" class="indexterm"/> allows you to rename your database files. This can be helpful when versioning or keeping backups of your database. To rename a database, provide the current database name and the new name as parameters to the <code class="literal">dbRename</code> method, as the following statement shows:</p><div><pre class="programlisting">my.dbfileext.dbRename('current name','new name');</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec57"/>Listing all databases</h3></div></div></div><p>When dealing<a id="id224" class="indexterm"/> with large apps, or apps that require database versioning, you will often need a list of all the databases installed within your app's sandbox. The <code class="literal">dbList</code> function provides the name and native path for each SQLite database within your app's database folder. You can then use this array to remove any unneeded database files:</p><div><pre class="programlisting">var installedDatabase = my.dbfileext.dbList();</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec58"/>Removing a database file</h3></div></div></div><p>The <code class="literal">dbRemove</code> function <a id="id225" class="indexterm"/>provides an easy and safe way to remove any unwanted database files. Provide the database name you wish to delete and the <code class="literal">DbFileExt</code> module will remove the file from your device:</p><div><pre class="programlisting">my.dbfileext.dbRemove('newtest');</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>How it works…</h2></div></div></div><p>The next series of<a id="id226" class="indexterm"/> tests demonstrate how the <code class="literal">DbFileExt</code> module works within a windowless sample <code class="literal">app.js</code>.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec59"/>Setting up our test</h3></div></div></div><p>First, we<a id="id227" class="indexterm"/> use the <code class="literal">Ti.Database.open</code> function to create a sample database. The following highlighted code demonstrates how to create a database named <code class="literal">testdb</code>:</p><div><pre class="programlisting">//Create our application namespace
var my = {
    isAndroid : Ti.Platform.osname === 'android',dbfileext : require('dbfileext')
};

<strong>var testDb = Ti.Database.open('testdb');</strong>
</pre></div><p>Next, we build a <code class="literal">Ti.Filesystem</code> object with a known reference to our <code class="literal">testdb</code> database. This will later be used to verify if the <code class="literal">DbFileExt</code> module is returning the correct values.</p><div><pre class="programlisting">var testFileReference = (function(){
  if(my.isAndroid){
    return Ti.Filesystem.getFile(
  }else{
    return testDb.file;
  }
})();</pre></div><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>The iOS <code class="literal">Ti.Database</code> object has a file property that can be used in your tests. On Android, you need to create the file object using the proper directory and file names.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec60"/>Finding our database Ti.Filesystem</h3></div></div></div><p>Next, we compare <a id="id228" class="indexterm"/>the <code class="literal">Ti.Filesystem.File</code> object returned by the <code class="literal">DbFileExt</code> module to see if it matches our test file. These should always match no matter what the platform.</p><div><pre class="programlisting">Ti.API.info("Does the module return the same as our test?");
Ti.API.info((testFileReference.nativePath === my.dbfileext.dbFile('testdb').nativePath) ?
"Test Pass" : "Test Failed");</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec61"/>Determining database directory</h3></div></div></div><p>The directory <a id="id229" class="indexterm"/>where your SQLite file is installed differs by platform. For example, it is in the <code class="literal">data</code> directory on Android and the <code class="literal">Private Documents</code> folder on iOS. The next example demonstrates how to write the path to your devices database directory to Titanium Studio's console:</p><div><pre class="programlisting">Ti.API.info("Your database directory is " + my.dbfileext.dbDirectory());</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec62"/>File exist check</h3></div></div></div><p>The most common <a id="id230" class="indexterm"/>use of the <code class="literal">DbFileExt</code> module is to check if a database has already been installed. The next test compares the <code class="literal">dbExists</code> result in <code class="literal">DbFileExt</code> with those generated by our test <code class="literal">Ti.Filesystem.File</code> object:</p><div><pre class="programlisting">Ti.API.info("Does the exists test work?");
Ti.API.info((testFileReference.exists() === my.dbfileext.dbExists('testdb')) ? "Both Exist" : "Test Failed");</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec63"/>Renaming a database file</h3></div></div></div><p>You will encounter<a id="id231" class="indexterm"/> the need to rename databases for a variety of reasons, the most common being archiving or versioning. The following highlighted code demonstrates how to rename the <code class="literal">testdb</code> database to <code class="literal">oldtest</code>. The <code class="literal">dbExists</code> method is then called on both the new and old names to demonstrate that the rename function has worked properly.</p><div><pre class="programlisting">
<strong>my.dbfileext.dbRename('testdb','oldtestdb');</strong>
Ti.API.info("Does the test db exist?  " + my.dbfileext.dbExists('testdb'));
Ti.API.info("How about the oldtest one? Does that exist?  " + my.dbfileext.dbExists('oldtest'));</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec64"/>Listing all databases</h3></div></div></div><p>It is often helpful to have<a id="id232" class="indexterm"/> a list of all the databases that are available within your app. This can be particularly helpful with large apps or apps containing third-party components.</p><p>To demonstrate this functionality, first we create several databases in our sample app:</p><div><pre class="programlisting">Ti.Database.open('test1');
Ti.Database.open('test2');
Ti.Database.open('test3');</pre></div><p>The <code class="literal">dbList</code> function<a id="id233" class="indexterm"/> of the <code class="literal">DbFileExt</code> module is used to return all the databases installed into our app:</p><div><pre class="programlisting">var installedDb =  my.dbfileext.dbList();</pre></div><p>The following snippet writes the list of databases provided by the <code class="literal">installedDb</code> variable to Titanium Studio's console.<a id="id234" class="indexterm"/> This will list all of the databases used in this sample, along with any that might also be installed within your Titanium project.</p><div><pre class="programlisting">installedDb.forEach(function(db) {
  Ti.API.info("Db Name = " + db.dbName);
  Ti.API.info("nativePath = " + db.nativePath);
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec65"/>Removing a database file</h3></div></div></div><p>The final test in this recipe <a id="id235" class="indexterm"/>demonstrates how to use the <code class="literal">dbRemove</code> function to delete an installed database. The following highlighted snippet shows how to delete the <code class="literal">oldtest</code> database that we used earlier in the sample:</p><div><pre class="programlisting">
<strong>my.dbfileext.dbRemove('oldtest');</strong>
Ti.API.info("db still exists?  " + my.dbfileext.dbExists('oldtest'));</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>DbTableChecker SQLite table existence checking</h1></div></div></div><p>SQLite and the <code class="literal">Ti.Database</code> API provide many powerful features. This recipe demonstrates how to use the existing <code class="literal">Ti.Database</code> API and SQL statements to check if a table has already been created.</p><p>The ability to check if database<a id="id236" class="indexterm"/> objects exist is critical for Enterprise apps, for versioning and data migration purposes A typical usage of this process would be to check if a table already exists during schema migration. For example, a specific data migration might be performed if the client table in your app already exists while creating the table for the first time.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Getting ready</h2></div></div></div><p>This recipe relies on the Titanium framework's <code class="literal">Ti.Database</code> API, requiring no dependencies. In the next section, we create a simple <code class="literal">app.js</code> file, demonstrating how to perform the table-exists check.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>How to do it…</h2></div></div></div><p>The following steps demonstrate how to check if a table exists within an SQLite database.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec66"/>Creating our module</h3></div></div></div><p>In Titanium Studio, create a module called <code class="literal">db</code>
<a id="id237" class="indexterm"/>
<code class="literal">tablechecker.js</code>. This module should have the following code snippet:</p><div><pre class="programlisting">exports.tableExists = function (dbName, tableName){
  var conn = Ti.Database.open(dbName);
  var selectSQL ='SELECT name FROM sqlite_master 'selectSQL +=' WHERE type="table" AND name=?';

  var getReader = conn.execute(selectSQL,tableName);
  var doesExist = (getReader.getRowCount() &gt; 0 );

  //Clean-up
  getReader.close();
  conn.close();
  getReader = null;
  conn = null;

  return doesExist;
};</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec67"/>Namespace and app setup</h3></div></div></div><p>Next, in our application's <code class="literal">app.js</code> file, we create our<a id="id238" class="indexterm"/> application namespace and use the <code class="literal">require</code> method to import the <code class="literal">CommonJS</code> module into our application:</p><div><pre class="programlisting">//Create our application namespace
var my = {
  dbTableChecker : require('dbtablechecker')
};</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec68"/>Creating our window</h3></div></div></div><p>To help demonstrate<a id="id239" class="indexterm"/> this recipe, a window with three buttons is created. These buttons will allow you to create, test whether the table exists, and remove the <code class="literal">myTable</code> sample table.</p><div><pre class="programlisting">var win = Ti.UI.createWindow({
  backgroundColor:'#fff',layout:'vertical'
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec69"/>Testing if a table exists</h3></div></div></div><p>The first button in the<a id="id240" class="indexterm"/> recipe demonstrates how to call the <code class="literal">tableExists</code> function created earlier in the <code class="literal">CommonJS</code> module <a id="id241" class="indexterm"/>of <code class="literal">dbTableChecker</code>:</p><div><pre class="programlisting">var tableExistsBtn = Ti.UI.createButton({
    title:'Does Table Exist?', height:50, right:5, left:5, top: 20
});
win.add(tableExistsBtn);</pre></div><p>When the button is pressed, the <code class="literal">tableExists</code> function<a id="id242" class="indexterm"/> is called within our <code class="literal">CommonJS</code> module to determine if the specified table exists. The next highlighted code snippet demonstrates checking if a table named <code class="literal">myTable</code> exists within the <code class="literal">myDatabase</code> SQLite database.</p><div><pre class="programlisting">tableExistsBtn.addEventListener('click',function(e){
  //Check if our table exists in our database
  <strong>var doesExist = my.dbTableChecker.</strong>
<strong>tableExists('myDatabase','myTable');</strong>
  //Alert the user if the table exists or not
  alert('Table "myTable" ' + (doesExist ? ' exists' : "does not exist"));
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec70"/>Creating a table</h3></div></div></div><p>The next button in this recipe<a id="id243" class="indexterm"/> is used to create a sample table, which is to be used in our tests. When exploring this recipe, this button will allow you to drop and re-create a sample table several times.</p><div><pre class="programlisting">var makeTestBtn = Ti.UI.createButton({
  title:'Create Test Table', height:50, right:5, left:5, top: 20
});
win.add(makeTestBtn);</pre></div><p>The following highlighted code demonstrates calling the <code class="literal">my.testers.makeTable</code> function to create a table named <code class="literal">myTable</code> in the <code class="literal">myDatabase</code> database:</p><div><pre class="programlisting">makeTestBtn.addEventListener('click',function(e){
  //Create a sample table
<strong>  my.testers.makeTable('myDatabase','myTable');</strong>

  //Alert the user a test table has been created
  alert('Table "myTable" was created.');
});</pre></div><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>See this recipe's <em>How it works…</em> section for more information on <code class="literal">my.testers</code>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec71"/>Removing a table</h3></div></div></div><p>The last button in this <a id="id244" class="indexterm"/>recipe is used to drop the sample table. When exploring this recipe, this button will allow you to drop and re-create a sample table several times:</p><div><pre class="programlisting">var removeTestBtn = Ti.UI.createButton({
  title:'Remove Test Table', height:50, right:5, left:5, top: 20
});
win.add(removeTestBtn);</pre></div><p>The highlighted line in the following code snippet demonstrates how to call the <code class="literal">my.testers.removeTable</code> function to drop a table named <code class="literal">myTable</code> in our database:</p><div><pre class="programlisting">removeTestBtn.addEventListener('click',function(e){
  //Create a sample table
  <strong>my.testers.removeTable('myDatabase','myTable');</strong>
  //Alert the user a test table has been removed
  alert('Table "myTable" was removed');
});</pre></div><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>See this recipe's <em>How it works…</em> section for more information on <code class="literal">my.testers</code>.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>How it works…</h2></div></div></div><p>This recipe uses the SQLite data dictionary and several helper methods to support testing. The functionality of these methods and how they are composed, is discussed here.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec72"/>Testing helpers</h3></div></div></div><p>This recipe uses two<a id="id245" class="indexterm"/> helper functions, <code class="literal">makeTable</code>
<a id="id246" class="indexterm"/> and <code class="literal">dropTable</code>, to <a id="id247" class="indexterm"/>manage our sample table. These methods allow for the <code class="literal">tableExists</code> method to be tested repeatedly without conflict.</p><div><pre class="programlisting">my.testers = {</pre></div><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">makeTable</code> function uses <code class="literal">dbName</code> to open a database connection. Once the database has been opened, a table is created (if it doesn't exist) using the provided <code class="literal">tableName</code> parameter:<div><pre class="programlisting">  makeTable : function(dbName,tableName){
    var conn = Ti.Database.open(dbName);
    var createSql = 'CREATE TABLE IF NOT EXISTS ' 
    createSql += tableName ;
    createSql += '(id INTEGER PRIMARY KEY AUTOINCREMENT,';
    createSql += ' my_column TEXT)';

    conn.execute(createSql);

    //Clean-up
    conn.close();
    conn = null;
  },</pre></div></li><li class="listitem">The <code class="literal">removeTable</code> function<a id="id248" class="indexterm"/> uses <code class="literal">dbName</code> to open a database connection. Once the database <a id="id249" class="indexterm"/>has been opened, the table name provided in the <code class="literal">tableName</code> parameter<a id="id250" class="indexterm"/> is dropped, if the table exists:<div><pre class="programlisting">  removeTable : function(dbName,tableName){
    var conn = Ti.Database.open(dbName);
    var dropSql = 'DROP TABLE IF EXISTS ' + tableName;

    conn.execute(dropSql);


    Conn.close();
    conn = null;
  }
};</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec73"/>The tableExists method</h3></div></div></div><p>The <code class="literal">dbTableCheck</code> module <a id="id251" class="indexterm"/>has a single method named <code class="literal">tableExists</code>
<a id="id252" class="indexterm"/> which returns a Boolean result if the provided table name exists within the database. This check is performed by querying the data dictionary of the SQLite database.</p><div><pre class="programlisting">exports.tableExists = function (dbName, tableName){
  var conn = Ti.Database.open(dbName);</pre></div><div><ol class="orderedlist arabic"><li class="listitem">The following SQL statements will query the SQLite data dictionary table, <code class="literal">sqlite_master</code>, for a list of tables with a specified table name. The <code class="literal">?</code> character is a parameter that is replaced by the execute method.<div><pre class="programlisting">  var selectSQL ='SELECT name FROM sqlite_master; selectSQL +=' WHERE type="table" AND name=?';</pre></div></li><li class="listitem">The data dictionary query is then executed using the <code class="literal">tableName</code> variable as its parameter. A <code class="literal">Ti.Database.DbResultSet</code> is returned and allocated to the <code class="literal">getReader</code> variable:<div><pre class="programlisting">  var getReader = conn.execute(selectSQL,tableName);</pre></div></li><li class="listitem">Next,<a id="id253" class="indexterm"/> the <code class="literal">getRowCount</code> method is used to determine if any rows are returned. This is converted into a Boolean statement that will later be returned by this method:<div><pre class="programlisting">  var doesExist = (getReader.getRowCount() &gt; 0 );</pre></div></li><li class="listitem">The <code class="literal">DbResultSet</code> and database is then closed to reduce the number of active objects:<div><pre class="programlisting">  getReader.close();
  conn.close();
  getReader = null;
  conn = null;</pre></div></li><li class="listitem">The Boolean result determined earlier is returned by the following method:<div><pre class="programlisting">  return doesExist;
};</pre></div></li></ol></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Recursively handling files using Dossier</h1></div></div></div><p>When creating your Titanium Enterprise app, you will often find the need to copy the contents of a directory to another place. Two of the most common examples of this would be: implementing a caching approach and performing lazy, loaded installations. For example, Dossier can be used to create an initial content cache, by copying files from your app's <code class="literal">Resources</code> directory into a working directory under <code class="literal">Ti.Filesystem.applicationDataDirectory</code>. This would allow for the user to see the initial content while data is being refreshed in the background.</p><p>The <code class="literal">Dossier</code>
<a id="id254" class="indexterm"/> CommonJS module provides a cross-platform API for handling these types of folder operations. The next section demonstrates how to install and use the <code class="literal">Dossier</code> module within your Titanium Enterprise app.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Getting ready</h2></div></div></div><p>The <code class="literal">Dossier</code> CommonJS module is installed by including the <code class="literal">dossier.js</code> file into your project.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec74"/>Adding the Dossier module into your project</h3></div></div></div><p>Adding the <code class="literal">dossier</code> module<a id="id255" class="indexterm"/> to your project is easy. Simply copy the <code class="literal">dossier.js</code> file and the <code class="literal">SampleData</code> folder into the <code class="literal">Resources</code> folder of your Titanium project, as highlighted in the following screenshot. This will install all the files needed for this recipe.</p><div><img src="img/5343OT_03_02.jpg" alt="Adding the Dossier module into your project"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>How to do it…</h2></div></div></div><p>Once you've added the <code class="literal">dossier.js</code> file to your project, you need to use <code class="literal">require</code> in order to import the module into your code:</p><div><pre class="programlisting">//Create our application namespace
var my = {
  dossier : require('dossier');
};</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec75"/>Creating sample directories</h3></div></div></div><p>To demonstrate the copy<a id="id256" class="indexterm"/> and move features of Dossier, a <code class="literal">Ti.Filesystem</code> object is created for both our source and destination directories. In the next snippet, the <code class="literal">sourceDir</code> variable contains a directory reference to the <code class="literal">SampleData</code> folder we copied as part of the recipe setup, and <code class="literal">targetDir</code> references a new folder named <code class="literal">NewSampleData</code>, to be created in your device's <code class="literal">data</code> directory.</p><div><pre class="programlisting">var sourceDir = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, 'SampleData');

var targetDir = Ti.Filesystem.getFile(
  Ti.Filesystem.applicationDataDirectory
  + '/NewSampleData');</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec76"/>Recursive listing of directory contents</h3></div></div></div><p>When dealing with <a id="id257" class="indexterm"/>dynamic or downloadable content, you will often need to list all of the content of a specific directory. The <code class="literal">listContents</code> method<a id="id258" class="indexterm"/> allows you to recursively query the content of a directory, listing all files and subdirectories within.</p><p>The following code snippet demonstrates how to query our recipe's <code class="literal">sourceDir</code> for a list of all files and folders:</p><div><pre class="programlisting">var listTargetContents = my.dossier.listContents(sourceDir.nativePath);</pre></div><p>The <code class="literal">listContents</code> method returns a file explorer dictionary object, listing all of the files and subdirectories in a hierarchal format, as highlighted in the following screenshot:</p><div><img src="img/5343OT_03_03.jpg" alt="Recursive listing of directory contents"/></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec77"/>Recursively copying directory contents</h3></div></div></div><p>Many Enterprise apps<a id="id259" class="indexterm"/> are content driven. To improve your first-time installation experience, you might wish to bundle introductory content within your app and copy this bundled content into local cache on startup.</p><p>Using <code class="literal">dossier</code> module's <code class="literal">copy</code> method, you can copy the entire content of one folder to another. The following code demonstrates how to copy all the content of our source directory to our new target directory:</p><div><pre class="programlisting">my.dossier.copy(sourceDir.nativePath,targetDir.nativePath);</pre></div><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>During the copy process, any existing content in the target folder will be removed.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec78"/>Recursively moving directory contents</h3></div></div></div><p>The <code class="literal">move</code> method<a id="id260" class="indexterm"/> <a id="id261" class="indexterm"/>creates a new copy of all the content of your source directory to your target folder. Once the copying process has been successfully completed, the source directory is removed.</p><div><pre class="programlisting">my.dossier.move(sourceDir.nativePath,targetDir.nativePath); </pre></div><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>During the move process, any existing content in the target folder will be removed and replaced with the content of our source folder. Additionally, after all the files have been moved, the source content will be removed if possible. In cases where the source directory is read-only, the contents will be retained.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Dossier</code> module <a id="id262" class="indexterm"/>used in this recipe is an open source project available on Github. If you are interested in learning more or contributing, please visit the project at <a class="ulink" href="https://github.com/benbahrenburg/Dossier">https://github.com/benbahrenburg/Dossier</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Tuning your SQLite database for maximum performance</h1></div></div></div><p>Data access is a common bottleneck in Titanium Enterprise development. Through proper use of SQLite transactions, you can experience up to a 10x improvement in bulk insert operations.</p><p>SQLite transactions<a id="id263" class="indexterm"/> provide reliable units of work that allow for data recovery and keep the database consistent. By default, each time an insert, update, or delete operation is performed on an SQLite database, an implicit transaction is created before and after your statement is executed. This helps keep your database in a consistent state. For batch operations however, this introduces an additional level of overhead and can drastically reduce your app's performance.</p><p>This recipe <a id="id264" class="indexterm"/>demonstrates how<a id="id265" class="indexterm"/> to use SQLite transactions to improve app performance when conducting batch SQL actions and working with large datasets.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Getting ready</h2></div></div></div><p>This recipe will run a performance comparison using 100,000 rows. Included in this recipe is the <a id="id266" class="indexterm"/>following basic UI that allows you to benchmark your different devices.</p><div><img src="img/5343OT_03_04.jpg" alt="Getting ready"/></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec79"/>Adding the TimeLogger module</h3></div></div></div><p>This recipe uses <a id="id267" class="indexterm"/>
<code class="literal">TimeLogger</code> to record the duration of each performance test. To add the<a id="id268" class="indexterm"/> <code class="literal">TimeLogger</code> module to your project, copy the <code class="literal">timelogger.js</code> file into your project, as shown in the following screenshot:</p><div><img src="img/5343OT_03_05.jpg" alt="Adding the TimeLogger module"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>How to do it…</h2></div></div></div><p>The first step<a id="id269" class="indexterm"/> in this recipe is to <a id="id270" class="indexterm"/>create the application namespace and import the timer module, as the following snippet demonstrates:</p><div><pre class="programlisting">//Create our application namespace
var my = {
  timer : require('timelogger')
};</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec80"/>Creating our testing Interface</h3></div></div></div><p>The next step<a id="id271" class="indexterm"/> is to create a <code class="literal">Ti.UI.Window</code> for our recipe. This will be used to provide a launching point for our performance tests.</p><div><pre class="programlisting">var win = Ti.UI.createWindow({
  backgroundColor:'#fff',layout:'vertical'
});</pre></div><div><ol class="orderedlist arabic"><li class="listitem">Now, a label is created to track the results of our <code class="literal">No Transactions</code> performance test:<div><pre class="programlisting">var noTransactionLabel = Ti.UI.createLabel({
    text: "No Transactions: NA",height:20, right:5, left:5, top: 40, textAlign:'left',color:'#000', font:{fontWeight:'bold',fontSize:14}
});
win.add(noTransactionLabel);</pre></div></li><li class="listitem">Then, a<a id="id272" class="indexterm"/> label is created to track the results of our <code class="literal">With Transactions</code> performance test:<div><pre class="programlisting">var withTransactionLabel = Ti.UI.createLabel({
  text: "With Transactions: NA",
  height:20, right:5, left:5, 
  top: 10, textAlign:'left',
  color:'#000', font:{fontWeight:'bold',fontSize:14}
});
win.add(withTransactionLabel);</pre></div></li><li class="listitem">The final UI element we create is a button that, when pressed, will launch our tests:<div><pre class="programlisting">var runTestButton = Ti.UI.createButton({
    title:'Start Performance Test', height:50, right:5, left:5, top: 40
});
win.add(runTestButton);</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec81"/>Benchmarking</h3></div></div></div><p>When the<a id="id273" class="indexterm"/> <code class="literal">runTestButton</code> button<a id="id274" class="indexterm"/> is pressed, a benchmark 100,000 record insert is performed, both with and without the use of transactional scoping. The screen is then updated with the elapsed milliseconds for each test.</p><div><ol class="orderedlist arabic"><li class="listitem">The following code demonstrates how each test is run when the button's click event is triggered:<div><pre class="programlisting">runTestButton.addEventListener('click',function(e){</pre></div></li><li class="listitem">First, a test is run without explicitly creating a transaction. This test returns the number of milliseconds elapsed while running, and stores the result in the <code class="literal">noTransactions</code> variable, as the following snippet demonstrates:<div><pre class="programlisting">var noTransactions = performanceTest.run(false);
noTransactionLabel.text = "No Transactions: " + noTransactions + ' ms';</pre></div></li><li class="listitem">Next, the same test is run using <code class="literal">BEGIN</code> and <code class="literal">COMMIT</code> statements to create an explicit transaction. <a id="id275" class="indexterm"/>This test returns the milliseconds elapsed during the test, and stores the result in the <code class="literal">withTransactions</code> variable<a id="id276" class="indexterm"/>, as shown in the following snippet:<div><pre class="programlisting">var withTransactions = performanceTest.run(true);
withTransactionLabel.text = "With Transactions: " + withTransactions + ' ms';
});</pre></div></li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>How it works…</h2></div></div></div><p>This recipe uses the helper objects discussed in this section, to perform the benchmarking operations.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec82"/>Database setup</h3></div></div></div><p>
<code class="literal">dbTestHelpers</code>
<a id="id277" class="indexterm"/> is the<a id="id278" class="indexterm"/> first helper object used during benchmarking. This object contains all the code needed to set up, create, and manage the database used in our tests:</p><div><pre class="programlisting">var dbTestHelpers = {</pre></div><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">maxIterations</code> property<a id="id279" class="indexterm"/> controls the number of iterations in our test:<div><pre class="programlisting">  maxIterations : 100001,</pre></div></li><li class="listitem">The <code class="literal">createOrResetDb</code> method<a id="id280" class="indexterm"/> is used to return a known and consistent database to test against:<div><pre class="programlisting">  createOrResetDb : function(){
    return Ti.Database.open("perf_test");
  },</pre></div></li><li class="listitem">The <code class="literal">resetTestTable</code> method<a id="id281" class="indexterm"/> is then called to drop and re-create our test table. This allows us to run our tests several times, while maintaining a consistent sample size:<div><pre class="programlisting">  resetTestTable : function(db){
    var dropSql = 'DROP TABLE IF EXISTS TEST_INSERT';
    var createSql = 'CREATE TABLE IF NOT EXISTS ';
    createSql += 'TEST_INSERT ';
    createSql += '(TEST_ID INTEGER, TEST_NAME TEXT, ';
    createSql += 'TEST_DATE DATE)';
    db.execute(dropSql); 
    db.execute(createSql);
  },</pre></div></li><li class="listitem">The <code class="literal">createSQLStatement</code> method<a id="id282" class="indexterm"/> returns the SQL that will be used to perform our insert operations:<div><pre class="programlisting">  createSQLStatement : function(){
    var sql = 'INSERT INTO TEST_INSERT ';
    sql += '(TEST_ID, TEST_NAME, TEST_DATE) ';
    sql += 'VALUES(?,?,?)';
    return sql;
  },</pre></div></li><li class="listitem">The <code class="literal">createDummyObject</code> function<a id="id283" class="indexterm"/> <a id="id284" class="indexterm"/>creates a unique object, to be inserted into each row:<div><pre class="programlisting">  createDummyObject : function(iterator){
    var dummy = {
      id:iterator, name : 'test record ' + iterator, date : new Date()
    }; 
    return dummy;
  }
};</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec83"/>Performing the tests</h3></div></div></div><p>The <code class="literal">performanceTest</code> object <a id="id285" class="indexterm"/>runs and times the recipe database's<a id="id286" class="indexterm"/> inserts. The <code class="literal">run</code> method starts our benchmark and provides an indicator if the test is to use transactions or not:</p><div><pre class="programlisting">var performanceTest = {
  run : function(useTransaction){</pre></div><div><ol class="orderedlist arabic"><li class="listitem">The first step in our test is to create a database connection and to reset our table. This is done by calling the <code class="literal">dbTestHelper</code> method<a id="id287" class="indexterm"/>, discussed earlier:<div><pre class="programlisting">    var db = dbTestHelpers.createOrResetDb();
    dbTestHelpers.resetTestTable(db);</pre></div></li><li class="listitem">After our database has been set up, the next step is to create our <code class="literal">insert</code> statement and <code class="literal">timer</code> objects, as demonstrated here:<div><pre class="programlisting">    var dummyObject = null;
    var insertSQL = dbTestHelpers.createSQLStatement();
    var insertTimer = new my.timer("Insert Timer");</pre></div></li><li class="listitem">If the <code class="literal">useTransaction</code> flag has been set, we then explicitly begin a transaction:<div><pre class="programlisting">    if(useTransaction){
      db.execute('BEGIN;');
    }</pre></div></li><li class="listitem">In the next step of this recipe, a loop is created, to insert records into the test table, a specific<a id="id288" class="indexterm"/> number of times. By default, this test will insert 100,000 records, and time the total duration.<div><pre class="programlisting">    for (var iLoop = 0; iLoop &lt; dbTestHelpers.maxIterations; iLoop++){
      dummyObject = dbTestHelpers.createDummyObject(iLoop);
      db.execute(insertSQL,dummyObject.id,dummyObject.name,dummyObject.date);
    }
  }</pre></div></li><li class="listitem">If the <code class="literal">useTransaction</code> flag has been set, we then explicitly "commit" the transaction:<div><pre class="programlisting">  if(useTransaction){
    db.execute('COMMIT;');
  }</pre></div></li><li class="listitem">The final step of this method is to retrieve our execution duration from our timer object. This value (in milliseconds) is then returned for later comparison operations:<div><pre class="programlisting">  var totalInsertTime = insertTimer.getResults().msElapsed;
  db.close();
  //Return total ms elapsed
  return totalInsertTime;
  }
};</pre></div></li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To learn more about SQLite transactions and how they are implemented, please read the official documentation at <a class="ulink" href="http://www.sqlite.org/lang_transaction.html">http://www.sqlite.org/lang_transaction.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Data access using DbLazyProvider</h1></div></div></div><p>Data access is a common challenge when building any Enterprise app. The <code class="literal">DbLazyProvider</code> module<a id="id289" class="indexterm"/> provides a lightweight wrapper around the <code class="literal">Ti.Database</code> API. This module provides helpers for commonly required operations such as managing transactions and lazy-loading connections.</p><p>Lazy loading<a id="id290" class="indexterm"/> is a common efficiency pattern that defers the initialization of an object until needed. By lazy-loading app-database connections, any memory usage or IO operation associated with creating a database connection is deferred until needed.</p><p>The following section demonstrates how to use the <code class="literal">DbLazyProvider</code> module to implement a lazy-loading pattern<a id="id291" class="indexterm"/> in your app, while maintaining control over your database transactions.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Getting ready</h2></div></div></div><p>Adding the <code class="literal">DbLazyProvider</code> module to your project is easy. Simply copy the <code class="literal">dblazyprovider.js</code> file into your project, as shown in the following screenshot:</p><div><img src="img/5343OT_03_06.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>How to do it…</h2></div></div></div><p>The first step<a id="id292" class="indexterm"/> in this recipe is to create the application namespace and import the <code class="literal">DbLazyProvider</code> module, as demonstrated here:</p><div><pre class="programlisting">//Create our application namespace
var my = {
  dbProvider : require('dblazyprovider')
};</pre></div><p>Next, a sample table named <code class="literal">MY_TEST</code> is created. If the table already exists, any existing records will be purged so we can start a new test.</p><div><pre class="programlisting">var dbSetup = new my.dbProvider("myDb");
var createSql = 'CREATE TABLE IF NOT EXISTS ';
createSql += 'MY_TEST (TEST_ID INTEGER, ';
createSql += 'TEST_NAME TEXT)';
dbSetup.connect().execute(createSql);
dbSetup.connect().execute('DELETE FROM MY_TEST');
dbSetup.close();</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec84"/>Creating our testing Interface</h3></div></div></div><p>Now, we create<a id="id293" class="indexterm"/> a <code class="literal">Ti.UI.Window</code> for our recipe. This will be used to provide a launching point for our tests.</p><div><pre class="programlisting">var win = Ti.UI.createWindow({
  backgroundColor:'#fff',layout:'vertical'
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec85"/>Lazy-loading using transactions</h3></div></div></div><p>The <code class="literal">insertDemoBtn</code> button is used to<a id="id294" class="indexterm"/> trigger our recipe, showing how to use transactions with <code class="literal">DbLazyProvider</code>:</p><div><pre class="programlisting">var insertDemoBtn = Ti.UI.createButton({
  title:'Run Inserts', height:50, right:5, left:5, top: 20;
});
win.add(insertDemoBtn);</pre></div><div><ol class="orderedlist arabic"><li class="listitem">Clicking on the <code class="literal">insertDemoBtn</code> button will insert 1,000 rows into our table:<div><pre class="programlisting">insertDemoBtn.addEventListener('click',function(e){
  var maxIteration = 1000;
  var sql = 'INSERT INTO MY_TEST ';
  sql+='(TEST_ID, TEST_NAME) VALUES(?,?)';
  var db = new my.dbProvider("myDb");
  for (var iLoop = 0; iLoop &lt; maxIteration; iLoop++){</pre></div></li><li class="listitem">The following code shows using the <code class="literal">connect</code> method with a transaction parameter of <code class="literal">true</code> to obtain the <code class="literal">Ti.Database</code> object that is used to execute the SQL <a id="id295" class="indexterm"/>statement. This will automatically create a transaction on the first insert for you.<div><pre class="programlisting">   db.connect(true).execute(sql,iLoop,'test ' + iLoop);</pre></div></li><li class="listitem">When the <code class="literal">close</code> method is called, any transactions that were created will be committed, and the database connection will be closed:<div><pre class="programlisting">
<strong>   db.close();</strong>
    alert('Test done ' + maxIteration + ' rows inserted');
  });</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec86"/>Creating a select statement using lazy-loading</h3></div></div></div><p>Not all SQL statements <a id="id296" class="indexterm"/>benefit from transactions. The following snippet demonstrates how to perform a select statement without using transactions:</p><div><pre class="programlisting">  var selectDemoBtn = Ti.UI.createButton({
    title:'Run Select', height:50, right:5, left:5, top: 20
  });
  win.add(selectDemoBtn);</pre></div><div><ol class="orderedlist arabic"><li class="listitem">Click on the <code class="literal">selectDemoBtn</code> button to create a new <code class="literal">DbLazyProvider</code> object, and run a select statement:<div><pre class="programlisting">  selectDemoBtn.addEventListener('click',function(e){
    var db = new my.dbProvider("myDb");
    var selectSQL = 'SELECT * FROM MY_TEST ';</pre></div></li><li class="listitem">The highlighted code shows how to use the <code class="literal">connect</code> method without providing any parameters. This will, by default, avoid using transactions.<div><pre class="programlisting">
<strong>   var getReader = db.connect().execute(selectSQL);</strong>
    var rowCount = getReader.getRowCount();</pre></div></li><li class="listitem">On using the <code class="literal">close</code> method, the database connection will be closed and all objects will be set to null:<div><pre class="programlisting">    db.close();
    alert('Rows available ' + rowCount);
  });</pre></div></li></ol></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec49"/>How it works…</h2></div></div></div><p>The <code class="literal">DbLazyProvider</code> module<a id="id297" class="indexterm"/> is a lightweight, yet powerful, wrapper over <code class="literal">Ti.Database</code>.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec87"/>Creating a new DbLazyProvider object</h3></div></div></div><p>To create a<a id="id298" class="indexterm"/> new <code class="literal">DbLazyProvider</code> object, simply use the <code class="literal">require</code> method to import the module and create a new object using the reference in the following highlighted snippet. This will create a new object wrapper for the database name provided.</p><div><pre class="programlisting">//Create our application namespace
var my = {
  dbProvider : require('dblazyprovider')
};
//Create a new dbLazy object
<strong>var db = new my.dbProvider("myDb");</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec88"/>Getting a connection object</h3></div></div></div><p>The most frequently<a id="id299" class="indexterm"/> used method of <code class="literal">DbLazyProvder</code> is <code class="literal">connect</code>. This method will create a new <code class="literal">Ti.Database</code> connection if needed, and then return the database object:</p><div><pre class="programlisting">db.connect().execute('Your SQL goes here');</pre></div><p>If you wish to have your SQL statement start a transaction, you simply pass in a Boolean parameter of <code class="literal">true</code> when calling the <code class="literal">connect</code> method, as shown here:</p><div><pre class="programlisting">db.connect(true).execute('Your SQL goes here');</pre></div><p>The transaction created will be used until either the <code class="literal">close</code> or <code class="literal">commit</code> method is called on your <code class="literal">DbLazyProvider</code> object.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec89"/>Beginning a transaction</h3></div></div></div><p>By default, transactions<a id="id300" class="indexterm"/> are handled automatically for you, using the <code class="literal">connect</code> and <code class="literal">close</code> methods. You can also explicitly create a transaction at any time using the <code class="literal">beginTransaction</code> method<a id="id301" class="indexterm"/>, as shown here:</p><div><pre class="programlisting">db.beginTransaction();</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec90"/>Ending a transaction</h3></div></div></div><p>By default, transactions<a id="id302" class="indexterm"/> are handled automatically for you, using the <code class="literal">connect</code> and <code class="literal">close</code> methods. You can also explicitly commit or finish a transaction at any time using the <code class="literal">commit</code> method, as shown here:</p><div><pre class="programlisting">db.commit();</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec91"/>Opening a database connection</h3></div></div></div><p>The module, by<a id="id303" class="indexterm"/> default, will wait until a database connection is needed, before opening the <code class="literal">Ti.Database</code> object. If a connection is needed in advance, you can call the <code class="literal">open</code> method at any time:</p><div><pre class="programlisting">db.open();</pre></div><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>You can also pass in a new database name to switch your database reference.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec92"/>Closing a database connection</h3></div></div></div><p>Using the <code class="literal">close</code> method <a id="id304" class="indexterm"/>on your <code class="literal">DbLazyProvider</code> objects is important, as it both commits any pending transactions and closes your database connection. The <code class="literal">close</code> method should be called after each transaction grouping or when the database connection is no longer needed.</p><div><pre class="programlisting">db.close();</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>NoSQL using MongloDb</h1></div></div></div><p>NoSQL databases<a id="id305" class="indexterm"/> are often a perfect fit for managing your application's data, as it allows you to work with objects instead of tables. In addition to the benefit of working with objects, using NoSQL on mobile reduces complexity by removing the need for schema management, data migration, and other common maintenance issues associated with maintaining a relational data model.</p><p>MongloDb<a id="id306" class="indexterm"/> is a pure JavaScript implementation of the popular MongoDb NoSQL solution. The <code class="literal">MongloDb</code> module allows you to query and persist objects using the familiar MongoDb syntax in your Titanium app. This recipe demonstrates how to leverage the <code class="literal">MongloDb</code> module within your new or existing Titanium project.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Getting ready</h2></div></div></div><p>Installing MongloDb for<a id="id307" class="indexterm"/> Titanium is a straightforward process. You can either copy the <code class="literal">Monglo</code> folder from the recipe's source code, or create the bundle yourself.</p><p>Creating the bundle<a id="id308" class="indexterm"/> is a three-step process:</p><div><ol class="orderedlist arabic"><li class="listitem">Using Titanium Studio, create a folder called <code class="literal">Monglo</code> in the <code class="literal">Resources</code> folder of your project.</li><li class="listitem">Download the latest <code class="literal">monglodb.js</code> file from <a class="ulink" href="http://monglodb.com">monglodb.com</a> into the <code class="literal">Monglo</code> folder created in the previous step.</li><li class="listitem">Download into the <code class="literal">Monglo</code> folder the latest <code class="literal">index.js</code> file from the Titanium Store project available on <a class="ulink" href="http://monglodb.com">monglodb.com</a>.</li></ol></div><p>Whether you copied the bundle from the recipe source or created your own, the <code class="literal">Monglo</code> folder in your Titanium project should resemble the highlighted part of the following screenshot:</p><div><img src="img/5343OT_03_07.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec51"/>How to do it…</h2></div></div></div><p>Once you have installed MongloDb, you will need to use <code class="literal">require</code> to import the module into your code:</p><div><pre class="programlisting">//Create our application namespace
var my = {
  monglo : require('./Monglo/monglodb').Monglo
};</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec93"/>Initializing your database</h3></div></div></div><p>After the<a id="id309" class="indexterm"/> module has been imported, a new instance of the database needs to be initialized. The following code demonstrates how to create a new instance of <code class="literal">Monglo</code> with the name <code class="literal">myDb</code>:</p><div><pre class="programlisting">my.db = my.monglo('myDb');</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec94"/>Adding the Titanium storage provider</h3></div></div></div><p>MongloDb has<a id="id310" class="indexterm"/> the ability to support a wide range of storage providers. This recipe implements the Titanium Store provider to persist data. Associating a storage provider with MongloDb is a two-step process. First, we <code class="literal">require</code> the Titanium storage provider, as shown here:</p><div><pre class="programlisting">var tistore = require('./Monglo/index');</pre></div><p>After the storage provider has been created, the provider is passed into the <code class="literal">use</code> method, as demonstrated in the following statement. Once the <code class="literal">use</code> method is called, MongloDb will perform all persistence operations using the Titanium Storage provider.</p><div><pre class="programlisting">my.db.use('store', tistore);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec95"/>Initializing our collection</h3></div></div></div><p>Once the storage <a id="id311" class="indexterm"/>provider has been associated, durable collections can be created using the <code class="literal">collection</code> method. The following line demonstrates how to create a document collection named <code class="literal">foo</code>:</p><div><pre class="programlisting">my.db.someCollection = my.db.collection('foo');</pre></div><p>When initializing a named collection, any documents previously persisted by this collection will automatically be reloaded. In the previous example, any documents previously saved in the <code class="literal">foo</code> document collection will be reloaded when the collection is initialized.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec96"/>Using events</h3></div></div></div><p>MongloDb provides events <a id="id312" class="indexterm"/>for monitoring a majority of the actions performed. The following snippet demonstrates how to add an event for each supported listener:</p><div><pre class="programlisting">my.db.someCollection.on('insert', function(){
  Ti.API.info("Document Inserted") ;
});
my.db.someCollection.on('update', function(){ 
  Ti.API.info("Document Updated");
});
my.db.someCollection.on('remove', function(){
  Ti.API.info("Document Removed");
});
my.db.someCollection.on('find', function(){ 
  Ti.API.info("Find Used");
});
my.db.someCollection.on('createCollection', function(){ 
  Ti.API.info("Collection Created");
});
my.db.someCollection.on('removeCollection', function(){
  Ti.API.info("Collection Removed");
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec97"/>Inserting documents</h3></div></div></div><p>The next step is<a id="id313" class="indexterm"/> to insert three new documents. The next snippet demonstrates how to insert a new document into <code class="literal">someCollection</code>. The <code class="literal">insert</code> method has two parameters. The first parameter is a document object to be stored. The second parameter is a callback that lists the errors and provides document information. This is shown in the following highlighted snippet:</p><div><pre class="programlisting">
<strong>my.db.someCollection.insert({text: "record 1", </strong>
<strong>batchId:'sample_test'}, function ( error, doc )</strong>
</pre></div><p>The <code class="literal">error</code> and <code class="literal">doc</code> objects are returned as part of the <code class="literal">callback</code> function. The <code class="literal">error</code> object contains any issues encountered during the insert action, and the <code class="literal">doc</code> object contains a copy of the <code class="literal">Monglo</code> document created.</p><div><pre class="programlisting">  Ti.API.info('Error: ' + JSON.stringify(error));
  Ti.API.info('doc: ' + JSON.stringify(doc));
});
//Create second record
my.db.someCollection.insert({text: "record 2", batchId:'sample_test'}, function ( error, doc ){ });
//Create third record
my.db.someCollection.insert({text: "record 3", batchId:'sample_test'}, function ( error, doc ){ });</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec98"/>Using find to query</h3></div></div></div><p>With three records now created, <a id="id314" class="indexterm"/>we can use the <code class="literal">find</code> function to search for all the documents that have the batch ID <code class="literal">sample_test</code>.</p><div><pre class="programlisting">my.db.someCollection.find({batchId:'sample_test'}, 
function ( error, cursor ){</pre></div><p>The <code class="literal">find</code> method returns both an <code class="literal">error</code> and <code class="literal">cursor</code> object. The cursor's <code class="literal">forEach</code> iterator provides a convenient way to inspect each document that is returned. The following snippet demonstrates how to print each document within the <code class="literal">cursor</code> to the Titanium Studio console as a JSON string:</p><div><pre class="programlisting">  cursor.forEach(function(doc){ 
    Ti.API.info('doc: ' + JSON.stringify(doc));
  });
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec99"/>Updating documents</h3></div></div></div><p>Similar to a <a id="id315" class="indexterm"/>traditional database, MongloDb provides the ability to change a document using the <code class="literal">update</code> method. The <code class="literal">update</code> method has three parameters. The first parameter is used to find the object you wish to update. The next example shows updating any object with the text property equal to <code class="literal">record 1</code>. The second parameter is the update statement. The example updates each matching object's text property to <code class="literal">updated record 1</code>. The final parameter is a callback which returns an <code class="literal">error</code> and <code class="literal">doc</code> object.</p><div><pre class="programlisting">my.db.someCollection.update({text: "record 1"}, {$set: {text: 'updated record 1'}}, function ( error, doc ){ 
  Ti.API.info('Error: ' + JSON.stringify(error));
  Ti.API.info('doc: ' + JSON.stringify(doc));
});</pre></div><p>This demonstrated how to update the text property on the first document inserted in this recipe.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec100"/>Using findOne to query for a single document</h3></div></div></div><p>The <code class="literal">findOne</code> method <a id="id316" class="indexterm"/>provides the means to query your collection for a specific document. The following snippet demonstrates how to query <code class="literal">someCollection</code> for the document we just updated. The resulting single-matching document is then printed to the Titanium Studio console as a JSON string.</p><div><pre class="programlisting">my.db.someCollection.findOne({text: 'updated record 1'}, function ( error, doc ){ 
  Ti.API.info('Error: ' + JSON.stringify(error));
  Ti.API.info('doc: ' + JSON.stringify(doc));
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec101"/>Removing documents</h3></div></div></div><p>The final section <a id="id317" class="indexterm"/>of this recipe demonstrates how to remove documents from a collection. The following snippet demonstrates how to remove all documents that have the batch ID <code class="literal">sample_test</code>.</p><div><pre class="programlisting">my.db.someCollection.remove({batchId:'sample_test'}, function (error) { 
  Ti.API.info('Error: ' + JSON.stringify(error));
});</pre></div><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>The previous code snippet  removes all records created in this recipe, allowing you to run the sample several times without creating unwanted records.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec52"/>See also</h2></div></div></div><p>All the NoSQL examples shown in this recipe use the MongloDb open source project.Please see the following to learn more about this project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Project site: <a class="ulink" href="http://monglodb.com/">http://monglodb.com/</a></li><li class="listitem" style="list-style-type: disc">Github project<a id="id318" class="indexterm"/>: <a class="ulink" href="https://github.com/Monglo/MongloDB">https://github.com/Monglo/MongloDB</a></li><li class="listitem" style="list-style-type: disc">Titanium Store<a id="id319" class="indexterm"/>: <a class="ulink" href="https://github.com/Monglo/MongloDB-Titanium-Store">https://github.com/Monglo/MongloDB-Titanium-Store</a></li><li class="listitem" style="list-style-type: disc">Google Groups<a id="id320" class="indexterm"/>: <a class="ulink" href="https://groups.google.com/forum/#!forum/monglodb">https://groups.google.com/forum/#!forum/monglodb</a></li></ul></div></div></div></body></html>