<html><head></head><body>
        

                            
                    <h1 class="header-title">Security</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Authenticating your microservices</li>
<li>Securing containers</li>
<li>Secure configuration</li>
<li>Secure logging</li>
<li>Infrastructure as Code</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>As with many of the topics covered in this book, security in a microservice architecture is about trade-offs. In a microservice architecture, individual code bases have limited responsibilities. If an attacker is able to compromise a single running service, they will only be able to perform actions that are governed by that particular microservice. The distributed nature of a microservice architecture, however, means that there are more targets for an attacker to potentially exploit in services running in separate clusters. The network traffic between those clusters, including traffic between edge services and internal services, presents many opportunities for an attacker to discover vulnerabilities.</p>
<p>Because of the distributed nature of microservice architectures, network topology must be considered when configuring how services are able to communicate with one another. This concern exists in monolithic code bases as well, where a running instance of a single code base needs to communicate over the network with database servers, caches, load balancers, and so on. It could be argued that microservice architectures make these challenges more obvious and therefore force engineers to consider them earlier.</p>
<p class="mce-root"/>
<p>Security is a big topic. This chapter will discuss a number of good practices to consider when building, deploying, and operating microservices, but it's important to note that this is not an exhaustive list of considerations. Good API practices and defense in depth should be considered when developing any system and microservices are no exception. I heartily recommend <strong>OWASP</strong> (<a href="https://www.owasp.org/index.php/Main_Page">https://www.owasp.org/index.php/Main_Page</a>) as a resource for learning more about web application security.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authenticating your microservices</h1>
                
            
            
                
<p>In <a href="d5b36f18-79eb-4c0a-bbde-3e94733ef97c.xhtml">Chapter 1</a>, <em>Breaking the Monolith</em>, we introduced a Ruby on Rails code base that powers our fictional image-sharing application, <kbd>pichat</kbd>. The Rails code base authenticates each request by inspecting the Authorization header. If the header is present, the application attempts to decode it using a shared secret read from an environment variable (see the <em>Secure</em> c<em>onfiguration</em> recipe). If the token provided in the Authorization header is valid, the decoded value contains contextual information about the user, including the user ID. That information is then used to retrieve the user from the database so that the application has context on the user making the request. If the Authorization header is missing or cannot be decoded successfully, the application raises an exception and returns an HTTP 401 to the caller, including an error message. In order to obtain a token to include in the Authorization header, a client application can send a <kbd>POST</kbd> request to the <kbd>/auth/login</kbd> endpoint with valid user credentials. The following CURL commands demonstrate this flow:</p>
<pre><strong>$ curl -D - -X POST http://localhost:9292/auth/login -d'email=p@eval.ca&amp;password=foobar123'</strong><br/><br/><strong>HTTP/1.1 200 OK</strong><br/><strong>Content-Type: application/json; charset=utf-8</strong><br/><strong>ETag: W/"3675d2006d59e01f8665f20ffef65fe7"</strong><br/><strong>Cache-Control: max-age=0, private, must-revalidate</strong><br/><strong>X-Request-Id: 6660a102-059f-4afe-b17c-99375db305dd</strong><br/><strong>X-Runtime: 0.150903</strong><br/><strong>Transfer-Encoding: chunked</strong><br/><br/><strong>{"auth_token":"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1MzE2ODUxNjR9.vAToW_mWlOnr-GPzP79EvN62Q2MpsnLIYanz3MTbZ5Q"}</strong></pre>
<p>Now that we have a token, we can include it in the headers of subsequent requests:</p>
<pre><strong>$ curl -X POST -D - -H 'Authorization: eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1MzE2ODUxNjR9.vAToW_mWlOnr-GPzP79EvN62Q2MpsnLIYanz3MTbZ5Q' http://localhost:9292/messages -d'body=Hello&amp;user_id=1'</strong><br/><strong>HTTP/1.1 201 Created</strong><br/><strong>Content-Type: application/json; charset=utf-8</strong><br/><strong>ETag: W/"211cdab551e63ca48de48217357f1cf7"</strong><br/><strong>Cache-Control: max-age=0, private, must-revalidate</strong><br/><strong>X-Request-Id: 1525333c-dada-40ff-8c25-a0e7d151433c</strong><br/><strong>X-Runtime: 0.019609</strong><br/><strong>Transfer-Encoding: chunked</strong><br/><br/><strong>{"id":1,"body":"Hello","user_id":1,"created_at":"2018-07-14T20:08:19.369Z","updated_at":"2018-07-14T20:08:19.369Z","from_user_id":1}</strong></pre>
<p>Because <kbd>pichat-api</kbd> is a monolithic code base, it is playing many different roles to support this flow. It is acting as an Authorization service, an Authentication gateway, a user store, and an Authorization client. This kind of coupling of responsibilities is exactly what we want to avoid in a microservice architecture. </p>
<p>Luckily, it's easy to divide these responsibilities into separate code bases while keeping the flow the same. Encoding information in <strong>JSON Web Tokens</strong> (<strong>JWT</strong>) using a shared secret allows individual microservices to securely authenticate requests without having to make requests to a centralized authentication service for each request. Obtaining an authentication token can be the responsibility of a centralized service, but this fact can be made transparent to the client using an API Gateway or a backend for a frontend. The following diagram demonstrates how some of the responsibilities will be divided:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/995d3ee1-7c63-4015-85ea-eafd43997426.png" style="width:24.58em;height:24.92em;"/></p>
<p>We will create an <strong>Authentication Service</strong> that handles user registration and exchanges credentials for a JWT. We will then create a simple <strong>API Gateway</strong> using the Zuul open source project that we covered in <a href="ab796ed6-2bb5-4fc1-b6db-6283ab5c54b4.xhtml">Chapter 2</a>, <em>Edge Services</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's have a look at the following steps:</p>
<ol>
<li>Let's create the authentication service. Create a new Java project with the following <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/>apply plugin: 'io.spring.dependency-management'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'<br/>    compile group: 'org.springframework.security', name: 'spring-security-core'<br/>    compile group: 'org.springframework.security', name: 'spring-security-config'<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa'</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre style="padding-left: 60px">    compile group: 'io.jsonwebtoken', name: 'jjwt', version: '0.9.1'<br/>    compile group: 'mysql', name: 'mysql-connector-java'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<p style="padding-left: 60px">We'll be storing user credentials in a MySQL database, so we declare <kbd>mysql-connector-java</kbd> as a dependency. We'll also use an open source JWT library called <kbd>jjwt</kbd>.</p>
<p>Storing user credentials is an important topic. User passwords should never be stored in plain text and many hashing algorithms, such as MD5 and SHA1, have been shown to be vulnerable to various brute force attacks. In this example, we'll be using <kbd>bcrypt</kbd>. In a real-world usage, we'd consider multiple hashing steps, such as hashing with SHA512 first and then running through <kbd>bcrypt</kbd>. We'd also consider adding a per-user salt. The <strong>Open Web Application Security Project</strong> has a lot of great recommendations for storing passwords: <a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet">https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet</a>.</p>
<ol start="2">
<li>Create a new class called <kbd>Application</kbd>. It will contain our main method as well as <kbd>PasswordEncoder</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.auth;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<br/>import org.springframework.security.crypto.password.PasswordEncoder;<br/><br/>@SpringBootApplication<br/>public class Application {<br/><br/>    @Bean<br/>    public PasswordEncoder passwordEncoder() {<br/>        return new BCryptPasswordEncoder();<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>We'll model the user credentials as a simple POJO with <kbd>email</kbd> and <kbd>password</kbd> fields. Create a new package called <kbd>com.packtpub.microservices.ch06.auth.models</kbd> and a new class called <kbd>UserCredential</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.auth.models;<br/><br/>import org.hibernate.annotations.GenericGenerator;<br/><br/>import javax.persistence.*;<br/><br/>@Entity<br/>public class UserCredential {<br/>    @Id<br/>    @GeneratedValue(generator = "uuid")<br/>    @GenericGenerator(name = "uuid", strategy = "uuid2")<br/>    private String id;<br/><br/>    @Column(unique=true)<br/>    private String email;<br/><br/>    private String password;<br/><br/>    public UserCredential(String email) {<br/>        this.email = email;<br/>    }<br/><br/>    public String getId() {<br/>        return id;<br/>    }<br/><br/>    public void setId(String id) {<br/>        this.id = id;<br/>    }<br/><br/>    public String getEmail() {<br/>        return email;<br/>    }<br/><br/>    public void setEmail(String email) {<br/>        this.email = email;<br/>    }<br/><br/>    public String getPassword() {<br/>        return password;<br/>    }<br/><br/></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<pre style="padding-left: 60px">    public void setPassword(String password) {<br/>        this.password = password;<br/>    }<br/>}</pre>
<ol start="4">
<li>Create a model to represent the response to successful login and registration requests. Successful responses will contain a JSON document containing a JWT. Create a new class called <kbd>AuthenticationToken</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.auth.models;<br/><br/>import com.fasterxml.jackson.annotation.JsonProperty;<br/><br/>public class AuthenticationToken {<br/><br/>    @JsonProperty("auth_token")<br/>    private String authToken;<br/><br/>    public AuthenticationToken() {}<br/><br/>    public AuthenticationToken(String authToken) {<br/>        this.authToken = authToken;<br/>    }<br/><br/>    public String getAuthToken() {<br/>        return this.authToken;<br/>    }<br/><br/>    public void setAuthToken(String authToken) {<br/>        this.authToken = authToken;<br/>    }<br/>}</pre>
<ol start="5">
<li>The <kbd>UserCredential</kbd> class will be accessed using the Java Persistence API. To do this, we have to first create <kbd>CrudRepository</kbd>. Create a new package called <kbd>com.packtpub.microservices.ch06.auth.data</kbd> and a new class called <kbd>UserCredentialRepository</kbd>. In addition to inheriting from <kbd>CrudRepository</kbd>, we'll define a single method used to retrieve a <kbd>UserCredential</kbd> instance by email:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.auth.data;<br/><br/>import com.packtpub.microservices.ch06.auth.models.UserCredential;<br/>import org.springframework.data.repository.CrudRepository;<br/><br/>public interface UserCredentialRepository extends CrudRepository&lt;UserCredential, String&gt; {<br/>    UserCredential findByEmail(String email);<br/>}</pre>
<ol start="6">
<li>When a user attempts to register or log in with invalid credentials, we want to return an HTTP 401 status code as well as a message indicating that they provided invalid credentials. In order to do this, we'll create a single exception that will be thrown in our controller methods:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.auth.exceptions;<br/><br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.web.bind.annotation.ResponseStatus;<br/><br/>@ResponseStatus(HttpStatus.UNAUTHORIZED)<br/>public class InvalidCredentialsException extends Exception {<br/>    public InvalidCredentialsException(String message) { super(message); }<br/>}</pre>
<ol start="7">
<li>Create the controller. The login and registration endpoints will be served from a single controller. The registration method will simply validate input and create a new <kbd>UserCredential</kbd> instance, persisting it using the <kbd>CrudRepository</kbd> package we created earlier. It will then encode a JWT with the user ID of the newly registered user as the subject. The login method will verify the provided credentials and provide a JWT with the user ID as its subject. The controller will need access to <kbd>UserCredentialRepository</kbd> and <kbd>PasswordEncoder</kbd> defined in the main class. Create a new package called <kbd>com.packtpub.microservices.ch06.auth.controllers</kbd> and a new class called <kbd>UserCredentialController</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.auth.controllers;<br/><br/>import com.packtpub.microservices.ch06.auth.data.UserCredentialRepository;<br/>import com.packtpub.microservices.ch06.auth.exceptions.InvalidCredentialsException;<br/>import com.packtpub.microservices.ch06.auth.models.AuthenticationToken;<br/>import com.packtpub.microservices.ch06.auth.models.UserCredential;<br/>import io.jsonwebtoken.JwtBuilder;<br/>import io.jsonwebtoken.Jwts;<br/>import io.jsonwebtoken.SignatureAlgorithm;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.beans.factory.annotation.Value;<br/>import org.springframework.security.crypto.password.PasswordEncoder;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import javax.crypto.spec.SecretKeySpec;<br/>import javax.xml.bind.DatatypeConverter;<br/>import java.security.Key;<br/><br/>@RestController<br/>public class UserCredentialController {<br/><br/>    @Autowired<br/>    private UserCredentialRepository userCredentialRepository;<br/><br/>    @Autowired<br/>    private PasswordEncoder passwordEncoder;<br/><br/>    @Value("${secretKey}")<br/>    private String keyString;<br/><br/>    private String encodeJwt(String userId) {<br/>        System.out.println("SIGNING KEY: " + keyString);<br/>        Key key = new SecretKeySpec(<br/>                DatatypeConverter.parseBase64Binary(keyString),<br/>                SignatureAlgorithm.HS256.getJcaName());<br/><br/>        JwtBuilder builder = Jwts.builder().setId(userId)<br/>                .setSubject(userId)<br/>                .setIssuer("authentication-service")<br/>                .signWith(SignatureAlgorithm.HS256, key);<br/><br/>        return builder.compact();<br/>    }<br/><br/>    @RequestMapping(path = "/register", method = RequestMethod.POST, produces = "application/json")<br/>    public AuthenticationToken register(@RequestParam String email, @RequestParam String password, @RequestParam String passwordConfirmation) throws InvalidCredentialsException {<br/>        if (!password.equals(passwordConfirmation)) {<br/>            throw new InvalidCredentialsException("Password and confirmation do not match");<br/>        }<br/><br/>        UserCredential cred = new UserCredential(email);<br/>        cred.setPassword(passwordEncoder.encode(password));<br/>        userCredentialRepository.save(cred);<br/><br/>        String jws = encodeJwt(cred.getId());<br/>        return new AuthenticationToken(jws);<br/>    }<br/><br/>    @RequestMapping(path = "/login", method = RequestMethod.POST, produces = "application/json")<br/>    public AuthenticationToken login(@RequestParam String email, @RequestParam String password) throws InvalidCredentialsException {<br/>        UserCredential user = userCredentialRepository.findByEmail(email);<br/><br/>        if (user == null || !passwordEncoder.matches(password, user.getPassword())) {<br/>            throw new InvalidCredentialsException("Username or password invalid");<br/>        }<br/><br/>        String jws = encodeJwt(user.getId());<br/>        return new AuthenticationToken(jws);<br/>    }<br/>}</pre>
<ol start="8">
<li>Because we are connecting to a local database, and because we use a shared secret when signing JWTs, we need to create a small properties file. Create a file called <kbd>application.yml</kbd> in the <kbd>src/main/resources</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px">server:<br/>  port: 8081<br/><br/>spring:<br/>  jpa.hibernate.ddl-auto: create<br/>  datasource.url: jdbc:mysql://localhost:3306/user_credentials<br/>  datasource.username: root<br/>  datasource.password:<br/><br/>secretKey: supers3cr3t</pre>
<p style="padding-left: 60px">Now that we have a functioning authentication service, the next step is to create a simple API Gateway using the open source gateway service, Zuul. In addition to routing requests to downstream services, the API Gateway will also use an authentication filter to verify that valid JWTs are passed in headers for requests that require authentication.</p>
<p class="mce-root"/>
<ol start="9">
<li>Create a new Java project with the following <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/>apply plugin: 'io.spring.dependency-management'<br/><br/>sourceCompatibility = 1.8<br/>targetCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencyManagement {<br/>    imports {<br/>        mavenBom 'org.springframework.cloud:spring-cloud-netflix:1.4.4.RELEASE'<br/>    }<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'<br/>    compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-zuul'<br/>    compile group: 'org.springframework.security', name: 'spring-security-core'<br/>    compile group: 'org.springframework.security', name: 'spring-security-config'<br/>    compile group: 'org.springframework.security', name: 'spring-security-web'<br/>    compile group: 'io.jsonwebtoken', name: 'jjwt', version: '0.9.1'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p style="padding-left: 60px">Note that we're using the same JWT library as the Authentication service.</p>
<ol start="10">
<li>Create a new package called <kbd>com.packtpub.microservices.ch06.gateway</kbd> and a new class called <kbd>Application</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.gateway;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.cloud.netflix.zuul.EnableZuulProxy;<br/><br/>@EnableZuulProxy<br/>@SpringBootApplication<br/>public class Application {<br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/>}</pre>
<ol start="11">
<li>We'll create an authentication filter by creating a subclass of <kbd>OncePerRequestFilter</kbd>, which aims to provide a single execution per request dispatch. The filter will parse the JWT out of the Authorization header and try to decode it using a shared secret. If the JWT can be verified and decoded, we can be sure that it was encoded by an issuer that had access to the shared secret. We'll treat this as our trust boundary; anyone with access to the shared secret can be trusted, and therefore we can trust that the subject of the JWT is the ID of the authenticated user. Create a new class called <kbd>AuthenticationFilter</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.gateway;<br/><br/>import io.jsonwebtoken.Claims;<br/>import io.jsonwebtoken.Jwts;<br/>import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;<br/>import org.springframework.security.core.Authentication;<br/>import org.springframework.security.core.authority.SimpleGrantedAuthority;<br/>import org.springframework.security.core.context.SecurityContextHolder;<br/>import org.springframework.web.filter.OncePerRequestFilter;<br/>import javax.servlet.FilterChain;<br/>import javax.servlet.ServletException;<br/>import javax.servlet.http.HttpServletRequest;<br/>import javax.servlet.http.HttpServletResponse;<br/>import javax.xml.bind.DatatypeConverter;<br/>import java.io.IOException;<br/>import java.util.ArrayList;<br/>import java.util.Optional;<br/><br/>public class AuthenticationFilter extends OncePerRequestFilter {<br/><br/>    private String signingSecret;<br/><br/>    AuthenticationFilter(String signingSecret) {<br/>        this.signingSecret = signingSecret;<br/>    }<br/><br/>    @Override<br/>    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {<br/>        Optional&lt;String&gt; token = Optional.ofNullable(request.getHeader("Authorization"));<br/>        Optional&lt;Authentication&gt; auth = token.filter(t -&gt; t.startsWith("Bearer")).flatMap(this::authentication);<br/>        auth.ifPresent(a -&gt; SecurityContextHolder.getContext().setAuthentication(a));<br/>        filterChain.doFilter(request, response);<br/>    }<br/><br/>    private Optional&lt;Authentication&gt; authentication(String t) {<br/>        System.out.println(signingSecret);<br/>        String actualToken = t.substring("Bearer ".length());<br/>        try {<br/>            Claims claims = Jwts.parser()<br/>                    .setSigningKey(DatatypeConverter.parseBase64Binary(signingSecret))<br/>                    .parseClaimsJws(actualToken).getBody();<br/>            Optional&lt;String&gt; userId = Optional.ofNullable(claims.getSubject()).map(Object::toString);<br/>            return userId.map(u -&gt; new UsernamePasswordAuthenticationToken(u, null, new ArrayList&lt;SimpleGrantedAuthority&gt;()));<br/>        } catch (Exception e) {<br/>            return Optional.empty();<br/>        }<br/><br/><br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="12">
<li>Wire this together with a security configuration for the API Gateway project. Create a new class called <kbd>SecurityConfig</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.gateway;<br/><br/>import org.springframework.beans.factory.annotation.Value;<br/>import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br/>import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br/>import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br/>import org.springframework.security.config.http.SessionCreationPolicy;<br/>import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;<br/><br/>import javax.servlet.http.HttpServletResponse;<br/><br/>@EnableWebSecurity<br/>public class SecurityConfig extends WebSecurityConfigurerAdapter {<br/><br/>    @Value("${jwt.secret}")<br/>    private String signingSecret;<br/><br/>    @Override<br/>    protected void configure(HttpSecurity security) throws Exception {<br/>        security<br/>            .csrf().disable()<br/>            .logout().disable()<br/>            .formLogin().disable()<br/>            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)<br/>            .and()<br/>                .anonymous()<br/>            .and()<br/>                .exceptionHandling().authenticationEntryPoint(<br/>                    (req, rsp, e) -&gt; rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED))<br/>            .and()<br/>            .addFilterAfter(new AuthenticationFilter(signingSecret),<br/>                    UsernamePasswordAuthenticationFilter.class)<br/>            .authorizeRequests()<br/>            .antMatchers("/auth/**").permitAll()<br/>            .antMatchers("/messages/**").authenticated()<br/>            .antMatchers("/users/**").authenticated();<br/>    }<br/>}<br/><br/></pre>
<p style="padding-left: 60px">As we can see, we're permitting any requests to the authentication service (requests prefixed with <kbd>/auth/...</kbd>). We require that requests to the users or messages service be authenticated.</p>
<ol start="13">
<li>We need a configuration file to store the shared secret as well as the routing information for the Zuul server. Create a file called <kbd>application.yml</kbd> in the <kbd>src/main/resources</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px">server:<br/>  port: 8080<br/><br/>jwt:<br/>  secret: supers3cr3t<br/><br/>zuul:<br/>  routes:<br/>    authentication-service:<br/>      path: /auth/**<br/>      url: http://127.0.0.1:8081<br/>    message-service:<br/>      path: /messages/**<br/>      url: http://127.0.0.1:8082<br/>    user-service:<br/>      path: /users/**<br/>      url: http://127.0.0.1:8083</pre>
<ol start="14">
<li>Now that we have a working authentication service and an API Gateway capable of verifying JWTs, we can test our authentication scheme by running the API Gateway, authentication service, and message service using the ports defined in the preceding configuration file. The following CURL requests now show that valid credentials can be exchanged for a JWT and the JWT can be used to access protected resources. We can also show that requests to protected resources are rejected without a valid JWT.</li>
</ol>
<p>Note that in this example, the message service still doesn't do any authorization of requests. Anyone making an authenticated request could theoretically access anyone else's messages. The message service should be modified to check the user ID from the subject of the JWT and only allow access to messages belonging to that user.</p>
<ol start="15">
<li>We can use <kbd>curl</kbd> to test registering a new user account:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ curl -X POST -D - http://localhost:8080/auth/register -d'email=p@eval.ca&amp;password=foobar123&amp;passwordConfirmation=foobar123'</strong><br/><br/><strong>HTTP/1.1 200</strong><br/><strong>X-Content-Type-Options: nosniff</strong><br/><strong>X-XSS-Protection: 1; mode=block</strong><br/><strong>Cache-Control: no-cache, no-store, max-age=0, must-revalidate</strong><br/><strong>Pragma: no-cache</strong><br/><strong>Expires: 0</strong><br/><strong>X-Frame-Options: DENY</strong><br/><strong>X-Application-Context: application:8080</strong><br/><strong>Date: Mon, 16 Jul 2018 03:27:17 GMT</strong><br/><strong>Content-Type: application/json;charset=UTF-8</strong><br/><strong>Transfer-Encoding: chunked</strong><br/><br/><strong>{"auth_token":"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJmYWQzMGZiMi03MzhmLTRiM2QtYTIyZC0zZGNmN2NmNGQ1NGIiLCJzdWIiOiJmYWQzMGZiMi03MzhmLTRiM2QtYTIyZC0zZGNmN2NmNGQ1NGIiLCJpc3MiOiJhdXRoZW50aWNhdGlvbi1zZXJ2aWNlIn0.TzOKItjBU-AtRMqIB_D1n-qv6IO_zCBIK8ksGzsTC90"}</strong></pre>
<ol start="16">
<li>Now that we have a JWT, we can include it in the headers of requests to the message service to test that the API Gateway is able to verify and decode the token:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ curl -D - -H "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI3YmU4N2U3Mi03ZjhhLTQ3ZjktODk3NS1mYzM5ZTE0NjNmODAiLCJzdWIiOiI3YmU4N2U3Mi03ZjhhLTQ3ZjktODk3NS1mYzM5ZTE0NjNmODAiLCJpc3MiOiJhdXRoZW50aWNhdGlvbi1zZXJ2aWNlIn0.fpFbHhdSEVKk95m5Q7iNjkKyM-eHkCGGKchTTKgbGWw" http://localhost:8080/messages/123</strong><br/><br/><strong>HTTP/1.1 404</strong><br/><strong>X-Content-Type-Options: nosniff</strong><br/><strong>X-XSS-Protection: 1; mode=block</strong><br/><strong>Cache-Control: no-cache, no-store, max-age=0, must-revalidate</strong><br/><strong>Pragma: no-cache</strong><br/><strong>Expires: 0</strong><br/><strong>X-Frame-Options: DENY</strong><br/><strong>X-Application-Context: application:8080</strong><br/><strong>Date: Mon, 16 Jul 2018 04:05:40 GMT</strong><br/><strong>Content-Type: application/json;charset=UTF-8</strong><br/><strong>Transfer-Encoding: chunked</strong><br/><br/><strong>{"timestamp":1532318740403,"status":404,"error":"Not Found","exception":"com.packtpub.microservices.ch06.message.exceptions.MessageNotFoundException","message":"Message 123 could not be found","path":"/123"}</strong></pre>
<p style="padding-left: 60px">The fact that we get a 404 from the message service shows that the request is getting to that service. If we modify the JWT in the request headers, we should get a 401:</p>
<pre style="padding-left: 60px"><strong>$ curl -D - -H "Authorization: Bearer not-the-right-jwt" http://localhost:8080/messages/123</strong><br/><br/><strong>HTTP/1.1 401</strong><br/><strong>X-Content-Type-Options: nosniff</strong><br/><strong>X-XSS-Protection: 1; mode=block</strong><br/><strong>Cache-Control: no-cache, no-store, max-age=0, must-revalidate</strong><br/><strong>Pragma: no-cache</strong><br/><strong>Expires: 0</strong><br/><strong>X-Frame-Options: DENY</strong><br/><strong>Content-Type: application/json;charset=UTF-8</strong><br/><strong>Transfer-Encoding: chunked</strong><br/><strong>Date: Mon, 23 Jul 2018 04:06:47 GMT</strong><br/><br/><strong>{"timestamp":1532318807874,"status":401,"error":"Unauthorized","message":"No message available","path":"/messages/123"}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing containers</h1>
                
            
            
                
<p>The advent of containers has solved many problems for organizations that are managing microservice architectures. Containers allow services to be bundled as a self-contained unit, and the software and its dependencies can be built as a single artifact and then shipped into any environment to be run or scheduled. Instead of relying on complicated configuration-management solutions to manage small changes to production systems, containers support the idea of immutable infrastructure; once the infrastructure is built, it does not have to be upgraded or maintained. Instead, you just build new infrastructure and throw away the old.</p>
<p class="mce-root"/>
<p>Containers also allow organizations to optimize their use of storage and compute resources. Because software can be built as containers, multiple applications can be running on a single virtual machine or piece of hardware, each unaware of the others' existence. While multi-tenancy has many advantages, having multiple services running on the same VM introduces new attack scenarios that a malicious user could exploit. If an attacker is able to exploit a vulnerability in one service, they may be able to use that exploit to attack services running on the same VM. In this kind of setup, by default, the cluster is treated as the security boundary; if you have access to the cluster, you must be trusted.</p>
<p>Depending on the needs of an organization, treating the cluster as the security boundary may not be sufficient and there may be a desire for more security and isolation between containers. The seccomp security facility was introduced into the Linux kernel in Version 2.6.12. It supports restricting the system calls that can be made from a process. Running containerized applications with a seccomp policy essentially sandboxes the service and any other process running in the container. In this recipe, we'll show you how to check that the seccomp is configured in your Linux kernel and demonstrate running a container with a custom seccomp policy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>In order to use a seccomp policy with a Docker container, you must be running the container on a host OS with a Linux kernel configured with seccomp support. To check this, you can search for <kbd>CONFIG_SECCOMP</kbd> in the kernel configuration file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ grep CONFIG_SECCOMP= /boot/config-$(uname -r)</strong><br/><strong>CONFIG_SECCOMP=y</strong></pre>
<ol start="2">
<li>Now that we've verified that seccomp is enabled in the Linux kernel, we can take a look at the default profile that is packaged with Docker (<a href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json">https://github.com/moby/moby/blob/master/profiles/seccomp/default.json</a>). This default policy is sufficient for most needs and is fairly restrictive. If seccomp support is enabled, containers will be run with this policy.</li>
<li>To further verify that seccomp is configured and Docker is able to support it, we'll create a simple custom policy and then run a command in a container that demonstrates that the policy is being enforced. Create a file called <kbd>policy.json</kbd>:</li>
</ol>
<pre style="padding-left: 60px">{<br/>    "defaultAction": "SCMP_ACT_ALLOW",<br/>    "syscalls": [<br/>        {<br/>            "name": "chown",<br/>            "action": "SCMP_ACT_ERRNO"<br/>        }<br/>    ]<br/>}</pre>
<ol start="4">
<li>Now, run a container executing a shell and try to create a file, then change the ownership. The error message indicates that the container is being restricted by the seccomp policy:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker run --rm -it --security-opt seccomp:policy.json busybox /bin/sh</strong><br/><strong>/ # touch foo</strong><br/><strong>/ # chown root foo</strong><br/><strong>chown: foo: Operation not permitted</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Secure configuration</h1>
                
            
            
                
<p>Services usually require some form of configuration. A service configuration stores all of the information that could potentially vary depending on the environment the service is deployed in. For example, when running a service locally on a developer's workstation, the service should probably connect to a database that is also running locally. In production, however, the service should connect to the production database. Common data stored in configuration includes the location of and credentials to data stores, access tokens, or other credentials for third-party services and operational information, such as where to send metrics or what values to use when initializing connection pools or configuring timeouts for network connections.</p>
<p>It's important to store configuration separately from code. When you make a configuration change, you should not have to commit a change to a source code repository, create a new build, and run a separate deploy. Ideally, there should be an easy way to change configuration without deploying a new version of a service. Storing configuration in code (for example, hard coding a password in a source code file) is also a bad practice from a security perspective. Anyone with access to the source code has access to the configuration, and in the case of secrets, this is rarely desired. It is a good practice to roll keys and credentials as often as possible, so that even if a secret is compromised or is vulnerable to being compromised, it will not be valid for very long. Hardcoding secrets makes this difficult, which in practice often means it won't happen.</p>
<p>A common best practice is to store configuration in environment variables. This is a good way to expose configuration values to a process in a way that can be changed easily depending on the environment a service is running in. Environment variables are good for non-secret configuration values, such as hostnames, timeouts, and log levels. Environment variables are not sufficient for storing secrets.</p>
<p>Storing secrets as environment variables makes the values accessible to any process running in the same container or process space as the service, which makes them susceptible to being intercepted. There are various solutions for storing secrets separately from the rest of an application's configuration. Applications deployed on a Kubernetes cluster can use a special object type called <kbd>secret</kbd>, which is intended for this purpose. Kubernetes secrets are encrypted using a private key residing on a master node while in transit between nodes, however, the secret is stored in plaintext at rest. Ideally, secrets should be stored as encrypted values and only decrypted by a process that is explicitly permitted to do so.</p>
<p>Vault is an open source project actively maintained by HashiCorp. Its purpose is to provide an easy-to-use system for storing and accessing secrets securely. In addition to secret-storage, Vault provides access-log auditing, fine-grained access-control, and easy rolling. In this recipe, we'll create a new service, called attachment-service, that is responsible for handling messages' image and video attachments. Attachment-service will use Vault to obtain valid AWS credentials used to access an S3 bucket when uploading photo and video files. The service will also use Vault to obtain database credentials to a MySQL database where attachment metadata will be stored. Non-sensitive configurations, such as the name of the database or the name of the S3 bucket to upload photos and videos to, will be made available to the service as environment variables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In order to demonstrate using Vault to securely store sensitive configuration data, we'll first create an attachment service that stores sensitive information using environment variables. We'll then integrate Vault so that the same configuration is read from a secure store:</p>
<ol>
<li>Create a new Java project called <kbd>attachment-service</kbd> with the following <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/>apply plugin: 'io.spring.dependency-management'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '1.5.9.RELEASE'<br/>    compile group: 'mysql', name: 'mysql-connector-java'<br/>    compile group: 'com.amazonaws', name: 'aws-java-sdk-s3', version: '1.11.375'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<ol start="2">
<li>Create a new package called <kbd>com.packtpub.microservices.ch06.attachment</kbd> and create a new class called <kbd>Application</kbd>, which will serve as our service's entry point. In addition to running our Spring Boot application, this class will expose one bean, which is the Amazon S3 client. Note that we're using the <kbd>EnvironmentVariableCredentialsProvider</kbd> class, which reads credentials from a set of environment variables for now, this is not what we want to do in production:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.attachment;<br/><br/>import com.amazonaws.auth.EnvironmentVariableCredentialsProvider;<br/>import com.amazonaws.regions.Regions;<br/>import com.amazonaws.services.s3.AmazonS3;<br/>import com.amazonaws.services.s3.AmazonS3ClientBuilder;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.context.annotation.Bean;<br/><br/>@SpringBootApplication<br/>public class Application {<br/><br/>    @Bean<br/>    public AmazonS3 getS3Client() {<br/>        AmazonS3ClientBuilder client = AmazonS3ClientBuilder.standard();<br/>        return client.withCredentials(<br/>                new EnvironmentVariableCredentialsProvider()).withRegion(Regions.US_WEST_2).build();<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/>}</pre>
<ol start="3">
<li>Create a new package called <kbd>com.packtpub.microservices.ch06.attachment.models</kbd> and a new class called <kbd>Attachment</kbd>. This will be the representation of attachments that we store in a relational database:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.attachment.models;<br/><br/>import org.hibernate.annotations.GenericGenerator;<br/><br/>import javax.persistence.Column;<br/>import javax.persistence.Entity;<br/>import javax.persistence.GeneratedValue;<br/>import javax.persistence.Id;<br/><br/>@Entity<br/>public class Attachment {<br/><br/>    @Id<br/>    @GeneratedValue(generator = "uuid")<br/>    @GenericGenerator(name = "uuid", strategy = "uuid2")<br/>    private String id;<br/><br/>    @Column(unique = true)<br/>    private String messageId;<br/>    private String url;<br/>    private String fileName;<br/>    private Integer mediaType;<br/><br/>    public Attachment(String messageId, String url, String fileName, Integer mediaType) {<br/>        this.messageId = messageId;<br/>        this.url = url;<br/>        this.fileName = fileName;<br/>        this.mediaType = mediaType;<br/>    }<br/><br/>    public String getId() {<br/>        return id;<br/>    }<br/><br/>    public void setId(String id) {<br/>        this.id = id;<br/>    }<br/><br/>    public String getMessageId() {<br/>        return messageId;<br/>    }<br/><br/>    public void setMessageId(String messageId) {<br/>        this.messageId = messageId;<br/>    }<br/><br/>    public String getUrl() {<br/>        return url;<br/>    }<br/><br/>    public void setUrl(String url) {<br/>        this.url = url;<br/>    }<br/><br/>    public String getFileName() {<br/>        return fileName;<br/>    }<br/><br/>    public void setFileName(String fileName) {<br/>        this.fileName = fileName;<br/>    }<br/><br/>    public Integer getMediaType() {<br/>        return mediaType;<br/>    }<br/><br/>    public void setMediaType(Integer mediaType) {<br/>        this.mediaType = mediaType;<br/>    }<br/>}</pre>
<ol start="4">
<li>In order to perform basic operations on the previously defined <kbd>Attachment</kbd> class, we'll create a new package called <kbd>com.packtpub.microservices.ch06.attachment.data</kbd> and an interface called <kbd>AttachmentRepository</kbd>, which extends <kbd>CrudRepository</kbd>. We'll also define one custom method signature that allows a caller to find all attachments related to a specific message:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.attachment.data;<br/><br/>import com.packtpub.microservices.ch06.attachment.models.Attachment;<br/>import org.springframework.data.repository.CrudRepository;<br/><br/>import java.util.List;<br/><br/>public interface AttachmentRepository extends CrudRepository&lt;Attachment, String&gt; {<br/>    public List&lt;Attachment&gt; findByMessageId(String messageId);<br/>}</pre>
<ol start="5">
<li>We also need a way to model incoming requests. Our service will accept requests as JSON sent in the request body. The JSON object will have a file name and contain the file data as a Base64-encoded string. Create a new class called <kbd>AttachmentRequest</kbd> with the following definition:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.attachment.models;<br/><br/>import com.fasterxml.jackson.annotation.JsonProperty;<br/><br/>import java.util.Map;<br/><br/>public class AttachmentRequest {<br/>    private String fileName;<br/><br/>    private String data;<br/><br/>    public AttachmentRequest() {}<br/><br/>    public AttachmentRequest(String fileName, String data) {<br/>        this.fileName = fileName;<br/>        this.data = data;<br/>    }<br/><br/>    public String getFileName() {<br/>        return fileName;<br/>    }<br/><br/>    public void setFileName(String fileName) {<br/>        this.fileName = fileName;<br/>    }<br/><br/>    public String getData() {<br/>        return data;<br/>    }<br/><br/>    public void setData(String data) {<br/>        this.data = data;<br/>    }<br/><br/>    @JsonProperty("file")<br/>    private void unpackFileName(Map&lt;String, String&gt; file) {<br/>        this.fileName = file.get("name");<br/>        this.data = file.get("data");<br/>    }<br/>}</pre>
<ol start="6">
<li>In our controller, which we'll define next, we'll need to return an HTTP 404 response to callers if no attachments can be found for a particular message. In order to do this, create a new package called <kbd>com.packtpub.microservices.ch06.attachment.exceptions</kbd> and a new class called <kbd>AttachmentNotFoundException</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.attachment.exceptions;<br/><br/>import org.springframework.http.HttpStatus;<br/>import org.springframework.web.bind.annotation.ResponseStatus;<br/><br/>@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "No attachment(s) found")<br/>public class AttachmentNotFoundException extends RuntimeException {}</pre>
<ol start="7">
<li>We'll put everything together in our controller. In this basic example, two methods are defined; one that lists attachments for a specific message and one that creates a new attachment. The attachment is uploaded to an Amazon S3 bucket, the name of which is specified in a configuration value. Create a new package called <kbd>com.packtpub.microservices.ch06.attachment.controllers</kbd> and a new class called <kbd>AttachmentController</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.attachment.controllers;<br/><br/>import com.amazonaws.services.s3.AmazonS3;<br/>import com.amazonaws.services.s3.model.CannedAccessControlList;<br/>import com.amazonaws.services.s3.model.ObjectMetadata;<br/>import com.amazonaws.services.s3.model.PutObjectRequest;<br/>import com.packtpub.microservices.ch06.attachment.data.AttachmentRepository;<br/>import com.packtpub.microservices.ch06.attachment.exceptions.AttachmentNotFoundException;<br/>import com.packtpub.microservices.ch06.attachment.models.Attachment;<br/>import com.packtpub.microservices.ch06.attachment.models.AttachmentRequest;<br/>import org.apache.commons.codec.binary.Base64;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.beans.factory.annotation.Value;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>import java.io.ByteArrayInputStream;<br/>import java.io.InputStream;<br/>import java.util.List;<br/><br/>@RestController<br/>public class AttachmentController {<br/><br/>    @Autowired<br/>    private AttachmentRepository attachmentRepository;<br/><br/>    @Autowired<br/>    private AmazonS3 s3Client;<br/><br/>    @Value("${s3.bucket-name}")<br/>    private String bucketName;<br/><br/>    @RequestMapping(path = "/message/{message_id}/attachments", method = RequestMethod.GET, produces = "application/json")<br/>    public List&lt;Attachment&gt; getAttachments(@PathVariable("message_id") String messageId) {<br/>        List&lt;Attachment&gt; attachments = attachmentRepository.findByMessageId(messageId);<br/>        if (attachments.isEmpty()) {<br/>            throw new AttachmentNotFoundException();<br/>        }<br/>        return attachments;<br/>    }<br/><br/>    @RequestMapping(path = "/message/{message_id}/attachments", method = RequestMethod.POST, produces = "application/json")<br/>    public Attachment create(@PathVariable("message_id") String messageId, @RequestBody AttachmentRequest request) {<br/><br/>        byte[] byteArray = Base64.decodeBase64(request.getData());<br/><br/>        ObjectMetadata metadata = new ObjectMetadata();<br/>        metadata.setContentLength(byteArray.length);<br/>        metadata.setContentType("image/jpeg");<br/>        metadata.setCacheControl("public, max-age=31536000");<br/>        InputStream stream = new ByteArrayInputStream(byteArray);<br/><br/>        String fullyResolved = String.format("%s/%s", messageId, request.getFileName());<br/><br/>        s3Client.putObject(<br/>            new PutObjectRequest(bucketName, fullyResolved, stream, metadata)<br/>                .withCannedAcl(CannedAccessControlList.PublicRead));<br/><br/>        String url = String.format("https://%s.s3.amazonaws.com/%s", bucketName, fullyResolved);<br/><br/>        Attachment attachment = new Attachment(messageId, url, request.getFileName(), 1);<br/>        attachmentRepository.save(attachment);<br/>        return attachment;<br/>    }<br/>}</pre>
<ol start="8">
<li>In order for any of this to work, we have to create a properties file. Java properties files support a syntax for getting values from environment variables, which is shown in the following code. Create a new file in the <kbd>src/main/resources</kbd> directory called <kbd>application.yml</kbd>:</li>
</ol>
<pre style="padding-left: 60px">spring:<br/>  jpa.hibernate.ddl-auto: create<br/>  datasource.url: ${DATABASE_URL}<br/>  datasource.username: ${DATABASE_USERNAME}<br/>  datasource.password: ${DATABASE_PASSWORD}<br/><br/>s3:<br/>  bucket-name: ${BUCKET_NAME}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p style="padding-left: 60px">This example works well enough. <kbd>EnvironmentVariableCredentialsProvider</kbd> in the AWS SDK expects <kbd>AWS_ACCESS_KEY_ID</kbd> and <kbd>AWS_SECRET_ACCESS_KEY</kbd> to be set, and we specify that a number of non-sensitive configuration values should be similarly read from environment variables. This is clearly better than hardcoding configuration values, but we're still exposing secrets to any process running in the same container or process space as our service. The environment variables also have to be set somewhere (by a configuration management system or specified in a Dockerfile), so we haven't solved the problem of storing sensitive secrets. Next, we'll modify our new service to read S3 credentials from Vault.</p>
<p>In this recipe, we'll be running Vault in development mode. Installing Vault for production use is a big topic that cannot be properly covered in a single recipe. For the production use of Vault, please consult the excellent documentation available at <a href="https://www.vaultproject.io/intro/index.html">https://www.vaultproject.io/intro/index.html</a>.</p>
<ol start="9">
<li>Install <kbd>vault</kbd> on your local development machine. See <a href="http://www.vaultproject.io">http://www.vaultproject.io</a> for instructions for any platform. If you are running macOS X and use <strong>HomeBrew</strong>, you can install Vault with a single command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ brew install vault</strong></pre>
<ol start="10">
<li>Run the <kbd>vault server</kbd> in development mode, providing a simple-to-remember root token:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ vault server --dev --dev-root-token-id="00000000-0000-0000-0000-000000000000"</strong></pre>
<ol start="11">
<li>Enable a new instance of a <kbd>kv</kbd> secrets engine with a path specific to this service:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ vault secrets enable -path=secret/attachment-service</strong></pre>
<ol start="12">
<li>Write the AWS access key and secret pair to <kbd>vault</kbd> as secrets. Substitute the placeholders for your actual AWS access key ID and AWS secret access key:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ vault write secret/attachment-service attachment.awsAccessKeyId=&lt;access-key&gt; attachment.awsSecretAccessKey=&lt;access-secret&gt;</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="13">
<li>In order for our service to read these values from Vault, we'll use a library that simplifies Vault integration for Spring Boot applications. Modify our project's <kbd>build.gradle</kbd> file and add the following dependency:</li>
</ol>
<pre style="padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/>apply plugin: 'io.spring.dependency-management'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '1.5.9.RELEASE'<br/><strong>    compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-vault-config', version: </strong><strong>'1.1.1.RELEASE'</strong><br/>    compile group: 'mysql', name: 'mysql-connector-java'<br/>    compile group: 'com.amazonaws', name: 'aws-java-sdk-s3', version: '1.11.375'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="14">
<li>Our application needs a configuration class to store values read from Vault. Create a new package called <kbd>com.packtpub.microservices.ch06.attachment.config</kbd> and a new class called <kbd>Configuration</kbd>:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.attachment.config;<br/><br/>import org.springframework.boot.context.properties.ConfigurationProperties;<br/><br/>@ConfigurationProperties("attachment")<br/>public class Configuration {<br/><br/>    private String awsAccessKeyId;<br/><br/>    private String awsSecretAccessKey;<br/><br/>    public String getAwsAccessKeyId() {<br/>        return awsAccessKeyId;<br/>    }<br/><br/>    public void setAwsAccessKeyId(String awsAccessKeyId) {<br/>        this.awsAccessKeyId = awsAccessKeyId;<br/>    }<br/><br/>    public String getAwsSecretAccessKey() {<br/>        return awsSecretAccessKey;<br/>    }<br/><br/>    public void setAwsSecretAccessKey(String awsSecretAccessKey) {<br/>        this.awsSecretAccessKey = awsSecretAccessKey;<br/>    }<br/>}</pre>
<ol start="15">
<li>Modify the <kbd>Application</kbd> class to create an instance of the class we just created. Then use the instance when creating the S3 client so that we can use credentials taken from Vault instead of environment variables:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices.ch06.attachment;<br/><br/><strong>import com.amazonaws.auth.AWSCredentials</strong><strong>;</strong><br/><strong>import com.amazonaws.auth.AWSStaticCredentialsProvider</strong><strong>;</strong><br/><strong>import com.amazonaws.auth.BasicAWSCredentials</strong><strong>;</strong><br/>import com.amazonaws.regions.Regions;<br/>import com.amazonaws.services.s3.AmazonS3;<br/>import com.amazonaws.services.s3.AmazonS3ClientBuilder;<br/><br/><strong>import com.packtpub.microservices.ch06.attachment.config.Configuration</strong><strong>;</strong><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/><strong>import org.springframework.boot.context.properties.EnableConfigurationProperties</strong><strong>;</strong><br/>import org.springframework.context.annotation.Bean;<br/><br/>@SpringBootApplication<br/><strong>@EnableConfigurationProperties(Configuration.class)</strong><br/>public class Application {<br/><br/><strong>    private final Configuration config</strong><strong>;</strong><br/><br/><strong>    public Application(Configuration config) {</strong><br/><strong>        this.config = config;<br/>    }</strong><br/><br/>    @Bean<br/>    public AmazonS3 getS3Client() {<br/>        AmazonS3ClientBuilder client = AmazonS3ClientBuilder.standard();<br/>        <strong>AWSCredentials credentials = new BasicAWSCredentials(config.getAwsAccessKeyId(), config.getAwsSecretAccessKey());<br/>        return client.withCredentials(</strong><br/><strong>                new AWSStaticCredentialsProvider(credentials)).withRegion(Regions.US_WEST_2).build()</strong><strong>;</strong><br/>    }<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/>}</pre>
<p>That's it! The attachment service is now configured to read AWS credentials from Vault. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Secure logging</h1>
                
            
            
                
<p>Together with traces and metrics, logs are an essential component of an observable system (we'll discuss Observability more generally in <a href="fc3632cc-83c0-44ff-b11d-87f556f7b46b.xhtml">Chapter 7</a>, <em>Monitoring and Observability</em>). Logs are an ordered, timestamped sequence of events that originated in a particular system.</p>
<p>In a microservice architecture, the increased complexity of having multiple services makes having good logs essential. The exact criteria that makes logs good is subjective, but generally speaking, good logs should help an engineer piece together events that may have led to a specific error state or bug. Logs are usually organized by levels, a configurable toggle that allows a developer to instruct a service to be more or less verbose with the information sent to logs.</p>
<p>While essential for observing the behavior of systems in production, logs can also present privacy and security risks. Having too much information sent from systems to logs can give a would-be attacker information about users of your system, or sensitive information such as tokens or keys that can be used to attack other parts of your system. Having a microservice architecture spreads out this possible attack surface, making it even more important to have a carefully planned strategy for how your services should log information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Infrastructure as Code</h1>
                
            
            
                
<p>Microservices architectures typically require more frequent provisioning of compute resources. Having more nodes in a system increases the attack surface that an attacker could scan for possible vulnerabilities. One of the easiest ways to leave a system vulnerable is to lose track of the inventory and leave multiple, heterogeneous configurations active. Before configuration-management systems, such as, Puppet or Ansible were popular, it was common to have a set of custom shell scripts that would <em>bootstrap</em> new servers in a system. This worked well enough, but as the needs of the system grew, and the shell scripts were modified, it became unwieldy to bring older parts of the system up to date with the changing standards. This type of configuration drift would often leave legacy parts of a system vulnerable to attack. Configuration-management solved many of these problems by allowing teams to use code, usually with a declarative syntax, to describe how nodes in a system should be configured. Configuration-management systems typically did not deal with provisioning actual compute resources, such as compute nodes, data stores, or network storage.</p>
<p>Infrastructure as Code is the process of managing infrastructure-provisioning and maintenance through machine-readable code files rather than manually. Using code to describe the infrastructure allows for effective versioning, reviews, and rollbacks of changes to a system. Being able to automate the process of bringing up a database node or adding a compute node to a cluster frees developers up to worry about their applications, relatively assured that they are not leaving old configurations out in the wild. Together with immutable infrastructure, Infrastructure as Code provides an additional safety net against a system being compromised by vulnerable, forgotten components.</p>
<p>In this recipe, we'll demonstrate using <em>Terraform</em>, an open source tool created by HashiCorp, to provision a collection of AWS resources, including an EC2 instance and a Redis ElastiCache. We'll guarantee that resources provisioned with Terraform share configurations with regards to network access, backups, and other security considerations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Before using terraform, you'll have to install it. Instructions are available on the <a href="https://www.terraform.io/intro/getting-started/install.html">project site</a>, but if you are running macOS X and use HomeBrew (<a href="https://brew.sh/">https://brew.sh/</a>), you can issue the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ brew install terraform</strong></pre>
<ol start="2">
<li>Create a new file called <kbd>example.tf</kbd>. This will contain configuration for our EC2 instance and ElastiCache instance. We'll use a default <strong>Amazon Machine Image</strong> (<strong>AMI</strong>) and enable daily snapshots that will be kept for five days:</li>
</ol>
<pre style="padding-left: 60px"> provider "aws" {<br/>     access_key = "ACCESS_KEY"<br/>     secret_key = "SECRET_KEY"<br/>     region = "us-east-1"<br/> }<br/><br/> resource "aws_instance" "example" {<br/>   ami           = "ami-b374d5a5"<br/>   instance_type = "t2.micro"<br/> }<br/><br/> resource "aws_elasticache_cluster" "example" {<br/>   cluster_id           = "cluster-example"<br/>   engine               = "redis"<br/>   node_type            = "cache.m3.medium"<br/>   num_cache_nodes      = 1<br/>   parameter_group_name = "default.redis3.2"<br/>   port                 = 6379<br/>   snapshot_window      = "05:00-09:00"<br/>   snapshot_retention_limit = 5<br/> }</pre>
<p style="padding-left: 60px">Replace <kbd>ACCESS_KEY</kbd> and <kbd>SECRET_KEY</kbd> with a valid AWS access key pair.</p>
<ol start="3">
<li>Initialize terraform. This will install the AWS provider referenced in the preceding file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ terraform init</strong></pre>
<ol start="4">
<li>Terraform works by presenting an execution plan and then asking whether you'd like to proceed by applying the plan. Run the following command and type <kbd>yes</kbd> when prompted:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ terraform apply</strong><br/><br/><strong>aws_instance.example: Refreshing state... (ID: i-09b5cf5ed923d60f4)</strong></pre>
<p style="padding-left: 60px">An execution plan has been generated and is shown in the following code. Resource actions are indicated with the following symbols: <kbd>+ create</kbd>.</p>
<p style="padding-left: 60px">Terraform will perform the following actions:</p>
<pre style="padding-left: 60px"><strong>+ aws_elasticache_cluster.example</strong><br/><strong>      id: &lt;computed&gt;</strong><br/><strong>      apply_immediately: &lt;computed&gt;</strong><br/><strong>      availability_zone: &lt;computed&gt;</strong><br/><strong>      az_mode: &lt;computed&gt;</strong><br/><strong>      cache_nodes.#: &lt;computed&gt;</strong><br/><strong>      cluster_address: &lt;computed&gt;</strong><br/><strong>      cluster_id: "cluster-example"</strong><br/><strong>      configuration_endpoint: &lt;computed&gt;</strong><br/><strong>      engine: "redis"</strong><br/><strong>      engine_version: &lt;computed&gt;</strong><br/><strong>      maintenance_window: &lt;computed&gt;</strong><br/><strong>      node_type: "cache.m3.medium"</strong><br/><strong>      num_cache_nodes: "1"</strong><br/><strong>      parameter_group_name: &lt;computed&gt;</strong><br/><strong>      port: "6379"</strong><br/><strong>      replication_group_id: &lt;computed&gt;</strong><br/><strong>      security_group_ids.#: &lt;computed&gt;</strong><br/><strong>      security_group_names.#: &lt;computed&gt;</strong><br/><strong>      snapshot_retention_limit: "5"</strong><br/><strong>      snapshot_window: "05:00-09:00"</strong><br/><strong>      subnet_group_name: &lt;computed&gt;</strong><br/><br/><br/><strong>Plan: 1 to add, 0 to change, 0 to destroy.</strong><br/><strong>Do you want to perform these actions?</strong></pre>
<p style="padding-left: 60px">Terraform will perform the actions described earlier. Only <kbd>yes</kbd> will be accepted to approve:</p>
<pre style="padding-left: 60px"><strong>Enter a value: yes</strong><br/><br/><strong>...</strong></pre>
<ol start="5">
<li>Log into your AWS management console and you'll see that a new Redis cluster and EC2 instance have been created. Terraform can also help you clean up. In order to destroy these two resources, run the destroy command and type in <kbd>yes</kbd> when prompted:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ terraform destroy</strong></pre>
<p>Terraform is an incredibly powerful tool. In this recipe, we used it to create a single EC2 instance and an ElastiCache Cluster instance. You can do loads more with Terraform – the subject of Infrastructure as Code could fill a cookbook of its own. Thankfully, the docs provided by HashiCorp (<a href="https://www.terraform.io/docs/index.html">https://www.terraform.io/docs/index.html</a>) are excellent and I would recommend reading them.</p>
<p>Using an Infrastructure as Code solution will make provisioning and managing resources a much safer process, limiting the possibility of losing track of legacy infrastructure with out-of-date configurations.</p>


            

            
        
    </body></html>