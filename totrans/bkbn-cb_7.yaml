- en: Chapter 7. REST and Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecting the REST API for the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototyping a RESTful backend with MongoLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing models and collections with a RESTful service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a RESTful frontend with Backbone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the polling technique to fetch data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on the way Backbone.js synchronizes models and collections
    with a RESTful backend, or stores them in the HTML5 local storage.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to design the REST API for our backend, which can be implemented
    with almost any programming framework, such as Symphony, Ruby on Rails, Django,
    or Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, we will use MongoLab ([http://mongolab.com](http://mongolab.com)),
    which is the cloud version of MongoDB, with a RESTful interface. We will also
    learn what tools to use to debug the RESTful service when the frontend app has
    not been built yet.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we will make the Backbone application communicate with the RESTful service,
    performing full set of CRUD operations supported by the REST server. We will also
    learn how to use the polling technique to update data in a collection in the application
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: We will also discuss about an extension that allows us to keep data in HTML5's
    local storage instead of keeping them in the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting the REST API for the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is an architectural style for
    designing network applications that communicate amongst each other. Unlike COBRA
    or SOAP, REST can be easily implemented on top of pure HTTP.'
  prefs: []
  type: TYPE_NORMAL
- en: REST-style architectures consist of clients and servers. The client calls the
    HTTP request method (`POST`, `GET`, `PUT`, or `DELETE`) to perform CRUD (created,
    read, update, and delete) operation over a resource that can be either a collection
    or a single element.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to architect an API of the REST server for the
    Billing application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to architect an API of a RESTful service:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the base REST URI used by the client to access resources stored on the
    server; for example, it can look like `http://example.com/resources`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define URIs to access your app-specific resources. These URIs should be relative
    to the base REST URI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Invoice collection**: `<rest-uri>/invoices`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoice**: `<rest-uri>/invoices/<invoice-id>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buyer collection**: `<rest-uri>/buyers`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buyer**: `<rest-uri>/buyers/<buyer-id>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seller**: `<rest-uri>/seller`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The URI to access the resource can look like `http://example.com/resources/items
    and data`, which are transferred through REST, and are typically in the JSON format,
    XML, or any other valid Internet media types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes what happens when the REST operation is performed
    on a specific resource type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Resource URI | Collection:`http://example.com/resources/items` | Element:`http://example.com/resources/items/1`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | This request creates a new item in the collection and returns a
    newly created item or its URI. | It''s not typically used. If used, it does the
    same job as a POST query for a collection''s resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | This request lists collection items or theirs URIs. | This request
    retrieves collection items by their URIs. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | This request replaces the entire collection with another collection.
    | This request replaces collection items or creates one if it does not exist.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | This request deletes the entire collection. | This request deletes
    items from the collection. |'
  prefs: []
  type: TYPE_TB
- en: Refer to the Roy Fieldings' PhD thesis, which is the first and most complete
    work about REST, to learn more about REST at [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping a RESTful backend with MongoLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we want to create a Backbone application that will communicate with
    a RESTful service. Should we start with creating a backend or a frontend? This
    question sounds like a dilemma, but the answer is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way is to create a prototype using a simple database with a REST-style
    interface, so we can quickly replace it with our own backend in the future.
  prefs: []
  type: TYPE_NORMAL
- en: There is a good tool for that named MongoLab ([http://mongolab.com](http://mongolab.com)),
    which is the cloud version of MongoDB with a REST-style interface. MongoDB is
    a NoSQL document-oriented database that works with JSON-like data. MongoLab will
    not require us to write even a single line of code on the backend, so it is perfect
    for us as a prototyping tool.
  prefs: []
  type: TYPE_NORMAL
- en: To test and debug the MongoLab backend, we will use the Advanced REST client,
    which is an extension to the Chrome browser. It allows performing HTTP queries
    on a RESTful service and visualizes JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to be prepared for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an account on the MongoLab website ([https://mongolab.com](https://mongolab.com)),
    or log in if you have an existing one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Advanced REST client on your browser using the URL [https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo).
    If you're using Firefox or Safari, you can easily find a similar extension for
    this purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a MongoLab database and fill it with data:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://mongolab.com/newdb](https://mongolab.com/newdb) and create a
    new database named `billing-app` within your MongoLab account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `https://mongolab.com/user?username=<username>` and get an API key that
    you can use for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check databases in your account, perform a `GET` request on a URI, say `https://api.mongolab.com/api/1/databases?apiKey=<your-api-key>`,
    using the Advanced REST client.![How to do it...](img/2728_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result will look like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2728_07_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To get a list of collections in the database, perform a `GET` request on the
    URI `https://api.mongolab.com/api/1/databases/billing-app/collections?apiKey=<your-api-key>`.
    The result will look like the following screenshot:![How to do it...](img/2728_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a new collection, let''s send the collection items defined in the
    JSON format using a `POST` query on this URI: `https://api.mongolab.com/api/1/databases/billing-app/collections/invoices?apiKey=<your-api-key>`.
    Make sure that the **application/json Content-Type** header is set.![How to do
    it...](img/2728_07_04.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result of such an operation will look like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2728_07_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: By performing a `GET` request on the same resource again, we will be returned
    inserted items with their IDs in the JSON format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2728_07_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To update an existing item in the collection, we need to perform a `PUT` request
    on the collection item resource, specified by its ID, in the URI `https://api.mongolab.com/api/1/databases/billing-app/collections/invoices/<invoice-id>?apiKey=<your-api-key>`.
    In the `PUT` request, we should pass an updated model in the JSON format. The
    result is also returned in JSON, as shown in the following screenshot:![How to
    do it...](img/2728_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MogoLab translates HTTP requests into MongoDB queries, which are executed, and
    the results are returned in the MongoDB Extended JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the MongoLab's REST API to learn more about performing queries at [https://support.mongolab.com/entries/20433053-REST-API-for-MongoDB](https://support.mongolab.com/entries/20433053-REST-API-for-MongoDB).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also visit the following URL in order to meet specifications of the
    MongoDB Extended JSON format at [http://docs.mongodb.org/manual/reference/mongodb-extended-json/](http://%20http://docs.mongodb.org/manual/reference/mongodb-extended-json/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing models and collections with a RESTful service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to synchronize models and collections
    with a RESTful service. Just as we did in all other recipes, we will use MongoLab
    for a RESTful service.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to get familiar with REST in Backbone.js:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a configuration object that stores a server URL and an authentication
    key for MongoLab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a `url()` method that returns a resource URL to perform a REST request.
    Such URLs should contain a model ID, if a model is already synchronized with a
    RESTful service. Also, such URLs should contain a MongoLab's authentication key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another way to do this is to define the `urlRoot` property, though it does not
    allow adding parameters to the URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a new collection and a `url` property or `url()` method that should return
    the URL to a collection resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To load data from a server into a collection, use the `fetch()` method. You
    can pass `success` and `error` callbacks as a parameter. Either of them will be
    called asynchronously if a synchronization succeeds or fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the `fetch()` method is run, the read event is triggered. Also, on success,
    the sync event is triggered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To load a specific model that exists on a server, you can also use the `fetch()`
    method, which works in a similar way as it worked for collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To sync a model with a RESTful service, use the `save()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To perform an update for a specific attribute, pass hash of changed attributes
    in the first parameter and `{patch: true}` in the second parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, the `save()` method works asynchronously, so you need to handle
    results in the `success` or `error` callbacks. However, if you need to run the
    `save()` method synchronously, pass `null` in the first parameter and `{wait:
    true}` in the second parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can create a new model within a collection using the `create()` method.
    In this case, Backbone.js automatically calls the `save()` method and a new module
    is pushed to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can destroy a model using the `destroy()` method, which removes a model
    both from a collection and a server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fetch()`, `save()`, or `destroy()` methods call the `sync()` method to
    perform HTTP queries to synchronize models and collections with a RESTful service.
    The `sync()` method accepts the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method`: It can be either create, update, patch, delete, or read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model`: It''s either a model or a collection used to sync.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: These are the options accepted by the `$.ajax` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can override the `sync()` method if you need to override synchronization,
    or to use storage without a REST support.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoLab returns data in the MongoDB Extended JSON format, which is not supported
    by Backbone.js by default. In this recipe, we are going to fix this and find a
    good solution to process MongoDB Extended JSON directly in a Backbone application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling MongoDB Extended JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MongoLab ([http://mongolab.com](http://mongolab.com)) is a RESTful service
    that transforms HTTP requests into MongoDB queries and returns the results in
    the MongoDB Extended JSON, which will look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For appropriate results, we need to handle such IDs. The idea behind this is
    to override the `parse()` method, which processes JSON and initializes the model
    properties out of it. We are going to replace the format of an ID here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Also, when the `sync()` method is run, we need to make sure that data is exported
    in the MongoDB Extended JSON format. In all the other cases, it should be exported
    in a regular JSON format. Data export is performed only in the `toJSON()` method,
    so we can do this by replacing the `toJSON()` method during the `sync()` method
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Backbone.js extension with Grunt* recipe in [Chapter 8](ch08.html
    "Chapter 8. Special Techniques"), *Special Techniques*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also be interested in checking the source code of `Backbone.sync` at
    [http://backbonejs.org/docs/backbone.html#section-134](http://backbonejs.org/docs/backbone.html#section-134).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit the following URL in order to meet specifications of MongoDB Extended
    JSON at [http://docs.mongodb.org/manual/reference/mongodb-extended-json/](http://docs.mongodb.org/manual/reference/mongodb-extended-json/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a RESTful frontend with Backbone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to write a frontend application that will act as
    a client for a RESTful service. For the backend, we will use the MongoLab service,
    which is a cloud version of MongoDB with a REST interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the LayoutManager extension to output our views in a neat format.
    To build our application, we will take an example app from [Chapter 6](ch06.html
    "Chapter 6. Templates and UX sugar"), *Templates and UX sugar*, and will modify
    it, so it will support data sync via REST and will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a RESTful frontend with Backbone](img/2728_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the left-hand side pane, we can see a list of invoice titles, and in the
    right-hand side pane, we can see the invoice details. By default, these details
    are shown for the first invoice until the user clicks on a link in the left-hand
    side pane.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user clicks on the **Edit** button, the following form is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a RESTful frontend with Backbone](img/2728_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the user clicks on the **Save** button, the model is updated, and it's
    JSON is sent to the server via REST, and the list in the left pane is also updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user clicks on the **Delete** button, a delete confirmation form appears,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a RESTful frontend with Backbone](img/2728_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the user confirms the deletion, the model is destroyed and removed from the
    server via REST.
  prefs: []
  type: TYPE_NORMAL
- en: Users can also create a new invoice by clicking on the **Add an invoice** link
    at the top of the page. Then, an Add Invoice form is shown, which is identical
    to the Edit form, with no data shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a RESTful frontend with Backbone](img/2728_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to be prepared for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the LayoutManager extension is installed. The usage and installation
    of this extension is described in the *Assembling layouts with LayoutManager*
    recipe in [Chapter 6](ch06.html "Chapter 6. Templates and UX sugar"), *Templates
    and UX Sugar*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `Backbone.Model` to support the MongoDB Extended JSON format, which
    is used in MongoLab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This allows Backbone to work correctly with data IDs in a format like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a RESTful application with Backbone:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a configuration object that we will store the server URL and authentication
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define `InvoiceModel` and set the `url()` method, which will return the model's
    resource URL to perform REST requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define `InvoiceCollection` and the `url()` method for the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a router and add the `initialize()` method, which creates an empty collection
    and layout objects and renders a layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a layout template into `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add `routes` and callbacks to the router object. Each callback calls the `switchPane()`
    method, which switches the right-hand side pane of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `switchPane()` method to the router, which fetches collection from the
    RESTful service and switches the right-hand side pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the invoice list pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a template for it in `index.html`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a view invoice pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a template for it in `index.html`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define an edit invoice pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a template for it in `index.html`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a delete invoice pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a template for it in `index.html`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a router instance and start the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To load the collection from a RESTful service, we need to call the `fetch()`
    method, which runs asynchronously as a regular AJAX call does. If we need to run
    any code after the data is fetched successfully, we need to pass the callback
    function in a second parameter keyed by the `success` key. If we need to perform
    a fallback behavior in case of an error, we should pass the callback function
    keyed by the `error` key in the function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To sync model with a remote server via REST, we use the `save()` method. To
    remove the model entirely from a remote server, we use the `destroy()` method.
    Both the methods accept the `success` and `error` callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Assembling layouts with LayoutManager* recipe in [Chapter 6](ch06.html
    "Chapter 6. Templates and UX sugar"), *Templates and UX sugar*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the official docs to get more information about Backbone methods we
    used in this recipe at [http://backbonejs.org/](http://backbonejs.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the polling technique to fetch data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we were fetching data into a collection each time the
    router processed a URL change. We may wonder what happens if someone else updates
    data in the same storage? Can we see the updates immediately?
  prefs: []
  type: TYPE_NORMAL
- en: You might have seen how Facebook or Twitter updates a news feed in real time,
    and you may want to implement a similar behavior in your application. Typically,
    it can be done using the polling technique, which we are going to learn in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a web application that will update the collection view
    dynamically with the help of a polling technique.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Override `Backbone.Model` and `Backbone.Collection` to support the MongoDB Extended
    JSON format, which is used in MongoLab.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the polling technique:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new polling collection that fetches data recursively and provides methods
    to start or stop polling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a configuration object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define an invoice view and bind callbacks to model events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define an invoice list view and bind callbacks to collection events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a collection and render the corresponding view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start polling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind polling is to fetch the server regularly. However, we can't
    do this in a simple loop, because fetching works asynchronously, and we need to
    make sure AJAX requests do not overlap with each other. Thus, we need to make
    sure previous fetching is completed successfully before performing the next one.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we inherited a collection from `Backbone.Collection` and added
    new methods and properties that we needed to implement polling. In the `executePolling()`
    method, we are performing the `fetch()` method and passing the `onFetch()` method
    as a success callback. In the `onFetch() method`, we call the `executePolling()`
    method with a timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Working with local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to store data on a browser storage rather than on a remote
    server. This is quite easy to do with the help of the Backbone extension known
    as localStorage Adapter, which overrides the behavior of the `Backbone.sync()`
    method to sync data with HTML5 local storage. In this recipe, we are going to
    learn how to use this extension.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the Backbone localStorage adapter from its GitHub page at [https://github.com/jeromegn/Backbone.localStorage](https://github.com/jeromegn/Backbone.localStorage).
    To include this extension into your project, save the `backbone.localStorage.js`
    file into the `lib` folder and include a reference to it in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Including Backbone extension into your project is described in detail in the
    *Extending an application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extend the collection and set the `localStorage` key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create an instance of `Backbone.LocalStorage` and pass the storage
    name as a constructor parameter. The storage name should be unique within your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backbone's localStorage adapter overrides the `Backbone.sync()` method, which
    executes a code to synchronize data with the HTML5 localStorage, if it is enabled
    for a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Be aware when creating new models**'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing you should avoid when using the localStorage adapter is creating
    new models and saving them by calling the `save()` method of the model. Instead,
    you should call the `create()` method of the collection object, because otherwise
    the model is not associated to a collection yet, and the localStorage adapter
    has no idea which local storage to use.
  prefs: []
  type: TYPE_NORMAL
- en: After the model is associated with a collection, the `save()` method works pretty
    well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is also a Backbone extension that allows storing data in the WebSQL storage
    at [https://github.com/MarrLiss/backbone-websql](https://github.com/MarrLiss/backbone-websql).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plenty of extensions that allow using different storage engines at
    [https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources#storage](https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources#storage).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
