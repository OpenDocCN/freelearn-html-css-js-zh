- en: Chapter 7. REST and Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. REST和存储
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Architecting the REST API for the backend
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为后端设计REST API
- en: Prototyping a RESTful backend with MongoLab
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoLab原型化RESTful后端
- en: Synchronizing models and collections with a RESTful service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与RESTful服务同步模型和集合
- en: Building a RESTful frontend with Backbone
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Backbone构建RESTful前端
- en: Using the polling technique to fetch data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用轮询技术获取数据
- en: Working with local storage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与本地存储一起工作
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter focuses on the way Backbone.js synchronizes models and collections
    with a RESTful backend, or stores them in the HTML5 local storage.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍Backbone.js如何与RESTful后端同步模型和集合，或者将它们存储在HTML5本地存储中。
- en: We will learn how to design the REST API for our backend, which can be implemented
    with almost any programming framework, such as Symphony, Ruby on Rails, Django,
    or Node.js.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何设计后端的REST API，这可以用几乎任何编程框架实现，例如Symphony、Ruby on Rails、Django或Node.js。
- en: Throughout the chapter, we will use MongoLab ([http://mongolab.com](http://mongolab.com)),
    which is the cloud version of MongoDB, with a RESTful interface. We will also
    learn what tools to use to debug the RESTful service when the frontend app has
    not been built yet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用MongoLab ([http://mongolab.com](http://mongolab.com))，它是MongoDB的云版本，具有RESTful接口。我们还将学习在前端应用程序尚未构建之前，如何使用工具调试RESTful服务。
- en: Finally we will make the Backbone application communicate with the RESTful service,
    performing full set of CRUD operations supported by the REST server. We will also
    learn how to use the polling technique to update data in a collection in the application
    dynamically.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使Backbone应用程序与RESTful服务通信，执行REST服务器支持的完整CRUD操作集。我们还将学习如何使用轮询技术动态更新应用程序中的集合数据。
- en: We will also discuss about an extension that allows us to keep data in HTML5's
    local storage instead of keeping them in the remote server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论一个扩展，允许我们将数据保存在HTML5的本地存储中，而不是保存在远程服务器上。
- en: Architecting the REST API for the backend
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为后端设计REST API
- en: '**Representational State Transfer** (**REST**) is an architectural style for
    designing network applications that communicate amongst each other. Unlike COBRA
    or SOAP, REST can be easily implemented on top of pure HTTP.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）是设计网络应用程序的架构风格，这些应用程序相互通信。与COBRA或SOAP不同，REST可以轻松地建立在纯HTTP之上。'
- en: REST-style architectures consist of clients and servers. The client calls the
    HTTP request method (`POST`, `GET`, `PUT`, or `DELETE`) to perform CRUD (created,
    read, update, and delete) operation over a resource that can be either a collection
    or a single element.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: REST风格的架构由客户端和服务器组成。客户端调用HTTP请求方法（`POST`、`GET`、`PUT`或`DELETE`）来在资源上执行CRUD（创建、读取、更新和删除）操作，资源可以是集合或单个元素。
- en: In this recipe, we are going to architect an API of the REST server for the
    Billing application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将设计用于计费应用程序的REST服务器API。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to architect an API of a RESTful service:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设计RESTful服务的API：
- en: Define the base REST URI used by the client to access resources stored on the
    server; for example, it can look like `http://example.com/resources`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义客户端用于访问服务器上存储资源的基REST URI；例如，它可以看起来像`http://example.com/resources`。
- en: 'Define URIs to access your app-specific resources. These URIs should be relative
    to the base REST URI:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义URI以访问您的应用程序特定资源。这些URI应相对于基本REST URI：
- en: '**Invoice collection**: `<rest-uri>/invoices`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发票集合**: `<rest-uri>/invoices`'
- en: '**Invoice**: `<rest-uri>/invoices/<invoice-id>`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发票**: `<rest-uri>/invoices/<invoice-id>`'
- en: '**Buyer collection**: `<rest-uri>/buyers`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**买家集合**: `<rest-uri>/buyers`'
- en: '**Buyer**: `<rest-uri>/buyers/<buyer-id>`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**买家**: `<rest-uri>/buyers/<buyer-id>`'
- en: '**Seller**: `<rest-uri>/seller`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卖家**: `<rest-uri>/seller`'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The URI to access the resource can look like `http://example.com/resources/items
    and data`, which are transferred through REST, and are typically in the JSON format,
    XML, or any other valid Internet media types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 访问资源的URI可以看起来像`http://example.com/resources/items and data`，这些数据通过REST传输，通常是JSON格式、XML或任何其他有效的Internet媒体类型。
- en: 'The following table describes what happens when the REST operation is performed
    on a specific resource type:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了在特定资源类型上执行REST操作时发生的情况：
- en: '| Resource URI | Collection:`http://example.com/resources/items` | Element:`http://example.com/resources/items/1`
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 资源URI | 集合:`http://example.com/resources/items` | 元素:`http://example.com/resources/items/1`
    |'
- en: '| `POST` | This request creates a new item in the collection and returns a
    newly created item or its URI. | It''s not typically used. If used, it does the
    same job as a POST query for a collection''s resource. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 此请求在集合中创建一个新项目并返回新创建的项目或其URI。| 通常不使用。如果使用，它执行与集合资源POST查询相同的任务。|'
- en: '| `GET` | This request lists collection items or theirs URIs. | This request
    retrieves collection items by their URIs. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 此请求列出集合项目或它们的URI。| 此请求通过它们的URI检索集合项目。|'
- en: '| `PUT` | This request replaces the entire collection with another collection.
    | This request replaces collection items or creates one if it does not exist.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 此请求用另一个集合替换整个集合。| 此请求替换集合项目或如果不存在则创建一个。|'
- en: '| `DELETE` | This request deletes the entire collection. | This request deletes
    items from the collection. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 此请求删除整个集合。| 此请求从集合中删除项目。|'
- en: Refer to the Roy Fieldings' PhD thesis, which is the first and most complete
    work about REST, to learn more about REST at [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 参考Roy Fieldings的博士论文，这是关于REST的第一份也是最为完整的工作，以了解更多关于REST的信息，请访问 [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)。
- en: Prototyping a RESTful backend with MongoLab
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoLab 构建RESTful后端
- en: Let's say we want to create a Backbone application that will communicate with
    a RESTful service. Should we start with creating a backend or a frontend? This
    question sounds like a dilemma, but the answer is very simple.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个将与RESTful服务通信的Backbone应用程序。我们应该从创建后端还是前端开始？这个问题听起来像是一个困境，但答案非常简单。
- en: The easiest way is to create a prototype using a simple database with a REST-style
    interface, so we can quickly replace it with our own backend in the future.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用具有REST风格界面的简单数据库创建原型，这样我们就可以在将来快速将其替换为我们自己的后端。
- en: There is a good tool for that named MongoLab ([http://mongolab.com](http://mongolab.com)),
    which is the cloud version of MongoDB with a REST-style interface. MongoDB is
    a NoSQL document-oriented database that works with JSON-like data. MongoLab will
    not require us to write even a single line of code on the backend, so it is perfect
    for us as a prototyping tool.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 MongoLab 的好工具（[http://mongolab.com](http://mongolab.com)），它是具有REST风格界面的MongoDB的云版本。MongoDB是一个与类似JSON的数据一起工作的NoSQL文档型数据库。MongoLab将不需要我们在后端编写任何一行代码，因此它非常适合我们作为原型工具。
- en: To test and debug the MongoLab backend, we will use the Advanced REST client,
    which is an extension to the Chrome browser. It allows performing HTTP queries
    on a RESTful service and visualizes JSON data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试MongoLab后端，我们将使用高级REST客户端，这是一个Chrome浏览器的扩展。它允许对RESTful服务执行HTTP查询并可视化JSON数据。
- en: Getting ready...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: 'Follow these steps to be prepared for this recipe:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤为这个食谱做好准备：
- en: Create an account on the MongoLab website ([https://mongolab.com](https://mongolab.com)),
    or log in if you have an existing one.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MongoLab网站上创建账户 ([https://mongolab.com](https://mongolab.com))，或者如果您已有账户则登录。
- en: Install the Advanced REST client on your browser using the URL [https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo).
    If you're using Firefox or Safari, you can easily find a similar extension for
    this purpose.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用URL [https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo](https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo)
    在您的浏览器上安装高级REST客户端。如果您使用Firefox或Safari，您可以轻松找到用于此目的的类似扩展。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a MongoLab database and fill it with data:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤创建MongoLab数据库并填充数据：
- en: Go to [https://mongolab.com/newdb](https://mongolab.com/newdb) and create a
    new database named `billing-app` within your MongoLab account.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://mongolab.com/newdb](https://mongolab.com/newdb) 并在您的MongoLab账户中创建一个名为
    `billing-app` 的新数据库。
- en: Go to `https://mongolab.com/user?username=<username>` and get an API key that
    you can use for authentication.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `https://mongolab.com/user?username=<username>` 并获取一个API密钥，您可以使用它进行身份验证。
- en: To check databases in your account, perform a `GET` request on a URI, say `https://api.mongolab.com/api/1/databases?apiKey=<your-api-key>`,
    using the Advanced REST client.![How to do it...](img/2728_07_01.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查您账户中的数据库，使用高级REST客户端在URI上执行一个`GET`请求，例如 `https://api.mongolab.com/api/1/databases?apiKey=<your-api-key>`。![如何做...](img/2728_07_01.jpg)
- en: 'The result will look like the following screenshot:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果将类似于以下截图：
- en: '![How to do it...](img/2728_07_02.jpg)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/2728_07_02.jpg)'
- en: To get a list of collections in the database, perform a `GET` request on the
    URI `https://api.mongolab.com/api/1/databases/billing-app/collections?apiKey=<your-api-key>`.
    The result will look like the following screenshot:![How to do it...](img/2728_07_03.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取数据库中集合的列表，请在 URI `https://api.mongolab.com/api/1/databases/billing-app/collections?apiKey=<your-api-key>`
    上执行 `GET` 请求。结果将类似于以下截图：![如何操作...](img/2728_07_03.jpg)
- en: 'To create a new collection, let''s send the collection items defined in the
    JSON format using a `POST` query on this URI: `https://api.mongolab.com/api/1/databases/billing-app/collections/invoices?apiKey=<your-api-key>`.
    Make sure that the **application/json Content-Type** header is set.![How to do
    it...](img/2728_07_04.jpg)'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的集合，请使用此 URI 上的 `POST` 查询发送定义在 JSON 格式的集合项：`https://api.mongolab.com/api/1/databases/billing-app/collections/invoices?apiKey=<your-api-key>`。请确保设置了
    **application/json Content-Type** 标头。![如何操作...](img/2728_07_04.jpg)
- en: 'The result of such an operation will look like the following screenshot:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此操作的输出结果将类似于以下截图：
- en: '![How to do it...](img/2728_07_05.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/2728_07_05.jpg)'
- en: By performing a `GET` request on the same resource again, we will be returned
    inserted items with their IDs in the JSON format.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过再次对同一资源执行 `GET` 请求，我们将以 JSON 格式返回插入的项目及其 ID。
- en: '![How to do it...](img/2728_07_06.jpg)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/2728_07_06.jpg)'
- en: To update an existing item in the collection, we need to perform a `PUT` request
    on the collection item resource, specified by its ID, in the URI `https://api.mongolab.com/api/1/databases/billing-app/collections/invoices/<invoice-id>?apiKey=<your-api-key>`.
    In the `PUT` request, we should pass an updated model in the JSON format. The
    result is also returned in JSON, as shown in the following screenshot:![How to
    do it...](img/2728_07_07.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新集合中现有的项目，我们需要在 URI `https://api.mongolab.com/api/1/databases/billing-app/collections/invoices/<invoice-id>?apiKey=<your-api-key>`
    上对指定 ID 的集合项目资源执行 `PUT` 请求。在 `PUT` 请求中，我们应该以 JSON 格式传递更新的模型。结果也以 JSON 格式返回，如下所示截图：![如何操作...](img/2728_07_07.jpg)
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: MogoLab translates HTTP requests into MongoDB queries, which are executed, and
    the results are returned in the MongoDB Extended JSON format.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MogoLab 将 HTTP 请求转换为 MongoDB 查询，执行查询并返回 MongoDB 扩展 JSON 格式的结果。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the MongoLab's REST API to learn more about performing queries at [https://support.mongolab.com/entries/20433053-REST-API-for-MongoDB](https://support.mongolab.com/entries/20433053-REST-API-for-MongoDB).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考MongoLab的REST API了解如何在[https://support.mongolab.com/entries/20433053-REST-API-for-MongoDB](https://support.mongolab.com/entries/20433053-REST-API-for-MongoDB)执行查询。
- en: You can also visit the following URL in order to meet specifications of the
    MongoDB Extended JSON format at [http://docs.mongodb.org/manual/reference/mongodb-extended-json/](http://%20http://docs.mongodb.org/manual/reference/mongodb-extended-json/)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以访问以下 URL 以了解 MongoDB 扩展 JSON 格式的规范：[http://docs.mongodb.org/manual/reference/mongodb-extended-json/](http://docs.mongodb.org/manual/reference/mongodb-extended-json/)
- en: Synchronizing models and collections with a RESTful service
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型和集合与 RESTful 服务同步
- en: In this recipe, we are going to learn how to synchronize models and collections
    with a RESTful service. Just as we did in all other recipes, we will use MongoLab
    for a RESTful service.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何将模型和集合与 RESTful 服务同步。就像我们在所有其他食谱中所做的那样，我们将使用 MongoLab 作为 RESTful
    服务。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to get familiar with REST in Backbone.js:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤熟悉 Backbone.js 中的 REST：
- en: Create a configuration object that stores a server URL and an authentication
    key for MongoLab.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个配置对象，该对象存储服务器 URL 和 MongoLab 的身份验证密钥。
- en: '[PRE0]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Define a `url()` method that returns a resource URL to perform a REST request.
    Such URLs should contain a model ID, if a model is already synchronized with a
    RESTful service. Also, such URLs should contain a MongoLab's authentication key.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `url()` 方法，该方法返回用于执行 REST 请求的资源 URL。如果模型已经与 RESTful 服务同步，则此类 URL 应包含模型
    ID。此外，此类 URL 应包含 MongoLab 的身份验证密钥。
- en: '[PRE1]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another way to do this is to define the `urlRoot` property, though it does not
    allow adding parameters to the URL.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种方法是定义 `urlRoot` 属性，尽管它不允许向 URL 添加参数。
- en: '[PRE2]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Define a new collection and a `url` property or `url()` method that should return
    the URL to a collection resource.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的集合和一个 `url` 属性或 `url()` 方法，该方法应返回集合资源的 URL。
- en: '[PRE3]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To load data from a server into a collection, use the `fetch()` method. You
    can pass `success` and `error` callbacks as a parameter. Either of them will be
    called asynchronously if a synchronization succeeds or fails.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从服务器加载数据到集合中，请使用`fetch()`方法。您可以传递`success`和`error`回调作为参数。如果同步成功或失败，任一回调都将异步调用。
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the `fetch()` method is run, the read event is triggered. Also, on success,
    the sync event is triggered.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`fetch()`方法运行时，会触发读取事件。成功时，还会触发同步事件。
- en: To load a specific model that exists on a server, you can also use the `fetch()`
    method, which works in a similar way as it worked for collection.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以使用`fetch()`方法加载服务器上存在的特定模型，它与集合的工作方式类似。
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To sync a model with a RESTful service, use the `save()` method.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要与RESTful服务同步模型，请使用`save()`方法。
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To perform an update for a specific attribute, pass hash of changed attributes
    in the first parameter and `{patch: true}` in the second parameter.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '要更新特定属性，请在第一个参数中传递更改的属性哈希，在第二个参数中传递`{patch: true}`。'
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By default, the `save()` method works asynchronously, so you need to handle
    results in the `success` or `error` callbacks. However, if you need to run the
    `save()` method synchronously, pass `null` in the first parameter and `{wait:
    true}` in the second parameter.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '默认情况下，`save()`方法以异步方式工作，因此您需要在`success`或`error`回调中处理结果。但是，如果您需要以同步方式运行`save()`方法，请在第一个参数中传递`null`，在第二个参数中传递`{wait:
    true}`。'
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can create a new model within a collection using the `create()` method.
    In this case, Backbone.js automatically calls the `save()` method and a new module
    is pushed to the server.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`create()`方法在集合内创建一个新的模型。在这种情况下，Backbone.js会自动调用`save()`方法，并将新的模块推送到服务器。
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can destroy a model using the `destroy()` method, which removes a model
    both from a collection and a server.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`destroy()`方法销毁一个模型，这将从集合和服务器中删除模型。
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `fetch()`, `save()`, or `destroy()` methods call the `sync()` method to
    perform HTTP queries to synchronize models and collections with a RESTful service.
    The `sync()` method accepts the following parameters:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()`、`save()`或`destroy()`方法调用`sync()`方法以执行HTTP查询，同步模型和集合与RESTful服务。`sync()`方法接受以下参数：'
- en: '`method`: It can be either create, update, patch, delete, or read.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：它可以是create、update、patch、delete或read。'
- en: '`model`: It''s either a model or a collection used to sync.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`：它是一个用于同步的模型或集合。'
- en: '`options`: These are the options accepted by the `$.ajax` variable.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这是`$.ajax`变量接受的选项。'
- en: You can override the `sync()` method if you need to override synchronization,
    or to use storage without a REST support.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要覆盖同步或在没有REST支持的情况下使用存储，您可以覆盖`sync()`方法。
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: MongoLab returns data in the MongoDB Extended JSON format, which is not supported
    by Backbone.js by default. In this recipe, we are going to fix this and find a
    good solution to process MongoDB Extended JSON directly in a Backbone application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab以MongoDB扩展JSON格式返回数据，而Backbone.js默认不支持这种格式。在本教程中，我们将解决这个问题，并找到在Backbone应用程序中直接处理MongoDB扩展JSON的好方法。
- en: Handling MongoDB Extended JSON
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理MongoDB扩展JSON
- en: 'MongoLab ([http://mongolab.com](http://mongolab.com)) is a RESTful service
    that transforms HTTP requests into MongoDB queries and returns the results in
    the MongoDB Extended JSON, which will look like the following code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab ([http://mongolab.com](http://mongolab.com)) 是一个RESTful服务，它将HTTP请求转换为MongoDB查询，并以MongoDB扩展JSON格式返回结果，如下代码片段所示：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For appropriate results, we need to handle such IDs. The idea behind this is
    to override the `parse()` method, which processes JSON and initializes the model
    properties out of it. We are going to replace the format of an ID here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到适当的结果，我们需要处理这样的ID。背后的想法是覆盖`parse()`方法，该方法处理JSON并从中初始化模型属性。我们将在这里替换ID的格式：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, when the `sync()` method is run, we need to make sure that data is exported
    in the MongoDB Extended JSON format. In all the other cases, it should be exported
    in a regular JSON format. Data export is performed only in the `toJSON()` method,
    so we can do this by replacing the `toJSON()` method during the `sync()` method
    execution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当`sync()`方法运行时，我们需要确保数据以MongoDB扩展JSON格式导出。在其他所有情况下，应导出为常规JSON格式。数据导出仅在`toJSON()`方法中执行，因此我们可以在`sync()`方法执行期间替换`toJSON()`方法。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a Backbone.js extension with Grunt* recipe in [Chapter 8](ch08.html
    "Chapter 8. Special Techniques"), *Special Techniques*
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章。特殊技术")的*使用Grunt创建Backbone.js扩展*配方，*特殊技术*'
- en: You may also be interested in checking the source code of `Backbone.sync` at
    [http://backbonejs.org/docs/backbone.html#section-134](http://backbonejs.org/docs/backbone.html#section-134).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能还感兴趣检查`Backbone.sync`的源代码，请参阅[http://backbonejs.org/docs/backbone.html#section-134](http://backbonejs.org/docs/backbone.html#section-134)。
- en: Visit the following URL in order to meet specifications of MongoDB Extended
    JSON at [http://docs.mongodb.org/manual/reference/mongodb-extended-json/](http://docs.mongodb.org/manual/reference/mongodb-extended-json/)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问以下URL以满足MongoDB扩展JSON的规范[http://docs.mongodb.org/manual/reference/mongodb-extended-json/](http://docs.mongodb.org/manual/reference/mongodb-extended-json/)
- en: Building a RESTful frontend with Backbone
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Backbone构建RESTful前端
- en: In this recipe, we are going to write a frontend application that will act as
    a client for a RESTful service. For the backend, we will use the MongoLab service,
    which is a cloud version of MongoDB with a REST interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将编写一个前端应用程序，它将作为RESTful服务的客户端。对于后端，我们将使用MongoLab服务，这是一个具有REST接口的MongoDB云版本。
- en: 'We will use the LayoutManager extension to output our views in a neat format.
    To build our application, we will take an example app from [Chapter 6](ch06.html
    "Chapter 6. Templates and UX sugar"), *Templates and UX sugar*, and will modify
    it, so it will support data sync via REST and will look like the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用布局管理器扩展来以整洁的格式输出我们的视图。为了构建我们的应用程序，我们将从[第6章](ch06.html "第6章。模板和UX糖")的示例应用程序中获取，*模板和UX糖*，并进行修改，使其支持通过REST进行数据同步，并看起来如下截图所示：
- en: '![Building a RESTful frontend with Backbone](img/2728_07_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用Backbone构建RESTful前端](img/2728_07_08.jpg)'
- en: In the left-hand side pane, we can see a list of invoice titles, and in the
    right-hand side pane, we can see the invoice details. By default, these details
    are shown for the first invoice until the user clicks on a link in the left-hand
    side pane.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧窗格中，我们可以看到一系列发票标题，在右侧窗格中，我们可以看到发票详情。默认情况下，这些详情为第一个发票显示，直到用户点击左侧窗格中的链接。
- en: 'If the user clicks on the **Edit** button, the following form is shown:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击**编辑**按钮，将显示以下表单：
- en: '![Building a RESTful frontend with Backbone](img/2728_07_09.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用Backbone构建RESTful前端](img/2728_07_09.jpg)'
- en: When the user clicks on the **Save** button, the model is updated, and it's
    JSON is sent to the server via REST, and the list in the left pane is also updated.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**保存**按钮时，模型被更新，并且它的JSON通过REST发送到服务器，并且左侧窗格中的列表也被更新。
- en: 'If the user clicks on the **Delete** button, a delete confirmation form appears,
    as shown in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击**删除**按钮，将出现一个删除确认表单，如下截图所示：
- en: '![Building a RESTful frontend with Backbone](img/2728_07_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![使用Backbone构建RESTful前端](img/2728_07_10.jpg)'
- en: If the user confirms the deletion, the model is destroyed and removed from the
    server via REST.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户确认删除，模型将被销毁并通过REST从服务器中移除。
- en: Users can also create a new invoice by clicking on the **Add an invoice** link
    at the top of the page. Then, an Add Invoice form is shown, which is identical
    to the Edit form, with no data shown.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以通过点击页面顶部的**添加发票**链接来创建一个新的发票。然后，会显示一个添加发票表单，它与编辑表单相同，但没有显示任何数据。
- en: '![Building a RESTful frontend with Backbone](img/2728_07_11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用Backbone构建RESTful前端](img/2728_07_11.jpg)'
- en: Getting ready...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中...
- en: 'Follow these steps to be prepared for this recipe:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为此配方做好准备：
- en: Make sure the LayoutManager extension is installed. The usage and installation
    of this extension is described in the *Assembling layouts with LayoutManager*
    recipe in [Chapter 6](ch06.html "Chapter 6. Templates and UX sugar"), *Templates
    and UX Sugar*.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已安装布局管理器扩展。该扩展的用法和安装描述在[第6章](ch06.html "第6章。模板和UX糖")的*使用LayoutManager组装布局*配方中，*模板和UX糖*。
- en: Override `Backbone.Model` to support the MongoDB Extended JSON format, which
    is used in MongoLab.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`Backbone.Model`以支持MongoLab中使用的MongoDB扩展JSON格式。
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This allows Backbone to work correctly with data IDs in a format like this:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许Backbone正确地与如下格式的数据ID一起工作：
- en: '[PRE15]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create a RESTful application with Backbone:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个使用Backbone的RESTful应用程序：
- en: Create a configuration object that we will store the server URL and authentication
    key.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个配置对象，我们将存储服务器URL和认证密钥。
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Define `InvoiceModel` and set the `url()` method, which will return the model's
    resource URL to perform REST requests.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `InvoiceModel` 并设置 `url()` 方法，该方法将返回执行 REST 请求的模型资源 URL。
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Define `InvoiceCollection` and the `url()` method for the model.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `InvoiceCollection` 和模型的 `url()` 方法。
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Define a router and add the `initialize()` method, which creates an empty collection
    and layout objects and renders a layout.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个路由并添加 `initialize()` 方法，该方法创建一个空集合和布局对象并渲染布局。
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Add a layout template into `index.html`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布局模板添加到 `index.html` 中。
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add `routes` and callbacks to the router object. Each callback calls the `switchPane()`
    method, which switches the right-hand side pane of the layout.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `routes` 和回调添加到路由对象中。每个回调都调用 `switchPane()` 方法，该方法切换布局的右侧面板。
- en: '[PRE21]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add the `switchPane()` method to the router, which fetches collection from the
    RESTful service and switches the right-hand side pane.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `switchPane()` 方法添加到路由中，该方法从 RESTful 服务获取集合并切换右侧面板。
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Define the invoice list pane.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义发票列表面板。
- en: '[PRE23]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add a template for it in `index.html`.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `index.html` 中为它添加一个模板。
- en: '[PRE24]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Define a view invoice pane.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义查看发票面板。
- en: '[PRE25]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Add a template for it in `index.html`.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `index.html` 中为它添加一个模板。
- en: '[PRE26]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Define an edit invoice pane.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义编辑发票面板。
- en: '[PRE27]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Add a template for it in `index.html`.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `index.html` 中为它添加一个模板。
- en: '[PRE28]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Define a delete invoice pane.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义删除发票面板。
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Add a template for it in `index.html`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `index.html` 中为它添加一个模板。
- en: '[PRE30]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a router instance and start the application.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个路由实例并启动应用程序。
- en: '[PRE31]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To load the collection from a RESTful service, we need to call the `fetch()`
    method, which runs asynchronously as a regular AJAX call does. If we need to run
    any code after the data is fetched successfully, we need to pass the callback
    function in a second parameter keyed by the `success` key. If we need to perform
    a fallback behavior in case of an error, we should pass the callback function
    keyed by the `error` key in the function parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 RESTful 服务加载集合，我们需要调用 `fetch()` 方法，它以异步方式运行，就像常规 AJAX 调用一样。如果我们需要在数据成功获取后运行任何代码，我们需要在第二个参数中传递一个以
    `success` 为键的回调函数。如果我们需要在出错时执行回退行为，我们应该在函数参数中以 `error` 为键传递回调函数。
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To sync model with a remote server via REST, we use the `save()` method. To
    remove the model entirely from a remote server, we use the `destroy()` method.
    Both the methods accept the `success` and `error` callbacks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 REST 与远程服务器同步模型，我们使用 `save()` 方法。要从远程服务器完全删除模型，我们使用 `destroy()` 方法。这两个方法都接受
    `success` 和 `error` 回调函数。
- en: See also
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Assembling layouts with LayoutManager* recipe in [Chapter 6](ch06.html
    "Chapter 6. Templates and UX sugar"), *Templates and UX sugar*
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 6 章 *使用 LayoutManager 组装布局* 的菜谱中，*模板和 UX 糖分*，请参阅 [Chapter 6](ch06.html "Chapter 6. Templates
    and UX sugar")。
- en: Refer to the official docs to get more information about Backbone methods we
    used in this recipe at [http://backbonejs.org/](http://backbonejs.org/).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考官方文档以获取有关我们在本菜谱中使用的 Backbone 方法的更多信息，请参阅 [http://backbonejs.org/](http://backbonejs.org/)。
- en: Using the polling technique to fetch data
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用轮询技术获取数据
- en: In the previous recipes, we were fetching data into a collection each time the
    router processed a URL change. We may wonder what happens if someone else updates
    data in the same storage? Can we see the updates immediately?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们每次路由处理 URL 变化时都会将数据获取到一个集合中。我们可能会想知道如果其他人更新了相同存储中的数据会发生什么？我们能否立即看到更新？
- en: You might have seen how Facebook or Twitter updates a news feed in real time,
    and you may want to implement a similar behavior in your application. Typically,
    it can be done using the polling technique, which we are going to learn in this
    recipe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到 Facebook 或 Twitter 如何实时更新新闻源，你可能想在应用程序中实现类似的行为。通常，这可以通过轮询技术完成，我们将在本菜谱中学习这项技术。
- en: We are going to create a web application that will update the collection view
    dynamically with the help of a polling technique.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个网络应用程序，它将使用轮询技术动态更新集合视图。
- en: Getting ready...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: Override `Backbone.Model` and `Backbone.Collection` to support the MongoDB Extended
    JSON format, which is used in MongoLab.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖 `Backbone.Model` 和 `Backbone.Collection` 以支持 MongoDB 扩展 JSON 格式，该格式用于 MongoLab。
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the polling technique:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现轮询技术：
- en: Create a new polling collection that fetches data recursively and provides methods
    to start or stop polling.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的轮询集合，它递归地获取数据并提供启动或停止轮询的方法。
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Define a configuration object.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义配置对象。
- en: '[PRE35]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Define an invoice view and bind callbacks to model events.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义发票视图并将回调绑定到模型事件。
- en: '[PRE36]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Define an invoice list view and bind callbacks to collection events.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个发票列表视图并将回调绑定到集合事件。
- en: '[PRE37]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create a collection and render the corresponding view.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个集合并渲染相应的视图。
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Start polling.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始轮询。
- en: '[PRE39]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The idea behind polling is to fetch the server regularly. However, we can't
    do this in a simple loop, because fetching works asynchronously, and we need to
    make sure AJAX requests do not overlap with each other. Thus, we need to make
    sure previous fetching is completed successfully before performing the next one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询背后的想法是定期从服务器获取数据。然而，我们无法在简单的循环中这样做，因为获取操作是异步的，我们需要确保 AJAX 请求不会相互重叠。因此，我们需要确保之前的获取操作成功完成后再执行下一个。
- en: In this recipe, we inherited a collection from `Backbone.Collection` and added
    new methods and properties that we needed to implement polling. In the `executePolling()`
    method, we are performing the `fetch()` method and passing the `onFetch()` method
    as a success callback. In the `onFetch() method`, we call the `executePolling()`
    method with a timeout.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们从 `Backbone.Collection` 继承了一个集合，并添加了我们需要实现轮询的新方法和属性。在 `executePolling()`
    方法中，我们执行 `fetch()` 方法，并将 `onFetch()` 方法作为成功回调传递。在 `onFetch()` 方法中，我们使用超时调用 `executePolling()`
    方法。
- en: Working with local storage
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与本地存储一起工作
- en: Sometimes, we need to store data on a browser storage rather than on a remote
    server. This is quite easy to do with the help of the Backbone extension known
    as localStorage Adapter, which overrides the behavior of the `Backbone.sync()`
    method to sync data with HTML5 local storage. In this recipe, we are going to
    learn how to use this extension.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要在浏览器存储上而不是在远程服务器上存储数据。借助名为 localStorage Adapter 的 Backbone 扩展，这相当容易做到，该扩展覆盖了
    `Backbone.sync()` 方法的行为以同步数据到 HTML5 local storage。在这个配方中，我们将学习如何使用这个扩展。
- en: Getting ready...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: You can download the Backbone localStorage adapter from its GitHub page at [https://github.com/jeromegn/Backbone.localStorage](https://github.com/jeromegn/Backbone.localStorage).
    To include this extension into your project, save the `backbone.localStorage.js`
    file into the `lib` folder and include a reference to it in `index.html`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从其 GitHub 页面 [https://github.com/jeromegn/Backbone.localStorage](https://github.com/jeromegn/Backbone.localStorage)
    下载 Backbone localStorage 适配器。要将此扩展包含到您的项目中，将 `backbone.localStorage.js` 文件保存到
    `lib` 文件夹，并在 `index.html` 中包含对其的引用。
- en: Including Backbone extension into your project is described in detail in the
    *Extending an application with plugins* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Backbone"), *Understanding Backbone*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。理解 Backbone") 的 *使用插件扩展应用程序* 配方中详细描述了将 Backbone 扩展包含到你的项目中，*理解
    Backbone*。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Extend the collection and set the `localStorage` key as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展集合并设置 `localStorage` 键如下：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we create an instance of `Backbone.LocalStorage` and pass the storage
    name as a constructor parameter. The storage name should be unique within your
    application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `Backbone.LocalStorage` 的实例，并将存储名称作为构造函数参数传递。存储名称应该在您的应用程序中是唯一的。
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Backbone's localStorage adapter overrides the `Backbone.sync()` method, which
    executes a code to synchronize data with the HTML5 localStorage, if it is enabled
    for a collection.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 的 localStorage 适配器覆盖了 `Backbone.sync()` 方法，当集合启用时，它会执行代码以同步数据到 HTML5
    localStorage。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Be aware when creating new models**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建新模型时请注意**'
- en: The only thing you should avoid when using the localStorage adapter is creating
    new models and saving them by calling the `save()` method of the model. Instead,
    you should call the `create()` method of the collection object, because otherwise
    the model is not associated to a collection yet, and the localStorage adapter
    has no idea which local storage to use.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 localStorage 适配器时，你应该避免的唯一事情是创建新模型并通过调用模型的 `save()` 方法来保存它们。相反，你应该调用集合对象的
    `create()` 方法，因为否则模型尚未与集合关联，localStorage 适配器不知道应该使用哪个本地存储。
- en: After the model is associated with a collection, the `save()` method works pretty
    well.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型与集合关联之后，`save()` 方法工作得相当好。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There is also a Backbone extension that allows storing data in the WebSQL storage
    at [https://github.com/MarrLiss/backbone-websql](https://github.com/MarrLiss/backbone-websql).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个 Backbone 扩展，允许在 [https://github.com/MarrLiss/backbone-websql](https://github.com/MarrLiss/backbone-websql)
    的 WebSQL 存储中存储数据。
- en: There are plenty of extensions that allow using different storage engines at
    [https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources#storage](https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources#storage).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多扩展允许使用不同的存储引擎，请参阅[https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources#storage](https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources#storage)。
