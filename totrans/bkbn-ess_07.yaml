- en: Chapter 7. Fitting Square Pegs in Round Holes – Advanced Backbone Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at various advanced uses of Backbone, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using methods in place of properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding a class's constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixins to share logic between classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the publish/subscribe pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping widgets from other libraries in Backbone `Views`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking it up a notch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we've discussed the basics of using Backbone's four
    classes, and while these basics are more than enough to make you productive with
    Backbone, we've deliberately left out a few of the more complicated details. In
    this chapter, we'll explore those left-out details and how they relate to certain
    advanced Backbone techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, however, it is important to note that all of the techniques
    discussed in this chapter are intended to be used to solve specific problems,
    and not as general-purpose patterns. While there is certainly nothing "wrong"
    with using any of these techniques, they will make your code more complex and
    thus, less intuitive and harder to maintain. Thus, it is recommended that you
    avoid using any of the techniques discussed in this chapter unless you specifically
    need to do so to solve a particular problem.
  prefs: []
  type: TYPE_NORMAL
- en: Methods in place of properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the properties of Backbone classes have the option of being defined
    as functions instead of as primitives. In fact, we've already seen one instance
    of this behavior in the `url` property of `Models` and `Collections`. As we learned
    in [Chapter 3](part0029.xhtml#aid-RL0A1 "Chapter 3. Accessing Server Data with
    Models"), *Accessing Server Data with Models*, this property can be a simple string,
    but if you have a more complex URL that requires logic to generate, you can instead
    use a function that returns a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'This same approach can be used with a number of Backbone properties, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Models:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaults`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urlRoot`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Views:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributes`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`className`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tagName`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Routers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`routes`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, let''s say you wanted to have `View` that can generate either
    `<input>` or `<select>` based on whether or not it has `Collection`. By using
    a function in place of a string for our `Views` `tagName` property of the `Views`,
    we can do exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Collection.model as a factory method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Collection` class also has a property that can be replaced with a function,
    but unlike the other properties, this one isn't normally a primitive… it's a Backbone
    `Model` subclass. As discussed in [Chapter 4](part0037.xhtml#aid-1394Q1 "Chapter 4. Organizing
    Models with Collections"), *Organizing Models with Collections*, the *model* property
    of a `Collection` class determines what type of `Model` will be created by that
    `Collection`. Normally, each `Collection` class can have only a single *model*
    property and thus, can only create a single type of `Model`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a way around this limitation: If we replace the *model* property
    of our `Collection` with a function that returns new `Models`, Backbone will cheerfully
    overlook the fact that the `model` property isn''t actually a `Model` subclass
    at all. For example, let''s say our server has a "/book" API endpoint that returns
    JSON for two types of books: fiction and nonfiction. Let''s also say that we have
    two different `Model` classes, one for each type of book. If we wanted to be able
    to have a `Collection` class that fetches the JSON for both types of books from
    a single end point but uses the appropriate `model` function to instantiate each
    type of book, we could use a factory "model" function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Overriding a class constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a Backbone class is instantiated, it runs the code defined in its `initialize`
    method. However, this code isn't run until after the new object has been instantiated.
    This means that even if you define an `initialize` method for a `Model` class,
    the attributes of that `Model` class will already have been set before your `initialize`
    code is even called.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, this is a good thing, as it is convenient to have things like the
    attributes of the `Model` class already set, but sometimes, we want to take control
    before this happens. For example, let's reimagine our previous scenario of fiction
    and nonfiction books, only this time instead of having a single `Collection` class
    that can create both types of books, we want a `Collection` that only creates
    one type and we want this type decided by the first book that we give the `Collection`
    class when its instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, if the first book given to our `Collection` class has the `isFiction`
    property, we want our `Collection` class to have the `Models` property of `FictionBook`;
    otherwise, we want it to have the `Models` property of `NonFictionBook`. If we
    do this inside an `initialize` method, the "model" option will already have been
    set on the `Collection` class before the `initialize` method is run, and any `Model`
    attributes that we pass in it will already have been converted into `Models`.
    Therefore, we need to add logic that runs before `initialize`. We can do this
    by overriding the constructor of the `Collection Constructor` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we still called the original `Collection` `Constructor` method from
    within our overridden version; if we hadn't done so, none of Backbone's normal
    logic would run and we wouldn't even have a proper `Collection` class when we're
    done.
  prefs: []
  type: TYPE_NORMAL
- en: As with the other techniques discussed in this chapter, it is not recommended
    that you override constructors very often. If at all possible you should override
    the `initialize` method instead. Constructor overriding should mainly be left
    to cases where you want to preprocess the arguments that go into a Backbone object
    before that object actually gets created.
  prefs: []
  type: TYPE_NORMAL
- en: Class mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone provides a very powerful class system, but sometimes, even this class
    system isn't enough. For instance, let's say you have several classes that all
    contain several identical methods. The popular **Don't Repeat Yourself** (**DRY)**
    programming principle suggests that you should eliminate the duplicate versions
    of the methods and instead, define them all together in just one place in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you could do so by refactoring these methods into a common parent
    class of these classes. But what if these classes can't share a common parent
    class? For instance, what if one of these classes is a `Model` class and the other
    a `Collection` class?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you need to rely on something called a mixin. A mixin is just
    an object that holds one or more methods (or even primitive properties) that you
    want to share between several classes. For example, if we wanted to share a couple
    of logging-related methods between several classes, we could create a mixin of
    these methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve defined your mixin, the next step is to "mix it in" to the definition
    of your class. This means modifying the `prototype` of the class to include the
    methods from our mixin. For instance, let''s say we have a book `Model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because Backbone''s syntax makes creating our new class so simple, it''s easy
    to miss the fact that we''re actually defining a prototype object here, but if
    we change things just a little, it suddenly becomes more obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve separated the Book prototype, we can augment it with our mixin.
    We could do this manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this won''t work well if we have a lot of methods to mixin, or if
    our mixin later gets new methods added. Instead, we can use Underscore''s `extend`
    function to extend all of the methods in our mixin on to the `Book` prototype
    in a single command: `_.extend(bookPrototype, loggingMixin);`'
  prefs: []
  type: TYPE_NORMAL
- en: With just this one line, we've added a whole set of logging-related methods
    to our `Book` class. Plus, we can now share these methods with any other class,
    again by using only a single line, all without having to change the parent class
    of any of the classes involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, it''s important to note that because we are applying our mixin on
    top of the existing prototype, it will overwrite any properties that it has in
    common with the prototype. In other words, assume that our `Book` class already
    has its own `startLogging` method that prevents logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will erase this method by applying our mixin, giving us logging on our class
    even though we don't want it. Further, even if `Book` doesn't have such a method,
    a future developer might add one and then, be confused when it doesn't work. If
    the future developer doesn't see (or doesn't understand) the mixin line, he might
    spend hours looking through the parent classes of `Book`, trying to figure out
    what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this issue, it is usually better to rely on standard object-oriented
    programming as much as possible when designing your classes, and only use mixins
    when you can't share methods through a normal class hierarchy. In these cases,
    however, mixins can be a powerful tool and serve as yet another example of what
    is possible in JavaScript but not in most other languages (Good luck mixing methods
    into a Java class!).
  prefs: []
  type: TYPE_NORMAL
- en: Publish/subscribe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone classes often wind up being tightly coupled together. For instance,
    a `View` class might listen to a `Model` class for changes in its data, and then,
    when this data changes, it might look at the `attributes` of the `Model` to determine
    what to render. This practice couples the `View` class to the `Model` class, which
    normally is a good thing as it lets you define the exact relationship you need
    between the two classes, while still keeping your code fairly simple and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: When you only have a few `Models` and `Views`, it's easy enough to manage their
    relationships in this way. However, if you are building a particularly complex
    user interface, then this same coupling can instead become a hindrance. Imagine
    having a single page with a large number of `Collections`, `Models`, and `Views`,
    all listening and responding to changes in one another. Whenever a single change
    occurs, it can cause a ripple effect, resulting in further changes, which can
    then result in still further changes, and these changes can … well, you get the
    idea! This can make it nearly impossible to understand what changes are occurring
    and what effect they will have; in the worst case scenario, they can create infinite
    loops or make it difficult to fix bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The solution for a complex system like this is to decouple the various components
    (`Collections`, `Models`, and `Views`) involved with each other by using the Publish/Subscribe
    pattern (or pub/sub for short). In this pattern, all of the components still communicate
    via events, but instead of each `Collection` and `Model` class having its own
    event bus, all of the `Collection` and `Model` classes involved share a single,
    global event bus, eliminating direct connections between them. Whenever one component
    wants to communicate with another, it publishes (triggers) an event that the other
    component has subscribed (listened) to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this pattern in Backbone, we need a global event bus, and it turns
    out that Backbone already includes one for us: the Backbone object itself. Like
    `Models` and `Collections`, the Backbone object has both an "on" (subscription)
    method and a "trigger" (publishing) method. Both these methods work the same way
    as they do on other Backbone objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One type of application that often benefits from the pub/sub pattern is games,
    because they often have many different UI pieces being updated by a variety of
    different data sources. Let''s imagine that we''re building a three-player game
    where each player is represented by a `Model` class. Since we want to keep the
    player `Models` updated with changes from the server, we fetch those `Model` at
    periodic intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s further imagine that we have a scoreboard `View`, which needs to update
    itself in response to changes in the players'' scores. Now, of course, in the
    real world, if we just had a single `View`, we most likely wouldn''t even need
    the pub/sub pattern, but let''s keep this example as simple as possible. To avoid
    coupling our `View` to our player `Models` directly we''ll instead have it listen
    for a `scoreChange` event on the Backbone object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to have these `scoreChange` events occur, we''ll need to make
    our `Player` class trigger them. We''ll also need a way to tell if a score has
    changed, but luckily for us, each of the `Model` classes has a `hasChanged` method,
    which does exactly that. We can use this method, inside an overwritten `fetch`
    method, to trigger our `scoreChange` event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Model` class and the `View` are now completely separate.
    The `Model` class passes any information that the `View` requires through the
    event itself, when it makes the `Backbone.trigger` call; otherwise, all classes
    involved remain oblivious to one another.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as with any of these advanced techniques, there are also disadvantages
    to this approach, primarily the lack of encapsulation. When you have a `View`
    fetch a `Model` class directly, you know exactly what code connects the two, and
    if you want to refactor or otherwise change that code, it's easy to determine
    what will be affected. However, with the pub/sub pattern, it can be much more
    difficult to determine what code will be impacted by a potential change.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many ways, this is very similar to the trade-off between using global variables
    and using local variables: While the former are much more powerful and easy to
    work with, initially, their very lack of limits can make them much harder to work
    with in the long run. Therefore, as much as possible, you should avoid relying
    on the pub/sub pattern and instead, rely on event listeners bound to particular
    Backbone objects. However, when you do have a problem that requires communication
    between many disparate parts of your code, relying on this pattern and listening
    for/triggering events on the Backbone object itself can allow for a much more
    elegant solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping widgets of other libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone is an incredibly powerful framework, but it can't do everything. If
    you want to add a calendar widget, a rich text editor, or a node tree to your
    site, you'll probably want to use another library, which can provide such a component
    for you (for example, jQuery UI, TinyMCE, or jsTree). However, just because you
    want to use a tool other than Backbone, it doesn't mean you have to give up all
    of the convenience and power of Backbone classes. In fact, there are a number
    of benefits of creating a Backbone `View` class that wraps your third-party component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, wrapping the component in a `View` allows you to specify a common way
    of using this component. For instance, let''s say you wanted to use the JQuery
    UI calendar widget (or `datepicker`) in your site. In jQuery UI, if you want your
    calendar to include a month-picking control, you have to supply a `changeMonth:
    true` option in every place in your code that creates a calendar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, assume that you create a `View` class that wraps the `datepicker`
    widget as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this class anywhere in your code that needs a calendar, and you
    won''t have to worry about forgetting to provide the `changeMonth` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If a completely different developer on your team wants to add a calendar, even
    if he knows nothing about jQuery UI or the `changeMonth` option, he'll still be
    able to create a calendar with the appropriate options for your site just by using
    the `View` you've created. This ability to encapsulate all logic related to a
    particular component and define your own interface for using it is another major
    benefit of this wrapping approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another benefit is the ability to easily make changes to a component. For
    instance, let''s say one day, we decide that we want all the calendars on our
    site to also have a year-picking drop-down (in other words, we want them all to
    have a `changeYear: true` option). Without a wrapping Backbone `View`, we''d have
    to find every place on our site that uses the `datepicker` widget and change its
    options, but with our `View`, we only have a single place in the code to update.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are disadvantages to this technique as well. One obvious one
    is that if we add any components to our site that don't use the same options as
    the rest, such as a `datepicker` widget without a month selector, we'll need to
    refactor our wrapping `View` to allow for such a possibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem is that wrapped components can remove themselves from the DOM
    without calling remove on their wrapping `View`, preventing this `View` from being
    garbage collected. Normally, this won''t be a problem, as a few extra "zombie"
    `Views` widgets in the memory won''t meaningfully impact performance. However,
    if you have a significant number of these wrapped widgets, then you may want to
    use the widget''s event system to ensure that the wrapping `View` always has `remove`
    called on it when its wrapped widget leaves the page. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, while hiding the details of a widget's usage inside a `View` may be
    convenient, it can also inadvertently hide relevant details about this widget
    from your fellow developers. For instance, a widget might have a certain side
    effect, but because other developers just use the widget's wrapping `View` and
    never read the original widget's documentation, they won't be aware of this side
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is important to ensure that such `Views` are properly documented.
    If the wrapped component has any sort of side effect, performance or otherwise,
    this side effect should also be carefully documented on the `View` itself or you
    should ensure that all developers on the team understand the workings of the underlying
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored several advanced techniques for using Backbone.
    First, we learned how many of Backbone's properties can be replaced with methods,
    and in particular, how the `model` property of a `Collection` class can be used
    in this way to generate different types of `Models`. We then learned how to override
    a class `constructor` to gain access to and/or manipulate its arguments before
    `initialize`, and how to use mixins to share methods between otherwise unrelated
    classes. Finally, we examined how to use the Backbone object itself to implement
    the pub/sub pattern, and how Backbone `Views` can be used to "wrap" components
    from other JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at some of the performance implications of Backbone
    and how you can avoid the most common performance pitfalls.
  prefs: []
  type: TYPE_NORMAL
