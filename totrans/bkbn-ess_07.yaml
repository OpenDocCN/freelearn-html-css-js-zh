- en: Chapter 7. Fitting Square Pegs in Round Holes – Advanced Backbone Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。将方钉塞入圆孔——高级 Backbone 技巧
- en: 'In this chapter, we will look at various advanced uses of Backbone, including
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Backbone 的各种高级用法，包括以下内容：
- en: Using methods in place of properties
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用方法代替属性
- en: Overriding a class's constructor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖类的构造函数
- en: Using mixins to share logic between classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混入（mixins）在类之间共享逻辑
- en: Implementing the publish/subscribe pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现发布/订阅模式
- en: Wrapping widgets from other libraries in Backbone `Views`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Backbone `Views` 中包装来自其他库的控件
- en: Taking it up a notch
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升一个层次
- en: In the previous chapters, we've discussed the basics of using Backbone's four
    classes, and while these basics are more than enough to make you productive with
    Backbone, we've deliberately left out a few of the more complicated details. In
    this chapter, we'll explore those left-out details and how they relate to certain
    advanced Backbone techniques.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了使用 Backbone 的四个类的基本方法，虽然这些基本方法已经足够让你在 Backbone 中变得高效，但我们故意省略了一些更复杂的细节。在本章中，我们将探讨这些省略的细节以及它们如何与某些高级
    Backbone 技巧相关。
- en: Before we proceed, however, it is important to note that all of the techniques
    discussed in this chapter are intended to be used to solve specific problems,
    and not as general-purpose patterns. While there is certainly nothing "wrong"
    with using any of these techniques, they will make your code more complex and
    thus, less intuitive and harder to maintain. Thus, it is recommended that you
    avoid using any of the techniques discussed in this chapter unless you specifically
    need to do so to solve a particular problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，在我们继续之前，重要的是要注意，本章中讨论的所有技术都是为了解决特定问题而设计的，而不是作为通用模式。虽然使用这些技术中任何一项都没有“错误”，但它们会使你的代码更加复杂，因此，更难以直观理解和维护。因此，建议除非你确实需要解决特定问题，否则避免使用本章中讨论的技术。 '
- en: Methods in place of properties
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用方法代替属性
- en: Many of the properties of Backbone classes have the option of being defined
    as functions instead of as primitives. In fact, we've already seen one instance
    of this behavior in the `url` property of `Models` and `Collections`. As we learned
    in [Chapter 3](part0029.xhtml#aid-RL0A1 "Chapter 3. Accessing Server Data with
    Models"), *Accessing Server Data with Models*, this property can be a simple string,
    but if you have a more complex URL that requires logic to generate, you can instead
    use a function that returns a string.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 类的许多属性都可以定义为函数而不是原始数据类型。实际上，我们在 `Models` 和 `Collections` 的 `url` 属性中已经看到了这种行为的一个例子。正如我们在第
    3 章[使用模型访问服务器数据](part0029.xhtml#aid-RL0A1 "第 3 章。使用模型访问服务器数据")中学到的，这个属性可以是一个简单的字符串，但如果需要逻辑来生成更复杂的
    URL，则可以使用返回字符串的函数。
- en: 'This same approach can be used with a number of Backbone properties, including
    the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相同的方法可以用于许多 Backbone 属性，包括以下内容：
- en: 'For Models:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于模型：
- en: '`defaults`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults`'
- en: '`url`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`'
- en: '`urlRoot`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urlRoot`'
- en: 'For Views:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于视图：
- en: '`attributes`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`'
- en: '`className`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`className`'
- en: '`events`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`events`'
- en: '`id`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`'
- en: '`tagName`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tagName`'
- en: 'For Routers:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于路由器：
- en: '`routes`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`'
- en: 'For instance, let''s say you wanted to have `View` that can generate either
    `<input>` or `<select>` based on whether or not it has `Collection`. By using
    a function in place of a string for our `Views` `tagName` property of the `Views`,
    we can do exactly that:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要一个 `View`，它可以根据是否有 `Collection` 生成 `<input>` 或 `<select>`。通过为 `Views`
    的 `tagName` 属性使用函数而不是字符串，我们可以做到这一点：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Collection.model as a factory method
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Collection.model 作为工厂方法使用
- en: The `Collection` class also has a property that can be replaced with a function,
    but unlike the other properties, this one isn't normally a primitive… it's a Backbone
    `Model` subclass. As discussed in [Chapter 4](part0037.xhtml#aid-1394Q1 "Chapter 4. Organizing
    Models with Collections"), *Organizing Models with Collections*, the *model* property
    of a `Collection` class determines what type of `Model` will be created by that
    `Collection`. Normally, each `Collection` class can have only a single *model*
    property and thus, can only create a single type of `Model`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection` 类也有一个可以用函数替换的属性，但与其它属性不同，这个属性通常不是一个原始数据类型……它是一个 Backbone `Model`
    子类。正如在第 4 章[使用集合组织模型](part0037.xhtml#aid-1394Q1 "第 4 章。使用集合组织模型")中讨论的，`Collection`
    类的 `model` 属性决定了该 `Collection` 将创建哪种类型的 `Model`。通常，每个 `Collection` 类只能有一个 `model`
    属性，因此只能创建一种类型的 `Model`。'
- en: 'However, there is a way around this limitation: If we replace the *model* property
    of our `Collection` with a function that returns new `Models`, Backbone will cheerfully
    overlook the fact that the `model` property isn''t actually a `Model` subclass
    at all. For example, let''s say our server has a "/book" API endpoint that returns
    JSON for two types of books: fiction and nonfiction. Let''s also say that we have
    two different `Model` classes, one for each type of book. If we wanted to be able
    to have a `Collection` class that fetches the JSON for both types of books from
    a single end point but uses the appropriate `model` function to instantiate each
    type of book, we could use a factory "model" function, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种方法可以绕过这个限制：如果我们用返回新`Models`的函数替换我们的`Collection`的`model`属性，Backbone将愉快地忽略`model`属性实际上根本不是`Model`子类的事实。例如，假设我们的服务器有一个返回两种类型书籍（虚构和非虚构）JSON的"/book"
    API端点。假设我们有两个不同的`Model`类，每个类对应一种类型的书籍。如果我们想要有一个能够从单个端点获取两种类型书籍的JSON的`Collection`类，但使用适当的`model`函数来实例化每种类型的书籍，我们可以使用一个工厂“model”函数，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Overriding a class constructor
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖类构造函数
- en: Whenever a Backbone class is instantiated, it runs the code defined in its `initialize`
    method. However, this code isn't run until after the new object has been instantiated.
    This means that even if you define an `initialize` method for a `Model` class,
    the attributes of that `Model` class will already have been set before your `initialize`
    code is even called.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Backbone类被实例化时，它都会运行其`initialize`方法中定义的代码。然而，这段代码是在新对象实例化之后才运行的。这意味着即使您为`Model`类定义了一个`initialize`方法，该`Model`类的属性已经在您的`initialize`代码被调用之前设置了。
- en: Normally, this is a good thing, as it is convenient to have things like the
    attributes of the `Model` class already set, but sometimes, we want to take control
    before this happens. For example, let's reimagine our previous scenario of fiction
    and nonfiction books, only this time instead of having a single `Collection` class
    that can create both types of books, we want a `Collection` that only creates
    one type and we want this type decided by the first book that we give the `Collection`
    class when its instantiated.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是好事，因为像`Model`类的属性已经设置这样的东西很方便，但有时我们希望在发生之前就掌握控制权。例如，让我们重新想象我们之前的虚构和非虚构书籍的场景，但这次我们不是有一个可以创建两种类型书籍的单个`Collection`类，我们想要一个只能创建一种类型的`Collection`，并且我们希望这种类型由我们给`Collection`类实例化的第一本书决定。
- en: 'In other words, if the first book given to our `Collection` class has the `isFiction`
    property, we want our `Collection` class to have the `Models` property of `FictionBook`;
    otherwise, we want it to have the `Models` property of `NonFictionBook`. If we
    do this inside an `initialize` method, the "model" option will already have been
    set on the `Collection` class before the `initialize` method is run, and any `Model`
    attributes that we pass in it will already have been converted into `Models`.
    Therefore, we need to add logic that runs before `initialize`. We can do this
    by overriding the constructor of the `Collection Constructor` method, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果给我们的`Collection`类提供的第一个书具有`isFiction`属性，我们希望我们的`Collection`类具有`FictionBook`的`Models`属性；否则，我们希望它具有`NonFictionBook`的`Models`属性。如果我们在这个`initialize`方法内部这样做，那么在`initialize`方法运行之前，“model”选项已经在`Collection`类上设置了，并且我们传递给它的任何`Model`属性已经转换成了`Models`。因此，我们需要添加在`initialize`之前运行的逻辑。我们可以通过覆盖`Collection
    Constructor`方法的构造函数来实现这一点，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how we still called the original `Collection` `Constructor` method from
    within our overridden version; if we hadn't done so, none of Backbone's normal
    logic would run and we wouldn't even have a proper `Collection` class when we're
    done.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在我们的覆盖版本中仍然调用了原始的`Collection` `Constructor`方法；如果我们没有这样做，Backbone的正常逻辑将不会运行，并且在我们完成时甚至可能没有正确的`Collection`类。
- en: As with the other techniques discussed in this chapter, it is not recommended
    that you override constructors very often. If at all possible you should override
    the `initialize` method instead. Constructor overriding should mainly be left
    to cases where you want to preprocess the arguments that go into a Backbone object
    before that object actually gets created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章讨论的其他技术一样，不建议您经常覆盖构造函数。如果可能的话，您应该覆盖`initialize`方法。构造函数的覆盖主要应留给那些您希望在Backbone对象实际创建之前预处理传入参数的情况。
- en: Class mixins
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类混合
- en: Backbone provides a very powerful class system, but sometimes, even this class
    system isn't enough. For instance, let's say you have several classes that all
    contain several identical methods. The popular **Don't Repeat Yourself** (**DRY)**
    programming principle suggests that you should eliminate the duplicate versions
    of the methods and instead, define them all together in just one place in your
    code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone提供了一个非常强大的类系统，但有时，即使是这个类系统也不够用。例如，假设你有几个类，它们都包含几个相同的方法。流行的**不要重复自己**（**DRY**）编程原则建议你应该消除方法的重复版本，而是在代码中的一个地方定义它们。
- en: Normally, you could do so by refactoring these methods into a common parent
    class of these classes. But what if these classes can't share a common parent
    class? For instance, what if one of these classes is a `Model` class and the other
    a `Collection` class?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过将这些方法重构为这些类的一个公共父类来实现这一点。但如果这些类不能共享一个公共父类怎么办？例如，如果其中一个类是`Model`类，而另一个是`Collection`类呢？
- en: 'In this case, you need to rely on something called a mixin. A mixin is just
    an object that holds one or more methods (or even primitive properties) that you
    want to share between several classes. For example, if we wanted to share a couple
    of logging-related methods between several classes, we could create a mixin of
    these methods, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要依赖一种称为混入（mixin）的东西。混入只是一个包含一个或多个你想要在几个类之间共享的方法（甚至原始属性）的对象。例如，如果我们想在几个类之间共享一些与日志记录相关的功能，我们可以创建一个包含这些方法的混入，如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you''ve defined your mixin, the next step is to "mix it in" to the definition
    of your class. This means modifying the `prototype` of the class to include the
    methods from our mixin. For instance, let''s say we have a book `Model`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了你的混入（mixin），下一步就是将其“混合”到你的类定义中。这意味着修改类的`prototype`以包含混入中的方法。例如，假设我们有一个书`Model`：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because Backbone''s syntax makes creating our new class so simple, it''s easy
    to miss the fact that we''re actually defining a prototype object here, but if
    we change things just a little, it suddenly becomes more obvious:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Backbone的语法使得创建我们的新类变得如此简单，所以我们很容易忽略这样一个事实：我们实际上在这里定义了一个原型对象，但如果我们稍作改变，它突然就变得明显了：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we''ve separated the Book prototype, we can augment it with our mixin.
    We could do this manually:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们分离了书的原型（prototype），我们就可以用我们的混入来增强它。我们可以手动做这件事：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, this won''t work well if we have a lot of methods to mixin, or if
    our mixin later gets new methods added. Instead, we can use Underscore''s `extend`
    function to extend all of the methods in our mixin on to the `Book` prototype
    in a single command: `_.extend(bookPrototype, loggingMixin);`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们有很多方法要混入，或者我们的混入后来添加了新方法，这就不太适用了。相反，我们可以使用Underscore的`extend`函数来通过单个命令将混入中的所有方法扩展到`Book`原型上：`_.extend(bookPrototype,
    loggingMixin);`
- en: With just this one line, we've added a whole set of logging-related methods
    to our `Book` class. Plus, we can now share these methods with any other class,
    again by using only a single line, all without having to change the parent class
    of any of the classes involved.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就这一行代码，我们就为我们的`Book`类添加了一整套与日志记录相关的功能。此外，我们还可以通过仅使用一行代码将这些方法与任何其他类共享，而无需更改任何相关类的父类。
- en: 'Of course, it''s important to note that because we are applying our mixin on
    top of the existing prototype, it will overwrite any properties that it has in
    common with the prototype. In other words, assume that our `Book` class already
    has its own `startLogging` method that prevents logging:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，重要的是要注意，因为我们是在现有原型上应用混入，所以它将覆盖与原型共有的任何属性。换句话说，假设我们的`Book`类已经有一个自己的`startLogging`方法来阻止日志记录：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will erase this method by applying our mixin, giving us logging on our class
    even though we don't want it. Further, even if `Book` doesn't have such a method,
    a future developer might add one and then, be confused when it doesn't work. If
    the future developer doesn't see (or doesn't understand) the mixin line, he might
    spend hours looking through the parent classes of `Book`, trying to figure out
    what's happening.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过应用混入来擦除这个方法，即使我们不想这样做，也会在我们的类上实现日志记录。进一步来说，即使`Book`没有这样的方法，未来的开发者可能会添加一个，然后，当它不起作用时感到困惑。如果未来的开发者没有看到（或没有理解）混入行，他可能会花几个小时查看`Book`的父类，试图弄清楚发生了什么。
- en: Because of this issue, it is usually better to rely on standard object-oriented
    programming as much as possible when designing your classes, and only use mixins
    when you can't share methods through a normal class hierarchy. In these cases,
    however, mixins can be a powerful tool and serve as yet another example of what
    is possible in JavaScript but not in most other languages (Good luck mixing methods
    into a Java class!).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个问题，在设计你的类时，通常最好尽可能多地依赖标准面向对象编程，并且只有在无法通过正常类层次结构共享方法时才使用混入。然而，在这些情况下，混入可以是一个强大的工具，并作为
    JavaScript 中但大多数其他语言中不可能实现的另一个例子（祝你好运，将方法混入一个 Java 类！）。
- en: Publish/subscribe
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布/订阅
- en: Backbone classes often wind up being tightly coupled together. For instance,
    a `View` class might listen to a `Model` class for changes in its data, and then,
    when this data changes, it might look at the `attributes` of the `Model` to determine
    what to render. This practice couples the `View` class to the `Model` class, which
    normally is a good thing as it lets you define the exact relationship you need
    between the two classes, while still keeping your code fairly simple and maintainable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 类通常最终会紧密耦合在一起。例如，一个 `View` 类可能会监听 `Model` 类数据的变化，然后，当数据发生变化时，它可能会查看
    `Model` 的 `attributes` 来确定要渲染的内容。这种做法将 `View` 类耦合到 `Model` 类，这在正常情况下是好事，因为它允许你定义两个类之间所需的确切关系，同时仍然保持你的代码相对简单和可维护。
- en: When you only have a few `Models` and `Views`, it's easy enough to manage their
    relationships in this way. However, if you are building a particularly complex
    user interface, then this same coupling can instead become a hindrance. Imagine
    having a single page with a large number of `Collections`, `Models`, and `Views`,
    all listening and responding to changes in one another. Whenever a single change
    occurs, it can cause a ripple effect, resulting in further changes, which can
    then result in still further changes, and these changes can … well, you get the
    idea! This can make it nearly impossible to understand what changes are occurring
    and what effect they will have; in the worst case scenario, they can create infinite
    loops or make it difficult to fix bugs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只有少数 `Models` 和 `Views` 时，以这种方式管理它们之间的关系很容易。然而，如果你正在构建一个特别复杂的用户界面，那么这种相同的耦合可能会变成一种障碍。想象一下，有一个单页面上有大量
    `Collections`、`Models` 和 `Views`，它们都在监听并响应彼此的变化。每当发生单个变化时，它都可能引起连锁反应，导致进一步的改变，然后这些改变又可能导致更多的改变，如此等等！这几乎使得理解正在发生什么变化以及它们将产生什么影响变得不可能；在最坏的情况下，它们可以创建无限循环或使修复错误变得困难。
- en: The solution for a complex system like this is to decouple the various components
    (`Collections`, `Models`, and `Views`) involved with each other by using the Publish/Subscribe
    pattern (or pub/sub for short). In this pattern, all of the components still communicate
    via events, but instead of each `Collection` and `Model` class having its own
    event bus, all of the `Collection` and `Model` classes involved share a single,
    global event bus, eliminating direct connections between them. Whenever one component
    wants to communicate with another, it publishes (triggers) an event that the other
    component has subscribed (listened) to.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个复杂系统，解决方案是使用发布/订阅模式（或简称 pub/sub）来解耦各个组件（`Collections`、`Models` 和 `Views`）。在这个模式中，所有组件仍然通过事件进行通信，但不是每个
    `Collection` 和 `Model` 类都有自己的事件总线，所有涉及的 `Collection` 和 `Model` 类共享一个单一的全局事件总线，消除了它们之间的直接连接。每当一个组件想要与另一个组件通信时，它会发布（触发）一个其他组件已订阅（监听）的事件。
- en: 'To implement this pattern in Backbone, we need a global event bus, and it turns
    out that Backbone already includes one for us: the Backbone object itself. Like
    `Models` and `Collections`, the Backbone object has both an "on" (subscription)
    method and a "trigger" (publishing) method. Both these methods work the same way
    as they do on other Backbone objects.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Backbone 中实现这种模式，我们需要一个全局事件总线，而实际上 Backbone 已经为我们提供了一个：Backbone 对象本身。就像 `Models`
    和 `Collections` 一样，Backbone 对象既有 "on"（订阅）方法，也有 "trigger"（发布）方法。这两个方法的工作方式与其他 Backbone
    对象相同。
- en: 'One type of application that often benefits from the pub/sub pattern is games,
    because they often have many different UI pieces being updated by a variety of
    different data sources. Let''s imagine that we''re building a three-player game
    where each player is represented by a `Model` class. Since we want to keep the
    player `Models` updated with changes from the server, we fetch those `Model` at
    periodic intervals:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 常常从发布/订阅模式中受益的一种应用类型是游戏，因为它们通常有很多不同的UI组件被各种不同的数据源更新。让我们想象一下，我们正在构建一个三人游戏，其中每个玩家都由一个`Model`类表示。由于我们希望保持玩家`Model`与服务器更改同步，我们以周期性的间隔获取这些`Model`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s further imagine that we have a scoreboard `View`, which needs to update
    itself in response to changes in the players'' scores. Now, of course, in the
    real world, if we just had a single `View`, we most likely wouldn''t even need
    the pub/sub pattern, but let''s keep this example as simple as possible. To avoid
    coupling our `View` to our player `Models` directly we''ll instead have it listen
    for a `scoreChange` event on the Backbone object:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步想象，我们有一个计分板`View`，它需要根据玩家分数的变化来更新自己。当然，在现实世界中，如果我们只有一个`View`，我们很可能甚至不需要发布/订阅模式，但让我们使这个例子尽可能简单。为了避免将`View`直接耦合到玩家`Model`，我们将让它监听Backbone对象上的`scoreChange`事件：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in order to have these `scoreChange` events occur, we''ll need to make
    our `Player` class trigger them. We''ll also need a way to tell if a score has
    changed, but luckily for us, each of the `Model` classes has a `hasChanged` method,
    which does exactly that. We can use this method, inside an overwritten `fetch`
    method, to trigger our `scoreChange` event as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使这些`scoreChange`事件发生，我们需要让我们的`Player`类触发它们。我们还需要一种方法来判断分数是否已更改，但幸运的是，每个`Model`类都有一个`hasChanged`方法，它正好可以做到这一点。我们可以在重写的`fetch`方法中使用这个方法来触发我们的`scoreChange`事件，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `Model` class and the `View` are now completely separate.
    The `Model` class passes any information that the `View` requires through the
    event itself, when it makes the `Backbone.trigger` call; otherwise, all classes
    involved remain oblivious to one another.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Model`类和`View`现在是完全独立的。`Model`类通过事件本身传递任何`View`所需的信息，当它调用`Backbone.trigger`时；否则，所有涉及的类都对彼此一无所知。
- en: Of course, as with any of these advanced techniques, there are also disadvantages
    to this approach, primarily the lack of encapsulation. When you have a `View`
    fetch a `Model` class directly, you know exactly what code connects the two, and
    if you want to refactor or otherwise change that code, it's easy to determine
    what will be affected. However, with the pub/sub pattern, it can be much more
    difficult to determine what code will be impacted by a potential change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与任何这些高级技术一样，这种方法也有其缺点，主要是封装性不足。当你有一个`View`直接获取`Model`类时，你知道连接两个类的确切代码，如果你想要重构或更改该代码，很容易确定会受到什么影响。然而，在使用发布/订阅模式的情况下，确定可能受到潜在更改影响的代码可能会困难得多。
- en: 'In many ways, this is very similar to the trade-off between using global variables
    and using local variables: While the former are much more powerful and easy to
    work with, initially, their very lack of limits can make them much harder to work
    with in the long run. Therefore, as much as possible, you should avoid relying
    on the pub/sub pattern and instead, rely on event listeners bound to particular
    Backbone objects. However, when you do have a problem that requires communication
    between many disparate parts of your code, relying on this pattern and listening
    for/triggering events on the Backbone object itself can allow for a much more
    elegant solution.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这类似于使用全局变量和使用局部变量之间的权衡：虽然前者在最初更强大且易于处理，但它们缺乏限制性可能会使它们在长期使用中更难以处理。因此，尽可能避免依赖发布/订阅模式，而是依赖绑定到特定Backbone对象的监听器。然而，当你遇到需要代码中多个不同部分之间通信的问题时，依赖这种模式并在Backbone对象上监听/触发事件可以提供一种更优雅的解决方案。
- en: Wrapping widgets of other libraries
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装其他库的组件
- en: Backbone is an incredibly powerful framework, but it can't do everything. If
    you want to add a calendar widget, a rich text editor, or a node tree to your
    site, you'll probably want to use another library, which can provide such a component
    for you (for example, jQuery UI, TinyMCE, or jsTree). However, just because you
    want to use a tool other than Backbone, it doesn't mean you have to give up all
    of the convenience and power of Backbone classes. In fact, there are a number
    of benefits of creating a Backbone `View` class that wraps your third-party component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 是一个非常强大的框架，但它不能做所有事情。如果你想向你的网站添加日历小部件、富文本编辑器或节点树，你可能想使用另一个库，该库可以为你提供这样的组件（例如，jQuery
    UI、TinyMCE 或 jsTree）。然而，仅仅因为你想要使用除 Backbone 之外的工具，并不意味着你必须放弃 Backbone 类的所有便利和功能。事实上，创建包装第三方组件的
    Backbone `View` 类有许多好处。
- en: 'First, wrapping the component in a `View` allows you to specify a common way
    of using this component. For instance, let''s say you wanted to use the JQuery
    UI calendar widget (or `datepicker`) in your site. In jQuery UI, if you want your
    calendar to include a month-picking control, you have to supply a `changeMonth:
    true` option in every place in your code that creates a calendar:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，将组件包装在 `View` 中允许你指定使用此组件的通用方式。例如，假设你想要在你的网站上使用 JQuery UI 日历小部件（或 `datepicker`）。在
    jQuery UI 中，如果你想让你的日历包含月份选择控件，你必须在每个创建日历的代码位置提供 `changeMonth: true` 选项：'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, assume that you create a `View` class that wraps the `datepicker`
    widget as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你创建了一个如下包装 `datepicker` 小部件的 `View` 类：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can use this class anywhere in your code that needs a calendar, and you
    won''t have to worry about forgetting to provide the `changeMonth` option:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中需要日历的任何地方使用这个类，你不必担心忘记提供 `changeMonth` 选项：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If a completely different developer on your team wants to add a calendar, even
    if he knows nothing about jQuery UI or the `changeMonth` option, he'll still be
    able to create a calendar with the appropriate options for your site just by using
    the `View` you've created. This ability to encapsulate all logic related to a
    particular component and define your own interface for using it is another major
    benefit of this wrapping approach.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的团队中有一个完全不同的开发者想要添加一个日历，即使他对 jQuery UI 或 `changeMonth` 选项一无所知，他仍然能够仅通过使用你创建的
    `View` 来创建一个适合你网站的日历。这种将特定组件相关的所有逻辑封装起来并定义自己使用接口的能力是这种包装方法的主要好处之一。
- en: 'Yet another benefit is the ability to easily make changes to a component. For
    instance, let''s say one day, we decide that we want all the calendars on our
    site to also have a year-picking drop-down (in other words, we want them all to
    have a `changeYear: true` option). Without a wrapping Backbone `View`, we''d have
    to find every place on our site that uses the `datepicker` widget and change its
    options, but with our `View`, we only have a single place in the code to update.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个好处是能够轻松地更改组件。例如，假设有一天，我们决定我们希望我们网站上的所有日历都也具有一个年份选择的下拉菜单（换句话说，我们希望它们都具有 `changeYear:
    true` 选项）。如果没有包装的 Backbone `View`，我们就必须找到网站上所有使用 `datepicker` 小部件的地方并更改其选项，但有了我们的
    `View`，我们只需要在代码中的一个地方更新。'
- en: Of course, there are disadvantages to this technique as well. One obvious one
    is that if we add any components to our site that don't use the same options as
    the rest, such as a `datepicker` widget without a month selector, we'll need to
    refactor our wrapping `View` to allow for such a possibility.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种技术也有其缺点。一个明显的缺点是，如果我们向我们的网站添加任何不使用相同选项的组件，例如没有月份选择器的 `datepicker` 小部件，我们就需要重构我们的包装
    `View` 以允许这种可能性。
- en: 'Another problem is that wrapped components can remove themselves from the DOM
    without calling remove on their wrapping `View`, preventing this `View` from being
    garbage collected. Normally, this won''t be a problem, as a few extra "zombie"
    `Views` widgets in the memory won''t meaningfully impact performance. However,
    if you have a significant number of these wrapped widgets, then you may want to
    use the widget''s event system to ensure that the wrapping `View` always has `remove`
    called on it when its wrapped widget leaves the page. For instance:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是有包装的组件可以在不调用其包装 `View` 上的 `remove` 方法的情况下从 DOM 中移除自己，这阻止了该 `View` 被垃圾回收。通常情况下，这不会成为问题，因为内存中一些额外的“僵尸”
    `View` 小部件不会对性能产生重大影响。然而，如果你有大量这些包装小部件，那么你可能想使用小部件的事件系统来确保当其包装小部件离开页面时，包装 `View`
    总是会调用 `remove` 方法。例如：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, while hiding the details of a widget's usage inside a `View` may be
    convenient, it can also inadvertently hide relevant details about this widget
    from your fellow developers. For instance, a widget might have a certain side
    effect, but because other developers just use the widget's wrapping `View` and
    never read the original widget's documentation, they won't be aware of this side
    effect.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然将小部件的使用细节隐藏在 `View` 中可能很方便，但它也可能无意中隐藏了有关此小部件的相关细节，从而让其他开发者无法了解。例如，一个小部件可能有一个特定的副作用，但由于其他开发者只是使用小部件的包装
    `View` 而从未阅读原始小部件的文档，他们可能不会意识到这个副作用。
- en: For this reason, it is important to ensure that such `Views` are properly documented.
    If the wrapped component has any sort of side effect, performance or otherwise,
    this side effect should also be carefully documented on the `View` itself or you
    should ensure that all developers on the team understand the workings of the underlying
    component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，确保这样的 `Views` 被适当文档化是很重要的。如果被包装的组件有任何形式的副作用，无论是性能上的还是其他方面，这种副作用也应该在 `View`
    本身上仔细记录，或者你应该确保团队中的所有开发者都理解底层组件的工作原理。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored several advanced techniques for using Backbone.
    First, we learned how many of Backbone's properties can be replaced with methods,
    and in particular, how the `model` property of a `Collection` class can be used
    in this way to generate different types of `Models`. We then learned how to override
    a class `constructor` to gain access to and/or manipulate its arguments before
    `initialize`, and how to use mixins to share methods between otherwise unrelated
    classes. Finally, we examined how to use the Backbone object itself to implement
    the pub/sub pattern, and how Backbone `Views` can be used to "wrap" components
    from other JavaScript libraries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Backbone 的几种高级技术。首先，我们学习了 Backbone 的许多属性可以被方法所替代，特别是如何使用 `Collection`
    类的 `model` 属性以这种方式生成不同类型的 `Models`。然后，我们学习了如何覆盖类 `constructor` 以在 `initialize`
    之前访问和/或操作其参数，以及如何使用混入（mixins）在原本无关的类之间共享方法。最后，我们考察了如何使用 Backbone 对象本身来实现发布/订阅（pub/sub）模式，以及如何使用
    Backbone `Views` 来“包装”来自其他 JavaScript 库的组件。
- en: In the next chapter, we'll look at some of the performance implications of Backbone
    and how you can avoid the most common performance pitfalls.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Backbone 的性能影响以及如何避免最常见的性能陷阱。
