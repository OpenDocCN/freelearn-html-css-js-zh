<html><head></head><body>
        

                            
                    <h1 class="header-title">The Animation Library</h1>
                
            
            
                
<p>Servos are great tools for creating movement in our robotics projects but we need more control in order to create truly mobile walking robots. Each servo is different; for example, each servo moves at slightly different max speeds. If you want a bot to walk, you need timing control, and the ability to know when a servo has finished its movement. Enter the animation library; this powerful tool inside Johnny-Five allows you to fine-tune your servo movements to allow you more in-depth control.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Animating movement</li>
<li>The terminology of the animation library</li>
<li>The construction of the animation object</li>
<li>Easing into your servo animations</li>
<li>Learning more about queuing and playing animation segments</li>
<li>Animation object events</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>You'll need your two-servo setup from the previous chapter, and that's it for hardware for this chapter.</p>
<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Hands-On-Robotics-with-JavaScript/tree/master/Chapter08">https://github.com/PacktPublishing/Hands-On-Robotics-with-JavaScript/tree/master/Chapter08</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating movement</h1>
                
            
            
                
<p>The animation library makes many things possible with servos that are otherwise anywhere from difficult to downright implausible. Before we explore the <em>how</em> of the animation library, however, we should more thoroughly explain the <em>why</em>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Why we need the animation library</h1>
                
            
            
                
<p>Think about the movement of your leg as you take a step. You don't normally have to, but when you do, there's a lot going on in your joints! Your hip extends your leg out, and your knee extends your leg without usually locking it. And your back leg is doing things too; your hip is allowing the leg to move back, and your ankle is flexing. This is a massive oversimplification, but it's still really complicated!</p>
<p>Now imagine each of your joints as a servo, and you have to program taking a step. You cannot control the timing of each movement, because each servo will get to where you tell it to go as fast as you can. You also can't tell when a joint is done moving, so you have to hard-code timings and hope it holds up.</p>
<p>This exact kind of issue is what the animation library was made to alleviate. By giving you more control, you have more precision. But what do we mean by precision?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Moving servos with true precision</h1>
                
            
            
                
<p>True precision, in the context of moving servos, means being able to control the timing, position, and speed of the servos being used. This level of precision is vital when building meticulous movements that require multiple movements happening in sync to avoid physical collisions. A great example of this is a hexapod robot: each joint needs to move in time with the other joints in the leg, and each leg needs to move at a precise time during a step in order to avoid colliding with each other or throwing the hexapod off balance.</p>
<p>Moving servos with true precision is a daunting task if you are hard-coding it; imagine setting 60 calls to <kbd>servo.to()</kbd> in order to create an animation that you <em>hope</em> takes one second. Or hard-coding each movement with <kbd>servo.to()</kbd>, timing it with the exact servo you've placed in the leg of your bot, and everything works...until the servo strips (it inevitably will), and you have to replace it and repeat the entire calibration process.</p>
<p class="mce-root">The animation library in Johnny-Five makes this process much simpler by allowing you to define your movements as segments of a larger design, that design being the animation itself. It does all of the math and works out all of the timings to ensure that your servos are where they need to be when they need to be there.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Implicit use of the animation library</h1>
                
            
            
                
<p>Sometimes, you don't even need to create an animation object in order to create an animation for your servos. Before we really break into the animation object, let's write some code that uses the animation library implicitly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using servo.to() to implicitly create an animation</h1>
                
            
            
                
<p>In a <kbd>project</kbd> folder for this chapter, create a file called <kbd>implicit-animations.js</kbd>. We'll set up this file to use the REPL to demonstrate animations created without explicitly creating an animation object. Start with the normal boilerplate: bring in <kbd>johnny-five</kbd> and <kbd>raspi-io</kbd>, set up your board and <kbd>board.ready()</kbd> handler as usual:</p>
<pre>const Raspi = require('raspi-io')<br/>const five = require('johnny-five')<br/><br/>const board = new five.Board({<br/>  io: new Raspi()<br/>})<br/><br/>board.on('ready', () =&gt; {<br/>})</pre>
<p>Then, inside the <kbd>board.on('ready')</kbd> handler, construct a <kbd>Servo</kbd> object:</p>
<pre>  let servo = new five.Servo({<br/>    controller: "PCA9685",<br/>    pin: 0<br/>  })</pre>
<p>Next, while still inside the <kbd>board.on('ready')</kbd> handler, we're going to create the same motion three times—each time with a different set of specifications. Two of these will create an animation behind-the-scenes, and one is the default movement, so you can see the difference.</p>
<p class="mce-root"/>
<p>It can be a little hard to spot the differences in the servo movements if you're looking at a micro servo horn. I taped a Popsicle stick to my servo horns for this chapter, to make the differences easier to see. I also taped it to stand up on my desk so it wouldn't tip over, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-738 image-border" src="img/fc252dec-e458-49c8-a00c-3ef579fee832.png" style="width:137.50em;height:64.17em;"/></p>
<p>First movement function, still inside your <kbd>board.on('ready')</kbd> handler, will be called <kbd>normalFullSwing()</kbd>:</p>
<pre>function normalFullSwing() {<br/> servo.to(0)<br/> servo.to(180)<br/>}</pre>
<p>This function will move the servo to <kbd>0</kbd> degrees as quickly as it can, then bring the servo to <kbd>180</kbd> degrees as fast as it can. </p>
<p>Let's add a parameter to <kbd>servo.to()</kbd> in our next function that will change how long the servo takes to get there. We'll set it to take in a time parameter that we'll pass through when we experiment in the REPL: </p>
<pre>function timedFullSwing(time) {<br/>  servo.to(0)<br/>  servo.to(180, time)<br/>}</pre>
<p class="mce-root"/>
<p>This function will take the number of milliseconds passed to it to go from <kbd>0</kbd> to <kbd>180</kbd> degrees. It will still start by going to <kbd>0</kbd> degrees as fast as possible.</p>
<p>Finally, we'll write a function that takes in a time and a steps parameter that will move the servo from <kbd>0</kbd> to <kbd>180</kbd> in the time given, using the number of steps given. We'll call this function <kbd>timedFullSwingWithSteps()</kbd>:</p>
<pre>function timedFullSwingWithSteps(time, steps) {<br/> servo.to(0)<br/> servo.to(180, time, steps)<br/>}</pre>
<p>This function will, as the others, still go to <kbd>0</kbd> as fast as possible first.</p>
<p>Finally, we'll give ourselves access to these functions from the REPL using <kbd>board.repl.inject()</kbd>:</p>
<pre>board.repl.inject({<br/>  normalFullSwing,<br/>  timedFullSwing,<br/>  timedFullSwingWithSteps<br/>})</pre>
<p>And we're ready to roll (or swing, as it were)!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing with implicit animations</h1>
                
            
            
                
<p>Load the folder onto your Pi, navigate into it using your Pi SSH session, and run the following commands:</p>
<pre><strong>npm init -y</strong><br/><strong>npm i --save johnny-five raspi-io</strong></pre>
<p>Now that we're all set up, we run the code using:</p>
<pre><strong>sudo node implicit-animations.js</strong></pre>
<p>Once you see <kbd>Board Initialized</kbd>, we can run our functions and see the differences. Here are just a few to try:</p>
<pre>normalFullSwing() // hm...<br/>timedFullSwing(1000) // wait a tick...<br/>timedFullSwingWithSteps(1000, 10) // why didn't it do it?</pre>
<p>You may be noticing something is up by now. At most, you might see a twitch or two, but it's certainly not working as intended!</p>
<p class="mce-root"/>
<p>That's because of a very important thing with timing, and that's that <strong>if you don't wait for servo movements to finish, they'll just override each other, causing unstable results</strong>.</p>
<p>That's part of why the animation library is so important! It has the ability for you to queue animations, meaning that the servo will let each movement finish before moving on to the next, preventing the need for you to program the waiting in yourself (especially icky considering the asynchronous nature of JavaScript).</p>
<p>Now, we're going to use a few more implicit animations, and some <kbd>setTimeout()</kbd> calls, to make these functions work properly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing with implicit animations, take two</h1>
                
            
            
                
<p>To fix your <kbd>normalFullSwing()</kbd> function, we'll set the <kbd>servo.to(0)</kbd> call to take 250 milliseconds, and <kbd>call servo.to(180)</kbd> after 255 milliseconds (just to be sure it's completely done getting to <kbd>0</kbd> first):</p>
<pre>function normalFullSwing() {<br/> servo.to(0, 1000)<br/> setTimeout(() =&gt; { servo.to(180) }, 1010)<br/>}</pre>
<p>We'll do the same to the <kbd>timedFullSwing()</kbd> and <kbd>timedFullSwingWithSteps()</kbd> functions:</p>
<pre>function timedFullSwing(time) {<br/>  servo.to(0, 1000)<br/>  setTimeout(() =&gt; { servo.to(180, time) }, 1010)<br/>}<br/><br/>function timedFullSwingWithSteps(time, steps) {<br/>  servo.to(0, 1000)<br/>  setTimeout(() =&gt; { servo.to(180, time, steps) }, 1010)<br/>}</pre>
<p>Once you've made these changes, reload your <kbd>project</kbd> folder and run it:</p>
<pre><strong>sudo node implicit-animations.js</strong></pre>
<p>If you're using the book code directly instead of following along, <kbd>implicit-animations-fixed.js</kbd> contains the timeouts so you should run that file instead of running <kbd>implicit-animations.js</kbd> again.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now that the code is running as intended, let's play around a little more with these implicit animations:</p>
<pre>// Just a normal swing<br/>normalFullSwing()<br/>// Playing with the time parameter<br/>timedFullSwing(1000)<br/>timedFullSwing(750)<br/>timedFullSwing(5000)<br/>// Playing with the steps parameter<br/>timedFullSwingWithSteps(3000, 2)<br/>timedFullSwingWithSteps(1000, 10)<br/>timedFullSwingWithSteps(1000, 100)</pre>
<p>Make a mental note of what changing the timing and steps does to the servo's movements, it'll come in handy for the rest of the chapter.</p>
<p>Now that we understand some of the underlying effects of the animation library, and why it's so crucial when dealing with complex servo movements, let's dig into the animation library in detail. We'll start with the terminology, unless you have a strong background with animation (as in animated imagery), you have some vocabulary to learn!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The terminology of the animation library</h1>
                
            
            
                
<p>The animation library was named the way it was quite intentionally; the vocabulary of the animation object very closely matches the vocabulary of animating images. Let's look at a few of the terms we'll be using heavily throughout this chapter.</p>
<ul>
<li><strong>Frame</strong>: A frame of an animation is, in this context, the state of the servo at a given instance in time. As you can imagine, programming each and every frame of servo movement for a complex group of servos, such as a limb, would be a nightmare. Luckily, technology is on our side here, and we won't have to write each and every frame.</li>
<li><strong>Keyframe</strong>: A keyframe is a point in an animation that serves as an anchor unless you're drawing (or programming) every frame of an animation by hand; you establish a set of keyframes that establish the major points of movement for the animation. For example, in our full sweep we were doing earlier, a good set of keyframes would be something like this:
<ul>
<li>Start at any degree</li>
<li>Be at <kbd>0</kbd> degrees</li>
<li>End at <kbd>180</kbd> degrees</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p style="padding-left: 60px">Simpler animations have fewer keyframes, but you always need at least two to create an animation. Note that keyframes themselves do not have any concept of time attached; they must be coupled with cue points to create an animation.</p>
<ul>
<li><strong>Cue point</strong>: A cue point is a point in the context of the sequence between 0 and 1, and a set of cue points paired with an equally-sized set of keyframes and an overall duration creates a full animation. For instance, when we care the keyframes above with the set of cue points containing 0 seconds, 1 second, and 2 seconds, you get what starts to sound like an animation:
<ul>
<li>Start at any degree at 0%</li>
<li>Be at <kbd>0</kbd> degrees at 50%</li>
<li>End at <kbd>180</kbd> degrees at 100%</li>
</ul>
</li>
<li><strong>Duration</strong>:<strong> </strong>Duration is the amount of time the animation sequence will run, and completes an animation when paired with keyframes and cue points. Take the above example with a duration of 2000 millseconds and you get:
<ul>
<li>Start at any degree at 0 ms</li>
<li>Be at <kbd>0</kbd> degrees at 1000 ms</li>
<li>End at <kbd>180</kbd> degrees at 2000 ms</li>
</ul>
</li>
<li><strong>Tweening</strong>: Tweening is the idea of your software creating the necessary frames between your keyframes. You establish the keyframes, and tweening figures out what to do in between those frames. The time between each frame (exhibited by our <kbd>timedFullSwing()</kbd> function) and the number of steps (frames) between keyframes (exhibited by our <kbd>timedFullSwingWithSteps()</kbd> function) allow us to fine-tune the tweening process.</li>
<li><strong>Easing</strong>:<strong> </strong>Another part of the tweening process is easing. Without easing, all tweening is done linearly, with the same amount of movement in each tweened frame. This does not look smooth at all if you're building anything trying to walk. There are several forms of tweening; one of the most common form is ease-in or ease-out easing, which either starts slowly and ramps up to a fast ending, or starts fast and ramps down to a slow ending, respectively.</li>
</ul>
<p>Now that we've discussed the terminology of an animation, we can start coding our first (explicit) animation object with Johnny-Five!</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The construction of the animation object</h1>
                
            
            
                
<p>To construct an animation object, we need to create the object itself, create a set of keyframes and a set of cue points, then enqueue those keyframes and cue points as an animation to run on our servos.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the animation object</h1>
                
            
            
                
<p>Create a new file in your <kbd>project</kbd> folder called <kbd>my-first-animation.js</kbd> and create the normal boilerplate: <kbd>require</kbd> in Johnny-Five and Raspi-IO, create your <kbd>Board</kbd> object, and create the <kbd>board.on('ready')</kbd> function:</p>
<pre>const Raspi = require('raspi-io')<br/>const five = require('johnny-five')<br/><br/>const board = new five.Board({<br/>  io: new Raspi()<br/>})<br/><br/>board.on('ready', () =&gt; {<br/>})</pre>
<p>Then, inside the <kbd>board.on('ready')</kbd> handler, construct our two <kbd>Servo</kbd> objects on pin <kbd>0</kbd> and pin <kbd>1</kbd> of our PWM hat:</p>
<pre>let servoOne = new five.Servo({<br/>  controller: "PCA9685",<br/>  pin: 0<br/>})<br/><br/>let servoTwo = new five.Servo({<br/>  controller: "PCA9685",<br/>  pin: 1<br/>})</pre>
<p>And create a <kbd>Servos</kbd> object containing our servos:</p>
<pre>let servos = new five.Servos([servoOne, servoTwo])</pre>
<p class="mce-root"/>
<p>Now that we have a group of servos, we can create an animation object:</p>
<pre>let myFirstAnimation = new five.Animation(servos)</pre>
<p>Now that we have our animation object, it's time to plan out our animation sequence, set keyframes and cue points, and queue them to animate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning out the animation sequence</h1>
                
            
            
                
<p>Let's plan a simple enough animation for our first go-round: let's allow the servos to start anywhere, then <kbd>servoOne</kbd> will move to <kbd>0</kbd> degrees while <kbd>servoTwo</kbd> will move to <kbd>180</kbd>. Then, <kbd>servoOne</kbd> will sweep to <kbd>180</kbd> while <kbd>servoTwo</kbd> starts moving to <kbd>90</kbd> degrees, then both servos will end at <kbd>90</kbd> degrees. Let's have each of these positions happen two seconds apart. So our keyframes will look something like this:</p>
<ol>
<li>Start with <kbd>servoOne</kbd> at any degree, start with <kbd>servoTwo</kbd> at any degree</li>
<li>Move <kbd>servoOne</kbd> to <kbd>0</kbd> degrees, move <kbd>servoTwo</kbd> to <kbd>180</kbd> degrees</li>
<li><kbd>servoOne</kbd> stays at its last known position, <kbd>servoTwo</kbd> is moving towards <kbd>90</kbd> degrees</li>
<li>Move <kbd>servoOne</kbd> to <kbd>180</kbd> degrees, <kbd>servoTwo</kbd> is moving towards <kbd>90</kbd> degrees</li>
<li>Move <kbd>servoOne</kbd> to <kbd>90</kbd> degrees, move <kbd>servoTwo</kbd> to <kbd>90</kbd> degrees completed</li>
</ol>
<p>Our cue points will be (in terms of <kbd>0</kbd>-<kbd>1</kbd>): <kbd>0</kbd>, <kbd>.25</kbd>, <kbd>.5</kbd>, <kbd>.75</kbd>, <kbd>1</kbd>.</p>
<p>Now that we've planned out our sequence, we can start programming our keyframes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating keyframes</h1>
                
            
            
                
<p>We need to make a keyframe array for each servo in our servos group, for each cue point: two arrays of five keyframes each.</p>
<p>That sounds simple enough, but how do we tell the animation to let the servos start wherever they happen to be? And how do we tween <kbd>servoTwo</kbd> across two cue points in its move to <kbd>90</kbd> degrees? The answer lies in the way Johnny-Five parses null and false as servo positions in keyframes.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using null and false as positions in keyframes</h1>
                
            
            
                
<p>Null and false are used by Johnny-Five to allow us to create complex segments where we can tween between multiple cue points or use the last known position of a servo as a keyframe position.</p>
<p>The effect of null depends on where it is used, if it is used in the first keyframe, it uses the position of the servo as the animation begins as that keyframe's position. This is exactly what we need to start our animation sequence, as we want both servos to start at wherever they happen to be. If null is used in a keyframe that is not the first, then the keyframe will essentially be ignored at that cue point; if you have 30 in one keyframe, null in the next, and 120 in the third, the servo will move <kbd>90</kbd> degrees over the two cue points. We will use this to allow <kbd>servoTwo</kbd> to move from <kbd>180</kbd> to <kbd>90</kbd> over two cue points.</p>
<p>When you use false as a keyframe position, it will use the position set in the last keyframe. We will use this on <kbd>servoOne</kbd> when the keyframe calls for the servo to remain in its last known position, instead of hard-coding a second 180-degree position.</p>
<p>Now that we know how null and false affect our positioning in keyframes, let's program our keyframes for our planned animation sequence.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Programming our keyframes </h1>
                
            
            
                
<p>So based on the information we've been given, the values we need for each keyframe are:</p>
<ul>
<li><kbd>servoOne null</kbd>, <kbd>servoTwo null</kbd> (start wherever the servos happen to be)</li>
<li><kbd>servoOne 0</kbd>, <kbd>servoTwo 180</kbd></li>
<li><kbd>servoOne 180</kbd>, <kbd>servoTwo null</kbd> (<kbd>servoTwo</kbd> starts moving towards <kbd>90</kbd> degrees)</li>
<li><kbd>servoOne false</kbd>, <kbd>servoTwo null</kbd> (<kbd>servoOne</kbd> stays put, <kbd>servoTwo</kbd> still moving to <kbd>90</kbd> degrees)</li>
<li><kbd>servoOne 90</kbd>, <kbd>servoTwo 90</kbd></li>
</ul>
<p class="mce-root">Each position needs to be an object with a property <kbd>degrees</kbd> for each keyframe. Let's translate that into JavaScript, right under the construction of our animation object:</p>
<pre>let keyframes = [<br/> [null, {degrees: 0}, {degrees: 180}, false, {degrees:90}], // servoOne<br/> [null, {degrees: 180}, null, null, {degrees: 90}] // servoTwo<br/>]</pre>
<p>Now that we have our keyframes programmed, let's get started on our cue points.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting cue points and duration</h1>
                
            
            
                
<p>Cue points, no matter how many servos you have, will always be a one-dimensional array of times to match each keyframe in the array of keyframes you pass in.</p>
<p>Note that while the cue points in this animation are evenly spaced, that is absolutely optional your cue points can vary wildly in distance from each other without breaking anything.</p>
<p>Underneath our keyframes object, let's set up our cue points array:</p>
<pre>let cuePoints = [0, .25, .5, .75, 1]</pre>
<p>We want our animation to take 8 seconds overall, so add:</p>
<pre>let duration = 8000</pre>
<p>We have all the data we need, let's make an animation!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Putting it all together to make an animation</h1>
                
            
            
                
<p>In order to run our animation sequence, we have to place it in the queue using the <kbd>Animation.enqueue()</kbd> function. We'll need to pass in the duration, keyframes, and cue points together. In your <kbd>my-first-animation.js</kbd>, after the duration, add:</p>
<pre>myFirstAnimation.enqueue({<br/> duration: duration,<br/> keyFrames: keyframes,<br/> cuePoints: cuePoints<br/>})</pre>
<p>The object containing the duration, <kbd>keyFrames</kbd>, and <kbd>cuePoints</kbd> properties is known within the animation library as a <kbd>Segment</kbd> object.</p>
<p>The animation segment will immediately begin to play upon queuing, so we're ready to load our project in and see some animated servos!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Watching your animation at work</h1>
                
            
            
                
<p>Load your <kbd>project</kbd> folder onto the Pi, navigate into the folder in your Pi SSH session, and run:</p>
<pre><strong>sudo node my-first-animation.js</strong></pre>
<p class="mce-root"/>
<p>You should see the animation play out with the two servos as we described it.</p>
<p>This is really powerful, but when you think of a walking hexapod, these linear movements wouldn't make for a realistic or pretty gait. Let's add some easing into our animation sequence in order to create some more organic-looking movement.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Easing into your servo animations</h1>
                
            
            
                
<p>Unless you want any of your future walking bots to be very firmly in the uncanny valley, you'll need to use easing to create a more fluid, natural motion with your animation segments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How easing fits into an animation segment</h1>
                
            
            
                
<p>Easing functions are added into the <kbd>keyframes</kbd> of a servo; so not only are we saying what position we want the servo to be, but how it gets there. For example, these <kbd>keyframes</kbd>:</p>
<pre>let keyframes = [<br/>  null,<br/>  {degrees: 180, easing: 'inoutcirc'}<br/>]</pre>
<p>Will take a servo starting at any position and move it to <kbd>180</kbd>, starting out slow, speeding up in the middle, and slowing down again towards the end.</p>
<p>There are many different options for easing, and they are documented in the ease-component (<a href="https://www.npmjs.com/package/ease-component">https://www.npmjs.com/package/ease-component</a>) <kbd>npm</kbd> module included as a dependency to Johnny-Five. We'll be using <kbd>incirc</kbd>, <kbd>outcirc</kbd>, and <kbd>inoutcirc</kbd> to start.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding easing to our first animation</h1>
                
            
            
                
<p>Copy the contents of <kbd>my-first-animation.js</kbd> into a new file called <kbd>easing-animations.js</kbd>. Next, we'll modify the <kbd>keyframes</kbd> array to include some easing:</p>
<pre>let keyframes = [<br/> [null, {degrees: 0}, {degrees: 180, easing: 'inOutCirc'}, false, {degrees:90, easing:'outCirc'}], // servoOne<br/> [null, {degrees: 180}, null, null, {degrees: 90, easing:'inCirc'}] // servoTwo<br/>]</pre>
<p class="mce-root"/>
<p>Let's also increase the duration of the animation segment so we can really see the difference easing makes:</p>
<pre>let duration = 16000</pre>
<p>Then, load it onto the Pi, navigate to the folder in your Pi SSH session, and run the following command:</p>
<pre><strong>sudo node easing-animations.js</strong></pre>
<p>Really watch how <kbd>inCirc</kbd>, <kbd>outCirc</kbd>, and <kbd>inOutCirc</kbd> affect your animation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Easing an entire animation segment</h1>
                
            
            
                
<p>In order to easily set all keyframes in an animation segment to have the same easing, you can pass an <kbd>easing</kbd> property when you enqueue your segment. For example:</p>
<pre>myFirstAnimation.enqueue({<br/>  keyFrames: keyframes,<br/>  duration: duration,<br/>  cuePoints: cuePoints,<br/>  easing: 'inOutCirc'<br/>})</pre>
<p>The preceding code will override the keyframes and all of them will use <kbd>inOutCirc</kbd> easing. Now that we've fully explored easing our animation segments, let's take a look at the animation queue and how we can affect our segments when we queue them and when they're playing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning more about queuing and playing animation segments</h1>
                
            
            
                
<p>When we queue an animation segment, we pass it a duration, cue points, and keyframes. But we can also pass in other options that affect the playback of the animation segment. We can also call methods on the animation object that affect animation segments currently playing and in the queue.</p>
<p>Before we start messing with these, copy the content of <kbd>easing-animations.js</kbd> into a new file called <kbd>playing-with-the-queue.js</kbd>. Remove the call to <kbd>myFirstAnimation.enqueue()</kbd> at the end; we want a little control when we get into the REPL this time around.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Looping animation segments</h1>
                
            
            
                
<p>First, let's add a function that will enqueue our animation normally:</p>
<pre>function playMyAnimation() {<br/>  myFirstAnimation.enqueue({<br/>    keyFrames: keyframes,<br/>    duration: duration,<br/>    cuePoints: cuePoints<br/>  })<br/>}</pre>
<p>Sometimes you want the animation segment you are enqueuing to run on a loop. Let's create a function in our <kbd>board.on('ready')</kbd> handler that will enqueue our animation segment on a loop:</p>
<pre>function loopMyAnimation() {<br/>  myFirstAnimation.enqueue({<br/>    keyFrames: keyframes,<br/>    duration: duration,<br/>    cuePoints: cuePoints,<br/>    loop: true<br/>  })<br/>}</pre>
<p>You can also add the <kbd>loopBackTo</kbd> property, and set it to the index of a cue point; the animation will start its loop from the designated cue point.</p>
<p>What if we want the animation to play forward, then back to the start, and repeat? Let's write a function that will set the <kbd>metronomic</kbd> property to do just that:</p>
<pre>function metronomeMyAnimation() {<br/>  myFirstAnimation.enqueue({<br/>    keyFrames: keyframes,<br/>    duration: duration,<br/>    cuePoints: cuePoints,<br/>    metronomic: true<br/>  })<br/>}</pre>
<p>Now that we know how to loop and metronome our animation segments, let's explore changing the speed of animation segments using the animation object.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the speed of animation segments</h1>
                
            
            
                
<p>You can call <kbd>Animation.speed()</kbd> with a numeric multiplier to change the speed of the current animation segment. For instance, calling <kbd>Animation.speed(.5)</kbd> will halve the speed, and <kbd>Animation.speed(2)</kbd> will double it.</p>
<p>Let's write some functions to half, double, and normalize our animation segment speed:</p>
<pre>function halfSpeed() {<br/> myFirstAnimation.speed(.5)<br/>}<br/><br/>function doubleSpeed() {<br/> myFirstAnimation.speed(2)<br/>}<br/><br/>function regularSpeed() {<br/> myFirstAnimation.speed(1)<br/>}</pre>
<p>Add these to the loop and metronome functions.</p>
<p>Now that we know how to adjust the speed of animation functions, as well as how to loop them, let's talk about pausing, playing, and stopping animations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing, pausing, and stopping animation segments</h1>
                
            
            
                
<p>If left alone, the animation segments will be played until there is nothing left in the queue to play (meaning if there is a looped or metronome segment, it will stay on that segment).</p>
<p>But you can move to the next animation:</p>
<pre>Animation.next()</pre>
<p>Or you can pause the current segment:</p>
<pre>Animation.pause()</pre>
<p>Start it up again:</p>
<pre>Animation.play()</pre>
<p class="mce-root"/>
<p>Or stop the current segment and clear out the entire queue:</p>
<pre>Animation.stop()</pre>
<p>Let's use these, along with the REPL, to play with our animation and our new-found powers to manipulate it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tying it all together in the REPL</h1>
                
            
            
                
<p>Add the following to the end of the <kbd>board.on('ready')</kbd> handler in <kbd>playing-with-the-queue.js</kbd>:</p>
<pre>board.repl.inject({<br/>  myFirstAnimation,<br/>  playMyAnimation,<br/>  loopMyAnimation,<br/>  metronomeMyAnimation,<br/>  halfSpeed,<br/>  doubleSpeed,<br/>  normalSpeed<br/>})</pre>
<p>Then, load your <kbd>project</kbd> folder onto your Pi, navigate to the <kbd>project</kbd> folder in your Pi SSH session, and run the following command:</p>
<pre><strong>sudo node playing-with-the-queue.js</strong></pre>
<p>Once you see <kbd>Board Initialized</kbd>, try a few commands to experiment with how your animation plays:</p>
<pre><strong>loopMyAnimation()</strong><br/><strong>myFirstAnimation.pause()</strong><br/><strong>myFirstAnimation.play()</strong><br/><strong>halfSpeed()</strong><br/><strong>myFirstAnimation.stop()</strong><br/><strong>metronomeMyAnimation()</strong><br/><strong>doubleSpeed()</strong><br/><strong>playMyAnimation()</strong><br/><strong>myFirstAnimation.next()Summary</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we dived into the animation library with servos. We learned the key terminology for the animation library, how to construct an animation segment, how to queue it, and how to manipulate playback, both when queuing the segments or by calling methods of the animation object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Why are animations necessary for complex movements with multiple servos?</li>
<li>What is a keyframe? </li>
<li>What is a cue point?</li>
<li>Name the three pieces of an animation segment.</li>
<li>What does easing do to our animation keyframes and segments?</li>
<li>What method of the animation object stops the current segment and clears the animation queue?</li>
<li>What does calling <kbd>Animation.speed(.25)</kbd> do to the current animation?</li>
</ol>


            

            
        
    </body></html>