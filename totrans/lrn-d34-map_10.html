<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Adding Interactivity to Your Canvas Map</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the preceding chapter, you saw one of the shining qualities of Canvas in action – animating thousands of points on the screen in a smooth animation. </span><span class="koboSpan" id="kobo.2.2">In this chapter, you will deal with one Canvas caveat: interaction. </span><span class="koboSpan" id="kobo.2.3">While interaction with HTML or SVG elements is straightforward, it requires a little more thought and some tricks to achieve with Canvas. </span><span class="koboSpan" id="kobo.2.4">In this chapter, you will follow along these thoughts and learn the tricks needed to do the following things:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Making a globe move, and adding zoom and rotation interaction to it</span></li>
<li><span class="koboSpan" id="kobo.4.1">Learning how to interact with Canvas elements through </span><strong><span class="koboSpan" id="kobo.5.1">picking</span></strong></li>
<li><span class="koboSpan" id="kobo.6.1">Retrieving data from a Canvas element to display it in a tooltip</span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">After this chapter, you will have covered all important facets of Canvas, drawing, animating, and, finally, interacting with Canvas.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Why Canvas interaction is different</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the preceding chapter, you achieved a smooth animation of thousands of points by doing away with the DOM. </span><span class="koboSpan" id="kobo.2.2">The DOM is a representation of each element in browser memory. </span><span class="koboSpan" id="kobo.2.3">Bypassing it, you were dealing with much less overhead during animation. </span><span class="koboSpan" id="kobo.2.4">However, the DOM can be very useful for other goals in web development. </span><span class="koboSpan" id="kobo.2.5">High up on that list – especially for data visualization – is the </span><strong><span class="koboSpan" id="kobo.3.1">interaction</span></strong><span class="koboSpan" id="kobo.4.1"> with elements on screen.</span></p>
<p><span class="koboSpan" id="kobo.5.1">You can just add an </span><kbd><span class="koboSpan" id="kobo.6.1">onmousemove</span></kbd><span class="koboSpan" id="kobo.7.1"> or </span><kbd><span class="koboSpan" id="kobo.8.1">onclick</span></kbd><span class="koboSpan" id="kobo.9.1"> listener to an element. </span><span class="koboSpan" id="kobo.9.2">You can’t do that to elements on a Canvas. </span><span class="koboSpan" id="kobo.9.3">They are a pixel manifestation of past code, not represented as a model within the browser.</span></p>
<p><span class="koboSpan" id="kobo.10.1">However, don’t despair, there are indirect yet simple techniques to interact with your Canvas. </span><span class="koboSpan" id="kobo.10.2">We’ll be looking at the most important techniques in this chapter, building an interactive globe:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1"><img height="345" width="550" src="assets/56ecc99f-4a88-4175-9571-e33a954922e0.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1">A map of the world’s forest cover by country</span></div>
<p><span class="koboSpan" id="kobo.13.1">Leaving flying planes behind, you will build a globe showing </span><span><span class="koboSpan" id="kobo.14.1">each country's</span></span><span class="koboSpan" id="kobo.15.1"> forest cover percentage. </span><span class="koboSpan" id="kobo.15.2">The greener a country is (you guessed it), the higher the forest cover. </span><span class="koboSpan" id="kobo.15.3">As you can see in the preceding figure, you will have a tooltip showing country-specific information when hovering over each country. </span><span class="koboSpan" id="kobo.15.4">Users will further be able to rotate the globe and zoom into specific areas at their leisure.</span></p>
<div class="packt_infobox"><span><span class="koboSpan" id="kobo.16.1">You can view the final app at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-10-4"><span class="koboSpan" id="kobo.17.1">https://larsvers.github.io/learning-d3-mapping-10-4</span></a><span class="koboSpan" id="kobo.18.1"> and a c</span><a href="https://larsvers.github.io/learning-d3-mapping-10-4"><span><span class="koboSpan" id="kobo.19.1">ode example at</span></span></a> <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html"><span class="koboSpan" id="kobo.20.1">10_04.html</span></a><span><span class="koboSpan" id="kobo.21.1">.</span></span></div>
<div class="packt_tip">
<p><span class="koboSpan" id="kobo.22.1">At </span><span><span class="koboSpan" id="kobo.23.1">the conclusion of each step, you will find two links in an info box close to the relevant image</span></span><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">The first link brings you to a working implementation of this step that you can view in the browser. </span><span class="koboSpan" id="kobo.24.3">The second </span><em><span class="koboSpan" id="kobo.25.1">code example</span></em><span class="koboSpan" id="kobo.26.1"> link brings you to the full code. </span><span class="koboSpan" id="kobo.26.2">If you're reading the print version, you can find all code examples at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping"><span class="koboSpan" id="kobo.27.1">https://github.com/larsvers/Learning-D3.js-4-Mapping</span></a><span class="koboSpan" id="kobo.28.1"> in their relevant chapter.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing the world on a Canvas</span></h1>
                </header>
            
            <article>
                
<p class="NormalPACKT"><span><span class="koboSpan" id="kobo.2.1">Let’s start drawing a globe. </span><span class="koboSpan" id="kobo.2.2">This is straightforward, very much building on the preceding chapter.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Setting up</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">First, you will create a few variables required for initialization. </span><span class="koboSpan" id="kobo.2.2">We’ll come back to this list as the application grows, but, for now, it’s lean:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">var width = 960,</span><br/><span class="koboSpan" id="kobo.4.1">    height = 600,</span><br/><span class="koboSpan" id="kobo.5.1">    projectionScale = height / 2.1,</span><br/><span class="koboSpan" id="kobo.6.1">    translation = [width / 2, height / 2];</span></pre>
<p><span class="koboSpan" id="kobo.7.1">You are setting the </span><kbd><span class="koboSpan" id="kobo.8.1">width</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">height</span></kbd><span class="koboSpan" id="kobo.11.1"> of the Canvas as well as the scale and the translation of the globe. </span><span class="koboSpan" id="kobo.11.2">Each projection has their own ideal starting scale. </span><span class="koboSpan" id="kobo.11.3">You can play with this number to find the right scale. </span><span class="koboSpan" id="kobo.11.4">You will use the </span><kbd><span class="koboSpan" id="kobo.12.1">width</span></kbd><span class="koboSpan" id="kobo.13.1"> and </span><kbd><span class="koboSpan" id="kobo.14.1">height</span></kbd><span class="koboSpan" id="kobo.15.1"> straight away, setting up the Canvas and its context:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.16.1">var canvas = d3.select('#canvas-container').append('canvas')</span><br/><span class="koboSpan" id="kobo.17.1">    .attr('id', 'canvas-globe')</span><br/><span class="koboSpan" id="kobo.18.1">    .attr('width', width)</span><br/><span class="koboSpan" id="kobo.19.1">    .attr('height', height);</span><br/><span class="koboSpan" id="kobo.20.1">var context = canvas.node().getContext('2d');</span></pre>
<p><span class="koboSpan" id="kobo.21.1">No magic here. </span><span class="koboSpan" id="kobo.21.2">Note that we have a </span><kbd><span class="koboSpan" id="kobo.22.1">div</span></kbd><span class="koboSpan" id="kobo.23.1"> with the </span><kbd><span class="koboSpan" id="kobo.24.1">#canvas-container</span></kbd><span class="koboSpan" id="kobo.25.1"> ID in our HTML, in which you add the main Canvas.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Let’s also produce a </span><kbd><span class="koboSpan" id="kobo.27.1">bufferCanvas</span></kbd><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">You learned about the benefits of buffer Canvases in the preceding chapter. </span><span class="koboSpan" id="kobo.28.3">In short, rendering an image in memory and copying it onto your main Canvas is more performant than rendering an image directly onto the main Canvas:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.29.1">var bufferCanvas = document.createElement('canvas');</span><br/><span class="koboSpan" id="kobo.30.1">var bufferContext = bufferCanvas.getContext('2d');</span><br/><br/><span class="koboSpan" id="kobo.31.1">bufferContext.canvas.width = width;</span><br/><span class="koboSpan" id="kobo.32.1">bufferContext.canvas.height = height;</span></pre>
<p><span><span class="koboSpan" id="kobo.33.1">A rather central part of building a globe is the right projection. </span><span class="koboSpan" id="kobo.33.2">Building a globe reduces our options dramatically to the </span><kbd><span class="koboSpan" id="kobo.34.1">d3.geoOrthographic()</span></kbd><span class="koboSpan" id="kobo.35.1"> projection, a 2D globe projection which is part of the standard d3-geo module. </span><span class="koboSpan" id="kobo.35.2">You already used it in </span><a href="d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml"><span class="koboSpan" id="kobo.36.1">chapter 5</span></a><span class="koboSpan" id="kobo.37.1">, </span><em><span class="koboSpan" id="kobo.38.1">Click-Click Boom! </span><span class="koboSpan" id="kobo.38.2">Applying Interactivity to Your Map</span></em><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">Let's set it up first:</span></span></p>
<pre><span class="koboSpan" id="kobo.40.1">var projection = d3.geoOrthographic()</span><br/><span class="koboSpan" id="kobo.41.1">    .scale(projectionScale)</span><br/><span class="koboSpan" id="kobo.42.1">    .translate(translation)</span><br/><span class="koboSpan" id="kobo.43.1">    .clipAngle(90);</span></pre>
<p><span class="koboSpan" id="kobo.44.1">We applied the scale and translation array we specified above, as well as the </span><kbd><span class="koboSpan" id="kobo.45.1">.clipAngle()</span></kbd><span class="koboSpan" id="kobo.46.1"> to 90 degrees to always clip the backside of the projection, our globe.</span></p>
<p><span class="koboSpan" id="kobo.47.1">As we use the </span><kbd><span class="koboSpan" id="kobo.48.1">bufferCanvas</span></kbd><span class="koboSpan" id="kobo.49.1"> for all our drawings, we will tie our projection to a path generator that will exclusively draw to the buffer Canvas , as follows:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.50.1">var bufferPath = d3.geoPath()</span><br/><span class="koboSpan" id="kobo.51.1">    .projection(projection)</span><br/><span class="koboSpan" id="kobo.52.1">    .context(bufferContext);</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.53.1">There are two more geo helpers you will create: a base </span><strong><span class="koboSpan" id="kobo.54.1">sphere</span></strong><span class="koboSpan" id="kobo.55.1"> and a </span><strong><span class="koboSpan" id="kobo.56.1">graticule</span></strong><span class="koboSpan" id="kobo.57.1">:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.58.1">var sphere = { type: 'Sphere' };</span><br/><span class="koboSpan" id="kobo.59.1">var grid = d3.geoGraticule()();</span></pre>
<p><span><span class="koboSpan" id="kobo.60.1">Both are geo-visualization primitives. </span><span class="koboSpan" id="kobo.60.2">The</span></span> <strong><span class="koboSpan" id="kobo.61.1">sphere</span></strong> <span><span class="koboSpan" id="kobo.62.1">is, well, a sphere you use to underlay your globe with. </span><span class="koboSpan" id="kobo.62.2">You can then fill it or give it an outline to give your globe a round shape beyond the countries. </span><span class="koboSpan" id="kobo.62.3">A</span></span> <strong><span class="koboSpan" id="kobo.63.1">graticule</span></strong> <span><span class="koboSpan" id="kobo.64.1">is a grid of the main meridians (longitude lines) and parallels (latitude lines) 10 degrees apart from each other (and, yes, you need four parentheses to produce the actual graticule object). </span><span class="koboSpan" id="kobo.64.2">We shall see them in action very soon.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing the world</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The scene is set. </span><span class="koboSpan" id="kobo.2.2">In this section, you will load some country shape data to draw the world. </span><span class="koboSpan" id="kobo.2.3">You will set up four small functions to achieve the draw:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">A </span><kbd><span class="koboSpan" id="kobo.4.1">data load</span></kbd><span class="koboSpan" id="kobo.5.1"> function</span></li>
<li><span class="koboSpan" id="kobo.6.1">A </span><kbd><span class="koboSpan" id="kobo.7.1">ready()</span></kbd><span class="koboSpan" id="kobo.8.1"> function that prepares the data and passes it on to the render function</span></li>
<li><span class="koboSpan" id="kobo.9.1">A </span><kbd><span class="koboSpan" id="kobo.10.1">renderScene()</span></kbd><span class="koboSpan" id="kobo.11.1"> function that kicks off the world draw and copies the final image from the buffer onto the main Canvas</span></li>
<li><span class="koboSpan" id="kobo.12.1">A </span><kbd><span class="koboSpan" id="kobo.13.1">drawScene()</span></kbd><span class="koboSpan" id="kobo.14.1"> function that renders the world onto the </span><kbd><span class="koboSpan" id="kobo.15.1">bufferCanvas</span></kbd><span class="koboSpan" id="kobo.16.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">This might sound overkill for just drawing a static globe, and let me assure you it is. </span><span class="koboSpan" id="kobo.17.2">However, we are aiming for higher goals, which will be greatly helped by having this structure set up already.</span></p>
<p><span class="koboSpan" id="kobo.18.1">The data load function just requests the data and passes it on to the </span><kbd><span class="koboSpan" id="kobo.19.1">ready()</span></kbd><span class="koboSpan" id="kobo.20.1"> function:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.21.1">d3.json('../../data/world/world-110.json', function(error, data) {</span><br/><span class="koboSpan" id="kobo.22.1">  if(error) throw error;</span><br/><span class="koboSpan" id="kobo.23.1">  ready(data);</span><br/><span class="koboSpan" id="kobo.24.1">});</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.25.1">The </span><kbd><span class="koboSpan" id="kobo.26.1">ready()</span></kbd><span class="koboSpan" id="kobo.27.1"> function doesn’t really add much more complexity so far:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.28.1">function ready(world) {</span><br/><span class="koboSpan" id="kobo.29.1">  var countries = topojson.feature(world,</span><br/><span class="koboSpan" id="kobo.30.1">  world.objects.ne_110m_admin_0_countries); </span><br/><span class="koboSpan" id="kobo.31.1">  renderScene(countries);</span><br/><span class="koboSpan" id="kobo.32.1">}</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.33.1">It turns the TopoJSON to an array of GeoJSON </span><kbd><span class="koboSpan" id="kobo.34.1">countries</span></kbd><span class="koboSpan" id="kobo.35.1"> and calls </span><kbd><span class="koboSpan" id="kobo.36.1">renderScene()</span></kbd><span class="koboSpan" id="kobo.37.1">. </span><kbd><span class="koboSpan" id="kobo.38.1">renderScene()</span></kbd><span class="koboSpan" id="kobo.39.1"> does what we’ve already described in the preceding code. </span><span class="koboSpan" id="kobo.39.2">It draws the globe on the </span><kbd><span class="koboSpan" id="kobo.40.1">bufferContext</span></kbd><span class="koboSpan" id="kobo.41.1"> in thin air, and as soon as it’s done, copies it over to the freshly cleared main Canvas:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.42.1">function renderScene(world){</span><br/><span class="koboSpan" id="kobo.43.1">  drawScene(world);</span><br/><span class="koboSpan" id="kobo.44.1">  context.clearRect(0, 0, width, height);</span><br/><span class="koboSpan" id="kobo.45.1">  context.drawImage(bufferCanvas, 0, 0, bufferCanvas.width,</span><br/><span class="koboSpan" id="kobo.46.1">  bufferCanvas.height);</span><br/><span class="koboSpan" id="kobo.47.1">}</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.48.1">Although </span><kbd><span class="koboSpan" id="kobo.49.1">drawScene()</span></kbd><span class="koboSpan" id="kobo.50.1"> is our longest function, it’s not very complex:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.51.1">function drawScene(countries) {</span><br/> <br/><span class="koboSpan" id="kobo.52.1">  bufferContext.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);</span><br/><span class="koboSpan" id="kobo.53.1">  // Sphere fill</span><br/><span class="koboSpan" id="kobo.54.1">  bufferContext.beginPath(); </span><br/><span class="koboSpan" id="kobo.55.1">  bufferPath(sphere);</span><br/><span class="koboSpan" id="kobo.56.1">  bufferContext.fillStyle = '#D9EAEF';</span><br/><span class="koboSpan" id="kobo.57.1">  bufferContext.fill();</span><br/>  <br/><span class="koboSpan" id="kobo.58.1">  // Grid</span><br/><span class="koboSpan" id="kobo.59.1">  bufferContext.beginPath();</span><br/><span class="koboSpan" id="kobo.60.1">  bufferPath(grid);</span><br/><span class="koboSpan" id="kobo.61.1">  bufferContext.lineWidth = 0.5;</span><br/><span class="koboSpan" id="kobo.62.1">  bufferContext.strokeStyle = '#BDDAE3';</span><br/><span class="koboSpan" id="kobo.63.1">  bufferContext.stroke();</span><br/><br/><span class="koboSpan" id="kobo.64.1">  // Country fill</span><br/><span class="koboSpan" id="kobo.65.1">  bufferContext.beginPath();</span><br/><span class="koboSpan" id="kobo.66.1">  bufferPath(countries);</span><br/><span class="koboSpan" id="kobo.67.1">  bufferContext.fillStyle = '#FFFAFA';</span><br/><span class="koboSpan" id="kobo.68.1">  bufferContext.fill();</span><br/><br/><span class="koboSpan" id="kobo.69.1">  // Country stroke</span><br/><span class="koboSpan" id="kobo.70.1">  bufferContext.beginPath();</span><br/><span class="koboSpan" id="kobo.71.1">  bufferPath(countries);</span><br/><span class="koboSpan" id="kobo.72.1">  bufferContext.lineWidth = 0.5;</span><br/><span class="koboSpan" id="kobo.73.1">  bufferContext.strokeStyle = '#D2D3CE';</span><br/><span class="koboSpan" id="kobo.74.1">  bufferContext.stroke();</span><br/><br/><span class="koboSpan" id="kobo.75.1">}</span></pre>
<p><span class="koboSpan" id="kobo.76.1">It clears the </span><kbd><span class="koboSpan" id="kobo.77.1">buffer</span></kbd><span class="koboSpan" id="kobo.78.1"> context, then draws a base sphere in a light blue and a graticule grid in a slightly more saturated blue. </span><span class="koboSpan" id="kobo.78.2">It then fills the countries in a light gray color and strokes each country in a darker gray. </span><span class="koboSpan" id="kobo.78.3">That’s it. </span><span class="koboSpan" id="kobo.78.4">Here’s your very own Canvas globe:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.79.1"><img height="262" width="415" src="assets/6915f37c-f7cf-4031-9c94-d8b518d15d60.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.80.1">A static Canvas globe</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.81.1">View this step in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-10-1"><span class="koboSpan" id="kobo.82.1">https://larsvers.github.io/learning-d3-mapping-10-1</span></a><span class="koboSpan" id="kobo.83.1"> and a code example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_01.html"><span class="koboSpan" id="kobo.84.1">10_01.html</span></a><span class="koboSpan" id="kobo.85.1">.</span></div>
<p><span class="koboSpan" id="kobo.86.1">Great! </span><span class="koboSpan" id="kobo.86.2">You learned to draw a Canvas globe, which is nice, even if a little mono-dimensional. </span><span class="koboSpan" id="kobo.86.3">So, let’s add our first bit of interaction with it and let the users (and ourselves) zoom and rotate the globe.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Making the world move</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Zooming into and rotating a globe projection is a truly joyous pastime, I find. </span><span class="koboSpan" id="kobo.2.2">Apart from being such fun, it’s also extremely useful when dealing with globe projections, as the user needs to be able to view the world from different angles.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In this section, we will add our first bit of Canvas interactivity to the globe. </span><span class="koboSpan" id="kobo.3.2">We will equip the users with the ability to zoom into and rotate the globe. </span><span class="koboSpan" id="kobo.3.3">Apart from setting up two additional global variables, we will exclusively do work in the </span><kbd><span class="koboSpan" id="kobo.4.1">ready()</span></kbd><span class="koboSpan" id="kobo.5.1"> function–our central function tasked to prepare the data. </span><span class="koboSpan" id="kobo.5.2">From now onward, it will also deal with interactivity, right here:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.6.1">function ready(world) {</span><br/><span class="koboSpan" id="kobo.7.1">  var countries = topojson.feature(world, </span><br/><span class="koboSpan" id="kobo.8.1">  world.objects.ne_110m_admin_0_countries);</span><br/><span class="koboSpan" id="kobo.9.1">  requestAnimationFrame(function() {</span><br/><span class="koboSpan" id="kobo.10.1">    renderScene(countries);</span><br/><span class="koboSpan" id="kobo.11.1">  });</span><br/><br/><span class="koboSpan" id="kobo.12.1">  /* Interactivity goes here */</span><br/><span class="koboSpan" id="kobo.13.1">}</span></pre>
<p><span class="koboSpan" id="kobo.14.1">Also, note that we wrapped our </span><kbd><span class="koboSpan" id="kobo.15.1">renderScene()</span></kbd><span class="koboSpan" id="kobo.16.1"> function into a </span><kbd><span class="koboSpan" id="kobo.17.1">requestAnimationFrame()</span></kbd><span class="koboSpan" id="kobo.18.1"> function to always let the browser decide the best time point for a new render.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Note, that here is a prominent and often preferred way to deal with zooming and panning (not so much rotating) in D3 using </span><kbd><span class="koboSpan" id="kobo.20.1">context.scale()</span></kbd><span class="koboSpan" id="kobo.21.1"> and </span><kbd><span class="koboSpan" id="kobo.22.1">context.translate()</span></kbd><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">However, to implement both zooming and rotating, we won’t use these in-built methods, but will change the projection instead. </span><span class="koboSpan" id="kobo.23.3">We’ll get back to the why a little later as it becomes clear on the way.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Setting up the behavior</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Zooming is no more than changing the scale for our projection. </span><span class="koboSpan" id="kobo.2.2">Rotating is no more than changing the rotation values of our projection. </span><span class="koboSpan" id="kobo.2.3">When you want the user to mandate zoom and rotation, you will need to listen to their mouse movement. </span><span class="koboSpan" id="kobo.2.4">As such, you will need to set up a zoom listener to track the user's mouse wheel and drag moves, and attach it to the Canvas. </span><span class="koboSpan" id="kobo.2.5">We implemented zoom and rotation already in </span><a href="d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml"><span class="koboSpan" id="kobo.3.1">chapter 5</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Click-Click Boom! </span><span class="koboSpan" id="kobo.5.2">Applying Interactivity to Your Map</span></em><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">In our </span><kbd><span class="koboSpan" id="kobo.7.1">ready()</span></kbd><span class="koboSpan" id="kobo.8.1"> function, as specified above, we will use D3’s zoom behavior to deliver all the user interaction changes we need:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.9.1">var zoom = d3.zoom()</span><br/><span class="koboSpan" id="kobo.10.1">   .scaleExtent([0.5, 4])</span><br/><span class="koboSpan" id="kobo.11.1">   .on("zoom", zoomed);</span><br/><br/><span class="koboSpan" id="kobo.12.1">canvas.call(zoom);</span><br/><br/><span class="koboSpan" id="kobo.13.1">function zoomed() { // our handler code goes here }</span></pre>
<p><span class="koboSpan" id="kobo.14.1">First, you create the zoom behavior with </span><kbd><span class="koboSpan" id="kobo.15.1">d3.zoom()</span></kbd><span class="koboSpan" id="kobo.16.1">, define scaling bounds between </span><em><span class="koboSpan" id="kobo.17.1">0.5</span></em><span class="koboSpan" id="kobo.18.1"> and </span><em><span class="koboSpan" id="kobo.19.1">4</span></em><span class="koboSpan" id="kobo.20.1">, and inform the behavior to trigger our </span><kbd><span class="koboSpan" id="kobo.21.1">zoomed()</span></kbd><span class="koboSpan" id="kobo.22.1"> handler as soon as a </span><kbd><span class="koboSpan" id="kobo.23.1">“zoom”</span></kbd><span class="koboSpan" id="kobo.24.1"> event has been triggered. </span><span class="koboSpan" id="kobo.24.2">However, so far, this has been a blunt tool. </span><span class="koboSpan" id="kobo.24.3">To understand what it does, you have to call it on an element. </span><span class="koboSpan" id="kobo.24.4">Call it on your Canvas element, and that element will be the sensor of all zoom-related user events. </span><span class="koboSpan" id="kobo.24.5">Importantly, it will listen for mouse wheel and drag events and expose the event information in the global </span><kbd><span class="koboSpan" id="kobo.25.1">d3.event</span></kbd><span class="koboSpan" id="kobo.26.1"> object. </span><span class="koboSpan" id="kobo.26.2">It will further store the information in the base element it got called on (in our case, the main Canvas), but we’ll be happily served by the </span><kbd><span class="koboSpan" id="kobo.27.1">d3.event</span></kbd><span class="koboSpan" id="kobo.28.1"> object you can tap into at each event.</span></p>
<p><span class="koboSpan" id="kobo.29.1">Further, we want to set up some variables for tracking our scale and rotation whereabouts during zoom. </span><span class="koboSpan" id="kobo.29.2">We do this at the very top of our code with the following global variables:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">var width = 960,</span><br/><span class="koboSpan" id="kobo.31.1">    height = 600,</span><br/><span class="koboSpan" id="kobo.32.1">    projectionScale = origProjectionScale = height / 2.1,</span><br/><span class="koboSpan" id="kobo.33.1">    translation = [width / 2, height / 2],</span><br/><span class="koboSpan" id="kobo.34.1">    projectionScaleChange,</span><br/><span class="koboSpan" id="kobo.35.1">    prevTransformScale = 1,</span><br/><span class="koboSpan" id="kobo.36.1">    rotation;</span></pre>
<p><span class="koboSpan" id="kobo.37.1">The newcomers in the preceding code are </span><kbd><span class="koboSpan" id="kobo.38.1">origProjectionScale</span></kbd><span class="koboSpan" id="kobo.39.1">, </span><kbd><span class="koboSpan" id="kobo.40.1">projectionScaleChange</span></kbd><span class="koboSpan" id="kobo.41.1">, </span><kbd><span class="koboSpan" id="kobo.42.1">prevTransformScale</span></kbd><span class="koboSpan" id="kobo.43.1">, and </span><kbd><span class="koboSpan" id="kobo.44.1">rotation</span></kbd><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">Their mission will become clear in the following paragraphs.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Handling zoom and rotation</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We set up the zoom behavior, meaning that our Canvas is</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">listening on every mouse wheel and drag</span></li>
<li><span class="koboSpan" id="kobo.4.1">firing the </span><kbd><span class="koboSpan" id="kobo.5.1">zoomed()</span></kbd><span class="koboSpan" id="kobo.6.1"> handler on each of these events</span></li>
</ol>
<p><span class="koboSpan" id="kobo.7.1">Let’s now fill our handler to do something to the globe.</span></p>
<p><span class="koboSpan" id="kobo.8.1">What do we want to do? </span><span class="koboSpan" id="kobo.8.2">From a bird’s perspective, for each zoom, we want to establish the scale for the projection, apply it to the path, and redraw the globe a little bit bigger or a little smaller. </span><span class="koboSpan" id="kobo.8.3">For each drag, we would want to establish the new rotation values, apply them to the projection and path, and redraw the globe a little bit rotated. </span><span class="koboSpan" id="kobo.8.4">To get there, the handler should distinguish between a zoom and a drag. </span><span class="koboSpan" id="kobo.8.5">A zoom should lead to a projection-scale change and a drag should lead to a rotation change. </span><span class="koboSpan" id="kobo.8.6">For each path, you calculate the position change. </span><span class="koboSpan" id="kobo.8.7">Once that’s done, you will need to redraw the globe. </span><span class="koboSpan" id="kobo.8.8">It’s the game-loop mantra: process user-input, clear the Canvas, then redraw the Canvas with updated data.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Let’s start with the zoom action:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">function zoomed() {</span><br/><span class="koboSpan" id="kobo.11.1">  var event = d3.event.sourceEvent.type;     </span><br/><br/><span class="koboSpan" id="kobo.12.1">  if (event === 'wheel') {</span><br/><span class="koboSpan" id="kobo.13.1">    var transformScale = d3.event.transform.k;</span><br/><span class="koboSpan" id="kobo.14.1">    projectionScaleChange = (transformScale – prevTransformScale) *</span><br/><span class="koboSpan" id="kobo.15.1">    origProjectionScale;</span><br/><span class="koboSpan" id="kobo.16.1">    projectionScale = projectionScale + projectionScaleChange;</span><br/><span class="koboSpan" id="kobo.17.1">    projection.scale(projectionScale);</span><br/><span class="koboSpan" id="kobo.18.1">    prevTransformScale = transformScale;</span><br/><span class="koboSpan" id="kobo.19.1">  } else if (event === 'mousemove'){</span><br/><span class="koboSpan" id="kobo.20.1">    // Here goes the rotation logic as this will be triggered upon dragging</span><br/><span class="koboSpan" id="kobo.21.1">  }</span><br/> <br/><span class="koboSpan" id="kobo.22.1">  requestAnimationFrame(function() {</span><br/><span class="koboSpan" id="kobo.23.1">    renderScene(countries);</span><br/><span class="koboSpan" id="kobo.24.1">  });</span><br/><span class="koboSpan" id="kobo.25.1">}</span></pre>
<p><span class="koboSpan" id="kobo.26.1">At first, we will need to distinguish between a zoom and a drag event. </span><span class="koboSpan" id="kobo.26.2">D3 makes this easy for us with the </span><kbd><span class="koboSpan" id="kobo.27.1">d3.event</span></kbd><span class="koboSpan" id="kobo.28.1"> object holding a </span><kbd><span class="koboSpan" id="kobo.29.1">sourceEvent</span></kbd><span class="koboSpan" id="kobo.30.1"> property specifying what event </span><kbd><span class="koboSpan" id="kobo.31.1">type</span></kbd><span class="koboSpan" id="kobo.32.1"> the user triggers. </span><span class="koboSpan" id="kobo.32.2">If it’s a </span><kbd><span class="koboSpan" id="kobo.33.1">wheel</span></kbd><span class="koboSpan" id="kobo.34.1"> event, we change the scale if it's a </span><kbd><span class="koboSpan" id="kobo.35.1">mousemove</span></kbd><span class="koboSpan" id="kobo.36.1"> event, we change the rotation. </span><span class="koboSpan" id="kobo.36.2">Simple.</span></p>
<p><span class="koboSpan" id="kobo.37.1">Changing the scale looks involved but is pretty straightforward. </span><span class="koboSpan" id="kobo.37.2">Before we dive into the code, let’s make one important distinction. </span><span class="koboSpan" id="kobo.37.3">The projection has a scale, and the transformation upon user zoom also has a scale. </span><span class="koboSpan" id="kobo.37.4">However, they are different. </span><span class="koboSpan" id="kobo.37.5">Projection scales differ between projections. </span><span class="koboSpan" id="kobo.37.6">Our </span><kbd><span class="koboSpan" id="kobo.38.1">d3.geoOrthographic()</span></kbd><span class="koboSpan" id="kobo.39.1"> projection has an initial scale of around </span><em><span class="koboSpan" id="kobo.40.1">286</span></em><span class="koboSpan" id="kobo.41.1"> (we set it to </span><em><span class="koboSpan" id="kobo.42.1">height / 2.1 = 286</span></em><span class="koboSpan" id="kobo.43.1">). </span><span class="koboSpan" id="kobo.43.2">Our transformation has an initial scale of </span><em><span class="koboSpan" id="kobo.44.1">1</span></em><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">That’s the default.</span></p>
<p><span class="koboSpan" id="kobo.46.1">So, you retrieve the current </span><kbd><span class="koboSpan" id="kobo.47.1">transformScale</span></kbd><span class="koboSpan" id="kobo.48.1"> via </span><kbd><span class="koboSpan" id="kobo.49.1">d3.transform.k</span></kbd><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">You note down the change of this scale to the previous transform scale, which can be negative for zoom in or positive for zoom out. </span><span class="koboSpan" id="kobo.50.3">However, as your projection scale is quite a big number (as in </span><em><span class="koboSpan" id="kobo.51.1">286</span></em><span class="koboSpan" id="kobo.52.1"> to start with) and the transform scale change per zoom will be small (for a normal mouse wheel turn the change might be around </span><em><span class="koboSpan" id="kobo.53.1">0.005</span></em><span class="koboSpan" id="kobo.54.1">), you will want to boost this number up to get a noticeable change in your projection. </span><span class="koboSpan" id="kobo.54.2">Hence, you will multiply it with a larger number. </span><span class="koboSpan" id="kobo.54.3">You can choose any large number you like, but choosing your initial projection scale we called </span><kbd><span class="koboSpan" id="kobo.55.1">origProjectionScale</span></kbd><span class="koboSpan" id="kobo.56.1"> allows you to port this calculation over to any other projection, and it should work nicely. </span><span class="koboSpan" id="kobo.56.2">You then just change the current </span><kbd><span class="koboSpan" id="kobo.57.1">projectionScale</span></kbd><span class="koboSpan" id="kobo.58.1"> by this </span><kbd><span class="koboSpan" id="kobo.59.1">projectionScaleChange.</span></kbd></p>
<p><span class="koboSpan" id="kobo.60.1">The rest is simple. </span><span class="koboSpan" id="kobo.60.2">Just apply it to your globe’s projection with </span><kbd><span class="koboSpan" id="kobo.61.1">projection.scale(projectionScale)</span></kbd><span class="koboSpan" id="kobo.62.1">, set the previous transform scale to the updated transform scale, and re-render the globe. </span><span class="koboSpan" id="kobo.62.2">Note, that you don’t need to update the path generator, as whenever it’s called, it will use the projection as is at the moment of being called, which we’ve changed accordingly.</span></p>
<p><span class="koboSpan" id="kobo.63.1">That was the hard bit. </span><span class="koboSpan" id="kobo.63.2">Rotating is even simpler. </span><span class="koboSpan" id="kobo.63.3">You just need to track the changes in the user’s mouse movements and apply them to D3’s </span><kbd><span class="koboSpan" id="kobo.64.1">projection.rotate()</span></kbd><span class="koboSpan" id="kobo.65.1"> parameters. </span><span class="koboSpan" id="kobo.65.2">Let’s track the change in mouse coordinates right at the top of the </span><kbd><span class="koboSpan" id="kobo.66.1">zoomed()</span></kbd><span class="koboSpan" id="kobo.67.1"> handler:</span></p>
<pre><span class="koboSpan" id="kobo.68.1">function zoomed(</span><br/><span class="koboSpan" id="kobo.69.1">  var dx = d3.event.sourceEvent.movementX;</span><br/><span class="koboSpan" id="kobo.70.1">  var dy = d3.event.sourceEvent.movementY;</span><br/><br/><span class="koboSpan" id="kobo.71.1">  // all the rest</span></pre>
<p><span class="koboSpan" id="kobo.72.1">Note, that the two </span><kbd><span class="koboSpan" id="kobo.73.1">MouseEvent</span></kbd><span class="koboSpan" id="kobo.74.1"> properties </span><kbd><span class="koboSpan" id="kobo.75.1">.movementX</span></kbd><span class="koboSpan" id="kobo.76.1"> and </span><span><kbd><span class="koboSpan" id="kobo.77.1">.movementY</span></kbd><span class="koboSpan" id="kobo.78.1"> are not available in Safari or Internet Explorer. </span><span class="koboSpan" id="kobo.78.2">You can see a cross-browser implementation, which is calculating the two values on the fly in code example </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html#L237"><span class="koboSpan" id="kobo.79.1">10_02.html</span></a><span class="koboSpan" id="kobo.80.1"> at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping"><span class="koboSpan" id="kobo.81.1">https://github.com/larsvers/Learning-D3.js-4-Mapping</span></a><span class="koboSpan" id="kobo.82.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">The rotation logic will trigger when the user drags or rather triggers the </span><kbd><span class="koboSpan" id="kobo.84.1">mousemove</span></kbd><span class="koboSpan" id="kobo.85.1"> event, which goes into the </span><kbd><span class="koboSpan" id="kobo.86.1">else if</span></kbd><span class="koboSpan" id="kobo.87.1"> part of our conditional:</span></p>
<pre><span class="koboSpan" id="kobo.88.1">if (event === ‘wheel’) {</span><br/><span class="koboSpan" id="kobo.89.1">  // here goes the zoom logic described previously </span><br/><span class="koboSpan" id="kobo.90.1">} else if (event === ‘mousemove’) {</span><br/><span class="koboSpan" id="kobo.91.1"> var r = projection.rotate();</span><br/><span class="koboSpan" id="kobo.92.1"> rotation = [r[0] + dx * 0.4, r[1] - dy * 0.5, r[2]];</span><br/><span class="koboSpan" id="kobo.93.1"> projection.rotate(rotation);</span><br/><span class="koboSpan" id="kobo.94.1">} else { </span><br/><span class="koboSpan" id="kobo.95.1">  console.warn('unknown mouse event in zoomed()'); // alerting issues</span><br/><span class="koboSpan" id="kobo.96.1">}</span></pre>
<p><span class="koboSpan" id="kobo.97.1">In the preceding code, we first retrieve the current rotation values from the projection in the variable </span><kbd><span class="koboSpan" id="kobo.98.1">r</span></kbd><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">Then, you change the </span><kbd><span class="koboSpan" id="kobo.100.1">r[0]</span></kbd><span class="koboSpan" id="kobo.101.1">, the yaw value (responsible for rotating the world around its normal or vertical axis) by the </span><em><span class="koboSpan" id="kobo.102.1">x</span></em><span class="koboSpan" id="kobo.103.1"> change of the mouse coordinates. </span><span class="koboSpan" id="kobo.103.2">You further change </span><kbd><span class="koboSpan" id="kobo.104.1">r[1]</span></kbd><span class="koboSpan" id="kobo.105.1">, the roll value (rotating the world around its lateral axis, going horizontally from left to right) by the y change of the mouse coordinates. </span><span class="koboSpan" id="kobo.105.2">We leave the third pitch value as is, and yes, the best way is to throttle these values to a reasonable speed of rotation with </span><kbd><span class="koboSpan" id="kobo.106.1">dx * 0.4</span></kbd><span class="koboSpan" id="kobo.107.1"> and </span><kbd><span class="koboSpan" id="kobo.108.1">dy * 0.5</span></kbd><span class="koboSpan" id="kobo.109.1">, respectively. </span><span class="koboSpan" id="kobo.109.2">Note that this is the straightforward but naive way to rotate the globe. </span><span class="koboSpan" id="kobo.109.3">It will fully do in our case. </span><span class="koboSpan" id="kobo.109.4">If you want to apply utmost precision, you could use </span><strong><span class="koboSpan" id="kobo.110.1">versor</span></strong><span class="koboSpan" id="kobo.111.1"> dragging (check out </span><a href="http://tiny.cc/versor"><span class="koboSpan" id="kobo.112.1">http://tiny.cc/versor</span></a><span class="koboSpan" id="kobo.113.1">). </span><span class="koboSpan" id="kobo.113.2">The key difference is that versor dragging rotates the globe in the right direction even when it's upside down.</span></p>
<p><span class="koboSpan" id="kobo.114.1">That’s it for rotation. </span><span class="koboSpan" id="kobo.114.2">Remember, the world gets re-rendered after this conditional as we do this in the following Canvas game loop: get user input – calculate the new position – re-render.</span></p>
<p><span class="koboSpan" id="kobo.115.1">Here’s a static attempt to show dynamic zooming and rotations:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.116.1"><img src="assets/ed98d35d-88fb-4cf9-bf78-115e400d2056.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.117.1">Zooming and rotating a Canvas globe</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.118.1">View the step shown in the preceding screenshot in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-10-2"><span class="koboSpan" id="kobo.119.1">https://larsvers.github.io/learning-d3-mapping-10-2</span></a><span class="koboSpan" id="kobo.120.1"> and its code example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html"><span class="koboSpan" id="kobo.121.1">10_02.html</span></a><span class="koboSpan" id="kobo.122.1">.</span></div>
<p><span class="koboSpan" id="kobo.123.1">The main benefit of zooming via a projection change is that it allows rotating (that’s a win) and guarantees </span><strong><span class="koboSpan" id="kobo.124.1">semantic zooming</span></strong><span class="koboSpan" id="kobo.125.1"> of the world rather than </span><strong><span class="koboSpan" id="kobo.126.1">geometric zooming</span></strong><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">When you zoom into a Canvas object with </span><kbd><span class="koboSpan" id="kobo.128.1">context.scale()</span></kbd><span class="koboSpan" id="kobo.129.1">, it naively enlarges anything that’s on the Canvas. </span><span class="koboSpan" id="kobo.129.2">So, a country border, for example, gets wider and wider, the more you scale it. </span><span class="koboSpan" id="kobo.129.3">That’s </span><strong><span class="koboSpan" id="kobo.130.1">geometric zooming</span></strong><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">We, however, want to keep everything constant, apart from the area of the individual country polygons. </span><span class="koboSpan" id="kobo.131.3">This is called </span><strong><span class="koboSpan" id="kobo.132.1">semantic zooming</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">Another benefit of the </span><strong><span class="koboSpan" id="kobo.134.1">projection change</span></strong><span class="koboSpan" id="kobo.135.1"> is that getting the coordinate of a Canvas object by mouse-over is more straightforward. </span><span class="koboSpan" id="kobo.135.2">This is our next stop.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Finding the Canvas object under the mouse - Picking</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We’ve done zooming and rotating. </span><span class="koboSpan" id="kobo.2.2">Let’s celebrate by adding another key piece of interactivity: the mouseover. </span><span class="koboSpan" id="kobo.2.3">In fact, we don’t want just any mouseover. </span><span class="koboSpan" id="kobo.2.4">We want to mouse over an object drawn on the Canvas and retrieve information from that object. </span><span class="koboSpan" id="kobo.2.5">Once we have that, we have a lot—we can create tooltips, we can highlight the object, we can link views with another graph showing the same data point, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Picking, the theory</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So, how are we doing this? </span><span class="koboSpan" id="kobo.2.2">As established many times above, we can’t just add a listener to a set of pixels, because an event is an object maintained by the browser, interacting with DOM nodes. </span><span class="koboSpan" id="kobo.2.3">However, our browser doesn’t know about the pixel. </span><span class="koboSpan" id="kobo.2.4">It doesn’t have a representation of the Canvas pixels it wants to interact with. </span><span class="koboSpan" id="kobo.2.5">So, how?</span></p>
<p><span class="koboSpan" id="kobo.3.1">The answer is relatively simple: we build it ourselves. </span><span class="koboSpan" id="kobo.3.2">Not the DOM, that would be madness, but a representation of our Canvas drawing in which the target object’s pixel are charged with this object’s information.</span></p>
<p><span class="koboSpan" id="kobo.4.1">So, what do we need to build our own little visual object representation? </span><span class="koboSpan" id="kobo.4.2">In short, you will build two Canvases. </span><span class="koboSpan" id="kobo.4.3">One </span><strong><span class="koboSpan" id="kobo.5.1">main Canvas</span></strong><span class="koboSpan" id="kobo.6.1"> that produces our visual (done already) and one </span><strong><span class="koboSpan" id="kobo.7.1">hidden Canvas</span></strong><span class="koboSpan" id="kobo.8.1"> (as in you can’t see it) that produces the same visual. </span><span class="koboSpan" id="kobo.8.2">The key here is that all elements on the second Canvas will be at the same position in relation to the Canvas origin compared to the first Canvas. </span><span class="koboSpan" id="kobo.8.3">We will bend this rule a little in practice, but, for now, imagine that the northern tip of Scotland is at pixel position </span><em><span class="koboSpan" id="kobo.9.1">250, 100</span></em><span class="koboSpan" id="kobo.10.1"> of the main Canvas and that it is also at </span><em><span class="koboSpan" id="kobo.11.1">250, 100</span></em><span class="koboSpan" id="kobo.12.1"> of the hidden Canvas.</span></p>
<p><span class="koboSpan" id="kobo.13.1">There is only one key difference between the main and the hidden Canvas. </span><span class="koboSpan" id="kobo.13.2">Each element on the hidden Canvas will get a </span><strong><span class="koboSpan" id="kobo.14.1">unique color</span></strong><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">What’s more, these color values will be indexes to look up our data values. </span><span class="koboSpan" id="kobo.15.3">In our case, we will assign </span><em><span class="koboSpan" id="kobo.16.1">rgb(0,0,0)</span></em><span class="koboSpan" id="kobo.17.1"> to the first country in our country list: Afghanistan. </span><span class="koboSpan" id="kobo.17.2">Our second country will get the color value </span><em><span class="koboSpan" id="kobo.18.1">rgb(1,0,0)</span></em><span class="koboSpan" id="kobo.19.1"> and so on until our last country–Zimbabwe–will get the color value </span><em><span class="koboSpan" id="kobo.20.1">rgb(176,0,0)</span></em><span class="koboSpan" id="kobo.21.1">.</span></p>
<p><span class="koboSpan" id="kobo.22.1">Why? </span><span class="koboSpan" id="kobo.22.2">Because, next, we will attach a mousemove listener to the main Canvas to retrieve a flow of mouse positions as we move the mouse. </span><span class="koboSpan" id="kobo.22.3">At each mouse position, we can use the Canvas's own method </span><kbd><span class="koboSpan" id="kobo.23.1">context.getImageData()</span></kbd><span class="koboSpan" id="kobo.24.1"> to pick the color of the pixel at this exact position. </span><span class="koboSpan" id="kobo.24.2">We just extract the R value from our RGB color and can query our data array to get the object we need.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Our itinerary is clear and, with three steps, relatively short. </span><span class="koboSpan" id="kobo.25.2">First, we will create the hidden Canvas. </span><span class="koboSpan" id="kobo.25.3">Secondly, we will draw the world with a unique color per country. </span><span class="koboSpan" id="kobo.25.4">Finally, we will write the mousemove handler to pick the color and get the data. </span><span class="koboSpan" id="kobo.25.5">Lastly, we have to decide what to do with all that data we can access.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Before we start, let’s make sure that we actually have some data for each country. </span><span class="koboSpan" id="kobo.26.2">Here’s our GeoJSON country object that shows the contents of the first two of 177 countries:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.27.1"><img height="330" width="313" src="assets/51458214-8499-4fd2-87cf-988d935ffcd7.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.28.1">The data properties of the country’s array</span></div>
<p><span class="koboSpan" id="kobo.29.1">Our GeoJSON world is a </span><kbd><span class="koboSpan" id="kobo.30.1">FeatureCollection</span></kbd><span class="koboSpan" id="kobo.31.1"> with one feature per country, ascendingly sorted by country name. </span><span class="koboSpan" id="kobo.31.2">Each feature is an object holding a </span><kbd><span class="koboSpan" id="kobo.32.1">type</span></kbd><span class="koboSpan" id="kobo.33.1"> property, the </span><kbd><span class="koboSpan" id="kobo.34.1">geometry</span></kbd><span class="koboSpan" id="kobo.35.1"> for the country polygon, and a property called </span><kbd><span class="koboSpan" id="kobo.36.1">properties</span></kbd><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">In here, we have three data points: the country abbreviation, the country name, and even an estimate of the country’s population. </span><span class="koboSpan" id="kobo.37.3">Now, let’s get to that data by mouse over.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating all things hidden</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">By now, you’ve set up so many Canvases that, at worst, this code just bores you:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.3.1">var hiddenCanvas = d3.select('#canvas-container').append('canvas')</span><br/><span class="koboSpan" id="kobo.4.1">    .attr('id', 'canvas-hidden')</span><br/><span class="koboSpan" id="kobo.5.1">    .attr('width', width)</span><br/><span class="koboSpan" id="kobo.6.1">    .attr('height', height);</span><br/><br/><span class="koboSpan" id="kobo.7.1">var hiddenContext = hiddenCanvas.node().getContext('2d');</span></pre>
<p><span class="koboSpan" id="kobo.8.1">The only thing we want to make sure of here is to apply the same width and height that we applied to the main Canvas.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Next, we will draw the world to it. </span><span class="koboSpan" id="kobo.9.2">In order to do so, we have to build a projection and path generator and then loop through all countries to draw each country to the Canvas; let's do that:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">var hiddenProjection = d3.geoEquirectangular()</span><br/><span class="koboSpan" id="kobo.11.1">    .translate([width / 2, height / 2])</span><br/><span class="koboSpan" id="kobo.12.1">    .scale(width / 7);</span><br/><br/><span class="koboSpan" id="kobo.13.1">var hiddenPath = d3.geoPath()</span><br/><span class="koboSpan" id="kobo.14.1">    .projection(hiddenProjection)</span><br/><span class="koboSpan" id="kobo.15.1">    .context(hiddenContext);</span></pre>
<p><span class="koboSpan" id="kobo.16.1">We, of course, need a new path generator, as we need to feed our now hidden drawing context to the </span><kbd><span class="koboSpan" id="kobo.17.1">.context()</span></kbd><span class="koboSpan" id="kobo.18.1"> method. </span><span class="koboSpan" id="kobo.18.2">However–hold on–we already have a projection for the main Canvas. </span><span class="koboSpan" id="kobo.18.3">Shouldn’t we use it for the hidden Canvas </span><span><span class="koboSpan" id="kobo.19.1">also</span></span><span class="koboSpan" id="kobo.20.1">? </span><span class="koboSpan" id="kobo.20.2">Especially, as we said above that ideally the objects on our hidden Canvas should be in the exact same position as the objects on our main Canvas to query the hidden positions easily? </span><span class="koboSpan" id="kobo.20.3">However, here, we use an </span><strong><span class="koboSpan" id="kobo.21.1">equi-rectangular</span></strong><span class="koboSpan" id="kobo.22.1"> projection, which will draw the world in a rather different way to our </span><strong><span class="koboSpan" id="kobo.23.1">orthographic</span></strong><span class="koboSpan" id="kobo.24.1"> projection on the main Canvas. </span><span class="koboSpan" id="kobo.24.2">Don’t we need the same projection to produce the same globe?</span></p>
<p><span class="koboSpan" id="kobo.25.1">The answer is no, we don’t need the same projection. </span><span class="koboSpan" id="kobo.25.2">When our mouse is on a specific position on the main Canvas, we just need to find the same position on the hidden Canvas. </span><span class="koboSpan" id="kobo.25.3">No doubt, the easiest way to do this is to use the exact same coordinates. </span><span class="koboSpan" id="kobo.25.4">However, we can also use the main projection’s </span><kbd><span class="koboSpan" id="kobo.26.1">projection.invert([x,y])</span></kbd><span class="koboSpan" id="kobo.27.1"> function to retrieve this position’s longitude and latitude values. </span><span class="koboSpan" id="kobo.27.2">We will then use the hidden projection to convert the geo-coordinates to pixel coordinates on the hidden Canvas. </span><span class="koboSpan" id="kobo.27.3">Long-winded? </span><span class="koboSpan" id="kobo.27.4">Yes, a little. </span><span class="koboSpan" id="kobo.27.5">However, with a moving object such as a zooming and rotating globe, this saves us from re-drawing the hidden Canvas. </span><span class="koboSpan" id="kobo.27.6">We shall see this in action very soon when we build the handler in the third step.</span></p>
<p><span class="koboSpan" id="kobo.28.1">First, let’s draw the hidden Canvas.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing the hidden Canvas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There’s just a single simple function that does what you need in this step:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">function drawHiddenCanvas(world) {</span><br/><span class="koboSpan" id="kobo.4.1">  var countries = world.features;</span><br/><span class="koboSpan" id="kobo.5.1">  countries.forEach(function(el, i) {</span><br/><span class="koboSpan" id="kobo.6.1">    hiddenContext.beginPath();</span><br/><span class="koboSpan" id="kobo.7.1">    hiddenPath(el);</span><br/><span class="koboSpan" id="kobo.8.1">    hiddenContext.fillStyle = 'rgb(' + i + ',0,0)';</span><br/><span class="koboSpan" id="kobo.9.1">    hiddenContext.fill();</span><br/><span class="koboSpan" id="kobo.10.1">  });</span><br/><span class="koboSpan" id="kobo.11.1">}</span></pre>
<p><span class="koboSpan" id="kobo.12.1">The only argument—</span><kbd><span class="koboSpan" id="kobo.13.1">world</span></kbd><span><span class="koboSpan" id="kobo.14.1">—</span></span><span class="koboSpan" id="kobo.15.1">is our GeoJSON feature collection. </span><kbd><span class="koboSpan" id="kobo.16.1">countries</span></kbd><span class="koboSpan" id="kobo.17.1"> pulls out just the array of country information, including the polygons and the additional data we’re after. </span><span class="koboSpan" id="kobo.17.2">We loop through all of them, drawing each country with the </span><kbd><span class="koboSpan" id="kobo.18.1">hiddenContext</span></kbd><span class="koboSpan" id="kobo.19.1"> and </span><span><span class="koboSpan" id="kobo.20.1">—</span></span><span class="koboSpan" id="kobo.21.1"> most importantly</span><span><span class="koboSpan" id="kobo.22.1">—we</span></span><span class="koboSpan" id="kobo.23.1"> gave each country a color using the </span><kbd><span class="koboSpan" id="kobo.24.1">rgb(&lt;country index&gt;, 0, 0)</span></kbd> <span><span class="koboSpan" id="kobo.25.1">pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Here we have it! </span><span class="koboSpan" id="kobo.26.2">A graph-like structure of our Canvas visual, representing our data.</span></p>
<p><span class="koboSpan" id="kobo.27.1">So far, it’s only a function, so let’s invoke it. </span><span class="koboSpan" id="kobo.27.2">We only need to call </span><kbd><span class="koboSpan" id="kobo.28.1">drawHiddenCanvas()</span></kbd><span class="koboSpan" id="kobo.29.1"> once whenever we have the data available. </span><span class="koboSpan" id="kobo.29.2">So, we venture to the </span><kbd><span class="koboSpan" id="kobo.30.1">ready()</span></kbd><span class="koboSpan" id="kobo.31.1"> function and invoke it right after we draw the main Canvas with </span><kbd><span class="koboSpan" id="kobo.32.1">renderScene()</span></kbd><span class="koboSpan" id="kobo.33.1">:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">  requestAnimationFrame(function() {</span><br/><span class="koboSpan" id="kobo.35.1">    renderScene(countries);</span><br/><span class="koboSpan" id="kobo.36.1">    drawHiddenCanvas(countries);</span><br/><span class="koboSpan" id="kobo.37.1">  });</span></pre>
<p><span class="koboSpan" id="kobo.38.1">Here they are; our two worlds:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.39.1"><img height="394" width="315" src="assets/c5b95c2f-20ad-4338-8e97-53477c1ec9f7.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.40.1">The main and the hidden Canvas</span></div>
<p><span class="koboSpan" id="kobo.41.1">Each country has a slightly different color, ranging from black to red or from </span><em><span class="koboSpan" id="kobo.42.1">rgb(0,0,0)</span></em><span class="koboSpan" id="kobo.43.1"> = </span><em><span class="koboSpan" id="kobo.44.1">Afghanistan</span></em><span class="koboSpan" id="kobo.45.1"> to </span><em><span class="koboSpan" id="kobo.46.1">rbg(176,0,0) = Zimbabwe</span></em><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">You can see how countries that start high up in the alphabet</span><span><span class="koboSpan" id="kobo.48.1">—</span></span><span class="koboSpan" id="kobo.49.1">Antarctica, Australia, Brasil, or Canada</span><span><span class="koboSpan" id="kobo.50.1">—</span></span><span class="koboSpan" id="kobo.51.1">are much darker than countries that are low down in the alphabet</span><span><span class="koboSpan" id="kobo.52.1">—</span></span><span class="koboSpan" id="kobo.53.1">the United States or Russia. </span><span class="koboSpan" id="kobo.53.2">Note that we’ll keep our hidden Canvas visible for demonstration purposes, but, in production, we can just add the CSS rule </span><kbd><span class="koboSpan" id="kobo.54.1">{ display: hidden }</span></kbd><span class="koboSpan" id="kobo.55.1"> to hide our Canvas. </span><span class="koboSpan" id="kobo.55.2">No one needs to know about our little trick.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Picking the values</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">At this point, you have all tools </span><span><span class="koboSpan" id="kobo.3.1">at hands</span></span><span class="koboSpan" id="kobo.4.1"> to implement a hover. </span><span class="koboSpan" id="kobo.4.2">Now, you will need to make it happen. </span><span class="koboSpan" id="kobo.4.3">To wire it all up, you need to do the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">Listen to mousemoves on the main Canvas.</span></li>
<li><span class="koboSpan" id="kobo.6.1">Translate these coordinates to positions on the hidden Canvas.</span></li>
<li><span class="koboSpan" id="kobo.7.1">Pick the color from that position.</span></li>
<li><span class="koboSpan" id="kobo.8.1">Strip out the color value that represents the data array index for your data.</span></li>
<li><span class="koboSpan" id="kobo.9.1">Lean back and think of ways to use it.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.10.1">Listening on mousemove is easy; you just need to perform the following command:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">canvas.on('mousemove', highlightPicking);</span></pre>
<p><span class="koboSpan" id="kobo.12.1">Done. </span><span class="koboSpan" id="kobo.12.2">The first thing we will do in </span><kbd><span class="koboSpan" id="kobo.13.1">highlightPicking()</span></kbd><span class="koboSpan" id="kobo.14.1"> is translate the mouse position on the main Canvas to the coordinates on the hidden Canvas:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">function highlightPicking() {</span><br/><span class="koboSpan" id="kobo.16.1">  var pos = d3.mouse(this);</span><br/><span class="koboSpan" id="kobo.17.1">  var longlat = projection.invert(pos);</span><br/><span class="koboSpan" id="kobo.18.1">  var hiddenPos = hiddenProjection(longlat);</span></pre>
<p><span class="koboSpan" id="kobo.19.1">We first get the </span><em><span class="koboSpan" id="kobo.20.1">x, y</span></em><span class="koboSpan" id="kobo.21.1"> mouse coordinates. </span><span class="koboSpan" id="kobo.21.2">This will be updated whenever we move the mouse. </span><span class="koboSpan" id="kobo.21.3">An example value of the </span><kbd><span class="koboSpan" id="kobo.22.1">pos</span></kbd><span class="koboSpan" id="kobo.23.1"> variable is </span><em><span class="koboSpan" id="kobo.24.1">[488, 85]</span></em><span class="koboSpan" id="kobo.25.1">, which is in the north of France. </span><span class="koboSpan" id="kobo.25.2">We use D3’s own </span><kbd><span class="koboSpan" id="kobo.26.1">projection.invert()</span></kbd><span class="koboSpan" id="kobo.27.1"> which is the inverse of </span><kbd><span class="koboSpan" id="kobo.28.1">projection()</span></kbd><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">What does </span><kbd><span class="koboSpan" id="kobo.30.1">projection()</span></kbd><span class="koboSpan" id="kobo.31.1"> do? </span><span class="koboSpan" id="kobo.31.2">It takes an array of [longitude, latitude] values and returns a pair of [x, y] pixel coordinates. </span><span class="koboSpan" id="kobo.31.3">Well, </span><kbd><span class="koboSpan" id="kobo.32.1">projection.invert()</span></kbd><span class="koboSpan" id="kobo.33.1"> does the opposite. </span><span class="koboSpan" id="kobo.33.2">It takes a pixel coordinate array and returns the respective longitude and latitude array. </span><span class="koboSpan" id="kobo.33.3">In our case, that will be [2.44, 48.81]. </span><span class="koboSpan" id="kobo.33.4">The longitude is a bit further right of </span><em><span class="koboSpan" id="kobo.34.1">0</span></em><span class="koboSpan" id="kobo.35.1">, which is Greenwich, so yes, that seems right. </span><span class="koboSpan" id="kobo.35.2">Note, that this projection is our main Canvas projection. </span><span class="koboSpan" id="kobo.35.3">Next, we use our </span><kbd><span class="koboSpan" id="kobo.36.1">hiddenProjection()</span></kbd><span class="koboSpan" id="kobo.37.1"> function to reproject our </span><kbd><span class="koboSpan" id="kobo.38.1">longlat</span></kbd><span class="koboSpan" id="kobo.39.1"> values to the pixel coordinates of this very place. </span><span class="koboSpan" id="kobo.39.2">In our example, </span><kbd><span class="koboSpan" id="kobo.40.1">hiddenPos</span></kbd><span class="koboSpan" id="kobo.41.1"> gets the pixel coordinates [485.83, 183.17] assigned to it. </span><span class="koboSpan" id="kobo.41.2">That’s the very same spot in the north of France on the hidden Canvas! </span><span class="koboSpan" id="kobo.41.3">Exactly what we were after.</span></p>
<p><span class="koboSpan" id="kobo.42.1">To demonstrate this, take a look at the following screenshots:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.43.1"><img height="191" width="476" src="assets/6b5b3bee-eb0d-421b-bf5c-ece23935491a.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.44.1">Translating the main Canvas mouse coordinates to the hidden Canvas coordinates</span></div>
<p><span class="koboSpan" id="kobo.45.1">Our mouse position on the upper main Canvas represented by </span><kbd><span class="koboSpan" id="kobo.46.1">pos</span></kbd><span class="koboSpan" id="kobo.47.1"> gets translated to the lower orange circle represented by the </span><kbd><span class="koboSpan" id="kobo.48.1">hiddenPos</span></kbd><span class="koboSpan" id="kobo.49.1"> variable.</span></p>
<p><span class="koboSpan" id="kobo.50.1">Now, we finally get to pick that color:</span></p>
<pre><span class="koboSpan" id="kobo.51.1">var pickedColor = hiddenContext.getImageData(hiddenPos[0], hiddenPos[1], 1, 1).data;</span></pre>
<p><span class="koboSpan" id="kobo.52.1">This returns a special array with the unwieldy name </span><kbd><span class="koboSpan" id="kobo.53.1">Uint8ClampedArray</span></kbd><span class="koboSpan" id="kobo.54.1"> representing the R, the G, the B, and the alpha value (peculiarly also ranging from </span><em><span class="koboSpan" id="kobo.55.1">0</span></em><span class="koboSpan" id="kobo.56.1"> to </span><em><span class="koboSpan" id="kobo.57.1">255</span></em><span class="koboSpan" id="kobo.58.1">) at exactly that pixel. </span><span class="koboSpan" id="kobo.58.2">In our case, for example, for France (the left most pick in the preceding screenshot), the color is </span><kbd><span class="koboSpan" id="kobo.59.1">52</span></kbd><span class="koboSpan" id="kobo.60.1">:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.61.1"><img height="174" width="374" src="assets/82452b63-cb05-49c3-bce9-aa1860dde291.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.62.1">The picked color array</span></div>
<p><span class="koboSpan" id="kobo.63.1">Cross-checking with our </span><kbd><span class="koboSpan" id="kobo.64.1">countries</span></kbd><span class="koboSpan" id="kobo.65.1"> array, we can confirm that the array element with the index </span><kbd><span class="koboSpan" id="kobo.66.1">52</span></kbd><span class="koboSpan" id="kobo.67.1"> is </span><strong><span class="koboSpan" id="kobo.68.1">France</span></strong><span class="koboSpan" id="kobo.69.1">.</span></p>
<p><span class="koboSpan" id="kobo.70.1">However, we will build in two security checks before we can be sure of hovering over a country. </span><span class="koboSpan" id="kobo.70.2">First, you will check whether the user’s mouse is on the globe and not somewhere in the outer space:</span></p>
<pre><span class="koboSpan" id="kobo.71.1">var inGlobe =</span><br/><span class="koboSpan" id="kobo.72.1">    Math.abs(pos[0] - projection(projection.invert(pos))[0]) &lt; 0.5 &amp;&amp;</span><br/><span class="koboSpan" id="kobo.73.1">    Math.abs(pos[1] - projection(projection.invert(pos))[1]) &lt; 0.5;</span></pre>
<p><span class="koboSpan" id="kobo.74.1">In an ideal world, for our purpose, </span><kbd><span class="koboSpan" id="kobo.75.1">projection.invert(pos)</span></kbd><span class="koboSpan" id="kobo.76.1"> above would return </span><kbd><span class="koboSpan" id="kobo.77.1">undefined</span></kbd><span class="koboSpan" id="kobo.78.1"> or similar when we move beyond the globe; however, it still returns actual pixel coordinates, which is not what we want. </span><span class="koboSpan" id="kobo.78.2">The problem is that </span><kbd><span class="koboSpan" id="kobo.79.1">projection.invert()</span></kbd><span class="koboSpan" id="kobo.80.1"> is not </span><strong><span class="koboSpan" id="kobo.81.1">bijective</span></strong><span class="koboSpan" id="kobo.82.1">, meaning it can in fact return the same </span><em><span class="koboSpan" id="kobo.83.1">[long, lat]</span></em><span class="koboSpan" id="kobo.84.1"> coordinates for different pixel position inputs. </span><span class="koboSpan" id="kobo.84.2">This is especially the case when we move the mouse beyond the globe bounds. </span><span class="koboSpan" id="kobo.84.3">To alleviate this issue, we do a so called </span><strong><span class="koboSpan" id="kobo.85.1">forward projection</span></strong><span class="koboSpan" id="kobo.86.1"> here. </span><span class="koboSpan" id="kobo.86.2">This just means that we project the inverse of our projection. </span><span class="koboSpan" id="kobo.86.3">We take in the pixel coordinates, translate them to </span><em><span class="koboSpan" id="kobo.87.1">[long, lat]</span></em><span class="koboSpan" id="kobo.88.1"> values and project them back to pixel coordinates. </span><span class="koboSpan" id="kobo.88.2">If our mouse is within the globe, this will return our exact mouse position (in fact we give it a leeway of +/- 0.5 pixels here). </span><span class="koboSpan" id="kobo.88.3">If our mouse is outside the globe, the forward projection will deviate from our mouse position in pixel.</span></p>
<p><span class="koboSpan" id="kobo.89.1">The second check we perform is to make sure that our mouse is over a country and not a country border:</span></p>
<pre><span class="koboSpan" id="kobo.90.1">selected = inGlobe &amp;&amp; pickedColor[3] === 255 ? </span><span class="koboSpan" id="kobo.90.2">pickedColor[0] : false;</span></pre>
<p><span class="koboSpan" id="kobo.91.1">Let’s take this one by one. </span><kbd><span class="koboSpan" id="kobo.92.1">selected</span></kbd><span class="koboSpan" id="kobo.93.1"> will hold the index. </span><span class="koboSpan" id="kobo.93.2">You will, however, only get the index if the user’s mouse is inside the globe (</span><kbd><span class="koboSpan" id="kobo.94.1">inGlobe</span></kbd><span class="koboSpan" id="kobo.95.1"> === </span><kbd><span class="koboSpan" id="kobo.96.1">true</span></kbd><span class="koboSpan" id="kobo.97.1">). </span><span class="koboSpan" id="kobo.97.2">This is our first check. </span><span class="koboSpan" id="kobo.97.3">Secondly, the fourth element of our special </span><kbd><span class="koboSpan" id="kobo.98.1">pickedColor</span></kbd><span class="koboSpan" id="kobo.99.1"> array has to be exactly </span><em><span class="koboSpan" id="kobo.100.1">255</span></em><span class="koboSpan" id="kobo.101.1">. </span><span class="koboSpan" id="kobo.101.2">Otherwise, selected will be false. </span><span class="koboSpan" id="kobo.101.3">This second check is to surpass </span><strong><span class="koboSpan" id="kobo.102.1">antialiasing</span></strong><span class="koboSpan" id="kobo.103.1"> effects.</span></p>
<p><span class="koboSpan" id="kobo.104.1">Why do we need that? </span><span class="koboSpan" id="kobo.104.2">The problem with pixels in browsers is that they outsmart us. </span><span class="koboSpan" id="kobo.104.3">Lines are feathered at the edges to allow the impression of a smooth transition from line to background:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.105.1"><img height="174" width="382" src="assets/e529dada-a2c0-4afb-a9f9-ef0b1f473653.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.106.1">An aliased line above an antialiased line</span></div>
<p><span class="koboSpan" id="kobo.107.1">Picking values at these feathered edges would not return fully opaque colors, but transparent values of varying degree. </span><span class="koboSpan" id="kobo.107.2">These values have an alpha channel lower than 255, so checking for our alpha to be 255 allows us to pick only from aliased areas.</span></p>
<p class="mce-root"><span><span class="koboSpan" id="kobo.108.1">Fabulous!</span></span><span class="koboSpan" id="kobo.109.1"> We’ve built ourself a second Canvas that functions as a memory of the objects on our main data. </span><span class="koboSpan" id="kobo.109.2">Next, we’ll use it. </span><span class="koboSpan" id="kobo.109.3">The Canvas way of changing anything with our elements and objects is to pass the information to the redrawing part of our app to use it in there accordingly.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Storing more data and using a lookup array</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">We are blessed with the fact that the world we visualize only has 176 countries. </span><span class="koboSpan" id="kobo.2.2">This way, we only need to keep track of 176 indeces. </span><span class="koboSpan" id="kobo.2.3">However, you often deal with more data objects so that 256 (as in 0-255) will be used up rather quickly. </span><span class="koboSpan" id="kobo.2.4">Luckily, we not only have R but also G and B values and their unique combinations, which gets us to </span><em><span class="koboSpan" id="kobo.3.1">256*256*256 = 16,777,216</span></em><span class="koboSpan" id="kobo.4.1"> possible indeces you can store. </span><span class="koboSpan" id="kobo.4.2">That will bring you far.</span></span></p>
<div class="packt_tip"><span><span class="koboSpan" id="kobo.5.1">Check the tutorial at</span></span> <span><a href="http://tiny.cc/d3-canvas"><span class="koboSpan" id="kobo.6.1">http://tiny.cc/d3-canvas</span></a></span> <span><span class="koboSpan" id="kobo.7.1">for more details.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Highlighting the country on mouse over</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Whenever a country is picked, we just pass the selected variable through to our </span><kbd><span class="koboSpan" id="kobo.3.1">drawScene()</span></kbd><span class="koboSpan" id="kobo.4.1"> function that draws the world at each mouseover:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">  // ...</span><br/><span class="koboSpan" id="kobo.6.1">  selected = inGlobe &amp;&amp; pickedColor[3] === 255 ? </span><span class="koboSpan" id="kobo.6.2">pickedColor[0] : false;</span><br/><br/><span class="koboSpan" id="kobo.7.1">  requestAnimationFrame(function() {</span><br/><span class="koboSpan" id="kobo.8.1">    renderScene(countries, </span><strong><span class="koboSpan" id="kobo.9.1">selected</span></strong><span class="koboSpan" id="kobo.10.1">);</span><br/><span class="koboSpan" id="kobo.11.1">  });</span><br/><br/><span class="koboSpan" id="kobo.12.1">} // highlightPicking()</span></pre>
<p><span class="koboSpan" id="kobo.13.1">At the end of our highlight handler, we didn’t only pass the </span><kbd><span class="koboSpan" id="kobo.14.1">countries</span></kbd><span class="koboSpan" id="kobo.15.1"> to our render function, we also sent our newly created </span><kbd><span class="koboSpan" id="kobo.16.1">selected</span></kbd><span class="koboSpan" id="kobo.17.1"> on the way. </span><span class="koboSpan" id="kobo.17.2">The </span><kbd><span class="koboSpan" id="kobo.18.1">renderScene()</span></kbd><span class="koboSpan" id="kobo.19.1"> function just passes it through to </span><kbd><span class="koboSpan" id="kobo.20.1">drawScene()</span></kbd><span class="koboSpan" id="kobo.21.1">, which draws the world to the </span><kbd><span class="koboSpan" id="kobo.22.1">buffer</span></kbd><span class="koboSpan" id="kobo.23.1"> Canvas. </span><span class="koboSpan" id="kobo.23.2">Remember that </span><kbd><span class="koboSpan" id="kobo.24.1">renderScene()</span></kbd><span class="koboSpan" id="kobo.25.1"> just calls </span><kbd><span class="koboSpan" id="kobo.26.1">drawScene()</span></kbd><span class="koboSpan" id="kobo.27.1">, then clears the main Canvas and copies the </span><kbd><span class="koboSpan" id="kobo.28.1">buffer</span></kbd><span class="koboSpan" id="kobo.29.1"> image over to the main Canvas.</span></p>
<p><span class="koboSpan" id="kobo.30.1">In </span><kbd><span class="koboSpan" id="kobo.31.1">drawCanvas()</span></kbd><span class="koboSpan" id="kobo.32.1">, we will add a single block:</span></p>
<pre><span class="koboSpan" id="kobo.33.1">function drawScene(countries, countryIndex) {</span><br/><span class="koboSpan" id="kobo.34.1">  // Clear …</span><br/><span class="koboSpan" id="kobo.35.1">  // Sphere fill …</span><br/><span class="koboSpan" id="kobo.36.1">  // Grid …</span><br/><span class="koboSpan" id="kobo.37.1">  // Country fill …</span><br/><span class="koboSpan" id="kobo.38.1">  // Country stroke - each country ….</span><br/><br/><span class="koboSpan" id="kobo.39.1">  // Country stroke - hovered country</span><br/><span class="koboSpan" id="kobo.40.1">  if (countryIndex &gt;= 0) {</span><br/><span class="koboSpan" id="kobo.41.1">    bufferContext.beginPath();</span><br/><span class="koboSpan" id="kobo.42.1">    bufferContext.setLineDash([4,2]);</span><br/><span class="koboSpan" id="kobo.43.1">    bufferPath(countries.features[countryIndex]);</span><br/><span class="koboSpan" id="kobo.44.1">    bufferContext.lineWidth = 1;</span><br/><span class="koboSpan" id="kobo.45.1">    bufferContext.strokeStyle = '#777';</span><br/><span class="koboSpan" id="kobo.46.1">    bufferContext.stroke();</span><br/><span class="koboSpan" id="kobo.47.1">    bufferContext.setLineDash([]);</span><br/><span class="koboSpan" id="kobo.48.1">  }</span><br/><span class="koboSpan" id="kobo.49.1">}</span></pre>
<p><span class="koboSpan" id="kobo.50.1">We will receive the </span><kbd><span class="koboSpan" id="kobo.51.1">selected</span></kbd><span class="koboSpan" id="kobo.52.1"> index via the </span><kbd><span class="koboSpan" id="kobo.53.1">countryIndex</span></kbd><span class="koboSpan" id="kobo.54.1"> argument and check whether it's larger or equal to </span><em><span class="koboSpan" id="kobo.55.1">0</span></em><span class="koboSpan" id="kobo.56.1"> (remember, that would be </span><em><span class="koboSpan" id="kobo.57.1">Afghanistan</span></em><span class="koboSpan" id="kobo.58.1">). </span><span class="koboSpan" id="kobo.58.2">If so, we draw a dashed path around the country. </span><span class="koboSpan" id="kobo.58.3">How do we know which country? </span><span class="koboSpan" id="kobo.58.4">We access the right country via </span><kbd><span class="koboSpan" id="kobo.59.1">countries.features[countryIndex]</span></kbd><span class="koboSpan" id="kobo.60.1"> and draw it accordingly. </span><span class="koboSpan" id="kobo.60.2">The mind boggles:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.61.1"><img height="304" width="482" src="assets/d94adbe9-f76b-4d32-a236-72c2363a7d6f.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.62.1">A dashed line around the US, just because we picked the right color</span></div>
<div class="packt_infobox"><span class="koboSpan" id="kobo.63.1">View this step in the browser at </span><a href="https://larsvers.github.io/learning-d3-mapping-10-3"><span class="koboSpan" id="kobo.64.1">https://larsvers.github.io/learning-d3-mapping-10-3</span></a><span class="koboSpan" id="kobo.65.1"> and the code example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_03.html"><span class="koboSpan" id="kobo.66.1">10_03.html</span></a><span class="koboSpan" id="kobo.67.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Visualizing data per country and adding a tooltip</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You learned to build a data-driven and -giving representation of your visual. </span><span class="koboSpan" id="kobo.2.2">You have also used it to highlight the country at hover. </span><span class="koboSpan" id="kobo.2.3">However, you haven’t really tapped into the plentiful options of interaction this gives you. </span><span class="koboSpan" id="kobo.2.4">Let’s do this now. </span><span class="koboSpan" id="kobo.2.5">There’s a lot you could do, but I think a tooltip would be a reasonable place to start.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Before we embark on the tooltip build, let’s add some more interesting data to the globe. </span><span class="koboSpan" id="kobo.3.2">So far, we have </span><strong><span class="koboSpan" id="kobo.4.1">country name</span></strong><span class="koboSpan" id="kobo.5.1">, </span><strong><span class="koboSpan" id="kobo.6.1">country name abbreviation</span></strong><span class="koboSpan" id="kobo.7.1">, and </span><strong><span class="koboSpan" id="kobo.8.1">population estimate</span></strong><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">That’s already something to work with. </span><span class="koboSpan" id="kobo.9.3">However, let’s task ourselves with adding an additional data source to our globe, visualize it appropriately, and add a sensible interaction for user exploration.</span></p>
<p><span class="koboSpan" id="kobo.10.1">As a little reminder, this is what you will build:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1"><img height="315" width="495" src="assets/c7d07b70-2fa9-414f-ae6e-93ed530c9f35.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1">Our final Canvas adventure</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.13.1">View the final app at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-10-4"><span class="koboSpan" id="kobo.14.1">https://larsvers.github.io/learning-d3-mapping-10-4</span></a><span class="koboSpan" id="kobo.15.1"> and the code example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html"><span class="koboSpan" id="kobo.16.1">10_04.html</span></a><span class="koboSpan" id="kobo.17.1">.</span></div>
<p><span class="koboSpan" id="kobo.18.1">The preceding screenshot shows a globe visualization of forest cover per country. </span><span class="koboSpan" id="kobo.18.2">The data comes from the source of all solid wisdom, Wikipedia. </span><span class="koboSpan" id="kobo.18.3">The suggestion is to visualize it as a choropleth map. </span><span class="koboSpan" id="kobo.18.4">Arguably, choropleth maps have been overused in recent years, but they are nonetheless a great option to show percentage comparisons of geo-areas.</span></p>
<div class="mce-root packt_tip"><span class="koboSpan" id="kobo.19.1">The data is from </span><a href="https://en.wikipedia.org/wiki/List_of_countries_by_forest_area"><span class="koboSpan" id="kobo.20.1">https://en.wikipedia.org/wiki/List_of_countries_by_forest_area</span></a><span class="koboSpan" id="kobo.21.1">. </span><span class="koboSpan" id="kobo.21.2">The missing North Cyprus, Somaliland, and Haiti have been estimated.</span></div>
<p><span class="koboSpan" id="kobo.22.1">The steps are relatively simple. </span><span class="koboSpan" id="kobo.22.2">First, we add our forest data to our GeoJSON world object. </span><span class="koboSpan" id="kobo.22.3">We’ll move on swiftly to color our countries according to the new data, and finally add a tooltip with HTML and SVG.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Adding new data to our old globe</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">After copying and pasting or scraping the data from Wikipedia, you should save your forest file in a data format of your choice. </span><span class="koboSpan" id="kobo.2.2">We saved it in CSV, and as we now have several data sources to load for one visual, we will use </span><kbd><span class="koboSpan" id="kobo.3.1">d3.queue()</span></kbd><span class="koboSpan" id="kobo.4.1"> to wait for both files to load before invoking </span><kbd><span class="koboSpan" id="kobo.5.1">ready()</span></kbd><span class="koboSpan" id="kobo.6.1">:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">d3.queue()</span><br/><span class="koboSpan" id="kobo.8.1">  .defer(d3.json, 'data/world-110.json')</span><br/><span class="koboSpan" id="kobo.9.1">  .defer(d3.csv, 'data/forests.csv')</span><br/><span class="koboSpan" id="kobo.10.1">  .await(ready);</span></pre>
<p><span class="koboSpan" id="kobo.11.1">Then, adapt your </span><kbd><span class="koboSpan" id="kobo.12.1">ready()</span></kbd><span class="koboSpan" id="kobo.13.1"> function arguments and start accordingly:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">function ready(error, world, forests) {</span><br/><span class="koboSpan" id="kobo.15.1">  if (error) throw error;</span></pre>
<p><span class="koboSpan" id="kobo.16.1">Leave the country data prep as is (in that we push the world’s country arrays into a variable called </span><kbd><span class="koboSpan" id="kobo.17.1">countries</span></kbd><span class="koboSpan" id="kobo.18.1">) and move on to including the forest data into the world. </span><span class="koboSpan" id="kobo.18.2">What we want is this:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.19.1"><img height="189" width="352" src="assets/17c00718-1299-4794-b0a5-84855436574a.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1">The updated data object we strive for</span></div>
<p><span class="koboSpan" id="kobo.21.1">The properties we need for the coloring and the tooltip are country name (</span><kbd><span class="koboSpan" id="kobo.22.1">admin</span></kbd><span class="koboSpan" id="kobo.23.1">), </span><kbd><span class="koboSpan" id="kobo.24.1">forest_percent</span></kbd><span class="koboSpan" id="kobo.25.1">, and </span><kbd><span class="koboSpan" id="kobo.26.1">forest_area</span></kbd><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">Note, that we also have </span><kbd><span class="koboSpan" id="kobo.28.1">forest_color</span></kbd><span class="koboSpan" id="kobo.29.1"> here. </span><span class="koboSpan" id="kobo.29.2">This is the choropleth color for that country. </span><span class="koboSpan" id="kobo.29.3">It’s often beneficial to have your data in place before the draw. </span><span class="koboSpan" id="kobo.29.4">Hefty calculations during redraw can slow down performance and re-render.</span></p>
<p><span class="koboSpan" id="kobo.30.1">The forest CSV country names have been changed to match the exact naming of the countries GeoJSON. </span><span class="koboSpan" id="kobo.30.2">This way, you can use the names to join the two datasets. </span><span class="koboSpan" id="kobo.30.3">To join the data speedily, we will use </span><strong><span class="koboSpan" id="kobo.31.1">binary search</span></strong><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">Binary search leverages the sorted nature of our </span><kbd><span class="koboSpan" id="kobo.33.1">countries</span></kbd><span class="koboSpan" id="kobo.34.1"> array to find a country match quickly. </span><span class="koboSpan" id="kobo.34.2">In short, it looks at the country name we want to find, and instead of looping through all countries in the GeoJSON, it splits the </span><kbd><span class="koboSpan" id="kobo.35.1">countries</span></kbd><span class="koboSpan" id="kobo.36.1"> array in two halves and checks whether the search term is in the upper or the lower half. </span><span class="koboSpan" id="kobo.36.2">It does that repeatedly until it finds the term. </span><span class="koboSpan" id="kobo.36.3">This is much quicker than </span><strong><span class="koboSpan" id="kobo.37.1">linear search</span></strong><span class="koboSpan" id="kobo.38.1"> (looping through all data); in our case, around 10 times faster.</span></p>
<p><span class="koboSpan" id="kobo.39.1">You can implement binary search in D3 with </span><kbd><span class="koboSpan" id="kobo.40.1">d3.bisect()</span></kbd><span class="koboSpan" id="kobo.41.1"> and that’s what we shall use. </span><span class="koboSpan" id="kobo.41.2">We add the data with a function we call </span><kbd><span class="koboSpan" id="kobo.42.1">insertForestDataBinary()</span></kbd><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">We shall add this function call and the function to the data preparation flow in the </span><kbd><span class="koboSpan" id="kobo.44.1">ready()</span></kbd><span class="koboSpan" id="kobo.45.1"> function:</span></p>
<pre><span class="koboSpan" id="kobo.46.1">function insertForestDataBinary() {</span><br/><span class="koboSpan" id="kobo.47.1">  var bisectName = d3.bisector(function(d) { return d.properties.admin;</span><br/><span class="koboSpan" id="kobo.48.1">  }).right;</span><br/><span class="koboSpan" id="kobo.49.1">  for (var i = 0; i &lt; forests.length; i++) {</span><br/><span class="koboSpan" id="kobo.50.1">    var indexBisect = bisectName(countries.features, forests[i].country);</span><br/><span class="koboSpan" id="kobo.51.1">    var indexMatch = indexBisect - 1;</span><br/><span class="koboSpan" id="kobo.52.1">    countries.features[indexMatch].properties.forest_area = +forests[i].area;</span><br/><span class="koboSpan" id="kobo.53.1">    countries.features[indexMatch].properties.forest_percent = </span><br/><span class="koboSpan" id="kobo.54.1">    +forests[i].percent;</span><br/><span class="koboSpan" id="kobo.55.1">    countries.features[indexMatch].properties.forest_color =</span><br/><span class="koboSpan" id="kobo.56.1">    colorScale(+forests[i].percent);</span><br/><span class="koboSpan" id="kobo.57.1">  }</span><br/><span class="koboSpan" id="kobo.58.1"> }</span></pre>
<p><span class="koboSpan" id="kobo.59.1">First, you create a </span><em><span class="koboSpan" id="kobo.60.1">bisector</span></em><span class="koboSpan" id="kobo.61.1"> function so that D3 knows which variable we want to find a name (</span><kbd><span class="koboSpan" id="kobo.62.1">d.properties.admin</span></kbd><span class="koboSpan" id="kobo.63.1">, the country name). </span><span class="koboSpan" id="kobo.63.2">You then iterate through all forest objects. </span><span class="koboSpan" id="kobo.63.3">Each forest object holds the </span><kbd><span class="koboSpan" id="kobo.64.1">country</span></kbd><span class="koboSpan" id="kobo.65.1"> (the name we match), </span><kbd><span class="koboSpan" id="kobo.66.1">forest_percent</span></kbd><span class="koboSpan" id="kobo.67.1"> and </span><kbd><span class="koboSpan" id="kobo.68.1">forest_area</span></kbd> <span><span class="koboSpan" id="kobo.69.1">properties.</span></span><span class="koboSpan" id="kobo.70.1"> The bisector will search the array and return the index after the matching </span><kbd><span class="koboSpan" id="kobo.71.1">countries</span></kbd><span class="koboSpan" id="kobo.72.1"> object (or to the </span><kbd><span class="koboSpan" id="kobo.73.1">.right</span></kbd><span class="koboSpan" id="kobo.74.1">, as we specified above). </span><span class="koboSpan" id="kobo.74.2">Once you have that, you can add the new properties one index position before.</span></p>
<p><span class="koboSpan" id="kobo.75.1">For the last property, </span><kbd><span class="koboSpan" id="kobo.76.1">forest_color</span></kbd><span class="koboSpan" id="kobo.77.1">, you need to create a </span><kbd><span class="koboSpan" id="kobo.78.1">colorScale</span></kbd><span class="koboSpan" id="kobo.79.1"> somewhere in higher scope:</span></p>
<pre><span class="koboSpan" id="kobo.80.1">var colorScale = d3.scaleSequential(d3.interpolateYlGn).domain([0,1]);</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Coloring the globe</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Note that you have implemented all these changes before you draw the globe. </span><span class="koboSpan" id="kobo.2.2">That’s great as you can now simply draw it with the new color scheme. </span><span class="koboSpan" id="kobo.2.3">The only change is in our </span><kbd><span class="koboSpan" id="kobo.3.1">drawScene()</span></kbd><span class="koboSpan" id="kobo.4.1"> function, filling the </span><kbd><span class="koboSpan" id="kobo.5.1">countries</span></kbd><span class="koboSpan" id="kobo.6.1"> accordingly in a loop:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">function drawScene(countries, countryIndex) {</span><br/><span class="koboSpan" id="kobo.8.1">  // Clear the rect, draw the sphere and the graticule</span><br/><span class="koboSpan" id="kobo.9.1">  // Country fill - individual</span><br/><br/><span class="koboSpan" id="kobo.10.1">  countries.features.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.11.1">    bufferContext.beginPath();</span><br/><span class="koboSpan" id="kobo.12.1">    bufferPath(el);</span><br/><span class="koboSpan" id="kobo.13.1">    bufferContext.fillStyle = el.properties.forest_color;</span><br/><span class="koboSpan" id="kobo.14.1">    bufferContext.fill();</span><br/><span class="koboSpan" id="kobo.15.1">  });</span><br/><br/><span class="koboSpan" id="kobo.16.1">  // Draw the country stroke…</span><br/><span class="koboSpan" id="kobo.17.1">}</span></pre>
<p><span class="koboSpan" id="kobo.18.1">Also, note that we adjusted the sphere fill and the graticule colors a little to work better with our yellow-green country color scale:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.19.1"><img height="296" width="468" src="assets/d09ac20e-fb0d-45f4-ab4a-a6a21dbdfceb.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1">A choropleth globe visualizing forest cover ratio per country</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Adding a tooltip</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Your globe is colored by forest cover. </span><span class="koboSpan" id="kobo.2.2">Yellow countries have a low percentage of cover; dark green a higher one. </span><span class="koboSpan" id="kobo.2.3">That’s already a good clue about how much forest there is proportionally in each country. </span><span class="koboSpan" id="kobo.2.4">However, a user might additionally be interested in how high the forest cover is exactly, and how this compares to other countries. </span><span class="koboSpan" id="kobo.2.5">You have all the data in your hands, so let’s not be stingy, and add the following tooltip:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="249" width="172" src="assets/0d04cdee-f36b-4b53-9f4f-e4a6e336f1e0.png"/></span></div>
<div class="FigurePACKT packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">Our tooltip</span></div>
<p><span class="koboSpan" id="kobo.5.1">The visual on the tooltip shows a sorted bar chart of all countries, forest cover percentage, and a red indicator of the hovered country’s place in the overall distribution.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The HTML</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It is simple, as follows:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">&lt;div id="tooltip"&gt;</span><br/><span class="koboSpan" id="kobo.4.1">  &lt;div id="tip-header"&gt;</span><br/><span class="koboSpan" id="kobo.5.1">    &lt;h1&gt;&lt;/h1&gt;</span><br/><span class="koboSpan" id="kobo.6.1">    &lt;div&gt;&lt;/div&gt;</span><br/><span class="koboSpan" id="kobo.7.1">  &lt;/div&gt;</span><br/><span class="koboSpan" id="kobo.8.1">  &lt;div id="tip-body"&gt;</span><br/><span class="koboSpan" id="kobo.9.1">    &lt;svg id="tip-visual"&gt;&lt;/svg&gt;</span><br/><span class="koboSpan" id="kobo.10.1">  &lt;/div&gt;</span><br/><span class="koboSpan" id="kobo.11.1">&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.12.1">A tooltip wrapper </span><kbd><span class="koboSpan" id="kobo.13.1">div</span></kbd><span class="koboSpan" id="kobo.14.1">, a header with an </span><kbd><span class="koboSpan" id="kobo.15.1">h1</span></kbd><span class="koboSpan" id="kobo.16.1"> for the country, and a </span><kbd><span class="koboSpan" id="kobo.17.1">div</span></kbd><span class="koboSpan" id="kobo.18.1"> to hold the info. </span><span class="koboSpan" id="kobo.18.2">The following is a body with an SVG element to hold the bar chart. </span><span class="koboSpan" id="kobo.18.3">Note here that we add an HTML and SVG element to a Canvas, which is, of course, no problem. </span><span class="koboSpan" id="kobo.18.4">We could even draw SVG elements over the Canvas element or vice versa.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Building the static parts of the tooltip</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Next, we will build the tooltip. </span><span class="koboSpan" id="kobo.2.2">To be precise, we will build the </span><em><span class="koboSpan" id="kobo.3.1">static</span></em><span class="koboSpan" id="kobo.4.1"> part of the tooltip, that is, the bar chart. </span><span class="koboSpan" id="kobo.4.2">We will add the changing parts such as the header information and the red indicator as soon as we hover over the country. </span><span class="koboSpan" id="kobo.4.3">First, we twist the data into the right shape, and then we build a simple bar chart:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">function buildTooltip(data) {</span><br/><span class="koboSpan" id="kobo.6.1">  var forestsByPercent = data</span><br/><span class="koboSpan" id="kobo.7.1">    .slice()</span><br/><span class="koboSpan" id="kobo.8.1">    .sort(function(a, b) {</span><br/><span class="koboSpan" id="kobo.9.1">      return d3.descending(+a.percent, +b.percent);</span><br/><span class="koboSpan" id="kobo.10.1">    })</span><br/><span class="koboSpan" id="kobo.11.1">    .map(function(el) {</span><br/><span class="koboSpan" id="kobo.12.1">      return {</span><br/><span class="koboSpan" id="kobo.13.1">        country: el.country,</span><br/><span class="koboSpan" id="kobo.14.1">        percent: +el.percent,</span><br/><span class="koboSpan" id="kobo.15.1">        color: colorScale(+el.percent)</span><br/><span class="koboSpan" id="kobo.16.1">      };</span><br/><span class="koboSpan" id="kobo.17.1">    });</span><br/><br/><span class="koboSpan" id="kobo.18.1">  var countryList = forestsByPercent.map(function(el) {</span><br/><span class="koboSpan" id="kobo.19.1">    return el.country;</span><br/><span class="koboSpan" id="kobo.20.1">  });  </span></pre>
<p><span class="koboSpan" id="kobo.21.1">The data we pass into this function is—you guessed it</span><span><span class="koboSpan" id="kobo.22.1">—</span></span><span class="koboSpan" id="kobo.23.1">our forestry-boosted countries' GeoJSON. </span><kbd><span class="koboSpan" id="kobo.24.1">forestsByPercent</span></kbd><span class="koboSpan" id="kobo.25.1"> is just a sorted array of objects holding the data we need for the bar chart. </span><kbd><span class="koboSpan" id="kobo.26.1">countryList</span></kbd><span class="koboSpan" id="kobo.27.1"> is just an array of (also sorted) </span><kbd><span class="koboSpan" id="kobo.28.1">countries</span></kbd><span class="koboSpan" id="kobo.29.1"> we will use as an extension to our ordinal scale. </span><span class="koboSpan" id="kobo.29.2">The following is the resulting bar chart:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">    var tipWidth = 200,</span><br/><span class="koboSpan" id="kobo.31.1">        tipHeight = 200;</span><br/><br/><span class="koboSpan" id="kobo.32.1">    var xScale = d3.scaleLinear()</span><br/><span class="koboSpan" id="kobo.33.1">        .domain([0, 1])</span><br/><span class="koboSpan" id="kobo.34.1">        .range([0, tipWidth]);</span><br/><br/><span class="koboSpan" id="kobo.35.1">    var yScale = d3.scaleBand()</span><br/><span class="koboSpan" id="kobo.36.1">        .domain(countryList)</span><br/><span class="koboSpan" id="kobo.37.1">        .rangeRound([0, tipHeight]);</span><br/><br/><span class="koboSpan" id="kobo.38.1">    svg = d3.select('svg#tip-visual')</span><br/><span class="koboSpan" id="kobo.39.1">        .attr('width', tipWidth)</span><br/><span class="koboSpan" id="kobo.40.1">        .attr('height', tipHeight);</span><br/><br/><span class="koboSpan" id="kobo.41.1">    svg.selectAll('.bar')</span><br/><span class="koboSpan" id="kobo.42.1">        .data(forestsByPercent)</span><br/><span class="koboSpan" id="kobo.43.1">      .enter().append('rect')</span><br/><span class="koboSpan" id="kobo.44.1">        .attr('class', 'bar')</span><br/><span class="koboSpan" id="kobo.45.1">        .attr('id', function(d) { return stripString(d.country); })</span><br/><span class="koboSpan" id="kobo.46.1">        .attr('x', xScale(0))</span><br/><span class="koboSpan" id="kobo.47.1">        .attr('y', function(d) { return yScale(d.country); })</span><br/><span class="koboSpan" id="kobo.48.1">        .attr('width', function(d) { return xScale(d.percent); })</span><br/><span class="koboSpan" id="kobo.49.1">        .attr('height', yScale.bandwidth())</span><br/><span class="koboSpan" id="kobo.50.1">        .attr('fill', function(d) { return d.color; });</span><br/><br/><span class="koboSpan" id="kobo.51.1">  } // buildTooltip()</span></pre>
<p><span class="koboSpan" id="kobo.52.1">That was simple. </span><span class="koboSpan" id="kobo.52.2">By the way, we build all our interactive tooltip functions in the </span><kbd><span class="koboSpan" id="kobo.53.1">ready()</span></kbd><span class="koboSpan" id="kobo.54.1"> function. </span><span class="koboSpan" id="kobo.54.2">This way, we have access to all the data we need and have it all nicely cordoned off from any outside JavaScript scopes. </span><span class="koboSpan" id="kobo.54.3">In real life, it might be worth considering outsourcing interactivity to its own module to keep concerns separate.</span></p>
<p><span class="koboSpan" id="kobo.55.1">We call this </span><kbd><span class="koboSpan" id="kobo.56.1">buildTooltip()</span></kbd><span class="koboSpan" id="kobo.57.1"> function in </span><kbd><span class="koboSpan" id="kobo.58.1">ready()</span></kbd><span class="koboSpan" id="kobo.59.1"> after defining an </span><kbd><span class="koboSpan" id="kobo.60.1">svg</span></kbd><span class="koboSpan" id="kobo.61.1"> variable we can address from the other two tooltip functions, </span><kbd><span class="koboSpan" id="kobo.62.1">tooltipShow()</span></kbd><span class="koboSpan" id="kobo.63.1"> and </span><kbd><span class="koboSpan" id="kobo.64.1">tooltipHide()</span></kbd><span class="koboSpan" id="kobo.65.1"> which we will build next.</span></p>
<pre><span class="koboSpan" id="kobo.66.1">var svg;</span><br/><span class="koboSpan" id="kobo.67.1">buildTooltip(forests);</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Showing and hiding the tooltip</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We need a small chunk of logic to tell our app when to show and when to hide the tooltip. </span><span class="koboSpan" id="kobo.2.2">With SVG, this logic is usually straightforward, as we can leverage mouseover and mouseout. </span><span class="koboSpan" id="kobo.2.3">With Canvas, we only really have mousemove on the entire Canvas. </span><span class="koboSpan" id="kobo.2.4">So, we build our own mouseover and mouseout logic. </span><span class="koboSpan" id="kobo.2.5">We start in the mousemove handler called </span><kbd><span class="koboSpan" id="kobo.3.1">highlightPicking()</span></kbd><span class="koboSpan" id="kobo.4.1">:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">function highlightPicking() {</span><br/><br/><span class="koboSpan" id="kobo.6.1">  // Here, you find the country index and store it in pickedColor</span><br/><span class="koboSpan" id="kobo.7.1">  // and you check if the user’s mouse is in the globe or not with inGlobe</span><br/><br/><span class="koboSpan" id="kobo.8.1">  selected = inGlobe &amp;&amp; pickedColor[3] === 255 ? </span><span class="koboSpan" id="kobo.8.2">pickedColor[0] : false;</span><br/><span class="koboSpan" id="kobo.9.1">  requestAnimationFrame(function() {</span><br/><span class="koboSpan" id="kobo.10.1">    renderScene(countries, selected);</span><br/><span class="koboSpan" id="kobo.11.1">  });</span><br/><br/><span class="koboSpan" id="kobo.12.1">  var country = countries.features[selected];</span><br/><span class="koboSpan" id="kobo.13.1">  if (selected !== false) showTooltip(pos, country); // build tooltip</span><br/><span class="koboSpan" id="kobo.14.1">  if (selected === false) hideTooltip(); // remove tooltip</span><br/><span class="koboSpan" id="kobo.15.1">}</span></pre>
<p><span class="koboSpan" id="kobo.16.1">You store the data of the country the mouse is over in </span><kbd><span class="koboSpan" id="kobo.17.1">country.</span></kbd><span class="koboSpan" id="kobo.18.1"> If </span><kbd><span class="koboSpan" id="kobo.19.1">selected</span></kbd><span class="koboSpan" id="kobo.20.1"> holds a number (a country index), we trigger the creatively named function </span><kbd><span class="koboSpan" id="kobo.21.1">showTooltip()</span></kbd><span class="koboSpan" id="kobo.22.1"> and pass it the main Canvas’s mouse positions and the country. </span><span class="koboSpan" id="kobo.22.2">If </span><kbd><span class="koboSpan" id="kobo.23.1">selected</span></kbd><span class="koboSpan" id="kobo.24.1"> returns </span><kbd><span class="koboSpan" id="kobo.25.1">false</span></kbd><span class="koboSpan" id="kobo.26.1">, the mouse is not over a country, and we will trigger the equally creatively named function </span><kbd><span class="koboSpan" id="kobo.27.1">hideTooltip()</span></kbd><span class="koboSpan" id="kobo.28.1">.</span></p>
<p><span class="koboSpan" id="kobo.29.1">The key thing you want to figure out in </span><kbd><span class="koboSpan" id="kobo.30.1">showTooltip()</span></kbd><span class="koboSpan" id="kobo.31.1"> is when to build a new tooltip and when to just move the existing tooltip. </span><span class="koboSpan" id="kobo.31.2">You want to build a new tooltip when the mouse moves from one country to another country. </span><span class="koboSpan" id="kobo.31.3">You just want to move the tooltip along with the mouse when the mouse is within the borders of a specific country.</span></p>
<p><span class="koboSpan" id="kobo.32.1">We will achieve this by an array that will work like a </span><strong><span class="koboSpan" id="kobo.33.1">queue</span></strong><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">You can imagine a stack to stand up vertically, able to only add new data to the top or remove data from the top. </span><span class="koboSpan" id="kobo.34.3">In contrast, you can imagine a queue horizontally like a queue in front of an ice-cream shop. </span><span class="koboSpan" id="kobo.34.4">People arrive in the queue at the back and leave the queue at the front.</span></p>
<p><span class="koboSpan" id="kobo.35.1">Our queue will, however, only be two-people long. </span><span class="koboSpan" id="kobo.35.2">In fact, it won’t be two people long but two countries long. </span><span class="koboSpan" id="kobo.35.3">Whenever we move the mouse, the queue will be fed the country we’re over to one side of it (the front actually), immediately pushing off the country at the other side (the back). </span><span class="koboSpan" id="kobo.35.4">When we’re moving from one spot in the US to another spot in the US, it will say </span><kbd><span class="koboSpan" id="kobo.36.1">[“United States of America”, “United States of America”]</span></kbd><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">As soon as our mouse moves effortlessly over to Mexico, it will add </span><kbd><span class="koboSpan" id="kobo.38.1">“Mexico”</span></kbd><span class="koboSpan" id="kobo.39.1"> at the front of the queue, pushing the previously </span><em><span class="koboSpan" id="kobo.40.1">0</span></em><span class="koboSpan" id="kobo.41.1">-indexed </span><kbd><span class="koboSpan" id="kobo.42.1">“United States of America”</span></kbd><span class="koboSpan" id="kobo.43.1"> to index position </span><em><span class="koboSpan" id="kobo.44.1">1</span></em><span class="koboSpan" id="kobo.45.1"> and cutting off the array right there. </span><span class="koboSpan" id="kobo.45.2">Now, we have an array with </span><kbd><span class="koboSpan" id="kobo.46.1">[“Mexico”, “United States of America”]</span></kbd><span><span class="koboSpan" id="kobo.47.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Checking whether we change a country is now a simple affair of comparing the two values in our queue. </span><span class="koboSpan" id="kobo.48.2">If they are the same, we just move the mouse; if they are different, we create a new tooltip for Mexico.</span></p>
<p><span class="koboSpan" id="kobo.49.1">This is a textbook example of why SVG or HTML is often preferred over Canvas when the application is interaction heavy. </span><span class="koboSpan" id="kobo.49.2">Still, that wasn’t too bad, was it? </span><span class="koboSpan" id="kobo.49.3">Let’s implement it. </span><span class="koboSpan" id="kobo.49.4">First, you will need to define your yet-empty queue:</span></p>
<pre><span class="koboSpan" id="kobo.50.1">var countryQueue = [undefined, undefined];</span></pre>
<p><span class="koboSpan" id="kobo.51.1">Then, you need to write </span><kbd><span class="koboSpan" id="kobo.52.1">showTooltip()</span></kbd><span class="koboSpan" id="kobo.53.1">, taking in the mouse positions and the element, that is, the country the mouse is over:</span></p>
<pre><span class="koboSpan" id="kobo.54.1">function showTooltip(mouse, element) {</span><br/><span class="koboSpan" id="kobo.55.1">  var countryProps = element.properties;</span><br/><span class="koboSpan" id="kobo.56.1">  countryQueue.unshift(countryProps.admin);</span><br/><span class="koboSpan" id="kobo.57.1">  countryQueue.pop();</span></pre>
<p><span class="koboSpan" id="kobo.58.1">You save the country’s data in </span><kbd><span class="koboSpan" id="kobo.59.1">countryProps</span></kbd><span class="koboSpan" id="kobo.60.1">, add the country’s name to the front of the queue with JavaScript’s own </span><kbd><span class="koboSpan" id="kobo.61.1">.unshift()</span></kbd><span class="koboSpan" id="kobo.62.1"> method, and </span><kbd><span class="koboSpan" id="kobo.63.1">pop()</span></kbd><span class="koboSpan" id="kobo.64.1"> off the last value from the queue.</span></p>
<p><span class="koboSpan" id="kobo.65.1">Then, we will establish if there is a country change or not:</span></p>
<pre><span class="koboSpan" id="kobo.66.1">  if (countryQueue[0] !== countryQueue[1]) {</span><br/><span class="koboSpan" id="kobo.67.1">    var headHtml =</span><br/><span class="koboSpan" id="kobo.68.1">      'Forest cover: ' + formatPer(countryProps.forest_percent) + '' +</span><br/><span class="koboSpan" id="kobo.69.1">      '&lt;br&gt;Forested area: ' + formatNum(countryProps.forest_area) + '</span><br/><span class="koboSpan" id="kobo.70.1">       km&lt;sup&gt;2&lt;/sup&gt;';</span><br/><br/><span class="koboSpan" id="kobo.71.1">    d3.select('#tip-header h1').html(countryProps.admin);</span><br/><span class="koboSpan" id="kobo.72.1">    d3.select('#tip-header div').html(headHtml);</span><br/><br/><span class="koboSpan" id="kobo.73.1">    svg.selectAll('.bar').attr('fill', function(d) { return d.color; });</span><br/><span class="koboSpan" id="kobo.74.1">    d3.select('#' + stripString(countryProps.admin)).attr('fill', 'orange');</span><br/><br/><span class="koboSpan" id="kobo.75.1">    d3.select('#tooltip')</span><br/><span class="koboSpan" id="kobo.76.1">      .style('left', (mouse[0] + 20) + 'px')</span><br/><span class="koboSpan" id="kobo.77.1">      .style('top', (mouse[1] + 20) + 'px')</span><br/><span class="koboSpan" id="kobo.78.1">      .transition().duration(100)</span><br/><span class="koboSpan" id="kobo.79.1">      .style('opacity', 0.98);</span></pre>
<p><span class="koboSpan" id="kobo.80.1">If there is one, you fill the tooltip’s header with the country-specific information. </span><span class="koboSpan" id="kobo.80.2">You also color all bars according to the appropriate country color before the bar of this specific country gets colored red. </span><span class="koboSpan" id="kobo.80.3">The rest is just moving the tip along with the mouse and cranking its opacity up to make it visible.</span></p>
<pre><span class="koboSpan" id="kobo.81.1">If the queue values are the same, you just move the tip:</span><br/><span class="koboSpan" id="kobo.82.1">  } else {</span><br/><span class="koboSpan" id="kobo.83.1">    d3.select('#tooltip')</span><br/><span class="koboSpan" id="kobo.84.1">      .style('left', (mouse[0] + 20) + 'px')</span><br/><span class="koboSpan" id="kobo.85.1">      .style('top', (mouse[1] + 20) + 'px');</span><br/><span class="koboSpan" id="kobo.86.1">  }</span><br/><span class="koboSpan" id="kobo.87.1">}</span></pre>
<p><span class="koboSpan" id="kobo.88.1">Remember, </span><kbd><span class="koboSpan" id="kobo.89.1">showTooltip()</span></kbd><span class="koboSpan" id="kobo.90.1"> gets shown every time the mouse is over a country, and our selected variable gets filled with a country index. </span><span class="koboSpan" id="kobo.90.2">If </span><kbd><span class="koboSpan" id="kobo.91.1">selected</span></kbd><span class="koboSpan" id="kobo.92.1"> is false, we know we’re not over a country, meaning that we want to remove our tooltip. </span><span class="koboSpan" id="kobo.92.2">We do this with, well, </span><kbd><span class="koboSpan" id="kobo.93.1">hideTooltip():</span></kbd></p>
<pre><span class="koboSpan" id="kobo.94.1">function hideTooltip() {</span><br/><span class="koboSpan" id="kobo.95.1">  countryQueue.unshift(undefined);</span><br/><span class="koboSpan" id="kobo.96.1">  countryQueue.pop();</span><br/><span class="koboSpan" id="kobo.97.1">  d3.select('#tooltip')</span><br/><span class="koboSpan" id="kobo.98.1">    .transition().duration(100)</span><br/><span class="koboSpan" id="kobo.99.1">    .style('opacity', 0);</span><br/><span class="koboSpan" id="kobo.100.1">}</span></pre>
<p><span class="koboSpan" id="kobo.101.1">We decided to appropriately allocate </span><kbd><span class="koboSpan" id="kobo.102.1">undefined</span></kbd><span class="koboSpan" id="kobo.103.1"> to the queue if we’re not over a country, so we </span><kbd><span class="koboSpan" id="kobo.104.1">unshift()</span></kbd><span class="koboSpan" id="kobo.105.1"> it to the front of the queue and </span><kbd><span class="koboSpan" id="kobo.106.1">pop()</span></kbd><span class="koboSpan" id="kobo.107.1"> off the last value of the array to always keep it in pairs we can compare at the next move. </span><span class="koboSpan" id="kobo.107.2">Finally, we will transition the opacity back to zero and it is </span><span><span class="koboSpan" id="kobo.108.1">gone</span></span><span class="koboSpan" id="kobo.109.1"> again. </span><span class="koboSpan" id="kobo.109.2">That’s it! </span><span class="koboSpan" id="kobo.109.3">All done.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You have officially seen and used Canvas. </span><span class="koboSpan" id="kobo.2.2">You’ve reveled in its shining moments and mastered its quirks. </span><span class="koboSpan" id="kobo.2.3">You have started with a royal blue rectangle and have now successfully built a whole world, which you can spin, resize as desired, and retrieve country-specific information from. </span><span class="koboSpan" id="kobo.2.4">On the way, you have also seen how Canvas works in comparison to SVG. </span><span class="koboSpan" id="kobo.2.5">You have learned about the benefits and issues when coding a little closer to the graphics processing part of your machine.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The idea of these chapters has, of course, been to extend your technical skill set. </span><span class="koboSpan" id="kobo.3.2">However, beyond that, it’s the alternative concept of how to approach Canvas—the procedural style, the game loop routine, and the way Canvas interacts with D3</span><span><span class="koboSpan" id="kobo.4.1">—</span></span><span class="koboSpan" id="kobo.5.1">that broadens your horizon as a developer and allows for a different perspective to tackle problems.</span></p>


            </article>

            
        </section>
    </body></html>