<html><head></head><body>
        

                            
                    <h1 class="header-title">Adding Interactivity to Your Canvas Map</h1>
                
            
            
                
<p>In the preceding chapter, you saw one of the shining qualities of Canvas in action – animating thousands of points on the screen in a smooth animation. In this chapter, you will deal with one Canvas caveat: interaction. While interaction with HTML or SVG elements is straightforward, it requires a little more thought and some tricks to achieve with Canvas. In this chapter, you will follow along these thoughts and learn the tricks needed to do the following things:</p>
<ul>
<li>Making a globe move, and adding zoom and rotation interaction to it</li>
<li>Learning how to interact with Canvas elements through <strong>picking</strong></li>
<li>Retrieving data from a Canvas element to display it in a tooltip</li>
</ul>
<p>After this chapter, you will have covered all important facets of Canvas, drawing, animating, and, finally, interacting with Canvas.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Why Canvas interaction is different</h1>
                
            
            
                
<p>In the preceding chapter, you achieved a smooth animation of thousands of points by doing away with the DOM. The DOM is a representation of each element in browser memory. Bypassing it, you were dealing with much less overhead during animation. However, the DOM can be very useful for other goals in web development. High up on that list – especially for data visualization – is the <strong>interaction</strong> with elements on screen.</p>
<p>You can just add an <kbd>onmousemove</kbd> or <kbd>onclick</kbd> listener to an element. You can’t do that to elements on a Canvas. They are a pixel manifestation of past code, not represented as a model within the browser.</p>
<p>However, don’t despair, there are indirect yet simple techniques to interact with your Canvas. We’ll be looking at the most important techniques in this chapter, building an interactive globe:</p>
<div><img height="345" width="550" src="img/56ecc99f-4a88-4175-9571-e33a954922e0.png"/></div>
<p>A map of the world’s forest cover by country</p>
<p>Leaving flying planes behind, you will build a globe showing each country's forest cover percentage. The greener a country is (you guessed it), the higher the forest cover. As you can see in the preceding figure, you will have a tooltip showing country-specific information when hovering over each country. Users will further be able to rotate the globe and zoom into specific areas at their leisure.</p>
<p>You can view the final app at <a href="https://larsvers.github.io/learning-d3-mapping-10-4">https://larsvers.github.io/learning-d3-mapping-10-4</a> and a c<a href="https://larsvers.github.io/learning-d3-mapping-10-4">ode example at</a> <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html">10_04.html</a>.</p>
<div><p>At the conclusion of each step, you will find two links in an info box close to the relevant image. The first link brings you to a working implementation of this step that you can view in the browser. The second <em>code example</em> link brings you to the full code. If you're reading the print version, you can find all code examples at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping">https://github.com/larsvers/Learning-D3.js-4-Mapping</a> in their relevant chapter.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing the world on a Canvas</h1>
                
            
            
                
<p class="NormalPACKT">Let’s start drawing a globe. This is straightforward, very much building on the preceding chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up</h1>
                
            
            
                
<p>First, you will create a few variables required for initialization. We’ll come back to this list as the application grows, but, for now, it’s lean:</p>
<pre>var width = 960,<br/>    height = 600,<br/>    projectionScale = height / 2.1,<br/>    translation = [width / 2, height / 2];</pre>
<p>You are setting the <kbd>width</kbd> and <kbd>height</kbd> of the Canvas as well as the scale and the translation of the globe. Each projection has their own ideal starting scale. You can play with this number to find the right scale. You will use the <kbd>width</kbd> and <kbd>height</kbd> straight away, setting up the Canvas and its context:</p>
<pre class="mce-root">var canvas = d3.select('#canvas-container').append('canvas')<br/>    .attr('id', 'canvas-globe')<br/>    .attr('width', width)<br/>    .attr('height', height);<br/>var context = canvas.node().getContext('2d');</pre>
<p>No magic here. Note that we have a <kbd>div</kbd> with the <kbd>#canvas-container</kbd> ID in our HTML, in which you add the main Canvas.</p>
<p>Let’s also produce a <kbd>bufferCanvas</kbd>. You learned about the benefits of buffer Canvases in the preceding chapter. In short, rendering an image in memory and copying it onto your main Canvas is more performant than rendering an image directly onto the main Canvas:</p>
<pre class="mce-root">var bufferCanvas = document.createElement('canvas');<br/>var bufferContext = bufferCanvas.getContext('2d');<br/><br/>bufferContext.canvas.width = width;<br/>bufferContext.canvas.height = height;</pre>
<p>A rather central part of building a globe is the right projection. Building a globe reduces our options dramatically to the <kbd>d3.geoOrthographic()</kbd> projection, a 2D globe projection which is part of the standard d3-geo module. You already used it in <a href="d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml">chapter 5</a>, <em>Click-Click Boom! Applying Interactivity to Your Map</em>. Let's set it up first:</p>
<pre>var projection = d3.geoOrthographic()<br/>    .scale(projectionScale)<br/>    .translate(translation)<br/>    .clipAngle(90);</pre>
<p>We applied the scale and translation array we specified above, as well as the <kbd>.clipAngle()</kbd> to 90 degrees to always clip the backside of the projection, our globe.</p>
<p>As we use the <kbd>bufferCanvas</kbd> for all our drawings, we will tie our projection to a path generator that will exclusively draw to the buffer Canvas , as follows:</p>
<pre class="mce-root">var bufferPath = d3.geoPath()<br/>    .projection(projection)<br/>    .context(bufferContext);</pre>
<p class="mce-root">There are two more geo helpers you will create: a base <strong>sphere</strong> and a <strong>graticule</strong>:</p>
<pre class="mce-root">var sphere = { type: 'Sphere' };<br/>var grid = d3.geoGraticule()();</pre>
<p>Both are geo-visualization primitives. The <strong>sphere</strong> is, well, a sphere you use to underlay your globe with. You can then fill it or give it an outline to give your globe a round shape beyond the countries. A <strong>graticule</strong> is a grid of the main meridians (longitude lines) and parallels (latitude lines) 10 degrees apart from each other (and, yes, you need four parentheses to produce the actual graticule object). We shall see them in action very soon.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing the world</h1>
                
            
            
                
<p>The scene is set. In this section, you will load some country shape data to draw the world. You will set up four small functions to achieve the draw:</p>
<ul>
<li>A <kbd>data load</kbd> function</li>
<li>A <kbd>ready()</kbd> function that prepares the data and passes it on to the render function</li>
<li>A <kbd>renderScene()</kbd> function that kicks off the world draw and copies the final image from the buffer onto the main Canvas</li>
<li>A <kbd>drawScene()</kbd> function that renders the world onto the <kbd>bufferCanvas</kbd>.</li>
</ul>
<p>This might sound overkill for just drawing a static globe, and let me assure you it is. However, we are aiming for higher goals, which will be greatly helped by having this structure set up already.</p>
<p>The data load function just requests the data and passes it on to the <kbd>ready()</kbd> function:</p>
<pre class="mce-root">d3.json('../../data/world/world-110.json', function(error, data) {<br/>  if(error) throw error;<br/>  ready(data);<br/>});</pre>
<p class="mce-root">The <kbd>ready()</kbd> function doesn’t really add much more complexity so far:</p>
<pre class="mce-root">function ready(world) {<br/>  var countries = topojson.feature(world,<br/>  world.objects.ne_110m_admin_0_countries); <br/>  renderScene(countries);<br/>}</pre>
<p class="mce-root">It turns the TopoJSON to an array of GeoJSON <kbd>countries</kbd> and calls <kbd>renderScene()</kbd>. <kbd>renderScene()</kbd> does what we’ve already described in the preceding code. It draws the globe on the <kbd>bufferContext</kbd> in thin air, and as soon as it’s done, copies it over to the freshly cleared main Canvas:</p>
<pre class="mce-root">function renderScene(world){<br/>  drawScene(world);<br/>  context.clearRect(0, 0, width, height);<br/>  context.drawImage(bufferCanvas, 0, 0, bufferCanvas.width,<br/>  bufferCanvas.height);<br/>}</pre>
<p class="mce-root">Although <kbd>drawScene()</kbd> is our longest function, it’s not very complex:</p>
<pre class="mce-root">function drawScene(countries) {<br/> <br/>  bufferContext.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);<br/>  // Sphere fill<br/>  bufferContext.beginPath(); <br/>  bufferPath(sphere);<br/>  bufferContext.fillStyle = '#D9EAEF';<br/>  bufferContext.fill();<br/>  <br/>  // Grid<br/>  bufferContext.beginPath();<br/>  bufferPath(grid);<br/>  bufferContext.lineWidth = 0.5;<br/>  bufferContext.strokeStyle = '#BDDAE3';<br/>  bufferContext.stroke();<br/><br/>  // Country fill<br/>  bufferContext.beginPath();<br/>  bufferPath(countries);<br/>  bufferContext.fillStyle = '#FFFAFA';<br/>  bufferContext.fill();<br/><br/>  // Country stroke<br/>  bufferContext.beginPath();<br/>  bufferPath(countries);<br/>  bufferContext.lineWidth = 0.5;<br/>  bufferContext.strokeStyle = '#D2D3CE';<br/>  bufferContext.stroke();<br/><br/>}</pre>
<p>It clears the <kbd>buffer</kbd> context, then draws a base sphere in a light blue and a graticule grid in a slightly more saturated blue. It then fills the countries in a light gray color and strokes each country in a darker gray. That’s it. Here’s your very own Canvas globe:</p>
<div><img height="262" width="415" src="img/6915f37c-f7cf-4031-9c94-d8b518d15d60.png"/></div>
<p>A static Canvas globe</p>
<p>View this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-10-1">https://larsvers.github.io/learning-d3-mapping-10-1</a> and a code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_01.html">10_01.html</a>.</p>
<p>Great! You learned to draw a Canvas globe, which is nice, even if a little mono-dimensional. So, let’s add our first bit of interaction with it and let the users (and ourselves) zoom and rotate the globe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making the world move</h1>
                
            
            
                
<p>Zooming into and rotating a globe projection is a truly joyous pastime, I find. Apart from being such fun, it’s also extremely useful when dealing with globe projections, as the user needs to be able to view the world from different angles.</p>
<p>In this section, we will add our first bit of Canvas interactivity to the globe. We will equip the users with the ability to zoom into and rotate the globe. Apart from setting up two additional global variables, we will exclusively do work in the <kbd>ready()</kbd> function–our central function tasked to prepare the data. From now onward, it will also deal with interactivity, right here:</p>
<pre class="mce-root">function ready(world) {<br/>  var countries = topojson.feature(world, <br/>  world.objects.ne_110m_admin_0_countries);<br/>  requestAnimationFrame(function() {<br/>    renderScene(countries);<br/>  });<br/><br/>  /* Interactivity goes here */<br/>}</pre>
<p>Also, note that we wrapped our <kbd>renderScene()</kbd> function into a <kbd>requestAnimationFrame()</kbd> function to always let the browser decide the best time point for a new render.</p>
<p>Note, that here is a prominent and often preferred way to deal with zooming and panning (not so much rotating) in D3 using <kbd>context.scale()</kbd> and <kbd>context.translate()</kbd>. However, to implement both zooming and rotating, we won’t use these in-built methods, but will change the projection instead. We’ll get back to the why a little later as it becomes clear on the way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the behavior</h1>
                
            
            
                
<p>Zooming is no more than changing the scale for our projection. Rotating is no more than changing the rotation values of our projection. When you want the user to mandate zoom and rotation, you will need to listen to their mouse movement. As such, you will need to set up a zoom listener to track the user's mouse wheel and drag moves, and attach it to the Canvas. We implemented zoom and rotation already in <a href="d2d3d4c7-b83a-4947-993a-84baa0f01674.xhtml">chapter 5</a>, <em>Click-Click Boom! Applying Interactivity to Your Map</em>. In our <kbd>ready()</kbd> function, as specified above, we will use D3’s zoom behavior to deliver all the user interaction changes we need:</p>
<pre class="mce-root">var zoom = d3.zoom()<br/>   .scaleExtent([0.5, 4])<br/>   .on("zoom", zoomed);<br/><br/>canvas.call(zoom);<br/><br/>function zoomed() { // our handler code goes here }</pre>
<p>First, you create the zoom behavior with <kbd>d3.zoom()</kbd>, define scaling bounds between <em>0.5</em> and <em>4</em>, and inform the behavior to trigger our <kbd>zoomed()</kbd> handler as soon as a <kbd>“zoom”</kbd> event has been triggered. However, so far, this has been a blunt tool. To understand what it does, you have to call it on an element. Call it on your Canvas element, and that element will be the sensor of all zoom-related user events. Importantly, it will listen for mouse wheel and drag events and expose the event information in the global <kbd>d3.event</kbd> object. It will further store the information in the base element it got called on (in our case, the main Canvas), but we’ll be happily served by the <kbd>d3.event</kbd> object you can tap into at each event.</p>
<p>Further, we want to set up some variables for tracking our scale and rotation whereabouts during zoom. We do this at the very top of our code with the following global variables:</p>
<pre>var width = 960,<br/>    height = 600,<br/>    projectionScale = origProjectionScale = height / 2.1,<br/>    translation = [width / 2, height / 2],<br/>    projectionScaleChange,<br/>    prevTransformScale = 1,<br/>    rotation;</pre>
<p>The newcomers in the preceding code are <kbd>origProjectionScale</kbd>, <kbd>projectionScaleChange</kbd>, <kbd>prevTransformScale</kbd>, and <kbd>rotation</kbd>. Their mission will become clear in the following paragraphs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling zoom and rotation</h1>
                
            
            
                
<p>We set up the zoom behavior, meaning that our Canvas is</p>
<ol>
<li>listening on every mouse wheel and drag</li>
<li>firing the <kbd>zoomed()</kbd> handler on each of these events</li>
</ol>
<p>Let’s now fill our handler to do something to the globe.</p>
<p>What do we want to do? From a bird’s perspective, for each zoom, we want to establish the scale for the projection, apply it to the path, and redraw the globe a little bit bigger or a little smaller. For each drag, we would want to establish the new rotation values, apply them to the projection and path, and redraw the globe a little bit rotated. To get there, the handler should distinguish between a zoom and a drag. A zoom should lead to a projection-scale change and a drag should lead to a rotation change. For each path, you calculate the position change. Once that’s done, you will need to redraw the globe. It’s the game-loop mantra: process user-input, clear the Canvas, then redraw the Canvas with updated data.</p>
<p>Let’s start with the zoom action:</p>
<pre>function zoomed() {<br/>  var event = d3.event.sourceEvent.type;     <br/><br/>  if (event === 'wheel') {<br/>    var transformScale = d3.event.transform.k;<br/>    projectionScaleChange = (transformScale – prevTransformScale) *<br/>    origProjectionScale;<br/>    projectionScale = projectionScale + projectionScaleChange;<br/>    projection.scale(projectionScale);<br/>    prevTransformScale = transformScale;<br/>  } else if (event === 'mousemove'){<br/>    // Here goes the rotation logic as this will be triggered upon dragging<br/>  }<br/> <br/>  requestAnimationFrame(function() {<br/>    renderScene(countries);<br/>  });<br/>}</pre>
<p>At first, we will need to distinguish between a zoom and a drag event. D3 makes this easy for us with the <kbd>d3.event</kbd> object holding a <kbd>sourceEvent</kbd> property specifying what event <kbd>type</kbd> the user triggers. If it’s a <kbd>wheel</kbd> event, we change the scale if it's a <kbd>mousemove</kbd> event, we change the rotation. Simple.</p>
<p>Changing the scale looks involved but is pretty straightforward. Before we dive into the code, let’s make one important distinction. The projection has a scale, and the transformation upon user zoom also has a scale. However, they are different. Projection scales differ between projections. Our <kbd>d3.geoOrthographic()</kbd> projection has an initial scale of around <em>286</em> (we set it to <em>height / 2.1 = 286</em>). Our transformation has an initial scale of <em>1</em>. That’s the default.</p>
<p>So, you retrieve the current <kbd>transformScale</kbd> via <kbd>d3.transform.k</kbd>. You note down the change of this scale to the previous transform scale, which can be negative for zoom in or positive for zoom out. However, as your projection scale is quite a big number (as in <em>286</em> to start with) and the transform scale change per zoom will be small (for a normal mouse wheel turn the change might be around <em>0.005</em>), you will want to boost this number up to get a noticeable change in your projection. Hence, you will multiply it with a larger number. You can choose any large number you like, but choosing your initial projection scale we called <kbd>origProjectionScale</kbd> allows you to port this calculation over to any other projection, and it should work nicely. You then just change the current <kbd>projectionScale</kbd> by this <kbd>projectionScaleChange.</kbd></p>
<p>The rest is simple. Just apply it to your globe’s projection with <kbd>projection.scale(projectionScale)</kbd>, set the previous transform scale to the updated transform scale, and re-render the globe. Note, that you don’t need to update the path generator, as whenever it’s called, it will use the projection as is at the moment of being called, which we’ve changed accordingly.</p>
<p>That was the hard bit. Rotating is even simpler. You just need to track the changes in the user’s mouse movements and apply them to D3’s <kbd>projection.rotate()</kbd> parameters. Let’s track the change in mouse coordinates right at the top of the <kbd>zoomed()</kbd> handler:</p>
<pre>function zoomed(<br/>  var dx = d3.event.sourceEvent.movementX;<br/>  var dy = d3.event.sourceEvent.movementY;<br/><br/>  // all the rest</pre>
<p>Note, that the two <kbd>MouseEvent</kbd> properties <kbd>.movementX</kbd> and <kbd>.movementY</kbd> are not available in Safari or Internet Explorer. You can see a cross-browser implementation, which is calculating the two values on the fly in code example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html#L237">10_02.html</a> at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping">https://github.com/larsvers/Learning-D3.js-4-Mapping</a>.</p>
<p>The rotation logic will trigger when the user drags or rather triggers the <kbd>mousemove</kbd> event, which goes into the <kbd>else if</kbd> part of our conditional:</p>
<pre>if (event === ‘wheel’) {<br/>  // here goes the zoom logic described previously <br/>} else if (event === ‘mousemove’) {<br/> var r = projection.rotate();<br/> rotation = [r[0] + dx * 0.4, r[1] - dy * 0.5, r[2]];<br/> projection.rotate(rotation);<br/>} else { <br/>  console.warn('unknown mouse event in zoomed()'); // alerting issues<br/>}</pre>
<p>In the preceding code, we first retrieve the current rotation values from the projection in the variable <kbd>r</kbd>. Then, you change the <kbd>r[0]</kbd>, the yaw value (responsible for rotating the world around its normal or vertical axis) by the <em>x</em> change of the mouse coordinates. You further change <kbd>r[1]</kbd>, the roll value (rotating the world around its lateral axis, going horizontally from left to right) by the y change of the mouse coordinates. We leave the third pitch value as is, and yes, the best way is to throttle these values to a reasonable speed of rotation with <kbd>dx * 0.4</kbd> and <kbd>dy * 0.5</kbd>, respectively. Note that this is the straightforward but naive way to rotate the globe. It will fully do in our case. If you want to apply utmost precision, you could use <strong>versor</strong> dragging (check out <a href="http://tiny.cc/versor">http://tiny.cc/versor</a>). The key difference is that versor dragging rotates the globe in the right direction even when it's upside down.</p>
<p>That’s it for rotation. Remember, the world gets re-rendered after this conditional as we do this in the following Canvas game loop: get user input – calculate the new position – re-render.</p>
<p>Here’s a static attempt to show dynamic zooming and rotations:</p>
<div><img src="img/ed98d35d-88fb-4cf9-bf78-115e400d2056.png"/></div>
<p>Zooming and rotating a Canvas globe</p>
<p>View the step shown in the preceding screenshot in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-10-2">https://larsvers.github.io/learning-d3-mapping-10-2</a> and its code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_02.html">10_02.html</a>.</p>
<p>The main benefit of zooming via a projection change is that it allows rotating (that’s a win) and guarantees <strong>semantic zooming</strong> of the world rather than <strong>geometric zooming</strong>. When you zoom into a Canvas object with <kbd>context.scale()</kbd>, it naively enlarges anything that’s on the Canvas. So, a country border, for example, gets wider and wider, the more you scale it. That’s <strong>geometric zooming</strong>. We, however, want to keep everything constant, apart from the area of the individual country polygons. This is called <strong>semantic zooming</strong>. Another benefit of the <strong>projection change</strong> is that getting the coordinate of a Canvas object by mouse-over is more straightforward. This is our next stop.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding the Canvas object under the mouse - Picking</h1>
                
            
            
                
<p>We’ve done zooming and rotating. Let’s celebrate by adding another key piece of interactivity: the mouseover. In fact, we don’t want just any mouseover. We want to mouse over an object drawn on the Canvas and retrieve information from that object. Once we have that, we have a lot—we can create tooltips, we can highlight the object, we can link views with another graph showing the same data point, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Picking, the theory</h1>
                
            
            
                
<p>So, how are we doing this? As established many times above, we can’t just add a listener to a set of pixels, because an event is an object maintained by the browser, interacting with DOM nodes. However, our browser doesn’t know about the pixel. It doesn’t have a representation of the Canvas pixels it wants to interact with. So, how?</p>
<p>The answer is relatively simple: we build it ourselves. Not the DOM, that would be madness, but a representation of our Canvas drawing in which the target object’s pixel are charged with this object’s information.</p>
<p>So, what do we need to build our own little visual object representation? In short, you will build two Canvases. One <strong>main Canvas</strong> that produces our visual (done already) and one <strong>hidden Canvas</strong> (as in you can’t see it) that produces the same visual. The key here is that all elements on the second Canvas will be at the same position in relation to the Canvas origin compared to the first Canvas. We will bend this rule a little in practice, but, for now, imagine that the northern tip of Scotland is at pixel position <em>250, 100</em> of the main Canvas and that it is also at <em>250, 100</em> of the hidden Canvas.</p>
<p>There is only one key difference between the main and the hidden Canvas. Each element on the hidden Canvas will get a <strong>unique color</strong>. What’s more, these color values will be indexes to look up our data values. In our case, we will assign <em>rgb(0,0,0)</em> to the first country in our country list: Afghanistan. Our second country will get the color value <em>rgb(1,0,0)</em> and so on until our last country–Zimbabwe–will get the color value <em>rgb(176,0,0)</em>.</p>
<p>Why? Because, next, we will attach a mousemove listener to the main Canvas to retrieve a flow of mouse positions as we move the mouse. At each mouse position, we can use the Canvas's own method <kbd>context.getImageData()</kbd> to pick the color of the pixel at this exact position. We just extract the R value from our RGB color and can query our data array to get the object we need.</p>
<p>Our itinerary is clear and, with three steps, relatively short. First, we will create the hidden Canvas. Secondly, we will draw the world with a unique color per country. Finally, we will write the mousemove handler to pick the color and get the data. Lastly, we have to decide what to do with all that data we can access.</p>
<p>Before we start, let’s make sure that we actually have some data for each country. Here’s our GeoJSON country object that shows the contents of the first two of 177 countries:</p>
<div><img height="330" width="313" src="img/51458214-8499-4fd2-87cf-988d935ffcd7.png"/></div>
<p>The data properties of the country’s array</p>
<p>Our GeoJSON world is a <kbd>FeatureCollection</kbd> with one feature per country, ascendingly sorted by country name. Each feature is an object holding a <kbd>type</kbd> property, the <kbd>geometry</kbd> for the country polygon, and a property called <kbd>properties</kbd>. In here, we have three data points: the country abbreviation, the country name, and even an estimate of the country’s population. Now, let’s get to that data by mouse over.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating all things hidden</h1>
                
            
            
                
<p>By now, you’ve set up so many Canvases that, at worst, this code just bores you:</p>
<pre class="mce-root">var hiddenCanvas = d3.select('#canvas-container').append('canvas')<br/>    .attr('id', 'canvas-hidden')<br/>    .attr('width', width)<br/>    .attr('height', height);<br/><br/>var hiddenContext = hiddenCanvas.node().getContext('2d');</pre>
<p>The only thing we want to make sure of here is to apply the same width and height that we applied to the main Canvas.</p>
<p>Next, we will draw the world to it. In order to do so, we have to build a projection and path generator and then loop through all countries to draw each country to the Canvas; let's do that:</p>
<pre>var hiddenProjection = d3.geoEquirectangular()<br/>    .translate([width / 2, height / 2])<br/>    .scale(width / 7);<br/><br/>var hiddenPath = d3.geoPath()<br/>    .projection(hiddenProjection)<br/>    .context(hiddenContext);</pre>
<p>We, of course, need a new path generator, as we need to feed our now hidden drawing context to the <kbd>.context()</kbd> method. However–hold on–we already have a projection for the main Canvas. Shouldn’t we use it for the hidden Canvas also? Especially, as we said above that ideally the objects on our hidden Canvas should be in the exact same position as the objects on our main Canvas to query the hidden positions easily? However, here, we use an <strong>equi-rectangular</strong> projection, which will draw the world in a rather different way to our <strong>orthographic</strong> projection on the main Canvas. Don’t we need the same projection to produce the same globe?</p>
<p>The answer is no, we don’t need the same projection. When our mouse is on a specific position on the main Canvas, we just need to find the same position on the hidden Canvas. No doubt, the easiest way to do this is to use the exact same coordinates. However, we can also use the main projection’s <kbd>projection.invert([x,y])</kbd> function to retrieve this position’s longitude and latitude values. We will then use the hidden projection to convert the geo-coordinates to pixel coordinates on the hidden Canvas. Long-winded? Yes, a little. However, with a moving object such as a zooming and rotating globe, this saves us from re-drawing the hidden Canvas. We shall see this in action very soon when we build the handler in the third step.</p>
<p>First, let’s draw the hidden Canvas.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing the hidden Canvas</h1>
                
            
            
                
<p>There’s just a single simple function that does what you need in this step:</p>
<pre>function drawHiddenCanvas(world) {<br/>  var countries = world.features;<br/>  countries.forEach(function(el, i) {<br/>    hiddenContext.beginPath();<br/>    hiddenPath(el);<br/>    hiddenContext.fillStyle = 'rgb(' + i + ',0,0)';<br/>    hiddenContext.fill();<br/>  });<br/>}</pre>
<p>The only argument—<kbd>world</kbd>—is our GeoJSON feature collection. <kbd>countries</kbd> pulls out just the array of country information, including the polygons and the additional data we’re after. We loop through all of them, drawing each country with the <kbd>hiddenContext</kbd> and — most importantly—we gave each country a color using the <kbd>rgb(&lt;country index&gt;, 0, 0)</kbd> pattern.</p>
<p>Here we have it! A graph-like structure of our Canvas visual, representing our data.</p>
<p>So far, it’s only a function, so let’s invoke it. We only need to call <kbd>drawHiddenCanvas()</kbd> once whenever we have the data available. So, we venture to the <kbd>ready()</kbd> function and invoke it right after we draw the main Canvas with <kbd>renderScene()</kbd>:</p>
<pre>  requestAnimationFrame(function() {<br/>    renderScene(countries);<br/>    drawHiddenCanvas(countries);<br/>  });</pre>
<p>Here they are; our two worlds:</p>
<div><img height="394" width="315" src="img/c5b95c2f-20ad-4338-8e97-53477c1ec9f7.png"/></div>
<p>The main and the hidden Canvas</p>
<p>Each country has a slightly different color, ranging from black to red or from <em>rgb(0,0,0)</em> = <em>Afghanistan</em> to <em>rbg(176,0,0) = Zimbabwe</em>. You can see how countries that start high up in the alphabet—Antarctica, Australia, Brasil, or Canada—are much darker than countries that are low down in the alphabet—the United States or Russia. Note that we’ll keep our hidden Canvas visible for demonstration purposes, but, in production, we can just add the CSS rule <kbd>{ display: hidden }</kbd> to hide our Canvas. No one needs to know about our little trick.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Picking the values</h1>
                
            
            
                
<p>At this point, you have all tools at hands to implement a hover. Now, you will need to make it happen. To wire it all up, you need to do the following steps:</p>
<ol>
<li>Listen to mousemoves on the main Canvas.</li>
<li>Translate these coordinates to positions on the hidden Canvas.</li>
<li>Pick the color from that position.</li>
<li>Strip out the color value that represents the data array index for your data.</li>
<li>Lean back and think of ways to use it.</li>
</ol>
<p>Listening on mousemove is easy; you just need to perform the following command:</p>
<pre>canvas.on('mousemove', highlightPicking);</pre>
<p>Done. The first thing we will do in <kbd>highlightPicking()</kbd> is translate the mouse position on the main Canvas to the coordinates on the hidden Canvas:</p>
<pre>function highlightPicking() {<br/>  var pos = d3.mouse(this);<br/>  var longlat = projection.invert(pos);<br/>  var hiddenPos = hiddenProjection(longlat);</pre>
<p>We first get the <em>x, y</em> mouse coordinates. This will be updated whenever we move the mouse. An example value of the <kbd>pos</kbd> variable is <em>[488, 85]</em>, which is in the north of France. We use D3’s own <kbd>projection.invert()</kbd> which is the inverse of <kbd>projection()</kbd>. What does <kbd>projection()</kbd> do? It takes an array of [longitude, latitude] values and returns a pair of [x, y] pixel coordinates. Well, <kbd>projection.invert()</kbd> does the opposite. It takes a pixel coordinate array and returns the respective longitude and latitude array. In our case, that will be [2.44, 48.81]. The longitude is a bit further right of <em>0</em>, which is Greenwich, so yes, that seems right. Note, that this projection is our main Canvas projection. Next, we use our <kbd>hiddenProjection()</kbd> function to reproject our <kbd>longlat</kbd> values to the pixel coordinates of this very place. In our example, <kbd>hiddenPos</kbd> gets the pixel coordinates [485.83, 183.17] assigned to it. That’s the very same spot in the north of France on the hidden Canvas! Exactly what we were after.</p>
<p>To demonstrate this, take a look at the following screenshots:</p>
<div><img height="191" width="476" src="img/6b5b3bee-eb0d-421b-bf5c-ece23935491a.png"/></div>
<p>Translating the main Canvas mouse coordinates to the hidden Canvas coordinates</p>
<p>Our mouse position on the upper main Canvas represented by <kbd>pos</kbd> gets translated to the lower orange circle represented by the <kbd>hiddenPos</kbd> variable.</p>
<p>Now, we finally get to pick that color:</p>
<pre>var pickedColor = hiddenContext.getImageData(hiddenPos[0], hiddenPos[1], 1, 1).data;</pre>
<p>This returns a special array with the unwieldy name <kbd>Uint8ClampedArray</kbd> representing the R, the G, the B, and the alpha value (peculiarly also ranging from <em>0</em> to <em>255</em>) at exactly that pixel. In our case, for example, for France (the left most pick in the preceding screenshot), the color is <kbd>52</kbd>:</p>
<div><img height="174" width="374" src="img/82452b63-cb05-49c3-bce9-aa1860dde291.png"/></div>
<p>The picked color array</p>
<p>Cross-checking with our <kbd>countries</kbd> array, we can confirm that the array element with the index <kbd>52</kbd> is <strong>France</strong>.</p>
<p>However, we will build in two security checks before we can be sure of hovering over a country. First, you will check whether the user’s mouse is on the globe and not somewhere in the outer space:</p>
<pre>var inGlobe =<br/>    Math.abs(pos[0] - projection(projection.invert(pos))[0]) &lt; 0.5 &amp;&amp;<br/>    Math.abs(pos[1] - projection(projection.invert(pos))[1]) &lt; 0.5;</pre>
<p>In an ideal world, for our purpose, <kbd>projection.invert(pos)</kbd> above would return <kbd>undefined</kbd> or similar when we move beyond the globe; however, it still returns actual pixel coordinates, which is not what we want. The problem is that <kbd>projection.invert()</kbd> is not <strong>bijective</strong>, meaning it can in fact return the same <em>[long, lat]</em> coordinates for different pixel position inputs. This is especially the case when we move the mouse beyond the globe bounds. To alleviate this issue, we do a so called <strong>forward projection</strong> here. This just means that we project the inverse of our projection. We take in the pixel coordinates, translate them to <em>[long, lat]</em> values and project them back to pixel coordinates. If our mouse is within the globe, this will return our exact mouse position (in fact we give it a leeway of +/- 0.5 pixels here). If our mouse is outside the globe, the forward projection will deviate from our mouse position in pixel.</p>
<p>The second check we perform is to make sure that our mouse is over a country and not a country border:</p>
<pre>selected = inGlobe &amp;&amp; pickedColor[3] === 255 ? pickedColor[0] : false;</pre>
<p>Let’s take this one by one. <kbd>selected</kbd> will hold the index. You will, however, only get the index if the user’s mouse is inside the globe (<kbd>inGlobe</kbd> === <kbd>true</kbd>). This is our first check. Secondly, the fourth element of our special <kbd>pickedColor</kbd> array has to be exactly <em>255</em>. Otherwise, selected will be false. This second check is to surpass <strong>antialiasing</strong> effects.</p>
<p>Why do we need that? The problem with pixels in browsers is that they outsmart us. Lines are feathered at the edges to allow the impression of a smooth transition from line to background:</p>
<div><img height="174" width="382" src="img/e529dada-a2c0-4afb-a9f9-ef0b1f473653.png"/></div>
<p>An aliased line above an antialiased line</p>
<p>Picking values at these feathered edges would not return fully opaque colors, but transparent values of varying degree. These values have an alpha channel lower than 255, so checking for our alpha to be 255 allows us to pick only from aliased areas.</p>
<p class="mce-root">Fabulous! We’ve built ourself a second Canvas that functions as a memory of the objects on our main data. Next, we’ll use it. The Canvas way of changing anything with our elements and objects is to pass the information to the redrawing part of our app to use it in there accordingly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Storing more data and using a lookup array</h1>
                
            
            
                
<p>We are blessed with the fact that the world we visualize only has 176 countries. This way, we only need to keep track of 176 indeces. However, you often deal with more data objects so that 256 (as in 0-255) will be used up rather quickly. Luckily, we not only have R but also G and B values and their unique combinations, which gets us to <em>256*256*256 = 16,777,216</em> possible indeces you can store. That will bring you far.</p>
<p>Check the tutorial at <a href="http://tiny.cc/d3-canvas">http://tiny.cc/d3-canvas</a> for more details.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Highlighting the country on mouse over</h1>
                
            
            
                
<p>Whenever a country is picked, we just pass the selected variable through to our <kbd>drawScene()</kbd> function that draws the world at each mouseover:</p>
<pre>  // ...<br/>  selected = inGlobe &amp;&amp; pickedColor[3] === 255 ? pickedColor[0] : false;<br/><br/>  requestAnimationFrame(function() {<br/>    renderScene(countries, <strong>selected</strong>);<br/>  });<br/><br/>} // highlightPicking()</pre>
<p>At the end of our highlight handler, we didn’t only pass the <kbd>countries</kbd> to our render function, we also sent our newly created <kbd>selected</kbd> on the way. The <kbd>renderScene()</kbd> function just passes it through to <kbd>drawScene()</kbd>, which draws the world to the <kbd>buffer</kbd> Canvas. Remember that <kbd>renderScene()</kbd> just calls <kbd>drawScene()</kbd>, then clears the main Canvas and copies the <kbd>buffer</kbd> image over to the main Canvas.</p>
<p>In <kbd>drawCanvas()</kbd>, we will add a single block:</p>
<pre>function drawScene(countries, countryIndex) {<br/>  // Clear …<br/>  // Sphere fill …<br/>  // Grid …<br/>  // Country fill …<br/>  // Country stroke - each country ….<br/><br/>  // Country stroke - hovered country<br/>  if (countryIndex &gt;= 0) {<br/>    bufferContext.beginPath();<br/>    bufferContext.setLineDash([4,2]);<br/>    bufferPath(countries.features[countryIndex]);<br/>    bufferContext.lineWidth = 1;<br/>    bufferContext.strokeStyle = '#777';<br/>    bufferContext.stroke();<br/>    bufferContext.setLineDash([]);<br/>  }<br/>}</pre>
<p>We will receive the <kbd>selected</kbd> index via the <kbd>countryIndex</kbd> argument and check whether it's larger or equal to <em>0</em> (remember, that would be <em>Afghanistan</em>). If so, we draw a dashed path around the country. How do we know which country? We access the right country via <kbd>countries.features[countryIndex]</kbd> and draw it accordingly. The mind boggles:</p>
<div><img height="304" width="482" src="img/d94adbe9-f76b-4d32-a236-72c2363a7d6f.png"/></div>
<p>A dashed line around the US, just because we picked the right color</p>
<p>View this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-10-3">https://larsvers.github.io/learning-d3-mapping-10-3</a> and the code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_03.html">10_03.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Visualizing data per country and adding a tooltip</h1>
                
            
            
                
<p>You learned to build a data-driven and -giving representation of your visual. You have also used it to highlight the country at hover. However, you haven’t really tapped into the plentiful options of interaction this gives you. Let’s do this now. There’s a lot you could do, but I think a tooltip would be a reasonable place to start.</p>
<p>Before we embark on the tooltip build, let’s add some more interesting data to the globe. So far, we have <strong>country name</strong>, <strong>country name abbreviation</strong>, and <strong>population estimate</strong>. That’s already something to work with. However, let’s task ourselves with adding an additional data source to our globe, visualize it appropriately, and add a sensible interaction for user exploration.</p>
<p>As a little reminder, this is what you will build:</p>
<div><img height="315" width="495" src="img/c7d07b70-2fa9-414f-ae6e-93ed530c9f35.png"/></div>
<p>Our final Canvas adventure</p>
<p>View the final app at <a href="https://larsvers.github.io/learning-d3-mapping-10-4">https://larsvers.github.io/learning-d3-mapping-10-4</a> and the code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2010%20-%20Adding%20Interactivity/10_04.html">10_04.html</a>.</p>
<p>The preceding screenshot shows a globe visualization of forest cover per country. The data comes from the source of all solid wisdom, Wikipedia. The suggestion is to visualize it as a choropleth map. Arguably, choropleth maps have been overused in recent years, but they are nonetheless a great option to show percentage comparisons of geo-areas.</p>
<p>The data is from <a href="https://en.wikipedia.org/wiki/List_of_countries_by_forest_area">https://en.wikipedia.org/wiki/List_of_countries_by_forest_area</a>. The missing North Cyprus, Somaliland, and Haiti have been estimated.</p>
<p>The steps are relatively simple. First, we add our forest data to our GeoJSON world object. We’ll move on swiftly to color our countries according to the new data, and finally add a tooltip with HTML and SVG.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding new data to our old globe</h1>
                
            
            
                
<p>After copying and pasting or scraping the data from Wikipedia, you should save your forest file in a data format of your choice. We saved it in CSV, and as we now have several data sources to load for one visual, we will use <kbd>d3.queue()</kbd> to wait for both files to load before invoking <kbd>ready()</kbd>:</p>
<pre>d3.queue()<br/>  .defer(d3.json, 'data/world-110.json')<br/>  .defer(d3.csv, 'data/forests.csv')<br/>  .await(ready);</pre>
<p>Then, adapt your <kbd>ready()</kbd> function arguments and start accordingly:</p>
<pre>function ready(error, world, forests) {<br/>  if (error) throw error;</pre>
<p>Leave the country data prep as is (in that we push the world’s country arrays into a variable called <kbd>countries</kbd>) and move on to including the forest data into the world. What we want is this:</p>
<div><img height="189" width="352" src="img/17c00718-1299-4794-b0a5-84855436574a.png"/></div>
<p>The updated data object we strive for</p>
<p>The properties we need for the coloring and the tooltip are country name (<kbd>admin</kbd>), <kbd>forest_percent</kbd>, and <kbd>forest_area</kbd>. Note, that we also have <kbd>forest_color</kbd> here. This is the choropleth color for that country. It’s often beneficial to have your data in place before the draw. Hefty calculations during redraw can slow down performance and re-render.</p>
<p>The forest CSV country names have been changed to match the exact naming of the countries GeoJSON. This way, you can use the names to join the two datasets. To join the data speedily, we will use <strong>binary search</strong>. Binary search leverages the sorted nature of our <kbd>countries</kbd> array to find a country match quickly. In short, it looks at the country name we want to find, and instead of looping through all countries in the GeoJSON, it splits the <kbd>countries</kbd> array in two halves and checks whether the search term is in the upper or the lower half. It does that repeatedly until it finds the term. This is much quicker than <strong>linear search</strong> (looping through all data); in our case, around 10 times faster.</p>
<p>You can implement binary search in D3 with <kbd>d3.bisect()</kbd> and that’s what we shall use. We add the data with a function we call <kbd>insertForestDataBinary()</kbd>. We shall add this function call and the function to the data preparation flow in the <kbd>ready()</kbd> function:</p>
<pre>function insertForestDataBinary() {<br/>  var bisectName = d3.bisector(function(d) { return d.properties.admin;<br/>  }).right;<br/>  for (var i = 0; i &lt; forests.length; i++) {<br/>    var indexBisect = bisectName(countries.features, forests[i].country);<br/>    var indexMatch = indexBisect - 1;<br/>    countries.features[indexMatch].properties.forest_area = +forests[i].area;<br/>    countries.features[indexMatch].properties.forest_percent = <br/>    +forests[i].percent;<br/>    countries.features[indexMatch].properties.forest_color =<br/>    colorScale(+forests[i].percent);<br/>  }<br/> }</pre>
<p>First, you create a <em>bisector</em> function so that D3 knows which variable we want to find a name (<kbd>d.properties.admin</kbd>, the country name). You then iterate through all forest objects. Each forest object holds the <kbd>country</kbd> (the name we match), <kbd>forest_percent</kbd> and <kbd>forest_area</kbd> properties. The bisector will search the array and return the index after the matching <kbd>countries</kbd> object (or to the <kbd>.right</kbd>, as we specified above). Once you have that, you can add the new properties one index position before.</p>
<p>For the last property, <kbd>forest_color</kbd>, you need to create a <kbd>colorScale</kbd> somewhere in higher scope:</p>
<pre>var colorScale = d3.scaleSequential(d3.interpolateYlGn).domain([0,1]);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Coloring the globe</h1>
                
            
            
                
<p>Note that you have implemented all these changes before you draw the globe. That’s great as you can now simply draw it with the new color scheme. The only change is in our <kbd>drawScene()</kbd> function, filling the <kbd>countries</kbd> accordingly in a loop:</p>
<pre>function drawScene(countries, countryIndex) {<br/>  // Clear the rect, draw the sphere and the graticule<br/>  // Country fill - individual<br/><br/>  countries.features.forEach(function(el) {<br/>    bufferContext.beginPath();<br/>    bufferPath(el);<br/>    bufferContext.fillStyle = el.properties.forest_color;<br/>    bufferContext.fill();<br/>  });<br/><br/>  // Draw the country stroke…<br/>}</pre>
<p>Also, note that we adjusted the sphere fill and the graticule colors a little to work better with our yellow-green country color scale:</p>
<div><img height="296" width="468" src="img/d09ac20e-fb0d-45f4-ab4a-a6a21dbdfceb.png"/></div>
<p>A choropleth globe visualizing forest cover ratio per country</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a tooltip</h1>
                
            
            
                
<p>Your globe is colored by forest cover. Yellow countries have a low percentage of cover; dark green a higher one. That’s already a good clue about how much forest there is proportionally in each country. However, a user might additionally be interested in how high the forest cover is exactly, and how this compares to other countries. You have all the data in your hands, so let’s not be stingy, and add the following tooltip:</p>
<div><img height="249" width="172" src="img/0d04cdee-f36b-4b53-9f4f-e4a6e336f1e0.png"/></div>
<p>Our tooltip</p>
<p>The visual on the tooltip shows a sorted bar chart of all countries, forest cover percentage, and a red indicator of the hovered country’s place in the overall distribution.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The HTML</h1>
                
            
            
                
<p>It is simple, as follows:</p>
<pre>&lt;div id="tooltip"&gt;<br/>  &lt;div id="tip-header"&gt;<br/>    &lt;h1&gt;&lt;/h1&gt;<br/>    &lt;div&gt;&lt;/div&gt;<br/>  &lt;/div&gt;<br/>  &lt;div id="tip-body"&gt;<br/>    &lt;svg id="tip-visual"&gt;&lt;/svg&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>A tooltip wrapper <kbd>div</kbd>, a header with an <kbd>h1</kbd> for the country, and a <kbd>div</kbd> to hold the info. The following is a body with an SVG element to hold the bar chart. Note here that we add an HTML and SVG element to a Canvas, which is, of course, no problem. We could even draw SVG elements over the Canvas element or vice versa.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the static parts of the tooltip</h1>
                
            
            
                
<p>Next, we will build the tooltip. To be precise, we will build the <em>static</em> part of the tooltip, that is, the bar chart. We will add the changing parts such as the header information and the red indicator as soon as we hover over the country. First, we twist the data into the right shape, and then we build a simple bar chart:</p>
<pre>function buildTooltip(data) {<br/>  var forestsByPercent = data<br/>    .slice()<br/>    .sort(function(a, b) {<br/>      return d3.descending(+a.percent, +b.percent);<br/>    })<br/>    .map(function(el) {<br/>      return {<br/>        country: el.country,<br/>        percent: +el.percent,<br/>        color: colorScale(+el.percent)<br/>      };<br/>    });<br/><br/>  var countryList = forestsByPercent.map(function(el) {<br/>    return el.country;<br/>  });  </pre>
<p>The data we pass into this function is—you guessed it—our forestry-boosted countries' GeoJSON. <kbd>forestsByPercent</kbd> is just a sorted array of objects holding the data we need for the bar chart. <kbd>countryList</kbd> is just an array of (also sorted) <kbd>countries</kbd> we will use as an extension to our ordinal scale. The following is the resulting bar chart:</p>
<pre>    var tipWidth = 200,<br/>        tipHeight = 200;<br/><br/>    var xScale = d3.scaleLinear()<br/>        .domain([0, 1])<br/>        .range([0, tipWidth]);<br/><br/>    var yScale = d3.scaleBand()<br/>        .domain(countryList)<br/>        .rangeRound([0, tipHeight]);<br/><br/>    svg = d3.select('svg#tip-visual')<br/>        .attr('width', tipWidth)<br/>        .attr('height', tipHeight);<br/><br/>    svg.selectAll('.bar')<br/>        .data(forestsByPercent)<br/>      .enter().append('rect')<br/>        .attr('class', 'bar')<br/>        .attr('id', function(d) { return stripString(d.country); })<br/>        .attr('x', xScale(0))<br/>        .attr('y', function(d) { return yScale(d.country); })<br/>        .attr('width', function(d) { return xScale(d.percent); })<br/>        .attr('height', yScale.bandwidth())<br/>        .attr('fill', function(d) { return d.color; });<br/><br/>  } // buildTooltip()</pre>
<p>That was simple. By the way, we build all our interactive tooltip functions in the <kbd>ready()</kbd> function. This way, we have access to all the data we need and have it all nicely cordoned off from any outside JavaScript scopes. In real life, it might be worth considering outsourcing interactivity to its own module to keep concerns separate.</p>
<p>We call this <kbd>buildTooltip()</kbd> function in <kbd>ready()</kbd> after defining an <kbd>svg</kbd> variable we can address from the other two tooltip functions, <kbd>tooltipShow()</kbd> and <kbd>tooltipHide()</kbd> which we will build next.</p>
<pre>var svg;<br/>buildTooltip(forests);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Showing and hiding the tooltip</h1>
                
            
            
                
<p>We need a small chunk of logic to tell our app when to show and when to hide the tooltip. With SVG, this logic is usually straightforward, as we can leverage mouseover and mouseout. With Canvas, we only really have mousemove on the entire Canvas. So, we build our own mouseover and mouseout logic. We start in the mousemove handler called <kbd>highlightPicking()</kbd>:</p>
<pre>function highlightPicking() {<br/><br/>  // Here, you find the country index and store it in pickedColor<br/>  // and you check if the user’s mouse is in the globe or not with inGlobe<br/><br/>  selected = inGlobe &amp;&amp; pickedColor[3] === 255 ? pickedColor[0] : false;<br/>  requestAnimationFrame(function() {<br/>    renderScene(countries, selected);<br/>  });<br/><br/>  var country = countries.features[selected];<br/>  if (selected !== false) showTooltip(pos, country); // build tooltip<br/>  if (selected === false) hideTooltip(); // remove tooltip<br/>}</pre>
<p>You store the data of the country the mouse is over in <kbd>country.</kbd> If <kbd>selected</kbd> holds a number (a country index), we trigger the creatively named function <kbd>showTooltip()</kbd> and pass it the main Canvas’s mouse positions and the country. If <kbd>selected</kbd> returns <kbd>false</kbd>, the mouse is not over a country, and we will trigger the equally creatively named function <kbd>hideTooltip()</kbd>.</p>
<p>The key thing you want to figure out in <kbd>showTooltip()</kbd> is when to build a new tooltip and when to just move the existing tooltip. You want to build a new tooltip when the mouse moves from one country to another country. You just want to move the tooltip along with the mouse when the mouse is within the borders of a specific country.</p>
<p>We will achieve this by an array that will work like a <strong>queue</strong>. You can imagine a stack to stand up vertically, able to only add new data to the top or remove data from the top. In contrast, you can imagine a queue horizontally like a queue in front of an ice-cream shop. People arrive in the queue at the back and leave the queue at the front.</p>
<p>Our queue will, however, only be two-people long. In fact, it won’t be two people long but two countries long. Whenever we move the mouse, the queue will be fed the country we’re over to one side of it (the front actually), immediately pushing off the country at the other side (the back). When we’re moving from one spot in the US to another spot in the US, it will say <kbd>[“United States of America”, “United States of America”]</kbd>. As soon as our mouse moves effortlessly over to Mexico, it will add <kbd>“Mexico”</kbd> at the front of the queue, pushing the previously <em>0</em>-indexed <kbd>“United States of America”</kbd> to index position <em>1</em> and cutting off the array right there. Now, we have an array with <kbd>[“Mexico”, “United States of America”]</kbd>.</p>
<p>Checking whether we change a country is now a simple affair of comparing the two values in our queue. If they are the same, we just move the mouse; if they are different, we create a new tooltip for Mexico.</p>
<p>This is a textbook example of why SVG or HTML is often preferred over Canvas when the application is interaction heavy. Still, that wasn’t too bad, was it? Let’s implement it. First, you will need to define your yet-empty queue:</p>
<pre>var countryQueue = [undefined, undefined];</pre>
<p>Then, you need to write <kbd>showTooltip()</kbd>, taking in the mouse positions and the element, that is, the country the mouse is over:</p>
<pre>function showTooltip(mouse, element) {<br/>  var countryProps = element.properties;<br/>  countryQueue.unshift(countryProps.admin);<br/>  countryQueue.pop();</pre>
<p>You save the country’s data in <kbd>countryProps</kbd>, add the country’s name to the front of the queue with JavaScript’s own <kbd>.unshift()</kbd> method, and <kbd>pop()</kbd> off the last value from the queue.</p>
<p>Then, we will establish if there is a country change or not:</p>
<pre>  if (countryQueue[0] !== countryQueue[1]) {<br/>    var headHtml =<br/>      'Forest cover: ' + formatPer(countryProps.forest_percent) + '' +<br/>      '&lt;br&gt;Forested area: ' + formatNum(countryProps.forest_area) + '<br/>       km&lt;sup&gt;2&lt;/sup&gt;';<br/><br/>    d3.select('#tip-header h1').html(countryProps.admin);<br/>    d3.select('#tip-header div').html(headHtml);<br/><br/>    svg.selectAll('.bar').attr('fill', function(d) { return d.color; });<br/>    d3.select('#' + stripString(countryProps.admin)).attr('fill', 'orange');<br/><br/>    d3.select('#tooltip')<br/>      .style('left', (mouse[0] + 20) + 'px')<br/>      .style('top', (mouse[1] + 20) + 'px')<br/>      .transition().duration(100)<br/>      .style('opacity', 0.98);</pre>
<p>If there is one, you fill the tooltip’s header with the country-specific information. You also color all bars according to the appropriate country color before the bar of this specific country gets colored red. The rest is just moving the tip along with the mouse and cranking its opacity up to make it visible.</p>
<pre>If the queue values are the same, you just move the tip:<br/>  } else {<br/>    d3.select('#tooltip')<br/>      .style('left', (mouse[0] + 20) + 'px')<br/>      .style('top', (mouse[1] + 20) + 'px');<br/>  }<br/>}</pre>
<p>Remember, <kbd>showTooltip()</kbd> gets shown every time the mouse is over a country, and our selected variable gets filled with a country index. If <kbd>selected</kbd> is false, we know we’re not over a country, meaning that we want to remove our tooltip. We do this with, well, <kbd>hideTooltip():</kbd></p>
<pre>function hideTooltip() {<br/>  countryQueue.unshift(undefined);<br/>  countryQueue.pop();<br/>  d3.select('#tooltip')<br/>    .transition().duration(100)<br/>    .style('opacity', 0);<br/>}</pre>
<p>We decided to appropriately allocate <kbd>undefined</kbd> to the queue if we’re not over a country, so we <kbd>unshift()</kbd> it to the front of the queue and <kbd>pop()</kbd> off the last value of the array to always keep it in pairs we can compare at the next move. Finally, we will transition the opacity back to zero and it is gone again. That’s it! All done.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>You have officially seen and used Canvas. You’ve reveled in its shining moments and mastered its quirks. You have started with a royal blue rectangle and have now successfully built a whole world, which you can spin, resize as desired, and retrieve country-specific information from. On the way, you have also seen how Canvas works in comparison to SVG. You have learned about the benefits and issues when coding a little closer to the graphics processing part of your machine.</p>
<p>The idea of these chapters has, of course, been to extend your technical skill set. However, beyond that, it’s the alternative concept of how to approach Canvas—the procedural style, the game loop routine, and the way Canvas interacts with D3—that broadens your horizon as a developer and allows for a different perspective to tackle problems.</p>


            

            
        
    </body></html>