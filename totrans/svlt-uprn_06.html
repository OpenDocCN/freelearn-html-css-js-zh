<html><head></head><body>
<div id="_idContainer020">
<h1 class="chapter-number" id="_idParaDest-80"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.2.1">Forms and Data Submission</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we went into some of the finer details behind loading data in SvelteKit. </span><span class="koboSpan" id="kobo.3.2">While loading data is important, it is equally important that we understand how to empower users to submit that data. </span><span class="koboSpan" id="kobo.3.3">That is why this chapter will explore some of the finer details behind forms and actions in SvelteKit. </span><span class="koboSpan" id="kobo.3.4">While not all applications </span><em class="italic"><span class="koboSpan" id="kobo.4.1">have</span></em><span class="koboSpan" id="kobo.5.1"> to accept data from users, the ones that do so in an intuitive manner tend to rise above the rest. </span><span class="koboSpan" id="kobo.5.2">After all, some of the best user experiences are taken for granted because they simply work. </span><span class="koboSpan" id="kobo.5.3">It’s when things break that users begin paying attention </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">to them.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Throughout this chapter, we’ll learn how leveraging </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.9.1"> elements can keep our application accessible and our code minimal. </span><span class="koboSpan" id="kobo.9.2">Integrating those forms with easily implemented actions lets us take the submitted data and process it accordingly. </span><span class="koboSpan" id="kobo.9.3">And finally, we’ll look at how we can soften some of the edges of the standard user experience surrounding forms by adding progressive enhancements. </span><span class="koboSpan" id="kobo.9.4">To do all of this, we’ll put the finishing touches on the login form we </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">started previously.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’ll cover </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Form Setup</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Analyzing Actions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.15.1">Enhancing Forms</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.16.1">Upon completing this chapter, you should feel comfortable creating your very own login form, and you’ll know how to go forward and accept all types of data from users of your </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">SvelteKit-based application.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">The complete code for this chapter is available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">at: </span></span><a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter06"><span class="No-Break"><span class="koboSpan" id="kobo.21.1">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter06</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.22.1">.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.23.1">Form Setup</span></h1>
<p><span class="koboSpan" id="kobo.24.1">We took a glance at </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.25.1">using forms and actions together in </span><a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.26.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">And while covering </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">RequestEvent</span></strong><span class="koboSpan" id="kobo.29.1"> in the previous chapter, we began creating the code necessary to authenticate a user in our application with cookies. </span><span class="koboSpan" id="kobo.29.2">However, in that example, we never gave the user a means to provide a username or password. </span><span class="koboSpan" id="kobo.29.3">We also never created the cookie in the application. </span><span class="koboSpan" id="kobo.29.4">Instead, we opted to manually create one using the browser’s developer tools. </span><span class="koboSpan" id="kobo.29.5">It’s time we bring the whole thing together. </span><span class="koboSpan" id="kobo.29.6">Since we’ve covered the logic related to </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">load()</span></strong><span class="koboSpan" id="kobo.31.1">, as well as the details surrounding </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">RequestEvent</span></strong><span class="koboSpan" id="kobo.33.1">, we can continue building off of our previous example. </span><span class="koboSpan" id="kobo.33.2">A good place to start would be the login form itself. </span><span class="koboSpan" id="kobo.33.3">After all, we can’t log a user in without giving them a place to </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">But before we create the form, let’s go ahead and add a link to the login page in </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">our navigation:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.37.1">src/lib/Nav.svelte</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.38.1">
&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href='/'&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/news'&gt;News&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/fetch'&gt;Fetch&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/comment'&gt;Comment&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/about'&gt;About&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/api/post'&gt;API&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/login'&gt;Login&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</span></pre>
<p><span class="koboSpan" id="kobo.39.1">The change is as simple as copying an existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.41.1"> element and replacing the route and text inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">&lt;a&gt;</span></strong><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">This will make navigating and testing our login </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">functionality simpler.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">Next, let’s start with the actual form. </span><span class="koboSpan" id="kobo.45.2">Looking back at the file we created to show users a successful login based on their cookie, we’ll need to make several changes. </span><span class="koboSpan" id="kobo.45.3">Firstly, we’ll import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">enhance</span></strong><span class="koboSpan" id="kobo.47.1"> module from </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">$app/forms</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">We’ll discuss some of the magic behind this one later in this chapter, so don’t worry about it for now. </span><span class="koboSpan" id="kobo.49.3">Next, we’ll want to export the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">form</span></strong><span class="koboSpan" id="kobo.51.1"> variable so that we can signal to the user the status of their login. </span><span class="koboSpan" id="kobo.51.2">Finally, we’ll need to</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.52.1"> create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.54.1"> element with appropriate inputs and give it </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">some styling:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.56.1">src/routes/login/+page.svelte</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.57.1">
&lt;script&gt;
  import { enhance } from '$app/forms';
  export let data;
  export let form;
&lt;/script&gt;
{#if form?.msg}
  {form.msg}
{/if}
{#if data.user}
  &lt;p&gt;
    Welcome, {data.user.name}!
</span><span class="koboSpan" id="kobo.57.2">  &lt;/p&gt;
{/if}
&lt;form use:enhance method="POST" action="?/login"&gt;
  &lt;label for="username"&gt;Username&lt;/label&gt;
  &lt;input name="username" id="username" type="text"/&gt;
  &lt;label for="password"&gt;Password&lt;/label&gt;
  &lt;input name="password" id="password" type="password"/&gt;
  &lt;button&gt;Log In&lt;/button&gt;
&lt;/form&gt;
&lt;style&gt;
  form {
    display: flex;
    flex-direction: column;
    justify-content: center;
    width: 25%;
    margin: 0 auto;
  }
  input {
    margin: .25em 1em 1em;
    display: block;
  }
  label {
    margin: 0 .5em;
  }
&lt;/style&gt;</span></pre>
<p><span class="koboSpan" id="kobo.58.1">Now that</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.59.1"> you’ve seen the additions altogether, let’s discuss them. </span><span class="koboSpan" id="kobo.59.2">Aside from the new imports and exports, the next change you’ll notice is the Svelte directive checking whether or not </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">form?.msg</span></strong><span class="koboSpan" id="kobo.61.1"> is set. </span><span class="koboSpan" id="kobo.61.2">If that is set, we display </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">the message.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.63.1">data versus form</span></p>
<p class="callout"><span class="koboSpan" id="kobo.64.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">form</span></strong><span class="koboSpan" id="kobo.66.1"> prop comes to us from the data returned by our login action (which will be created in the next section). </span><span class="koboSpan" id="kobo.66.2">Remember that we include </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">export let data;</span></strong><span class="koboSpan" id="kobo.68.1">  to get access to the data prop returned from </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">load()</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">In the same vein, we include </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">export let form;</span></strong><span class="koboSpan" id="kobo.72.1"> to retrieve data that has been returned by form actions. </span><span class="koboSpan" id="kobo.72.2">The data returned can also be retrieved anywhere in the application via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">$</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">page.form</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1"> store.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">The next big change is the addition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.78.1"> element. </span><span class="koboSpan" id="kobo.78.2">It makes use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">enhance</span></strong><span class="koboSpan" id="kobo.80.1"> module we imported earlier, sets the HTTP method to POST, and sends its data to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">login</span></strong><span class="koboSpan" id="kobo.82.1"> action located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">src/routes/login/+page.server.js</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">We </span><em class="italic"><span class="koboSpan" id="kobo.85.1">must set the HTTP method to POST</span></em><span class="koboSpan" id="kobo.86.1">; otherwise, our form will attempt to submit data via a GET request, and we don’t want to be sending passwords </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">around insecurely.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">We’ve then</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.89.1"> included the appropriate markup for inputs, labels, and buttons. </span><span class="koboSpan" id="kobo.89.2">For now, we’re only referencing one form action to manage logging a user in. </span><span class="koboSpan" id="kobo.89.3">If we wanted to enable registration or password reset functionality and keep the subsequent actions in the same file as our login action, we could leverage the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">formaction</span></strong><span class="koboSpan" id="kobo.91.1"> property. </span><span class="koboSpan" id="kobo.91.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">formaction</span></strong><span class="koboSpan" id="kobo.93.1"> is intended to be used when you have multiple buttons referring to separate endpoints within the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.95.1"> element. </span><span class="koboSpan" id="kobo.95.2">In a password reset scenario, we would likely need another </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.97.1"> element specifying the email to send our password reset link. </span><span class="koboSpan" id="kobo.97.2">Likewise, with registration, we would probably need to obtain a user’s email, as well as their username and password, so having both of those within the context of a form that </span><em class="italic"><span class="koboSpan" id="kobo.98.1">only</span></em><span class="koboSpan" id="kobo.99.1"> accepts username and password details makes little sense. </span><span class="koboSpan" id="kobo.99.2">In each of these cases, it would make more sense to create a separate form for each of the features and specify the action directly on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.101.1"> element. </span><span class="koboSpan" id="kobo.101.2">It may still make sense to keep logic concerning authentication in a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">+page.server.js</span></strong><span class="koboSpan" id="kobo.103.1"> file for the sake of </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">project organization.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">The actual markup for creating a form is relatively straightforward to implement. </span><span class="koboSpan" id="kobo.105.2">We’ve just seen that we need to specify the method as well as the action to be called. </span><span class="koboSpan" id="kobo.105.3">And to obtain information returned from our action, we’ll need to include </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">export let form;</span></strong><span class="koboSpan" id="kobo.107.1"> on the page while making use of data returned from the action. </span><span class="koboSpan" id="kobo.107.2">Now that you’ve seen a few variations of it, you should be comfortable creating forms to accept data from your users. </span><span class="koboSpan" id="kobo.107.3">Of course, a form doesn’t do much good if we don’t make use of the submitted data. </span><span class="koboSpan" id="kobo.107.4">In the next section, we’ll create an action to handle the data collected by the form. </span><span class="koboSpan" id="kobo.107.5">To ensure our action works smoothly, we’ll need to set up a database and discuss some security </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">best practices.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.109.1">Analyzing Actions</span></h1>
<p><span class="koboSpan" id="kobo.110.1">In </span><a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.111.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.112.1">, we spent </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.113.1">a section looking at how actions worked. </span><span class="koboSpan" id="kobo.113.2">Now, it’s time that we took a closer look at them and how they work under the hood. </span><span class="koboSpan" id="kobo.113.3">But before we begin, we’ll need to set up another fake database and briefly discuss security. </span><span class="koboSpan" id="kobo.113.4">Once we’ve done that, we’ll finish adding logic to our application and authenticate valid users. </span><span class="koboSpan" id="kobo.113.5">This section will cover </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.115.1">Database setup</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">Passwords </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">and security</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.118.1">Login action</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.119.1">After all of this, you’ll have a general understanding of how to finally create a login form for your own </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">SvelteKit application.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.121.1">Database setup</span></h2>
<p><span class="koboSpan" id="kobo.122.1">Of course, this</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.123.1"> isn’t a real database. </span><span class="koboSpan" id="kobo.123.2">We’re going to utilize yet another JSON file that will store our user data and help us simulate looking up a user and their hashed password. </span><span class="koboSpan" id="kobo.123.3">It should look something </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.125.1">src/lib/users.json</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
[
  {
    "id": "1",
    "username": "dylan",
    "password": "$2b$10$7EakXlg...",
    "identity": "301b1118-3a11-...",
    "name": "Dylan"
  },
  {
    "id": "2",
    "username": "jimmy",
    "password": "$2b$10$3rdM9VQ...",
    "identity": "62e3e3cc-adbe-...",
    "name": "Jimmy"
  }
]</span></pre>
<p><span class="koboSpan" id="kobo.127.1">This</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.128.1"> file is a simple array containing two user objects and various properties related to our users. </span><span class="koboSpan" id="kobo.128.2">For this demonstration, the values of these properties are trivial, but the values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">identity</span></strong><span class="koboSpan" id="kobo.130.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">password</span></strong><span class="koboSpan" id="kobo.132.1"> are of particular interest to us, as we will see in the next section. </span><span class="koboSpan" id="kobo.132.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">identity</span></strong><span class="koboSpan" id="kobo.134.1"> property would normally correspond to a user session ID stored in another table. </span><span class="koboSpan" id="kobo.134.2">It should also utilize a unique identifier and not be easily guessable. </span><span class="koboSpan" id="kobo.134.3">If it were, anyone could authenticate to our application as any user by simply creating the identity cookie on their device with a valid session ID. </span><span class="koboSpan" id="kobo.134.4">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">identity</span></strong><span class="koboSpan" id="kobo.136.1"> makes use of </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.137.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">Crypto Web API</span></strong><span class="koboSpan" id="kobo.139.1"> to generate a </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.140.1">random </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Universally Unique Identifier</span></strong><span class="koboSpan" id="kobo.142.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.143.1">UUID</span></strong><span class="koboSpan" id="kobo.144.1">). </span><span class="koboSpan" id="kobo.144.2">The Crypto Web API should not be used for hashing passwords. </span><span class="koboSpan" id="kobo.144.3">For this demonstration, we’ll only be using it to create a UUID that will be saved in a cookie used to authenticate a user. </span><span class="koboSpan" id="kobo.144.4">For your testing purposes, the value could be any unique string, but this example aims to be relatively realistic. </span><span class="koboSpan" id="kobo.144.5">To keep this material from diverging too far from the directive of learning SvelteKit, this is all we’ll need to include for our fake </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">user database.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.146.1">Passwords and Security</span></h2>
<p><span class="koboSpan" id="kobo.147.1">Because</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.148.1"> authentication is such a common feature found in web applications, it would be a disservice to not further elaborate on how to properly implement it. </span><span class="koboSpan" id="kobo.148.2">And </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.149.1">because when done improperly it can have such disastrous consequences, we’ll learn how to implement it securely. </span><span class="koboSpan" id="kobo.149.2">While we’re still not connecting to a real database and are instead storing our user passwords in a JSON file (which is highly advised against for anything other than demonstration purposes), we will observe how to properly hash passwords with another package installed </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">via npm.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">To proceed further, we’ll need to</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.152.1"> install </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">bcrypt</span></strong><span class="koboSpan" id="kobo.154.1">. </span><span class="koboSpan" id="kobo.154.2">In your terminal, run the following command in the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">project directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
npm install bcrypt</span></pre>
<p><span class="koboSpan" id="kobo.157.1">Once this has been done, we can generate hashes with the following code. </span><span class="koboSpan" id="kobo.157.2">This code will only be temporary as it will give us a convenient way to generate the hashes for our passwords </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.158.1">as well as UUIDs for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">identity</span></strong><span class="koboSpan" id="kobo.160.1"> property of our user </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.161.1">objects. </span><span class="koboSpan" id="kobo.161.2">These can then be added to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">users.json</span></strong><span class="koboSpan" id="kobo.163.1"> file to simulate looking up a user password from a database. </span><span class="koboSpan" id="kobo.163.2">We’ll demonstrate login functionality to utilize </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">it afterward:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.165.1">src/routes/login/+page.server.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.166.1">
import bcrypt from 'bcrypt';
export const actions = {
  login: async ({request}) =&gt; {
    const form = await request.formData();
    const hash = bcrypt.hashSync(form.get('password'), 10);
    console.log(hash);
    console.log(crypto.randomUUID());
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.167.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">+page.server.js</span></strong><span class="koboSpan" id="kobo.169.1"> file imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">bcrypt</span></strong><span class="koboSpan" id="kobo.171.1"> module we just installed with npm. </span><span class="koboSpan" id="kobo.171.2">It then creates the login action that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.173.1"> element submits data to. </span><span class="koboSpan" id="kobo.173.2">It retrieves the form data submitted by the login form via</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.174.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">FormData API</span></strong><span class="koboSpan" id="kobo.176.1"> and creates a secure hash of the password provided. </span><span class="koboSpan" id="kobo.176.2">It also outputs a randomly generated UUID. </span><span class="koboSpan" id="kobo.176.3">This step could also be performed in the browser by simply entering </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">crypto.randomUUID();</span></strong><span class="koboSpan" id="kobo.178.1"> into the console of the developer tools. </span><span class="koboSpan" id="kobo.178.2">Upon navigating to </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">/login</span></strong><span class="koboSpan" id="kobo.180.1"> in your browser, filling in the password field of the form, submitting it, and then opening the server console in your terminal, you will be able to copy the hash and the randomly generated UUID to the respective </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">password</span></strong><span class="koboSpan" id="kobo.182.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">identity</span></strong><span class="koboSpan" id="kobo.184.1"> properties of each user in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">users.json</span></strong><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">In this way, you can create passwords for your users. </span><span class="koboSpan" id="kobo.186.3">If you’re using the code in this book’s GitHub repository, the hashes for each of the users were derived from the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">following strings:</span></span></p>
<ol>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.188.1">password</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.189.1">jimmy</span></strong></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.190.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.191.1">It should go without saying but these are considered bad passwords. </span><span class="koboSpan" id="kobo.191.2">Under no circumstances should you ever attempt to use these passwords or their hashes outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">this demonstration.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">While we’re on </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.194.1">the subject of security, we should take this opportunity to note some practices to avoid. </span><span class="koboSpan" id="kobo.194.2">It’s important that we developers do not use </span><em class="italic"><span class="koboSpan" id="kobo.195.1">shared variables</span></em><span class="koboSpan" id="kobo.196.1"> to </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.197.1">store sensitive data. </span><span class="koboSpan" id="kobo.197.2">To clarify, that doesn’t mean to not use variables to store sensitive data. </span><span class="koboSpan" id="kobo.197.3">Rather, we should avoid setting a variable in a form action that could then be available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">load()</span></strong><span class="koboSpan" id="kobo.199.1">. </span><span class="koboSpan" id="kobo.199.2">For a bad practice example, consider a developer declaring a variable for storing chat messages at the highest scope level of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">+page.server.js</span></strong><span class="koboSpan" id="kobo.201.1"> file, assigning message data to it in a form action, and then returning the same variable in the same file’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">load()</span></strong><span class="koboSpan" id="kobo.203.1"> function. </span><span class="koboSpan" id="kobo.203.2">Doing so would have the potential to allow user B to view the chat messages for user A. </span><span class="koboSpan" id="kobo.203.3">This spillover of data can be avoided by immediately returning the data to the page instead. </span><span class="koboSpan" id="kobo.203.4">These same guidelines also apply to Svelte stores. </span><span class="koboSpan" id="kobo.203.5">When managing data on the server, we should never set the state of a store as doing so on the server could potentially make it available to all users on </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">that server.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Now that we know how to create hashed passwords and UUIDs, we can follow some basic best practices surrounding security. </span><span class="koboSpan" id="kobo.205.2">If you’re ever in doubt, consult the official SvelteKit documentation. </span><span class="koboSpan" id="kobo.205.3">As technologies change, so too can best practices. </span><span class="koboSpan" id="kobo.205.4">In the next section, we’ll see how can finally finish the login form by creating the action to tie it </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">all together.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.207.1">Login Action</span></h2>
<p><span class="koboSpan" id="kobo.208.1">After </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.209.1">all of that setup, we’ve finally made it. </span><span class="koboSpan" id="kobo.209.2">We can now complete the action used by the form to log our user in and set a cookie in their browser. </span><span class="koboSpan" id="kobo.209.3">I’m sure you’re ready by now, so let’s dive </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">into it.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Previously in this file, we created some code to generate hashes for our passwords to test against. </span><span class="koboSpan" id="kobo.211.2">We can do away with that code and replace it with code that will look in our database for a matching username, check the provided password against the found user’s hashed password, and set a cookie on the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">user’s device:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.213.1">src/routes/login/+page.server.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
import bcrypt from 'bcrypt';
import users from '$lib/users.json';
export const actions = {
  login: async ({request, cookies}) =&gt; {
    const form = await request.formData();
    const exists = users.filter(user =&gt; user.username === form.
</span><span class="koboSpan" id="kobo.214.2">      get('username'));
    const auth = exists.filter(user =&gt; bcrypt.compareSync(form.
</span><span class="koboSpan" id="kobo.214.3">      get('password'), user.password));
    if(!exists.length || !auth.length) {
      return {msg: 'Invalid login!'};
    }
    cookies.set('identity', auth[0].identity, {path: '/'});
    return {msg: 'success!'}
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.215.1">In this</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.216.1"> new version, we still import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">bcrypt</span></strong><span class="koboSpan" id="kobo.218.1"> module but we’ve also added the import of </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">user.json</span></strong><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">We then added </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">cookies</span></strong><span class="koboSpan" id="kobo.222.1"> to the destructured </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">RequestEvent</span></strong><span class="koboSpan" id="kobo.224.1"> parameter. </span><span class="koboSpan" id="kobo.224.2">After setting up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">login</span></strong><span class="koboSpan" id="kobo.226.1"> action, we get the data submitted by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.228.1"> element and put it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">form</span></strong><span class="koboSpan" id="kobo.230.1"> constant. </span><span class="koboSpan" id="kobo.230.2">Next, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">filter()</span></strong><span class="koboSpan" id="kobo.232.1"> to check against the username of each element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">users</span></strong><span class="koboSpan" id="kobo.234.1"> array. </span><span class="koboSpan" id="kobo.234.2">Any matches are added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">exists</span></strong><span class="koboSpan" id="kobo.236.1"> constant. </span><span class="koboSpan" id="kobo.236.2">We then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">filter()</span></strong><span class="koboSpan" id="kobo.238.1"> again to check the submitted password against the hashed password of every user in </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">exists</span></strong><span class="koboSpan" id="kobo.240.1">. </span><span class="koboSpan" id="kobo.240.2">If a match is found, it is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">auth</span></strong><span class="koboSpan" id="kobo.242.1"> constant. </span><span class="koboSpan" id="kobo.242.2">If either </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">exists</span></strong><span class="koboSpan" id="kobo.244.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">auth</span></strong><span class="koboSpan" id="kobo.246.1"> contains no items in their arrays, we return a message that the login attempt </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">was invalid.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.248.1">Combatting account enumeration</span></p>
<p class="callout"><span class="koboSpan" id="kobo.249.1">We should never return a message alerting the user that their username (or email) was correct but that the provided password failed. </span><span class="koboSpan" id="kobo.249.2">Doing so would allow malicious actors to enumerate valid accounts, essentially guessing usernames in quick succession. </span><span class="koboSpan" id="kobo.249.3">Once done, it becomes trivial for attackers to compile a list of valid usernames and begin brute-forcing passwords on real accounts. </span><span class="koboSpan" id="kobo.249.4">Since users are not well known for creating strong passwords, this could lead to account takeovers for multiple accounts. </span><span class="koboSpan" id="kobo.249.5">This is why we only return a message alerting the user that their login attempt failed. </span><span class="koboSpan" id="kobo.249.6">Whether or not their username or password was incorrect is for them to </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">figure out.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">If a user </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.252.1">was successful in logging in, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">cookies.set()</span></strong><span class="koboSpan" id="kobo.254.1"> to send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.256.1"> headers telling the client to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">identity</span></strong><span class="koboSpan" id="kobo.258.1"> cookie to the user’s session ID on the root directory of the domain. </span><span class="koboSpan" id="kobo.258.2">We must specify the root path in the options; otherwise, our cookie will default to only working at the highest level route where it was set – in this case, only on pages such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">/login</span></strong><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">You can imagine how frustrating that would be for users. </span><span class="koboSpan" id="kobo.260.3">We can then check whether the user is authorized to access functionality at various locations across the application. </span><span class="koboSpan" id="kobo.260.4">To remove the same cookie and log a user out, we could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">cookies.delete()</span></strong><span class="koboSpan" id="kobo.262.1"> while passing in the name of the cookie, as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">our path.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Finally, to show users whether or not their login attempt was successful, we’ll need to make a couple of adjustments to our root server layout. </span><span class="koboSpan" id="kobo.264.2">If you recall, we previously only checked whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">identity === '1'</span></strong><span class="koboSpan" id="kobo.266.1">. </span><span class="koboSpan" id="kobo.266.2">With a fake database implemented, we can instead check against our user’s </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">JSON file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.268.1">src/routes/+layout.server.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
import users from '$lib/users.json';
export function load({ cookies }) {
  const data = {
    notifications: {
      count: 3,
      items: […]
    }
  };
  const exists = users.filter(user =&gt; user.identity === cookies.get('identity'));
  if(exists.length) {
    const {password, …user} = {...exists[0]};
    data.user = user;
  }
  return data;
}</span></pre>
<p><span class="koboSpan" id="kobo.270.1">Since we need </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.271.1">to check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">identity</span></strong><span class="koboSpan" id="kobo.273.1"> cookie value against those that exist in </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">users.json</span></strong><span class="koboSpan" id="kobo.275.1">, we’ll need to import it first. </span><span class="koboSpan" id="kobo.275.2">We don’t need to change anything with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">data</span></strong><span class="koboSpan" id="kobo.277.1"> constant yet, so we can leave the code related to notifications alone. </span><span class="koboSpan" id="kobo.277.2">We must then utilize </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">filter()</span></strong><span class="koboSpan" id="kobo.279.1"> to find whether any users exist with the value obtained from the identity cookie and assign those found to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">exists</span></strong><span class="koboSpan" id="kobo.281.1"> constant. </span><span class="koboSpan" id="kobo.281.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">exists</span></strong><span class="koboSpan" id="kobo.283.1"> has values, we obtain the first one found and harness the power of a destructuring assignment to avoid passing the user's password into </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">data.user</span></strong><span class="koboSpan" id="kobo.285.1">. </span><span class="koboSpan" id="kobo.285.2">This is done to prevent including </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">sensitive data.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">Now that we’ve</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.288.1"> put it all together, we can verify that the login works by navigating to </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">/login</span></strong><span class="koboSpan" id="kobo.290.1"> in our browser and typing in the appropriate details. </span><span class="koboSpan" id="kobo.290.2">If you have created your own hashes, you’ll need to use the strings you provided to successfully authenticate. </span><span class="koboSpan" id="kobo.290.3">Upon submitting the form, we should be greeted by the status message, as well as the welcome message </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">src/routes/login/+page.svelte</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">To recap, in this section, we created a fake user database using a JSON file. </span><span class="koboSpan" id="kobo.294.2">We included our secure password hashes in that file to check against. </span><span class="koboSpan" id="kobo.294.3">When a username and password are submitted from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.296.1"> element in </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">src/routes/login/+page.svelte</span></strong><span class="koboSpan" id="kobo.298.1">, that data is retrieved using the </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">FormData API</span></strong><span class="koboSpan" id="kobo.300.1"> in the </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.301.1">login action located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">src/routes/login/+page.server.js</span></strong><span class="koboSpan" id="kobo.303.1">. </span><span class="koboSpan" id="kobo.303.2">We then checked for the username as well as that user’s hashed password; if found, we send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">Set-Cookie</span></strong><span class="koboSpan" id="kobo.305.1"> headers in our response by way of </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">cookies.set()</span></strong><span class="koboSpan" id="kobo.307.1"> and send a </span><em class="italic"><span class="koboSpan" id="kobo.308.1">Success</span></em><span class="koboSpan" id="kobo.309.1"> status message. </span><span class="koboSpan" id="kobo.309.2">If a login attempt does not match a username or password, we return an </span><em class="italic"><span class="koboSpan" id="kobo.310.1">Invalid Login</span></em><span class="koboSpan" id="kobo.311.1"> status message. </span><span class="koboSpan" id="kobo.311.2">Now that we know how to create a form and submit our data to the appropriate actions, let’s examine some methods that can improve the user experience of </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">our application.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.313.1">Enhancing Forms</span></h1>
<p><span class="koboSpan" id="kobo.314.1">To reduce the </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.315.1">friction inherent in forms on the web, SvelteKit provides us with a few options. </span><span class="koboSpan" id="kobo.315.2">We saw the first of those options earlier when we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">use:enhance</span></strong><span class="koboSpan" id="kobo.317.1"> on our login form. </span><span class="koboSpan" id="kobo.317.2">This one is great for keeping the page from redirecting as it can submit the form data in the background, which means our page doesn’t need to be reloaded. </span><span class="koboSpan" id="kobo.317.3">Another tool we’ve yet to see is what </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.318.1">SvelteKit calls </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">snapshots</span></strong><span class="koboSpan" id="kobo.320.1">. </span><span class="koboSpan" id="kobo.320.2">In this section, we’ll look at both and how they can help improve the experience of </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">your application:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">enhance</span></strong></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.323.1">Snapshots</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.324.1">After completing this section, you’ll be capable of building forms for your users that will be intuitive and streamlined, leading to far greater chances of acceptance by users of </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">your application.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.326.1">enhance</span></h2>
<p><span class="koboSpan" id="kobo.327.1">By</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.328.1"> importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">enhance</span></strong><span class="koboSpan" id="kobo.330.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">$app/forms</span></strong><span class="koboSpan" id="kobo.332.1">, we can progressively enhance the flow of </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.334.1"> elements. </span><span class="koboSpan" id="kobo.334.2">This means that we can submit the data without requiring a page reload, which would normally be found when submitting an </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.336.1"> element. </span><span class="koboSpan" id="kobo.336.2">We’ve seen this action a couple of times now but in both cases we never discussed how </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">it works.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">The first step that’s taken by </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">enhance</span></strong><span class="koboSpan" id="kobo.340.1"> is updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">form</span></strong><span class="koboSpan" id="kobo.342.1"> property. </span><span class="koboSpan" id="kobo.342.2">We were able to observe this with the Svelte directive located in </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">src/routes/login/+page.svelte</span></strong><span class="koboSpan" id="kobo.344.1">, which checks whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">form?.msg</span></strong><span class="koboSpan" id="kobo.346.1"> is set. </span><span class="koboSpan" id="kobo.346.2">Because Svelte is reactive, when </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">enhance</span></strong><span class="koboSpan" id="kobo.348.1"> updates </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">form</span></strong><span class="koboSpan" id="kobo.350.1">, we can immediately view the change and display our message. </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">enhance</span></strong><span class="koboSpan" id="kobo.352.1"> will also update </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">$page.form</span></strong><span class="koboSpan" id="kobo.354.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">$page.status</span></strong><span class="koboSpan" id="kobo.356.1">, which are both properties of the Svelte </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">$page</span></strong><span class="koboSpan" id="kobo.358.1"> store. </span><span class="koboSpan" id="kobo.358.2">This store gives us information about the currently displayed page. </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">$page.form</span></strong><span class="koboSpan" id="kobo.360.1"> will contain the same data returned from the form action, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">$page.status</span></strong><span class="koboSpan" id="kobo.362.1"> will contain HTTP status code data. </span><span class="koboSpan" id="kobo.362.2">We first saw an example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">$page</span></strong><span class="koboSpan" id="kobo.364.1"> store used in the </span><em class="italic"><span class="koboSpan" id="kobo.365.1">Dynamic routing</span></em><span class="koboSpan" id="kobo.366.1"> section of </span><a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.367.1">Chapter 4</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.368.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">Upon receiving a successful response, </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">enhance</span></strong><span class="koboSpan" id="kobo.371.1"> will reset the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.373.1"> element and force the appropriate </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">load()</span></strong><span class="koboSpan" id="kobo.375.1"> functions to rerun by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">invalidateAll()</span></strong><span class="koboSpan" id="kobo.377.1">. </span><span class="koboSpan" id="kobo.377.2">It will then resolve any redirects, render the nearest </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">+error.svelte</span></strong><span class="koboSpan" id="kobo.379.1"> (if an error occurred), and reset the focus to the correct element as if the page was being loaded for the </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">first time.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Should </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">enhance</span></strong><span class="koboSpan" id="kobo.383.1"> be used on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.385.1"> element with an action to an entirely different route, </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">enhance</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.387.1">will not update</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.388.1">form</span></strong><span class="koboSpan" id="kobo.389.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">$page</span></strong><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">This is because it aims to emulate native browser behavior and submission of data across routes like this would normally trigger a page reload. </span><span class="koboSpan" id="kobo.391.3">To force it to update these properties, you will need to pass a callback function to </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">enhance</span></strong><span class="koboSpan" id="kobo.393.1">. </span><span class="koboSpan" id="kobo.393.2">The callback function can then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">applyAction</span></strong><span class="koboSpan" id="kobo.395.1"> to update the stores accordingly. </span><span class="koboSpan" id="kobo.395.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">applyAction()</span></strong><span class="koboSpan" id="kobo.397.1"> function accepts a SvelteKit </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">ActionResult</span></strong><span class="koboSpan" id="kobo.399.1"> type and can also be imported </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">$app/forms</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.403.1">Snapshots</span></h2>
<p><span class="koboSpan" id="kobo.404.1">One commonly </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.405.1">frustrating experience endured by users is caused by navigating away from a page after filling out a large form but before that form has been submitted. </span><span class="koboSpan" id="kobo.405.2">No matter the cause, losing data that took significant time to enter </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">is painful.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">By persisting </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.409.1"> data in a snapshot, we can make it easier for users to pick up where they left off. </span><span class="koboSpan" id="kobo.409.2">Fewer headaches for users means a better experience with our application. </span><span class="koboSpan" id="kobo.409.3">And implementing it is a breeze as we only need to export a </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">snapshot</span></strong><span class="koboSpan" id="kobo.411.1"> constant with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">capture</span></strong><span class="koboSpan" id="kobo.413.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">restore</span></strong><span class="koboSpan" id="kobo.415.1"> properties set. </span><span class="koboSpan" id="kobo.415.2">To see it in action, let’s persist the comment form data we </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">built earlier:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.417.1">src/routes/comment/+page.svelte</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
&lt;script&gt;
  import { enhance } from '$app/forms';
  export let form;
  let comment = '';
  export const snapshot = {
    capture: () =&gt; comment,
    restore: (item) =&gt; comment = item
  }
&lt;/script&gt;
&lt;div class='wrap'&gt;
  {#if form &amp;&amp; form.status === true}
    &lt;p&gt;{form.msg}&lt;/p&gt;
  {/if}
  &lt;form method='POST' action='?/create' use:enhance&gt;
    &lt;label&gt;
      Comment
      &lt;input name="comment" type="text" bind:value={comment}&gt;
    &lt;/label&gt;
    &lt;button&gt;Submit&lt;/button&gt;
    &lt;button formaction='?/star'&gt;Star&lt;/button&gt;
    &lt;button formaction='?/reply'&gt;Reply&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.419.1">In this new version, we’ve only </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.420.1">made three </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">significant changes:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.422.1">Added </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">let comment = '';</span></strong><span class="koboSpan" id="kobo.424.1"> so that we may capture and restore the input value to </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">our JS.</span></span></li>
<li><span class="koboSpan" id="kobo.426.1">Added the snapshot object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">export </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">const snapshot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">:</span></span><ol><li><span class="koboSpan" id="kobo.430.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">capture</span></strong><span class="koboSpan" id="kobo.432.1"> property calls an anonymous function just before the page updates when navigating away. </span><span class="koboSpan" id="kobo.432.2">This function only needs to return the values we wish to capture and restore later – in this case, the value associated </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">comment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">restore</span></strong><span class="koboSpan" id="kobo.437.1"> is called immediately after the page is loaded and assigns the parameter it was called with </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">comment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.441.1">We bind the value of the comment’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">&lt;text&gt;</span></strong><span class="koboSpan" id="kobo.443.1"> input to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">comment</span></strong><span class="koboSpan" id="kobo.445.1"> variable so that the input’s value may be retrieved on capture and set </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">on restore.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.447.1">Once you have implemented these changes, you can test them out by opening the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">/comment</span></strong><span class="koboSpan" id="kobo.449.1"> route in your browser, typing in a test comment, and navigating away to another page. </span><span class="koboSpan" id="kobo.449.2">When you click </span><em class="italic"><span class="koboSpan" id="kobo.450.1">Back</span></em><span class="koboSpan" id="kobo.451.1"> in your browser, you will observe the data that was restored just as you left it. </span><span class="koboSpan" id="kobo.451.2">Because snapshots persist the data they capture to Session Storage, you can open your browser developer tools and observe the data. </span><span class="koboSpan" id="kobo.451.3">In Firefox, you can find it under </span><strong class="bold"><span class="koboSpan" id="kobo.452.1">Storage</span></strong><span class="koboSpan" id="kobo.453.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">Session Storage</span></strong><span class="koboSpan" id="kobo.455.1">. </span><span class="koboSpan" id="kobo.455.2">In Chrome, it can be located under </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">Application</span></strong><span class="koboSpan" id="kobo.457.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">Storage</span></strong><span class="koboSpan" id="kobo.459.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">Session Storage</span></strong><span class="koboSpan" id="kobo.461.1">. </span><span class="koboSpan" id="kobo.461.2">In both Chrome and Firefox, you will need to refresh the page manually to view the changed data as the developer console windowpanes will not update during client-side navigation. </span><span class="koboSpan" id="kobo.461.3">Because Session Storage is meant to only contain small amounts of data, anything saved here must be serialized into JSON. </span><span class="koboSpan" id="kobo.461.4">It is worth noting that the data will only be restored upon navigating </span><em class="italic"><span class="koboSpan" id="kobo.462.1">Back</span></em><span class="koboSpan" id="kobo.463.1"> to the page. </span><span class="koboSpan" id="kobo.463.2">SvelteKit will only trigger the restore based on browser history. </span><span class="koboSpan" id="kobo.463.3">Navigating to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">/comment</span></strong><span class="koboSpan" id="kobo.465.1"> page by clicking the link in the menu will not trigger a restore as it is considered navigating to a </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">new page.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">Knowing how to progressively and seamlessly enhance your forms can lead to an experience that will keep users coming back. </span><span class="koboSpan" id="kobo.467.2">By running form submissions in the background, we can make use of Svelte’s reactivity to provide immediate and useful feedback to users. </span><span class="koboSpan" id="kobo.467.3">And with the use of snapshots, we can preserve a user’s progress on simple or complex forms. </span><span class="koboSpan" id="kobo.467.4">With this knowledge, you can now go forth and build intuitive experiences into </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">your applications.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.469.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.470.1">We started this chapter by building a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.472.1"> element that accepts a username and password. </span><span class="koboSpan" id="kobo.472.2">On the same page component, we relayed the status of the authentication attempt back to the user. </span><span class="koboSpan" id="kobo.472.3">After this, we created a form action that looked up the username and compared the provided password with a hashed value. </span><span class="koboSpan" id="kobo.472.4">If successful, we logged the user in by setting a cookie on their device. </span><span class="koboSpan" id="kobo.472.5">If unsuccessful, we informed the user that their attempt had failed. </span><span class="koboSpan" id="kobo.472.6">We also briefly discussed some security best practices surrounding authenticating users with our application. </span><span class="koboSpan" id="kobo.472.7">We then examined how experiences with </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.474.1"> elements can be improved by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">enhance</span></strong><span class="koboSpan" id="kobo.476.1"> and snapshots. </span><span class="koboSpan" id="kobo.476.2">Having done all of this, we can be confident in any forms we implement in future </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">SvelteKit projects.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">With everything we’ve covered up until this point, you should be able to put together a basic website or application. </span><span class="koboSpan" id="kobo.478.2">In the next chapter, we’ll cover more advanced functionality that can truly showcase the power of building with SvelteKit. </span><span class="koboSpan" id="kobo.478.3">We will look at even more advanced routing concepts noting how they’ve made use of features we’ve already discussed and explaining some that have yet to </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">be covered.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.480.1">Resources</span></h1>
<p><span class="koboSpan" id="kobo.481.1">The following are the resources for </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.483.1">bcrypt: </span></span><a href="https://github.com/kelektiv/node.bcrypt.js"><span class="No-Break"><span class="koboSpan" id="kobo.484.1">https://github.com/kelektiv/node.bcrypt.js</span></span></a></li>
<li><span class="koboSpan" id="kobo.485.1">Crypto Web </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">API: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto"><span class="No-Break"><span class="koboSpan" id="kobo.487.1">https://developer.mozilla.org/en-US/docs/Web/API/Crypto</span></span></a></li>
</ul>
</div>
</body></html>