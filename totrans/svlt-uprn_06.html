<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-80"><a id="_idTextAnchor080"/>6</h1>
<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Forms and Data Submission</h1>
<p>In the previous chapter, we went into some of the finer details behind loading data in SvelteKit. While loading data is important, it is equally important that we understand how to empower users to submit that data. That is why this chapter will explore some of the finer details behind forms and actions in SvelteKit. While not all applications <em class="italic">have</em> to accept data from users, the ones that do so in an intuitive manner tend to rise above the rest. After all, some of the best user experiences are taken for granted because they simply work. It’s when things break that users begin paying attention to them.</p>
<p>Throughout this chapter, we’ll learn how leveraging <code>&lt;form&gt;</code> elements can keep our application accessible and our code minimal. Integrating those forms with easily implemented actions lets us take the submitted data and process it accordingly. And finally, we’ll look at how we can soften some of the edges of the standard user experience surrounding forms by adding progressive enhancements. To do all of this, we’ll put the finishing touches on the login form we started previously.</p>
<p>In this chapter, we’ll cover the following:</p>
<ul>
<li>Form Setup</li>
<li>Analyzing Actions</li>
<li>Enhancing Forms</li>
</ul>
<p>Upon completing this chapter, you should feel comfortable creating your very own login form, and you’ll know how to go forward and accept all types of data from users of your SvelteKit-based application.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor082"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter06">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter06</a>.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Form Setup</h1>
<p>We took a glance at <a id="_idIndexMarker122"/>using forms and actions together in <a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>. And while covering <code>RequestEvent</code> in the previous chapter, we began creating the code necessary to authenticate a user in our application with cookies. However, in that example, we never gave the user a means to provide a username or password. We also never created the cookie in the application. Instead, we opted to manually create one using the browser’s developer tools. It’s time we bring the whole thing together. Since we’ve covered the logic related to <code>load()</code>, as well as the details surrounding <code>RequestEvent</code>, we can continue building off of our previous example. A good place to start would be the login form itself. After all, we can’t log a user in without giving them a place to do so.</p>
<p>But before we create the form, let’s go ahead and add a link to the login page in our navigation:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/lib/Nav.svelte</p>
<pre class="source-code">
&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href='/'&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/news'&gt;News&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/fetch'&gt;Fetch&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/comment'&gt;Comment&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/about'&gt;About&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/api/post'&gt;API&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href='/login'&gt;Login&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</pre>
<p>The change is as simple as copying an existing <code>&lt;li&gt;</code> element and replacing the route and text inside <code>&lt;a&gt;</code>. This will make navigating and testing our login functionality simpler.</p>
<p>Next, let’s start with the actual form. Looking back at the file we created to show users a successful login based on their cookie, we’ll need to make several changes. Firstly, we’ll import the <code>enhance</code> module from <code>$app/forms</code>. We’ll discuss some of the magic behind this one later in this chapter, so don’t worry about it for now. Next, we’ll want to export the <code>form</code> variable so that we can signal to the user the status of their login. Finally, we’ll need to<a id="_idIndexMarker123"/> create the <code>&lt;form&gt;</code> element with appropriate inputs and give it some styling:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/login/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import { enhance } from '$app/forms';
  export let data;
  export let form;
&lt;/script&gt;
{#if form?.msg}
  {form.msg}
{/if}
{#if data.user}
  &lt;p&gt;
    Welcome, {data.user.name}!
  &lt;/p&gt;
{/if}
&lt;form use:enhance method="POST" action="?/login"&gt;
  &lt;label for="username"&gt;Username&lt;/label&gt;
  &lt;input name="username" id="username" type="text"/&gt;
  &lt;label for="password"&gt;Password&lt;/label&gt;
  &lt;input name="password" id="password" type="password"/&gt;
  &lt;button&gt;Log In&lt;/button&gt;
&lt;/form&gt;
&lt;style&gt;
  form {
    display: flex;
    flex-direction: column;
    justify-content: center;
    width: 25%;
    margin: 0 auto;
  }
  input {
    margin: .25em 1em 1em;
    display: block;
  }
  label {
    margin: 0 .5em;
  }
&lt;/style&gt;</pre>
<p>Now that<a id="_idIndexMarker124"/> you’ve seen the additions altogether, let’s discuss them. Aside from the new imports and exports, the next change you’ll notice is the Svelte directive checking whether or not <code>form?.msg</code> is set. If that is set, we display the message.</p>
<p class="callout-heading">data versus form</p>
<p class="callout">The <code>form</code> prop comes to us from the data returned by our login action (which will be created in the next section). Remember that we include <code>export let data;</code>  to get access to the data prop returned from <code>load()</code>. In the same vein, we include <code>export let form;</code> to retrieve data that has been returned by form actions. The data returned can also be retrieved anywhere in the application via the <code>$</code><code>page.form</code> store.</p>
<p>The next big change is the addition of the <code>&lt;form&gt;</code> element. It makes use of the <code>enhance</code> module we imported earlier, sets the HTTP method to POST, and sends its data to the <code>login</code> action located at <code>src/routes/login/+page.server.js</code>. We <em class="italic">must set the HTTP method to POST</em>; otherwise, our form will attempt to submit data via a GET request, and we don’t want to be sending passwords around insecurely.</p>
<p>We’ve then<a id="_idIndexMarker125"/> included the appropriate markup for inputs, labels, and buttons. For now, we’re only referencing one form action to manage logging a user in. If we wanted to enable registration or password reset functionality and keep the subsequent actions in the same file as our login action, we could leverage the <code>formaction</code> property. However, <code>formaction</code> is intended to be used when you have multiple buttons referring to separate endpoints within the same <code>&lt;form&gt;</code> element. In a password reset scenario, we would likely need another <code>&lt;form&gt;</code> element specifying the email to send our password reset link. Likewise, with registration, we would probably need to obtain a user’s email, as well as their username and password, so having both of those within the context of a form that <em class="italic">only</em> accepts username and password details makes little sense. In each of these cases, it would make more sense to create a separate form for each of the features and specify the action directly on the <code>&lt;form&gt;</code> element. It may still make sense to keep logic concerning authentication in a single <code>+page.server.js</code> file for the sake of project organization.</p>
<p>The actual markup for creating a form is relatively straightforward to implement. We’ve just seen that we need to specify the method as well as the action to be called. And to obtain information returned from our action, we’ll need to include <code>export let form;</code> on the page while making use of data returned from the action. Now that you’ve seen a few variations of it, you should be comfortable creating forms to accept data from your users. Of course, a form doesn’t do much good if we don’t make use of the submitted data. In the next section, we’ll create an action to handle the data collected by the form. To ensure our action works smoothly, we’ll need to set up a database and discuss some security best practices.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Analyzing Actions</h1>
<p>In <a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, we spent <a id="_idIndexMarker126"/>a section looking at how actions worked. Now, it’s time that we took a closer look at them and how they work under the hood. But before we begin, we’ll need to set up another fake database and briefly discuss security. Once we’ve done that, we’ll finish adding logic to our application and authenticate valid users. This section will cover the following:</p>
<ul>
<li>Database setup</li>
<li>Passwords and security</li>
<li>Login action</li>
</ul>
<p>After all of this, you’ll have a general understanding of how to finally create a login form for your own SvelteKit application.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Database setup</h2>
<p>Of course, this<a id="_idIndexMarker127"/> isn’t a real database. We’re going to utilize yet another JSON file that will store our user data and help us simulate looking up a user and their hashed password. It should look something like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/lib/users.json</p>
<pre class="source-code">
[
  {
    "id": "1",
    "username": "dylan",
    "password": "$2b$10$7EakXlg...",
    "identity": "301b1118-3a11-...",
    "name": "Dylan"
  },
  {
    "id": "2",
    "username": "jimmy",
    "password": "$2b$10$3rdM9VQ...",
    "identity": "62e3e3cc-adbe-...",
    "name": "Jimmy"
  }
]</pre>
<p>This<a id="_idIndexMarker128"/> file is a simple array containing two user objects and various properties related to our users. For this demonstration, the values of these properties are trivial, but the values of <code>identity</code> and <code>password</code> are of particular interest to us, as we will see in the next section. The <code>identity</code> property would normally correspond to a user session ID stored in another table. It should also utilize a unique identifier and not be easily guessable. If it were, anyone could authenticate to our application as any user by simply creating the identity cookie on their device with a valid session ID. In this example, <code>identity</code> makes use of <a id="_idIndexMarker129"/>the <strong class="bold">Crypto Web API</strong> to generate a <a id="_idIndexMarker130"/>random <strong class="bold">Universally Unique Identifier</strong> (<strong class="bold">UUID</strong>). The Crypto Web API should not be used for hashing passwords. For this demonstration, we’ll only be using it to create a UUID that will be saved in a cookie used to authenticate a user. For your testing purposes, the value could be any unique string, but this example aims to be relatively realistic. To keep this material from diverging too far from the directive of learning SvelteKit, this is all we’ll need to include for our fake user database.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>Passwords and Security</h2>
<p>Because<a id="_idIndexMarker131"/> authentication is such a common feature found in web applications, it would be a disservice to not further elaborate on how to properly implement it. And <a id="_idIndexMarker132"/>because when done improperly it can have such disastrous consequences, we’ll learn how to implement it securely. While we’re still not connecting to a real database and are instead storing our user passwords in a JSON file (which is highly advised against for anything other than demonstration purposes), we will observe how to properly hash passwords with another package installed via npm.</p>
<p>To proceed further, we’ll need to<a id="_idIndexMarker133"/> install <strong class="bold">bcrypt</strong>. In your terminal, run the following command in the project directory:</p>
<pre class="source-code">
npm install bcrypt</pre>
<p>Once this has been done, we can generate hashes with the following code. This code will only be temporary as it will give us a convenient way to generate the hashes for our passwords <a id="_idIndexMarker134"/>as well as UUIDs for the <code>identity</code> property of our user <a id="_idIndexMarker135"/>objects. These can then be added to your <code>users.json</code> file to simulate looking up a user password from a database. We’ll demonstrate login functionality to utilize it afterward:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/login/+page.server.js</p>
<pre class="source-code">
import bcrypt from 'bcrypt';
export const actions = {
  login: async ({request}) =&gt; {
    const form = await request.formData();
    const hash = bcrypt.hashSync(form.get('password'), 10);
    console.log(hash);
    console.log(crypto.randomUUID());
  }
}</pre>
<p>This <code>+page.server.js</code> file imports the <code>bcrypt</code> module we just installed with npm. It then creates the login action that our <code>&lt;form&gt;</code> element submits data to. It retrieves the form data submitted by the login form via<a id="_idIndexMarker136"/> the <code>crypto.randomUUID();</code> into the console of the developer tools. Upon navigating to <code>/login</code> in your browser, filling in the password field of the form, submitting it, and then opening the server console in your terminal, you will be able to copy the hash and the randomly generated UUID to the respective <code>password</code> and <code>identity</code> properties of each user in your <code>users.json</code>. In this way, you can create passwords for your users. If you’re using the code in this book’s GitHub repository, the hashes for each of the users were derived from the following strings:</p>
<ol>
<li><strong class="bold">password</strong></li>
<li><strong class="bold">jimmy</strong></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">It should go without saying but these are considered bad passwords. Under no circumstances should you ever attempt to use these passwords or their hashes outside of this demonstration.</p>
<p>While we’re on <a id="_idIndexMarker137"/>the subject of security, we should take this opportunity to note some practices to avoid. It’s important that we developers do not use <em class="italic">shared variables</em> to <a id="_idIndexMarker138"/>store sensitive data. To clarify, that doesn’t mean to not use variables to store sensitive data. Rather, we should avoid setting a variable in a form action that could then be available in <code>load()</code>. For a bad practice example, consider a developer declaring a variable for storing chat messages at the highest scope level of a <code>+page.server.js</code> file, assigning message data to it in a form action, and then returning the same variable in the same file’s <code>load()</code> function. Doing so would have the potential to allow user B to view the chat messages for user A. This spillover of data can be avoided by immediately returning the data to the page instead. These same guidelines also apply to Svelte stores. When managing data on the server, we should never set the state of a store as doing so on the server could potentially make it available to all users on that server.</p>
<p>Now that we know how to create hashed passwords and UUIDs, we can follow some basic best practices surrounding security. If you’re ever in doubt, consult the official SvelteKit documentation. As technologies change, so too can best practices. In the next section, we’ll see how can finally finish the login form by creating the action to tie it all together.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Login Action</h2>
<p>After <a id="_idIndexMarker139"/>all of that setup, we’ve finally made it. We can now complete the action used by the form to log our user in and set a cookie in their browser. I’m sure you’re ready by now, so let’s dive into it.</p>
<p>Previously in this file, we created some code to generate hashes for our passwords to test against. We can do away with that code and replace it with code that will look in our database for a matching username, check the provided password against the found user’s hashed password, and set a cookie on the user’s device:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/login/+page.server.js</p>
<pre class="source-code">
import bcrypt from 'bcrypt';
import users from '$lib/users.json';
export const actions = {
  login: async ({request, cookies}) =&gt; {
    const form = await request.formData();
    const exists = users.filter(user =&gt; user.username === form.
      get('username'));
    const auth = exists.filter(user =&gt; bcrypt.compareSync(form.
      get('password'), user.password));
    if(!exists.length || !auth.length) {
      return {msg: 'Invalid login!'};
    }
    cookies.set('identity', auth[0].identity, {path: '/'});
    return {msg: 'success!'}
  }
}</pre>
<p>In this<a id="_idIndexMarker140"/> new version, we still import the <code>bcrypt</code> module but we’ve also added the import of <code>user.json</code>. We then added <code>cookies</code> to the destructured <code>RequestEvent</code> parameter. After setting up the <code>login</code> action, we get the data submitted by the <code>&lt;form&gt;</code> element and put it into the <code>form</code> constant. Next, we use <code>filter()</code> to check against the username of each element in the <code>users</code> array. Any matches are added to the <code>exists</code> constant. We then use <code>filter()</code> again to check the submitted password against the hashed password of every user in <code>exists</code>. If a match is found, it is added to the <code>auth</code> constant. If either <code>exists</code> or <code>auth</code> contains no items in their arrays, we return a message that the login attempt was invalid.</p>
<p class="callout-heading">Combatting account enumeration</p>
<p class="callout">We should never return a message alerting the user that their username (or email) was correct but that the provided password failed. Doing so would allow malicious actors to enumerate valid accounts, essentially guessing usernames in quick succession. Once done, it becomes trivial for attackers to compile a list of valid usernames and begin brute-forcing passwords on real accounts. Since users are not well known for creating strong passwords, this could lead to account takeovers for multiple accounts. This is why we only return a message alerting the user that their login attempt failed. Whether or not their username or password was incorrect is for them to figure out.</p>
<p>If a user <a id="_idIndexMarker141"/>was successful in logging in, we use <code>cookies.set()</code> to send the <code>Set-Cookie</code> headers telling the client to set the <code>identity</code> cookie to the user’s session ID on the root directory of the domain. We must specify the root path in the options; otherwise, our cookie will default to only working at the highest level route where it was set – in this case, only on pages such as <code>/login</code>. You can imagine how frustrating that would be for users. We can then check whether the user is authorized to access functionality at various locations across the application. To remove the same cookie and log a user out, we could use <code>cookies.delete()</code> while passing in the name of the cookie, as well as our path.</p>
<p>Finally, to show users whether or not their login attempt was successful, we’ll need to make a couple of adjustments to our root server layout. If you recall, we previously only checked whether <code>identity === '1'</code>. With a fake database implemented, we can instead check against our user’s JSON file:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+layout.server.js</p>
<pre class="source-code">
import users from '$lib/users.json';
export function load({ cookies }) {
  const data = {
    notifications: {
      count: 3,
      items: […]
    }
  };
  const exists = users.filter(user =&gt; user.identity === cookies.get('identity'));
  if(exists.length) {
    const {password, …user} = {...exists[0]};
    data.user = user;
  }
  return data;
}</pre>
<p>Since we need <a id="_idIndexMarker142"/>to check the <code>identity</code> cookie value against those that exist in <code>users.json</code>, we’ll need to import it first. We don’t need to change anything with the <code>data</code> constant yet, so we can leave the code related to notifications alone. We must then utilize <code>filter()</code> to find whether any users exist with the value obtained from the identity cookie and assign those found to the <code>exists</code> constant. If <code>exists</code> has values, we obtain the first one found and harness the power of a destructuring assignment to avoid passing the user's password into <code>data.user</code>. This is done to prevent including sensitive data.</p>
<p>Now that we’ve<a id="_idIndexMarker143"/> put it all together, we can verify that the login works by navigating to <code>/login</code> in our browser and typing in the appropriate details. If you have created your own hashes, you’ll need to use the strings you provided to successfully authenticate. Upon submitting the form, we should be greeted by the status message, as well as the welcome message from <code>src/routes/login/+page.svelte</code>.</p>
<p>To recap, in this section, we created a fake user database using a JSON file. We included our secure password hashes in that file to check against. When a username and password are submitted from the <code>&lt;form&gt;</code> element in <code>src/routes/login/+page.svelte</code>, that data is retrieved using the <code>src/routes/login/+page.server.js</code>. We then checked for the username as well as that user’s hashed password; if found, we send the <code>Set-Cookie</code> headers in our response by way of <code>cookies.set()</code> and send a <em class="italic">Success</em> status message. If a login attempt does not match a username or password, we return an <em class="italic">Invalid Login</em> status message. Now that we know how to create a form and submit our data to the appropriate actions, let’s examine some methods that can improve the user experience of our application.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Enhancing Forms</h1>
<p>To reduce the <a id="_idIndexMarker145"/>friction inherent in forms on the web, SvelteKit provides us with a few options. We saw the first of those options earlier when we set <code>use:enhance</code> on our login form. This one is great for keeping the page from redirecting as it can submit the form data in the background, which means our page doesn’t need to be reloaded. Another tool we’ve yet to see is what <a id="_idIndexMarker146"/>SvelteKit calls <strong class="bold">snapshots</strong>. In this section, we’ll look at both and how they can help improve the experience of your application:</p>
<ul>
<li><code>enhance</code></li>
<li>Snapshots</li>
</ul>
<p>After completing this section, you’ll be capable of building forms for your users that will be intuitive and streamlined, leading to far greater chances of acceptance by users of your application.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/>enhance</h2>
<p>By<a id="_idIndexMarker147"/> importing <code>enhance</code> from <code>$app/forms</code>, we can progressively enhance the flow of <code>&lt;form&gt;</code> elements. This means that we can submit the data without requiring a page reload, which would normally be found when submitting an <code>&lt;form&gt;</code> element. We’ve seen this action a couple of times now but in both cases we never discussed how it works.</p>
<p>The first step that’s taken by <code>enhance</code> is updating the <code>form</code> property. We were able to observe this with the Svelte directive located in <code>src/routes/login/+page.svelte</code>, which checks whether <code>form?.msg</code> is set. Because Svelte is reactive, when <code>enhance</code> updates <code>form</code>, we can immediately view the change and display our message. <code>enhance</code> will also update <code>$page.form</code> and <code>$page.status</code>, which are both properties of the Svelte <code>$page</code> store. This store gives us information about the currently displayed page. <code>$page.form</code> will contain the same data returned from the form action, whereas <code>$page.status</code> will contain HTTP status code data. We first saw an example of the <code>$page</code> store used in the <em class="italic">Dynamic routing</em> section of <a href="B19024_04_Final_AM.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>.</p>
<p>Upon receiving a successful response, <code>enhance</code> will reset the <code>&lt;form&gt;</code> element and force the appropriate <code>load()</code> functions to rerun by calling <code>invalidateAll()</code>. It will then resolve any redirects, render the nearest <code>+error.svelte</code> (if an error occurred), and reset the focus to the correct element as if the page was being loaded for the first time.</p>
<p>Should <code>enhance</code> be used on a <code>&lt;form&gt;</code> element with an action to an entirely different route, <code>enhance</code> <code>form</code> or <code>$page</code>. This is because it aims to emulate native browser behavior and submission of data across routes like this would normally trigger a page reload. To force it to update these properties, you will need to pass a callback function to <code>enhance</code>. The callback function can then use <code>applyAction</code> to update the stores accordingly. The <code>applyAction()</code> function accepts a SvelteKit <code>ActionResult</code> type and can also be imported from <code>$app/forms</code>.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>Snapshots</h2>
<p>One commonly <a id="_idIndexMarker148"/>frustrating experience endured by users is caused by navigating away from a page after filling out a large form but before that form has been submitted. No matter the cause, losing data that took significant time to enter is painful.</p>
<p>By persisting <code>&lt;form&gt;</code> data in a snapshot, we can make it easier for users to pick up where they left off. Fewer headaches for users means a better experience with our application. And implementing it is a breeze as we only need to export a <code>snapshot</code> constant with the <code>capture</code> and <code>restore</code> properties set. To see it in action, let’s persist the comment form data we built earlier:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/comment/+page.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import { enhance } from '$app/forms';
  export let form;
  let comment = '';
  export const snapshot = {
    capture: () =&gt; comment,
    restore: (item) =&gt; comment = item
  }
&lt;/script&gt;
&lt;div class='wrap'&gt;
  {#if form &amp;&amp; form.status === true}
    &lt;p&gt;{form.msg}&lt;/p&gt;
  {/if}
  &lt;form method='POST' action='?/create' use:enhance&gt;
    &lt;label&gt;
      Comment
      &lt;input name="comment" type="text" bind:value={comment}&gt;
    &lt;/label&gt;
    &lt;button&gt;Submit&lt;/button&gt;
    &lt;button formaction='?/star'&gt;Star&lt;/button&gt;
    &lt;button formaction='?/reply'&gt;Reply&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;</pre>
<p>In this new version, we’ve only <a id="_idIndexMarker149"/>made three significant changes:</p>
<ol>
<li>Added <code>let comment = '';</code> so that we may capture and restore the input value to our JS.</li>
<li>Added the snapshot object with <code>export </code><code>const snapshot</code>:<ol><li>The <code>capture</code> property calls an anonymous function just before the page updates when navigating away. This function only needs to return the values we wish to capture and restore later – in this case, the value associated with <code>comment</code>.</li><li><code>restore</code> is called immediately after the page is loaded and assigns the parameter it was called with to <code>comment</code>.</li></ol></li>
<li>We bind the value of the comment’s <code>&lt;text&gt;</code> input to the <code>comment</code> variable so that the input’s value may be retrieved on capture and set on restore.</li>
</ol>
<p>Once you have implemented these changes, you can test them out by opening the <code>/comment</code> route in your browser, typing in a test comment, and navigating away to another page. When you click <em class="italic">Back</em> in your browser, you will observe the data that was restored just as you left it. Because snapshots persist the data they capture to Session Storage, you can open your browser developer tools and observe the data. In Firefox, you can find it under <code>/comment</code> page by clicking the link in the menu will not trigger a restore as it is considered navigating to a new page.</p>
<p>Knowing how to progressively and seamlessly enhance your forms can lead to an experience that will keep users coming back. By running form submissions in the background, we can make use of Svelte’s reactivity to provide immediate and useful feedback to users. And with the use of snapshots, we can preserve a user’s progress on simple or complex forms. With this knowledge, you can now go forth and build intuitive experiences into your applications.</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/>Summary</h1>
<p>We started this chapter by building a simple <code>&lt;form&gt;</code> element that accepts a username and password. On the same page component, we relayed the status of the authentication attempt back to the user. After this, we created a form action that looked up the username and compared the provided password with a hashed value. If successful, we logged the user in by setting a cookie on their device. If unsuccessful, we informed the user that their attempt had failed. We also briefly discussed some security best practices surrounding authenticating users with our application. We then examined how experiences with <code>&lt;form&gt;</code> elements can be improved by using <code>enhance</code> and snapshots. Having done all of this, we can be confident in any forms we implement in future SvelteKit projects.</p>
<p>With everything we’ve covered up until this point, you should be able to put together a basic website or application. In the next chapter, we’ll cover more advanced functionality that can truly showcase the power of building with SvelteKit. We will look at even more advanced routing concepts noting how they’ve made use of features we’ve already discussed and explaining some that have yet to be covered.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Resources</h1>
<p>The following are the resources for this chapter:</p>
<ul>
<li>bcrypt: <a href="https://github.com/kelektiv/node.bcrypt.js">https://github.com/kelektiv/node.bcrypt.js</a></li>
<li>Crypto Web API: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto">https://developer.mozilla.org/en-US/docs/Web/API/Crypto</a></li>
</ul>
</div>
</body></html>