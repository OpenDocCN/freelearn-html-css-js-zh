- en: 6\. Advanced Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 高级类型
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to advanced types. You will start with the building
    blocks of advanced types – type alias, string, and number literals. This will
    allow you to gain a better understanding as you take on more complex concepts
    such as union types. You will also learn how you can combine types to build more
    complex types, such as intersections. Using advanced types, this chapter teaches
    you how to write code that is easier to understand for yourself and any others
    working with you or who are inheriting the project. By the end of this chapter,
    you will be able to build advanced types by combining primitive types, such as
    strings, numbers, and Booleans, with objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍高级类型。你将从高级类型的基础——类型别名、字符串和数字字面量开始。这将帮助你更好地理解，当你承担更复杂的概念，如联合类型时。你还将学习如何将类型组合起来构建更复杂的类型，例如交集。使用高级类型，本章将教你如何编写易于你自己和任何与你一起工作或继承项目的人理解的代码。到本章结束时，你将能够通过将原始类型，如字符串、数字和布尔值，与对象相结合来构建高级类型。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: In the previous chapter, we went over interfaces and inheritance. You saw how
    they allowed for the extension and modeling of your classes. Interfaces give your
    classes structure, and inheritance allows you to extend and build on your existing
    code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了接口和继承。你看到了它们如何允许扩展和建模你的类。接口给你的类提供了结构，继承允许你扩展并基于现有代码进行构建。
- en: As web applications become more complex, it is necessary to be able to model
    that complexity, and TypeScript makes that easy with advanced types. Advanced
    types allow you to model the complex data you will be working with as a modern
    web developer. You will be able to take primitive types and make more complex
    types from them, creating types that are conditional and flexible. This will allow
    you to write code that is easy to understand and therefore easier to work with.
    As a working developer, you may come across a dataset provided by an API that
    you need to integrate into your application. These datasets can be complex. For
    example, Cloud Firestore from Google is a document-based, real-time database that
    can have objects nested within objects. With advanced types, you can create a
    type that is an exact representation of the data coming from the API. This will
    provide much more context to your code, which, in turn, will make it easier to
    work with for you and your team. You will also be able to stack complexity by
    building simpler types and stacking them to make more complex types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络应用程序变得越来越复杂，能够对这种复杂性进行建模变得必要，TypeScript 通过高级类型使这一点变得简单。高级类型允许你将作为现代网络开发者将要处理的数据建模为复杂的数据。你将能够从原始类型中创建更复杂的类型，创建出条件性和灵活性的类型。这将使你能够编写易于理解的代码，因此也更容易与之工作。作为一名正在工作的开发者，你可能会遇到一个由API提供的需要集成到你的应用程序中的数据集。这些数据集可能很复杂。例如，Google的Cloud
    Firestore是一个基于文档的实时数据库，可以在对象中嵌套对象。使用高级类型，你可以创建一个与API返回的数据完全一致的类型。这将为你提供更多的代码上下文，从而反过来使你和你团队的工作更容易。你还可以通过构建更简单的类型并将它们堆叠起来来构建更复杂的类型。
- en: In this chapter, we will cover the building blocks of advanced types – type
    aliases and type literals. Once we learn how to build types, we will move on to
    more advanced concepts, including intersection, union, and index types. All these
    concepts will help you to learn how to use advanced types to add context and abstract
    complexity to code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍高级类型的基础——类型别名和类型字面量。一旦我们学会了如何构建类型，我们就会继续学习更高级的概念，包括交集、联合和索引类型。所有这些概念都将帮助你学习如何使用高级类型为代码添加上下文和抽象复杂性。
- en: Type Aliases
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: '**Type Aliases** allow you to declare references to any type – advanced or
    primitive. Aliases make our code easier to read by allowing us to be less verbose.
    Aliases allow you, the developer, to declare your type once and reuse it throughout
    your application. This makes working with complex types easier and your code more
    readable and maintainable.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型别名**允许你声明对任何类型的引用——无论是高级类型还是原始类型。别名通过允许我们更简洁地表达来使我们的代码更容易阅读。别名允许你，作为开发者，一次性声明你的类型并在整个应用程序中重用它。这使得处理复杂类型变得更容易，并使你的代码更易于阅读和维护。'
- en: 'Let''s say, for example, we are working on a social networking application
    and we needed to provide an administrator user type for users to manage the pages
    they created. Additionally, we also need to define a site administrator user.
    On a base level, they are both admins, and therefore the types would have some
    commonality between them. With a type alias, we could create an admin type as
    shown in *Figure 6.1*, with common properties an admin user would possess and
    build upon that admin when creating our site admin and user admin types. Aliases
    allow you to mask the complexity of your code, which will make it easier to understand.
    Here we have a diagram of an alias that assigns the `Admin` alias to an admin
    type, which is a complex `type` object. We also have an example of an alias, `One`,
    that is assigned to a type, `number`, which is a primitive type:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，我们正在开发一个社交网络应用程序，我们需要为用户提供一个管理员用户类型，以便他们可以管理他们创建的页面。此外，我们还需要定义一个网站管理员用户。在基本层面上，他们都是管理员，因此类型之间会有一些共性。使用类型别名，我们可以创建一个如
    *图6.1* 所示的管理员类型，包含管理员用户将拥有的常见属性，并在创建我们的网站管理员和用户管理员类型时在此基础上构建。别名允许你隐藏代码的复杂性，这将使代码更容易理解。这里有一个将
    `Admin` 别名分配给代表典型管理员共同属性的复杂 `type` 对象的图示。我们还有一个别名 `One` 的例子，它被分配给一个类型 `number`，这是一个原始类型：
- en: '![Figure 6.1: Alias assigning a complex admin type alias'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：别名分配复杂管理员类型别名'
- en: '](img/B14508_06_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_06_01.jpg)'
- en: 'Figure 6.1: Alias assigning a complex admin type alias'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：别名分配复杂管理员类型别名
- en: 'Consider the following code snippet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we have created an alias, `One`, that can be used
    as a type for any number, as it is assigned to the type number.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个别名 `One`，它可以被用作任何数字的类型，因为它被分配为数字类型。
- en: 'Now, consider the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码片段：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we have created an `Admin` alias, which we have assigned to an object
    that represents the common properties of a typical administrator, in the context
    of this example. As you can see, we have created a reference to a `type` object,
    which we can now use in our code instead of having to implement the object each
    time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `Admin` 别名，并将其分配给代表典型管理员共同属性的对象，在这个例子中。正如你所看到的，我们创建了一个对 `type` 对象的引用，我们现在可以在我们的代码中使用它，而无需每次都实现该对象。
- en: As you can see in the preceding diagram and code snippet, type aliases work
    in a similar way to variable assignments, except a reference is created for a
    primitive type and/or an object. This reference can then be used as a template
    for your data. This will allow you to take advantage of all the benefits of a
    strongly typed language, such as code completion and data validation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图和代码片段所示，类型别名的工作方式与变量赋值类似，除了为原始类型和/或对象创建了一个引用。然后，这个引用可以作为数据模板使用。这将允许你利用强类型语言的所有好处，例如代码补全和数据验证。
- en: Before we go into our first exercise on type aliases, we will look at some examples
    of primitive and complex assignments.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行关于类型别名的第一个练习之前，我们将查看一些原始和复杂赋值的例子。
- en: Let's say you are working on a class method that takes numbers as arguments,
    and only numbers. You want to make sure that when your method is used, only numbers
    are passed as arguments and the right error messages are shown to the user if
    any other type is passed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个类方法，该方法只接受数字作为参数。你想要确保当你的方法被使用时，只传递数字作为参数，如果传递了其他类型，则向用户显示正确的错误消息。
- en: 'First, we need to create a number type alias with the following syntax:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用以下语法创建一个数字类型别名：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `type` keyword is followed by the alias, `OnlyNumbers`, and then the `number` type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 关键字后面跟着别名 `OnlyNumbers`，然后是 `number` 类型。'
- en: 'Now we can build a class with a method that only takes numbers as an argument
    and use the type alias to enforce our rule:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建一个只接受数字作为参数的方法的类，并使用类型别名来强制执行我们的规则：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's instance our class and pass some arguments to our method to see whether
    our code works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实例化我们的类，并将一些参数传递给我们的方法，以查看我们的代码是否工作。
- en: 'For this example, let''s try and assign a string as the argument type:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们尝试将字符串作为参数类型分配：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code snippet, we have provided the wrong argument of the `string`
    type and this will result in a warning because our method, `SetNumber`, is expecting
    a number. Also, by providing your type aliases with meaningful names such as `onlyNumbers`,
    you can make your code easier to read and debug. For this example, the section
    of the code with the problem is highlighted, and when you hover over the error,
    you get a very helpful error message telling you what the issue is and how it
    can be resolved:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们提供了错误的`string`类型参数，这将导致警告，因为我们的方法`SetNumber`期望一个数字。此外，通过为你的类型别名提供有意义的名称，如`onlyNumbers`，你可以使你的代码更容易阅读和调试。对于这个例子，有问题的代码部分被突出显示，当你悬停在错误上时，你会得到一个非常有用的错误消息，告诉你问题是什么以及如何解决它：
- en: '![Figure 6.2: Error message in VS Code'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：VS Code中的错误消息'
- en: '](img/B14508_06_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_06_02.jpg)'
- en: 'Figure 6.2: Error message in VS Code'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：VS Code中的错误消息
- en: This is the case provided that you have the correct support from your IDE. If
    you don't have IDE support, you will be shown an error message at code compilation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的IDE提供了正确的支持，这是这种情况。如果你没有IDE支持，你将在代码编译时看到错误消息。
- en: This is a simple use case, but as your applications become larger, some time
    has passed, or you are working in a large team, this kind of type security is
    vital to writing code that is free of mistakes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的用例，但随着你的应用程序变得更大，时间过去了一些，或者你在一个大型团队中工作，这种类型安全对于编写无错误的代码至关重要。
- en: 'Let''s consider another example: Say you are working on an online store application
    and you need to use a product class that was not created by you. If the person
    who created the class made use of types and used descriptive names, it would be
    easier for you to work with that code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子：假设你正在开发一个在线商店应用程序，你需要使用一个不是由你创建的类。如果创建这个类的人使用了类型并且使用了描述性的名称，那么你使用这段代码会更容易。
- en: 'Now, let''s edit the first example with the correct argument type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用正确的参数类型编辑第一个例子：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code snippet, we have provided the correct argument type of
    `number` and your class method takes the argument with no issues.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们提供了正确的`number`类型参数，并且你的类方法没有问题地接收了参数。
- en: Now, let's consider a complex alias assignment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个复杂的别名赋值。
- en: 'For example, we want to create a new function that takes a user object as a
    type argument. We could define the object as the function argument inline, as
    shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要创建一个新的函数，该函数接受一个用户对象作为类型参数。我们可以将对象作为函数参数内联定义，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding snippet, the code creates a function that takes a user as an
    argument, but the type is defined in the function itself. While this would work,
    let's say you were using the object in a few places in your code, then, you would
    have to define this object each time. This is very inefficient and, as a good
    developer, you don't want to repeat code. This way of working will also lead to
    errors; it will make your code harder to work with and update as every instance
    of the `User` type will need to be changed throughout your code. Type aliases
    resolve this by allowing you to define your type once, as we will demonstrate
    in the following code snippet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，代码创建了一个函数，该函数接受一个用户作为参数，但类型是在函数本身中定义的。虽然这可以工作，但假设你在代码的几个地方使用这个对象，那么你将不得不每次都定义这个对象。这非常低效，作为一个好的开发者，你不想重复代码。这种工作方式也会导致错误；它会使你的代码更难处理和更新，因为代码中每个`User`类型的实例都需要更改。类型别名通过允许你一次性定义你的类型，从而解决了这个问题，我们将在下面的代码片段中演示。
- en: 'In much the same way as we have defined our primitive type, we have defined
    our `User` type. We use the `type` keyword, but now we have mapped to an object
    that is a template of our `User` type. We can now use the `User` alias, rather
    than having to redeclare the object every time we need to define the `User` type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们定义了我们的原始类型一样，我们也定义了我们的`User`类型。我们使用`type`关键字，但现在我们将它映射到一个代表我们的`User`类型的对象模板。现在我们可以使用`User`别名，而无需每次需要定义`User`类型时都重新声明该对象：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we have created a type with the alias `User`. This allows you
    to make a single reference to this object type and reuse it throughout your code.
    If we did not do this, we would have to reference the type directly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们创建了一个带有别名`User`的类型。这允许你在整个代码中只对这个对象类型进行一次引用并重用它。如果我们没有这样做，我们就必须直接引用该类型。
- en: 'Now you can build a new function using your `User` type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用你的`User`类型构建一个新的函数：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, this code is much less verbose and easy to understand. All your
    code regarding the `User` type is in one location, and when changes are made to
    the object, all aliases are updated. In the following exercise, you will implement
    what we have covered so far to build your own type alias.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码更加简洁易懂。所有关于`User`类型的代码都在一个位置，当对象发生变化时，所有别名都会更新。在接下来的练习中，你将实现我们到目前为止所学的知识来构建你自己的类型别名。
- en: 'Exercise 6.01: Implementing a Type Alias'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：实现类型别名
- en: In this exercise, we will use our knowledge of types to build a function that
    creates products. Let's say, for example, you are working on a shopping application
    and when the inventory manager adds a product to the inventory, you need to push
    that product to your array of products. This exercise demonstrates a few ways
    in which type aliases can be useful by allowing you to define your `Product` model
    once and reuse it throughout your code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用我们对类型的了解来构建一个创建产品的函数。例如，假设你正在开发一个购物应用程序，当库存管理员将产品添加到库存中时，你需要将此产品推送到你的产品数组中。这个练习演示了类型别名如何通过允许你一次性定义你的`Product`模型并在整个代码中重用它来发挥其作用。
- en: Now, in an actual inventory management application, you might have a frontend
    page that allows a user to input the product name and supporting information manually.
    For the purpose of this exercise, let's assume the products you want to add are
    named `Product_0` through to `Product_5` and all have a price of 100, while the
    number of each of these products added to the inventory is 15.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在一个实际的库存管理应用程序中，你可能有一个前端页面，允许用户手动输入产品名称和相关信息。为了这个练习的目的，让我们假设你想要添加的产品命名为`Product_0`到`Product_5`，并且所有产品的价格都是100，而每种产品添加到库存中的数量是15。
- en: 'This may not be truly reflective of an actual scenario in an inventory management
    application, but remember, our key goal is to use a type alias. So for now, a
    simple `for` loop to complete the aforementioned tasks will suffice:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能并不真正反映库存管理应用程序中的实际场景，但请记住，我们的关键目标是使用类型别名。所以现在，一个简单的`for`循环来完成上述任务就足够了：
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'All files in this chapter can be executed by running `npx ts-node filename.ts`
    on the terminal. The code file for this exercise can be found here: [https://packt.link/EAiHb](https://packt.link/EAiHb).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有文件都可以通过在终端中运行`npx ts-node filename.ts`来执行。本练习的代码文件可以在以下位置找到：[https://packt.link/EAiHb](https://packt.link/EAiHb)。
- en: Open VS Code and create a new file named `Exercise01.ts`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code并创建一个名为`Exercise01.ts`的新文件。
- en: 'Create a primitive type alias, `Count`, that is of the `number` type. `Count`
    will be used to keep track of the number of products:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个原始类型别名，`Count`，它属于`number`类型。`Count`将用于跟踪产品的数量：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create an object type alias, `Product`, that is of the `type` object. Re-use
    `Count` to define the count of the product. The `Product` type alias will be used
    to define every product we add to our inventory. The properties are common across
    all products:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象类型别名，`Product`，它属于`type`对象。重用`Count`来定义产品的数量。`Product`类型别名将用于定义我们添加到库存中的每个产品。属性在所有产品中是通用的：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Declare a `products` variable of the `Product` type array:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`products`变量，其类型为数组类型的`Product`：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order for us to make use of the `Product` type, it was first assigned to
    a variable in the preceding code, and the `product_list` variable is an array
    of objects of the `Product` type.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让我们能够使用`Product`类型，它首先在前面代码中被分配给一个变量，`product_list`变量是一个`Product`类型的对象数组。
- en: 'Create a function that adds products to the array. Re-use the `Product` type
    alias to validate the argument input:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于向数组中添加产品。重用`Product`类型别名来验证输入参数：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use a `for` loop to create product objects of the `Product` type and add them
    to the `products` array:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环创建`Product`类型的产品对象并将它们添加到`products`数组中：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile and run the program by executing `npx ts-node Exercise01.ts` in the
    correct directory in which this file is present. You should obtain the following
    output:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在正确的目录中执行`npx ts-node Exercise01.ts`来编译并运行程序。你应该获得以下输出：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this exercise, you created two type aliases, which in turn created references
    to your actual types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你创建了两个类型别名，这反过来又创建了对你实际类型的引用。
- en: This allowed you to reduce complexity and make your code more readable, as now
    you can provide names that have additional context with descriptive names such
    as `Product` and `products_list`. If we were to write this code without the use
    of aliases, at every place where you used your aliases in the exercise, you would
    have to define the object or the type directly. This might not be much of an issue
    here with this simple function, but keep in mind how much more code you would
    need to build a class or a major project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你减少复杂性并使你的代码更易于阅读，因为现在你可以提供具有额外上下文的名字，例如 `Product` 和 `products_list`。如果我们不使用别名来编写此代码，在练习中每次使用别名的地方，你都必须直接定义对象或类型。这在这个简单的函数中可能不是什么大问题，但请记住，构建一个类或大型项目你需要多少代码。
- en: As we proceed to more complex type structures, this knowledge will become invaluable.
    We will continue to build on our knowledge in the next section as we cover type
    literals.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续深入到更复杂的类型结构，这些知识将变得极其宝贵。在下一节中，当我们介绍类型字面量时，我们将继续构建我们的知识。
- en: Type Literals
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型字面量
- en: '**Type literals** allow you to create a type based on a specific string or
    number. This, in itself, is not very useful, but as we move on to more complex
    types such as union types, their use will become apparent. Literals are straightforward,
    so we will not spend a lot of time on them but you will need to understand the
    concept of literals as we move into the next phase.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型字面量**允许你基于特定的字符串或数字创建一个类型。这本身可能不是非常有用，但随着我们继续到更复杂类型，如联合类型，它们的使用将变得明显。字面量很简单，所以我们不会花太多时间在它们上面，但当你进入下一阶段时，你需要理解字面量的概念。'
- en: Let's start by creating our string and number literals.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建我们的字符串和数字字面量。
- en: 'We will begin with a string literal:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个字符串字面量开始：
- en: '**Example01.ts**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**Example01.ts**'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code creates a `Yes` type that will take only a specific string,
    `"yes"`, as the input.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个 `Yes` 类型，它只接受特定的字符串 `"yes"` 作为输入。
- en: 'Similarly, we can create a number literal:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以创建一个数字字面量：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we create a number literal type, `One`, that will only take `1` as the
    input.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个数字字面量类型 `One`，它只接受 `1` 作为输入。
- en: The basic syntax as observed in the preceding examples is quite simple. We start
    with the `type` keyword, followed by the name (alias) of our new literal, and
    then the literal itself, as shown in the preceding syntax. We now have a type
    of the `yes` string and the number `1`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中观察到的基本语法相当简单。我们以 `type` 关键字开始，然后是我们的新字面量的名称（别名），接着是字面量本身，如前一个语法所示。我们现在有了
    `yes` 字符串和数字 `1` 的类型。
- en: 'Next, we will build a function that will make use of our new types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个将利用我们新类型的函数：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have cast our function arguments to our literal types, and because our types
    are literal, only the "`yes`" string or the number `1` will be accepted as arguments.
    Our function will not take other arguments. Let''s say we passed `""` and `2`
    as arguments (`yesOne("", 2)`). You will notice the following warning in VS Code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将函数参数转换为我们的字面量类型，并且由于我们的类型是字面量，只有 `"yes"` 字符串或数字 `1` 将被接受作为参数。我们的函数不会接受其他参数。假设我们传递了
    `""` 和 `2` 作为参数（`yesOne("", 2)`）。你会在VS Code中注意到以下警告：
- en: '![Figure 6.3: IDE warning when incorrect arguments are passed'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：传递错误参数时IDE显示的警告'
- en: '](img/B14508_06_03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_06_03.jpg)'
- en: 'Figure 6.3: IDE warning when incorrect arguments are passed'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：传递错误参数时IDE显示的警告
- en: 'Now, let''s say we passed `"yes"` and `2` as arguments. Again, you will get
    the following warning:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们传递了 `"yes"` 和 `2` 作为参数。再次，你会得到以下警告：
- en: '![Figure 6.4: Errors displayed when a parameter that cannot be assigned is
    passed'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：传递无法分配的参数时显示的错误'
- en: '](img/B14508_06_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_06_04.jpg)'
- en: 'Figure 6.4: Errors displayed when a parameter that cannot be assigned is passed'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：传递无法分配的参数时显示的错误
- en: The preceding are some examples of error messages you might expect if you provide
    the wrong arguments. The error messages are clear and tell you precisely what
    you need to do to resolve the error. As you can see, even though we are passing
    a string and a number, we still get a type error. This happens because these arguments
    are literal; they can only match themselves exactly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可能期望的错误消息示例，如果你提供了错误的参数。错误消息很清晰，并确切地告诉你如何解决错误。正如你所看到的，尽管我们传递了一个字符串和一个数字，我们仍然得到了类型错误。这是因为这些参数是字面量；它们只能与自身完全匹配。
- en: 'Now, let''s try and pass the correct arguments:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试传递正确的参数：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once provided with the correct arguments, the function can be called without
    any issue, as shown in the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提供了正确的参数，函数就可以无任何问题地调用，如下所示输出：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before we move on to intersection types, let's quickly complete a simple exercise
    to cement our knowledge of string and number literals.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续介绍交集类型之前，让我们快速完成一个简单的练习，以巩固我们对字符串和数字字面量的知识。
- en: 'Exercise 6.02: Type Literals'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：类型字面量
- en: 'Now that we have a better understanding of literals, let''s go through a small
    exercise to reinforce what we have covered. Here we will create a function that
    takes a string literal and returns a number literal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对字面量有了更好的理解，让我们通过一个小练习来巩固我们所学的内容。在这里，我们将创建一个函数，该函数接受一个字符串字面量并返回一个数字字面量：
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/hHgNa](https://packt.link/hHgNa).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在此处找到：[https://packt.link/hHgNa](https://packt.link/hHgNa)。
- en: Open VS Code and create a new file named `Exercise02.ts`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code并创建一个名为`Exercise02.ts`的新文件。
- en: 'Create a string literal type, `No`, and assign the string `"no"` as the value.
    Also, create a number literal and assign 0 as the value:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串字面量类型`No`，并将其值设置为字符串`"no"`。同时，创建一个数字字面量并将其值设置为0：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Build a function that takes the "`No`" literal and prints it to the console:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受`"No"`字面量并将其打印到控制台：
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Console out the function call results:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出函数调用的结果：
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will result in the following output:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Literals by themselves are not very useful, but when used in combination with
    more complex types, their usefulness will become apparent. For now, you need to
    understand how to create literals, so you can make use of them later in this chapter.
    In the next section, we move on to intersection types. All the work that we have
    completed so far will help as we make use of type aliases and literals.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量本身并不是非常有用，但与更复杂的类型结合使用时，它们的有用性将变得明显。目前，你需要了解如何创建字面量，这样你就可以在本书的后面部分使用它们。在下一节中，我们将继续介绍交集类型。到目前为止我们所完成的所有工作都将有助于我们使用类型别名和字面量。
- en: Intersection Types
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交集类型
- en: '**Intersection Types** allow you to combine types to form a new type with the
    properties of the combined types. This is useful in cases where you have an existing
    type that does not, by itself, address some data you need to define, but it can
    do so in combination with another existing type. This is similar to multi-class
    inheritance, as the child object can have more than one parent object that it
    derives its properties from.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**交集类型**允许你结合类型以形成一个新类型，该类型具有组合类型的属性。这在以下情况下很有用：你有一个现有的类型，它本身并不能定义你需要的一些数据，但它可以与另一个现有类型结合使用。这类似于多类继承，因为子对象可以有一个或多个父对象，从中继承其属性。'
- en: 'Let''s say you have a type `A` with a name and age property. You also have
    a type `B` with a height and weight property. In your application, you find that
    there is a need for a person type: you want to track the user''s name, age, height,
    and weight. You can intersect type `A` and `B` to form a `Person` type. Why not
    just create a new type you ask? Well, this takes us back to wanting to be good
    coders and good coders stay DRY – Don''t Repeat Yourself. Unless a type is truly
    unique in your application, you should reuse as much code as possible. Also, there
    is centralization.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`A`的类型，它具有姓名和年龄属性。你还有一个名为`B`的类型，它具有身高和体重属性。在你的应用程序中，你发现需要一个人员类型：你想要跟踪用户的姓名、年龄、身高和体重。你可以通过交集类型`A`和`B`来形成一个`Person`类型。你可能会问，为什么不直接创建一个新的类型呢？好吧，这让我们回到了想要成为优秀的程序员和优秀的程序员保持DRY（不要重复自己）的原则。除非一个类型在你的应用程序中真正独特，否则你应该尽可能重用代码。此外，还有集中化。
- en: If you need to make changes to any of the type code for `Person`, you just need
    to make the changes in `A` or `B`. This is also a bit limiting as there may be
    cases where type `A` is used by more than one object, and if you make changes,
    it will break the application. With intersection, you can simply create a type
    `C` with the changes and update your `Person` type. You can also merge types with
    common properties.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要修改`Person`类型的任何类型代码，你只需在`A`或`B`中做出更改即可。这也有一点限制，因为可能存在类型`A`被多个对象使用的情况，如果你做出更改，它将破坏应用程序。使用交集，你可以简单地创建一个带有更改的`C`类型，并更新你的`Person`类型。你还可以合并具有共同属性的类型。
- en: Consider a situation where you have a `name` property in `A` and also in `B`.
    When the types are intersected, you would now have just one `name` property; however,
    the merged properties must not only be the same in name, but should also be of
    the same type, otherwise the types will not merge and will result in errors.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，你有一个 `name` 属性在 `A` 中，也在 `B` 中。当类型相交时，你现在将只有一个 `name` 属性；然而，合并的属性不仅要在名称上相同，还应该是同一类型，否则类型将无法合并，并导致错误。
- en: If this is not clear, let's look at a property, `age`. This can be a number
    in one type and a string in another. The only way you could intersect these types
    would be to make the properties common, as either would need to be a string or
    number.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不清楚，让我们看看一个属性，`age`。这可以在一个类型中是数字，在另一个类型中是字符串。唯一能够相交这些类型的方法是使属性通用，因为它们都需要是字符串或数字。
- en: Imagine that as part of an e-commerce project, you are required to build a shopping
    cart object that derives its properties from a `Product` object and an `Order`
    object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，作为一个电子商务项目的一部分，你需要构建一个购物车对象，该对象从 `Product` 对象和 `Order` 对象中继承属性。
- en: 'The following diagram shows the basic properties of each object and the properties
    of the new `Cart` object that is formed using the `Product` and `Order` objects:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了每个对象的基本属性以及使用 `Product` 和 `Order` 对象形成的新 `Cart` 对象的属性：
- en: '![Figure 6.5: Diagram showing the properties of the Cart object'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5：显示购物车对象属性的图]'
- en: '](img/B14508_06_05.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_06_05.jpg](img/B14508_06_05.jpg)'
- en: 'Figure 6.5: Diagram showing the properties of the Cart object'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：显示购物车对象属性的图
- en: In the diagram, we have our parent objects, `Product` and `Order`, that combine
    to form a child object, `Cart`, with all the properties of its parent objects.
    Please note that we can have more than two parents in an intersection, but for
    the sake of this explanation, we will stick to two, as this will allow you to
    grasp the concept faster. In the upcoming example, we will walk through the process
    of creating our new `Cart` type in code and a basic use case.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们有父对象 `Product` 和 `Order`，它们组合形成一个具有其父对象所有属性的子对象 `Cart`。请注意，我们可以有超过两个父对象在交集中，但为了解释的方便，我们将坚持两个，这样你可以更快地掌握这个概念。在接下来的示例中，我们将通过代码创建我们的新
    `Cart` 类型，并展示一个基本的使用案例。
- en: 'Imagine you are working on the shopping application. You need to create an
    object to model the product data you will push to the cart for checking out. We
    already have a `Product` type for our product data. The `Product` type has most
    of what we need to display correct information pertaining to our products on the
    web page. However, we are missing a few things we require when checking a product
    out. We will address this not by creating a new type of product, but we will create
    an `Order` type with just the properties we need: `orderId`, `amount`, and `discount`,
    the last of which is optional as it will not always apply.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在开发购物应用程序。你需要创建一个对象来建模你将推送到购物车的产品数据。我们已经有了一个用于产品数据的 `Product` 类型。`Product`
    类型包含了我们在网页上显示产品正确信息所需的大部分内容。然而，我们在结账时缺少一些必需的属性。我们将通过不创建新的产品类型来解决这个问题，而是创建一个只包含我们需要的属性的
    `Order` 类型：`orderId`、`amount` 和 `discount`，其中 `discount` 是可选的，因为它并不总是适用。
- en: 'Here is the code for declaration of the `Product` type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是声明 `Product` 类型的代码：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code snippet, we have created our parent types names `Product`
    and `Order`. Now we need to merge them. This will create the type we need to model
    our cart data:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了父类型名称 `Product` 和 `Order`。现在我们需要将它们合并。这将创建我们需要的类型来建模购物车数据：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We build our cart object by assigning an alias, `Cart`, to our `Product` and
    `Order` types and using `&` between our two types, as shown in the preceding snippet.
    We now have a new merged type, `Cart`, that we can use to model our cart data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将别名 `Cart` 分配给我们的 `Product` 和 `Order` 类型，并在两个类型之间使用 `&`，如前面的代码片段所示来构建我们的购物车对象。我们现在有一个新的合并类型
    `Cart`，我们可以用它来建模购物车数据：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding is an example of a cart object declared using the `Cart` type.
    As you can see, we have access to all our properties and can omit optional ones
    that may not always apply, such as `discount`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了使用 `Cart` 类型声明的购物车对象。正如你所见，我们可以访问所有属性，并且可以省略那些可能不总是适用的可选属性，例如 `discount`。
- en: 'If we do not provide all the required properties, the IDE gives a very helpful
    error message telling us just what we need to do in order to fix the issue:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有提供所有必需的属性，IDE 会给出一个非常有用的错误信息，告诉我们如何修复问题：
- en: '![Figure 6.6: The error message displayed when missing required properties'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_06_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: The error message displayed when missing required properties'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s console out our new cart object: This will display the following
    output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the next section, you will get some hands-on experience in terms of creating
    intersection types by performing an exercise in which you will build a prototype
    user management system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Creating Intersection Types'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are working on an e-commerce application; you have been assigned the task
    of building out the user management system. In the application requirements, the
    customer has listed the types of user profiles they expect will interact with
    the system. You will use type intersection to build out your user types. This
    will allow you to build simple types that can be combined to make more complex
    types and separate your concerns. This will result in code that is less error-prone
    and better supported. Here, we name the user types we will build and provide an
    overview of their functions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`_id`, `email`, and `token`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accessPages` and `lastLogin`. `accessPages` is a string array of pages that
    this user can access, while `lastLogin` will help us to log the activates of the
    Admin user.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastBackUp` and `backUpLocation`. `lastBackUp` will let us know what time
    the system was last backed up, while `backUpLocation` will tell us where the backup
    files are stored.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**superUser**: This user is an intersection of the Admin and User types. All
    users require the properties of a Basic user, but only Admin users require Admin
    properties. Here, we use type intersection to build the necessary properties we need.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Backup` user and `Basic` user types. Once again, we can incorporate into our
    basic user the necessary complexity this user type requires in order to function.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/FVvj5](https://packt.link/FVvj5).'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open VS Code and create a new file named `Exercise03.ts`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a basic `User` type:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will be the type we will use as our base for the other user types in our
    application. Thus, it has all the common user properties that all users will require.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an `Admin` user type for users who need to perform the functions of
    an administrator:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a `Backup` user type for users who are responsible for backing up the
    application data:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using your `User` and `Admin` types, declare a `superuser` object of the `User`
    type at the `Admin` intersect. Add the required properties. In order to create
    a superuser, you will have to provide values for the properties of `User` and
    `Admin`, as shown in the following code block:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In an actual application, this code may be in a login function and the values
    returned might be from an API on login.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build a `BackUpUser` type by assigning the alias `BackUpUser` to the intersection
    of `User` and `Backup`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Declare a `backUpUser` object of the `BackUpUser` type and add the requisite properties:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Console out your `superUser` and `backupUser` objects:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出你的 `superUser` 和 `backupUser` 对象：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will print the following output:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding exercise, you built two user types using the `superUser` and
    `backupUser` intersections that are based on the `User`, `Admin`, and `Backup`
    types. The use of intersections allows you to keep your core user type simple
    and can therefore be used as a model for most of your user data. `Admin` and `Backup`
    are intersected with `User` only when it is necessary to model that specific user
    case. This is the separation of concerns. Now, any changes made to `User`, `Backup`,
    or `Admin` will be reflected in all child types. We will now take a look at union
    types, which is a type functionality. However, unlike intersections, union types
    provide an `OR` functionality when types are merged.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，你使用了基于 `User`、`Admin` 和 `Backup` 类型的 `superUser` 和 `backupUser` 交集来构建两个用户类型。使用交集允许你保持核心用户类型简单，因此可以用作大多数用户数据的模型。只有当需要建模特定用户情况时，`Admin`
    和 `Backup` 才与 `User` 交集。这是关注点的分离。现在，对 `User`、`Backup` 或 `Admin` 所做的任何更改都将反映在所有子类型中。现在，我们将探讨联合类型，这是一种类型功能。然而，与交集不同，当类型合并时，联合类型提供
    `OR` 功能。
- en: Union Types
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型
- en: '`or` type functionality instead of an `and` type functionality, which was the
    case with intersection types. This works in a similar way to the ternary operator
    in JavaScript, where the types you are combining are separated by the `|` pipe.
    If this is confusing, it will all become clear as we move on to an example. We
    will also take a look at type guards, which is a pattern that will play a major
    role in the app use of union types. First, consider the following visual representation
    of a union type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `or` 类型功能而不是 `and` 类型功能，这在交集类型中是常见的情况。这类似于 JavaScript 中的三元运算符，其中你正在组合的类型由
    `|` 管道分隔。如果这让你感到困惑，随着我们继续到示例，一切都会变得清晰。我们还将探讨类型守卫，这是一个在应用联合类型中将发挥重要作用的模式。首先，考虑以下联合类型的视觉表示：
- en: '![Figure 6.7: Illustration of a union type assignment'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7：联合类型赋值的说明'
- en: '](img/B14508_06_07.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_06_07.jpg]'
- en: 'Figure 6.7: Illustration of a union type assignment'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：联合类型赋值的说明
- en: In the preceding diagram, we have a basic diagram of a union type assignment,
    where `Age` can be of the `number` or `string` datatypes. You can have union types
    with more than two options and non-primitive types. This gives you the option
    to write code that is more dynamic. In the upcoming example, we will extend our
    age example as mentioned previously and build a basic union type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有一个联合类型赋值的基本图，其中 `Age` 可以是 `number` 或 `string` 数据类型。你可以有超过两个选项的联合类型和非原始类型。这为你提供了编写更动态代码的选项。在接下来的示例中，我们将扩展之前提到的年龄示例，并构建一个基本的联合类型。
- en: 'Let''s say you''re working on an application that needs to validate someone''s
    age. You want to write one function that will process ages from a database that
    are stored as a number and ages from the web frontend that come in as a string.
    In a case such as this, you might be tempted to use `any` as a type. However,
    unions allow us to address this kind of scenario without creating a vector for
    errors by using `any`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个需要验证某人年龄的应用程序。你想要编写一个函数，该函数将处理存储在数据库中作为数字的年龄和作为字符串从前端传入的年龄。在这种情况下，你可能会倾向于使用
    `any` 作为类型。然而，联合类型允许我们通过不使用 `any` 来创建错误向量来处理这种场景：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, we create a union type, `Age`, which can be of the `number` or `string`
    datatypes, as shown in the preceding syntax. We assign our `Age` alias to our
    types separated by a pipe, `|`. We could have more than two options, for example,
    `"number" | "string" | "object"`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个联合类型 `Age`，它可以具有 `number` 或 `string` 数据类型，如前面的语法所示。我们将我们的 `Age` 别名分配给由管道
    `|` 分隔的类型。我们可以有超过两个选项，例如 `"number" | "string" | "object"`：
- en: 'Now we create a function that will make use of the new type, `Age`, as shown
    in the preceding snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个函数，它将使用前面代码片段中所示的新类型 `Age`：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `myAge` function takes the `Age` type as an argument and returns a formatted
    string of the `Age` type using an `if …else` loop. We are also making use of a
    type guard pattern, `typeof`, which allows you to check the type of your argument.
    This kind of type checking is necessary while using union types as your argument
    can be of several types, which, in the case of this preceding code snippet, is
    a string or a number. Each type will need to be processed with a different logic.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`myAge` 函数接受 `Age` 类型作为参数，并使用 `if …else` 循环返回一个格式化的 `Age` 类型字符串。我们还在使用类型守卫模式，`typeof`，它允许你检查你的参数类型。这种类型检查在使用联合类型作为参数时是必要的，因为你的参数可以是几种类型之一，在这个前面的代码片段中，是字符串或数字。每种类型都需要用不同的逻辑进行处理。'
- en: Union types can also be objects; however, in such a case, `typeof` will not
    be very useful as it will only return the type, which will always be `object`.
    To resolve such cases, you can check for any unique properties of your object
    and apply your logic in this way. We will see examples of this as we work through
    our exercise in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型也可以是对象；然而，在这种情况下，`typeof` 将不会非常有用，因为它只会返回类型，而这个类型始终是 `object`。为了解决这类情况，你可以检查你的对象是否有任何独特的属性，并以此方式应用你的逻辑。随着我们在下一节中完成练习，我们将看到这方面的示例。
- en: 'Now, let''s get back to the example. To ensure that our functions are working
    as they should, we console out the results by calling them with different argument
    types (number and string):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到示例。为了确保我们的函数按预期工作，我们通过调用它们并使用不同的参数类型（数字和字符串）来控制台输出结果：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will result in the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s say that you passed an incorrect argument instead:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你传递了一个错误的参数：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will see the following error message:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下错误信息：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Exercise 6.04: Updating the Products Inventory using an API'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.04：使用 API 更新产品库存
- en: In the following exercise, we will extend our inventory management example from
    *Exercise 03* by adding an API. This will allow remote users to add and update
    products in our inventory via an API `PUT` or `POST` request.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将通过添加 API 扩展我们的库存管理示例 *Exercise 03*。这将允许远程用户通过 API `PUT` 或 `POST` 请求添加和更新我们的库存。
- en: Since the processes of updating and adding a product are so similar, we will
    write one method to handle both requests and use a union type to allow our method
    to take both types and remain type safe. This will also mean that we can write
    less code and encapsulate all related code to the one method, which will make
    it easy for us or any other developer working on the application to find and resolve
    errors.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更新和添加产品的过程非常相似，我们将编写一个方法来处理这两个请求，并使用联合类型允许我们的方法接受这两种类型并保持类型安全。这也意味着我们可以编写更少的代码，并将所有相关代码封装到一个方法中，这将使我们或任何其他正在开发应用程序的开发者更容易找到和解决错误。
- en: 'You could use the `any` type, but then your code would become type insecure,
    which could lead to bugs and unstable code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `any` 类型，但这样你的代码就会变得类型不安全，这可能导致错误和不稳定的代码：
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/Qvx6D](https://packt.link/Qvx6D).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下位置找到：[https://packt.link/Qvx6D](https://packt.link/Qvx6D)。
- en: Open VS Code and create a new file named `Exercise04.ts`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code 并创建一个名为 `Exercise04.ts` 的新文件。
- en: 'Create three types, `Product`, `Post`, and `Put`, along with the base objects
    you will require, as shown here:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个类型，`Product`、`Post` 和 `Put`，以及你将需要的基对象，如下所示：
- en: '[PRE42]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We first create a product type that will help us to define what format the product
    data will take as part of a `Put` or `Post` request. We have also defined `Put`
    and `Post`, which differ slightly because a `Put` request will need to update
    a record that already exists. Note that `Put` has the property `productId`.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先创建一个产品类型，这将帮助我们定义在 `Put` 或 `Post` 请求中产品数据将采取的格式。我们还定义了 `Put` 和 `Post`，它们略有不同，因为
    `Put` 请求需要更新已存在的记录。请注意，`Put` 有 `productId` 属性。
- en: 'Create a union type, `SomeRequest`, which can be either the `Put` or `Post`
    type:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个联合类型 `SomeRequest`，它可以是要么 `Put` 类型，要么 `Post` 类型：
- en: '[PRE43]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The data being matched to the union type can be any of the types in the union.
    Note that unions do not combine types; they simply try to match the data to one
    of the types in the union, which gives you, the developer, more flexibility.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与联合类型匹配的数据可以是联合中的任何类型。请注意，联合类型并不组合类型；它们只是尝试将数据匹配到联合中的某个类型，这为你，开发者，提供了更多的灵活性。
- en: 'Create an instance of an array of the `Product` type:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Product` 类型的数组实例：
- en: '[PRE44]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Build a handler function that processes a request of the `SomeRequest` type:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个处理函数，该函数处理`SomeRequest`类型的请求：
- en: '[PRE45]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This function will receive a request of the `Put` or `Post` type and add or
    update an attached product to the `products` array. In order to know whether it
    should update or add the function, it first checks whether the product has a `productId`
    argument. If it does, we will loop through the `Products` array until we find
    a matching `productId` argument. Then, we use the spread operator to update the
    product data with the data from the request. If the product does not have a `productId`
    argument, we then just use the `push` function attached to the array to add the
    new product to the array.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数将接收`Put`或`Post`类型的请求，并将附加的产品添加或更新到`products`数组中。为了知道它应该更新还是添加，它首先检查产品是否有`productId`参数。如果有，我们将遍历`Products`数组，直到找到匹配的`productId`参数。然后，我们使用扩展运算符使用请求中的数据更新产品数据。如果产品没有`productId`参数，我们则只需使用数组附加的`push`函数将新产品添加到数组中。
- en: 'Declare `apple` and `mango` objects of the `Product` type, as shown here:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`apple`和`mango`对象为`Product`类型，如下所示：
- en: '[PRE46]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In a real API, the data would be provided by the user sending it via a request,
    but for the purposes of this exercise, we have hardcoded some data for you to
    work with.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在真实的API中，数据将由用户通过请求发送提供，但为了本练习的目的，我们为您硬编码了一些数据来操作。
- en: 'Declare `postAppleRequest` and `putMangoRequest` objects of the `Post` and
    `Put` types:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`postAppleRequest`和`putMangoRequest`对象为`Post`和`Put`类型：
- en: '[PRE47]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code, we have defined our `POST` and `PUT` objects. We have
    attached the product object as a payload of the request. Remember that the function
    is not checking the product object but the request type, which will tell the function
    whether it's `POST` or `PUT`.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已定义我们的`POST`和`PUT`对象。我们将产品对象作为请求的有效负载附加。请记住，函数不是检查产品对象，而是检查请求类型，这将告诉函数它是`POST`还是`PUT`。
- en: 'Call the handler function and pass `postAppleRequest` and `putMangoRequest`
    as arguments, as shown in the following code snippet:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用处理函数，并传递`postAppleRequest`和`putMangoRequest`作为参数，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In a normal API, when the user makes a `PUT` or `POST` request, the `ProcessRequest`
    method would be called. We are, however, just simulating an API and making the
    calls ourselves.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在正常的API中，当用户发起`PUT`或`POST`请求时，会调用`ProcessRequest`方法。然而，我们只是在模拟API并自行进行调用。
- en: 'Console out the results:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出控制台结果：
- en: '[PRE49]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You will see the following output:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE50]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding output, we can now see the products that we passed to our methods.
    This means that our simulated API code using unions works as intended.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们现在可以看到传递给我们的方法的产品。这意味着我们使用联合类型编写的模拟API代码按预期工作。
- en: Union types, such as intersection types, give you, the developer, more functionality
    and flexibility when building your applications. In the preceding exercise, we
    were able to write a function that takes a single argument of two different types
    and applies logic based on type checking patterns or type guards. In the next
    section, we will continue the theme of more code flexibility with index types.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型，例如交集类型，在构建应用程序时为开发者提供了更多的功能性和灵活性。在前面的练习中，我们能够编写一个函数，该函数接受两种不同类型的单个参数，并根据类型检查模式或类型守卫应用逻辑。在下一节中，我们将继续探讨更多代码灵活性的主题，即索引类型。
- en: Index Types
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引类型
- en: 'Index types allow us to create objects that have flexibility as regards the
    number of properties they may hold. Let''s say you have a type that defines an
    error message, which can be more than one type, and you want the flexibility to
    add more types of messages over time. Because objects have a fixed number of properties,
    we would need to make changes to our message code whenever there was a new message
    type. Index types allow you to define a signature for your type using an interface,
    which gives you the ability to have a flexible number of properties. In the following
    example, we will expand on this in the code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 索引类型允许我们创建具有关于它们可能持有的属性数量灵活性的对象。假设您有一个定义错误消息的类型，该消息可以超过一个类型，并且您希望随着时间的推移添加更多类型的消息的灵活性。由于对象具有固定数量的属性，因此每当有新的消息类型时，我们都需要修改我们的消息代码。索引类型允许您使用接口定义您的类型签名，这为您提供了具有灵活数量的属性的能力。在下面的示例中，我们将在代码中扩展这一点：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, we create our type signature, as shown in the preceding snippet. Here
    we have a property name and type, which is the index `[msg: number]` followed
    by the value type. The name of the `msg` argument can be anything, but as a good
    coder, you should provide a name that makes sense in the context of the type.
    Note that your index can only be a number, string, or symbol.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们创建我们的类型签名，如前文代码片段所示。这里有一个属性名和类型，即索引 `[msg: number]` 后跟值类型。`msg` 参数的名称可以是任何名称，但作为一个优秀的程序员，你应该提供一个在类型上下文中有意义的名称。请注意，你的索引只能是一个数字、字符串或符号。'
- en: 'You can also add other properties to your index, but they must be the same
    type as the index, as shown in the preceding code snippet, `apiId: number`. Next,
    we make use of your type by casting it to `errorMessage`. We can now have an error
    message object with as many properties as we require. There is no need to modify
    the type as our list of messages grows. We maintain flexibility while keeping
    our code typed, thereby making it easy to scale and support:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以向你的索引添加其他属性，但它们必须与索引具有相同的类型，如前文代码片段所示，`apiId: number`。接下来，我们通过类型转换使用你的类型，现在我们可以拥有一个具有所需属性数量的错误信息对象。随着消息列表的增长，我们不需要修改类型。我们保持灵活性，同时保持代码的类型化，这使得代码易于扩展和支持：'
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we console out the new object just to make sure that everything works:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们控制台输出新对象，以确保一切正常：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You will get the following output once you run the file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件后，你将得到以下输出：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we try to give a property name of an incorrect type, such as a string, we
    get the kind of error message you might expect:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试给一个属性名赋予错误类型，例如字符串，我们会得到你可能期望的错误信息：
- en: '![Figure 6.8: Output displaying the type error'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8：显示类型错误的输出'
- en: '](img/B14508_06_08.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_06_08.jpg)'
- en: 'Figure 6.8: Output displaying the type error'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：显示类型错误的输出
- en: 'You can, however, use strings that are numbers, for example, and the code will
    function as before and the output will be the same:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用数字字符串，例如，代码将像以前一样运行，输出也将相同：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You may think that this will not work given that the value is a string, but
    it gets converted to a number literal. It will also work the other way around
    using a number literal that gets converted to a string. Next in our exercise,
    we will simulate the real-world usage of an index type, building a simple system
    to process error messages.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这不会工作，因为值是字符串，但它会被转换为数字字面量。使用数字字面量转换为字符串的方式也可以工作。接下来在我们的练习中，我们将模拟索引类型的实际应用，构建一个简单的系统来处理错误信息。
- en: 'Exercise 6.05: Displaying Error Messages'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.05：显示错误信息
- en: 'In this exercise, we will build a system to process error messages. We will
    also reuse the `ErrorMessage` index type we created in our example. The code in
    this exercise is somewhat contrived but will serve to help you get a better understanding
    of index types:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建一个系统来处理错误信息。我们还将重用我们在示例中创建的 `ErrorMessage` 索引类型。这个练习中的代码有些人为设计，但将有助于你更好地理解索引类型：
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/ZkApY](https://packt.link/ZkApY).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下位置找到：[https://packt.link/ZkApY](https://packt.link/ZkApY)。
- en: Open VS Code and create a new file named `Exercise05.ts`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code 并创建一个名为 `Exercise05.ts` 的新文件。
- en: 'Create the `ErrorMessage` type interface from our example if you have not already
    done so:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有创建，请从我们的示例中创建 `ErrorMessage` 类型接口：
- en: '[PRE56]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Build an `errorCodes` object as an `ErrorMessage` type, as shown here:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下示例，构建一个 `errorCodes` 对象，其类型为 `ErrorMessage`：
- en: '[PRE57]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create an error code array as `errorCodes`, as shown here:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下示例创建一个错误代码数组 `errorCodes`：
- en: '[PRE58]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Loop through the `errorCodes` array and console out the error messages:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `errorCodes` 数组并在控制台输出错误信息：
- en: '[PRE59]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Once you run the file, you will obtain the following output:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行文件后，你将获得以下输出：
- en: '[PRE60]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Index types allow you to have flexibility with your type definitions, as you
    can see in the preceding exercise. If you need to add new codes, you will not
    need to change your type definition; simply add the new code property to your
    `errorCode` object. Index types work here because even though the properties for
    the object are different, they all have the same basic makeup – a number property
    (key) followed by a string value.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 索引类型允许你在类型定义中具有灵活性，如前文练习所示。如果你需要添加新的代码，你不需要更改你的类型定义；只需将新的代码属性添加到你的 `errorCode`
    对象中。索引类型在这里之所以有效，是因为尽管对象的属性不同，但它们都具有相同的基本结构——一个数字属性（键）后跟一个字符串值。
- en: Now that you have the building blocks for advanced types, you can work through
    the following activities. The activities will make use of all the skills you have
    acquired in this chapter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了高级类型的构建块，你可以完成以下活动。这些活动将利用你在本章中学到的所有技能。
- en: 'Activity 6.01: Intersection Type'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.01：交集类型
- en: Imagine that you are a developer working on a truck builder feature for a custom
    truck website. You will need to make it possible for customers that come to the
    site to build a variety of truck types. To that end, you need to build your own
    intersection type, `PickUptruck`, by combining two types, `Motor` and `Truck`.
    You can then use your new type, `PickUpTruck`, with a function that returns the
    type and validates its input with the `PickUpTruck` intersection type.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你是一名正在为定制卡车网站开发卡车构建功能的开发者。你需要让来到网站的客户能够构建各种卡车类型。为此，你需要通过组合两个类型`Motor`和`Truck`来构建自己的交集类型`PickUptruck`。然后你可以使用你的新类型`PickUpTruck`，该函数返回类型并使用`PickUpTruck`交集类型验证其输入。
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this activity can be found here: [https://packt.link/n4tfL](https://packt.link/n4tfL).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在此处找到：[https://packt.link/n4tfL](https://packt.link/n4tfL)。
- en: 'Here are some steps that will help you to complete this activity:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些帮助你完成此活动的步骤：
- en: 'Create a `Motor` type, which will house some common properties you may reuse
    on their own or in combination with other types to describe a vehicle object.
    You can use the following properties as a starting point: `color`, `doors`, `wheels`,
    and `fourWheelDrive`.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Motor`类型，它将包含一些你可能单独或与其他类型组合使用的通用属性，用于描述车辆对象。你可以使用以下属性作为起点：`颜色`、`车门`、`车轮`和`四驱`。
- en: Create a `Truck` type with properties common to a truck, for example, `doubleCab`
    and `winch`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有卡车通用属性的`Truck`类型，例如`双排座`和`绞盘`。
- en: Intersect the two types to create a `PickUpTruck` type.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个类型相交以创建一个`PickUpTruck`类型。
- en: Build a `TruckBuilder` function that returns our `PickUpTruck` type and also
    takes `PickUpTruck` as an argument.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个返回我们的`PickUpTruck`类型并接受`PickUpTruck`作为参数的`TruckBuilder`函数。
- en: Console out the function return.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出函数返回值。
- en: 'Once you complete the activity, you should obtain the following output:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成活动，你应该获得以下输出：
- en: '[PRE61]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity is presented via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor409).
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor409)提供。
- en: 'Activity 6.02: Union Type'
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.02：联合类型
- en: A logistics company has asked you to develop a feature on their website that
    will allow customers to choose the way they would like their packages to be shipped
    – via land or air. You have decided to use union types to achieve this. You can
    build your own union type called `ComboPack`, which can be either the `LandPack`
    or `AirPack` type. You can add any properties to your package types that you think
    will be common to a package. Also, consider using one type literal to identify
    your package as air or land, and a label property that will be optional. You will
    then need to construct a class to process your packages. Your class should have
    a method to identify your package type that takes arguments of the `ComboPack`
    type and uses your literal property to identify the package type and add the correct
    label, `air cargo` or `land cargo`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一家物流公司要求你在他们的网站上开发一个功能，允许客户选择他们希望包裹如何运输的方式——通过陆路或空运。你决定使用联合类型来实现这一点。你可以创建自己的联合类型，称为`ComboPack`，它可以是指`LandPack`或`AirPack`类型。你可以为你的包裹类型添加你认为将通用的任何属性。同时，考虑使用一个类型字面量来识别你的包裹是空运还是陆运，以及一个可选的标签属性。然后你需要构建一个类来处理你的包裹。你的类应该有一个方法来识别你的包裹类型，该方法接受`ComboPack`类型的参数，并使用你的字面量属性来识别包裹类型并添加正确的标签，`空运货物`或`陆运货物`。
- en: Note
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this activity can be found here: [https://packt.link/GQ2ZS](https://packt.link/GQ2ZS).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在此处找到：[https://packt.link/GQ2ZS](https://packt.link/GQ2ZS)。
- en: 'Here are some steps that will help you to complete this activity:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些帮助你完成此活动的步骤：
- en: Build a `LandPack` and an `AirPack` type. Make sure to have a literal to identify
    the package type.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`LandPack`和`AirPack`类型。确保有一个字面量来识别包裹类型。
- en: Construct a union type, `ComboPack`, which can be `LandPack` or `AirPack`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个联合类型`ComboPack`，可以是`LandPack`或`AirPack`。
- en: Make a `Shipping` class to process your packages. Make sure to use your literal
    to identify your package types and modify your package with the correct label
    for its type.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Shipping`类来处理你的包裹。确保使用你的字面量来识别你的包裹类型，并使用正确的标签修改你的包裹。
- en: Create two package objects of the `AirPack` and `LandPack` types.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个`AirPack`和`LandPack`类型的包裹对象。
- en: Instantiate your `Shipping` class, process your new objects, and console out
    the modified objects.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化你的`Shipping`类，处理你的新对象，并在控制台输出修改后的对象。
- en: Note
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity is presented via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor411).
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor411)展示。
- en: 'Activity 6.03: Index Type'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.03：索引类型
- en: Now that you have done such a good job of incorporating the shipping option
    into the website, the company now needs you to add a feature that will allow their
    customers to track the status of their packages. It is important to the client
    that they have the ability to add new package statuses as the company grows, and
    as shipping methods change, they would like that flexibility.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经很好地将运输选项整合到网站中，公司现在需要你添加一个功能，允许他们的客户跟踪其包裹的状态。对于客户来说，他们有权限随着公司的发展以及运输方式的变化添加新的包裹状态非常重要，他们希望有这种灵活性。
- en: 'Hence, you have decided to build an index type, `PackageStatus`, using an interface
    signature of the `status` property of the `string` type and a value of the `Boolean`
    type. You will then construct a `Package` type with some common package properties.
    You will also include a `packageStatus` property of the `PackageStatus` type.
    You will use `PackageStatus` to track three statuses of your package: `shipped`,
    `packed`, and `delivered`, set to `true` or `false`. You will then construct a
    class that takes an object of the `Package` type on initialization, contains a
    method that returns the `status` property, and a method that updates the `status`
    property, which takes `status` as a string and `Boolean` as a state.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你决定构建一个索引类型，`PackageStatus`，使用`status`属性的接口签名，其类型为`string`，值为`Boolean`类型。然后，你将构建一个包含一些常见包裹属性的`Package`类型。你还将包括一个`packageStatus`属性，其类型为`PackageStatus`。你将使用`PackageStatus`来跟踪你的包裹的三个状态：`shipped`、`packed`和`delivered`，设置为`true`或`false`。然后，你将构建一个类，该类在初始化时接受`Package`类型的对象，包含一个返回`status`属性的方法，以及一个更新并返回`status`属性的方法，该方法接受`status`作为字符串和`Boolean`作为状态。
- en: The method that updates your package should also return your `packageStatus` property.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的包的方法也应该返回你的`packageStatus`属性。
- en: Note
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this activity can be found here: [https://packt.link/2LwHq](https://packt.link/2LwHq).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在此处找到：[https://packt.link/2LwHq](https://packt.link/2LwHq)。
- en: 'Here are some steps that will help you to complete this activity:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些帮助你完成此活动的步骤：
- en: Build your `PackageStatus` index type using an interface with a property of
    `status` of the `string` type and a value of the `Boolean` type.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用具有`status`属性为`string`类型和`Boolean`类型值的接口，构建你的`PackageStatus`索引类型。
- en: Create a `Package` type that includes a property of the `PackageStatus` type
    and some common properties of a typical package.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`PackageStatus`类型属性和一些典型包裹常见属性的`Package`类型。
- en: Make a class to process your `Package` type that takes the `Package` type on
    initialization, has a method to return your `packageStatus` property, and a method
    that updates and returns the `packageStatus` property.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类来处理你的`Package`类型，该类在初始化时接受`Package`类型，有一个方法返回你的`packageStatus`属性，以及一个更新并返回`packageStatus`属性的方法。
- en: Create a `Package` object called `pack`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pack`的`Package`对象。
- en: Instantiate your `PackageProcess` class with your new `pack` object.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的新`pack`对象实例化`PackageProcess`类。
- en: Console out your `pack` status.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出你的`pack`状态。
- en: Update your `pack` status and console out your new `pack` status.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`pack`状态，并在控制台输出你的新`pack`状态。
- en: 'The expected output is as follows:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE62]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor413).
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor413)找到。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered advanced types, which allow you to extend beyond
    your basic types. As applications become more complex and the frontend takes on
    more functionality, your data models will also become more complex. This chapter
    showed you how TypeScript advanced types give you the ability to implement strong
    typing, which will help you develop cleaner and more reliable applications. We
    covered the building blocks of advanced types – type aliases and literals, and
    we then moved on to intersection, union, and index types with some practical examples,
    exercises, and activities.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了高级类型，这些类型允许您超越基本类型。随着应用变得更加复杂，前端承担更多功能，您的数据模型也将变得更加复杂。本章向您展示了 TypeScript
    高级类型如何让您能够实现强类型，这将帮助您开发更干净、更可靠的应用程序。我们涵盖了高级类型的构建块——类型别名和字面量，然后通过一些实际示例、练习和活动，我们继续探讨了交集、联合和索引类型。
- en: You now have the ability to create complex types that will allow you to build
    types for modern applications and write code that is well supported and scalable.
    Having reached this point, you now have the tools to take on web frameworks, such as
    Angular2 and React. You can even use TypeScript on the server side with Node.js.
    There is much more to advanced types and the topic is quite vast, complex, and
    abstract in its implementations. However, here in this chapter, you have been
    equipped with the skills you need to start building applications with advanced
    types.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在拥有了创建复杂类型的能力，这将使您能够构建适用于现代应用的类型，并编写得到良好支持和可扩展的代码。达到这一点后，您现在拥有了应对像 Angular2
    和 React 这样的 Web 框架的工具。您甚至可以在 Node.js 服务器端使用 TypeScript。高级类型还有很多内容，这个主题在实现上相当广泛、复杂和抽象。然而，在本章中，您已经获得了开始使用高级类型构建应用程序所需的所有技能。
