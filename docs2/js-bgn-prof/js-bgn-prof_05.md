# 5

# 循环

我们开始对 JavaScript 有一个很好的基本掌握。本章将重点介绍一个非常重要的控制流概念：循环。循环执行代码块一定次数。我们可以使用循环做很多事情，例如重复操作多次以及遍历数据集、数组和对象。每次当你觉得需要复制一小段代码并将其放置在复制的下方时，你可能应该使用循环。

我们将首先讨论循环的基础知识，然后继续讨论嵌套循环，这基本上是在循环内部使用循环。此外，我们还将解释如何遍历我们已看到的两个复杂结构，数组和对象。最后，我们将介绍与循环相关的两个关键字，`break`和`continue`，以进一步控制循环的流程。

有一个与循环密切相关的话题，但不在本章中。这是内置的`foreach`方法。当我们可以使用箭头函数时，我们可以使用此方法遍历数组。由于我们将在下一章讨论这些内容，因此`foreach`不包括在内。

本章我们将讨论以下不同的循环：

+   `while`循环

+   `do` `while`循环

+   `for`循环

+   `for` `in`

+   `for of`循环

注意：练习、项目和自我检查测验的答案可以在*附录*中找到。

# `while`循环

```js
while loop:
```

```js
while (condition) {
  // code that gets executed as long as the condition is true
} 
```

`while`循环只有在条件为`true`时才会执行，所以如果一开始条件就是`false`，则代码内部将被跳过。

这里有一个非常简单的`while`循环示例，将数字 0 到 10（不包括 10）打印到控制台：

```js
let i = 0;
while (i < 10) {
  console.log(i);
  i++;
} 
```

输出将如下所示：

```js
1
2
3
4
5
6
7
8
9 
```

这里发生以下步骤：

1.  创建一个变量`i`并将其值设置为 0

1.  开始`while`循环并检查`i`的值是否小于 10 的条件

1.  由于条件为真，代码记录了`i`并增加`i`的值 1

1.  条件再次被评估；1 仍然小于 10

1.  由于条件为真，代码记录了`i`并增加`i`的值 1

1.  记录和增加会持续到`i`变为 10

1.  10 不小于 10，所以循环结束

我们可以有一个`while`循环来在数组中查找值，如下所示：

```js
let someArray = ["Mike", "Antal", "Marc", "Emir", "Louiza", "Jacky"];
let notFound = true;
while (notFound && someArray.length > 0) {
  if (someArray[0] === "Louiza") {
    console.log("Found her!");
    notFound = false;
  } else {
    someArray.shift();
  }
} 
```

它检查数组的第一个值是否是某个特定的值，如果不是，它将使用`shift`方法从数组中删除该值。你还记得这个方法吗？它移除数组的第一个元素。所以，在下一次迭代中，第一个值已经改变并再次进行检查。如果它偶然发现该值，它将记录到控制台并将布尔值`notFound`更改为`false`，因为它已经找到了它。那将是最后一次迭代，循环结束。它将输出：

```js
Found her!
false 
```

你为什么认为在`while`条件中添加了`&& someArray.length > 0`？如果我们省略它，并且我们正在寻找的值不在数组中，我们就会陷入无限循环。这就是为什么我们确保如果我们的值不存在，我们也会结束，这样我们的代码就可以继续。

但我们也可以很容易地使用循环做更复杂的事情。让我们看看使用循环填充斐波那契数列到数组有多容易：

```js
let nr1 = 0;
let nr2 = 1;
let temp;
fibonacciArray = [];
while (fibonacciArray.length < 25) {
  fibonacciArray.push(nr1);
  temp = nr1 + nr2;
  nr1 = nr2;
  nr2 = temp;  
} 
```

在斐波那契数列中，每个值都是前两个值的和，从 0 和 1 开始。我们可以像上面所述的那样使用 while 循环来做这件事。我们创建两个数字，它们在每次迭代中都会改变。我们限制了迭代的次数，使其等于`fibonacciArray`的长度，因为我们不希望出现无限循环。在这种情况下，循环将在数组的长度不再小于 25 时结束。

我们需要一个临时变量来存储`nr2`的下一个值。在每次迭代中，我们将第一个数字的值推送到数组中。如果你记录数组，你会看到数字会非常快地变得相当高。想象一下，你需要在代码中逐个生成这些值！

```js
[
     0,     1,     1,     2,     3,
     5,     8,    13,    21,    34,
    55,    89,   144,   233,   377,
   610,   987,  1597,  2584,  4181,
  6765, 10946, 17711, 28657, 46368
] 
```

## 练习 5.1

在这个练习中，我们将创建一个数字猜谜游戏，该游戏根据用户的猜测准确性进行回复。

1.  创建一个变量作为数字猜谜游戏的最大值。

1.  使用`Math.random()`和`Math.floor()`生成一个随机数作为解。你还需要添加 1，以便返回的值是 1-[设置的任何最大值]。你可以将此值记录到控制台以供开发查看，当游戏完成时，你可以取消注释此控制台输出。

1.  创建一个变量用于跟踪答案是否正确，并将其设置为默认的布尔值`false`。如果用户的猜测匹配，我们可以将其更新为`true`。

1.  使用 while 循环迭代一个提示，要求用户输入一个介于 1 和 5 之间的数字，并将响应转换为数字，以匹配随机数的数据类型。

1.  在 while 循环内部，使用条件检查提示值是否等于解的数字。应用逻辑，如果数字正确，将状态设置为`true`并退出循环。向玩家提供一些反馈，说明猜测是高还是低，并启动另一个提示，直到用户猜正确为止。这样我们使用循环不断提问，直到解正确，然后我们可以停止代码块的迭代。

# do while 循环

在某些情况下，你确实需要至少执行一次代码块。例如，如果你需要有效的用户输入，你需要至少询问一次。同样，尝试连接数据库或其他外部源也是如此：你必须至少尝试一次才能成功。而且你可能需要一直这样做，直到你得到所需的结果。在这些情况下，你可以使用**do while 循环**。

以下是语法示例：

```js
do {
  // code to be executed if the condition is true
} while (condition); 
```

它执行`do`块内的内容，然后执行`while`。如果条件为`true`，它将再次执行`do`块内的内容。它将继续这样做，直到`while`中的条件变为`false`。

我们可以使用`prompt()`方法获取用户输入。让我们使用`do while`循环来要求用户输入一个介于 0 和 100 之间的数字。

```js
let number;
do {
  number = prompt("Please enter a number between 0 and 100: ");
} while (!(number >= 0 && number < 100)); 
```

这是输出；您将需要在这里自己输入控制台中的数字。

```js
Please enter a number between 0 and 100: > -50
Please enter a number between 0 and 100: > 150
Please enter a number between 0 and 100: > 34 
```

`>`后面的所有内容都是用户输入。`>`是代码的一部分；它是控制台添加的，以使控制台输出（`请输入一个介于 0 和 100 之间的数字`）和控制台输入（`-50`、`150`和`34`）之间的区别更清晰。

它询问三次，因为前两次数字不在 0 到 100 之间，`while`块中的条件为真。当输入`34`时，`while`块中的条件变为假，循环结束。

## 练习 5.2

在这个练习中，我们将创建一个基本的计数器，它将通过一个一致的步长值增加动态变量，直到上限。

1.  将起始计数器设置为 0

1.  创建一个变量，`step`，用于增加计数器

1.  添加一个`do while`循环，将计数器打印到控制台，并在每次循环中增加`step`的值

1.  继续循环，直到计数器等于 100 或超过 100

# `for`循环

**`for`循环**是特殊的循环。语法可能一开始有点令人困惑，但您很快就会发现自己会使用它们，因为它们非常有用。

这是语法看起来像什么：

```js
for (initialize variable; condition; statement) { 
  // code to be executed
} 
```

在`for`语句后面的括号中，有三个部分，由分号分隔。第一个部分初始化可以在`for`循环中使用的变量。第二个部分是一个条件：只要这个条件为真，循环就会继续迭代。这个条件在第一次迭代之前检查变量初始化（这只会发生在条件评估为真时）。最后一个部分是一个语句。这个语句在每次迭代后执行。以下是`for`循环的流程：

1.  初始化变量。

1.  检查条件。

1.  如果条件为真，则执行代码块。如果条件为假，循环将在这里结束。

1.  执行语句（例如，第三部分`i++`）。

1.  返回到步骤 2。

这是一个简单的示例，将数字 0 到 10（不包括 10）记录到控制台：

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
} 
```

它首先创建一个变量`i`，并将其设置为`0`。然后它检查`i`是否小于 10。如果是，它将执行日志语句。之后，它将执行`i++`并增加`i`的值。

如果我们不增加`i`，我们将陷入无限循环，因为`i`的值将不会改变，并且将永远小于 10。这是在所有循环中需要注意的事情！

条件再次被检查。然后继续，直到`i`达到 10 的值。10 不小于 10，所以循环完成执行，数字 0 到 9 已经记录到控制台。

我们也可以使用`for`循环创建一个序列并将值添加到数组中，如下所示：

```js
let arr = [];
for (let i = 0; i < 100; i++) {
  arr.push(i);
} 
```

这是循环之后的数组看起来像什么：

```js
[
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
  12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
  24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
  36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
  72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
  84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
  96, 97, 98, 99
] 
```

由于循环运行了 100 次代码块，从`i`的初始值 0 开始，代码块将在数组的末尾添加递增的值。这导致一个计数为 0–99 且长度为 100 项的数组。由于数组从索引值 0 开始，数组中的值实际上与数组中项的索引值相匹配。

或者我们可以创建一个只包含偶数值的数组：

```js
let arr = [];
for (let i = 0; i < 100; i = i + 2) {
  arr.push(i);
} 
```

结果是这个数组：

```js
[
   0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20,
  22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
  44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64,
  66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
  88, 90, 92, 94, 96, 98
] 
```

最常见的是，你会看到`i++`作为`for`循环的第三部分，但请注意，你可以在那里写任何语句。在这种情况下，我们使用`i = i + 2`来每次将 2 加到前一个值上，创建一个只包含偶数的数组。

## 练习 5.3

在这个练习中，我们将使用`for`循环创建一个包含对象的数组。从创建一个空数组开始，循环内的代码块将创建一个被插入到数组中的对象。

1.  设置一个空数组，`myWork`。

1.  使用`for`循环创建一个包含 10 个对象的列表，每个对象都是一个编号的课程（例如，课程 1、课程 2、课程 3……），每个其他项目交替`true`/`false`状态以指示该课程是否将在今年运行。例如：

    ```js
    name: 'Lesson 1', status: true 
    ```

1.  你可以通过使用三元运算符来指定状态，该运算符检查给定课程值的模是否等于零，并设置一个布尔值以在每个迭代中交替值。

1.  使用一个临时对象变量创建一个课程，包含名称（`lesson`带有数值）和预定义的状态（我们在上一步中设置）。

1.  将对象推送到`myWork`数组。

1.  将数组输出到控制台。

# 嵌套循环

有时候在循环内部使用循环可能是必要的。循环内部的循环被称为嵌套循环。通常，这并不是解决问题的最佳方案。它甚至可能是代码编写不佳的迹象（在程序员中有时被称为“代码异味”），但偶尔它是一个完美的解决方案。

这里是`while`循环的示例：

```js
while (condition 1) {
  // code that gets executed as long as condition 1 is true
  // this loop depends on condition 1 being true
    while (condition 2) {
      // code that gets executed as long as condition 2 is true
    }
} 
```

嵌套也可以与`for`循环一起使用，或者与`for`和`while`的组合一起使用，甚至可以与所有类型的循环一起使用；它们可以深入几个层级。

我们可能使用嵌套循环的一个例子是当我们想要创建一个数组数组。在外部循环中，我们创建顶层数组，在内部循环中，我们向数组添加值。

```js
let arrOfArrays = [];
for (let i = 0; i < 3; i++){
  arrOfArrays.push([]);
  for (let j = 0; j < 7; j++) {
    arrOfArrays[i].push(j);
  }
} 
```

当我们这样记录这个数组时：

```js
console.log(arrOfArrays); 
```

我们可以看到输出是一个包含从`0`到`6`的值的数组。

```js
[
  [
    0, 1, 2, 3, 4, 5, 6
  ],
  [
    0, 1, 2, 3, 4, 5, 6
  ],
  [
    0, 1, 2, 3, 4, 5, 6
  ]
] 
```

我们使用了嵌套循环来创建一个数组中的数组，这意味着在创建了这个循环之后，我们可以处理行和列。这意味着嵌套循环可以用来创建表格数据。我们可以使用`console.table()`方法将此输出显示为表格，如下所示：

```js
console.table(arrOfArrays); 
```

这将输出：

```js
┌─────────┬───┬───┬───┬───┬───┬───┬───┐
│ (index) │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │
├─────────┼───┼───┼───┼───┼───┼───┼───┤
│    0    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │
│    1    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │
│    2    │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │
└─────────┴───┴───┴───┴───┴───┴───┴───┘ 
```

让我们在下一个练习中将这个应用到实践中。

## 练习 5.4

在这个练习中，我们将生成一个值表格。我们将使用循环生成行和列，列将嵌套在行内。嵌套数组可以用来表示表格中的行。这是电子表格中常见的结构，其中每行都是表格内的嵌套数组，这些行的内容是表格中的单元格。列将按照我们在每行中创建相等数量的单元格来对齐。

1.  要创建一个表格生成器，首先创建一个空的数组`myTable`来存储你的表格数据。

1.  设置行和列的变量值。这将使我们能够动态地控制表格内想要的行和列的数量。将值从主代码中分离出来有助于更容易地更新维度。

1.  设置一个初始值为`0`的`counter`变量。计数器将用于设置单元格的内容并计算表格内单元格的值。

1.  创建一个带有条件的`for`循环来设置迭代次数，并构建表格的每一行。在其中，设置一个新的临时数组`tempTable`来存储每行数据。列将嵌套在行内，生成所需的每个列单元格。

1.  在第一个循环内嵌套第二个循环来计数列。列在行循环内运行，以便在表格内有均匀数量的列。

1.  在内循环的每次迭代中增加主计数器，以便我们跟踪每个单元格的总体计数以及创建了多少个单元格。

1.  将计数器值推送到临时数组`tempTable`。由于数组是一个表示表格的嵌套数组，计数器的值也可以用来在表格中相邻显示单元格值。尽管这些是表示新行的单独数组，但计数器的值将有助于说明最终表格中单元格的整体顺序。

1.  将临时数组推送到主表格中。随着每次迭代构建一个新行数组项，这将继续在数组中构建主表格。

1.  使用`console.table(myTable)`将输出到控制台。这将显示表格结构的可视化表示。

# 循环和数组

如果你现在还没有完全确信循环的极端有用性，请看看循环和数组。循环让数组的生活变得更加舒适。

我们可以将`length`属性和`for`循环或`while`循环的条件部分结合起来，在数组上循环。在`for`循环的情况下，它看起来是这样的：

```js
let arr = [some array];
for (initialize variable; variable smaller than arr.length; statement) {
  // code to be executed
} 
```

让我们从以下简单示例开始，该示例将记录数组的每个值：

```js
let names = ["Chantal", "John", "Maxime", "Bobbi", "Jair"];
for (let i = 0; i < names.length; i ++){
  console.log(names[i]);
} 
```

这将输出：

```js
Chantal
John
Maxime
Bobbi
Jair 
```

我们使用 `length` 属性来确定索引的最大值。索引从 0 开始计数，但长度不是。索引总是比长度小 1。因此，我们通过增加长度来遍历数组的值。

在这个例子中，我们还没有做非常有趣的事情；我们只是在打印值。但我们可以在一个循环中改变数组的值，例如，像这样：

```js
let names = ["Chantal", "John", "Maxime", "Bobbi", "Jair"];
for (let i = 0; i < names.length; i ++){
  names[i] = "hello " + names[i];
} 
```

我们将 `hello` 与我们名字的开头连接起来。数组在循环中被更改，循环执行后数组将包含以下内容：

```js
[
  'hello Chantal',
  'hello John',
  'hello Maxime',
  'hello Bobbi',
  'hello Jair'
] 
```

可能性是无限的。当数组在应用程序的某个地方出现时，可以按值将数据发送到数据库。数据可以按值修改，甚至可以像这样进行过滤：

```js
let names = ["Chantal", "John", "Maxime", "Bobbi", "Jair"]; 
for (let i = 0; i < names.length; i ++){ 
  if(names[i].startsWith("M")){
    delete names[i];
    continue;
  }
  names[i] = "hello " + names[i]; 
} 
console.log(names); 
```

`startsWith()` 方法只是检查字符串是否以某个字符开头。在这种情况下，它检查名称是否以字符串 `M` 开头。

别担心，我们将在 *第八章*，*内置 JavaScript 方法* 中详细讲解这个函数以及许多其他函数。

输出如下：

```js
[
  'hello Chantal',
  'hello John',
  <1 empty item>,
  'hello Bobbi',
  'hello Jair'
] 
```

但是在这里你必须小心。如果我们删除项而不是删除并留下空值，我们会意外地跳过下一个值，因为那个值会得到最近删除的那个值的索引，而 `i` 会增加并移动到下一个索引。

你认为这个函数是做什么的：

```js
let names = ["Chantal", "John", "Maxime", "Bobbi", "Jair"]; 
for (let i = 0; i < names.length; i++){ 
  names.push("...")
} 
```

你的程序会在这里陷入无限循环。由于每次迭代都会添加一个值，循环的长度会随着每次迭代而增长，`i` 将永远不会大于或等于 `length`。

## 练习 5.5

探索如何创建一个包含嵌套数组作为表格行的表格网格。每一行将包含设置在变量中的列数所需的单元格数量。这个网格表格将根据变量的值动态调整。

1.  创建一个网格数组变量。

1.  将单元格的数量设置为 `64`。

1.  将计数器设置为 `0`。

1.  创建一个全局变量用于 `row` 数组。

1.  创建一个循环，该循环将迭代到数组中你想要的单元格数量，再加一以包含零值。在我们的例子中，我们会使用 64+1。

1.  添加一个外部的 `if` 语句，该语句使用取模运算来检查主计数器是否能被 8 或你想要的任意列数整除。

1.  在前面的 `if` 语句内部，添加另一个 `if` 语句来检查行是否未定义，这表示是否是第一次运行或者行是否已完成。如果行已经被定义，那么将行添加到主网格数组。

1.  为了完成外部的 `if` 语句，如果计数器能被 8 整除，则清空 `row` 数组——它已经被内部 `if` 语句添加到网格中。

1.  在 `for` 循环结束时，将主计数器增加 1。

1.  设置一个临时变量来保存计数器的值并将其推送到 `row` 数组。

1.  在循环迭代中，检查计数器的值是否等于你想要的列总数；如果是，则将当前行添加到网格中。

1.  请注意，由于没有足够的单元格在添加行的条件下创建新行，额外的单元格将不会添加到网格中。另一种解决方案是移除循环条件中的+1，并在循环完成后添加`grid.push(row)`，这两种方法都将提供相同的解决方案输出。

1.  将网格输出到控制台。

## for of 循环

我们还可以使用另一种循环来遍历数组的元素：**for of 循环**。它不能用来改变与索引关联的值，就像我们可以在常规循环中做的那样，但对于处理值来说，它是一个非常优雅且易于阅读的循环。

以下是语法示例：

```js
let arr = [some array];
for (let variableName of arr) {
  // code to be executed
  // value of variableName gets updated every iteration
  // all values of the array will be variableName once
} 
```

所以你可以这样读：“对于数组中的每个值，称之为`variableName`并执行以下操作。”我们可以使用这个循环记录`names`数组：

```js
let names = ["Chantal", "John", "Maxime", "Bobbi", "Jair"];
for (let name of names){
  console.log(name);
} 
```

我们需要指定一个临时变量；在这个例子中我们称之为`name`。这个变量用于放置当前迭代的值，迭代完成后，它会被`next`值替换。这段代码的结果如下：

```js
Chantal
John
Maxime
Bobbi
Jair 
```

这里有一些限制；我们无法修改数组，但我们可以将所有元素写入数据库或文件，或者发送到其他地方。这种做法的优势在于我们不会意外陷入无限循环或跳过值。

### 练习 5.6

这个练习将在遍历 x 的递增值时构建一个数组。一旦数组完成，这个练习还将展示几种输出数组内容的方法。

1.  创建一个空数组

1.  运行循环 10 次，向数组添加一个新的递增值

1.  将数组记录到控制台

1.  使用`for`循环遍历数组（调整迭代次数以匹配数组中的值数）并将输出到控制台

1.  使用`for of`循环将值输出到控制台

# 循环和对象

我们刚刚看到了如何遍历数组中的值，但我们也可以遍历对象属性。当我们需要遍历所有属性但不知道正在迭代的对象的确切属性时，这可能会很有帮助。

以几种方式遍历对象。我们可以使用`for in`循环直接遍历对象，或者将对象转换为数组并遍历数组。我们将在以下章节中考虑这两种方法。

## for in 循环

使用循环操作对象也可以通过`for`循环的另一种变体来实现，即**for in 循环**。`for in`循环与`for of`循环有些相似。在这里，我们同样需要指定一个临时名称，也称为键，来存储每个属性名称。我们可以在以下示例中看到它的实际应用：

```js
let car = {
  model: "Golf",
  make: "Volkswagen",
  year: 1999,
  color: "black",
};
for (let prop in car){
  console.log(car[prop]);
} 
```

我们需要使用每次循环的`prop`来从`car`对象中获取值。输出结果如下：

```js
Golf
Volkswagen
1999
black 
```

如果我们只是像这样记录了 prop：

```js
for (let prop in car){
  console.log(prop);
} 
```

这是我们输出的样子：

```js
model
make
year
color 
```

如您所见，所有属性的名称都打印出来了，而不是值。这是因为`for in`循环获取的是属性名（键），而不是值。`for of`做的是相反的；它获取的是值，而不是键。

这个`for in`循环也可以用于数组，但它实际上并不实用。它只会返回索引，因为这些是数组值的“键”。还应注意的是，执行顺序不能保证，尽管这对于数组通常很重要。因此，最好使用在循环和数组部分提到的那些方法。

### 练习 5.7

在这个练习中，我们将实验如何遍历对象和内部数组。

1.  创建一个包含三个项目的简单对象。

1.  使用`for in`循环，从对象中获取属性名和值，并将它们输出到控制台。

1.  创建一个包含相同三个项目的数组。使用`for`循环或`for in`循环，将数组中的值输出到控制台。

## 通过转换为数组来遍历对象

你可以在将对象转换为数组后使用任何循环。这可以通过三种方式完成：

+   将对象的键转换为数组

+   将对象的值转换为数组

+   将键值对转换为数组（包含包含两个元素的数组：对象键和对象值）

让我们使用这个例子：

```js
let car = {
  model: "Golf",
  make: "Volkswagen",
  year: 1999,
  color: "black",
}; 
```

如果我们想遍历对象的键，我们可以使用`for in`循环，就像我们在上一节中看到的那样，但如果我们首先将其转换为数组，我们也可以使用`for of`循环。我们这样做是通过使用`Object.keys(nameOfObject)`内置函数。它接受一个对象，获取该对象的所有属性并将它们转换为数组。

为了演示它是如何工作的：

```js
let arrKeys = Object.keys(car);
console.log(arrKeys); 
```

这将输出：

```js
[ 'model', 'make', 'year', 'color' ] 
```

我们可以使用`for of`循环像这样遍历数组的属性：

```js
for(let key of Object.keys(car)) {
  console.log(key);
} 
```

这就是它输出的内容：

```js
model
make
year
color 
```

类似地，我们可以使用`for of`循环通过将值转换为数组来遍历对象的值。这里的主要区别在于我们使用`Object.values(nameOfObject)`：

```js
for(let key of Object.values(car)) {
  console.log(key);
} 
```

你可以用和遍历任何数组一样的方式遍历这些数组。你可以在常规的`for`循环中使用长度和索引策略，如下所示：

```js
let arrKeys = Object.keys(car);
for(let i = 0; i < arrKeys.length; i++) {
  console.log(arrKeys[i] + ": " + car[arrKeys[i]]);
} 
```

这将输出：

```js
model: Golf
make: Volkswagen
year: 1999
color: black 
```

更有趣的是如何同时使用`for of`循环遍历两个数组。为了做到这一点，我们必须使用`Object.entries()`。让我们演示它是如何工作的：

```js
let arrEntries = Object.entries(car);
console.log(arrEntries); 
```

这将输出：

```js
[
  [ 'model', 'Golf' ],
  [ 'make', 'Volkswagen' ],
  [ 'year', 1999 ],
  [ 'color', 'black' ]
] 
```

如您所见，它返回一个二维数组，包含键值对。我们可以像这样遍历它：

```js
for (const [key, value] of Object.entries(car)) {
  console.log(key, ":", value);
} 
```

这将输出：

```js
model : Golf
make : Volkswagen
year : 1999
color : black 
```

好的，你现在已经看到了许多遍历对象的方法。大多数方法都归结为将对象转换为数组。我们可以想象，到这一点，你可能想使用 break。或者，也许你只是想继续？

# break 和 continue

**break**和**continue**是两个我们可以用来控制循环执行流程的关键字。`break`将停止循环并继续执行循环下面的代码。`continue`将停止当前迭代并返回到循环的顶部，检查条件（或者在`for`循环的情况下，执行语句然后检查条件）。

我们将使用这个`car`对象数组来演示`break`和`continue`：

```js
let cars = [
  {
    model: "Golf",
    make: "Volkswagen",
    year: 1999,
    color: "black",
  },
  {
    model: "Picanto",
    make: "Kia",
    year: 2020,
    color: "red",
  },
  {
    model: "Peugeot",
    make: "208",
    year: 2021,
    color: "black",
  },
  {
    model: "Fiat",
    make: "Punto",
    year: 2020,
    color: "black",
  }
]; 
```

我们将首先更详细地看看`break`。

## break

我们已经在`switch`语句中看到了**break**。当执行`break`时，`switch`语句结束。在循环方面，这并没有太大的不同：当执行`break`语句时，循环将结束，即使条件仍然为真。

这里有一个愚蠢的例子来演示`break`是如何工作的：

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
  if (i === 4) {
    break;
  }
} 
```

这看起来像是一个将数字 0 到 10（再次排除 10）记录到控制台的循环。然而，这里有一个陷阱：一旦`i`等于 4，我们就执行`break`命令。`break`会立即结束循环，因此之后不再执行更多的循环代码。

我们还可以使用`break`来停止遍历汽车数组，当我们找到符合我们要求的汽车时。

```js
for (let i = 0; i < cars.length; i++) {
  if (cars[i].year >= 2020) {
    if (cars[i].color === "black") {
      console.log("I have found my new car:", cars[i]);
      break;
    }
  }
} 
```

一旦我们遇到一辆 2020 年或之后的黑色汽车，我们就会停止寻找其他汽车，直接购买那辆。数组中的最后一辆车也是一个选择，但我们甚至没有考虑它，因为我们已经找到了一辆。代码片段将输出如下：

```js
I have found my new car: { model: 'Peugeot', make: '208', year: 2021, color: 'black' } 
```

然而，通常使用`break`并不是一个好的实践。如果你能够通过管理循环的条件来跳出循环，这会是一个更好的实践。它防止你陷入无限循环，并且代码更容易阅读。

如果循环的条件不是一个真正的条件，而几乎是一个永远运行的语句，代码就很难阅读。

考虑以下代码片段：

```js
while (true) {
  if (superLongArray[0] != 42 && superLongArray.length > 0) {
    superLongArray.shift();
  } else {
    console.log("Found 42!");
    break;
  }
} 
```

这最好不使用`break`和不使用像`while(true)`这样可怕的东西来写；你可以这样做：

```js
while (superLongArray.length > 0 && notFound) {
  if (superLongArray[0] != 42) {
    superLongArray.shift();
  } else {
    console.log("Found 42!");
    notFound = false;
  }
} 
```

在第二个例子中，我们可以很容易地看到循环的条件，即数组的长度和一个`notFound`标志。然而，使用`while(true)`我们有点误用了 while 的概念。你想要指定条件，并且它应该评估为`true`或`false`；这样你的代码就很好阅读。如果你说`while(true)`，你实际上是在说永远，你的代码读者将不得不逐行解释以了解发生了什么以及循环是如何通过一个工作`break`语句结束的。

## continue

`break`可以用来退出循环，而**continue**可以用来继续循环的下一个迭代。它将退出当前迭代并返回到检查条件并开始新迭代的位置。

这里你可以看到一个`continue`的例子：

```js
for (let car of cars){
  if(car.color !== "black"){
    continue;
  }
  if (car.year >= 2020) {
    console.log("we could get this one:", car);
  }
} 
```

这里的方法是不考虑所有不是黑色的车，只考虑所有不是在 2020 年或之后生产的其他车。代码将输出如下：

```js
we could get this one: { model: 'Peugeot', make: '208', year: 2021, color: 'black' }
we could get this one: { model: 'Fiat', make: 'Punto', year: 2020, color: 'black' } 
```

在`while`循环中注意`continue`。在不运行它的情况下，你认为下一个代码片段会做什么？

```js
// let's only log the odd numbers to the console
let i = 1;
while (i < 50) {
  if (i % 2 === 0){
    continue;
  }
  console.log(i);
  i++;
} 
```

它记录`1`，然后它会让你陷入无限循环，因为`continue`在`i`的值改变之前被触发，所以它会再次遇到`continue`，然后又是，然后又是，如此等等。这可以通过将`i++`向上移动并从`i`中减去 1 来修复，如下所示：

```js
let i = 1;
while (i < 50) {
  i++;
  if ((i-1) % 2 === 0){
    continue;
  }
  console.log(i-1);
} 
```

但再次强调，这里有一种更好的方法，不需要使用`continue`。错误的机会要小得多：

```js
for (let i = 1; i < 50; i = i + 2) {
  console.log(i);
} 
```

如您所见，它甚至更短、更易读。`break`和`continue`的价值通常在您遍历大型数据集时出现，这些数据集可能来自您的应用程序之外。在这里，您将更少地影响应用其他类型的控制。在简单的示例中使用`break`和`continue`不是最佳实践，但它是一个了解这些概念的好方法。

## 练习 5.8

这个练习将演示如何创建一个字符串，其中包含循环遍历的所有数字。我们还可以通过添加一个使用`continue`跳过匹配条件的条件来设置一个要跳过的值。第二种选择是做同样的练习并使用`break`关键字。

1.  设置一个字符串变量作为输出。

1.  选择一个要跳过的数字，并将其设置为变量。

1.  创建一个计数到 10 的`for`循环。

1.  添加一个条件来检查循环变量的值是否等于要跳过的数字。

1.  如果该数字在条件中要被跳过，则`continue`到下一个数字。

1.  当你遍历值时，将新的计数值追加到主输出变量的末尾。

1.  循环完成后，输出主变量。

1.  重新使用代码，但将`continue`改为`break`，看看区别。现在它应该会在跳过的值处停止。

## break, continue, and nested loops

`break`和`continue`也可以用在嵌套循环中，但重要的是要知道，当在嵌套循环中使用`break`或`continue`时，外层循环不会中断。

我们将使用这个数组的数组来讨论嵌套循环中的`break`和`continue`：

```js
let groups = [
  ["Martin", "Daniel", "Keith"],
  ["Margot", "Marina", "Ali"],
  ["Helen", "Jonah", "Sambikos"],
]; 
```

让我们分解这个例子。我们正在寻找所有有两个以 M 开头的名字的组。如果我们找到这样的组，我们将记录它。

```js
for (let i = 0; i < groups.length; i++) {
  let matches = 0;
for (let j = 0; j < groups[i].length; j++) {
  if(groups[i][j].startsWith("M")){
      matches++;
    } else {
      continue;
    }
  if (matches === 2){
      console.log("Found a group with two names starting with an M:");
      console.log(groups[i]);
      break;
    }
  }
} 
```

我们首先遍历顶层数组并设置一个计数器`matches`，起始值为`0`，对于这些顶层数组中的每一个，我们将遍历其值。当一个值以 M 开头时，我们将`matches`增加 1 并检查是否已经找到了两个匹配项。如果我们找到两个 M，我们将跳出内层循环并继续外层循环。由于内层循环之后没有其他操作，这个循环将移动到下一个顶层数组。

如果名字不以 M 开头，我们不需要检查`matches`是否为`2`，我们可以继续到内数组的下一个值。

看看这个例子：你认为它会记录什么？

```js
for (let group of groups){
  for (let member of group){
    if (member.startsWith("M")){
      console.log("found one starting with M:", member);
      break;
    }
  }
} 
```

它将遍历数组，并且对于每个数组，它将检查值是否以 M 开头。如果是，内部循环将中断。所以，如果数组中的某个数组包含多个以 M 开头的值，只有第一个会被找到，因为遍历该数组的迭代会中断，然后我们继续到下一个数组。

这个会输出：

```js
found one starting with M: Martin
found one starting with M: Margot 
```

我们可以看到它找到了 Margot，第二个数组中的第一个，但它跳过了 Marina，因为它在该数组中是第二个。找到一组后，它会中断循环，因此不会遍历内部数组的其他元素。它将继续到下一个数组，该数组不包含以 M 开头的名字。

```js
data set contains at least one of something. Because of the nature of the for of loop, it won't give the index or place where it found it. It will simply break, and you have the value of the element of the array to use. If you need to know more, you can work with counters, which are updated every iteration.
```

如果我们想查看数组数组中的所有名字中是否只有一个以 M 开头，我们就必须跳出外部循环。这是我们可以通过标签循环来做到的。

## break 和 continue 以及标签块

我们可以从内部循环中跳出外部循环，但前提是我们给我们的循环一个标签。这可以通过以下方式完成：

```js
outer:
for (let group of groups) {
  inner:
  for (let member of group) {
    if (member.startsWith("M")) {
      console.log("found one starting with M:", member);
      break outer;
    }
  }
} 
```

我们通过在代码块前放置一个单词和冒号来给我们的代码块一个标签。这些单词可以是几乎任何东西（在我们的例子中是“outer”和“inner”），但不能是 JavaScript 的保留词，如 `for`、`if`、`break`、`else` 等。

这只会记录以 `M` 开头的第一个名字：

```js
found one starting with M: Martin 
```

它只会记录一个，因为它会跳出外部循环，并且所有循环都会在找到第一个匹配项时结束。以类似的方式，你也可以继续外部循环。

每当你想要在找到第一个匹配项后立即完成时，这就是你要使用的选项。例如，如果你想检查错误并在没有错误的情况下退出，这就是你要采取的方式。

# 章节项目

## 数学乘法表

在这个项目中，你将使用循环创建一个数学乘法表。你可以通过自己的创意或遵循以下建议步骤之一来完成此操作：

1.  设置一个空数组来包含最终的乘法表。

1.  设置一个 `value` 变量来指定你想要相乘的值的数量，并显示结果。

1.  创建一个外部 `for` 循环来遍历每一行，并创建一个 `temp` 数组来存储行值。每一行将是一个单元格数组，它将被嵌套到最终表中。

1.  为列值添加一个内部 `for` 循环，它将乘积的行和列值推送到 `temp` 数组中。

1.  将包含计算结果的临时行数据添加到最终表的主体数组中。最终结果将为计算添加一行值。

# 自我检查测验

1.  以下代码的预期输出是什么？

    ```js
    let step = 3;

    for (let i = 0; i < 1000; i += step) {
        if (i > 10) {
            break;
        }
        console.log(i);
    } 
    ```

1.  `myArray` 的最终值是什么，控制台中的预期输出是什么？

    ```js
    const myArray = [1,5,7];
    for(el in myArray){
        console.log(Number(el));
        el = Number(el) + 5;
        console.log(el);
    }
    console.log(myArray); 
    ```

# 概述

在本章中，我们介绍了循环的概念。循环使我们能够重复执行特定的代码块。当我们循环时，我们需要某种条件，并且只要该条件为真，我们就会继续循环。一旦它变为假，我们就结束循环。

我们已经看到了 `while` 循环，其中我们只需插入一个条件，只要该条件为真，我们就继续循环。如果条件永远不为真，我们甚至不会执行循环代码一次。

对于 `do while` 循环来说，情况就不同了。我们总是先执行代码一次，然后开始检查条件。如果这个条件为真，我们会再次执行代码，并一直这样做，直到条件变为假。当处理来自外部（如用户输入）的输入时，这可能很有用。我们需要请求一次，然后我们可以继续请求，直到它有效。

然后我们看到了 `for` 循环，它的语法略有不同。我们必须指定一个变量，检查一个条件（最好使用那个变量，但这不是强制性的），然后指定在每次迭代后要执行的操作。同样，最好让操作包括 `for` 循环第一部分中的变量。这给了我们一段只要条件为真就会执行的代码。

我们还看到了两种遍历数组和对象的方法，`for in` 和 `for of`。`for in` 循环遍历键，而 `for of` 循环遍历值。它们遍历集合中的每个元素。这些循环的优势在于 JavaScript 控制执行：你不会错过任何元素，也不会陷入无限循环。

最后，我们看到了 `break` 和 `continue`。我们可以使用 `break` 关键字立即结束循环，使用 `continue` 关键字结束当前迭代并回到顶部开始下一次迭代，如果条件仍然为真，那就是了。

在下一章中，我们将向我们的 JavaScript 工具箱添加一个真正强大的工具：函数！它们允许我们将我们的编码技能提升到下一个层次，并更好地组织我们的代码。
