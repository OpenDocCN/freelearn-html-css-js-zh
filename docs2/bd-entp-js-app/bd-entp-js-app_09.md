# 设计我们的 API

在过去的几章中，我们遵循 TDD 方法来实现我们的创建用户端点。然而，用户目录应用程序需要做更多的事情：检索、编辑、删除和搜索用户。在本章中，我们希望你们练习所学到的知识，并自己实现这些端点。

为了帮助你设计一个易于使用的 API，我们将概述一些 API 设计原则。具体来说，我们将：

+   讨论 REST 是什么，以及它不是什么

+   学习如何设计我们的 API 以使其**一致**、**快速**、**直观**和**简单**

+   理解不同类型的致性：**通用**、**本地**、**跨域**、**领域**和**永久**

# RESTful 的含义

当你阅读关于 API 的内容时，你无疑会遇到**SOAP**、**RCP**、**REST**等术语，如今还有**GRPC**和**GraphQL**。在撰写本文时，现状是所有 API 都应该“RESTful”，任何非 RESTful 的 API 都被认为是不够好的。这是一个常见的误解，它源于许多人实际上对 REST 的理解有误。因此，我们从这个章节开始，检查 REST 是什么，它不是什么，为什么它可能并不总是实用的，以及为什么我们的 API 将**不会**是 RESTful 的。

# 什么是 REST？

REST 代表**表征状态转移**，是一组*架构风格*，它规定了构建你的 API 的方式和模式。REST 并不是什么新东西；你可能已经非常熟悉它，因为这就是万维网的结构，所以不要让术语让你感到陌生。

REST 有六个要求：

+   **客户端-服务器**：定义了客户端和服务器之间清晰的**关注点分离**（**SoC**）。客户端应提供用户界面，而服务器提供数据。

+   **无状态**：服务器不应持有关于客户端的任何临时信息。换句话说，服务器不应持久化客户端会话；如果需要持久化会话，必须在客户端完成。到达服务器的任何请求都必须包含处理该请求所需的所有信息。

    这并不是说服务器不能存储**任何**状态；服务器仍然可以在数据库中持久化**资源状态**。但服务器不应在内存中存储临时的**应用程序状态**。

    这个约束的重要性将在第十八章，“使用 Kubernetes 的鲁棒基础设施”中变得明显，当我们把我们的应用程序作为**负载均衡**服务器的**集群**部署时。由于是无状态的，请求可以由集群中的任何服务器来满足，服务器可以重启而不会丢失信息。正是这个约束使得我们的应用程序具有可扩展性。

    然而，这个约束确实有其缺点，因为客户端必须反复在每个请求中发送认证信息（例如，**JSON Web Token**，或**JWT**），这会增加使用的带宽。

+   **可缓存性**：如果给定相同的请求，响应将是相同的，那么该响应应该由客户端和/或任何中间件缓存。RESTful 架构要求响应消息必须包含指示是否应该缓存响应或不应缓存，以及如果应该缓存，则缓存多长时间的指示。

    此约束可能有益，因为它有助于减少带宽使用，并且可以减少服务器负载，使其能够处理更多请求。

+   **分层系统**：许多应用程序，尤其是 Node.js 应用程序，由一个网络服务器**反向代理**（例如，**NGINX**）。这意味着在请求到达我们的应用程序之前，它可能通过由网络服务器（例如，**HAProxy**）、负载均衡器（例如，**Varnish**）和/或缓存服务器（例如，**Varnish**）组成的层。

    分层系统约束规定客户端不应了解这些层；用简单的话说，客户端不需要关心服务器的实现。

+   **按需代码**：一个可选约束，允许服务器返回客户端执行的代码。例如，服务器可能发送回自定义 JavaScript 代码、**Java 小程序**或**Flash**应用程序。这可以被视为客户端-服务器约束的扩展，因为它确保客户端不需要实现针对该服务器的特定代码，否则这将耦合客户端和服务器。

+   **统一接口**：一个**接口**是用于在两个组件之间交换信息的共享边界。接口很重要，因为它将服务器与客户端解耦；只要两者都遵守相同的接口，它们就可以独立开发。

    统一接口约束规定了该接口应该如何构建的规则，并且进一步细分为四个子约束（也称为**接口约束**）：

    +   **资源的识别**：存储在服务器上的数据单元称为**资源**。资源是一个抽象实体，例如人或产品。此约束要求我们的 API 为每个资源分配一个标识符。否则，客户端将无法与之交互。

        当使用 HTTP 中的 REST 时，此约束通过使用*统一资源定位器*或*URLs*得到满足。例如，产品#58 应通过 URL `api.myapp.com/users/58/` 访问。

    +   **通过表示形式操作资源**：您可以使用不同的格式表示资源，例如 XML 或 JSON。这些都是同一资源的不同**表示**。

        如果客户端希望以某种方式操作资源，此约束要求客户端发送资源所需状态的完整或部分表示。

        作为这一点的扩展，服务器还应向客户端指示它愿意接受哪些表示形式，以及它正在发送回哪些表示形式。当使用 HTTP 进行 REST 时，这是通过`Accept`和`Content-Type`头部分别完成的。

    +   **自描述消息**：服务器的响应应包含客户端正确处理所需的所有信息。

    +   **超媒体作为应用程序状态引擎**（**HATEOAS**）：这要求服务器响应包括客户端在收到响应后可以采取的操作列表。

为了将“RESTful”标签应用于一个 API，它必须遵守除了代码按需（这是可选的）之外的所有约束。

# REST 不是什么

在我们讨论我们应该遵循哪些 REST 约束以及哪些不应该遵循之前，让我们强调一个非常重要的区别：REST 是一种**架构风格**，并不强加低级实现细节。

REST 是一套通用的规则/模式，你可以将其应用于任何 API。我们通常用它来构建 HTTP API，因为 HTTP 是万维网的协议；然而，HTTP 协议及其动词与 REST 没有任何关联。

话虽如此，REST 规范的作者 Roy Fielding 也是 HTTP/1.1 规范的首席架构师，因此 REST 风格非常适合 HTTP 实现。

# 我的 API 应该是 RESTful 的吗？

在上一节中，我提到我们的 API 将**不是**RESTful；让我解释一下原因。虽然 REST 的几乎所有约束对现代 API 都有意义，但 HATEOAS 却没有。

Roy Fielding 在他的博士论文《架构风格和网络软件架构设计》中概述了 REST 约束，该论文的标题为*Architectural Styles and the Design of Network-based Software Architectures*，您可以在[www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)找到。这是在 2000 年，在像 Yahoo!、Lycos、Infoseek、AltaVista、Ask Jeeves 和 Google 这样的搜索引擎变得突出之前。当时 HATEOAS 约束是有意义的，因为它允许网站访客使用链接列表从任何一页导航到任何其他页面。

然而，HATEOAS 约束对于 API 来说意义不大。今天想要使用我们的 API 的开发者可能会参考我们项目网站上的 API 文档，而不是从服务器响应中推断出来。他们也可能将 URL 硬编码到他们的应用程序代码中，而不是从服务器提供的链接中获取它们。

换句话说，HATEOAS 对于人类用户是有意义的，但对于代码来说并不那么好。事实上，严格遵循 HATEOAS 约束意味着我们的响应必须包含对应用程序无用的信息。这将增加网络延迟，而不会提供任何实质性的好处。

因此，我们的 API 将按照设计不遵守 HATEOAS 约束。因此，我们不能称我们的 API 为 RESTful。

这可能会令人困惑，因为许多声称是 RESTful 的 API 实际上并不是（你使用过多少 API 实际上会在每次请求中返回端点列表？我猜没有）。我们应该吸取的教训是，我们应该将每个 REST 约束与我们的 API 进行分析，应用那些有意义的，但也要理解 API 不一定要是 RESTful 才能是“好”的。

# 设计我们的 API

应用程序编程接口，或 API，是最终用户与我们应用程序交互的接口。为了使 API 工作，客户端和 API 服务器必须就某种共同约定的形式或合同达成一致；对于特定类型的请求，客户端可以期望 API 以特定类型的响应进行回复。但是，为了有一个“好”的 API，这个合同也必须是**一致**的、**直观**的，并且**简单**。现在，让我们逐个解决每个标准。

# 一致性

一致性原则在 API 设计中非常重要。Arnaud Lauret，书籍《日常 API 设计》的作者，在他的博客文章《API 设计的四个一致性层级》（[restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/](http://restlet.com/company/blog/2017/05/18/the-four-levels-of-consistency-in-api-design/))中优雅地概述了四种不同类型的一致性，我们在这里进行了总结：

+   **共同**: 与世界保持一致

+   **局部**: 在同一 API 内保持一致

+   **横切性**: 同一组织下的不同 API 保持一致性

+   **领域**: 与特定领域保持一致

我已经向这个列表增加了一个条目——**持久一致性**——*或跨时间的一致性*。

让我们逐一检查每个。

# 共同一致性

如 Lauret 所解释，共同的共识是“与世界保持一致”。这意味着我们的 API 应该符合已建立的和/或权威的标准；如果没有，则符合社区共识。

如果一个 API 与世界不一致，它将迫使开发者学习一种新的思维方式。这可能需要大量的时间投入，这可能会阻止用户首先尝试使用 API。因此，拥有共同的共识可能会提高开发者的体验，甚至可能提高 API 的采用率。

对于 HTTP API，显然应该采用 HTTP/1.1 规范。这是一个由**万维网联盟**（**W3C**）批准的标准，它是万维网的权威国际标准组织。那么，让我们看看我们如何设计我们的 API 以符合这个标准。

# 发送正确的 HTTP 状态码

HTTP 规范规定，任何响应都必须有一个三位数的状态码，允许程序确定响应的性质。这些代码允许程序有效地处理响应：

| 状态码 | 响应类别 | 描述 |
| --- | --- | --- |
| `1xx` | 信息性 | 请求已接收但尚未完全处理。客户端不需要做任何事情。 |
| `2xx` | 成功 | 请求已成功接收、理解并被接受。 |
| `3xx` | 重定向 | 资源已移动，无论是临时还是永久。客户端需要采取进一步的操作来完成请求。 |
| `4xx` | 客户端错误 | 请求在语法和/或语义上不正确，服务器无法（或拒绝）处理它。 |
| `5xx` | 服务器错误 | 请求可能是有效的，但服务器出现了错误。 |

您可以在 W3C 的[httpstatuses.com](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)找到原始的状态码定义。当前有效的 HTTP 状态码列表由**互联网数字分配机构**（**IANA**）维护；您可以在[iana.org/assignments/http-status-codes](https://www.iana.org/assignments/http-status-codes)找到完整的列表。我个人使用[httpstatuses.com](https://httpstatuses.com/)，对我来说它更易于阅读。

我们已经遵循了这些标准来处理我们的创建用户端点。例如，当请求有效负载不是 JSON 时，我们响应`415 不支持的媒体类型`错误状态码；如果客户端尝试访问未实现的端点，Express 将自动响应`404 未找到`错误。

根据 IANA，目前有 62 个分配的 HTTP 状态码。大多数开发者无法记住所有 62 个。因此，许多 API 限制了它们发送回的状态码数量。我们将这样做，并将我们的 API 限制在仅使用以下九个状态码：

+   `200 OK`：通用的成功操作。

+   `201 已创建`：成功操作，创建了一个资源，如用户。

+   `400 错误请求`：当请求在语法或语义上不正确时。

+   `401 未授权`：当请求缺少认证凭据，服务器无法确定发送请求者时。客户端应带有这些凭据重新发送请求。

+   `403 禁止`：服务器理解请求但未授权。

+   `404 未找到`：资源未找到，或端点路径无效。

+   `409 冲突`：客户端上次检索资源后，资源已被修改。客户端应请求资源的新版本，并决定是否再次发送请求。

+   `415 不支持的媒体类型`：此端点的有效负载格式不受支持，例如，当服务器只接受 JSON 时发送 XML 有效负载。

+   `500 内部服务器错误`：请求可能是有效的，但服务器出现了错误。

# 使用 HTTP 方法

HTTP 规范还规定，HTTP 请求必须包含一个动词，并规定了哪些动词可以用于哪些类型的请求：

+   `GET`：请求检索资源。

+   `POST`：服务器决定如何处理数据的请求。URL 指定要处理此请求的资源。

+   `PUT`：请求在指定的 URL 下存储实体。

+   `PATCH`：请求对现有资源进行部分更改。

+   `DELETE`：请求删除资源。

+   `HEAD`：请求资源的元数据。

+   `OPTIONS`：请求服务器有关允许哪些请求的信息。

此外，`GET`、`HEAD`、`OPTIONS` 和 `TRACE` 被认为是**安全**方法，这意味着它们不得修改任何资源的表示。其他动词，如 `POST`、`PUT` 和 `DELETE`，预期会修改资源，应被视为*不安全*方法。

此外，还有一个相关的概念是**幂等性**。幂等的 HTTP 方法是可以重复多次但仍会产生与只发送单个请求相同的结果的 HTTP 方法。例如，`DELETE` 是一个幂等方法，因为多次删除资源的效果与只删除一次相同。*所有安全方法也都是幂等的*：

| 方法 | 安全 | 幂等 |
| --- | --- | --- |
| `CONNECT` | ✗ | ✗ |
| `DELETE` | ✗ | ✓ |
| `GET` | ✓ | ✓ |
| `HEAD` | ✓ | ✓ |
| `OPTIONS` | ✓ | ✓ |
| `POST` | ✗ | ✗ |
| `PUT` | ✗ | ✓ |
| `PATCH` | ✗ | ✗ |
| `TRACE` | ✓ | ✓ |

即使我们遵守 HTTP 规范，更新资源仍有多种方式：使用 `POST`、`PUT` 或 `PATCH`。因此，当对标准的解释存在歧义时，我们应该转向社区共识。

我们将使用由伦敦的数字产品工作室 Elsewhen 发布的一系列项目指南。它在 GitHub 上有超过 17,500 个星标，可通过 [github.com/elsewhencode/project-guidelines](https://github.com/elsewhencode/project-guidelines) 访问。

这里重现了指南中关于 HTTP 方法的部分：

+   `GET`：检索资源的表示。

+   `POST`：创建新资源和子资源。

+   `PUT`：更新现有资源。

+   `PATCH`：对现有资源进行部分更改的请求。它只更新提供的字段，其他字段保持不变。

+   `DELETE`：删除现有资源。

因此，尽管我们可以通过发送 `POST` 请求来更新资源，但我们只将 `POST` 请求限制在资源的创建上。

遵循指南，我们还将使用 `/<collection>/<id>` 结构来构建我们的 API 路径，其中 `<collection>` 是资源类别（例如，用户、产品或文章），而 `<id>` 是该集合中特定资源的标识符（例如，特定用户）。

我们将使用复数名词来命名我们的集合，以使 URL 更一致且易于阅读。换句话说，我们将使用 `/users` 和 `/users/<id>`，而不是 `/user` 和 `/user/<id>`。

将所有这些放在一起，我们得到以下表格，其中详细说明了针对每个资源应执行的操作和 HTTP 方法。

| 资源 | `GET` | `POST` | `PUT` | `PATCH` | `DELETE` |
| --- | --- | --- | --- | --- | --- |
| `/users` | 获取用户列表 | 创建新用户 | 错误 | 错误 | 错误 |
| `/users/<id>` | 获取用户 | 错误 | 更新用户对象（完全）；如果用户不存在则错误 | 更新用户对象（部分）；如果用户不存在则错误 | 删除用户对象；如果用户不存在则错误 |

# 使用 ISO 格式

对于诸如单位之类的项目，我们应尽可能使用国际标准化组织（**ISO**）提供的格式：

+   **日期/时间**: 使用 UNIX 时间戳（以毫秒为单位）表示时间，以及 ISO 8601 完整日期格式表示日期([iso.org/iso-8601-date-and-time-format.html](https://www.iso.org/iso-8601-date-and-time-format.html))

+   **货币**: ISO 4217 货币代码([iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html))

+   **国家**: 可以是 ISO 3166-1 alpha-2、ISO 3166-1 alpha-3 或 ISO 3166-1 数字代码([iso.org/iso-3166-country-codes.html](https://www.iso.org/iso-3166-country-codes.html))

+   **语言**: ISO 639-2 代码([iso.org/iso-639-language-codes.html](https://www.iso.org/iso-639-language-codes.html))

# 本地一致性

本地一致性意味着在同一 API 内部保持一致性。换句话说，如果一个开发者已经与你的 API 的一部分（例如，创建用户）合作过，他/她应该能够使用相同的约定来处理 API 的其他部分。

# 命名约定

例如，我们应该遵循一致的命名约定来命名所有我们的 URL。具体来说，我们将执行以下操作：

+   使用短横线命名法（kebab-case）为 URL 命名

+   在查询字符串中的参数使用驼峰命名法（camelCase），例如，`/users/12?fields=name,coverImage,avatar`

+   对于嵌套资源，应按如下结构组织：`/resource/id/sub-resource/id`，例如，`/users/21/article/583`

对于我们的非 CRUD 端点，URL 命名约定应遵循`/动词-名词`结构：我们应该使用`/search-articles`而不是`/articles-search`。

# 一致的数据交换格式

这听起来可能很明显，但我们应该使用纯文本或**JavaScript 对象表示法**（**JSON**）作为数据交换的格式。你不应该在一个端点使用 JSON，而在另一个端点使用 XML，例如。

# 错误响应负载

错误响应负载应遵循一致的格式。例如，负载应是一个包含错误对象的 JSON 对象数组，每个对象包含三个字段：

+   `code`: 一个数字错误代码，供程序使用

+   `message`: 错误的简短、可读性强的摘要

+   `description`: 错误的可选更详细描述

每个错误负载都必须遵循此格式。这允许开发者编写一个可以处理所有错误消息的单个函数。

# 交叉一致性

交叉一致性是指在同一组织内的不同 API 之间保持一致性。原因与本地一致性类似。

# 域一致性

领域一致性是指与特定领域保持一致。

例如，如果你正在开发一个科学出版物目录，你应该进行一些研究以获取特定于这个领域的知识和规范。例如，你应该知道科学出版物可能被识别为**PubMed 标识符**（**PMID**）、PMCID、稿件 ID 或**数字对象标识符**（**DOI**），因此你的 API 响应对象应包含包含这些不同标识符的字段，或者至少允许用户根据这些 ID 搜索文章。这与科学领域的规范一致。

另一个例子是允许使用与领域一致的过滤器。继续以科学出版物目录为例，通常有几种科学出版物类别：原始/主要研究、评论、社论/观点、简报、临床案例研究、方法、荟萃分析、学位论文、会议记录等。允许用户根据这些类别进行筛选将是另一个领域一致性的例子。

# 长期一致性

最后，我创造了“*perennial consistency*”（长期一致性）这个术语，意味着与 API 的过去和未来保持一致。

我选择“*perennial*”（常年的）这个形容词而不是“*perpetual*”（永久的”或“*persistent*”（持续的”），因为“*perpetual*”意味着 API 将“*永远*”不会改变，这是不切实际的；“*persistent*”意味着即使有必要，开发者也应该固执地拒绝更改 API，这是不正确的；“*perennial*”意味着 API 结构应该长期保持不变，但不是永远不变。

要理解为什么长期一致性很重要，我们首先必须了解当我们对 API 引入破坏性（向后不兼容）更改时会发生什么。

# API 中的破坏性更改

如果我们正在开发一个库并想引入破坏性更改，我们只需简单地增加主版本号并发布即可。开发者可以自由选择是否以及何时迁移。然而，对于 API 来说，这个过程并不那么简单，原因如下：

+   对于 API 的每个版本，API 提供者必须维护一个不同的服务实例。这可能会造成巨大的开销。

+   API 的不同版本仍将使用相同的数据集，因此你必须设计一个与所有版本兼容的数据结构。有时，这可能需要你在数据中包含冗余字段。

+   如果更改过于剧烈，开发者可能会继续使用旧版本，这可能会延长你必须支持旧 API 的期限。

破坏性更改对开发者体验也不好，原因如下：

+   在旧版本被淘汰之前，开发者通常被给予一个有限的时间段来更新他们的代码以符合新版本。

+   依赖于你的 API 的第三方库也必须更新它们的代码。但如果维护者缺乏时间或意愿进行迁移，可能会导致过时库的积累。

由于这些原因，应尽可能避免破坏性变更。当你设计 API 时，要注意不仅要考虑当前的需求，还要考虑任何可能的未来需求。

这并不与“你不需要它”（YAGNI）原则相矛盾。你不会去实现你可能不需要的功能。你只是在提前思考，以便可以提前规划。

# 为你的 URL 提供未来保障

实现永久一致性的一种方法是为你的 URL 设计未来保障。例如，如果我们正在构建一个社交网络，其中每个用户都必须属于一个组织，我们可以使用类似于`/orgs/<org-id>/users/<user-id>`的 URL 结构来标识用户。但如果我们向前看，未来可能会有这样的时刻，我们的平台需要为属于多个组织的用户提供支持；在这种情况下，我们提出的 URL 结构将不支持这一点。

因此，我们应该设计我们的 URL，使其简单地包含用户的 ID（即，`/users/<user-id>`）。然后，为了将用户与组织关联起来，我们可以实现成员资格的概念，并将成员资格 URL 的结构设计为`/orgs/<org-id>/members/<member-id>`。

# 为你的数据结构提供未来保障

确保永久一致性的另一种方法是为你数据结构提供未来保障。例如，如果我们想存储用户的姓名，我们可以简单地指定一个类型为字符串的`name`属性。这可能现在有效，但将来，我们可能想要区分名、中名和姓。我们甚至可能想要根据名或姓实现排序和过滤。进一步思考，许多人，尤其是来自亚洲国家的人，既有英文名也有非英文名，所以我们甚至可能希望允许用户用多种语言提供他们的姓名。将姓名属性作为字符串来结构化是不行的！

这就是为什么我们的用户模式指定了一个对象作为`name`属性的数结构。这允许我们在不破坏现有代码的情况下向对象添加更多属性。例如，我们的配置文件对象最终可能会演变成如下所示：

```js
{
  name: {
    first: "John",
    middle: "Alan",
    last: "Doe"
    display: "John Doe",
    nickname: "JD",
    others: [{
      lang: "zho",
      name: ""
    }]
  }
}
```

# 版本控制

但如果无法避免破坏性的变更，那么我们必须遵守语义版本控制（semver）并增加 API 的主版本号。但版本数据存储在哪里呢？通常有两种方法：

+   在 URL 中（例如，`/v2/users`）：这到目前为止最容易解释和实现，但从语义上讲是不正确的。这是因为 URL 应该用于定位资源；如果我们向 URL 中添加版本信息，那么这会暗示资源本身是版本化的，而不是 API。

+   作为`Accept`头的一部分（例如，`Accept: application/vnd.hobnob.api.v2+json`）：MIME 类型中的`vnd`前缀表示这是一个供应商特定的 MIME 类型；在这里，我们用它来指定我们想要的 API 版本。`+json`表示回复可以被解析为 JSON。这是最语义化的方法，但也需要更多的努力向最终用户解释。

URL 方法更为实用；`Accept`头方法更为语义化。两者没有“更好”之分。选择对你和你的受众都有意义的方法。

在进行重大更改时，除了增加 API 版本号外，还确保你做了以下事情：

+   在可能的情况下，提供一段宽限期，即降级期，在此期间，旧版和新版同时运行，以便开发者有时间迁移到新版本。

+   提前提供降级警告，包括旧 API 版本将不再支持的确切日期以及它将完全不可用的日期

+   提供所有重大更改的清晰列表

+   提供如何迁移到新版本的清晰说明

# 直观

当我们与日常物品互动时，我们对它们的工作方式有一个预期。这在设计中被称为“可用性”。例如，如果你看到一个门把手，你应该本能地知道你应该拉门把手；相反，一个平面的长方形金属片（称为“指板”）固定在门上意味着它应该被推：

![图片](img/b44fd0e3-0b25-43a0-8504-d5a6449a6f32.jpg)

（左）在门的一侧添加一个用于推的门把手是设计不良的例子，因为门把手是用于拉的，而不是推的。（右）门把手已经暗示了门是用于拉的，所以这里的“拉”标签是不必要的。此图片来自`chriselyea.com/wp-content/uploads/2010/01/PushPullDoors.jpg`（已失效链接）。

这种可用性的概念适用于所有设计，包括 API 设计。同样，API 应该是自我解释的，尽可能明显。

用户不想学习新的行为。用户不想阅读文档来使用你的平台。最佳情况是，你的 API 如此直观，以至于他们只需要偶尔查阅文档。

另一方面，如果你的 API 不够直观，用户可能仍然会尝试使用它，但他们可能会觉得学习曲线太高，转而使用其他平台。

这也涉及到之前提到的关于一致性的观点：如果它通常是连贯的，那么用户在使用你的 API 时会感到更加熟悉。

直观仅仅意味着使事物明显。我们应该遵循**最小惊讶原则**（**POLA**），该原则指出：“执行某些操作的结果应该是显而易见、一致和可预测的，基于操作名称和其他线索。”

在这里，我们概述了一些我们可以做的事情，以确保我们的 API 尽可能直观。

# 适合人类的 URL

相关端点应分组。例如，Instagram API 将端点分组为用户、媒体、标签和位置相关的端点，每个端点都在`api.instagram.com/v1/{group}/`下。

这使得端点的消费者能够立即推断出端点的预期功能，而无需查阅文档。端点的功能应该对消费者显而易见。

例如，`/users/:user-id/media/recent`这个端点很明显是用来检索用户最近媒体对象的。

# 倾向于详尽和明确

当有疑问时，始终倾向于详尽和明确而不是隐晦，因为这可以消除 API 中的歧义。例如，使用`userId`而不是`uid`，有些人可能会将其解释为“唯一 ID”。

# 简单至上（KISS）

最后但同样重要的是，一个好的 API 必须是简单的。

拥有一个 API 的主要原因是将实现细节从最终用户抽象出来。您不应该向最终用户公开内部函数，因为这会给您的 API 增加不必要的复杂性——用户将需要阅读更多的文档，即使其中 90%与他们想要做的事情无关。

规则是考虑最小的一组可以公开的功能，但仍然允许典型用户执行所有必要的功能。例如，当新用户注册时，会自动为他们创建一个个人资料，因此没有必要将内部`createProfile`函数作为`/POST profile`端点公开，因为典型用户永远不会调用它。

“当有疑问时，就把它留在外面”是一个值得记住的格言；通常向 API 添加功能比移除一些开发者（尽管比例很小）已经使用的功能要容易。

一个蹒跚学步的孩子如果没得到他们没要求的玩具不会哭，但如果你试图拿走他们正在玩的玩具，你可能会发现你的耳朵会嗡嗡响一段时间。

# 完成我们的 API

在前面的章节中，我们向您展示了如何在 TDD 过程中编写单元、集成和端到端测试。在本章中，我们概述了在设计 API 时应考虑的因素。现在，我们将接力棒传给您，以实现 API 的其余部分。具体来说，您应该实现以下要求：

+   删除

    +   用户必须提供一个用户 ID 以进行删除

+   搜索

    +   默认为最后注册的 10 个用户

+   创建

    +   用户必须提供一个电子邮件地址和密码

    +   用户可以选择提供个人资料；否则，将为他们创建一个空的个人资料

+   检索

    +   当用户提供一个其他用户的用户 ID 时，应返回该用户的个人资料

+   更新

    +   当用户提供一个用户 ID 和完整的用户对象时，我们应该用新的用户对象替换旧的用户对象

    +   当用户提供一个用户 ID 和部分用户对象时，我们应该将部分对象合并到现有对象中

记得也要遵循我们现有的约定：

+   所有请求数据必须以 JSON 格式传输

+   所有响应数据负载必须以 JSON 格式或纯文本格式

# 摘要

在本章中，我们探讨了如何设计和构建我们的 API，使其对最终用户来说保持一致性、直观性和简单性。然后，我们将这些原则留给你，在你实现 CRUD 和搜索端点时应用。在下一章中，我们将学习如何将我们的 API 部署到云服务器上，使其对全世界都可用！
