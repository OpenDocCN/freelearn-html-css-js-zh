# 第七章：构建表示操作的类型

在前面的章节中，我们看到了如何构建类型来模拟多种类型的数据。在所有这些章节中，我们都依赖于函数。函数封装计算和操作以便于重用，因此它们是任何编程语言中最常用的功能之一。因此，通过利用 Reason 的类型系统和函数式编程技术，我们可以设计出最有效的函数。

在本章中，我们将涵盖以下主题：

+   有意义的函数类型和有用的属性

+   柯里化和部分应用

+   高阶函数

+   使用函数来控制依赖顺序和程序流程

+   常用函数和运算符

但首先，什么是函数？在类型理论和数学中，函数有一个正式的定义，但我们可以将其视为给定输入计算输出的公式。在 Reason 和其他静态类型函数式编程语言中，函数总是有输出的，即使它们实际上没有进行任何计算。我们将研究如何表达这些输入和输出，但首先我们需要对函数类型和属性有一个基本了解。

# 函数类型和其他有用的属性

在 Reason 中，函数具有非常具体的类型，并且就像其他值一样，不同类型的函数不能相互替换。

每个 Reason 函数的基本类型如下：

```js
*a* => b
```

将其读作`a -> b`。

如您所见，输入`a`和输出`b`可以是任何类型（甚至是相同的类型）。这种基本函数类型，具有单个输入和单个输出，导致了 Reason 中所有其他函数类型。我们将在稍后讨论这是如何发生的，但首先让我们谈谈几个在类型驱动世界中非常重要的有用函数式编程概念。

# 引用透明性

第一个属性被称为**引用透明性**（或**RT**），这意味着对于给定的输入`a`，函数将始终产生相同的输出`b`，无论我们如何、何时或多少次调用它。这意味着函数不能表现出不可预测的行为；我们必须能够预测每个输入的输出，就像一个数学公式一样。

例如，以下是一个非引用透明函数：

```js
/* [xDaysAgo(x)] returns the time [x] days before now, in ms since Unix
    epoch. */
let *xDaysAgo*(*x*) =
 * Js.Date.now*() -. *float_of_int*(*x*) *. 24\. *. 60\. *. 60\. *. 1_000.;
```

在 Reason 中，浮点算术运算符与整数运算符不同（它们以点作为后缀）。Reason 试图在算术和转换方面尽可能明确，以便我们可以避免意外结果。

我们无法预测任何给定输入`x`的输出，因为这取决于函数被调用的日期和时间。问题在于对当前日期或时间的隐藏依赖。一个解决方案是通过将依赖项作为函数参数传递来消除依赖，如下所示：

```js
/* [xDaysAgo(now, x)] returns the time [x] days before [now], in ms
    since Unix epoch. */
let *xDaysAgo*(*now*, *x*) =
  *now* -. *float_of_int*(*x*) *. 24\. *. 60\. *. 60\. *. 1_000.;
```

立即的好处是函数更容易测试，但更大的好处是，代码库中这样的函数使得推理更容易*。

关于代码的推理（也称为**等式推理**）意味着能够用实际值替换函数参数，就像一个数学方程式一样，通过简化来评估结果。这听起来像是一个微不足道的优势，但当在一个代码库中使用时，它可以是一个确保透明性的强大技术。

实际上讲，我们无法使整个代码库具有引用透明性（除非我们使用诸如效果类型等高级技术）。然而，我们可以将非 RT 操作推到程序的边缘。例如，我们可以用`Js.Date.now()`的调用结果或从其他地方传入的日期值调用（第二个）`xDaysAgo`函数。这是一种简单但有效的**依赖注入**形式（向程序传递值而不是让程序自己尝试获取值）。我们将在本章的后面部分更详细地介绍依赖注入。

# 函数纯净性

我们试图实现的第二个重要属性是**纯净性**。这个概念意味着，对于调用者（即调用它的代码）和外部世界来说，一个函数除了评估其结果外没有其他影响。我们说函数没有任何**可观察的效果**。可观察性在这里是关键；可能确实有在函数内部发生和包含的效果（如突变），但调用者不知道，也不能知道它们。以下是一个纯函数的例子，它在内部发生突变但不可观察：

```js
let *sum*(*numbers*) = {
  let *result* = *ref*(0);
  for (*i* in 0 to *Array.length*(*numbers*) - 1) {
    *result* := *result*^ + *numbers*[*i*];
  };
  *result*^
};
```

如果我们在`for`循环体中添加一个`Js.log(result^)`，函数就会变得不纯，因为它的效果会变得可观察。人们有时对“可观察”的确切含义存在分歧，尤其是在记录其他方面纯净函数的操作时，但出于谨慎，我们可以接受任何可观察的效果都是函数中的杂质（而且这没关系，因为有时我们确实需要那些可观察的效果）。

# 完全性

我们希望函数拥有的最后一个重要属性是**完全性**。这意味着函数应该处理它们接受的类型的每个可能值，这实际上比看起来要复杂得多！例如，再次看看`xDaysAgo`函数。如果`x`是负数怎么办？或者非常大或非常小？我们是否考虑了整数溢出？尤其是在处理数字时，我们需要了解它们在我们运行的平台的属性。

在我们的情况下，我们运行在 JavaScript 平台（如 Node.js）上，所以所有数字都是内部表示为 IEEE 浮点数（这就是 JavaScript 的工作方式），我们可以在需要担心溢出之前走得很远。但考虑以下一个简单的函数：

```js
let *sendMoney*(*from*: string, *to_*: string, *amount*: float) = Js.log(
  {j|Send \$$*amount* from $*from* to $*to_*|j});
```

第一个美元符号需要转义，否则编译器会尝试将其视为开始一个插值的标志。

在这里，我们只是打印出我们想要发生的事情。在实际应用中，我们可能想要进行货币转账。假设我们通过 HTTP 服务调用公开了这个函数。如果有人用负浮点数调用服务会发生什么？最好的情况是错误会在其他地方被捕获；最坏的情况是人们可能调用服务从别人的账户中吸走资金。

解决这个问题的方法之一是在函数的开始处验证我们的参数，如下所示：

```js
let *sendMoney*(*from*, *to_*, *amount*) = {
  assert(*from* != "");
  assert(*to_* != "");
  assert(*amount* > 0.);
  *Js.log*({j|Send \$$*amount* from $*from* to $*to_*|j});
};
```

为了确保万无一失，在这个片段中，我们对发送者和接收者字符串进行了一些基本的验证。我们还能够去除类型注解，因为断言将导致它们被正确推断。

`assert`是一个内置关键字，尽管它看起来和像一个函数工作。

从函数的角度来看，内部现在是一个完整的函数，因为它明确地错误处理了它不想处理的案例，但处理了剩余的愉快路径。然而，对于外界来说，函数仍然接受原始字符串和浮点数，并且未能处理大多数情况。一个更好的解决方案是使用更约束的类型来精确描述函数可以接受的内容，如下所示：

```js
/* src/Ch07/Ch07_DomainTypes.re */
module *NonEmptyString*: { /* (1) */
 type t = pri string; /* (2) */
 let *makeExn*: string => t;
} = {
 type t = string;
 let *makeExn*(*string*) = { assert(*string* != ""); *string* };
};

module *PositiveFloat*: { /* (3) */
 type t = pri float;
 let *makeExn*: float => t;
} = {
 type t = float;
 let *makeExn*(*float*) = { assert(*float* > 0.); *float* };
 let *toFloat*(*t*) = *t*;
};

let *sendMoney*( /* (4) */
 *from*: *NonEmptyString*.t,
 *to_*: *NonEmptyString*.t,
 *amount*: *PositiveFloat*.t) = {

 let *from* = (*from* :> string); /* (5) */
 let *to_* = (*to_* :> string);
 let *amount* = (*amount* :> float);
 *Js.log*({j|Send \$$*amount* from $*from* to $*to_*|j});
};

*sendMoney*( /* (6) */
 *NonEmptyString.makeExn*("Alice"),
 *NonEmptyString.makeExn*("Bob"),
 *PositiveFloat.makeExn*(32.));
```

我们不得不使用`to_`作为参数名而不是`to`，因为在 Reason 中`to`是一个保留关键字。如果我们想将其用作名称，通常会在关键字前添加一个下划线。

这个片段看起来更冗长，但从长远来看，这是一个更好的解决方案，因为我们可以在隔离的情况下为包装类型及其模块编写测试，确保类型确实执行了我们的规则，并且可以重用这些类型，而不是在整个代码库中添加检查。以下是它是如何工作的：

1.  我们设置了一个只能是非空字符串的类型。如果调用者尝试构造一个空字符串的类型，这将引发异常。

1.  类型声明表明这是一个`private`类型，这意味着我们暴露了其内部表示，但不允许用户构造该类型的值。当我们想半透明地取一个现有的类型并对其进行某种限制时，这是一种有用的技术。我们很快就会看到如何做到这一点。

1.  类似地，我们设置了一个只能有正浮点数值的类型。

1.  在`sendMoney`函数中，我们通过只接受这些约束类型而不是它们的原始变体来利用这些类型的好处。现在函数是完整的，因为它根据（类型）定义只接受它处理的精确值。

1.  我们仍然需要解包约束值以获取原始值，因为我们最终想要打印原始值。尽管类型被声明为 `private`，但我们可以将它们**强制**回更通用的版本。强制意味着将约束类型（如 `NonEmptyString.t`）的值强制转换为更通用的类型（如 `string`）。强制是完全静态的；如果我们不能强制转换某个值，我们将得到编译错误。请注意，强制转换的语法需要相当精确，并且需要包括括号。

1.  在将值传递给函数之前，我们还需要包装这些值。这是可能失败的地方，因此我们将它移出了我们的函数实现。

在这里，我们使用了在可能抛出异常的函数名称中添加 `Exn` 的约定。有些人更喜欢返回可选值而不是抛出异常。这个约定是惯用的且类型安全的，但最终只是报告错误的一种方法。关键点是，任何可能的失败都已被移出我们的总 `sendMoney` 函数以及其他使用约束类型的函数。

# 函数类型意味着什么

在类型驱动开发的背景下，为什么引用透明性、纯洁性和完备性等函数式编程概念很重要？原因是函数的类型有一个被充分理解的数学意义，违反这些规则会模糊这个意义。

类似于 `a => b` 的函数类型意味着这种类型的函数将接受类型为 `a` 的输入并评估为类型为 `b` 的结果，并且不会做其他任何事情（例如，打印日志、启动咖啡机或发射导弹）。我们非常喜欢这种保证，就像我们喜欢知道 `int` 只是一个 `int`，而不是导弹发射后跟一个 `int` 一样。

事实是，Reason 允许副作用是一个伟大的实用决策，但我们仍然可以努力将副作用推到我们程序的边缘，并保持其核心纯粹是函数式的。在函数式意义上，纯洁性对于函数类型的准确性是必要的。如果我们程序中的类型是准确的，我们就可以更有信心地进行类型驱动开发。

# 多个参数和柯里化

我们已经提到，Reason 函数始终接受单个参数并返回单个值，但我们一直愉快地使用看起来接受多个参数的函数，例如 `xDaysAgo(now, x)`。这是如何可能的？

在 Reason 中，具有多个参数的函数会自动**柯里化**。这意味着它们实际上是接受单个参数并返回一个新的函数，该函数接受下一个参数，依此类推，形成一个单参数函数的链，最终返回一个结果。这看起来可能效率不高，但在实践中，编译器几乎总能优化调用链为单个高效的调用。让我们看看以下具体的例子，定义`xDaysAgo`：

```js
let *xDaysAgo*(*now*, *x*) = ...;
```

此语法等同于以下（这由 Reason 代码格式化工具支持，因此通常在野外看到）：

```js
let *xDaysAgo* = (*now*, *x*) => ...;
```

接下来，我们有以下内容：

```js
let *xDaysAgo* = *now* => *x* => ...;
```

类似地，我们可以调用以下函数：

```js
let *result* = *xDaysAgo*(*now*, *x*);
```

这等同于以下语法：

```js
let *result* = *xDaysAgo*(*now*)(*x*);
```

编译器理解这个语法是一个**完全应用**的函数调用，并相应地进行优化。

有时候，一个调用不是完全应用的。换句话说，它是**部分应用**的。这意味着它只使用了它接受的某些参数。一个部分应用的函数只是接受一个或多个参数，但根据定义，比原始函数少的参数。让我们看看以下简单的例子：

```js
let *xDaysBeforeNow* = *xDaysAgo*(*Js.Date.now*());
let *result* = *xDaysBeforeNow*(10);
```

此示例通过调用适当的 JavaScript 日期函数并随后将其注入到`xDaysAgo`函数中，以获取一个预先加载了当前时间的新的函数来捕捉当前时刻。然后，这个新函数被绑定到名称`xDaysBeforeNow`并调用以获取结果。结果将是确定的；换句话说，对于给定的输入，我们总是会得到相同的输出。原因是非确定性的数据已经输入到函数中，并作为静态值捕获在函数内部。换句话说，`xDaysBeforeNow`也是引用透明的。

根据规则，我们从引用透明函数的应用中获得的函数（如`xDaysAgo`）也是引用透明的。这个规则同样适用于其他函数特性：纯净性和完备性。这在我们从更一般的函数构建专用函数时非常有帮助，因为我们可以从自信开始，并在每一步保持这种自信。

现在，让我们看看另一个既有趣又展示了其有用性的部分应用示例。

在以下示例中，我们定义了一个函数，该函数返回或打印用于邮寄信件的信封标签，使用收件人的姓名、邮政地址等。此函数可以定义为如下：

```js
let printEnveloppeLabel = (~firstname: string, ~lastname: string, ~address: string, ~country: string)
  : unit => {
    print_newline();
    print_endline(firstname ++ " " ++ lastname);
    print_endline(address);
    print_endline(country);
};
```

我们可以像下面这样以正常方式调用该函数，使用所有参数：

```js
printEnveloppeLabel("John", "Doe", "Some address in the US", "USA");
```

我们还可以定义另一个用于部分应用的函数，为国家参数传递一个值，如下所示：

```js
let printEnveloppeLabelUS = printEnveloppeLabel(~country="USA");
printEnveloppeLabelUS("John", "Doe", "Some address in the US");
```

我们还可以为`lastname`参数传递一个值，为打印同一家庭成员标签的函数，如下所示：

```js
let printEnveloppeLabelDoeFamily = printEnveloppeLabelUS(~lastname="Doe", ~address="Some address in the US");
printEnveloppeLabelDoeFamily(~firstname="Jane");
```

此示例（`src/Ch07/Ch07_Currying.re`）编译后生成的 JS 执行结果如下：

```js
John Doe
Some address in the US
USA

John Doe
Some address in the US
USA

Jane Doe
Some address in the US
USA
```

# 函数作为值

在上一节中，我们介绍了如何通过将函数定义语法上 **去糖化**（即使用稍微繁琐的语法）成一系列链式函数值。让我们来探讨函数在 Reason 中实际上是第一类值这一观点，就像数字、字符串、记录等一样。

# 函数字面量语法

Reason 为所谓的 **函数字面量** 提供了强大的支持，也称为 **lambda** 或 **闭包**。这意味着，就像在 JavaScript 和其他各种语言中一样，我们可以在任何可以写下任何值的地方直接写下函数值。以下是一个函数字面量的基本语法：

```js
PATTERN => body
```

以下是为编写柯里化函数的语法：

```js
PATTERN1 => PATTERN2 => ... => PATTERNn => body
```

Reason 为编写柯里化函数提供了一个看起来熟悉的语法糖，如下所示：

```js
(PATTERN1, PATTERN2, ..., PATTERNn) => body
```

注意到与绑定一样，故意使用了 `PATTERN`：

```js
let *PATTERN* = VALUE;
```

事实上，Reason 函数（无论是字面量还是正常函数绑定）都可以直接对其参数进行模式匹配。然而，与任何模式匹配一样，我们必须小心在函数参数中匹配可反驳的模式，因为这些风险在运行时失败。以下代码片段包括函数字面量的示例：

```js
/* src/Ch07/Ch07_FunctionLiterals.re */
let addV1(int1, int2) = int1 + int2; /* (1) */
let addV2 = (int1, int2) => int1 + int2; /* (2) */
let addV3 = int1 => int2 => int1 + int2; /* (3) */

/** A way to convert values of type ['a] to and from floats. */
module FloatConverter = {
 /* (4) */
 type t('a) = {encodeExn: 'a => float, decodeExn: float => 'a};

 /* (5) */
 let float = {encodeExn: float => float, decodeExn: float => float};
 let int = {encodeExn: float_of_int, decodeExn: int_of_float}; /* (6) */
};

let greet = ({Ch03_Domain.Person.id, name}) => /* (7) */
 {j|Hello, $name with ID $id!|j};
```

此文件展示了相当多的事物，如下所述：

1.  我们使用本书中一直使用的语法定义一个函数，以进行比较。

1.  如何使用稍微去糖化的 Reason 语法定义并立即绑定一个函数字面量。

1.  如何使用完全去糖化的柯里化语法定义并立即绑定一个函数字面量。这里需要意识到的是，这三个函数在类型和行为上完全相同，并且可以以完全相同的方式调用：`addV*n*(1, 2)`。

1.  如何定义一个可以包含两个函数的类型：一个将给定的类型 `'a'` 转换为 `float`，另一个将 `float` 转换回相同的 `'a'`。请注意，我们使用命名约定来表明这两个函数都可能抛出异常，因为我们不能事先保证每个类型 `'a'` 都可以实际转换为 `float` 并返回。

1.  如何定义一个 `FloatConverter.t(float)`，它（简单地）知道如何将 `float` 转换为 `float`。函数实现为 `float => float`，在这个上下文中意味着返回与输入相同的 `float`。

1.  如何定义一个 `FloatConverter.t(int)`，它知道如何使用 Reason 标准库中的函数在 `int` 和 `float` 之间进行转换。

1.  最后，我们看到了如何通过创建一个函数字面量，使用参数的解构模式匹配并将函数绑定到名称 `greet` 来定义另一个问候函数。

# Eta 抽象

注意，在前面的第六点中，我们直接使用了两个标准库提供的函数作为值。我们也可以将它们包裹在第一类函数中，如下所示：

```js
let *int* = {
  *encodeExn*: *int* => *float_of_int*(*int*),
  *decodeExn*: *float* => *int_of_float*(*float*)
};
```

通常情况下，将某个东西包裹在函数内部被称为**eta 抽象**。它是一种抽象，因为它增加了一层间接性，而不是直接返回一个值。换句话说，我们首先需要传入一个参数，该参数在函数体内部被替换，然后才能返回计算结果。

在某些情况下，eta 抽象是必要的。例如，我们之前的浮点转换器需要一个将 `float` 转换为 `float` 的方法，以便适应我们设置的类型。为此，eta 抽象 `float => float` 是完美的。然而，当它直接包裹单个函数调用时，eta 抽象是多余的，例如 `int => float_of_int(int)` 或 `output => Js.log(output)`。这是因为那个单个函数调用本身就是一个等价的 eta 抽象；它已经接受相同的参数并计算相同的结果。多亏了 Reason 函数是值，我们总是可以直接传递它们。

通常，当我们专注于编写所需的函数时，很容易忽略这些冗余。幸运的是，我们可以在稍后简化代码库时移除冗余的 eta 抽象，而不会改变代码的含义。

# 摘要

函数是 Reason 的重要组成部分，并且被广泛使用。本章重点介绍了它们的本质属性：引用透明性、纯净性和完备性。我们还讨论了与 Reason 函数相关的具体技术，例如柯里化和部分应用。

在下一章中，我们将探讨 Reason 支持的更多方法和技术，这些方法和技术有助于代码重用和通用编程。
