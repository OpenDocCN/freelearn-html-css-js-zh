# 第一章：模块及其优势是什么？

在本章的第一部分，我将为你提供有关应用程序开发中模块化设计方法的概述，特别是与 JavaScript 应用程序相关的内容。

我还将提及应用程序架构的模块化风格与这种概念设计的现实生活示例之间的相似之处。

希望在你阅读的过程中，你能够至少与模块化设计方法的一些方面产生共鸣，并开始看到为什么这种组织代码的风格可以极为有益。

本章的主要目标是为你创造一个熟悉的环境，并让你在创建和组织代码时开始以模块化的方式思考。很快，你就会发现这种方法可以自然地发展成为一套定义良好的应用程序架构方法。

我们将本章的开头部分用于简要讨论我们如何根据专业化来组织我们的代码。然后，我们将探讨如何根据它们提供的功能来定义模块。

本章涵盖的主题包括：

+   创建模块的简单规则

+   模块的实际生活示例

+   非模块化示例的审视

+   以更模块化的方式重构

+   以模块化方式进行设计

# 模块化编程的序言

多年前，当我上大学上第一门计算机编程课时，我发现自己在将代码组织成函数和类方面遇到了困难。我总是想知道我需要记住什么样的标准来判断一段代码是否属于一个函数、一个类或一个子类。我应该什么时候将一个函数分解成多个函数，或者将一个类分解成多个类？

当然，我熟悉一些规则和指南，例如“函数不应该太长或不应该做太多事情；类应该是一个数据类型的蓝图”等等。然而，这样的规则和指南对我来说似乎很抽象，我想要找到一个精确且适用于所有情况的规则。

随着我编程概念的深入和应用程序设计经验的增加，我能够编写更复杂的代码，并将我的代码更好地组织到函数和类中。

然而，尽管我的代码被组织成定义良好的函数和类，但这些函数和类在应用程序的不同部分仍然显得分散。当我需要修改应用程序的一部分时，我会担心这种变化会对其他部分以及整个应用程序的功能产生什么影响。

随着我的应用程序变得更大、更复杂，变化和改进的影响变得更加明显。如果应用程序的各个部分没有设计得当，会有更多的事情对应用程序产生不利影响。

基于浏览器的应用程序尤其容易受到这种影响，因为应用程序的不同部分可能会在浏览器中操作同一个元素，这会导致应用程序的其他部分出现意外的行为和效果。

另一方面，对应用程序进行小的改动本身就是一项挑战，因为找到进行这种小改动最佳位置并不总是非常明显。应用程序的每一部分都可能执行许多不同的活动，从操作 DOM 到写入 cookie，再到发起 AJAX 调用。

如果我能让应用程序的某一部分只负责一种功能类型会怎样？如果只有应用程序的一部分负责所有与 cookie 相关的功能会怎样？如果只有一部分会向服务器发起 AJAX 调用并提供其他应用程序部分返回的数据会怎样？

当我们设计函数和类以专门执行非常具体的任务时，我们也可以将这些函数和类捆绑在一起，作为专门的应用程序部分，负责提供特定的功能。关键点在于创建专门的代码包。

这意味着，我们对 cookie 的读写方式的变化只会发生在负责 cookie 操作的包中，这样的变化不会影响对服务器的 AJAX 调用方式。

如果我们将代码组织成专门的包（或者我们称之为模块），我们就可以轻松实现应用程序各个部分之间关注点和责任分离的目标。

但在我们能够将代码组织成模块之前，我们需要了解我们如何决定一块代码应该是一个模块。

# 创建模块的简单规则

我需要强调的是，模块化编程并不是某种难以掌握且难以实现的神奇和神秘的设计概念和模式。它实际上只是组织我们代码的一种实用方法，使得每一块代码只执行一个非常具体和专业的任务。

想法是，每个模块都是应用程序的一个松散耦合的部分，一个构建块，它与其他部分（和其他模块）一起创建了一个生态系统，即你的应用程序。

因此，这里有一个创建模块的简单规则：“如果你的应用程序的一部分提供了专门的功能，它可以被制作成一个模块，也可以在其他应用程序中重用。”

我之前提到，我在寻找一个“精确”的规则来帮助我组织应用程序代码，但正如我的经验所表明的，除了我上面提到的之外，没有这样的精确规则，而这实际上不是一个规则，而是一个指导方针。作为一个指导方针，在考虑一个模块或不是模块时有一定的灵活性。这最好在设计时间和应用程序演变过程中决定，因为应用程序的需求会随时间变化。

# 模块的真实生活示例

让我们考虑一个熟悉的模块化系统。你很可能在拥有电力并且周围墙壁上有许多电源插座的地方阅读这本书。这个系统使你能够将各种电器插入插座，而这些设备每一个都是设计来执行一个非常具体的任务的。

考虑插在这些插座中的电器：微波炉、电热水壶、洗衣机、烘干机等等。

这些设备都不在乎它们是否插在你家的电源插座或邻居家的电源插座上。它们被设计成在插入并接通电源时执行它们的具体任务和功能，无论它们在哪个房子里。

我们的应用程序模块应该遵循相同的理念。这意味着，无论它们在应用程序中的哪个位置插入，甚至无论它们插入到哪个应用程序中，它们都应该执行它们的具体任务，并且只执行它们的具体任务。

同样地，就像电器可以很容易地从墙上拔掉一样，代码模块也应该设计成可以轻松解耦并从你的应用程序中移除。

此外，由于移除一个电器不会影响你电系统中其他插上电器的功能，从你的应用程序中移除一个代码模块或一系列代码模块也不应该影响应用程序其他部分的功能。

这种解耦不应该对整个应用程序产生任何影响，除了可能只是失去由该特定模块或模块组在应用程序中提供的特定功能。

在这本书中，我们将探讨创建模块如何帮助我们设计更好的专用代码片段，这些代码片段可以轻松地插入和从我们的应用程序中拔出。我们还将看到模块化架构如何为整体提供更健壮和灵活的应用程序。

我们将发现这种类型的架构方法如何在许多方面为我们的应用程序基础带来巨大的优势，例如代码可用性、可维护性、可测试性以及更多。

我希望现在你已经足够好奇，至少考虑模块化编程，特别是 JavaScript 模块化编程，作为你未来应用程序设计的可能方法。

在接下来的章节中，我们将应用我们讨论过的关于电源插座和电器的相同原则，应用到我们的代码模块的设计和实现阶段。

# 看一个非模块化示例

让我们考虑一个非常简单的例子，看看这种（某种方式）**专业化的**模块化方法与非模块化方法有何不同。

我们首先以传统的方式编写几个函数，如下所示：

```js
function doAddition(num1, num2){
  return num1 + num2;
}

function doSubtraction(num1, num2){
  var result = null;
  if(num1 > num2){
  result = num1 - num2;

  }else{
    result = num2 - num1; 
  }
  return result;
}

console.log(doAddition(3,2)); // displays 5

console.log(doSubtraction(3,2)); // displays 1
```

如您在上面的代码中所见，我们有两个独立的功能用于执行简单的加法和减法，它们之间没有关系，除了它们都操作于传入的两个数字（数值）之外。

如果我们在一个应用程序中实现了这些功能，然后在不同的应用程序中执行相同的操作，我们很可能会要么在该应用程序中从头开始重新编写相同的函数，要么将此应用程序中的代码复制/粘贴到另一个应用程序中。

如果我们现在决定在应用程序中使用相同的方法进行乘法、除法和其他相关计算，那会怎样呢？

好吧，一种方法就是继续像上面那样编写独立的函数，并将它们添加到我们的应用程序中。这种方法可能可行，并且能够完成任务，但可能不是最佳方式，因为随着代码的增长，它将变得更加混乱和杂乱。

通过使用这种方法，我们不仅会将大量可能与其他同名全局函数冲突的全局函数污染全局命名空间。我们最终还会得到一些散乱的代码片段，这些代码片段没有根据其功能和专业性打包在一起。

如果所有这些函数都进行一种或多种数学计算，并且这是它们共有的共性，那么我们是否可以创建一个**包**（模块）来专门进行数学计算呢？

这将使我们能够拥有一个专门的包，无论它托管在哪个应用程序中，都会始终提供相同的专业功能。

让我们更进一步，假设我们在一个单独的 JavaScript 文件中创建了此包，该文件可以作为独立模块添加到任何应用程序中。

更好一点，如果这个模块只会在运行时添加（在客户端 Web 应用程序的情况下，从服务器请求）到应用程序中，并且只有在需要时才添加，那会怎样？

这种类型的实现将使我们能够在运行时根据需要加载代码的块、部分或模块，然后在应用程序不再需要它们时卸载它们。这将使我们能够减少应用程序在客户端的占用空间，同时按需提供所有必要的功能。

这种方法在带宽和资源有限的移动设备上也非常有用。

请放心，我确实打算在本书的后续章节中与您探讨所有这些可能性。

# 重构为更模块化的方法

让我们考虑重构之前查看的两个函数，并将它们组合在一个更专业的包（类或模块）中，称为`CalculationHandler`，如下所示：

```js
function CalculationHandler(){
  CalculationHandler.result = null;
}

CalculationHandler.doAddition = function(num1, num2){
  return num1 + num2;
};

CalculationHandler.doSubtraction = function(num1, num2){

  if(num1 > num2){
    CalculationHandler.result = num1 - num2;

  }else{
    CalculationHandler.result = num2 - num1; 
  }
  return CalculationHandler.result;

};

console.log(CalculationHandler.doAddition(3,2)); // displays 5
console.log(CalculationHandler.doSubtraction(3,2)); // displays 1
```

正如你在“模块”中可以看到的（我在这里使用这个术语比较宽松；你将在后面的章节中看到原因），我正在使用一个函数对象，并向这个对象添加属性（方法）。这些方法执行与对象（模块）的整体功能相关的特定任务，例如加法和减法。

### 注意

**关于我们模块的注意事项**

如果你更熟悉 JavaScript 编程，你可能认为我创建这个模块的方式可能不是在 JavaScript 中创建真实模块的最佳方式，你是对的！但就目前而言，这里的主要思想是，任何执行特定任务的代码片段都可以被标记为模块，在大多数情况下。

然而，在 JavaScript 中编写更健壮和可扩展的模块肯定有更好的方法。例如，通过使用**模块设计模式**（Module Design Pattern）来创建模块可以做得更好，我们将在本书的后续章节中深入探讨这一点。

# 以模块化的方式进行设计

在设计应用的早期阶段，最重要的步骤之一是确定应用需要提供的功能。这当然基于应用的整体目的和你要设计的应用类型。

根据这样的要求，在设计阶段，你应该尝试将应用的整体功能（大局）分解成更小、更专业的部分。然后，你可以确定这些部分是否已经存在，无论是以第三方库的形式还是以你为其他应用编写的代码的形式。

如果你已经以模块化的方式设计了自己的可重用代码块（大多数第三方库也是这样设计的），那么将这些部分连接起来并在新应用中使用它们将会容易得多，也快得多。这就像把各种乐高积木组合起来创建一个游乐结构一样。

这种方法非常重要，并且非常适合**敏捷**开发环境。这使你能够在需要时以及当新的应用需求被定义时，工作在定义良好、专业的模块上。此外，当你基于模块创建代码时，你能够防止应用各个部分之间出现紧密耦合。

另一方面，这种方法允许不同的开发者独立地工作在相同应用的各个部分（模块）上。另一个优点是，模块可以在被添加到应用之前单独并在不同的环境中进行测试。

随着时间的推移和更多在模块化应用设计和实现方面的经验，你将更好地决定如何区分和设计你的模块。然而，认为你可以在第一次尝试中就提出应用中可能需要的所有模块的完整列表是不现实的。

这是因为应用程序会发展，需求会随时间变化。你可能需要创建新的模块，或修改现有的模块，或者决定使用不同的模块或库来适应需求的变化。

模块化设计的关键优势是它提供的灵活性。在模块化架构中处理上述所有情况要容易得多，并且需要付出更少的努力。它还将减轻添加、删除或修改模块可能对整个应用程序产生的影响。

在接下来的章节中，你将看到我们如何创建简单和复杂的模块，以及它们将以松散耦合的方式添加到我们的应用程序中。

你还将看到我们如何在需要时动态和按需加载这些模块到我们的应用程序中。

因此，让我们为进入未来应用程序设计的激动人心的旅程做好准备，使用模块化架构。

# 摘要

在本章中，我们试图概述模块化编程背后的概念，以及这些概念如何在 JavaScript 应用程序中特别使用。

我们看到，这种方法本质上基于创建执行非常特定任务的专用代码包。

我们还比较了现实生活中模块的设计方式以及我们的应用程序模块，以便将相似之处转化为我们自己的应用程序设计方法。

虽然术语“模块”可以在代码中指代不同的事物，但我们将在后续章节中将这个术语用于指代我们 JavaScript 应用程序设计方法中的一种编程和架构风格。

然而，在我们完全深入 JavaScript 模块化编程的更技术方面之前，回顾下一章中 JavaScript 面向对象编程的基础知识是个好主意。这将为我们前进过程中更技术性的章节建立一个坚实的基础。
