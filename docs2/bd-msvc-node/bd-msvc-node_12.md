# 12

# 使用 Saga 模式、加密和安全措施确保数据安全

当使用微服务架构和 Node.js 时，你需要更好地理解使用 Saga 模式确保数据安全，并了解加密和安全措施。

我们将首先通过理解如何使用 Node.js 中的 Saga 模式、加密和安全措施来确保微服务中的数据安全来开始本章。在设计和实现微服务时，Saga 模式、数据加密和安全都是需要考虑的重要方面。Saga 模式是一种用于管理跨多个微服务的分布式事务的技术。

到本章结束时，你将学会如何使用 Saga 模式、加密和 Node.js 中的安全措施来确保数据安全。

本章中，我们将涵盖以下主要内容：

+   补偿操作和 Saga 协调

+   事件驱动通信和 Sagas 及状态

+   传输层安全（TLS）和静态数据加密

+   加密算法和密钥管理

+   认证、授权、输入验证、安全编码实践和 API 速率限制

在下一节中，我们将学习如何处理补偿操作和 Saga 协调。补偿操作和 Saga 协调都是微服务架构中使用的概念。

# 补偿操作和 Saga 协调

微服务通常需要在多个服务之间具有事务行为。补偿操作和 Saga 协调是与 Saga 模式相关的两个概念，后者是一种在分布式事务场景中管理微服务间数据一致性的方法。

## 补偿操作

**补偿操作**用于在微服务架构中撤销失败操作的影响。当操作由多个最终一致性的步骤组成时，通常需要补偿操作，这意味着系统可能处于不一致状态，直到所有步骤都完成。如果其中一个或多个步骤失败，系统应通过应用补偿操作来撤销之前步骤所做的更改，以恢复到一致状态。例如，如果操作涉及预订酒店房间、预订航班和扣款信用卡，而航班预订失败，补偿操作将是取消酒店预订并退还信用卡。补偿操作通常作为由错误或超时触发的单独事务实现。它们也可以是幂等的，这意味着它们可以多次执行而不改变结果。

与在单体系统中可以使用传统数据库事务不同，在分布式系统中，每个微服务可以有自己的数据库，这是不可能的。

让我们看看补偿操作最常见的一个用例。在微服务中，当复杂事务涉及跨不同服务的多个步骤，并且在任何一点发生故障时，补偿操作至关重要。而不是回滚整个事务，补偿操作被触发以撤销事务期间所做的更改。

例如，考虑一个电子商务系统，其中用户下单，涉及多个微服务（订单创建、库存扣除、支付处理）。如果支付失败，补偿操作可能包括取消订单、恢复库存和向用户退款。

以下是对补偿操作的一些关键考虑因素：

+   **幂等性**：补偿操作必须设计成幂等的，确保多次执行与单次执行具有相同的效果。

+   **原子性**：每个补偿操作应该是原子的，并且与其他操作独立，以确保正确处理。

**补偿操作失败场景**是指在微服务中，补偿操作本身失败或未能正确执行的情况。这可能导致数据不一致、资源泄漏或业务逻辑错误。以下是一些失败场景的例子：

+   **网络故障**：如果服务之间的网络连接不可靠或缓慢，补偿操作可能无法到达目标服务或可能延迟。这可能导致补偿操作的局部或重复执行，导致数据损坏或不一致。

+   **服务故障**：如果在执行补偿操作期间目标服务不可用或崩溃，补偿操作可能无法完成或可能被回滚。这可能导致系统处于不一致状态或造成资源泄漏。

+   **业务逻辑失败**：如果补偿操作违反某些业务规则或约束，补偿操作可能会失败或产生不希望的结果。例如，如果补偿操作试图取消已经入住的酒店预订，补偿操作可能会失败或产生罚款。

+   **数据冲突**：如果补偿操作试图修改的数据已被其他并发操作更改，补偿操作可能会失败或覆盖新数据。这可能导致数据丢失或不一致。

为了处理这些失败场景，以下是一些可能的解决方案：

+   **重试机制**：在出现暂时性故障或网络延迟的情况下，补偿操作可以重试一定次数或直到达到超时。重试机制还应处理幂等性和并发问题，例如使用唯一标识符或版本号来避免重复或冲突的更新。

+   **回退机制**：补偿行为可以有一个回退选项，提供撤销原始操作的一种替代方式，以防永久性故障或服务不可用。回退机制还应确保数据一致性和业务逻辑正确性，例如使用人工流程或第三方服务来执行补偿行为。

+   **补偿链**：在失败的情况下，补偿行为可以触发另一个补偿行为，形成一个补偿链，最终将系统恢复到一致状态。补偿链还应避免循环依赖和无限循环，例如使用终止条件或最大深度限制来停止链。

在这种情况下，补偿事务会提供帮助。它们是在失败时撤销先前操作的一种方式。例如，如果你正在创建一个订单并从库存中扣除了一个项目，但由于某些原因支付服务失败，你将想要补偿扣除的项目并将其重新添加到库存中。这种撤销操作就是补偿行为。

我们已经学习了补偿行为的基础知识，现在，让我们继续学习 Saga 编排。

## Saga 编排

**Saga**是一种管理跨多个微服务的交易的设计模式。**Saga 编排**是实施 Saga 模式的一种特定方式。在这种方法中，一个中心服务（“协调器”）管理交易的步骤顺序，并告诉每个服务何时执行其部分。它还处理失败情况，并在必要时触发补偿行为。这种方法的优点是简化了错误处理，因为 Saga 编排是集中的，并且在整个交易中提供一致性。然而，这也导致了对协调器服务的依赖，这可能会成为瓶颈。

Saga 编排最常见的使用场景是在业务流程跨越多个微服务的情况下，此时一个 Saga 确保流程中的每一步要么完全完成，要么在失败时得到补偿。

例如，在电子商务系统的背景下，一个 Saga 可能涉及多个步骤：创建订单、扣除库存、处理支付和发货。如果任何步骤失败，将触发补偿行为以撤销之前步骤所做的更改。

Saga 模式有两种类型：

+   **编排**：在基于编排的 Sagas 中，每个参与的微服务都知道如何启动其 Sagas 的部分并与他人通信以实现整体业务流程。

+   **编排**：在基于编排的 Sagas 中，有一个中心组件（协调器）负责协调 Sagas 中步骤的顺序，指导微服务何时执行其部分。

两种方法都有其优点和缺点，这取决于系统的复杂性、可靠性和可伸缩性。

以下是一些关于 Saga 编排的关键考虑因素：

+   **Sagas 与事务的比较**：Sagas 与传统**ACID**（**原子性**、**一致性**、**隔离性**、**持久性**）事务不同，因为它们侧重于分布式和长时间运行的过程，而不是短暂、隔离的事务。

+   **补偿事务**：补偿失败的能力是 Sagas 的关键方面，确保即使在单个步骤失败的情况下，系统也能保持一致性。

Saga 编排是一种在分布式事务场景中管理跨微服务数据一致性的技术。它使用中央协调器来执行和补偿事务。

Saga 可能会遇到以下挑战：

+   **一致性**：确保即使在出现故障的情况下，系统也能保持一致性。为了解决这个问题，Saga 可以使用版本控制、锁定或时间戳等技术来防止或解决数据冲突。

+   **持久性**：处理在叙事的不同点系统失败的场景，并确保状态可恢复。为了解决这个问题，Saga 可以使用重试、超时、断路器或补偿事务等技术从失败中恢复并恢复数据一致性（[`research.aimultiple.com/facial-recognition-challenges/`](https://research.aimultiple.com/facial-recognition-challenges/)）。

+   **复杂性**：实现和管理 Sagas 引入了复杂性，需要适当的工具和模式。为了解决这个问题，Saga 可以使用支持 Sagas 模式的工具和框架，如 Axon、Eventuate 或 Camunda。

通常，这两个概念都用于确保数据一致性并处理分布式系统环境中的故障。还应注意，选择方法取决于您应用程序的具体需求和团队能力。两者都有其优点和权衡。

这里有一些 Node.js 中电子商务的示例 Saga 编排代码（分为代码块）。

让我们一步一步来，从使用默认依赖和常量的服务初始化开始：

```js
// Orchestator service
const express = require('express');
const KafkaBroker = require('./kafkaHandler/kafkaBroker');
const app = express();
const port = 3000;
// Kafka producer and consumer
const kafkaBroker = new KafkaBroker();
const producer = kafkaBroker.getProducer();
const consumer = kafkaBroker.getConsumer();
// Order state
const orderState = {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};
// Order database (mock)
const orders = {};
```

接下来，我们将创建具有其功能的 API 端点：

```js
// Create a new order
app.post('/order', (req, res) => {
  // Generate a random order ID and get the order details
  const orderId = Math.floor(Math.random() * 10000);
  const order = req.body;
  // Set the order status to pending and save it
  order.status = orderState.PENDING;
  orders[orderId] = order;
  // Send a message to the order service to start the saga
  producer.send([{
    topic: 'order',
    messages: JSON.stringify({
      type: 'ORDER_CREATED',
      payload: {
        orderId: orderId,
        order: order
      }
    })
  }]);
  // Return the order ID and status
  res.json({
    orderId: orderId,
    status: order.status
  });
});
```

使用以下代码块，我们可以处理来自订单服务的消息：

```js
// Handle the messages from the order service
consumer.on('message', (message) => {
  // Parse the message value and get the event type and payload
  const event = JSON.parse(message.value);
  const { type, payload } = event;
  // Get the order ID and order from the payload
  const { orderId, order } = payload;
  // Find the order in the database
  const currentOrder = orders[orderId];
  // Check if the order exists and is not already cancelled
  if (currentOrder && currentOrder.status !== orderState.CANCELLED) {
    // Handle the event type
    switch (type) {
      // The order service has approved the order
      case 'ORDER_APPROVED':
        // Set the order status to approved and send a message to the payment service
        currentOrder.status = orderState.APPROVED;
        producer.send([{
          topic: 'payment',
          messages: JSON.stringify({
            type: 'PAYMENT_REQUESTED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        break;
      // The order service has rejected the order
      case 'ORDER_REJECTED':
        // Set the order status to rejected
        currentOrder.status = orderState.REJECTED;
        break;
      // The payment service has charged the payment
      case 'PAYMENT_APPROVED':
        // Send a message to the stock service to reserve the items
        producer.send([{
          topic: 'stock',
          messages: JSON.stringify({
            type: 'STOCK_REQUESTED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        break;
      // The payment service has failed to charge the payment
      case 'PAYMENT_REJECTED':
        // Send a message to the order service to reject the order
        producer.send([{
          topic: 'order',
          messages: JSON.stringify({
            type: 'ORDER_REJECTED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        break;
      // The stock service has reserved the items
      case 'STOCK_APPROVED':
        // The saga is completed successfully
        console.log('Saga completed successfully');
        break;
      // The stock service has failed to reserve the items
      case 'STOCK_REJECTED':
        // Send a message to the payment service to refund the payment
        producer.send([{
          topic: 'payment',
          messages: JSON.stringify({
            type: 'PAYMENT_REFUNDED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        // Send a message to the order service to reject the order
        producer.send([{
          topic: 'order',
          messages: JSON.stringify({
            type: 'ORDER_REJECTED',
            payload: {
              orderId: orderId,
              order: order
            }
          })
        }]);
        break;
      default:
        // Unknown event type
        console.error('Unknown event type:', type);
    }
  } else {
    // The order is not found or already cancelled
    console.error('Order not found or already cancelled:', orderId);
  }
});
```

最后，我们将在所选端口上启动服务器：

```js
// Start the server
app.listen(port, () => {
  console.log(`Orchestrator service listening at http://localhost:${port}`);
});
```

此代码的输出取决于输入以及在顺序处理叙事中的事件顺序。该代码是一个使用 Kafka 作为消息代理以协调订单、支付和库存服务的 Node.js 编排服务示例。代码定义了以下步骤：

+   当创建新订单时，编排服务分配一个随机订单 ID，将订单状态设置为`pending`，将其保存在模拟数据库中，并向订单服务发送消息以启动 Saga。

+   当编排服务从订单服务接收到消息时，它会检查事件类型和订单 ID，并在数据库中找到相应的订单。如果订单存在且尚未取消，它将根据事件类型执行以下操作：

    +   如果订单服务已批准订单，编排服务将订单状态设置为`approved`并向支付服务发送消息请求支付。

    +   如果订单服务已拒绝订单，编排服务将订单状态设置为`rejected`并不再执行其他操作。

    +   如果支付服务已收取支付，编排服务向库存服务发送消息以预留商品。

    +   如果支付服务未能收取支付，编排服务向订单服务发送消息以拒绝订单。

    +   如果库存服务已预留商品，编排服务记录 Sagas 成功完成并不再执行其他操作。

    +   如果库存服务未能预留商品，编排服务向支付服务发送消息以退款并向订单服务发送消息以拒绝订单。

+   如果事件类型未知，编排服务记录错误并不再执行其他操作。

+   如果找不到订单或订单已被取消，编排服务记录错误并不再执行其他操作。

代码还定义了一个创建新订单的路由和一个启动服务器的监听器。此代码的输出将是控制台日志和编排服务发送或接收的 JSON 响应。

*图 12.1*展示了 Sagas 编排：

![图 12.1：Sagas 编排（图片由 Freepik 提供）](img/B14980_12_01.jpg)

图 12.1：Sagas 编排（图片由 Freepik 提供）

总结来说，补偿操作和 Sagas 编排是微服务架构中的关键模式，使得设计健壮和有弹性的分布式系统成为可能。它们提供了在传统 ACID 事务不适用的情况下处理故障和维护数据一致性的机制。

理解了这些概念后，我们现在转向事件驱动通信和 Sagas 以及状态。

# 事件驱动通信和具有状态的 Sagas

事件驱动通信和 Sagas 以及状态指的是软件和系统开发概念，尤其是在微服务架构领域。

## 事件驱动通信

**事件驱动通信**是一种软件组件之间的通信范式，其中一个组件改变其状态并向其他组件发出事件以通知它们。这种通信模型的优势在于它有助于减少系统连接性并增强反应性、可扩展性和灵活性。

事件驱动通信的一个用例是在微服务分布式系统中，事件驱动通信对于松耦合服务和实现异步、实时交互非常有价值。

例如，在一个电子商务系统中，当用户下单时，会触发 `OrderPlaced` 事件。**库存服务**和**支付服务**等感兴趣的相关方可以订阅此事件并采取适当的行动。

以下事件驱动通信的关键特性：

+   **发布者和订阅者**：当生成事件时，微服务充当发布者；当对感兴趣的事件做出反应时，充当订阅者。

+   **解耦**：事件驱动通信促进了微服务之间的松散耦合，使它们能够独立演进。

事件驱动通信是一种基于事件的数据交换方式，这些事件是代表系统状态变化的离散消息。

以下展示了事件驱动通信的挑战：

+   **最终一致性**：由于事件异步处理，确保微服务之间的最终一致性可能具有挑战性。为了解决这个问题，事件驱动通信可以使用版本控制、锁定或时间戳等技术来防止或解决数据冲突。

+   **消息顺序**：在特定场景中，保持事件的正确顺序至关重要。

以下是一个使用 Node.js 内置的 `http` 模块和 `EventEmitter` 类的事件驱动通信的简单示例：

```js
// Import the http and events modules
const http = require('http');
const EventEmitter = require('events');
// Create a custom event emitter class
class MyEmitter extends EventEmitter {}
// Create an instance of the custom event emitter
const myEmitter = new MyEmitter();
// Define an event listener for the 'hello' event
myEmitter.on('hello', (name) => {
  console.log('Hello, ' + name);
});
// Create a simple web server
const server = http.createServer((req, res) => {
  // Get the query parameter from the request URL
  const url = new URL(req.url, 'http://localhost:3000');
  const name = url.searchParams.get('name');
  // Emit the 'hello' event with the query parameter as the argument
  myEmitter.emit('hello', name);
  // Send a response to the client
  res.end('Event emitted');
});
// Start the server on port 3000
server.listen(3000, () => {
  console.log('Server listening on port 3000');
});
```

事件驱动通信是一种范式，其中微服务通过生成和消费事件相互通信。事件代表微服务生态系统中的状态变化或事件。

学习了这些概念后，我们可以继续学习 Saga 和状态。

## 有状态的 Saga

在微服务的上下文中，**有状态**的 **Saga** 指的是一个涉及一系列步骤的长期运行的业务流程（Saga），每个步骤都有其关联的状态。Saga 的状态决定了下一步要采取的行动。

Saga 和状态的一个常见用例是在涉及多个微服务和多个步骤及其关联状态的复杂业务流程中。

以下是一个 Saga 和状态的示例。考虑预订航班的流程。Saga 可能涉及选择座位、支付和确认等步骤。Saga 的状态（例如，`SeatSelected`、`PaymentProcessed`）决定了流程中的下一步。

它的一些关键特性如下：

+   **有状态步骤**：在 Saga 中，每个步骤都维护其状态，整个 Saga 的进展基于这些状态的组合。

+   **补偿操作**：如果发生故障，将执行补偿操作以撤销先前步骤的影响。

+   **协调**：需要协调以确保步骤按正确的顺序执行。

Saga 和状态是微服务架构中的两个重要概念。

以下是对 Saga 和状态的挑战：

+   **状态管理**：管理和持久化 Saga 的状态对于可靠性至关重要。

+   **补偿逻辑**：为每个步骤设计和实施补偿措施需要仔细考虑。

总结来说，在微服务架构中，Sagas 用于管理跨越多个服务的交易。每个 Sagas 代表一个高级业务交易，涉及需要在多个服务中执行的多步操作。它管理和监督这些过程，确保它们要么全部成功，要么在失败时进行补偿交易，以保持服务之间的数据一致性。状态通常指软件组件在其生命周期中维护的信息。这可能涉及用户信息、系统配置或其他操作关键数据。

现在，我们可以继续到下一节，我们将讨论 TLS 和静态数据加密。

# 传输层安全（TLS）和静态数据加密

**传输层安全**（**TLS**）是一种协议，为两个通信应用程序之间提供隐私和数据完整性。静态数据加密是将存储在数据库、文件系统或磁盘存储中的数据进行编码和加密的过程。相比之下，运动中的数据通常由网络协议（如 TLS）保护。

## TLS

**TLS**是一种加密协议，确保计算机网络上的安全通信。它被广泛用于保护客户端和服务器之间的数据传输，防止窃听、篡改和伪造。

TLS 的一个重要用例是在微服务中，其中 TLS 对于在网络中保护服务之间的通信至关重要。它通过在传输过程中加密数据来建立安全通道。

要实现 TLS，每个微服务都可以配置为支持**HTTPS**，这是 HTTP 的安全版本。TLS 证书用于加密通信通道，并且可以实现**双向 TLS**（**mTLS**）以进行服务到服务的认证。

以下是对 TLS 的关键考虑因素：

+   **加密**：TLS 确保微服务之间传输的数据被加密，防止未经授权的访问。

+   **认证**：mTLS 通过要求双方相互认证，增加了额外的安全层，增强了整体的安全态势。

+   **证书和公钥基础设施（PKI）**：证书和 PKI 是相关概念，它们使互联网上的安全认证通信成为可能。证书是一个包含有关用户、设备或服务身份信息以及可用于加密和数字签名的公钥的数字文档。PKI 是一个系统，它使用称为**证书颁发机构**（**CAs**）的受信任实体来管理证书的创建、分发、验证和撤销。PKI 确保证书有效且可信，并且公钥与正确的所有者相关联。

+   **TLS 握手**：TLS 握手是一个过程，它通过互联网在客户端和服务器之间建立安全且加密的连接。

TLS 是一种提供互联网上安全可靠通信的协议。

TLS 面临的一些挑战如下：

+   **证书管理**：正确管理 TLS 证书，包括颁发、续订和吊销，至关重要。一些解决方案是使用集中化和自动化的证书管理解决方案，该解决方案可以跨网络发现、盘点、监控、续订和吊销证书。

+   **性能开销**：虽然开销很小，但 TLS 中的加密和解密过程引入了一些计算负载。一种解决方案是使用最新的 TLS 版本（TLS 1.3），它比之前的版本提供更快、更安全的连接。

+   **算法灵活性**：算法灵活性是指在不影响系统功能或安全性的情况下更改或替换加密算法的能力。它是更广泛的概念——适应加密领域变化的加密敏捷性的一个重要方面。算法灵活性可以帮助缓解 TLS 的挑战，TLS 是一种提供互联网上安全认证通信的协议。

+   **私钥安全**：TLS 上私钥的安全性是一个关于如何保护用于建立和确保 TLS 连接的加密密钥的问题。私钥是用于使用相应公钥解密数据的秘密密钥。如果私钥被泄露，攻击者可以拦截、修改或冒充 TLS 流量，导致数据泄露、身份盗窃或**中间人攻击**（MitM）。

*图 12.2*展示了 TLS：

![图 12.2：TLS（图片由 Freepik 提供）](img/B14980_12_02.jpg)

图 12.2：TLS（图片由 Freepik 提供）

TLS 用于创建安全的网络浏览、电子商务和其他类型互联网流量的环境。它是通过加密客户端和服务器之间发送的数据来实现的，从而防止潜在的窃听者获取敏感信息。

我们现在可以继续讨论静态数据加密。

## 静态数据加密

静态数据加密涉及在数据库、文件系统或任何其他持久存储中存储数据时的数据安全。即使物理存储介质被破坏，它也能防止未经授权的数据访问。

在微服务中，静态数据加密对于保护存储在数据库或其他持久存储解决方案中的敏感信息至关重要。

要实现静态数据加密，使用加密算法在数据存储之前对其进行加密。这可以在应用层完成，或者通过利用数据库或存储系统提供的功能来实现。

在静态数据加密方面，以下是一些关键考虑因素：

+   **密钥管理**：适当的密钥管理对于确保加密密钥安全存储和管理至关重要。

+   **粒度加密**：根据敏感度，考虑加密特定的字段或列而不是整个数据集，以获得更好的性能。

静态数据加密是保护存储在物理介质上（如磁盘或磁带）的数据免受未经授权的访问或盗窃的过程。

以下是对静态数据加密的挑战：

+   **密钥生命周期管理**：管理加密密钥的生命周期，包括生成、轮换和销毁，可能很复杂。一种解决方案是使用集中式和自动化的证书管理解决方案，该解决方案可以跨您的网络发现、库存、监控、续订和吊销证书。

+   **性能影响**：对静态数据进行加密和解密可能会引入一些性能开销，这需要考虑。一种解决方案是使用最新版本的 TLS（TLS 1.3），它比之前的版本提供更快、更安全的连接。

使用静态数据加密，即使未经授权的方获得了对物理存储的访问权限，没有加密密钥，数据也将无法读取。这个过程对于确保存储在数字形式时个人或敏感信息的安全至关重要。结合这些技术可以在传输和存储敏感数据时提供全面的安全保障。

总结来说，实施 TLS（传输中的数据）和静态加密提供了一种分层的安全方法，在整个微服务架构的生命周期中保护数据。了解安全最佳实践并基于不断发展的威胁和技术持续监控和调整安全措施是至关重要的。

在下一节中，我们将学习关于加密算法和密钥管理的内容。

# 加密算法和密钥管理

加密算法和密钥管理是信息安全的关键组成部分。

## 加密算法

**加密算法**是将数据转换为只有授权方才能解密的秘密代码的方法。

存在多种加密算法，包括以下几种：

+   **对称算法**：使用相同的密钥进行加密和解密数据。例如包括**高级加密标准**（**AES**）、**数据加密标准**（**DES**）、**三重 DES**（**3DES**）、Blowfish 和**Rivest Cipher 4**（**RC4**）。以下是每种算法的简要概述：

    +   **AES**是对称加密的当前标准，这意味着使用相同的密钥进行加密和解密数据。AES 可以使用不同的密钥大小，如 128 位、192 位或 256 位，并操作 128 位的数据块。AES 被认为非常安全和高效，在各种应用和协议中广泛使用，如 HTTPS、VPN 和 Wi-Fi。

    +   **DES** 是 AES 的前身，是第一个对称加密标准。DES 使用 56 位密钥，操作 64 位数据块。由于密钥大小太小，DES 已不再被认为是安全的，可以通过暴力攻击破解。DES 于 2005 年正式撤消为标准。

    +   **3DES** 是 DES 的一个变体，它使用不同的密钥三次应用 DES 算法，有效地将密钥大小增加到 112 或 168 位。3DES 比 DES 更安全，但仍然存在一些漏洞，例如其小的块大小和较慢的性能。3DES 仍在一些遗留系统中使用，但不推荐用于新应用。

    +   **Blowfish** 是 Bruce Schneier 设计的一种对称加密算法，作为 DES 的替代方案。Blowfish 可以使用可变密钥大小，高达 448 位，并操作 64 位数据块。Blowfish 被认为是安全且快速的，但尚未被广泛采用为标准。Blowfish 主要用于一些软件应用中，例如密码管理器和文件加密工具。

    +   **RC4** 是 Ron Rivest 设计的一种对称加密算法，作为流密码，这意味着它一次加密 1 位或 1 字节的数据，而不是块。RC4 可以使用可变密钥大小，高达 256 位，非常简单且快速。然而，RC4 已被发现存在几个弱点和漏洞，不再被认为是安全的。RC4 曾在许多协议中使用，如 **安全套接字层**（**SSL**）、TLS 和 **有线等效隐私**（**WEP**），但已被弃用或被较新的算法取代。

+   **非对称算法**：使用不同的密钥来加密和解密数据。

加密算法广泛用于保护传输中和静止中的数据，例如在线通信、网络交易和云存储。让我们更详细地看看这些：

+   **对称加密**：对称加密使用单个密钥进行加密和解密。它速度快，适合大量数据。以下是一个用例和示例算法：

    +   *用例*：保护微服务架构中传输中的数据。

    +   *示例* *算法*：AES。

+   **非对称加密**：非对称加密使用一对公钥和私钥。用其中一个密钥加密的数据只能由这对密钥中的另一个密钥解密。以下是一个用例和示例算法：

    +   *用例*：安全交换用于对称加密的秘密密钥。

    +   *示例算法*：**Rivest-Shamir-Adleman**（**RSA**）。

+   **散列函数**：散列函数将可变大小的输入（散列值）转换为固定大小的输出。它们用于完整性验证。以下是一个用例和示例算法：

    +   *用例*：验证数据的完整性或创建数字签名。

    +   *示例算法*：**安全散列算法** **256 位**（**SHA-256**）。

+   **椭圆曲线密码学 (ECC)**：ECC 使用椭圆曲线的数学来提供与传统非对称算法相比具有更短密钥长度的强大安全性。以下是一个用例和示例算法：

    +   *用例*：在资源受限环境中进行高效的非对称加密。

    +   *示例算法*：**椭圆曲线** **Diffie-Hellman** (**ECDH**)。

*图 12**.3* 展示了加密算法：

![图 12.3：加密（图片由 macrovector 在 Freepik 提供）](img/B14980_12_03.jpg)

图 12.3：加密（图片由 Freepik 上的 macrovector 提供）

您需要掌握这些概念以更好地进行数据加密。

现在，我们可以继续讨论密钥管理。

## 密钥管理

**密钥管理**涉及加密密钥和其他相关密钥材料的整个生命周期。在微服务中的密钥管理是生成、存储、轮换和吊销用于保护微服务之间数据和通信的加密密钥的过程。让我们更详细地看看这一点，以及一些最佳实践和注意事项的示例：

+   **密钥生成**：密钥生成是创建用于密码学的密钥的过程。密钥用于加密和解密数据，以确保只有授权方可以访问它。

    +   *最佳实践*：使用密码学安全的随机数生成器来创建强大的密钥。

    +   *注意事项*：密钥长度和算法选择影响安全性。通常，较长的密钥提供更强的安全性。

+   **密钥存储**：密钥存储是将加密密钥安全且可供授权方访问的过程。加密密钥用于保护数据和通信免受未经授权的访问或盗窃。

    +   *最佳实践*：安全存储加密密钥，避免在源代码或配置文件中硬编码它们。

    +   *注意事项*：利用 **硬件安全模块** (**HSM**) 以增强密钥保护。

+   **密钥分发**：密钥分发是将加密密钥交付给希望交换安全加密数据的各方的过程。加密密钥用于保护数据和通信免受未经授权的访问或盗窃。

    +   *最佳实践*：在不对称加密场景中安全地分发密钥。使用如 **Diffie-Hellman** 的密钥交换协议。

    +   *注意事项*：在密钥交换期间防止中间人攻击。中间人攻击是一种网络攻击，攻击者秘密拦截并修改两个认为他们正在直接交谈的当事人之间的通信。

+   **密钥轮换**：密钥轮换是定期更改加密密钥的过程，以降低密钥被泄露或暴露的风险。

    +   *最佳实践*：定期轮换密钥以最大限度地减少泄露密钥的影响。

    +   *注意事项*：协调微服务之间的密钥轮换以避免中断。

+   **密钥吊销**：密钥吊销是宣布一个加密密钥不再有效且不应用于加密或解密的过程。

    +   *最佳实践*：实施吊销受损密钥的流程。

    +   *注意事项*：如果怀疑出现泄露，应迅速吊销并更换密钥。

+   **密钥管理**：密钥管理是安全且高效地管理数字授权凭证的创建、轮换、吊销和存储的过程。

    +   *最佳实践*：使用专门的密钥管理解决方案，以安全地存储、检索和轮换密钥及其他敏感信息。

    +   *注意事项*：与支持密钥生命周期管理的解决方案集成。

+   **监控和审计**：监控和审计是两个相关但不同的过程，对于确保组织运营、系统和数据的有效性和合规性至关重要。

    +   *最佳实践*：实施对密钥使用的稳健监控和审计。

    +   *注意事项*：检测并响应异常或不授权的密钥访问。

+   **加密灵活性**：加密灵活性是指系统在不会干扰系统功能或安全性的情况下，在不同的加密算法、密钥和参数之间切换的能力。

    +   *最佳实践*：设计具有加密灵活性的系统，以促进新算法或密钥长度的采用。

    +   *注意事项*：关注密码学的发展动态，并准备好过渡到更强的算法。

密钥管理很重要，因为如果密钥被泄露，受这些密钥保护的数据也会受到损害。因此，**密钥管理系统**（**KMSs**）旨在防止密钥泄露。

总结来说，加密算法和密钥管理是微服务安全的基础元素。选择合适的算法并实施合理的密钥管理实践对于保护敏感信息和确保微服务架构的整体安全性至关重要。

现在，让我们进入下一节，我们将讨论身份验证和授权、输入验证、安全编码实践和 API 速率限制。

# 身份验证、授权、输入验证、安全编码实践和 API 速率限制

在本节中，我们将讨论一些安全软件开发和 API 管理的核心原则。

## 身份验证

**身份验证**是验证用户、设备或系统身份的过程。它通常涉及用户名和密码，但可以包括任何其他证明身份的方法，例如生物识别。

身份验证的最佳实践如下：

+   使用强认证机制，如**开放授权 2.0**（**OAuth 2.0**）或**JSON Web 令牌**（**JWT**）。

+   实施额外的**多因素认证**（**MFA**）以提高安全性。

+   在可能的情况下，将身份验证集中到专用服务。

以下是一些关于身份验证的关键考虑因素：

+   确保凭证的安全传输。

+   定期审计和监控身份验证日志。

认证是在授予对机密数据或系统访问权限之前验证用户或进程身份的过程。

*图 12.4* 展示了认证和授权：

![图 12.4：授权和认证（图片由 vectorjuice 在 Freepik 提供）](img/B14980_12_04.jpg)

图 12.4：授权和认证（图片由 vectorjuice 在 Freepik 提供）

## 授权

一旦验证了用户的身份，**授权**将确定用户拥有的权限——即他们被允许做什么。这可能包括访问某些文件、执行某些功能等。

以下是一些授权的最佳实践：

+   采用**最小权限**（**PoLP**）原则。

+   使用**基于角色的访问控制**（**RBAC**）进行细粒度授权。

+   定期审查和更新访问权限。

授权的一些关键考虑因素如下：

+   实施适当的会话管理。

+   使用**基于属性的访问控制**（**ABAC**）进行更动态的授权。

授权是根据请求者的身份和权限授予或拒绝访问资源的过程。授权可以应用于不同类型的资源，如文件、数据库、网络或应用程序。

## 输入验证

这是一个确保在处理之前，输入到应用程序或 API 中的数据有效且安全的过程。这有助于防止 SQL 注入攻击或数据损坏。

以下是一些输入验证的最佳实践：

+   在客户端和服务器端验证和清理所有用户输入。

+   使用参数化查询来防止 SQL 注入。

+   在前端和后端组件上应用输入验证。

输入验证的一些关键考虑因素如下：

+   实施白名单验证，仅接受已知和预期的输入。

+   定期更新和修补组件以解决已知漏洞。

输入验证是检查用户输入到网站或应用程序中的数据的过程，以确保其正确、完整和安全。

## 安全编码实践

这些是编写代码时避免常见安全漏洞的指南或标准。这可能包括正确处理错误、使用强加密等。

安全编码实践的最佳实践如下：

+   分配服务权限时遵循 PoLP 原则。

+   使用安全的编码框架和库。

+   定期进行安全代码审查。

以下是一些安全编码实践的关键考虑因素：

+   对开发者进行安全编码实践培训。

+   实施安全编码指南并强制执行。

安全编码实践是帮助开发者编写安全、可靠且对常见漏洞和攻击具有抵抗力的代码的指南和标准。

## API 速率限制

**API 速率限制**是指在一定时间内限制客户端（用户或系统）对 API 发出请求数量的过程。这有助于保护 API 不被过载，也可以作为一种安全方法来防止诸如暴力攻击等问题。

API 速率限制的最佳实践如下：

+   实施速率限制以防止滥用并保护免受**分布式拒绝服务**（**DDoS**）攻击。

+   使用令牌桶或滑动窗口算法（用于速率限制）。

滑动窗口技术

**滑动窗口**技术是一种计算方法，用于优化涉及数组、字符串或其他数据结构的某些问题。它的目的是减少嵌套循环的使用，并用单个循环来替换它们，从而提高时间复杂度。）

+   当超过速率限制时，提供清晰的错误信息。

以下是一些 API 速率限制的关键考虑因素：

+   根据用户角色或 API 端点区分速率限制。

+   实施自适应速率限制以动态响应流量模式。

所有这些实践都有助于提高软件应用程序和 Web 服务的可靠性和安全性。

总结来说，通过将这些安全实践集成到微服务的开发生命周期中，组织可以显著提高其系统的安全态势。定期的安全评估、培训和积极应对新兴威胁是强大微服务安全策略的关键组成部分。

# 摘要

在本章中，我们学习了关于微服务的大量知识，以及如何在微服务架构中确保数据安全，这涉及到实施各种措施，包括使用 Saga 模式、加密和额外的安全措施。

总结来说，通过结合 Saga 模式、加密和额外的安全措施，您可以在微服务环境中创建针对各种安全威胁的强大防御。定期重新评估和更新安全实践，以保持对新兴威胁的领先。

数据安全至关重要，尤其是在我们这个以数据驱动的现代时代。保护敏感信息免受未经授权的访问、使用、披露、中断、修改或破坏需要战略措施。我们探讨了确保数据安全的三个方法——通过实施 Saga 模式、加密和额外的安全措施。

在下一章中，我们将学习如何在 Node.js 中监控微服务。

# 测验时间

+   补偿操作有哪些关键考虑因素？

+   什么是 saga 调度？

+   什么是事件驱动通信？

+   加密算法是什么？

# 第四部分：使用 Node.js 在微服务中进行监控和日志记录

在这部分中，我们将讨论微服务的监控和日志记录，以及如何在 Node.js 中解释和分析日志数据。

本部分包含以下章节：

+   *第十三章*，*在 Node.js 中监控微服务*

+   *第十四章*, *使用 Node.js 在微服务中进行日志记录*

+   *第十五章*, *在微服务中解释监控数据*

+   *第十六章*, *使用 Node.js 在微服务中分析日志数据*
