# 7

# 高级路由技术

到目前为止，我们已经涵盖了所有内容，你现在可以放下这本书，使用 SvelteKit 构建一个简单的网站。但如果你想在应用程序中构建更高级的功能，你可能会发现自己难以找到合适的路由层次结构。这是因为当我们谈到动态路由时，我们只是触及了表面。在*第四章*中，我们讨论了通过传递给我们的路由的参数创建动态页面。在那个例子中，我们通过提供的 slug 加载文章，并将其与我们在演示数据库中找到的匹配。我们无法提前知道 slug 是什么，为每篇文章创建一个新的路由将会过于复杂。相反，我们研究了基于访问的 URL 接收到的 slug 参数。

这只是对动态路由的简要介绍。在本章中，我们将探讨一些更高级的技术，可以帮助你提升你的路由逻辑。我们将研究带有可选参数的路由、未知长度的参数、如何使用正则表达式匹配参数、在路由逻辑冲突的情况下哪些路由将具有优先级，以及更高级的布局技术，包括如何从中退出。

本章将分为以下主题：

+   使用可选参数

+   剩余参数

+   匹配、排序和编码——哦，我的天！

+   高级布局

到本章结束时，你将掌握 SvelteKit 中可用的各种路由技术。无论你的下一个 SvelteKit 项目的需求如何，你都将拥有解决和应对任何复杂路由难题所需的知识。

# 技术要求

本章的完整代码可在 GitHub 上找到：[`github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter07`](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter07)

# 使用可选参数

自从我们在*第四章*的*创建动态页面*部分提到了可选参数，让我们从这里开始。在创建路由中的可选参数时，有一些事情需要考虑。例如，它们不能与另一个路由共存，因为这会导致路由规则冲突。在创建可选路由时，最佳做法是当路由的最后一部分可以有一个默认选项时。许多应用程序会根据用户选择的语言更改 URL。在我们的例子中，我们将展示如何通过选择我们演示商店运营的北美国家来创建一个可选参数。我们实际上不会构建一个完整的商店，而是用它来展示本章中高级路由概念。

首先，让我们在我们的导航中创建一个新的路由，就像我们之前的示例一样：

src/lib/Nav.svelte

```js
<nav>
  <ul>
    <li><a href='/'>Home</a></li>
    ...
    <li><a href='/login'>Login</a></li>
    <li><a href='/store'>Store</a></li>
  </ul>
</nav>
```

我们需要做的只是再在导航菜单中添加一个链接到我们新的路由的另一个列表项。完成之后，我们可以创建`store`目录，这个目录将包含本章的所有示例：

src/routes/store/+layout.svelte

```js
<h2>Store</h2>
<ul>
  <li><a href="/store/locations/">Locations</a></li>
  <li><a href="/store/products/">Products</a></li>
</ul>
<slot />
```

这个简单的布局将允许我们导航本章中涵盖的各种概念。在添加链接后，我们使用在早期章节中提到的 Svelte `<slot>`元素。花点时间创建所有必要的目录。接下来，我们还将为`/store`路由创建一个简单的着陆页：

src/routes/store/+page.svelte

```js
<h3>Welcome to the Store!</h3>
```

在创建了`/store`路由和`locations`目录所需的文件之后，我们现在将创建另一个目录。与这个目录的主要区别在于它使用双方括号(`[[country]]`)作为名称。这是 SvelteKit 区分可选路由和不可选路由的方式。因为我们正在创建一个带有可选参数的页面，所以我们不需要在`locations`目录中创建`+page.svelte`。相反，我们将它添加到`[[country]]`目录中。为了继续，我们将创建适当的`+page.svelte`和`+page.js`文件：

src/routes/store/locations/[[country]]/+page.svelte

```js
<script>
  export let data;
</script>
<h2>You're viewing the {data.country.toUpperCase()} store.</h2>
<ul>
  <li><a href="/store/locations">North America</a></li>
  <li><a href="/store/locations/ca">Canada</a></li>
  <li><a href="/store/locations/me">Mexico</a></li>
  <li><a href="/store/locations/us">United States</a></li>
</ul>
```

到现在为止，这应该看起来非常熟悉。我们使用`export let data;`以便在下一个文件中访问`load()`提供的信息。我们使用这些数据来告知用户他们正在查看哪个国家的商店位置，并显示大写缩写。然后我们创建一个无序列表，其中包含指向我们将在下一个文件中提供的各种允许路由的链接。

在`[[country]]/+page.js`中，我们需要将路由提供的参数与我们的商店运营的国家列表进行比对。我们可以使用以下代码来完成：

src/routes/store/locations/[[country]]/+page.js

```js
export function load({ params }) {
  const codes = [
    'na',
    'ca',
    'me',
    'us'
  ];
  const found = codes.filter(country_code => country_code === params.country);
  return {country: found[0] ?? 'na'};
}
```

到目前为止，导出`load()`函数应该对你来说也很熟悉。在这个特定的函数中，我们只需要访问`params`，所以我们解构了传递给`load()`的`RequestEvent`对象。然后我们声明了一个`codes`数组，它作为一个允许路由的列表。在下一行，我们通过在`codes`上运行`filter()`来检查提供的路由是否在允许路由的数组中。然后`filter()`返回一个包含所有匹配项的数组，并将其分配给`found`常量。然后我们可以返回一个包含`country`属性的数组，它被分配给`found`中的第一个值。如果`found`的第一个值是空的，我们将默认显示所有北美地区的值。在这种情况下，`na`。

一旦我们完成所有这些，我们就可以打开我们的应用程序，点击 `load()`。当选择其他任何选项时，缩写会相应更新。正如之前提到的，可选参数在路由的最后一部分可以有一个默认选项时效果最佳。如果可选参数被包含在路由中间的某个位置，那么路由机制将理解随后的路由部分为可选参数。

在这个例子中，我们使用双方括号 `[[ ]]` 创建了一个新的路由。虽然这个例子距离作为一个完整的存储还有很长的路要走，但它应该可以阐明如何在路由中使用可选参数。现在，既然你已经理解了可选参数，让我们看看我们如何可以处理未知长度的路由。

# 剩余参数

就像 JavaScript 函数可以使用剩余参数操作符（`…`）接受剩余参数一样，我们的路由也可以这样做。通过在单个方括号内使用剩余参数操作符，我们可以允许指定路由具有可变长度。当创建类似文件浏览器这样的东西时，URL 应该匹配一个路径，然后通过 URL 使页面内容可共享，这个特性非常有用。

为了看到这个概念的实际应用，让我们在我们的存储中创建一个 `products` 路由。首先添加 `src/routes/store/products/+layout.svelte`，这样我们就可以轻松地导航产品：

src/routes/store/products/+layout.svelte

```js
<h3>Products</h3>
<ul>
  <li><a href="/store/products/shirts">Shirts</a></li>
  <li><a href="/store/products/shirts/mens">Mens Shirts</a></li>
  <li><a href="/store/products/shirts/mens/tshirts">Men's T-shirts
    </a></li>
  <li><a href="/store/products/shirts/mens/tshirts/cotton">Men's 
    Cotton T-shirts</a></li>
  <li><a href="/store/products/shirts/mens/tshirts/cotton/
    graphic">Men's Graphic Cotton T-shirts</a></li>
</ul>
<slot />
```

这个 Svelte 组件相当简单。它由标题、无序列表、列表项以及指向各种产品的链接组成。同样，我们使用了 Svelte 的 `<slot />` 元素来保持我们在页面上的导航，当我们点击时。接下来，让我们创建一个可以处理我们刚刚提供的不同长度的产品端点。为此，我们将创建一个使用方括号和剩余参数操作符作为目录名称的文件夹。在这个例子中，我们将使用 `[...details]` 作为目录名称。现在，让我们看看 `+page.js` 和 `+page.svelte` 文件： 

src/routes/store/products/[...details]/+page.js

```js
export function load({ params }) {
  return params;
}
```

由于我们不是构建整个存储，我们可以保持这个存储非常简单。因为我们试图展示 SvelteKit 路由机制中剩余参数的工作方式，我们将在 `load()` 中简单地返回 `params`。一个更健壮且实用的例子可能会从 `params` 中获取值，并使用它来过滤从数据库检索的产品列表。然后，这些数据可以从 `load()` 返回，以便在下一个文件中渲染每个产品。

现在，为了展示剩余参数值的变化，我们将添加以下 `+page.svelte`：

src/routes/store/products/[...details]/+page.svelte

```js
<script>
  export let data;
</script>
<h4>Product page</h4>
{#if data.details}
  <p class='red'>{data.details}</p>
{:else}
  <p>No product selected! Try clicking one or adding your own URL.
{/if}
<style>
  .red {
    color: red;
    font-weight: bold;
  }
</style>
```

再次强调，我们保持简单。我们不是显示 `data` 中可能可用的所有产品，而是简单地使用 Svelte 的 `{#if}` 和 `{:else}` 指令来演示 `details` 参数如何变化。如果 `data.details` 为空，我们显示一个默认消息。如果它有值，我们以粗体红色文本显示它。如果我们给目录起了一个不同的名字，那么这个名字就是访问参数的方式。尝试点击一些指向各种产品的链接，注意浏览器中的 URL 如何变化，红色中的值也是如此。如果你在 `/store/products/` 之后向 URL 添加自己的值会发生什么？ 

使用这些高级路由技术时，我们必须考虑一些影响。例如，正如可选参数在 URL 的末尾部分工作时效果最佳一样，剩余参数后面不能跟一个可选参数。如果我们尝试在剩余参数之后提供可选路由部分，它们将被剩余参数消耗。要查看 Vite 开发服务器抛出的错误，尝试在 `/[...details]/` 内创建一个可选目录。你不必担心意外这样做，因为 Vite 会为你留意，但在规划应用程序的路由时了解这一点仍然很重要。

如果你发现自己正在将未知长度的路由构建到应用程序中，考虑使用 SvelteKit 的剩余参数来创建它们。它们不仅处理那些不确定的长度，而且逻辑可以轻松地融入现有的 SvelteKit 应用程序流程中。

# 匹配、排序和编码——哦，我的天啊！

如果你不太熟悉 SvelteKit 更高级的路由技术细节，它可能会很快变得难以控制。为了应对意外情况，我们将探讨一些你可以使用的策略，以确保你的应用程序的路由按预期工作。在本节中，我们将介绍如何确保参数的类型是你所期望的。然后，我们将检查 SvelteKit 如何处理可以解析到多个路由的 URL。最后，我们将提供一些关于 URL 编码的信息。你可以期待看到以下子章节：

+   匹配

+   排序

+   编码

一旦完成，你将更接近掌握 SvelteKit 应用程序的路由。

## 匹配

我们已经探讨了如何在路由中使用可选和剩余参数。但回想一下我们在 *第四章* 中创建的示例，它涉及到动态路由。在新闻部分，我们只检查提供的 `[slug]` 参数是否存在于我们的数据库中。如果我们想确保传递给数据库的值实际上是一个 slug，我们可以创建一个自定义匹配器来完成这项工作。

要使用 SvelteKit 创建匹配器，我们向`src/params/`添加一个具有描述性名称的 JS 文件。如果该目录尚不存在，请不要担心！您现在可以简单地创建它。这里的文件导出一个单个函数：`match()`。该函数接受一个字符串参数并返回一个布尔值。因为传递给函数的值是字符串，我们将使用**正则表达式**（**regex**）来确保传入的参数是我们希望在路由上强制执行的类型。正则表达式可能一开始看起来令人畏惧，但网上有大量工具可以帮助创建和学习正则表达式规则。请参阅本章末尾以获取更多资源。现在让我们为我们的新闻文章创建一个匹配器，以确保在执行数据库查找之前传递了正确的 slug：

src/params/slug.js

```js
export function match(str) {
  return /^[a-z0-9]+(?:-[a-z0-9]+)*$/gim.test(str);
}
```

很明显，匹配器不需要过于复杂。它只需要导出`match()`函数，该函数接受一个字符串参数。然后，此匹配器将该字符串与正则表达式字面量进行比较，对于匹配返回 true，对于不匹配返回 false。此正则表达式测试一个或多个字符串或数字字符后跟一个`–`字符，该字符必须后跟一个或多个字符串或数字字符。以`–`字符结尾的字符串被认为是无效的。

应用匹配器

当将匹配器应用于特定路由时，`=`字符后面的值是给定匹配器的名称。另一个例子可能包括创建一个测试整数的匹配器。该规则可以通过设置参数如下来应用于动态路由：`[param=integer]`，其中`params/integer.js`是匹配器文件的名称。

要将我们刚刚创建的匹配器应用于我们的新闻文章，我们需要将`src/routes/news/[slug]`重命名为`src/routes/news/[slug=slug]`。一旦我们相应地调整了路由中的参数，我们就可以像之前一样查看我们的新闻文章。当然，现有的文章将匹配得很好，因为它们包含有效的 slugs。为了测试在运行数据库查找之前是否应用了此匹配器，我们可以在`src/lib/articles.json`中创建一个新文章。新文章对象的内容和标题无关紧要，但通过创建一个具有无效 slug 的文章，我们可以确认匹配器正在工作。一旦您创建了一个具有不良 slug 的文章，尝试查看它。您应该收到**404 未找到**错误，尽管文章存在。这是因为传递给动态参数的值没有匹配我们提供的正则表达式。

虽然正则表达式可能难以处理，但知道 SvelteKit 使开发者能够利用其背后的力量是令人欣慰的。能够这样做确保我们的应用程序按预期工作。然而，仍然可能存在 SvelteKit 路由以意外方式到达端点的情况。为了避免这些情况，让我们看看哪些路由规则比其他规则具有优先级。

## 排序

由于 URL 完全可能匹配多个路由，因此了解哪些路由规则将以何种顺序执行非常重要。类似于 CSS 规则被赋予不同的权重，SvelteKit 的路由规则也是如此。那么，在何时以及如何避免冲突？

1.  更具体的路由总是优先于不那么具体的路由。没有参数的路由被认为是最高级别的。例如，`src/routes/about/+page.svelte` 将在 `src/routes/[param]/+page.svelte` 之前执行。

1.  将匹配器应用于动态参数将赋予它比没有匹配器的参数更高的优先级。调用 `src/routes/news/[slug=slug]/+page.svelte` 将比 `src/routes/news/[slug]/+page.svelte` 具有更高的优先级。

1.  可选参数和剩余参数的优先级最低。如果它们不是路由的最后一部分，则会被忽略。例如，`src/routes/[x]/+page.svelte` 将在 `src/routes/[...rest]/+page.svelte` 之前执行。

1.  冲突解决者由参数的字母顺序决定。也就是说，`src/routes/[x]/+page.svelte` 将在 `src/routes/[z]/+page.svelte` 之前执行。

如果你计划利用 SvelteKit 更高级的路由功能，那么理解这些规则是绝对必要的。尝试自定义项目中创建的路由，并调整它们以创建冲突。看看你是否能自己解决冲突或预测哪些页面将在其他页面之前被调用。接下来，我们将探讨如何通过编码管理 URL 中的特殊字符。

## 编码

在他们的职业生涯中，每个开发者都遇到过编码问题，但没有人花时间去完全理解它们。既然你是一位忙碌的开发者，渴望开始构建，而且你可能不是来这本书上听关于编码的讲座的，所以我们会尽量简短。为了防止在构建使用特殊字符的路由时产生严重的挫败感，SvelteKit 允许我们编码路由，以便它们可以在 URL 中使用。当然，一些字符，如 **[** **]** **(** **)** **#** 和 **%** 在 SvelteKit 或浏览器中具有特殊含义，因此它们大多被禁止使用。然而，当在路由机制中正确编码并在浏览器中进行 URL 编码时，它们仍然可以使用。

在 SvelteKit 中创建包含特殊字符的路由时，特殊字符的写法类似于动态参数，放在方括号 `[ ]` 内。然而，它们前面会加上 `x+` 前缀，后面跟着字符的十六进制值。一个例子是在创建指向 `/.well-known/` 目录的路由时，它可以表示为：`src/routes/[x+2e]well-known/+page.svelte`。在大多数情况下，此路由应该没有问题，编码也不必要，但我们使用它来演示。请继续在你的项目中创建它。在浏览器中，导航到开发站点，并将 `/.well-known/` 路由附加到地址栏以确认它是否工作。现在尝试创建路由 `/?-help/`。因为 `src/routes/[x+3f]-help/+page.svelte`。但我们将无法访问 `/?-help/` 的网页。相反，我们需要在 `/%3f%-help/` 访问该特定路由。在路由中使用特殊字符时，请考虑事先使用十六进制值对其进行编码。

要获取字符的十六进制值，你可以使用以下 JS 片段：`':'.charCodeAt(0).toString(16);` 其中 `:` 是你想要获取十六进制值的特殊字符。我们不仅限于只使用十六进制值来处理简单的文本。SvelteKit 的路由也支持 `[u+xxxx]`，其中 `xxxx` 是 Unicode 码点。

为了确保我们的应用程序按预期运行，了解如何正确编码特殊字符是至关重要的。我们还探讨了如何将匹配器应用于路由，以确保动态参数的类型符合我们的预期。并且通过简要了解路由是如何优先于其他路由的，你应该可以放心地在应用程序的路由中探索更高级的技术。

# 高级布局

应用程序越复杂，其结构也越复杂。为了保持应用程序逻辑的有序性，我们可以利用更高级的路由机制，例如布局组和断开。通过使用布局组，我们可以组织各种布局组件，而不会使应用程序的 URL 变得杂乱。并且通过在页面和模板中插入简单的语法，我们可以将布局或页面从其层次结构中分离出来，同时保持我们应用程序的结构完整。

由于我们将应用程序组件组织成逻辑分组，因此将应用程序功能组织成逻辑分组也是有意义的。为了使用实际示例进行演示，考虑那些仅对已登录用户可用而对匿名用户不可用的界面组件。当用户登录时，他们可以通过评论与其他用户互动，更改他们的个人资料信息或查看自己的通知。未登录的网站用户不应看到这些组件中的任何一项。根据我们到目前为止对布局的了解，为每种类型的用户创建不同的布局可能会使我们遇到影响应用程序干净 URL 的问题。这就是我们可以利用 SvelteKit 的布局组的地方。

在创建布局组时，使用括号 `( )` 包围目录名称。该布局组内部的所有内容都将包含在该组中，并槽位在找到那里的 `+layout.svelte` 文件中。为了演示布局组，我们将创建两个组：`(app)` 和 `(site)`。在 `(app)` 中，我们将移动与应用程序功能相关的逻辑，在 `(site)` 中，我们将移动在基本网站上常见的一些逻辑。我们新的 `routes` 目录结构应该看起来像这样：

src/routes/

```js
src/
|_routes/
   |_(app)/
   |  |_comment/
   |  |_login/
   |  |_notifications/
   |  |_store/
   |
   |_(site)/
   |  |_about/
   |  |_fetch/
   |  |_news/
   |
   |_api/
   |_+layout.server.js
   |_+layout.svelte
   |_+page.svelte
```

在调整文件夹后，我们可以为每个新的布局组创建一个布局：

src/routes/(app)/+layout.svelte

```js
<div class='app_layout'>
  <slot />
</div>
<style>
  .app_layout {
    background: #cac4c4;
    padding: 1rem;
  }
</style>
```

在这个布局文件中，我们将要在 Svelte `<slot />` 指令中渲染的所有内容包裹在一个应用背景颜色的 `<div>` 元素中。为了简化，我们只是尝试展示不同的布局组是如何工作的。下一个文件会做完全相同的事情，但应用不同的颜色：

src/routes/(site)/+layout.svelte

```js
<div class='site_layout'>
  <slot />
</div>
<style>
  .site_layout {
    background: #83a8ee;
    padding: 1rem;
  }
</style>
```

保存这些布局后，你会注意到当在浏览器中导航到 `comment/`、`login/`、`notifications/` 和 `store/` 时，应用程序显示的背景颜色与导航到 `about/`、`fetch/` 和 `news/` 时显示的颜色不同。然而，我们的 URL 完全相同！

对于想要从现有层次结构中跳出特定布局或页面的情况，我们可以在文件名中附加 `@` 字符。例如，`+page@` 或 `+layout@`。然后我们可以跟随着我们希望它直接继承的目录名称。如果没有提供 `@` 字符后面的名称，则将使用根布局。我们可以通过将 `src/routes/(app)/store/products/[...details]/+page.svelte` 重命名为 `src/routes/(app)/store/products/[...details]/+page@(app).svelte` 来看到这个功能的效果。这样做将产品页面从产品和存储布局中移出。尝试将其重命名为 `+page@store.svelte` 以保留存储布局，或重命名为 `+page@.svelte` 以将其完全返回到根布局。当然，我们的产品链接不再可见，因为显示它们的标记包含在 `src/routes/(app)/store/products/+layout.svelte` 中，但我们只是试图展示如何跳出页面的直接布局。这个功能对于将应用程序逻辑分离到管理或认证部分，同时保持 URL 不受影响非常有用。

我们刚刚看到，如何通过在 Svelte 组件命名约定中使用 `@` 符号来跳出布局。当我们包含 `@` 符号后跟我们想要的布局名称时，文件将直接继承该布局名称，而不是所有布局之间的布局。我们还看到了如何创建布局组以保持我们的项目结构，同时不破坏应用程序的 URL。涵盖了一切之后，你应该能够满足任何 SvelteKit 项目的最复杂的路由需求。

# 摘要

在本章节之前的章节中，我们介绍了核心路由概念。在本章中，我们探讨了 SvelteKit 中可用的更高级技术。这些技术可以帮助我们进一步自定义应用程序并解决边缘情况。在路由方面，我们现在理解了如何创建具有默认值的可选参数。我们还看到了如何使用剩余参数创建未知长度的可共享 URL。匹配被证明对于确保我们的应用程序正在接收预期类型的参数非常有用。我们还看到了 SvelteKit 如何优先考虑某些路由规则，这对于理解当 URL 匹配多个路由时的执行顺序非常有帮助。在介绍了如何在路由中编码特殊字符之后，我们探讨了如何创建布局组，甚至跳出布局层次结构，同时保持应用程序逻辑完整。如果你完成了这一章，并且对所学内容感到满意，你将能够处理在构建 SvelteKit 应用程序的路由时遇到的任何最奇怪的边缘情况。

在下一章中，我们将短暂地休息一下路由，分析各种 SvelteKit 适配器和它们所使用的环境。我们还将更仔细地研究页面选项，并尝试第一次为生产环境构建我们的应用程序。

# 资源

+   RegExr – 一个练习和学习正则表达式的优秀网站：[`regexr.com/`](https://regexr.com/)

+   Unicode 标准：[`www.unicode.org/standard/standard.html`](https://www.unicode.org/standard/standard.html)

+   使用 Unicode 编程：[`unicodebook.readthedocs.io/index.html`](https://unicodebook.readthedocs.io/index.html)

# 第三部分 - 补充概念

本部分旨在介绍 SvelteKit 的额外必需概念。它首先向您展示如何使用 SvelteKit 的适配器系统轻松地为生产环境生成构建，并展示了如何做到这一点。然后，它涵盖了如何使用钩子来操作进入和离开 SvelteKit 应用程序的数据。从那里，它讨论了如何利用 Vite 最好地导入静态资源。然后，它解释了 SvelteKit 中可用的各种模块，这些模块使整个框架成为可能。该部分接着介绍了如何确保 SvelteKit 应用程序能够提供给尽可能多的用户，同时提高搜索引擎排名。最后，它总结了各种对任何试图用 SvelteKit 为其下一个项目提供动力的开发者都非常有价值的资源。

本部分包含以下章节：

+   *第八章*，*构建和适配器*

+   *第九章*，*钩子和错误处理*

+   *第十章*，*管理静态资源*

+   *第十一章*，*模块和密钥*

+   *第十二章*，*增强可访问性和优化 SEO*

+   *附录* *示例和支持*
