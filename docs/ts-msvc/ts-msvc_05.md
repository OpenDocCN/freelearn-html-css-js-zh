# 第五章：理解 API 网关

设计了一些微服务后，我们将在这里讨论微服务网关。与单片应用程序相比，微服务不通过内存调用进行通信，而是使用网络调用。因此，网络设计和实现在分布式系统的稳定性中起着重要作用。我们将揭示 API 网关，并了解它如何处理基于微服务的架构中的重要关注点。

本章将从理解 API 网关及其必要性开始。然后将讨论 API 网关处理的所有集中关注点，以及引入网关的好处和缺点。我们将为购物车微服务设计我们的网关，并查看网关的所有可用选项，并熟悉 API 网关中涉及的设计模式和方面。本章将讨论以下主题：

+   揭示 API 网关

+   API 网关处理的关注点

+   API 网关设计模式

+   断路器及其作用

+   我们的购物车微服务中需要网关

+   可用的网关选项

+   为购物车微服务设计我们的网关

# 揭示 API 网关

随着我们深入微服务开发，我们看到前方有各种陷阱。现在我们的微服务已经准备就绪，当我们考虑客户端利用这些微服务时，我们将遇到以下问题：

+   消费者或 Web 客户端在浏览器上运行。前端没有任何发现客户端，负责识别容器/VM 服务的位置，也不负责负载平衡。我们需要一个额外的拼图，它连接后端不同容器中的微服务，并将该实现从客户端抽象出来。

+   到目前为止，我们还没有讨论像认证服务、版本化服务、过滤或转换任何请求/响应等集中关注点。经过反思，我们意识到它们需要一个中央控制点，可以在整个系统中应用，而无需在每个地方重新实现相同的逻辑。

+   此外，不同的客户端可能有不同的合同要求。一个客户端可能期望 XML 响应，而另一个需要 JSON 响应。我们需要一个中心组件来处理路由请求，根据协议需求翻译响应，并根据需要组合各种响应。

+   如果我们想独立按需扩展任何微服务，需要根据需要添加新实例，其位置应该对客户端进行抽象。因此，我们需要一个不断与所有微服务通信并维护注册表的中央客户端。此外，如果服务宕机，它应该通知客户端并在那里断开连接，从而防止故障传播。此外，它可以作为中央缓存管理的地方。

API 网关是一种解决所有上述问题的服务类型。它是我们微服务世界的入口点，并为客户端提供与内部服务通信的共享层。它可以执行路由请求、转换协议、认证、对服务进行速率限制等任务。它是治理的中心点，有助于实现以下各种事项：

+   监控整个分布式移动系统，并相应地采取行动

+   通过抽象实例和网络位置，以及通过 API 网关路由每个请求，将消费者与微服务解耦

+   通过将可重用代码保存在一个地方，避免代码重复

+   根据需要实现按需扩展，并从一个地方对故障服务采取行动

+   定义 API 标准，例如 Swagger，Thrift IDL 等

+   设计合同

+   跟踪 API 的生命周期，包括版本化、利用率、监控和警报、限流等

+   避免客户端和微服务之间的啰嗦通信

作为进入完全移动的分布式系统的单一入口点，很容易强制执行任何新的治理标准（例如，每个消费者都应该有 JWT 令牌），进行实时监控，审计，API 消费政策等。

JWT 令牌模式利用加密算法：令牌验证方法。在任何成功的身份验证之后，我们的系统生成一个具有 userID 和时间戳值的唯一令牌。将此令牌返回给客户端，需要在进一步的请求中发送。在接收任何服务请求时，服务器会读取并解密令牌。此令牌通常被称为**JSON Web Token**或**JWT**。为了防止**跨站点请求伪造**（**CSRF**）等攻击，我们使用这种技术。

网关提供了灵活性，可以自由操纵微服务实例，因为客户端完全与此逻辑抽象。这是处理基于客户端设备的转换需求的最佳位置。网关充当缓冲区，防止任何形式的攻击。服务被污染，不会危及整个系统。网关通过满足所有这些标准来处理安全性，保密性，完整性和可用性。随着利益的增加，如果网关没有得到适当处理，也会有很多缺点。网关可能会引入指数级的复杂性，随着动态系统的增加，响应时间会增加。

在下图中，详细解释了 API 网关：

![](img/f8004844-d3fa-426e-a7d5-78a7d1689b0d.png)

现在我们知道网关的作用，让我们现在了解网关的基本知识以及它总体上处理的事情。

# API 网关处理的问题

API 网关成为微服务架构中最重要的组件之一，因为它是处理核心问题的唯一位置。因此，在所有微服务实现中看到的常见实现是引入提供关键功能的 API 网关。此外，API 网关是连接到服务发现的部分，动态维护所有新添加服务的路由。在本节中，我们将研究网关功能，并了解我们中央操作层的整体架构的角色和影响。

# 安全性

随着分布的增加，自由度相当高。有很多移动服务，可能随时上升或下降。从安全性的角度考虑，当有很多移动部分时，事情可能出现相当大的问题。因此，需要一定的规则来管理安全性。因此，我们需要保护所有面向公众的 API 端点的远程服务调用。我们需要处理各种事情，如身份验证，威胁漏洞，授权，消息保护和安全通信。我们将添加 SSL/TLS 兼容的端点，以防范各种攻击，如中间人攻击，双向加密防止篡改。此外，为了处理 DDoS 攻击，API 网关将处理各种因素，如限制请求速率，按需连接数量等。网关将关闭慢速连接，黑名单或白名单 IP 地址，限制与其他后端微服务的连接，维护数据库连接数量等。API 网关将处理身份验证和授权等事项。我们可以在这里引入联邦身份，如**OpenID**，**SAML**和**OAuth**。此外，该层将生成 JWT 并验证所有请求。

微服务开发中的一个棘手部分是身份和访问管理。在大型企业中，通常通过 LDAP 等常见系统处理这一问题。联邦身份有点像授权服务器（它们在各种应用程序中使用：例如，您可以考虑将单个 Google 帐户链接到 Google 文档、Google Drive 等各种服务，然后授权用户并提供 ID 令牌和访问令牌）。著名的联邦身份提供者包括 OAuth 和**安全断言标记语言**（**SAML**）。

# 愚蠢的网关

网关的最基本原则之一是*网关始终是愚蠢的*。在设计网关时，需要注意的一个重要方面是，网关不应过于雄心勃勃；也就是说，它不应包含非通用逻辑或任何业务需求。使其过于雄心勃勃会违背网关的目的，并且可能使其成为单点故障，并且也可能使其难以测试和部署。智能网关无法轻松进行版本控制或集成到大型管道中。此外，它引入了紧密耦合，因为当您升级网关时，通常必须处理升级其依赖项和与之相关的核心逻辑。

简而言之，API 网关应包含任何我们可以在其中验证或维护的内容，而无需其他服务或共享状态的帮助。除此之外的任何内容都应移出 API 网关。以下几点简要总结了 API 网关的愚蠢和其功能：

+   像 JWT 令牌验证这样的验证（我们不请求任何外部服务）

+   提高服务质量（例如缩小响应、HTTP 头缓存、发送缓存数据等）

+   请求和响应操作（处理多种内容类型并相应操作请求和响应）

+   与服务发现的交互（与服务注册表进行非阻塞交互以获取服务请求详细信息）

+   速率限制和节流（隔离的功能）

+   断路器（检测故障并相应处理）

# 转换和编排

我们已经很好地将我们的微服务划分为单一责任原则；然而，为了实现业务能力，我们经常需要结合多个微服务。例如，购买产品的人是支付微服务、库存微服务、运输微服务和结账微服务的混合体。就像 Linux 管道结合各种命令一样，我们需要类似的编排解决方案。这对消费者来说是至关重要的，因为逐个调用每个细粒度服务绝对是一场噩梦。以我们的购物车微服务为例。我们有以下两个微服务：

+   **受众定位**：这些微服务接收用户信息并返回所有推荐的列表（它返回产品 ID 的列表）

+   **产品详情**：这些微服务接收产品 ID 并通过提供产品元数据和详细信息来做出响应

假设我们正在为 20 个项目设计一个推荐页面。如果我们保持原样，那么消费者将不得不进行总共 21 次 HTTP 调用（1 次获取产品 ID 列表的调用，20 次获取产品详细信息的调用），这是一场噩梦。为了避免这种情况，我们需要编排器（可以组合所有这些 21 次调用的东西）。此外，微服务必须处理需要不同响应的不同客户端。API 网关是一个转换的地方，可以处理通信协议、响应格式、协议转换等所有事情。我们可以在 API 网关中放置诸如 JSON 到 XML 转换、HTTP 到 gRPC 或 GraphQL 协议转换等内容。

# 监控、警报和高可用性

微服务架构中有很多移动部件。因此，系统范围的监控和避免级联故障变得至关重要。API 网关为这个问题提供了一站式解决方案。我们可以监控和捕获所有数据流的信息，可以用于安全目的。我们可以监控健康、流量和数据。API 网关可以监控各种事物，如网络连接、日志维护、备份和恢复、安全性以及系统状态和健康状况。此外，API 网关还可以监控一些基本事物，如 API 的请求数、维护远程主机、浏览器、操作系统、性能统计、消息的堆栈跟踪、违反网关策略的违规行为等。API 网关可以集成警报工具，如 consul alerts ([`github.com/AcalephStorage/consul-alerts`](https://github.com/AcalephStorage/consul-alerts))，并相应地采取适当的行动以实现高可用性。我们必须在负载均衡器后部署多个 API 网关实例，以有效地在多个 API 网关实例之间平衡流量。我们必须计划高容量和负载。如果部署在云中，我们可以启用自动扩展，如果没有，则必须确保它有足够的数据资源来处理未来的负载。

# 缓存和错误处理

为了实现最大的优化和性能，缓存经常被引入到分布式系统中。Redis 因为它轻量级并且可以很好地满足缓存的目的，因此得到了巨大的增长。此外，在某些业务能力中，可以容忍陈旧的数据，这是离线优先时代。API 网关可以处理这一部分，如果微服务宕机或者防止过多的数据库调用，提供缓存响应。设计缓存机制的黄金法则可以是那些实际上永远不需要进行的服务调用应该是最快的调用。例如，考虑 IMDB 中《复仇者联盟 4》页面的更新。它每秒都在获得超过 20,000 次的点击。

数据库受到这些访问的冲击，因为它还必须获取其他东西（如评论、评论等）。这就是缓存变得有用的地方。很少改变的东西，如演员描述、电影描述等，来自缓存层。返回的响应非常快，它节省了网络跳跃，也不会增加 CPU 性能。通过实施缓存层，API 网关确保用户体验不受影响。在分布式系统中，由于通信频繁，错误很可能发生，因此错误应该通过超时和断路器等模式得到适当处理，这些模式应该提供缓存响应。

我们可以在以下两个级别进行缓存管理：

+   **在 API 网关级别进行缓存：** 选择这个选项，我们可以在网关或中央级别缓存服务响应。这样可以节省服务调用的优势，因为我们可以直接在网关级别返回数据。此外，在服务不可用或无响应的情况下，API 网关可以从缓存中返回数据。

+   **在服务级别进行缓存：** 选择这个选项，每个服务都可以管理自己的缓存数据。API 网关不知道内部缓存或内部任何精确的东西。服务可以根据需要轻松地使缓存失效。然而，在实施这个选项时，我们应该在中央缓存级别准备好默认响应。

**Netflix Hystrix** 是一个非常有用的库，具有强大的选项，如超时调用超过特定阈值，不必要等待，定义回退操作，如返回默认值或从缓存返回值。它也有一个 Node.js 客户端 ([`www.npmjs.com/package/hystrixjs`](https://www.npmjs.com/package/hystrixjs))。

# 服务注册和发现

微服务的一个关键优势是易于扩展。在任何时候，新的微服务都可以根据流量进行调整，可以进行扩展，并且现有的单片式可以分解为多个微服务。所有这些服务实例都具有动态分配的网络位置。API 网关可以维护与服务注册表的连接，该注册表可以跟踪所有这些服务实例。API 网关与包含所有实例的网络位置的数据库进行通信。每个服务实例在启动和关闭时都会告诉注册表其位置。与 API 网关连接的另一个组件是服务发现。消费各种微服务的客户端需要具有简单的发现模式，以防止应用程序变得过于啰嗦。

Consul 是最广泛使用的服务注册和发现工具之一。它知道特定服务有多少活动容器失败，如果该数字为零，它会将该服务标记为损坏。

有以下两种类型的方法：

+   `推送`：微服务本身负责向 API 网关确认其入口

+   `拉取`：API 网关负责检查所有微服务

# 断路器

API 网关处理的另一个重要问题是当服务宕机时断开连接。比如说一个微服务宕机并开始抛出大量错误。排队进一步请求该微服务是不明智的，因为它很快就会有很高的资源利用率。在这里引入的 API 网关可以实现诸如断开连接或者简单地说当某个阈值被超过时，网关将停止向该失败组件发送数据，直到组件被解决，分析日志，实施修复，推送更新，从而防止整个系统中的故障级联。因此，扩展底层和流行的微服务变得非常容易。网关因此可以水平和垂直扩展。API 网关通过以滚动方式部署配置来实现零停机时间，也就是说，在新部署时，电路被触发，新请求不会被服务，旧请求在单个集群中被接受，同时另一个集群接受新请求。我们将在第七章中看到断路器的实时示例，*服务状态和服务间通信*。

# 版本控制和依赖解析

当微服务非常细粒度并且基于单一职责原则设计时，它们只处理特定的问题，因此它们变得啰嗦（太多的网络调用）：也就是说，为了执行一组常规任务，需要向不同的服务发送许多请求。网关可以提供虚拟端点或外观，可以在内部路由到许多不同的微服务。API 网关可以解析所有依赖关系，并将所有响应分离成一个单一的响应，从而使客户端易于消费。此外，随着不断变化的业务需求和能力，我们需要保持版本控制，因此在任何时候，我们都可以回到旧服务。

API 版本控制有两种方式进行管理——一种是通过在 URI 中发送（URI 不要与 URL 混淆，它是包含信息的统一资源标识符，例如`http://example.com/users/v4/1234/`），另一种是通过在标头中发送。API 网关可以通过以下两种方式处理这个问题：

+   **微服务发现**：这是最广泛使用的模式，其中微服务和客户端应用程序之间的耦合完全消除，因为微服务是动态注册的（我们将在下一章中更详细地看到这一点）。这个组件直接与 API 网关联系，并向其提供有关服务位置的信息，从而防止传统的 SOA 单片式方法。

+   **微服务描述**：另一方面，这种方法更注重通过合同进行通信。它以非常详细的描述性合同表达微服务的特性，这些合同可以被其他客户端应用程序理解。合同还包含元数据信息，如 API 版本、要求等。

在这一部分，我们看了 API 网关副处理的所有关注点。对于 API 网关，应特别注意以下几个方面：

+   它不应该是单点故障

+   它不应该是集中化的或具有同步协调

+   它不应该依赖于任何状态

+   它应该只是另一个微服务

+   业务逻辑不应该封装在内部

# API 网关设计模式和方面

现在我们知道 API 网关处理什么，让我们现在看看 API 网关涉及的常见设计方面。在这一部分，我们将看看在设计 API 网关时需要考虑的所有设计方面。我们将了解设计 API 网关的模式，这将帮助我们设计一个具有高可用性的可扩展系统。

作为处理集中关注点并且是微服务的起点的核心部分，API 网关应该被设计成：

+   **它支持并发性**：由于基于单一责任的设计而具有高度分布性，需要服务器端并发性，这可以减少网络通信。Node.js 是非阻塞和异步的，每个请求都与其他请求并行执行，因此单个重型客户端请求并不比许多轻量级非并发请求好多少。虽然业务用例可能需要对后端系统进行阻塞调用，但 API 网关应该通过响应式框架以高效的方式组合这些调用，这不会增加资源池的利用率。

+   **它应该是反应式的**：反应式编程提供了各种操作符，能够过滤、选择、转换、组合和组合可观察对象，从而在 API 网关层实现高效的执行和组合。它提倡随时间填充的变量的概念。它提倡非阻塞架构，因为在可观察模式中，生产者只是在值可用时向消费者推送值，而不是在那段时间内阻塞线程。值可以在任何时间点异步或同步到达。它还有额外的优势，比如生产者可以向消费者发出结束信号，告诉消费者没有更多的数据，或者发生了错误。

+   **服务层遵循可观察模式**：当 API 网关中的所有方法都返回`Observable<T>`时，默认启用并发性。服务层然后遵循诸如根据条件返回缓存响应以及如果资源不可用或服务不可用，则阻止请求等操作。这可以在不改变客户端端的情况下发生。

+   **它处理后端服务和依赖关系**：由于网关在虚拟外观层后面抽象了所有后端服务和依赖关系，因此任何入站请求都可以访问业务能力而不是整个系统。这将允许我们在对依赖它的代码影响有限的情况下更改底层实现。因此，服务层确保所有模型和紧密耦合保持内部，并且被抽象化并且不允许泄漏到端点中。

+   **它们应该是无状态的**：API 网关应该是无状态的，这意味着不创建任何会话数据。这将使我们能够扩展网关，因为在灾难情况下不需要在以后复制会话。但是，API 网关可以维护缓存数据，可以使用点对点关系复制这些数据，或者引入缓存库（如 Redis）而不是进行内存调用。以下是一些常见陷阱的一般指导方针：

+   为了实现最佳的可用性，API 网关应该在主动-主动模式下使用。这意味着系统应该始终保持完全运作，并能够维持当前的系统状态。

+   适当的分析和监控工具以防止消息洪泛。在这种情况下，对该服务的流量应该受到限制。

+   使用工具不断监视系统，可以通过一些可用的工具、系统日志或网络管理协议。

主动-主动模式是一种处理故障转移、负载平衡和保持系统高度可用性的方法。这里使用两个或更多服务器，它们聚合网络流量负载，并一起工作作为一个团队将其分配给可用的网络服务器。负载均衡器还会持久保存信息请求，并将此信息保存在缓存中。如果它们返回寻找相同的信息，用户将直接锁定到之前提供其请求的服务器上。这个过程大大减少了网络流量负载。

# 断路器及其作用

在实际世界中，错误确实会发生。服务可能会超时，变得无法访问，或者需要更长时间才能完成。作为一个分布式系统，整个系统不应该崩溃。断路器是解决这个问题的方法，它是 API 网关中非常重要的组件。

该模式基本上分为两种状态。如果电路关闭，一切正常，请求被分派到目的地，接收到响应。但如果有错误或超时，电路就会打开，这意味着该路由目前不可用，我们需要采用不同的路线或方式来实现服务请求。为了实现这个功能，Netflix 开源了他们的项目——Hystrix。然而，这是同样的 Node.js 版本：[`www.npmjs.com/package/hystrixjs`](https://www.npmjs.com/package/hystrixjs)（这不是 Netflix 官方的，而是一个开源项目）。它甚至有用于监控目的的 Hystrix 仪表板。根据 Hystrix 的库，它具有以下功能：

+   保护系统免受因网络问题或任何第三方客户端或库而发生的任何故障

+   停止传播失败，避免错误的扩散

+   快速失败，经常失败，更好地失败，向前失败，并迅速恢复与对策

+   使用回退机制来降级失败，比如从缓存中返回响应

+   提供监控目的的仪表板

看一下下面的图表：

![](img/64667362-37e9-489f-b474-fd082acb167c.png)

断路器遵循与原始**Hystrix**模块相同的一套规则。为了计算命令的健康状况，执行以下步骤：

1.  在整个电路中保持对音量的监控如下：

+   如果电路中的网络音量没有超过预定义值，那么 Hystrix 可以简单地执行运行函数，而根本不需要比较任何东西。度量可以记录所有这些情况以供将来参考。

+   如果电路中的网络音量超过配置的边界值，Hystrix 可以首先检查健康状况以采取预防措施。

+   在检查健康状况时，如果错误百分比超过预定义的阈值，电路的转换会从关闭到打开，所有后续的请求都将被拒绝，以防止进一步的请求。

1.  经过一段时间的组织，Hystrix 可以允许一个请求通过以检查服务是否已恢复。如果它通过了期望的测试，电路再次转换为关闭状态，并且所有计数器被重置。要在应用程序中使用它，只需创建服务命令并添加值：

```ts
var serviceCommand = CommandsFactory.getOrCreate("Service on port :"+ service.port +":"+ port)
 .circuitBreakerErrorThresholdPercentage(service.errorThreshold)
 .timeout(service.timeout)
 .run(makeRequest)
 .circuitBreakerRequestVolumeThreshold(service.concurrency)
 .circuitBreakerSleepWindowInMilliseconds(service.timeout)
 .statisticalWindowLength(10000)
 .statisticalWindowNumberOfBuckets(10)
 .errorHandler(isErrorHandler)
 .build();
 serviceCommand.service = service;
 commands.push(serviceCommand);
```

1.  要执行这些命令，只需使用 execute 方法。在`hystrix`文件夹中的源代码中可以找到完整的要点。

# 我们购物车微服务中网关的需求

在详细解释网关之后，让我们回到我们的购物车微服务系统。我们将看看我们系统中网关的需求以及它将处理的内容，然后继续设计网关。在本节中，我们将看看在设计网关时需要考虑的各种设计方面。

# 处理性能和可伸缩性

作为系统性能、可伸缩性和 API 网关高可用性的入口点，非常关键。因为它将处理所有请求，使其成为异步非阻塞 I/O 似乎非常合乎逻辑，这正是 Node.js 的特点。来自我们的购物车微服务的所有请求都需要经过身份验证、缓存、监控，并不断发送健康检查。考虑一个场景，我们的产品服务有大量流量。API 网关应该自动产生服务器的新实例并维护新实例的地址。然后新实例需要不断向网关发送健康检查，以便知道哪些实例是活着的。考虑之前我们看到的同样的例子，我们有产品微服务，我们需要向客户显示 20 个项目的详细列表。现在客户不会发出 21 个 HTTP 请求，而是我们需要一个核心组合组件，它将从各种请求中组合响应。

# 响应式编程提高胜算

为了确保我们不必频繁更改客户端代码，API 网关简单地将客户端请求路由到微服务。它可能通过进行多个后端服务调用来发出其他请求，然后聚合所有结果。为了确保最小的响应时间，API 网关应该同时进行独立调用，这就是响应式编程模型发挥作用的地方。在各种情况下都需要 API 组合，比如获取用户的过去订单，我们首先需要获取用户详情，然后获取他们的过去订单。使用传统的异步回调编写组合逻辑很快就会导致回调地狱的问题，这将产生耦合、混乱、难以理解和容易出错的代码，这就是响应式编程非常有帮助的地方。

# 调用服务

微服务确实需要根据业务能力同步或异步地相互通信。必须有进程间通信机制。我们的购物车微服务可以有两种通信模式。一种涉及消息代理，它排队消息并在可用时将它们发送到服务。另一种涉及无代理通信，服务直接与另一个服务通信，这可能会导致数据丢失。有许多事件驱动的消息代理，如 AMQP、RabbitMQ 等，还有一些无代理的，如 Zeromq。

一些业务能力需要异步通信模式，比如在产品结账时，我们需要调用支付服务。只有成功支付，产品才能被购买。API 网关需要支持基于业务能力的各种机制。我们将在第七章中看到一个实时例子，*服务状态和服务间通信*，在*NetFlix 案例研究*部分。

# 发现服务

随着不断动态和发展的服务，我们的网关需要知道系统中每个微服务的位置（IP 地址、服务端口）。现在，这可以在系统中进行热插拔，但由于它们不断发展，我们需要更动态的方法，因为服务不断自动扩展和升级。例如，在我们的购物车微服务中，我们可能会根据用例不断添加新服务。现在 API 网关需要知道这些服务的位置，以便随时查询任何服务以返回响应给客户端。API 网关必须与服务注册表保持通信，服务注册表只是所有微服务位置及其实例的数据库。

# 处理部分服务故障

另一个需要解决的问题是处理部分故障。当一个服务调用另一个服务时，可能根本不会收到响应，或者可能会收到延迟的响应。随着服务数量的增加，任何服务都可能在任何时间点宕机。API 网关应能够通过实施以下一些/全部策略来处理部分故障：

+   默认使用异步通信模式。仅在需要时使用同步模式。

+   应处理多次重试，采用指数退避，即 1、2、4、16 等。

+   定义良好的网络超时，以防止资源阻塞。

+   断路器模式用于在服务宕机或过载时中断请求。

+   回退或返回缓存值。例如，产品的图像不会经常更改，可以进行缓存。

+   监控排队请求的数量。如果数量超过限制，那么发送进一步的请求就没有意义。

# 设计考虑

一个良好的 API 网关应遵循以下设计考虑，以便拥有坚固的微服务设计：

+   **依赖性：**不应依赖任何其他微服务。API 网关只是另一个微服务。如果任何服务 ID 在预先配置的时间内不可用或不遵循 SLA，则 API 网关不应等待该服务。它应该使用断路器或其他回退策略快速失败，如返回缓存响应。

+   **数据库和业务逻辑：**API 网关不应具有数据库连接。网关是愚蠢的，即它们没有任何状态。如果需要数据库，我们需要创建一个单独的微服务。同样，业务逻辑应该驻留在服务本身。网关只是将任何服务请求路由到适当的目的地。

+   **编排和处理多种内容类型：**服务编排（微服务相互通信的模式）应该在 API 网关而不是编排中完成。网关应连接到服务注册表，这样我们就可以得到动态移动服务的位置。

+   **版本控制：**网关应具有适当的版本控制策略。就像我们需要将一块巨大的岩石移到山上，但由于它太大，我们将岩石分成较小的块并分发给每个人。现在每个人都会按自己的步伐前进，但这并不意味着他必须满足其他人的期望，因为最终重要的是整块岩石而不是较小的块。同样，服务的任何特定版本都不应该破坏暴露的合同。新合同应根据需要进行更新，以便其他客户端了解新的期望，直到需要向后兼容性。

+   **高可用性：**它应该是高可用和可扩展的。应该为高容量和高负载进行规划。如果部署在云中，我们可以选择：AWS 自动扩展。

在下一节中，我们将深入研究可用的网关选项并进行详细讨论。我们还将查看一些云提供商选项，并了解每个选项的优缺点。

# 可用的 API 网关选项

现在让我们看一些可用的 API 网关的实际实现。在本节中，我们将看到 Express 网关、Netflix OSS、消息代理、NGINX 作为反向代理以及用于设计网关的工具等选项。

# HTTP 代理和 Express 网关

HTTP 代理是用于代理的 HTTP 可编程库。这对于应用反向代理或负载平衡非常有帮助。npm 中可用的`http-proxy`每天的下载量超过 10 万次。为了实现请求分发，我们可以使用`http-proxy`。这很容易实现，可以像这样实现：

```ts
const express = require('express')
const httpProxy = require('express-http-proxy')
const app = express();
const productServiceProxy= httpProxy('https://10.0.0.1/') 
//10.0.0.1 is product container location
// Authentication
app.use((req, res, next) => {
    // TODO: Central Authentication logic for all
    next()
    })
// Proxy request
app.get('/products/:productId', (req, res, next) => {
    productServiceProxy(req, res, next)
```

Express 网关是基于 Express.js 和 Node.js 构建的网关之一，是最简单易用的，具有诸如面向微服务用例的语言不可知性和可移植性等广泛选项，因此可以在 Docker 中的任何地方（公共或私有云）运行。它可以与任何 DevOps 工具一起使用，并且配备了预打包的经过验证和流行的模块。我们可以使用任何 express 中间件来扩展它，这完全基于配置，配置会自动检测并进行热重载。以下是 Express 网关中的核心组件：

| **端点（API 和服务）** | 它们只是 URL。Express 网关以两种形式维护它们。API 端点和服务端点。API 端点是公开的，并将 API 请求代理到服务中请求的微服务。 |
| --- | --- |
| **策略** | 一组条件、操作或合同，用于评估并对通过网关的任何请求采取行动。中间件被利用。 |
| **管道** | 一组与微服务相关联的策略，按顺序执行。对于策略执行，API 请求通过管道，最终遇到一个代理策略，该策略指导请求到服务端点。 |
| **消费者** | 消费微服务的任何人。为了处理不同的消费者，Express 网关配备了一个消费者管理模块。其中的黄金法则是应用程序必须属于一个用户。 |
| **凭证** | 认证和授权的类型。消费者或用户可能有一个或多个凭证。凭证与范围相关联。Express 网关配备了凭证管理模块。 |
| **范围** | 用于分配授权的标签。保护端点的授权策略查看凭证，以确保系统的完整性，并且消费者具有相应的范围。 |

现在让我们看一个 Express 网关的示例。以下是使用 Express 网关生成的`gateway.config.yml`文件的示例（[`www.express-gateway.io/`](https://www.express-gateway.io/)）。

```ts
http:
  port: 8990
  serviceEndpoints:
    example: # will be referenced in proxy policy
    url: 'http://example.com'
  apiEndpoints:
  api:
    path: '/*'
  pipelines:
  example-pipeline:
    apiEndpoints: # process all request matching "api" apiEndpoint
    - api
  policies:
  - jwt:
  - action:
  secretOrPublicKeyFile: '/app/key.pem'
  - proxy:
  - action:
  serviceEndpoint: example # reference to serviceEndpoints Section
```

上述配置是网关和代理路由中 JWT 的最简单示例，并且是不言自明的。

# Zuul 和 Eureka

接下来我们要看的选项是 Netflix 提供的 Zuul 代理服务器。Zuul 是一个边缘服务，其目标是代理请求到各种后端服务。因此，它充当了消费服务的“统一前门”。Zuul 可以与 Netflix 提供的其他开源工具集成，例如 Hystrix 用于容错、Eureka 用于服务发现、路由引擎、负载平衡等。Zuul 是用 Java 编写的，但可以用于任何语言编写的微服务。Zuul 在以下方面提供了便利：

+   验证每个资源的合同要求。如果合同未得到满足，则拒绝那些不符合要求的请求。

+   通过跟踪有意义的数据和统计信息，为我们提供准确的生产视图。

+   连接到服务注册表，并根据需要动态路由到不同的后端集群。

+   为了逐渐增加集群中的流量来衡量性能。

+   丢弃超出限制的请求，从而通过为每种类型的请求分配容量来实现负载分担。

+   处理静态或缓存响应，从而防止内部容器的频繁访问。

Zuul 2.1 正在积极开发，旨在在网关级别实现异步操作。然而，Zuul 2 是非阻塞的，并且完全依赖于 RxJava 和响应式编程。要将 Zuul 作为 API 网关运行，请执行以下步骤：

1.  Zuul 需要 Java 环境。克隆以下 Spring boot 项目：[`github.com/kissaten/heroku-zuul-server-demo`](https://github.com/kissaten/heroku-zuul-server-demo)

1.  使用`mvn spring-boot:run`启动项目。

1.  在项目的`src/main/resources/application.yml`文件中，我们将编写我们的 Zuul 过滤器逻辑。

1.  我们将在那里添加故障转移逻辑。例如考虑以下示例配置：

```ts
zuul:
  routes:
    httpbin:
      path: /**
      serviceId: httpbin
    httpbin:
    ribbon:
      listOfServers: httpbin.org,eu.httpbin.org
    ribbon:
eureka:
  client:
    serviceUrl:
    defaultZone:  
    ${EUREKA_URL:http://user:password@localhost:5000}/eureka/
```

此配置告诉`zuul`将所有请求发送到`httpbin`服务。如果我们想在这里定义多个路由，我们可以。然后，`httpbin`服务定义了可用服务器的数量。如果第一个主机出现故障，那么代理将故障转移到第二个主机。

下一章通过另一个 Netflix 库 Eureka 实现了服务发现。

# API 网关与反向代理 NGINX

在本节中，我们将查看服务器级别可用的可能选项。反向代理（NGINX 或 Apache httpd）可以执行诸如验证请求、处理传输安全性和负载平衡等任务。NGINX 是在微服务网关级别使用反向代理的广泛工具之一。以下代码示例描述了使用反向代理、SSL 证书和负载平衡的配置：

```ts
#user gateway;
 worker_processes 1;
 events {worker_connections 1024;}
 http {
     include mime.types;
     default_type application/json;
     keepalive_timeout 65;
     server {
         listen 443 ssl;
         server_name yourdomain.com;
         ssl_certificate cert.pem;
         ssl_certificate_key cert.key;
         ssl_session_cache shared:SSL:1m;
         ssl_session_timeout 5m;
         ssl_ciphers HIGH:!aNULL:!MD5;
         ssl_prefer_server_ciphers on;
         location public1.yourdomain.com {proxy_pass  
         http://localhost:9000;}
         location public2.yourdomain.com {proxy_pass 
         http://localhost:9001;}
         location public3.yourdomain.com {proxy_pass   
         http://localhost:9002;}
     }
 }
```

上述配置在中心级别添加了 SSL 证书，并在三个域中添加了代理，并在它们之间平衡所有请求。

# RabbitMQ

RabbitMQ 是最广泛部署的消息代理之一，它使用 AMQP 协议。Node.js 的`amqplib`客户端被广泛采用，每天的下载量超过 16,000 次。在本节中，我们将查看`amqp`的示例实现，并了解它提供的选项。RabbitMQ 更多地遵循基于事件的方法，其中每个服务都监听 RabbitMQ 的“tasks”队列，当监听到事件时，服务完成其任务，然后将其发送到`completed_tasks`队列。API 网关监听`completed_tasks`队列，当收到消息时，将响应发送回客户端。因此，让我们通过执行以下步骤设计我们的 RabbitMQ 类：

1.  我们将定义我们的构造函数如下：

```ts
constructor(host, user, password, queues, prefetch) {
    super();
    this._url = `amqp://${user}:${password}@${host}`;
    this._queues = queues || [ 'default' ];
    this._prefetch = prefetch;
}
```

1.  接下来，我们将定义我们的连接方法如下：

```ts
connect() {
    return amqp.connect(this._url)
    .then(connection => (this._connection =  
    connection).createChannel())
    .then(channel => {
        this._channel = channel;
        channel.prefetch(this._prefetch);
        var promises = [];
        for (var queue of this._queues) {
            promises.push(
            channel.assertQueue(queue, { durable: true })
            .then(result => channel.consume(result.queue, 
            (message) => {
                if (message != null) {
                    this.emit('messageReceived',  
                    JSON.parse(message.content), 
                    result.queue, message);
                }
            }, { noAck: false }))
            );
        }
        return Promise.all(promises);
    });
}
```

1.  接下来，我们将有一个`send`方法，该方法将消息发送到 RabbitMQ 通道，如下所示：

```ts
send(queue, message) {
    var messageBuff = new Buffer(JSON.stringify(message));
    return this._channel.assertQueue(queue, { durable: true })
    .then(result => this._channel.sendToQueue(result.queue, 
    messageBuff, { persistent: true }));
}
```

您可以在此处查看完整文件，其中将找到所有可用选项。与之前的用例类似，您还可以在 definitely typed 存储库中找到`amqp`模块的类型[`gist.github.com/insanityrules/4d120b3d9c20053a7c6e280a6d5c5bfb`](https://gist.github.com/insanityrules/4d120b3d9c20053a7c6e280a6d5c5bfb)。

1.  接下来，我们只需使用该类。例如，看一下以下代码：

```ts
...
constructor(){ this._conn = new RabbitMqConnection(host, user, password, queues, 1);}
...
addTask(queue, task) {
    return this._conn.send(queue, task);
}
...
```

作为此项目的先决条件，RabbitMQ 必须安装在系统上，这需要安装 Erlang。一旦 RabbitMQ 启动运行，您可以通过键入`rabbitmqctl status`来检查 RabbitMQ 服务是否正在运行。

# 设计我们的购物车微服务网关

在看到各种选项后，现在让我们动手开始实现购物车微服务的微服务网关。在本节中，我们将从头开始实现网关，该网关将具有从公共端点到内部端点的请求分派功能，从多个服务聚合响应，并处理传输安全性和依赖关系解析。在继续编码之前，让我们先看一下我们将在此模块中使用的所有概念。

# 我们将使用什么？

在本节中，我们将查看所有以下节点模块和概念，以便有效地构建我们的网关：

+   **ES6 代理**：一般来说，代理服务器是指作为客户端请求的中间服务器。ES6 中最强大和有趣的功能之一就是代理。ES6 代理在 API 消费者和服务对象之间充当中间人。当我们希望在访问基础目标对象的属性时获得自己想要的行为时，通常会创建代理。为了配置代理的陷阱，控制基础目标对象，我们使用处理程序函数。

+   **NPM 模块 dockerode**：它是用于 Docker 远程 API 的 Node.js 响应式模块。它具有一些不错的功能，如用于响应式编程的流、支持附加的多路复用和承诺以及基于回调的接口，便于编程。

+   **依赖注入**：这是最重要的设计模式之一（最初在 Java 中开始，现在到处都有），其中一个或多个服务的依赖项被注入或通过引用传递给依赖对象。

请查看`第五章`的源代码，其中包括服务发现的自定义实现。在完成`第六章`后，您可以重新访问这个练习。

# 总结

在本章中，我们揭示了 API 网关。我们了解了引入 API 网关的利弊，以及 API 网关可以集中处理哪些问题。我们研究了 API 网关的设计方面，并了解了在我们的系统中需要 API 网关的原因。我们看了一下断路器以及为什么拥有它是至关重要的。我们研究了可用的网关选项，如 Zuul、Express Gateway、反向代理，并为购物车微服务设计了我们自己的网关。

在下一章中，我们将学习服务注册表和服务发现。我们将看到网关如何连接到服务发现，自动了解移动服务的位置。我们将看到服务可以注册的方式，并了解每种方法的利弊。我们将看到一些选项，比如 consul，并在我们的购物车微服务中实现它们。
