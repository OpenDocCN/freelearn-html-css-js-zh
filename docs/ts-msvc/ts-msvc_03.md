# 第三章：探索响应式编程

到目前为止，我们描述了我们的应用程序是非常著名的行业术语的混合体，如异步、实时、松散耦合、可扩展、分布式、消息驱动、并发、非阻塞、容错、低延迟和高吞吐量。在本章中，我们将进一步了解响应式编程，它将所有这些特征汇集在一起。我们将看到并了解响应式宣言-一组原则，当集体应用时，将带来所有前述的优势。我们将了解响应式微服务的一些关键方面，它应该是什么，响应式编程的主要优势是什么。我们将看看响应式编程解决了什么问题，响应式编程的不同风格，等等。

在本章中，我们将重点关注以下内容：

+   响应式编程介绍

+   响应式宣言

+   响应式微服务-主要构建模块和关注点

+   何时反应，何时不反应（编排）-混合方法的介绍

+   在 Node.js 中成为响应式

# 响应式编程介绍

如果我们想从 5 万英尺的高空看响应式编程的视图，它可以简要地被称为：

<q>当任何函数中的输入 x 发生变化时，相应的输出 y 会在对应的响应中自动更新，而无需手动调用。简而言之，唯一的目的是在输出世界提示时不断响应外部输入。</q>

响应式编程是通过 map、filter、reduce、subscribe、unsubscribe、streams 等实用程序实现的。响应式编程更注重事件和消息驱动模式，而不是手动处理庞大的实现细节。

让我们以一个实际的日常例子来理解响应式编程。我们从 IT 生涯的开始就使用 Excel。现在，假设你根据一个单元格的值编写一个公式。现在，每当单元格的值发生变化时，基于该值的所有相应结果都会自动反映出变化。这就是所谓的**响应式**。

简要了解响应式编程，当与处理各种数据流相结合时，响应式编程可以是具有处理以下内容的高级数据流的能力：

+   事件流，我们可以接入和订阅的流，然后使用订阅输出作为数据源。

+   拥有流使我们能够操作流，从原始流创建新流，并根据需要应用转换。

+   转换应该在分布式系统中独立工作。特定的转换可以是从各个地方接收到的多个流的合并。

我们将使用函数式响应式编程。简而言之，我们的函数式响应式微服务应具有以下两个基本属性：

+   **指示性或表示性**：每个函数、服务或类型都是精确、简单、单一、负责和实现无关的。

+   **连续时间**：编程应该考虑到时间变化的值。函数式响应式编程中的变量值持续时间很短。它应该为我们提供转换灵活性、效率、模块化、单一责任。

函数式响应式编程的特点如下：

+   **动态**：知道如何对时间做出反应或处理各种输入变化

+   处理时间变化：当反应值不断变化时，处理适当的变化

+   **高效**：当输入值发生变化时，只在需要时进行最少量的处理

+   **了解历史转换**：在本地维护状态变化，而不是全局

既然我们简要了解了响应式编程，让我们看看在采用响应式编程时我们能得到什么优势。下一节将讨论并给出非常强烈的理由，说明为什么你应该放下一切开始响应式编程。

# 为什么我应该考虑采用反应式编程？

现在我们已经揭开了反应式编程的神秘面纱，下一个重要问题是为什么我们应该关注反应式编程以及在进行反应式编程时可以获得什么优势。在本节中，我们将看到反应式编程的主要优势以及如何轻松地管理代码，以在任何时候引入重大新功能：

+   与回调或中间件相比，更容易解释或利用任何功能。

+   轻松处理错误和内存管理，无需任何集中配置。单个订阅可以有一个错误函数，您可以轻松地处理资源。

+   高效处理与时间相关的复杂性。有时，我们受到调用一些外部 API 的速率限制约束，例如 Google Cloud Vision API。在这种情况下，反应式编程具有巨大的用例。

+   走向市场率更快。当正确实施时，反应式编程大大减少了老式代码到很少的代码行。

+   易于处理可节流的输入流，即，我的输入流是动态的。它可以根据需求增加或减少。

现在我们已经了解了反应式编程的一些主要优势，在下一节中我们将讨论反应式编程的结果，即反应式系统。我们将看到在反应式宣言中定义的一组标准。

# 反应式宣言

反应式系统旨在更松散耦合，灵活，易于迁移，并且可以根据需求轻松扩展。这些特质使其易于开发，优雅地处理故障，并对错误做出反应。错误会得到优雅的处理，而不是引起恐慌性灾难。反应式系统是有效的，并立即做出反应，为用户提供有效和互动的反馈。为了总结反应式系统的所有特征，引入了**反应式宣言**。在本节中，我们将看一下反应式宣言和所有所需的标准。现在，让我们看看反应式宣言陈述了什么。

# 响应式系统

作为响应标准的一部分，反应式系统始终需要响应。它们需要及时地向用户提供和响应。这提高了用户体验，我们可以更好地处理错误。服务的任何故障都不应传播到系统，因为这可能会导致一系列错误。响应是一个重要的事情。即使服务降级，也应该提供响应。

# 对错误具有弹性

系统应该对所有错误具有弹性。弹性应该是这样的，错误应该得到优雅处理，而不是导致整个系统崩溃。可以通过以下方式实现弹性架构：

+   复制以确保在主节点出现故障时有一个副本。这避免了单点故障。为了确保组件或服务应该以这样一种方式委托服务，以便单一责任得到处理。

+   确保系统中的组件被包含在其边界内，以防止级联错误。组件的客户端不需要处理自己的故障。

# 弹性可扩展

这通常用于指代系统处理不同负载的能力，通过增加或减少在某个时间内利用的资源数量。反应式系统应该能够对某一时刻的负载做出反应，并相应地采取行动来提供成本效益的解决方案，即在资源不需要时缩减规模，在需要时仅扩展到所需资源的百分比，以保持基础设施成本在预设值以下。系统应该能够分片或复制组件，并在它们之间分发输入。系统应该能够根据需要为客户服务请求生成下游和上游服务的新实例。应该有一个高效的服务发现过程来帮助弹性扩展。

# 消息驱动

异步消息传递是反应式系统的基础。这有助于我们在组件之间建立边界，并同时确保松耦合、隔离和位置透明性。如果某个特定组件现在不可用，系统应该将失败委托为消息。这种模式帮助我们通过控制系统中的消息队列来实现负载管理、弹性和流量控制，并在需要时应用反压。非阻塞通信会减少系统开销。有许多可用于消息传递的工具，如 Apache Kafka、Rabbit MQ、Amazon Simple Queue Service、ActiveMQ、Akka 等。代码的不同模块通过消息传递相互交互。深入思考反应式宣言，微服务似乎只是反应式宣言的延伸。

# 主要构建模块和关注点

继续我们的反应式之旅，我们现在将讨论反应式编程（确切地说是函数式反应式编程）的主要构建模块以及反应式微服务实际应该处理的关注点。以下是反应式编程的主要构建模块及其处理的内容。反应式微服务应该基于类似的原则进行设计。这些构建模块将确保微服务是隔离的，具有单一职责，可以异步传递消息，并且是可移动的。

# 可观察流

可观察流实际上就是随时间构建的数组。项目不是存储在内存中，而是随时间异步到达。可观察流可以被订阅，并且可以监听并对其发出的事件做出反应。每个反应式微服务都应该能够处理本机可观察事件流。可观察对象允许您通过调用系列中的`next()`函数向订阅者发出值。

+   热和冷可观察流：可观察流根据订阅者的生产者进一步分类为热和冷。如果需要创建多次，则称为热可观察流，而如果只需要创建一次，则称为冷可观察流。简单来说，热可观察流通常是多播，而冷可观察流通常是单播。举个例子，当你在 YouTube 上打开任何视频时，每个订阅者都会看到相同的序列，从开始到结束，这基本上是一个冷可观察流。然而，当你打开一个直播流时，你只能看到最近的视图并进一步查看。这是一个热可观察流，其中只有对生产者/订阅者的引用，生产者并不是从每次订阅的开始创建的。

+   **主题**：主题只是一个可以自行调用`next()`方法的可观察对象，以便根据需要发出新值。主题允许您从一个公共点广播值，同时限制订阅只发生一次。创建一个共享订阅。主题可以被称为观察者和可观察对象。它可以充当一组订阅者的代理。主题用于实现通用工具的可观察对象，如缓存、缓冲、日志等。

# 订阅

虽然可观察对象是随时间填充的数组，但**订阅**是一个随时间迭代该数组的`for`循环。订阅提供了易于使用和易于处理的方法，因此没有内存加载问题。在取消订阅时，可观察对象将停止监听特定的订阅。

# 发射和映射

当一个可观察对象抛出一个值时，有一个订阅者监听可观察对象抛出的值。**发射**和**映射**允许您监听这个值并根据您的需求对其进行操作。例如，它可以用于将 HTTP 可观察对象的响应转换为 JSON。为了进一步扩展链，提供了`flatMap`操作符，它从函数的返回值创建一个新的流。

# 操作符

当一个可观察对象发出值时，它们并不总是以我们期望的形式。操作符很有用，因为它们帮助我们改变可观察对象发出值的方式。操作符可以在以下阶段使用：

+   在创建可观察序列时

+   将事件或一些异步模式转换为可观察序列

+   处理多个可观察序列，将它们合并为单个可观察对象

+   共享可观察对象的副作用

+   对可观察序列进行一些数学转换

+   基于时间的操作，如节流

+   处理异常

+   过滤可观察序列发出的值

+   分组和窗口化发出的值

# 反压策略

到目前为止，我们已经玩过可观察对象和观察者。我们使用数据流（可观察对象）模拟了我们的问题，将其转换为我们期望的输出（使用操作符），并丢弃了一些值或一些副作用（观察者）。现在，也可能出现这样一种情况，即可观察对象的数据抛出速度比观察者处理速度快。这最终导致数据丢失，这就是**反压问题**。为了处理反压，我们需要接受数据丢失，或者我们需要缓冲可观察流并在不允许数据丢失时以块的方式处理它。在这两种选择中都有不同的策略：

| **当输掉是一个选择** | **当输掉不是一个选择** |
| --- | --- |
| **去抖动**：只有在经过一段时间后才发出数据。 | **缓冲**：设置一定时间或最大事件数来缓冲。 |
| **暂停**：暂停源流一段时间。 | **缓冲暂停**：缓冲源流发出的任何内容。 |
|  | **受控流**：这是生产者推送事件，消费者只拉取它能够处理的事件的推送-拉取策略。 |

# 柯里化函数

**柯里化**是一个逐个评估函数参数的过程，在每次评估结束时产生一个少一个参数的新函数。当函数的参数需要在不同的地方进行评估时，柯里化是有用的。使用柯里化过程，一个参数可以在某个组件中进行评估，然后可以传递到任何其他地方，然后结果可以传递到另一个组件，直到所有参数都被评估。这似乎与我们的微服务类比非常相似。当我们有服务依赖关系时，我们将在以后使用柯里化。

# 何时做出反应，何时不做出反应（协调）

现在，我们已经熟悉了微服务的核心概念。我们经常接触的下一个问题是关于微服务的实现，以及它们如何相互交互。最常见的问题是何时使用编排，何时使用反应，以及是否可能使用混合方法。在本节中，我们将了解每种方法，其优缺点，并查看每种方法的实际示例。让我们从编排开始。

# 编排

**编排**更多地是一种**面向服务的架构（SOA）**方法，在 SOA 中我们处理各种服务之间的交互。当我们说编排时，我们维护一个控制器，即编排者或所有服务交互的主协调者。这通常遵循更多的请求/响应类型模式，其中通信模式可以是任何东西。例如，在我们的购物微服务中可以有一个编排者，它同步执行以下任务——首先接受客户订单，然后检查产品，准备账单，成功付款后更新产品库存。

# 优势

它提供了一种系统化的处理编程流程的方式，您可以实际控制请求的发出方式。例如，您可以确保只有在请求 A 完成后才能成功调用请求 B。

# 缺点

虽然编排模式看起来有利，但这种模式涉及到一些权衡，比如：

+   对系统有严格的依赖。比如如果最初的某个服务宕机，那么链中的下一个服务将永远不会被调用。系统很快就会成为一个瓶颈，因为会有几个单点故障。

+   系统中将引入同步行为。总的端到端时间将是处理所有单个服务所需时间的总和。

# 反应式方法

微服务是为了能够独立存在的。它们不应该相互依赖。**反应式方法**倾向于解决编排方法的一些挑战。与控制逻辑在何时发生哪些步骤的编排器不同，反应式模式促进了服务知道逻辑要提前构建和执行。服务知道要对什么做出反应以及如何提前处理。服务之间的通信模式是愚蠢的管道，它们内部没有任何逻辑。由于其异步性质，它消除了编排过程中的等待部分。服务可以产生事件并继续处理。生产和消费服务是解耦的，因此生产者不需要知道消费者是否在线。在这种方法中可以有多种模式，其中生产者可能希望从消费者那里收到确认。集中的事件流在反应式方法中处理所有这些事情。

# 优势

反应式方法有很多优势，它克服了许多传统问题：

+   并行或异步执行可以更快地完成端到端处理。异步处理基本上不会在提供请求时阻止资源。

+   拥有集中的事件流或愚蠢的通信管道作为通信模式具有在任何时间点轻松添加或删除任何服务的优势。

+   系统的控制是分布式的。系统中不再有单一故障点作为编排者。

+   当这种方法与其他几种方法结合时，就可以实现各种好处。

+   当这种方法与事件溯源结合时，所有事件都被存储，并且它可以进行事件重放。因此，即使某个服务宕机，事件存储仍然可以在服务再次在线时重放该事件，并且服务可以检查更新。

+   另一个优点是**命令查询责任分离**（**CQRS**）。如第一章所示，*揭秘微服务*，我们可以将这种模式应用于分离读取和写入活动。因此，任何服务都可以独立扩展。这在应用程序是读取或写入密集型的情况下非常有帮助。

# 缺点

虽然这种方法解决了大部分复杂性，但也引入了一些权衡：

+   异步编程有时可能很难处理。仅通过查看代码无法弄清楚。必须深入了解事件循环，如第二章所示，*为旅程做准备*，才能理解*异步编码*的实际工作流程。

+   复杂性和集中的代码现在转移到了各个服务中。流程控制现在被分解并分布到所有服务中。这可能会在系统中引入冗余代码。

像所有事物一样，一刀切的方法在这里行不通。出现了几种混合方法，它们充分利用了两种过程。现在让我们来看看一些混合方法。混合方法可以增加很多价值。

# 外部反应，内部编排

第一个混合模式促进了不同微服务之间的反应式模式和服务内的编排。让我们举个例子来理解这一点。考虑我们的购物微服务示例。每当有人购买产品时，我们将检查库存，计算价格，处理付款，结账付款，添加推荐产品等。每个微服务都是不同的。在这里，我们可以在产品库存服务、付款服务和推荐产品之间采用反应式方法，在结账服务、处理付款和发货产品之间采用编排方法。一个集体服务根据这三个服务的结果产生一个事件，然后可以产生。有几个优点和附加值，例如：

+   大多数服务是解耦的。只有在需要时才会出现编排。应用程序的整体流程是分布式的。

+   具有异步事件和基于事件的方法可确保没有单点故障。如果服务错过了事件，那么可以在服务再次上线时重放事件。

虽然有几个优点，但也引入了一些权衡：

+   如果服务耦合在一起，它们很快就会成为单点故障。它们无法独立扩展。

+   同步处理可能会导致系统阻塞，资源会被占用，直到请求完全完成。

# 驱动流程的反应式协调器

第二种方法引入了更像是反应式协调器的东西，用于驱动各种服务之间的流程。它更多地使用基于命令和基于事件的方法来控制整个生态系统的整体流程。命令指示需要完成的任务，事件是完成命令的结果。反应式协调器接收请求并生成命令，然后将其推送到事件流中。已经为命令设置的各种微服务消耗这些命令，进行一些处理，然后在成功执行命令时抛出一个事件。反应式协调器消耗这些事件，并根据需要编程和反应事件。这种方法有几个附加值，例如：

+   服务是解耦的；即使协调器和服务之间似乎存在耦合，但反应式方法和集中的事件流解决了大部分以前的缺点。

+   事件流或集中的事件总线确保微服务之间的异步编程。事件可以按需重放。没有单点故障。

+   整体流程可以在反应式协调器中集中在一个地方。所有这样的集中逻辑都可以在那里保留，而且任何地方都不会有重复的代码。

虽然有很多好处，但这种方法引入了以下权衡——协调器需要被照顾。如果协调器出现问题，整个系统可能会受到影响。协调器需要知道需要哪些命令以便做出反应或执行一组预设动作。

# 概要

在经历了纯反应式、纯编排和两种不同的混合方法之后，我们现在将介绍可以应用前面四种方法的各种用例。我们将学习哪种方法适用于哪种情况。

# 当纯反应式方法是一个完美的选择时

在以下情况下，纯粹的反应式方法是一个完美的选择：

+   当应用程序中的大部分处理可以异步完成时。当应用程序可以进行并行处理时，反应式架构模式非常适合处理应用程序需求。

+   在每个服务中分散应用程序流程是可以管理的，而且不会成为一个痛点。对于监控和审计，可以使用相关 ID（**UUID**，**GUID**，**CUID**）生成集中视图。

+   当应用程序需要快速部署，市场速度是最重要的目标。当微服务与反应式方法结合时，它有助于增加解耦，最小化依赖关系，处理临时关闭的情况，从而有助于更快地将产品推向市场。

# 当纯编排是一个完美的选择

在以下情况下，纯编排方法是一个完美的选择：

+   当应用程序的需求无法通过并行处理满足时。所有步骤必须按顺序进行处理，没有机会进行并行处理。

+   如果应用程序需要集中的流程控制。各个领域，如**银行**和**ERP**，都有需要在一个地方查看端到端流程的需求。如果有 100 个服务，每个服务都有自己的控制流程，那么维护集中的流程可能很快成为分发的瓶颈。

# 在外部反应，内部编排是一个完美的选择

在以下情况下，混合方法，更具体地说是在外部反应，在内部编排，是一个完美的选择：

+   大部分处理可以异步完成。您的服务可以通过事件流相互通信，并且您可以在系统中进行并行处理，也就是说，您可以通过事件流或基于系统的命令传递数据。例如，每当付款成功入账时，一个微服务显示相关产品，另一个微服务将订单发送给卖家。

+   在每个微服务中分散流程很容易管理，而且不会在各处重复代码。

+   市场速度是主要优先事项。

+   顺序步骤不适用于系统，但适用于服务。只要顺序步骤不适用于整个系统。

# 引入反应式协调器是完美的选择时

在以下情况下，引入一个反应式协调器是完美的解决方案：

+   根据正在处理的数据，应用程序的流程可能会发生变化。流程可能包括数百个微服务，应用程序需要临时关闭，一旦应用程序恢复在线，事件就可以被重放。

+   系统中有几个需要同步处理的异步处理块。

+   它允许轻松的服务发现。服务可以随时轻松扩展。整个服务可以轻松地移动。

根据您的整体需求，您可以在微服务架构中选择任何一种策略。

# 在 Node.js 中成为反应式

现在我们已经了解了响应式编程的概念和在微服务中的优势，让我们现在看看在 Node.js 中响应式编程的一些实际实现。在本节中，我们将通过在 Node.js 中实现响应式编程来了解响应式编程的构建模块。

# Rx.js

这是最流行的库之一，它得到了积极的维护。该库以不同形式提供给大多数编程语言，如**RxJava**、**RxJS**、**Rx.Net**、**RxScala**、**RxClojure**等。在撰写本文时，上个月的下载量超过 40 万次。除此之外，该库还有大量的文档和在线支持可用。我们将大部分时间使用这个库，除非需要其他库。您可以在以下网址查看：[`reactivex.io/`](http://reactivex.io/)。在撰写本文时，Rx.js 的稳定版本是**5.5.6**。Rx.js 有很多操作符。我们可以使用 Rx.js 操作符进行各种操作，如组合各种内容，根据需要应用条件，从承诺或事件创建新的 observables，错误处理，过滤数据，具有发布者-订阅者模式，转换数据，请求-响应工具等。让我们快速动手试试。为了安装 RxJS，我们需要安装 Rx 包和 Node-Rx 绑定。打开终端并输入`npm install rx node-rx --save`。由于此库需要支持我们的 Node.js 作为构建系统，因此我们还需要安装一个模块。在终端中输入以下命令：`npm install @reactivex/rxjs --save`。在本章中，我们将使用我们在第二章中创建的`Hello World`微服务骨架，并继续进行。以下是我们将在演示中看到的各种选项：

| `forkjoin` | 当我们有一组 observable 并且只想要最后一个值时使用。如果其中一个 observable 永远不完成，则无法使用此操作符。 |
| --- | --- |
| `combineAll` | 通过等待外部 observable 完成，然后自动应用`combineLatest`来简化/组合 observable 的 observable。 |
| `race` | 首先发出值的 observable 将被使用。 |
| `retry` | 如果发生错误，重试特定次数的 observable 序列。 |
| `debounce` | 忽略少于指定时间的发出值。例如，如果我们将防抖设置为一秒，那么在一秒之前发出的任何值都将被忽略。 |
| `throttle` | 仅在由提供的函数确定的持续时间后发出值。 |

以下示例将值节流到两秒钟：

```ts
const source = Rx.Observable.interval(1000);
const example2 = source.throttle(val => Rx.Observable.interval(2000));
const subscribe2 = example2.subscribe(val => console.log(val));
```

以下示例将在 observables 上触发竞争条件：

```ts
let example3=Rx.Observable.race(
 Rx.Observable.interval(2000)
            .mapTo("i am first obs"),
  Rx.Observable.of(1000)
            .mapTo("i am second"),
 Rx.Observable.interval(1500)
            .mapTo("i am third")
  )
let subscribe3=example3.
                  subscribe(val=>console.log(val));
```

您可以在源文件夹中的`using_rxjs`中跟随源代码。在前面的表中，可以在`rx_combinations.ts`、`rx_error_handing.ts`和`rx_filtering.ts`中找到所有操作符的示例。可以在[`reactivex.io/rxjs/`](http://reactivex.io/rxjs/)找到完整的 API 列表。

# Bacon.js

**Bacon.js**是一个小巧的函数式响应式编程库。与 Node.js 集成后，您可以轻松将混乱的代码转换为清晰的声明式代码。它每月的下载量超过 29,000 次。在撰写本文时，可用的版本是**1.0.0**。让我们快速动手试试。为了安装 Bacon.js，我们需要安装 Bacon.js 及其类型。打开终端并输入`npm install baconjs --save`和`npm install @types/baconjs --only=dev`。现在，让我们看一个基本示例，看看代码有多清晰。我们有一个 JSON 对象，其中一些产品与数字`1`（手机）、`2`（电视）等相对应。我们创建一个服务来返回产品名称，如果产品不存在，则应返回`Not found`。以下是服务代码：

```ts
baconService(productId: number){
  return Bacon.constant(this.productMap[productId])
}
```

以下是控制器代码：

```ts
@Get('/:productId')
async get(@Req() req: Request,@Res() res: Response,@Param("productId") productId: number) {
  let resp: any;
  this.baconService.baconService(productId)
    .flatMap((x) => {
      return x == null || undefined ? "No Product Found" : x;
    })
    .onValue((o: string) => {
      resp = o;
    })
  return resp;
} 
```

您可以在源文件夹中的`using_baconjs`中查看源代码。完整的 API 列表可以在[`baconjs.github.io/api.html`](https://baconjs.github.io/api.html)找到。

# HighLand.js

这更像是一个通用的函数库，它是建立在 Node.js 流之上的，因此允许它处理异步和同步代码。**HighLand.js**最好的特点之一是它处理背压的方式。它具有用于暂停和缓冲的内置功能，也就是说，当客户端无法处理更多数据时，流将被暂停，直到准备好，如果源无法暂停，那么它将保持一个临时缓冲区，直到可以恢复正常操作。是时候用一个实际的例子来动手了。让我们偏离 express 主题，专注于文件读取主题。我们将看到 Node.js I/O 操作与并行执行的强大功能。打开终端并输入`npm install highland --save`。

根据我们之前的骨架，创建`index.ts`，其中包含以下代码，基本上读取三个文件并打印它们的内容：

```ts
import * as highland from "highland";
import { Stream } from "stream";
import * as fs from "fs";

var readFile = highland.wrapCallback(fs.readFile);
console.log("started at", new Date());

var filenames = highland(['file1.txt', 'file2.txt', 'file3.txt']);
filenames
  .map(readFile)
  .parallel(10) //reads up to 10 times at a time
  .errors((err: any, rethrow: any) => {
    console.log(err);
    rethrow();
  })
  .each((x: Stream) => {
    console.log("---");
    console.log(x.toString());
    console.log("---");
  });
console.log("finished at", new Date());
```

转换文件，保持三个`.txt`文件与`package.json`平行，并运行`node`文件。内容将被读取。您可以在源代码的`src`文件夹中的`using_highlandjs`项目中跟踪。完整的 API 列表可以在[`highlandjs.org/`](http://highlandjs.org/)找到。

# 主要观点

现在我们已经看到了这三个库，我们将总结以下关键点和显著特点：

|  | **Rx.js** | **Bacon.js** | **Highland.js** |
| --- | --- | --- | --- |
| **文档** | 文档完善，API 非常成熟，有很多选项，在其他语言中也有扩展。 | Node.js 示例较少，API 文档很好，对 Node.js 有原生支持。 | 文档很少，辅助方法较少，发展中的足迹。 |
| **背压** | 已实现。 | 不支持。 | 最佳实现。 |
| **社区** | 被 Netflix 和微软等大公司使用。在所有其他语言中都有类似的概念，更像是 Java，学习曲线陡峭。 | 比 Rx.js 小，学习曲线降低。 | 社区活动最少，必须直接深入代码库。 |
| **许可证** | Apache 2.0 | MIT | Apache 2.0 |

# 摘要

在本章中，我们了解了响应式宣言。我们将响应式原则应用于微服务。我们学习了如何在 Node.js 中应用响应式编程。我们了解了设计微服务架构的可能方法，看到了它的优点和缺点，并看到了一些实际场景，以找出在哪些情况下可以应用这些模式。我们看到了编排过程、反应过程和两种混合方法的特殊情况。

在下一章中，我们将开始开发我们的购物车微服务。我们将设计我们的微服务架构，编写一些微服务，并部署它们。我们将看到如何将我们的代码组织成适当的结构。
