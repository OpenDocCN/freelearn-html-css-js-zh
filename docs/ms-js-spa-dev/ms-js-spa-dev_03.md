# 第三章. 单页应用（SPA）基础 - 创建理想的应用程序环境

现在，你应该已经相当熟悉 Node.js 生态系统中的模块、任务和包管理。在本章中，我们将更深入地探讨 JavaScript SPA 及其依赖的复杂性。我们将通过以下主题来探索各种数据格式和数据库类型、SPA 封装架构模式等：

+   JSON 和其他数据格式

+   SQL 和 NoSQL 数据库之间的区别

+   何时使用 SQL 相比 NoSQL 数据库

+   展示单页应用程序容器的各种方法

+   提供和管理布局

# JSON 数据格式

**JavaScript 对象表示法**（**JSON**）是当今大多数 JavaScript 开发者都非常熟悉的东西。尽管其名称如此，JSON 实际上是一个与语言无关的标准，它实际上只是一个文本文档，在它被用作表示具有名称-值对的对象的 数据或作为简单值序列之前，必须首先由 JavaScript 或任何语言解释器进行解析。

JSON 的缩写中包含单词 *JavaScript* 的原因是因为其格式基于 JavaScript 对象和数组的结构。这就是为什么处理 JSON 数据和 JavaScript 是如此直接，以及为什么在 JavaScript 应用程序中消费 JSON 数据非常有意义。

我们在 *第二章* 中创建的 `user.json` 文件的内容，*模型-视图-任何* 是 JSON 数据交换格式的一个示例：

```js
{ 
    "id": 1, 
    "name": { 
        "first": "Philip", 
        "last": "Klauzinski" 
    }, 
    "title": "Sr. UI Engineer", 
    "website": "http://webtopian.com" 
} 

```

JSON 遵循标准 JavaScript 对象的格式，但还必须遵守一些重要规则才能有效：

+   属性名必须用双引号格式化

+   值可以是双引号中的字符串、数字、`true` 或 `false`、对象或数组

+   对象和数组可以嵌套

+   字符串中的双引号必须使用反斜杠转义

这些规则允许 JSON 格式直接解析为原生 JavaScript，同时仍然足够严格，使其成为跨语言之间易于交换的格式。尽管原生 JavaScript 对象表示法不强制要求在属性名周围使用双引号，但对于 JSON 来说这是必需的，以防止发生 JavaScript 保留字异常。

JavaScript 中的保留字不允许用作变量或函数名，因为它们代表语言的一些当前或潜在的未来结构。例如，保留字 `class` 经常被缺乏经验的开发者误用作 CSS 类的变量名：

```js
Var class = 'myClass'; 

```

这个例子会抛出异常，因为 `class` 是一个保留字。此外，将其用作 JavaScript 对象中的直接属性名也会抛出异常：

```js
{ 
    class: 'myClass' 
} 

```

有经验的 JavaScript 开发者会知道不要将这个单词用作属性名，因为它是一个保留字，但如果你的应用程序正在从外部源消费 JSON 数据，你无法控制可能随对象一起拉入的属性名。例如，你可能从运行在另一个服务器上的应用程序中检索数据，该服务器不是 JavaScript，并且没有意识到任何可能消费它的应用程序的保留字限制。如果这个应用程序想要传达 CSS 类信息，它很可能使用单词 `"class"` 来实现：

```js
{ 
    "class": "myClass" 
} 

```

在这个例子中，属性名是有效的，因为它被双引号包围，因此被解析为字符串而不是保留字。因此，要求属性名周围使用双引号的规则被严格执行，没有任何 JSON 解析器会允许没有双引号的属性名。

## 其他数据格式

JSON 首次由 Douglas Crockford 在 2001 年构想出来。在此之前，数据交换一直是通过使用已经与许多编程语言集成的既定格式来实践的。

### XML

在 JSON 众所周知之前，**可扩展标记语言**（**XML**）是使用最广泛的网络应用程序数据交换格式之一。XML 首次在 1996 年推出，并成为国际标准。它是一种 **标准通用标记语言**（**SGML**）的形式，由 **万维网联盟**（**W3C**）创建：

```js
<?xml version="1.0" encoding="UTF-8"?> 
<note> 
    <to>Tobums Kindermeyer</to> 
    <from>Jarmond Dittlemore</from> 
    <heading>A Message</heading> 
    <body>Hello world!</body> 
</note> 

```

这是一个简单的 XML 文档示例。如果你之前没有使用过 XML，你很可能至少听说过它。XML 是许多其他数据格式的先驱，包括 SOAP、RSS、Atom 和 XHTML。XHTML 也为许多网络开发者所熟知，在 HTML5 规范引入之前，它是提供网页的推荐标准。注意，前面示例的格式与 HTML 类似。

### YAML

YAML 是一个递归缩写词，意味着它指的是自己，即 *YAML Ain't Markup Language*。除了它的愚蠢名字之外，使 YAML 有趣的是，它的层次结构语法要求使用行和缩进来作为分隔符，而不是 JSON 中使用的结构化括号和方括号：

```js
item-key-one: 
  - list item 1 
  - list item 2 
item-key-two: 
  nested_key_one: this is an associative array 
  nested_key_two: end the associative array 

```

YAML 的语法设计是为了使数据的层次结构更容易被人类阅读，它要求使用行和空格来明确界定其结构。相比之下，其他使用括号等字符定义结构的格式，在压缩格式下可能难以向人类眼睛传达层次结构。

YAML 最初是在与 JSON 大致相同的时间创建的，但它并没有像 JSON 在 Web 开发社区中那样获得那么多的知名度。YAML 在灵活性方面可能比 JSON 更胜一筹，因为它允许更多的功能，如注释和关系锚点，但可能是 JSON 的简单性使其成为 Web 应用程序以及更广泛的数据消费中的更受欢迎的数据格式。

### BSON

**二进制 JSON** (**BSON**) 是 JSON 的二进制形式，主要用于 MongoDB 面向文档的数据库系统的数据存储格式。BSON 与 JSON 类似，主要区别在于 BSON 支持更复杂的数据类型，如日期、时间戳和`ObjectId`。在 BSON 和 MongoDB 中，`ObjectId`是一个 12 字节的唯一标识符，用于存储的对象。MongoDB 要求每个对象都有一个名为`_id`的唯一标识符字段，而`ObjectId`是为此字段赋值的默认机制。这个概念与关系型数据库系统中的*主键*类似。

一个使用`ObjectId`和`Timestamp`数据类型的 BSON 文档可能看起来像这样：

```js
{ 
    "_id": ObjectId("542c2b97bac0595474108b48"), 
    "timestamp": Timestamp(1412180887, 1) 
} 

```

当我们在本文中讨论 MongoDB 和面向文档的数据库时，术语 JSON 可能与 BSON 互换使用，其含义是理解这种区别。您可以在 bsonspec.org 上了解更多关于 BSON 规范的信息。

## 为什么 JSON 如此盛行？

JSON 简单、易于阅读，并以一种几乎所有现有的编程语言都能轻松理解的方式结构化。列表（或数组）和名称-值对（或关联数组）是计算机语言中的基本概念和常见实现。格式越简单，解析起来就越容易，因此更多平台将开发出一种固有的方式来消费该数据格式。JSON 的情况就是这样。

此外，JSON 规范在最初开发后只更改了几次。其创造者 Douglas Crockford 故意没有为规范指定版本号，以便使其成为固定不变的，并且随着时间的推移不能改变。这可能是 JSON 在数据格式中占据主导地位的最大因素。由于它不会随时间改变，因此为消费它而构建的跨众多编程语言和平台的解析器也不需要改变。这创造了一个生态系统，其中 JSON 在每个地方都只有一个版本，使其完全可预测、广泛理解且几乎坚不可摧。

# SQL 和 NoSQL 数据库之间的差异

在*第二章*中，我们简要讨论了面向文档的数据库，也称为 NoSQL 数据库。这个概念对于 MEAN 栈至关重要，因为 MEAN 缩写中的*M*代表 MongoDB，这是一个广泛使用的 NoSQL 数据库实现。NoSQL 数据库在概念上与传统的关系型，或 SQL，数据库有所不同。

非关系型数据库已经存在了几十年，但直到最近才得到广泛应用。这种流行度的上升导致了术语*NoSQL*首先被应用于这些类型的数据库。NoSQL 数据库使用量增加的主要原因主要是为了解决处理*大数据*的问题，即大规模和复杂的数据集，以及在现代 Web 应用程序中水平扩展这些数据。

## NoSQL 数据类型

术语 NoSQL 意味着*非 SQL*，这暗示它是一种非关系型数据库类型。像 MongoDB 这样的面向文档的 NoSQL 数据库将它们的数据存储在由结构化 JSON 对象表示的文档中。这种类型的 NoSQL 数据库中的数据*类型*由数据本身定义，就像标准 JSON 一样：

```js
{ 
    "id": 1 
} 

```

例如，如果你在 NoSQL 数据库中有一个键为`id`的字段，其值为`1`，一个数字，你可以轻松地将该值更改为`myID`，一个字符串，而无需更改对该数据类型的任何其他引用：

```js
{ 
    "id": "myID" 
} 

```

以这种方式，该值的*数据类型*完全取决于其定义。在关系型数据库中，进行这种更改不会那么直接。

## 关系型数据类型

与面向文档的数据库相比，传统的 SQL 数据库使用表格来结构化其数据。每个表格列都设置为特定的数据类型，存储在该列下的数据必须遵守定义的类型。如果你有一个大型的 SQL 数据库，并且希望更改特定列的类型，这可能会带来潜在的问题，并且可能需要更改在数千行数据上执行。与更改 JSON 文档中的数据类型相比，这相对容易，因为它只涉及更改数据本身，并且没有跨多个记录定义数据类型的表格列的概念。

关系型数据库中的*关系*术语指的是存储数据的表格关系。每个数据表被视为一个关系，因为其中存储的不同数据以某种方式相互关联，这种关联由将消费它的应用程序和程序定义。SQL 数据库中的一个表可以与 NoSQL 数据库中的一个 JSON 对象相比较。然而，两者之间最大的区别是，表由行和列组成，数据通过列类型和包含相关数据记录的行进一步关联。在 NoSQL 数据库中，没有行和列的概念，数据可以无限嵌套。

为了检索 SQL 数据库中的*嵌套*数据，还必须在表之间识别关系。由于数据实际上不能嵌套，因此必须使用一个或多个表到一个或多个其他表的引用来创建用于应用程序模型和视图的相关数据集。SQL 是一种编程语言，用于管理从关系型数据库表中提取数据，并以满足应用程序所需的方式对其进行格式化。

## ACID 事务

大多数 NoSQL 数据库系统不支持符合**ACID**属性的事务，**ACID**代表**原子性**、**一致性**、**隔离性**和**耐用性**。这一组属性是数据库以可靠方式处理事务所必需的。事务是对数据库的任何更改。这种更改可以是单个表中某个字段的单个值，也可以是跨越多个表并影响这些表中的多行的更改。大多数广泛使用的数据库管理系统都支持事务的 ACID 属性，无论执行的操作有多复杂。

### 原子性

ACID 的原子性属性指的是数据库内的原子操作，意味着事务所需的更改必须确保全部发生，否则不会发生任何更改。这一属性提供了一种保证，即不会进行部分更改，这可能导致数据集损坏。如果一个原子事务在数据库中的任何一点失败，那么到该点为止所做的更改将回滚到其之前的状态。

### 一致性

ACID 的一致性属性要求事务只能根据该数据库系统定义的**有效**数据更改。这包括确保数据不被破坏，在必要时强制执行回滚，以及执行与事务相关的所有必要数据库触发器。

### 隔离性

ACID 的隔离性属性要求同时执行的事务或并发不会导致相关数据出现数据库错误。这可以涉及不同级别的严格性，取决于所使用的数据库系统。隔离性的主要目标是确保一组并发事务的最终结果与如果你依次回放它们是相同的。隔离性与一致性紧密相关，并且始终应确保一致性得到维护。

### 耐用性

ACID 的耐用性属性要求在执行过程中事务不会被**丢失**。你可以想象在事务执行过程中可能会发生任何数量的计算机故障，比如断电。当发生类似情况时，耐用性确保数据库系统**记住**正在执行中的事务，通过将其记录到磁盘并确保即使在重启后也不会丢失。

### MongoDB 和 ACID

确实，许多 NoSQL 数据库系统并不符合 ACID 属性；然而，MongoDB 在一定程度上做到了。正如之前提到的，MongoDB 是一个面向文档的数据库系统，它是 NoSQL 数据库的一个更简洁的子集。以这种方式，MongoDB 能够在单文档级别支持 ACID 事务。它不能支持多文档事务，因此在这方面它不如大多数关系型数据库，后者可以在多个表中支持 ACID 事务，但 MongoDB 在文档级别仍然在面向文档的数据库中脱颖而出。

#### MongoDB 的写入前日志

MongoDB 吹嘘的另一个超过其他特性的功能是**写入前日志**（**WAL**）。这是一组功能，允许数据库系统符合 ACID 的原子性和持久性属性。为此，MongoDB 在执行操作之前，将所有操作及其结果记录到一个内部日志中。这是一种简单而有效的方式来确保文档级别事务的持久性，因为所有操作都在执行之前进行了记录，因此即使在操作突然中断的情况下，也不会丢失发生事件的证据。同样，这个特性确保了原子性，因为它使 MongoDB 能够在确定更改内容并将其与中断操作之前数据库的状态进行比较后，重新启动时能够*撤销*和*重做*这些操作。

# 何时使用 SQL 数据库与 NoSQL 数据库

SQL 数据库和 NoSQL 数据库之间显然存在重大差异，这不仅体现在它们的结构上，还体现在开发者和应用程序如何与之交互。这些差异从架构和功能的角度来看，都可能对应用程序的开发产生严重影响。这就是为什么选择数据库类型不是一件小事，在开始应用程序的开发之前，应该始终对其进行彻底评估。

## 可扩展性

之前提到，现代 Web 应用程序的需求导致了 NoSQL 数据库的流行。*可扩展性*，即持续处理不断增长的数据量和数据操作的能力，是这些需求之一。你可以想象这种情况适用于像 Facebook 或 Twitter 这样的社交媒体公司，以及可能与此类资源交互的任何其他社交应用程序。在下面的内容中，可扩展性是在决定为应用程序选择哪种类型的数据库时可能需要考虑的一个特性。

### 水平扩展

尤其是对于越来越多的现代网络应用来说，**水平扩展**是必需的。这指的是随着用户基础的扩大，需要在地理上分布服务器和数据库。有效的水平扩展使得应用程序的用户能够从离他们最近的服务器接收数据，而不是从可能位于世界另一端的数据仓库中的单个服务器或服务器组。

在关系型数据库中实现水平扩展当然不是不可能的，但这很困难，并且需要使用复杂的**数据库管理系统**（**DBMS**）。另一方面，NoSQL 数据库在设计上更简单，这使得在机器和网络集群之间进行数据复制变得更加简单。

## **大数据**

现代网络应用还需要另一个需求，即**大数据**，这可以确切地意味着其名称所暗示的：大量数据。然而，更多的时候，大数据指的是数据集之间的高度复杂性，以至于没有使用复杂的分析技术，很难从中分析和提取价值。

NoSQL 数据库非常适合处理大数据，因为它们支持**动态模式设计**，这简单意味着在存储之前，您不需要为数据集定义特定的模式，正如传统的关系型数据库所要求的。这回到了 NoSQL 中数据类型的灵活性，它不需要字段类型受规则控制，就像表格数据模式中的列一样。此外，关系型数据库表的模式不能更改，否则会影响到该表的所有数据。相比之下，例如，JSON 文档中特定数据集的模式可以随时更改，而不会影响该文档中先前存储的数据集。

如果大数据是您网络应用的可预见需求，那么在选择数据库类型之前，您应该进一步考虑大数据的类型。

### **操作大数据**

**操作大数据**指的是在分布式应用程序中实时消耗和管理的数据，以支持当前运行过程中的操作。例如，MongoDB 这样的面向文档的数据库就是考虑到操作大数据的支持而构建的，并专注于提供并发读写操作的速度。

MongoDB 以及其他旨在与操作大数据一起工作的 NoSQL 系统，通过利用现代分布式网络计算能力来提高操作效率。然而，传统的数据库系统在开发时并没有考虑到这种能力，因为那时的计算机系统更加孤立。

### **分析大数据**

**分析型大数据**与操作型大数据有很大不同，因为它的重点是**大规模并行处理**（MPP）。这意味着消耗了大量的数据，随后为了给使用该应用的应用提供价值，对这些数据进行各种分析。与操作型大数据相比，为分析型大数据设计的数据库系统专注于巨大的*吞吐量*和数据的回顾性处理，而不是并发、无关操作的速度。

在开发应用时，处理分析型大数据的需求并不总是从一开始就明显。预测这种需求往往很困难，因为当你从一个小的数据集开始时，你可能不知道随着时间的推移，你可能会想要分析哪些大量的数据。幸运的是，这个问题可以通过在确定其需求后实施解决方案来解决。MPP 数据库就是为了这个特定目的而构建的，此外还有*MapReduce*，它是一种替代实现，用于在集群中的分布式计算机上处理 MPP。

## 总体考虑因素

在决定为你的应用使用 SQL 或 NoSQL 数据库时，你应该考虑应用在初始发布时的需求以及你预见的未来需求。如果你预期会有一个庞大的用户基础和病毒式增长的可能性，那么你可能需要考虑一个专为处理操作型大数据和可扩展性而构建的 NoSQL 数据库。

如果你正在开发一个预期用户基础较小的应用，或者可能除了数据管理员外没有其他用户，那么关系型 SQL 数据库可能更合适。此外，如果你的应用可能有众多用户，但没有横向扩展的需求，SQL 数据库也可能是一个合适的选择。

还要考虑到许多现代、分布式 Web 应用最初只使用了关系型数据库，后来在现有数据库的基础上实现了 NoSQL 解决方案，以处理不断增长的需求。这也是一个可以在应用生命周期中根据需要规划和适应的场景。

# 展示 SPA 容器的方案

在单页应用中，*容器*是应用最初加载并显示给用户的对象。这个概念与*软件容器*不同，后者是一个应用生活的隔离环境，就像虚拟机一样。

对于单页 Web 应用，容器可以是`<body>`元素，或者`<body>`元素内的任何元素。例如，你可能在页面上用`<p>`元素加载一些初始的静态欢迎文本，然后单页应用（SPA）将在该元素下方动态加载到`<div>`元素中：

```js
<!doctype html> 
<html> 
    <body> 
        <p>This is some welcome text.</p> 
        <div class="container"> 
            The application will be loaded here. 
        </div> 
    </body> 
</html> 

```

在这样的场景中，页面上总会有一些固定内容，这些内容不需要根据用户与应用程序的交互而改变。这是一个简单的例子，但同样的方法也可以用于常见的 `<header>`、`<footer>` 和 `<nav>` 元素：

```js
<!doctype html> 
<html> 
    <body> 
        <header>Static header content</header> 
        <div class="container"> 
            The application will be loaded here. 
        </div> 
        <footer>Static footer content</footer> 
    </body> 
</html> 

```

## 如何定义您的 SPA 容器

定义您的 SPA 容器的*正确*方式并不存在；这实际上完全取决于您正在构建的应用程序类型以及您的偏好。它也可能取决于您用于提供布局的系统（即用于容纳您的应用程序的 HTML 页面）的客户端限制。

### 部分页容器

如前几节所示，您可能希望在应用程序加载之前在您的 SPA 布局中显示一些静态内容。当您预计应用程序的初始加载时间较长，或者需要某些用户交互来触发应用程序的加载时，这很有用。

### 全页容器

如果您的应用程序可以通过**XMLHttpRequest**（通常称为**Asynchronous JavaScript and XML**（AJAX））完全控制，那么除非您想要，否则不需要在您的 SPA 布局中加载任何静态内容。您可能在布局中加载静态内容的一个原因是为用户提供在等待应用程序加载期间查看或阅读的内容。当您预计应用程序的初始加载时间较长，并且希望帮助防止用户在应用程序的初始*状态*准备好之前离开时，这尤其有用。

在 SPA 中的*状态*指的是在任何时间点上的特定版本的**Document Object Model**（DOM）。一个*加载状态*是在等待容器元素加载下一个请求的状态时您可能会在其中显示的状态。某种类型的加载指示器通常足以让用户知道正在发生某些事情，并且应用程序很快就会加载，但当您的应用程序有任何过度的延迟时，用户可能会认为出了问题，并在过程完成之前离开应用程序布局页面。

## 如何加载您的 SPA 容器

您最初加载 SPA 的方式高度依赖于您应用程序的性质。在您的应用程序加载之前，可能需要满足任何数量的要求。

### 用户交互时的加载

许多 Web 应用程序在完全加载 SPA 之前需要某种类型用户交互。例如：

+   用户身份验证

+   用户接受进入协议

+   必须显示并由用户参与或忽略的间隔内容，例如广告

这样的场景在 Web 应用程序中相当常见，并且通常很难以流畅的方式解决。

#### 登录页面过渡

在许多 Web 应用程序中，登录界面在安全页面上加载，并使用 HTTP POST 提交到另一个安全页面以验证用户并加载实际的 SPA。这种模式通常由于正在使用的服务器端框架在处理身份验证方面的限制而被采用。

如果您考虑一个用于访问您在手机上登录的银行账户的金融应用程序，您在通过用户名和密码进行身份验证之前，可能看不到比登录界面更多的内容。这通常会将您带到第二个页面，该页面加载了包含您敏感银行信息的完整单页应用程序，而这些信息您不希望其他人拿起您的手机时也能看到。

登录界面可以说是最常见的一种需要用户交互来加载应用程序的使用场景，而且通常处理得并不优雅。如果您的 REST 框架允许这样做，处理这种用例最流畅的方式是将登录界面作为 SPA 的一部分加载，并通过登录表单从 REST 端点请求身份验证。当您从 API 请求中收到正确验证的响应时，您可以将所需的数据加载到现有的 SPA 容器中，并用新的*已登录*状态替换登录状态。

### 基于 DOMContentLoaded 事件加载

如果您的 SPA 不需要用户身份验证或任何其他交互来初始加载，或者如果您在页面加载时检测到已经验证的用户，并且可以跳过该步骤，那么您将需要一个方法来自动在初始页面加载时尽快加载您的 SPA。

加载单页应用程序的最佳时机通常是 DOM 完全加载并且可以被浏览器解析的时候。现代浏览器在发生这种情况时会在`document`对象上触发一个事件，称为`DOMContentLoaded`，这可以用于此目的。为此，您只需在`document`上添加一个`EventListener`来检测事件何时被触发，然后调用一个函数来加载您的应用程序：

```js
<script> 
    document.addEventListener('DOMContentLoaded', function(event) { 
        loadMyApp(); 
    }); 
</script> 

```

或者，如果您正在使用 jQuery，您可以调用方便的 jQuery `.ready()` 方法来监听 `DOMContentLoaded` 事件，并在匿名函数中触发您的自定义应用程序代码：

```js
<script> 
    $(document).ready(function() { 
        loadMyApp(); 
    }); 
</script> 

```

### 基于文档 readystatechange 事件加载

现代浏览器还提供了一个在首次加载页面时在`document`对象上触发的事件，称为`readystatechange`。此事件可以用来确定 DOM 的三个状态，这些状态通过以下方式通过`document.readyState`属性返回：

+   `loading` - 这是指文档仍在加载且尚未被浏览器完全解析的情况。

+   `interactive` - 这是指所有 DOM 元素都已加载并可以访问，但某些外部资源可能尚未完全加载，例如图像和样式表。这种状态变化还表明`DOMContentLoaded`事件已被触发。

+   `complete` - 这是在所有 DOM 元素和外部资源都已完全加载时。

要使用`readystatechange`事件在`DOMContentLoaded`事件的同时加载您的应用程序，您需要将一个函数分配给在`readystatechange`事件上被调用的函数，然后检查`document.readyState`属性是否设置为`interactive`。如果是，那么您可以调用您的应用程序代码：

```js
<script> 
    document.onreadystatechange = function() { 
        if (document.readyState === 'interactive') { 
            loadMyApp(); 
        } 
    }; 
</script> 

```

使用这种方法来检测文档的状态提供了更多的灵活性，在您想要为三个文档状态中的任何一个调用自定义应用程序代码时，而不仅仅是`DOMContentLoaded`事件或`interactive`状态时。

### 直接从`document.body`加载

加载`<script>`标签的更传统方式是将它们放置在文档的`<head>`元素中。如果您在您的外部 JavaScript 中使用`DOMContentLoaded`或`readystatechange`事件来在适当的时间初始化应用程序代码，那么将`<script>`标签添加到`<head>`中对于加载 SPA 来说是完全可以接受的：

```js
<!doctype html> 
<html> 
    <head> 
        <script src="img/app.js"></script> 
    </head> 
    <body> 
       <div class="container"> 
            The application will be loaded here. 
        </div> 
  </body> 
</html> 

```

然而，如果您想避免使用这些自定义 DOM 事件，并在需要时精确触发您的应用程序代码，则可以采取不同的更直接的方法。

在当今的网页中加载 JavaScript 的常见技术是将加载您的外部 JavaScript 文件的`<script>`标签直接放置在页面的`<body>`元素中。能够这样做的原因在于浏览器解析 DOM 的方式：从上到下。

以此代码为例：

```js
<!doctype html> 
<html> 
    <body> 
       <div class="container"> 
            The application will be loaded here. 
        </div> 
        <script src="img/app.js"></script> 
   </body> 
</html> 

```

从`document.body`内部和紧接在关闭的`</body>`标签上方加载外部 JavaScript 文件`app.js`将确保在加载之前解析所有位于`<script>`标签之上的 DOM 元素，并且`app.js`文件将在`<div class="container">`元素之后精确加载。如果该元素是您将加载 SPA 的地方，那么这种技术确保了`app.js`中的应用程序代码将在解析`container`元素之后立即执行。

另一个优点是在 DOM 底部和加载应用程序所需的元素附近加载您的`<script>`标签是，由于浏览器的自上而下的 DOM 解析，这些`<script>`标签的加载不会阻塞它们上方内容的加载。一旦到达`<script>`标签，可能会有一些阻塞阻止浏览器在加载时可用，但用户至少会看到直到那个点已经加载的页面上的一切。

因此，在`<body>`中靠近 DOM 底部的位置加载`<script>`标签，而不是使用传统的`<head>`标签插入，这样可以避免在页面上任何内容可见之前发生阻塞。

#### 使用`<script>`标签的`async`属性

防止`<script>`标签在加载时阻塞浏览器可用性的一个方法是使用`async`属性。可以将此属性添加到`app.js`文件中，以确保一旦解析，该文件就会异步加载，并且 DOM 的其余部分将继续解析和加载，无论该脚本的加载何时完成：

```js
<!doctype html> 
<html> 
    <body> 
       <div class="container"> 
            The application will be loaded here. 
        </div> 
        <script src="img/app.js" async></script> 
   </body> 
</html> 

```

这种方法的优点是，同样没有阻塞。然而，缺点是，当你异步加载多个脚本时，无法保证它们加载和最终执行的顺序。这就是为什么尽可能只加载一个压缩的 JavaScript 文件也是一项良好的实践。脚本标签越少，需要解析和下载的外部资源就越少。在使用`async`属性的情况下，只使用一个`<script>`标签意味着只需等待一个异步资源加载，而不必担心多个文件加载的不可预测顺序，这可能会破坏你的应用。

#### 使用`<script>`标签的`defer`属性

从`<body>`中直接加载`<script>`标签而不阻塞文档解析的另一种方法是使用`defer`属性。与`async`不同，此属性确保在文档解析完成或`DOMContentLoaded`事件发生之前，不会加载`<script>`标签。

使用`defer`属性，你的`<script>`标签可以放置在`<body>`中的任何位置，并始终保证在`DOMContentLoaded`事件之后加载：

```js
<!doctype html> 
<html> 
    <body> 
        <script src="img/app.js" defer></script> 
        <div class="container"> 
            The application will be loaded here. 
        </div> 
  </body> 
</html> 

```

# 管理布局

如*第二章*所述，*模型-视图-任意*，与 SPA 相关的布局是用于存放、初始化和显示应用的 HTML 页面。布局将包含与上一节中关于如何加载 SPA 容器的示例类似的 HTML 标记。

布局通常是创建单页应用（SPA）所需的唯一原生服务器端组件，其他组件包括原生前端代码以及用于提供数据消费和操作端点的外部 API。

## 静态布局

布局可以是加载到 Web 服务器上的静态 HTML 页面，并在该页面上调用加载应用所需的资源，在定义的容器元素内。理想情况下，一旦加载了初始 HTML 页面，就不需要访问其他服务器端 HTML 页面来运行你的应用，这就是“单页应用”这个术语的由来。

如果你不需要任何服务器端框架交互来设置环境变量、测试登录状态等，那么静态 HTML 页面是启动 SPA 最快、最简单的方式。

一个静态 HTML 布局页面可能像以下示例那样简单：

```js
<!doctype html> 
<html> 
    <head> 
        <title>This is a static HTML page</title> 
    </head> 
    <body> 
       <div class="container"> 
            The application will be loaded here. 
        </div> 
        <script src="img/app.js"></script> 
    </body> 
</html> 

```

使用静态 HTML 文件简单地作为 Web 服务器上的服务的一个缺点是，您必须直接访问该文件才能加载您的应用程序。例如，如果您的应用程序在 `myapp.com` 上，并且您的静态 HTML 布局页面命名为 `index.html`，大多数 Web 服务器会自动将 *root* 服务器请求路由到该页面，因此用户不需要直接导航到 `myapp.com/index.html` 来访问它，只需访问 `myapp.com` 即可。

然而，如果用户访问 `myapp.com/profile`，他们可能会找到他们的用户资料信息，应用程序布局将不会被加载，服务器将生成一个 **HTTP 404**，或 **未找到**，响应。为了提供这种用例并允许您的应用程序有自定义的 URL，需要一个 *动态布局*。

## 动态布局

当您控制单页应用程序的后端框架时，例如在使用 MEAN 栈时，您可能希望开发一个更动态的服务器布局页面，以便在应用程序最初加载时从服务器端加载变量和一些基本逻辑。

Express 是一个用于 Node.js 的服务器端 Web 框架，它是 MEAN 栈缩写中的 *E*。当您使用 MEAN 栈进行开发时，您将使用 Express 来定义和处理所有您的 REST API 端点，但您也想要处理您的主要应用程序入口点。

### 安装 Express

让我们回到我们一直在使用的 Node.js 环境，使用 NPM、Bower 和 Grunt，并安装 Express：

```js
$ npm install express --save

```

在这种情况下，我们使用 `--save` 参数将 Express 保存到我们的主要 NPM 依赖项中，因为它不仅用于开发。

### 使用 Express 设置基本服务器

一旦您安装了 Express，请在您的应用程序根目录中创建一个名为 `server.js` 的文件：

```js
$ touch server.js

```

在此文件中，添加以下代码以包含 Express 模块并初始化您的应用程序对象：

```js
var express = require('express'); 
var app = express(); 

```

您的 `server.js` 文件中的 `app` 对象将允许您调用它来定义路由。在我们的 SPA 示例中，我们目前只需要定义一个路由。

### 使用 Express 进行基本路由

Express 中的路由是指定义用于响应服务器请求的 URL 路径。Express 可以定义任何类型的 HTTP 请求的路由，包括 `GET`、`POST`、`PUT` 和 `DELETE` 请求，这对于创建 REST API 是必要的。然而，在此阶段，我们只想定义一个用于加载 HTML 页面的路由。

为您的应用程序主入口点定义一个路由将是一个 GET 请求，使用 Express 来做这件事非常简单。在您刚刚创建的 `server.js` 文件中，在 `app` 对象定义下方添加以下代码：

```js
app.get('/', function(request, response) { 
    response.sendFile('/index.html', {root: __dirname}); 
}); 

```

此命令添加了一个路由，它将为您之前创建的 `index.html` 文件提供服务，作为应用程序的根响应。第二个参数，它定义了一个 `root` 属性为 `__dirname`，只是将应用程序的根服务器路径设置为当前目录。

现在我们想使用 Express 来提供我们的应用程序，而不是之前简单的 `http-server` 模块。

### 使用 Express 运行服务器

现在你已经设置了 `server.js` 文件，并添加了一个指向应用程序根目录的基本路由，剩下要做的就是设置一个 HTTP 端口来监听并加载应用程序。在你的 `server.js` 文件中，向路由定义中添加以下代码：

```js
app.listen(8080, function() { 
    console.log('App now listening on port 8080'); 
}); 

```

这告诉服务器在 HTTP `端口 8080` 上监听以提供应用程序布局。现在你只需要从命令行运行服务器：

```js
$ node server.js

```

这将运行服务器并在终端显示控制台消息 `App now listening on port 8080`。

现在转到浏览器中的 `localhost:8080`，你应该看到我们在 *第二章* 模型-视图-Whatever* 中创建的简单 SPA 页面。然而，你会在浏览器控制台中注意到一些错误，因为链接到 `index.html` 的本地 JavaScript 文件找不到。这是因为你还没有为加载静态资源文件定义路由。

### 使用 Express 加载静态资源

首先，通过在命令行中按 *Ctrl* + *C* 停止应用程序。现在再次编辑 `server.js` 并在 SPA 布局页面路由定义之上添加以下代码：

```js
app.use('/', express.static('./')); 

```

此命令将设置应用程序从根目录加载静态资源。现在如果你再次从命令行运行 `nodeserver.js` 并在浏览器中重新加载页面，SPA 应该加载所有资源并像之前使用 `http-server` 一样正常工作。

### 使用 Express 进行动态路由

如前所述，我们的应用程序应该允许用户访问类似 `myapp.com/profile` 或在我们的情况下 `localhost:8080/profile` 的位置，以加载一个将触发与应用程序主根视图不同的视图的动态请求。如果你现在在应用程序中访问 `localhost:8080/profile`，你将在浏览器中收到以下响应：

```js
Cannot GET /profile 

```

为了解决这个问题，再次停止本地服务器，编辑 `server.js` 文件，并对应用程序布局路由定义进行以下更改：

```js
app.get('*', function(request, response) { 
    response.sendFile('/index.html', {root: __dirname}); 
}); 

```

在这里，我们只是将 `GET` 路由定义中的路径参数从 `'/'` 更改为 `'*'`。Express 允许在路由定义中使用正则表达式语法，所以这告诉服务器将所有动态路径请求路由到 `index.html` 页面，而不仅仅是根 `'/'` 路径。

保存此更改，现在如果你再次在命令行中运行 `node server.js` 并在浏览器中访问 `localhost:8080/profile`，你将再次看到从根路径显示的 SPA，并且所有静态资源文件都应该按预期加载。

在设置此基本的 Node.js Express 服务器之后，你的最终 `server.js` 文件应该看起来像这样：

```js
var express = require('express'); 
var app = express(); 

app.use('/', express.static('./')); 

app.get('*', function(request, response) { 
    response.sendFile('/index.html', {root: __dirname}); 
}); 

app.listen(8080, function() { 
    console.log('App now listening on port 8080'); 
}); 

```

我们简单的 SPA 现在变得更加复杂，能够提供动态布局文件，并使用动态路由通过自定义 URL 加载布局。

# 摘要

现在，你应该对各种数据交换格式有了更好的理解，例如 JSON、BSON、XML 和 YAML，以及它们在 Web 应用中的使用方式。你应该了解 SQL 和 NoSQL 数据库之间的区别，以及根据应用需求选择使用其中一种数据库的优势，并且你已经学习了 MongoDB 及其将 BSON 作为 JSON 的二进制形式的使用。此外，你还学习了如何使用 Web SPA 容器元素，以及将你的应用初始化和加载到该容器中的各种方法。

这些概念对于理解 SPA（单页应用）开发至关重要，并且有助于理解 MEAN 栈的内部工作原理以及它与其它应用开发架构的不同之处。

既然你已经对 Node.js 应用程序的客户端有了初步的了解，并且使用 Express 构建了一个基本的服务器，那么让我们进一步学习如何使用 Express，并了解如何在 SPA 内部创建 REST API 请求。
