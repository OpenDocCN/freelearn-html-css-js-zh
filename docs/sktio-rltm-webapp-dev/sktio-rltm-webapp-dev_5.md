# 第五章. Socket.IO 协议

Socket.io 提供了一个非常简单但易于使用的 API，同时暴露了大量的功能。此外，这些功能在所有浏览器和 socket.io 提供的各种传输机制中都是统一的。为了实现这一点，socket.io 客户端和服务器在后台做了很多工作。在本章中，我们将检查并尝试理解 socket.io 中的通信以及一些 socket.io 内部机制。

# 为什么我们需要另一个协议？

对于熟悉 WebSocket 的人来说，第一个问题是，为什么我们已经有 WebSocket 了，还需要另一个协议？答案是双重的；socket.io 在所有浏览器中都以统一的方式工作（追溯到 Internet Explorer 6），并且 socket.io 提供了一个功能更丰富的 API

WebSocket 规范仍在开发中，并且不支持许多正在使用的浏览器。事实上，任何版本的 Internet Explorer 10 之前的版本都没有 WebSocket 支持。仍然有很多人在使用不支持 WebSocket 的旧浏览器。

对于 WebSocket 来说，另一个问题是防火墙和代理。大多数防火墙会阻止任何通信（除了标准的 HTTP 1.0/1.1），并且可能不允许建立 WebSocket 连接。同样适用于大多数代理服务器。

因此，如果我们决定只使用 WebSocket 协议，我们必须理解会有很多人可能无法使用我们的应用程序。

与此相反，当我们使用 socket.io 构建应用程序时，能够使用 WebSocket 的人将继续使用它，而那些不能使用的人将退而求其次，使用下一个最好的可用传输机制，然后是下一个，直到他们在浏览器中找到一个可以工作的机制，即使是通过防火墙和代理，一直到 iframe（很少使用）。默认顺序如下：

+   WebSocket

+   FlashSocket

+   XHR 长轮询

+   XHR 多部分流式传输

+   XHR 轮询

+   JSONP 轮询

+   iframe

值得注意的是，使用 JSONP 轮询，socket.io 提供了跨域通信的支持，而无需在服务器上进行任何特殊配置或客户端上的任何特殊代码：

现在，让我们看看 API 中的差异。为此，我们将只看到 JavaScript 客户端 API，因为任何服务器都将根据使用的编程语言有自己的实现和 API。

## WebSocket API

让我们从快速查看一个显示 WebSocket 客户端骨架的代码片段开始：

```js
<script>
  var socket = new WebSocket('ws://localhost:8080');

  socket.onopen = function(event) {
    socket.send('Client socket connected');
  };

  socket.onmessage = function(event) {
    console.log('Client received a message', event);
  };

  socket.onclose = function(event) {
    console.log('Client socket disconnected', event);
  };

  //socket.close()
</script>
```

第一步，如前一个代码片段所示，是创建一个新的 WebSocket 实例；在这里，我们必须传递 WebSocket 服务器的 URI。这个 URI，像任何其他 URI 一样，有一个指定协议的部分，在这个情况下可以是`ws`（未加密）或`wss`（加密）；服务器地址（服务器的 IP 地址或有效的域名）；最后，端口。

理想情况下，我们还需要检查用户所使用的浏览器是否支持 WebSocket，但我已经跳过了这部分内容，以专注于 API。

在创建 WebSocket 对象之后，我们可以向其附加事件处理器。WebSocket 公开了三个事件，以及它们对应的事件处理器：

+   `open`：`onopen`事件处理器

+   `message`：`onmessage`事件处理器

+   `close`：`onclose`事件处理器

如其名称所示，这些处理器将在套接字连接打开时、套接字上有新消息时以及关闭套接字连接时分别被调用。

对于每个事件，客户端都会接收到事件数据。如果事件是消息，它将包含该消息以及其他数据。WebSocket 客户端不会尝试解释消息或其类型，也就是说，它将所有消息视为纯文本，并且由应用程序负责解释和理解。此外，没有提及消息的命名空间或套接字连接的多路复用。

如果您看到`onopen`处理器，您会注意到`send`方法，这是客户端用来发送消息的方法。同样，它只能发送纯文本，因此您必须负责序列化和反序列化。

最后，我们有`close`方法，正如其名称所暗示的，可以用来从客户端关闭套接字连接。

## Socket.IO API

让我们看看使用 sockt.io 的相同代码：

```js
<script>
  var socket = io.connect('http://localhost:8080');

  socket.on('connect', function() {
    socket.send('Client socket connected');
  });

  socket.on('message', function(data) {
    console.log('Received a message from the server!',data);
  });

  socket.on('disconnect', function() {
    console.log('The client socket disconnected!');
  });

</script>
```

上述代码片段看起来与 WebSocket 的代码相似，并且不出所料，与之前的代码执行相同的工作。然而，有一些细微的变化：我们不是使用`onopen`、`onmessage`和`onclose`，而是使用 socket.io 的`on`方法来附加处理器。优点是，当我们使用 socket.io 的自定义事件功能时，处理事件的 API 保持不变。

正如我们已经看到的，您可以使用以下代码行来发出新事件：

```js
socket.emit("myevent", {"eventData": "..."});
```

然后使用以下方式接收它：

```js
socket.on("myevent", function(event){...});
```

如您所见，在这种情况下，我们正在传递一个 JSON 对象作为数据；socket.io 将为我们处理序列化和反序列化。

此外，socket.io 提供了对消息命名空间、连接多路复用、断开检测、重新连接以及向所有客户端广播消息的 API 支持。

考虑到本节中涵盖的所有内容，我们可以得出结论，socket.io 将需要自己的协议和机制来工作。

# Socket.IO 套接字

socket.io 套接字通过不同的传输机制模拟网络套接字。就像任何其他套接字一样，它在其生命周期中有各种阶段，这取决于连接的状态。以下是这些阶段：

+   正在连接

+   已连接

+   正在断开连接

+   断开连接

当客户端向服务器发送连接请求并开始握手时，套接字建立。

一旦握手完成，将使用握手期间协商的传输方式打开连接，并将套接字的状态设置为*已连接*。

为了根据服务器配置检查套接字的活动性，服务器可能需要客户端定期向服务器发送心跳消息。如果没有这样的消息，或者底层传输失败，套接字将被断开连接。

在这种情况下，客户端将发起一个重新连接。如果连接在连接终止时间或握手时同意的超时时间内恢复，则缓冲的消息将被发送。如果连接未恢复，客户端将启动一个新的连接请求，从新的握手开始。

此外，可选地，为了确保通过套接字的消息传递，我们可以强制套接字确认消息传递。

当在客户端或服务器上调用`close`方法时，套接字将被终止。

# Socket.IO 连接

socket.io 连接从握手开始。这使得握手成为协议的一个特殊部分。除了握手之外，协议中的所有其他事件和消息都是通过套接字传输的。

Socket.io 旨在与 Web 应用程序一起使用，因此假设这些应用程序始终能够使用 HTTP。正因为如此，socket.io 的握手才发生在 HTTP 上。

为了发起连接并执行握手，客户端在握手 URI（由传递给`connect`方法的 URI 构建）上执行一个`POST`请求。让我们以相同的 socket.io 连接 URI 为例，尝试理解其各个部分。假设 URI 如下：

[`myhost.com:8080/socket.io/1/`](http://myhost.com:8080/socket.io/1/)

让我们分解并理解这个 URI。

`http` 是正在使用的协议。我们可以将其设置为使用`https`，在客户端的`connect` `ct`方法中使用`https`。

`myhost.com` 再次来自`connect`方法，是你想要连接的主机的名称或 IP 地址。默认值为`localhost`。

`8080` 是服务器监听的端口。当我们调用它时，这也传递给了`connect`方法。默认值为`80`。

`socket.io` 是处理所有连接请求的命名空间。

`1` 是 socket.io 协议版本号。

服务器可以通过以下三种方式之一对此做出响应：

+   `200 OK` – 当握手成功时，服务器将给出此响应。除了状态外，响应体应该是一个冒号分隔的列表，包含分配给此连接的会话 ID、心跳超时、连接关闭超时以及通过逗号分隔的支持的传输列表。一个示例响应体如下：

    ```js
    8749dke9387:20:10:websocket,flashsocket,xhr-polling
    ```

+   `401 Unauthorized` – 如果授权处理程序未能授权客户端，服务器将给出此响应。正如我们在上一章中看到的，这是我们附加到服务器上`authorize`事件的处理器，它使用连接和 cookie 信息来授权用户。

+   `503 服务不可用` – 当服务器有任何其他原因（包括错误）拒绝向客户端提供服务时。

如果握手成功，基于服务器提供的传输和客户端支持的传输，socket.io 客户端将开始在特定的 URI 上与服务器通信。此 URI 的形式为`[scheme]://[host]/[namespace]/[version]/[transportId]/[sessionId]`。

+   `[scheme]` 是客户端将用于通信的协议。在 WebSocket 的情况下，这将是`ws`或`wss`，而在 XHR 的情况下，则是`http`或`https`。

+   `[host]` 是服务器名称或 IP 地址。

+   `[namespace]` 是我们想要发送消息的 socket.io 命名空间。

+   `[version]` 是我们使用的 socket.io 协议版本，目前为`1`。

+   `[transportId]` 是为通信选择的传输机制名称。

+   `[sessionId]` 是服务器在握手期间分配给客户端的会话 ID。

在双向传输的情况下，例如 WebSocket，在此 URI 上打开的连接将用于发送和接收消息。

对于单向传输，如 XHR 长轮询，客户端将在此 URI 上执行`GET`请求，服务器将保持此请求直到有数据要发送，而客户端将在此 URI 上执行`POST`请求，每当它需要向服务器发送消息或事件时。

# Socket.IO 消息

一旦建立了传输的连接，客户端和服务器之间的所有通信都通过套接字上的消息进行。消息需要按照 socket.io 指定的格式进行编码。

此格式使 socket.io 能够确定消息的类型和消息中发送的数据，以及一些对操作有用的元数据。消息格式为`[type] : [id ('+')] : [endpoint] (: [data])`。

+   `type` 是一个单数字整数，指定消息的类型。

+   `id` 是消息 ID，它是一个递增整数；它用于 ACK。它是可选的。

+   如果存在`+`符号，它告诉 socket.io 不要处理 ACK，因为应用程序打算自己处理它。

+   `endpoint` 是消息打算发送到的 socket 端点。这是可选的，用于在命名空间中复用套接字。如果省略，消息将发送到默认套接字。

+   `data` 是要发送到套接字的相关数据。在消息的情况下，它被视为纯文本，而在事件的情况下，它将被解析为 JSON。

在接下来的章节中，我们将看到消息的类型。

## 断开连接（0）

当类型为零（`0`）时，消息是一个断开信号。这将告诉 socket.io 关闭连接和提到的套接字。如果未指定端点，消息将发送到默认套接字，这将导致整个套接字关闭，并且该套接字上的所有端点都将终止。例如：

+   消息：`0` – 结果是套接字被关闭，所有连接/端点都被终止。

+   消息：`0::/endpoint` – 将关闭到 `/endpoint` 的套接字连接，并且无法向该端点发送或接收消息。其他端点将继续运行。

## 连接（1）

此消息仅用于多路复用，并由客户端发送到服务器以打开新的连接。因此，此消息必须始终包含一个端点。第一个（默认）套接字连接是通过前面解释的手 shake 建立的。端点可能后跟 URL 查询格式的查询参数。如果连接成功，服务器将回显相同的消息，否则服务器可以发送错误消息。例如：

+   消息：`1::/endpoint` – 请求服务器打开一个到端点的多路复用套接字。

+   消息：`0::/endpoint?param=one` – 请求服务器打开一个到端点的多路复用套接字，传递一个名为 `param` 的参数，其值为 `one`。

## 心跳（2）

这是心跳消息。必须在握手期间协商的超时时间内从客户端发送到服务器。服务器也将回复心跳消息。在这种情况下，我们没有端点，也不需要任何其他信息。这是因为它服务于整个套接字。例如：

+   消息：`2` – 向另一端发送心跳消息。

## 消息（3）

这是通过套接字发送的消息。在 API 中，此消息将在您使用 `socket.send` 时发送，并在接收端引发消息事件。此消息将携带数据，将其视为纯文本。例如：

+   消息：`3:1::Some message` – 这将向另一端发送消息，其中消息事件处理程序将触发事件数据中的 `Some message` 消息。

+   消息：`3:1:/endpoint:Some message` – 再次，消息将被发送到套接字的另一端，但是在多路复用端点上。

## JSON 消息（4）

这与发送消息类似，但在此情况下，消息必须使用 JSON 进行序列化，并在发送到处理程序之前在另一端进行解析。在版本 0.6 中，这是使用与 `send()` 消息相同的 API 实现的，只是传递一个 JSON 消息而不是字符串消息。但从版本 0.7 开始，由于这引入了比发送纯文本更高的性能开销，我们必须使用 `json` 标志来发送 JSON 消息；例如，`socket.json.send`。例如：

+   消息：`4:1::{"some":"content"}` – 将 JSON 消息发送到套接字的另一端。

## 事件（5）

事件消息是一种特殊的 JSON 消息，用于通过套接字发送事件。在事件中，数据负载的形式为 `{"name":"eventName", "args":{"some":"content"}}`。

在这里，`name` 是事件的名称，`args` 是要发送到处理程序的参数。`socket.emit` 调用用于在应用程序中发送事件。

以下事件名称是保留的，不能在应用程序中使用：

+   `message`

+   `connect`

+   `disconnect`

+   `open`

+   `close`

+   `error`

+   `retry`

+   `reconnect`

例如：

+   消息：`5:1::{"name": "myEvent", "args":{"some": "data"}}` – 结果是事件将被发送到另一端，并且将调用适当的事件处理器，并将参数传递给它。

## ACK (6)

当消息被接收并且启用了 ACK 请求时，将发送确认（ACK）消息；或者，它也可以由应用程序发送。ACK 消息中的数据部分可以是正在确认的消息的 ID。如果消息 ID 后面跟着`+`和附加数据，它被视为一个事件包。例如：

+   消息：`6:::1` – 发送对 ID 为`1`的消息的接收确认。

+   消息：`6:::1+["A", "B"]` – 这将发送包含数据的消息确认。

## 错误 (7)

当服务器在处理连接到端点的`connect`请求时出现错误等情况时，会发送此消息。此消息的数据部分将包含错误消息和可选的建议，由`+`符号分隔。例如：

+   消息：`7:::Unauthorized` – 结果是将错误发送到客户端。

## NOOP (8)

此消息表示没有操作，用于在轮询超时后关闭轮询。

# 概述

在本章中，我们看到了 socket.io 服务器和客户端的通信机制。理解其工作原理和消息格式，有助于我们在开发 socket.io 应用程序时调试遇到的问题。

在下一章中，我们将学习如何在生产环境中部署和扩展 socket.io 应用程序。同时，我们还将获得一些关于如何最小化生产服务器上麻烦的提示。
