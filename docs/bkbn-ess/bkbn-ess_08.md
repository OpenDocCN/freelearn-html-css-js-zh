# 第八章。扩展 – 确保复杂应用程序的性能

在本章中，我们将探讨 Backbone 中最常见的性能问题，以及如何避免它们。特别是，我们将涵盖以下内容：

+   基于 CPU 的性能问题

+   与内容大小相关的基于带宽的性能问题

+   与请求数量相关的基于带宽的性能问题

+   基于内存的性能问题

# Backbone 与性能

Backbone 的核心只是一个 JavaScript 库，因此它不会添加任何 JavaScript 本身没有的新性能挑战。事实上，Backbone 的创建者已经非常注意使库性能良好，并且在与其他库的性能比较中，Backbone 通常处于领先地位，如果不是最顶尖的。

然而，尽管 Backbone 本身不会创建性能问题，但它确实为创建 Web 应用程序提供了全新的方式，并且由于此类应用程序可能比传统网站复杂得多，因此暴露了全新的潜在性能问题领域。在本章中，我们将探讨这些问题，以及它们的技术细节，并讨论避免或减轻这些问题的方法。

# 性能问题的原因

当用户遇到性能问题时，是因为他已经超出了他系统资源（带宽、内存或处理能力）之一的容量。在调试任何性能问题之前，了解这些因素中的哪一个负责是至关重要的，这可以通过两种方式之一来确定。首先，可以使用性能分析工具（如所有主要浏览器中包含的工具）来测量每种资源的使用量，这应该会迅速清楚地表明哪种资源被过度使用。这些工具的解释超出了本书的范围，但我强烈建议您熟悉您最喜欢的浏览器中可用的工具。

对于大多数问题，然而，甚至不需要使用性能分析工具，因为它们的原因可以通过它们的表现来确定。带宽问题仅在从您的服务器检索或发送数据时出现（在大多数应用程序中，只有检索操作涉及足够的带宽以成为问题）。如果它们在加载时出现，那么可能是由大量大型静态资源（如图像）引起的，但如果它们在之后出现，更有可能是由 AJAX 调用引起的。在 Backbone 应用程序中，这意味着从`Models`或`Collections`进行的*fetch*操作（或很少见的*save*或*destroy*操作）。

CPU 性能问题仅在用户的计算机被迫对您让它做的事情进行深入思考时才会出现。例如，一系列嵌套的`for`循环，或渲染复杂的可视化（如图表）可能导致此类性能问题。这种性能问题通常很容易识别，因为它仅在用户触发这种计算密集型代码时才会发生。

性能问题的最终来源，也是最难解决的，是内存。与通常有明显的触发器（如 AJAX 操作的开始或图表的渲染）的其他两个问题不同，内存问题可能没有任何明显或明显的来源。事实上，内存问题可能在用户真正开始注意到问题之前几秒甚至几分钟就开始出现，迫使你回溯所有触发的代码以尝试找到原因。由于内存问题是最常见的类型，并且它们是最难理解和解决的，因此我们将重点放在它们上。然而，在我们这样做之前，让我们检查其他两个来源，以及一些避免它们的常识性方法。

# 与 CPU 相关的性能问题

如前所述，Backbone 本身通常不会是 CPU 相关性能问题的源头，因为这些问题的原因往往是由特定组件引起的，而不是整个网站架构。然而，Backbone 可以通过使重复相同工作变得容易而贡献于这类问题。例如，让我们假设你正在创建一个仪表板页面，该页面将使用一个主要的`View`类来展示用户的各种数据，以及多个子`Views`来渲染这些数据中的每一个。此外，让我们假设这些数据将定期更新。通常，你会将数据的更新与 AJAX 响应或用户事件绑定，但在某些情况下，你可能更愿意使用`setInterval`语句。例如，`onScroll`事件已知存在问题，因此许多开发者避免使用它们，而是依赖于`setInterval`定期检查滚动。

只要只有一个`setInterval`事件在运行，这种方法就会工作得很好，但如果你决定为每个子`View`创建一个单独的`setInterval`事件会怎样呢？对于只有少数子`Views`的情况，这仍然可能工作，但最终，太多的这种间隔将消耗用户的 CPU 资源，导致性能问题。在最坏的情况下，虽然你的开发机器可以处理页面，但用户的（较弱的）机器可能无法处理，导致用户报告你无法复制的错误。

在此类情况下，解决方案简单明了：不要不必要地重复执行计算密集型任务。在前面的例子中，你不需要每个子`View`都响应自己的`setInterval`事件来更新，你可以在主`View`中启动一个单独的`setInterval`进程，然后让它触发子`Views`的更新（可能通过使用前一章中描述的 pub/sub 模式）。

# 事件委托

开发者可以通过创建过多的事件处理器，以另一种方式轻易地对用户的浏览器造成不必要的压力。例如，假设你想创建一个大表格（可能是 20 行×20 列），因此你为表格创建了一个父`View`，并为每个单元格创建了大量子`View`。到目前为止，一切顺利！现在假设，你为这些子`View`中的每一个添加了一个`click`事件处理器。没有意识到，你刚刚创建了 400 个事件处理器。如果你为单元格内的`<input>`元素添加另一个事件处理器，比如一个`change`处理器，你又会增加 400 个，以此类推。

给定足够的`Views`和足够的事件处理器，这最终可能会造成性能问题，但幸运的是，JavaScript 自带了一个我们可以用来解决这个问题内置机制：事件冒泡。每当在 DOM 中发生事件时，它首先在相关的 DOM 元素上触发事件处理器，然后冒泡到该元素的每个后续父元素。换句话说，如果一个`click`事件发生在`<td>`元素上，浏览器将首先解决绑定到该`<td>`元素的任何事件处理器，然后（除非某个事件处理器返回了 false），它将调用`<td>`元素父`<tr>`元素上的处理器，然后是那个`<tr>`父元素的`<table>`：

```js
$(document.body).append('<table><tr><td></td></tr></table>');
$('td').on('click', function(e) {
    e.target; // will be the td element
    e.currentTarget; // will also be the td element
});
$('tr').on('click', function(e) {
    e.target; // will still be the td element
    e.currentTarget; // will be the tr element
});
$('table').on('click', function(e) {
    e.target; // will still be the td element
    e.currentTarget; // will be the table element
});
$('td').click(); // first the td handler will trigger, then the tr
                 // handler, and finally the table handler
```

我们可以利用这个事实，并改变我们的事件绑定策略，通过将事件绑定到父`table`元素的`View`而不是每个子`View`来提高性能。然后，这个父`View`事件处理器可以通过使用事件的`target`属性来确定哪个子`View`引发了事件，从而触发相关子`View`上的适当逻辑。虽然这种方法需要稍微多做一些工作，但它使我们能够将 400 个点击事件处理器减少到单个事件处理器，并且在特别复杂的页面（例如我们假设的表格页面）上，使用这种事件代理可以显著减少对浏览器的压力。

# 与带宽相关的性能问题

虽然确实，近年来典型用户的带宽显著增长，但带宽仍然是网络开发者面临的一个持续问题。然而，许多开发者并没有意识到，实际上存在两个主要的带宽问题来源。第一个问题相当明显：强迫用户下载过大的文件。但是，还有一个不那么明显的问题：强迫用户一次性下载过多的文件。

## 下载过大的文件

让我们先从最明显的原因开始。如果用户需要下载的文件太大，无论是图片、视频还是 JavaScript 代码文件，你的网站都会加载得很慢。然而，你可以在使用任何文件的大小上做出很大的改变，只需在 Web 服务器级别启用压缩即可。在 Apache Web 服务器上，这可以通过使用`mod_deflate`来实现，而大多数其他 Web 服务器都有类似选项。这样做会使服务器以用户浏览器可以轻松解压缩的方式压缩发送给用户的文件……而用户甚至不知道有任何解压缩正在进行。

然而，如果开启压缩没有足够帮助，那么你的下一步取决于文件类型。如果你的问题来自图片或视频，那么你只需找到一种方法来使用更小的文件，例如，通过降低它们的分辨率。然而，如果你的主要问题是 JavaScript 文件，那么还有一个选择：使用压缩程序。

最小化程序解析你的代码，创建一个新的优化版本，该版本消除了注释，移除了额外的空白，并使用更短的名字重命名变量。使用此类程序的唯一缺点是，它会使你在生产服务器上调试问题变得更加困难，只要你有一个匹配的开发环境，你不需要对文件进行最小化，这就不应该是一个问题。此外，如果最小化确实成为一个问题，你总是可以暂时将服务器切换回未最小化的文件来进行调试。

服务器压缩和最小化这两种技术结合起来，可以在文件大小上产生重大差异。例如，未压缩的 jQuery 库（版本 1.11.0）大小为 276 KB，而压缩版本仅为 82 KB，而最小化后的压缩 jQuery 代码版本仅为 33 KB。换句话说，仅仅通过使用这两种技术，就有可能将 jQuery 的占用空间减少近十倍！

## 下载过多文件

不幸的是，即使你减少了代码文件和资源的带宽，还有一个更微妙但需要关注的带宽问题，这与用户下载的字节数无关。要理解这个问题，你必须了解浏览器如何处理数据请求，无论是来自 DOM（如`<link>`和`<script>`标签）的还是 AJAX 请求。

当浏览器打开到特定远程计算机的连接时，它会跟踪已经打开到该计算机域的连接数量，如果已经打开太多，它会暂停，直到之前的某个请求完成。在发生这种情况之前可以发生的连接数因浏览器而异：在 Internet Explorer 7 中，只有两个，但在大多数现代浏览器中，是六或八个。由于这个限制，并且因为每个请求，无论大小，都需要一定的时间（也称为延迟），实际使用的带宽可能无关紧要。解决带宽问题主要有两种方法。

首先，显然是要减少请求数量。如果你的问题是同时获取过多的`模型`，`集合`可以非常有助于解决这个问题；而不是单独获取每个`模型`类，只需在你的服务器上创建一个可以一次性返回所有`模型`的端点，然后使用`集合`类来获取它们。尽管你将下载相同数量的数据，但这种 API 的改变将导致请求量显著减少。同样，如果你的问题是图像过多，你可以将所有图像合并成一个单独的`sprites`文件，然后使用 CSS 只显示一次图像。

另一个选项，如果你的应用程序确实需要大量的请求，可以使用子域名。当浏览器计算未完成的连接数时，它不仅查看源域名，还查看其子域名。这意味着你可以从[`example.com/`](http://example.com/)获取最大数量的请求，然后，从`foo.example.com`、`bar.example.com`等获取相同数量的请求。这个技巧通常用于更快地提供 CSS 和图像，但也可以同样容易地用于进行大量的并发获取（只要适当地更新你的`url`方法以从正确的子域名获取）。

最后，还有一个解决带宽问题的方案，这并不是真正解决了这些问题，而是使它们对用户来说更加容易接受。如果你知道你将发起一个请求，这个请求的时间足够长以至于用户会注意到，你可以给用户一个视觉等待指示器，比如添加一个动画旋转图像或改变光标的 CSS 属性以等待。如果你在开始`fetch`操作之前进行这些更改，然后你可以使用该操作的成功和失败回调（或者如果你使用延迟样式，一个单一的`complete`回调）来撤销这些更改。虽然这不会使你的数据下载速度更快，但它会在用户体验上有所区别。

# 与内存相关的性能问题

与内存相关的问题是最难调试和解决的，而且不幸的是，当你刚开始使用 Backbone 时，它们也是最有可能遇到的。再次强调，这并不是因为 Backbone 本身有内存问题，而是因为 Backbone 提供的可能性如果开发者不小心，可能会自己给自己挖坑。

然而，在我们继续之前，首先解释一下浏览器是如何管理内存的非常重要。正如你可能已经知道的，JavaScript 中的内存是由浏览器而不是开发者管理的，使用的是称为**垃圾回收器**的东西。这意味着你不需要告诉浏览器我已经完成对这个变量的使用。相反，你只需停止使用那个变量，浏览器就会弄清楚它已经变成了`garbage`，这通常会使它自动清理那个变量。

问题在于垃圾回收器对垃圾的简单解释。本质上，任何没有被其他变量引用的变量都被认为是垃圾。例如：

```js
var bookReference = {
    fakeBook: new Book({title: 'Hamlet, Part 2: The Reckoning'})
};
delete bookReference.fakeBook;
// fakeBook has no references, and will be collected as "garbage"
```

问题在于开发者往往没有意识到他们留下了变量的引用，因此迫使浏览器继续使用其内存，尽管程序员认为它是垃圾。让我们看看一个例子：

```js
var exampleModel = new Backbone.Model();
var exampleView = new Backbone.View();
exampleModel.on('change', exampleView.render);
$(document.body).append(exampleView.el);
exampleView.remove();
// exampleView will NOT be garbage collected
```

在这个例子中，当我们调用`exampleView.remove()`并从 DOM 中移除`exampleView`时，似乎我们消除了对`exampleView`的所有引用，但实际上，还有一个引用被遗留下来，隐藏在`exampleModel`内部。这个引用是在我们调用`exampleModel`的`on`方法并传递`exampleView.render`时创建的。通过这样做，我们告诉`Model`等待发生变化，然后调用`exampleView.render`，这需要它存储对`exampleView.render`的引用。由于我们没有删除`exampleModel`，这个引用仍然存在，不会被垃圾回收，从而在浏览器内存中留下一个所谓的僵尸`View`。

解决这个问题的方法之一是使用`off`方法手动删除这个引用：

```js
example.model.off('change');
```

然而，管理这样的引用很快就会变得繁琐。幸运的是，Backbone 的创建者为`View`（以及其他三个 Backbone 类）添加了一个方法来帮助解决这个问题，称为`listenTo`。这个方法与`on`非常相似，有两个重要的区别。首先，它是在监听对象（在这种情况下，是`View`）上调用，而不是在被监听的对象（在这种情况下，是`Model`）上调用，其次，它不接收上下文参数。相反，回调的上下文将始终设置为`listenTo`被调用的对象。

正如存在`off`方法用于`on`一样，也存在一个`stopListening`方法，它可以移除由`listenTo`创建的监听器。然而，你不需要经常调用`stopListening`，因为它会作为`View`的`remove`方法的一部分自动调用，这使得它非常方便。

让我们使用 `listenTo` 重新尝试我们的上一个例子：

```js
exampleModel = new Backbone.Model();exampleView = new Backbone.View();
exampleModel.listenTo('change', exampleView.render);
$(document.body).append(exampleView.el);
exampleView.remove();
// exampleView WILL be garbage collected
```

这次，就像之前一样，我们有一个 `View` 正在监听 `Model` 的变化。然而，因为我们使用了 `listenTo` 而不是 `on`，作为副作用创建的引用将在调用 `stopListening` 时被移除。由于我们在 `exampleView` 上调用了 `remove`，并且这个方法会自动为我们调用 `stopListening`，所以我们的 `View` 被正确地垃圾回收，而无需我们做任何额外的工作。

然而，不幸的是，`listenTo` 无法解决所有潜在泄漏的引用。一方面，你可能仍然需要不时地使用 `on` 方法。这样做的主要原因是为了监听来自非 Backbone 代码的事件，例如 jQuery UI 小部件。你也可能因为（与 `listenTo` 不同）它接受一个上下文参数而想使用 `on`，但多亏了 Underscore 的 `bind` 方法，你不需要这样做；你可以在将回调函数传递给 `listenTo` 之前，简单地在你想要的上下文中绑定回调函数。然而，即使你完全避免使用 `on`，你仍然需要记得在 `View` 上调用 `remove`。如果你不这样做，你仍然需要使用 `off` 或 `stopListening` 来清除事件绑定引用。最后，事件处理器并不是引用的唯一来源。

例如，父 `View` 和子 `View` 经常相互引用，除非你完全删除引用 `View`，否则它所引用的 `View` 实际上不会被垃圾回收。好消息是，在小规模上，你不需要过于担心这样的引用，实际上，试图过度优化应用程序中每一行代码的性能可能会适得其反。任何给定的 `Model` 或 `View` 通常只占用很少的内存，所以即使你创建了防止其被垃圾回收的泄漏引用，对应用程序性能的实际影响也将是最小的。如果用户甚至没有注意到泄漏，然后在关闭浏览器或刷新时回收内存，那么显然你不需要花费时间担心它。

相反，当你处理大量对象时，你主要需要关注管理你的引用。如果你正在设计一个将在整个应用程序中使用的页面 `View`，或者为具有许多单独子 `View` 的大表格创建 `View`，那么你可能希望对每个创建的引用格外小心，并确保在完成使用后清理所有这些引用。

# 摘要

在本章中，我们学习了 JavaScript 代码在一般情况下，以及 Backbone 代码特别情况下，如何导致性能问题。我们了解了这类问题的三个主要原因（即带宽、CPU 和内存），以及可以用来解决这些问题的技术和方法。特别是，我们学习了漏斗式事件绑定或其他引用如何阻止垃圾回收，以及如何使用`listenTo`或手动清理引用来使垃圾回收按预期工作。

在下一章中，我们将探讨良好代码文档化的好处，学习如何解决一些 Backbone 特定的文档挑战，并考虑众多高质量的文档工具中哪一个是用于记录你的项目的最佳选择。
