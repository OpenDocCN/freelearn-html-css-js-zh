# 第一章：Node.js 简介

Node.js 已经开启了服务器端 JavaScript 的时代，这是客户端 JavaScript 在过去几年中经历的复兴的下一个逻辑步骤。虽然 Node.js 不是第一个服务器端 JavaScript 实现，但它肯定成为了最受欢迎的。通过利用 JavaScript 作为一种语言的最佳特性并培养一个充满活力的社区，Node.js 已经成为一个非常受欢迎的平台和框架，而且没有放缓的迹象。关于 Node 是什么的很好描述可以在[`nodejs.org/`](http://nodejs.org/)找到：

> Node.js 是建立在 Chrome 的 JavaScript 运行时之上的平台，用于轻松构建快速、可扩展的网络应用程序。Node.js 使用事件驱动的、非阻塞的 I/O 模型，使其轻量高效，非常适合在分布式设备上运行的数据密集型实时应用程序。

# Node.js 的历史

该项目始于 2009 年，是 Ryan Dahl 的创意。在那一年的 JSConf.eu（欧洲每年举办的会议）上，他做了演讲，改变了 JavaScript 开发的面貌。他的演讲包括了一个完整的 IRC 服务器的令人印象深刻的演示，该服务器用大约 400 行 JavaScript 编写。在他的演讲中，他概述了为什么开始这个项目，为什么 JavaScript 成为其中一个重要部分，以及他在服务器编程领域中希望实现的目标，特别是关于我们如何处理输入和输出（I/O）。

那一年晚些时候，**npm**项目开始了，其目标是管理 Node.js 应用程序的软件包，并创建一个公开可用的注册表，供 Node.js 开发人员之间共享代码。截至 Node.js 的 0.6.3 版本，npm 已经部署并与 Node.js 一起安装，成为事实上的软件包管理器。

# Node.js 的不同之处？

Node.js 与其他平台的不同之处在于它如何处理 I/O。它使用事件循环与异步 I/O 相结合，这使得它能够以轻量级的方式实现高并发性。

通常，当程序需要某种外部输入时，它会以同步的方式进行。以下代码行对任何程序员来说应该非常熟悉：

```js
var results = db.query("SELECT * FROM users");
print(results[0].username);
```

我们在这里所做的一切就是查询 SQL 数据库中所有用户的列表，然后打印出第一个用户的名字。在查询这样的数据库时，需要采取许多中间步骤，例如：

1.  打开到数据库服务器的连接。

1.  将请求通过网络传输到该服务器。

1.  服务器本身需要在接收到请求后处理该请求。

1.  服务器必须通过网络将响应传输回我们的应用程序。

这个列表并没有涵盖所有的细节，因为有比必要的要点更多的因素。通过查看我们的源代码，这被视为瞬时操作，但我们知道得更清楚。我们经常忽视这种浪费的时间，因为它发生得如此之快，以至于我们没有注意到它的发生。考虑以下表格：

| I/O 的成本 |
| --- |
| L1 缓存 | 3 个周期 |
| L2 缓存 | 14 个周期 |
| RAM | 250 个周期 |
| 磁盘 | 41,000,000 个周期 |
| 网络 | 240,000,000 个周期 |

每个 I/O 操作都有一个成本，在使用同步 I/O 的程序中直接支付。在程序可以继续进行之前，可能会有数百万甚至数千万个时钟周期发生。

编写应用程序服务器时，这样的程序一次只能为一个用户提供服务，直到上一个用户的所有 I/O 和处理完成后，才能为下一个用户提供服务。这是不可接受的，所以最简单的解决方案是为每个传入的请求创建一个新的线程，这样它们可以并行运行。

这就是**Apache**网页服务器的工作原理，实现起来并不困难。然而，随着同时用户数量的增加，内存使用量也会增加。每个线程都需要操作系统级别的开销，并且这些开销会迅速累积。此外，在这些线程之间进行上下文切换的开销比预期的更加耗时，进一步加剧了问题。

**nginx**网页服务器使用事件循环来处理进程。通过这样做，它能够同时处理更多的用户，使用更少的资源。事件循环要求将处理的位分解成小块，并在一个单一队列中运行。这消除了创建线程的高成本，来回切换线程之间的开销，并减少了对整个系统的需求。同时，它填补了处理间隙，特别是在等待 I/O 完成时发生的间隙。

Node.js 采用了 nginx 成功使用的事件驱动模型，并为许多类型的应用程序提供了相同的能力。在 Node.js 中，所有 I/O 都是完全异步的，不会阻塞应用程序的其他线程。Node.js API 接受函数参数（通常称为“回调函数”）进行所有 I/O 操作。然后 Node.js 启动该 I/O 操作，并让应用程序外的另一个线程进行处理。完成请求的操作后，事件循环被通知，回调函数被调用并返回结果。

事实证明，等待 I/O 完成是许多应用程序在原始处理时间方面最昂贵的部分。使用 Node.js，等待 I/O 的时间完全与应用程序的其余处理时间分离。你的应用程序只是使用回调函数来处理结果作为简单的事件，并且 JavaScript 的闭包能力保留了函数的上下文，尽管是异步执行的。

如果你要写一个多线程应用程序，你将不得不关注并发问题，比如死锁，这在真实应用程序中很难（甚至不可能）重现和调试。使用 Node.js，你的主要应用逻辑在单个线程上运行，不会出现这样的并发问题，而耗时的 I/O 则由 Node.js 代表你处理。

和其他平台一样，Node.js 有一个 API 供开发者编写他们的应用程序使用。JavaScript 本身缺乏标准库，特别是用于执行 I/O。这实际上成为 Ryan Dahl 选择 JavaScript 的原因之一。因为核心 API 可以从头开始构建，而不需要担心与标准库发生冲突，如果做错了（考虑到 JavaScript 的历史，这并不是一个不合理的假设）。

那个核心库是最小化的，但它包括了基本的模块。这包括但不限于：文件系统访问、网络通信、事件、二进制数据结构和流。其中许多 API 虽然不难使用，但在实现上非常底层。考虑一下这个直接来自 Node.js 网站的“Hello World”演示（附加了注释）：

```js
// one of the core modules
var http = require('http');
// creates an http server, this function is called for each request
http.createServer(function (req, res) {
  // these parameters represent the request and response objects
  // the response is going to use a HTTP status code 200 (OK)
  // the content-type HTTP header is set as well
  res.writeHead(200, {'Content-Type': 'text/plain'});
  // lastly, the response is concluded with simple text
  res.end('Hello World\n');
}).listen(1337, '127.0.0.1');
console.log('Server running at http://127.0.0.1:1337/');
```

这个服务器使用**http**核心模块来建立一个简单的网页服务器，向任何请求它的人发送“Hello World”。这是一个简单的例子，但没有注释的话，总共只有六行代码。

Node.js 团队选择保持核心库的范围有限，让开发者社区为其他所有内容创建他们所需的模块，比如数据库驱动程序、单元测试、模板和核心 API 的抽象。为了帮助这个过程，Node.js 有一个叫做 npm 的包管理器。

npm 是处理 Node.js 应用程序安装依赖项的工具。它选择本地捆绑的依赖项，而不是使用单一的全局命名空间。这允许不同的项目拥有自己的依赖项，即使这些项目之间的版本不同。

### 提示

**下载示例代码**

您可以从您在[`www.packtpub.com`](http://www.packtpub.com)购买的所有 Packt 图书的帐户中下载示例代码文件。如果您在其他地方购买了本书，您可以访问[`www.packtpub.com/supportand`](http://www.packtpub.com/supportand)注册，将文件直接发送到您的电子邮件。

除了允许使用第三方模块外，npm 还使得向注册表贡献成为公开的事务。将模块添加到注册表就像执行一个简单的命令一样，使得进入门槛极低。如今，npm 注册表上列出了超过 42,000 个软件包，并且每天都在快速增长。

注册表增长如此迅速，显然背后有一个充满活力的生态系统。我个人可以证明，Node.js 开发者社区非常友好，极其多产，并且有巨大的热情。

# 保护 Node.js 应用程序

在保护您的应用程序时，有许多因素需要考虑。我们将首先检查 JavaScript 本身，然后分析 Node.js 作为一个平台，并揭示一些与讨论相关的内部信息。之后，我们将调查整个应用程序的考虑因素和模式。最后，我们将调查应用程序请求和响应级别的漏洞。通过本书的最后，您应该对 Node.js 的内部有足够的了解，不仅能够解决我们在这里讨论的问题，还能够理解可能出现在您的应用程序中的任何未来漏洞。

# 摘要

在本章中，我们探讨了 Node.js 项目本身的历史，并介绍了开发环境和社区的背景。在下一章中，我们将首先查看 JavaScript 语言本身的安全功能。
