- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Implementing Structural Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现结构型设计模式
- en: Structural design patterns give us tools to handle *connecting* different objects;
    in other words, managing the relationships between objects. This includes techniques
    to reduce memory usage and develop functionality with existing classes without
    modifying these existing classes. In addition, JavaScript features allow us to
    more effectively apply these patterns. Modern JavaScript includes some built-ins
    that allow us to implement structural design patterns in a more efficient manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型设计模式为我们提供了处理*连接*不同对象的方法；换句话说，管理对象之间的关系。这包括减少内存使用和在不修改现有类的情况下开发功能的技术。此外，JavaScript特性使我们能够更有效地应用这些模式。现代JavaScript包括一些内置功能，允许我们以更有效的方式实现结构型设计模式。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining structural design patterns as a whole, and proxy, decorator, flyweight,
    and adapter specifically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义结构型设计模式整体，以及代理、装饰、享元和适配器具体实现
- en: An implementation of the proxy pattern with a class-based approach as well as
    an alternative using Proxy and Reflect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于类的代理模式实现以及使用Proxy和Reflect的替代实现
- en: Multiple implementations of the decorator pattern, leveraging JavaScript first-class
    support for functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用JavaScript对函数的一级支持实现的装饰模式多种实现
- en: An iterative approach to implementing flyweight in JavaScript, including ergonomic
    improvements using modern JavaScript features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种迭代方法，用于在JavaScript中实现享元模式，包括使用现代JavaScript特性进行的人体工程学改进
- en: Class- and function-based adapter implementations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于类和函数的适配器实现
- en: At the end of this chapter, you’ll be able to make informed decisions on when
    and how to use structural design patterns in JavaScript.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够就何时以及如何在使用JavaScript时应用结构型设计模式做出明智的决定。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
- en: What are structural design patterns?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是结构型设计模式？
- en: When building software, we want to be able to *connect* different pieces of
    code (e.g., classes and functions) and change how the parties involved in these
    connections and relationships interact without having to jump through multiple
    fragmented parts of the codebase.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建软件时，我们希望能够*连接*不同的代码片段（例如，类和函数），并改变参与这些连接和关系的各方如何交互，而无需跳转到代码库的多个碎片化部分。
- en: Structural design patterns allow us to add, remove, and change functionality
    in modules and classes safely. The “structural” aspect of these patterns is due
    to the fact that we can play around with implementations if the exposed interfaces
    are stable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型设计模式允许我们在模块和类中安全地添加、删除和更改功能。这些模式的“结构”方面是由于我们可以围绕实现进行操作，如果暴露的接口是稳定的。
- en: Structural design patterns are a good way to maintain the separation of concerns
    and loose coupling of different classes and modules while maintaining a high development
    velocity.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型设计模式是维护关注点分离和不同类和模块的松散耦合，同时保持高开发速度的好方法。
- en: In the next section, we’ll look at multiple approaches to implement the Proxy
    pattern in JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨在JavaScript中实现代理模式的多种方法。
- en: Implementing the Proxy pattern with Proxy and Reflect
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Proxy和Reflect实现代理模式
- en: The proxy pattern involves providing an object (the `subject`, or `real` object)
    that fulfills a certain interface. The `proxy` (a `placeholder` or `wrapper` object)
    controls access to the `subject`. This allows us to provide additional functionality
    on top of the subject without changing a consumer’s interactions with the `subject`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式涉及提供一个对象（`subject`，或`real`对象），该对象满足一定的接口。`proxy`（一个`placeholder`或`wrapper`对象）控制对`subject`的访问。这允许我们在不改变消费者与`subject`交互的情况下，在`subject`之上提供额外的功能。
- en: This means that a proxy needs to provide an interface matching the `subject`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着代理需要提供一个与`subject`匹配的接口。
- en: By using the proxy pattern, we can intercept all operations on the original
    object and either pass them through or change their implementation. This follows
    the open/closed principle, where both the `subject` and `consumer` are closed
    for modification, but the proxy provides us with a hook to `extend`, which means
    the design is open to extension.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用代理模式，我们可以拦截对原始对象的全部操作，要么将它们传递通过，要么改变它们的实现。这遵循了开闭原则，其中`subject`和`consumer`都封闭于修改，但代理为我们提供了一个钩子来`extend`，这意味着设计是开放的，可以扩展。
- en: A redaction proxy implementation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红色代理实现
- en: 'We’ll start with the following implementation class that has a couple of methods
    that output strings:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下实现类开始，它有几个输出字符串的方法：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s imagine that the `sensitive` string in the output should be redacted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象输出中的`sensitive`字符串应该被编辑。
- en: 'Here’s how a `RedactionProxy` class could look:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个`RedactionProxy`类可能的样子：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this case, `RedactionProxy` does what we call a `someFn()` calls. In other
    words, `RedactionProxy#someFn` simply forwards the `someFn` call to `Implementation`.
    See the following illustration:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`RedactionProxy`执行我们所说的`someFn()`调用。换句话说，`RedactionProxy#someFn`只是将`someFn`调用转发到`Implementation`。以下是一个说明：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When it comes to `sensitiveFn`, `RedactionProxy` implements the same interface
    as `Implementation` except it overrides the output, replacing `sensitive` with
    `[REDACTED]`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到`sensitiveFn`时，`RedactionProxy`实现了与`Implementation`相同的接口，除了它覆盖了输出，将`sensitive`替换为`[REDACTED]`。
- en: 'This means the interface for `RedactionProxy` and `Implementation` is the same,
    but `RedactionProxy` can control which method calls and fields are available along
    with their implementation. See the following example of this behavior:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`RedactionProxy`和`Implementation`的接口是相同的，但`RedactionProxy`可以控制哪些方法调用和字段可用，以及它们的实现。以下是一个此行为的示例：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Use cases
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: The proxy pattern allows us to intercept calls to an object (the `implementation`
    or `subject`) and augment them, either by manipulating the output or by adding
    a side-effect.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式允许我们拦截对对象的调用（实现或主题），并通过操纵输出或添加副作用来增强它们。
- en: Our example of redaction is a good use case for it, but any other type of instrumentation
    is also a good use case. The instrumentation could be concerned with measuring
    something about a function/field access (e.g. the time it takes) or ensuring access
    to a property triggers a certain effect. For example, the **reactivity** system
    of Vue.js and Alpine.js is based on proxies, where a JavaScript Proxy object is
    used to wrap the reactive data objects. This allows the library (Vue or Alpine)
    to detect when properties are changed and run things such as watchers, effects,
    and re-renders.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对编辑的例子是一个很好的用例，但任何其他类型的工具也是很好的用例。工具可能涉及测量关于函数/字段访问的某些内容（例如，所需的时间）或确保对属性的访问触发某种效果。例如，Vue.js和Alpine.js的**响应性**系统基于代理，其中使用JavaScript代理对象来包装响应式数据对象。这允许库（Vue或Alpine）检测属性何时被更改，并运行诸如观察者、效果和重新渲染等操作。
- en: Improving the proxy pattern in JavaScript with the Proxy and Reflect global
    objects
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Proxy`和`Reflect`全局对象改进JavaScript中的代理模式
- en: Back to our example, what happens when we need to redact more functions?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，当我们需要编辑更多函数时会发生什么？
- en: 'Let’s take an `Implementation` class with three methods (`someFn`, `sensitiveFn`,
    and `otherSensitiveFn`):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个有三个方法（`someFn`、`sensitiveFn`和`otherSensitiveFn`）的`Implementation`类为例：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A naïve implementation of an extended proxy looks as follows, where each method
    calls the implementation’s method and then replaces `sensitive` in its output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展代理的一个简单实现如下，其中每个方法都调用实现的方法，然后在输出中替换`sensitive`：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This implementation of the `Proxy` works, as we can ensure with the following
    code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Proxy`的实现是有效的，我们可以通过以下代码确保：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One improvement we can make here is to extract a `#redact` private method to
    handle the replacement of `sensitive`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里进行的一个改进是提取一个`#redact`私有方法来处理`sensitive`的替换：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The downside of this approach is that every method on the `Implementation` object
    (the subject) will require a change to our Proxy implementation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，`Implementation`对象（主题）上的每个方法都需要更改我们的代理实现。
- en: Fortunately, JavaScript has a built-in class to programmatically manage these
    situations. The JavaScript class is aptly called `Proxy`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript有一个内置的类可以编程管理这些情况。这个JavaScript类恰当地被称为`Proxy`。
- en: 'Let’s take the following plain JavaScript object (this also works for class
    instances) with both fields and functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下普通的JavaScript对象（这也适用于类实例）为例，它既有字段又有函数：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We want to be able to completely redact (i.e., keep none of the original output)
    those fields that contain `sensitive` in the field or method name. We also want
    to have a value redaction functionality when the output contains the string `sensitive`,
    where we replace `sensitive` with `[REDACTED]`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够完全编辑（即保留原始输出的全部内容）那些在字段或方法名称中包含`sensitive`的字段。我们还希望在输出包含字符串`sensitive`时具有值编辑功能，其中将`sensitive`替换为`[REDACTED]`。
- en: To achieve this, we define a Proxy that will wrap our `obj` object. We instantiate
    the Proxy with a “get trap,” which allows us to intercept all property accesses
    (which includes function access).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们定义了一个将包装我们的`obj`对象的代理。我们使用一个“get trap”实例化代理，这允许我们拦截所有属性访问（包括函数访问）。
- en: The `get` function receives a `target` and `property`. The target is the object
    being wrapped (`obj`), `property` is the property being accessed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`函数接收一个`target`和一个`property`。`target`是被包装的对象（`obj`），`property`是被访问的属性。'
- en: Based on whether `target[property]` is a function or not, we’ll replace it with
    a wrapper function that will collect all the arguments, call `target[property]`
    with those arguments, intercept the output, and replace `sensitive` with `[REDACTED]`.
    We also return `[REDACTED]` if the property name includes `sensitive` (in our
    case, using `sensitiveFn`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`target[property]`是否是函数，我们将用收集所有参数的包装函数替换它，使用这些参数调用`target[property]`，拦截输出，并将`sensitive`替换为`[REDACTED]`。如果属性名包含`sensitive`（在我们的情况下，使用`sensitiveFn`），我们还将返回`[REDACTED]`。
- en: 'In cases where `target[property]` is not a function, we’ll do a full redaction
    if the property name includes `sensitive` and also replace `sensitive` in the
    output for all other properties:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`target[property]`不是一个函数的情况下，如果属性名包含`sensitive`，我们将进行完整的编辑，并且替换所有其他属性中的`sensitive`：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code ensures our Proxy implementation works as expected. `sensitive`
    is not present in any of the function output or in the `field` value:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码确保我们的代理实现按预期工作。`sensitive`不在任何函数输出或`field`值中：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One of the key benefits is the simplicity of the setup; all the redaction logic
    is contained in the `get` function, which keeps it localized.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个关键好处是设置的简单性；所有的编辑逻辑都包含在`get`函数中，这使得它更加集中。
- en: As an effect of the co-located logic, we’ve been able to add redaction by property
    name in addition to redacting values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逻辑集中，我们能够除了编辑值之外，还能通过属性名添加编辑。
- en: There are still some slight issues with our current Proxy-based approach since
    we’re losing the `this` context on functions. We call `target[property](...args)`,
    which is fine as long as our object is not accessing `this`. We’ll further refactor
    our implementation to make further extension easier, as well as leveraging the
    `Reflect` global built-in object to simplify our code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在函数中丢失了`this`上下文，我们当前的基于代理的方法还存在一些轻微的问题。我们调用`target[property](...args)`，只要我们的对象不访问`this`，这是可以的。我们将进一步重构我们的实现，以便更容易地进行扩展，同时利用`Reflect`全局内置对象来简化我们的代码。
- en: '`Reflect` provides functions with the same name as the `Proxy` trap with the
    same arguments; for example, `Reflect.get(target,` `property, receiver)`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect`提供了与`Proxy`陷阱具有相同名称和参数的函数；例如，`Reflect.get(target, property, receiver)`。'
- en: 'We’ll extract a `redact` function, which takes a `propertyName` and a `redactionValue`.
    It will keep our redaction logic even more in sync by abstracting it to a separate
    function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提取一个`redact`函数，它接受一个`propertyName`和一个`redactionValue`。它将通过将其抽象为单独的函数来使我们的编辑逻辑更加同步：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then use `redact` where necessary, use `Reflect.get()` as a shortcut
    to `target[property]`, and use `Reflect.apply` to maintain the `this` context:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在必要时使用`redact`，使用`Reflect.get()`作为`target[property]`的快捷方式，并使用`Reflect.apply`来保持`this`上下文：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our redaction still functions the same over values, function outputs, and property
    and function names:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编辑在值、函数输出、属性和函数名称上仍然按相同的方式工作：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we’ve delved into how to implement the proxy pattern, we’ll contrast
    it with the decorator pattern and which JavaScript tools we can use to implement
    it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入探讨了如何实现代理模式，我们将将其与装饰器模式进行对比，并讨论我们可以使用哪些JavaScript工具来实现它。
- en: Decorator in JavaScript
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的装饰器
- en: The decorator pattern is similar to the proxy pattern in that it’s about “wrapping”
    an object. However, the decorator pattern is about adding functionality to an
    object at runtime. Different decorators can be applied to an object to add different
    functionalities to it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式与代理模式类似，因为它涉及到“包装”一个对象。然而，装饰器模式是在运行时向对象添加功能。不同的装饰器可以应用于对象，以向其添加不同的功能。
- en: Implementation
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Given the following `HttpClient` class based on the `fetch` API, we want to
    instrument the requests made through this client. `HttpClient` implements `getJson`
    and returns JSON output if the `fetch` request succeeds:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下基于`fetch` API的`HttpClient`类，我们想要测量通过此客户端发出的请求。`HttpClient`实现了`getJson`，如果`fetch`请求成功则返回JSON输出：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`InstrumentedHttpClient`, which is a decorator, might look like the following,
    where we expose the same `getJson` method but have the added `requestTimings`
    field on the instance.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstrumentedHttpClient`，这是一个装饰器，可能看起来如下，其中我们暴露了相同的`getJson`方法，但在实例上增加了`requestTimings`字段。'
- en: 'When `getJson` is called, we track the start and end time of the `HttpClient#getJson`
    method call and add it to the instance’s `requestTimings`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`getJson`时，我们跟踪`HttpClient#getJson`方法调用的开始和结束时间，并将其添加到实例的`requestTimings`中：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can ensure that the `InstrumentedHttpClient` works as described with the
    following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码确保`InstrumentedHttpClient`按描述工作：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Use cases
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: The decorator pattern, much like the proxy pattern, can be used to instrument
    or intercept operations on a “subject”.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式，就像代理模式一样，可以用来测量或拦截“主题”上的操作。
- en: One key difference is that the decorator is about adding “new members” to the
    class, not just maintaining the interface one to one. That’s why it’s normal for
    us to save an additional `requestTimings` field and access it from the “decorated”
    class, `InstrumentedHttpClient`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的区别是，装饰器是关于向类添加“新成员”，而不仅仅是保持接口一对一。这就是为什么我们通常保存一个额外的`requestTimings`字段，并从“装饰”类`InstrumentedHttpClient`中访问它。
- en: This means that multiple decorators can “stack” on top of each other. For example,
    we can have our `InstrumentedHttpClient`, which has `requestTimings`, and then
    create another decorator class that does something useful with the timing information.
    An example here is sending a “client-time” heuristic header that allows the server
    to stop processing a request once a certain amount time of time has passed since
    it knows the client will have aborted the connection by then.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着多个装饰器可以“堆叠”在彼此之上。例如，我们可以拥有我们的`InstrumentedHttpClient`，它有`requestTimings`，然后创建另一个装饰器类，使用时对时间信息进行有用的处理。这里的一个例子是发送一个“client-time”启发式头，允许服务器在知道客户端将在某个时间点终止连接后停止处理请求。
- en: Improvements/limitations
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进/限制
- en: Due to JavaScript’s first-class support for functions, we can use functions
    as the basis for decoration instead of classes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript对函数的第一类支持，我们可以使用函数作为装饰的基础，而不是类。
- en: 'Our `getJson` function could look as follows, with similar logic to the `HttpClient.getJson`
    method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`getJson`函数可能如下所示，与`HttpClient.getJson`方法的逻辑相似：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can then create an `addTiming` method that stores the request times in an
    `allOperationTimings` `Map` instance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`addTiming`方法，该方法将请求时间存储在`allOperationTimings` `Map`实例中。
- en: 'We’re using both aspects of first-class functions here – we’re passing a function
    as a parameter (`getJson`) and returning a function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了第一类函数的两个方面——我们传递一个函数作为参数（`getJson`）并返回一个函数：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using our decorator function is done as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的装饰器函数的方式如下：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then invoke our instrumented function and check that it adds timings
    to our `allOperationTimings` `Map`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用我们的仪器化函数并检查它是否向我们的`allOperationTimings` `Map`添加了时间：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One thing you might’ve noticed is that our `addTiming` *is* still aware of the
    `getJson` interface (it knows to pass a URL parameter and that `getJson` returns
    a Promise object). We’ll leave it as an exercise for the reader to implement,
    but it would be possible to turn `addTiming` into a function that can instrument
    the operation time of *any* JavaScript function; the tricky part is to find a
    good key for our operations map.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到的一件事是，我们的`addTiming` *仍然*知道`getJson`接口（它知道传递URL参数，并且`getJson`返回一个Promise对象）。我们将把它留给读者作为练习来实现，但将`addTiming`转换成一个可以测量任何JavaScript函数操作时间的函数是可能的；困难的部分是找到我们操作映射的一个好键。
- en: In the next part of the chapter, we’ll look at the flyweight pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，我们将探讨享元模式。
- en: Flyweight in JavaScript
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的享元模式
- en: The flyweight pattern is where the subset of object properties that have the
    same value are stored in shared “flyweight” objects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 模式是指具有相同值的对象属性子集存储在共享的“轻量级”对象中。
- en: The flyweight pattern is useful when generating large quantities of objects
    that share a subset of the same values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成大量具有相同值子集的对象时，Flyweight 模式很有用。
- en: Implementation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: One concept from domain-driven design by Eric Evans is “value objects”. These
    value objects have the property that their contents matter more than their identity.
    Let’s take the example of a value object being a “coin” where, for the purposes
    of payment, two 50-cent coins are interchangeable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Eric Evans 的领域驱动设计中的一个概念是“值对象”。这些值对象具有其内容比其身份更重要的属性。让我们以一个“硬币”作为值对象的例子，其中，在支付的目的上，两枚
    50 分硬币是可互换的。
- en: Value objects are interchangeable and immutable (a 50-cent coin can’t become
    a 10-cent coin). These types of objects are therefore a great fit for the Flyweight
    pattern.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象是可互换的且不可变的（50 分硬币不能变成 10 分硬币）。因此，这些类型的对象非常适合 Flyweight 模式。
- en: Not all properties of a “coin” are “value”-driven, for example, certain coins
    are made from certain materials and coins tend to be issued in a certain year.
    These two properties (material and year of issue) might be interesting to collectors
    and in this respect, real-world coins are not only value objects as two 1993 coins
    might be interesting in different ways in the context of a coin collection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有“硬币”的特性都是由“价值”驱动的，例如，某些硬币是由某些材料制成的，并且硬币往往在特定年份发行。这两个特性（材料发行年份）可能对收藏家来说很有趣，从这个角度来看，现实中的硬币不仅作为价值对象，两枚
    1993 年的硬币在硬币收藏的背景下可能以不同的方式有趣。
- en: We therefore model our `Wallet` as containing a list of coins and our `Coin`
    as containing an amount (in cents or other “minor currency”), a currency, a year
    of issue, and a list of materials.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将我们的 `Wallet` 模型化为包含一个硬币列表，将 `Coin` 模型化为包含金额（以分或其他“小额货币”计）、货币、发行年份和材料列表。
- en: '![Figure 2.1: Class diagram where a Wallet has associated coins and methods
    to operate over them](img/B19109_02_1.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：包含关联硬币及其操作方法的类图](img/B19109_02_1.jpg)'
- en: 'Figure 2.1: Class diagram where a Wallet has associated coins and methods to
    operate over them'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：包含关联硬币及其操作方法的类图
- en: 'Our `CoinFlyweight` will be our “value object” and contain the `amount` and
    `currency`, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `CoinFlyweight` 将是我们的“值对象”，包含 `amount` 和 `currency`，如下所示：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The key benefit of the flyweight pattern is that we can reuse our flyweight
    objects. In order to do so, we need to control the instantiation of the flyweights
    with a factory (as covered in [*Chapter 1*](B19109_01.xhtml#_idTextAnchor018)*,
    Working with Creational Design Patterns*, The factory pattern in JavaScript section).
    We therefore define `CoinFlyweightFactory` with a static `get` method that takes
    the flyweight’s initialization parameters but only instantiates a new `CoinFlyweight`
    if one with the right amount and currency is not already present in memory. It
    also provides a `getCount` method to return the amount of flyweights currently
    instantiated:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 模式的关键优势在于我们可以重用我们的轻量级对象。为了做到这一点，我们需要通过工厂（如[*第 1 章*](B19109_01.xhtml#_idTextAnchor018)*，使用创建型设计模式，JavaScript
    中的工厂模式）来控制轻量级的实例化。因此，我们定义了 `CoinFlyweightFactory`，它具有一个静态的 `get` 方法，该方法接受轻量级的初始化参数，但只有当内存中不存在具有正确金额和货币的
    `CoinFlyweight` 时，才会实例化一个新的 `CoinFlyweight`。它还提供了一个 `getCount` 方法来返回当前实例化的轻量级的数量：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another opportunity to use the Flyweight pattern is with materials. We can
    similarly create a `MaterialFlyweight` and reuse its values via a `MaterialFlyweightFactory`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flyweight 模式的另一个机会是与材料。我们可以类似地创建一个 `MaterialFlyweight` 并通过 `MaterialFlyweightFactory`
    重复使用其值：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can implement the `Coin` and `Wallet` classes. Our `Coin` instance
    has a `flyweight` field, which is populated using the `CoinFlyweightFactory`.
    The `Coin#materials` field is populated with a regular array but the array’s contents
    are of `MaterialFlyweight`, loaded using the `MaterialFlyweightFactory`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现 `Coin` 和 `Wallet` 类。我们的 `Coin` 实例有一个 `flyweight` 字段，该字段使用 `CoinFlyweightFactory`
    进行填充。`Coin#materials` 字段使用常规数组进行填充，但数组的元素是 `MaterialFlyweight`，使用 `MaterialFlyweightFactory`
    加载：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Wallet` is a plain JavaScript object. Its `add` method creates a new `Coin`
    instance and pushes it into the Wallet’s `coins` field. `getTotalValueForCurrency`
    sums the coin’s values for a given currency:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wallet` 是一个普通的 JavaScript 对象。它的 `add` 方法创建一个新的 `Coin` 实例并将其推入 Wallet 的 `coins`
    字段。`getTotalValueForCurrency` 对给定货币的硬币价值进行求和：'
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The wallet can be used as follows, adding GBP and USD of different denominations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包可以使用以下方式使用，添加不同面额的 GBP 和 USD：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that while the wallet instance contains eight coins, we’ve created six
    `CoinFlyweight` and five `MaterialFlyweight` instances:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管钱包实例包含八个硬币，但我们创建了六个 `CoinFlyweight` 和五个 `MaterialFlyweight` 实例：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use cases
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: The flyweight pattern is a normalization technique that reduces the memory footprint
    at the cost of cognitive overhead when accessing and running computations over
    objects using this pattern. Flyweight can be leveraged as a performance optimization
    when handling large numbers of objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Flyweight 模式是一种规范化技术，它以在访问和运行使用此模式的对象的计算时的认知开销为代价，减少了内存占用。当处理大量对象时，Flyweight
    可以作为性能优化的手段。
- en: It’s *very* well suited to modeling value objects as we’ve shown in the previous
    section. The only drawback was the `getTotalValueForCurrency`, where we had to
    read `coin.flyweight.currency` and `coin.flyweight.amount`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常适合作为我们之前章节中展示的价值对象进行建模。唯一的缺点是 `getTotalValueForCurrency`，在那里我们必须读取 `coin.flyweight.currency`
    和 `coin.flyweight.amount`。
- en: Improvements/limitations
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进/限制
- en: 'There are a few improvements we can make to our flyweight wallet/coin setup.
    A few of the improvements center on the “factories”. The `flyweights` shouldn’t
    really be accessed from outside of the `get` function, so we can make it a private
    field using `#flyweights`. We can also leverage the `Map` object, still with the
    same cache key, although `Map` has greater flexibility in terms of what keys can
    be used and a different property access interface (`.get(key)` instead of `[key]`
    access). Using a `Map` means we need to use `this.#flyweights.size` in `getCount`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对我们的 flyweight 钱包/硬币设置进行一些改进。其中一些改进集中在“工厂”上。`flyweights` 不应该从 `get` 函数外部访问，因此我们可以使用
    `#flyweights` 使其成为私有字段。我们还可以利用 `Map` 对象，仍然使用相同的缓存键，尽管 `Map` 在可用的键方面具有更大的灵活性，并且具有不同的属性访问接口（`.get(key)`
    而不是 `[key]` 访问）。使用 `Map` 意味着我们需要在 `getCount` 中使用 `this.#flyweights.size`：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Another change we’ll make is in light of the fact that there were not any material
    gains by making `materials` a flyweight, so we’ll revert it to storing the list
    of strings per `Coin` instance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将做出另一个改变，鉴于将 `materials` 作为 flyweight 并没有带来任何实质性的收益，因此我们将将其恢复为每个 `Coin` 实例存储字符串列表。
- en: Again, we want to make `#flyweight` private, this will change the interface
    of `Coin` since consumers will not be able to access `coin.#flyweight` (it’s a
    private field).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们希望将 `#flyweight` 设置为私有，这将改变 `Coin` 的接口，因为消费者将无法访问 `coin.#flyweight`（它是一个私有字段）。
- en: 'What we’ll do is tackle the mismatch of having to read `coin.flyweight.amount`
    and `coin.flyweight.currency`. We’ll supply two getters, `get amount()` and `get
    currency()`, which will return `this.#flyweight.amount` and `this.#flyweight.currency`
    respectively:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决必须读取 `coin.flyweight.amount` 和 `coin.flyweight.currency` 的不匹配问题。我们将提供两个获取器，`get
    amount()` 和 `get currency()`，分别返回 `this.#flyweight.amount` 和 `this.#flyweight.currency`：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As mentioned, the interface of `Coin` doesn’t have a `flyweight` property so
    `getTotalValueForCurrency` will read from `Coin#currency` and `Coin#amount`. As
    far as `Wallet` is concerned, `currency` and `amount` are fields on the `Coin`
    instance, although they’re getters:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Coin` 的接口没有 `flyweight` 属性，因此 `getTotalValueForCurrency` 将会从 `Coin#currency`
    和 `Coin#amount` 中读取。至于 `Wallet`，`currency` 和 `amount` 是 `Coin` 实例的字段，尽管它们是获取器：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can check that our new `Wallet` and `Coin` implementations work as expected
    by using the same tests as in our earlier iteration of the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用与代码早期迭代中相同的测试来检查我们的新 `Wallet` 和 `Coin` 实现是否按预期工作：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We’ve seen how the flyweight pattern can be used to optimize memory usage by
    using shared value objects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 flyweight 模式通过使用共享值对象来优化内存使用。
- en: In the next part of the chapter, we’ll look at the last structural design pattern
    covered in this book, the adapter pattern in JavaScript.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，我们将探讨本书中涵盖的最后一个结构化设计模式，即 JavaScript 中的适配器模式。
- en: Adapter in JavaScript
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 中的适配器
- en: The adapter pattern, similar to the other structural design patterns, focuses
    on interfaces.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他结构化设计模式类似，适配器模式关注于接口。
- en: In the adapter pattern’s case, it involves being able to use a new implementation
    without changing the consumer or the implementation’s interface. The “adapter”
    takes the new implementation and “adapts” the interface to match what the consumer
    expects.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在适配器模式的情况下，它涉及到能够在不更改消费者或实现接口的情况下使用新的实现。适配器“适配”接口以匹配消费者的期望。
- en: We’re not changing the implementation *or* the consumer; rather, we’re building
    an adapter to wrap the implementation and plug it into the consumer without changing
    either.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有改变实现或消费者；相反，我们构建了一个适配器来包装实现并将其插入消费者，而不改变任何一方。
- en: Implementation
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: Let’s start with a simple in-memory database that uses a naive `IdGenerator`
    to generate keys for the database entries by encoding the object as a string.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用简单的内存数据库开始，该数据库使用一个简单的 `IdGenerator` 通过将对象编码为字符串来生成数据库条目的键：
- en: '`Database` has a `createEntry` method that stores given data using the `IdGenerator`
    to generate a key. `Database` also has a `get` method to recall entries by ID:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database` 有一个 `createEntry` 方法，它使用 `IdGenerator` 生成键来存储给定数据。`Database` 还有一个
    `get` 方法，可以通过 ID 回忆条目：'
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By composing `Database` with an `IdGenerator` instance, we get a key-value
    lookup database instance with the key equal to the JSON representation of the
    value:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `Database` 与 `IdGenerator` 实例组合，我们得到一个键值查找数据库实例，其键等于值的 JSON 表示形式：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, the naive ID generation that encodes the whole entry value in the key
    is not ideal. An alternative is to use a UUID. Here’s a `UuidFactory` using the
    `uuid` npm module. The key operation it exposes is `generateUuid`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将整个条目值编码在键中的简单 ID 生成方法并不理想。一个替代方案是使用 UUID。以下是一个使用 `uuid` npm 模块的 `UuidFactory`。它公开的关键操作是
    `generateUuid`：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To use the `UuidFactory` with our `Database`, we would need a `get` method
    instead of a `generateUuid` method. This is where our adapter comes in – we can
    wrap the `UuidFactory` in a class that exposes `get(entry)` but calls `generateUuid`
    on the `UuidFactor` instance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `UuidFactory` 与我们的 `Database`，我们需要一个 `get` 方法而不是 `generateUuid` 方法。这就是我们的适配器发挥作用的地方——我们可以将
    `UuidFactory` 包装在一个类中，该类公开 `get(entry)` 但在 `UuidFactor` 实例上调用 `generateUuid`：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `UuidIdGeneratorAdapter` can then be passed as the `idGenerator` to `Database`.
    It all works as expected, where the entry IDs for the database are UUIDs:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`UuidIdGeneratorAdapter` 可以作为 `idGenerator` 传递给 `Database`。一切如预期般工作，其中数据库的条目
    ID 是 UUID：'
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Another example that makes use of the fact that the `entry` is being passed
    to `idGenerator.get()` is to generate prefixed auto-incrementing IDs based on
    the `entry` contents. Here, `name` will be used as the prefix. We have a `Counter`
    class that implements `getAndIncrement(prefix)`, which generates incrementing
    IDs given a prefix (or no prefix):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个利用 `entry` 被传递给 `idGenerator.get()` 的事实来生成基于 `entry` 内容的前缀自增 ID 的例子。在这里，`name`
    将用作前缀。我们有一个 `Counter` 类，它实现了 `getAndIncrement(prefix)`，它根据前缀（或没有前缀）生成递增 ID：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again, `getAndIncrement(prefix)` doesn’t match the `IdGenerator` interface
    (no `get` method). We can wrap `Counter` in a `PrefixedAutoIncrementIdGeneratorAdapter`
    to expose an `IdGenerator` interface but using the `Counter` implementation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`getAndIncrement(prefix)` 不符合 `IdGenerator` 接口（没有 `get` 方法）。我们可以将 `Counter`
    包装在 `PrefixedAutoIncrementIdGeneratorAdapter` 中，以暴露 `IdGenerator` 接口，但使用 `Counter`
    的实现：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can ensure the prefixing logic works as expected for the `Database` since
    it creates entries keyed by prefixed auto-incrementing IDs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保前缀逻辑对 `Database` 的工作是正确的，因为它创建的条目键是带有前缀的自增 ID：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can check that the case where no `name` field is set works as expected:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查没有设置 `name` 字段的情况是否按预期工作：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And the scenarios where a prefix is available also functions correctly per
    the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 并且带有前缀的场景也按照以下示例正确地工作：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Use cases
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: The adapter pattern is useful when you need to use two classes that weren’t
    specifically designed to work together. Consider, for example, a third-party library
    or module that exposes a function (such as the `uuid` module or even `UuidFactory`
    from our scenario). We want to abstract the implementation behind an interface,
    in our case the interface of `IdGenerator`, which is just a `get` method, so that
    any implementation can be used.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用两个没有特别设计来一起工作的类时，适配器模式非常有用。例如，考虑一个第三方库或模块，它公开了一个函数（例如 `uuid` 模块或甚至是我们场景中的
    `UuidFactory`）。我们希望将实现抽象化，在我们的例子中是 `IdGenerator` 接口，它只是一个 `get` 方法，这样任何实现都可以使用。
- en: Our example showcased the value of the adapter pattern. We were able to create
    very differently behaving databases without changing `UuidFactory`, `Counter`,
    or `Database` for that matter. This is very important when having to connect two
    third-party modules or modules which are self-contained and shouldn’t be changed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子展示了适配器模式的价值。我们能够创建行为非常不同的数据库，而无需更改 `UuidFactory`、`Counter` 或 `Database`。这在需要连接两个第三方模块或自包含且不应更改的模块时非常重要。
- en: Using the adapter pattern therefore means that we can avoid changing difficult-to-understand
    code while delivering the required functionality.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用适配器模式意味着我们可以避免更改难以理解的代码，同时提供所需的功能。
- en: Improvements/limitations
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进/限制
- en: Similarly, to the *Decorator in JavaScript - Improvements/limitations* section,
    one of the JavaScript features that can help when implementing structural design
    patterns is the first-class support for functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于*JavaScript中的装饰器 - 改进/限制*部分，JavaScript中的一项特性可以帮助实现结构化设计模式，那就是对函数的一级支持。
- en: 'Instead of an `IdGenerator` class, we can have a `defaultIdGenerator` function
    that takes an entry and returns a string:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是`IdGenerator`类，我们可以有一个`defaultIdGenerator`函数，它接受一个条目并返回一个字符串：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Database` class would now look something as follows, where `this.idGenerator(entryData)`
    is called directly:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database`类现在看起来可能如下所示，其中`this.idGenerator(entryData)`被直接调用：'
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can validate that the naive implementation still works by serializing whatever
    is passed to it as JSON:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其传递的内容序列化为JSON来验证原始实现仍然有效：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This approach shines when we need to plug in the UUID and prefix generators.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要插入UUID和前缀生成器时，这种方法特别有效。
- en: 'A `uuidGenerator` function can call `uuidv4()`. We can validate that `uuidIdDatabase`
    uses UUIDs to key and recall the entries:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuidGenerator`函数可以调用`uuidv4()`。我们可以验证`uuidIdDatabase`使用UUID作为键来检索条目：'
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, a `prefixAutoIncrementIdGenerator` would look as follows. We’re using
    module-scoped variables, which is another feature of JavaScript:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个`prefixAutoIncrementIdGenerator`可能如下所示。我们正在使用模块作用域变量，这是JavaScript的另一个特性：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This code would be in a different module than its consumer, so it would be `export
    function prefixAutoIncrementIdGenerator` and its consumer would import `{prefixAutoIncrementIdGenerator}`
    from `'./path-to-module.js'`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将位于与其消费者不同的模块中，因此它将是`export function prefixAutoIncrementIdGenerator`，其消费者将导入`{prefixAutoIncrementIdGenerator}`从`'./path-to-module.js'`。
- en: '`prefixAutoIncrementIdGenerator` functions like the `PrefixedAutoIncrementIdGeneratorAdapter`
    class did, generating auto-incrementing IDs and prefixing them where possible
    by `entry.name`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefixAutoIncrementIdGenerator`函数与`PrefixedAutoIncrementIdGeneratorAdapter`类的作用类似，生成自增ID，并在可能的情况下通过`entry.name`进行前缀：'
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this final section of the chapter, we covered the adapter pattern and how
    to use it when the consumer expects a class but also a function in JavaScript.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们讨论了适配器模式以及如何在JavaScript中，当消费者期望一个类和一个函数时使用它。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve looked at how structural design patterns enable the extension
    of functionality without needing to rework interfaces in JavaScript.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了结构化设计模式如何使JavaScript中功能的扩展成为可能，而无需重新工作接口。
- en: The proxy design pattern is useful when we want to intercept calls to an object
    without changing the interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式在想要拦截对象调用而不改变接口时非常有用。
- en: By contrast, the decorator design pattern concerns itself with dynamically adding
    functionality through new instance members.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，装饰器设计模式关注的是通过新的实例成员动态添加功能。
- en: The flyweight pattern can be used effectively for managing large numbers of
    objects, which is especially useful for value objects. There are workarounds in
    JavaScript for some of the ergonomic drawbacks of it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级模式可以有效地用于管理大量对象，这对于值对象尤其有用。JavaScript中存在一些解决方案来解决其一些用户体验上的缺点。
- en: The adapter pattern allows us to integrate multiple classes, modules, or functions
    with different opinions and interfaces without modifying them. The shape of the
    adapter is dictated by the existing modules and classes that we’re attempting
    to connect together.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式允许我们集成具有不同意见和接口的多个类、模块或函数，而无需修改它们。适配器的形状由我们试图连接的现有模块和类决定。
- en: Now that we know how to organize relationships between different objects and
    classes with structural design patterns, in the next chapter, we’ll cover how
    to use behavioral design patterns to organize communication between objects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用结构化设计模式来组织不同对象和类之间的关系，在下一章中，我们将介绍如何使用行为设计模式来组织对象之间的通信。
