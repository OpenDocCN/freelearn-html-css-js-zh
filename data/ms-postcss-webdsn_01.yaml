- en: Chapter 1. Introducing PostCSS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 介绍 PostCSS
- en: A key part of any website is styling—it doesn't matter if this is for a simple
    element tag or a complex animation; a website is not a website without color and
    action. Building styles for any online presence takes time and effort—we can reduce
    development time by using a preprocessor to automate the creation of styles, automatically
    apply vendor prefixes and the like, but the extra dependency of a library can
    be like using a sledgehammer to crack a nut!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的关键部分是样式——无论是简单的元素标签还是复杂的动画，网站没有颜色和动作就不是网站。为任何在线存在构建样式需要时间和精力——我们可以通过使用预处理器来自动创建样式，自动应用供应商前缀等来减少开发时间，但额外的库依赖可能就像用大锤砸核桃一样！
- en: 'Enter PostCSS—its unique modular style allows us to create a leaner, faster
    CSS processor, with no external dependencies. In this chapter, we look at installing
    PostCSS, understanding its architecture, and learn how to use its speed and power
    to compile code into valid CSS. We will cover a number of topics throughout this
    chapter, which will include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 PostCSS——它独特的模块化风格允许我们创建一个更精简、更快的 CSS 处理器，没有外部依赖。在本章中，我们将探讨安装 PostCSS、了解其架构，并学习如何利用其速度和力量将代码编译成有效的
    CSS。在本章中，我们将涵盖多个主题，包括以下内容：
- en: Considering the benefits of creating our own preprocessor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑创建我们自己的预处理器的好处
- en: Introducing PostCSS and exploring its features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 PostCSS 并探索其功能
- en: Setting up a development environment using PostCSS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PostCSS 设置开发环境
- en: Creating a simple example using PostCSS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PostCSS 创建一个简单的示例
- en: Exploring how PostCSS works and its architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 PostCSS 的工作原理及其架构
- en: Let's make a start…!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧…！
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of the exercises in this book are written for the Windows platform; please
    adjust accordingly if you use a different operating system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有练习都是为Windows平台编写的；如果您使用的是其他操作系统，请相应地进行调整。
- en: Discovering the art of processing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现处理艺术的技巧
- en: 'A question: what do SASS, Stylus, Haml, and Less all have in common?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题：SASS、Stylus、Haml 和 Less 都有什么共同之处？
- en: The answer is, they are all compilers, source to source compiling, or **transpilers**
    (to give them their official name), that have been around since the 1980s. They
    have appeared in many different formats, with Digital Research's XLT86 being one
    of the earliest versions, dating from 1981.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，它们都是编译器，源到源编译，或者称为**转换器**（以它们的官方名称），自20世纪80年代以来一直存在。它们以许多不同的格式出现，Digital
    Research的XLT86是其中最早的版本之一，始于1981年。
- en: 'More recently, the well-known SASS processor arrived in 2006; this was followed
    by Less, created by Alexis Sellier in 2009\. Both work in a similar fashion: they
    take a set of rules and compile it into valid CSS. We can extend CSS with all
    manner of features, such as variables, mixins, functions, and more. Although processors
    may not help cut down the physical number of lines we have to write, they help
    us reorganize code into more manageable blocks that we can reuse in future projects,
    which helps make CSS easier to maintain.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，知名的 SASS 处理器于 2006 年出现；随后是 2009 年由 Alexis Sellier 创建的 Less。它们以类似的方式工作：它们接受一组规则并将其编译成有效的
    CSS。我们可以通过所有种类的功能扩展 CSS，如变量、混入、函数等。尽管处理器可能无法减少我们必须编写的物理行数，但它们帮助我们重新组织代码成更易于管理的块，我们可以在未来的项目中重用，这有助于使
    CSS 更易于维护。
- en: 'But, as is nearly always the case, there are some drawbacks to using processors:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，几乎总是如此，使用处理器的缺点也是有的：
- en: There is nearly always a dependency involved, in some form or other—with SASS,
    it's Ruby; if you're using Less, it's a library, even though it is written in
    JavaScript
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎总是涉及到某种形式的依赖——对于SASS来说，是Ruby；如果您使用Less，则是一个库，尽管它是用JavaScript编写的
- en: Our project may only use a small amount of preprocessed code, yet we are forced
    to rely on what can be a large library, such as SASS
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的项目可能只使用一小部分预处理的代码，但我们被迫依赖于可能是一个大型库，如SASS
- en: Processing style sheets using a preprocessor is slow; it may only be a few seconds,
    but this builds up over time to become a significant amount of time spent waiting
    for processes to complete
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预处理器处理样式表很慢；可能只有几秒钟，但随着时间的推移，这会积累成大量的等待过程完成的时间
- en: Hmm, this doesn't make processing so attractive! But what if there were a way
    to alleviate all of these issues, and remove the need for dependencies at the
    same time?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并没有让处理变得那么吸引人！但如果有一种方法可以缓解所有这些问题，同时去除对依赖的需求呢？
- en: 'Well, there is: let''s build our own processor! Okay, this might sound a little
    crazy, but as someone once said, there is method in this madness, so bear with
    me while I explain why this may be a better option.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，原因如下：让我们自己构建一个处理器！好吧，这听起来可能有点疯狂，但正如有人曾经说过，疯狂之中自有方法，所以请耐心听我解释为什么这可能是一个更好的选择。
- en: Introducing PostCSS
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 PostCSS
- en: 'At the beginning of this chapter, I mentioned that we would focus on creating
    our own preprocessor, right? Well, I have a little confession to make: we''re
    not. Hold on, what gives?'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我提到我们会专注于创建自己的预处理器，对吧？好吧，我有一个小小的坦白要讲：我们并没有这么做。等等，这是怎么回事？
- en: Well, we will create a preprocessor…but we will also create a postprocessor
    too. Let me explain why—our alternative "option" allows us to create both at the
    same time. Our alternative option is PostCSS, which can be downloaded from [https://github.com/postcss/postcss](https://github.com/postcss/postcss).
    PostCSS is used by some major companies, such as Twitter, Google, Bootstrap and
    CodePen, and even WordPress (in a limited capacity).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们将创建一个预处理器……但我们也会创建一个后处理器。让我解释一下原因——我们的替代“选项”允许我们同时创建这两个处理器。我们的替代选项是 PostCSS，可以从
    [https://github.com/postcss/postcss](https://github.com/postcss/postcss) 下载。PostCSS
    被一些主要公司使用，例如 Twitter、Google、Bootstrap 和 CodePen，甚至 WordPress（在有限的范围内）。
- en: PostCSS was built as a Node.js module, so will work with any number of the existing
    plugins already available for Node.js—we will be using a number of these plugins
    throughout the book. Let's take a moment to explore some of the benefits of this
    tool.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS 是作为一个 Node.js 模块构建的，因此将与 Node.js 已经提供的任何数量的现有插件一起工作——我们将在整本书中使用这些插件中的许多。让我们花点时间来探索这个工具的一些好处。
- en: Exploring the benefits of using PostCSS
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索使用 PostCSS 的好处
- en: 'What do we mean by PostCSS? In a nutshell, it can be used to refer to one of
    two things—the PostCSS core tool or the plugin ecosystem that is powered by the
    tool. On its own, it doesn''t actually do a lot; once we start adding plugins,
    we can achieve a great deal. Let''s explore what this means in practice:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的 PostCSS 是什么意思？简单来说，它可以指代两件事之一——PostCSS 核心工具或由该工具驱动的插件生态系统。单独来看，它实际上并没有做什么；一旦我们开始添加插件，我们就能实现很多功能。让我们来看看在实践中这意味着什么：
- en: Its modular architecture means we can pick and choose what we use; this allows
    us to keep the size of the library very small and responsive.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的模块化架构意味着我们可以挑选和选择我们需要的；这允许我们保持库的大小非常小且响应迅速。
- en: Existing processors tend to fall into one of two camps—pre- or post-processing—which
    is a limiting factor when choosing which to use. PostCSS allows us to perform
    both operations within the same process, meaning we get the benefits of both worlds
    of processing!
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的处理器往往分为两个阵营——预处理或后处理——这在使用选择时是一个限制因素。PostCSS 允许我们在同一个过程中执行这两个操作，这意味着我们得到了两个处理世界的好处！
- en: PostCSS comes with seamless support for all of the common task runners such
    as Gulp, Grunt, or Broccoli; we can combine it with a number of other tasks that
    can be automated.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostCSS 集成了对 Gulp、Grunt 或 Broccoli 等常见任务运行器的无缝支持；我们可以将其与许多其他可自动化的任务结合起来。
- en: There are no dependencies for compiling, PostCSS is written entirely in JavaScript,
    so no need for Ruby, or libraries such as `libsass`, in order to compile code.
    The only dependency (as such) is Node.js—many developers will likely already have
    this installed.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时没有依赖项；PostCSS 完全用 JavaScript 编写，因此不需要 Ruby 或 `libsass` 等库来编译代码。唯一的依赖项（如果可以这样称呼的话）是
    Node.js——许多开发者可能已经安装了它。
- en: There is no need to learn any new languages; every developer will be familiar
    with JavaScript, and use it in their development process.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要学习任何新的语言；每个开发者都会熟悉 JavaScript，并在他们的开发过程中使用它。
- en: We can change any plugin in use for something else when needed; we do not get
    this choice when using a larger library.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要时，我们可以更改正在使用的任何插件以用于其他目的；在使用较大的库时，我们没有这种选择。
- en: Its relatively low barrier of entry means we can create any plugins we need
    very easily, or potentially modify existing ones to better suit our needs.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它相对较低的学习门槛意味着我们可以非常容易地创建所需的任何插件，或者可能修改现有的插件以更好地满足我们的需求。
- en: PostCSS is quick—in a test using the `postcss-benchmark` plugin (available from
    [https://github.com/postcss/benchmark](https://github.com/postcss/benchmark)),
    which contained parsed code, nested rules, mixins, variables, and math, PostCSS
    came out a clear winner:![Exploring the benefits of using PostCSS](img/BO5194_01_01.jpg)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostCSS 很快——在一个使用 `postcss-benchmark` 插件（可在 [https://github.com/postcss/benchmark](https://github.com/postcss/benchmark)
    获取）的测试中，该插件包含了解析后的代码、嵌套规则、混入、变量和数学，PostCSS 以明显的优势胜出：![探索使用 PostCSS 的好处](img/BO5194_01_01.jpg)
- en: Perfect—no need to continually update SASS, or have to download a new version
    of the `libsass` library, right?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完美——无需不断更新 SASS，或下载 `libsass` 库的新版本，对吧？
- en: Considering some of the pitfalls
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑一些潜在的问题
- en: 'Well, there are some considerations to using a custom processor; the key thing
    to remember is that PostCSS is neither a pre- nor post-processor, but more of
    a Swiss Army Knife of a toolbox that we can use to process our CSS code. Let''s
    take a look at some of these drawbacks:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，使用自定义处理器有一些考虑因素；关键是要记住，PostCSS 既不是预处理器也不是后处理器，而更像是一个瑞士军刀式的工具箱，我们可以用它来处理我们的
    CSS 代码。让我们来看看这些缺点：
- en: Although we don't need to learn a new language in order to use PostCSS, creating
    a custom processor will add a layer of complexity to our development process.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们不需要学习新语言来使用 PostCSS，但创建自定义处理器将给我们的开发过程增加一层复杂性。
- en: Its flexible approach means some may treat PostCSS as either a preprocessor
    or a postprocessor; this short-sighted approach means that you will miss opportunities,
    so it is crucial to keep an open mind in terms of what PostCSS can offer your
    development process.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的灵活方法意味着有些人可能会将 PostCSS 视为预处理器或后处理器；这种短视的方法意味着你会错过机会，因此，在考虑 PostCSS 可以为你带来的开发过程方面，保持开放的心态至关重要。
- en: Converting code from an existing preprocessor to using PostCSS can be painful;
    this process only works if we don't try to convert explicitly, but use it as a
    basis for progressively moving to using PostCSS.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有预处理器中的代码转换为使用 PostCSS 可能很痛苦；这个过程只有在我们不尝试显式转换，而是将其作为逐步转向使用 PostCSS 的基础时才有效。
- en: PostCSS requires syntactically correct CSS from the start; although we could
    use any syntax (as PostCSS files are just plain text), compilation can easily
    fail, even through use of a single line comment!
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostCSS 从一开始就需要语法正确的 CSS；尽管我们可以使用任何语法（因为 PostCSS 文件只是纯文本），但编译很容易失败，即使是使用单行注释也可能如此！
- en: 'The real benefit of using PostCSS, though, is in its seamless integration into
    tools such as Gulp—imagine this scenario if you will:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，使用 PostCSS 的真正好处在于其与 Gulp 等工具的无缝集成——如果你愿意的话，想象一下这个场景：
- en: You already develop sites using a preprocessor such as SASS. You can compile
    code using a standalone processor, but normally prefer to use Node.js and Gulp
    to complete the task. Sound about right? What about making the move to using PostCSS?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用像 SASS 这样的预处理器开发网站。你可以使用独立的处理器来编译代码，但通常更喜欢使用 Node.js 和 Gulp 来完成任务。听起来合理吗？那么，转向使用
    PostCSS 呢？
- en: No problem, we can include a section for processing CSS files using PostCSS.
    The key here is to not use PostCSS to perform the initial compilation, but to
    perform the post-processing, such as adding vendor prefixes or minifying the results.
    Once this is established, we can start to incorporate some of the plugins available
    for PostCSS that allow us to replicate functionality, such as from within SASS.
    Once we've adjusted existing code to use the format required by the plugins, we
    can then switch to using PostCSS, and begin to remove our dependency on using
    SASS.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题，我们可以添加一个用于使用 PostCSS 处理 CSS 文件的章节。关键在于不要使用 PostCSS 来执行初始编译，而是执行后处理，例如添加供应商前缀或最小化结果。一旦确立了这一点，我们就可以开始整合一些可用的
    PostCSS 插件，这些插件允许我们复制功能，例如从 SASS 内部。一旦我们将现有代码调整为使用插件所需的格式，我们就可以切换到使用 PostCSS，并开始减少对
    SASS 的依赖。
- en: Clearing up some misconceptions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 澄清一些误解
- en: 'At this point, it is worth spending a few minutes to help clear up some common
    misconceptions about PostCSS, although many associate it as being a preprocessor,
    or even a postprocessor, this isn''t what was intended:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，花几分钟时间澄清一些关于 PostCSS 的常见误解是值得的，尽管许多人将其与预处理器或后处理器联系起来，但这并不是其初衷：
- en: Classing PostCSS as a postprocessor, as opposed to a preprocessor (such as Less
    or SASS) is misguided; PostCSS is capable of compiling in a variety of different
    use-case scenarios, working on code compiled using any preprocessor, or just plain
    CSS.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 PostCSS 归类为后处理器，而不是预处理器（如 Less 或 SASS）是错误的；PostCSS 能够在各种不同的使用场景中编译，可以处理使用任何预处理器编译的代码，或者直接处理纯
    CSS 代码。
- en: PostCSS should not be classed as a tool that should be tied in to any one process
    (such as writing SASS-based loops or conditionals). There are plugins available
    to do both, but this is just a small part of the role that PostCSS can play in
    your development workflow.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostCSS 不应该被归类为应该与任何特定过程（如编写基于 SASS 的循环或条件语句）绑定的工具。有插件可以完成这两项任务，但这只是 PostCSS
    在你的开发工作流程中可以扮演的角色的一小部分。
- en: If you find yourself in a position where "PostCSS" doesn't appear to perform
    as expected, it is unlikely to be PostCSS itself, but more likely to be a plugin
    being used that is causing the issue. Although PostCSS is still relatively young,
    there are plenty of plugins available, so it is worth trying alternatives if you
    can as a first port of call.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你发现自己处于“PostCSS”似乎没有按预期表现的情况，这不太可能是 PostCSS 本身的问题，而更有可能是使用的某个插件导致了问题。尽管 PostCSS
    仍然相对较新，但已经有大量的插件可供选择，所以如果你能尝试作为首选的替代方案，这是值得的。
- en: Okay, let's move on, I think it's time for less chat and more action, right?
    Let's get stuck in to producing something; there's no better time than now to
    get PostCSS installed and ready for use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续前进，我认为现在是时候减少聊天，多做一些实际的工作了，对吧？让我们开始做一些实际的事情；现在安装 PostCSS 并准备好使用是再合适不过的时候了。
- en: Preparing for exercises in this book
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为本书的练习做准备
- en: Before we do so, we just need to cover a couple of requirements. First, we need
    to set up a local web server. It's not critical, but gives a better effect. I
    personally use WAMP Server (for PC, from [http://www.wampserver.com/en](http://www.wampserver.com/en)),
    otherwise, Mac users can try MAMP ([http://www.mamp.info/en](http://www.mamp.info/en)),
    or the cross-platform Apache web server (from [http://www.apachefriends.org](http://www.apachefriends.org)).
    In each case, default settings should be sufficient.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们只需要覆盖几个要求。首先，我们需要设置一个本地 Web 服务器。这不是关键，但会带来更好的效果。我个人使用 WAMP Server（适用于
    PC，来自 [http://www.wampserver.com/en](http://www.wampserver.com/en)），否则，Mac 用户可以尝试
    MAMP ([http://www.mamp.info/en](http://www.mamp.info/en))，或者跨平台的 Apache Web 服务器（来自
    [http://www.apachefriends.org](http://www.apachefriends.org)）。在每种情况下，默认设置都应该足够。
- en: 'The second requirement is to set up a project area; assuming you have set up
    a WAMP as a local web server, go ahead and set up a folder called `postcss` in
    `c:\wamp\www`, as shown in this screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要求是设置一个项目区域；假设你已经设置了一个 WAMP 作为本地 Web 服务器，那么请继续在 `c:\wamp\www` 中创建一个名为 `postcss`
    的文件夹，如图所示：
- en: '![Preparing for exercises in this book](img/BO5194_01_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![为本书的练习做准备](img/BO5194_01_02.jpg)'
- en: Right, with that out of the way, let's make a start on getting PostCSS installed!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经解决了这个问题，让我们开始安装 PostCSS 吧！
- en: Setting up a development environment
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: The first step on our journey is to get PostCSS installed—this runs from Node.js;
    we can use any one of several task runner plugins to install it. For the purpose
    of the exercises throughout this book, we will use Gulp; if you prefer, alternatives
    such as Grunt or Broccoli can be used.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旅程的第一步是安装 PostCSS——这需要通过 Node.js 来运行；我们可以使用几个任务运行器插件中的任何一个来安装它。为了本书中的练习，我们将使用
    Gulp；如果你更喜欢，可以使用 Grunt 或 Broccoli 这样的替代品。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using Node.js, make sure you use the Node.js command prompt, and not `node.exe`;
    the exercises will not work when using the latter!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Node.js 时，确保你使用 Node.js 命令提示符，而不是 `node.exe`；使用后者时练习将无法工作！
- en: 'Let''s make a start with installing Node and Gulp:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装 Node 和 Gulp 开始：
- en: We first need to install Node.js; this is available at [http://nodejs.org](http://nodejs.org).
    Make sure you select the right version that is appropriate for your platform:![Setting
    up a development environment](img/BO5194_01_03.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要安装 Node.js；它可以在 [http://nodejs.org](http://nodejs.org) 获取。确保你选择适合你平台的正确版本：![设置开发环境](img/BO5194_01_03.jpg)
- en: When installing, accept all defaults; this will be sufficient for the exercises
    throughout this book.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在安装时，接受所有默认设置；这将为本书中的所有练习足够。
- en: 'Next, bring up a Node.js command prompt, enter the following command, and press
    *Enter*:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开一个 Node.js 命令提示符，输入以下命令，然后按 *Enter*：
- en: '[PRE0]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output shown is the version of Node that is installed; this is a quick
    check to ensure Node.js has indeed been installed correctly:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示的输出是已安装的 Node 版本；这是一个快速检查，以确保 Node.js 已经正确安装：
- en: '![Setting up a development environment](img/BO5194_01_04.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置开发环境](img/BO5194_01_04.jpg)'
- en: 'Now that Node is installed, we need to create a `package.json` file to store
    our dependencies for projects. Run this command at the command prompt, and press
    *Enter*:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Node 已安装，我们需要创建一个 `package.json` 文件来存储我们的项目依赖项。在命令提示符中运行此命令，并按 *Enter* 键：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Node will prompt for information when creating the `package.json` file; enter
    the details as shown in the screenshot, or press *Enter* to accept the given default
    (shown in brackets, after each question):![Setting up a development environment](img/BO5194_01_05.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当创建 `package.json` 文件时，Node 将会提示输入信息；请按照截图中的显示输入详细信息，或者按 *Enter* 键接受给定的默认值（括号内显示，每个问题之后）：![设置开发环境](img/BO5194_01_05.jpg)
- en: 'We now have Node configured and an empty `package.json` file in place, so let''s
    add our dependencies. We will start by adding Gulp first:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 Node 并放置了一个空的 `package.json` 文件，所以让我们添加我们的依赖项。我们将首先添加 Gulp：
- en: Revert back to the Node.js command prompt (or bring up a new one if you closed
    off the previous session).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 Node.js 命令提示符（或者如果关闭了上一个会话，则打开一个新的会话）。
- en: Go ahead and change the working directory to `c:\wamp\www\postcss`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请继续更改工作目录到 `c:\wamp\www\postcss`。
- en: 'At the command prompt, enter the following command, then press *Enter*. This
    installs Gulp globally and makes it available for use:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中输入以下命令，然后按 *Enter* 键。这将全局安装 Gulp 并使其可用于使用：
- en: '[PRE2]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once done, we need to install Gulp for use in our project area—go ahead and
    run this command, which will add an entry to the `package.json` file we created
    earlier in step *3* and step *4*:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们需要在我们的项目区域安装 Gulp 以供使用——运行此命令，这将添加到我们在步骤 *3* 和 *4* 中创建的 `package.json`
    文件中的一个条目：
- en: '[PRE3]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once completed, Gulp is now ready for use; we can go ahead and install PostCSS.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，Gulp 现在已准备好使用；我们可以继续安装 PostCSS。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A small point on the use of `--save-dev`: this installs any dependencies required
    to develop using a specific plugin; if we simply need the dependencies for *running*
    the plugin (in a production environment), then we can simply use `--save` instead.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 `--save-dev` 的小提示：这会安装开发特定插件所需的任何依赖项；如果我们只需要运行插件（在生产环境中）的依赖项，那么我们可以简单地使用
    `--save`。
- en: Installing PostCSS
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 PostCSS
- en: 'We''re at the interesting stage now—installing PostCSS. PostCSS is available
    from [https://github.com/postcss/postcss](https://github.com/postcss/postcss),
    and can be installed into Node using a Gulp plugin. Let''s do that now:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于一个有趣阶段——安装 PostCSS。PostCSS 可从 [https://github.com/postcss/postcss](https://github.com/postcss/postcss)
    获取，并且可以使用 Gulp 插件安装到 Node 中。现在让我们来做这件事：
- en: We'll start by reverting back to the Node.js command prompt session we've just
    used (or a new one, if the previous one is closed).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先回到我们刚刚使用的 Node.js 命令提示符会话（或者如果上一个会话已关闭，则创建一个新的会话）。
- en: 'At the prompt, go ahead and enter this command, then press *Enter*:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，请输入以下命令，然后按 *Enter* 键：
- en: '[PRE4]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If all is well, we should see something akin to this screenshot:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到类似于以下截图的内容：
- en: '![Installing PostCSS](img/BO5194_01_06.jpg)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![安装 PostCSS](img/BO5194_01_06.jpg)'
- en: 'On its own, PostCSS doesn''t do anything; to make it more useful, we are going
    to install three plugins. We will explore using plugins in greater detail later
    in the book, but for now, don''t worry too much about what is happening:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，PostCSS 什么也不做；为了使其更有用，我们将安装三个插件。我们将在本书的后面部分更详细地探讨插件的使用，但现在不必太担心正在发生的事情：
- en: 'Enter these commands one by one on the Node.js command prompt, pressing *Enter*
    after each one:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命令逐个在 Node.js 命令提示符中输入，每个命令输入后按 *Enter* 键：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's check our `package.json` file; if all is well, we should see something
    akin to this screenshot:![Installing PostCSS](img/BO5194_01_07.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查我们的 `package.json` 文件；如果一切顺利，我们应该看到类似于以下截图的内容：![安装 PostCSS](img/BO5194_01_07.jpg)
- en: Tip
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To make it easier to view JSON files in Sublime Text, try installing and activating
    a custom theme, such as MonokaiJSON Plus, available to install from [https://github.com/ColibriApps/MonokaiJsonPlus](https://github.com/ColibriApps/MonokaiJsonPlus).
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在 Sublime Text 中更容易查看 JSON 文件，尝试安装并激活一个自定义主题，例如 MonokaiJSON Plus，可以从 [https://github.com/ColibriApps/MonokaiJsonPlus](https://github.com/ColibriApps/MonokaiJsonPlus)
    安装。
- en: PostCSS is now installed for use, but if we try to use it, we probably won't
    get very far, as it needs to be configured for use! Let's take a look at doing
    that now, by creating a simple example that will add vendor prefixes to some sample
    CSS rules, and automatically minify the results.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS 现已安装并可使用，但如果我们尝试使用它，可能不会走得很远，因为它需要配置后才能使用！现在让我们通过创建一个简单的示例来查看如何进行配置，该示例将为一些示例
    CSS 规则添加供应商前缀，并自动压缩结果。
- en: Creating a simple example using PostCSS
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PostCSS 创建一个简单示例
- en: PostCSS is a fascinating tool; its modular architecture leaves it wide open
    to being used in a variety of different use-case scenarios, or even a mix of several!
    Throughout this book, we'll touch on different uses, before bringing them all
    together to create a processor that can both pre- and post-process files within
    the same workflow.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS 是一个令人着迷的工具；其模块化架构使其能够广泛应用于各种不同的使用场景，甚至可以混合使用几个！在这本书的整个过程中，我们将探讨不同的用法，最后将它们全部整合到一个可以在同一工作流程中预处理和后处理文件的处理器中。
- en: To give you a taste of how well it works, we're going to build a simple processor
    now; this will automatically add vendor prefixes and spit out minified versions
    during compilation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您体验其效果，我们现在将构建一个简单的处理器；这将在编译过程中自动添加供应商前缀并输出压缩版本。
- en: 'Let''s make a start, we''ve installed the relevant plugins, so let''s go create
    our Gulp task file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，我们已经安装了相关的插件，所以让我们创建我们的 Gulp 任务文件：
- en: In a new file, add the following code, saving it as `gulpfile.js` at the root
    of our project area:![Creating a simple example using PostCSS](img/BO5194_01_08.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码，将其保存为项目区域的根目录下的 `gulpfile.js`：![使用 PostCSS 创建一个简单示例](img/BO5194_01_08.jpg)
- en: In the project area, create a folder called `dest`; other folders will be created,
    but these will be done automatically during compilation.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目区域中，创建一个名为 `dest` 的文件夹；其他文件夹将会在编译过程中自动创建。
- en: 'In a new file, add the following code, saving it as `example.css` in the `src`
    folder of our project area:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中，添加以下代码，将其保存为项目区域 `src` 文件夹下的 `example.css`：
- en: '[PRE6]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Revert back to the Node.js command prompt, then at the command prompt, enter
    the following command and press *Enter*:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Node.js 命令提示符，然后在命令提示符中，输入以下命令并按 *Enter*：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Gulp will now process the instructions in `gulpfile.js`:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gulp 将现在处理 `gulpfile.js` 中的指令：
- en: '![Creating a simple example using PostCSS](img/BO5194_01_09.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 PostCSS 创建一个简单示例](img/BO5194_01_09.jpg)'
- en: Within a matter of seconds (almost instantaneously), we should see a compiled
    `example.css` appear in the `dest` folder of our project area.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟内（几乎是瞬间），我们应该在我们的项目区域的 `dest` 文件夹中看到编译好的 `example.css`。
- en: 'We can prove PostCSS has done its job properly; go ahead and open up `example.css`
    in a text editor: if all is well, we should see this:![Creating a simple example
    using PostCSS](img/BO5194_01_11.jpg)'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以证明 PostCSS 已经正确地完成了其工作；请打开文本编辑器中的 `example.css`：如果一切顺利，我们应该看到这个：![使用 PostCSS
    创建一个简单示例](img/BO5194_01_11.jpg)
- en: Perfect, we now have a working PostCSS installation; any time we need to add
    vendor prefixes, we can just fire up our compilation process, and away we go…
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，我们现在有一个工作的 PostCSS 安装；任何需要添加供应商前缀的时候，我们都可以启动我们的编译过程，然后就可以开始了…
- en: Adding source map support
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加源映射支持
- en: Or do we? Ah, there is much more to PostCSS than simply adding vendor prefixes!
    Remember how I mentioned that PostCSS is often (incorrectly) labelled as a pre-
    or post-processor?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者呢？啊，PostCSS 的功能远不止添加供应商前缀！记得我提到 PostCSS 经常（不正确地）被标记为预处理器或后处理器吗？
- en: Well, there is much more we can do; one of the key benefits of PostCSS is being
    selective about how we process our code. We're not forced to rely on dependencies
    (such as Ruby for SASS); we can instead produce something that is very light and
    quick. In our previous example, we created a task called `styles`; we'll change
    this to use the task name `default`, which will allow us to run multiple tasks
    from one command. This means we can simply call `gulp`, instead of needing to
    supply the task name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们还有很多可以做的；PostCSS 的一个关键好处是我们可以选择性地处理我们的代码。我们不必依赖于依赖项（如 Ruby 的 SASS）；我们可以生产出非常轻量且快速的东西。在我们的上一个示例中，我们创建了一个名为
    `styles` 的任务；我们将将其更改为使用任务名称 `default`，这将允许我们从单个命令中运行多个任务。这意味着我们可以简单地调用 `gulp`，而无需提供任务名称。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of our examples from this point onwards will use this convention by default.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们所有的示例都将默认使用此约定。
- en: 'Let''s put this to the test and start to expand on our compilation process
    by adding source map support—we''ll use the source map plugin for Gulp by Florian
    Reiterer, available from [https://github.com/floridoo/gulp-sourcemaps](https://github.com/floridoo/gulp-sourcemaps):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加源映射支持来测试这一点，并开始扩展我们的编译过程——我们将使用Florian Reiterer提供的Gulp源映射插件，可从[https://github.com/floridoo/gulp-sourcemaps](https://github.com/floridoo/gulp-sourcemaps)获取：
- en: We'll start, as always, by installing the plugin using Node—fire up a Node.js
    command prompt, then change to our project area.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样，使用Node安装插件——启动一个Node.js命令提示符，然后切换到我们的项目区域。
- en: 'Next, enter this at the command line and press *Enter*:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在命令行中输入以下内容并按*Enter*键：
- en: '[PRE8]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open up the `gulp` file we created back in the *Creating a simple example using
    PostCSS* section, then add a reference to `gulp-sourcemaps` as a variable:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在*使用PostCSS创建简单示例*部分创建的`gulp`文件，然后添加对`gulp-sourcemaps`的引用作为一个变量：
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then need to add the commands to create the source maps—in the same file,
    alter the code as shown:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要添加创建源映射的命令——在同一个文件中，按照以下所示修改代码：
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save the results, then from the Node.js command prompt, run this command, and
    press *Enter*:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存结果，然后从Node.js命令提示符中运行此命令，并按*Enter*键：
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If all is well, we should see a new source map appear in the `dest` folder,
    under a subfolder called `maps`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在`dest`文件夹下的一个名为`maps`的子文件夹中看到一个新源映射出现。
- en: We're a step further in the right direction; we now have a map file for our
    style sheet in the maps folder, created automatically during the compilation process.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们又向前迈出一步，朝着正确的方向前进；现在我们已经在`maps`文件夹中为我们的样式表创建了一个映射文件，这是在编译过程中自动创建的。
- en: Note
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth noting that we will make full use of this area—if you see any reference
    to `project area` throughout the book, this will be our given name for this folder.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，我们将充分利用这个区域——如果你在整本书中看到任何关于`project area`的提及，这将是我们对这个文件夹的指定名称。
- en: 'But, we can do more: although we only have a small CSS file here, it''s still
    important to compress it to save on unnecessary bandwidth usage. We can easily
    fix that using PostCSS—let''s take a look at how, using the `cssnano` plugin.'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，我们可以做得更多：尽管我们这里只有一个小的CSS文件，但将其压缩以节省不必要的带宽使用仍然很重要。我们可以很容易地使用PostCSS来修复这个问题——让我们看看如何使用`cssnano`插件来操作。
- en: Creating minified style sheets
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建最小化样式表
- en: A key part of producing style sheets is minifying the output; this should feature
    as standard in any developer's workflow. Minifying the results will cut down on
    bandwidth usage. In an age of broadband or cable use, this is less critical for
    smaller sites, but should not attract any less importance than for larger sites!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 生成样式表的关键部分是输出最小化；这应该在任何开发者的工作流程中作为标准。最小化结果将减少带宽使用。在宽带或电缆使用时代，对于较小的网站来说，这可能不那么关键，但不应比大型网站的重要性低！
- en: 'Thankfully, minifying files is a cinch to achieve when working with PostCSS.
    For this next exercise, we will use the `cssnano` and `gulp-rename` plugins, available
    from [http://cssnano.co/](http://cssnano.co/) and [https://github.com/hparra/gulp-rename](https://github.com/hparra/gulp-rename),
    respectively. Let''s go ahead and get them installed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当使用PostCSS时，最小化文件变得非常简单。对于接下来的练习，我们将使用从[http://cssnano.co/](http://cssnano.co/)和[https://github.com/hparra/gulp-rename](https://github.com/hparra/gulp-rename)可用的`cssnano`和`gulp-rename`插件。让我们继续安装它们：
- en: 'We''ll start by firing up a Node.js command prompt, then entering the following
    and pressing *Enter*:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先启动一个Node.js命令提示符，然后输入以下内容并按*Enter*键：
- en: '[PRE12]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Don't close the session window, we will use it later in this exercise.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要关闭会话窗口，我们将在本练习的后面使用它。
- en: 'Switch to the `gulpfile.js` file we created earlier (it''s stored at the root
    of our project folder), then add the following lines immediately after the last
    closing `})` on or around line 12:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到我们之前创建的`gulpfile.js`文件（它存储在我们的项目文件夹的根目录），然后在第12行或其附近的最后一个关闭`})`之后立即添加以下行：
- en: '[PRE13]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the top of the file, we need to add two declarations, otherwise our code
    will fail; go ahead and add the following two lines, as highlighted:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，我们需要添加两个声明，否则我们的代码将失败；请继续添加以下两条高亮显示的行：
- en: '[PRE14]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Any sharp-eyed readers may now spot a problem—in the last line, we have a reference
    to `styles`, yet nothing is shown in the code for this! To fix it, we need to
    change our code. In line 8, change the line as shown:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何细心的读者现在可能已经发现了问题——在最后一行，我们有一个对`styles`的引用，但在代码中却没有显示这一点！为了修复它，我们需要更改我们的代码。在第8行，按照以下所示更改行：
- en: '[PRE15]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save the file, then switch back to the Node.js command prompt window and enter
    this command, followed by *Enter*:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后切换回 Node.js 命令提示符窗口，并输入以下命令，然后按 *Enter*：
- en: '[PRE16]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Gulp will now compile:![Creating minified style sheets](img/BO5194_01_12.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gulp 现在将编译：![创建压缩样式表](img/BO5194_01_12.jpg)
- en: 'If all is well, we should see the compiled output appear in the `dest` folder
    of our project area:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在我们的项目区域的 `dest` 文件夹中看到编译后的输出：
- en: '![Creating minified style sheets](img/BO5194_01_13.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建压缩样式表](img/BO5194_01_13.jpg)'
- en: In our project area, we not only have the source map file created under maps,
    but now also have a minified style sheet, the latter created by renaming the output
    from `cssnano` (`cssnano` does not do this renaming natively, hence use of the
    `rename` plugin).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目区域，我们不仅创建了 `maps` 下的源映射文件，现在还创建了一个最小化样式表，后者是通过重命名 `cssnano` 的输出创建的（`cssnano`
    本身不执行重命名，因此使用了 `rename` 插件）。
- en: 'Unfortunately though, we still have one small issue—take a look at the contents
    of the `maps` folder: notice anything? Hopefully, you may spot that the source
    map file is there for the uncompressed version of our style sheet, but not the
    compressed one! Let''s fix that now. To do so, we just need to use the `rename`
    task in our Gulp file, as shown:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不幸的是，我们仍然有一个小问题——看看 `maps` 文件夹的内容：你注意到什么了吗？希望你能发现，源映射文件在我们的样式表的未压缩版本中，但压缩版本中没有！现在让我们修复这个问题。要做到这一点，我们只需要在我们的
    Gulp 文件中使用 `rename` 任务，如下所示：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Try running Gulp now. If all is well we should see the source map appear for
    our minified style sheet:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行 Gulp。如果一切顺利，我们应该在我们的最小化样式表看到源映射：
- en: '![Creating minified style sheets](img/BO5194_01_14.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![创建压缩样式表](img/BO5194_01_14.jpg)'
- en: Let's finish off our `gulp` file; the last stage is to add a `watch` facility,
    so that changes are compiled automatically as soon as files are modified.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完成我们的 `gulp` 文件；最后一步是添加一个 `watch` 功能，以便在文件修改后自动编译更改。
- en: Altering to compile automatically
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动编译的修改
- en: Adding a `watch` facility is simple when using Gulp. It helps reduce the manual
    effort required when using Gulp, as we only need to fire off the Gulp task file
    once, and it will continue to apply the tasks each time files are changed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Gulp 时添加 `watch` 功能很简单。这有助于减少使用 Gulp 时所需的手动工作量，因为我们只需要运行一次 Gulp 任务文件，每次文件更改时它都会继续应用这些任务。
- en: 'Unlike other plugins, we don''t need to install any plugins for this; simply
    add the highlighted lines from the following to the `gulpfile.js` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他插件不同，我们不需要为此安装任何插件；只需将以下高亮行添加到 `gulpfile.js` 文件中即可：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can see the results of the addition to our gulp task file, and how it all
    comes together, in this screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们添加到 `gulp` 任务文件中的结果，以及它是如何结合在一起的，如下面的截图所示：
- en: '![Altering to compile automatically](img/BO5194_01_15.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![自动编译的修改](img/BO5194_01_15.jpg)'
- en: At this point, we can save the file then re-run the `gulp` command as before;
    this time it will automatically recompile any file that has changed, from within
    the `src` folder. In this instance, we've added an event handler to log an indication
    into the session so we can tell what is happening; we can easily modify this if
    needed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以保存文件然后像之前一样重新运行 `gulp` 命令；这次它将自动重新编译 `src` 文件夹中更改的任何文件。在这个例子中，我们添加了一个事件处理程序来记录会话中的指示，这样我们就可以知道发生了什么；如果需要，我们可以轻松地修改它。
- en: 'We now have a basic working system; we will begin to add to this over the next
    few chapters, toward building up our own processor. There is one small thing we
    should cover though: it''s not essential, but a useful tip for developing with
    PostCSS. I''m talking about linting your code, to ensure it is valid; let''s dive
    in and get this set up for use.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个基本的工作系统；我们将在接下来的几章中开始添加内容，以构建我们自己的处理器。不过，有一件小事我们应该注意：这不是必需的，但是一个在 PostCSS
    开发中很有用的技巧。我指的是检查你的代码，以确保它是有效的；让我们深入探讨并设置好以供使用。
- en: Linting code using plugins
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件进行代码检查
- en: It goes without saying that linting code should be part of any developer's workflow.
    There are lots of different ways to achieve this, depending on the tools you use.
    The beauty of PostCSS is that we can easily add a suitable linting capability
    to our processor, using the `stylelint` plugin for PostCSS (available from [http://stylelint.io/](http://stylelint.io/)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，代码检查应该是任何开发者工作流程的一部分。根据你使用的工具，有各种不同的方法来实现这一点。PostCSS 的美妙之处在于，我们可以轻松地为我们的处理器添加合适的代码检查功能，使用
    PostCSS 的 `stylelint` 插件（可在 [http://stylelint.io/](http://stylelint.io/) 获取）。
- en: 'Why would we do this? Easy: we can get a single consistent result throughout.
    This becomes essential if you work as part of a team; instead as different team
    members using inconsistent settings, we can set up a central point for processing,
    to retain a consistent output. Moving the linting process to our central workflow
    means the server can do the grunt work for us, and provide a consistent result
    anytime for anyone running the process.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这样做呢？很简单：我们可以得到一个一致的结果。如果你作为团队的一员工作，这一点变得至关重要；而不是不同的团队成员使用不一致的设置，我们可以设置一个中心点进行处理，以保持一致的输出。将代码检查过程移至我们的中心工作流程意味着服务器可以为我们做苦力工作，并且随时为任何运行此过程的人提供一致的结果。
- en: 'With this in mind, let''s take a look at how we can set up our linting capability:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看看我们如何设置我们的代码检查能力：
- en: We start as always by installing our plugin. For this, fire up a Node.js command
    prompt, then change to the root of our project area.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样开始安装插件。为此，打开Node.js命令提示符，然后切换到我们的项目区域根目录。
- en: 'At the command prompt, enter this command, followed by *Enter*:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符下，输入以下命令，然后按*Enter*：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If all is well, we should see this appear at the prompt:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在提示符中看到这个：
- en: '![Linting code using plugins](img/BO5194_01_16.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用插件进行代码检查](img/BO5194_01_16.jpg)'
- en: Next up, we need to install a second plugin—there is a reporter function within
    `stylelint` that posts any messages to console (or in this case, screen). The
    plugin is `postcss-reporter`, and is available at [https://github.com/postcss/postcss-reporter](https://github.com/postcss/postcss-reporter).
    We can install it thus:![Linting code using plugins](img/BO5194_01_17.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装第二个插件——`stylelint`中有一个报告函数，它会将任何消息发布到控制台（或在这种情况下，屏幕）。该插件是`postcss-reporter`，可在[https://github.com/postcss/postcss-reporter](https://github.com/postcss/postcss-reporter)找到。我们可以这样安装它：![使用插件进行代码检查](img/BO5194_01_17.jpg)
- en: 'With the plugins installed, we need to update our `gulp` file; add the following
    lines immediately below the last `var` line shown:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件安装完成后，我们需要更新我们的`gulp`文件；在显示的最后`var`行下面立即添加以下行：
- en: '[PRE20]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Immediately, below the rename task in the Gulp file, add this task—this takes
    care of linting our code, and flagging any errors on-screen:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Gulp文件中的重命名任务下面立即添加此任务——这个任务负责检查我们的代码，并在屏幕上标记任何错误：
- en: '[PRE21]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Open a copy of `example.css` from the root area of our project folder and change
    the `color` to `#fff1az`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目文件夹根目录下的`example.css`副本，并将`color`更改为`#fff1az`。
- en: 'Back in the Node.js command prompt, enter this command and press *Enter*:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Node.js命令提示符中，输入此命令并按*Enter*：
- en: '[PRE22]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Gulp will begin to process our code; if all is well, it should flag a warning:![Linting
    code using plugins](img/BO5194_01_18.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gulp将开始处理我们的代码；如果一切顺利，它应该会显示警告：![使用插件进行代码检查](img/BO5194_01_18.jpg)
- en: 'It shouldn''t take much effort to spot that `#fff1az` is clearly not a valid
    number! Stylelint has correctly identified it, using the highlighted rule from
    our configuration:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易就能发现`#fff1az`显然不是一个有效的数字！Stylelint已经正确地识别了它，使用我们配置中的高亮规则：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's explore how this plugin works for a moment—the great thing about it is
    that there are simply dozens of rules available (which you can see at [https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md](https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md)).
    It works by concatenating together what is being checked (in this case, `color`)
    and the check being run against it (in our case, **-no-invalid-hex**, or checking
    for invalid hex numbers). We can apply any number of rules in our configuration
    object, to ensure that the output is consistent for all projects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时探索一下这个插件的工作原理——它的好处是，有数十个规则可供选择（你可以在[https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md](https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md)中看到）。它通过将检查的内容（在这种情况下，`color`）和对其运行的检查（在我们的情况下，**-no-invalid-hex**，或检查无效的十六进制数）连接起来工作。我们可以在配置对象中应用任意数量的规则，以确保所有项目的输出都是一致的。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you would like to get a feel for how the rules can be put together, then
    check out the user guide at [https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/user-guide.md](https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/user-guide.md),
    with more examples of rules available at [https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md](https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解规则是如何组合在一起的，那么请查看用户指南[https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/user-guide.md](https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/user-guide.md)，其中提供了更多规则的示例，可在[https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md](https://cdn.rawgit.com/stylelint/stylelint/1.0.0/docs/rules.md)找到。
- en: 'Okay, let''s move on: we will begin to look at compiling code in more detail
    from the next chapter, but for now, let''s take a look at how PostCSS works in
    more detail, and how we can begin to make the move from our existing processor
    to PostCSS.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续：从下一章开始，我们将更详细地探讨代码的编译过程，但就目前而言，让我们更详细地了解一下PostCSS是如何工作的，以及我们如何开始从现有的处理器迁移到PostCSS。
- en: Exploring how PostCSS works
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索PostCSS的工作原理
- en: So far, we've covered the basics of setting up and using PostCSS. It's worth
    taking a moment to learn about how it works, to better understand how we can use
    it and develop our own plugins for the platform.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了设置和使用PostCSS的基础知识。花点时间了解它是如何工作的，这样我们就能更好地理解如何使用它，并为该平台开发自己的插件。
- en: 'PostCSS is like me on a Saturday morning after a good night out: it does nothing!
    Yes, it''s true, by itself, the application doesn''t do anything at all; it''s
    when we add plugins into the mix that it starts to become useful.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS就像我周六早上在狂欢之后：什么也不做！是的，这是真的，单凭它本身，这个应用根本什么也不做；只有当我们添加插件进来，它才开始变得有用。
- en: 'The key to PostCSS is treating it as an enabler, it is not meant as a direct
    replacement for your existing preprocessor, or even postprocessor, but to complement
    them. It works on the basis of parsing code, processing it with any assigned plugins,
    and rendering the results:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS的关键是将其视为一个启用器，它不是作为你现有预处理器或后处理器的直接替代品，而是作为它们的补充。它基于解析代码，使用任何分配的插件处理代码，并渲染结果：
- en: '![Exploring how PostCSS works](img/BO5194_01_19.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![探索PostCSS的工作原理](img/BO5194_01_19.jpg)'
- en: It works by parsing content into an **Abstract Syntax Tree** (or AST) with a
    series of nodes. Each node in the tree contains a symbolic representation of an
    element in your code. In other words, if you had a condition statement that pointed
    to three possible outcomes, then the AST would have a single node, with three
    branches representing the possible outcomes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过一系列节点将内容解析为**抽象语法树**（或AST）。树中的每个节点都包含了对代码中元素的符号表示。换句话说，如果你有一个指向三个可能结果的条件语句，那么AST将有一个节点，有三个分支代表可能的结果。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an example of an AST, take a look at [http://jointjs.com/demos/javascript-ast](http://jointjs.com/demos/javascript-ast),
    which shows the breakdown of a simple arithmetic function using plain JavaScript.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看[http://jointjs.com/demos/javascript-ast](http://jointjs.com/demos/javascript-ast)，它展示了使用纯JavaScript分解一个简单的算术函数。
- en: Our AST is then sent through one or more plugins (we must always use one plugin,
    but can have many in our `gulp` file). It then converts the code to a long string,
    before processing it through any assigned plugins and spitting out the result
    in the form of valid CSS. We can use this as a basis for creating our own plugins,
    using the boilerplate code and API that are both available from the main PostCSS
    site on GitHub.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的AST通过一个或多个插件（我们必须始终使用一个插件，但可以在我们的`gulp`文件中有多个）。然后它将代码转换成长字符串，在通过任何分配的插件处理之前，并以有效CSS的形式输出结果。我们可以利用这一点作为创建我们自己的插件的基础，使用从GitHub上PostCSS主站提供的样板代码和API。
- en: The trick to the plugin stage is in the mix of plugins we must use to satisfy
    our needs; the better ones should only perform one role. Any that perform multiple
    tasks are less ideal, as they are likely to contain excess functionality that
    we don't need in our projects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 插件阶段的技巧在于我们必须使用的插件组合来满足我们的需求；更好的插件应该只执行一个角色。任何执行多个任务的插件都不太理想，因为它们可能包含我们项目中不需要的额外功能。
- en: Making the move from SASS
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从SASS迁移
- en: 'Assuming we decided to use PostCSS, there is almost always one question at
    the top of everyone''s mind: how do we make the move?'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定使用PostCSS，几乎每个人心中都有一个首要问题：我们如何进行迁移？
- en: In short, the key here is *not* to simply assume existing code can be put through
    the PostCSS process, as it will likely not work. Instead, we should take an iterative
    process, and begin to convert low-hanging fruit to using PostCSS. The process
    will of course require some work, but there are tips on how we can reduce the
    pain involved in making the switch to PostCSS.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，关键不是简单假设现有的代码可以直接通过PostCSS过程，因为它可能不起作用。相反，我们应该采取迭代的过程，开始将低垂的果实转换为使用PostCSS。这个过程当然需要一些工作，但有一些技巧可以帮助我们减少迁移到PostCSS时的痛苦。
- en: The key to making the transfer is to work out what functionality needs to be
    processed, then to create the initial framework for a build process (for example,
    a Gulp or Grunt task file), then to gradually add in plugin support one by one,
    until you have a fully working compiler.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实现迁移的关键是确定需要处理的功能，然后创建构建过程的初始框架（例如，一个 Gulp 或 Grunt 任务文件），然后逐步添加插件支持，直到你拥有一个完全工作的编译器。
- en: We can take this a step further, and use plugins that replicate SASS code format
    into PostCSS; an ideal plugin to start with is Autoprefixer, followed by plugins
    such as `postcss-mixins` or `postcss-partial-import`. We will explore using SASS
    as a basis for a custom syntax in [Chapter 11](ch11.html "Chapter 11. Manipulating
    Custom Syntaxes"), *Manipulating Custom Syntaxes*, where we will use these two
    plugins, and more, to help make the transition process easier and help remove
    the dependencies on preprocessors such as SASS or Less. Oh, and above all, being
    based on JavaScript makes it portable; what more could a developer ask for, I
    wonder?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，使用可以将 SASS 代码格式复制到 PostCSS 的插件；一个理想的开始插件是 Autoprefixer，随后可以尝试 `postcss-mixins`
    或 `postcss-partial-import` 等插件。我们将在第 11 章 [“操纵自定义语法”](ch11.html "Chapter 11. Manipulating
    Custom Syntaxes") 中探讨如何以 SASS 为基础创建自定义语法，我们将使用这两个插件以及更多插件，以帮助简化过渡过程并帮助移除对 SASS
    或 Less 等预处理器依赖。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many of the SASS format plugins for PostCSS now come in the `PreCSS` pack. We
    will explore using this in [Chapter 10](ch10.html "Chapter 10. Building a Custom
    Processor"), *Building a Custom Preprocessor*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在许多用于 PostCSS 的 SASS 格式插件都包含在 `PreCSS` 套件中。我们将在第 10 章 [“构建自定义预处理器”](ch10.html
    "Chapter 10. Building a Custom Preprocessor") 中探讨如何使用这个套件。
- en: Okay, on we go. Over the course of the next few chapters, we will take a look
    at different processor elements that are commonly used to create build processors,
    such as variables or mixins. We'll see how they might typically be written in
    processors such as SASS or Less, then work on converting our code to use PostCSS
    equivalents before processing to produce valid CSS. We will then finish up with
    pulling everything together to build your own custom processor for use in future
    projects.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们继续前进。在接下来的几章中，我们将探讨不同处理器元素，这些元素通常用于创建构建处理器，例如变量或混入（mixins）。我们将看到它们通常如何在
    SASS 或 Less 等处理器中编写，然后努力将我们的代码转换为使用 PostCSS 等价物，在处理之前生成有效的 CSS。然后我们将完成所有这些，构建你自己的自定义处理器，用于未来的项目。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Writing valid CSS is an art that has been present since the dawn of the Internet;
    this takes skill, patience, and time to produce and perfect any masterpiece. Processors
    such as SASS or Less have helped to make the process more efficient, but are not
    without their drawbacks; PostCSS allows for a more customized approach, but without
    the extra baggage. We've covered a few key points around PostCSS throughout this
    chapter, so let's take a moment to review what we've learned.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 编写有效的 CSS 是一种自互联网诞生以来就存在的艺术；这需要技巧、耐心和时间来创作和完美任何杰作。SASS 或 Less 等处理器有助于使这个过程更高效，但并非没有缺点；PostCSS
    允许更定制化的方法，但无需额外的负担。我们在本章中已经覆盖了关于 PostCSS 的几个关键点，所以让我们花点时间回顾一下我们学到了什么。
- en: We began with a brief look at the art of processing, before introducing PostCSS
    as a tool. We then explored some of the benefits and drawbacks of using it, and
    how it can fit in seamlessly with your existing development workflow, with a little
    careful planning.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先简要地看了看处理的艺术，然后介绍了 PostCSS 作为一种工具。接着我们探讨了使用它的利弊，以及如何通过一些周密的计划使其与现有的开发工作流程无缝结合。
- en: Next up, we covered the installation of PostCSS along with Gulp as the task
    runner/host process, before embarking on a simple demo to introduce how the compilation
    process works, and that with the right choice of plugins, we can take out some
    of the manual grunt work required to manage our code (pun intended!). With our
    code compiling, we then turned our attention to adding a watch facility, and automatic
    support for linting our code, to ensure we maintain consistent standards.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了 PostCSS 的安装，以及 Gulp 作为任务运行器/宿主进程，然后进行了一个简单的演示，介绍编译过程是如何工作的，以及通过正确选择插件，我们可以减少管理代码所需的某些手动工作（有意为之！）。随着我们的代码编译完成，我们接着关注添加监视功能，以及自动支持代码检查，以确保我们保持一致的标准。
- en: We then rounded out the chapter with a look at how PostCSS works, and understanding
    something of its architecture, so that we can begin to make the move from using
    plain CSS or an existing preprocessor, to using PostCSS.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着通过了解 PostCSS 的工作原理和其架构的某些方面来完善本章，这样我们就可以开始从使用纯 CSS 或现有预处理器过渡到使用 PostCSS。
- en: Phew, we've certainly covered a lot; it's time to really get stuck in now, and
    start to use PostCSS in earnest. Over the next few chapters, we will explore a
    number of different concepts that are common to existing preprocessors, and explore
    how we can benefit from making the transition to using PostCSS. We have to start
    somewhere, so we'll kick off with using variables, functions, and mixins in the
    next chapter, and see how we can use some of the techniques from processors, but
    without the associated baggage!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们确实已经涵盖了很多内容；现在是时候真正深入研究了，开始认真使用 PostCSS。在接下来的几章中，我们将探讨许多现有预处理器中常见的概念，并探讨我们如何从过渡到使用
    PostCSS 中受益。我们必须从某个地方开始，所以我们将从下一章使用变量、函数和混入开始，看看我们如何使用一些处理器技术，但又不带相关的负担！
