- en: Chapter 1. Why CoffeeScript?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 为什么使用CoffeeScript？
- en: CoffeeScript compiles to JavaScript and follows its idioms closely. It's quite
    possible to rewrite any CoffeeScript code in Javascript and it won't look drastically
    different. So why would you want to use CoffeeScript?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript编译成JavaScript，并且紧密遵循其习惯用法。完全可以将任何CoffeeScript代码重写为JavaScript，它们看起来并不会有很大的不同。那么为什么要使用CoffeeScript呢？
- en: As an experienced JavaScript programmer, you might think that learning a completely
    new language is simply not worth the time and effort.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名有经验的JavaScript程序员，你可能认为学习一个全新的语言根本不值得时间和精力。
- en: But ultimately, code is for programmers. The compiler doesn't care how the code
    looks or how clear its meaning is; either it will run or it won't. We aim to write
    expressive code as programmers so that we can read, reference, understand, modify,
    and rewrite it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但最终，代码是给程序员看的。编译器不在乎代码的外观或清晰的含义；它要么运行，要么不运行。我们的目标是作为程序员编写表达性强的代码，这样我们就可以阅读、引用、理解、修改和重写它。
- en: If the code is too complex or filled with needless ceremony, it will be harder
    to understand and maintain. CoffeeScript gives us an advantage to clarify our
    ideas and write more readable code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码过于复杂或充满了不必要的仪式，那么理解和维护将会更加困难。CoffeeScript给了我们一个优势，可以澄清我们的想法并编写更易读的代码。
- en: It's a misconception to think that CoffeeScript is very different from JavaScript.
    There might be some drastic syntax differences here and there, but in essence,
    CoffeeScript was designed to polish the rough edges of JavaScript to reveal the
    beautiful language hidden beneath. It steers programmers towards JavaScript's
    so-called "good parts" and holds strong opinions of what constitutes good JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 认为CoffeeScript与JavaScript非常不同是一种误解。可能在某些地方会有一些极端的语法差异，但本质上，CoffeeScript旨在打磨JavaScript的粗糙边缘，揭示其中隐藏的美丽语言。它引导程序员走向JavaScript的所谓“好部分”，并对构成良好JavaScript的内容持有坚定的看法。
- en: 'One of the mantras of the CoffeeScript community is: "It''s just JavaScript",
    and I have also found that the best way to truly comprehend the language is to
    look at how it generates its output, which is actually quite readable and understandable
    code.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript社区的口头禅之一是：“它只是JavaScript”，我也发现真正理解这种语言的最佳方法是看它是如何生成输出的，实际上生成的代码相当可读和易懂。
- en: Throughout this chapter, we'll highlight some of the differences between the
    two languages, often focusing on the things in JavaScript that CoffeeScript tries
    to improve.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍两种语言之间的一些差异，通常关注JavaScript中CoffeeScript试图改进的内容。
- en: In this way, I would not only like to give you an overview of the major features
    of the language, but also prepare you to be able to debug your CoffeeScript from
    its generated code once you start using it more often, as well as being able to
    convert existing JavaScript.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我不仅想给你一个关于该语言主要特性的概述，还想让你能够在更频繁地使用它后，能够调试生成的代码，以及能够转换现有的JavaScript。
- en: Let's start with some of the things CoffeeScript fixes in JavaScript.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从CoffeeScript修复JavaScript中的一些问题开始。
- en: CoffeeScript syntax
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoffeeScript语法
- en: One of the great things about CoffeeScript is that you tend to write much shorter
    and more succinct programs than you normally would in JavaScript. Some of this
    is because of the powerful features added to the language, but it also makes a
    few tweaks to the general syntax of JavaScript to transform it to something quite
    elegant. It does away with all the semicolons, braces, and other cruft that usually
    contributes to a lot of the "line noise" in JavaScript.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript的一大优点是，你写的程序通常比在JavaScript中写的要短得多，更简洁。部分原因是语言中添加了强大的功能，但它也对JavaScript的一般语法进行了一些调整，使其变得相当优雅。它取消了所有的分号、大括号和其他通常导致JavaScript中很多“线噪音”的东西。
- en: 'To illustrate this, let''s look at an example. On the left-hand side of the
    following table is CoffeeScript; on the right-hand side is the generated JavaScript:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看一个例子。下表的左侧是CoffeeScript，右侧是生成的JavaScript：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'To run the code examples in this chapter, you can use the great **Try CoffeeScript**
    online tool, at [http://coffeescript.org](http://coffeescript.org). It allows
    you to type in CoffeeScript code, which will then display the equivalent JavaScript
    in a side pane. You can also run the code right from the browser (by clicking
    the **Run** button in the upper-left corner). If you prefer to get CoffeeScript
    running on your computer to run the samples first, skip to the next chapter and
    then come back once you have CoffeeScript installed. This tool is shown in the
    following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，可以使用伟大的**尝试CoffeeScript**在线工具，网址为[http://coffeescript.org](http://coffeescript.org)。它允许你输入CoffeeScript代码，然后在侧边栏显示相应的JavaScript。你也可以直接从浏览器中运行代码（点击左上角的**运行**按钮）。如果你更喜欢先在计算机上运行CoffeeScript来运行示例，请跳到下一章，然后安装好CoffeeScript再回来。该工具如下截图所示：
- en: '![CoffeeScript syntax](img/9588OS_01_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![CoffeeScript语法](img/9588OS_01_01.jpg)'
- en: At first, the two languages might appear to be quite drastically different,
    but hopefully as we go through the differences, you'll see that it's all still
    JavaScript with some small tweaks and a lot of nice syntactical sugar.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这两种语言可能看起来截然不同，但希望随着我们对比差异，你会发现它们仍然是JavaScript，只是进行了一些小的调整和大量的语法糖。
- en: Semicolons and braces
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分号和大括号
- en: As you might have noticed, CoffeeScript does away with all the trailing semicolons
    at the end of a line. You can still use a semicolon if you want to put two expressions
    on a single line. It also does away with enclosing braces (also known as curly
    brackets) for code blocks such as `if` statements, `switch`, and the `try..catch`
    block.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，CoffeeScript取消了所有行末的分号。如果想要在一行上放两个表达式，仍然可以使用分号。它还取消了代码块的大括号（也称为花括号），比如`if`语句、`switch`和`try..catch`块。
- en: Whitespace
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空格
- en: You might be wondering how the parser figures out where your code blocks start
    and end. The CoffeeScript compiler does this by using syntactical whitespace.
    This means that indentation is used for delimited code blocks instead of braces.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道解析器如何确定代码块的起始和结束位置。CoffeeScript编译器通过使用语法空格来实现这一点。这意味着缩进用于分隔代码块，而不是大括号。
- en: This is perhaps one of the most controversial features of the language. If you
    think about it, in almost all languages, programmers tend to already use indentation
    of code blocks to improve readability, so why not make it part of the syntax?
    This is not a new concept, and was mostly borrowed from Python. If you have any
    experience with significant whitespace language, you will not have any trouble
    with CoffeeScript indentation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是该语言最具争议的特性之一。如果你仔细想想，在几乎所有的语言中，程序员倾向于使用代码块的缩进来提高可读性，那么为什么不将其作为语法的一部分呢？这并不是一个新概念，而是大部分借鉴自Python。如果你有任何与显著空白语言的经验，你将不会对CoffeeScript的缩进感到困扰。
- en: If you don't, it might take some getting used to, but it makes for code that
    is wonderfully readable and easy to scan, while shaving off quite a few keystrokes.
    I'm willing to bet that if you do take the time to get over some initial reservations
    you might have, you might just grow to love block indentation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，可能需要一些时间来适应，但这样做可以使代码非常易读和易于扫描，同时减少了很多按键。我敢打赌，如果你花时间克服一些可能存在的初步保留，你可能会喜欢块缩进。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Blocks can be indented with tabs or spaces, but be careful about being consistent
    using one or the other, or CoffeeScript will not be able to parse your code correctly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 块可以使用制表符或空格进行缩进，但要注意一致使用其中一种，否则CoffeeScript将无法正确解析您的代码。
- en: Parenthesis
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 括号
- en: You'll see that the clause of the `if` statement does not need be enclosed within
    parentheses. The same goes for the `alert` function; you'll see that the single
    string parameter follows the function call without parentheses as well. In CoffeeScript,
    parentheses are optional in function calls with parameters, clauses for `if..else`
    statements, as well as `while` loops.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`if`语句的子句不需要用括号括起来。`alert`函数也是一样；你会发现单个字符串参数跟在函数调用后面，也没有括号。在CoffeeScript中，带参数的函数调用、`if..else`语句的子句以及`while`循环的括号都是可选的。
- en: 'Although functions with arguments do not need parentheses, it is still a good
    idea to use them in cases where ambiguity might exist. The CoffeeScript community
    has come up with a nice idiom: wrapping the whole function call in parenthesis.
    The use of the `alert` function in CoffeeScript is shown in the following table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然带参数的函数不需要括号，但在可能存在歧义的情况下使用括号仍然是一个好主意。CoffeeScript社区提出了一个不错的习惯：将整个函数调用包装在括号中。在下表中显示了在CoffeeScript中使用`alert`函数：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: CoffeeScript | JavaScript
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Functions are first class objects in JavaScript. This means that when you refer
    to a function without parentheses, it will return the function itself, as a value.
    Thus, in CoffeeScript you still need to add parentheses when calling a function
    with no arguments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是一等对象。这意味着当你引用一个没有括号的函数时，它将返回函数本身作为值。因此，在CoffeeScript中，当调用没有参数的函数时，仍然需要添加括号。
- en: By making these few tweaks to the syntax of JavaScript, CoffeeScript arguably
    already improves the readability and succinctness of your code by a big factor,
    and also saves you quite a lot of keystrokes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对JavaScript的语法进行这些小调整，CoffeeScript可以说已经大大提高了代码的可读性和简洁性，并且还节省了大量的按键。
- en: But it has a few other tricks up its sleeve. Most programmers who have written
    a fair amount of JavaScript would probably agree that one of the phrases that
    gets typed the most frequently would have to be the function definition `function(){}`.
    Functions are really at the heart of JavaScript, yet not without its many warts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但它还有一些其他的技巧。大多数写过大量JavaScript的程序员可能会同意，最频繁输入的短语之一应该是函数定义`function(){}`。函数确实是JavaScript的核心，但也不是没有缺点。
- en: CoffeeScript has great function syntax
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoffeeScript具有出色的函数语法
- en: 'The fact that you can treat functions as first class objects as well as being
    able to create anonymous functions is one of JavaScript''s most powerful features.
    However, the syntax can be very awkward and make the code hard to read (especially
    if you start nesting functions). But CoffeeScript has a fix for this. Have a look
    at the following snippets:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将函数视为一等对象，也可以创建匿名函数，这是JavaScript最强大的特性之一。然而，语法可能非常笨拙，使得代码难以阅读（特别是如果你开始嵌套函数）。但是CoffeeScript对此有解决方法。看一下以下代码片段：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Here, we are creating two anonymous functions, the first just displays a dialog
    and the second will return the square of its argument. You've probably noticed
    the funny `->` symbol and might have figured out what it does. Yep, that is how
    you define a function in CoffeeScript. I have come across a couple of different
    names for the symbol but the most accepted term seems to be a thin arrow or just
    an arrow. This is as opposed to the fat arrow, which we'll discuss later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个匿名函数，第一个只显示一个对话框，第二个将返回其参数的平方。你可能已经注意到了有趣的`->`符号，并可能已经弄清楚了它的作用。是的，这就是你在CoffeeScript中定义函数的方式。我遇到过一些不同的符号名称，但最被接受的术语似乎是一个细箭头或者只是一个箭头。这与粗箭头相对，我们稍后会讨论。
- en: 'Notice that the first function definition has no arguments and thus we can
    drop the parenthesis. The second function does have a single argument, which is
    enclosed in parenthesis, which goes in front of the `->` symbol. With what we
    now know, we can formulate a few simple substitution rules to convert JavaScript
    function declarations to CoffeeScript. They are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个函数定义没有参数，因此我们可以省略括号。第二个函数有一个参数，括号括起来，放在`->`符号前面。根据我们现在所知道的，我们可以制定一些简单的替换规则，将JavaScript函数声明转换为CoffeeScript。它们如下：
- en: Replace the `function` keyword with `->`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`->`替换`function`关键字
- en: If the function has no arguments, drop the parenthesis
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数没有参数，去掉括号
- en: If it has arguments, move the whole argument list with parenthesis in front
    of the `->` symbol
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有参数，请将整个参数列表与括号一起移到`->`符号前面
- en: Make sure that the function body is properly indented and then drop the enclosing
    braces
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保函数体正确缩进，然后去掉括号
- en: Return isn't required
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不需要返回
- en: You might have noted that in both the functions, we left out the `return` keyword.
    By default, CoffeeScript will return the last expression in your function. It
    will try to do this in all the paths of execution. CoffeeScript will try turning
    any statement (fragment of code that returns nothing) into an expression that
    returns a value. CoffeeScript programmers will often refer to this feature of
    the language by saying that everything is an expression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在这两个函数中，我们都省略了`return`关键字。默认情况下，CoffeeScript将返回函数中的最后一个表达式。它将尝试在所有执行路径中执行此操作。CoffeeScript将尝试将任何语句（返回空值的代码片段）转换为返回值的表达式。CoffeeScript程序员经常通过说语言的所有内容都是表达式来提到语言的这个特性。
- en: This means you don't need to type `return` anymore, but keep in mind that this
    can, in many cases, alter your code subtly, because of the fact that you will
    always return something. If you need to return a value from a function before
    the last statement, you can still use `return`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您不再需要输入`return`，但请记住，这可能会在许多情况下微妙地改变您的代码，因为您总是会返回某些东西。如果需要在最后一个语句之前从函数返回一个值，仍然可以使用`return`。
- en: Function arguments
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'Function arguments can also take an optional default value. In the following
    code snippet you''ll see that the optional value specified is assigned in the
    body of the generated Javascript:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数也可以采用可选的默认值。在下面的代码片段中，您将看到指定的可选值被分配在生成的Javascript的主体中：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In JavaScript, each function has an array-like structure called `arguments`
    with an indexed property for each argument that was passed to the function. You
    can use `arguments` to pass in a variable number of parameters to a function.
    Each parameter will be an element in arguments and thus you don't have to refer
    to parameters by name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，每个函数都有一个类似数组的结构，称为`arguments`，其中为传递给函数的每个参数都有一个索引属性。您可以使用`arguments`向函数传递可变数量的参数。每个参数都将成为arguments中的一个元素，因此您不必按名称引用参数。
- en: Although the `arguments` object acts somewhat like an array, it is in not in
    fact a "real" array and lacks most of the standard array methods. Often, you'll
    find that `arguments` doesn't provide the functionality needed to inspect and
    manipulate its elements like they are used with an array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`arguments`对象在某种程度上类似于数组，但它实际上不是一个“真正”的数组，并且缺少大部分标准数组方法。通常，您会发现`arguments`无法提供检查和操作其元素所需的功能，就像它们与数组一起使用一样。
- en: This has forced many programmers to use a hack by making `Array.prototype.slice`
    copy the `argument` object elements, or to use the `jQuery.makeArray` method to
    create a standard array, which can then be used like normal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使许多程序员使用一个小技巧，即使`Array.prototype.slice`复制`argument`对象元素，或者使用`jQuery.makeArray`方法创建一个标准数组，然后可以像正常数组一样使用。
- en: 'CoffeeScript borrows this pattern of creating an array from arguments that
    are represented by **splats** , denoted with three dots (`...`). These are shown
    in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript借用了从参数创建数组的模式，这些参数由三个点(`...`)表示。这些在下面的代码片段中显示：
- en: '**CoffeeScript:**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript:**'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**JavaScript:**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript:**'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that in the function definition, the parameter is followed by `...`.
    This tells CoffeeScript to allow for variable arguments. The function can then
    be invoked using either a list of parameters or an array followed by `...`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数定义中，参数后面跟着`...`。这告诉CoffeeScript允许可变参数。然后可以使用参数列表或跟随`...`的数组来调用函数。
- en: Where did the var keyword go?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: var关键字去哪了？
- en: In JavaScript, you create local variables by prefixing their declarations with
    a `var` keyword. If you omit it, the variable will be created in the global scope.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，通过在声明它们的时候加上`var`关键字来创建局部变量。如果省略它，变量将在全局范围内创建。
- en: You'll see throughout these examples that that we didn't need to use the `var`
    keyword, and that CoffeeScript created the actual variable declarations at the
    top of the function in the generated JavaScript.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在这些示例中看到，我们不需要使用`var`关键字，并且CoffeeScript在生成的JavaScript中创建了实际的变量声明。
- en: If you're an experienced JavaScripter, you might be wondering how you would
    then go about creating global variables. The simple answer is you can't.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一位经验丰富的JavaScript程序员，您可能会想知道如何创建全局变量。简单的答案是您不能。
- en: Many people (probably including the authors of CoffeeScript) would argue that
    this is a good thing, because in most cases global variables should be avoided.
    Don't fret though, as there are ways to create top-level objects that we'll get
    to in a moment. But this does lead us neatly onto another benefit of CoffeeScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人（可能包括CoffeeScript的作者）会认为这是一件好事，因为在大多数情况下应该避免使用全局变量。不过，不用担心，因为有办法创建顶层对象，我们马上就会讲到。但这也巧妙地引出了CoffeeScript的另一个好处。
- en: CoffeeScript handles scope better
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoffeeScript处理作用域更好
- en: 'Take a look at the following snippet of JavaScript. Notice that a variable
    called `salutation` gets defined in two places, inside the function, as well as
    after the function gets called the first time:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的JavaScript片段。注意，一个名为`salutation`的变量在函数内部以及在第一次调用函数后被定义：
- en: '| JavaScript |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript |'
- en: '| --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In JavaScript, when you omit the `var` keyword while declaring a variable, it
    immediately becomes a global variable. Global variables are available in all scopes,
    and thus can be overwritten from anywhere, which often ends up as being a mess.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，当您在声明变量时省略`var`关键字时，它立即成为全局变量。全局变量在所有作用域中都可用，因此可以从任何地方进行覆盖，这经常会变得混乱。
- en: In the previous example, the `greet` function first checks if the `salutation`
    variable is defined (by checking if `typeof` equals `undefined`, a common workaround
    to see if a variable is defined in JavaScript). If it has not been defined previously,
    it creates it without a `var` keyword. This will immediately promote the variable
    to the global scope. We can see the consequences of this in the rest of the snippet.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`greet`函数首先检查`salutation`变量是否已定义（通过检查`typeof`是否等于`undefined`，这是JavaScript中常见的检查变量是否已定义的解决方法）。如果之前没有定义，它将在没有`var`关键字的情况下创建它。这将立即将变量提升到全局作用域。我们可以在代码片段的其余部分看到这种后果。
- en: The first time the `greet` function is called, the string **Hi!** will be logged.
    After the salutation has been changed and the function is called again, the console
    will instead log **Bye!**. Because the variable was leaked to be a global variable,
    its value was overwritten outside of the function scope.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`greet`函数时，将记录字符串**Hi!**。在问候语已更改并再次调用函数后，控制台将记录**Bye!**。因为变量泄露为全局变量，其值在函数作用域之外被覆盖。
- en: This odd "feature" of the language has been the cause of many a headache for
    some weary programmer who forgot to include a `var` keyword somewhere. Even if
    you mean to declare a global variable, it is generally considered to be a bad
    design choice, which is why CoffeeScript disallows it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言的奇怪“特性”曾经让一些疲惫的程序员头疼不已，因为他们忘记在某个地方包含`var`关键字。即使你想声明一个全局变量，通常也被认为是一个糟糕的设计选择，这就是为什么CoffeeScript不允许它的原因。
- en: CoffeeScript will always add the `var` keyword to any variable declaration to
    make sure that it doesn't inadvertently end up as a global declaration. In fact,
    you should never type `var` yourself, and the compiler will complain if you do.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript将始终向任何变量声明添加`var`关键字，以确保它不会无意中成为全局声明。事实上，你不应该自己输入`var`，如果你这样做，编译器会报错。
- en: Top level var keywords
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶级变量关键字
- en: When you declare a `var` normally at the top level of your script in JavaScript,
    it will still be available globally. This can also cause havoc when you include
    a bunch of different JavaScript files, since you might overwrite variables declared
    in earlier scripts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在JavaScript脚本的顶层正常声明一个`var`时，它仍然会全局可用。这也可能在包含大量不同的JavaScript文件时造成混乱，因为你可能会覆盖在先前脚本中声明的变量。
- en: In JavaScript and subsequently CoffeeScript, functions act as closures, meaning
    that they create their own variable scope as well as having their enclosing scope
    variables available to them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript和随后的CoffeeScript中，函数充当闭包，这意味着它们创建自己的变量作用域，并且可以访问它们的封闭作用域变量。
- en: Throughout the years, a common pattern started to emerge where library authors
    wrap their entire script in an anonymous closure function that they assign to
    a single variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，一个常见的模式开始出现，即库作者将他们的整个脚本包装在一个匿名闭包函数中，然后将其赋值给一个单一变量。
- en: 'The CoffeeScript compiler does something similar, and will wrap scripts in
    an anonymous function to avoid leaking its scope. In the following sample, the
    JavaScript is the output of running the CoffeeScript compiler:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript编译器做了类似的事情，并且会将脚本包装在一个匿名函数中，以避免泄露其作用域。在下面的示例中，JavaScript是运行CoffeeScript编译器后的输出：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Here you can see how CoffeeScript has wrapped the function definition in its
    own scope.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到CoffeeScript是如何将函数定义包装在自己的作用域中的。
- en: There are, however, certain cases where you would want a variable to be available
    throughout your application. Usually attaching a property to an existing global
    object can do this. When you're in the browser, you can just create a property
    on the global `window` object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些情况下，你可能希望一个变量在整个应用程序中都可用。通常可以通过将属性附加到现有的全局对象来实现这一点。当你在浏览器中时，你可以在全局的`window`对象上创建一个属性。
- en: In browser-side JavaScript, the `window` object represents an open window. It's
    globally available to all other objects and thus can be used as a global namespace
    or container for other objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器端的JavaScript中，`window`对象代表一个打开的窗口。它对所有其他对象都是全局可用的，因此可以用作全局命名空间或其他对象的容器。
- en: 'While we are on the subject of objects, let''s talk about another part of JavaScript
    that CoffeeScript makes much better: defining and using objects.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到对象时，让我们谈谈JavaScript的另一个部分，CoffeeScript使之更好：定义和使用对象。
- en: CoffeeScript has better object syntax
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoffeeScript有更好的对象语法
- en: The JavaScript language has a wonderful and unique object model, but the syntax
    and semantics for creating objects and inheriting from them has always been a
    bit cumbersome and widely misunderstood.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言拥有一个奇妙而独特的对象模型，但是创建对象和从中继承的语法和语义一直有些麻烦并且被广泛误解。
- en: 'CoffeeScript cleans this up in a simple and elegant syntax that does not stray
    too far from idiomatic JavaScript. The following code demonstrates how CoffeeScript
    compiles its class syntax into JavaScript:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript通过简单而优雅的语法对此进行了清理，不会偏离惯用的JavaScript。以下代码演示了CoffeeScript如何将其类语法编译成JavaScript：
- en: '**CoffeeScript:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript:**'
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**JavaScript:**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript:**'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In CoffeeScript, you use the `class` keyword to define object structures. Under
    the hood, this creates a function object with function methods added to its prototype.
    The `constructor: operator` will create a constructor function that will be called
    when your object gets initialized with the `new` keyword.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '在CoffeeScript中，你使用`class`关键字来定义对象结构。在底层，这将创建一个带有添加到其原型的函数方法的函数对象。`constructor:
    operator`将创建一个构造函数，在使用`new`关键字初始化对象时将被调用。'
- en: 'All the other function methods are declared using the `methodName: () ->` syntax.
    These are created on the prototype of the object.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '所有其他函数方法都是使用`methodName: () ->`语法声明的。这些方法是在对象的原型上创建的。'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Did you notice the `#{km}` in our alert string? This is the string interpolation
    syntax, which was borrowed from Ruby. We'll talk about this later in the chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们的警报字符串中的`#{km}`了吗？这是字符串插值语法，它是从Ruby中借鉴过来的。我们将在本章后面讨论这个。
- en: Inheritance
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: What about object inheritance? Although it's possible, normally this is such
    a pain in JavaScript that most programmers don't even bother, or use a third-party
    library with non-standard semantics.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么对象继承呢？虽然这是可能的，但通常在JavaScript中这是一个麻烦，大多数程序员甚至不会费心，或者使用具有非标准语义的第三方库。
- en: 'In this example you can see how CoffeeScript makes object inheritance elegant:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以看到CoffeeScript如何使对象继承优雅：
- en: '**CoffeeScript:**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript：**'
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**JavaScript:**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript：**'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example does not contain all the JavaScript code that will be generated
    by the compiler, but has enough to highlight the interesting parts. The `extends`
    operator is used to set up the inheritance chain between two objects and their
    constructors. Notice how much simpler the call to the parent class becomes with
    `super`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不包含编译器将生成的所有JavaScript代码，但足以突出有趣的部分。`extends`运算符用于在两个对象及其构造函数之间建立继承链。请注意，使用`super`调用父类变得简单得多。
- en: As you can see, `@odometer` was translated to `this.odometer`. The `@` symbol
    is just a shortcut for `this`. We'll talk about it further on in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`@odometer`被翻译为`this.odometer`。`@`符号只是`this`的快捷方式。我们将在本章后面进一步讨论它。
- en: Overwhelmed?
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不知所措？
- en: The `class` syntax is, in my opinion, where you'll find the greatest difference
    between CoffeeScript and its compiled JavaScript. However, most of the time it
    just works and once you understand it you'll rarely have to worry about the details.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的看来，`class`语法是CoffeeScript和它编译的JavaScript之间最大的区别。然而，大多数时候它只是起作用，一旦您理解它，您很少需要担心细节。
- en: Extending prototypes
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展原型
- en: 'If you''re an experienced JavaScript programmer who still likes to do all of
    this yourself, you don''t need to use `class`. CoffeeScript still provides the
    helpful shortcut to get at prototypes through the `::` symbol, which will be replaced
    by `.prototype` in the generated JavaScript, as shown in the following code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一位有经验的JavaScript程序员，仍然喜欢自己完成所有这些工作，您不需要使用`class`。CoffeeScript仍然提供了一个有用的快捷方式，通过`::`符号可以访问原型，在生成的JavaScript中将被替换为`.prototype`，如下面的代码片段所示：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A few other things CoffeeScript fixes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoffeeScript修复的其他一些问题
- en: JavaScript has lots of other small annoyances that CoffeeScript makes nicer.
    Let's have a look at some of these.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还有许多其他小的烦恼，CoffeeScript使得它们更加美好。让我们来看看其中一些。
- en: Reserved words and object syntax
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留字和对象语法
- en: Often in JavaScript, you will need to make use of a reserved word, or a keyword
    that is used by JavaScript. This often happens with keys for literal objects as
    data in JavaScript, like `class` or `for`, which you then need to enclose in quotes.
    CoffeeScript will automatically quote reserved words for you, and generally you
    don't even need to worry about it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中经常需要使用保留字或关键字。这经常发生在JavaScript中作为数据的文字对象的键，比如`class`或`for`，然后您需要将其括在引号中。CoffeeScript会自动为您引用保留字，通常您甚至不需要担心它。
- en: '| CoffeeScript | JavaScript |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Notice that we don't need the braces to create object literals and can use indentation
    here as well. While using this style, as long as there is only one property per
    line, we can drop the trailing commas too.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要大括号来创建对象文字，这里也可以使用缩进。在使用这种风格时，只要每行只有一个属性，我们也可以省略尾随逗号。
- en: 'We can also write array literals in this way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以这种方式编写数组文字：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'These features combined make writing JSON a breeze. Compare the following samples
    to see the difference:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性结合在一起使得编写JSON变得轻而易举。比较以下示例以查看差异：
- en: '**CoffeeScript:**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript：**'
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**JavaScript:**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript：**'
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: String concatenation
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接
- en: For a language that deals with a lot of strings, JavaScript has always been
    pretty bad at building strings up from parts. Variables and expression values
    are often meant to be inserted inside a string somewhere, and this is usually
    done by concatenation using the `+` operator. If you've ever tried concatenating
    a couple of variables in a string, you'll know this soon becomes burdensome and
    hard to read.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个处理大量字符串的语言来说，JavaScript一直在从部分构建字符串方面表现得相当糟糕。变量和表达式值通常需要插入到字符串的某个位置，通常通过使用`+`运算符进行连接。如果您曾经尝试在字符串中连接几个变量，您会知道这很快变得繁琐且难以阅读。
- en: 'CoffeeScript has a built-in string interpolation syntax, which is similar to
    many other scripting languages, but was specifically borrowed from Ruby. This
    is shown in the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript具有内置的字符串插值语法，类似于许多其他脚本语言，但是专门从Ruby中借鉴而来。这在下面的代码片段中显示：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You can write any expression within `#{}` and its string value will be concatenated.
    Note that you can only use string interpolation in double-quoted strings, `""`.
    Single-quoted strings are literal and will be represented exactly how they are.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`#{}`中写入任何表达式，其字符串值将被连接。请注意，您只能在双引号`""`中使用字符串插值。单引号字符串是文字的，将被准确表示。
- en: Equality
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等
- en: The equality operator `==` (and its inverse `!=`) in JavaScript is fraught with
    dangers, and a lot of times doesn't do what you would expect. This is because
    it will first try to coerce objects of a different type to be the same before
    comparing them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，等号运算符`==`（及其反向`!=`）充满了危险，很多时候并不会做你期望的事情。这是因为它首先会尝试强制将不同类型的对象在比较之前变成相同的。
- en: 'It''s also not transitive, meaning it might return different values of `true`
    or `false` depending on if a type is on the left or right of the operator. Please
    refer to the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它也不是传递的，这意味着它可能根据操作符的左侧或右侧的类型返回不同的`true`或`false`值。请参考以下代码片段：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because of its inconsistent and strange behavior, respected members in the JavaScript
    community advise avoiding it altogether and to rather use the identity operator,
    `===` in its place. This operator will always return `false` if two objects are
    of a different type, which is consistent to how `==` works in many other languages.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其不一致和奇怪的行为，JavaScript社区中受尊敬的成员建议完全避免使用它，而是使用身份运算符`===`来代替。如果两个对象的类型不同，这个运算符将始终返回`false`，这与许多其他语言中`==`的工作方式一致。
- en: 'CoffeeScript will always convert `==` to `===` and `!=` to `!===`, as shown
    in the following implementation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript将始终将`==`转换为`===`，将`!=`转换为`!==`，如下所示：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The existential operator
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在运算符
- en: 'When you''re trying to check if a variable exists and has a value (is not `null`
    or `undefined`) in JavaScript, you need to use this quirky idiom:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要检查一个变量是否存在并且有值（不是`null`或`undefined`）时，你需要使用这种古怪的习惯用法：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: CoffeeScript has a nice shortcut for this, the existential operator `?`, which
    will return `false` unless a variable is `undefined` or `null`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 为此提供了一个很好的快捷方式，即存在运算符`?`，它会在变量不是`undefined`或`null`时返回`false`。
- en: '| CoffeeScript | JavaScript |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In this example, since the compiler already knows that broccoli is defined,
    the `?` operator will only check if it has a `null` value, while it will check
    if `carrots` is `undefined` as well as `null`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于编译器已经知道`broccoli`是定义的，`?`运算符只会检查它是否有`null`值，而它将检查`carrots`是否`undefined`以及`null`。
- en: 'The existential operator has a method call variant: `?.` or just the "soak",
    which will allow you to swallow the method calls on `null` objects in a method
    chain, as shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 存在运算符还有一个方法调用变体：`?.`或者称为"soak"，它允许你在方法链中吞掉`null`对象上的方法调用，如下所示：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If all of the values in the chain exist, you should get the expected result.
    If any of them should be `null` or `undefined`, you will get an undefined value,
    instead of `TypeError` being thrown.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链中的所有值都存在，你应该得到预期的结果。如果它们中的任何一个应该是`null`或`undefined`，你将得到一个未定义的值，而不是抛出`TypeError`。
- en: Although this is a powerful technique, it can also be easily abused and make
    the code hard to reason with. If you have long method chains it may become hard
    to know just exactly where the null or undefined value came from.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一种强大的技术，但它也很容易被滥用，并且使代码难以理解。如果你有很长的方法链，可能很难知道`null`或`undefined`值究竟来自哪里。
- en: 'The **Law of Demeter** , a well-known object orientation design principle,
    can be used to minimize this kind of complexity and improve decoupling in your
    code. It can be summarized as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**迪米特法则**，一个众所周知的面向对象设计原则，可以用来最小化这种复杂性，并改善代码中的解耦。它可以总结如下：'
- en: Your method can call other methods in its class directly
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的方法可以直接调用其类中的其他方法
- en: Your method can call methods on its own fields directly (but not on the fields'
    fields)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的方法可以直接调用自己字段上的方法（但不能调用字段的字段）
- en: When your method takes parameters, your method can call methods on those parameters
    directly
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的方法带有参数时，你的方法可以直接调用这些参数上的方法
- en: When your method creates local objects, that method can call methods on the
    local objects
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的方法创建本地对象时，该方法可以直接调用本地对象上的方法
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although, this is not a "strict law" in the sense that it should never be broken,
    it is more analogous to the law of nature, such that the code that tends to follow
    it also tends to be much simpler and more loosely coupled.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是严格的法则，不应该被打破，但更类似于自然法则，使得遵循它的代码也更简单和更松散耦合。
- en: Now that we have spent some time going over some of the inadequacies and annoyances
    of JavaScript that CoffeeScript fixes, let's dwell on some of the other powerful
    features that CoffeeScript adds; some borrowed from other scripting languages
    and some that are unique to the language.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经花了一些时间来讨论CoffeeScript修复了JavaScript的一些不足和烦恼，让我们再来看看CoffeeScript添加的一些其他强大功能；一些是从其他脚本语言借鉴的，一些是这种语言独有的。
- en: List comprehensions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导
- en: In CoffeeScript, looping through collections works quite differently from JavaScript's
    imperative approach. CoffeeScript takes ideas from functional programming languages
    and uses list comprehensions to transform lists instead of looping through elements
    iteratively.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在CoffeeScript中，遍历集合的方式与JavaScript的命令式方法有很大不同。CoffeeScript借鉴了函数式编程语言的思想，并使用列表推导来转换列表，而不是迭代地遍历元素。
- en: The while loop
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while循环
- en: 'The `while` loop is still present and works more or less the same, except that
    it can be used as an expression, meaning it will return an array of values:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环仍然存在，工作方式差不多，只是它可以作为表达式使用，意味着它将返回一个值的数组：'
- en: '**CoffeeScript:**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript:**'
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**JavaScript:**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript:**'
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that in the previous code, the `while` body goes in front of the condition.
    This is a common idiom in CoffeeScript if the body is of only one line. You can
    do the same thing with `if` statements and list comprehensions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，`while`循环体放在条件的前面。这是CoffeeScript中的一个常见习惯，如果循环体只有一行。你也可以在`if`语句和列表推导中做同样的事情。
- en: 'We can improve the readability of the previous code slightly by using the `until`
    keyword, which is basically the negation of `while`, as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`until`关键字稍微改善前面代码的可读性，它基本上是`while`的否定，如下所示：
- en: '**CoffeeScript:**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript:**'
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**JavaScript:**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript:**'
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `for` statement doesn''t work like it does in JavaScript. CoffeeScript
    replaces it with list comprehensions, which were mostly borrowed from the Python
    language and also very similar to constructs that you''ll find in functional languages
    such as Haskell. Comprehensions provide a more declarative way of filtering, transforming,
    and aggregating collections or performing an action for each element. The best
    way to illustrate them would be through some examples:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句不像在JavaScript中那样工作。CoffeeScript用列表推导式替换它，这主要是从Python语言借鉴来的，也非常类似于您在函数式语言（如Haskell）中找到的构造。推导式提供了一种更声明性的方式来过滤、转换和聚合集合，或者对每个元素执行操作。最好的方法是通过一些示例来说明它们：'
- en: '**CoffeeScript:**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript:**'
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**JavaScript:**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript:**'
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Although they are quite simple, comprehensions have a very condensed form and
    do a lot in very little code. Let''s break it down to its separate parts:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们非常简单，但推导式具有非常紧凑的形式，并且在非常少的代码中完成了很多工作。让我们将其分解为单独的部分：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Comprehensions are best read from right to left, starting from the `in` collection.
    The `selector` name is a temporary name that is given to each element as we iterate
    through the collection. The clause in front of the `for` keyword describes what
    you want to do with the `selector` name, by either calling a method with it as
    an argument, selecting a property or method on it, or assigning a value.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 理解推导式最好从右向左阅读，从`in`集合开始。`selector`名称是一个临时名称，它在我们遍历集合时赋予每个元素。在`for`关键字前面的子句描述了您希望对`selector`名称执行的操作，可以通过调用带有它作为参数的方法、选择其上的属性或方法，或者赋值来实现。
- en: The `when` and `by` guard clauses are optional. They describe how the iteration
    should be filtered (elements will only be returned when their subsequent `when`
    condition is `true`), or which parts of the collection to select using `by` followed
    by a number. For example, `by 2` will return every evenly numbered element.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`和`by`保护子句是可选的。它们描述了迭代应该如何被过滤（仅当后续的`when`条件为`true`时才会返回元素），或者使用`by`后跟一个数字来选择集合的哪些部分。例如，`by
    2`将返回每个偶数编号的元素。'
- en: 'We can rewrite our `multiplesOf` function by using `by` and `when`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`by`和`when`来重写我们的`multiplesOf`函数：
- en: '**CoffeeScript:**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript:**'
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**JavaScript:**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript:**'
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `[0..n*times]` syntax is CoffeeScripts's range syntax, which was borrowed
    from Ruby. It will create an array with all the elements between the first and
    last number. When the range has two dots it will be inclusive, meaning the range
    will contain the specified start and end element. If it has three dots (`…`),
    it will only contain the numbers in between.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`[0..n*times]`语法是CoffeeScripts的范围语法，它是从Ruby中借鉴来的。它将创建一个包含第一个和最后一个数字之间所有元素的数组。当范围有两个点时，它将是包容的，这意味着范围将包含指定的起始和结束元素。如果有三个点（`…`），它将只包含其中的数字。'
- en: List comprehensions were one of the biggest new concepts to grasp when I started
    learning CoffeeScript. They are an extremely powerful feature, but it does take
    some time to get used to and think in comprehensions. Whenever you feel tempted
    to write a looping construct using the lower level `while`, consider using a comprehension
    instead. They provide just about everything you could possibly need when working
    with collections, and they are extremely fast compared to built-in ECMAScript
    array methods, such as `.map()` and `.select()`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始学习CoffeeScript时，推导式是我需要掌握的最大的新概念之一。它们是一个非常强大的特性，但确实需要一些时间来习惯和思考推导式。每当您感到想要使用较低级别的`while`编写循环结构时，请考虑改用推导式。它们几乎提供了您在处理集合时可能需要的一切，而且与内置的ECMAScript数组方法（如`.map()`和`.select()`）相比，它们非常快速。
- en: 'You can use comprehensions to loop through key-value pairs in an object, using
    the `of` keyword, as shown in the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用推导式来循环遍历对象中的键值对，使用`of`关键字，如下面的代码所示：
- en: '**CoffeeScript:**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript:**'
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**JavaScript:**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript:**'
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Conditional clauses and logical aliases
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件子句和逻辑别名
- en: CoffeeScript introduces some very nice logic and conditional features, some
    also borrowed from other scripting languages. The `unless` keyword is the inverse
    of the `if` keyword; `if` and `unless` can take the postfix form, meaning statements
    can go at the end of the line.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript引入了一些非常好的逻辑和条件特性，有些也是从其他脚本语言借鉴来的。`unless`关键字是`if`关键字的反义词；`if`和`unless`可以采用后缀形式，这意味着语句可以放在行的末尾。
- en: 'CoffeeScript also provides plain English aliases for some of the logical operators.
    They are as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript还为一些逻辑运算符提供了纯英语别名。它们如下：
- en: '`is` for `==`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is` 用于 `==`'
- en: '`isnt` for `!=`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isnt` 用于 `!=`'
- en: '`not` for `!`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not` 用于 `!`'
- en: '`and` for `&&`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`和` 用于 `&&`'
- en: '`or` for `||`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or` 用于 `||`'
- en: '`true` can also be `yes`, or `on`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`也可以是`yes`或`on`'
- en: '`false` can be `no` or `off`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`可以是`no`或`off`'
- en: 'Putting all this together, let''s look at some code to demonstrate it:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，让我们看一些代码来演示它：
- en: '**CoffeeScript:**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript:**'
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**JavaScript:**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript:**'
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Array slicing and splicing
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组切片和拼接
- en: CoffeeScript allows you to easily extract parts of an array using the `..` and
    `...` notation. `[n..m]` will select all the elements including `n` and `m`, whereas
    `[n…m]` will select only the elements between `n` and `m`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript允许您使用`..`和`...`符号轻松提取数组的部分。`[n..m]`将选择包括`n`和`m`在内的所有元素，而`[n…m]`将仅选择`n`和`m`之间的元素。
- en: 'Both `[..]` and `[…]` will select the whole array. These are used in the following
    code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`[..]`和`[…]`都将选择整个数组。这些在以下代码中使用：'
- en: '| CoffeeScript | JavaScript |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'CoffeeScript sure loves its ellipses. They are used by splats, ranges, and
    array slices. Here are some quick tips on how to identify them: If the `…` is
    next to the last argument in a function definition or a function call, it''s a
    splat. If it''s enclosed in square brackets that are not indexing an array, it''s
    a range. If it is indexing an array, it''s a slice.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript确实喜欢它的省略号。它们被用于splat、范围和数组切片。以下是一些关于如何识别它们的快速提示：如果`…`紧挨着函数定义或函数调用中的最后一个参数，那么它是splat。如果它被包含在不索引数组的方括号中，那么它是范围。如果它索引一个数组，那么它是切片。
- en: Destructuring or pattern matching
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构或模式匹配
- en: '**Destructuring** is a powerful concept that you''ll find in many functional
    programming languages. In essence, it allows you to pull single values from complex
    objects. It can simply allow you to assign multiple values at once, or deal with
    functions that return multiple values; as shown here:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**解构**是许多函数式编程语言中的一个强大概念。实质上，它允许您从复杂对象中提取单个值。它可以简单地允许您一次分配多个值，或者处理返回多个值的函数；如下所示：'
- en: '**CoffeeScript:**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript：**'
- en: '[PRE50]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**JavaScript:**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript：**'
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When you run this, you get three variables, `city`, `state`, and `country` with
    values that were assigned from the corresponding element in the array returned
    by the `getLocation` function.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，您将获得三个变量，`city`，`state`和`country`，它们的值是从`getLocation`函数返回的数组中的相应元素分配的。
- en: 'You can use destructuring to pull out values from objects and hashes as well.
    There are no limits to how deeply data in the object can be nested. Here is an
    example of that:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用解构从对象和哈希中提取值。对象中的数据可以嵌套到任意深度。以下是一个示例：
- en: '**CoffeeScript:**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript：**'
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**JavaScript:**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript：**'
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this example, the `{address: {street: ---}}` part describes your pattern,
    basically where to find the information you need. When we put the `myStreet` variable
    inside our pattern, we tell CoffeeScript to assign the value in that place to
    `myStreet`. While we can use nested objects, we can also mix and match destructuring
    objects and arrays, as shown in the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，`{address: {street: ---}}`部分描述了您的模式，基本上是要找到您需要的信息。当我们将`myStreet`变量放入我们的模式中时，我们告诉CoffeeScript将该位置的值分配给`myStreet`。虽然我们可以使用嵌套对象，但我们也可以混合和匹配解构对象和数组，如下面的代码所示：'
- en: '**CoffeeScript:**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript：**'
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**JavaScript:**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript：**'
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, in the previous code, we are pulling elements from the array value that
    we get from `addressLines` and give them names.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从`addressLines`获取的数组值中提取元素并为它们命名。
- en: => and @
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: => 和 @
- en: In JavaScript, the value of `this` refers to the owner of the currently executing
    function, or the object that the function is a method of. Unlike in other object-oriented
    languages, JavaScript also has the notion that functions are not tightly bound
    to objects, meaning that the value of this can be changed at will (or accidently).
    This is a very powerful feature of the language but can also lead to confusion
    if used incorrectly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`this`的值指的是当前执行函数的所有者，或者函数是其方法的对象。与其他面向对象的语言不同，JavaScript还有一个概念，即函数与对象没有紧密绑定，这意味着`this`的值可以随意更改（或者意外更改）。这是语言的一个非常强大的特性，但如果使用不正确也会导致混淆。
- en: In CoffeeScript, the `@` symbol is a shortcut for `this`. Whenever the compiler
    sees something like `@foo`, it will replace it with `this.foo`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在CoffeeScript中，`@`符号是`this`的快捷方式。每当编译器看到类似`@foo`的东西时，它将用`this.foo`替换它。
- en: Although it's still possible to use this in CoffeeScript, it's generally frowned
    upon and more idiomatic to use `@` instead.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在CoffeeScript中仍然可以使用这个，但通常不鼓励这样做，更符合习惯的是使用`@`代替。
- en: In any JavaScript function, the value of `this` is the object that the function
    is attached to. However, when you pass functions to other functions or reattach
    a function to another object, the value of `this` will change. Sometimes this
    is what you want, but often you would like to keep the original value of `this`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何JavaScript函数中，`this`的值是函数附加到的对象。但是，当您将函数传递给其他函数或重新将函数附加到另一个对象时，`this`的值将发生变化。有时这是您想要的，但通常您希望保留`this`的原始值。
- en: For this purpose, CoffeeScript provides the `=>`, or fat arrow, which will define
    a function but at the same time capture the value of `this`, so that the function
    can be safely called in any context. This is especially useful when using callbacks,
    for instance in a jQuery event handler.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，CoffeeScript提供了`=>`，或者fat箭头，它将定义一个函数，但同时捕获`this`的值，以便函数可以在任何上下文中安全调用。在使用回调时特别有用，例如在jQuery事件处理程序中。
- en: 'The following example will illustrate the idea:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将说明这个想法：
- en: '**CoffeeScript:**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript：**'
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**JavaScript:**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript：**'
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Notice that the `prepare` function on the `birthday` class takes an `action`
    function as an argument, to be called when the birthday occurs. Because we're
    passing this function using the fat arrow, it will have its scope fixed to the
    `Person` object. This means we can still refer to the `@name` instance variable
    even though it doesn't exist on the `Birthday` object that runs the function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`birthday`类上的`prepare`函数将`action`函数作为参数传递，以便在生日发生时调用。因为我们使用fat箭头传递这个函数，它的作用域将固定在`Person`对象上。这意味着我们仍然可以引用`@name`实例变量，即使它不存在于运行函数的`Birthday`对象上。
- en: Switch statements
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Switch语句
- en: In CoffeeScript, `switch` statements take a different form, and look a lot less
    like JavaScript's Java-inspired syntax, and a lot more like Ruby's `case` statement.
    You don't need to call `break` to avoid falling through to the next `case` condition.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在CoffeeScript中，`switch`语句采用不同的形式，看起来不太像JavaScript的受Java启发的语法，更像Ruby的`case`语句。您不需要调用`break`来避免掉入下一个`case`条件。
- en: 'They have the following form:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的形式如下：
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, `else` is the default case.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`else`是默认情况。
- en: Like everything else in CoffeeScript, they are expressions, and this can be
    assigned to a value.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与CoffeeScript中的其他所有内容一样，它们都是表达式，可以分配给一个值。
- en: 'Let''s look at an example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '**CoffeeScript:**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript：**'
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**JavaScript:**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript：**'
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: CoffeeScript doesn't force you to add a default `else` clause, although it is
    a good programming practice to always add one, just in case.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript不强制您添加默认的`else`子句，尽管始终添加一个是一个很好的编程实践，以防万一。
- en: Chained comparisons
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式比较
- en: 'CoffeeScript borrowed chained comparisons from Python. These basically allow
    you to write greater than or less than comparisons like you would in mathematics,
    as shown here:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript从Python借用了链式比较。这基本上允许您像在数学中那样编写大于或小于的比较，如下所示：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Block strings, block comments, and strings
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块字符串，块注释和字符串
- en: Most programming books start with comments, and I thought I would end with them.
    In CoffeeScript, single line comments start with `#`. The comments do not end
    up in your generated output. Multiline comments start and end with `###`, and
    they are included in the generated JavaScript.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程书籍都以注释开始，我想以它们结束。在CoffeeScript中，单行注释以`#`开头。这些注释不会出现在生成的输出中。多行注释以`###`开头和结尾，并包含在生成的JavaScript中。
- en: You can span a string over multiple lines using the `"""` triple quote to enclose
    it.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`"""`三重引号将字符串跨越多行。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started looking at CoffeeScript from JavaScript's perspective.
    We saw how it can help you write shorter, cleaner, and more elegant code than
    you normally would in JavaScript and avoid many of its pitfalls.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从JavaScript的角度开始了解CoffeeScript。我们看到它如何帮助你编写比在JavaScript中更短、更清晰、更优雅的代码，并避免许多它的缺陷。
- en: We came to realize that even though CoffeeScripts' syntax seems to be quite
    different from JavaScript, it actually maps pretty closely to its generated output.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到，尽管CoffeeScript的语法看起来与JavaScript有很大不同，但实际上它与生成的输出非常接近。
- en: Later on, we delved into some of CoffeeScripts' unique and wonderful additions,
    like list comprehensions, destructuring assignment, and its class syntax, as well
    as many more convenient and powerful features such as string interpolation, ranges,
    splats, and array slicing.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们深入了解了一些CoffeeScript独特和精彩的功能，比如列表推导、解构赋值和类语法，以及许多方便和强大的功能，比如字符串插值、范围、扩展和数组切片。
- en: My goal in this chapter was to convince you that CoffeeScript is a superior
    alternative to JavaScript, and I have tried to do so by showing the differences
    between them. Although I have previously said "it's just JavaScript", I hope that
    you'll appreciate that CoffeeScript is a wonderful and modern language in its
    own right, with brilliant influences from other great scripting languages.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章的目标是说服你，CoffeeScript是JavaScript的一个更优秀的替代品，并通过展示它们之间的差异来尝试做到这一点。尽管我之前说过"它只是JavaScript"，我希望你能欣赏到CoffeeScript是一门独立的、现代的语言，受到其他伟大脚本语言的影响。
- en: I can still write a great deal about the beauty of the language, but I feel
    that we have reached the point where we can dive into some real world CoffeeScript
    and get to appreciate it "in the wild", so to speak.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然可以写很多关于这门语言之美的东西，但我觉得我们已经到了可以深入了解一些真实世界的CoffeeScript并欣赏它的时候了。
- en: So, are you ready? Let's get started then and get CoffeeScript installed.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你准备好了吗？让我们开始吧，安装CoffeeScript。
