- en: Chapter 6. Accelerating Development with Express
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用Express加速开发
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Generating Express scaffolding
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成Express脚手架
- en: Defining and applying environments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和应用环境
- en: Dynamic routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路由
- en: Templating in Express
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express中的模板
- en: CSS engines with Express
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express中的CSS引擎
- en: Initializing and using a session
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化和使用会话
- en: Making an Express web app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Express Web应用程序
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As excellent as Node's HTTP module is, Express repackages and streamlines its
    functionality to provide us with a fluid interface that makes for almost frictionless
    rapid web development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Node的HTTP模块非常出色，但Express重新打包和简化了其功能，为我们提供了一个流畅的接口，几乎没有摩擦的快速Web开发。
- en: In this chapter, we will progress from generating a vanilla Express project
    base to a fully-fledged Express web-application foundation with MongoDB providing
    backend data support.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从生成一个普通的Express项目基础开始，到一个完整的Express Web应用程序基础，MongoDB提供后端数据支持。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: Throughout this chapter there are helpful boxes, like this one, that demonstrate
    how to migrate code from Express 2 to Express 3\. The supporting code files contain
    both Express 2 and 3 code (with 3 commented out). Code files can be downloaded
    from [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，有一些有用的提示框，比如这个，演示了如何将代码从Express 2迁移到Express 3。支持代码文件包含了Express 2和3的代码（3被注释掉）。代码文件可以从[http://www.packtpub.com/support](http://www.packtpub.com/support)下载。
- en: Generating Express scaffolding
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成Express脚手架
- en: Express works both as a Node module and as a command-line executable. When we
    run `express` from the command line it generates a project skeleton for us, accelerating
    the preparation process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Express既可以作为一个Node模块，也可以作为一个命令行可执行文件。当我们从命令行运行`express`时，它会为我们生成一个项目骨架，加快准备过程。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to install `express` using the `-g` flag (install globally) in order
    to run the `express` executable from any directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`-g`标志（全局安装）来安装`express`，以便从任何目录运行`express`可执行文件。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use `sudo` to ensure we get permission to install globally. This doesn't
    apply under Windows.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sudo`来确保我们获得全局安装的权限。这在Windows下不适用。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we decide upon the name of our app. Let''s call it `nca` (Node Cookbook
    App) and simply do:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们决定我们应用的名称。让我们称之为`nca`（Node Cookbook App），然后简单地执行：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will generate all of our project files under a new directory called `nca`.
    Before we can run our app, we must ensure that all dependencies are installed.
    We can find app dependencies in `nca/package.json:`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在一个名为`nca`的新目录下生成所有项目文件。在我们运行应用之前，我们必须确保所有依赖项都已安装。我们可以在`nca/package.json`中找到应用的依赖项：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For portability, it''s important to have relevant modules installed within
    the `project` folder. To achieve this, we simply use the command line to `cd`
    into the `nca` directory and say:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可移植性，重要的是在`project`文件夹中安装相关模块。为了实现这一点，我们只需在命令行中`cd`进入`nca`目录，然后输入：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will make a new `node_modules` directory in our `project` folder, holding
    all dependencies.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的`project`文件夹中创建一个新的`node_modules`目录，其中包含所有的依赖项。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we run the `express` executable, it creates a folder structure that's suited
    to Express development. In the project root, we have `app.js` and `package.json`
    files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`express`可执行文件时，它会创建一个适合Express开发的文件夹结构。在项目根目录中，我们有`app.js`和`package.json`文件。
- en: '`package.json` is a convention established by the CommonJS group (a Javascript
    standards community), and has become the established method for describing modules
    and applications in Node.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`是由CommonJS组（一个Javascript标准社区）建立的约定，并已成为描述Node中模块和应用的已建立方法。'
- en: The `npm install` command parses the dependencies from `package.json`, installing
    them locally in the `node_modules` folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install`命令从`package.json`中解析依赖项，在`node_modules`文件夹中本地安装它们。'
- en: This is significant because it ensures stability. Node's `require` function
    looks for a `node_modules` folder in the current working directory before searching
    parent directories. If we upgrade any modules in a parent directory, our project
    will continue to use the same version it was built upon. Installing modules locally
    allows us to distribute our project along with its dependencies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为它确保了稳定性。Node的`require`函数在搜索父目录之前会在当前工作目录中寻找`node_modules`文件夹。如果我们在父目录中升级任何模块，我们的项目将继续使用构建时的相同版本。本地安装模块允许我们将项目与其依赖项一起分发。
- en: 'The `app.js` file is our project boilerplate. We run our app with:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js`文件是我们项目的样板。我们用以下命令运行我们的应用：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `express` executable adds three subdirectories to the project folder: `public,
    routes` and `views`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`express`可执行文件将三个子目录添加到项目文件夹中：`public, routes`和`views`。'
- en: '`public` is the default folder that `app.js` passes to the `express.static`
    method, all our static files go here. It contains `images, javascripts`, and `stylesheets`
    folders each for their own self-evident purpose.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`是`app.js`传递给`express.static`方法的默认文件夹，所有静态文件都放在这里。它包含`images, javascripts`和`stylesheets`文件夹，每个文件夹都有自己明显的目的。'
- en: The `routes` folder holds `index.js` which is required by `app.js`. To define
    our routes, we push them onto Node's `exports` object (which we'll learn more
    about In [Chapter 9](ch09.html "Chapter 9. Writing Your Own Node Modules"), *Writing
    Your Own Node Modules)*. Using `routes/index.js` helps to avoid clutter in `app.js`,
    and separates server code from route code. This way we can focus purely on our
    server, or purely on our routes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`文件夹包含`index.js`，被`app.js`所需。为了定义我们的路由，我们将它们推送到Node的`exports`对象上（我们将在[第9章](ch09.html
    "第9章.编写自己的Node模块")中学到更多关于*编写自己的Node模块*）。使用`routes/index.js`有助于避免`app.js`中的混乱，并将服务器代码与路由代码分开。这样我们可以纯粹地专注于我们的服务器，或者纯粹地专注于我们的路由。'
- en: Finally, `views` hold template files, which can really help with development
    acceleration. We'll be finding out how to work with views in the *Templating in
    Express* recipe.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`views`包含模板文件，这可以真正帮助加速开发。我们将在*Express中的模板*中了解如何处理视图。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's take a few moments to go deeper into our generated project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一些时间深入了解我们生成的项目。
- en: Picking apart app.js
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析app.js
- en: 'Let''s take a look at our generated `app.js` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们生成的“app.js”文件：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `app` variable holds the result of `express.createServer`, which is essentially
    an enhanced `http.createServer`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “app”变量保存了“express.createServer”的结果，这实质上是一个增强的“http.createServer”。
- en: 'The `configure` method is invoked three times: once for global settings, once
    for production, and once for development. We''ll be looking at production and
    development in greater detail in the next recipe.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: “configure”方法被调用了三次：一次用于全局设置，一次用于生产环境，一次用于开发环境。我们将在下一个示例中更详细地查看生产环境和开发环境。
- en: Within the global `configure` callback, the default view directory (`views`)
    and engine (`jade`) are `set`, and the `app` is told to `use express.bodyParser,
    express.methodOverride, app.router`, and `express.static` middleware.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局“configure”回调中，设置了默认的视图目录（“views”）和引擎（“jade”），并告诉“app”使用“express.bodyParser,
    express.methodOverride, app.router”和“express.static”中间件。
- en: '`bodyParser` made a brief appearance In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"), *Exploring the HTTP Object*, in the first recipe''s *There''s
    more..*. section, in the form of `connect.bodyParser`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “bodyParser”在[第2章](ch02.html "第2章。探索HTTP对象")*探索HTTP对象*的第一个示例的*还有更多..*部分中简要出现，以“connect.bodyParser”的形式。
- en: Express includes all the standard Connect middleware, and is compatible with
    add-on Connect middleware. Therefore, in an Express project, `bodyParser` is loaded
    with `express.bodyParser. bodyParser` gives us access to any data sent from the
    client (like in a POST request).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Express包含所有标准的Connect中间件，并兼容附加的Connect中间件。因此，在Express项目中，使用“express.bodyParser”加载“bodyParser”。bodyParser使我们能够访问从客户端发送的任何数据（例如在POST请求中）。
- en: '`methodOverride` allows us to make pseudo `DELETE` and `PUT` requests from
    browser forms using a hidden input element called `_method`. For example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “methodOverride”允许我们使用名为“_method”的隐藏输入元素从浏览器表单中进行伪“DELETE”和“PUT”请求。例如：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are many HTTP methods defined in the Hypertext Transfer Protocol documents
    (see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)).
    However, browsers have typically only supported GET and POST, leaving other methods
    up to purpose built clients. Express works around lack of browser support using
    this hidden input to emulate a `DELETE` request while also supporting real DELETE
    requests from clients that do support the method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在超文本传输协议文档中定义了许多HTTP方法（参见[http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)）。然而，浏览器通常只支持GET和POST，其他方法留给特定客户端支持。Express通过使用隐藏输入来模拟“DELETE”请求来解决浏览器支持不足的问题，同时还支持来自支持该方法的客户端的真实DELETE请求。
- en: '`app.router` contains all the defined routes (anything passed to `app.get,
    app.post`, and so on). Routes are, in themselves, middleware. If `app.router`
    is not passed to `app.use`, the routes are automatically appended to the middleware
    stack. However, with manual inclusion we have the ability to place additional
    middleware after the `app.router` middleware.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “app.router”包含了所有定义的路由（传递给“app.get, app.post”等）。路由本身就是中间件。如果没有将“app.router”传递给“app.use”，则路由将自动附加到中间件堆栈。但是，通过手动包含，我们可以在“app.router”中间件之后放置其他中间件。
- en: 'Middleware is generally constructed as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件通常构造如下：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `next` parameter is a sort of callback mechanism which loads any ensuing
    middleware. So when `app.router` is positioned above `express.static`, any dynamic
    routes accessed by a client will not unnecessarily trigger the static server to
    look for the non-existent file, unless those routes call `next` (alternatively,
    `next` can be called as a method of `req: req.next())`. For more information on
    middleware, see [http://www.expressjs.com/guide.html#middleware](http://www.expressjs.com/guide.html#middleware).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '“next”参数是一种回调机制，它加载任何随后的中间件。因此，当“app.router”位于“express.static”之上时，客户端访问的任何动态路由都不会不必要地触发静态服务器去寻找不存在的文件，除非这些路由调用“next”（或者可以将“next”作为“req:
    req.next()”的方法调用）。有关中间件的更多信息，请参阅[http://www.expressjs.com/guide.html#middleware](http://www.expressjs.com/guide.html#middleware)。'
- en: Looking into routes/index.js
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看routes/index.js
- en: In `app.js, routes/index.js` is loaded with a `require:`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在“app.js, routes/index.js”中加载了一个“require:”
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that `index` isn''t specified, but if a directory is passed to `require`,
    Node will automatically look for `index.js`. Let''s take a look:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“index”没有指定，但是如果将目录传递给“require”，Node将自动查找“index.js”。让我们来看一下：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Pushing `index` onto the `exports` object makes it available in `app.js` as
    `routes.index`, which is passed to `app.get` as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将“index”推送到“exports”对象中，使其在“app.js”中作为“routes.index”可用，并将其传递给“app.get”如下：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `routes.index` function should look familiar. It follows the pattern of
    an `http.createServer` callback, but is specific to the route. The request (`req`)
    and response (`res`) parameters are enhanced by Express. We'll be looking into
    these in coming recipes. The function itself simply calls the `res.render` method,
    which loads a template from `views/index.jade`, passing `title` as a variable
    which then outputs the generated content to the client.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: “routes.index”函数应该看起来很熟悉。它遵循了“http.createServer”回调的模式，但是特定于路由。请求（“req”）和响应（“res”）参数由Express增强。我们将在接下来的示例中详细了解这些内容。该函数本身只是调用“res.render”方法，该方法从“views/index.jade”加载模板，将“title”作为变量传递，然后将生成的内容输出到客户端。
- en: See also
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Defining and applying environments* discussed in this chapter'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中讨论的*定义和应用环境*
- en: '*Dynamic routing* discussed in this chapter'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中讨论的*动态路由*
- en: '*Templating in Express* discussed in this chapter'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中讨论的*Express中的模板*
- en: Defining and applying environments
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和应用环境
- en: Development and production code have different requirements. For instance, during
    development we will most likely want a detailed error output to the client, for
    debugging purposes. In production, we protect ourselves from opportunistic exploitation
    by revealing as little internal information as possible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和生产代码有不同的要求。例如，在开发过程中，我们很可能希望向客户端输出详细的错误信息，以进行调试。在生产环境中，我们通过尽可能少地暴露内部信息来保护自己免受机会主义性的利用。
- en: Express caters to these differences with `app.configure` which allows us to
    define environments with specific settings.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Express通过`app.configure`来满足这些差异，它允许我们定义具有特定设置的环境。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need our project folder (`nca`) from the previous recipe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从上一个配方中获取我们的项目文件夹（`nca`）。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s take a look at the preconfigured environments:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看预配置的环境：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The generated file defines customized error-reporting levels for each environment.
    Let's add caching to our production server, which can be a hindrance in development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件为每个环境定义了定制的错误报告级别。让我们为我们的生产服务器添加缓存，这在开发中可能会成为障碍。
- en: 'We use `express.staticCache` to achieve this. However, it has to be called
    prior to `express.static`, so we move `express.static` from the global `configure`
    into both development and production environments, along with `staticCache` in
    production as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`express.staticCache`来实现这一点。但是，它必须在`express.static`之前调用，所以我们将`express.static`从全局`configure`中移动到开发和生产环境中，并在生产环境中加入`staticCache`，如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We also set `dumpExceptions` to true for the production `errorHandler`. This
    would allow us to quickly identify any problems that might occur once we've launched
    our app.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为生产`errorHandler`设置了`dumpExceptions`为`true`。这将使我们能够快速识别一旦启动我们的应用程序可能出现的任何问题。
- en: To use an environment, we set the special `NODE_ENV` variable on the command
    line as we are executing `node:`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个环境，我们在执行`node`时在命令行上设置特殊的`NODE_ENV`变量：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or on Windows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在Windows上：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The development environment is default, so there's no need to use `NODE_ENV`
    to set it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境是默认的，因此无需使用`NODE_ENV`来设置它。
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Express provides a very convenient way for us to separate our work flow process.
    All we have to do is pass in the name of our environment with specific settings.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Express为我们提供了一个非常方便的方法来分离我们的工作流程。我们所要做的就是传入我们的环境名称和特定设置。
- en: Under the hood, Express will be using `process.env` to determine the `NODE_ENV`
    variable, checking for a match against any defined environments. If `NODE_ENV`
    isn't set, Express defaults to loading the development environment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Express将使用`process.env`来确定`NODE_ENV`变量，检查是否与任何定义的环境匹配。如果未设置`NODE_ENV`，Express默认加载开发环境。
- en: There's more...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's look into some of the ways we can manage our environments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些管理我们环境的方法。
- en: Setting other environments
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置其他环境
- en: We could have other phases in our work flow that would benefit from specific
    settings. For instance, we may have a staging phase where we emulate as much of
    the production environment as possible on the development machine for testing
    purposes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作流程中可能有其他阶段，可以从特定设置中受益。例如，我们可能有一个分阶段，在这个阶段，我们在开发机器上尽可能模拟生产环境，以进行测试。
- en: For example, if our production server requires us to run the process on a specific
    port (say port 80), that we cannot achieve on our development server (if we do
    not have root privileges for instance), we could add a staging environment and
    set a `port` variable that is only set to `80` in a production environment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的生产服务器要求我们在特定端口上运行进程（比如端口80），而我们在开发服务器上无法实现（例如如果我们没有root权限），我们可以添加一个分阶段环境，并在生产环境中设置一个只在生产环境中设置为`80`的`port`变量。
- en: See[Chapter 10](ch10.html "Chapter 10. Taking It Live"), *Taking It Live*, for
    information on how to safely run Node on Port 80.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[第10章](ch10.html "第10章。上线")，“上线”，了解如何安全地在端口80上运行Node的信息。
- en: 'Let''s add the staging environment underneath development as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式在开发环境下添加分阶段环境：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we''ll add the port logic as shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加端口逻辑，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So our `port` is set based upon the environment, if `port` is empty we default
    to `3000`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们的`port`是根据环境设置的，如果`port`为空，我们默认为`3000`。
- en: 'We could initialize our production server with:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式初始化我们的生产服务器：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or for Windows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于Windows：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When attempting to run the server with `NODE_ENV` set to `production`, if we
    receive `TypeError: Cannot read property ''port'' of null`, it''s likely that
    a service is already running on port 80\. We would need to stop this service in
    order to test our code. For instance, if Apache is running on our system, it''s
    probably hosting through port `80`. We can stop Apache with `sudo apachectl -k
    stop` (or `net stop apache2.2` on Windows).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '当尝试使用`NODE_ENV`设置为`production`运行服务器时，如果收到`TypeError: Cannot read property ''port''
    of null`，很可能是端口80上已经运行了一个服务。我们需要停止这个服务以测试我们的代码。例如，如果Apache在我们的系统上运行，它可能是通过端口`80`进行托管。我们可以使用`sudo
    apachectl -k stop`（或者在Windows上使用`net stop apache2.2`）来停止Apache。'
- en: Changing NODE_ENV permanently
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 永久更改NODE_ENV
- en: If we are in a staging process, we may not wish to type `NODE_ENV=staging` every
    time we load our app. The same applies to production. While the server would be
    started a lot less, we would have to remember to set `NODE_ENV` when restarting.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于一个分阶段的过程中，我们可能不希望每次加载我们的应用程序时都要输入`NODE_ENV=staging`。同样的情况也适用于生产环境。虽然服务器启动的次数会少得多，但我们必须记得在重新启动时设置`NODE_ENV`。
- en: 'We can make things easier on Unix-type systems (Linux or Max OS X), with the
    `export` shell command as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类Unix系统（Linux或Max OS X）上使用`export` shell命令来简化操作，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This only sets `NODE_ENV` while our terminal is open. To make it permanent,
    we add this line to our home directory's `rc` file. The `rc` file is named depending
    upon the shell. For bash, it's located in `~/.bashrc` (where `~` is the home folder).
    Other shells, such as `sh` and `ksh`, would be `~/.shrc, ~/.kshrc`, and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这只在我们的终端打开时设置`NODE_ENV`。要使其永久生效，我们将这行添加到我们的主目录的`rc`文件中。`rc`文件的名称取决于shell。对于bash，它位于`~/.bashrc`（其中`~`是主文件夹）。其他shell，如`sh`和`ksh`，将是`~/.shrc,
    ~/.kshrc`等。
- en: 'To permanently set `NODE_ENV`, we can use:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要永久设置`NODE_ENV`，我们可以使用：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Where staging is our desired environment and bash is our shell.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，staging是我们期望的环境，bash是我们的shell。
- en: In Windows, we use `set` and `setx:`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，我们使用`set`和`setx:`
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`set` takes immediate effect, but is lost once the command prompt is closed.
    `setx` applies permanently but not until we open a new command prompt, so we use
    both.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`立即生效，但一旦命令提示符关闭就会丢失。`setx`永久应用，但直到我们打开一个新的命令提示符，所以我们两者都使用。'
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Generating Express scaffolding* discussed in this chapter'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成Express脚手架*在本章中讨论'
- en: '*Deploying to a server environment* discussed In [Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署到服务器环境*在[第10章](ch10.html "第10章。上线")中讨论，上线'
- en: '*Making an Express web app* discussed in this chapter'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*制作Express Web应用程序*在本章中讨论'
- en: '*Initializing and using a session* discussed in this chapter'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化和使用会话*在本章中讨论'
- en: Dynamic routing
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态路由
- en: In the very first recipe of this cookbook, *Setting up a router*, we explored
    various ways to set up routing in Node. Express provides a far superior and very
    powerful routing interface which we'll explore in this recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本烹饪书的第一个食谱中，*设置路由*，我们探讨了在Node中设置路由的各种方法。Express提供了一个远远优越且非常强大的路由接口，我们将在本食谱中探讨。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be working with our `nca` folder.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的`nca`文件夹。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s say we want to add a page for a fictional character by the name of Mr
    Page. We''ll name the route `page`, so in the `routes` section of `app.js` we
    add the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想为一个名为Mr Page的虚构角色添加一个页面。我们将路由命名为`page`，因此在`app.js`的`routes`部分中，我们添加以下代码：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also define flexible routes, and grab the requested route using `req.params`,
    like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义灵活的路由，并使用`req.params`来获取请求的路由，如下所示：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It''s okay to throw our callbacks directly into `app.get` while developing,
    but in the interest of a clutter-free `app.js` let''s take our callbacks and load
    them from `routes/index.js` as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，直接将回调函数放入`app.get`是可以的，但为了使`app.js`更整洁，让我们将回调函数从`routes/index.js`中加载，如下所示：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And back in our `app.js` file our routes become:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的`app.js`文件中，我们的路由变成了：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create the `/page` route using `app.get`. Then outline how we wish to respond
    to that route in the callback of `app.get`. In our example, we use `res.send`
    (an enhanced `res.write)` to output simple text. This is our inflexible dynamic
    route.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`app.get`创建了`/page`路由。然后在`app.get`的回调中概述我们希望如何响应该路由。在我们的示例中，我们使用`res.send`（增强的`res.write`）来输出简单的文本。这是我们不灵活的动态路由。
- en: Express also provides flexible route capabilities using placeholders. In the
    main recipe, we defined a `:page` placeholder. When the placeholder is filled
    in by a request (for example, `/anyPageYouLike)`, the fulfillment of the placeholder
    is added to `req.params` according to its name. So in this case `req.params.page`
    would hold `/anyPageYouLike`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Express还提供了使用占位符的灵活路由功能。在主要的示例中，我们定义了一个`:page`占位符。当请求填充占位符时（例如，`/anyPageYouLike`），占位符的实现将根据其名称添加到`req.params`中。因此，在这种情况下，`req.params.page`将保存`/anyPageYouLike`。
- en: When a user loads `localhost:3000/page` they see **Hello I am Mr Page**, when
    they access `localhost:3000/absolutelyAnythingElse` they get **Welcome to the
    absolutelyAnythingElse page**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户加载`localhost:3000/page`时，他们会看到**Hello I am Mr Page**，当他们访问`localhost:3000/absolutelyAnythingElse`时，他们会得到**Welcome
    to the absolutelyAnythingElse page**。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What other things can we do with Express routes?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Express路由还可以做哪些其他事情？
- en: Route validation
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由验证
- en: 'We can restrict flexible routes to specific character ranges using pieces of
    Regular Expression syntax, like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用正则表达式语法的部分来限制灵活路由到特定的字符范围，如下所示：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We pass a character match, `[a-zA-Z]` along with a plus (+). This will match
    the characters one or more times. As a result, we limit our `:page` parameter
    to letters only.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个字符匹配，`[a-zA-Z]`以及一个加号（+）。这将匹配一个或多个字符。因此，我们将我们的`:page`参数限制为仅包含字母。
- en: Therefore, `http://localhost:3000/moo` will give **Welcome to the moo page**,
    whereas `http://localhost:3000/moo1` will return a `404` error.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`http://localhost:3000/moo`将给出**Welcome to the moo page**，而`http://localhost:3000/moo1`将返回`404`错误。
- en: Optional routes
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选路由
- en: 'We can also define optional routes using the question mark (?):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用问号（?）来定义可选路由：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We would place this in our `app.js` file, underneath our other defined routes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个放在我们的`app.js`文件中，在我们定义的其他路由下面。
- en: 'Our `anypageAdmin` function in `routes/index.js` could go like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`routes/index.js`中的`anypageAdmin`函数可能是这样的：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We check for the existence of the `:admin` placeholder. If a route fulfills
    it, we verify that it is allowed (either add or delete) and send a tailored response.
    If the route is not allowed, we send a `404` error.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查`:admin`占位符是否存在。如果路由满足它，我们验证它是否被允许（添加或删除），并发送一个定制的响应。如果路由不被允许，我们发送一个`404`错误。
- en: While the query wildcard (`?`) can be appropriate for lots of similar routes,
    if we only had our `add` and `delete` routes and there was no possibility of adding
    more routes later, we could implement this functionality in a much cleaner way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查询通配符（`?`）可能适用于许多类似的路由，但如果我们只有我们的`add`和`delete`路由，并且没有可能以后添加更多路由，我们可以以更简洁的方式实现这个功能。
- en: 'In `app.js` we could put:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中，我们可以放置：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And in `index/routes.js:`
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index/routes.js`中：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Asterisks wildcards
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 星号通配符
- en: 'We can use the asterisks (*) as a wildcard for general matching requirements.
    For instance, let''s add the following route:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用星号（*）作为通配符来进行一般匹配。例如，让我们添加以下路由：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And change `routes.anypage` to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并将`routes.anypage`更改为以下内容：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now if we access `localhost:3000/foo/bar` we get **Welcome to the bar page of
    the foo page**, but if we just access `localhost:3000/foo` we see **Welcome to
    the foo page**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们访问`localhost:3000/foo/bar`，我们会看到**欢迎来到foo页面的bar页面**，但如果我们只访问`localhost:3000/foo`，我们会看到**欢迎来到foo页面**。
- en: 'We could also get a little wild and apply this to Mr Page''s route as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以稍微疯狂一点，将其应用到Mr Page的路由上，如下所示：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now any route containing the word `page` will get a message from **Mr Page**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何包含单词`page`的路由都将收到**Mr Page**的消息。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Setting up a router* discussed In [Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"),Making a Web Server'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第1章](ch01.html "第1章。制作Web服务器")中讨论的设置路由器*，制作Web服务器'
- en: '*Making an Express web app* discussed in this chapter'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的制作Express Web应用*'
- en: '*Templating in Express* discussed in this chapter'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的Express中的模板*'
- en: Templating in Express
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Express中使用模板
- en: A fundamental part of the Express framework is its use of views. A view is simply
    a file that holds template code. Express helps us to separate our code into operationally
    distinct concerns. We have server code in `app.js`, route-specific functionality
    in `routes/index.js`, and then we have our output generating logic in the `views`
    folder. A template language provides a basis for defining dynamic logic-driven
    content, and the template (or view) engine converts our logic into the final HTML
    which is served to the user. In this recipe, we'll use Express' default view engine,
    Jade, to process and present some data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Express框架的一个基本部分是其使用视图。视图只是保存模板代码的文件。Express帮助我们将代码分离为操作上不同的关注点。我们在`app.js`中有服务器代码，在`routes/index.js`中有特定于路由的功能，然后我们在`views`文件夹中有我们的输出生成逻辑。模板语言提供了定义动态逻辑驱动内容的基础，模板（或视图）引擎将我们的逻辑转换为最终提供给用户的HTML。在这个示例中，我们将使用Express的默认视图引擎Jade来处理和呈现一些数据。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the *There's more..*. section, we'll find out how to change the view engine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在*还有更多..*部分，我们将了解如何更改视图引擎。
- en: A list of supported template engines can be found at [https://www.github.com/visionmedia/express/wiki](https://www.github.com/visionmedia/express/wiki).
    Comparisons of various template engines can be found at [http://paularmstrong.github.com/node-templates/](http://paularmstrong.github.com/node-templates/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://www.github.com/visionmedia/express/wiki](https://www.github.com/visionmedia/express/wiki)找到支持的模板引擎列表。可以在[http://paularmstrong.github.com/node-templates/](http://paularmstrong.github.com/node-templates/)找到各种模板引擎的比较。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For our data, we'll be using the `profiles.js` object we created back in the
    first recipe of[Chapter 3](ch03.html "Chapter 3. Working with Data Serialization"),
    *Working with Data Serialization*. We'll need to copy it into the root of our
    `nca` folder.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数据，我们将使用我们在[第3章](ch03.html "第3章。与数据序列化一起工作")中创建的`profiles.js`对象。我们需要将其复制到`nca`文件夹的根目录中。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's keep it simple and strip any routes we've added to `app.js`. We just want
    our top-level route.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持简单，并删除我们添加到`app.js`的任何路由。我们只想要我们的顶级路由。
- en: Since Jade is set as the default view engine in `app.configure`, there's nothing
    else we need to do with `app.js` in this example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jade被设置为`app.configure`中的默认视图引擎，在这个示例中我们不需要在`app.js`中做其他事情。
- en: In `routes/index.js`, we'll strip all routes except for `index`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/index.js`中，我们将删除除`index`之外的所有路由。
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `res.render` method loads the Jade template in `views/index.jade`. We're
    going to use `index.jade` as a view for our `profiles.js` object data, so we need
    to make it available to our `index` view.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.render`方法加载`views/index.jade`中的Jade模板。我们将使用`index.jade`作为我们的`profiles.js`对象数据的视图，因此我们需要将其提供给我们的`index`视图。'
- en: We do this by passing it through the `options` object of `res.render:`
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将其传递给`res.render`的`options`对象来实现这一点：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice we also changed the `title` property to`'Profiles'`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还将`title`属性更改为`'Profiles'`。
- en: 'All we do now is edit `views/index.jade`. The generated `index.jade` contains
    the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需编辑`views/index.jade`。生成的`index.jade`包含以下内容：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We''re going to add a table to the page that outputs the details of each person
    in the `profiles.js` object:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在页面上添加一个表格，输出`profiles.js`对象中每个人的详细信息：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To test we start our app:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试，我们启动我们的应用程序：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And then navigate to `http://localhost:3000` to see something like the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后导航到`http://localhost:3000`，看到类似以下内容：
- en: '![How to do it...](img/7188-06-01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/7188-06-01.jpg)'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`res.render` pulls `index.jade` from the `views` folder, even though the first
    parameter is simply `index`. Express knows that a Jade file inside the `views`
    directory is intended because `app.configure` of `app.js` contains the following
    code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.render`从`views`文件夹中提取`index.jade`，即使第一个参数只是`index`。Express知道`views`目录中的Jade文件是有意的，因为`app.js`的`app.configure`包含以下代码：'
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second parameter is an object, holding two properties: `title` and `profiles`.
    These object properties become local variables within the Jade view. We output
    the variables either by return value buffering with a preceding equals (=) sign,
    or by using Jade''s interpolation, wrapping it like so: `#{title}`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个对象，包含两个属性：`title`和`profiles`。这些对象属性在Jade视图中成为局部变量。我们通过使用等号（=）符号进行返回值缓冲来输出变量，或者通过使用Jade的插值，像这样包装它：`#{title}`。
- en: Jade is a lean templating language. It uses bracket-stripped markup tags and
    has an indentation-based syntax with an alternative block expansion option (where
    we use the colon instead of an indent to signify nesting). It also has a minimal
    syntax set for defining `id` and `class` attributes using the hash (#) and dot
    (.) respectively.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Jade是一种精简的模板语言。它使用去除括号的标记和基于缩进的语法，还有一个替代块扩展选项（我们使用冒号而不是缩进来表示嵌套）。它还有一组最小的语法集，用于使用井号（#）和点（.）分别定义`id`和`class`属性。
- en: 'For instance, the following Jade:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下Jade：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Would create the following HTML:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建以下HTML：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'To learn more about the Jade language, check out its GitHub page: [https://www.github.com/visionmedia/jade](https://www.github.com/visionmedia/jade).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Jade语言的更多信息，请访问其GitHub页面：[https://www.github.com/visionmedia/jade](https://www.github.com/visionmedia/jade)。
- en: 'Jade also processes iteration logic. We used two `each` Jade iterators to pull
    the values from our `profiles` object as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Jade还处理迭代逻辑。我们使用两个`each` Jade迭代器从我们的`profiles`对象中提取值，如下所示：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code traverses the `profiles` object, loading each ID (ryan, `isaac, bert`,
    and so on) into a new `id` variable, and each object containing profile information
    into a `profile` object variable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历`profiles`对象，将每个ID（ryan, `isaac, bert`等）加载到一个新的`id`变量中，将包含配置文件信息的每个对象加载到一个`profile`对象变量中。
- en: Underneath our first `each`, we indent `tr(id=id)`. Unlike JavaScript, indentation
    in Jade is part of the logic, so getting it right is essential.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个`each`下面，我们缩进`tr(id=id)`。与JavaScript不同，Jade中的缩进是逻辑的一部分，因此正确的缩进至关重要。
- en: This tells Jade that for each profile we want to output a`<tr>` tag with the
    `id` attribute set to the ID of the `profile`. We don't use the hash (#) shorthand
    to set the `id` attribute in this case since we need Jade to evaluate our `id`
    variable. `tr#id` would generate`<tr id=id>` for each profile, whereas `tr(id=id)`
    generates`<tr id=ryan>` or `isaac`, or `bert` and so forth.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Jade，对于每个配置文件，我们要输出一个`<tr>`标签，其`id`属性设置为`profile`的ID。在这种情况下，我们不使用井号（#）缩写来设置`id`属性，因为我们需要Jade来评估我们的`id`变量。`tr#id`会为每个配置文件生成`<tr
    id=id>`，而`tr(id=id)`会生成`<tr id=ryan>`或`isaac`或`bert`等。
- en: Underneath `tr` we indent again, indicating that whatever comes next should
    be nested within the`<tr>` tags. Again we use `each` to traverse the values of
    each sub-object, indenting beneath with a `td` that holds each value of the profile.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tr`下面再次缩进，表示接下来的内容应该嵌套在`<tr>`标签内。我们再次使用`each`来遍历每个子对象的值，并在`td`下缩进，其中包含每个配置文件的值。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's take a look at some of the other templating capabilities and features
    Express has to offer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Express还提供了哪些其他模板功能和特性。
- en: Using other template engines
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用其他模板引擎
- en: Express supports a variety of alternative template engines, unsupported engines
    can be adapted to Express without excessive hassle.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Express支持各种替代模板引擎，不支持的引擎可以适应Express而不会带来过多的麻烦。
- en: 'The `express` executable will only generate Jade or EJS-based project scaffolding.
    To generate EJS we simply pass `ejs` to the `-t` flag:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`express`可执行文件只会生成基于Jade或EJS的项目脚手架。要生成EJS，我们只需将`ejs`传递给`-t`标志：'
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Instead of generating an Express project with EJS as the default view engine,
    let's convert our existing project (we'll start by copying it to `nca_ejs)`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将现有项目转换为EJS作为默认视图引擎的Express项目（我们将首先将其复制到`nca_ejs`）。
- en: First, we need to edit dependencies in `package.json:`
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编辑`package.json`中的依赖项：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ve simply removed `jade` and put `ejs` in its place. Now we do:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是删除了`jade`，并用`ejs`代替。现在我们这样做：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So `npm` will put the EJS module into the `node_modules` folder.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`npm`会将EJS模块放入`node_modules`文件夹中。
- en: 'Finally, we change our view engine in `app.configure` as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`app.configure`中更改我们的视图引擎如下：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This technique will work for any Express-supported template engine. There's
    no need to `require` the EJS module, Express takes care of that behind the scenes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术适用于任何Express支持的模板引擎。无需`require` EJS模块，Express会在后台处理。
- en: EJS templates
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EJS模板
- en: Since we've set up `nca_ejs`, we may as well go ahead and rewrite our index
    view in Embedded JavaScript.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经设置了`nca_ejs`，我们可以继续在嵌入式JavaScript中重写我们的索引视图。
- en: 'In `nca_ejs/views` we add a new file, `index.ejs`, and put:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nca_ejs/views`中添加一个新文件`index.ejs`，并写入：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`<%` and `%>` denote embedded JavaScript. If JavaScript happens to wrap any
    HTML code, the HTML is processed as if it''s part of the JavaScript. For instance,
    in our `forEach` callbacks we have`<tr>` and`<td>`, these are included as output
    from each loop.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`<%`和`%>`表示嵌入式JavaScript。如果JavaScript恰好包裹任何HTML代码，则HTML将被处理为JavaScript的一部分。例如，在我们的`forEach`回调中，我们有`<tr>`和`<td>`，这些都包含在每次循环的输出中。'
- en: When the opening tag is accompanied by an equals sign (`<%=`), it evaluates
    any given JavaScript variable and pulls it into the generated output. For example,
    in our first`<h1>` we output the `title` variable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当开放标签伴随等号（`<%=`）时，它会评估任何给定的JavaScript变量，并将其拉入生成的输出中。例如，在我们的第一个`<h1>`中，我们输出`title`变量。
- en: Literal JavaScript in Jade
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jade中的字面JavaScript
- en: 'Jade can also process plain JavaScript. Let''s use that to our advantage to
    output our table headers in a more concise, dry fashion:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Jade也可以处理纯JavaScript。让我们利用这一点，以更简洁、干燥的方式输出我们的表头：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A dash (—) at the beginning of a line informs Jade that we're using plain JavaScript.
    Here we simply create a new array called `headers` and then use Jade's `each`
    iterator to output our headers, using the equals (=) sign to evaluate the `header`
    variable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 行的开头有一个破折号（—），告诉Jade我们正在使用纯JavaScript。在这里，我们简单地创建一个名为`headers`的新数组，然后使用Jade的`each`迭代器输出我们的标题，使用等号（=）来评估`header`变量。
- en: 'We could alternatively create our array in Jade as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Jade中创建我们的数组如下：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Jade then compiles this to the embedded JavaScript in the preceding example,
    including the `var` declarative.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Jade然后将其编译为前面示例中的嵌入式JavaScript，包括`var`声明。
- en: Jade partials
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jade部分
- en: '**Partials** are described as mini-views or document-fragments. They are mainly
    intended for automatic templated iteration over an array (a collection), although
    they''ll also work with objects.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分**被描述为迷你视图或文档片段。它们主要用于自动模板化对数组（集合）的迭代，尽管它们也可以与对象一起使用。'
- en: 'For instance, instead of saying:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，而不是说：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can create a view file, which we''ll call `row.jade`, in which we write:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个视图文件，我们将其称为`row.jade`，在其中写入：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Back in `index.jade`, we replace our `each` iterator with `partial` as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`index.jade`，我们将我们的`each`迭代器替换为`partial`，如下所示：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`!=` tells Jade to not only buffer what `partial` returns, but also to refrain
    from escaping the returned HTML. If we don''t include the exclamation mark Jade
    replaces HTML characters with their special entity codes, (for example,`<` becomes`&lt;)`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`!=`告诉Jade不仅要缓冲`partial`返回的内容，还要避免转义返回的HTML。如果我们不包含感叹号，Jade会用特殊实体代码替换HTML字符（例如，`<`变成`&lt;`）。'
- en: We pass`'row'` into `partial` which tells Jade to use the `row.jade` view as
    the partial. We pass an object with a `collection` property as the next parameter.
    If our profile was a simple array, we could simply pass the array and Jade would
    generate a `td` tag for each value in the array. However, the `profile` variables
    are objects, so passing it to `collection` causes Jade to traverse the values
    as if they were a simple array.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`'row'`传递给`partial`，告诉Jade使用`row.jade`视图作为部分。我们将一个具有`collection`属性的对象作为下一个参数传递。如果我们的资料是一个简单的数组，我们可以简单地传递数组，Jade会为数组中的每个值生成一个`td`标签。但是，`profile`变量是对象，因此将其传递给`collection`会导致Jade遍历值，就好像它们是一个简单的数组一样。
- en: 'Each value in our `collection` (Ryan `Dahl, ryah, Creator` of `Node.js`, and
    so on), is referenced by the name of the view. So in our `row.jade` view, we use
    the `row` variable to grab each value. We can customize it by using the `as` property
    as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`collection`中的每个值（Ryan `Dahl, ryah, Node.js的创建者`等）都由视图的名称引用。因此，在我们的`row.jade`视图中，我们使用`row`变量来获取每个值。我们可以通过使用`as`属性来自定义它，如下所示：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Then in `row.jade` we would change `row` to `line:`
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`row.jade`中，我们将`row`更改为`line:`
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: 'In an effort to simplify viewing system internals and make it easier for template
    engines to integrate with Express, version 3 will no longer support partials.
    In Express 3, instead of a `row.jade` file, and using the call to `partial`, we
    could instead say:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化查看系统内部并使模板引擎更容易集成到Express中，版本3将不再支持部分。在Express 3中，我们可以说，而不是使用`partial`调用`row.jade`文件：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Express partials
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express部分
- en: One of the excellent things about partials is we can use them in our Express
    routes on the response (`res`) object. This is particularly remarkable because
    it allows us to seamlessly send fragments of HTML to AJAX or WebSocket requests,
    all while generating content from the same fragments (inside our views) for whole-page
    requests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 部分的一个很棒的地方是我们可以在Express路由上使用它们在响应（`res`）对象上。这是特别了不起的，因为它允许我们无缝地将HTML片段发送到AJAX或WebSocket请求，同时从相同的片段（在我们的视图中）生成整个页面请求的内容。
- en: 'At the end of `index.jade` (the partials version), we''ll insert a small proof
    of concept script:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.jade`（部分版本）的末尾，我们将插入一个小的概念验证脚本：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will wait for one and a half seconds and then make an AJAX request to our
    `index` route. So let's modify our `index` route in `routes/index.js:`
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等待一秒半，然后向我们的`index`路由发出一个AJAX请求。因此，让我们修改`routes/index.js`中的`index`路由：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If the request is an `XmlHttpRequest` (AJAX), we generate a new table row out
    of the `ryan` profile.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求是一个`XmlHttpRequest`（AJAX），我们会根据`ryan`的资料生成一个新的表格行。
- en: Now when we load `http://localhost:3000`, after a short delay Ryan's profile
    appears at the bottom of the table.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们加载`http://localhost:3000`时，经过短暂的延迟，Ryan的资料将出现在表格底部。
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: Express 3 doesn't support partials, (neither in template logic nor in app code),
    so we would have to approach this a different way. For instance, we could send
    a JSON representation of the profiles and have the browser loop through it to
    populate the table.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Express 3不支持部分（无论在模板逻辑还是在应用程序代码中），因此我们必须以不同的方式处理。例如，我们可以发送资料的JSON表示，并让浏览器循环遍历以填充表格。
- en: As of this time of writing, there is no replacement middleware for partials,
    but there may well be in the near future.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，还没有部分的替代中间件，但在不久的将来可能会有。
- en: Jade includes
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jade包括
- en: Includes help us to separate and re-use pieces of template code. Let's put our
    `profiles` table into its own view. We'll call it `profiles.jade`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 包含帮助我们分离和重用模板代码的部分。让我们将我们的`profiles`表格放入自己的视图中。我们将其称为`profiles.jade`。
- en: 'To include `profiles.jade` from the `index.jade` file we simply do the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`index.jade`文件中包含`profiles.jade`，我们只需执行以下操作：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: layout.jade
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: layout.jade
- en: Tip
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: Layouts are also being axed from Express 3 in favor of block inheritance. So
    instead of any rendered views being implicitly wrapped up into the `body` variable
    and rendered within `layout.jade`, we now have to explicitly declare a block and
    then insert that block into our body.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express 3中，布局也被取消，以支持块继承。因此，不再将任何渲染的视图隐式地包装到`body`变量中并在`layout.jade`中渲染，现在我们必须明确声明一个块，然后将该块插入到我们的body中。
- en: Also included in a generated project is the `layout.jade` view. This is a special
    view that is intertwined with Express logic. Any rendered views are packaged into
    a `body` variable, which is then passed into `layout.jade`. So in our case, we
    tell `res.render` to assemble `index.jade`. Express converts `index.jade` to HTML,
    and then internally renders `layout.jade`, passing the generated HTML in a body
    variable. `layout.jade` allows us to head and foot our views. To disable this
    feature for the entire app, we use `app.set('view options', {layout:false})`.
    To prevent it from applying to a particular render, we simply pass `layout:false`
    to the options object of `res.render`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目中还包括`layout.jade`视图。这是一个与Express逻辑交织在一起的特殊视图。任何渲染的视图都被打包到一个`body`变量中，然后传递到`layout.jade`中。因此，在我们的情况下，我们告诉`res.render`组装`index.jade`。Express将`index.jade`转换为HTML，然后在内部渲染`layout.jade`，将生成的HTML传递给`body`变量。`layout.jade`允许我们为视图添加头部和底部。要禁用整个应用程序的此功能，我们使用`app.set('view
    options', {layout:false})`。要防止它应用于特定的渲染，我们只需将`layout:false`传递给`res.render`的选项对象。
- en: Tip
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: 'So in `layout.jade`, instead of `body!=body` we have the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`layout.jade`中，我们不再使用`body!=body`，而是使用以下内容：
- en: '[PRE59]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And at the top of `index.jade` we would inherit from `layout.jade` using `extend`
    and then define the `content` block, which would be loaded into the body of `layout.jade:`
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.jade`的顶部，我们将使用`extend`从`layout.jade`继承，然后定义`content`块，该块将加载到`layout.jade`的body中：
- en: '[PRE60]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All Jade Express code examples have an additional folder named `views-Express3`
    containing equivalent templates, which follow the explicit block inheritance pattern
    instead of implicit layout wrapping.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Jade Express代码示例都有一个名为`views-Express3`的额外文件夹，其中包含等效的模板，这些模板遵循显式块继承模式，而不是隐式布局包装。
- en: See also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*CSS Engines with Express* discussed in this chapter'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的Express的CSS引擎*'
- en: '*Making an Express web app* discussed in this chapter'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的创建Express web应用程序*'
- en: '*Generating Express scaffolding* discussed in this chapter'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的生成Express脚手架*'
- en: CSS engines with Express
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express的CSS引擎
- en: Once we have our HTML, we'll want to style it. We could of course use raw CSS,
    but Express integrates nicely with some select CSS engines.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的HTML，我们就会想要为它设置样式。当然，我们可以使用原始的CSS，但Express与一些选择的CSS引擎集成得很好。
- en: Stylus is one such engine. It's written with Express in mind, and as a syntax
    it follows many of the design principles found in Jade.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Stylus就是这样一个引擎。它是为Express编写的，并且作为一种语法，它遵循了Jade中发现的许多设计原则。
- en: In this recipe, we're going to put Stylus in the spotlight, learning how we
    can use it to apply styles to our `profiles` table from the previous recipe.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将把Stylus放在聚光灯下，学习如何使用它来为我们之前教程中的`profiles`表应用样式。
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need our `nca` folder as it was left in the previous recipe.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要我们之前教程中留下的`nca`文件夹。
- en: How to do it...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we need to set up our app to use Stylus.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置我们的应用程序来使用Stylus。
- en: 'If we were starting a new project, we could use the `express` executable to
    generate a Stylus-based Express project, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要开始一个新项目，我们可以使用`express`可执行文件来生成一个基于Stylus的Express项目，如下所示：
- en: '[PRE61]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This would generate a project where `stylus` is a dependency in `package.json`,
    with an extra line in `app.js` within `app.configure:`
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个项目，其中`stylus`是`package.json`中的一个依赖项，在`app.configure`中的`app.js`中有一行额外的代码：
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: However, since we've already got a project on the hotplate, let's modify our
    existing app to use Stylus.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，既然我们已经有一个项目在热板上，让我们修改我们现有的应用程序来使用Stylus。
- en: In `package.json:`
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中：
- en: '[PRE63]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then on the command line run the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在命令行中运行以下命令：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally in `app.js`, inside `app.configure` we insert the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后在`app.js`中，在`app.configure`中插入以下代码：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice we've set a different `src` and added a `dest` property to the generated
    code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们设置了不同的`src`并添加了`dest`属性到生成的代码中。
- en: We're going to put our Stylus files in `views/stylesheets`. So let's make that
    directory and place a new file in it, which we'll call `style.styl`. Express will
    find this file, placing generated CSS in the corresponding folder (`stylesheets`)
    of the `public` directory.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的Stylus文件放在`views/stylesheets`中。所以让我们创建这个目录，并在其中放置一个新文件，我们将其命名为`style.styl`。Express将找到这个文件，将生成的CSS放在`public`目录的相应文件夹(`stylesheets`)中。
- en: 'To start our Stylus file, we''ll copy the current CSS from `/stylesheets/style.css`
    as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的Stylus文件，我们将从`/stylesheets/style.css`中复制当前的CSS，如下所示：
- en: '[PRE66]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Stylus is fully compatible with plain CSS, but for learning purposes let''s
    convert it into the minimal indentation-based format:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Stylus完全兼容纯CSS，但为了学习目的，让我们将其转换为最小缩进格式：
- en: '[PRE67]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now we'll style our `#profiles` table from the previous recipe.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为之前教程中的`#profiles`表设置样式。
- en: 'We can apply consistent padding to our `td` and `th` tags as well as our `#profile`
    table utilizing Stylus'' `@extend` directive as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Stylus的`@extend`指令为我们的`td`和`th`标签以及我们的`#profile`表应用一致的填充：
- en: '[PRE68]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As new CSS properties are introduced into browsers, they often come with vendor-specific
    prefixes until the implementation is considered mature and stable. One such property
    is `border-radius`, on Mozilla browsers it's `-moz-border-radius`, on WebKit types
    it's referenced as `-webkit-border-radius`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的CSS属性被引入到浏览器中时，它们通常带有特定于供应商的前缀，直到实现被认为是成熟和稳定的。其中一个属性是`border-radius`，在Mozilla浏览器上是`-moz-border-radius`，在WebKit类型上被引用为`-webkit-border-radius`。
- en: 'Writing and maintaining this sort of CSS can be quite involved, so let''s use
    a Stylus mixin to make our lives easier:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和维护这种CSS可能会相当复杂，所以让我们使用一个Stylus mixin来简化我们的生活：
- en: '[PRE69]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we''ll apply our mixin to the `#profiles` table and all the `td` elements:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的mixin应用到`#profiles`表和所有的`td`元素上：
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'So our `#profiles` table now looks as shown in the following screenshot:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`#profiles`表现在看起来如下截图所示：
- en: '![How to do it...](img/7188-06-02.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/7188-06-02.jpg)'
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As a module, `stylus` can operate independent of Express. However, it also has
    a convenient `middleware` method which can be passed into `app.use`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个模块，`stylus`可以独立于Express运行。然而，它也有一个方便的`middleware`方法，可以传递到`app.use`中。
- en: When the `express` executable generates a Stylus-powered project, only the `src`
    property is set, which means Stylus pulls files with a `.styl` extension and converts
    them to `.css` files in the same folder. When we set `dest`, we load our Stylus
    code from one place and save it in another.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当`express`可执行文件生成一个使用Stylus的项目时，只设置了`src`属性，这意味着Stylus从一个地方加载`.styl`文件，并将它们转换为`.css`文件放在同一个文件夹中。当我们设置`dest`时，我们从一个地方加载我们的Stylus代码，并将它保存在另一个地方。
- en: Our `src` is `views` and `dest` is `public`, but even though we put our `styles.styl`
    in a subdirectory of `views`, Stylus still finds it and places it in the corresponding
    subdirectory of the `dest` folder.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`src`是`views`，`dest`是`public`，但即使我们把我们的`styles.styl`放在`views`的子目录中，Stylus仍然可以找到它，并将它放在`dest`文件夹的相应子目录中。
- en: The `layout.jade` file includes a `link` tag to `/stylesheets/style.css`. So
    when we created `style.styl` in `views/stylesheets`, the generated CSS was written
    to `public/stylesheets`. Since our static server directory is set to `public`,
    requests for `/stylesheets/style.css` are served from `public/stylesheets/style.css`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout.jade`文件包括一个到`/stylesheets/style.css`的`link`标签。因此，当我们在`views/stylesheets`中创建`style.styl`文件时，生成的CSS将被写入`public/stylesheets`。由于我们的静态服务器目录设置为`public`，对`/stylesheets/style.css`的请求将从`public/stylesheets/style.css`中提供。'
- en: We used several Stylus features to create our stylesheet.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了几个Stylus功能来创建我们的样式表。
- en: 'The `@extend` directive is based upon the concept of inheritance. We make a
    class and then use `@extend` to apply all the qualities of that class to another
    element. Our use of `@extend` in the recipe creates the following CSS:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`@extend`指令基于继承的概念。我们创建一个类，然后使用`@extend`将该类的所有特性应用到另一个元素上。我们在这个教程中使用`@extend`创建了以下CSS：'
- en: '[PRE71]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The larger our styles base becomes the more the `@extend` directive tends to
    ease maintenance and readability.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样式基础越大，`@extend`指令就越能简化维护和可读性。
- en: We make it easier to define a border, with rounded corners if desired, by using
    a mixin. Stylus mixins allow us to define default values as we set the parameters.
    If we mixed in `borderIt` with no arguments, it would generate a 1 pixel-wide,
    right-angled solid black border according to its defaults.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用mixin，我们可以更容易地定义边框，如果需要的话，可以使用圆角。Stylus mixins允许我们在设置参数时定义默认值。如果我们没有参数混合`borderIt`，它将根据其默认值生成一个1像素宽的直角实心黑色边框。
- en: We first use `borderIt` on the `#profiles` table, passing in `20px` and `2px`.
    There's no need to use parentheses — Stylus understands it's a mixin. The first
    parameter (20px) in our mixin is named `rad`. Since `rad` has specified the `borderIt`,
    mixin goes ahead and outputs the various vendor prefixes along with the desired
    radius. The second parameter overwrites our `border-width` default.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`#profiles`表上使用`borderIt`，传入`20px`和`2px`。无需使用括号 - Stylus会理解它是一个mixin。我们mixin中的第一个参数（20px）被命名为`rad`。由于`rad`已经指定了`borderIt`，mixin继续输出各种供应商前缀以及所需的半径。第二个参数覆盖了我们的`border-width`默认值。
- en: We do need parentheses when we apply `borderIt` to the td elements, because
    we define our options using a `kwarg` (a keyword argument). All we want to do
    is set the color, so instead of supplying all preceding parameters, we simply
    reference the desired parameter as a property. The color we pass is `#000 + 80%`.
    This is not valid CSS but Stylus understands.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`borderIt`应用于`td`元素时，我们需要括号，因为我们使用`kwarg`（关键字参数）来定义我们的选项。我们只需要设置颜色，所以我们不需要提供所有前面的参数，我们只需将所需的参数引用为属性。我们传递的颜色是`#000
    + 80%`。这不是有效的CSS，但Stylus理解。
- en: There's more...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's explore some more Stylus features, and also find out how to use the alternative
    CSS engine, LESS, as Express middleware.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些更多的Stylus功能，并找出如何使用替代的CSS引擎LESS作为Express中间件。
- en: Nested mixins and rest parameters
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套mixin和rest参数
- en: Let's take a look at reusing mixins in other mixins, and Stylus' rest parameter
    syntax (essentially a single parameter that consumes any following parameters,
    compiling them into an array).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在其他mixin中重用mixin，以及Stylus的rest参数语法（本质上是一个消耗任何后续参数的单个参数，将它们编译成一个数组）。
- en: We could soften the edges of our table further by rounding the relevant angles
    of the corner`<td>` elements, such that they match the rounded nature of the outer
    border.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使角`<td>`元素的相关角更圆来进一步软化我们表格的边缘，使它们与外边框的圆角性质相匹配。
- en: 'We need to be able to set a radius for an individual corner. Vendor implementations
    differ on their approach to this. In Mozilla-based browsers, the corner is defined
    after radius with no dash, for example:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够为单个角设置半径。供应商的实现在这方面有所不同。在基于Mozilla的浏览器中，角在半径之后定义，没有破折号，例如：
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Whereas WebKit conforms to the specification (except the prefix) with the following
    code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 而WebKit符合规范（除了前缀）的代码如下：
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Let's create another mixin dedicated to creating the rounded corners CSS, whether
    corners are equal or not.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个专门用于创建圆角CSS的mixin，无论角是否相等。
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`sides` is a rest parameter. It swallows up all remaining arguments. We need
    two sides for a corner, for example, top left. So we use a conditional statement
    to check if length of the remaining arguments is 2 (instead of `is` we could have
    used `==)`.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`sides`是一个rest参数。它吸收了所有剩余的参数。我们需要两个边来形成一个角，例如，左上角。因此，我们使用条件语句来检查剩余参数的长度是否为2（而不是`is`，我们可以使用`==`）。'
- en: If we have our sides, we integrate them into the various browser-specific CSS.
    Notice when including variables in a property we escape them with curly brackets
    ({}). If sides aren't specified we set the radius to all sides, as in our recipe.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有我们的边，我们将它们整合到各种特定于浏览器的CSS中。请注意，当在属性中包含变量时，我们用大括号（{}）进行转义。如果未指定边，我们将边的半径设置为所有边，就像我们的配方一样。
- en: 'Now we can call this mixin from our `borderIt` mixin as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从我们的`borderIt` mixin中调用这个mixin，如下所示：
- en: '[PRE75]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We didn''t have to wrap the conditional statement with braces. This just allows
    us to keep our `if` statement and mixin call on the same line. It''s the equivalent
    to the following code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必用大括号包裹条件语句。这只是让我们可以将我们的`if`语句和mixin调用放在同一行上。这相当于以下代码：
- en: '[PRE76]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, we apply our single corners to the relevant `td` elements:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将单个角应用于相关的`td`元素：
- en: '[PRE77]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Our first `borderIt` now calls the `rndCorner` mixin inferentially because it
    sets a radius. The second `borderIt` won't call `rndCorner`, which is great because
    we want to call it ourselves on specific elements.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个`borderIt`现在通过推理调用`rndCorner` mixin，因为它设置了半径。第二个`borderIt`不会调用`rndCorner`，这很好，因为我们希望在特定元素上自己调用它。
- en: We use the special ampersand (`&`) referencer to cite the parent `tr` element.
    We use CSS's `:nth-child(2)` to select the second row of our table. The first
    row consists of `th` elements. The same applies for `first-child` and `last-child`,
    which we use to apply the appropriate corners to our `td` elements.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用特殊的`&`引用符来引用父`tr`元素。我们使用CSS的`:nth-child(2)`来选择表格的第二行。第一行由`th`元素组成。对于`first-child`和`last-child`也是一样，我们用它们来对我们的`td`元素应用适当的角。
- en: While this `:nth-child` and `:last-child` pseudo-selectors won't work in Internet
    Explorer 8 and below, neither will `border-radius`, so this is one of the few
    cases we can use it and still be cross-browser compatible, progressively enhancing
    in more modern browsers.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`：nth-child`和`：last-child`伪选择器在Internet Explorer 8及以下版本中不起作用，`border-radius`也不会起作用，因此这是我们可以在更现代的浏览器中使用它并且仍然具有跨浏览器兼容性的少数情况之一。
- en: Playing with colors
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩转颜色
- en: Stylus does some amazing things with color. It has functions that allow us to
    lighten/darken, (de)saturate, hue adjust, and even mix colors together.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Stylus对颜色做了一些令人惊讶的事情。它有函数允许我们调整颜色的明暗度，（去）饱和度，色调调整，甚至混合颜色。
- en: 'Let''s color our table in:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的表格上色：
- en: '[PRE78]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can reference values of any properties already set for an element, We use
    the `@background` property lookup variable consistently throughout this piece
    of code, but in many cases it holds a different value.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引用已为元素设置的任何属性的值，我们在这段代码中始终使用`@background`属性查找变量，但在许多情况下它保存了不同的值。
- en: To start off, we invert our `#profile` table, setting `color` to white, and
    `background` to black. We next apply color to our `td` elements, obtaining a lighter
    shade of blue by adding `35%` to it. We match our `td` borders to their `background`
    colors with the `@background` property lookup.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们反转我们的`#profile`表，将`color`设置为白色，`background`设置为黑色。接下来，我们对我们的`td`元素应用颜色，通过添加`35%`来获得浅蓝色。我们使用`@background`属性查找将我们的`td`边框与它们的`background`颜色匹配。
- en: Then we just go wild with color mixing, eventually setting the text color of
    our `td` to a color not far from the original pink. We then pass `@color` to desaturate
    while also lightening it using `+`. Next, we set the hover text color by adding
    180 degrees to our `@background` color, obtaining the complimentary hue. We also
    `desaturate` our `background` and match `border-color` (`@background` now matches
    the `desaturated` background, whereas when we set the color on hover it matched
    the pre-hover background color).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以随意混合颜色，最终将我们的`td`文本颜色设置为与原始粉色相差不远的颜色。然后，我们通过`+`将`@color`传递给去饱和，同时使其变亮。接下来，我们通过向我们的`@background`颜色添加180度来设置悬停文本颜色，获得互补色。我们还对我们的`background`进行了`去饱和`，并匹配了`border-color`（现在`@background`与`去饱和`的背景匹配，而当我们设置悬停颜色时，它匹配了悬停前的背景颜色）。
- en: 'So now our table looks as shown in the following screenshot:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的表格看起来如下截图所示：
- en: '![Playing with colors](img/7188-06-03.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![Playing with colors](img/7188-06-03.jpg)'
- en: Using the LESS engine
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用LESS引擎
- en: 'LESS may be suitable as a more familiar and verbose alternative to Stylus.
    We can use LESS with Express by replacing:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: LESS可能是一个更熟悉和冗长的Stylus替代方案。我们可以通过替换来使用LESS与Express：
- en: '[PRE79]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'With:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用：
- en: '[PRE80]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To ensure this works, we should also change our `package.json` file as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个工作，我们还应该按照以下方式更改我们的`package.json`文件：
- en: '[PRE81]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And run the following command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令：
- en: '[PRE82]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: To test it out, we'll rewrite our recipe in LESS.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们将用LESS重写我们的配方。
- en: Some Stylus features have no equivalent in LESS. Instead of using `@extend`
    to inherit our `pad` class, we'll convert it into a mixin. There are no `if` conditionals
    in LESS either, so we'll declare the `.borderIt` mixin twice, the second time
    using the `when` statement.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Stylus功能在LESS中没有等价物。我们将`@extend`用于继承我们的`pad`类，我们将其转换为mixin。LESS中也没有`if`条件，因此我们将两次声明`.borderIt`
    mixin，第二次使用`when`语句。
- en: '[PRE83]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We save this to `views/styles.less`. Express compiles it to `public/styles.css`
    and once again our `#profiles` table has rounded corners.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这保存到`views/styles.less`。Express将其编译为`public/styles.css`，再次我们的`#profiles`表具有圆角。
- en: See also
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Templating in Express* discussed in this chapter'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的Express模板*'
- en: '*Generating Express scaffolding* discussed in this chapter'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的生成Express脚手架*'
- en: Initializing and using a session
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化和使用会话
- en: If we want to maintain state between page requests, we use sessions. Express
    supplies middleware that takes much of the complexity out of managing sessions.
    In this recipe, we're going to use Express to make a session between a browser
    and server to facilitate a user login process.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在页面请求之间保持状态，我们使用会话。Express提供了大部分管理会话复杂性的中间件。在这个配方中，我们将使用Express在浏览器和服务器之间建立一个会话，以便促进用户登录过程。
- en: Getting ready
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create a fresh project:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目：
- en: '[PRE84]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This will create a new Express skeleton named `login`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`login`的新的Express骨架。
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In our `app.js file`, we make the following changes to `app.configure:`
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`app.js`文件中，我们对`app.configure`进行以下更改：
- en: '[PRE85]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Sessions are dependent on cookies, so we need both `cookieParser` and `session`
    middleware.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 会话依赖于cookies，因此我们需要`cookieParser`和`session`中间件。
- en: Tip
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: In Express 3, we set the secret string through `cookieParser` instead of `session:`
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express 3中，我们通过`cookieParser`而不是`session`设置秘密字符串：
- en: '[PRE86]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We''ll finish `app.js` with some route handling as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下路由处理完成`app.js`：
- en: '[PRE87]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `GET` requests will serve pages as normal, the `POST` requests will be interpreted
    as login attempts. These will first be passed to a validating route which checks
    for valid user data. The `DELETE` request will clear the session with `routes.logout`
    and then pass over to `routes.index`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`请求将正常提供页面，`POST`请求将被解释为登录尝试。这些将首先传递到一个验证路由，检查有效的用户数据。`DELETE`请求将清除`routes.logout`的会话，然后传递到`routes.index`。'
- en: 'Now to edit the `routes/index.js` file:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编辑`routes/index.js`文件：
- en: '[PRE88]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, let''s put a login form together in a file. We''ll call `login.jade`
    as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在一个文件中组合一个登录表单。我们将称之为`login.jade`：
- en: '[PRE89]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Tip
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**_method**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**_method**'
- en: Notice how our logout form uses a hidden input named `_method`. Setting this
    value to `DELETE` overrides the `POST` method that the form is set to. This is
    made possible by the `methodOverride` middleware inside `app.configure` within
    the `app.js` file.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的注销表单如何使用名为`_method`的隐藏输入。将此值设置为`DELETE`会覆盖表单设置的`POST`方法。这是由`app.js`文件中`app.configure`内的`methodOverride`中间件实现的。
- en: We'll include this form within `index.jade:`
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`index.jade`中包含这个表单：
- en: '[PRE90]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now if we run our app, and navigate to `http://localhost:3000`, we'll see a
    login form. We enter username `dave`, password `expressrocks` and now we see a
    greeting with the option to logout.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的应用程序，并导航到`http://localhost:3000`，我们将看到一个登录表单。我们输入用户名`dave`，密码`expressrocks`，现在我们看到一个问候语，并有注销选项。
- en: How it works...
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to use sessions we have to include some additional middleware. We do
    this within `app.configure. express.parseCookie` comes first because `express.session`
    is dependent on it.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用会话，我们必须包含一些额外的中间件。我们在`app.configure`中进行这样做。`express.parseCookie`首先出现，因为`express.session`依赖于它。
- en: '`express.session` takes a mandatory object containing the `secret` property
    (or in Express 3 the secret is set by passing a string argument to `express.cookieParser).
    secret` is used to generate the session hash, so it needs to be unique and unknown
    to outsiders.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.session`接受一个包含`secret`属性的强制对象（或者在Express 3中，通过向`express.cookieParser`传递字符串参数来设置密钥）。`secret`用于生成会话哈希，因此需要是唯一的，并且对外部人员是未知的。'
- en: When we set up our routes, we assume that `POST` requests to the `/` path are
    login attempts, and thus pass them first to the `login` route, and `DELETE` requests
    to `/` are to be processed primarily by the `logout` route.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置我们的路由时，我们假设对`/`路径的`POST`请求是登录尝试，因此首先将它们传递给`login`路由，对`/`的`DELETE`请求首先由`logout`路由处理。
- en: Our `login` route checks the posted login details (using `req.body`, which is
    supplied to us by the `bodyParser` middleware) against our placeholder `users`
    object. In a real-world scenario, `login` would rather be validating against a
    database of users.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`login`路由检查已发布的登录详细信息（使用`bodyParser`中间件提供给我们的`req.body`）与我们的占位符`users`对象相匹配。在真实世界的情况下，`login`可能会对用户数据库进行验证。
- en: If everything checks out, we add a `user` object to the session, and place the
    `name` and password (pwd) into it.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们将一个`user`对象添加到会话中，并将`name`和密码（pwd）放入其中。
- en: 'When pushing user details to the session, we could have taken a shortcut and
    said:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当将用户详细信息推送到会话时，我们可以采取捷径并说：
- en: '[PRE91]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: However, doing so could leave us open for an attacker to fill the `req.session.user`
    object with anything they desire, in potentially large amounts. While any data
    being entered into session would be entered by a trusted user (one with login
    details), and although `bodyParser` has built-in safety limits for POST data,
    it is always better to err on the side of conservatism over convenience.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做可能会让攻击者填充`req.session.user`对象，填充任何他们想要的内容，可能会有大量内容。虽然任何输入会话的数据都是由受信任的用户（具有登录详细信息的用户）输入的，而且`bodyParser`对POST数据有内置的安全限制，但总是更倾向于保守而不是方便。
- en: The `index` route remains the same, except that we set a `user` property, to
    which we pass `req.session.user`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`路由保持不变，只是我们设置了一个`user`属性，我们将`req.session.user`传递给它。'
- en: This enables `login.jade` to check the `user` variable. If it is set, `login.jade`
    shows a greeting along with a small form containing a link that sends a POST request
    with a `DELETE` override to the server, thus triggering the `logout` route via
    `app.del`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这使`login.jade`能够检查`user`变量。如果设置了，`login.jade`会显示一个问候语，并包含一个小表单，其中包含一个链接，该链接发送带有`DELETE`覆盖的POST请求到服务器，从而通过`app.del`触发`logout`路由。
- en: The `logout` route simply deletes the `user` object from `req.session`, passes
    control to the `index.route` (using `next)`, which pushes a non-existent `req.session.user`
    back to Jade via `res.render`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`logout`路由只是从`req.session`中删除`user`对象，将控制传递给`index.route`（使用`next`），然后通过`res.render`将不存在的`req.session.user`推送回Jade。'
- en: When Jade finds that there is no `user` it displays the login form, which is
    of course also output to a pre-login request.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当Jade发现没有`user`时，它会显示登录表单，当然也会输出到预登录请求。
- en: There's more...
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can improve the way we interact with sessions.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改进与会话的交互方式。
- en: Custom middleware for site-wide session management
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于全站点会话管理的自定义中间件
- en: This recipe is fine if we want to pass our login and logout requests to just
    one route. However, as our routes and views increase, managing the complexities
    with sessions could become burdensome. We can mitigate this somewhat by creating
    our own custom middleware for session-handling purposes.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将我们的登录和注销请求传递到一个路由，那么这个配方就很好。然而，随着我们的路由和视图增加，管理会话的复杂性可能会变得繁重。我们可以通过为处理会话目的创建自定义中间件来在一定程度上减轻这种情况。
- en: 'In preparation to test from different URLs, we''ll modify our routes as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从不同的URL进行测试，我们将修改我们的路由如下：
- en: '[PRE92]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We're not using routes to control our session logic, so we've removed the middle
    routes, sending them straight to `routes.index. :page` would probably point to
    another route, but we'll leave it as `routes.index` for brevity.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用路由来控制我们的会话逻辑，因此我们已经删除了中间路由，直接发送到`routes.index`。`:page`可能指向另一个路由，但出于简洁起见，我们将其保留为`routes.index`。
- en: 'In `routes/index.js`, we can now simply have the following code:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/index.js`中，我们现在可以简单地使用以下代码：
- en: '[PRE93]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now let''s create a file and call it `login.js`, writing the following code:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个文件，命名为`login.js`，编写以下代码：
- en: '[PRE94]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Since we''re no longer using routes, we don''t have the opportunity to pass
    `req.session.user` through `res.render`. However, we can use a dynamic helper
    instead. Dynamic helpers have access to the `req` and `res` objects, they''re
    called just before a view is rendered. Any properties we pass to the dynamic helper
    object are pushed to the Jade view as local variables. In `app.js`, just above
    our routes we put:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用路由，我们没有机会通过`res.render`传递`req.session.user`。但是，我们可以使用动态助手。动态助手可以访问`req`和`res`对象，在视图呈现之前调用。我们传递给动态助手对象的任何属性都会作为本地变量推送到Jade视图中。在`app.js`中，我们在我们的路由上方放置：
- en: '[PRE95]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Tip
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: In Express 3, dynamic helpers are set with `app.locals.use:`
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express 3中，使用`app.locals.use`设置动态助手：
- en: '[PRE96]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Rather than sending an object containing desired locals, local variables are
    explicitly set by adding them to the `res.locals` object.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 而是通过发送包含所需本地变量的对象，通过将它们添加到`res.locals`对象中来显式设置本地变量。
- en: Now we simply include `login.js` as middleware inside the `app.configure` callback
    of `app.js:`
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需在`app.js`的`app.configure`回调中将`login.js`包含为中间件：
- en: '[PRE97]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, we''ll modify `login.jade` so instead of:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将修改`login.jade`，使其不再是：
- en: '[PRE98]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We have:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有：
- en: '[PRE99]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This makes the form POST to whatever address it is submitted from.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这使表单POST到从中提交的任何地址。
- en: Now all the muscle work is performed by `login.js`. The bottom half of the exported
    function performs the same actions as our recipe. We have to check the methods
    manually since we're not using the Express router.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的肌肉工作都是由`login.js`执行的。导出函数的下半部分执行与我们的配方相同的操作。由于我们没有使用Express路由器，我们必须手动检查方法。
- en: In the top half we access `req.app`. In `app.js`, the `app` variable is the
    result of the `express.createServer`. Express allows us to access our server within
    middleware and routes with a reference to the server instance under `req.app`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在上半部分，我们访问`req.app`。在`app.js`中，`app`变量是`express.createServer`的结果。Express允许我们在中间件和路由中访问我们的服务器，使用对服务器实例的引用`req.app`。
- en: In our interaction with `req.app`, we work with `req.app.routes.routes` which
    we store in the `routes` variable. This property holds any routes we defined using
    `app.get, app.post`, and so on. The routes are stored by request method type,
    for example, `req.app.routes.routes.post` holds an array of all the `app.post`
    routes. If a route method hasn't been defined, we simply call `next` and `return`.
    This lets Express handle the problem of an undefined method. Each item in the
    array is an object, containing `path, method, callbacks, keys`, and `regexp` properties.
    We loop through all routes for the `request` method, and use the `regexp` property
    to determine if there is a `match` for the requested URL. If there isn't, we reset
    the method to `GET`. We do this to transparently ensure that the `POST` and `DELETE`
    requests can be served through any URL and not return a `404 error` if a `post`
    or `del` route hasn't been defined for them.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们与`req.app`的交互中，我们使用`req.app.routes.routes`，将其存储在`routes`变量中。这个属性保存了我们使用`app.get,
    app.post`等定义的任何路由。路由按请求方法类型存储，例如，`req.app.routes.routes.post`保存了所有`app.post`路由的数组。如果路由方法没有被定义，我们简单地调用`next`和`return`。这样Express可以处理未定义方法的问题。数组中的每个项目都是一个对象，包含`path,
    method, callbacks, keys`和`regexp`属性。我们循环遍历`request`方法的所有路由，并使用`regexp`属性来确定请求的URL是否有匹配项。如果没有，我们将方法重置为`GET`。我们这样做是为了透明地确保`POST`和`DELETE`请求可以通过任何URL进行服务，并且如果没有为它们定义`post`或`del`路由，不会返回`404错误`。
- en: If this piece of code was missing, the login or logout mechanism would still
    occur, but the user would be left with a `not found` message. For instance, if
    we navigate to `http://localhost:3000/anypage`, and attempt to log in, our middleware
    will catch the request first. It will determine if login conditions are met (a
    POST request with `user` in the body) and processes it accordingly. If no POST
    route has been defined for `/anypage`, we reset the method to GET. The middleware
    later calls `next`, passing control over to `app.router`, which never sees the
    POST method and thus reloads the `/:page` GET route.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少这段代码，登录或注销机制仍会发生，但用户将收到`未找到`消息。例如，如果我们导航到`http://localhost:3000/anypage`，并尝试登录，我们的中间件将首先捕获请求。它将确定是否满足登录条件（在请求体中有`user`的POST请求），并相应地处理它。如果没有为`/anypage`定义POST路由，我们将方法重置为GET。稍后中间件调用`next`，将控制权传递给`app.router`，后者永远不会看到POST方法，因此重新加载`/:page`
    GET路由。
- en: Back in `app.js` we have Express' `dynamicHelpers` method. The `dynamicHelpers`
    method registers the helper, but it isn't called until just before a view is rendered
    (which means the dynamic helper is executed after all our route callbacks). This
    is convenient because it allows our routes to interact with `req.session.user`
    further if required. We pass an object to `dynamicHelpers` containing a `user`
    property. The ultimate value of the `user` property is loaded directly into our
    view as a variable. In the same way we can pass variables to views via the `res.render`
    options object within a route. The `user` property holds a callback which is evaluated
    by Express. It works much like a route or middleware callback except a `return`
    value is expected. We `return req.session.user`, so as in the main recipe, `req.session.user`
    is now available in `login.jade` as `user`. If there is no session, we make sure
    to reset the URL to `/` so that other routes cannot be used to bypass our authorization
    process.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`app.js`，我们有Express的`dynamicHelpers`方法。`dynamicHelpers`方法注册了助手，但直到视图渲染之前才调用它（这意味着动态助手在所有路由回调之后执行）。这很方便，因为它允许我们的路由在需要时进一步与`req.session.user`交互。我们将一个包含`user`属性的对象传递给`dynamicHelpers`。`user`属性的最终值直接加载到我们的视图中作为变量。以同样的方式，我们可以通过路由中的`res.render`选项对象将变量传递给视图。`user`属性包含一个回调，由Express进行评估。它的工作方式类似于路由或中间件回调，只是期望有一个`return`值。我们`return
    req.session.user`，因此与主要配方一样，`req.session.user`现在在`login.jade`中作为`user`可用。如果没有会话，我们确保将URL重置为`/`，以便其他路由不能用来绕过我们的授权过程。
- en: Finally, we call `next` which passes control to the next middleware, which in
    our case is `app.router`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`next`，将控制权传递给下一个中间件，在我们的例子中是`app.router`。
- en: Flash messages
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闪现消息
- en: Express provides a simple interface for session-based flash messages. A flash
    message is held in a session object for one request, and then disappears. It's
    an easy way to generate request associated information or error messages.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Express提供了一个基于会话的闪现消息的简单接口。闪现消息保存在会话对象中，仅用于一个请求，然后消失。这是一种生成请求相关信息或错误消息的简单方法。
- en: Tip
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: Express 3 doesn't support session flash messages out of the box. However, connect-flash
    provides this functionality as middleware.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Express 3不支持开箱即用的会话闪现消息。但是，connect-flash作为中间件提供了这个功能。
- en: 'In the dependencies section of our `package.json` file we would add:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`package.json`文件的依赖项部分，我们将添加：
- en: '[PRE100]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'And then do a:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行：
- en: '[PRE101]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, we would require `connect-flash` and call it inside the `app.configure`
    callback, after the cookie and session middleware:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要引入`connect-flash`，并在`app.configure`回调中调用它，放在cookie和会话中间件之后：
- en: '[PRE102]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Let''s modify our `login.js` file from the previous extension to our recipe
    (*Custom middleware for site wide session management)*. We''re going to modify
    it to flash an error message for invalid login details. First, we''ll need to
    alter the code located at the bottom of our exported function, inside the `if
    (login)` conditional:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一个扩展中的`login.js`文件到我们的配方（*网站范围会话管理的自定义中间件*）。我们将修改它以便在登录详情无效时闪现错误消息。首先，我们需要修改导出函数底部的代码，位于`if
    (login)`条件内：
- en: '[PRE103]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This works fine, but we can do better. Let''s tidy it up by extracting our
    validation code into a separate function:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但我们可以做得更好。让我们通过将验证代码提取到一个单独的函数中来整理它：
- en: '[PRE104]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Although everything happening in `validate` is synchronous, we've written it
    in asynchronous style (that is, passing values through a callback instead of returning
    values). This is because, in reality, we wouldn't use an object to store user
    details. We would use a remote database, which would have to be accessed asynchronously.
    In the next recipe, we'll be storing our user details in a MongoDB database and
    asynchronously reading it to validate login requests. The `validate` function
    is structured with this in mind.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`validate`中发生的一切都是同步的，但我们以异步的方式编写它（即通过回调传递值而不是返回值）。这是因为实际上，我们不会使用对象来存储用户详细信息。我们将使用远程数据库，必须异步访问。在下一个示例中，我们将把用户详细信息存储在MongoDB数据库中，并异步读取以验证登录请求。`validate`函数的结构考虑到了这一点。
- en: 'Now we replace our middleware user validation code with the following:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用以下代码替换我们的中间件用户验证代码：
- en: '[PRE105]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Our `validate` function uses the same Boolean method. However, it's tucked out
    of the way. Also notice the various strategic calls to `next` — either when exiting
    early from an error, adding a user session, or at the very end. Placing these
    `next` calls within the callback context future proofs our validation function
    for asynchronous operations, which is important for database interactions.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`validate`函数使用相同的布尔方法。但是，它被隐藏了。还要注意到对`next`的各种策略性调用——无论是在从错误中提前退出时，添加用户会话，还是在最后。在回调上下文中放置这些`next`调用，为异步操作未来证明了我们的验证函数，这对于数据库交互非常重要。
- en: We use the `callback(err)` style from the `validate` function to let our middleware
    know whether the login was successful. `err` is simply an object containing the
    error message (msg), it's only passed if `valid` is not true.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`validate`函数中的`callback(err)`样式来让我们的中间件知道登录是否成功。`err`只是一个包含错误消息（msg）的对象，只有在`valid`不为真时才传递。
- en: If `err` is present, we call `req.flash`, which is the built-in Express method
    that pushes an object called `flash` onto `req.session`. Once the request is fulfilled,
    the object is emptied of all properties.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`err`，我们调用`req.flash`，这是内置的Express方法，将一个名为`flash`的对象推送到`req.session`中。一旦请求被满足，该对象将被清空所有属性。
- en: We need to make this object available to `login.jade`, so we'll add another
    dynamic helper over in `app.js`.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使这个对象在`login.jade`中可用，所以我们将在`app.js`中添加另一个动态帮助程序。
- en: '[PRE106]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Tip
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**从Express 2到Express 3**'
- en: 'To add flash messages in Express 3, we''d simply add it to the `res.locals`
    object in our preexisting `app.locals.use` callback:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Express 3中添加flash消息，我们只需将其添加到我们现有的`app.locals.use`回调中的`res.locals`对象中：
- en: '[PRE107]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We could use `req.session.flash`, but `req.flash()` will do the same.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`req.session.flash`，但`req.flash()`也可以做同样的事情。
- en: 'Finally, at the top of `login.jade` we write:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`login.jade`的顶部，我们写入：
- en: '[PRE108]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: If login details are incorrect, the user receives a bold error notification
    between horizontal lines.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录详细信息不正确，用户将在水平线之间收到粗体错误通知。
- en: See also
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Making an Express web app* discussed in this chapter'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论创建一个Express web应用程序*'
- en: '*Templating in Express* discussed in this chapter'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论Express中的模板*'
- en: '*Dynamic routing* discussed in this chapter'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动态路由*在本章中讨论'
- en: Making an Express web app
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Express web应用程序
- en: In this recipe, we're going to combine a lot of previous recipes together, also
    throwing in a few extra Express features (such as app mounting) in order to create
    the foundations of an Express-based web app with integrated administration features.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将把许多以前的示例组合在一起，还加入了一些额外的Express功能（如应用程序挂载），以创建一个具有集成管理功能的基于Express的Web应用程序的基础。
- en: Getting ready
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start fresh, from the command line we say:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从命令行开始：
- en: '[PRE109]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Profiler is the name of our new app, it will be a profile manager for members
    of the Node community.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Profiler是我们的新应用的名称，它将是Node社区成员的个人资料管理器。
- en: 'We need to edit `package.json` to say:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编辑`package.json`，写入：
- en: '[PRE110]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We've set the name to `Profiler` adding `stylus` and `mongoskin`, setting stricter
    version requirements for `mongoskin`. Jade and Stylus are built to work with Express,
    so they're likely to remain compatible with new releases (although we've restricted
    Stylus to minor version updates). Mongoskin has its own development processes.
    To ensure our project isn't broken by future versions with possible API changes
    we've locked the version 0.3.6 (though this doesn't mean we can't upgrade at a
    later date).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将名称设置为`Profiler`，添加`stylus`和`mongoskin`，为`mongoskin`设置更严格的版本要求。Jade和Stylus是为Express设计的，因此它们可能会与新版本保持兼容（尽管我们将Stylus限制为次要版本更新）。Mongoskin有自己的开发流程。为了确保我们的项目不会因为可能的API更改而被未来版本破坏，我们将版本锁定为0.3.6（尽管这并不意味着我们不能在以后升级）。
- en: 'So we get our dependencies with:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们用以下代码获取我们的依赖项：
- en: '[PRE111]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We also need to ensure MongoDB is installed and running on our system, see the
    *Storing and retrieving data with MongoDB* recipe of [Chapter 4](ch04.html "Chapter 4. Interfacing
    with Databases"), *Interfacing with Databases*, for details.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保MongoDB已安装并在我们的系统上运行，请参阅[第4章](ch04.html "第4章.与数据库交互")的*使用MongoDB存储和检索数据*，了解详情。
- en: 'In short, we start Mongo with the following command:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们用以下命令启动Mongo：
- en: '[PRE112]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We''ll also push some data into MongoDB to get us started. Let''s create a
    new folder in the `profiler` directory, and call it `tools`. Then pull our `profiles.js`
    module from[Chapter 1](ch01.html "Chapter 1. Making a Web Server"), *Making a
    Web Server*, into it, creating a new file called `prepopulate.js`. Inside it we
    write the following code:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向MongoDB中推送一些数据以开始。让我们在`profiler`目录中创建一个新文件夹，并将其命名为`tools`。然后将我们的`profiles.js`模块从[第1章](ch01.html
    "第1章.创建Web服务器")中，*创建Web服务器*，移到其中，创建一个名为`prepopulate.js`的新文件。在其中，我们写入以下代码：
- en: '[PRE113]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: When executed, this gives us a database named `profiler` with a `profiles` and
    `users` collection.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，这将给我们一个名为`profiler`的数据库，其中包含`profiles`和`users`集合。
- en: Finally, we'll be using the entire login app of the previous recipe. However,
    we'll want it with the site-wide session management and flash messages (in the
    code examples, this folder is called `login_flash_messages)`. So let's copy the
    `login` folder to our new profile directory as `profiler/login`.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用上一个示例中的整个登录应用程序。但是，我们希望它具有站点范围的会话管理和闪存消息（在代码示例中，此文件夹称为`login_flash_messages`）。因此，让我们将`login`文件夹复制到我们的新配置文件目录中，命名为`profiler/login`。
- en: How to do it...
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Creating a database bridge
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据库桥接
- en: 'Let''s begin with some backend coding. We''ll create a new folder called `models`,
    and create a file inside it called `profiles.js`. This is going to be used to
    manage all our interactions with the MongoDB profiles collection. In `models/profiles.js`
    we put:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些后端编码开始。我们将创建一个名为`models`的新文件夹，并在其中创建一个名为`profiles.js`的文件。这将用于管理我们与MongoDB配置文件集合的所有交互。在`models/profiles.js`中，我们放置：
- en: '[PRE114]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We''ve defined three methods: `pull, del`, and `add`. Each one operates on
    the database asynchronously, and executes a user callback once data is returned,
    or operation is complete. We''ve set a low rows-per-page limit (`rowsPer`) to
    allow us to test our pagination work (the dividing of content into pages) with
    the few records we have.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三种方法：`pull, del`和`add`。每个方法都是异步操作数据库，并在数据返回或操作完成时执行用户回调。我们设置了一个较低的每页行数限制（`rowsPer`），以便我们可以使用我们拥有的少量记录来测试我们的分页工作（将内容分成页面）。
- en: 'We must also modify `login/login.js`, which we created in the previous recipe,
    to hook up our login app to the MongoDB user collection. The main module can remain
    untouched. We only have to change the way we validate a user, everything above
    `module.exports` changes to:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须修改`login/login.js`，这是我们在上一个示例中创建的，以将我们的登录应用程序连接到MongoDB用户集合。主模块可以保持不变。我们只需要改变验证用户的方式，`module.exports`之上的所有内容都会改变为：
- en: '[PRE115]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Configuring app.js files
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置app.js文件
- en: Now let's modify `app.js`.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改`app.js`。
- en: '`app.configure` should look like this:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.configure`应该如下所示：'
- en: '[PRE116]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We've fired up the Stylus engine and thrown in a favicon server for good measure.
    The last line `app.use` actually mounts our login app at the `/admin` route (we
    copied `login` into our profiler directory in *Getting ready)*.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动了Stylus引擎，并添加了一个网站图标服务器以确保一切正常。最后一行`app.use`实际上将我们的登录应用程序挂载到`/admin`路由（我们在*准备就绪*中将`login`复制到我们的配置文件目录中）。
- en: 'Next, let''s add our one and only route to our main `app.j` as follows:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们唯一的路由添加到我们的主`app.j`中，如下所示：
- en: '[PRE117]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We've specified an optional placeholder called `:pagenum`, which must consist
    of one or more digits. So `/, /1, /12`, and `/125452` would all be valid routes,
    but `/alphaCharsPage` would not.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了一个可选的占位符叫做`:pagenum`，它必须由一个或多个数字组成。因此，`/, /1, /12`和`/125452`都是有效的路由，但`/alphaCharsPage`不是。
- en: 'Now we''ll set up some extra configuration details in the `app.js` of our `login`
    app in `login/app.js` as shown in the following code:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`login`应用程序的`app.js`中的`login/app.js`中设置一些额外的配置细节，如下所示：
- en: '[PRE118]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Tip
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: Remember in Express 3, the secret goes in the `express.cookieParser` as a string
    instead of inside an object passed into `express.session`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在Express 3中，秘密放在`express.cookieParser`中作为字符串，而不是传递给`express.session`的对象内部。
- en: The `login` app will be pulling in our profiles table from the `profiler` app.
    We've configured it to use Stylus as we'll be applying extra admin-specific Stylus-generated
    CSS. We've also added a helper variable called `masterviews`. This will later
    be used to locate the absolute path of our app's main views directory. The `login`
    app will need to know this in order to load views from its parent `profiler` app.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`应用程序将从`profiler`应用程序中拉取我们的配置文件表。我们已经配置它使用Stylus，因为我们将应用额外的特定于管理员的Stylus生成的CSS。我们还添加了一个名为`masterviews`的辅助变量。稍后将用它来定位我们应用程序的主视图目录的绝对路径。`login`应用程序需要知道这一点，以便从其父`profiler`应用程序加载视图。'
- en: 'Next, we''ll modify the routes in our `login/app.js` file:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`login/app.js`文件中的路由：
- en: '[PRE119]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Adding the optional `:pagenum` to the `get` method route enables navigation
    of the profiles table as in the main app. Adding `:pagenum` to the `post` method
    route allows users to log in from pages they may have previously navigated to,
    (for example, this allows a login form to be served from `http://localhost:/admin/2`
    if a user's session is expired). Likewise, the `del` method route will allow us
    to log out from any valid page.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 将可选的`:pagenum`添加到`get`方法路由中，使得可以像在主应用程序中一样导航配置文件表。将`:pagenum`添加到`post`方法路由中允许用户从他们之前导航到的页面登录（例如，如果用户的会话已过期，这允许从`http://localhost:/admin/2`提供登录表单）。同样，`del`方法路由将允许我们从任何有效页面注销。
- en: We've also added a `/del` and `/add` route for processing admin tasks.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为处理管理员任务添加了`/del`和`/add`路由。
- en: When one Express app is mounted inside another, calling the `listen` method
    on the sub-app causes a port conflict. Sub-apps do not have to listen, their parent
    app does the listening for them.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Express应用程序被挂载到另一个Express应用程序中时，在子应用程序上调用`listen`方法会导致端口冲突。子应用程序不必监听，它们的父应用程序会为它们监听。
- en: 'So we modify the `listen` invocation of `login/app.js` to:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们修改`login/app.js`中的`listen`调用为：
- en: '[PRE120]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '`module` is a built-in Node global. The parent property tells us whether or
    not our app is being loaded by another app. Since our login app is being loaded
    by the profiler app, `app.listen` won''t trigger.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`module`是一个内置的Node全局变量。parent属性告诉我们我们的应用程序是否被另一个应用程序加载。由于我们的登录应用程序是由配置文件应用程序加载的，`app.listen`不会触发。'
- en: The login app is the gatekeeper of our administration section within which we
    will be able to add and remove profiles.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 登录应用程序是我们管理部分的门卫，我们将能够添加和删除配置文件。
- en: Now that our main app and mounted app are suitably prepared, we can move onto
    editing our views, styles, and routes.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的主应用程序和挂载的应用程序都已经准备就绪，我们可以继续编辑我们的视图、样式和路由。
- en: Modifying the profiler app
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改配置文件
- en: Let's start with the `profiler` apps `index.jade` view.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`profiler`应用程序的`index.jade`视图开始。
- en: '[PRE121]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Since we''re including `profiles.jade`, let''s write it as follows:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们包含了`profiles.jade`，让我们将其写成如下形式：
- en: '[PRE122]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Tip
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Express 2 to Express 3**'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express 2到Express 3**'
- en: 'We''re using a `partial` (see *Jade Partials* discussed in *Templating in Express)*
    in `profiles.jade`. Express 3 no longer supports partials so we would need to
    iterate through the rows manually instead:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`profiles.jade`中使用了一个`partial`（参见*Express中的模板*中讨论的*Jade Partials*）。Express
    3不再支持partials，因此我们需要手动遍历行：
- en: '[PRE123]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '`profiles.jade` should be saved to the `profiler/views` directory, it is based
    on our `profiles` table in the previous recipes. However, we''ve added code to
    support seamless integration with the login app and some additional HTML structure
    for pagination.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiles.jade`应该保存到`profiler/views`目录中，它是基于我们之前的recipes中的`profiles`表。但是，我们添加了一些代码来支持与登录应用程序的无缝集成，并为分页添加了一些额外的HTML结构。'
- en: At the top of `profiles.jade`, we've included a safety net to ensure our view
    doesn't choke if `masterviews` is undefined. For pagination, we've added a `tfoot`
    element to hold the back and forward links with a complimentary `thead` to hold
    wrap the `th` elements.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在`profiles.jade`的顶部，我们包含了一个安全网，以确保我们的视图在`masterviews`未定义时不会中断。对于分页，我们添加了一个`tfoot`元素来保存前进和后退链接，以及一个补充的`thead`来包装`th`元素。
- en: 'We''re using a partial to load each row, this will be loaded from `row.jade`
    as follows:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个partial来加载每一行，这将从`row.jade`中加载如下：
- en: '[PRE124]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We've also included some Jade mixin invocations. We'll be defining these mixins
    when we come to edit the `login` apps views.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了一些Jade mixin调用。当我们来编辑`login`应用程序视图时，我们将定义这些mixin。
- en: Let's create a new `stylesheets` directory under `views` and place a file in
    it called `style.styl`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`views`下创建一个新的`stylesheets`目录，并在其中放置一个名为`style.styl`的文件。
- en: 'In `views/stylesheets/style.styl` we write the following code:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views/stylesheets/style.styl`中，我们编写以下代码：
- en: '[PRE125]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This is the same Stylus sheet from the *Playing with color* section under *There's
    more..*. in the *CSS engines with Express* recipe, but with some modifications.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自*Express中的CSS引擎*中*Playing with color*部分下的*There's more..*的相同Stylus表，但进行了一些修改。
- en: Since we've placed our `th` elements under a `thead`, we can simply select our
    `tbody tr` elements by `:first-child` instead of `:nth-child(2)`. We also add
    some styling for the new `tfoot` element.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`th`元素放在`thead`下，我们可以简单地通过`:first-child`选择我们的`tbody tr`元素，而不是`:nth-child(2)`。我们还为新的`tfoot`元素添加了一些样式。
- en: Finally, we'll write the `routes/index.js` file.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写`routes/index.js`文件。
- en: '[PRE126]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Our `index` route makes a call via our `models/profiles.js` module to MongoDB,
    passing it the desired page number, and retrieves some profiles to display.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`index`路由通过我们的`models/profiles.js`模块向MongoDB发出调用，传递所需的页码，并检索一些要显示的profiles。
- en: It also calls our `patchMixins` function, included prior to our route, with
    an array of mixin names found in `profiles.jade`. These mixins don't exist yet.
    Furthermore, the mixins will only be available when we're logged in to `http://localhost:8080/admin`.
    This is intentional, the mixins will provide administrative controls which lie
    on top of our `profiles` table, we only want them to appear when a user is logged
    in.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 它还调用我们的`patchMixins`函数，在我们的路由之前包含了一个在`profiles.jade`中找到的mixin名称数组。这些mixin目前还不存在。此外，只有当我们登录到`http://localhost:8080/admin`时，这些mixin才可用。这是有意的，这些mixin将提供管理控件，这些控件位于我们的`profiles`表的顶部，我们只希望它们在用户登录时出现。
- en: However, if we don't include dummy mixins in the place of the admin mixins,
    Node will throw an error.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们不在admin mixin的位置包含虚拟mixin，Node将抛出错误。
- en: Internally, Jade mixins are compiled into JavaScript functions before they are
    executed within our view templates. So we create dummy `no-op` (no operation)
    functions to prevent a server error. Then when we do log in, they are replaced
    with the administration mixins.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Jade mixins在执行视图模板之前被编译为JavaScript函数。因此，我们创建了虚拟的`no-op`（无操作）函数来防止服务器错误。然后当我们登录时，它们将被替换为管理mixin。
- en: If we navigate to `localhost:3000` we should now have a functioning `profiler`
    app.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到`localhost:3000`，我们现在应该有一个正常运行的`profiler`应用程序。
- en: Modifying the mounted login App
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改已挂载的登录应用程序
- en: 'In `login/views`, we currently have `index.jade, login.jade`, and `layout.jade`.
    In `login.jade`, we want to add two `includes` as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在`login/views`中，我们目前有`index.jade, login.jade`和`layout.jade`。在`login.jade`中，我们想要添加两个`includes`，如下所示：
- en: '[PRE127]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Rather than repeating code, we reuse our `profiles.jade` view from the main
    app using a relative path. This means any changes we make to our frontend site
    are also made to our administration section! `admin.jade` is going to contain
    Jade mixins (which are conceptually similar to Stylus mixins). These mixins are
    conditionally included in `profiles.jade` (see the previous *Modifying the profiler
    app* section).
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再重复代码，而是使用相对路径从主应用程序重用我们的`profiles.jade`视图。这意味着我们对前端站点所做的任何更改也会应用到我们的管理部分！`admin.jade`将包含Jade
    mixins（在概念上类似于Stylus mixins）。这些mixin有条件地包含在`profiles.jade`中（请参见前面的*修改profiler应用程序*部分）。
- en: So in `admin.jade:`
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 因此在`admin.jade`中：
- en: '[PRE128]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: We have two includes in `admin.jade`, one as part of a mixin, and the other
    as a straight include.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在`admin.jade`中有两个包含，一个作为mixin的一部分，另一个作为直接包含。
- en: '`addfrm.jade` should be as follows:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`addfrm.jade`应该如下所示：'
- en: '[PRE129]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'And `adminScript.jade` should contain the following code:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`adminScript.jade`应包含以下代码：'
- en: '[PRE130]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Admin is positioned above profiles in `login.jade`, so `#addfrm` will sit above
    the `#profiles` table. However, our `adminScript` mixin hides the table, showing
    it when the **Add** button is clicked.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在`login.jade`中，`admin`位于`profiles`上方，因此`#addfrm`将位于`#profiles`表的上方。但是，我们的`adminScript`
    mixin隐藏了表格，在单击**添加**按钮时显示它。
- en: 'We create a `stylesheets` folder under `login/views`, creating `admin.styl`
    in it and write the following code:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`login/views`下创建一个`stylesheets`文件夹，在其中创建`admin.styl`并编写以下代码：
- en: '[PRE131]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now we're also reusing the Stylus sheet from our main app. The `@import` declarative
    is handled by Stylus on the server side (unless the extension is `.css)`. As a
    result, our main app's `styles.styl` sheet is combined with `admin.styl` and compiled
    as one CSS file in `login/public/stylesheets/admin.css`.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还在主应用程序中重用Stylus表。`@import`声明由服务器端的Stylus处理（除非扩展名为`.css`）。因此，我们的主应用程序的`styles.styl`表与`admin.styl`合并，并编译为`login/public/stylesheets/admin.css`中的一个CSS文件。
- en: 'To load our `admin.css` file, we must alter the login app''s `layout.jade`
    view as shown in the following code:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载我们的`admin.css`文件，我们必须修改登录应用程序的`layout.jade`视图，如下面的代码所示：
- en: '[PRE132]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We've altered the `link href` attribute from `/stylesheet/style.css` to `/admin/stylesheets/admin.css`,
    ensuring that CSS is loaded from the static server on our sub-apps route.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`link href`属性从`/stylesheet/style.css`更改为`/admin/stylesheets/admin.css`，确保CSS从我们子应用程序的静态服务器上加载。
- en: 'Finally, we complete our admin routes, in `login/routes/index.js` as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了我们的管理员路由，在`login/routes/index.js`中如下所示：
- en: '[PRE133]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We should now be able to log in to `http://localhost:3000/admin` to delete and
    add profiles as `Dave`, with password `expressrocks`, or as `Mr.Page`, with password
    `hellomynamesmrpage`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够登录到`http://localhost:3000/admin`，以`Dave`的身份删除和添加配置文件，密码为`expressrocks`，或者以`Mr.Page`的身份，密码为`hellomynamesmrpage`。
- en: Tip
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Login security**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**登录安全**'
- en: In the next chapter, we will learn how to hash our passwords and log in over
    SSL.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何对我们的密码进行哈希处理并通过SSL登录。
- en: How it works...
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our app contains a lot of pieces working together. So let's look at it from
    various angles.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序包含许多组件共同工作。所以让我们从不同的角度来看一下。
- en: App mounting
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序挂载
- en: In this recipe, we have two apps working with the same database, sharing views
    and Stylus sheets. We imported the login app to our new `profiler` folder and
    mounted it with `app.use` setting `/admin` as its route.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有两个应用程序与同一个数据库一起工作，共享视图和Stylus样式表。我们将登录应用程序导入到我们的新的`profiler`文件夹中，并使用`app.use`设置`/admin`作为其路由。
- en: This works because Express apps are an assemblage of middleware, so when we
    mount the login app it simply integrates with our app as a middleware plugin.
    Middleware works on the request and response objects. By passing the `/admin`
    route into `app.use`, we limit the login app to work only with requests made under
    that route.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Express应用程序是中间件的组合，所以当我们挂载登录应用程序时，它只是作为中间件插件与我们的应用程序集成。中间件在请求和响应对象上工作。通过将`/admin`路由传递给`app.use`，我们限制了登录应用程序仅在该路由下的请求中工作。
- en: Data Flow
  id: totrans-594
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据流
- en: 'Our app is supported by a MongoDB database that we set up with our `prepopulate.js`
    tool. Data flows to and from the database as shown:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序由MongoDB数据库支持，我们使用`prepopulate.js`工具进行设置。数据如下所示流向和从数据库流向：
- en: '![Data Flow](img/7188_06_05.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![数据流](img/7188_06_05.jpg)'
- en: '`models/profiles.js` pulls and pushes data to the profiles collection, providing
    an interface for the `routes/index.js` files in both master and sub-apps. Our
    routes integrate within their respective `app.js` files, and work to interact
    with models/profiles.js to carry out the desired tasks.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '`models/profiles.js`从配置文件集合中提取和推送数据，为主应用程序和子应用程序中的`routes/index.js`文件提供接口。我们的路由集成在各自的`app.js`文件中，并与`models/profiles.js`交互，执行所需的任务。'
- en: '`login.js` simply verifies the user''s credentials, performing a search with
    user-supplied input. `login.js` sits as a piece of middleware within `login/app.js`,
    waiting to respond to POST requests containing a username and password.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '`login.js`只是验证用户的凭据，使用用户提供的输入进行搜索。`login.js`作为一个中间件坐落在`login/app.js`中，等待响应包含用户名和密码的POST请求。'
- en: Route handling
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由处理
- en: In both apps, the `index` route provides a foundation for displaying and navigating
    the profiles table. In both we call `profiles.pull`, passing in `req.params.pagenum`.
    The `pagenum` parameter is loaded onto `req.params`. It will never by anything
    but a number — thanks to our restrictions placed on it, though it is optional
    so may not be present.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个应用程序中，`index`路由提供了显示和导航配置文件表的基础。在两者中，我们调用`profiles.pull`，传入`req.params.pagenum`。`pagenum`参数加载到`req.params`上。它永远不会是除了数字之外的任何东西
    - 这要归功于我们对它的限制，尽管它是可选的，因此可能不存在。
- en: 'Our `profiles.pull` takes two parameters: the page number and a callback. If
    the page number isn''t present, it sets the `page` to `1`. We determine which
    rows to extract by multiplying our internal `rowsPer` variable by `page —1` (we
    want to start at the beginning with page 1, therefore, for the first page we skip
    0 rows). The result is passed through as the `skip` modifier to MongoDB, as well
    as `rowsPer` being passed as the `limit` property. `skip` will pass over a predetermined
    number of rows before outputting and `limit` restricts the amount to output; thus
    we achieve pagination.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`profiles.pull`接受两个参数：页码和回调。如果页码不存在，则将`page`设置为`1`。我们通过将我们的内部`rowsPer`变量乘以`page-1`（我们想要从第一页开始，因此对于第一页，我们跳过0行）来确定要提取的行。结果作为`skip`修饰符传递给MongoDB，同时`rowsPer`作为`limit`属性传递。`skip`将在输出之前跳过预定数量的行，`limit`限制输出的数量；因此我们实现了分页。
- en: The `profiles.pull` callback is initiated either with an error, or with an object
    containing profiles. In both our `index` routes, we perform minimal error handling.
    Express tends to capture the errors and output them to the browser for debugging
    purposes. `profiles` is passed to `res.render` where it is later utilized by the
    `profiles.jade` view.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiles.pull`回调要么出现错误，要么包含配置文件的对象。在我们的`index`路由中，我们执行最小的错误处理。Express倾向于捕获错误并将其输出到浏览器以进行调试。`profiles`被传递给`res.render`，稍后在`profiles.jade`视图中使用。'
- en: 'In `login/app.js`, two inflexible routes are defined: `/add` and `/del`. The
    `/del` route is a basic GET request pointing to `routes.delprof`, it expects two
    query parameters: `id` and `p. id` is passed to `profiles.del`, which calls the
    Mongoskin `removeByID` method, effectively deleting a profile from the collection.
    We pass the `cb` parameter directly to the `removeById` callback, making the `profiles.del`
    callback a direct result of `removeById`.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在`login/app.js`中，定义了两个不可变的路由：`/add`和`/del`。`/del`路由是一个基本的GET请求，指向`routes.delprof`，它期望两个查询参数：`id`和`p.
    id`被传递给`profiles.del`，它调用Mongoskin的`removeByID`方法，有效地从集合中删除了一个配置文件。我们直接将`cb`参数传递给`removeById`回调，使`profiles.del`回调直接成为`removeById`的结果。
- en: Back in `login/routes/index.js`, as long as no error has occurred, we invoke
    `profiles.pull`, with the `p` query parameter, updating the `profiles` object
    to the views using `app.helpers`. This ensures that changes to the database are
    reflected to the user. Finally, we redirect the user back to where they came from.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`login/routes/index.js`，只要没有发生错误，我们调用`profiles.pull`，使用`p`查询参数更新`profiles`对象到视图中使用`app.helpers`。这确保了对数据库的更改会反映给用户。最后，我们将用户重定向回他们来的地方。
- en: The `/add` route works in much the same way, except as a POST request. The `req.body`
    is returned as an object, we can simply insert this object straight into MongoDB
    (since it is JSON-like).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`/add`路由的工作方式基本相同，只是作为POST请求。`req.body`作为一个对象返回，我们可以直接将这个对象插入到MongoDB中（因为它类似于JSON）。'
- en: Views
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Views
- en: 'We use a lot of `includes` in our views, and sometimes between apps, the relationships
    look as shown in the following diagram:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在视图中使用了很多`includes`，有时在应用程序之间的关系看起来如下图所示：
- en: '![Views](img/7188_06_07.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
  zh: '![Views](img/7188_06_07.jpg)'
- en: In our main app, the index view loads the profiles view, and profiles utilizes
    the rows view in a `partial` statement.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主应用程序中，索引视图加载profiles视图，并且profiles在`partial`语句中使用rows视图。
- en: In the login app, the index view includes the login view. The login view loads
    the profiles view and, under the right conditions, also includes the admin view
    (before profiles) to provide the administration layer. Admin includes the `addfrm`
    and `adminScript` views. The mixins defined in admin become available to profiles.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录应用程序中，索引视图包括登录视图。登录视图加载profiles视图，并在适当的条件下，还包括admin视图（在profiles之前）以提供管理层。Admin包括`addfrm`和`adminScript`视图。在admin中定义的mixins对profiles可用。
- en: 'The `profiles.jade` view is very central to the entire web app, it outputs
    our data, delivers the optional administration overlay, and provides navigational
    capabilities. Let''s take a look at the navigational portion:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`profiles.jade`视图对整个Web应用程序非常重要，它输出我们的数据，提供可选的管理覆盖层，并提供导航功能。让我们来看看导航部分：'
- en: '[PRE134]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The `page` variable is passed through from the `index` route, and is determined
    from `req.params.pagenum`. If page is `0` (or false), we set it to `1`, which
    in the user's mind is the first page. We then create a variable named `s`. In
    Jade, we don't have to use `var`, Jade takes care of the complications. If we
    are on the first page, a link to the previous pages is unnecessary, so add a style
    attribute containing `display:none` (if we wanted to be neater, we could have
    a CSS class set `display` and add a class attribute instead). By passing `null`,
    if the `page` is greater than one, we're telling Jade that we don't want to set
    the style attribute at all.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`page`变量是从`index`路由传递的，并且是从`req.params.pagenum`确定的。如果page是`0`（或false），我们将其设置为`1`，这在用户心中是第一页。然后我们创建一个名为`s`的变量。在Jade中，我们不必使用`var`，Jade会处理这些复杂性。如果我们在第一页，那么链接到前一页是不必要的，因此添加一个包含`display:none`的style属性（如果我们想更整洁，我们可以设置一个CSS类设置`display`并添加一个class属性）。通过传递`null`，如果`page`大于1，我们告诉Jade我们根本不想设置style属性。'
- en: Mixins
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mixins
- en: The only place we use Jade mixins is in the `login/views/admin.jade` view, but
    they are essential to the synergy between the admin section and the top-level
    site. Unless a user is logged in and under the `/admin` route, the mixins are
    not present in `profiles.jade`. They are only intended for privileged users.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在`login/views/admin.jade`视图中使用Jade mixins，但它们对于管理部分和顶层站点之间的协同作用至关重要。除非用户已登录并在`/admin`路由下，否则mixins不会出现在`profiles.jade`中。它们只适用于特权用户。
- en: We use mixins to supplement the `profiles` table with an administration layer.
    The only part of `admin.jade` that isn't a mixin is the final `include` of `addfrm.jade`.
    As admin is included before profiles, `#addfrm` sits above the `profiles` table.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用mixins来补充`profiles`表与管理层。`admin.jade`中唯一不是mixin的部分是最终的`include` `addfrm.jade`。由于admin在profiles之前被包含，`#addfrm`位于`profiles`表上方。
- en: 'The `adminScript` mixin is, as the name suggests, a `script` block that quickly
    applies an `id` of `js` to the `body` tag. We use this in `admin.styl` to hide
    our `#addfrm` (the generated CSS would be `#js #addfrm {display:none})`. This
    is quicker than directly hiding the element with JavaScript and minimizes the
    undesirable flash of content effect that can occur when hiding page elements on
    page load. Therefore, `#addfrm` is not initially visible. In the following screenshot,
    we can see the visible mixins displayed on the `#profiles` table within the admin
    section:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`adminScript` mixin就像其名称所示，是一个`script`块，快速地将`id`设置为`js`添加到`body`标签上。我们在`admin.styl`中使用它来隐藏我们的`#addfrm`（生成的CSS将是`#js
    #addfrm {display:none}`）。这比直接使用JavaScript隐藏元素更快，并且最小化了在页面加载时隐藏页面元素可能出现的不良内容闪烁效果。因此，`#addfrm`最初是不可见的。在下面的截图中，我们可以看到在管理部分的`#profiles`表中显示的可见mixins：'
- en: '![Mixins](img/7188-06-04.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![Mixins](img/7188-06-04.jpg)'
- en: Clicking on the **Add** button causes the `#profiles` table to fade out and
    `#addfrm` to fade in. The `del` mixin takes an `id` argument, which it then uses
    to generate a link for each profile, such as `/del?id=4f3336f369cca0310e000003&p=1`.
    The `p` variable is determined from the `page` property passed in at `res.render`
    time in the `index` route.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Add**按钮会导致`#profiles`表淡出，`#addfrm`淡入。`del` mixin接受一个`id`参数，然后使用它为每个profile生成一个链接，例如`/del?id=4f3336f369cca0310e000003&p=1`。`p`变量是从`res.render`时间中传递给`index`路由的`page`属性确定的。
- en: Helpers
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Helpers
- en: We use both static and dynamic helpers in the login app. Dynamic helpers sit
    between the final piece of route middleware and rendering of the view. So they
    have the last call on what is sent out. The dynamic helpers in our app stay the
    same.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在登录应用程序中同时使用静态和动态helpers。动态helpers位于路由中间件的最后一部分和视图渲染之间。因此，它们对发送出去的内容有最后的控制权。我们应用程序中的动态helpers保持不变。
- en: Static helpers are set when the app spins up and can be overwritten at any time.
    These helpers are stored within `app._locals`, along with other Express presets
    (such as the `settings` object we use for our `base` variable in the `profiles`
    view). We use `app.mounted` within our login app to access the parent app object
    to discover our parent app's view directory from `parent._locals.settings.views`.
    Then we pass that back as the `masterviews` helper to our login apps views.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 静态助手在应用程序启动时设置，并且可以随时被覆盖。这些助手存储在`app._locals`中，以及其他Express预设（例如我们在`profiles`视图中用于`base`变量的`settings`对象）。我们在我们的登录应用程序中使用`app.mounted`来访问父应用程序对象，以从`parent._locals.settings.views`中发现父应用程序的视图目录。然后我们将其作为`masterviews`助手传递给我们登录应用程序的视图。
- en: 'In `profiles.jade` we do this:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在`profiles.jade`中，我们这样做：
- en: '[PRE135]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: If, in our sub-app, we include a view from the parent app' and that view includes
    another parent view, or loads a partial with a parent view, we can use `masterviews`
    to ensure that the partial is loaded from the parent directory. `masterviews`
    enables `profiles.jade` to operate in both realms.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的子应用程序中，我们包含来自父应用程序的视图，并且该视图包含另一个父视图，或者加载一个包含父视图的部分，我们可以使用`masterviews`来确保部分是从父目录加载的。`masterviews`使`profiles.jade`能够在两个领域中运行。
- en: Styles
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: 'Our Stylus files also share a degree of interconnectivity, as shown in the
    following diagram:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Stylus文件也具有一定程度的互连性，如下图所示：
- en: '![Styles](img/7188_06_06.jpg)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![样式](img/7188_06_06.jpg)'
- en: User flow
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户流程
- en: All of these things work together to provide a website with an admin section.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都共同作用，为网站提供了一个管理部分。
- en: A user can browse the profiles table, using the back and forward links, and
    they can link to a particular page on the table.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以浏览配置文件表，使用返回和前进链接，并且可以链接到表上的特定页面。
- en: A privileged user can navigate to `/admin`, enter their login details, and proceed
    to add and delete records. The `/add` and `/delete` routes are protected by the
    middleware. Unless the user is logged in, the only route that gets delivered to
    them is the login app's `index` route asking for login details.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 特权用户可以导航到`/admin`，输入他们的登录详细信息，并继续添加和删除记录。`/add`和`/delete`路由受中间件保护。除非用户已登录，否则他们只能访问登录应用程序的`index`路由，要求登录详细信息。
- en: There's more...
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's look at ways to monitor and analyze our web app.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何监视和分析我们的Web应用程序。
- en: Benchmarking
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试
- en: Benchmarking a Node website can be very satisfying, but there's always going
    to be room for improvement.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 对Node网站进行基准测试可能非常令人满意，但总会有改进的空间。
- en: Apache Bench (ab) comes bundled with Apache servers, and while Apache have no
    part in NodeJS, their HTTP benchmarking utility is an excellent tool for stress
    testing our app's ability to respond to a large amount of simultaneous requests.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Bench（ab）与Apache服务器捆绑在一起，虽然Apache与NodeJS无关，但他们的HTTP基准测试工具是测试我们应用程序响应大量同时请求能力的绝佳工具。
- en: 'We can use it to test the performance benefits or hindrances of any changes
    to our app. Let''s quickly throw 1,000 requests, 50 at a time, at both the site
    and the admin section as follows:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来测试对我们应用程序的任何更改的性能优势或劣势。让我们快速地向站点和管理部分分别抛出1000个请求，每次50个请求，如下所示：
- en: '[PRE136]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Mileage will vary depending on system capabilities. However, since tests are
    run on the same machine, conclusions can be drawn from differences between tests.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 里程将根据系统功能而异。然而，由于测试是在同一台机器上运行的，因此可以从测试之间的差异中得出结论。
- en: With our test on the two sections, `/` delivers at 120 requests per second,
    whereas `/admin` serves at just under 160 request per second. This makes sense
    because the `/admin` page will only be serving a login form, whereas the `/` route
    is pulling data from MongoDB, performing iteration logic on the `profiles` object,
    and using a partial to display the rows.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对两个部分的测试中，`/`每秒传送120个请求，而`/admin`每秒仅传送近160个请求。这是有道理的，因为`/admin`页面只会提供登录表单，而`/`路由会从MongoDB获取数据，对`profiles`对象执行迭代逻辑，并使用部分来显示行。
- en: Using logger
  id: totrans-642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用记录器
- en: Express comes with Connects logger middleware, which outputs useful custom-defined
    information from our app. In a production scenario, this information can be an
    essential part of site maintenance.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: Express带有Connect的记录器中间件，它可以输出我们应用程序中有用的自定义信息。在生产场景中，这些信息可能是网站维护的重要部分。
- en: 'To use logger, we include it before all other middleware as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用记录器，我们在所有其他中间件之前包含它，如下所示：
- en: '[PRE137]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'By default, logger outputs something as shown in the following code:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，记录器会输出如下所示的内容：
- en: '[PRE138]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: It contains useful information about the request, the IP address of the client,
    the user agent string, and the content length (908 and 1395 respectively in the
    example output). We can use this information to determine a host of facts (for
    example, browser stats, geo-locational stats, and so on).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含有关请求的有用信息，客户端的IP地址，用户代理字符串以及内容长度（在示例输出中分别为908和1395）。我们可以使用这些信息来确定一系列事实（例如浏览器统计数据，地理位置统计数据等）。
- en: 'During development, we may want to set `logger` as shown in the following code:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们可能希望设置`logger`如下所示：
- en: '[PRE139]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This outputs color-formatted request information to the console, containing
    the request method (GET, for instance), the requested route, status number (such
    as 200), and time for the request to complete.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以颜色格式输出请求信息到控制台，包括请求方法（例如GET），请求的路由，状态码（例如200），以及请求完成的时间。
- en: 'We can also pass in tokens. For example:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以传递令牌。例如：
- en: '[PRE140]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'We can even define our own tokens as shown in the following code:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以像下面的代码中所示定义自己的令牌：
- en: '[PRE141]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: If the referrer is the same as our host, we mask it with `#local#`. Later, we
    could filter all lines containing `#local#`.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引荐者与我们的主机相同，我们用`#local#`掩盖它。稍后，我们可以过滤掉所有包含`#local#`的行。
- en: 'By default, `logger` outputs to the console. However, we can pass it a stream
    to output to. Logger would allow us to stream logs over TCP, HTTP, or simply to
    a file. Let''s make our logs go to a file:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`logger`输出到控制台。但是，我们可以将其传递给一个流以进行输出。记录器可以让我们通过TCP、HTTP或简单地输出到文件来流式传输日志。让我们将我们的日志写入文件：
- en: '[PRE142]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This time we give `logger` an object instead of a string. In order to set the
    formatting through the object we set the `format` property. To redirect the stream
    of output, we create a `writeStream` to our desired log file.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们给`logger`一个对象而不是一个字符串。为了通过对象设置格式，我们设置`format`属性。为了重定向输出流，我们创建一个`writeStream`到我们想要的日志文件。
- en: Tip
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more logger options, see [http://www.senchalabs.org/connect/middleware-logger.html.](http://www.senchalabs.org/connect/middleware-logger.html.)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多日志记录器选项，请参阅[http://www.senchalabs.org/connect/middleware-logger.html.](http://www.senchalabs.org/connect/middleware-logger.html.)
- en: See also
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Dynamic routing* discussed in this chapter'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章讨论的动态路由*'
- en: '*Templating in Express* discussed in this chapter'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章讨论的Express中的模板*'
- en: '*CSS engines with Express* discussed in this chapter'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章讨论的Express中的CSS引擎*'
- en: '*Initializing and using a session* discussed in this chapter'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本章讨论的初始化和使用会话*'
