- en: Chapter 4. Coding – AJAX, Binding Properties, Mapping, and Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 编码 – AJAX、属性绑定、映射和实用工具
- en: 'There is an aspect of Knockout that takes repeated tasks out of the way. There
    is also the reality that we never expect it to do 100 percent of our work. It
    also makes sense that we do not have Knockout doing so much as it is not good
    at its core strengths. Here, we will learn how to extend our reach into Knockout
    and how to connect to the world outside Knockout and do even more. This chapter
    will focus on:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout有一个方面可以消除重复的任务。还有这样一个现实，我们从未期望它完成100%的工作。它也很有道理，我们不希望Knockout做这么多，因为它在核心优势方面并不擅长。在这里，我们将学习如何扩展Knockout的覆盖范围，以及如何连接到Knockout之外的世界并做更多的事情。本章将重点介绍：
- en: Working with JSON
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与JSON一起工作
- en: Mapping versus manual ViewModels
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射与手动ViewModel
- en: Working with AJAX requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与AJAX请求一起工作
- en: Unmapping your data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解除数据映射
- en: Managed mapping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理映射
- en: Utility functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用函数
- en: In this chapter, we will be learning about some of the commonly used aspects
    of Knockout—working with JSON and the mapping plugin. These two are simple and
    powerful pivots where we will extend rapid application development with Knockout.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于Knockout的一些常用方面——与JSON一起工作以及映射插件。这两个都是简单而强大的枢纽，我们将通过Knockout扩展快速应用开发。
- en: JSON done Knockout style
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON done Knockout style
- en: 'JSON is the famous data packaging standard that seems to have taken over the
    Internet. At one time there was XML; RoR has its own packaging standard; and even
    Adobe had perhaps the best performing way to package and deliver data between
    the client and the server called **Action Message Format** (**AMF**). The overall
    winner seems to be JSON because it is simple and based on the most common development
    platform of all: JavaScript. If you would like more information about JSON you
    can visit [http://json.org](http://json.org).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是著名的数据打包标准，似乎已经占据了整个互联网。曾经有XML；RoR有自己的打包标准；甚至Adobe也有可能性能最好的方式来打包和传输客户端与服务器之间的数据，称为**动作消息格式**（**AMF**）。总体赢家似乎还是JSON，因为它简单，并且基于所有开发平台中最常见的：JavaScript。如果你想了解更多关于JSON的信息，你可以访问[http://json.org](http://json.org)。
- en: 'To serve our purpose, let''s create a file called, `json.html`. The first thing
    we will do is convert a ViewModel to JSON. Most modern browsers have a function
    called `JSON.stringify` but that is not how we do it in Knockout. There are two
    methods included in Knockout:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到我们的目的，让我们创建一个名为`json.html`的文件。我们将要做的第一件事是将ViewModel转换为JSON。大多数现代浏览器都有一个名为`JSON.stringify`的函数，但在Knockout中我们并不是这样做的。Knockout中包含两种方法：
- en: '`ko.toJS`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.toJS`'
- en: '`ko.toJSON`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.toJSON`'
- en: The first method, `ko.toJS`, will clone the Knockout data into a plain copy
    that contains no Knockout-related hints or information. The second method, `ko.toJSON`,
    will perform the `ko.toJS` action and then convert it into a serialized JSON string
    according to the JSON standard. If you are using older browsers such as IE7 or
    older, you will need to get a copy of the `json2.js` file, available at [https://github.com/douglascrockford/JSON-js/blob/master/json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，`ko.toJS`，将克隆Knockout数据到一个不包含任何Knockout相关提示或信息的普通副本。第二种方法，`ko.toJSON`，将执行`ko.toJS`操作，然后根据JSON标准将其转换为序列化的JSON字符串。如果你使用的是较旧的浏览器，如IE7或更早版本，你需要获取`json2.js`文件的副本，该文件可在[https://github.com/douglascrockford/JSON-js/blob/master/json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js)找到。
- en: 'Now enter the following code into your file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下代码输入到你的文件中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we will look at our structure stored in the ViewModel. We will be using
    Chrome as our browser but you can use any browser with development tools that
    support the console command. Here is the result we got by dumping our ViewModel.
    Type `console.log(vm)` in the console to get the results stored in `vm`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看存储在ViewModel中的结构。我们将使用Chrome作为我们的浏览器，但你可以使用任何带有支持控制台命令的开发工具的浏览器。以下是我们的ViewModel转储得到的结果。在控制台中输入`console.log(vm)`以获取存储在`vm`中的结果：
- en: '![JSON done Knockout style](img/1028OS_04_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![JSON done Knockout style](img/1028OS_04_01.jpg)'
- en: It is plainly visible that while a full exposure of our ViewModel is there,
    packaged in functions. You will get used to ignoring the `undefined` item`,` when
    dumping stuff into the console. If you get the results expected then don't get
    distracted by that item.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，虽然我们的ViewModel完全暴露在函数中，但你将习惯于在将内容倒入控制台时忽略`undefined`项`,`。如果你得到预期的结果，那么不要被该项分散注意力。
- en: 'This is where we use the two commands, which are `ko.toJS` and `ko.toJSON`.
    Let''s start by dumping the ViewModel to the console using the structure. Type
    `console.log( ko.toJS(vm) )` in the console:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了两个命令，即`ko.toJS`和`ko.toJSON`。让我们首先使用结构将ViewModel输出到控制台。在控制台中输入`console.log(
    ko.toJS(vm) )`：
- en: '![JSON done Knockout style](img/1028OS_04_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![以Knockout风格完成的JSON](img/1028OS_04_02.jpg)'
- en: 'Here, we see `console.log` versus dump. This is great, but if we wanted to
    send this out to an external source or store it using modern browser storage technology
    we would still want to package it as a JSON string in most cases. This can be
    achieved using the helper `ko.toJSON` method, which is what we will be doing next.
    You will see this time our data has been placed in the middle of special characters.
    This is the JSON formatting, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到`console.log`与`dump`。这很好，但如果我们想要将其发送到外部源或使用现代浏览器存储技术存储它，我们通常仍然希望将其作为JSON字符串打包。这可以通过使用辅助函数`ko.toJSON`方法来实现，这正是我们接下来要做的。您会看到这次我们的数据被放置在特殊字符的中间。这是JSON格式化，如下面的截图所示：
- en: '![JSON done Knockout style](img/1028OS_04_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![以Knockout风格完成的JSON](img/1028OS_04_03.jpg)'
- en: 'Now, we will create `json2.html` to pull our JSON data into our app. We will
    need to copy and paste the JSON into our app but we will be doing that from a
    separate file in the same directory as the HTML file. Name that file `json2.txt`
    for this example. Certainly, on a live site don''t store sensitive data in a text
    file. In the `json2.txt` file copy the console output you got in the preceding
    example. This is your JSON data and it should look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`json2.html`来将我们的JSON数据拉入我们的应用。我们需要将JSON复制并粘贴到我们的应用中，但我们将从与HTML文件相同的目录中的另一个文件中执行此操作。在这个例子中，将该文件命名为`json2.txt`。当然，在实时网站上，不要将敏感数据存储在文本文件中。在`json2.txt`文件中，复制您在前一个示例中获得的控制台输出。这是您的JSON数据，它应该看起来像这样：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While this might look good, we have an issue. JSON doesn''t stand on its own
    feet. It needs to be inside a variable to be managed. We will change it as follows.
    We will use the variable, `myJSON`. We also need to surround the text in quotes.
    Since the JSON tends to use double quotes internally, the traditional way to handle
    this is to use a single quote before the data string and a single quote at the
    end, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来不错，但我们有一个问题。JSON不能独立存在。它需要在一个变量中才能被管理。我们将按以下方式更改它。我们将使用变量`myJSON`。我们还需要在文本周围加上引号。由于JSON通常在内部使用双引号，处理这种情况的传统方法是在数据字符串之前使用单引号，并在末尾使用单引号，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code is used for our `json2.html` file. We will use the `script`
    command to pull the external data into the page. It is also common for people
    to name such a static file `json2.json`. We are using the `.text` extension to
    make a point that JSON is just a text file here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于我们的`json2.html`文件。我们将使用`script`命令将外部数据拉入页面。人们通常也会将这样的静态文件命名为`json2.json`。我们使用`.text`扩展名是为了强调这里的JSON只是一个文本文件：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We start out our ViewModel this time with structure but absolutely no data.
    After binding the ViewModel to our data model, we convert our string of JSON data
    into a standard JavaScript structure. We then use the standard JavaScript to pass
    the arrays into the `foodItems` and the `foods` attributes of our ViewModel. While
    that is neat, it doesn''t feel like we actually did something of value. Let''s
    add some View code onto the page above the `script` section, as follows. This
    is the same code we used in the previous chapter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们以结构开始我们的ViewModel，但没有任何数据。在将ViewModel绑定到我们的数据模型后，我们将我们的JSON数据字符串转换为标准的JavaScript结构。然后，我们使用标准的JavaScript将数组传递到ViewModel的`foodItems`和`foods`属性。虽然这样做很整洁，但感觉我们实际上并没有做任何有价值的事情。让我们在`script`部分上方添加一些View代码，如下所示。这是我们在上一章中使用过的相同代码：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What we see is a web page that pulls the external data in and automatically
    populates the View for us based on that data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是一个网页，它拉取外部数据，并自动根据该数据填充视图：
- en: '![JSON done Knockout style](img/1028OS_04_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![以Knockout风格完成的JSON](img/1028OS_04_04.jpg)'
- en: Mapping – first look
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射 - 首次查看
- en: We have been creating manual maps of our ViewModel so far in this book. With
    smaller datasets this can be practical and productive. As our datasets get larger
    along with the need to update the data, this will become a chore that has an alternative,
    enjoyed by a great number of Knockout developers. This is done through a mapping
    plugin. Knockout is a jQuery-based library in more than one way. It is possible
    to build and use libraries, called plugins, for Knockout also. The most famous
    library is the mapping library. I have included a copy of it in the downloaded
    files for this book. We will be looking again at the preceding code for our example
    but moving it this time using the mapping plugin.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在本书中手动创建ViewModel的映射。对于较小的数据集，这可能是实用且高效的。随着数据集的增大以及更新数据的需求，这将变成一项繁琐的工作，有一个替代方案，许多Knockout开发者都喜欢。这是通过映射插件完成的。Knockout是一个基于jQuery的库，在多个方面都是如此。对于Knockout，也有可能构建和使用称为插件的库。最著名的库是映射库。我已经在本书的下载文件中包含了一个副本。我们将再次查看我们示例中的先前代码，但这次我们将使用映射插件来移动它。
- en: 'We will create a file called `mapping.html` for our code this time. We will
    need to include one more JavaScript file right after the Knockout call for our
    mapping plugin. You can find these files in the working examples folder in the
    ZIP download. This, in our case, should look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次将为我们的代码创建一个名为`mapping.html`的文件。我们将在Knockout调用之后立即包含一个额外的JavaScript文件，用于我们的映射插件。你可以在ZIP下载的工作示例文件夹中找到这些文件。在我们的情况下，它应该看起来像这样：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create both of those files if you wish, but we suggest just copying them from
    the `done` folder in this chapter and making sure they are in the same folder
    as the `mapping.html` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建这两个文件，我们建议你只从本章的`done`文件夹中复制它们，并确保它们与`mapping.html`文件在同一个文件夹中。
- en: Connecting with AJAX remotely
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过AJAX远程连接
- en: 'Using a `script` tag to load data is definitely not very sophisticated. We
    are going to improve this by creating the example again, but this time using jQuery
    to make our AJAX request. We will put this code in a file named `ajax.html`. We
    will use the same HTML code as before, but we will add a button to the form using
    the following lines of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`script`标签来加载数据显然不是非常复杂。我们将通过再次创建示例来改进这一点，但这次我们将使用jQuery来执行我们的AJAX请求。我们将把这个代码放在一个名为`ajax.html`的文件中。我们将使用之前相同的HTML代码，但我们将添加一个按钮到表单中，使用以下代码行：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `pullData` request will be a method/function that we add to our ViewModel.
    It will be used, at this time, to pull the data from the server and update the
    View in our browser. Here is the `script` section of code we will use for this
    example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`pullData`请求将是我们添加到ViewModel中的方法/函数。目前，它将用于从服务器获取数据并更新我们浏览器中的视图。以下是本例中我们将使用的`script`代码段：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Please note that I am going to try to get you into the habit of using—this is
    a phrase I made up and like—"selfish coding". Because there is a risk of interaction
    with our code having the `this` value, debugging "this" issue is not fun. We have
    learned to use the `self` alias to make sure this does not become an issue. The
    `.done()` function is a chained command in jQuery to handle the completion of
    a good request to the server. See the jQuery documents for more handlers; you
    can use those docs to make your code even more fully responsive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我将尝试让你养成使用——这是一个我编造的短语，并且我喜欢——“自私的编码”的习惯。因为我们的代码与具有`this`值的交互存在风险，调试“this”问题并不有趣。我们已经学会了使用`self`别名来确保这不会成为一个问题。`.done()`函数是jQuery中的一个链式命令，用于处理对服务器的良好请求的完成。请参阅jQuery文档以获取更多处理程序；你可以使用这些文档使你的代码更加完全响应。
- en: 'We have created a function/method called `pullData`. Inside the data we will
    use a `jQuery.getJSON` request to pull our data back from the server. We have
    copied the JSON structure to a file called `data.json` this time. Make sure you
    do not assign this to a variable; you only want the structure of the JSON as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`pullData`的函数/方法。在数据内部，我们将使用`jQuery.getJSON`请求从服务器拉回我们的数据。我们这次将JSON结构复制到一个名为`data.json`的文件中。确保不要将其分配给变量；你只想得到如下的JSON结构：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s look at our initial screen when we load the page. Here is what you
    should get:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们加载页面时的初始屏幕。你应该得到以下内容：
- en: '![Connecting with AJAX remotely](img/1028OS_04_05.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![通过AJAX远程连接](img/1028OS_04_05.jpg)'
- en: 'When we click the **Pull Data** button we will see the results automatically
    update to the following view:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**拉取数据**按钮时，我们会看到结果自动更新到以下视图：
- en: '![Connecting with AJAX remotely](img/1028OS_04_06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![通过AJAX远程连接](img/1028OS_04_06.jpg)'
- en: 'This is already much better coding than a pure JavaScript experience for many
    developers. Yet, what if this form had 40 elements on the page? It would be a
    big block of code to set the ViewModel up for that much binding. We just learned
    about mapping; so what if we included the mapping plugin and reworked our code?
    Take a look at the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于许多开发者来说已经比纯JavaScript体验好多了。然而，如果这个表单在页面上有40个元素呢？这将是一个很大的代码块来设置ViewModel以进行那么多绑定。我们刚刚学习了映射；那么，如果我们包含映射插件并重新编写我们的代码会怎样呢？看看以下代码片段：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see a few changes in our approach. We could have just put the filename
    into the `getJSON` request, but we passed it in as a variable just as a matter
    of how we like to code. We also created the `vm` variable to hold our ViewModel.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的方法中的一些变化。我们本可以直接将文件名放入`getJSON`请求中，但我们只是按照我们喜欢的方式将其作为变量传递。我们还创建了`vm`变量来保存我们的ViewModel。
- en: The AJAX has been moved outside the ViewModel while the ViewModel declaration
    has been moved inside the AJAX. It is inside out compared to our last example.
    The difference is that we see the data populate our View immediately as the page
    loads. We have also changed the functionality of our `pullData` function. Now,
    it will be used to make a second call to the server. Normally, we would not reset
    this source file as it would be a typical AJAX request to see whether anything
    was updated. Since we are not coding for a dynamic server we will just show an
    imitation of that scenario here by changing the name of the source for our AJAX
    request.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX已经被移出ViewModel，而ViewModel的声明已经被移入AJAX。与上一个例子相比，它是反过来的。区别在于我们看到数据在页面加载时立即填充到视图中。我们还改变了`pullData`函数的功能。现在，它将被用来对服务器进行第二次调用。通常，我们不会重置这个源文件，因为它将是一个典型的AJAX请求，以查看是否有任何更新。由于我们不是为动态服务器编写代码，所以我们在这里通过更改AJAX请求的源名称来展示这个场景的模仿。
- en: Now, when doing mapping we have to declare the mapping features before we use
    the `applyBindings` method. This gives us the same results as manually creating
    each individual binding. Again, for a simple form like this the gain is not so
    obvious. When we get to larger, more complex pages, the gain is amazing. Oh, also
    note that when we run additional calls to the server we will be updating the data.
    We need to pass in the ViewModel variable after our data as we map an update.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们进行映射时，我们必须在使用`applyBindings`方法之前声明映射功能。这给我们带来了与手动创建每个单独绑定相同的结果。再次强调，对于这样一个简单的表单，这种收益并不明显。当我们到达更大、更复杂的页面时，收益是惊人的。哦，还要注意，当我们对服务器进行额外的调用时，我们将更新数据。我们需要在映射数据后传递ViewModel变量。
- en: 'Now, we will take another look at what we get by running our code with a little
    more progressive AJAX. The first load looks like the pulled data from our last
    example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次查看通过运行带有更多渐进式AJAX的代码我们能得到什么。第一次加载看起来就像是从我们上一个例子中拉取的数据：
- en: '![Connecting with AJAX remotely](img/1028OS_04_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![通过AJAX远程连接](img/1028OS_04_07.jpg)'
- en: 'We created an additional item; so when we load the update it will be obvious.
    The item is **Ice Cream**. We also preselected this item. Here is our JSON data
    structure for the second load:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个额外的项目；因此，当我们加载更新时，它将变得明显。这个项目是**冰淇淋**。我们还预先选择了这个项目。以下是第二次加载的JSON数据结构：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we push the button now to pull the update this is what we should see:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们按下按钮来拉取更新，我们应该看到以下内容：
- en: '![Connecting with AJAX remotely](img/1028OS_04_08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![通过AJAX远程连接](img/1028OS_04_08.jpg)'
- en: Unmapping your data
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解除数据映射
- en: This is coming along good but there is something we are going to need for most
    AJAX-based web applications. We are going to need to store the data back on the
    server. Pulling the data to the browser will not be enough. We will require the
    ability to push the data back to the server as well. Once again, we will be using
    jQuery for this function. Of course, we will show the code to do this but we will
    approach it differently because different readers will be using different backends
    such as ASP.NET, ColdFusion, Node.js, PHP, Python, Ruby, and others.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这进展得很好，但我们需要为大多数基于AJAX的Web应用程序做一些事情。我们需要将数据存储在服务器上。仅仅将数据拉到浏览器是不够的。我们还需要能够将数据推回服务器。我们再次将使用jQuery来完成这个功能。当然，我们将展示如何做到这一点的代码，但我们将以不同的方式来处理，因为不同的读者将使用不同的后端，如ASP.NET、ColdFusion、Node.js、PHP、Python、Ruby和其他。
- en: 'This time, just modify the code in the `AJAX.html` file unless, of course,
    you want to create a new file. We will be adding another button to our View to
    connect a push data method this time:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，除非你想要创建一个新文件，否则只需修改`AJAX.html`文件中的代码。我们将向我们的视图添加另一个按钮，这次连接一个推送数据方法：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will also need to put a textbox at the end of our View code to see the data
    that is pulled out of our ViewModel. Create the `textarea` field to hold the results:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的视图代码的末尾添加一个文本框，以便查看从我们的ViewModel中提取的数据。创建一个`textarea`字段来保存结果：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will need to add another method to our ViewModel now:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要向我们的ViewModel添加另一个方法：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We saw the code that would be used to send a request back to the server. We
    are assuming in this example that our server was able to respond to the URL in
    the `reqAJAX` variable and handle data coming into the server. If not, all you
    would need to do is set that variable to the target that can take data. The data
    is being sent in this case in the `POST` form of data. This would be the same
    as a form using the `POST` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了用于向服务器发送请求的代码。在这个例子中，我们假设我们的服务器能够响应该`reqAJAX`变量中的URL并处理进入服务器的数据。如果不能，你只需要将该变量设置为可以接收数据的目标。在这种情况下，数据是以`POST`形式发送的。这和表单使用`POST`方法是一样的。
- en: 'You should see all we did was add the ability to pull the results back out
    as a variable named `myData`. If we ran the code again, pulled data, and set the
    selections to just eggs and ice cream, we would be able to test the data being
    pushed back to the server. Notice we have the jQuery command to push the `myData`
    results to the `textarea` field. Here are the results we see:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到我们只是添加了将结果拉回作为名为`myData`的变量的能力。如果我们再次运行代码，提取数据，并将选择设置为仅鸡蛋和冰淇淋，我们就能测试被推回服务器的数据。注意我们有了将`myData`结果推送到`textarea`字段的jQuery命令。以下是我们看到的结果：
- en: '![Unmapping your data](img/1028OS_04_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![取消映射你的数据](img/1028OS_04_09.jpg)'
- en: We have what seems to be an issue with extra data. We don't have to manage that
    but it is not hard to fix. The issue occurs because when data is mapped it creates
    extra details internally. These come back out when unmapping the data. You can
    leave that if you choose or you can fix it using the following code. We will write
    a `console.log` command that will dump the structure to the console. We also need
    to change `myData` to return the JavaScript structure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们似乎遇到了一个与额外数据相关的问题。我们不必管理它，但修复起来并不难。这个问题发生是因为当数据被映射时，它会在内部创建额外的细节。这些细节在取消映射数据时会被带出来。如果你选择的话，可以保留这些细节，或者你可以使用以下代码来修复它。我们将编写一个`console.log`命令，将结构输出到控制台。我们还需要将`myData`更改为返回JavaScript结构。
- en: 'If we look at our developer tools console for our browser we will see the following
    structure for our dump. Then we will use `JSON.stringify()` to make it ready for
    AJAX:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看浏览器开发者工具的控制台，我们将看到以下结构用于我们的输出。然后我们将使用`JSON.stringify()`使其准备好AJAX：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We see the change to the `myData` variable and the console log to manage the
    dump. The extra detail in the console log is part of the `__ko_mapping__` data
    structure. Using the JavaScript delete command, we can trim it right off our results.
    Some functions are showing, but when we use the `stringify` function, it does
    not pull them. Here is what we get now:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`myData`变量和用于管理输出的控制台日志的变化。控制台日志中的额外细节是`__ko_mapping__`数据结构的一部分。使用JavaScript的删除命令，我们可以直接从我们的结果中移除它。一些函数显示出来了，但当我们使用`stringify`函数时，它不会拉取它们。以下是我们现在得到的内容：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we are doing meaningful AJAX interaction. You may want to send even less
    structure back to the server than we did here. There is the option of trimming
    even more data to keep things as compact as possible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在进行有意义的AJAX交互。你可能希望向服务器发送比这里更少的结构。有选项可以进一步裁剪数据，以使事物尽可能紧凑。
- en: Oh, for a live app, *remember* to remove the console log and the `textarea`
    field. Don't say I taught you to leave those in a real world web page!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，对于实时应用，*记住*要移除控制台日志和`textarea`字段。别说我教你把那些留在真实世界的网页上！
- en: Merging mapped data
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并映射数据
- en: 'There are times you may want to pull data into your ViewModel from multiple
    sources. When doing this you can create a map for each source. If the source variables
    have the same name they will overwrite the existing variables. As long as the
    base variable is a different name it will merge them into the ViewModel. Do this
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想要从多个来源将数据拉入你的ViewModel。当你这样做时，你可以为每个来源创建一个映射。如果源变量具有相同的名称，它们将覆盖现有的变量。只要基本变量具有不同的名称，它就会将它们合并到ViewModel中。如下这样做：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What you get is a combination of the `firstData` JavaScript structure, mapped
    with `firstMap`, combined with the `nextData` JavaScript structure, and with the
    `nextMap` mapping. If there are any duplicate base structures in `nextData`, they
    will override the same structures in the existing `firstData` JavaScript structure.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的是 `firstData` JavaScript 结构与 `firstMap` 映射的组合，再加上 `nextData` JavaScript
    结构和 `nextMap` 映射。如果 `nextData` 中有任何重复的基本结构，它们将覆盖现有 `firstData` JavaScript 结构中的相同结构。
- en: Mapping options
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射选项
- en: 'There are times when you are loading data into a page application that doesn''t
    need to be changed. This is just static data and making it observable spends extra
    processor time and memory resources for no gain. When passing data into the mapping
    handler, you can set which items are mapped as observable items, using the following
    lines of code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你将数据加载到不需要更改的页面应用程序中时，这只是一个静态数据，将其转换为可观察数据会额外消耗处理器时间和内存资源，而没有任何收益。在将数据传递到映射处理程序时，你可以设置哪些项目被映射为可观察项目，使用以下代码行：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The results we get from the `result` and `result2` variables will be the same.
    Why? This is because when we declare the `observe` items the other items are assumed
    to be copied items. If a single item is passed in we can declare it outside an
    array, as we did with `a`. If multiple items are passed in we would declare them
    in an array, as `["a","c"]`. This would make both `a` and `c` observable items.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `result` 和 `result2` 变量得到的结果将相同。为什么？这是因为当我们声明 `observe` 项目时，其他项目被认为是复制项目。如果传递单个项目，我们可以在数组外声明它，就像我们用
    `a` 做的那样。如果传递多个项目，我们将在数组中声明它们，例如 `["a","c"]`。这将使 `a` 和 `c` 都成为可观察项目。
- en: If we just wanted to declare an item to copy we would pass in the copy and that
    is the only item that would be directly copied. We also have the ability to ignore
    items from being copied in during the mapping using `ignore`, of course.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想声明一个要复制的项目，我们可以传递复制的内容，这将直接复制的唯一项目。当然，我们还有能力在映射过程中忽略要复制的项目，使用 `ignore`。
- en: Utility functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具函数
- en: There are a number of functions in `ko.utils`. Let's start by looking at the
    special array methods in standard Knockout.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.utils` 中有许多函数。让我们首先看看标准 Knockout 中的特殊数组方法。'
- en: ko.utils.arrayFilter()
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ko.utils.arrayFilter()
- en: 'The `ko.utils.arrayFilter` function allows us to filter items in an array.
    We are going to run these as straight code examples. We will create a sample JSON
    file and load it via AJAX to keep the focus on learning the methods and not waste
    time creating an example code set. We will create a page called `utility.html`
    for these pieces of code and run the filtering code from there. Our markup for
    this example is here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.utils.arrayFilter` 函数允许我们在数组中过滤项目。我们将直接作为代码示例运行这些。我们将创建一个示例 JSON 文件并通过
    AJAX 加载它，以保持对学习方法的关注，而不是浪费时间创建示例代码集。我们将创建一个名为 `utility.html` 的页面来运行这些代码，并从那里运行过滤代码。我们的示例标记如下：'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our `script` code is as follows. We will be adding more for each example as
    we go, but here are the basics for the utility examples:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `script` 代码如下。随着我们继续添加每个示例，我们将添加更多内容，但这里是对工具示例的基本介绍：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We set our mapping using the data and then we begin adding our custom features.
    These could be custom functions or computed values. Lastly, after adding all our
    customizations to the mapping we apply our bindings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数据设置映射，然后开始添加我们的自定义功能。这些可以是自定义函数或计算值。最后，在将所有自定义修改应用到映射后，我们应用绑定。
- en: In our code sample we showed you how to use `arrayFilter`. The `arrayFilter`
    function will pass in the items one at a time and will include the ones in the
    result set in which we send out a true value to let it know that it should be
    included.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们向您展示了如何使用 `arrayFilter`。`arrayFilter` 函数将逐个传递项目，并将包含在结果集中，其中我们发送一个
    true 值来告知它应该被包含。
- en: 'Here is the JSON we will use for our examples. We will show the whole dataset
    here. Note that the JSON is also in our `done` folder under the `utility.json`
    file if you do not want to type it in. Normally, I would suggest typing in these
    examples to strengthen your skills on the topic:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将用于示例的 JSON。我们将在这里展示整个数据集。请注意，如果不想手动输入，JSON 也在我们的 `done` 文件夹下的 `utility.json`
    文件中。通常，我会建议手动输入这些示例，以加强你在该主题上的技能：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, we used the following dataset to create our JSON. We just called the
    `JSON.stringify` method on the dataset. Here is the code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用了以下数据集来创建我们的 JSON。我们只是对数据集调用了 `JSON.stringify` 方法。以下是代码：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We still need to include our jQuery, Knockout, and Knockout mapping JavaScript
    files. When you get all these pulled together with the preceding code, this is
    what you should see in your browser:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要包含我们的 jQuery、Knockout 和 Knockout 映射 JavaScript 文件。当你将所有这些代码组合在一起时，你应在浏览器中看到以下内容：
- en: '![ko.utils.arrayFilter()](img/1028OS_04_10.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![ko.utils.arrayFilter()](img/1028OS_04_10.jpg)'
- en: We see that our filtered results only return two of the six items. This is because
    only two of them were less than 35\. What is even more fun is that this data is
    dynamically wired into the View model. If the arrays change by adding or removing
    items the screen will update automatically. This is just not wired into jQuery
    so it's a great addition. Also, if a value within an array item changes, say one
    of the ages, then the filter here will automatically know to add, remove, or leave
    the item in the view list.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的过滤结果只返回了六个项目中的两个。这是因为其中只有两个小于 35。更有趣的是，这些数据是动态连接到 View 模型的。如果数组通过添加或删除项目而发生变化，屏幕将自动更新。这并不是连接到
    jQuery，所以这是一个很好的补充。此外，如果数组项中的值发生变化，比如年龄之一，那么这里的过滤器将自动知道要添加、删除或保留项目在视图列表中。
- en: ko.utils.arrayFirst()
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ko.utils.arrayFirst()`'
- en: 'The `ko.utils.arrayFirst` method will pass items into the function to be searched
    until a match is found or declared. It will only return one item from the array.
    Here is the View code to add for this example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.utils.arrayFirst` 方法会将项目传递给要搜索的函数，直到找到匹配项或声明。它只会从数组中返回一个项目。以下是添加到这个示例中的
    View 代码：'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the logic to add to understand our `arrayFirst` utility command. Add
    it before the binding is set in our script:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是添加到理解我们的 `arrayFirst` 工具命令的逻辑。在脚本中绑定设置之前添加它：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Like the last utility method, the results are triggered by the true value coming
    back out. The difference in this example is that the first true value will be
    the only one ever returned. Here is a screenshot of our results:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个实用方法一样，结果是由返回的 true 值触发的。这个例子中的不同之处在于，第一个 true 值将是唯一返回的值。以下是我们的结果截图：
- en: '![ko.utils.arrayFirst()](img/1028OS_04_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![ko.utils.arrayFirst()](img/1028OS_04_11.jpg)'
- en: ko.utils.arrayMap()
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ko.utils.arrayMap()`'
- en: 'The `ko.utils.arrayMap` method allows creation of a flattened array. What this
    means is that sometimes we have an array of structures and want just a particular
    item for the whole structure to be pulled back into a simple array. Here is the
    markup code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.utils.arrayMap` 方法允许创建一个扁平化的数组。这意味着有时我们有一个结构数组，只想获取整个结构中的特定项，将其拉回到一个简单的数组中。以下是标记代码：'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the script code we need to add for this example. We will not return
    true or false style results this time. We will return a value that will, in this
    case, create a simple value array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是需要添加到这个示例中的脚本代码。这次我们不会返回 true 或 false 类型的结果。我们将返回一个值，在这种情况下，将创建一个简单的值数组：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the screen result you will see with our dataset:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将看到的屏幕结果，使用我们的数据集：
- en: '![ko.utils.arrayMap()](img/1028OS_04_12.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![ko.utils.arrayMap()](img/1028OS_04_12.jpg)'
- en: 'It is possible to actually modify the structure that is being passed into the
    process by modifying the item. This is because normally, structures and arrays
    are passed in by setting a reference to the source structure in memory. This means
    even though the name item is what is coming in, the item points to the original
    structure in the ViewModel. Here is another method we could have used if we wanted
    to modify the original structure within the ViewModel:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改项目，实际上可以修改传递给过程的结构。这是因为通常，结构和数组是通过在内存中设置对源结构的引用来传递的。这意味着尽管传入的是名称项，但项目指向
    ViewModel 中的原始结构。以下是如果我们想修改 ViewModel 中的原始结构可以使用的另一个方法：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The results would be a value nested within the ViewModel array collection, but
    the value would not be observed or computed. This means while it may work, it
    will not work with all the features of Knockout. So it should be tested carefully
    before trying this. If in doubt, avoid this approach to avoid unplanned features.
    Oh, you could also delete item fields, so beware that you are editing the original
    structure and anything connected is at risk if you manually change these things.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个嵌套在 ViewModel 数组集合中的值，但该值不会被观察或计算。这意味着虽然它可能工作，但它不会与 Knockout 的所有功能一起工作。因此，在尝试之前应该仔细测试。如果有疑问，为了避免意外功能，请避免这种方法。哦，你也可以删除项目字段，所以请注意，你正在编辑原始结构，如果你手动更改这些内容，任何与之相关的内容都处于风险之中。
- en: ko.utils.arrayGetDistinctValues ()
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ko.utils.arrayGetDistinctValues ()`'
- en: 'The `ko.utils.arrayGetDistinctValues` method allows you to take an array and
    remove duplicate values, leaving only distinct items. This time we will be dealing
    with a result set that is an array, so again in the View we will be using the
    foreach method on our `data-bind` attribute:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.utils.arrayGetDistinctValues` 方法允许您从一个数组中移除重复值，只留下唯一的项目。这次我们将处理一个结果集，它是一个数组，因此我们再次在视图的
    `data-bind` 属性上使用 foreach 方法：'
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You may have noticed that we are inserting two segments this time. This is
    because `arrayGetDistintValues` modifies another array. We need the array it is
    going to modify. What we will do is create an array of all the ages using our
    `arrayMap` method, and then create another result with only the distinct values
    in it. In our script code, we again need to set `arrayGetDistinctValues` before
    the `applyBindings` command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到这次我们插入了两个段。这是因为 `arrayGetDistinctValues` 修改了另一个数组。我们需要它将要修改的数组。我们将要做的是使用我们的
    `arrayMap` 方法创建一个包含所有年龄的数组，然后创建另一个只包含其中唯一值的数组。在我们的脚本代码中，我们再次需要在 `applyBindings`
    命令之前设置 `arrayGetDistinctValues`：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is a screenshot of both sets of results:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两组结果截图：
- en: '![ko.utils.arrayGetDistinctValues ()](img/1028OS_04_13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![ko.utils.arrayGetDistinctValues ()](img/1028OS_04_13.jpg)'
- en: The first set was sorted in the call to the unique value set. This is something
    to watch out for as it can be confusing when something like this happens. We included
    it here for some food for thought and to illustrate, again, the need to be aware
    that you might be performing a command on the original set of data. If you were
    to follow best practice you might sort the results of the unique years, if that
    was your goal, rather than sorting the input data within the method. This is also
    an example of where an external variable is visible even though the sort call
    happened within the method arguments.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组在调用唯一值集时进行了排序。这是需要注意的一点，因为当发生这种情况时可能会令人困惑。我们将其包括在这里，以便提供一些思考的食物，并再次说明需要意识到您可能正在对原始数据集执行命令。如果您遵循最佳实践，您可能会对唯一的年份结果进行排序，如果这是您的目标，而不是在方法中对输入数据进行排序。这也是一个外部变量即使在方法参数中发生排序调用时也能可见的例子。
- en: ko.utils.arrayForEach()
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ko.utils.arrayForEach()
- en: The `ko.utils.arrayForEach` method will allow you to loop through an array.
    This can be great for doing totals or other logic pulled from a summary of looking
    at individual objects. You could return all workers with children, for instance.
    While the most ideal place may be to do this coming from the database, this does
    not make it the only place it can ever be done. It is good practice to review
    where and why we do things to make sure our apps are performing and can scale
    as much as needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.utils.arrayForEach` 方法将允许您遍历一个数组。这对于执行总计或其他从总结中提取的逻辑非常有用。例如，您可以返回所有有孩子的工人。虽然最理想的地方可能是从数据库中这样做，但这并不意味着它只能在那里完成。审查我们在哪里以及为什么做事情是良好的实践，以确保我们的应用程序可以按需进行性能和扩展。'
- en: 'Our View code this time will be using a non-array value so we will not be using
    a foreach method. The reason we bring that up again here is if you use a wrong
    method your page will fail to run correctly. Often, the issue is as simple as
    trying to call an array method on a non-array property of the ViewModel. This
    is the kind of routine issue that can challenge any developer. Here is the View
    code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次的视图代码将使用非数组值，因此我们不会使用 foreach 方法。我们再次提到这一点的原因是，如果您使用错误的方法，您的页面将无法正确运行。通常，问题可能只是尝试在
    ViewModel 的非数组属性上调用数组方法。这是任何开发者都可能面临的常规问题。以下是视图代码：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Just in case you missed me saying this somewhere in this book, let me make
    a point. In Knockout, a little bit of code has a lot of power. Here is the code
    for our total age processing:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就怕我在这本书的某个地方没有说过，让我明确一点。在 Knockout 中，一点点的代码就有很大的力量。以下是我们的总年龄处理代码：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And of course, we get a total of the ages in our screenshot as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在截图中也得到了总年龄如下：
- en: '![ko.utils.arrayForEach()](img/1028OS_04_14.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![ko.utils.arrayForEach()](img/1028OS_04_14.jpg)'
- en: ko.utils.compareArrays()
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ko.utils.compareArrays()
- en: This allows you to compare arrays and return a collection, showing all items
    from both arrays. If the item did not exist in the second collection it will be
    shown as deleted. If the item is in the second set but not in the first set it
    will be shown as added. The return set will also show the index of the item where
    it exists.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您比较数组并返回一个集合，显示来自两个数组的所有项目。如果项目在第二个集合中不存在，则将其显示为已删除。如果项目在第二个集合中但不在第一个集合中，则将其显示为已添加。返回的集合还将显示项目存在的索引。
- en: 'Here is our View code for the last array example on `compareArrays`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`compareArrays`上最后一个数组示例的视图代码：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our script code is once again simple, and hopefully by working through coding
    each of these by hand, they have become more natural to you also. Here is the
    `script` code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本代码再次很简单，希望通过手动处理每个这些代码，它们对你来说也变得更加自然。以下是`script`代码：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the screenshot of our code running:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码运行的截图：
- en: '![ko.utils.compareArrays()](img/1028OS_04_15.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![ko.utils.compareArrays()](img/1028OS_04_15.jpg)'
- en: 'We wanted to include a console log from the browser developer tools as we thought
    Chrome showed the structure nicely:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想从浏览器开发者工具中包含一个控制台日志，因为我们认为Chrome显示了很好的结构：
- en: '![ko.utils.compareArrays()](img/1028OS_04_16.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![ko.utils.compareArrays()](img/1028OS_04_16.jpg)'
- en: Purifying our computations
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯化我们的计算
- en: Now we are going to redo the `script` section of code using `pureComputed` versus
    `computed`. The term `pureComputed` was inspired by the concept of pure functions
    as a style of programming. It is nothing you need to understand to use so don't
    get caught up with the semantics of the name as there is no practical win as far
    as learning how these pure computations benefit us here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`pureComputed`而不是`computed`来重做代码的`script`部分。术语`pureComputed`是从纯函数作为编程风格的概念中获得的灵感。这并不是你需要理解才能使用的东西，所以不要被名称的语义所困扰，因为就学习这些纯计算如何对我们在这里有所帮助而言，并没有实际的收益。
- en: When Knockout has something watching, a computed item is called a subscriber.
    Thus, it is considered to be a subscriber dependency. If we use the `pureComputed`
    method versus the `computed` method, Knockout will not calculate the value when
    there are no subscribers. This, of course, adds more speed to our processes by
    reducing calculations that aren't needed and unnecessary code from running. It
    is also another way to avoid any chance of memory issues.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当Knockout有东西在监视时，一个计算项被称为订阅者。因此，它被视为一个订阅者依赖项。如果我们使用`pureComputed`方法而不是`computed`方法，当没有订阅者时，Knockout不会计算值。这当然通过减少不必要的计算和运行不必要的代码来增加我们的处理速度。这也是避免任何内存问题的另一种方式。
- en: When there are no subscribers, a pure computed observable is considered to be
    **sleeping**. When there are subscribers it is considered to be **listening**.
    The term listening is a bit odd for me as to me it would be **responding**. It
    does make sense though, because it is a computing method. So it does need to listen
    to the values it is using to compute with. If any of those values change it needs
    to recalculate its results.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有订阅者时，纯计算可观察者被认为是**睡眠状态**。当有订阅者时，它被认为是**监听状态**。对我来说，术语“监听”有点奇怪，因为对我来说它应该是**响应**。尽管如此，这确实是有意义的，因为它是一种计算方法。所以它确实需要监听它用于计算的值。如果这些值中的任何一个发生变化，它需要重新计算其结果。
- en: 'Here is the updated script code moved to the better `pureComputed` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的脚本代码，移动到更好的`pureComputed`方法：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you want to know how many dependencies an item has, you can look at the
    `getDependenciesCount` method. Type the following into your console in your browser
    developer tools:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道一个项有多少个依赖项，你可以查看`getDependenciesCount`方法。在你的浏览器开发者工具的控制台中输入以下内容：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will show you how many items are subscribing to the `allYears` computed
    method. There is also a function that will tell us the number of items that are
    subscribing to the `allYears` calculation method, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示订阅`allYears`计算方法的项的数量。还有一个函数会告诉我们订阅`allYears`计算方法的项的数量，如下所示：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Coding documents for computed observables
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为计算可观察者编写代码文档
- en: We have included the following documents about observables just for reference
    here. While these were available online on the KnockoutJS site, it seemed like
    a good idea to include them here so you don't have to keep jumping between the
    website and the book.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里仅为了参考包含了以下关于可观察者的文档。虽然这些文档在KnockoutJS网站上可用，但将它们包含在这里似乎是个好主意，这样你就不必在网站和书籍之间跳来跳去了。
- en: A computed observable can be constructed using one of the following forms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 计算可观察者可以使用以下形式之一构建。
- en: Form 1
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格1
- en: 'The `ko.computed( evaluator [, targetObject, options] )` form supports the
    most common case of creating a computed observable. It has the following attributes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.computed( evaluator [, targetObject, options] )`形式支持创建计算可观察者的最常见情况。它有以下属性：'
- en: '`evaluator`: This is a function that is used to evaluate the computed observable''s
    current value.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaluator`：这是一个用于评估计算可观察者当前值的函数。'
- en: '`targetObject`: If given, it defines the value of `this` whenever Knockout
    invokes your callback functions.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetObject`: 如果提供，它定义了Knockout调用你的回调函数时`this`的值。'
- en: '`options`: This is an object with further properties for the computed observable.
    See the full list in the following section.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`: 这是一个对象，包含计算出的可观察对象的进一步属性。完整的列表见下文。'
- en: Form 2
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格2
- en: 'The `ko.computed( options )` parameter, is a single parameter form for creating
    a computed observable that accepts a JavaScript object with any of the following
    properties:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.computed( options )` 参数是一个用于创建计算出的可观察对象的单参数形式，它接受一个具有以下任何属性的JavaScript对象：'
- en: '`read`: This is a required function and used to evaluate the computed observable''s
    current value.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`: 这是一个必需的函数，用于评估计算出的可观察对象的当前值。'
- en: '`write`: This is an optional function and if given, this makes the computed
    observable writable. This function receives values that other code is trying to
    write to your computed observable. It''s up to you to supply custom logic to handle
    the incoming values, typically by writing the values to some underlying observable(s).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`: 这是一个可选函数。如果提供，这个函数使得计算出的可观察对象可写。这个函数接收其他代码尝试写入你的计算出的可观察对象的值。你需要提供自定义逻辑来处理传入的值，通常是通过将值写入某些底层可观察对象。'
- en: '`owner`: This is an optional function and, if given, it defines the value of
    `this` whenever Knockout invokes your `read` or `write` callbacks.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`: 这是一个可选函数，如果提供，它定义了Knockout调用你的`read`或`write`回调时`this`的值。'
- en: '`pure`: This is optional and if this is true, the computed observable will
    be set up as `purecomputed observable`. This option is an alternative to the `ko.pureComputed`
    constructor.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pure`: 这是一个可选参数。如果这个参数为真，计算出的可观察对象将被设置为`纯计算出的可观察对象`。这个选项是`ko.pureComputed`构造函数的替代。'
- en: '`deferEvaluation`: This is optional and if this option is true, then the value
    of the computed observable will not be evaluated until something actually attempts
    to access its value or manually subscribes to it. By default, a computed observable
    has its value determined immediately during creation.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deferEvaluation`: 这是一个可选参数。如果这个选项为真，那么计算出的可观察对象的值将不会在创建时立即评估，直到实际尝试访问其值或手动订阅它。'
- en: '`disposeWhen`: This is an optional function and if given, this function is
    executed before each re-evaluation to determine if the computed observable should
    be disposed. A true-ish result will trigger disposal of the computed observable.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disposeWhen`: 这是一个可选函数。如果提供，这个函数在每次重新评估之前执行，以确定是否应该销毁计算出的可观察对象。如果结果为真，将触发计算出的可观察对象的销毁。'
- en: '`disposeWhenNodeIsRemoved`: This is an optional function. If given, disposal
    of the computed observable will be triggered when the specified DOM node is removed
    by Knockout. This feature is used to dispose computed observables used in bindings
    when nodes are removed by the template and control-flow bindings.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disposeWhenNodeIsRemoved`: 这是一个可选函数。如果提供，当指定的DOM节点被Knockout移除时，将触发计算出的可观察对象的销毁。这个特性用于在模板和控制流绑定移除节点时销毁用于绑定的计算出的可观察对象。'
- en: Form 3
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格3
- en: The `ko.pureComputed( evaluator [, targetObject] )` form constructs `pure computed
    observable` using the given evaluator function and optional object to use for
    `this`. Unlike `ko.computed`, this method doesn't accept an `options` parameter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.pureComputed( evaluator [, targetObject] )` 形式使用给定的评估函数和可选对象来构建`纯计算出的可观察对象`。与`ko.computed`不同，这个方法不接受`options`参数。'
- en: Form 4
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格4
- en: The `ko.pureComputed( options )` form constructs a pure computed observable
    using an `options` object. This accepts the `read`, `write`, and `owner` options
    described previously.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.pureComputed( options )` 形式使用一个`options`对象来构建纯计算出的可观察对象。它接受之前描述的`read`、`write`和`owner`选项。'
- en: Using a computed observable
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算出的可观察对象
- en: 'A computed observable provides the following functions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出的可观察对象提供了以下函数：
- en: '`dispose()`: This manually disposes the computed observable, clearing all subscriptions
    to dependencies. This function is useful if you want to stop a computed observable
    from being updated or want to clean up memory for a computed observable that has
    dependencies on observables that won''t be cleaned.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispose()`: 这个函数手动销毁计算出的可观察对象，清除所有对依赖项的订阅。如果你想要停止计算出的可观察对象更新或想要清理依赖于不会清理的可观察对象的计算出的可观察对象的内存，这个函数很有用。'
- en: '`extend(extenders)`: This applies the given extenders to the computed observable.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extend(extenders)`: 这会将给定的扩展器应用到计算出的可观察对象上。'
- en: '`getDependenciesCount()`: This returns the current number of dependencies of
    the computed observable.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDependenciesCount()`: 这个函数返回计算可观察对象的当前依赖项数量。'
- en: '`getSubscriptionsCount()`: This returns the current number of subscriptions
    (either from other computed observables or manual subscriptions) of the computed
    observable.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSubscriptionsCount()`: 这个函数返回计算可观察对象的当前订阅数量（无论是来自其他计算可观察对象还是手动订阅）。'
- en: '`isActive()`: This returns whether the computed observable may be updated in
    the future. A computed observable is inactive if it has no dependencies.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isActive()`: 这个函数返回计算可观察对象是否可能在将来更新。如果没有依赖项，计算可观察对象是无活动的。'
- en: '`peek()`: This returns the current value of the computed observable without
    creating a dependency.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 这个函数返回计算可观察对象的当前值，而不创建依赖项。'
- en: '`subscribe( callback [,callbackTarget, event] )`: This registers `manual subscription`
    to be notified of changes to the computed observable.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe( callback [,callbackTarget, event] )`: 这个函数注册了`手动订阅`，以便在计算可观察对象发生变化时接收通知。'
- en: Using the computed context
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算上下文
- en: 'During the execution of a computed observable''s evaluator function, you can
    access `ko.computedContext` to get information about the current computed property.
    It provides the following functions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算可观察对象的评估函数执行期间，你可以访问`ko.computedContext`来获取有关当前计算属性的详细信息。它提供了以下函数：
- en: '`isInitial()`: This is a function that returns true if called during the first
    ever evaluation of the current computed observable, or false otherwise. For `pure`
    computed observables, `isInitial()` is always undefined.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isInitial()`: 这是一个函数，如果在当前计算可观察对象的第一次评估期间调用，则返回true，否则返回false。对于`纯`计算可观察对象，`isInitial()`始终是未定义的。'
- en: '`getDependenciesCount()`: This returns the number of dependencies of the computed
    observable detected so far during the current evaluation.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDependenciesCount()`: 这个函数返回当前评估期间检测到的计算可观察对象的依赖项数量。'
- en: Note
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ko.computedContext.getDependenciesCount()` function is equivalent to calling
    `getDependenciesCount()` on the computed observable itself. The reason that it
    also exists on `ko.computedContext` is to provide a way of counting the dependencies
    during the first ever evaluation, before the computed observable has even finished
    being constructed.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ko.computedContext.getDependenciesCount()`函数等同于在计算可观察对象本身上调用`getDependenciesCount()`。它之所以也存在于`ko.computedContext`上，是为了提供一个在计算可观察对象尚未完成构建之前，第一次评估期间计算依赖项的方法。'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter opens up a whole load of features and options to make web style
    coding powerful and elegant. Learning to let a library handle things for you is
    hard for some but that perspective is ironic as we are programming computers for
    others to let our work manage things for them. This chapter has added several
    valuable skills and options to our knowledge and experience:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们打开了大量功能和选项，使网络风格编码变得强大而优雅。对于一些人来说，学会让库为你处理事情是困难的，但这个观点是讽刺的，因为我们编程计算机是为了让其他人让我们的工作为他们管理事情。本章为我们知识和经验增添了几个有价值的技能和选项：
- en: We have learned to integrate data management in Knockout using JSON as an alternate
    way to pass data in and out.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何使用JSON作为传递数据进出的替代方式，将数据管理集成到Knockout中。
- en: We have seen the incredible power of mapping to make our code another magnitude
    of elegant using Knockout.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经看到了Knockout映射的强大功能，它使我们的代码变得更加优雅，提高了另一个数量级的优雅性。
- en: We have been introduced to the basics of using AJAX with Knockout.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经介绍了使用Knockout进行AJAX的基本知识。
- en: We have learned how to use utility functions for more advanced collection features,
    and again with less lines of code.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用实用函数来获取更高级的集合功能，并且代码行数更少。
- en: Lastly, we learned how to improve the performance of our ViewModel using pure
    oriented compute functions (with a bonus clip of compute documents from the KnockoutJS
    online documents).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用纯面向计算函数（附带KnockoutJS在线文档中的计算文档剪辑）来提高我们的ViewModel的性能。
- en: In our next chapter we will be looking at another way of packaging things to
    make our code shorter, more approachable, and more sustainable. Templates were
    once the domain of backend servers. The next chapter will show you why you need
    to do less on the backend and more on the frontend than ever before!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一种打包方式，以使我们的代码更短、更易于接近、更可持续。模板曾经是后端服务器的领域。下一章将向您展示为什么您需要在后端做更少的事情，而在前端做更多的事情，比以往任何时候都要多！
