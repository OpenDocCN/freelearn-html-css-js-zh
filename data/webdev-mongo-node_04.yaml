- en: Introducing Express
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Express
- en: When we need to build a full-fledged web application, writing the whole application
    from scratch is not the best approach to take. We can use a well-maintained and
    well-written web application framework to build our application to reduce development
    effort and increase maintainability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要构建一个完整的Web应用程序时，从头开始编写整个应用程序并不是最佳的方法。我们可以使用一个维护良好、编写良好的Web应用程序框架来构建我们的应用程序，以减少开发工作量并提高可维护性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Explore the Express.js web application framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Express.js Web应用程序框架
- en: Explore the various elements of Express.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Express.js的各种元素
- en: Develop the necessary code to bootstrap a web application using Express
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express开发必要的代码来引导Web应用程序
- en: Web application frameworks
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序框架
- en: Simply put, a web framework makes it easier to develop a web application. Consider
    the aspect of breaking down commonly used functionality into reusable modules.
    That is exactly what frameworks do. They come with a lot of reusable modules and
    enforce a standard structure for the code so that it will be easier for developers
    across the world to go through and understand the application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Web框架使得开发Web应用程序变得更容易。考虑将常用功能分解为可重用模块的方面。这正是框架所做的。它们带有许多可重用模块，并强制执行代码的标准结构，以便全世界的开发人员更容易地浏览和理解应用程序。
- en: Apart from all these advantages, web frameworks mostly get maintained by a lot
    of developers across the world. So, the effort of developers to incorporate the
    newer bug fixes and features of underlying languages is minimized to a point where
    we just need to upgrade the framework version which is being used by the application.
    So, the use of web frameworks for building web applications brings a lot of advantages
    to the development and maintenance phases of a web application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些优点之外，Web框架大多由全世界的开发人员维护。因此，开发人员将新的bug修复和底层语言的功能整合到框架版本中的工作量最小化，我们只需要升级应用程序使用的框架版本。因此，使用Web框架构建Web应用程序为开发和维护阶段带来了许多优势。
- en: 'The Express.js framework that we are going to use throughout this book is a
    **Model-View-Controller** (**MVC**) based web application framework. MVC is just
    an architectural design pattern:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中使用的Express.js框架是基于**模型-视图-控制器**（**MVC**）的Web应用程序框架。MVC只是一种架构设计模式：
- en: 'Models: Models are used to represent the data or entities of the web application.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型：模型用于表示Web应用程序的数据或实体。
- en: They align more closely with the instances, which store the data of the application—typically
    a database or a web service.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它更接近实例，这些实例存储应用程序的数据，通常是数据库或Web服务。
- en: 'Views: Views are responsible for how the application gets presented to the
    end user. So, a View can be considered as the presentation layer of the application.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图：视图负责将应用程序呈现给最终用户。因此，视图可以被视为应用程序的呈现层。
- en: 'Controllers: Now, you may be wondering about the role of controllers in the
    web application. Well, the role of controllers is to just glue together the models
    with the respective Views and to take care of the request from the user for a
    particular web page in our application end to end.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器：现在，你可能想知道控制器在Web应用程序中的作用。控制器的作用就是将模型与相应的视图粘合在一起，并负责处理用户对应用程序中特定Web页面的请求。
- en: This may be a bit hard for you to grasp if you are hearing this concept for
    the first time. But after going through this chapter, you will get used to these
    concepts while we present various examples to you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次听到这个概念，可能会有点难以理解。但是在阅读完本章之后，我们会向你展示各种例子，让你逐渐熟悉这些概念。
- en: What is Express.js?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Express.js？
- en: As described perfectly on its home page, Express is a minimal and flexible Node.js
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它在主页上完美描述的那样，Express是一个最小化和灵活的Node.js
- en: web application framework, providing a robust set of features for building single,
    multipage, and hybrid web applications. In other words, it provides all the tools
    and basic building blocks you need to get a web server up and running by writing
    very little code. It puts the power in focusing on writing your application and
    not worrying about the nuts and bolts that go into making the basic stuff work
    in your hands.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序框架，提供了一套强大的功能，用于构建单页、多页和混合Web应用程序。换句话说，它提供了所有你需要的工具和基本构建块，只需编写很少的代码就可以让Web服务器运行起来。它让你专注于编写你的应用程序，而不用担心基本功能的细节。
- en: The Express framework is one of the most popular Node-based web frameworks and
    one of the single most popular packages available in `npm`. It is built based
    on the Sinatra web framework, which is quite popular in the Ruby world. There
    are a lot of frameworks across languages that take inspiration from Sinatra's
    simplicity, such as PHP's Laravel framework. So, Express is the Sinatra-based
    web framework in the Node.js world.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Express框架是最流行的基于Node的Web框架之一，也是`npm`中最流行的包之一。它是基于Sinatra Web框架构建的，在Ruby世界中非常流行。有很多跨语言的框架都受到Sinatra简单性的启发，比如PHP的Laravel框架。因此，Express是Node.js世界中基于Sinatra的Web框架。
- en: 'If you look at a sample piece of code, one of the most basic implementations
    of Express, you can see how easy it is to get a web server up and running, for
    example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一段代码示例，Express的最基本实现之一，你会发现启动Web服务器是多么容易，例如：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The beauty of Express is that it makes building and maintaining the server code
    for a website simple.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Express的美妙之处在于它使得构建和维护网站的服务器代码变得简单。
- en: Building a complete web application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建完整的Web应用程序
- en: Beginning with this chapter, we are going to build a complete web application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将构建一个完整的Web应用程序。
- en: The web application that we are going to build will be a clone of a popular
    social image sharing site, [imgur.com](http://imgur.com). We'll call our site
    `imgPloadr.io`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的Web应用程序将是一个流行的社交图片分享网站[imgur.com](http://imgur.com)的克隆。我们将称我们的网站为`imgPloadr.io`。
- en: Designing the web application
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计Web应用程序
- en: 'The requirements of the site are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的要求如下：
- en: The home page will allow visitors to upload an image as well as browse the existing
    uploaded images, which will be sorted from newest to oldest.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页将允许访问者上传图片，并浏览已上传的图片，这些图片将按从新到旧的顺序进行排序。
- en: Each uploaded image will be presented via its own page that shows its title,
    description, and a large image display. Visitors will be able to like the image
    and post comments.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个上传的图片将通过自己的页面呈现，显示其标题、描述和大图像。访问者将能够喜欢图片并发表评论。
- en: A consistently shared sidebar will be visible on both pages and will showcase
    some general statistics about the site, the most popular images, and the most
    recent comments.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一致共享的侧边栏将在两个页面上可见，并展示有关网站的一般统计信息，最受欢迎的图片和最近的评论。
- en: The site will use Bootstrap so that it has a nice professional design and is
    responsive on any device.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站将使用Bootstrap，以便具有漂亮的专业设计，并且在任何设备上都能响应。
- en: 'The following screenshot is from the home page of the completed site:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图是完成网站的主页：
- en: '![](img/03b442bd-b85f-4b44-b678-59376c2e67dc.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03b442bd-b85f-4b44-b678-59376c2e67dc.png)'
- en: 'The following screenshot is an image''s details page from the site:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图是网站上图片的详细页面：
- en: '![](img/583645f2-a488-46a8-91cd-ae0421631c8e.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/583645f2-a488-46a8-91cd-ae0421631c8e.png)'
- en: Organizing the files
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织文件
- en: 'Before you start writing any code, we want to make sure that you have a project
    folder set up correctly, with the proper folder structure to house all of the
    various files that you will be creating. Get started by creating a new folder
    for your project, and name it anything you like. Then, inside that folder, create
    additional folders to match the following structure:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，我们希望确保您已经正确设置了项目文件夹，并具有正确的文件夹结构来存放您将要创建的各种文件。首先创建一个新的项目文件夹，并为其命名。然后，在该文件夹内，创建额外的文件夹以匹配以下结构：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of these folders will contain important modules that we will write throughout
    the remainder of this chapter and this book.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件夹中的每一个都将包含我们在本章和本书的其余部分中编写的重要模块。
- en: If you use an Express-based generator through Yeoman, you will get the necessary
    folder structure and the dependencies imported with the boilerplate code. However,
    as our intention is to understand this framework, we will skip this. Visit [http://yeoman.io/](http://yeoman.io/)
    for more information on the features of `Yeoman`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过Yeoman使用基于Express的生成器，您将获得必要的文件夹结构和依赖项与样板代码导入。然而，由于我们的意图是了解这个框架，我们将跳过这一步。访问[http://yeoman.io/](http://yeoman.io/)了解更多关于`Yeoman`功能的信息。
- en: 'You are going to need a `package.json` file for this project, and the easiest
    way to create one of these is by simply executing the following command from the
    root of the project folder:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个`package.json`文件用于这个项目，创建这个文件的最简单方法是从项目文件夹的根目录执行以下命令：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Respond to each of the questions as you are prompted, or simply press *Enter*
    repeatedly to accept the default values. Now, let''s install Express and its necessary
    dependencies via `npm`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时回答每个问题，或者简单地重复按*Enter*接受默认值。现在，让我们通过`npm`安装Express及其必要的依赖项：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will install the Express framework in the `node_modules` folder and also
    add Express to the `package.json` file in the dependencies section. Note that
    at the time of writing this book, Express.js is in its 4.x.x versions. Here, as
    you can see, Express is a completely decoupled framework that doesn't come with
    a lot of packaged modules within itself. Instead, you can figure out the dependencies
    of your application and plug in and out of the application anytime. If you have
    been following Express development from the beginning, you must have noticed that
    these changes were introduced as a part of the Express 4.x.x versions. Prior to
    this version, Express used to come with a lot of built-in modules bundled within
    it. Here, the modules we install alongside Express are the various dependencies
    our application has when we start building the complete web application. We will
    discuss the use of each module in a later section of this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`node_modules`文件夹中安装Express框架，并且还将在`package.json`文件的依赖项部分中添加Express。请注意，在撰写本书时，Express.js处于其4.x.x版本。在这里，您可以看到，Express是一个完全解耦的框架，它本身并不带有很多打包的模块。相反，您可以找出应用程序的依赖关系，并随时插入和拔出应用程序。如果您从一开始就一直关注Express的发展，您一定会注意到这些变化是作为Express
    4.x.x版本的一部分引入的。在此版本之前，Express通常会随附许多内置模块。在这里，我们与Express一起安装的模块是我们在构建完整Web应用程序时应用程序具有的各种依赖项。我们将在本章的后面部分讨论每个模块的使用。
- en: Creating the application's entry point
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序的入口点
- en: After installing Express and the necessary dependencies, the next step in developing
    the application will be to create a file which will serve as the default entry
    point of this application. We will be executing this file to start our web application,
    and it will contain the necessary code to require dependent modules and boot up
    the application to listen to a specified port on the development server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Express和必要的依赖项之后，开发应用程序的下一步将是创建一个文件，该文件将作为应用程序的默认入口点。我们将执行此文件来启动我们的Web应用程序，并且它将包含必要的代码来要求依赖模块，并在开发服务器上监听指定的端口。
- en: We are going to name the entry point file `server.js` for now and will keep
    it pretty lean so that its content is quite self-explanatory. Any major logic
    that is going to be executed within this file will actually be deferred to external
    modules hosted within other files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时将入口点文件命名为`server.js`，并且保持它非常简洁，以便内容相当自解释。在这个文件中执行的任何主要逻辑实际上将被延迟到其他文件中托管的外部模块中。
- en: 'Before we can do anything within `server.js`, we require a few modules that
    we''re going to work with, specifically Express:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中我们无法做任何事情之前，我们需要引入一些我们将要使用的模块，特别是Express：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we are assigning the `express` module to the `express`
    variable. The `config` module is actually going to be our own module that we will
    write shortly, but for now, since it doesn't exist, we will leave that line commented
    out. Finally, we will declare a variable called `app` that is actually what the
    Express framework returns when it is executed. This `app` object powers our entire
    `app` application, which is how it was so cleverly named.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`express`模块分配给`express`变量。`config`模块实际上将是我们自己编写的模块，但目前由于它不存在，我们将保留该行的注释。最后，我们将声明一个名为`app`的变量，这实际上是Express框架在执行时返回的内容。这个`app`对象驱动我们整个`app`应用程序，这就是它如此巧妙地命名的原因。
- en: Throughout this chapter and the remainder of the book, I may include commented
    out code in the samples (code that starts with `//`). This is so that following
    along will be easier when we use the commented lines as reference points, or when
    we enable those features by simply uncommenting the code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和本书的其余部分中，我可能会在示例中包含已注释的代码（以`//`开头的代码）。这样，当我们使用已注释的行作为参考点时，或者当我们通过简单取消注释代码来启用这些功能时，跟随将会更容易。
- en: 'Next up, we will set a few simple settings via the `app` object using the `app.set()`
    function. These settings are really just a way for us to define some app-level
    constants that we can use throughout the rest of our code as handy shortcuts:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过`app.set()`函数在`app`对象中设置一些简单的设置。这些设置实际上只是为了定义一些我们可以在代码的其余部分中使用的应用级常量，以便我们可以方便地使用它们作为快捷方式：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code is explained as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：
- en: The first two lines of the preceding code use built-in constants in Node. The
    `process.env.PORT` constant is an environment setting that is set on the actual
    machine for the default port value to the server. If no port value is set on the
    machine, we will hardcode a default value of `3300` to use in its place.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面代码的前两行使用了Node中的内置常量。`process.env.PORT`常量是设置在实际机器上的环境设置，用于服务器的默认端口值。如果在机器上没有设置端口值，我们将硬编码一个默认值`3300`来代替使用。
- en: After that, we set the location of our Views (HTML templates) to
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将我们的Views（HTML模板）的位置设置为
- en: '`${__dirname}''/Views`, or using another Node constant, the `/Views`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`${__dirname}''/Views`，或者使用另一个Node常量，`/Views`'
- en: folder within the current working directory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前工作目录中的文件夹。
- en: The third line of code is referencing the `config` module, which we haven't
    written yet, so that the line is commented out.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的第三行引用了尚未编写的`config`模块，因此该行被注释掉了。
- en: 'Last but not least, we will create a HTTP server using our `app` object and
    tell it to listen for connections:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们将使用我们的`app`对象创建一个HTTP服务器，并告诉它监听连接：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we set a route in our application to respond with a `Hello World` message.
    If any user requests for the root of our application, it will respond with a `Hello
    World` message. The last section of the code is to call the `listen()` function
    on our app that tells it which port to listen to, and to pass in a simple anonymous
    callback function that will execute once the server is up and listening by executing
    a simple `console.log()` message. That's it! Again, make sure to save this file
    with the name `server.js` within the root of the project. You're ready to run
    your server and see if it works.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在我们的应用程序中设置了一个路由，以响应`Hello World`消息。如果任何用户请求我们应用程序的根目录，它将会响应一个`Hello World`消息。代码的最后部分是在我们的应用程序上调用`listen()`函数，告诉它要监听哪个端口，并传入一个简单的匿名回调函数，一旦服务器启动并监听，就会执行一个简单的`console.log()`消息。就是这样！再次确保将此文件保存为项目根目录下的`server.js`。您已经准备好运行您的服务器，看看它是否正常工作。
- en: Booting up the application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: 'Let''s take your server for a spin and see how you''re doing so far:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下您的服务器的运行情况：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Perfect! At this point, your server doesn't actually do anything great. Try
    pointing your browser to `http://localhost:3300`. You should receive a pretty
    basic message that says `Hello World`! If you request any other routes on the
    port, such as `http://localhost:3300/`, it will respond with a cannot get response.
    This is because you haven't configured any routes or any actual logic in your
    server to say how to handle certain requests, but only a `GET` request to the
    default route of `/`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！到目前为止，您的服务器实际上并没有做任何伟大的事情。尝试将浏览器指向`http://localhost:3300`。您应该会收到一个非常基本的消息，上面写着`Hello
    World`！如果您请求端口上的任何其他路由，例如`http://localhost:3300/`，它将会响应一个无法获取的响应。这是因为您还没有配置任何路由或任何实际逻辑在您的服务器中，来处理特定的请求，只有一个对`/`默认路由的`GET`请求。
- en: Before you set up your routes, we should understand the concept of middleware
    in Express, which will be essential to understand how the modules that are custom
    dependencies of our application get integrated with our normal application flow.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置路由之前，我们应该了解Express中间件的概念，这对于理解我们应用程序的自定义依赖模块如何与我们的正常应用程序流集成是至关重要的。
- en: 'You can set any number of environment variables right from the command line
    before you run your server by executing something like the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在运行服务器之前，直接从命令行设置任意数量的环境变量，执行类似以下命令的操作：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also set environment variables in your environment settings permanently.
    This can be done typically by editing your `.profile` file or equivalent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在环境设置中永久设置环境变量。通常可以通过编辑您的`.profile`文件或等效文件来完成此操作。
- en: Middlewares
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: One of the most powerful features available with Express is the concept of middleware.
    The idea behind middleware is that it acts like a stack of filters that every
    request to your server passes through. Every request passes through each filter
    and each filter can perform a specific task against the request before it passes
    through to the next filter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Express提供的最强大的功能之一是中间件的概念。中间件背后的思想是，它就像一个过滤器堆栈，每个对服务器的请求都会通过。每个请求都会经过每个过滤器，并且每个过滤器可以对请求执行特定任务，然后再传递到下一个过滤器。
- en: 'To understand it better, here is a diagrammatic view of middlewares:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，这里是中间件的图解视图：
- en: '![](img/21df5552-efca-45c1-9090-21550c23cac5.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21df5552-efca-45c1-9090-21550c23cac5.png)'
- en: Typically, these filters are used for tasks such as cookie parsing, form-field
    handling, session handling, authentication, and error handling and logging. The
    list goes on and on. You can use hundreds of third-party modules as well as simply
    write your own custom middleware.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些过滤器用于诸如cookie解析、表单字段处理、会话处理、身份验证、错误处理和日志记录等任务。清单不胜枚举。您可以使用数百个第三方模块，也可以简单地编写自己的自定义中间件。
- en: Creating custom middleware
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义中间件
- en: Undoubtedly, there will be a time when you want to write your own custom middleware
    in addition to the existing middleware provided by *Connect* or any other third
    party. Before you write your own custom middleware in Node, make it a habit to
    search through [https://www.npmjs.org/](https://www.npmjs.org/) first, as there's
    a fairly big chance someone else has already done the work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，总有一天你会想要编写自己的自定义中间件，除了*Connect*或任何其他第三方提供的现有中间件。在Node中编写自定义中间件之前，习惯性地首先搜索[https://www.npmjs.org/](https://www.npmjs.org/)，因为很有可能其他人已经完成了这项工作。
- en: Writing your own custom middleware is pretty simple. While using an Express
    framework, it documents various types of middleware that we would simply categorize
    into two types, that is, application-based and route-based middlewares.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义中间件非常简单。在使用Express框架时，它记录了各种类型的中间件，我们可以简单地将其分类为两种类型，即应用程序级和基于路由的中间件。
- en: 'Here is a super basic example of application-based middleware:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序级中间件的超级基本示例：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `app.use` function allows us to register as a middleware. At its basic
    level, it is a function that is called on receiving a request in the `http.createServer`
    method. Further, we need to write a function that accepts four parameters: `err`,
    `req`, `res`, and `next`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use`函数允许我们注册为中间件。在基本级别上，它是一个在`http.createServer`方法中接收请求时调用的函数。此外，我们需要编写一个接受四个参数的函数：`err`，`req`，`res`和`next`。'
- en: The first parameter is an error object, and if there were any stack errors prior
    to your middleware running, that error would be passed to your middleware so that
    you can handle it accordingly. This is an optional parameter; hence, we can skip
    it if no error handling is required for the specific implementation of functionality.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个错误对象，如果在您的中间件运行之前有任何堆栈错误，该错误将被传递给您的中间件，以便您可以相应地处理它。这是一个可选参数；因此，如果对特定功能的实现不需要错误处理，我们可以跳过它。
- en: You are already familiar with the `req` and `res` parameters, having written
    your routes.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经熟悉了`req`和`res`参数，已经编写了你的路由。
- en: The fourth parameter is actually a reference to a callback. This next parameter
    is how the middleware stack is able to behave like a stack—each executing and
    ensuring that the next middleware in the pipeline is returned and called via `next`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数实际上是一个回调的引用。这个`next`参数是中间件堆栈能够像堆栈一样运行的方式，每个执行并确保管道中的下一个中间件通过`next`返回和调用。
- en: 'An `app.use` method also accepts the first parameter as a route or an endpoint.
    This forms the second type of middleware called the **route-based middleware**
    that was mentioned earlier. Here is the syntax:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use`方法还接受第一个参数作为路由或端点。这形成了之前提到的第二种中间件类型，称为**基于路由的中间件**。以下是语法：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, this depicts that instead of applying a middleware to all the incoming requests,
    we make it specific to a route and call on the route match.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这表明我们不是将中间件应用于所有传入的请求，而是将其特定于一个路由并调用路由匹配。
- en: The only important thing to keep in mind while writing your own custom middleware
    is that you have the correct parameters and you return `next()`. The rest is completely
    up to you!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写自定义中间件时唯一要记住的重要事情是你有正确的参数并且返回`next()`。其余完全取决于你！
- en: Order of middlewares
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件的顺序
- en: The order that the middleware is called in is very important. Again, using the
    concept of filters as a request that passes through each filter, you want to be
    sure that they are performing their responsibilities in the correct order. A great
    example of this is implementing a cookie parser before a session handler, since
    sessions typically rely on cookies to maintain states with a user between requests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件被调用的顺序非常重要。再次使用过滤器的概念，作为通过每个过滤器的请求，您要确保它们按正确的顺序执行其职责。一个很好的例子是在会话处理程序之前实现cookie解析器，因为会话通常依赖于cookie来在请求之间维护与用户的状态。
- en: Another great example of how the order of middleware is important involves error
    handling. If any of your middleware encounters an error, they will simply pass
    that error along to the next middleware in the stack. If the last middleware,
    regardless of what it is, doesn't gracefully handle that error, it will basically
    show up in your application as a stack trace (and that's bad). Having an error
    handler configured as one of the last middleware is like saying "*if everything
    else fails, and at any point in the previous middleware a failure occurs, deal
    with it gracefully*."
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件顺序重要的另一个很好的例子涉及错误处理。如果你的任何中间件遇到错误，它们将简单地将该错误传递给堆栈中的下一个中间件。如果最后一个中间件，无论是什么，都不能优雅地处理该错误，它基本上会显示在你的应用程序中作为堆栈跟踪（这是不好的）。将错误处理程序配置为最后一个中间件之一就像是在说“*如果一切都失败，并且在以前的中间件的任何时候发生故障，请优雅地处理它*。”
- en: The various dependencies we have installed to use in this application are going
    to be integrated into our code as middlewares. We are going to carry out this
    task of integrating the various middlewares through the `config` module, as it
    will help us to make our `server.js` file leaner and add more readability to the
    code base.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装的各种依赖项将被集成到我们的代码中作为中间件。我们将通过`config`模块来执行这个集成各种中间件的任务，因为它将帮助我们使`server.js`文件更加精简，并增加代码的可读性。
- en: The configure module
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置模块
- en: Since, we are keeping our `server.js` file very lean, there is still a fair
    amount of logic that is required in configuring our server. For this, we will
    defer to a custom module that we'll create called `configure`. To get started,
    create a `configure.js` file in the `server` folder. We have already installed
    the custom dependencies when we were installing Express in the first place.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们保持`server.js`文件非常简洁，因此在配置服务器时仍需要相当多的逻辑。为此，我们将使用一个名为`configure`的自定义模块。首先，在`server`文件夹中创建一个`configure.js`文件。当我们首次安装Express时，我们已经安装了自定义依赖项。
- en: 'Now that the module is installed and ready to be used, let''s start writing
    the `configure.js` file. First, like any of our modules, we will declare our dependencies:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模块已安装并准备好使用，让我们开始编写`configure.js`文件。首先，像我们的任何模块一样，我们将声明我们的依赖项：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we declared `const` for each of the modules that we will
    be using in our custom `configure` module. Then, we defined the actual module
    that will be exported by this code file, more specifically a function that accepts
    our `app` object as a parameter, as well as returns that same object (after we
    make some configuration modifications to it).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为我们自定义的`configure`模块中将要使用的每个模块声明了`const`。然后，我们定义了实际将由此代码文件导出的模块，更具体地说是一个接受我们的`app`对象作为参数的函数，并返回相同对象（在我们对其进行一些配置修改后）。
- en: You should see that we require Connect, which is actually installed by default
    with Express.js as one of its core dependencies. Connect is a popular third-party
    middleware framework that we will learn more about later in this chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到我们需要Connect，它实际上是Express.js的核心依赖项之一，默认安装。Connect是一个流行的第三方中间件框架，我们将在本章后面更多地了解它。
- en: 'Let''s take a look at each of the Connect middleware we have used in the preceding
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们在前面的代码中使用的每个Connect中间件：
- en: '`morgan`: This is the module responsible for logging. This is very helpful
    for debugging your Node server.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`morgan`：这是负责记录日志的模块。这对调试您的Node服务器非常有帮助。'
- en: '`bodyParser`: This helps to facilitate the packing of any form fields that
    are submitted via a HTML form submission from a browser. Form fields that are
    submitted via a `POST` request will be made available via the `req.body` property.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bodyParser`：这有助于方便打包通过浏览器的HTML表单提交的任何表单字段。通过`POST`请求提交的表单字段将通过`req.body`属性可用。'
- en: '`methodOverride`: For older browsers which don''t support REST HTTP verbs properly,
    such as `UPDATE` and `PUT`, the `methodOverride` middleware allows this to be
    faked using a special hidden input field.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`methodOverride`：对于不正确支持REST HTTP动词的旧浏览器，如`UPDATE`和`PUT`，`methodOverride`中间件允许使用特殊的隐藏输入字段来伪造它。'
- en: '`cookieParser`: This allows cookies to be sent and received.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookieParser`：这允许发送和接收cookie。'
- en: '`errorHandler`: This handles any error that occur throughout the entire middleware
    process. Typically, you would write your own custom `errorHandler` that might
    render a default 404 HTML page, log the error to a data store, and so on.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errorHandler`：这处理整个中间件过程中发生的任何错误。通常，您会编写自己的自定义`errorHandler`，可能会呈现默认的404 HTML页面，将错误记录到数据存储中，等等。'
- en: '`handlebars`: This is the templating engine we are going to use with the Views.
    We will explain more about integrating it in the upcoming sections.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlebars`：这是我们将与视图一起使用的模板引擎。我们将在接下来的部分中更多地解释如何集成它。'
- en: The `routes(app)` line is a special component of Express that says you are actually
    using a router with your server, and you can respond to requests such as `GET`,
    `POST`, `PUT`, and `UPDATE`. Since you are using the Express router as one of
    the last middleware, we will also define the actual routes in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes(app)`行是Express的一个特殊组件，表示您实际上正在使用路由器与服务器，您可以响应`GET`、`POST`、`PUT`和`UPDATE`等请求。由于您正在使用Express路由器作为最后一个中间件之一，我们还将在下一节中定义实际的路由。'
- en: 'Finally, the `express.static()` middleware is used to render static content
    files to the browser from a predefined static resource directory. This is important
    so that the server can serve up static files, such as `.js`, `.css`, `images`,
    and `regular.html`, as well as any other files you might need to serve up. The
    static middleware will serve up any static files from the public directory, like
    the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`express.static()`中间件用于从预定义的静态资源目录向浏览器呈现静态内容文件。这很重要，这样服务器可以提供静态文件，如`.js`、`.css`、`图像`和`regular.html`，以及您可能需要提供的任何其他文件。静态中间件将从public目录提供任何静态文件，就像以下代码一样：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's important that your static middleware is defined after `app.router()`,
    so that static assets aren't inadvertently taking priority over a matching route
    that you may have defined.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，您的静态中间件在`app.router()`之后定义，这样静态资产不会意外地优先于您可能已定义的匹配路由。
- en: Activating the configure module
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活配置模块
- en: 'Now that your `configure.js` file is complete, you''re ready to call it from
    your main `server.js` file. If you recall, we included two lines of code that
    were commented out for our `configure` module. It''s time to uncomment these two
    lines so that when you run your server, your `configure` module will do its part.
    The two lines should now look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的`configure.js`文件已经完成，您可以从主`server.js`文件中调用它了。如果您还记得，我们在`configure`模块中包含了两行被注释掉的代码。现在是时候取消注释这两行了，这样当您运行服务器时，您的`configure`模块将发挥作用。这两行现在应该是这样的：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Boot up your server again by executing the `server.js` node and everything should
    still be running smoothly. Now, it's time to incorporate more routes into our
    application in addition to the `Hello World` route we added earlier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`server.js`节点再次启动服务器，一切应该仍然运行顺利。现在，是时候在我们的应用程序中加入更多路由了，除了我们之前添加的`Hello World`路由。
- en: Routers and controllers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和控制器
- en: So far, you have your `server.js` file and a `configure` module that is used
    to wire up all of the necessary middleware for the application. The next step
    is to implement proper routers and the necessary controllers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你有你的`server.js`文件和一个`configure`模块，用于连接应用程序所需的所有中间件。下一步是实现适当的路由器和必要的控制器。
- en: 'The router is going to be a map of each of the available URL paths for the
    app. Every route on the server will correspond to a function in a controller.
    Here is what our routes table will look like for the particular application we
    are writing:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 路由将是应用程序中每个可用URL路径的映射。服务器上的每个路由都对应于控制器中的一个函数。这是我们正在编写的特定应用程序的路由表：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can see that we are handling two different `GET` requests and three different
    `POST` requests. In addition, we have two main controllers: `home` and `image`.
    Controllers are really just modules with different functions defined that match
    up with the corresponding routes. As pointed out earlier, they are called controllers
    in MVC design patterns. Typically, every route will correspond to a controller.
    This controller will more than likely render a View, and that View will more than
    likely have its own model (any data that is displayed in the View).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们处理了两个不同的`GET`请求和三个不同的`POST`请求。此外，我们有两个主要的控制器：`home`和`image`。控制器实际上只是具有不同函数定义的模块，这些函数与相应的路由相匹配。正如前面指出的，它们在MVC设计模式中被称为控制器。通常，每个路由都对应一个控制器。这个控制器很可能会渲染一个视图，而这个视图很可能会有自己的模型（在视图中显示的任何数据）。
- en: 'Let''s write our router as its own module matching the table outlined. First,
    create a `routes.js` file within the `server` folder. The `routes` file is going
    to be pretty simple, and the only dependencies it requires will be the controllers
    we define:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的路由写成一个与所述表格匹配的模块。首先，在`server`文件夹中创建一个`routes.js`文件。`routes`文件将会非常简单，它所需的唯一依赖将是我们定义的控制器：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Right off the bat, we declare a `router` variable and require the `controllers`
    folder to assign each application route (we haven't yet created these files, but
    that's coming up next). Here, we are assigning each route to its corresponding
    function in the controllers. Then, we export a module that, when invoked by itself,
    will attach all these routes to the `app` instance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即声明一个`router`变量，并要求`controllers`文件夹来分配每个应用程序路由（我们还没有创建这些文件，但接下来就要创建了）。在这里，我们将每个路由分配给控制器中的相应函数。然后，我们导出一个模块，当单独调用时，将所有这些路由附加到`app`实例上。
- en: The first parameter for a route is the string value of the route itself, which
    can contain variable values as subpaths. You can see with the second `router.get`,
    that we assign a route value of `/images/:image_id` that basically equates to
    `/image/ANYVALUE` in the browser address bar. When we write the `image.index`
    controller, you will see how to retrieve the value for `:image_id` and use it
    within the `controller` function itself.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的第一个参数是路由本身的字符串值，它可以包含变量值作为子路径。你可以看到第二个`router.get`，我们分配了一个路由值`/images/:image_id`，它基本上等同于浏览器地址栏中的`/image/ANYVALUE`。当我们编写`image.index`控制器时，你将看到如何检索`:image_id`的值并在`controller`函数内部使用它。
- en: The second parameter for a route is a callback function. You can completely
    omit the idea of using controllers and just define your callbacks as inline anonymous
    functions; however, as your routes grow, this file will get larger and larger,
    and the code will start to become a mess. It's always a good practice to break
    your code up into as many small and manageable modules as possible to keep yourself
    sane!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的第二个参数是一个回调函数。你可以完全忽略使用控制器的想法，只需将回调定义为内联匿名函数；然而，随着你的路由增长，这个文件会变得越来越大，代码会开始变得混乱。将代码分解成尽可能多的小而可管理的模块总是一个很好的做法，以保持自己的理智！
- en: The first two `router.get` routes are typical routes that would be called whenever
    a visitor points their browser to `yourdomain.com/routepath`—the browser sends
    a `GET` request to the server by default. The other three `router.post` routes
    are defined to handle when the browser posts a request to the server, typically
    done via a HTML form submission.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个`router.get`路由是典型的路由，当访问者将他们的浏览器指向`yourdomain.com/routepath`时会被调用——浏览器默认发送`GET`请求到服务器。另外三个`router.post`路由被定义为处理浏览器向服务器发出的请求，通常通过HTML表单提交完成。
- en: 'With all of our routes defined, let''s now create the matching controllers.
    Within the `controllers` folder, create both the `home.js` and `image.js` files.
    The `home.js` file is very basic:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有我们定义的路由，现在让我们创建匹配的控制器。在`controllers`文件夹中，创建`home.js`和`image.js`文件。`home.js`文件非常基本：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this module, we are actually exporting an object that has a single function
    called `index`. The `function` signature for `index` is the signature that is
    required for every route using Express. A first parameter is a request object
    and a second parameter is a response object. Every detail specific to the request
    that the browser sent to the server will be available via the request object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个模块，我们实际上是在导出一个对象，该对象具有一个名为`index`的单个函数。`index`的`function`签名是使用Express的每个路由所需的签名。第一个参数是一个请求对象，第二个参数是一个响应对象。浏览器发送到服务器的请求的每个具体细节都可以通过请求对象获得。
- en: In addition, the request object will be modified using all of the middleware
    that was declared earlier. You will use the response object to send a response
    back to the client—this may be a rendered HTML page, static asset, JSON data,
    an error, or whatever you determine. For now, our controllers just respond with
    a simple text so you can see that they are all working.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请求对象将使用之前声明的所有中间件进行修改。你将使用响应对象向客户端发送响应——这可能是一个渲染的HTML页面、静态资产、JSON数据、错误，或者你确定的任何内容。目前，我们的控制器只是简单地响应一个简单的文本，这样你就可以看到它们都在工作。
- en: 'Let''s create an image controller that has a few more functions. Edit the `/controllers/image.js`
    file and insert the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个图像控制器，其中有更多的函数。编辑`/controllers/image.js`文件并插入以下代码：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we defined the `index` function, just like we did in the home controller,
    except that we will also display `image_id`, which is set in the route when this
    controller function is executed. The `params` property was added to the `request`
    object via the `urlencoded` feature, which is a part of the body parser module!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`index`函数，就像我们在主控制器中所做的那样，只是我们还将显示`image_id`，这是在执行此控制器函数时在路由中设置的。`params`属性是通过`urlencoded`功能添加到`request`对象中的，这是body
    parser模块的一部分！
- en: Note that the controller currently doesn't require any dependencies (there were
    no `require` declarations defined at the top of the file). This will change as
    we actually flesh out the controller functions and start to do things such as
    inserting records into our MongoDB database and using other third-party `npm`
    modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，控制器目前不需要任何依赖项（文件顶部没有定义`require`声明）。随着我们实际完善控制器函数并开始执行诸如将记录插入我们的MongoDB数据库和使用其他第三方`npm`模块等操作，这将发生改变。
- en: 'Now that your controllers are created and ready to be used, you just need to
    activate your routes. To do this, we will insert one last line of code into our
    `configure.js` file, right above the `return app;` line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的控制器已经创建并准备好使用，你只需要激活你的路由。为了做到这一点，我们将在我们的`configure.js`文件中插入最后一行代码，就在`return
    app;`行的上方：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Don't forget to uncomment the `routes = require('./routes')` line at the top
    of the file as well. What we're doing here is using the `routes` module we defined
    and executing the `initialize` function, which will actually wire up our routes
    via our `app` object. We will need to comment out the redundant code that we just
    moved to `routes`, which is still present in `server.js.`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在文件顶部取消注释`routes = require('./routes')`这一行。我们在这里做的是使用我们定义的`routes`模块，并执行`initialize`函数，这将通过我们的`app`对象实际连接我们的路由。我们需要注释掉我们刚刚移动到`routes`中的冗余代码，它仍然存在于`server.js`中。
- en: 'As a recap of each of the files you have created so far, here are the uninterrupted
    files listed so you can view the full code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为迄今为止你已经创建的每个文件的总结，这里列出了不间断的文件，这样你就可以查看完整的代码：
- en: First, we need to boot up with `server.js`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要用`server.js`启动
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will configure the server with `server/configure.js`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`server/configure.js`配置服务器：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we have our routes defined in `server/routes.js`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`server/routes.js`中定义了我们的路由：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we will define our controllers with `controllers/home.js`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`controllers/home.js`定义我们的控制器：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Furthermore, we will also define our controllers with `controllers/image.js`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用`controllers/image.js`来定义我们的控制器：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's fire up the server one last time and check if it's all working.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后一次启动服务器并检查是否一切正常。
- en: 'Execute the `server.js` node, and this time point your browser to `http://localhost:3300`.
    Now, you should be seeing some responses in the browser. Go to `http://localhost:3300/images/testing123`.
    You should see the following message on the screen:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`server.js`节点，并且这次将浏览器指向`http://localhost:3300`。现在，你应该在浏览器中看到一些响应。转到`http://localhost:3300/images/testing123`。你应该在屏幕上看到以下消息：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Handlebars as View engines
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Handlebars作为视图引擎
- en: By default, Express can and will happily render static HTML documents and serve
    them back to the client. However, unless you're building a purely static, content-driven
    site, which is doubtful, you're more than likely going to want to render your
    HTML dynamically. That is, you want to generate portions of HTML on the fly as
    pages are requested, perhaps using loops, conditional statements, data-driven
    content, and so on. In order to render dynamic HTML pages, you need to use a rendering
    engine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Express可以愉快地呈现静态HTML文档并将其返回给客户端。但是，除非你正在构建一个纯静态的、内容驱动的网站，这是可疑的，否则你很可能希望动态地呈现你的HTML。也就是说，你希望在页面被请求时动态生成HTML的部分，也许使用循环、条件语句、数据驱动的内容等等。为了呈现动态HTML页面，你需要使用一个渲染引擎。
- en: 'This is where Handlebars comes in. The rendering engine is given its name because
    of the syntax it uses to display data, namely, double pairs of braces, `{{` and
    `}}`. Using Handlebars, you can have sections of your HTML pages that are determined
    at run time based on data passed to it. Consider the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Handlebars的用武之地。这个渲染引擎得名是因为它用于显示数据的语法，即双大括号`{{`和`}}`。使用Handlebars，你可以在你的HTML页面中有根据传递给它的数据在运行时确定的部分。考虑以下例子：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The actual HTML that would wind up on a visitor''s browser would be:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者浏览器上实际的HTML将是：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first thing we want to take care of in our `configure` module is to register
    Handlebars as the default View rendering engine. In the `configure.js` file, above
    the `return(app);` line, you should insert the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`configure`模块中要处理的第一件事是将Handlebars注册为默认的视图渲染引擎。在`configure.js`文件中，在`return(app);`行的上方，你应该插入以下代码：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, using the Express `app` object that was passed into the `configure` function,
    we define our rendering engine of choice by calling the engine function of `app`.
    The first parameter to the `engine` function is the file extension that the rendering
    engine should look for, namely, `handlebars`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用传入`configure`函数的Express `app`对象，通过调用`app`的`engine`函数来定义我们选择的渲染引擎。`engine`函数的第一个参数是渲染引擎应该寻找的文件扩展名，即`handlebars`。
- en: The second parameter builds the engine by calling the `express-hbs` module's
    `create` function. This `create` function takes an `options` object as a parameter,
    and this `options` object defines a number of constants for our server. Most importantly,
    we will define which layout is our default layout and also where our layouts will
    be stored. If you recall, in `server.js` we used `app.set` to set a `Views` property
    of our `app` that pointed to the current working directory `+/Views`. This setting
    is used when we configure the options for our rendering engine as well. You'll
    notice that the `partialsDir` property uses an array (with a single item) and
    a single string value for `layoutsDir`. Both of these methods are interchangeable,
    and I just wanted to demonstrate that you could have more than one partial directory,
    and it could just be an array of string values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数通过调用`express-hbs`模块的`create`函数来构建引擎。这个`create`函数以一个`options`对象作为参数，这个`options`对象为我们的服务器定义了许多常量。最重要的是，我们将定义哪个布局是我们的默认布局，以及我们的布局将存储在哪里。如果您还记得，在`server.js`中，我们使用`app.set`来设置我们的`app`的`Views`属性，指向当前工作目录`+/Views`。当我们配置渲染引擎的选项时，就会使用这个设置。您会注意到`partialsDir`属性使用了一个数组（只有一个项）和一个`layoutsDir`的单个字符串值。这两种方法是可以互换的，我只是想演示您可以有多个部分目录，它可以只是一个字符串值的数组。
- en: With that set, our server now knows that any time we try to render a HTML page
    that has a file extension of `handlebars`, it will use the Handlebars engine to
    perform the rendering. This means that we need to be sure to use Handlebars-specific
    syntax in our dynamic HTML pages.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们的服务器现在知道，每当我们尝试呈现具有`handlebars`文件扩展名的HTML页面时，它将使用Handlebars引擎执行呈现。这意味着我们需要确保在我们的动态HTML页面中使用Handlebars特定的语法。
- en: We will be learning more about Handlebars and how to write dynamic HTML pages
    in the next chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于Handlebars以及如何编写动态HTML页面的知识。
- en: Using `.handlebars` as a file extension was purely a personal choice. Some people
    prefer `.hbs`, and if you want, you can use anything you like. Just make sure
    that the first parameter in the `app.engine()` function and the second parameter
    in the `app.set('View engine')` function are identical.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.handlebars`作为文件扩展名纯粹是个人选择。有些人更喜欢`.hbs`，如果你愿意，你可以使用任何你喜欢的东西。只需确保`app.engine()`函数中的第一个参数和`app.set('View
    engine')`函数中的第二个参数是相同的。
- en: To learn more about the many template engines available with Express.js, check
    out this link [https://github.com/expressjs/express/wiki#template-engines](https://github.com/expressjs/express/wiki#template-engines).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Express.js提供的许多模板引擎，请查看此链接[https://github.com/expressjs/express/wiki#template-engines](https://github.com/expressjs/express/wiki#template-engines)。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the Express web framework for Node and wrote
    a basic web server using Express that will act as the foundation for the image
    uploading website that we will build throughout the remainder of the book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Node的Express Web框架，并使用Express编写了一个基本的Web服务器，这将成为我们在本书的其余部分中构建的图片上传网站的基础。
- en: The web server you wrote handles requests to specific routes, uses controllers
    to handle the logic for those routes, and supports all of the standard requirements
    a typical web server should.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写的Web服务器处理特定路由的请求，使用控制器处理这些路由的逻辑，并支持典型Web服务器应具备的所有标准要求。
- en: In the next chapter, we will cover the Handlebars template engine to write each
    of the dynamic HTML pages that the website needs. In addition, we will update
    the image and home controllers to include the necessary logic to properly render
    these HTML pages.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Handlebars模板引擎，以编写网站所需的每个动态HTML页面。此外，我们将更新图像和主页控制器，以包含必要的逻辑，以正确呈现这些HTML页面。
