- en: Chapter 8. Chart Them Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 图表化
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a line chart
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建折线图
- en: Creating an area chart
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建面积图
- en: Creating a scatterplot chart
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建散点图图表
- en: Creating a bubble chart
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: Creating a bar chart
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, we will turn our attention to one of the oldest and well-trusted
    companions in data visualization-charts. Charts are well-defined and well-understood
    graphical representation of data; the following definition expresses it in the
    simplest terms:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注数据可视化中最古老且最值得信赖的伴侣之一——图表。图表是对数据进行良好定义和理解的图形表示；以下定义以最简单的术语表达了这一点：
- en: '*(In charts) the data is represented by symbols, such as bars in a bar chart,
    lines in a line chart, or slices in a pie chart.*'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*(在图表中)数据通过符号表示，例如柱状图中的柱子、折线图中的线条或饼图中的切片。*'
- en: '*Jensen C. & Anderson L. (1991)*'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Jensen C. & Anderson L. (1991)*'
- en: When charts are used in data visualization, their well-understood graphical
    semantics and syntax relieve the audience of your visualization from the burden
    of learning the meaning of the graphical metaphor. Hence, they can focus on the
    data itself and the information generated through visualization. The goal of this
    chapter is not only to introduce some of the commonly used chart types but also
    to demonstrate how the various topics and techniques you learned so far can be
    combined and leveraged in producing sleek, interactive charts using D3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当图表用于数据可视化时，它们被广泛理解的图形语义和语法减轻了观众从学习图形隐喻的含义中的负担。因此，他们可以专注于数据本身以及通过可视化生成的信息。本章的目标不仅是介绍一些常用的图表类型，而且还展示您迄今为止学到的各种主题和技术如何结合并利用，以使用D3制作出简洁、交互式的图表。
- en: Recipes in this chapter are much longer than the recipes we encountered so far
    since they are designed to implement fully functional and reusable charts. I have
    tried to break these into different segments and with consistent chart structures
    to ease your reading experience. However, it is still highly recommended to open
    the companion code examples in your browser and your text editor while you go
    through this chapter to minimize potential confusion and maximize the benefit.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱比我们迄今为止遇到的食谱要长得多，因为它们旨在实现功能齐全且可重用的图表。我已经尝试将这些内容分成不同的部分，并保持一致的图表结构，以简化您的阅读体验。然而，仍然强烈建议您在阅读本章时，同时在浏览器和文本编辑器中打开配套的代码示例，以最大限度地减少潜在的混淆并最大化收益。
- en: D3 chart convention
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D3图表约定
- en: Before you dive into creating your first reusable chart in D3, we need to cover
    some charting conventions commonly accepted in the D3 community; otherwise, you
    might risk creating charting libraries that might confuse your user instead of
    helping them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始创建第一个可重用的D3图表之前，我们需要介绍一些在D3社区中普遍接受的图表约定；否则，您可能会创建出可能会让用户感到困惑而不是帮助他们的图表库。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you would have imagined, D3 charts are most commonly implemented using SVG
    instead of HTML; however, the convention we will discuss here would also apply
    to HTML-based charts albeit the implementation details will be somewhat different.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，D3图表通常使用SVG而不是HTML来实现；然而，我们在这里将要讨论的约定也适用于基于HTML的图表，尽管实现细节将有所不同。
- en: 'Let''s first take a look at the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看以下图表：
- en: '![D3 chart convention](img/image_08_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![D3图表约定](img/image_08_001.jpg)'
- en: D3 chart convention
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: D3图表约定
- en: As shown in this diagram, the point of origin *(0, 0)* in an SVG image is at
    its top-leftmost corner as expected; however, the most important aspect of this
    convention pertains to how chart margins are defined and furthermore where the
    axes are placed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图表所示，SVG图像中的原点 *(0, 0)* 位于其最左上角，正如预期的那样；然而，这个约定的最重要方面是关于如何定义图表边距，以及轴线的位置。
- en: '**Margins**: First of all, let''s take a look at the most important aspect
    of this convention-the margins. As you can see, for each chart, there are four
    different margin settings: left, right, top, and bottom margins. A flexible chart
    implementation should allow its user to set different values for each of these
    margins, and we will see in the later recipes how this can be achieved.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边距**：首先，让我们看看这个约定最重要的方面——边距。正如您所看到的，对于每个图表，都有四种不同的边距设置：左边距、右边距、上边距和下边距。灵活的图表实现应该允许用户为这些边距中的每一个设置不同的值，我们将在后面的食谱中看到如何实现这一点。'
- en: '**Coordinate translation**: Secondly, this convention also suggests that the
    coordinate reference of the chart body (gray area) should be defined using a SVG
    translate transformation, **translate(margin.left, margin.top)**. This translation
    effectively moves the chart body area to the desired point; and one additional
    benefit of this approach is that by shifting the frame of reference for chart
    body coordinates, it simplifies the job of creating subelements inside the chart
    body since the margin size becomes irrelevant. For any subelement inside the chart
    body, its point of origin *(0, 0)* is now the top-leftmost corner of the chart
    body area.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标转换**：其次，这种约定还建议使用SVG平移变换来定义图表主体（灰色区域）的坐标参考，**translate(margin.left, margin.top)**。这种平移有效地将图表主体区域移动到所需的位置；并且这种方法的另一个额外好处是，通过改变图表主体坐标的参考框架，简化了在图表主体内部创建子元素的工作，因为边距大小变得无关紧要。对于图表主体内部的任何子元素，其原点
    *(0, 0)* 现在是图表主体区域的左上角。'
- en: '**Axes**: Lastly, the final aspect of this convention is regarding how and
    where chart axes are placed. As shown in the preceding diagram, chart axes are
    placed inside chart margins instead of being a part of the chart body. This approach
    has the advantage of treating axes as peripheral elements in a chart, and hence,
    doesn''t convolute the chart body implementation and additionally makes axes rendering
    logic chart independent and easily reusable.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴**：最后，此约定的最后一个方面是关于图表轴如何以及在哪里放置。如图所示，图表轴放置在图表边距内部，而不是作为图表主体的一部分。这种方法的优势在于将轴视为图表中的外围元素，因此不会使图表主体实现复杂化，并且还使轴渲染逻辑与图表独立且易于重用。'
- en: Now let's create our first reusable D3 chart with all the knowledge and techniques
    we covered so far.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用迄今为止所学的所有知识和技巧，创建我们的第一个可重用D3图表。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To see this convention as it was explained by the creator of D3, please visit
    [http://bl.ocks.org/mbostock/3019563](http://bl.ocks.org/mbostock/3019563) .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解D3创建者的解释，请访问[http://bl.ocks.org/mbostock/3019563](http://bl.ocks.org/mbostock/3019563)。
- en: Creating a line chart
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建折线图
- en: 'Line chart is a common, basic chart type that is widely used in many fields.
    This chart consists of a series of data points connected by straight line segments.
    A line chart is also typically bordered by two perpendicular axes: the *x* axis
    and the *y* axis. In this recipe, we will take a look at how this basic chart
    can be implemented using D3 as a reusable JavaScript object that can be configured
    to display multiple data series on a different scale. Besides that, we will also
    show the technique of implementing a dynamic multi-data-series update with animation.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 折线图是一种常见的基本图表类型，在许多领域得到广泛应用。此图表由一系列通过直线段连接的数据点组成。折线图通常由两条垂直轴包围：*x* 轴和 *y* 轴。在此食谱中，我们将探讨如何使用D3实现这种基本图表，作为一个可配置为在不同尺度上显示多个数据系列的可重用JavaScript对象。除此之外，我们还将展示实现具有动画的动态多数据系列更新的技术。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/line-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/line-chart.html)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/line-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/line-chart.html)'
- en: It is highly recommended that you have the companion code example open while
    reading this recipe.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读此食谱时，强烈建议您打开配套的代码示例。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s take a look at the following code that implements this chart type; due
    the length of the recipe, we will only show the outline of the code here while
    diving into the details in the *How it works...* section:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下实现此图表类型的代码；由于食谱的长度，我们在这里只展示代码的概要，而详细内容将在*工作原理...*部分中介绍：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This recipe generates the following chart:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱生成以下图表：
- en: '![How to do it...](img/image_08_002.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_08_002.jpg)'
- en: Line chart
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 折线图
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you can see, this recipe is significantly more involved than anything we
    encountered so far; so now, I will break it into multiple detailed sections with
    different focuses.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个食谱比我们迄今为止遇到的任何内容都要复杂得多；因此，现在，我将将其分解成多个具有不同重点的详细部分。
- en: Chart object and attributes
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图表对象和属性
- en: 'First, we will take a look at how this chart object is created and how its
    associated attributes can be retrieved and set on it in the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看这个图表对象是如何创建的，以及如何在以下代码中检索和设置其关联的属性：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the chart object is defined using a function called `lineChart`
    on line 1A, following the functional object pattern we have discussed in the *Understanding
    D3-Style JavaScript* recipe in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with D3.js"), *Getting Started with D3.js*. Leveraging the greater flexibility
    with information hiding offered by the functional object pattern, we have defined
    a series of internal attributes all named starting with an underscore (line `1B`).
    Some of these attributes are made public by offering an accessor function (line
    `1C`). Publicly accessible attributes are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，图表对象是在第1A行使用名为`lineChart`的函数定义的，遵循我们在[第1章](ch01.html "第1章. 使用D3.js入门")中讨论的*理解D3风格的JavaScript*配方中的功能对象模式，*使用D3.js入门*。利用功能对象模式提供的信息隐藏的更大灵活性，我们定义了一系列内部属性，所有属性名都以下划线开头（第1B行）。其中一些属性通过提供访问器函数（第1C行）公开。公开可访问的属性如下：
- en: '`width`: Chart SVG total width in pixels'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：图表SVG总宽度（以像素为单位）'
- en: '`height`: Chart SVG total height in pixels'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`：图表SVG总高度（以像素为单位）'
- en: '`margins`: Chart margins'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margins`：图表边距'
- en: '`colors`: Chart ordinal color scale used to differentiate different data series'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colors`：用于区分不同数据系列的图表序数颜色刻度'
- en: '`x`: *x* axis scale'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：*x*轴刻度'
- en: '`y`: *y* axis scale'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：*y*轴刻度'
- en: The accessor functions are implemented using the technique we introduced in
    [Chapter 1](ch01.html "Chapter 1. Getting Started with D3.js"), *Getting Started
    with D3.js*, effectively combining both getter and setter functions in one function,
    which behave as a getter when no argument is given and a setter when an argument
    is present (line `1C`). Additionally, both `lineChart` function and its accessors
    return a chart instance, thus allowing function chaining. Finally, the chart object
    also offers an `addSeries` function, which simply pushes a data array (`series`)
    into its internal data storage array (`_data`), refer to line `1D`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器函数是使用我们在[第1章](ch01.html "第1章. 使用D3.js入门")中介绍的技术实现的，*使用D3.js入门*，有效地将获取器和设置器函数结合在一个函数中，当没有提供参数时表现为获取器，当提供参数时表现为设置器（第1C行）。此外，`lineChart`函数及其访问器都返回一个图表实例，从而允许函数链式调用。最后，图表对象还提供了一个`addSeries`函数，该函数简单地将数据数组（`series`）推入其内部数据存储数组（`_data`），请参阅第1D行。
- en: Chart body frame rendering
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图表主体框架渲染
- en: 'After covering the basic chart object and its attributes, the next aspect of
    this reusable chart implementation is the chart body `svg:g` element rendering
    and its clip path generation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完基本的图表对象及其属性后，此可重用图表实现的下一个方面是图表主体`svg:g`元素的渲染及其剪辑路径的生成：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `render` function defined on line 2A is responsible for creating the `svg:svg`
    element and setting its `width` and `height` (line 2B). After that, it creates
    an `svg:clipPath` element that covers the entire chart body area. The `svg:clipPath`
    element is used to restrict the region where paint can be applied. In our case,
    we used it to restrict the line and dots that can be painted (only within the
    chart body area). This code generates the following SVG element structure that
    defines the chart body:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第2A行定义的`render`函数负责创建`svg:svg`元素并设置其`width`和`height`（第2B行）。之后，它创建一个覆盖整个图表主体区域的`svg:clipPath`元素。`svg:clipPath`元素用于限制可以应用绘画的区域。在我们的例子中，我们使用它来限制可以绘制的线条和点（仅限于图表主体区域）。此代码生成了以下SVG元素结构，用于定义图表主体：
- en: '![Chart body frame rendering](img/image_08_003.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图表主体框架渲染](img/image_08_003.jpg)'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information on clipping and masking, please visit [https://www.w3.org/TR/SVG/masking.html](https://www.w3.org/TR/SVG/masking.html)
    .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于剪切和遮罩的信息，请访问 [https://www.w3.org/TR/SVG/masking.html](https://www.w3.org/TR/SVG/masking.html)
    。
- en: The `renderBody` function defined on line 2D generates the `svg:g` element,
    which wraps all the chart body content with a translation set according to the
    chart margin convention we have discussed in the previous section (line `2E`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第2D行定义的`renderBody`函数生成`svg:g`元素，该元素将所有图表主体内容包裹在一个根据我们在上一节中讨论的图表边距约定设置的平移中（第2E行）。
- en: Render axes
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染坐标轴
- en: 'Axes are rendered in the `renderAxes` function (line `3A`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标轴在`renderAxes`函数（第3A行）中渲染：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As discussed in the previous chapter, both the *x* and *y* axes are rendered
    inside the chart margin area. We will not go into details of axes rendering since
    we have discussed this topic in much detail in [Chapter 5](ch05.html "Chapter 5. Playing
    with Axes"), *Playing with Axes*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，*x*轴和*y*轴都在图表边距区域内渲染。我们不会详细介绍轴的渲染，因为我们已经在[第5章](ch05.html "第5章。玩转坐标轴")中详细讨论了这一主题，*玩转坐标轴*。
- en: Render data series
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染数据系列
- en: 'Everything we discussed so far in this recipe is not unique to this chart type
    alone but rather it is a shared framework among other Cartesian coordinates-based
    chart types. Finally, now we can discuss the core of this recipe-how the line
    segments and dots are created for multiple data series. Let''s take a look at
    the following code fragments that are responsible for data series rendering:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这个食谱中讨论的内容并不仅限于这种图表类型，而是一个与其他基于笛卡尔坐标的图表类型共享的框架。最后，现在我们可以讨论这个食谱的核心——如何为多个数据系列创建线段和点。让我们看看以下负责数据系列渲染的代码片段：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The line segments and dots are generated using techniques we introduced in [Chapter
    7](ch07.html "Chapter 7. Getting into Shape"), *Getting into Shape*. The `d3.line`
    generator was created on line 4A to create `svg:path` that maps the data series.
    The Enter-and-Update pattern is used to create the data line (line 4B). Line 4C
    sets a different color for each data line based on its index. Lastly, line 4E
    sets the transition in the update mode to move the data line smoothly on each
    update. The `renderDots` function performs a similar rendering logic that generates
    a set of `svg:circle` elements representing each data point (line 4E), coordinating
    its color based on the data series index (line 4F), and finally also initiates
    a transition on line 4G, so the dots can move with the line whenever the data
    is updated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 线段和点是通过我们在[第7章](ch07.html "第7章。进入形状")中介绍的技术生成的，*进入形状*。`d3.line`生成器在第4A行创建，用于创建映射数据系列的`svg:path`。使用Enter-and-Update模式在第4B行创建数据线。第4C行根据索引为每条数据线设置不同的颜色。最后，第4E行在更新模式下设置过渡，使数据线在每次更新时都能平滑移动。`renderDots`函数执行类似的渲染逻辑，生成一组代表每个数据点的`svg:circle`元素（第4E行），根据数据系列索引（第4F行）协调其颜色，并在第4G行上启动过渡，这样点就可以在数据更新时与线一起移动。
- en: As illustrated by this recipe, creating a reusable chart component involves
    actually quite a bit of work. However, more than two-thirds of the code is required
    to create peripheral graphical elements and accessors methods. Therefore, in a
    real-world project, you can extract this logic and reuse a large part of this
    implementation for other charts; though we did not do this in our recipes in order
    to reduce the complexity, you can quickly grasp all aspects of chart rendering.
    Due to limited scope in this book, in later recipes, we will omit all peripheral
    rendering logic and only focus on the core logic related to each chart type.Feel
    free to jump back to this recipe if you ever need to double-check the peripheral
    rendering logic while reading the later recipes in this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如本食谱所示，创建一个可重用的图表组件实际上需要做很多工作。然而，超过三分之二的代码用于创建外围图形元素和访问器方法。因此，在实际项目中，你可以提取这部分逻辑，并将此实现的大部分用于其他图表；尽管我们没有在我们的食谱中这样做以降低复杂性，但你仍然可以快速掌握图表渲染的所有方面。由于本书的范围有限，在后面的食谱中，我们将省略所有外围渲染逻辑，仅关注与每种图表类型相关的核心逻辑。如果你在阅读本章后面的食谱时需要再次检查外围渲染逻辑，请随时回到这个食谱。
- en: Creating an area chart
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建面积图
- en: An area chart or an area graph is very similar to a line chart and largely implemented
    based on the line chart. The main difference between an area chart and a line
    chart is that in the area chart, the area between the axis and the line will be
    filled with colors or textures. In this recipe, we will explore techniques of
    implementing a type of area chart known as **Layered Area Chart**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 面积图或面积图与折线图非常相似，主要基于折线图实现。面积图与折线图的主要区别在于，在面积图中，轴和线之间的区域将被填充颜色或纹理。在本食谱中，我们将探讨实现一种称为**分层面积图**的面积图的技术。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/area-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/area-chart.html)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/area-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/area-chart.html)'
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'An area chart implementation is largely based on the line chart implementation
    and shares a lot of common graphical elements, such as the axes and the clip path;
    therefore, in this recipe, we will only show the code that concerns the area chart
    implementation specifics:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 面积图的实现主要基于折线图的实现，并且共享许多共同的图形元素，例如坐标轴和裁剪路径；因此，在这个菜谱中，我们只展示与面积图实现具体相关的代码：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This recipe generates the following layered area chart:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱生成了以下层次面积图：
- en: '![How to do it...](img/image_08_004.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_08_004.jpg)'
- en: Layered area chart
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 层次面积图
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we mentioned before, since the area chart implementation is based on our
    line chart implementation, a large part of the implementation is identical to
    the line chart. In fact, the area chart needs to render the exact line and dots
    implemented in the line chart. The crucial difference lies in the `renderAreas`
    function. In this recipe, we rely on the area generation technique discussed in
    [Chapter 7](ch07.html "Chapter 7. Getting into Shape"), *Getting into Shape*.
    The `d3.area` generator was created on line `A` with its upper line created to
    match the line while its lower line (`y0`) fixed on x axis.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，由于面积图的实现基于我们的折线图实现，实现的大部分内容与折线图相同。实际上，面积图需要渲染折线图中实现的精确线条和点。关键的区别在于`renderAreas`函数。在这个菜谱中，我们依赖于第7章中讨论的面积生成技术，即*“形状入门”*。在行`A`上创建了`d3.area`生成器，其上边线与线条匹配，而下边线（`y0`）固定在x轴上。
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the area generator is defined, a classic Enter-and-Update pattern is employed
    to create and update the areas. In the Enter case (line `B`), an `svg:path` element
    was created for each data series. On line `B2`, we merged the `pathAreas.enter()`
    and `pathAreas`; therefore, all following code will be applied to both the enter
    and update modes; all areas are colored using its series index so it will have
    matching color with our line and dots (line `C`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了面积生成器，就采用经典的“进入-更新”模式来创建和更新面积。在进入情况下（行`B`），为每个数据系列创建了一个`svg:path`元素。在行`B2`中，我们将`pathAreas.enter()`和`pathAreas`合并；因此，所有后续代码都将应用于进入和更新模式；所有面积都使用其系列索引进行着色，因此将与我们的线和点匹配颜色（行`C`）：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Whenever the data is updated, as well as for newly created areas, we start a
    transition (line D) to update the area `svg:path` elements' `d` attribute to the
    desired shape (line E).Since we know that the line chart implementation animates
    both line and dots when updated, our area update transition here effectively allows
    the areas to be animated and moved in accordance with both lines and dots in our
    chart.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据更新时，以及对于新创建的面积，我们开始一个过渡（行D）来更新面积`svg:path`元素的`d`属性到所需的形状（行E）。由于我们知道折线图实现更新时同时动画化线和点，我们这里的面积更新过渡有效地允许面积根据图表中的线和点进行动画化和移动。
- en: 'Finally, we also add the CSS style for `path.area` to decrease its opacity
    so areas become see-through and `hence allow the layered effect` we want:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还添加了`path.area`的CSS样式以降低其不透明度，使区域变得透明，从而实现我们想要的`分层效果`：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a scatterplot chart
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建散点图图表
- en: A scatterplot or scattergraph is another common type of diagram used to display
    data points on Cartesian coordinates with two different variables. Scatterplot
    is especially useful when you're exploring the problem of spreading, clustering,
    and classification. In this recipe, you will learn how to implement a multi-series
    scatterplot chart in D3.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图或散点图是另一种常见的图表类型，用于在笛卡尔坐标系上显示具有两个不同变量的数据点。散点图在探索扩散、聚类和分类问题时特别有用。在这个菜谱中，你将学习如何在D3中实现多系列散点图图表。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/scatterplot-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/scatterplot-chart.html)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/scatterplot-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/scatterplot-chart.html)'
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A scatterplot is another chart that uses Cartesian coordinates. Thus, a large
    part of its implementation is very similar to the charts we introduced so far;
    and therefore, the code concerning peripheral graphical elements are again omitted
    to save space in this book. Please refer to the companion code for the complete
    implementation. Now let''s take a look the implementation of this recipe:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是另一种使用笛卡尔坐标系的图表。因此，其实现的大部分内容与我们之前介绍过的图表非常相似；因此，为了节省空间，本书中省略了有关外围图形元素的代码。请参考配套代码以获取完整的实现。现在让我们看看这个菜谱的实现：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This recipe generates the following scatterplot chart:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱生成了以下散点图图表：
- en: '![How to do it...](img/image_08_005.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_08_005.jpg)'
- en: Scatter plot chart
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图图表
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The content of the scatterplot chart is mainly rendered by the `renderSymbols`
    function on line `B`. You probably may have already noticed that the `renderSymbols`
    function implementation is very similar to the `renderDots` function we discussed
    in the *Creating a line chart* recipe. This is not by accident since both try
    to plot data points on Cartesian coordinates with two variables (x and y). In
    the case of plotting dots, the `svg:circle` elements were being created, whereas,
    in scatterplot, you will need to create the `d3.symbol` elements. D3 provides
    a list of predefined symbols that can be generated easily and rendered using an
    `svg:path` element. As shown on line `A`, we defined an ordinal scale to allow
    mapping of data series index to different symbol types:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图图表的内容主要由行`B`上的`renderSymbols`函数渲染。你可能已经注意到，`renderSymbols`函数的实现与我们之前在*创建折线图*菜谱中讨论的`renderDots`函数非常相似。这不是偶然的，因为两者都试图在笛卡尔坐标系上使用两个变量（x和y）绘制数据点。在绘制点的情况下，创建了`svg:circle`元素，而在散点图中，你需要创建`d3.symbol`元素。D3提供了一系列预定义的符号，可以轻松生成并使用`svg:path`元素渲染。如线`A`所示，我们定义了一个序数尺度，允许将数据系列索引映射到不同的符号类型：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Plotting the data points with symbols is quite straightforward. First, we will
    loop through the data series array, and for each data series, we will create a
    set of `svg:path` elements representing each data point in the series as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用符号绘制数据点相当直接。首先，我们将遍历数据系列数组，对于每个数据系列，我们将创建一组`svg:path`元素，代表系列中的每个数据点，如下所示：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By merging the `symbols.enter()` and `symbols` selections, we made sure that
    whenever data series are updated, as well as for newly created symbols, we apply
    the update with transition (line `C`), placing them on the right coordinates with
    an SVG translation transformation (line D). Finally, the `d` attribute of each
    `svg:path` element is generated using the `d3.svg.symbol` generator function as
    shown on line `E`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过合并`symbols.enter()`和`symbols`选择，我们确保在数据系列更新时，以及对于新创建的符号，我们使用过渡（线`C`）进行更新，将它们放置在正确的坐标上，使用SVG平移变换（线D）。最后，每个`svg:path`元素的`d`属性是通过`d3.svg.symbol`生成函数生成的，如线`E`所示。
- en: Creating a bubble chart
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建气泡图
- en: A bubble chart is a typical visualization capable of displaying three data dimensions.
    Every data entity with its three data points is visualized as a bubble (or disk)
    on Cartesian coordinates, with two different variables represented using *x* axis
    and *y* axis, similar to the `scatterplot` chart, while the third dimension is
    represented using the radius of the bubble (size of the disk). The bubble chart
    is particularly useful when it's used to facilitate `the understanding of relation`ships
    between data entities.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡图是一种典型的可视化工具，能够显示三个数据维度。每个具有三个数据点的数据实体在笛卡尔坐标系上被可视化为一个气泡（或圆盘），其中两个不同的变量使用*x*轴和*y*轴表示，类似于散点图图表，而第三个维度则使用气泡的半径（圆盘的大小）表示。当用于促进数据实体之间关系的理解时，气泡图尤其有用。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bubble-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bubble-chart.html)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bubble-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bubble-chart.html)'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will explore techniques and ways of implementing a typical
    bubble chart using D3\. The following code example shows the important implementation
    aspects of a bubble chart, omitting the accessors and peripheral graphic implementation
    details:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨使用D3实现典型气泡图的技术和方法。以下代码示例展示了气泡图的重要实现方面，省略了访问器和外围图形实现细节：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This recipe generates the following visualization:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方生成了以下可视化：
- en: '![How to do it...](img/image_08_006.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](img/image_08_006.jpg)'
- en: Bubble chart
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡图
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Overall, the bubble chart implementation follows the same pattern as other
    chart implementations introduced in this chapter so far. However, since we want
    to visualize three different dimensions (x, y, and radius) instead of two in the
    bubble chart, a new scale `_r` was added in this implementation (line `A`) as
    follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，气泡图的实现遵循本章迄今为止介绍的其他图表实现的相同模式。然而，由于我们想要可视化三个不同的维度（x、y和半径），而不是气泡图中通常的两个维度，因此在这个实现中添加了一个新的刻度`_r`（行`A`），如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Most of the bubble chart-related implementation details are handled by the
    `renderBubbles` function. It starts with setting the range on the radius scale
    (line `B`). Of course, we can also make the radius range configurable in our chart
    implementation; however, for simplicity, we chose to set it explicitly in the
    following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数气泡图相关的实现细节都由`renderBubbles`函数处理。它从设置半径刻度上的范围开始（行`B`）。当然，我们也可以在我们的图表实现中使半径范围可配置；然而，为了简单起见，我们选择在以下代码中显式设置它：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the range is set, we iterated through our data series, and for each series,
    we created a set of `svg:circle` elements (line `C`). Finally, we handled the
    newly created bubble and its update in the last section, where the `svg:circle`
    elements are colored and placed `to` the correct coordinates using its `cx` and
    `cy` attributes (lines `D` and `E`). In the end, the bubble size is controlled
    using its radius attribute `r` mapped using the `_r` scale we defined earlier
    (line F).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了范围，我们就遍历我们的数据系列，并为每个系列创建一组`svg:circle`元素（行`C`）。最后，在最后一节中处理新创建的气泡及其更新，其中使用其`cx`和`cy`属性将`svg:circle`元素着色并放置到正确的坐标（行`D`和`E`）。最后，使用我们之前定义的`_r`刻度来控制气泡大小，通过其半径属性`r`映射（行`F`）。
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In some of the bubble chart implementations, the implementer also leverages
    the color of each bubble to visualize a fourth data dimension, although some believe
    this kind of visual representation is hard to grasp and superfluous.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些气泡图实现中，实现者还利用每个气泡的颜色来可视化第四个数据维度，尽管有些人认为这种视觉表示难以理解且多余。
- en: Creating a bar chart
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: A bar chart is a visualization that uses either horizontal (row charts) or vertical
    (column charts) rectangular bars with length proportional to the values that they
    represent. In this recipe, we will implement a column chart using D3\. A column
    chart is capable of visually representing two variables at the same time with
    its *y* axis; in other words, the bar height and its *x* axis. The *x* axis values
    can be either discrete or continuous (for example, a histogram). In our example,
    we choose to visualize continuous values on the x axis. However, the same technique
    can be applied when you work with discrete values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 柱状图是一种使用水平（行图）或垂直（柱状图）矩形条来表示的视觉化，其长度与它们所代表的值成比例。在这个配方中，我们将使用D3实现柱状图。柱状图能够使用其*y*轴同时可视化两个变量；换句话说，条形的高度和它的*x*轴。*x*轴的值可以是离散的或连续的（例如，直方图）。在我们的例子中，我们选择在x轴上可视化连续值。然而，当您处理离散值时，也可以应用相同的技巧。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bar-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bar-chart.html)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bar-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bar-chart.html)'
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The following code example shows the important implementation aspects of a
    histogram, omitting the accessors and peripheral graphic implementation details:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了直方图的重要实现方面，省略了访问器和外围图形实现细节：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This recipe generates the following visualization:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方生成了以下可视化：
- en: '![How to do it...](img/image_08_007.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](img/image_08_007.jpg)'
- en: Bar chart (histogram)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 柱状图（直方图）
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'One major difference here is that the bar chart implementation does not support
    multiple data series. Therefore, instead of using a 2D array storing multiple
    data series as we did with other charts so far, in this implementation, the `_data`
    array simply stores a single set of data points directly. Main bar chart-related
    visualization logic resides in the `renderBars` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个主要区别是条形图实现不支持多个数据系列。因此，与迄今为止我们使用其他图表一样，我们在这个实现中，`_data`数组简单地直接存储一组数据点。主要的条形图相关可视化逻辑位于`renderBars`函数中：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the first step, we defined the padding between bars (line `A`) so that later
    on we can automatically calculate the width of each bar. After that, we generated
    an `svg:rect` element (the bars) for each data point (line `B`) as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们定义了条形之间的填充（线`A`），以便稍后我们可以自动计算每个条形的宽度。之后，我们为每个数据点（线`B`）生成一个`svg:rect`元素（条形），如下所示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in the update section, we placed each bar at the correct coordinates
    using its *x* and *y* attributes (lines `C` and `D`) and extended each bar all
    the way down to touch the *x* axis with an adaptive `height` calculated on line
    E. Finally, we calculated the optimal width for each bar using the number of bars
    and the padding value we defined earlier:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在更新部分，我们使用每个条形的`x`和`y`属性（线`C`和`D`）将每个条形放置在正确的坐标上，并使用线E上计算的适应性`高度`将每个条形延伸到底部，使其接触到`x`轴。最后，我们使用条形数量和我们之前定义的填充值计算每个条形的最佳宽度：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, in a more flexible implementation, we can make the padding configurable
    instead of being fixed to 2 pixels.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在更灵活的实现中，我们可以使填充可配置，而不是固定为2像素。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Before planning to implement your own reusable chart for your next visualization
    project, make sure that you also check out the following open source reusable
    chart projects based on D3:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在计划实现您下一个可视化项目的自定义可重用图表之前，请确保您还检查以下基于D3的开源可重用图表项目：
- en: 'NVD3: [http://nvd3.org/](http://nvd3.org/).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVD3：[http://nvd3.org/](http://nvd3.org/).
- en: 'Dimensional Charting: [https://dc-js.github.io/dc.js/](https://dc-js.github.io/dc.js/)
    .'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维度图表：[https://dc-js.github.io/dc.js/](https://dc-js.github.io/dc.js/).
- en: 'Rickshaw: [http://code.shutterstock.com/rickshaw/](http://code.shutterstock.com/rickshaw/).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手推车：[http://code.shutterstock.com/rickshaw/](http://code.shutterstock.com/rickshaw/).
