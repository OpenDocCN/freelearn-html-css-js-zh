- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Loading Data into a Route
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据加载到路由中
- en: '`/birthdays` route that we’ll work on in this chapter. Part of that routing
    is ensuring that the route has the data available to it. In this chapter, you’ll
    see how you can test-drive SvelteKit’s `load` function for pulling that data into
    a component.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要工作的`/birthdays`路由。其中一部分路由是确保路由有可用的数据。在本章中，你将看到如何测试驱动SvelteKit的`load`函数，以将数据拉入组件中。
- en: You’ll also see how Playwright can be used to build an end-to-end test that
    proves all the various components of this system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将看到如何使用Playwright构建一个端到端测试，以证明这个系统的所有各种组件。
- en: 'This chapter covers the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下内容：
- en: Using Playwright to specify end-to-end behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Playwright指定端到端行为
- en: Deciding an approach to make the end-to-end test pass
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使端到端测试通过的方法
- en: Test-driving the load function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动加载函数
- en: Test-driving the page component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动页面组件
- en: By the end of the chapter, you’ll have test-driven a functioning SvelteKit route
    that you can view in your web browser, and you’ll have learned the key differences
    between Playwright end-to-end tests and Vitest unit tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将测试驱动一个可以在你的网络浏览器中查看的SvelteKit路由，并且你将了解Playwright端到端测试和Vitest单元测试之间的关键区别。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，地址为[https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter03/Start)。
- en: Using Playwright to specify end-to-end behavior
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Playwright指定端到端行为
- en: In this section, you will write your first Playwright test and learn about the
    various function calls within it, and you’ll learn about differentiating between
    Playwright end-to-end tests and Vitest unit tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将编写你的第一个Playwright测试，并了解其中的各种函数调用，你还将了解区分Playwright端到端测试和Vitest单元测试。
- en: Writing the test and watching it fail
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试并观察其失败
- en: 'The test we are going to write is entitled `lists all birthdays` and it will
    perform the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的测试名为`列出所有生日`，它将执行以下步骤：
- en: Browse to the `/``birthdays` location.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到`/``birthdays`位置。
- en: Look for the text `Hercules` and `Athena`, which it will take as evidence that
    the test has passed.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找文本`Hercules`和`Athena`，这将作为测试通过的证据。
- en: Once the test is in place, we’ll stop to think about how this `Hercules` and
    `Athena` data should get into our system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试就位，我们将停下来思考如何让这个`Hercules`和`Athena`数据进入我们的系统。
- en: 'Create a new file named `tests/birthdays.test.js` and add the following content:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`tests/birthdays.test.js`的新文件，并添加以下内容：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see some things here that are similar to the Vitest tests, such as the
    use of `expect` and the `toBeVisible` matcher.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到一些与Vitest测试类似的东西，例如使用`expect`和`toBeVisible`匹配器。
- en: However, some things are different. For a start, the test is marked as `async`
    and all the function calls (including the `expect` function calls) are marked
    with `await`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些事情是不同的。首先，测试被标记为`async`，所有的函数调用（包括`expect`函数调用）都被标记为`await`。
- en: 'That’s necessary because Playwright is driving a headless browser, meaning
    it’s started a real browser process that runs in the background and is invisible
    to you. Playwright has no mechanism for determining when the browser has completed
    working, beyond waiting patiently and frequently checking the browser state. Therefore,
    most of its internal logic is driven by waits and timeouts: the browser is given
    a certain amount of time, generally a few seconds, to get things displayed.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必要的，因为Playwright正在驱动一个无头浏览器，这意味着它启动了一个在后台运行的真正浏览器进程，对你来说是不可见的。Playwright没有机制来确定浏览器何时完成工作，除了耐心地等待并频繁检查浏览器状态。因此，其大部分内部逻辑都是由等待和超时驱动的：浏览器被给予一定的时间，通常几秒钟，来显示内容。
- en: The `page.goto` call is instructing this headless browser to navigate to the
    `/birthdays` endpoint. Playwright takes care of spinning up a real dev server
    in the background and ensuring that any relative URLs (such as `/birthdays`) are
    converted to absolute URLs pointing at this dev server (like `https://localhost:5173/birthdays`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`page.goto`调用指示这个无头浏览器导航到`/birthdays`端点。Playwright负责在后台启动一个真实的开发服务器，并确保任何相对URL（例如`/birthdays`）都转换为指向此开发服务器的绝对URL（如`https://localhost:5173/birthdays`）。'
- en: 'Go ahead and run the test now, using the `npm test` shell command. You should
    see an almost immediate failure appear:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试，使用 `npm test` 命令。你应该会看到几乎立即出现的失败：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the test complete, let’s take a more detailed look at the difference between
    Vitest tests and Playwright tests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，让我们更详细地看看 Vitest 测试和 Playwright 测试之间的区别。
- en: Understanding the difference between Vitest tests and Playwright tests
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Vitest 测试和 Playwright 测试之间的区别
- en: There are fundamental differences between how Vitest tests work and how Playwright
    tests work. Both play their part in TDD.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 测试的工作方式和 Playwright 测试的工作方式之间有根本性的区别。两者都在 TDD 中扮演着它们的角色。
- en: '*Figure 3**.1* shows how each type of test encompasses your code. Playwright
    tests are often referred to as end-to-end tests and they are high-level, with
    each test exercising a whole lot of code. Vitest tests are often called unit tests.
    They are very detailed and exercise just a small piece of the code.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.1* 展示了每种类型的测试如何涵盖您的代码。Playwright 测试通常被称为端到端测试，它们是高级的，每个测试都锻炼大量的代码。Vitest
    测试通常被称为单元测试。它们非常详细，只锻炼一小段代码。'
- en: '![Figure 3.1 – End-to-end tests and unit tests in a SvelteKit project](img/Figure_3.1_B19611.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – SvelteKit 项目中的端到端测试和单元测试](img/Figure_3.1_B19611.jpg)'
- en: Figure 3.1 – End-to-end tests and unit tests in a SvelteKit project
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – SvelteKit 项目中的端到端测试和单元测试
- en: Playwright tests are often a good starting point when embarking on building
    a new feature. They may even be written by project stakeholders who are not developers
    but still participate in defining features. In [*Chapter* *13*](B19611_13.xhtml#_idTextAnchor148),
    *Adding Cucumber Tests*, we’ll see how this can be done with plain English syntax
    rather than JavaScript code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始构建新功能时，Playwright 测试通常是一个好的起点。甚至可能由不是开发者但仍然参与定义特性的项目利益相关者编写。在 [*第 13 章*](B19611_13.xhtml#_idTextAnchor148)，*添加
    Cucumber 测试* 中，我们将看到如何使用纯英语语法而不是 JavaScript 代码来完成这项工作。
- en: Playwright tests are often written against the browser UI. They exercise the
    whole system, including the web browser and any out-of-process resources such
    as databases. When working with a SvelteKit application, the Playwright test runner
    starts up the SvelteKit web server and executes all of the SvelteKit runtime code
    for managing routes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 测试通常针对浏览器 UI 编写。它们锻炼整个系统，包括网络浏览器和任何进程外资源，如数据库。当与 SvelteKit 应用程序一起工作时，Playwright
    测试运行器启动 SvelteKit 网络服务器并执行所有 SvelteKit 运行时代码，以管理路由。
- en: In contrast, the Vitest test runner does not load up the SvelteKit web server
    and does not execute any of its code. Instead, it loads your JavaScript files
    directly into the same Node process that Vitest and your test suites are loaded
    into.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Vitest 测试运行器不会加载 SvelteKit 网络服务器，也不会执行其任何代码。相反，它直接将您的 JavaScript 文件加载到与 Vitest
    和您的测试套件相同的 Node 进程中。
- en: While Playwright tests are good for focusing a team on what needs to be built,
    they often have nothing to say about the internal design of the software or even
    the architecture of the system as a whole. This is where Vitest unit tests come
    in. They can be used by developers to work out the *how* of a system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Playwright 测试有助于让团队专注于需要构建的内容，但它们通常对软件的内部设计或整个系统的架构没有太多可说的。这就是 Vitest 单元测试发挥作用的地方。开发者可以使用它们来弄清楚系统的
    *如何*。
- en: There are a number of ways that unit tests help with design. For example, if
    a unit test is proving difficult to write, that’s sometimes a sign that the application
    design is too complex. Breaking apart the units in a different way can lead to
    the unit tests becoming much simpler.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有助于设计的方式有很多。例如，如果一个单元测试很难编写，那有时可能意味着应用程序设计过于复杂。以不同的方式分解单元可以使得单元测试变得更加简单。
- en: Playwright tests are often kept low on specifics leaving the unit tests to cover
    the details. For example, in the test we just wrote, we are interested in the
    listing of the birthdays that the system knows about but notice that we only checked
    by looking for the names of people, and not the birthdays. We leave the complete
    birthday checks to the unit tests for the `Birthday` component, which we already
    wrote in [*Chapter 2*](B19611_02.xhtml#_idTextAnchor036), *Introducing the* *Red-Green-Refactor
    Workflow*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 测试通常在具体细节上保持较低的要求，将详细内容留给单元测试。例如，在我们刚刚编写的测试中，我们关注的是系统所知道的生日列表，但请注意，我们只是通过查找人的名字来检查，而没有检查生日。我们将完整的生日检查留给
    `Birthday` 组件的单元测试，该组件已在 [*第 2 章*](B19611_02.xhtml#_idTextAnchor036)，*介绍红-绿-重构工作流程*
    中编写。
- en: This way, we end up with lots of low-level Vitest unit tests and a few higher-level
    Playwright tests. This is the classic test automation pyramid as described by
    Mike Cohn in the book *Succeeding with Agile*. It encourages a testing strategy
    that includes many unit tests, some service tests, and just a dollop of UI tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们最终会有很多低级的 Vitest 单元测试和一些高级的 Playwright 测试。这正是 Mike Cohn 在《成功实施敏捷》一书中描述的经典测试自动化金字塔。它鼓励采用包含许多单元测试、一些服务测试以及少量
    UI 测试的测试策略。
- en: '*Figure 3**.2* shows how the test automated pyramid can be applied to SvelteKit
    projects. Playwright end-to-end tests can be written against both the UI and also
    against specific API endpoints, and your unit tests are written for the Vitest
    runner.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.2* 展示了测试自动化金字塔如何应用于 SvelteKit 项目。Playwright 端到端测试可以针对 UI 和特定 API 端点编写，而你的单元测试是为
    Vitest 运行器编写的。'
- en: '![Figure 3.2 – The testing pyramid as applied to SvelteKit projects](img/Figure_3.2_B19611.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 将测试金字塔应用于 SvelteKit 项目](img/Figure_3.2_B19611.jpg)'
- en: Figure 3.2 – The testing pyramid as applied to SvelteKit projects
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 将测试金字塔应用于 SvelteKit 项目
- en: One reason for structuring automated tests in this way is that unit tests are
    cheap to create and maintain, whereas UI tests are expensive in terms of time
    and energy put into them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建自动化测试的一个原因是单元测试创建和维护成本低，而 UI 测试在时间和精力投入方面成本高昂。
- en: The service tests are like the UI tests in that they cover a whole flow through
    a system but avoid the UI. For example, they may call HTTP API endpoints directly.
    That can be helpful because the UI tends to be the most brittle component of the
    system, and driving a UI can take a while as you wait for the on-screen changes
    to be rendered.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 服务测试类似于 UI 测试，因为它们覆盖了整个系统流程，但避免了 UI。例如，它们可以直接调用 HTTP API 端点。这可能很有帮助，因为 UI 往往是系统中最脆弱的组件，而驱动
    UI 需要一段时间，因为你需要等待屏幕上的变化被渲染。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Modern web browser environments, together with modern test runners such as Playwright,
    have gotten much better at handling automated UI tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络浏览器环境，以及现代测试运行器如 Playwright，在处理自动化 UI 测试方面已经变得越来越好。
- en: Another reason the classic test automation pyramid makes sense is that unit
    tests are often very fast to execute. You can have many unit tests, each of which
    executes just a tiny fraction of the code surface. When one of those tests breaks,
    it’s very quick to read the test description or test code and figure out where
    in the application code the failure lies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 经典测试自动化金字塔合理性的另一个原因是单元测试通常执行得非常快。你可以有很多单元测试，每个测试只执行代码表面的极小部分。当其中一个测试失败时，阅读测试描述或测试代码并找出应用程序代码中失败位置的速度非常快。
- en: It’s also worth remembering that unit tests serve to document all of the technical
    design decisions taken when writing the code, and this documentation is invaluable
    in understanding the history of a project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得记住的是，单元测试旨在记录编写代码时所做的所有技术设计决策，这种文档对于理解项目的历史至关重要。
- en: Finally, keep in mind that Vitest unit tests do not test the SvelteKit server-side
    runtime environment. That means, for example, that a Vitest unit test can test
    that you correctly defined a `load` function, but it cannot test that the route
    is hooked up correctly. For that, you need a Playwright test that compiles and
    runs your components and routes just as if it was a real browser environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，Vitest 单元测试并不测试 SvelteKit 服务器端运行环境。这意味着，例如，Vitest 单元测试可以测试你是否正确定义了 `load`
    函数，但它不能测试路由是否正确连接。为此，你需要一个 Playwright 测试，它编译并运行你的组件和路由，就像它是一个真实的浏览器环境一样。
- en: Deciding an approach to make the end-to-end test pass
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定一种方法来使端到端测试通过
- en: With that all said, how do we begin writing Vitest unit tests now that we have
    a Playwright test that defines what we want?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，既然我们已经有了定义我们想要什么的 Playwright 测试，我们现在如何开始编写 Vitest 单元测试呢？
- en: The Playwright test looks for the names `Hercules` and `Athena`. The test makes
    an assumption that these two people have their birthdays listed in the system
    and that the page at `/birthdays` lists them. But how do we get them into the
    system in the first place?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 测试寻找名称 `Hercules` 和 `Athena`。测试假设这两个人在系统中列出了他们的生日，并且 `/birthdays`
    页面列出了他们。但我们是怎样首先将他们放入系统中的呢？
- en: In true TDD style, we can defer this decision and simply hardcode these two
    birthdays in the system. After all, the test doesn’t seem to care about how the
    data gets into the system, only about how it is presented.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正的TDD风格中，我们可以推迟这个决定，并简单地将这些两个生日硬编码到系统中。毕竟，测试似乎并不关心数据是如何进入系统的，而只是关心它是如何呈现的。
- en: We can come back to how the birthdays are added later. In fact, we’ll do this
    in [*Chapter 8*](B19611_08.xhtml#_idTextAnchor100), *Creating Matchers to Simplify
    Tests*. We can also make use of our `Birthday` component from [*Chapter 2*](B19611_02.xhtml#_idTextAnchor036),
    *Introducing the Red-Green-Refactor Workflow*, to display each birthday in turn.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍后回来讨论如何添加生日。实际上，我们将在[*第8章*](B19611_08.xhtml#_idTextAnchor100)中这样做，*创建匹配器以简化测试*。我们还可以利用[*第2章*](B19611_02.xhtml#_idTextAnchor036)中的`Birthday`组件，*介绍红-绿-重构工作流程*，依次显示每个生日。
- en: 'Therefore, what we need to do is the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要做的是以下这些：
- en: Create a `load` function that returns hardcoded birthday data for Hercules and
    Athena. This needs to exist within the `src/routes/birthdays/+page.server.js`
    file.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`load`函数，返回赫拉克勒斯和雅典娜的硬编码生日数据。这需要在`src/routes/birthdays/+page.server.js`文件中存在。
- en: Create a `page` component that takes the data from `load` and displays a `Birthday`
    component for each of the birthdays given. This needs to exist as `src/routes/birthdays/+page.svelte`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`page`组件，它从`load`获取数据并为每个给定的生日显示一个`Birthday`组件。这需要作为`src/routes/birthdays/+page.svelte`存在。
- en: SvelteKit takes care of matching the `/birthdays` route to our files in the
    `src/routes/birthdays` directory. After calling `load`, it will pass the result
    into the `data` prop in the `+``page.svelte` component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SvelteKit负责将`/birthdays`路由与`src/routes/birthdays`目录中的文件匹配。在调用`load`后，它将结果传递到`+page.svelte`组件的`data`属性中。
- en: That covers how to write a basic Playwright end-to-end test. We’ve discussed
    the differences between Playwright end-to-end and Vitest unit tests, and we’ve
    come up with a plan for the rest of the chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了如何编写基本的Playwright端到端测试。我们已经讨论了Playwright端到端测试和Vitest单元测试之间的区别，并为本章的其余部分制定了一个计划。
- en: The next section covers how to test-drive a basic, hardcoded version of our
    `load` function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍如何测试驱动我们的`load`函数的基本、硬编码版本。
- en: Test-driving the load function
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动加载函数
- en: Now that we’ve decided to implement a `load` function that returns hardcoded
    birthday data for Hercules and Athena, the actual change has become very simple.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经决定实现一个`load`函数，该函数返回赫拉克勒斯和雅典娜的硬编码生日数据，实际的更改已经变得非常简单。
- en: The `load` function is a special SvelteKit function that will be invoked when
    a request comes in for the given route. So, when the user navigates to the `/birthdays`
    route, SvelteKit calls the `load` function in the `src/routes/birthdays/+page.server.js`
    file and then renders the component in the `src/routes/birthdays/+page.svelte`
    file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`函数是一个特殊的SvelteKit函数，当有请求到达指定的路由时将被调用。因此，当用户导航到`/birthdays`路由时，SvelteKit会调用`src/routes/birthdays/+page.server.js`文件中的`load`函数，然后渲染`src/routes/birthdays/+page.svelte`文件中的组件。'
- en: 'Follow these steps to create the `load` function using TDD:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用TDD创建`load`函数：
- en: 'Create a new Vitest test file named `src/routes/birthdays/page.server.test.js`
    and start it off as shown. We are importing the `load` function from a `+page.server.js`
    file that doesn’t yet exist. We call the function in our test and store the result:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Vitest测试文件，命名为`src/routes/birthdays/page.server.test.js`，并按照以下方式开始。我们正在从还不存在的`+page.server.js`文件中导入`load`函数。我们在测试中调用该函数并存储结果：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Naming describe blocks for load functions
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为加载函数命名describe块
- en: I’ve named the `describe` block `/birthdays - load`, which demonstrates a standard
    naming pattern that can be used for the `load` functions for routes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`describe`块命名为`/birthdays - load`，这展示了可以用于路由`load`函数的标准命名模式。
- en: 'Complete the test with the following expectation:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下期望完成测试：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One expectation per test
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试一个期望
- en: This entire test contains just a single call to `expect`. Generally, when writing
    tests, I find it’s useful to stick to just one expectation if possible. That helps
    to keep a strong link between the test description and the contents of the `expect`
    call.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 整个测试只包含对`expect`的单次调用。通常，在编写测试时，我发现尽可能只保留一个期望是有用的。这有助于保持测试描述和`expect`调用内容之间的紧密联系。
- en: It’s often the case (as in this test) that you can stuff a whole lot of checks
    in a single expectation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下（就像这个测试一样），你可以在单个期望中放入大量的检查。
- en: The `toEqual` matcher has a special *deep equality* mechanism that means each
    level of an object or array can be checked for its value, rather than its identity.
    And moreover, we can use constraint functions such as `objectContaining`, which
    we’ll see in [*Chapter 6*](B19611_06.xhtml#_idTextAnchor079), *Editing* *Form
    Data*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`toEqual` 匹配器有一个特殊的 *深度相等* 机制，这意味着可以检查对象或数组的每一层的值，而不是它的身份。而且，我们可以使用约束函数，例如
    `objectContaining`，我们将在 [*第6章*](B19611_06.xhtml#_idTextAnchor079)，*编辑* *表单数据*）中看到。'
- en: 'Go ahead and run the test with your Vitest test runner. This gives the following
    output:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的 Vitest 测试运行器运行测试。这将给出以下输出：
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Do as it suggests and create an empty file at the `src/routes/birthdays/+page.server.js`
    location, and then rerun your tests. You should see the following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照建议在 `src/routes/birthdays/+page.server.js` 位置创建一个空文件，然后重新运行你的测试。你应该会看到以下内容：
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Okay, marvelous: `load is not a function`. Let’s create a basic `load` function,
    then, with absolutely nothing in it. Add this to the new file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，太棒了：`load` 不是一个函数。那么，让我们创建一个基本的 `load` 函数，里面什么都没有。将以下内容添加到新文件中：
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Rerun your tests. You’ll get the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行你的测试。你会得到以下内容：
- en: '[PRE7]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To fix the issue, all we need to do is fill in the hardcoded values. Update
    the code in `src/routes/birthdays/+page.server.js` to look as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们只需要填写硬编码的值。更新 `src/routes/birthdays/+page.server.js` 中的代码，使其看起来如下：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Plumbing and hardcoded values
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和硬编码的值
- en: It may feel a bit pointless doing this, but the value is in getting the plumbing
    into place. The test we’ve written here will serve as a useful regression test
    when we come to fill in the *real* implementation, which does more than simply
    return hardcoded data. (We’ll improve upon this implementation in [*Chapter 4*](B19611_04.xhtml#_idTextAnchor060),
    *Saving* *Form Data*).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做可能感觉有点没有意义，但价值在于将管道设置到位。我们在这里编写的测试将在我们填充 *真实* 实现时作为一个有用的回归测试，这个实现不仅仅是返回硬编码的数据。（我们将在
    [*第4章*](B19611_04.xhtml#_idTextAnchor060)，*保存* *表单数据*）中改进这个实现）。
- en: 'Run your tests again and you’ll see the test succeeds:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行你的测试，你会看到测试成功：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That completes a working `load` function. You’ve now covered the basics of test-driving
    a route’s `load` function so that it meets SvelteKit’s requirements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了一个工作的 `load` 函数。你现在已经涵盖了测试驱动路由的 `load` 函数的基础，以确保它符合 SvelteKit 的要求。
- en: Now we can build the `page` component for the route.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建路由的 `page` 组件了。
- en: Test-driving the page component
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动页面组件
- en: 'It’s time to create the `page` component that exists for the route. As ever,
    we’ll start with a test:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建存在于路由中的 `page` 组件了。一如既往，我们将从一个测试开始：
- en: 'Create the `src/routes/birthdays/page.test.js` file and add the following imports.
    The last of these is for the `page` component itself. Because SvelteKit expects
    the component for a route to exist in a file named `+page.svelte`, we may as well
    give the component the name `Page` (that is what it is, after all):'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `src/routes/birthdays/page.test.js` 文件，并添加以下导入。最后一个是为 `page` 组件本身。因为 SvelteKit
    预期路由的组件存在于名为 `+page.svelte` 的文件中，所以我们不妨将组件命名为 `Page`（毕竟它就是这个名字）：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let’s write out the test. The key part here is that `Page` gets passed
    a `data` prop, which needs to match the structure of our `load` function. In the
    actual runtime environment, SvelteKit will invoke the `load` function and then
    render the component in `+page.svelte` with the `data` prop set to the result
    of the `load` function:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们编写测试。关键部分是 `Page` 接收一个 `data` 属性，它需要与我们的 `load` 函数的结构相匹配。在实际运行环境中，SvelteKit
    将调用 `load` 函数，然后使用 `data` 属性设置为 `load` 函数的结果来渲染 `+page.svelte` 中的组件：
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Test data fixtures
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据固定
- en: Even though they have the same values, there’s no connection between the `birthdays`
    value set here and the hardcoded values in the `load` function. The `load` function
    will eventually lose its *seeded* data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们有相同的值，但这里的 `birthdays` 值集合与 `load` 函数中的硬编码值之间没有联系。`load` 函数最终会失去其 *种子* 数据。
- en: 'If you go ahead and run the test now, you should see the usual failure of the
    missing file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，你应该会看到缺少文件的常规失败：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create an empty file at `src/routes/birthdays/+page.svelte`, and then run tests
    again:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/routes/birthdays/+page.svelte` 创建一个空文件，然后再次运行测试：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It’s time for the real implementation. Copy the following code, which uses
    the `data` prop to display an `ol` element with a `li` for each birthday. We use
    the `Birthday` component from [*Chapter 2*](B19611_02.xhtml#_idTextAnchor036),
    *Introducing the Red-Green-Refactor Workflow*, to display the birthday for each
    item in the `data.birthdays` array:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候进行真正的实现了。复制以下代码，它使用 `data` 属性来显示一个带有 `li` 的 `ol` 元素，每个生日都有一个。我们使用来自 [*第 2
    章*](B19611_02.xhtml#_idTextAnchor036) *介绍红-绿-重构工作流程* 的 `Birthday` 组件来显示 `data.birthdays`
    数组中的每个项目的生日：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using HTML lists for testability
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTML 列表进行可测试性
- en: When rendering *arrays* of items as we have here, it’s always a good idea to
    use either an `ol` element (for an ordered list) or a `ul` element (for an unordered
    list) as the parent container, and then use `li` elements for each item in the
    list. Using list elements increases the testability of your components because
    you can use locator functions that look specifically for the `listitem` role,
    which we’ll see in [*Chapter 6*](B19611_06.xhtml#_idTextAnchor079), *Editing*
    *Form Data*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染 *数组* 中的项目时，我们在这里所做的那样，始终使用 `ol` 元素（用于有序列表）或 `ul` 元素（用于无序列表）作为父容器，然后为列表中的每个项目使用
    `li` 元素。使用列表元素可以增加你组件的可测试性，因为你可以使用定位函数来特别寻找 `listitem` 角色，我们将在 [*第 6 章*](B19611_06.xhtml#_idTextAnchor079)
    *编辑表单数据* 中看到。
- en: 'Notice also that we’re using the `Birthday` component to make our tests pass.
    But our test didn’t explicitly request a `Birthday` component; the expectations
    looked like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 `Birthday` 组件来使测试通过。但我们的测试并没有明确请求一个 `Birthday` 组件；期望看起来是这样的：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You could argue that the simplest way to make this test pass would be to simply
    print out the name of the birthday. But that would be ignoring the intent of our
    testing, which is to display a list of `Birthday` components.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为使这个测试通过的最简单方法就是简单地打印出生日的名字。但那样会忽略我们测试的意图，我们的测试意图是显示一个 `Birthday` 组件的列表。
- en: In [*Chapter 12*](B19611_12.xhtml#_idTextAnchor134)*, Using Component Mocks
    to Clarify Tests*, we will look at how we can use component mocks to explicitly
    state that we want to use a `Birthday` component here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 12 章*](B19611_12.xhtml#_idTextAnchor134) *使用组件模拟来明确测试* 中，我们将探讨如何使用组件模拟来明确表示我们在这里想要使用
    `Birthday` 组件。
- en: With the implementation complete, you can now verify your passing tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实现完成后，你现在可以验证你通过测试。
- en: 'Run the Vitest test runner and you should see that the test is now passing:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Vitest 测试运行器，你应该会看到测试现在通过了：
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can now also run Playwright and see your passing test:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你也可以运行 Playwright 来查看你通过测试：
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can add some styles to the `src/routes/birthdays/+page.svelte` file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在 `src/routes/birthdays/+page.svelte` 文件中添加一些样式：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, run the dev server with `npm run dev`. Make a note of the base URL
    for your application and then fire up your browser, and load the `/birthdays`
    URL to check out your work.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `npm run dev` 命令运行开发服务器。记下你应用程序的基本 URL，然后打开浏览器，加载 `/birthdays` URL 来检查你的工作。
- en: Working out the path to load
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 计算加载路径
- en: 'The route we’ve built will end up at a location such as `https://localhost:5173/birthdays`.
    But the port number is likely to be different for you: you’ll need to run the
    `npm run dev` command and look for the base URL that is marked with the `Local`
    label.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的路由最终会指向类似 `https://localhost:5173/birthdays` 的位置。但你的端口号可能不同：你需要运行 `npm
    run dev` 命令并查找带有 `Local` 标签的基本 URL。
- en: This section has shown you how you can test-drive a `page` component in a file
    named `+page.svelte`, which SvelteKit will render for you when you browse to a
    known route.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向你展示了你如何在名为 `+page.svelte` 的文件中测试驱动一个 `page` 组件，SvelteKit 会在你浏览到已知路由时为你渲染该文件。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has shown you how to write an end-to-end test with Playwright and
    use that as a scaffold for your Vitest unit tests. The Playwright tests check
    that all the units are working together, and the framework is doing its job. The
    Vitest tests check that you are satisfying the contract required from SvelteKit,
    such as the `load` function working in the correct fashion.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了如何使用 Playwright 编写端到端测试，并将其用作 Vitest 单元测试的脚手架。Playwright 测试检查所有单元是否协同工作，框架是否正常工作。Vitest
    测试检查你是否满足了 SvelteKit 所要求的合同，例如 `load` 函数是否以正确的方式工作。
- en: You’ve also seen how TDD can be used to delay design decisions that aren’t immediately
    relevant, like how we hardcoded sample data rather than implement any kind of
    persisted database of birthdays.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了如何使用 TDD 来延迟那些不是立即相关的决策，比如我们为什么直接硬编码样本数据而不是实现任何形式的持久化数据库来存储生日。
- en: In the next chapter, we’ll expand on the same ideas by implementing a SvelteKit
    form action, enabling you to add new birthdays to the list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现一个 SvelteKit 表单操作来扩展相同的概念，使您能够向列表中添加新的生日。
