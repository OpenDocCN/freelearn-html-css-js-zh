- en: Chapter 9. Under the Hood
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章：内部机制
- en: 'We have covered the Knockout basics, learned how to extend Knockout''s binding
    system, and seen how to organize applications. Now, it''s time to indulge our
    inner tinkerers. In this chapter, we will look at the internals of Knockout to
    see what makes it tick. By the end of this chapter, you should be familiar with
    how Knockout handles the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了Knockout的基础知识，学习了如何扩展Knockout的绑定系统，并看到了如何组织应用程序。现在，是时候满足我们内心的工匠精神了。在本章中，我们将探讨Knockout的内部机制，看看是什么让它运转。到本章结束时，你应该熟悉Knockout如何处理以下内容：
- en: Dependency tracking
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项跟踪
- en: The prototype chain
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型链
- en: Parsing binding attribute expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析绑定属性表达式
- en: Applying bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用绑定
- en: Templating
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板化
- en: In addition to this, we will also look at the `ko.utils` namespace, which provides
    lots of useful tools for common actions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将探讨`ko.utils`命名空间，它为常见操作提供了许多有用的工具。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that all of the code discussed in this chapter is based on the Knockout
    3.2 release. It is possible, and likely, that parts of this will change in the
    future.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中讨论的所有代码都是基于Knockout 3.2版本发布的。将来这部分内容可能会发生变化，这是可能的，也是很可能的。
- en: Dependency tracking
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项跟踪
- en: 'Binding handlers and computed observables need to re-evaluate when their observable
    dependencies update. This means keeping track of dependencies and subscribing
    to them. Three objects make up the dependency-tracking feature: observables, computed
    observables, and the dependency-detection module.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定处理程序和计算可观察对象需要在它们的可观察依赖项更新时重新评估。这意味着跟踪依赖项并订阅它们。三个对象构成了依赖项跟踪功能：可观察对象、计算可观察对象和依赖项检测模块。
- en: Here's the basic overview. When a computed is evaluated, it asks `ko.dependencyDetection`
    to start tracking things. When observables are accessed, they register themselves
    with `ko.dependencyDetection`. When the computed is done evaluating, it records
    all of the registered dependencies and subscribes to each of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个基本的概述。当一个计算被评估时，它会请求`ko.dependencyDetection`开始跟踪事物。当访问可观察对象时，它们会将自己注册到`ko.dependencyDetection`。当计算完成评估后，它会记录所有已注册的依赖项并订阅每个依赖项。
- en: Okay, now let's look at some code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们看看一些代码。
- en: ko.dependencyDetection
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ko.dependencyDetection
- en: 'The dependency detection module is very small—small enough to reproduce here
    in its entirety, actually:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项检测模块非常小——小到足以在这里完整地复制出来：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is using the revealing module pattern to hide the internal
    variables for `outerFrames`, `currentFrame`, `lastId`, and the `getId` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了揭示模块模式来隐藏`outerFrames`、`currentFrame`、`lastId`和`getId`函数的内部变量。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the revealing module pattern, check out Todd Motto's
    blog at [http://toddmotto.com/mastering-the-module-pattern](http://toddmotto.com/mastering-the-module-pattern).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于揭示模块模式的信息，请查看Todd Motto的博客：[http://toddmotto.com/mastering-the-module-pattern](http://toddmotto.com/mastering-the-module-pattern)。
- en: The idea here is that `begin` is called with either a frame that can be used
    for tracking, or it is called with nothing to disable tracking. When `end` is
    called, the previous frame is popped off and set to the current frame. A **frame**
    is a layer that tracks dependencies; a frame exists inside of another frame, but
    only the current frame will register dependencies when they are accessed. This
    allows dependency tracking to occur recursively, while each layer receives only
    its immediate dependencies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，`begin`要么被调用时带有可用于跟踪的帧，要么不带任何内容来禁用跟踪。当调用`end`时，之前的帧会被弹出并设置为当前帧。**帧**是一个跟踪依赖项的层；帧存在于另一个帧内部，但只有当前帧在访问依赖项时会注册依赖项。这允许依赖项跟踪递归发生，同时每个层只接收其直接依赖项。
- en: 'The `options` object that is passed to `begin` should expose the following
    properties:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`begin`的`options`对象应该公开以下属性：
- en: '`callback`: This is a function that receives a dependency and its ID when a
    dependency registers itself'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`: 这是一个函数，当依赖项注册自身时，它会接收一个依赖项及其ID'
- en: '`computed`: This is the computed observable that performs the dependency tracking
    on the frame'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`computed`: 这是一个在帧上执行依赖项跟踪的计算可观察对象'
- en: '`isInitial`: This is a Boolean that indicates whether this is the first time
    dependency tracking has been requested for the current frame'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isInitial`: 这是一个布尔值，表示这是否是当前帧首次请求依赖项跟踪'
- en: When `registerDependency` is called, the current frame's callback is passed
    to the dependency and its ID. The ID is a sequentially generated number, which
    is assigned to the dependency if it is missing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `registerDependency` 时，当前帧的回调被传递给依赖及其 ID。ID 是按顺序生成的数字，如果依赖项缺失，则分配给依赖项。
- en: The `ignore` function provides an easy wrapper around `begin` and `end` inside
    a `try`/`finally` block. The call to `begin` has no options, so it will not trigger
    dependency detection. This makes it easy to evaluate data in situations where
    you know dependency detection will not, or should not, be used. Knockout does
    this inside several binding handlers as well as inside the `notifySubscribers`
    function of subscribables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignore` 函数提供了一个在 `try`/`finally` 块内对 `begin` 和 `end` 的简单包装。对 `begin` 的调用没有选项，因此不会触发依赖检测。这使得在你知道依赖检测不会或不应使用的情况下评估数据变得容易。Knockout
    在几个绑定处理程序以及可订阅对象的 `notifySubscribers` 函数内部也这样做。'
- en: The last two properties, which are `getDependenciesCount` and `isInitial`, expose
    the properties of the same name on the current frame.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个属性，即 `getDependenciesCount` 和 `isInitial`，暴露了当前帧上同名属性的特性。
- en: Registering dependencies
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册依赖项
- en: When an observable is read, it has to notify `ko.dependencyDetection` in order
    to indicate that a dependency has been accessed. Because computeds and observables
    are both descendants of subscribables, which do not register dependencies, each
    of them has their own similar dependency registration logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取可观察对象时，它必须通知 `ko.dependencyDetection` 以指示已访问依赖项。因为计算值和可观察对象都是可订阅的子类，而可订阅的子类不注册依赖项，因此它们各自都有自己的类似依赖项注册逻辑。
- en: 'The observable implementation happens when the observable is called with no
    arguments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当可观察对象不带参数被调用时，发生可观察对象的实现：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After registering itself as a dependency, it returns its current value. The
    computed version is almost identical:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在将自己注册为依赖项之后，它返回其当前值。计算版本几乎相同：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only difference here is that because computeds can be evaluated asynchronously,
    the `read` function checks whether a re-evaluation is needed before returning
    its value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是，因为计算值可以异步评估，所以 `read` 函数在返回其值之前会检查是否需要重新评估。
- en: There isn't much else to say regarding this. The observable array type makes
    no changes to the registration process. In fact, it couldn't make any changes.
    Dependency registration is an internal logic for observables; it can't be overridden.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点没有太多可说的。可观察数组类型不对注册过程进行任何更改。事实上，它无法进行任何更改。依赖注册是可观察对象的内部逻辑；不能被覆盖。
- en: Subscribing to dependencies
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅依赖项
- en: 'The prototype for all observables is the subscribable. The subscribable prototype
    provides two functions for dependency work: `subscribe` and `notifySubscribers`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可观察对象的原型都是可订阅的。可订阅原型提供了两个用于依赖工作的函数：`subscribe` 和 `notifySubscribers`。
- en: 'The `subscrib`e function creates a subscription on the subscribable. The subscription
    doesn''t do anything on its own, it''s just an object with a `callback` and `dispose`
    property (it has other properties; these are just the relevant ones). The subscription
    is stored in the `_subscriptions` object and the internal-use property. As subscriptions
    can be attached to named events, the subscriptions object has an array for each
    event:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe` 函数在可订阅对象上创建一个订阅。订阅本身不执行任何操作，它只是一个具有 `callback` 和 `dispose` 属性的对象（它还有其他属性；这些只是相关的属性）。订阅存储在
    `_subscriptions` 对象和内部使用属性中。由于订阅可以附加到命名事件，因此订阅对象为每个事件都有一个数组：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When a subscription is created without a name, it is attached to the change
    event by default. The other standard event is the `beforeChange` event, which
    is fired by observables just before they update. This is the write logic from
    the observable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个没有名称的订阅时，它默认附加到更改事件。另一个标准事件是 `beforeChange` 事件，它在可观察对象更新之前触发。这是来自可观察对象的写入逻辑：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before an observable is updated, it calls `valueWillMutate`, and afterwards,
    it calls `valueHasMutated`. Both of these are wrappers around the `notifySubscribers`
    function, with the first providing the `beforeChange` event name:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在可观察对象更新之前，它会调用 `valueWillMutate`，之后，它会调用 `valueHasMutated`。这两个都是 `notifySubscribers`
    函数的包装，第一个提供了 `beforeChange` 事件名称：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, the event name is optional and defaults to `change` when omitted.
    It also checks to make sure subscriptions for the event exist before it starts.
    Then, it disables dependency detection. If it didn't disable dependency detection,
    then a false dependency would be established between the original writer of the
    new value and subscribers of the current observable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，事件名称是可选的，如果省略，则默认为`change`。它还会在开始之前检查是否存在该事件的订阅。然后，它禁用依赖检测。如果没有禁用依赖检测，那么原始新值编写者与当前可观察对象的订阅者之间将建立虚假的依赖关系。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This basic publish/subscribe implementation can easily be used to create a messaging
    system. In fact, Ryan Niemeyer has created a plugin to do just that (see [https://github.com/rniemeyer/knockout-postbox](https://github.com/rniemeyer/knockout-postbox)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本的发布/订阅实现可以很容易地用来创建消息系统。实际上，Ryan Niemeyer已经创建了一个插件来完成这项工作（见[https://github.com/rniemeyer/knockout-postbox](https://github.com/rniemeyer/knockout-postbox)）。
- en: The primary work is to loop through the subscriptions and pass the current value
    to the subscriptions callback. A check is performed to ensure that the subscription
    didn't get disposed, as it is possible that one subscription is disposed because
    of another. Finally, the previous block of code ends the current frame of dependency
    detection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工作是遍历订阅并传递当前值给订阅回调。执行检查以确保订阅没有被销毁，因为一个订阅可能因为另一个订阅而被销毁。最后，前面的代码块结束当前帧的依赖检测。
- en: With these three pieces, Knockout provides a simple and performant dependency
    tracking system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个部分，Knockout提供了一个简单且高效的依赖跟踪系统。
- en: Subscribing to observable arrays
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅可观察数组
- en: Prototypically speaking, observable arrays are still observables, but because
    their changes are primarily their contents and not their values, they have a lot
    of additional logic that ensures performant notifications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从原型上讲，可观察数组仍然是可观察的，但由于它们的更改主要是它们的内容而不是它们的值，它们有很多额外的逻辑来确保高效的通知。
- en: Standard array functions
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准数组函数
- en: 'JavaScript has had a standard set of array functions since ECMAScript''s first
    edition, so you should already be familiar with them. The headache they cause
    for Knockout is that they modify the contents of the array directly. Since array
    subscribers expect to be notified to changes in the array''s content, Knockout
    provides their own implementation for `observableArray`. This implementation makes
    calls to the standard notification functions on observables before calling the
    original array function. The `slice` function is skipped, since it is a read-only
    function and doesn''t needs to notify subscribers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 自从ECMAScript的第一个版本以来，JavaScript就有一套标准的数组函数，所以你应该已经熟悉它们。它们给Knockout带来的头痛是它们直接修改数组的内容。由于数组订阅者期望在数组内容发生变化时被通知，Knockout为`observableArray`提供了自己的实现。此实现在对原始数组函数进行调用之前调用可观察的标准通知函数。`slice`函数被跳过，因为它是一个只读函数，不需要通知订阅者：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function has barely changed since Knockout 1.0, where it added the methods
    to each instance instead of the observable array's `fn` prototype. The only addition
    is the call to `cacheDiffForKnownOperation`, which works with the internal `trackArrayChanges`
    extender to provide smaller, faster change notifications for incremental updates
    to the array. Prior to this extender, observable arrays broadcasted their entire
    contents on every update.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Knockout 1.0以来，此函数几乎没有变化，当时它将方法添加到每个实例而不是可观察数组的`fn`原型。唯一的添加是调用`cacheDiffForKnownOperation`，它与内部`trackArrayChanges`扩展器一起工作，为增量更新数组提供更小、更快的变更通知。在此扩展器之前，可观察数组在每次更新时都会广播其全部内容。
- en: This function is not too different from the `write` function of normal observables;
    it calls `valueWillMutat`e before performing an update, and it calls `valueHasMutated`
    afterward. Instead of setting its own value, it just applies the original method
    name to the underlying array.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与普通可观察对象的`write`函数没有太大区别；它在执行更新之前调用`valueWillMutat`e，并在之后调用`valueHasMutated`。它不是设置自己的值，而是将原始方法名应用于底层数组。
- en: 'The `slice` function is even simpler. It does not cause subscriptions to fire,
    as it is read-only. All it does is wrap the original function on the underlying
    array:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice`函数甚至更简单。它不会触发订阅，因为它只读。它所做的只是包装底层数组的原始函数：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The utility methods
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具方法
- en: 'In addition to the standard methods, Knockout also provides friendly functions
    to common array changes that JavaScript, for some reason, still hasn''t bothered
    to implement: `remove`, `removeAll`, `destroy`, `destroyAll`, and `replace`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准方法之外，Knockout还提供了对JavaScript中一些原因尚未实现的一些常见数组更改的友好函数：`remove`、`removeAll`、`destroy`、`destroyAll`和`replace`。
- en: 'You should be able to guess what these functions look like by now; peek to
    get the underlying array, call `valueWillMutate`, make some changes, and then
    finish with `valueHasMutated`. The interesting part about the preceding functions
    is the arguments they take. If you pass an object to `remove`, it will predictably
    remove that object from the array if it exists. However, if you pass a function,
    it will be used as a predicate, removing any elements in the array, which causes
    the predicate to return truthy (I''m very fond of this pattern):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够猜到这些函数的样子；通过`peek`获取底层数组，调用`valueWillMutate`，进行一些更改，然后通过`valueHasMutated`完成。关于前面函数的有趣之处在于它们接受的参数。如果你传递一个对象给`remove`，如果它存在，它会预期地从这个数组中移除该对象。然而，如果你传递一个函数，它将被用作谓词，移除数组中任何导致谓词返回真值的元素（我非常喜欢这种模式）：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This works by converting single values into a predicate that checks for strict
    equality. The check for `!ko.isObservable(valueOrPredicate)` is important as observables
    are functions but should be treated as values here and not as predicates.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过将单个值转换为检查严格相等性的谓词来实现。检查`!ko.isObservable(valueOrPredicate)`很重要，因为可观察对象是函数，但在这里应该被视为值，而不是谓词。
- en: This same pattern is used for `destroy`, except that it marks the observables
    with the `_destory` property instead of removing them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的模式也用于`destroy`，只不过它使用`_destory`属性标记可观察对象，而不是移除它们。
- en: 'The `removeAll` and `destroyAll` functions are also overloaded: they can take
    an array of values to be removed, or it can remove all elements if no argument
    is provided. In the case where an array of values is provided, they just call
    `remove`/`destroy` with a predicate based on the array:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeAll`和`destroyAll`函数也是重载的：它们可以接受要移除的值的数组，或者在没有提供参数的情况下移除所有元素。在提供值数组的案例中，它们只是调用基于数组的`remove`/`destroy`谓词：'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The prototype chain
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型链
- en: 'Back in [Chapter 1](part0015_split_000.html#page "Chapter 1. Knockout Essentials"),
    *Knockout Essentials*, I showed you this diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第1章](part0015_split_000.html#page "第1章. Knockout基础"), *Knockout基础*，我向你展示了这张图：
- en: '![The prototype chain](img/00016.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![原型链](img/00016.jpeg)'
- en: The way functions are inherited by these objects is not through the normal JavaScript
    prototype chain, where a constructor function has its prototype assigned to an
    object. This is because observables are functions and not objects, and functions
    cannot be created with constructors or the `Object.create` function. Standard
    JavaScript prototypical inheritance doesn't work for functions. To see how Knockout
    shares methods, let's look at how subscribable and its descendant observable are
    constructed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象继承函数的方式不是通过正常的JavaScript原型链，其中构造函数的prototype被分配给一个对象。这是因为可观察对象是函数而不是对象，并且不能使用构造函数或`Object.create`函数来创建函数。标准的JavaScript原型继承对函数不起作用。要了解Knockout如何共享方法，让我们看看可订阅对象及其子对象可观察对象的构建方式。
- en: 'First, the base methods for subscribables are defined on the `fn` object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可订阅对象的基本方法定义在`fn`对象上：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is added to subscribables during the construction:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在构建可订阅对象时添加的：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `setPrototypeOfOrExtend` method will either assign the `__proto__` property
    of an object—something higher IE versions can't do—or use `ko.utils.extend` to
    extend the object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPrototypeOfOrExtend`方法将分配对象的`__proto__`属性——这是更高版本的IE版本无法做到的——或者使用`ko.utils.extend`来扩展对象。'
- en: 'Observables are built differently. Their *factory* method returns an internally
    built object, which uses both `ko.subscribable.call` and `setPrototypeOfOrExtend`
    to inherit methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象是以不同的方式构建的。它们的*工厂*方法返回一个内部构建的对象，该对象使用`ko.subscribable.call`和`setPrototypeOfOrExtend`来继承方法：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An observable is built and then run through the subscribable's constructor,
    extended with the `observable[''fn'']` object, and finally has its own methods
    added.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象被构建并运行通过可订阅对象的构造函数，扩展了`observable[''fn'']`对象，并最终添加了自己的方法。
- en: The ko.isObservable function
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ko.isObservable函数
- en: In standard JavaScript inheritance, the `instanceof` operator can be used to
    check whether an object, or any of its prototypes, has a constructor that matches
    the supplied function. Because Knockout isn't using standard inheritance, it cannot
    use the `instanceof` operator; instead Knockout uses the following code for the
    `ko.isObservable` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的 JavaScript 继承中，`instanceof` 操作符可以用来检查一个对象或其任何原型是否有与提供的函数匹配的构造函数。因为 Knockout
    不使用标准继承，所以它不能使用 `instanceof` 操作符；相反，Knockout 使用以下代码来实现 `ko.isObservable` 函数。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Knockout defines a `__ko_proto__` property on the `observable[''fn'']` object,
    which is set to the `ko.observable` object. This custom prototype property is
    used by `hasPrototype` in place of the `instanceof` operator to determine whether
    an instanced object is an observable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 在 `observable[''fn'']` 对象上定义了一个 `__ko_proto__` 属性，并将其设置为 `ko.observable`
    对象。这个自定义原型属性被 `hasPrototype` 用于代替 `instanceof` 操作符，以确定实例化对象是否是可观察的。
- en: The binding expression parser
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定表达式解析器
- en: 'The expressions written in data-bind attributes are not truly JavaScript or
    JSON, though they look very similar. Knockout has its own parser to convert these
    attributes into JavaScript. Say you write a data-bind attribute like this one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据绑定属性中编写的表达式实际上不是真正的 JavaScript 或 JSON，尽管它们看起来非常相似。Knockout 有自己的解析器将这些属性转换为
    JavaScript。比如说你写了一个这样的数据绑定属性：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, the binding provider''s job is to return an object like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，绑定提供者的任务是返回一个像这样的对象：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The default binding provider does this using the `ko.expressionRewriting` module,
    which is responsible for calling binding preprocessors and returning a JSON-esque
    string. Internally, this is done using regex to parse the full attribute into
    a key/value pair array. This might sound messy, but it gets the job done. That
    being said, even for an *under the hood* look, the details are not very relevant
    to Knockout, as the parsing is general purpose. If you are still curious, the
    code is located at [https://github.com/knockout/knockout/blob/master/src/binding/expressionRewriting.js](https://github.com/knockout/knockout/blob/master/src/binding/expressionRewriting.js),
    and its inline comments are better than average.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 默认绑定提供者使用 `ko.expressionRewriting` 模块来完成这项工作，该模块负责调用绑定预处理程序并返回一个类似 JSON 的字符串。在内部，这是通过正则表达式将完整属性解析为一个键/值对数组来完成的。这听起来可能有些混乱，但它完成了工作。话虽如此，即使是对于“内部”的查看，这些细节对
    Knockout 来说并不非常相关，因为解析是通用的。如果你仍然好奇，代码位于 [https://github.com/knockout/knockout/blob/master/src/binding/expressionRewriting.js](https://github.com/knockout/knockout/blob/master/src/binding/expressionRewriting.js)，其内联注释优于平均水平。
- en: 'After parsing the data-bind attribute, the array of key/value pairs is iterated
    to build an array of JSON-esque strings:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 解析数据绑定属性后，键/值对数组被迭代以构建一个类似 JSON 的字符串数组：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The key is used to look up the binding handler to call its `preprocess` function.
    If it returns falsy, the processing stops, as the binding was removed. The `makeValueAccessors`
    property will be true when it comes from `getBindingAccessors` and false when
    it comes from `getBindings`. The result is then added to a running list.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 键用于查找绑定处理程序以调用其 `preprocess` 函数。如果它返回假值，则处理停止，因为绑定已被移除。当它来自 `getBindingAccessors`
    时，`makeValueAccessors` 属性将为真，当它来自 `getBindings` 时为假。然后，结果被添加到一个运行列表中。
- en: 'The `twoWayBindings` block adds a special function string to `propertyAccessorResultStrings`,
    which is checked after all the other bindings keys are finished:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`twoWayBindings` 块向 `propertyAccessorResultStrings` 添加了一个特殊的功能字符串，在完成所有其他绑定键之后进行检查：'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This adds one extra binding property, `_ko_property_writers`, which is a function
    that will return a binding object that can be used to write to bound properties
    instead of reading from them. We will come back to this in just a minute.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了一个额外的绑定属性 `_ko_property_writers`，它是一个函数，可以用来写入而不是读取绑定属性。我们将在下一分钟回到这个问题。
- en: 'Finally, the running list of strings is returned with a join:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过连接返回运行列表中的字符串：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The resulting string from the example binding will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例绑定产生的字符串将看起来像这样：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The binding provider turns this string into a real object by putting the string
    inside a function body and calling the function with the binding context and the
    element being bound:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定提供者通过将字符串放在函数体中并使用绑定上下文和被绑定的元素调用该函数，将这个字符串转换成一个真正的对象：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This use of `new Function` causes Knockout's default binding provider to fail
    in environments using a **Content Security Policy** (**CSP**) that blocks `new
    Function` and `eval`, such as in Google Chrome Extensions. Knockout Secure Binding,
    which is a binding provider that does not use `new Function`, allows Knockout
    to be used with a CSP (see [https://github.com/brianmhunt/knockout-secure-binding](https://github.com/brianmhunt/knockout-secure-binding)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用 `new Function` 的方法会导致在阻止 `new Function` 和 `eval` 的环境中（如 Google Chrome 扩展程序中）使用
    Knockout 的默认绑定提供者失败。Knockout Secure Binding 是一个不使用 `new Function` 的绑定提供者，它允许 Knockout
    与 CSP（见 [https://github.com/brianmhunt/knockout-secure-binding](https://github.com/brianmhunt/knockout-secure-binding)）一起使用。
- en: 'When this function is evaluated with the binding context and element, it produces
    the final binding object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个函数在绑定上下文和元素上评估时，它会产生最终的绑定对象：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Knockout property writers
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knockout 属性写入器
- en: We haven't covered the _`ko_property_writers` property yet, because it's surprising
    to most people and would have been distracting. The role of this property is to
    expose writing functions for nonobservable values so that two-way binding handlers
    can still update their values. They aren't observable, so notifications won't
    occur, but it's still a supported scenario.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍 `_`ko_property_writers` 属性，因为它对大多数人来说都很令人惊讶，并且可能会分散注意力。这个属性的作用是暴露非可观察值的写入函数，以便双向绑定处理程序仍然可以更新它们的值。它们不是可观察的，因此不会发生通知，但这仍然是一个受支持的场景。
- en: 'This special binding is carried on the binding accessor. When two-way bindings,
    such as `value`, need to update the viewmodel they, call `ko.expressionRewriting.writeValueToProperty`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特殊的绑定是在绑定访问器上进行的。当需要更新 viewmodel 的双向绑定，例如 `value`，它们会调用 `ko.expressionRewriting.writeValueToProperty`：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is an undocumented part of the API, so it is subject to changing without
    notice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是 API 的非文档部分，因此可能会在没有通知的情况下更改。
- en: If the property is not observable and a property writer exists for it, then
    it is used to update the value. If the property is observable, the property is
    written directly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性不是可观察的并且存在一个属性写入器，则使用它来更新值。如果属性是可观察的，则直接写入属性。
- en: Applying bindings
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用绑定
- en: 'The binding application process takes place primarily in the `bindingAttributeSyntax`
    module, which defines the `ko.bindingContext` class as well as the `ko.applyBindings`
    method. The high-level overview looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定应用过程主要发生在 `bindingAttributeSyntax` 模块中，该模块定义了 `ko.bindingContext` 类以及 `ko.applyBindings`
    方法。高级概述如下：
- en: The `ko.applyBindings` method is called with the viewmodel.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 viewmodel 调用 `ko.applyBindings` 方法。
- en: A binding context is constructed using the viewmodel.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 viewmodel 构造绑定上下文。
- en: The binding provider is retrieved from `ko.bindingProvider.instance`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ko.bindingProvider.instance` 获取绑定提供者。
- en: 'Knockout works with the DOM tree:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Knockout 与 DOM 树协同工作：
- en: It is passed through the binding provider's node preprocessor (except the root
    node)
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过绑定提供者的节点预处理器传递（除了根节点）
- en: The binding handlers for the node are constructed using the binding provider
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绑定提供者构建节点的绑定处理程序
- en: The binding handlers are sorted by ensuring that any bindings in their `after`
    property are loaded first
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过确保它们的 `after` 属性中的任何绑定首先加载来对绑定处理程序进行排序
- en: The binding handlers are iterated through, calling each handler's `init` and
    `update` function.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历绑定处理程序，调用每个处理程序的 `init` 和 `update` 函数。
- en: The first three steps are pretty straightforward; even the walking algorithm
    is just a simple recursion that applies bindings to a node and then iterates over
    its children to preprocess and bind them. The real meat of this process is the
    `applyBindingsToNodeInternal` function, which actually does the work of applying
    bindings to a node.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个步骤相当直接；即使是遍历算法也只是一个简单的递归，它将绑定应用于一个节点，然后遍历其子节点以预处理和绑定它们。这个过程的真正核心是 `applyBindingsToNodeInternal`
    函数，它实际上执行将绑定应用于节点的操作。
- en: The first half of the function is safety checks. We are going to skip the code
    for this, as it's not very important to understanding how the binding part works.
    As we have already covered how the binding provider generates bindings, we are
    only going to look at the last two bullet points.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的前半部分是安全检查。我们将跳过这部分代码，因为它对于理解绑定部分的工作方式并不非常重要。因为我们已经介绍了绑定提供者如何生成绑定，所以我们只将查看最后两个要点。
- en: Sorting binding handlers
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序绑定处理程序
- en: Knockout uses a topological sort to order the binding handlers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 使用拓扑排序来对绑定处理程序进行排序。
- en: If you are unfamiliar with topological sorting, remember that it comes from
    graph theory. We will not go into the details of graph theory here (if you are
    interested, Google can tell you all about it), but a topological sort is basically
    an ordering of elements, which ensures that all dependencies of an element come
    before the element itself. Topological sorts do not guarantee the same order every
    time; it's just that no dependency cycles exist.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对拓扑排序不熟悉，请记住它来自图论。我们不会在这里详细介绍图论（如果你感兴趣，谷歌可以告诉你所有关于它的事情），但拓扑排序基本上是元素的排序，确保一个元素的依赖项都在该元素本身之前。拓扑排序不保证每次都保证相同的顺序；只是不存在依赖循环。
- en: 'This is the sort function that Knockout uses to order binding handlers; it
    is a fairly common implementation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Knockout用来排序绑定处理程序的排序函数；它是一个相当常见的实现：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function loops through the supplied bindings, skipping bindings it has
    already processed; if it has an `after` property, it starts the dependency check.
    It pushes the current binding into the array-tracking dependencies, and then loops
    through each of the bindings in the `after` property. If a dependent binding is
    already found to be in the array of dependencies Knockout throws an exception,
    it would mean a cycling dependency. If the dependent binding is not found, it
    recurses into the loop handler so that its dependencies are checked.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会遍历提供的绑定，跳过它已经处理过的绑定；如果它有一个`after`属性，它将开始依赖检查。它将当前绑定推入跟踪依赖的数组中，然后遍历`after`属性中的每个绑定。如果已经发现依赖绑定在依赖数组中，Knockout会抛出一个异常，这意味着存在循环依赖。如果依赖绑定未找到，它将递归到循环处理程序中，以便检查其依赖项。
- en: After the dependent bindings are checked, the last element in the array of dependencies
    is removed and the current binding is pushed to the array of results and the array
    of already processed bindings. If a future binding requires it as a dependency,
    the loop handler will return immediately, indicating that the future binding is
    safe to continue.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查完依赖绑定后，将依赖数组中的最后一个元素移除，并将当前绑定推入结果数组和已处理绑定数组。如果未来的绑定需要它作为依赖项，循环处理程序将立即返回，表示未来的绑定可以安全继续。
- en: Running the binding handlers
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行绑定处理程序
- en: 'After getting the binding handlers in the proper order, they are iterated through.
    One last safety check is made in order to ensure that if the node is a comment
    node, the binding handler is allowed for virtual elements. Then the `init` and
    `update` functions are called inside a `try`/`catch` block:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取正确的绑定处理程序顺序后，它们将被迭代。进行最后一次安全检查以确保如果节点是注释节点，则允许虚拟元素使用绑定处理程序。然后在`try`/`catch`块中调用`init`和`update`函数：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The whole thing is run in a scope with dependency detection disabled, as the
    `init` function does not run twice. The `init` handler passes all the required
    arguments, and the result is checked to see whether this handler wants to control
    descendant bindings. If it isn''t the first handler to control descendant bindings,
    then Knockout throws an exception:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程在一个禁用依赖检测的作用域中运行，因为`init`函数不会运行两次。`init`处理程序传递所有必需的参数，并检查结果以查看此处理程序是否想要控制子代绑定。如果不是第一个控制子代绑定的处理程序，Knockout会抛出一个异常：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `update` handler is run inside of a computed observable (`dependantObservable`
    was the original name for computeds and is still used in the source code), which
    will automatically rerun it when dependencies change. This is one of my favorite
    parts of Knockout: binding handlers rerun automatically when observable dependencies
    change because *they are inside observables themselves*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`处理程序在计算可观察值（`dependantObservable`是计算值的原始名称，仍在源代码中使用）内部运行，当依赖项发生变化时，它会自动重新运行。这是Knockout我最喜欢的部分之一：绑定处理程序在可观察依赖项变化时自动重新运行，因为*它们本身就在可观察值内部*。'
- en: 'Once the binding handlers have all been looped through, `applyBindingsToNodeInternal`
    returns with an object that tells its caller whether or not to recurse into the
    current node''s children using the flag from the `init` handler''s result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有绑定处理程序都已遍历，`applyBindingsToNodeInternal`函数返回一个对象，告诉其调用者是否需要使用`init`处理程序的结果中的标志递归到当前节点的子节点：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Templates
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Knockout''s template system is incredibly flexible: it works with *anonymous*
    templates, named templates, and allows the engine that renders templates to be
    overridden. The template binding is also used by the `foreach` binding, which
    is just a syntactic sugar for the `{ foreach: someExpression }` template. To understand
    how the template system works, let''s start with the template-binding handler.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'Knockout的模板系统非常灵活：它支持*匿名*模板、命名模板，并允许覆盖渲染模板的引擎。模板绑定还用于`foreach`绑定，它只是`{ foreach:
    someExpression }`模板的语法糖。要了解模板系统是如何工作的，让我们从模板绑定处理程序开始。'
- en: The template binding handler
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板绑定处理程序
- en: 'The `init` function of the template binding understands that templates can
    either be named (loaded from a source) or inline (loaded using the contents of
    the bound element):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 模板绑定的`init`函数理解模板可以是命名的（从源加载）或内联（使用绑定元素的內容加载）：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the binding value is just a string, or if the binding value is an object
    with a `name` property, then we are using a named source and the only work that
    needs to be done is to empty the node. Named sources need to be changed when the
    name of the template changes, so all of the work of actually rendering the template
    is in the `update` method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果绑定值只是一个字符串，或者绑定值是一个具有`name`属性的对象，那么我们正在使用一个命名源，并且需要完成的工作仅仅是清空节点。命名源需要在模板名称更改时进行更改，因此实际渲染模板的所有工作都在`update`方法中。
- en: If it's an anonymous template, `moveCleanedNodesToContainerElement` removes
    the children from the element and places them in a `div` container, but the `div`
    container isn't placed in the DOM. A new anonymous template source is created
    with the element, and the `div` container is passed to the template's `nodes`
    function. The `nodes` function stores the container with `utils.domData`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是一个匿名模板，`moveCleanedNodesToContainerElement`将移除元素的孩子并将它们放置在一个`div`容器中，但`div`容器不会被放置在DOM中。使用该元素创建一个新的匿名模板源，并将`div`容器传递给模板的`nodes`函数。`nodes`函数使用`utils.domData`存储容器。
- en: 'A **template source** is an object that is used by the template engine to provide
    the DOM that is required to render the template. It must provide either a `nodes`
    function that returns a container with the nodes to be used, or a text function
    that provides a stringified version of the same. The `ko.templateSources` array
    contains two template source types: `domElement` for named sources and `anonymousTemplate`
    for inline sources.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板源**是一个由模板引擎使用的对象，用于提供渲染模板所需的DOM。它必须提供一个返回包含要使用节点的容器的`nodes`函数，或者提供一个提供相同内容的字符串化的`text`函数。`ko.templateSources`数组包含两种模板源类型：`domElement`用于命名源，`anonymousTemplate`用于内联源。'
- en: 'Finally, the `init` function returns `{ ''controlsDescendantBindings'': true
    }`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，`init`函数返回`{ ''controlsDescendantBindings'': true }`。'
- en: 'The `update` function has three different branches: branches that render a
    single template, branches that render an array of templates with `foreach`, and
    branches that remove everything if an `if` (or `ifnot`) binding is present and
    false. The last branch doesn''t need much explanation, and the first two branches
    are very functionally similar: they call `renderTemplate` on the template engine,
    which returns an array of DOM nodes that are then added to the DOM. After this,
    they each call `applyBindings` on the template.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数有三个不同的分支：渲染单个模板的分支、使用`foreach`渲染模板数组的分支，以及如果存在`if`（或`ifnot`）绑定且为假时删除所有内容的分支。最后一个分支不需要太多解释，而前两个分支在功能上非常相似：它们在模板引擎上调用`renderTemplate`，该引擎返回一个DOM节点数组，然后这些节点被添加到DOM中。之后，它们各自在模板上调用`applyBindings`。'
- en: The template engine
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板引擎
- en: The template engine is responsible for generating DOM nodes. It can't be used
    on its own though, as it's just a base class. When `renderTemplate` is called
    on the base template engine, it calls `makeTemplateSource` and passes the result
    to `renderTemplateSource`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎负责生成DOM节点。然而，它不能单独使用，因为它只是一个基类。当在基模板引擎上调用`renderTemplate`时，它调用`makeTemplateSource`并将结果传递给`renderTemplateSource`。
- en: The default `makeTemplateSource` method takes a template parameter. If a template
    is a string, it will try to find a script by that name and create a `domElement`
    source. If the template is a node, it will create and return a new `anonymousTemplate`
    source from it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`makeTemplateSource`方法接受一个模板参数。如果模板是一个字符串，它将尝试通过该名称查找脚本并创建一个`domElement`源。如果模板是一个节点，它将从中创建并返回一个新的`anonymousTemplate`源。
- en: The default `renderTemplateSource` method is not implemented and will throw
    an error. A template implementation must override this method in order to work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`renderTemplateSource`方法未实现，将抛出错误。模板实现必须覆盖此方法才能工作。
- en: 'Knockout provides two template engine implementations out of the box: native
    and jQuery.tmpl. The jQuery.tmpl engine hasn''t been under development since 2011,
    and I think Knockout''s continued inclusion with the standard distribution is
    probably more backwards-compatibility than anyone really needs. It''s there, but
    we are going to ignore it.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout提供了两个模板引擎实现：原生和jQuery.tmpl。jQuery.tmpl引擎自2011年以来就没有再进行开发了，我认为Knockout继续包含在标准分发中可能更多的是向后兼容性，而不是任何人真正需要的。它在那里，但我们将会忽略它。
- en: 'The native template engine overrides `renderTemplateSource` with this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 原生模板引擎使用此方法覆盖`renderTemplateSource`：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If `nodes` is present, it will be used to get the template node container, clone
    it, and return it. If it's in an higher IE, where clone doesn't work, or if `nodes`
    isn't provided, the text source will be parsed by `ko.utils` and will be returned.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`nodes`，它将被用来获取模板节点容器，克隆它，并返回它。如果它在更高的IE版本中，克隆不起作用，或者如果没有提供`nodes`，文本源将由`ko.utils`解析，并返回。
- en: The template engine does not add the nodes to the DOM and does not bind them;
    it just returns them. The template binding takes care of this part after it gets
    the generated template from the template engine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎不会将节点添加到DOM中，也不会绑定它们；它只是返回它们。模板绑定在从模板引擎获取生成的模板后负责这部分。
- en: The ko.utils reference
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ko.utils`参考'
- en: The `ko.utils` namespace is Knockout's bucket for utility functions. Not all
    of these functions are publicly exposed—at least not in a usable way. Knockout's
    minification process obfuscates more than half of them. As the unobfuscated methods
    are a public API that Knockout has committed to providing, changing them would
    be a major change. Despite considering all of the exposed methods on the `ko.utils`
    part of the API, Knockout does not provide any documentation for them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ko.utils`命名空间是Knockout的实用函数桶。并非所有这些函数都是公开暴露的——至少不是以可用的方式。Knockout的压缩过程使其中超过一半的函数变得模糊。由于未模糊的方法是Knockout承诺提供的公共API，因此更改它们将是一个重大的变更。尽管考虑了API的`ko.utils`部分的公开方法，但Knockout并没有为它们提供任何文档。'
- en: 'Here is a complete list of the public functions on `ko.utils` as of Knockout
    3.2:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Knockout 3.2版本中`ko.utils`的公共函数完整列表：
- en: '`addOrRemoveItem(array, item, included)`: If `included` is `true`, it will
    add the item to the array if it is not already there; if `included` is `false`,
    it will remove the item from the array if it is present.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addOrRemoveItem(array, item, included)`: 如果`included`为`true`，它将如果项目不在数组中则将其添加到数组中；如果`included`为`false`，它将如果项目存在则从数组中移除它。'
- en: '`arrayFilter(array, predicate)`: This returns an array of elements from the
    array that returns `true` from the predicate using `predicate(element, index)`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayFilter(array, predicate)`: 这返回一个数组，其中包含从数组中返回谓词`true`的元素，使用`predicate(element,
    index)`。'
- en: '`arrayFirst(array, predicate, predicateOwner)`: This returns the first element
    in the array that returns `true` from the predicate using `predicate.call(predicateOwner,
    element, index)`. This makes `predicateOwner` an optional parameter, which controls
    this in the predicate.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayFirst(array, predicate, predicateOwner)`: 这返回数组中第一个使谓词返回`true`的元素，使用`predicate.call(predicateOwner,
    element, index)`。这使得`predicateOwner`成为一个可选参数，它控制谓词中的这部分。'
- en: '`arrayForEach(array, action)`: This calls the action on each element in the
    array with `action(element, index)`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayForEach(array, action)`: 这将在数组的每个元素上调用操作，使用`action(element, index)`。'
- en: '`arrayGetDistinctValues(array)`: This returns an array with only distinct elements
    from the original array. It uses `ko.utils.arrayIndexOf` to determine the uniqueness.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayGetDistinctValues(array)`: 这返回一个只包含原始数组中唯一元素的新数组。它使用`ko.utils.arrayIndexOf`来确定唯一性。'
- en: '`arrayIndexOf(array, item)`: If `Array.prototype.indexOf` is present, `arrayIndexOf(array,
    item)` will call it, otherwise it will loop the array manually and return the
    index or `-1` if the element isn''t found. This is a polyfill for versions of
    Internet Explorer less than 9.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayIndexOf(array, item)`: 如果存在`Array.prototype.indexOf`，`arrayIndexOf(array,
    item)`将调用它，否则它将手动遍历数组并返回索引或如果找不到元素则返回`-1`。这是针对小于9版本的Internet Explorer的polyfill。'
- en: '`arrayMap(array, mapping)`: This is not quite a polyfill for `Array.prototype.map`;
    this function returns an array by calling `mapping(element, index)` on each element
    of the original array.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayMap(array, mapping)`: 这并不是`Array.prototype.map`的polyfill；这个函数通过在原始数组的每个元素上调用`mapping(element,
    index)`来返回一个新数组。'
- en: '`arrayPushAll(array, valuesToPush)`: This pushes the `valuesToPush` parameter
    into the `array` parameter. This function handles cases where `valuesToPush` is
    like an array but is not a real array, such as `HTMLCollection`, where calling
    `array.push.apply(array, valuesToPush`) would normally fail.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayPushAll(array, valuesToPush)`: 这个函数将 `valuesToPush` 参数推入 `array` 参数。此函数处理
    `valuesToPush` 类似于数组但实际上不是数组的情况，例如 `HTMLCollection`，在正常情况下调用 `array.push.apply(array,
    valuesToPush)` 会失败。'
- en: '`arrayRemoveItem(array, itemToRemove)`: This removes the item from the array
    by either splicing or shifting, depending on the item''s index.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayRemoveItem(array, itemToRemove)`: 这个函数通过剪切或移动，根据项目索引从数组中移除项目。'
- en: '`domData`: This object provides a `get`, `set`, and `clear` method in order
    to work with arbitrary key/value pairs on DOM nodes. Knockout uses it internally
    to track the binding information, but it can be used to store anything.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domData`: 此对象提供 `get`、`set` 和 `clear` 方法，以便在 DOM 节点上处理任意键/值对。Knockout 内部使用它来跟踪绑定信息，但也可以用来存储任何内容。'
- en: '`domNodeDisposal`: This object provides the following utilities that are related
    to DOM''s cleanup tasks:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domNodeDisposal`: 此对象提供与 DOM 清理任务相关的以下实用工具：'
- en: '`addDisposeCallback(node, callback)`: This adds a callback to the node with
    `domData`. The callback will be used if Knockout removes the node via templating
    or control flow.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addDisposeCallback(node, callback)`: 这个函数向具有 `domData` 的节点添加回调。如果 Knockout
    通过模板或控制流删除节点，将使用此回调。'
- en: '`cleanNode(node)`: This runs all the associated disposal callbacks that were
    registered with `addDisposeCallback`. This function is aliased as `ko.cleanNode`.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cleanNode(node)`: 这个函数运行所有与 `addDisposeCallback` 注册的关联的销毁回调。此函数别名为 `ko.cleanNode`。'
- en: '`cleanExternalData(node)`: This uses jQuery''s `cleanData` function to remove
    data added by jQuery plugins. It does nothing if jQuery is not found.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cleanExternalData(node)`: 这个函数使用 jQuery 的 `cleanData` 函数来移除 jQuery 插件添加的数据。如果未找到
    jQuery，则不执行任何操作。'
- en: '`removeDisposeCallback(node, callback)`: This removes the callback from the
    node''s `domData` function.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeDisposeCallback(node, callback)`: 这个函数从节点的 `domData` 函数中移除回调。'
- en: '`removeNode(node)`: This cleans the node with `cleanNode` and then removes
    it from the DOM. This function is aliased as `ko.removeNode`.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeNode(node)`: 这个函数使用 `cleanNode` 清理节点，然后将其从 DOM 中删除。此函数别名为 `ko.removeNode`。'
- en: '`Extend(target, source)`: This is a run-of-the-mill extend method; it adds
    or overwrites all properties on the target with those on the source. It filters
    source properties with `hasOwnProperty`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Extend(target, source)`: 这是一个普通的扩展方法；它将源上的所有属性添加或覆盖到目标上。它使用 `hasOwnProperty`
    过滤源属性。'
- en: '`fieldsIncludedWithJsonPost`: This is an array of default fields that are used
    for `postJson` if an `includeFields` option is not specified.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fieldsIncludedWithJsonPost`: 这是一个默认字段数组，用于 `postJson`，如果没有指定 `includeFields`
    选项。'
- en: '`getFormFields(form, fieldName)`: This returns all the `input` or `textarea`
    fields from a form that matches `fieldname`, which can be either a string, a regex,
    or an object with a test predicate that takes the field''s name.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFormFields(form, fieldName)`: 这个函数返回所有与 `fieldname` 匹配的 `input` 或 `textarea`
    字段，其中 `fieldname` 可以是一个字符串、一个正则表达式，或者一个包含测试谓词的对象，该谓词接受字段名称。'
- en: '`objectForEach(obj, action)`: This calls `action(properyName, propetyValue)`
    on each property in `obj`, filtering it with `hasOwnProperty`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectForEach(obj, action)`: 这个函数对 `obj` 中的每个属性调用 `action(properyName, propetyValue)`，使用
    `hasOwnProperty` 过滤。'
- en: '`parseHtmlFragment(html)`: If jQuery is present, this function uses its `parseHTML`
    function; otherwise, it uses a simple internal HTML parse. It returns DOM nodes.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseHtmlFragment(html)`: 如果存在 jQuery，此函数使用其 `parseHTML` 函数；否则，它使用简单的内部 HTML
    解析。它返回 DOM 节点。'
- en: '`parseJson(jsonString)`: This will return a JavaScript object by parsing the
    supplied string. If the JSON object exists, it will be used; otherwise, `new Function`
    will be used.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseJson(jsonString)`: 通过解析提供的字符串，这将返回一个 JavaScript 对象。如果 JSON 对象存在，它将被使用；否则，将使用
    `new Function`。'
- en: '`peekObservable(value)`: Just like `ko.unwrap`, this is a safety method. If
    the value is observable, it will return the result of its peek; otherwise, it
    will just return the value.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peekObservable(value)`: 就像 `ko.unwrap` 一样，这是一个安全方法。如果值是可观察的，它将返回其 peek 的结果；否则，它将只返回值。'
- en: '`postJson(urlOrForm, data, options)`: This will perform a post by creating
    a new form, appending it to the DOM, and calling `submit` on it. The form will
    use `data` to create its fields. If `urlOrForm` is a form, its fields will be
    included in the data if they match `options[''''includeFields'''']` (or `fieldsIncludedWithJsonPost`
    if `options[''''includeFields'''']` isn''t present), and its action will be used
    as the URL.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postJson(urlOrForm, data, options)`: 这将通过创建一个新的表单，将其附加到 DOM 上，并在其上调用 `submit`
    来执行一个 POST 操作。表单将使用 `data` 来创建其字段。如果 `urlOrForm` 是一个表单，并且其字段与 `options[''includeFields'']`（或如果
    `options[''includeFields'']` 不存在，则为 `fieldsIncludedWithJsonPost`）匹配，则其字段将包含在数据中，并且其
    action 将用作 URL。'
- en: '`Range(min, max)`: This returns an array of values between `min` and `max`.
    It uses `ko.unwrap` on both the arguments.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range(min, max)`: 这返回一个介于 `min` 和 `max` 之间的值数组。它对两个参数都使用 `ko.unwrap`。'
- en: '`registerEventHandler(element, eventType, handler)`: This attaches an event
    handler to the element. It uses jQuery if possible, `addEventListener` if available
    or `attachEvent` as a last resort (Internet Explorer). If using `attachEvent`,
    it registers a disposal handler to call `detachEvent`, as IE does not do so automatically.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerEventHandler(element, eventType, handler)`: 这将事件处理器附加到元素上。如果可能，它使用
    jQuery，如果可用，则使用 `addEventListener`，或者作为最后的手段使用 `attachEvent`（Internet Explorer）。如果使用
    `attachEvent`，它将注册一个清理处理器来调用 `detachEvent`，因为 IE 不会自动这样做。'
- en: '`setHtml(node, html)`: This empties the node''s contents, unwraps the HTML,
    and sets the node''s HTML using either `jQuery.html`, if available, or `parseHtmlFragement`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setHtml(node, html)`: 这会清空节点的内容，解包 HTML，并使用 `jQuery.html`（如果可用）或 `parseHtmlFragement`
    来设置节点的 HTML。'
- en: '`stringifyJson(data, replacer, space)`: This uses `ko.unwrap` to handle observable
    data and calls `JSON.stringify`. The `replacer` and `space` parameters are optional.
    If the JSON object is not present, it throws an exception.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringifyJson(data, replacer, space)`: 这使用 `ko.unwrap` 来处理可观察数据，并调用 `JSON.stringify`。`replacer`
    和 `space` 参数是可选的。如果 JSON 对象不存在，它将抛出异常。'
- en: '`toggleDomNodeCssClass(node, classNames, shouldHaveClass)`: This uses the `shouldHaveClass`
    Boolean to either add or remove all of `classNames` Boolean from the node.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toggleDomNodeCssClass(node, classNames, shouldHaveClass)`: 这使用 `shouldHaveClass`
    布尔值来决定是否添加或移除节点上所有 `classNames` 布尔值。'
- en: '`triggerEvent(element, eventType)`: This triggers the event on the element.
    It uses jQuery when applicable and handles known issues with raising the click
    event in IE and in jQuery.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`triggerEvent(element, eventType)`: 这在元素上触发事件。当适用时，它使用 jQuery，并处理在 IE 和 jQuery
    中引发点击事件的已知问题。'
- en: '`unwrapObservable(value)`: This was the original name of `ko.unwrap` and is
    maintained for backward compatibility. It will either return the underlying value
    of an observable or the value itself if it''s not an observable.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unwrapObservable(value)`: 这是 `ko.unwrap` 的原始名称，为了向后兼容而保留。它将返回可观察值的底层值，或者如果不是可观察值，则返回其本身。'
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While this certainly isn't an exhaustive look at the guts of Knockout, which
    you probably wouldn't want anyway, you should at least have a good understanding
    of how Knockout gets most of the important things done. This chapter covered dependency
    tracking, the *prototype* (`fn`) chain, the binding expression parser, how `ko.applyBindings`
    works, how Knockout handles templates, and the `ko.utils` namespace. Hopefully,
    you will feel comfortable with how each of these systems work internally. Knowing
    how these pieces fit together should help you in troubleshooting those really
    tricky bugs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这当然不是对 Knockout 内部结构的详尽分析，你可能根本不希望这样做，但你至少应该对 Knockout 如何完成大多数重要任务有一个很好的理解。本章涵盖了依赖跟踪、*原型*（`fn`）链、绑定表达式解析器、`ko.applyBindings`
    的工作方式、Knockout 如何处理模板以及 `ko.utils` 命名空间。希望你会对每个系统如何内部工作感到舒适。了解这些组件如何组合在一起应该有助于你在调试那些真正棘手的错误时。
