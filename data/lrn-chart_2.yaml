- en: Technology Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术基础
- en: This book assumes that you have a working knowledge of HTML, CSS, and JavaScript,
    which are essential tools for creating visualizations with Chart.js. All examples
    in the book are written with JavaScript ES2015 or ES6\. One of the goals of this
    chapter is to review the fundamental topics of these technologies. This includes
    JavaScript topics related to string, object, and array manipulation, the HTML
    document object model (DOM), basic JQuery, CSS selectors, and HTML canvas. You
    can, of course, skip these sections if you already feel comfortable with these
    technologies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你已经掌握了HTML、CSS和JavaScript的基本知识，这些是使用Chart.js创建可视化的必备工具。本书中的所有示例都是用JavaScript
    ES2015或ES6编写的。本章的一个目标是对这些技术的核心主题进行回顾。这包括与字符串、对象和数组操作相关的JavaScript主题，HTML文档对象模型（DOM），基本的JQuery，CSS选择器，以及HTML画布。当然，如果你已经对这些技术感到熟悉，你可以跳过这些部分。
- en: This chapter also describes popular data formats used in visualizations, such
    as CSV, XML, and JSON, and how to load, parse, and use external data files in
    these formats in your Web pages. You will also learn how to set up a small testing
    Web server to run files that load external resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还描述了在可视化中常用的数据格式，如CSV、XML和JSON，以及如何在你的Web页面中加载、解析和使用这些格式的外部数据文件。你还将学习如何设置一个小型测试Web服务器来运行加载外部资源的文件。
- en: The final section contains some tips on how to obtain and prepare data for your
    visualizations, how to convert HTML data into standard formats, and how to extract
    selected information from HTML pages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后部分包含了一些关于如何获取和准备数据以供你的可视化使用、如何将HTML数据转换为标准格式，以及如何从HTML页面中提取所需信息的技巧。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Essential JavaScript for Chart.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chart.js必需的JavaScript
- en: 'Other technologies: DOM, CSS, JQuery, and Canvas'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他技术：DOM、CSS、JQuery和Canvas
- en: Data formats
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据格式
- en: How to load and parse external data files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加载和解析外部数据文件
- en: How to extract and transform data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提取和转换数据
- en: Essential JavaScript for Chart.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chart.js必需的JavaScript
- en: Client-side applications, such as interactive Web graphics, depend on browser
    support. This book assumes that your audience uses browsers that support HTML5
    Canvas and ES2015 (which include all modern browsers). All examples use ES2015
    syntax, including *const* and *let* instead of *var*, arrow functions where appropriate,
    spread operators, maps, sets, and promises. External files are loaded using the
    Fetch API, which has only been supported more recently, but you can easily switch
    to JQuery if necessary.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序，如交互式Web图形，依赖于浏览器支持。本书假设你的受众使用支持HTML5 Canvas和ES2015（包括所有现代浏览器）的浏览器。所有示例都使用ES2015语法，包括*const*和*let*代替*var*，在适当的地方使用箭头函数，使用扩展运算符、映射、集合和承诺。外部文件使用Fetch
    API加载，该API最近才得到支持，但如果你需要，可以轻松切换到JQuery。
- en: Although the creation of visualizations with Chart.js is mostly a declarative
    process, it is still a JavaScript library and requires basic knowledge of JavaScript.
    To create a simple chart, you need to know how to declare constants and variables,
    perform basic mathematical Boolean string and attribution operations, call and
    create functions, manipulate objects and arrays, and instantiate the Chart.js
    object. A typical chart also requires enough knowledge to program control structures,
    write callbacks, sort and filter datasets, generate random numbers, and load external
    files. This section is a quick refresher on the main ES2015 topics you will need
    to use Chart.js.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Chart.js创建可视化主要是一个声明性过程，但它仍然是一个JavaScript库，需要基本的JavaScript知识。要创建一个简单的图表，你需要知道如何声明常量和变量，执行基本的数学布尔字符串和属性操作，调用和创建函数，操作对象和数组，以及实例化Chart.js对象。典型的图表还需要足够的知识来编程控制结构，编写回调函数，排序和过滤数据集，生成随机数，以及加载外部文件。本节是对你使用Chart.js所需的主要ES2015主题的快速回顾。
- en: Browser tools
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器工具
- en: You don't need a full frontend modular Node development environment to create
    visualizations with Chart.js, but you still need a good debugger. Every browser
    comes with development tools that allow you to navigate a static page structure
    and generated DOM elements, and a console where you can interact in real time
    with the data used by the JavaScript engine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要一个完整的客户端模块化Node开发环境来使用Chart.js创建可视化，但你仍然需要一个良好的调试器。每个浏览器都自带开发工具，允许你导航静态页面结构和生成的DOM元素，以及一个控制台，你可以实时与JavaScript引擎使用的数据进行交互。
- en: 'The most important tool is the **JavaScript console**, where you will see any
    error messages. It''s very common to get a blank page when you expected something
    else and not have a clue as to why your code doesn''t work as expected. Sometimes,
    it''s just a comma you forgot, or the internet is down and some file was not loaded.
    If you have the JavaScript console open while you run your page, it will instantly
    tell you what''s going on. It''s also a good idea to use an editor with line numbering,
    since most error messages inform us of the lines where the problem occurred:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的工具是**JavaScript控制台**，在这里你会看到任何错误信息。当你期望看到其他内容却得到一个空白页面，并且不知道为什么你的代码没有按预期工作，这种情况非常常见。有时，可能只是你忘记了一个逗号，或者网络连接中断导致某些文件没有加载。如果你在运行页面时打开了JavaScript控制台，它会立即告诉你发生了什么。使用带有行号的编辑器也是一个好主意，因为大多数错误信息都会告诉我们问题发生的位置：
- en: '![](img/b0d0a36f-9ca6-4578-bf2e-86e8895b12c4.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0d0a36f-9ca6-4578-bf2e-86e8895b12c4.png)'
- en: Debugging JavaScript with the JavaScript console
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript控制台调试JavaScript
- en: 'You can open the developer tools as a frame in your browser or as a separate
    window. The following are the menu paths for the JavaScript console in latest
    versions of the three most popular browsers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将开发者工具作为浏览器中的一个框架或作为单独的窗口打开。以下是最受欢迎的三种浏览器最新版本中JavaScript控制台的菜单路径：
- en: 'Chrome: View | Developer | JavaScript Console'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Chrome: 查看 | 开发者 | JavaScript控制台'
- en: 'Firefox: Tools | Web Developer | Web Console'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Firefox: 工具 | 网页开发者 | 网页控制台'
- en: 'Safari: Develop | Show Error Console'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Safari: 开发 | 显示错误控制台'
- en: Most of the code fragments and examples in this section can be tested by typing
    them in the JavaScript console. It's a great way to learn JavaScript. It will
    also access the functions of any JavaScript library file that was loaded with
    the `<script>` tag, and any global variables declared in the `<script></script>`
    blocks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的大多数代码片段和示例都可以通过在JavaScript控制台中输入它们来测试。这是一种学习JavaScript的好方法。它还会访问通过`<script>`标签加载的任何JavaScript库文件的功能，以及`<script></script>`块中声明的任何全局变量。
- en: JavaScript types and variables
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript类型和变量
- en: JavaScript is not a typed language, since types are not declared and variables
    can receive different types, but data values do have types. The main types are *Number*,
    *String*, *Boolean*, *Array*, *Object*, and *Function*. The first three are scalar
    types, and the last three are also objects. A value is treated differently in
    the same expression if it has one type or another. For example, in an expression
    such as *a = b* + *c*, the value of *a* will be different if *b* and *c* are numbers
    (they will be added) or if one of them is a string (they will be concatenated).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不是一种强类型语言，因为类型没有声明，变量可以接收不同的类型，但数据值确实有类型。主要类型有**Number**、**String**、**Boolean**、**Array**、**Object**和**Function**。前三种是标量类型，后三种也是对象。如果值具有不同的类型，它们在同一个表达式中会被以不同的方式处理。例如，在一个表达式如`a
    = b + c`中，如果`b`和`c`是数字（它们将被相加），或者其中一个是一个字符串（它们将被连接），那么`a`的值将会不同。
- en: Values can be compared, and their types are important if the comparison is *strict*
    (for example, using `===` instead of `==`). But it can be confusing to rely on
    such conversions (`0`, `""`, `null`, `NaN` , and `undefined` are all considered
    `false`, but the  `false` string converts to `true`, since its not an empty string).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以进行比较，如果比较是**严格的**（例如，使用`===`而不是`==`），那么它们的类型就很重要。但是，依赖于这样的转换可能会令人困惑（`0`、`""`、`null`、`NaN`和`undefined`都被认为是`false`，但`false`字符串转换为`true`，因为它不是一个空字符串）。
- en: 'In ES5 JavaScript, `var` was the only keyword for declaring a variable. It
    ignores block scope and is hoisted to the top of the functions. Since ES6 (ES2015),
    two new keywords have been introduced: `const` and `let`. They both are block-scoped
    and need to be assigned a value before they are used (`var` defaults to `undefined`).
    Declarations with `const` are constants and can''t be reassigned. It''s usually
    considered good practice to use `const` whenever possible, and only use `let`
    if you actually need to redefine a variable.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5 JavaScript中，`var`是声明变量的唯一关键字。它忽略了块作用域，并且会被提升到函数的顶部。自从ES6（ES2015）以来，引入了两个新的关键字：`const`和`let`。它们都是块作用域的，并且在使用之前需要赋值（`var`默认为`undefined`）。使用`const`的声明是常量，不能重新赋值。通常认为，尽可能使用`const`是好的做法，只有在确实需要重新定义变量时才使用`let`。
- en: Data structures used in charts
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表中使用的**数据结构**
- en: Data used as sources for visualizations is usually organized in some kind of
    structure. The most common structures are probably *lists* (arrays) and *tables*
    (maps), stored in some standard data format. When using data from external sources,
    you usually need to clean it up, removing unnecessary values, simplifying its
    structure, applying bounds, and so on. After that, you can parse it and finally
    store it locally in a JavaScript array or JavaScript object that can be used by
    the chart.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 用作可视化数据源的数据通常以某种结构组织。最常见的数据结构可能是*列表*（数组）和*表格*（映射），存储在某种标准数据格式中。当使用外部数据源时，你通常需要对其进行清理，删除不必要的值，简化其结构，应用边界等。之后，你可以解析它，并将其最终存储在本地JavaScript数组或JavaScript对象中，以便图表使用。
- en: Once your data is stored in a JavaScript data structure, you can transform it
    further by applying mathematical operations on the stored values. You can change
    the structure, create new fields, merge, and delete data. Typical operations include
    pushing new values into the dataset, splicing or splitting the array, creating
    a subset, transforming data, and so on. JavaScript provides many native operations
    that make it easier to modify arrays and objects. You can also use libraries such
    as JQuery.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的数据存储在JavaScript数据结构中，你可以通过在存储的值上应用数学运算来进一步转换它。你可以更改结构，创建新字段，合并和删除数据。典型操作包括将新值推送到数据集中，切片或拆分数组，创建子集，转换数据等。JavaScript提供了许多原生操作，使修改数组和对象变得更容易。你还可以使用JQuery等库。
- en: Arrays
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arrays
- en: 'The main data structure you will use to store one-dimensional data is the JavaScript
    array. It''s used as the main dataset format in most chart types in Chart.js.
    An array of values is all you need to make a simple bar chart. You can create
    an array by declaring a list of items within brackets, or simply a pair of opening-closing
    brackets if you want to start with an empty array:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的主要数据结构来存储一维数据是JavaScript数组。它是Chart.js中大多数图表类型的主要数据集格式。制作一个简单的柱状图只需要一个值数组。你可以通过在括号内声明一个项目列表来创建一个数组，或者如果你想从一个空数组开始，只需一对开闭括号：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can then access the items of an array using an array index, which starts
    counting from zero:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用数组索引访问数组的项，索引从零开始计数：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each array has a length property that returns the number of elements. It''s
    very useful to iterate using the array index:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组都有一个长度属性，它返回元素的个数。使用数组索引进行迭代非常有用：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also loop over the elements of an array using the *of* operator (introduced
    in ES2015) when you don''t need the index:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用*of*运算符（在ES2015中引入）遍历数组的元素，当你不需要索引时：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And you can use the `forEach()` method, which runs a function for each element
    and also allows access to the index, item, and array inside the function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`forEach()`方法，它为每个元素运行一个函数，并允许在函数内部访问索引、项和数组：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Multidimensional arrays are created in JavaScript as arrays of arrays:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，多维数组是以数组数组的格式创建的：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can retrieve individual items like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样检索单个项：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'JavaScript provides many ways to extract and insert data into an array. It''s
    usually recommended to use these methods whenever possible. The following table
    lists useful methods you can use on arrays. Some modify the array; others return
    new arrays and other types. The examples provided use the `colors` and `numbers`
    arrays as declared previously. Try them out using your browser''s JavaScript console:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了许多方法来提取和插入数组中的数据。通常建议尽可能使用这些方法。以下表格列出了你可以用于数组的有用方法。一些方法会修改数组；其他方法返回新的数组和其他类型。提供的示例使用之前声明的`colors`和`numbers`数组。你可以使用浏览器中的JavaScript控制台尝试它们：
- en: '| **Method** | **Description** | **Example** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** | **示例** |'
- en: '| `push(item)` | Modifies the array, adding an item to the end. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `push(item)` | 修改数组，在末尾添加一个项。 |'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `pop()` | Modifies the array, removing and returning the last item. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 修改数组，移除并返回最后一个项。 |'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `unshift(item)` | Modifies the array, inserting an item at the beginning.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `unshift(item)` | 修改数组，在开头插入一个项。 |'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `shift()` | Modifies the array, removing and returning the first item. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `shift()` | 修改数组，移除并返回第一个项。 |'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `splice(p,n,i)` | Modifies the array, starting at position `p`. Can be used
    to delete, insert, or replace items. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `splice(p,n,i)` | 从位置`p`开始修改数组。可用于删除、插入或替换项。 |'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `reverse()` | Modifies the array, reversing its order. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `reverse()` | 修改数组，反转其顺序。 |'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `sort()` | Modifies the array, sorting by string order (if no args) or by
    a comparator function. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `sort()` | 修改数组，按字符串顺序（如果没有参数）或按比较函数排序。 |'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `slice(b,e)` | Returns a shallow copy of the array between `b` and `e`. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `slice(b,e)` | 返回从 `b` 到 `e` 的数组的一个浅拷贝。 |'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `filter(callback)` | Returns new array where the elements pass the test implemented
    by the function. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `filter(callback)` | 返回一个新数组，其中的元素通过函数实现的测试。 |'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `find(function)` | Returns the first element that satisfies the test function.
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `find(function)` | 返回满足测试函数的第一个元素。 |'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `indexOf(item)` | Returns the index of the first occurrence of the item in
    the array. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `indexOf(item)` | 返回数组中项目首次出现的位置索引。 |'
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `includes(item)` | Returns `true` if an array contains the item among its
    entries. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `includes(item)` | 如果数组在其条目中包含项目，则返回 `true`。 |'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `lastIndexOf(item)` | Returns the index of the last occurrence of the item
    in the array. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `lastIndexOf(item)` | 返回数组中项目最后一次出现的位置索引。 |'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `concat(other)` | Returns a new array that merges the current array with
    another. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `concat(other)` | 返回一个新数组，它将当前数组与另一个数组合并。 |'
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `join()``join(delim)` | Returns a comma-separated string of the elements
    in the array (an optional delimiter may be used). |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `join()``join(delim)` | 返回数组中元素的逗号分隔字符串（可以使用可选的分隔符）。 |'
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `map(function)` | Returns a new array with each element modified by the function.
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `map(function)` | 返回一个新数组，其中的每个元素都通过函数修改。 |'
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `reduce(function)` | Returns the result of an accumulation operation using
    the values in the array. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `reduce(function)` | 返回使用数组中的值进行的累积操作的结果。 |'
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `forEach(function)` | Executes the provided function once for each element
    in the array. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `forEach(function)` | 对数组中的每个元素执行提供的函数一次。 |'
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: JavaScript functions for array manipulation
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数组操作函数
- en: 'Besides arrays, ES2015 also introduced two new data structures: Map, an associative
    array with key-value pairs, easier to use than simple objects, and Set, which
    doesn''t allow repeated values. Both can be transformed to and from arrays.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数组之外，ES2015还引入了两种新的数据结构：Map，一个具有键值对的关联数组，比简单对象更容易使用，以及Set，它不允许重复值。两者都可以转换为数组。
- en: Strings
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are primitive types in JavaScript that can be created with single quotes
    or double quotes. There is no difference. It''s only a matter of style. ES2015
    introduced two new string features: *template literals* and *multiline strings*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，字符串是原始类型，可以使用单引号或双引号创建。它们之间没有区别，这只是风格问题。ES2015引入了两个新的字符串特性：*模板字符串*和*多行字符串*。
- en: 'Multiline strings can be created by adding a backslash at the end of each line:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 多行字符串可以通过在每行末尾添加反斜杠来创建：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Template literals are strings created with backticks. They allow the inclusion
    of JavaScript expressions inside the `${}` placeholders. The result is concatenated
    as a single string:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串是通过反引号创建的字符串。它们允许在 `${}` 插值占位符内包含JavaScript表达式。结果作为单个字符串连接：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you need to use a special character in a string, such as a double quote
    in a double-quoted string or a backslash, you need to precede it with a backslash:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在字符串中使用特殊字符，例如双引号字符串中的双引号或反斜杠，需要在它前面加上反斜杠：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are several methods for string manipulation. They all return new strings
    or other types. No methods modify the original strings:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种字符串操作方法。它们都返回新的字符串或其他类型。没有方法修改原始字符串：
- en: '| **Method** | **Description** | **Example** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** | **示例** |'
- en: '| `startsWith(s)` | Returns `true` if the string starts with the string passed
    as a parameter. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `startsWith(s)` | 如果字符串以作为参数传递的字符串开头，则返回 `true`。 |'
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `endsWith(s)` | Returns `true` if string ends with the string passed as a
    parameter. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `endsWith(s)` | 如果字符串以作为参数传递的字符串结尾，则返回 `true`。 |'
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `substring(s,e)` | Returns a substring between `start` (incl.) and *end*
    indexes (not incl.). |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `substring(s,e)` | 返回从 `start`（包含）到 *end* 索引（不包含）之间的子字符串。 |'
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `split(regx)``split(delim)` | Splits a string by a delimiter character or 
    a regular expression and returns an array. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `split(regx)``split(delim)` | 通过分隔符字符或正则表达式分割字符串，并返回一个数组。 |'
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `indexOf()` | Returns the index of the first occurrence of a substring. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `indexOf()` | 返回子字符串首次出现的位置索引。 |'
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `lastIndexOf()` | Returns the index of the last occurrence of a substring.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `lastIndexOf()` | 返回子字符串最后一次出现的位置索引。 |'
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `charAt(i)` | Returns `char` at index `*i*`. Also supported as `‘string''[i]`.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `charAt(i)` | 返回索引 `*i*` 处的 `char`。也支持为 `‘string''[i]`。 |'
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `trim()` | Removes whitespace from both ends of a string. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `trim()` | 从字符串的两端删除空白字符。|'
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `match(regx)` | Returns an array as the result of matching a regular expression
    against the string. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `match(regx)` | 返回一个数组，该数组是正则表达式与字符串匹配的结果。|'
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `replace(regx,r)``replace(s,t)` | Returns a new string replacing the matching
    of regexp applied to the string with a replacement or all occurrences of the source
    string with a target string. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `replace(regx,r)``replace(s,t)` | 返回一个新的字符串，该字符串将应用于字符串的正则表达式匹配替换为替换文本，或将源字符串的所有出现替换为目标字符串。|'
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: JavaScript functions for string manipulation
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 字符串操作函数
- en: Functions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are typically created in JavaScript using the `function` keyword,
    using one of the following forms:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通常使用 JavaScript 中的 `function` 关键字创建，使用以下形式之一：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `this` keyword refers to the object that owns the function. If this code
    runs in a browser, and this is a top-level function created in the `<script>`
    block, the owner is the global `window` object. Any properties accessed via this
    refer to that object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 关键字指向拥有函数的对象。如果此代码在浏览器中运行，并且这是一个在 `<script>` 块中创建的顶级函数，则所有者是全球的 `window`
    对象。通过此访问的任何属性都指向该对象。'
- en: 'A function can be placed in the scope of an object, behaving as a method. The
    `this` reference in the following code refers to the `obj` object and can access
    `this.a` and `this.b`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以放置在对象的范围内，作为方法使用。以下代码中的 `this` 引用指向 `obj` 对象，可以访问 `this.a` 和 `this.b`：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Arrow functions were introduced in ES2015\. They are much more compact and
    can lead to cleaner code, but the scope of `this` is no longer retained by the
    object. In the following code, it refers to the global window object. Code that
    uses `this.a` and `this.b` will not find any data in the object and will return
    undefined:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是在 ES2015 中引入的。它们更加紧凑，可以使代码更简洁，但 `this` 的作用域不再由对象保留。在以下代码中，它引用全局的 `window`
    对象。使用 `this.a` 和 `this.b` 的代码将不会在对象中找到任何数据，并返回 `undefined`：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can use arrow functions in Chart.js callbacks, but you should use regular
    functions instead of arrow functions if you need to access the instance of the
    chart, usually available using `this`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Chart.js 回调中使用箭头函数，但如果你需要访问图表实例，通常使用 `this`，你应该使用普通函数而不是箭头函数。
- en: Objects
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: 'An object is an unordered collection of data. Values in an object are stored
    as key-value pairs. You can create an object by declaring a comma-separated list
    of *key:value* pairs within curly braces, or simply a pair of opening-closing
    curly braces if you want to start with an empty object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是无序的数据集合。对象中的值存储为键值对。你可以通过在花括号内声明逗号分隔的 *键:值* 对来创建对象，或者如果你想要从空对象开始，可以简单地使用一对开闭花括号：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Objects can contain other objects and arrays, which can also contain objects.
    They can also contain functions, which have access to local properties and behave
    as methods:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以包含其他对象和数组，这些数组也可以包含对象。它们还可以包含函数，这些函数可以访问局部属性，并作为方法使用：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A typical dataset used by a simple chart usually consists of an array of objects:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 简单图表通常使用的典型数据集通常由一个对象数组组成：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can access the properties of an object using the dot operator or brackets
    containing the key as a string. You can run its methods using the dot operator:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用点操作符或包含键作为字符串的方括号来访问对象的属性。你可以使用点操作符运行其方法：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also loop over the properties of an object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以遍历对象的属性：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Properties and functions can be added to objects. It''s common to write code
    that declares an empty object in a global context so that operations in other
    contexts add data to it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向对象添加属性和函数。在全局范围内声明一个空对象以声明代码很常见，以便在其他上下文中添加数据：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Objects can also be created with a constructor. You can create an object that
    contains the current date/time using:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对象也可以通过构造函数创建。你可以使用以下方式创建包含当前日期/时间的对象：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A Chart.js instance is created using a constructor that receives at least two
    parameters. The second parameter is an object with two properties, a string and
    another object:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Chart.js 实例需要使用至少两个参数的构造函数。第二个参数是一个对象，包含两个属性，一个字符串和另一个对象：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'JSON is a data format based on JavaScript objects. It has the same structure
    as a JavaScript object, but the property keys have to be placed within double
    quotes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是基于 JavaScript 对象的数据格式。它与 JavaScript 对象具有相同的结构，但属性键必须放在双引号内：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To use a JSON string in JavaScript you have to parse it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 JavaScript 中使用 JSON 字符串，你必须解析它。
- en: Other technologies
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他技术
- en: This section presents a brief summary of other technologies you should know
    about, covering their fundamental concepts. They include HTML DOM, JQuery, CSS,
    and HTML Canvas. You can skim or skip this section if you already know about and
    use these technologies. The next sections also provide code examples that can
    be downloaded from the GitHub repository for this chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了你应该了解的其他技术，包括它们的基本概念。它们包括 HTML DOM、JQuery、CSS 和 HTML Canvas。如果你已经了解并使用这些技术，可以浏览或跳过本节。接下来的几节还提供了可以从本章
    GitHub 仓库下载的代码示例。
- en: HTML Document Object Model(DOM)
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML 文档对象模型（DOM）
- en: 'The structure of an HTML document is normally described with tags, but it can
    also be specified using JavaScript commands with a **Document Object Model (DOM)**:
    a language-neutral API that represents an HTML or XML document as a *tree*. Consider
    the following HTML document (`Examples/example-1.html`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文档的结构通常用标签描述，但也可以使用带有 **Document Object Model (DOM)** 的 JavaScript 命令指定：一个语言中立的
    API，它将 HTML 或 XML 文档表示为 *树*。考虑以下 HTML 文档（`Examples/example-1.html`）：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This page builds a tree of interconnected *nodes* containing HTML elements
    and text. The exact same result can be obtained with the following JavaScript
    commands (`Examples/example-2.html`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本页构建了一个包含 HTML 元素和文本的相互连接的 *节点* 树。可以使用以下 JavaScript 命令获得相同的结果（`Examples/example-2.html`）：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Of course, it's much simpler to write tags, but JavaScript gives you the power
    to make the structure and content *dynamic*. Using DOM commands, you can add new
    elements, move them around, remove them, and change their attributes and text
    contents. You can also navigate the DOM tree, select or search for specific elements
    or data, and bind styles and event handlers to elements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，编写标签要简单得多，但 JavaScript 给你提供了使结构和内容 *动态化* 的能力。使用 DOM 命令，你可以添加新元素，移动它们，删除它们，并更改它们的属性和文本内容。你还可以在
    DOM 树中导航，选择或搜索特定元素或数据，并将样式和事件处理器绑定到元素上。
- en: 'For example, if you add the following code, a new `<p>` containing the `“New
    line”` text will be created every time you click on the image (`Examples/example-3.html`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你添加以下代码，每次点击图片时都会创建一个新的 `<p>` 元素，包含 `“New line”` 文本（`Examples/example-3.html`）：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Normally, you wouldn''t write your entire document using DOM, but only the
    parts you wish to control dynamically. Normally, you write the static parts as
    HTML and use scripting only when necessary (`Examples/example-4.html`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会使用 DOM 编写整个文档，而只是控制动态部分的文档。通常，你会将静态部分编写为 HTML，并在必要时使用脚本（`Examples/example-4.html`）：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For data-driven documents, you can use DOM scripting to bind data stored in
    arrays and objects to attributes of the elements, changing the dimensions, colors,
    text contents, and position. Most data visualization libraries do exactly that
    by providing functions that are built over the DOM, and make this task much simpler.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据驱动的文档，你可以使用 DOM 脚本来将存储在数组或对象中的数据绑定到元素的属性，从而改变尺寸、颜色、文本内容和位置。大多数数据可视化库正是通过提供基于
    DOM 的函数来实现这一点，使这项任务变得简单得多。
- en: 'The following table lists the most important DOM commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了最重要的 DOM 命令：
- en: '| **Method or property** | **Description** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **方法或属性** | **描述** |'
- en: '| `createElement(tag)` | Creates an element (not connected to the node tree)
    and returns its reference. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `createElement(tag)` | 创建一个元素（不连接到节点树）并返回其引用。|'
- en: '| `createTextNode(text)` | Creates a text node (not connected to the node tree)
    and returns its reference. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `createTextNode(text)` | 创建一个文本节点（不连接到节点树）并返回其引用。|'
- en: '| `appendChild(element)` | Connects the element passed as a parameter as the
    child of the current element. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `appendChild(element)` | 将传入参数的元素作为当前元素的子元素连接。|'
- en: '| `removeChild(element)` | Disconnects the child element from the current element.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `removeChild(element)` | 将子元素从当前元素中断开连接。|'
- en: '| `setAttribute(name, value)` | Sets an attribute for this element with the
    name and value passed as parameters. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `setAttribute(name, value)` | 使用传入的参数设置此元素的属性名称和值。|'
- en: '| `getElementById(id)` | Returns an element identified by the `id` passed as
    a parameter. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `getElementById(id)` | 返回一个通过传入参数的 `id` 标识的元素。|'
- en: '| `getElementsByTagName(tag)` | Returns a `nodelist` (array) containing all
    the elements that match the tag name passed as a parameter. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `getElementsByTagName(tag)` | 返回一个包含所有匹配传入参数标签名的元素的 `nodelist`（数组）。|'
- en: '| `addEventListener(e, func)` | Attaches an event handler to this element.
    The first parameter is the event type (for example, `‘click''`, `‘key''`, and
    so on) and the second parameter is a handler function. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `addEventListener(e, func)` | 将事件处理程序附加到该元素。第一个参数是事件类型（例如，`‘click''`, `‘key''`,
    等等）第二个参数是处理函数。|'
- en: '| `documentElement` | This property references the element at the root of the
    document. For HTML and XHTML, it is the `<html>` element. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `documentElement` | 该属性引用文档根部的元素。对于HTML和XHTML，它是`<html>`元素。|'
- en: '| `children` | This property returns a node list containing the child elements
    of this element. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `children` | 该属性返回一个包含此元素子元素的节点列表。|'
- en: '| `innerText` | In SVG or HTML documents, this read/write property is a shortcut
    for creating a text node and appending it to the element. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `innerText` | 在SVG或HTML文档中，这个读写属性是一个创建文本节点并将其附加到元素的快捷方式。|'
- en: '| `innerHTML` | In HTML documents, this read/write property is a shortcut for
    appending an entire HTML fragment as a child element. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `innerHTML` | 在HTML文档中，这个读写属性是一个将整个HTML片段作为子元素附加的快捷方式。|'
- en: '| `style` | In SVG or HTML documents, this property allows access to the element''s
    CSS styles. You can use it to read and modify styles dynamically. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `style` | 在SVG或HTML文档中，该属性允许访问元素的CSS样式。您可以使用它动态地读取和修改样式。|'
- en: A selection of properties and methods supported by HTML DOM
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: HTML DOM支持的属性和方法选择
- en: Cascading Style Sheets
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层叠样式表
- en: '**Cascading Style Sheets** (**CSS**) is a W3C standard that specifies how HTML
    and XML elements are displayed on the screen. It''s a declarative language where
    visual properties are applied to tag selectors. You can use CSS to apply properties
    such as colors, fonts, margins, shadows, and gradients to one or more tags, perform
    coordinate transformations in two and three dimensions, and set rules for transitions
    and animations. CSS properties and selectors are also used in JavaScript libraries,
    such as JQuery and D3.js.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**层叠样式表**（**CSS**）是一个W3C标准，它指定了HTML和XML元素在屏幕上的显示方式。它是一种声明性语言，其中视觉属性应用于标签选择器。您可以使用CSS将颜色、字体、边距、阴影和渐变等属性应用于一个或多个标签，在二维和三维中进行坐标变换，并设置过渡和动画的规则。CSS属性和选择器也用于JavaScript库，如JQuery和D3.js。'
- en: 'CSS selectors are expressions used to select elements by type, class, ID, wildcards,
    attributes, context, state, and position. The result of a selection expression
    may consist of none, one, or more elements. JavaScript libraries use selectors
    to obtain objects that can be manipulated programmatically via DOM. A result set
    can be formed from a list of comma-separated selection expressions. Elements may
    also be selected from context with combinator selectors. The following table lists
    some of the main selectors and some examples:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: CSS选择器是用于通过类型、类、ID、通配符、属性、上下文、状态和位置选择元素的表达式。选择表达式的结果可能由零个、一个或多个元素组成。JavaScript库使用选择器来获取可以通过DOM编程方式操作的对象。可以从逗号分隔的选择表达式列表中形成结果集。元素也可以通过组合选择器从上下文中选择。以下表格列出了主要选择器及其一些示例：
- en: '| **Selector** | **Syntax** | **Description Example (in CSS)** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **选择器** | **语法** | **描述示例（在CSS中）** |'
- en: '| Type selector | `tagname` | Selects a set of elements of the specified type
    (tag name), for example `td, h1, prect { … } /* all <rect> tags */`. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 类型选择器 | `tagname` | 选择指定类型（标签名）的元素集合，例如 `td, h1, prect { … } /* 所有 <rect>
    标签 */`。|'
- en: '| Class selector | `.classname` | Selects a set of elements that belongs to
    a specified class, for example `.selected` and `p.copy`. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 类选择器 | `.classname` | 选择属于指定类的元素集合，例如 `.selected` 和 `p.copy`。|'
- en: '| ID selector | `#idname` | Selects one element with the specified `id` attribute,
    for example `#main` and `#chart`. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| ID选择器 | `#idname` | 选择具有指定`id`属性的元素，例如 `#main` 和 `#chart`。|'
- en: '| Universal selector | `*` | Selects all elements. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 全局选择器 | `*` | 选择所有元素。|'
- en: '| Attribute selector | `[attr]` `[attr=value]`(several other combinations)
    | Selects elements that contain an attribute.Selects elements that contain an
    attribute with a specified value.Other combinations match a string in the attribute
    value. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 属性选择器 | `[attr]` `[attr=value]`(其他几种组合) | 选择包含属性的元素。选择具有指定值的属性的元素。其他组合匹配属性值中的字符串。|'
- en: '| Descendant combinator | `ancestor selectedtag` | Selects elements nested
    within a specified ancestor element (may have other elements in between), for
    example table `td`. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 后代组合器 | `ancestor selectedtag` | 选择嵌套在指定祖先元素内的元素（之间可能包含其他元素），例如 `table td`。|'
- en: '| Child combinator | `parent > selectedtag` | Selects elements nested *directly*
    below a specified parent element (`selectedTag` is a child of a parent), for example `table
    >tbody >tr >td`. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 子组合器 | `parent > selectedtag` | 选择直接位于指定父元素（`selectedTag`是父元素的子元素）下方的元素，例如 `table
    >tbody >tr >td`。 |'
- en: '| General sibling combinator | `preceding ~ selectedtag` | Selects elements
    that appear after a specified predecessor (both have the same parent), for example `h1
    ~p.last`. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 一般兄弟组合器 | `preceding ~ selectedtag` | 选择出现在指定前驱之后（两者具有相同的父元素）的元素，例如 `h1 ~p.last`。
    |'
- en: '| Adjacent sibling combinator | `previous + selectedtag` | Selects elements
    that appear *directly* after a specified sibling (both have the same parent),
    for example `h1 +p.first`. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 相邻兄弟组合器 | `previous + selectedtag` | 选择出现在指定兄弟之后（两者具有相同的父元素）的元素，例如 `h1 +p.first`。
    |'
- en: '| Pseudo-classes | `tag:state` | Selects elements that are in a specified *state,*
    for example `a:hover, p:last-child, td:nth-of-type(2), :not(x)`. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 伪类 | `tag:state` | 选择处于指定*state*的元素，例如 `a:hover, p:last-child, td:nth-of-type(2),
    :not(x)`。 |'
- en: '| Pseudo-elements | `tag::property` | Selects elements with a specified `property`,
    and is rarely used. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 伪元素 | `tag::property` | 选择具有指定`property`的元素，很少使用。 |'
- en: CSS selectors
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: CSS选择器
- en: Most of the time, you will use the simplest selectors. The ID, class, and type
    selectors are the most common. Eventually, you might use descendant combinators
    or attribute selectors.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，您将使用最简单的选择器。ID、类和类型选择器是最常见的。最终，您可能会使用后代组合器或属性选择器。
- en: 'The following code uses simple selectors to change the visual appearance of
    an unformatted page containing three sections. The sections are stacked one on
    top of the other. The CSS properties and other parts were omitted, but you can
    see them in the full code listing (`Examples/example-5-selectors.html`):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用简单选择器更改包含三个部分的未格式化页面的视觉外观。这些部分是堆叠在一起的。省略了CSS属性和其他部分，但您可以在完整的代码列表中看到它们（`Examples/example-5-selectors.html`）：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/bd5c5108-f516-4aca-b70f-c6563c648daf.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd5c5108-f516-4aca-b70f-c6563c648daf.png)'
- en: An HTML page with stacked information styled using only CSS
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用CSS样式化的堆叠信息的HTML页面
- en: JQuery fundamentals
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JQuery基础
- en: 'JQuery is not a standard technology, but it''s a de facto Web standard. It
    uses CSS selectors to locate elements in any HTML file, and provides the same
    power as the DOM but with a much cleaner syntax. To use *JQuery,* you first need
    to include its library in your HTML page using the `<script>` tag. This is easily
    done with a CDN URL:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: JQuery不是一个标准技术，但它是一个事实上的Web标准。它使用CSS选择器在任意HTML文件中定位元素，并提供与DOM相同的功能，但语法更简洁。要使用*JQuery*，您首先需要使用`<script>`标签将其库包含在您的HTML页面中。这可以通过CDN
    URL轻松完成：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The code fragment here is a page that uses *JQuery* to perform the exact same
    operations shown in the last DOM example. The result is much easier to understand
    (`Examples/example-6.html`):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段是一个使用*JQuery*执行与最后一个DOM示例中显示的完全相同操作的页面。结果是更容易理解（`Examples/example-6.html`）：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'CSS selectors are used in JavaScript libraries such as *JQuery* to apply dynamic
    styles and manipulate a document''s structure and contents. The main JQuery(selector)
    function, normally used via its alias, the `$(selector)`function, is an element
    selector that receives a CSS selector expression as its parameter:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: CSS选择器用于JavaScript库，如*JQuery*，以应用动态样式和操作文档的结构和内容。主要的JQuery(selector)函数，通常通过其别名`$(selector)`函数使用，是一个元素选择器，它接收一个CSS选择器表达式作为其参数：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A selection can return zero, one, or a list of elements. You can test the length
    of a selection using the `length` attribute:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 选择可以返回零个、一个或一个元素列表。您可以使用`length`属性测试选择的长度：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Using *JQuery* and the code shown in the CSS example, we can make the tabs
    fade in and fade out as they are clicked using selectors and *JQuery* functions
    (`Examples/example-7-selectors.html`):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*JQuery*和CSS示例中显示的代码，我们可以通过选择器和*JQuery*函数使选项卡在点击时淡入和淡出（`Examples/example-7-selectors.html`）：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: HTML5 Canvas
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5画布
- en: 'There is no way to draw circles or gradients using HTML tags, but you can use
    HTML Canvas: a full-featured JavaScript graphics API for 2D vector graphics. You
    can draw anything you wish with Canvas, and since it''s JavaScript, you can make
    it animate and respond to events.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML标签无法绘制圆形或渐变，但您可以使用HTML Canvas：一个用于2D矢量图形的完整功能的JavaScript图形API。您可以使用Canvas绘制任何您想要的，由于它是JavaScript，您可以使其动画化并响应用件。
- en: 'To draw using Canvas, you need to create a `<canvas>` element in your page.
    You can do that using plain HTML:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Canvas 绘制，您需要在您的页面上创建一个 `<canvas>` 元素。您可以使用纯 HTML 来做这件事：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can also create it dynamically, using HTML DOM:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 HTML DOM 动态创建它：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can create it using *JQuery* too:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 *JQuery* 创建它：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then you can reference using the DOM:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 DOM 引用：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Or you can reference using JQuery:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 jQuery 引用：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once you have a canvas object, you obtain a 2D graphics context and can start
    drawing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了画布对象，您就可以获取一个 2D 图形上下文并开始绘制：
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Practically, all the Canvas API consists of is methods and properties called
    from the graphics context. Before drawing, you set properties such as font, fill
    color, and stroke color:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Canvas API 主要由从图形上下文调用的方法和属性组成。在绘制之前，您设置诸如字体、填充颜色和描边颜色等属性：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And then *fill* or *stroke* rectangles and arbitrary paths containing lines
    and curves. These commands will draw a red 50 x 50 pixel square with a 10 pixel
    wide yellow semi-transparent border at position 50,50:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后填充或描边矩形和包含线条和曲线的任意路径。这些命令将在位置 50,50 绘制一个红色 50 x 50 像素的正方形，并带有 10 像素宽的黄色半透明边框：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can draw other shapes, texts, and images on the same canvas. The context
    properties will not change unless they are redefined.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在同一画布上绘制其他形状、文本和图像。上下文属性除非重新定义，否则不会改变。
- en: You can also draw using path commands. You need to start the path with `ctx.beginPath()`,
    and call a sequence of commands that moves to points and draws lines and curves,
    and when you are done you can close the path (if it's a closed path) and call
    `fill()` and/or `stroke()` to draw it using the current styles.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用路径命令来绘制。您需要从 `ctx.beginPath()` 开始路径，然后调用一系列命令将点移动到并绘制线条和曲线，完成后您可以关闭路径（如果它是闭合路径），并调用
    `fill()` 和/或 `stroke()` 来使用当前样式绘制它。
- en: 'The following code draws some shapes, paths, shadows, gradients, and text:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码绘制了一些形状、路径、阴影、渐变和文本：
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following diagram shows the result. You can try and run the full code,
    which is available in `Examples/example-8-canvas.html`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了结果。您可以尝试运行完整的代码，该代码可在 `Examples/example-8-canvas.html` 中找到：
- en: '![](img/36859749-cdcb-4ec3-a68b-764d6d911393.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36859749-cdcb-4ec3-a68b-764d6d911393.png)'
- en: 'Some shapes drawn in an HTML Canvas context. Code: *Examples/example-8-canvas.html*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML Canvas 上下文中绘制的某些形状。代码：*Examples/example-8-canvas.html*
- en: 'Some essential Canvas commands are listed in the following table. All commands
    are methods of the current Canvas context:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了一些基本的 Canvas 命令。所有命令都是当前 Canvas 上下文的方法：
- en: '| **Method or property** | **Description** |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **方法或属性** | **描述** |'
- en: '| `fillStyle` | Sets the color to be used in the `fill()` commands. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `fillStyle` | 设置在 `fill()` 命令中使用的颜色。|'
- en: '| `strokeStyle` | Sets the color to be used in the `stroke()` commands. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `strokeStyle` | 设置在 `stroke()` 命令中使用的颜色。|'
- en: '| `lineWidth` | Sets the line width to be used in the `stroke()` commands.
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `lineWidth` | 设置在 `stroke()` 命令中使用的线宽。|'
- en: '| `lineCap` | Sets the style of the line caps, for example `butt` (default),
    `round`, or `square`. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `lineCap` | 设置线条端点的样式，例如 `butt`（默认）、`round` 或 `square`。|'
- en: '| `lineJoin` | Sets the style of the line joins, for example `‘round''`, `‘bevel''`,
    or `‘miter''` (default). |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `lineJoin` | 设置线条连接的样式，例如 `‘round''`、`‘bevel''` 或 `‘miter''`（默认）。|'
- en: '| `font` | Sets the font to be used in the `strokeText()` or `fillText()` commands.
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `font` | 设置在 `strokeText()` 或 `fillText()` 命令中使用的字体。|'
- en: '| `globalAlpha` | Sets the global opacity (`0` = transparent, `1` = opaque)
    for the context. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `globalAlpha` | 设置上下文的全局不透明度（`0` = 透明，`1` = 不透明）。|'
- en: '| `shadowBlur, shadowColor,` `shadowOffsetX, shadowOffsetY` | Sets shadow properties.
    The default color is transparent black. The default numeric values are zero. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `shadowBlur, shadowColor,` `shadowOffsetX, shadowOffsetY` | 设置阴影属性。默认颜色是透明的黑色。默认数值为零。|'
- en: '| `fillRect(x,y,w,h)` | Fills a rectangle. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `fillRect(x,y,w,h)` | 填充一个矩形。|'
- en: '| `strokeRect(x,y,w,h)` | Draws a border around a rectangle. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `strokeRect(x,y,w,h)` | 在矩形周围绘制一个边框。|'
- en: '| `setLineDash(dasharray)` | Receives an array for the dash, alternating lines
    and spaces. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `setLineDash(dasharray)` | 接收一个用于虚线的数组，交替绘制线条和空白。|'
- en: '| `fillText(text,x,y);` | Fills text at the x and y positions (y is the baseline).
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `fillText(text,x,y);` | 在 x 和 y 位置填充文本（y 是基线）。|'
- en: '| `strokeText(text,` x, y); | Draws a border around text at the x and y positions.
    |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `strokeText(text,` x, y); | 在 x 和 y 位置绘制文本的边框。|'
- en: '| `createLinearGradient(x0, y0, x1, y1)` | Creates a linear gradient perpendicular
    to the line. Radial gradients and patterns are also supported. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `createLinearGradient(x0, y0, x1, y1)` | 创建与线条垂直的线性渐变。也支持径向渐变和图案。|'
- en: '| `drawImage(image, x, y, w, h)` | Draws an image. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `drawImage(image, x, y, w, h)` | 绘制图像。|'
- en: '| `beginPath()` | Starts a path. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `beginPath()` | 开始路径。|'
- en: '| `moveTo(x, y)` | Moves the cursor to a position in the path. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `moveTo(x, y)` | 将光标移动到路径中的某个位置。|'
- en: '| `lineTo(x, y)` | Moves the cursor to a position in the path, drawing a line
    along the way. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `lineTo(x, y)` | 将光标移动到路径中的某个位置，同时绘制一条线。|'
- en: '| `bezierCurveTo(c1x, c1y, c2x, c2y, x, y), quadraticCurveTo(cx, cy, x, y)`
    | Draws curves with one (*quadratic*) or two (*Bezier*) control points in a path.
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `bezierCurveTo(c1x, c1y, c2x, c2y, x, y), quadraticCurveTo(cx, cy, x, y)`
    | 在路径中绘制具有一个（*二次*）或两个（*贝塞尔*）控制点的曲线。|'
- en: '| `arc(x, y, r, sa, ea)` | Draws an arc by specifying the center, radius, start,
    and end angles in a path. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `arc(x, y, r, sa, ea)` | 通过指定路径中的中心、半径、起始角和结束角来绘制弧线。|'
- en: '| `arcTo(sx, sy, r, ex, ey)` | Draws an arc by specifying the coordinates of
    the starting point, the radius, and the coordinates of the end point. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `arcTo(sx, sy, r, ex, ey)` | 通过指定起始点坐标、半径和终点坐标来绘制弧线。|'
- en: '| `rect(x, y, w, h)` | Draws a rectangle in a path with the coordinates of
    the top-left corner, width, and height. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `rect(x, y, w, h)` | 使用左上角的坐标、宽度和高度在路径中绘制矩形。|'
- en: '| `clip()` | Creates a clipping region with the shapes drawn by the path that
    will affect objects that are drawn afterwards. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `clip()` | 使用路径绘制的形状创建一个裁剪区域，该区域将影响之后绘制的对象。|'
- en: '| `fill()` | Fills a path with the current color. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `fill()` | 使用当前颜色填充路径。|'
- en: '| `stroke()` | Strokes the path with the current color. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `stroke()` | 使用当前颜色绘制路径。|'
- en: Selected HTML Canvas commands
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的HTML Canvas命令
- en: Data formats
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据格式
- en: Data used in visualizations is usually distributed in a standard format that
    can be shared. Even when the data is served from a database, the data is usually
    delivered in some standard format. Popular proprietary formats, such as Excel
    spreadsheets, are common, but most statistical data is stored or delivered in
    CSV, XML, or JSON formats.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 用于可视化的数据通常以标准格式分布，可以共享。即使数据来自数据库，数据通常也以某种标准格式提供。流行的专有格式，如Excel电子表格，很常见，但大多数统计数据是以CSV、XML或JSON格式存储或提供的。
- en: CSV
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV
- en: 'CSV stands for comma-separated values. It''s a very popular data format for
    public data. A CSV file is a text file that emulates a table. It usually contains
    one header row with the names of the columns, and one or more data rows containing
    value fields. Rows are separated by line breaks, and the comma-separated fields
    in each row form columns. It maps perfectly to an HTML table. This is a simple
    CSV file containing the population and land area of seven continents (`Data/sample.csv`):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: CSV代表逗号分隔值。它是一种非常流行的公共数据格式。CSV文件是一个文本文件，模拟表格。它通常包含一个标题行，包含列名，以及一个或多个包含值字段的数据行。行由换行符分隔，每行中的逗号分隔字段形成列。它与HTML表格完美对应。这是一个简单的CSV文件，包含七个大洲的人口和陆地面积（`Data/sample.csv`）：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There are no types in CVS. Quotes are used to contain text that might contain
    the delimiter. They are not necessary if the fields don't contain a comma.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在CVS中没有类型。引号用于包含可能包含分隔符的文本。如果字段不包含逗号，则不需要引号。
- en: CSV is also used to refer to similar files that don't use a comma as a delimiter.
    These files are more accurately called **delimiter-separated value **(**DSV**)
    files. The most common delimiters are tabs (TSV), vertical bars (|), and semicolons.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: CSV也用于指代不使用逗号作为分隔符的类似文件。这些文件更准确地称为**分隔符分隔值**（**DSV**）文件。最常见的分隔符是制表符（TSV）、竖线（|）和分号。
- en: CSVs may become corrupt and unreadable, but it's text and you can fix it. Missing
    or unescaped commas are the most common problems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: CSVs可能变得损坏且无法读取，但它是文本，你可以修复它。缺失或未转义的逗号是最常见的问题。
- en: XML
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML
- en: '**eXtensible Markup Language** (**XML**) is a very popular data format. Ajax
    responses from Web services are usually returned as text or XML. It has standard
    native support in JavaScript via the DOM APIs and doesn''t require additional
    parsing. Although it is still common to find data in XML format, CSV and JSON
    alternatives, if available, are usually smaller and easier to work with.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**（**XML**）是一种非常流行的数据格式。Web服务的Ajax响应通常以文本或XML返回。它通过DOM API在JavaScript中具有标准原生支持，不需要额外的解析。尽管仍然可以在XML格式中找到数据，但如果可用，CSV和JSON替代品通常更小且更容易处理。'
- en: 'This is an example of an XML file with the same data as the CSV file shown
    earlier (`Data/sample.xml`):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与前面显示的CSV文件相同数据的XML文件示例（`Data/sample.xml`）：
- en: '[PRE70]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: XML files can be validated if an XML Schema is available. You can extract data
    from a well-formed XML file with DOM or with XPath (which is easier). There are
    many tools in all languages to manipulate XML. XML is also very easy to generate.
    Its main disadvantage is verbosity and size.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有 XML Schema 可用，XML 文件可以进行验证。你可以使用 DOM 或 XPath（这更容易）从格式良好的 XML 文件中提取数据。所有语言中都有许多工具可以用来操作
    XML。XML 也很容易生成。它的主要缺点是冗长和体积大。
- en: JSON
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: JSON stands for JavaScript Object Notation. It looks a lot like a JavaScript
    object, but it has stricter formation rules. It's probably the easiest format
    to work with. It's compact and easy to parse, and it's gradually replacing XML
    as a preferred data format in Web services.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 代表 JavaScript 对象表示法。它看起来很像 JavaScript 对象，但它有更严格的格式规则。这可能是最容易处理的一种格式。它紧凑且易于解析，并且正在逐渐取代
    XML，成为 Web 服务中首选的数据格式。
- en: 'The following data file containing continent data is shown in JSON format (`Data/sample.json`):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 包含大陆数据的以下数据文件以 JSON 格式（`Data/sample.json`）展示：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: JSON is the preferred format for data manipulation in JavaScript. There are
    many online tools you can use to transform CSV and XML files into JSON.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是 JavaScript 中数据操作的首选格式。你可以使用许多在线工具将 CSV 和 XML 文件转换为 JSON。
- en: Loading and parsing external data files
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和解析外部数据文件
- en: Unless you have a very small or static dataset, it will usually not be embedded
    in your web page. You will probably use an asynchronous request to load it from
    a separate file after your HTML page is already loaded and then parse it. This
    section covers topics related to loading and parsing external files.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的数据集非常小或静态，否则通常不会将其嵌入到你的网页中。你可能会在 HTML 页面加载后，从单独的文件中异步请求加载它，然后解析它。本节涵盖了与加载和解析外部文件相关的话题。
- en: Using a Web server
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web 服务器
- en: Most of the examples in this book consist of a single file (not considering
    the external libraries loaded using the `<script>` tags), and you can run them
    by simply opening them in a browser. You don't even need a Web server. Just click
    on the file and view it in your browser. But this won't work in examples that
    load external files via Ajax. For those files, you do need a Web server.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数示例都由一个单独的文件组成（不考虑使用 `<script>` 标签加载的外部库），你只需在浏览器中打开它们即可运行。你甚至不需要 Web
    服务器。只需点击文件，然后在浏览器中查看即可。但这种方法在通过 Ajax 加载外部文件的示例中不起作用。对于这些文件，你需要一个 Web 服务器。
- en: 'If you are using an HTML editor, such as PHPStorm or Brackets, it automatically
    starts a Web server for you and serves the page to your default browser. If you
    have Python installed in your system (it is native in macOS and Linux, and you
    can install it in Windows), you can run a simple server from the directory where
    your files are installed. The syntax depends on which Python version you have
    installed. You can check by opening a console and typing:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 HTML 编辑器，例如 PHPStorm 或 Brackets，它将自动为你启动一个 Web 服务器，并将页面服务到你的默认浏览器。如果你在系统中安装了
    Python（它在 macOS 和 Linux 中是原生的，你可以在 Windows 中安装它），你可以在文件安装的目录中运行一个简单的服务器。语法取决于你安装的
    Python 版本。你可以通过打开控制台并输入以下命令来检查：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now move to the directory where your HTML files are stored and run one of the
    following commands. If you have Python 3.x , run:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到存储你的 HTML 文件的目录，并运行以下命令之一。如果你有 Python 3.x，运行：
- en: '[PRE73]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If your version is 2.x, run:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 2.x 版本，运行：
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now you can open your files using `http://localhost:8080/your-file-name.html`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `http://localhost:8080/your-file-name.html` 打开你的文件。
- en: Loading files using standard JavaScript
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准 JavaScript 加载文件
- en: The standard way to load data into a Web page is using asynchronous JavaScript
    and XML, or Ajax. It uses the standard built-in `XMLHttpRequest` object, supported
    by all modern browsers.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据加载到网页中的标准方式是使用异步 JavaScript 和 XML，或 Ajax。它使用所有现代浏览器都支持的内置 `XMLHttpRequest`
    对象。
- en: To load a file using `XMLHttpRequest`, you need to create the `XMLHttpRequest`
    object, choose an HTTP method, use the object to open an HTTP connection to the
    file's URL, and send the request. You must also create a callback function that
    listens to the object's `'readystatechange'` event and test the object's `readystate`
    property.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `XMLHttpRequest` 加载文件，你需要创建 `XMLHttpRequest` 对象，选择一个 HTTP 方法，使用该对象打开到文件
    URL 的 HTTP 连接，并发送请求。你还必须创建一个回调函数，该函数监听对象的 `'readystatechange'` 事件并测试对象的 `readystate`
    属性。
- en: 'When this property contains `XMLHttpRequest.DONE`, the request is done and
    you can extract the data. But it''s not finished yet! If the request finished
    successfully (the object *status* property equals 200), you need to extract the
    data from the object. In a CSV file, the data will be in the `responseText` property
    (it''s in a different place if it''s XML). Only then can you finally parse its
    contents and create your data array. This is shown in the following code (`Examples/example-9-ajax.html`):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个属性包含 `XMLHttpRequest.DONE` 时，请求已完成，你可以提取数据。但还没有结束！如果请求成功完成（对象 *status* 属性等于
    200），你需要从对象中提取数据。在 CSV 文件中，数据将在 `responseText` 属性中（如果是 XML，则位于不同的位置）。只有在这种情况下，你才能最终解析其内容并创建你的数据数组。这在上面的代码（`Examples/example-9-ajax.html`）中展示：
- en: '[PRE75]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Loading files using JQuery
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JQuery 加载文件
- en: 'You never have to use standard JavaScript to load files, but it''s good to
    know how it works. It''s much, much simpler to load files using the *JQuery* library
    (`Examples/example-10-ajax-jquery.html`):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不需要使用标准的 JavaScript 来加载文件，但了解它是如何工作的总是好的。使用 *JQuery* 库加载文件要简单得多得多（`Examples/example-10-ajax-jquery.html`）：
- en: '[PRE76]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can also load and parse JSON files in a single step using *JQuery*:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 *JQuery* 在单步中加载和解析 JSON 文件：
- en: '[PRE77]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Loading files using the standard Fetch API
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准 Fetch API 加载文件
- en: In all modern browsers, you can also load external files using the Fetch API.
    It's the new JavaScript standard for loading files asynchronously, and we will
    be using it in all examples that load external files in this book, but it may
    not work in some older browsers. In that case, you should revert to standard JavaScript
    or JQuery.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有现代浏览器中，你也可以使用 Fetch API 加载外部文件。这是加载文件的新的 JavaScript 标准，我们将在本书中所有加载外部文件的示例中使用它，但在一些较旧的浏览器中可能不起作用。在这种情况下，你应该回退到标准的
    JavaScript 或 JQuery。
- en: 'The `fetch()` command is a reactive method based on JavaScript promises. A
    basic fetch request is shown as follows (`Examples/example-12-fetch.html`):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 命令是一个基于 JavaScript 承诺的响应式方法。一个基本的 fetch 请求示例如下（`Examples/example-12-fetch.html`）:'
- en: '[PRE78]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You can also parse JSON files using `fetch()`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `fetch()` 解析 JSON 文件：
- en: '[PRE79]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Parsing JSON
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 JSON
- en: 'Although JSON is based on JavaScript, a JSON file is not a JavaScript object.
    It''s a string. To convert it into an object and access its properties with the
    dot operator, you can use `JSON.parse()`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JSON 基于 JavaScript，但 JSON 文件不是一个 JavaScript 对象。它是一个字符串。为了将其转换为对象并使用点操作符访问其属性，你可以使用
    `JSON.parse()`：
- en: '[PRE80]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Sometimes you need to convert a JavaScript object back into JSON format. You
    might also do this for debugging. You can do this with `JSON.stringify()`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要将 JavaScript 对象转换回 JSON 格式。你可能也会这样做以进行调试。你可以使用 `JSON.stringify()` 来实现：
- en: '[PRE81]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you parsed the example JSON file at the beginning of this section, the JavaScript
    object will actually be an array of objects, and you can list its contents (in
    the JavaScript console) using the following code (`Examples/example-14.html`):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你解析了本节开头示例中的 JSON 文件，JavaScript 对象实际上将是一个对象数组，你可以使用以下代码（`Examples/example-14.html`）列出其内容（在
    JavaScript 控制台中）：
- en: '[PRE82]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Parsing CSV
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 CSV
- en: There is no native CSV parser in JavaScript, but if you have a very small and
    simple CSV file, you can parse it using JavaScript string manipulation tools or
    regular expressions, splitting by newlines (`\n`) to select each row, and then
    splitting by the delimiter to select each data cell within each row.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中没有内置的 CSV 解析器，但如果你有一个非常小且简单的 CSV 文件，你可以使用 JavaScript 字符串操作工具或正则表达式来解析它，通过换行符（`\n`）分割以选择每一行，然后通过分隔符分割以选择每一行中的数据单元格。
- en: 'Larger data files are more complex, since the preceding code depends on a specific
    format and does not deal with commas inside quoted strings, missing data, and
    so on. In this case, you should use a CSV parser. Most examples in this book use
    the PapaParse CSV parser ([papaparse.com](http://papaparse.com)) by Matt Holt,
    which is open source and free. The following code shows how to convert CSV into
    a JavaScript object using PapaParse:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的数据文件更复杂，因为前面的代码依赖于特定的格式，并且没有处理引号字符串内的逗号、缺失数据等问题。在这种情况下，你应该使用 CSV 解析器。本书中的大多数示例使用由
    Matt Holt 开发的 PapaParse CSV 解析器 ([papaparse.com](http://papaparse.com))，它是开源的且免费的。以下代码展示了如何使用
    PapaParse 将 CSV 转换为 JavaScript 对象：
- en: '[PRE83]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If you parsed the example CSV file at the beginning of this section, you will
    receive an array of objects, and you can list the contents (in the JavaScript
    console) using the following code (`Examples/example-15.html`):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你解析了本节开头示例中的 CSV 文件，你将收到一个对象数组，你可以使用以下代码（`Examples/example-15.html`）列出其内容（在
    JavaScript 控制台中）：
- en: '[PRE84]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The + before the last two properties converts them into numbers. If you don't
    do that they will be loaded as strings, even though they are numbers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个属性前的加号将它们转换为数字。如果你不这样做，即使它们是数字，它们也会被加载为字符串。
- en: Loading multiple files
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载多个文件
- en: 'Sometimes you need files from different sources that need to be loaded and
    then manipulated within a page. You load these using `Promise.all()`, as shown
    next. The code in the promise will only be executed when all the files are loaded
    (`Examples/example-16.html`):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要从不同的来源获取文件，这些文件需要在页面上加载并操作。你可以使用`Promise.all()`来加载这些文件，如下所示。Promise中的代码只有在所有文件都加载完成后才会执行（`Examples/example-16.html`）：
- en: '[PRE85]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Displaying a map
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示地图
- en: 'Without any charting library, using just standard JavaScript, you can load
    a JSON file and draw a world map using Canvas. The data is a special JSON format
    that stores geographical shapes: GeoJSON. Its general structure is as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用任何图表库，仅使用标准JavaScript，你可以加载一个JSON文件，并使用Canvas绘制世界地图。数据是特殊的JSON格式，用于存储地理形状：GeoJSON。其一般结构如下：
- en: '[PRE86]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Using JavaScript, you can load this file, parse it, and access each longitude
    and latitude pair. Then you can scale the values so that they fit into the coordinate
    system of your Canvas, and draw each shape using Canvas path commands. This is
    done in the following code (`Examples/example-17.html`):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript，你可以加载这个文件，解析它，并访问每个经纬度对。然后你可以调整这些值，使它们适合你的Canvas坐标系统，并使用Canvas路径命令绘制每个形状。这是在以下代码中完成的（`Examples/example-17.html`）：
- en: '[PRE87]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The result is shown as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/a15b5ae7-16a4-44ac-a0bb-31508fd50cc3.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a15b5ae7-16a4-44ac-a0bb-31508fd50cc3.png)'
- en: A world map created using GeoJSON, JavaScript, and Canvas code
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GeoJSON、JavaScript和Canvas代码创建的世界地图
- en: Extracting and transforming data
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取和转换数据
- en: If you are lucky enough to find your data in CSV, XML, or JSON, you can load
    it and start using it right away. But what if your data is only available as HTML
    tables, or worse, as a PDF file? In these cases, you need to extract your data
    and transform it into a usable format.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够幸运，能在CSV、XML或JSON中找到你的数据，你可以立即加载并开始使用。但如果你的数据仅以HTML表格的形式提供，或者更糟糕的是，以PDF文件的形式提供呢？在这些情况下，你需要提取你的数据并将其转换为可用的格式。
- en: If it's a very simple HTML table, sometimes you can select it and copy and paste
    it into a spreadsheet and preserve the rows and columns. Then you can export it
    as a CSV. Sometimes you will need to do extra work, perhaps removing garbage characters,
    styles, and unnecessary columns. This is risky, since you may also lose data or
    introduce errors during the process.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个非常简单的HTML表格，有时你可以选择它并将其复制粘贴到电子表格中，以保留行和列。然后你可以将其导出为CSV。有时你可能需要做额外的工作，比如删除垃圾字符、样式和不需要的列。这是有风险的，因为你可能在处理过程中丢失数据或引入错误。
- en: Online tools
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线工具
- en: 'You can also use online tools that try to convert HTML tables into XML, CSV,
    and JSON. Let''s try an example. The NASA JPL site has a Web page containing data
    about the moon and the planets in our solar system ([nssdc.gsfc.nasa.gov/planetary/factsheet](http://nssdc.gsfc.nasa.gov/planetary/factsheet)).
    To use that data, you will need to have it in a standard format such as JSON,
    CSV, or XML, but it''s only available as an HTML table, shown as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用在线工具，尝试将HTML表格转换为XML、CSV和JSON。让我们试一个例子。NASA JPL网站有一个包含关于月球和太阳系内行星数据的网页([nssdc.gsfc.nasa.gov/planetary/factsheet](http://nssdc.gsfc.nasa.gov/planetary/factsheet))。要使用这些数据，你需要将其转换为标准格式，如JSON、CSV或XML，但它只以HTML表格的形式提供，如下所示：
- en: '![](img/117a42aa-2a25-49c4-a2e5-adf0c11e2f03.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/117a42aa-2a25-49c4-a2e5-adf0c11e2f03.png)'
- en: An HTML table containing data that can be used in a chart
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 包含可用于图表的数据的HTML表格
- en: 'Let''s first try an online conversion service. Searching for HTML-to-CSV conversion,
    I found an online conversion service at at `www.convertcsv.com` with several CSV
    conversion tools. Open the HTML Table to CSV link and either paste the source
    code in the input box, or provide its URL. There are some options you can configure,
    such as choosing the delimiter. Click on the Convert HTML to CSV button, and the
    following text will appear in the output box:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先尝试一个在线转换服务。搜索HTML到CSV转换，我在`www.convertcsv.com`找到了一个在线转换服务，有几个CSV转换工具。打开HTML表格到CSV链接，然后可以在输入框中粘贴源代码，或者提供其URL。有一些选项你可以配置，例如选择分隔符。点击“将HTML转换为CSV”按钮，以下文本将出现在输出框中：
- en: '[PRE88]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is valid CSV, but some fields were interpreted as strings, not numbers
    (some diameters, for example). You might also wish to remove some unnecessary
    rows, such as the last one, or data you don't need. You can edit the file later
    and write a script to fix the numbers using regular expressions. Download the
    result and save it in a file, and then try loading the file using JavaScript.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的 CSV 文件，但一些字段被解释为字符串，而不是数字（例如，一些直径）。你可能还希望删除一些不必要的行，例如最后一行，或者你不需要的数据。你可以在以后编辑文件并编写一个脚本，使用正则表达式修复数字。下载结果并将其保存到文件中，然后尝试使用
    JavaScript 加载该文件。
- en: Since this is a third-party online service, I can't guarantee it will still
    exist when you read this book, but you should find similar services that perform
    the same conversion. If not, you can always write an extraction script yourself.
    A good tool for that is *XPath*, supported by many extraction libraries and browsers,
    described in the next section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个第三方在线服务，我无法保证你在阅读这本书时它仍然存在，但你应该能找到执行相同转换的类似服务。如果找不到，你也可以自己编写一个提取脚本。用于此目的的一个好工具是
    *XPath*，它被许多提取库和浏览器支持，将在下一节中描述。
- en: Extracting data with XPath
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XPath 提取数据
- en: 'Since HTML is a structure document, you can use a computer program to navigate
    that structure and extract selected text nodes, attributes, and elements. Most
    Web extraction tools are based on XPath: an XML standard that can be used to navigate
    in a XML structure and select elements, attributes, and text nodes using path
    notation. Although HTML is not as strict as XML, it has similar structures that
    can be represented as XPath paths and is supported by many Web scraping tools.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 HTML 是一个结构化文档，你可以使用计算机程序来导航这个结构并提取选定的文本节点、属性和元素。大多数网络提取工具都是基于 XPath 的：这是一个
    XML 标准，可以用来在 XML 结构中导航并使用路径符号选择元素、属性和文本节点。尽管 HTML 不像 XML 那样严格，但它有类似的可以表示为 XPath
    路径的结构，并且被许多网络抓取工具支持。
- en: 'For example, the first lines of the previous web page have the following structure:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上一页面的前几行具有以下结构：
- en: '[PRE89]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'It''s not XML or XHTML, since attributes are not within quotes and tags don''t
    close, but you can still use XPath to extract data from it. This path will give
    you the title:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是 XML 或 XHTML，因为属性不在引号内，标签也没有关闭，但你仍然可以使用 XPath 从它中提取数据。此路径将给出标题：
- en: '[PRE90]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Any one of these one will return the `bgcolor` attribute (its name and value)
    from the body tag:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下任何一个都可以从 body 标签返回 `bgcolor` 属性（其名称和值）：
- en: '[PRE91]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This one will return the contents of the `<H1>` header:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将返回 `<H1>` 标题的内容：
- en: '[PRE92]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This one is tricky. If this was XML, it would be `/html/head/p/hr/H1`, because
    all XML tags must close, but HTML parsers automatically close the `<p>` and `<hr>`
    tags because there can''t be an `<h1>` header inside them. HTML is also case insensitive,
    so using `H1` or `h1` doesn''t make any difference with these parsers. Still,
    this may still confuse some parsers. You can play it safe by using:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点棘手。如果这是 XML，它将是 `/html/head/p/hr/H1`，因为所有 XML 标签都必须关闭，但 HTML 解析器会自动关闭 `<p>`
    和 `<hr>` 标签，因为其中不能有 `<h1>` 标题。HTML 也不区分大小写，所以使用 `H1` 或 `h1` 对这些解析器来说没有区别。尽管如此，这仍然可能会让一些解析器感到困惑。你可以通过使用以下方法来确保安全：
- en: '[PRE93]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `//` or double slash means that between `<head>` and `<H1>` there can be
    any number of levels. This is compatible with the XML or HTML absolute path.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`//` 或双斜杠表示在 `<head>` 和 `<H1>` 之间可以有任意数量的层级。这与 XML 或 HTML 绝对路径兼容。'
- en: 'You can experiment with XPath using your browser''s JavaScript console, writing
    XPath expressions inside `$x(expression)`. Let''s try it out using the *Planetary
    Fact Sheet* page. Open the page in your browser and then open a console window,
    and type the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用浏览器中的 JavaScript 控制台来实验 XPath，在 `$x(expression)` 内写入 XPath 表达式。让我们用 *行星事实表*
    页面来试一试。在浏览器中打开页面，然后打开一个控制台窗口，并输入以下内容：
- en: '[PRE94]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This will select all the tables in the document. In this case, there is only
    one. You can also view the source code or inspect the page to discover the absolute
    path:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择文档中的所有表格。在这种情况下，只有一个。你也可以查看源代码或检查页面以发现绝对路径：
- en: '[PRE95]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Enter this command and the console will reveal the HTML fragment corresponding
    to your selection. Now let''s select the row that contains diameters. It''s the
    third row in the table. You can ignore the existing `<thead>` or `<tbody>` tags
    using the `//`. XPath counts child nodes starting with 1, not 0 as in JavaScript.
    The command returns a single `<tr>` element in an array. We can extract it using
    `[0]`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 输入此命令，控制台将显示与你的选择对应的HTML片段。现在让我们选择包含直径的行。它是表格中的第三行。你可以忽略现有的`<thead>`或`<tbody>`标签，使用`//`。XPath从1开始计数子节点，而不是JavaScript中的0。命令返回一个包含单个`<tr>`元素的数组。我们可以使用`[0]`来提取它：
- en: '[PRE96]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This will select the following fragment:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择以下片段：
- en: '[PRE97]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To select the diameter of the earth, you need to add one more path step:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择地球的直径，你需要添加一个额外的路径步骤：
- en: '[PRE98]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The result is as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE99]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To extract the text, you need to include the `text()` function at the end of
    the XPath expression. You also need to extract the data from the `$x()` function
    result, using the `data` property:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取文本，你需要在XPath表达式的末尾包含`text()`函数。你还需要从`$x()`函数的结果中提取数据，使用`data`属性：
- en: '[PRE100]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This will return the result as a string. You can then use regular expressions
    to remove the comma and then convert the result to a number:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个字符串结果。然后你可以使用正则表达式删除逗号，然后将结果转换为数字：
- en: '[PRE101]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You might want to automate that with a programming library if you need to extract
    lots of data, such as all the planetary diameters. The `$x()` command only works
    in the browser console, but many programming languages support XPath libraries
    and APIs. You can also use tools such as Scrapy (in Python) or testing tools such
    as Selenium (in several languages) that support XPath selectors for extracting
    data from HTML.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要提取大量数据，例如所有行星的直径，你可能想使用编程库来自动化这个过程。`$x()`命令仅在浏览器控制台中有效，但许多编程语言支持XPath库和API。你也可以使用像Scrapy（Python中）或Selenium（多种语言中）这样的工具，这些工具支持XPath选择器，可以从HTML中提取数据。
- en: XPath is a very powerful data extraction language, and this was only a very
    brief introduction. But there are also alternatives, such as XQuery (another XML
    standard with a query syntax) and CSS selectors (used by *JQuery* and also supported
    by Scrapy and Selenium).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: XPath是一种非常强大的数据提取语言，这只是一个非常简短的介绍。但也有一些替代方案，例如XQuery（另一种具有查询语法的XML标准）和CSS选择器（由*JQuery*使用，也由Scrapy和Selenium支持）。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a refresher on several fundamental technology concepts
    that will help you create visualizations with Chart.js. Even though Chart.js tries
    to hide all the underlying complexity from you, it is still a JavaScript library
    and basic knowledge of JavaScript, DOM, and CSS are important.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了几个基本的技术概念，这些概念将帮助你使用Chart.js创建可视化。尽管Chart.js试图隐藏所有底层复杂性，但它仍然是一个JavaScript库，对JavaScript、DOM和CSS的基本知识仍然很重要。
- en: 'This chapter also described the main data formats used for statistical data:
    CSV, XML, and JSON. It also described how to load external files in these formats
    and how to parse them. Additionally, you learned some ways to obtain data not
    in these formats by extracting it from HTML pages.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还描述了用于统计数据的常用数据格式：CSV、XML和JSON。它还描述了如何加载这些格式的外部文件以及如何解析它们。此外，你还了解了一些从HTML页面中提取非这些格式数据的方法。
- en: In the next chapter, we will begin using Chart.js to create data visualizations.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始使用Chart.js创建数据可视化。
