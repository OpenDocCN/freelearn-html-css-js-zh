- en: Chapter 3. Creational Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。创建型设计模式
- en: Creational design patterns in object-oriented programming are design patterns
    that are to be applied during the instantiation of objects. In this chapter, we'll
    be talking about patterns in this category.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，创建型设计模式是在对象实例化期间应用的设计模式。在本章中，我们将讨论这一类别的模式。
- en: 'Consider we are building a rocket, which has payload and one or more stages:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在建造一个具有有效载荷和一个或多个阶段的火箭：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In old-fashioned JavaScript, there are two major approaches to building such
    a rocket:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的JavaScript中，有两种主要的方法来构建这样的火箭：
- en: Constructor with `new` operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new`运算符的构造函数
- en: Factory function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂函数
- en: 'For the first approach, things could be like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，事情可能如下所示：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And for the second approach, it could be like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种方法，它可能如下所示：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From a certain angle, they are doing pretty much the same thing, but semantically
    they differ a lot. The constructor approach suggests a strong association between
    the building process and the final product. The factory function, on the other
    hand, implies an interface of its product and claims the ability to build such
    a product.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个角度来看，它们几乎在做同样的事情，但在语义上差异很大。构造函数方法建议构建过程与最终产品之间有很强的关联。另一方面，工厂函数则暗示了其产品的接口，并声称有能力构建这样的产品。
- en: However, neither of the preceding implementations provides the flexibility to
    modularly assemble rockets based on specific needs; this is what creational design
    patterns are about.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述两种实现都没有提供根据特定需求模块化组装火箭的灵活性；这正是创建型设计模式所涉及的。
- en: 'In this chapter, we''ll cover the following creational patterns:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下创建型模式：
- en: '**Factory method**: By using abstract methods of a factory instead of the constructor
    to build instances, this allows subclasses to change what''s built by implementing
    or overriding these methods.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法**：通过使用工厂的抽象方法而不是构造函数来构建实例，这允许子类通过实现或覆盖这些方法来改变构建的内容。'
- en: '**Abstract factory**: Defining the interface of compatible factories and their
    *products*. Thus by changing the factory passed, we can change the family of built
    products.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂**：定义兼容工厂及其**产品**的接口。因此，通过更改传递的工厂，我们可以更改构建产品的家族。'
- en: '**Builder**: Defining the *steps* of building complex objects, and changing
    what''s built either by changing the sequence of steps, or using a different builder
    implementation.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Builder**：定义构建复杂对象的**步骤**，并通过改变步骤的顺序或使用不同的Builder实现来改变构建的内容。'
- en: '**Prototype**: Creating objects by cloning parameterized prototypes. Thus by
    replacing these prototypes, we may build different products.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prototype**：通过克隆参数化的原型来创建对象。因此，通过替换这些原型，我们可以构建不同的产品。'
- en: '**Singleton**: Ensuring only one instance (under a certain scope) will be created.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：确保（在某个范围内）只创建一个实例。'
- en: It is interesting to see that even though the factory function approach to creating
    objects in JavaScript looks primitive, it does have parts in common with some
    patterns we are going to talk about (although applied to different scopes).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，尽管在JavaScript中创建对象的工厂函数方法看起来很原始，但它确实与我们将要讨论的一些模式有共同之处（尽管应用于不同的范围）。
- en: Factory method
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法
- en: Under some scenarios, a class cannot predict exactly what objects it will create,
    or its subclasses may want to create more specified versions of these objects.
    Then, the Factory Method Pattern can be applied.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个类无法准确预测它将创建哪些对象，或者其子类可能想要创建这些对象的更具体的版本。然后，可以应用工厂方法模式。
- en: 'The following picture shows the possible structure of the Factory Method Pattern
    applied to creating rockets:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了将工厂方法模式应用于创建火箭的可能结构：
- en: '![Factory method](img/image_03_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![工厂方法](img/image_03_001.jpg)'
- en: A **factory method** is a method of a factory that builds objects. Take building
    rockets as an example; a factory method could be a method that builds either the
    entire rocket or a single component. One factory method might rely on other factory
    methods to build its target object. For example, if we have a `createRocket` method
    under the `Rocket` class, it would probably call factory methods like `createStages`
    and `createPayload` to get the necessary components.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂方法**是一种工厂构建对象的方法。以建造火箭为例；一个工厂方法可以是构建整个火箭或单个组件的方法。一个工厂方法可能依赖于其他工厂方法来构建其目标对象。例如，如果我们有一个在`Rocket`类下的`createRocket`方法，它可能会调用像`createStages`和`createPayload`这样的工厂方法来获取必要的组件。'
- en: The Factory Method Pattern provides some flexibility upon reasonable complexity.
    It allows extendable usage by implementing (or overriding) specific factory methods.
    Taking `createStages` method, for example, we can create a one-stage rocket or
    a two-stage rocket by providing different `createStages` method that return one
    or two stages respectively.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式在合理的复杂性上提供了一定的灵活性。它通过实现（或覆盖）特定的工厂方法来允许可扩展的使用。以`createStages`方法为例，我们可以通过提供不同的`createStages`方法来创建单级火箭或双级火箭，分别返回一个或两个阶段。
- en: Participants
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of a typical Factory Method Pattern implementation include
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 典型工厂方法模式实现的参与者包括以下内容：
- en: 'Product: `Rocket`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品：`Rocket`
- en: Define an abstract class or an interface of a rocket that will be created as
    the product.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个将要创建为产品的火箭的抽象类或接口。
- en: 'Concrete product: `FreightRocket`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体产品：`FreightRocket`
- en: Implement a specific rocket product.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实现特定的火箭产品。
- en: 'Creator: `RocketFactory`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建者：`RocketFactory`
- en: Define the optionally abstract factory class that creates products.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定义可选的抽象工厂类以创建产品。
- en: 'Concrete creator: `FreightRocketFactory`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体创建者：`FreightRocketFactory`
- en: Implement or overrides specific factory methods to build products on demand.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实现或覆盖特定的工厂方法以按需构建产品。
- en: Pattern scope
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: The Factory Method Pattern decouples `Rocket` from the constructor implementation
    and makes it possible for subclasses of a factory to change what's built accordingly.
    A concrete creator still cares about what exactly its components are and how they
    are built. But the implementation or overriding usually focuses more on each component,
    rather than the entire product.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式将`Rocket`与其构造函数实现解耦，并使得工厂的子类可以根据需要进行相应的构建更改。具体的创建者仍然关心其组件的确切内容和构建方式。但实现或覆盖通常更多地关注每个组件，而不是整个产品。
- en: Implementation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Let''s begin with building a simple one-stage rocket that carries a 0-weight
    payload as the default implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个简单的单级火箭开始，该火箭携带一个默认的0重量有效载荷作为基本实现：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We start with creating components. We will simply return a payload with 0 weight
    for the factory method `createPayload` and one single stage with one single engine
    for the factory method `createStages`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建组件开始。对于工厂方法`createPayload`，我们将简单地返回一个重量为0的有效载荷，对于工厂方法`createStages`，我们将返回一个单级，带有一个单独的引擎：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After implementing methods to create the components of a rocket, we are going
    to put them together with the factory method `buildRocket`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了创建火箭组件的方法之后，我们将使用工厂方法`buildRocket`将它们组合在一起：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we have the blueprint of a simple rocket factory, yet with certain extensibilities.
    To build a rocket (that does nothing so far), we just need to instantiate this
    very factory and call its `buildRocket` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了简单火箭工厂的蓝图，但具有一定的可扩展性。要构建一个火箭（目前什么也不做），我们只需要实例化这个工厂并调用它的`buildRocket`方法：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we are going to build two-stage freight rockets that send satellites into
    orbit. Thus, there are some differences compared to the basic factory implementation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建双级货运火箭，将卫星送入轨道。因此，与基本工厂实现相比，有一些不同之处。
- en: 'First, we have a different payload, satellites, instead of a 0-weight placeholder:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有不同的有效载荷、卫星，而不是一个0重量的占位符：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Second, we now have two stages, probably with different specifications. The
    first stage is going to have four engines:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们现在有两个阶段，可能具有不同的规格。第一级将配备四个引擎：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While the second stage has only one:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 而第二级只有一个：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we have what this new freight rocket would look like in mind, let''s extend
    the factory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经心中有数，这个新的货运火箭将是什么样子，让我们扩展工厂：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Here we are using the *type alias* of a *tuple* to represent the stages sequence
    of a freight rocket, namely the first and second stages. To find out more about
    type aliases, please refer to [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用*tuple*的类型别名来表示货运火箭的阶段序列，即第一级和第二级。要了解更多关于类型别名的信息，请参阅[https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)。
- en: 'As we added the `id` property to `Satellite`, we might need a counter for each
    instance of the factory, and then create every satellite with a unique ID:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为`Satellite`添加了`id`属性，我们可能需要为工厂的每个实例提供一个计数器，然后为每个卫星创建一个唯一的ID：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s move on and implement the `createStages` method that builds first and
    second stage of the rocket:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并实现`createStages`方法，该方法构建火箭的第一级和第二级：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Comparing to the original implementation, you may have noticed that we've automatically
    decoupled specific stage building processes from assembling them into constructors
    of different stages. It is also possible to apply another creational pattern for
    the initiation of every stage if it helps.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始实现相比，你可能已经注意到，我们已经自动将特定阶段构建过程与将它们组装成不同阶段的构造函数解耦。如果有助于的话，也可以应用另一个创建模式来初始化每个阶段。
- en: Consequences
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: In the preceding implementation, the factory method `buildRocket` handles the
    outline of the building steps. We were lucky to have the freight rocket in the
    same structure as the very first rocket we had defined.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，工厂方法`buildRocket`处理了构建步骤的大纲。我们很幸运，货运火箭与最初定义的第一个火箭在结构上是相同的。
- en: 'But that won''t always happen. If we want to change the class of products (`Rocket`),
    we''ll have to override the entire `buildRocket` with everything else but the
    class name. This looks frustrating but it can be solved, again, by decoupling
    the creation of a rocket instance from the building process:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种情况并不总是发生。如果我们想改变产品类（`Rocket`），我们就必须重写整个`buildRocket`，除了类名之外的所有内容。这看起来很令人沮丧，但可以通过将火箭实例的创建与构建过程解耦来解决：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Thus we can change the rocket class by overriding the `createRocket` method.
    However, the return type of the `buildRocket` of a subclass (for example, `FreightRocketFactory`)
    is still `Rocket` instead of something like `FreightRocket`. But as the object
    created is actually an instance of `FreightRocket`, it is valid to cast the type
    by type assertion:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过重写`createRocket`方法来改变火箭类。然而，子类（例如`FreightRocketFactory`）的`buildRocket`方法的返回类型仍然是`Rocket`而不是像`FreightRocket`这样的类型。但是，由于创建的对象实际上是`FreightRocket`的实例，通过类型断言进行类型转换是有效的：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The trade-off is a little type safety, but that can be eliminated using generics.
    Unfortunately, in TypeScript what you get from a generic type argument is just
    a type without an actual value. This means that we may need another level of abstraction
    or other patterns that can use the help of type inference to make sure of everything.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 权衡是略微牺牲类型安全，但可以使用泛型来消除。不幸的是，在TypeScript中，从泛型类型参数中得到的只是一个类型而没有实际值。这意味着我们可能需要另一个抽象级别或其他可以使用类型推断帮助确保一切的图案。
- en: The former option would lead us to the Abstract Factory Pattern.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个选项将引导我们走向抽象工厂模式。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Type safety could be one reason to consider when choosing a pattern but usually,
    it will not be decisive. Please note we are not trying to switch a pattern for
    this single reason, but just exploring.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全可能是选择模式时需要考虑的一个因素，但通常，它不会是决定性的。请注意，我们并不是试图仅仅因为这个单一原因就切换模式，我们只是在探索。
- en: Abstract Factory
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: 'The Abstract Factory Pattern usually defines the interfaces of a collection
    of factory methods, without specifying concrete products. This allows an entire
    factory to be replaceable, in order to produce different products following the
    same production outline:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式通常定义了一组工厂方法的接口，而不指定具体产品。这允许整个工厂可替换，以便按照相同的生产大纲生产不同的产品：
- en: '![Abstract Factory](img/image_03_002.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂](img/image_03_002.jpg)'
- en: 'The details of the products (components) are omitted from the diagram, but
    do notice that these products belong to two parallel families: `ExperimentalRocket`
    and `FreightRocket`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 产品（组件）的细节在图中省略，但请注意，这些产品属于两个平行的家族：`ExperimentalRocket`和`FreightRocket`。
- en: Different from the Factory Method Pattern, the Abstract Factory Pattern extracts
    another part called **client** that take cares of shaping the outline of the building
    process. This makes the factory part focused more on producing each component.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与工厂方法模式不同，抽象工厂模式提取了另一个称为**客户端**的部分，负责塑造构建过程的大纲。这使得工厂部分更专注于生产每个组件。
- en: Participants
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of a typical Abstract Factory Pattern implementation include
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 典型抽象工厂模式实现的参与者包括以下内容：
- en: '**Abstract factory**: `RocketFactory`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂**：`RocketFactory`'
- en: Defines the *industrial standards* of a factory which provide interfaces for
    manufacturing components or complex products.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 定义工厂的*工业标准*，该工厂提供制造组件或复杂产品的接口。
- en: '**Concrete factory**: `ExperimentalRocketFactory`, `FreightRocketFactory`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体工厂**：`ExperimentalRocketFactory`，`FreightRocketFactory`'
- en: Implements the interfaces defined by the abstract factory and builds concrete
    products.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实现由抽象工厂定义的接口并构建具体产品。
- en: '**Abstract products**: `Rocket`, `Payload`, `Stage[]`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象产品**：`Rocket`，`Payload`，`Stage[]`'
- en: Define the interfaces of the products the factories are going to build.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 定义工厂将要构建的产品接口。
- en: '**Concrete products**: `ExperimentalRocket`/`FreightRocket`, `ExperimentalPayload`/`Satellite`,
    and so on.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体产品**：`ExperimentalRocket`/`FreightRocket`，`ExperimentalPayload`/`Satellite`等等。'
- en: Presents actual products that are manufactured by a concrete factory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 展示由具体工厂制造的实际情况产品。
- en: '**Client**:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：'
- en: Arranges the production process across factories (only if these factories conform
    to *industrial standards*).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在工厂之间安排生产过程（仅当这些工厂符合*工业标准*时）。
- en: Pattern scope
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Abstract Factory Pattern makes the abstraction on top of different concrete
    factories. At the scope of a single factory or a single branch of factories, it
    just works like the Factory Method Pattern. However, the highlight of this pattern
    is to make a whole family of products interchangeable. A good example could be
    components of themes for a UI implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式在多个具体工厂之上进行了抽象。在单个工厂或单个工厂分支的范围内，它就像工厂方法模式一样工作。然而，这个模式的高光之处在于使整个产品系列可互换。一个很好的例子可以是UI实现的主题组件。
- en: Implementation
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In the Abstract Factory Pattern, it is the client interacting with a concrete
    factory for building integral products. However, the concrete class of products
    is decoupled from the client during design time, while the client cares only about
    what a factory and its products look like instead of what exactly they are.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象工厂模式中，客户端与具体工厂交互以构建整体产品。然而，在设计时，产品的具体类与客户端解耦，而客户端只关心工厂及其产品的外观，而不是它们确切是什么。
- en: 'Let''s start by simplifying related classes to interfaces:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先简化相关的类到接口：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And of course the abstract factory itself is:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，抽象工厂本身是：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The building steps are abstracted from the factory and put into the client,
    but we still need to implement it anyway:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 建造步骤从工厂抽象出来并放入客户端，但我们仍然需要实现它：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we have the same issue we previously had when we implemented the Factory
    Method Pattern. As different concrete factories build different rockets, the class
    of the product changes. However, now we have generics to the rescue.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们遇到了我们在实现工厂方法模式时遇到的问题。由于不同的具体工厂构建不同的火箭，产品的类发生了变化。然而，现在我们有泛型来拯救我们。
- en: 'First, we need a `RocketFactory`  interface with a generic type parameter that
    describes a concrete rocket class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个带有泛型类型参数的`RocketFactory`接口，该参数描述了一个具体的火箭类：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And second, update the `buildRocket` method of the client to support generic
    factories:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，更新客户端的`buildRocket`方法以支持泛型工厂：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Thus, with the help of the type system, we will have rocket type inferred based
    on the type of a concrete factory, starting with `ExperimentalRocket` and `ExperimentalRocketFactory`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，借助类型系统，我们将根据具体工厂的类型推断出火箭类型，从`ExperimentalRocket`和`ExperimentalRocketFactory`开始：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we call the `buildRocket` method of a client with an instance of `ExperimentalRocketFactory`,
    the return type will automatically be `ExperimentalRocket`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用一个`ExperimentalRocketFactory`的实例调用客户端的`buildRocket`方法，返回类型将自动是`ExperimentalRocket`：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before we can complete the implementation of the `ExperimentalRocketFactory` object,
    we need to define concrete classes for the products of the family:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成`ExperimentalRocketFactory`对象的实现之前，我们需要为家族产品定义具体的类：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Trivial initializations of payload and stage are omitted for more compact content.
    The same kinds of omission may be applied if they are not necessary for this book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内容更紧凑，省略了有效载荷和阶段的简单初始化。如果它们对于这本书不是必要的，可以应用相同类型的省略。
- en: 'And now we may define the factory methods of this concrete factory class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义这个具体工厂类的工厂方法：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s move on to another concrete factory that builds a freight rocket and
    products of its family, starting with the rocket components:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨另一个具体的工厂，该工厂制造货运火箭及其家族产品，从火箭组件开始：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Continue with the rocket itself:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论火箭本身：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the structures or classes of the freight rocket family defined, we are
    ready to implement its factory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了货运火箭家族的结构或类之后，我们就可以实现其工厂了：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we once again have two families of rockets and their factories, and we
    can use the same client to build different rockets by passing different factories:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次拥有两个火箭家族及其工厂，并且我们可以通过传递不同的工厂来使用相同的客户端构建不同的火箭：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Consequences
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: The Abstract Factory Pattern makes it easy and smooth to change the entire family
    of products. This is the direct benefit brought by the factory level abstraction.
    As a consequence, it also brings other benefits, as well as some disadvantages
    at the same time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式使得改变整个产品家族变得容易且顺畅。这是工厂级别抽象带来的直接好处。因此，它也带来了其他好处，同时也带来了一些缺点。
- en: On the one hand, it provides better compatibility within the products in a specific
    family. As the products built by a single factory are usually meant to work together,
    we can assume that they tend to cooperate more easily.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，它提供了在特定家族产品内的更好兼容性。由于单个工厂构建的产品通常旨在协同工作，我们可以假设它们更容易合作。
- en: But on the other hand, it relies on a common outline of the building process,
    although for a well-abstracted building process, this won't always be an issue.
    We can also parameterize factory methods on both concrete factories and the client
    to make the process more flexible.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一方面，它依赖于构建过程的共同轮廓，尽管对于良好的抽象构建过程，这通常不会成为问题。我们还可以在具体工厂和客户端上参数化工厂方法，使过程更加灵活。
- en: Of course, an abstract factory does not have to be a pure interface or an abstract
    class with no methods implemented. An implementation in practice should be decided
    based on detailed context.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，抽象工厂不一定是纯接口或没有实现任何方法的抽象类。实际实现应根据详细上下文来决定。
- en: Although the Abstract Factory Pattern and Factory Method Pattern have abstractions
    of different levels, what they encapsulate are similar. For building a product
    with multiple components, the factories split the products into components to
    gain flexibility. However, a fixed family of products and their internal components
    may not always satisfy the requirements, and thus we may consider the Builder
    Pattern as another option.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管抽象工厂模式和工厂方法模式具有不同级别的抽象，但它们封装的内容是相似的。对于构建具有多个组件的产品，工厂将产品分解为组件以获得灵活性。然而，固定家族的产品及其内部组件可能并不总是满足要求，因此我们可以考虑将建造者模式作为另一种选择。
- en: Builder
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者
- en: While Factory Patterns expose the internal components (such as the payload and
    stages of a rocket), the Builder Pattern encapsulates them by exposing only the
    building steps and provides the final products directly. At the same time, the
    Builder Pattern also encapsulates the internal structures of a product. This makes
    it possible for a more flexible abstraction and implementation of building complex
    objects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当工厂模式暴露内部组件（如火箭的负载和阶段）时，建造者模式通过仅暴露构建步骤来封装它们，并直接提供最终产品。同时，建造者模式还封装了产品的内部结构。这使得更灵活地抽象和实现构建复杂对象成为可能。
- en: 'The Builder Pattern also introduces a new role called **director**, as shown
    in the following diagram. It is quite like the client in the Abstract Factory
    Pattern, although it cares only about build steps or pipelines:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式还引入了一个新的角色，称为**导演**，如下面的图所示。它与抽象工厂模式中的客户端非常相似，尽管它只关心构建步骤或管道：
- en: '![Builder](img/image_03_003.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Builder](img/image_03_003.jpg)'
- en: Now the only constraint from `RocketBuilder` that applies to a product of its
    subclass is the overall shape of a `Rocket`. This might not bring a lot of benefits
    with the `Rocket` interface we previously defined, which exposes some details
    of the rocket that the clients (by clients I mean those who want to send their
    satellites or other kinds of payload to space) may not care about that much. For
    these clients, what they want to know might just be which orbit the rocket is
    capable of sending their payloads to, rather than how many and what stages this
    rocket has.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从`RocketBuilder`对子类产品施加的唯一约束是`Rocket`的整体形状。这可能不会带来很多好处，因为我们之前定义的`Rocket`接口暴露了一些火箭的细节，而客户端（我指的是那些想要将卫星或其他类型的有效载荷送入太空的人）可能不太关心这些细节。对于这些客户端，他们可能想知道的只是火箭能够将有效载荷送入哪个轨道，而不是火箭有多少级以及具体是哪些级。
- en: Participants
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of a typical Builder Pattern implementation include the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 典型建造者模式实现的参与者包括以下内容：
- en: '**Builder**: `RocketBuilder`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建造者**：`RocketBuilder`'
- en: Defines the interface of a builder that builds products.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个构建产品的构建器接口。
- en: '**Concrete builder**: `FalconBuilder`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体建造者**：`FalconBuilder`'
- en: Implements methods that build parts of the products, and keeps track of the
    current building state.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实现构建产品部分的方法，并跟踪当前的构建状态。
- en: '**Director**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导演**'
- en: Defines the steps and collaborates with builders to build products.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 定义步骤并与构建者协作以构建产品。
- en: '**Final product**: `Falcon`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终产品**：`Falcon`'
- en: The product built by a builder.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由构建者构建的产品。
- en: Pattern scope
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范畴
- en: The Builder Pattern has a similar scope to the Abstract Factory Pattern, which
    extracts abstraction from a complete collection of operations that will finally
    initiate the products. Compared to the Abstract Factory Pattern, a builder in
    the Builder Pattern focuses more on the building steps and the association between
    those steps, while the Abstract Factory Pattern puts that part into the clients
    and makes its factory focus on producing components.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式与抽象工厂模式具有相似的范畴，它从将最终启动产品的完整操作集合中提取抽象。与抽象工厂模式相比，建造者模式在构建步骤及其关联上更加关注，而抽象工厂模式将这部分放在客户端，并使工厂专注于生产组件。
- en: Implementation
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'As now we are assuming that stages are not the concern of the clients who want
    to buy rockets to carry their payloads, we can remove the `stages` property from
    the general `Rocket` interface:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在假设阶段不是想要购买火箭以携带其有效载荷的客户所关心的问题，我们可以从通用`Rocket`接口中删除`stages`属性：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is a rocket family called sounding rocket that sends probes to near space.
    And this means we don''t even need to have the concept of stages. `SoundingRocket`
    is going to have only one `engine` property other than `payload` (which will be
    a `Probe`), and the only engine will be a `SolidRocketEngine`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为“ sounding rocket”的火箭家族，它将探测器发送到近太空。这意味着我们甚至不需要有阶段的概念。`SoundingRocket`将只有一个`engine`属性（除了`payload`，它将是一个`Probe`），唯一的发动机将是一个`SolidRocketEngine`：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But still we need rockets to send satellites, which usually use `LiquidRocketEngine`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然需要火箭来发送卫星，这些卫星通常使用`LiquidRocketEngine`：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And we might want to have the corresponding  `LiquidRocketStage` abstract class
    that handles refuelling:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想有一个相应的`LiquidRocketStage`抽象类来处理加注：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can update  `FreightRocketFirstStage` and `FreightRocketSecondStage`
    as subclasses of `LiquidRocketStage`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`FreightRocketFirstStage`和`FreightRocketSecondStage`更新为`LiquidRocketStage`的子类：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `FreightRocket` will remain the same as it was:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`FreightRocket`将保持不变：'
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And, of course, there is the builder. This time, we are going to use an abstract
    class that has the builder partially implemented, with generics applied:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有构建者。这次，我们将使用一个抽象类，该类部分实现了构建器，并应用了泛型：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There's actually no abstract method in this abstract class. One of the reasons
    is that specific steps might be optional to certain builders. By implementing
    no-op methods, the subclasses can just leave the steps they don't care about empty.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个抽象类中实际上没有抽象方法。其中一个原因是特定步骤可能对某些构建者来说是可选的。通过实现no-op方法，子类可以简单地留出它们不关心的步骤为空。
- en: 'Here is the implementation of the `Director` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Director`类的实现：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be cautious, without explicitly providing a building context, the builder instance
    relies on the building pipelines being queued (either synchronously or asynchronously).
    One way to avoid risk (especially with asynchronous operations) is to initialize
    a builder instance every time you prepare a rocket.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎起见，如果没有明确提供构建上下文，构建实例将依赖于构建管道正在排队（无论是同步还是异步）。避免风险的一种方法（尤其是在异步操作中）是每次准备火箭时都初始化一个构建实例。
- en: 'Now it''s time to implement concrete builders, starting with `SoundingRocketBuilder`,
    which builds a `SoundingRocket` with only one `SolidRocketEngine`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现具体的构建器了，从`SoundingRocketBuilder`开始，它使用只有一个`SolidRocketEngine`构建`SoundingRocket`：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There are several notable things in this implementation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，有几个值得注意的地方：
- en: The `addStages` method relies on the previously added payload to add an engine
    with the correct thrust specification.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addStages`方法依赖于之前添加的有效载荷来添加具有正确推力规格的发动机。'
- en: The `refuel` method is not overridden (so it remains no-op) because a solid
    rocket engine does not need to be refueled.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refuel`方法没有被重写（因此它仍然是no-op），因为固体火箭发动机不需要加注。'
- en: 'We''ve sensed a little about the context provided by a builder, and it could
    have a significant influence on the result. For example, let''s take a look at
    `FreightRocketBuilder`. It could be similar to `SoundingRocket` if we don''t take
    the `addStages` and `refuel` methods into consideration:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对构建者提供的一些上下文有所了解，这可能会对结果产生重大影响。例如，让我们看看`FreightRocketBuilder`。如果我们不考虑`addStages`和`refuel`方法，它可能与`SoundingRocket`相似：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Assume that a payload that weighs less than `1000` takes only one stage to
    send into space, while payloads weighing more take two or more stages:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设重量小于`1000`的有效载荷只需要一个阶段就能送入太空，而重量更大的有效载荷需要两个或更多阶段：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When it comes to refueling, we can even decide how much to refuel based on
    the weight of the payloads:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到加油时，我们甚至可以根据有效载荷的重量来决定加油量：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can prepare different rockets ready to launch, with different builders:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以准备不同制造商的不同火箭，准备发射：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Consequences
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: As the Builder Pattern takes greater control of the product structures and how
    the building steps influence each other, it provides the maximum flexibility by
    subclassing the builder itself, without changing the director (which plays a similar
    role to a client in the Abstract Factory Pattern).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于建造者模式对产品结构和构建步骤如何相互影响有更大的控制权，它通过自身子类化建造者提供了最大的灵活性，而不改变导演（在抽象工厂模式中扮演类似客户端的角色）。
- en: Prototype
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: As JavaScript is a prototype-based programming language, you might be using
    prototype related patterns all the time without knowing it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript是一种基于原型的编程语言，你可能会在不自知的情况下一直使用与原型相关的模式。
- en: 'We''ve talked about an example in the Abstract Factory Pattern, and part of
    the code is like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在抽象工厂模式中讨论了一个例子，部分代码如下：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Sometimes we may need to add a subclass just for changing the class name while
    performing the same `new` operation. Instances of a single class usually share
    the same methods and properties, so we can `clone` one existing instance for new
    instances to be created. That is the concept of a prototype.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要添加一个子类，只是为了在执行相同的`new`操作时更改类名。单类实例通常共享相同的方法和属性，因此我们可以克隆一个现有实例以创建新的实例。这就是原型的概念。
- en: 'But in JavaScript, with the prototype concept built-in, `new Constructor()`
    does basically what a `clone` method would do. So actually a constructor can play
    the role of a concrete factory in some way:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但在JavaScript中，由于内置了原型概念，`new Constructor()`基本上会做克隆方法会做的事情。所以实际上构造函数可以在某种程度上扮演具体工厂的角色：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this privilege, we can parameterize product or component classes as part
    of other patterns and make creation even more flexible.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个特权，我们可以将产品或组件类作为其他模式的一部分进行参数化，使创建更加灵活。
- en: 'There is something that could easily be ignored when talking about the Prototype
    Pattern in JavaScript: cloning with the state. With the `class` syntax sugar introduced
    in ES6, which hides the prototype modifications, we may occasionally forget that
    we can actually modify prototypes directly:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论JavaScript中的原型模式时，可能会容易忽略一些东西：带有状态的克隆。随着ES6中引入的`class`语法糖，它隐藏了原型修改，我们有时可能会忘记我们实际上可以直接修改原型：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, the `derived` object will keep the `state` of the `base` object. This could
    be useful when you want to create copies of a specific instance, but keep in mind
    that properties in a prototype of these copies are not the *own properties* of
    these cloned objects.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`derived`对象将保持`base`对象的`state`。当你想要创建特定实例的副本但又不希望这些副本的原型属性成为克隆对象的*自有属性*时，这可能很有用。
- en: Singleton
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Singleton
- en: There are scenarios in which only one instance of the specific class should
    ever exist, and that leads to Singleton Pattern.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景中，应该只存在特定类的单个实例，这导致了单例模式。
- en: Basic implementations
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本实现
- en: 'The simplest singleton in JavaScript is an object literal; it provides a quick
    and cheap way to create a unique object:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中最简单的单例是一个对象字面量；它提供了一种快速且经济的方式创建一个唯一的对象：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But sometimes we might want private variables:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时我们可能需要私有变量：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or we want to take the advantage of an anonymous constructor function or class
    expression in ES6:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们想利用ES6中的匿名构造函数或类表达式：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the `private` modifier only has an effect at compile time, and
    simply disappears after being compiled to JavaScript (although of course its accessibility
    will be kept in `.d.ts`).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`private`修饰符仅在编译时有效，编译成JavaScript后（尽管当然其可访问性将保留在`.d.ts`中）将简单地消失。
- en: 'However, it is possible to have the requirements for creating new instances
    of "singletons" sometimes. Thus a normal class will still be helpful:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时可能需要创建“单例”新实例的要求。因此，一个普通的类仍然是有帮助的：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Another benefit brought by this approach is lazy initialization: the object
    only gets initialized when it gets accessed the first time.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法带来的另一个好处是延迟初始化：对象仅在第一次访问时才被初始化。
- en: Conditional singletons
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件单例
- en: Sometimes we might want to get "singletons" based on certain conditions. For
    example, every country usually has only one capital city, thus a capital city
    could be treated as a singleton under the scope of the specific country.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能希望根据某些条件获取“单例”。例如，每个国家通常只有一个首都，因此首都可以在特定国家的范围内被视为单例。
- en: The condition could also be the result of context rather than explicit arguments.
    Assuming we have a class `Environment` and its derived classes, `WindowsEnvironment`
    and `UnixEnvironment`, we would like to access the correct environment singleton
    across platforms by using `Environment.default` and apparently, a selection could
    be made by the `default` getter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 条件也可能是上下文的结果，而不是显式的参数。假设我们有一个类`Environment`及其派生类`WindowsEnvironment`和`UnixEnvironment`，我们希望通过使用`Environment.default`在各个平台上访问正确的环境单例，显然，可以通过`default`获取器进行选择。
- en: For more complex scenarios, we might want a registration-based implementation
    to make it extendable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的场景，我们可能需要一个基于注册的实现来使其可扩展。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've talked about several important creational design patterns
    including the Factory Method, Abstract Factory, Builder, Prototype, and Singleton.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了包括工厂方法、抽象工厂、建造者、原型和单例在内的几个重要的创建型设计模式。
- en: Starting with the Factory Method Pattern, which provides flexibility with limited
    complexity, we also explored the Abstract Factory Pattern, the Builder Pattern
    and the Prototype Pattern, which share similar levels of abstraction but focus
    on different aspects. These patterns have more flexibility than the Factory Method
    Pattern, but are more complex at the same time. With the knowledge of the idea
    behind each of the patterns, we should be able to choose and apply a pattern accordingly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从工厂方法模式开始，它以有限的复杂性提供灵活性，我们还探讨了抽象工厂模式、建造者模式和原型模式，这些模式具有相似级别的抽象，但关注不同的方面。这些模式比工厂方法模式具有更大的灵活性，但同时也更复杂。了解每个模式背后的理念，我们应该能够相应地选择和应用模式。
- en: While comparing the differences, we also found many things in common between
    different creational patterns. These patterns are unlikely to be isolated from
    others and some of them can even collaborate with or complete each other.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较不同创建型模式之间的差异时，我们也发现了它们之间许多共同之处。这些模式不太可能孤立于其他模式之外，其中一些甚至可以相互协作或补充。
- en: In the next chapter, we'll continue to discuss structural patterns that help
    to form large objects with complex structures.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论有助于形成具有复杂结构的对象的组合型模式。
