- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Creating Your First 3D Scene with Three.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Three.js创建你的第一个3D场景
- en: 'In recent years, modern browsers have acquired powerful features that can be
    accessed directly from **JavaScript**. You can easily add video and audio with
    **HTML5 tags** and create interactive components through the use of **HTML5 Canvas**.
    Together with HTML5, modern browsers also support **WebGL**. With WebGL, you can
    directly make use of the processing resources of your graphics card and create
    high-performance 2D and 3D computer graphics. Using WebGL directly from JavaScript
    to create and animate 3D scenes is a very complex, verbose, and error-prone process.
    **Three.js** is a library that makes this a lot easier. The following list shows
    some of the things that are very easy to do with Three.js:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在近年来，现代浏览器获得了可以直接从**JavaScript**访问的强大功能。你可以轻松地使用**HTML5标签**添加视频和音频，并通过使用**HTML5
    Canvas**创建交互式组件。与现代浏览器一起，HTML5还支持**WebGL**。使用WebGL，你可以直接利用你的图形卡的处理器资源，创建高性能的2D和3D计算机图形。直接从JavaScript使用WebGL创建和动画化3D场景是一个非常复杂、冗长且容易出错的流程。**Three.js**是一个库，它使这个过程变得容易得多。以下列表显示了使用Three.js可以轻松完成的一些事情：
- en: Create simple and complex 3D geometries and render them in any browser
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单和复杂的3D几何形状，并在任何浏览器中渲染它们
- en: Animate and move objects through a 3D scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3D场景中动画化和移动对象
- en: Apply textures and materials to your objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纹理和材质应用到你的对象上
- en: Use different light sources to illuminate the scene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的光源照亮场景
- en: Use models from 3D modeling software and export generated models into these
    programs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用3D建模软件中的模型，并将生成的模型导出到这些程序中
- en: Add advanced post-processing effects to your 3D scene
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的3D场景添加高级后处理效果
- en: Create and work with custom shaders
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并使用自定义着色器
- en: Create, visualize, and animate point clouds
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、可视化和动画点云
- en: Create **virtual reality** (**VR**) and **augmented reality** (**AR**) scenes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**虚拟现实**（**VR**）和**增强现实**（**AR**）场景
- en: 'With a couple of lines of JavaScript (or **TypeScript**, as we’ll see later
    in this book), you can create anything, from simple 3D models to photorealistic
    scenes, all of which are rendered in real time in the browser. For instance, *Figure
    1**.1* shows an example of what can be done with Three.js (you can see the animation
    for yourself by opening [https://threejs.org/examples/webgl_animation_keyframes.html](https://threejs.org/examples/webgl_animation_keyframes.html)
    in your browser):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几行JavaScript（或**TypeScript**，正如我们将在本书后面看到的），你可以创建任何东西，从简单的3D模型到逼真的场景，所有这些都在浏览器中以实时渲染。例如，*图1.1*展示了使用Three.js可以完成的事情（您可以通过在浏览器中打开[https://threejs.org/examples/webgl_animation_keyframes.html](https://threejs.org/examples/webgl_animation_keyframes.html)来亲自查看动画）：
- en: '![Figure 1.1 – Three.js rendered and animated scene](img/Figure_1.1_B18726.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – Three.js渲染和动画场景](img/Figure_1.1_B18726.jpg)'
- en: Figure 1.1 – Three.js rendered and animated scene
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Three.js渲染和动画场景
- en: In this chapter, we’ll directly dive into Three.js and create a couple of examples
    that will show you how Three.js works, and that you can use to play around with
    and get to know Three.js a little bit. We won’t dive into all the technical details
    yet; you'll learn about those in the following chapters. By the end of this chapter,
    you’ll be able to create a scene, and run and explore all the examples in this
    book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将直接进入Three.js，创建几个示例，展示Three.js的工作原理，并让你可以用来玩耍和了解Three.js。我们不会深入所有技术细节；你将在接下来的章节中了解这些。到本章结束时，你将能够创建一个场景，并运行和探索本书中的所有示例。
- en: We’ll start this book with a short introduction to Three.js and then quickly
    move on to the first few examples and code samples. Before we get started, let’s
    quickly look at the most important browsers out there and their support for WebGL
    (and WebGPU).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个简短的Three.js介绍开始，然后快速进入前几个示例和代码示例。在我们开始之前，让我们快速查看最重要的浏览器及其对WebGL（和WebGPU）的支持情况。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All modern browsers on desktop, as well as on mobile, currently support WebGL.
    Older versions of IE (those before version 11) won’t be able to run WebGL-based
    applications. On mobile, most browsers support WebGL. So, with WebGL, you can
    create interactive 3D visualizations that run very well on desktops, as well as
    on mobile devices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有桌面上的现代浏览器以及移动设备上的浏览器都支持WebGL。IE的旧版本（11版本之前的版本）将无法运行基于WebGL的应用程序。在移动设备上，大多数浏览器支持WebGL。因此，使用WebGL，你可以在桌面和移动设备上创建运行良好的交互式3D可视化。
- en: In this book, we’ll focus on the WebGL-based renderer provided by Three.js.
    There is, however, also a CSS 3D-based renderer, which provides an easy API to
    create CSS 3D-based 3D scenes. A big advantage of using a CSS 3D-based approach
    is that this standard is supported on all mobile and desktop browsers and allows
    you to render HTML elements in a 3D space. We won’t go into the details of this
    browser but will show an example in [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122),
    *Points* *and Sprites*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将专注于Three.js提供的基于WebGL的渲染器。然而，也存在一个基于CSS 3D的渲染器，它提供了一个简单的API来创建基于CSS
    3D的3D场景。使用基于CSS 3D的方法的一个大优点是，这个标准在所有移动和桌面浏览器上都得到支持，并允许你在3D空间中渲染HTML元素。我们不会深入探讨这个浏览器的细节，但将在[*第7章*](B18726_07.xhtml#_idTextAnchor122)的*点和精灵*示例中展示一个例子。
- en: Besides WebGL, a new standard for using the GPU to render in your browser called
    WebGPU is being developed, which will provide even better performance than WebGL
    and, in the future, become the new standard. When you use Three.js, you don’t
    have to worry about this change. Three.js already partly supports WebGPU and as
    that standard matures, so will the support of this standard in Three.js. So, everything
    you create with Three.js will also work out of the box with WebGPU.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了WebGL之外，一个名为WebGPU的新标准正在开发中，它将提供比WebGL更好的性能，并在未来成为新的标准。当你使用Three.js时，你不必担心这个变化。Three.js已经部分支持WebGPU，随着该标准的成熟，Three.js对该标准的支持也将成熟。因此，你用Three.js创建的一切也将与WebGPU无缝工作。
- en: 'In this first chapter, you’ll directly create a 3D scene and be able to run
    it on a desktop or mobile device. We’ll explain the core concepts of Three.js,
    and if there are more advanced topics, we’ll mention in what chapter we’ll explain
    these in more detail. In this chapter, we’ll create two different scenes. The
    first one will show a basic geometry rendered in Three.js, as shown in the following
    figure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将直接创建一个3D场景，并能够在桌面或移动设备上运行它。我们将解释Three.js的核心概念，如果有更高级的主题，我们将在哪一章中更详细地解释这些内容。在本章中，我们将创建两个不同的场景。第一个场景将展示在Three.js中渲染的基本几何形状，如图下所示：
- en: '![Figure 1.2 – Default geometries rendered](img/Figure_1.2_B18726.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 默认几何形状渲染](img/Figure_1.2_B18726.jpg)'
- en: Figure 1.2 – Default geometries rendered
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 默认几何形状渲染
- en: 'After that, we’ll also quickly show you how you can load external models, and
    how easy it is to create realistic-looking scenes. The result of the second example
    will look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们还会快速展示如何加载外部模型，以及创建看起来逼真的场景是多么容易。第二个示例的结果将如下所示：
- en: '![Figure 1.3 – Rendering an externally loaded model](img/Figure_1.3_B18726.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 渲染外部加载的模型](img/Figure_1.3_B18726.jpg)'
- en: Figure 1.3 – Rendering an externally loaded model
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 渲染外部加载的模型
- en: Before you start working on these examples, in the next couple of sections,
    we’ll look at the tools you need to easily work with Three.js and how you can
    download the examples shown in this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始这些示例之前，在接下来的几个部分中，我们将探讨你需要的工具，以及如何下载本书中展示的示例。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Requirements for using Three.js
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Three.js的要求
- en: Downloading the source code and examples used in this book
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载本书中使用的源代码和示例
- en: Testing and experimenting with the examples
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和实验示例
- en: Rendering and viewing a 3D object
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染和查看3D对象
- en: Introducing a couple of helper libraries for statistics and controlling the
    scene
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍几个用于统计和场景控制的辅助库
- en: Technical requirements
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Three.js is a JavaScript **library**, so all you need to create Three.js WebGL
    applications is a text editor and one of the supported browsers to render the
    results. I would like to recommend the following text editors, which I’ve used
    extensively over the last couple of years for various projects:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js是一个JavaScript **库**，因此你只需要一个文本编辑器和支持渲染结果的浏览器之一来创建Three.js WebGL应用程序。我推荐以下文本编辑器，我在过去几年中为各种项目广泛使用过：
- en: '**Visual Studio Code**: This free editor from Microsoft runs on all major platforms
    and provides great syntax highlighting and smart completion based on types, function
    definitions, and imported libraries. It provides a very clean interface and is
    great for working on JavaScript projects. It can be downloaded from here: [https://code.visualstudio.com/](https://code.visualstudio.com/).
    If you don’t want to download this editor, you can also just navigate to [https://vscode.dev/](https://vscode.dev/),
    which will launch an editor directly in your browser, from which you can connect
    to a GitHub repository or access directories on your local filesystem.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：这个来自微软的免费编辑器在所有主要平台上运行，提供了基于类型、函数定义和导入库的出色语法高亮和智能完成。它提供了一个非常干净的界面，非常适合JavaScript项目开发。您可以从这里下载：[https://code.visualstudio.com/](https://code.visualstudio.com/)。如果您不想下载此编辑器，也可以直接导航到[https://vscode.dev/](https://vscode.dev/)，它将在您的浏览器中直接启动一个编辑器，您可以通过它连接到GitHub仓库或访问本地文件系统上的目录。'
- en: '**WebStorm**: This editor from *JetBrains* offers great support for editing
    JavaScript. It supports code completion, automatic deployment, and JavaScript
    debugging, directly from the editor. Besides this, WebStorm has excellent GitHub
    (and other version control system) support. You can download a trial edition from
    [http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebStorm**：来自*JetBrains*的此编辑器提供了出色的JavaScript编辑支持。它支持代码补全、自动部署和JavaScript调试，直接从编辑器中进行。除此之外，WebStorm对GitHub（和其他版本控制系统）有出色的支持。您可以从[http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/)下载试用版。'
- en: '**Notepad++**: Notepad++ is a general-purpose editor that supports code highlighting
    for a wide range of programming languages. It can easily lay out and format JavaScript.
    Note that Notepad++ is only for Windows. You can download Notepad++ from [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Notepad++**：Notepad++是一个通用编辑器，支持多种编程语言的代码高亮显示。它可以轻松地布局和格式化JavaScript。请注意，Notepad++仅适用于Windows。您可以从[http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)下载Notepad++。'
- en: '**Sublime Text Editor**: Sublime is a great editor that offers very good support
    for editing JavaScript. Besides this, it provides many very helpful selections
    (such as multi-line select) and edit options, which, once you get used to them,
    provide a really good JavaScript-editing environment. Sublime can also be tested
    for free and can be downloaded from [http://www.sublimetext.com/](http://www.sublimetext.com/).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sublime Text Editor**：Sublime是一个优秀的编辑器，提供了非常好的JavaScript编辑支持。除此之外，它还提供了许多非常有用的选择（如多行选择）和编辑选项，一旦您习惯了它们，就能提供一个真正优秀的JavaScript编辑环境。Sublime可以免费测试，并可以从[http://www.sublimetext.com/](http://www.sublimetext.com/)下载。'
- en: Even if you don’t use any of these editors, there are a lot of editors available,
    both open source and commercial, that you can use to edit JavaScript and create
    your Three.js projects, since all you need is the ability to edit text. An interesting
    project you might want to look at is AWS Cloud9 ([http://c9.io](http://c9.io)).
    This is a cloud-based JavaScript editor that can be connected to a GitHub account.
    This way, you can directly access all the source code and examples from this book
    and experiment with them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不使用这些编辑器，也有很多编辑器可供选择，包括开源和商业的，您可以使用它们来编辑JavaScript并创建您的Three.js项目，因为您需要的只是文本编辑的能力。一个您可能想查看的项目是AWS
    Cloud9 ([http://c9.io](http://c9.io))。这是一个基于云的JavaScript编辑器，可以连接到GitHub账户。这样，您可以直接访问本书的所有源代码和示例，并对其进行实验。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Besides these text-based editors, which you can use to edit and experiment with
    the sources from this book, Three.js currently also provides an online editor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基于文本的编辑器，您可以使用它们来编辑和实验本书的源代码，Three.js目前还提供了一个在线编辑器。
- en: With this editor, which you can find at [http://threejs.org/editor/](http://threejs.org/editor/),
    you can create Three.js scenes using a graphical approach.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个编辑器，您可以在[http://threejs.org/editor/](http://threejs.org/editor/)找到它，通过图形化方式创建Three.js场景。
- en: I suggest picking up Visual Studio Code. It is a very lightweight editor with
    great support for JavaScript and has several other extensions that make writing
    JavaScript applications easier.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议选择Visual Studio Code。这是一个非常轻量级的编辑器，对JavaScript有很好的支持，并且有几个其他扩展，使编写JavaScript应用程序变得更加容易。
- en: 'Earlier, I mentioned that most modern web browsers support WebGL and can be
    used to run Three.js examples. I usually run my code in Firefox. The reason is
    that, often, Firefox has the best support and performance for WebGL and it has
    a great JavaScript debugger. With this debugger, as shown in the following screenshot,
    you can quickly pinpoint problems using, for instance, breakpoints and console
    output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到，大多数现代网络浏览器都支持 WebGL，并且可以用来运行 Three.js 示例。我通常在 Firefox 中运行我的代码。原因是，Firefox
    通常对 WebGL 有最好的支持和性能，并且它有一个出色的 JavaScript 调试器。使用这个调试器，如图下所示，你可以通过使用断点和控制台输出等方式快速定位问题：
- en: '![Figure 1.4 – Firefox debugger](img/Figure_1.4_B18726.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – Firefox 调试器](img/Figure_1.4_B18726.jpg)'
- en: Figure 1.4 – Firefox debugger
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – Firefox 调试器
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the examples in this book will work just as well with Chrome as they do
    with Firefox. So, if that’s your browser of choice, you can, of course, use that
    one instead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都可以像在 Firefox 中一样在 Chrome 中运行。所以，如果你选择的是这个浏览器，当然可以使用它。
- en: Throughout this book, I’ll give you pointers on debugger usage and other debugging
    tips and tricks. That’s enough by way of an introduction for now; let’s get the
    source code and start with the first scene.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将为您提供调试器使用和其他调试技巧的指导。现在就介绍到这里；让我们获取源代码，并从第一个场景开始。
- en: Getting the source code
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取源代码
- en: 'All the code for this book is available on GitHub ([https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition](https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition)).
    GitHub is a site that hosts Git repositories. You can use these to store, access,
    and version source code. There are a couple of ways that you can get the sources
    for yourself. You can do either of the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可在 GitHub 上找到 ([https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition](https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition))。GitHub
    是一个托管 Git 仓库的网站。你可以使用这些来存储、访问和版本控制源代码。你可以通过以下几种方式获取源代码：你可以做以下任何一种：
- en: Clone the Git repository. This means you use the `git` command-line tool to
    get the latest version of the sources for this book.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆 Git 仓库。这意味着你使用 `git` 命令行工具获取本书源代码的最新版本。
- en: Download and extract an archive from GitHub, which contains everything.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 下载并解压存档，其中包含所有内容。
- en: In the following two subsections, we’ll explore these options in a bit more
    detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个小节中，我们将更详细地探讨这些选项。
- en: Using git to clone the repository
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 git 克隆仓库
- en: 'One way to get all the examples is to *clone* this repository using the `git`
    command-line tool. To do this, you need to download a Git client for your operating
    system. If you’ve got an up-to-date operating system, you probably already have
    Git installed. You can quickly check this by running the following in a terminal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所有示例的一种方法是通过 `git` 命令行工具克隆此仓库。为此，你需要为你的操作系统下载一个 Git 客户端。如果你有一个最新的操作系统，你可能已经安装了
    Git。你可以在终端中快速检查这一点，如下所示：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the command isn’t installed yet, you can get a client and instructions on
    how to install it from here: [http://git-scm.com](http://git-scm.com). After installing
    Git, you can use the `git` command-line tool to clone this book’s repository.
    Open a command prompt and go to the directory where you want to download the sources.
    In that directory, run the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令尚未安装，你可以从这里获取客户端和安装说明：[http://git-scm.com](http://git-scm.com)。安装 Git 后，你可以使用
    `git` 命令行工具克隆本书的仓库。打开命令提示符并转到你想下载源代码的目录。在该目录中，运行以下命令：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After doing this, all the source code will be downloaded into the `learning-threejs-fourth`
    directory. From that directory, you can run all the examples explained throughout
    this book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，所有源代码都将下载到 `learning-threejs-fourth` 目录中。从该目录，你可以运行本书中解释的所有示例。
- en: Downloading and extracting the archive
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载和解压存档
- en: 'If you don’t want to use `git` to download the sources directly from GitHub,
    you can also download an archive. Open [https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition](https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition)
    in a browser and click on the **Code** button on the right-hand side. This will
    give you the option to download all the sources in a single ZIP file by clicking
    on the **Download** **ZIP** option:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用 `git` 直接从 GitHub 下载源代码，你也可以下载一个存档。在浏览器中打开 [https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition](https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition)，点击右侧的
    **Code** 按钮。这将给你一个选项，通过点击 **Download** **ZIP** 选项来下载所有源代码的单一 ZIP 文件：
- en: '![Figure 1.5 – Downloading the archive from GitHub](img/Figure_1.5_B18726.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 从 GitHub 下载存档](img/Figure_1.5_B18726.jpg)'
- en: Figure 1.5 – Downloading the archive from GitHub
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 从 GitHub 下载存档
- en: After extracting this to a directory of your choice, all the examples will become
    available.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将其解压到您选择的目录后，所有示例都将可用。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载示例代码文件，以获取您购买的所有
    Packt 出版物的书籍。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: Now that you’ve downloaded or cloned the source code, let’s quickly check whether
    everything is working and familiarize you with the directory structure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经下载或克隆了源代码，让我们快速检查一切是否正常工作，并熟悉目录结构。
- en: Testing and experimenting with the examples
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和实验示例
- en: The code and examples are organized per chapter and, with the examples, we will
    provide a simple integrated server that you can use to access all the examples.
    To get this server up and running, we need to install *Node.js* and *npm*. These
    tools are used to manage JavaScript packages and build JavaScript applications
    and make it easier to modularize our Three.js code and integrate existing JavaScript
    libraries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和示例按章节组织，并且，我们将提供一个简单的集成服务器，您可以使用它来访问所有示例。要启动并运行此服务器，我们需要安装 *Node.js* 和 *npm*。这些工具用于管理
    JavaScript 包和构建 JavaScript 应用程序，并使我们的 Three.js 代码模块化以及集成现有的 JavaScript 库变得更加容易。
- en: 'To install these two tools, go to [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    and select the appropriate installer for your operating system. Once installed,
    open a terminal and check whether everything is working. On my machine, the following
    versions are being used:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这两个工具，请访问 [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    并选择适合您操作系统的适当安装程序。安装完成后，打开一个终端并检查一切是否正常。在我的机器上，以下版本正在使用：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once these tools have been installed, we need to perform a few steps to get
    all the externally needed dependencies before we can build and access the examples:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这些工具，我们需要在构建和访问示例之前执行几个步骤来获取所有外部需要的依赖项：
- en: First, we need to download the external libraries used in the examples. For
    instance, Three.js is one of the dependencies we need to download.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要下载示例中使用的所有外部库。例如，Three.js 是我们需要下载的依赖项之一。
- en: 'To download all the dependencies, run the following command in the directory
    where you downloaded or extracted all the examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载所有依赖项，请在下载或提取所有示例的目录中运行以下命令：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding command will start downloading all the required JavaScript libraries
    and store these in the `node_modules` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将开始下载所有必需的 JavaScript 库并将这些存储在 `node_modules` 文件夹中。
- en: Next, we need to build the examples. Doing so will combine our source code and
    the external libraries into a single file, which we can show in the browser.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建示例。这样做会将我们的源代码和外部库合并成一个文件，我们可以在浏览器中查看。
- en: 'To build the examples using `npm`, use the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `npm` 构建示例，请使用以下命令：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that you only have to run the two preceding commands once.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您只需运行前面的两个命令一次。
- en: 'With that, all the examples will have been built and are ready for you to explore.
    To open these examples, you need a web server. To start a server, simply run the
    following command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些，所有示例都将构建完成，并准备好供你探索。要打开这些示例，你需要一个网络服务器。要启动服务器，只需运行以下命令：
- en: '[PRE5]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, you’ll probably notice that `npm` has already opened your default
    browser and shows the content of `http://localhost:8080` (if this isn’t the case,
    just open your browser of choice and navigate to `http://localhost:8080`). You’ll
    be presented with an overview of all the chapters. In each of these subfolders,
    you’ll find the examples that are explained in that chapter:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到 `npm` 已经打开了您的默认浏览器，并显示了 `http://localhost:8080` 的内容（如果这不是这种情况，只需打开您选择的浏览器并导航到
    `http://localhost:8080`）。您将看到一个所有章节的概述。在每个这些子文件夹中，您将找到该章节中解释的示例：
- en: '![Figure 1.6 – Overview of all the chapters and examples](img/Figure_1.6_B18726.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 所有章节和示例概述](img/Figure_1.6_B18726.jpg)'
- en: Figure 1.6 – Overview of all the chapters and examples
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 所有章节和示例概述
- en: 'One very interesting feature of this server is that we can now see the changes
    we make to the source code immediately reflected in the browser. If you have started
    the server by running `npm run serve`, open up the `chapter-01/geometries.js`
    example from the sources you’ve downloaded in your editor and change something;
    you’ll see that this is also changed at the same time in your browser after you
    have saved the change. This makes testing changes and fine-tuning colors and lights
    much easier. If you open the `chapter-01/geometries.js` file in your code editor,
    and you open the `http://localhost:8080/chapter-01/geometries.html` example in
    your browser, you can see this in action. In your editor, change the color of
    the cube. To do so, find the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器的一个非常有趣的特点是，我们现在可以看到我们对源代码所做的更改立即反映在浏览器中。如果你是通过运行`npm run serve`来启动服务器的，请打开你从下载的源中在编辑器中打开的`chapter-01/geometries.js`示例，并更改一些内容；你会在保存更改后看到，在浏览器中这些更改也是同时发生的。这使得测试更改和微调颜色和灯光变得容易得多。如果你在你的代码编辑器中打开`chapter-01/geometries.js`文件，并在你的浏览器中打开`http://localhost:8080/chapter-01/geometries.html`示例，你就可以看到这个功能是如何工作的。在你的编辑器中，更改立方体的颜色。为此，找到以下代码：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Change it to the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为以下内容：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, when you save the file, you’ll immediately see that the color of the cube
    in the browser changes, without you having to refresh the browser or do anything
    else.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你保存文件时，你会立即看到浏览器中立方体的颜色发生了变化，而无需刷新浏览器或做其他任何事情。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The setup we’re working with in this book is one of many different approaches
    you can use to develop web applications. Alternatively, you can include Three.js
    (and other libraries) directly in your HTML file or use an approach with `import-maps`,
    as is done with the example on the Three.js website. All of these have advantages
    and disadvantages. For this book, we’ve chosen an approach that makes it easy
    to experiment with the sources and get direct feedback in the browser, and closely
    resembles how these kinds of applications are built normally.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中所使用的设置是众多可用于开发Web应用的多种方法之一。或者，你也可以直接在HTML文件中包含Three.js（以及其他库），或者使用与Three.js网站上的示例相同的`import-maps`方法。所有这些方法都有其优缺点。对于本书，我们选择了一种方法，这使得在浏览器中实验源代码变得容易，并且与这些类型的应用程序通常的构建方式非常相似。
- en: A good starting point to understand how everything works together is by looking
    at the HTML file that we opened in the browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解所有这些是如何协同工作的，一个很好的起点是查看我们在浏览器中打开的HTML文件。
- en: Exploring the HTML structure for Three.js applications
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Three.js应用程序的HTML结构
- en: 'In this section, we’ll look at the source of the `geometries.html` file. You
    can do this by looking at the source in the browser or opening the file from the
    `dist/chapter-1` folder in the same location where you downloaded the source for
    this book:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看`geometries.html`文件的源代码。你可以通过在浏览器中查看源代码或从与本书源代码下载相同位置的`dist/chapter-1`文件夹中打开文件来完成此操作：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code is generated when you run the `npm run build` step. This will combine
    all the sources and external libraries you’ve used into separate source files
    (called bundles) and add them to this page. So, you don’t need to do this yourself.
    The first three `<script>` tags refer to any of the external libraries we use.
    Later in the book, we’ll introduce other libraries such as `<style>` and `<body>`.
    `<style>` is used to disable any margins in the page, so we can use the complete
    browser viewport to show our 3D scenes. Furthermore, we’ll add the 3D scene programmatically
    into an empty `<body>` element, which we’ll explain in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是在你运行`npm run build`步骤时生成的。这将把所有你使用的源代码和外部库组合成单独的源文件（称为包），并将它们添加到这个页面中。所以，你不需要自己这样做。前三个`<script>`标签指的是我们使用的任何外部库。在本书的后面部分，我们将介绍其他库，如`<style>`和`<body>`。`<style>`用于禁用页面上的任何边距，这样我们就可以使用完整的浏览器视口来显示我们的3D场景。此外，我们将通过编程方式将3D场景添加到空的`<body>`元素中，我们将在下一节中解释。
- en: 'If you do want to add custom HTML elements here, you can, of course, do that.
    In the root of the downloaded code, you’ll find a `template.html` file, which
    is used by the build process to create the individual HTML files for the examples.
    Anything you add there will be added to all the examples. We won’t dive too deep
    into how this works since that’s outside the scope of this book. However, if you
    want to learn more about how this works, a couple of good resources on *webpack*
    (which we use for this) are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想在这里添加自定义的HTML元素，当然可以。在下载的代码根目录下，你会找到一个`template.html`文件，该文件在构建过程中被用来为示例创建单独的HTML文件。你添加到那里的任何内容都将被添加到所有示例中。我们不会深入探讨其工作原理，因为这超出了本书的范围。然而，如果你想了解更多关于其工作原理的信息，以下是一些关于*webpack*（我们用于此）的优质资源：
- en: 'The getting started with webpack guide: [https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/).
    This site contains a tutorial that explains the reason why we need webpack for
    JavaScript development, and how the basic concepts work.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack入门指南：[https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/)。这个网站包含一个教程，解释了为什么我们需要webpack进行JavaScript开发，以及基本概念是如何工作的。
- en: 'Information on the *HTML webpack plugin*: [https://github.com/jantimon/html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin).
    Here, you can find information on the webpack plugin we use to combine the sources
    into the separate HTML pages you see when you open the browser after running `npm
    run build` and then running `npm` `run serve`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于*HTML webpack插件*的信息：[https://github.com/jantimon/html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)。在这里，你可以找到关于我们使用的webpack插件的信息，该插件用于将源代码组合成你在运行`npm
    run build`并在之后运行`npm run serve`后打开浏览器时看到的单独HTML页面。
- en: Note that we don’t have to explicitly initialize our scene or call JavaScript.
    Whenever we open this page and the `geometries.js` file is loaded, the JavaScript
    from that file will run and create our 3D scene.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不必显式初始化场景或调用JavaScript。每次我们打开这个页面，并且`geometries.js`文件被加载时，该文件中的JavaScript就会运行并创建我们的3D场景。
- en: Now that we’ve set up the basic structure, we can create and render our first
    scene.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了基本结构，我们可以创建并渲染我们的第一个场景。
- en: Rendering and viewing a 3D object
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和查看3D对象
- en: 'In this section, you’ll create your first scene, which is a simple 3D scene
    that looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建你的第一个场景，这是一个看起来像这样的简单3D场景：
- en: '![Figure 1.7 – First scene with two standard geometries](img/Figure_1.8_B18726.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 包含两个标准几何形状的第一个场景](img/Figure_1.8_B18726.jpg)'
- en: Figure 1.7 – First scene with two standard geometries
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 包含两个标准几何形状的第一个场景
- en: In the preceding screenshot, you can see two objects that rotate. These objects
    are called *meshes*. A mesh describes the geometry of an object – that is, its
    shape – and contains information about the material of the object. A mesh determines
    how the shape gets shown on screen through traits such as color, or whether the
    object is shiny or transparent.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到两个旋转的对象。这些对象被称为*网格*。网格描述了对象的几何形状——即其形状——并包含有关对象材料的信息。网格决定了形状如何通过如颜色等特性在屏幕上显示，或者对象是闪亮的还是透明的。
- en: 'In the previous screenshot, we can identify three of these meshes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以识别出这三个网格：
- en: '| **Object** | **Description** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **对象** | **描述** |'
- en: '| **Plane** | This is a two-dimensional rectangle that serves as the ground
    area. In *Figure 1**.7*, you can see this since it shows the shadows cast by the
    two meshes. We will create this as a very large rectangle so that you don’t see
    any edges. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **平面** | 这是一个二维矩形，作为地面区域。在图1.7中，你可以看到它，因为它显示了两个网格的阴影。我们将创建一个非常大的矩形，这样你就看不到任何边缘。
    |'
- en: '| **Cube** | This is a three-dimensional cube and is shown on the left of *Figure
    1**.7*. It is rendered in *red*. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **立方体** | 这是一个三维立方体，如图1.7左边的所示。它以红色渲染。 |'
- en: '| **Torus knot** | This is the *TorusKnot* you can see to the right of *Figure
    1**.7*. This one is rendered in *green*. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **环面结** | 这是图1.7右边可以看到的*环面结*。这个以绿色渲染。'
- en: Figure 1.8 – Overview of the objects in the scene
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 场景中对象的概述
- en: To get all this on screen, we need to perform a couple of steps, which we’ll
    explain in the upcoming sections.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所有这些显示在屏幕上，我们需要执行几个步骤，我们将在接下来的章节中解释。
- en: Setting up the scene
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置场景
- en: Each Three.js application at least needs a camera, a scene, and a renderer.
    The scene is the container that holds all the objects (meshes, cameras, and lights),
    the camera determines what part of the scene is shown when it is rendered, and
    the renderer takes care of creating the output on the screen, taking into account
    all the information from the meshes, cameras, and lights in the scene.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Three.js应用程序至少需要一个相机、一个场景和一个渲染器。场景是包含所有对象（网格、相机和灯光）的容器，相机确定渲染时显示场景的哪个部分，渲染器负责在屏幕上创建输出，考虑到场景中网格、相机和灯光的所有信息。
- en: 'All the code we’ll be discussing can be found in the `chapter-1/getting-started.js`
    file. The basic structure of this file is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的所有代码都可以在 `chapter-1/getting-started.js` 文件中找到。这个文件的基本结构如下：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you look through the preceding steps, you might have noticed that a lot of
    these steps are the same for each scene you create. Since we’ve got a lot of examples
    in this book that show different features of Three.js, we’ll extract this code
    into a couple of helper files. We’ll show how we did this at the end of this chapter.
    For now, we will walk through the different steps and introduce you to the basic
    components of a Three.js scene.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾前面的步骤，可能会注意到这些步骤对于你创建的每个场景都是相同的。由于这本书中有许多示例展示了 Three.js 的不同功能，我们将把这段代码提取到几个辅助文件中。我们将在本章末尾展示如何做到这一点。现在，我们将逐步介绍不同的步骤，并介绍
    Three.js 场景的基本组件。
- en: 'First, we must create a `THREE.Scene`. This is a basic container that will
    hold all of the meshes, lights, and cameras and has a couple of simple properties,
    which we’ll explore in more depth in the next chapter:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个 `THREE.Scene`。这是一个基本的容器，将包含所有的网格、灯光和相机，并具有一些简单的属性，我们将在下一章中更深入地探讨：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we will create the container object that will hold all our objects, set
    the background color of this scene to white (`0xffffff`), and enable the fog effect
    in this scene. With fog enabled, objects further away from the camera will slowly
    get hidden by fog.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个容器对象，用于存放所有我们的对象，将此场景的背景颜色设置为白色（`0xffffff`），并在此场景中启用雾效。启用雾效后，远离相机的对象将逐渐被雾隐藏。
- en: 'The next step is creating the camera and the renderer:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建相机和渲染器：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we created a `PerspectiveCamera`, which determines what
    part of the scene is rendered. Don’t worry too much about the parameters at this
    point, since we’ll discuss those in detail in [*Chapter 3*](B18726_03.xhtml#_idTextAnchor040),
    *Working with Light Sources in Three.js*. We also positioned the camera at the
    specified *x-*, *y-*, and *z-*oordinates. The camera will, by default, look at
    the center of the scene (which is `0`, `0`, `0`), so we don’t need to change anything
    for that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个 `PerspectiveCamera`，它决定了场景的哪个部分被渲染。不要过于担心这一点，因为我们将在 [*第 3 章*](B18726_03.xhtml#_idTextAnchor040)
    中详细讨论这些参数，*在 Three.js 中处理光源*。我们还把相机定位在指定的 *x-、y-、z-* 坐标上。默认情况下，相机将朝向场景的中心（即 `0`、`0`、`0`），所以我们不需要为此做任何改变。
- en: 'In this code fragment, we also created a `WebGLRenderer`, which we will use
    to render the view from the camera on the scene. Ignore the other properties for
    now; we’ll explain these in the next few chapters when we dive into the details
    of `WebGLRenderer` and how you can fine-tune the colors and work with shadows.
    One interesting part to notice is `document.body.appendChild(renderer.domElement)`.
    This step adds an HTML `canvas` element to the page, which shows the output of
    the renderer. You can see this when you inspect the page in your browser:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们还创建了一个 `WebGLRenderer`，我们将使用它来渲染相机在场景中的视图。现在忽略其他属性；我们将在下一章中详细介绍 `WebGLRenderer`
    的细节，以及如何调整颜色和与阴影一起工作。一个值得注意的有趣部分是 `document.body.appendChild(renderer.domElement)`。这一步将一个
    HTML `canvas` 元素添加到页面中，显示渲染器的输出。你可以在浏览器中检查页面时看到这一点：
- en: '![Figure 1.9 – Canvas added by Three.js](img/Figure_1.9_B18726.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 由 Three.js 添加的画布](img/Figure_1.9_B18726.jpg)'
- en: Figure 1.9 – Canvas added by Three.js
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 由 Three.js 添加的画布
- en: 'At this point, we’ve got an empty `THREE.Scene`, a `THREE.PerspectiveCamera`,
    and a `THREE.WebGLRenderer`. If we add some objects to the scene, we can already
    show some output on the screen. Before we do this, though, we’ll add a couple
    of additional components:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个空的 `THREE.Scene`、一个 `THREE.PerspectiveCamera` 和一个 `THREE.WebGLRenderer`。如果我们向场景添加一些对象，我们就可以在屏幕上显示一些输出。不过，在我们这样做之前，我们还会添加一些额外的组件：
- en: '**OrbitControls**: This will allow you to use the mouse to rotate and pan around
    the scene'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OrbitControls**：这将允许你使用鼠标旋转和平移场景'
- en: '**Lights**: This allows us to use some more advanced materials, cast shadows,
    and generally make our scene look better'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灯光**：这允许我们使用一些更高级的材质，投射阴影，并使我们的场景看起来更好'
- en: In the next section, we’ll first add the lights.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将首先添加灯光。
- en: Adding lights
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加灯光
- en: 'If we don’t have lights in the scene, most materials will be rendered in black.
    So, to see our meshes (and get shadows), we’re going to add some lights to the
    scene. In this case, we’re going to add two lights:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景中没有灯光，大多数材质将被渲染为黑色。所以，为了看到我们的网格（并获得阴影），我们需要在场景中添加一些灯光。在这种情况下，我们将添加两个灯光：
- en: '`THREE.AmbientLight`: This is just a simple light that affects everything with
    the same intensity and color.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.AmbientLight`：这只是影响一切物体强度和颜色相同的一个简单灯光。'
- en: '`THREE.DirectionalLight`: This is a light source whose rays are cast in parallel
    to one another. This is pretty much how we experience the light of the Sun.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.DirectionalLight`：这是一种光线彼此平行的光源。这正是我们体验太阳光的方式。'
- en: 'The following code fragment shows how to do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何做到这一点：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And once again, these lights can be configured in various ways, the details
    of which we’ll explain in [*Chapter 3*](B18726_03.xhtml#_idTextAnchor040). At
    this point, we’ve got all the components ready to render a scene, so let’s add
    the meshes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些灯光可以通过各种方式配置，具体细节我们将在[*第3章*](B18726_03.xhtml#_idTextAnchor040)中解释。到目前为止，我们已经准备好了所有渲染场景的组件，所以让我们添加网格。
- en: Adding the meshes
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加网格
- en: 'In the following code fragment, we create the three meshes in our scene:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们在场景中创建了三个网格：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we have created a cube, a torus knot, and the ground. All these meshes
    follow the same idea:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个立方体、一个环面结和地面。所有这些网格都遵循同样的理念：
- en: 'We create the shape – that is, the geometry of the objects: a `THREE.BoxGeometry`,
    a `THREE.TorusKnotBufferGeometry`, and a `THREE.PlaneBufferGeometry`.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建形状——即物体的几何形状：一个`THREE.BoxGeometry`，一个`THREE.TorusKnotBufferGeometry`和一个`THREE.PlaneBufferGeometry`。
- en: We create the material. In this case, we use a `THREE.MeshPhongMaterial` for
    the cube, a `THREE.MeshStandardMaterial` for the torus knot, and a `THREE.MeshLambertMaterial`
    for the ground. The color of the cube is blue, the color of the torus knot is
    greenish, and the color of the ground is white. In [*Chapter 4*](B18726_04.xhtml#_idTextAnchor056),
    *Working with Three.js Materials*, we’re going to explore all these materials,
    where they can best be used, and how to configure them.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建材质。在这种情况下，我们为立方体使用`THREE.MeshPhongMaterial`，为环面结使用`THREE.MeshStandardMaterial`，为地面使用`THREE.MeshLambertMaterial`。立方体的颜色是蓝色，环面结的颜色是绿色的，地面的颜色是白色的。在[*第4章*](B18726_04.xhtml#_idTextAnchor056)中，我们将探讨所有这些材质，它们最适合在哪里使用，以及如何配置它们。
- en: We tell Three.js that the cube and the torus knot cast shadows and that the
    ground will receive shadows.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉Three.js立方体和环面结可以投射阴影，而地面将接收阴影。
- en: Finally, from the shape and the material, we create a `THREE.Mesh`, position
    the mesh, and add it to the scene.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从形状和材质中创建一个`THREE.Mesh`，定位网格，并将其添加到场景中。
- en: 'At this point, we just have to call `renderer.render(scene, camera)`. You will
    see the result on your screen:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只需要调用`renderer.render(scene, camera)`。你将在屏幕上看到结果：
- en: '![Figure 1.10 – Geometries renderer – static](img/Figure_1.10_B18726.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图1.10 – 几何形状渲染器 – 静态](img/Figure_1.10_B18726.jpg)'
- en: Figure 1.10 – Geometries renderer – static
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 几何形状渲染器 – 静态
- en: If you’ve got the source file (`chapter-01/getting-started.js`), open it in
    your editor; now is also a good time to experiment a bit with the settings. By
    changing the `torusKnot.postion.x`, `torusKnot.position.y`, and `torusKnot.position.z`
    settings, you can move the torus knot around the scene (changes are applied after
    you save the file in the editor). You can also easily change the color of the
    meshes by changing the `color` property of the materials.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了源文件（`chapter-01/getting-started.js`），请在你的编辑器中打开它；现在也是尝试一些设置的好时机。通过改变`torusKnot.position.x`、`torusKnot.position.y`和`torusKnot.position.z`设置，你可以将环面结在场景中移动（更改将在你在编辑器中保存文件后生效）。你还可以通过改变材质的`color`属性轻松地更改网格的颜色。
- en: Adding an animation loop
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加动画循环
- en: At this point, the scene is very static. You can’t move the camera around, and
    nothing is moving. If we want to animate the scene, the first thing that we need
    to do is find some way to re-render the scene at a specific interval. Before HTML5
    and the related JavaScript APIs came along, the way to do this was by using the
    `setInterval(function,interval)` function. With `setInterval`, we could specify
    a function that, for instance, would be called every 100 milliseconds. The problem
    with this function is that it doesn’t take into account what is happening in the
    browser. If you were browsing another tab, this function would still be fired
    every couple of milliseconds. Besides that, `setInterval` isn’t synchronized when
    the the screen is redrawn. This can lead to higher CPU usage, flickering, and
    generally poor performance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，场景非常静态。你不能移动相机，也没有任何东西在移动。如果我们想对场景进行动画处理，我们首先需要找到一种方法在特定的时间间隔重新渲染场景。在HTML5和相关JavaScript
    API出现之前，我们通过使用`setInterval(function,interval)`函数来完成这个任务。使用`setInterval`，我们可以指定一个函数，例如，每100毫秒被调用一次。这个函数的问题在于它没有考虑到浏览器中的情况。如果你在浏览另一个标签页，这个函数仍然会每隔几毫秒被触发。除此之外，当屏幕重绘时，`setInterval`并不同步。这可能导致CPU使用率更高，闪烁，以及整体性能较差。
- en: Luckily, modern browsers have a solution for that with the `requestAnimationFrame`
    function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现代浏览器通过`requestAnimationFrame`函数提供了解决方案。
- en: Introducing requestAnimationFrame
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍requestAnimationFrame
- en: 'With `requestAnimationFrame`, you can specify a function that is called at
    an interval. However, you don’t define this interval. This interval is defined
    by the browser. You do any drawing you need to do in the supplied function, and
    the browser will make sure it is painted as smoothly and efficiently as possible.
    Using this is simple. We just add the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`requestAnimationFrame`，你可以指定一个在特定间隔被调用的函数。然而，你并不定义这个间隔。这个间隔由浏览器定义。你需要在提供的函数中完成任何需要的绘图，浏览器将确保尽可能平滑和高效地绘制。使用它很简单。我们只需添加以下代码：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding `animate` function, we called `requestAnimationFrame` again,
    to keep the animation going. The only thing we need to change in the code is that
    instead of calling `renderer.render` after we’ve created the complete scene, we
    call the `animate()` function once to initiate the animation. If you run this,
    you won’t see any changes yet compared to the previous example because we haven’t
    changed anything in this `animate()` function. Before we add additional functionality
    to this function though, we will introduce a small helper library called **stats.js**,
    which gives us information about the frame rate the animation is running at. This
    library, from the same author as Three.js, renders a small graph that shows us
    information about the rate at which the scene is rendered.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`animate`函数中，我们再次调用了`requestAnimationFrame`，以保持动画的持续。我们唯一需要更改的代码是，在创建完整的场景之后，我们不是调用`renderer.render`，而是调用一次`animate()`函数来启动动画。如果你运行这个示例，与上一个示例相比，你不会看到任何变化，因为我们没有在这个`animate()`函数中做任何更改。然而，在我们向这个函数添加更多功能之前，我们将介绍一个小型的辅助库**stats.js**，它提供了关于动画运行帧率的详细信息。这个库与Three.js的作者相同，它渲染一个小型图表，显示场景渲染速率的信息。
- en: 'To add these statistics, all we need to do is import the correct module and
    add it to our page:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这些统计数据，我们只需要导入正确的模块并将其添加到我们的页面中：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you leave it at this, you’ll see a nice stats counter in the top left of
    your screen, but nothing will happen. The reason is that we need to tell this
    element when we’re in the `requestAnimationFrame` loop. For this, we just need
    to add the following to our `animate` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保持这个状态，你会在屏幕左上角看到一个漂亮的统计计数器，但什么都不会发生。原因是我们需要告诉这个元素我们是否处于`requestAnimationFrame`循环中。为此，我们只需要在我们的`animate`函数中添加以下内容：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you open the `chapter-1/getting-started.html` example, you’ll see that it
    shows a **frames per second** (**FPS**) counter in the top left of your screen:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`chapter-1/getting-started.html`示例，你会看到屏幕左上角显示了一个**每秒帧数**（**FPS**）计数器：
- en: '![Figure 1.11 – FPS statistics](img/Figure_1.11_B18726.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11 – FPS统计信息](img/Figure_1.11_B18726.jpg)'
- en: Figure 1.11 – FPS statistics
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – FPS统计信息
- en: In the `chapter-1/getting-started.html` example, you can already see that the
    torus knot and cube are moving around their axes. In the following section, we’ll
    explain how you do this by extending the `animate()` function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter-1/getting-started.html`示例中，你可以看到环面结和立方体正在它们的轴上移动。在下一节中，我们将解释如何通过扩展`animate()`函数来完成这个操作。
- en: Animating the meshes
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格动画
- en: 'With `requestAnimationFrame` and the statistics configured, we’ve got a place
    to put our animation code. All we need to do is add this to the `animate()` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了`requestAnimationFrame`和统计信息后，我们就有了放置动画代码的地方。我们只需要将以下内容添加到`animate()`函数中：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That looks simple, right? What we do is increase the rotation property of each
    of the axes by 0.01 every time the `animate()` function is called, which shows
    up as the meshes smoothly rotating around all of their axes. If we change the
    position instead of the rotation around the axes, we can move the meshes around:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，对吧？我们每次调用`animate()`函数时，都会将每个轴的旋转属性增加0.01，这表现为网格在所有轴上平滑旋转。如果我们改变位置而不是围绕轴旋转，我们可以移动网格：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the cube, we have already changed the `rotation` property; now, we’re
    also going to change its `position` property in the scene. We want the cube to
    bounce from one point in the scene to another with a nice, smooth curve. For this,
    we need to change its position on the *X*-axis, as well as the *y*-axis. The `Math.cos`
    and `Math.sin` functions help us create a smooth trajectory using the `step` variable.
    I won’t go into the details of how this works here. For now, all you need to know
    is that `step+=0.04` defines the speed of the bouncing sphere. If you want to
    enable this for yourself, open up the `chapter-1/geometries.js` file and uncomment
    the section from the `animate()` function. Once you’ve done this, you’ll see something
    like this on screen, where the blue cube is dancing around the scene:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于立方体，我们已经在场景中改变了`rotation`属性；现在，我们还将改变其`position`属性。我们希望立方体在场景中的一个点到另一个点之间以平滑的曲线弹跳。为此，我们需要改变其在*X*轴和*y*轴上的位置。`Math.cos`和`Math.sin`函数帮助我们使用`step`变量创建平滑的轨迹。这里我不会详细介绍它是如何工作的。现在，你需要知道的是，`step+=0.04`定义了弹跳球体的速度。如果你想自己启用这个功能，请打开`chapter-1/geometries.js`文件，并取消注释`animate()`函数中的部分。一旦这样做，你将在屏幕上看到类似这样的效果，其中蓝色的立方体在场景中舞动：
- en: '![Figure 1.12 – Jumping blue cube](img/Figure_1.12_B18726.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图1.12 – 跳跃的蓝色立方体](img/Figure_1.12_B18726.jpg)'
- en: Figure 1.12 – Jumping blue cube
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 – 跳跃的蓝色立方体
- en: Enabling orbit controls
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用轨道控制
- en: 'If you try and move the scene around with your mouse, nothing much will happen.
    That is because we added the camera to a fixed position, and we didn’t update
    its position in the animate loop. We can, of course, do this in the same manner
    as we did to the position of the cube, but Three.js comes with several *controls*
    that allow you to easily pan around the scene and move the camera around. For
    this example, we’ll introduce `THREE.OrbitControls`. With these controls, you
    can use your mouse to move the camera around the scene and look at different objects.
    All we need to do to get this working is create a new instance of these controls,
    attach them to the camera, and call the `update` function from our animation loop:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试用鼠标移动场景，不会发生太多变化。这是因为我们给相机添加了一个固定位置，并且在动画循环中没有更新其位置。当然，我们可以像处理立方体的位置一样做这件事，但Three.js自带了几个*控制*，允许你轻松地在场景中平移并移动相机。在这个例子中，我们将介绍`THREE.OrbitControls`。有了这些控制，你可以使用鼠标在场景中移动相机并查看不同的对象。为了使这个功能正常工作，我们只需要创建这些控制的新实例，将其附加到相机上，并在动画循环中调用`update`函数：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, you can use your mouse to navigate around the scene. This is already enabled
    in the `chapter-1/getting-started.html` example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用鼠标在场景中导航。这已经在`chapter-1/getting-started.html`示例中启用：
- en: "![Figure 1.13 – Zoom\uFEFFing in with orbit controls](img/Figure_1.13_B18726.jpg)"
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图1.13 – 使用轨道控制进行缩放](img/Figure_1.13_B18726.jpg)'
- en: Figure 1.13 – Zooming in with orbit controls
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 使用轨道控制进行缩放
- en: Before wrapping up this section, we will add one more element to our basic scene.
    When working with 3D scenes, animations, colors, and properties, it often requires
    a bit of experimenting to get the correct color, animation speed, or material
    property. It would be very easy if you had a simple **GUI** that allowed you to
    change these kinds of properties on the fly. Luckily, you do!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，我们将向我们的基本场景添加一个额外的元素。当与3D场景、动画、颜色和属性一起工作时，通常需要一些实验来获得正确的颜色、动画速度或材质属性。如果你有一个简单的**GUI**，可以让你实时更改这些属性，那就太容易了。幸运的是，你确实有！
- en: Using lil-gui to control properties and make experimenting easier
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lil-gui来控制属性并简化实验
- en: 'In the previous example, we added a little bit of animation for the torus knot
    and the cube. Now, we’ll create a simple UI element that allows us to control
    the speed of the rotations and the movement. For this, we’re going to use the
    `lil-gui` library from [https://lil-gui.georgealways.com/](https://lil-gui.georgealways.com/).
    This library allows us to quickly create a simple control UI to make experimenting
    with the scene easier. It can be added as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们为环面结和立方体添加了一点点动画。现在，我们将创建一个简单的UI元素，使我们能够控制旋转的速度和移动。为此，我们将使用来自[https://lil-gui.georgealways.com/](https://lil-gui.georgealways.com/)的`lil-gui`库。这个库允许我们快速创建一个简单的控制UI，使实验场景变得更加容易。它可以按照以下方式添加：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code fragment, we created a new control element (`new GUI`)
    and configured two controls: `cubeSpeed` and `torusSpeed`. In each animation step,
    we’ll just look up the current values and use those to rotate the meshes. Now,
    we can experiment with the properties without having to switch between the browser
    and the editor. You’ll see this UI in most of the examples in this book where
    we provide it so that you can easily play around with the different options provided
    by the materials, the lights, and the other Three.js objects. In the following
    screenshot, you can see the controls you can use to control the scene in the top-right
    part of the screen:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个新的控制元素（`new GUI`）并配置了两个控制：`cubeSpeed`和`torusSpeed`。在每次动画步骤中，我们只需查找当前值并使用这些值来旋转网格。现在，我们可以实验这些属性，而无需在浏览器和编辑器之间切换。你将在本书的大多数示例中看到这个UI，我们提供它，以便你可以轻松地玩转材料、灯光和其他Three.js对象提供的不同选项。在下面的屏幕截图中，你可以看到用于控制场景的控件，位于屏幕的右上角：
- en: '![Figure 1.14 – Using controls to modify the properties of the scene](img/Figure_1.14_B18726.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图1.14 – 使用控件修改场景属性](img/Figure_1.14_B18726.jpg)'
- en: Figure 1.14 – Using controls to modify the properties of the scene
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 使用控件修改场景属性
- en: Before we move on to the last section of this chapter, here’s a quick note on
    what we’ve shown so far. You can imagine that most scenes will need pretty much
    the same setup. They all need some lights, a camera, a scene, and maybe a ground
    floor. To avoid having to add all this to each example, we’ve externalized most
    of these common elements to a set of helper libraries. That way, we can keep the
    examples nice and clean so that they only show you the code relevant to that example.
    If you’re interested in how that’s set up, you can look at the files from the
    `bootstrap` folder, which brings this approach together.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本章的最后部分之前，这里有一个关于我们迄今为止所展示内容的快速说明。你可以想象，大多数场景都需要相当相同的设置。它们都需要一些灯光、一个相机、一个场景，也许还有一个地面。为了避免在每个示例中添加所有这些，我们将大多数这些常见元素外部化到一个辅助库集中。这样，我们可以保持示例干净整洁，只展示与该示例相关的代码。如果你对如何设置感兴趣，可以查看`bootstrap`文件夹中的文件，它将这种方法整合在一起。
- en: In the previous example, we rendered some simple meshes in the scene and positioned
    them directly. Sometimes, though, it is hard to determine where to position objects,
    or how far we should rotate them. Three.js provides several different helpers
    that provide you with additional information about the scene. In the next section,
    we’ll look at a couple of these helper functions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们在场景中渲染了一些简单的网格，并直接定位它们。有时，确定物体的位置或旋转角度可能很困难。Three.js提供了几个不同的辅助工具，它们为你提供了有关场景的额外信息。在下一节中，我们将探讨这些辅助函数中的几个。
- en: Helper objects and util functions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助对象和实用函数
- en: 'Before we move on to the next chapter, we’re going to quickly introduce a couple
    of helper functions and objects. These helpers make it easier to position objects
    and see what is happening in a scene. The easiest way to see this in action is
    to open the `chapter-01/porsche.html` example in your browser:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一章之前，我们将快速介绍几个辅助函数和对象。这些辅助工具使定位物体和查看场景中的情况变得更加容易。要看到这个动作的实际效果，最简单的方法是在浏览器中打开`chapter-01/porsche.html`示例：
- en: '![Figure 1.15 – Porsche example with helper](img/Figure_1.15_B18726.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图1.15 – 带辅助工具的保时捷示例](img/Figure_1.15_B18726.jpg)'
- en: Figure 1.15 – Porsche example with helper
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 – 带辅助工具的保时捷示例
- en: 'On the right-hand side of the screen, at the bottom of the menu, you will see
    three buttons in the controls: **Toggle AxesHelper**, **Toggle GridHelper**, and
    **Toggle PolarGridHelper**. When you click on any of them, Three.js will add an
    overlay to the screen that can help you orient and position meshes, determine
    needed rotations, and check the sizes of your objects. For instance, when we toggle
    **AxesHelper**, we will see the *x-*, *y-*, and *z-a*xes in the scene:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的右侧，菜单的底部，你会看到控制区域中的三个按钮：**切换AxesHelper**、**切换GridHelper**和**切换PolarGridHelper**。当你点击任何一个按钮时，Three.js会在屏幕上添加一个覆盖层，这可以帮助你定位和定位网格，确定所需的旋转，并检查你对象的尺寸。例如，当我们切换**AxesHelper**时，我们将在场景中看到*x-*、*y-*和*z-*轴：
- en: '![Figure 1.16 – Porsche example with AxesHelper enabled](img/Figure_1.16_B18726.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图1.16 – 启用AxesHelper的保时捷示例](img/Figure_1.16_B18726.jpg)'
- en: Figure 1.16 – Porsche example with AxesHelper enabled
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16 – 启用AxesHelper的保时捷示例
- en: Note that in this example, you can see a more extensive control UI, where you
    can also control various aspects of `WebGLRenderer`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，你可以看到一个更广泛的控制用户界面，你还可以控制`WebGLRenderer`的各个方面。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That’s it for this first chapter. In this chapter, you learned how to set up
    your development environment, how to get the code, and how to get started with
    the examples provided in this book. Then, you learned that to render a scene with
    Three.js, you have to create a `THREE.Scene` object and add a camera, a light
    source, and the objects that you want to render. We also showed you how you can
    expand this basic scene by adding animations. Lastly, we added a couple of helper
    libraries. We used *lil-GUI*, which allows you to quickly create control UIs,
    and we added an FPS counter, which provided feedback on the frame rate and other
    metrics using which your scene is rendered.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第一章的全部内容。在本章中，你学习了如何设置你的开发环境，如何获取代码，以及如何开始使用本书提供的示例。然后，你学习了要使用Three.js渲染场景，你必须创建一个`THREE.Scene`对象，并添加一个相机、光源以及你想要渲染的对象。我们还展示了你如何通过添加动画来扩展这个基本场景。最后，我们添加了几个辅助库。我们使用了*lil-GUI*，它允许你快速创建控制用户界面，我们还添加了一个帧率计数器，它通过反馈帧率和其他指标来显示你的场景是如何渲染的。
- en: 'All these items will help you understand the examples in upcoming chapters
    and make it easier for you to experiment with the more advanced examples and start
    modifying those to your liking. Should stuff break or not result in what you expect
    in the next few chapters when you experiment, remember what we showed you in this
    chapter: use the JavaScript console to get additional information, add debug statements,
    use the helpers provided by Three.js, or add custom control elements.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些项目都将帮助你理解即将到来的章节中的示例，并使你更容易尝试更高级的示例，并开始根据你的喜好修改它们。如果在接下来的几章中你进行实验时，东西坏了或者没有达到你预期的结果，请记住我们在本章中展示的内容：使用JavaScript控制台获取更多信息，添加调试语句，使用Three.js提供的辅助工具，或者添加自定义控制元素。
- en: In the next chapter, we’ll expand on the basic setup shown here and you’ll learn
    more about the most important building blocks that you can use in Three.js.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展这里展示的基本设置，你将学习更多关于你可以用在Three.js中的最重要的构建块。
