- en: Chapter 3. Exploring and Interacting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 探索和交互
- en: This chapter explains how users can interact with our games. We'll also cover
    some physics and use what we've learned to create a basic first-person shooter
    game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了用户如何与我们的游戏互动。我们还将涵盖一些物理知识，并利用所学知识创建一个基本的单人第一人称射击游戏。
- en: Keyboard movement and mouse looking
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘移动和鼠标环顾四周
- en: 'In order to move our camera around, we''re going to encapsulate some state,
    so let''s define a `KeyboardControls` class in a new JavaScript file:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动我们的相机，我们将封装一些状态，所以让我们在新的JavaScript文件中定义一个`KeyboardControls`类：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the constructor, we added listeners for the `keydown` event and the `keyup`
    event so that when a key is pressed, we can keep track of the direction in which
    we should move. (In JavaScript, pressed keys are identified by numeric key codes.)
    In our `update` method, we just move in the specified direction. This is accomplished
    by checking flags that we set during key events so that we can poll the keyboard
    state during each frame. We can then use the controller by declaring it with `new`
    `KeyboardControls(camera)` and make it affect the camera in every frame by calling
    `controls.update(delta)` in our animation loop.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们添加了对`keydown`事件和`keyup`事件的监听器，以便在按键按下时，我们可以追踪我们应该移动的方向。（在JavaScript中，按下的键通过数字键码来识别。）在我们的`update`方法中，我们只需按照指定的方向移动。这是通过检查我们在键事件期间设置的标志来实现的，这样我们就可以在每一帧中轮询键盘状态。然后，我们可以通过使用`new`
    `KeyboardControls(camera)`来声明控制器，并在我们的动画循环中调用`controls.update(delta)`来使控制器影响每一帧的相机。
- en: If you've ever written event-driven JavaScript before, most of this should look
    pretty familiar, and it's not hard to see how this could be extended in different
    ways to support different control mechanisms. Luckily, most applications are controlled
    pretty similarly, so Three.js provides a number of default control handlers that
    take care of most of this for you. These controllers are located in `examples/js/controls`
    and not in the main library, so you need to make sure to include them separately
    in your HTML file if you want to use them. Feel free to copy and extend an existing
    controller if you want a slightly different behavior, rather than writing your
    own controller from scratch every time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前编写过事件驱动的JavaScript，那么大部分内容应该看起来很熟悉，而且不难看出如何以不同的方式扩展以支持不同的控制机制。幸运的是，大多数应用程序的控制方式相当相似，因此Three.js提供了一系列默认的控制处理器，这些处理器为你处理了大部分工作。这些控制器位于`examples/js/controls`目录中，而不是主库中，所以如果你想要使用它们，需要确保在HTML文件中单独包含它们。如果你想得到稍微不同的行为，可以自由地复制并扩展现有的控制器，而不是每次都从头开始编写自己的控制器。
- en: 'The available controllers are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的控制器有：
- en: '| Constructor | Important properties | Explanation |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | 重要属性 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `FirstPersonControls` | `movementSpeed = 1.0``lookSpeed = 0.005``constrainVertical
    = false``freeze = false` | Keyboard movement (*WASD* or arrow keys for forward/back/strafe;
    up/down with *R* or *F*) and look around by following the mouse. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `FirstPersonControls` | `movementSpeed = 1.0` `lookSpeed = 0.005` `constrainVertical
    = false` `freeze = false` | 使用键盘移动（*WASD*或箭头键用于前进/后退/侧滑；使用*R*或*F*上下移动）并通过跟随鼠标来环顾四周。|'
- en: '| `FlyControls` | `movementSpeed = 1.0``rollSpeed = 0.005` | Press keys to
    move (*WASD*), tilt (*QE*), and look around (up/down/left/right). |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `FlyControls` | `movementSpeed = 1.0` `rollSpeed = 0.005` | 按键移动（*WASD*），倾斜（*QE*），并通过锁定鼠标来环顾四周。|'
- en: '| `OculusControls` | `freeze = false` | Use the Oculus Rift virtual reality
    headset. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `OculusControls` | `freeze = false` | 使用Oculus Rift虚拟现实头盔。|'
- en: '| `OrbitControls` | `enabled = true``target = new THREE.Vector3()``zoomSpeed
    = 1.0``minDistance = 0``maxDistance = Infinity``rotateSpeed = 1.0``keyPanSpeed
    = 7.0``autoRotateSpeed = 2.0` | Rotate, pan, and zoom with mouse or touch controls,
    maintaining the *up* direction along the positive y axis. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `OrbitControls` | `enabled = true` `target = new THREE.Vector3()` `zoomSpeed
    = 1.0` `minDistance = 0` `maxDistance = Infinity` `rotateSpeed = 1.0` `keyPanSpeed
    = 7.0` `autoRotateSpeed = 2.0` | 使用鼠标或触摸控制旋转、平移和缩放，并保持沿正y轴的*up*方向。|'
- en: '| `PathControls` | `duration = 10000``waypoints = []``lookSpeed = 0.005``lookVertical
    = true``lookHorizontal = true` | Move along a predefined route and look around
    by following the mouse. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `PathControls` | `duration = 10000` `waypoints = []` `lookSpeed = 0.005`
    `lookVertical = true` `lookHorizontal = true` | 沿着预定义的路线移动，并通过跟随鼠标来环顾四周。|'
- en: '| `PointerLockControls` |   | Keyboard movement (*WASD* or arrow keys for forward/back/strafe/jump)
    and look around by locking to the mouse. Requires that the canvas is in pointer
    lock mode. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `PointerLockControls` |  | 使用键盘移动（*WASD*或箭头键用于前进/后退/侧滑/跳跃）并通过锁定鼠标来环顾四周。需要画布处于指针锁定模式。|'
- en: '| `TrackballControls` | `enabled = true``rotateSpeed = 1.0``zoomSpeed = 1.2``panSpeed
    = 0.3``minDistance = 0``maxDistance = Infinity` | Rotate, pan, zoom, and tilt
    with mouse or touch controls. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `TrackballControls` | `enabled = true` `rotateSpeed = 1.0` `zoomSpeed = 1.2`
    `panSpeed = 0.3` `minDistance = 0` `maxDistance = Infinity` | 使用鼠标或触摸控制旋转、平移、缩放和倾斜。|'
- en: '| `TransformControls` | `size = 1` | Creates a widget around an object that
    allows users to rotate, scale, and translate it. Mainly used in an editor. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `TransformControls` | `size = 1` | 在对象周围创建一个控件，允许用户旋转、缩放和移动它。主要用于编辑器。|'
- en: All the `controller` constructors take `camera` as their first parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`controller`构造函数都将`camera`作为它们的第一个参数。
- en: 'Let''s add the `FirstPersonControls` controller to our city example from the
    last chapter and try flying around to see the city from the streets. First, we
    need to add the JavaScript file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`FirstPersonControls`控制器添加到上一章的城市示例中，并尝试飞越城市，从街道上观察城市。首先，我们需要添加JavaScript文件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we''ll add some globals:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一些全局变量：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we''ll instantiate the `controls` variable and the `clock` variable in
    `setupThreeJS()`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`setupThreeJS()`中实例化`controls`变量和`clock`变量：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A `clock` is a timer. We'll use it in this case to keep track of the amount
    of time that passes between each frame we draw. Also note that we changed the
    speed at which the camera moves and looks; otherwise, it feels very sluggish.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`clock`是一个计时器。我们将在这个案例中使用它来跟踪我们绘制每一帧之间经过的时间量。此外，请注意，我们改变了相机移动和观察的速度；否则，感觉非常迟缓。
- en: 'Finally, we''ll change our animation loop in the `setup()` function to update
    our controller:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更改`setup()`函数中的动画循环以更新我们的控制器：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Updating the controls allows the camera to move when each frame is rendered.
    The clock's `getDelta` method returns the amount of time in seconds since the
    last time the `getDelta` method was called, so in this case it returns the number
    of seconds since the last frame was rendered. Internally, the controls use that
    delta to make sure that the animation is smooth over time. Now we can fly around
    our city!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更新控制器允许相机在渲染每一帧时移动。时钟的`getDelta`方法返回自上次调用`getDelta`方法以来经过的时间（以秒为单位），因此在这种情况下，它返回自上次渲染最后一帧以来经过的秒数。内部，控制器使用这个差值来确保动画随时间平滑。现在我们可以飞越我们的城市了！
- en: 'You can see in the following screenshot what the city might look like from
    the ground:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的屏幕截图中看到城市可能从地面上看起来是什么样子：
- en: '![Keyboard movement and mouse looking](img/8539OS_03_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![键盘移动和鼠标观察](img/8539OS_03_01.jpg)'
- en: Flying around the city
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 飞越城市
- en: Clicking
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击
- en: Clicking on the screen in order to select or interact with something is a common
    requirement, but it's somewhat harder than it sounds because of the need to project
    the location of the click in the 2D plane of your screen into the 3D world of
    Three.js. To do this, we draw an imaginary line, called a ray, from the camera
    toward the position where the mouse might be in 3D space and see if it intersects
    with anything.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上点击以选择或与之交互是一个常见的要求，但由于需要将屏幕2D平面上点击的位置投影到Three.js的3D世界中，所以这比听起来要困难一些。为了做到这一点，我们从一个称为射线的想象线绘制到3D空间中鼠标可能的位置，并查看它是否与任何东西相交。
- en: 'In order to project, we first need a projector:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行投影，我们首先需要一个投影仪：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we need to register a listener on the click event for the canvas:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要在画布的点击事件上注册一个监听器：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The previous code assumes that you are using the `PerspectiveCamera` class.
    If you are using the `OrthographicCamera` class, projectors have a utility method
    that returns an appropriate raycaster, and you do not have to un-project the vector
    first:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码假设你正在使用`PerspectiveCamera`类。如果你正在使用`OrthographicCamera`类，投影仪有一个实用方法返回一个适当的射线投射器，并且你不需要首先反投影向量：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code listens to the `mousedown` event on the renderer's canvas.
    Then, it creates a new `Vector3` instance with the mouse's coordinates on the
    screen relative to the center of the canvas as a percent of the canvas width.
    That vector is then un-projected (from 2D into 3D space) relative to the camera.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '之前的代码监听渲染器画布上的`mousedown`事件。然后，它创建一个新的`Vector3`实例，其中包含鼠标在屏幕上的坐标，相对于画布中心的百分比是画布宽度的百分比。然后，这个向量相对于相机进行反投影（从2D空间到3D空间）。 '
- en: Once we have the point in 3D space representing the mouse's location, we draw
    a line to it using the `Raycaster`. The two arguments that it receives are the
    starting point and the direction to the ending point. We determine the direction
    by subtracting the mouse and camera positions and then normalizing the result,
    which divides each dimension by the length of the vector to scale it so that no
    dimension has a value greater than `1`. Finally, we use the ray to check which
    objects are located in the given direction (that is, under the mouse) with the
    `intersectObjects` method. `OBJECTS` is an array of objects (generally meshes)
    to check; be sure to change it appropriately for your code. An array of objects
    that are behind the mouse are returned and sorted by distance, so the first result
    is the object that was clicked.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了表示鼠标位置的3D空间中的点，我们就使用`Raycaster`绘制一条线到它。它接收的两个参数是起始点和指向结束点的方向。我们通过减去鼠标和相机位置并规范化结果来确定方向，即通过将每个维度除以向量的长度来缩放它，以便没有维度具有大于`1`的值。最后，我们使用射线通过`intersectObjects`方法检查给定方向（即鼠标下方）上是否有对象。`OBJECTS`是一个要检查的对象数组（通常是网格），确保根据你的代码适当地更改它。返回一个位于鼠标后面的对象数组，并按距离排序，因此第一个结果是点击的对象。
- en: Each object in the `intersects` array has an `object`, `point`, `face`, and
    `distance` property. Respectively, the values of these properties are the clicked
    object (generally a `Mesh`), a `Vector3` instance representing the clicked location
    in space, the `Face3` instance at the clicked location, and the distance from
    the camera to the clicked point.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersects`数组中的每个对象都有一个`object`、`point`、`face`和`distance`属性。分别，这些属性的值是点击的对象（通常是`Mesh`）、表示空间中点击位置的`Vector3`实例、点击位置的`Face3`实例，以及从相机到点击点的距离。'
- en: 'It''s also possible to go in reverse (3D to 2D) by projecting instead of un-projecting:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过投影而不是反投影来实现反向（3D到2D）：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After this code runs, `vector.x` and `vector.y` will hold the horizontal and
    vertical coordinates of the specified point relative to the upper-left corner
    of the canvas. (Make sure you actually specify the point you want, instead of
    using `mesh.position.clone()`, and that you've instantiated your `projector`.)
    Note that the resulting coordinates might not be over the canvas if the original
    3D point is not on the screen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码运行后，`vector.x`和`vector.y`将持有相对于画布左上角的指定点的水平和垂直坐标。（确保你实际上指定了想要指定的点，而不是使用`mesh.position.clone()`，并且你已经实例化了你的`projector`。）注意，如果原始3D点不在屏幕上，则生成的坐标可能不在画布上。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The last thing you want when your player is clicking madly to shoot at enemies
    is for the whole screen to suddenly turn blue because the browser thinks the user
    is trying to select something. To avoid this, you can either cancel the `select`
    event in JavaScript with `document.onselectstart = function() { return false;
    }` or disable it in CSS:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的玩家疯狂点击射击敌人时，最不想看到的是整个屏幕突然变成蓝色，因为浏览器认为用户正在尝试选择某个东西。为了避免这种情况，你可以在JavaScript中使用`document.onselectstart
    = function() { return false; }`取消`select`事件，或者在CSS中禁用它：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Timing
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时
- en: As we start building more realistic examples, you'll notice delta parameters
    being passed around to functions that affect physics. Those deltas represent an
    amount of time since the last time physics was calculated, and they're used to
    smooth out movement over time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建更真实的示例时，你会注意到delta参数被传递到影响物理的函数中。这些delta表示自上次计算物理以来的时间量，并且它们用于平滑随时间移动。
- en: The naive way to move objects in code is to simply change the object's position.
    For example, to move an object across the canvas, you might write `obj.x += 10`
    inside your animation loop to move it 10 units every frame. This approach suffers
    from the issue that it is dependent on the frame rate. In other words, if your
    game is running slowly (that is, fewer frames per second), your object will also
    appear to move slowly, whereas if your game is running quickly (that is, more
    frames per second), your object will appear to move quickly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中移动对象的最简单方法是简单地改变对象的位置。例如，为了在画布上移动一个对象，你可能会在动画循环中写入`obj.x += 10`，以便每帧移动10个单位。这种方法的问题在于它依赖于帧率。换句话说，如果你的游戏运行缓慢（即每秒帧数较少），你的对象看起来也会移动缓慢；而如果你的游戏运行得快（即每秒帧数较多），你的对象看起来也会移动得快。
- en: One solution is to multiply the speed by the amount of time that has passed
    between rendering frames. For example, if you want your object to move 600 units
    per second, you might write `obj.x += 600 * delta`. In this way, your object will
    move a constant distance over time. However, at low frame rates and high speeds,
    your object will be moving large distances every frame, which can cause it to
    do strange things such as move through walls. At high frame rates, computing your
    physics might take longer than the amount of time between frames, which will cause
    your application to freeze and crash (this is called a *spiral of death*). Additionally,
    we would like to achieve perfect reproducibility. That is, every time we run the
    application with the same input, we would like exactly the same output. If we
    have variable frame deltas, our output will diverge the longer the program runs
    due to accumulated rounding errors, even at normal frame rates.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是将速度乘以渲染帧之间的时间差。例如，如果你想使你的物体每秒移动600个单位，你可能会写`obj.x += 600 * delta`。这样，你的物体将随着时间的推移移动一个恒定的距离。然而，在低帧率和高速的情况下，你的物体在每一帧都会移动很大的距离，这可能导致它做一些奇怪的事情，比如穿过墙壁。在高帧率下，计算物理可能需要的时间可能比帧之间的时间更长，这将导致你的应用程序冻结并崩溃（这被称为*死亡螺旋*）。此外，我们希望实现完美的可重复性。也就是说，每次我们用相同的输入运行应用程序时，我们都希望得到完全相同的输出。如果我们有可变的帧时间差，由于累积的舍入误差，我们的输出会随着程序运行时间的增长而发散，即使在正常的帧率下也是如此。
- en: 'A better solution is to separate physics update time-steps from frame refresh
    time-steps. The physics engine should receive fixed-size time deltas, while the
    rendering engine should determine how many physics updates should occur per frame.
    The fixed-size deltas avoid an inconsistent rounding error and ensure that there
    are no giant leaps between frames. The following code shows how to divide the
    amount of time between frames into discrete chunks to use for physics calculations:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是将物理更新时间步长与帧刷新时间步长分开。物理引擎应该接收固定大小的时差，而渲染引擎应该确定每帧应该发生多少物理更新。固定大小的时差避免了不一致的舍入误差，并确保帧之间没有巨大的跳跃。以下代码显示了如何将帧之间的时间分成离散的块以用于物理计算：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we declare `INV_MAX_FPS`, the multiplicative inverse of the maximum frames
    per second that we want to render (`60` in this case). This is the time-step we
    will feed to our physics engine via the `update` function, and you may need to
    adjust it depending on how slowly your simulation runs (keep in mind that most
    monitors can't refresh faster than 60 frames per second, and above 30 is usually
    considered acceptable). Then, we start tracking our `frameDelta`, the accumulated
    amount of time since the last physics update. Our clock will be used to keep track
    of the time between rendering frames.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明`INV_MAX_FPS`，这是我们想要渲染的最大每秒帧数的倒数（在这个例子中是`60`）。这是我们通过`update`函数提供给物理引擎的时间步长，你可能需要根据你的模拟运行速度进行调整（记住，大多数显示器无法以每秒超过60帧的速度刷新，通常认为30帧以上是可接受的）。然后，我们开始跟踪我们的`frameDelta`，这是自上次物理更新以来的累积时间。我们的时钟将用于跟踪渲染帧之间的时间。
- en: In the animation loop, we first add the amount of time since the last render
    to `frameDelta`, then perform as many fixed-size physics updates as we need. We
    might end up with some time left over in `frameDelta`, but it will be used up
    during the next frame.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画循环中，我们首先将自上次渲染以来经过的时间加到`frameDelta`上，然后执行所需的固定大小的物理更新。我们可能在`frameDelta`中剩下一些时间，但将在下一帧中用完。
- en: For our purposes, "physics updates" means both moving objects in our world and
    moving the player's camera.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，“物理更新”既包括我们世界中物体的移动，也包括玩家摄像机的移动。
- en: First-person shooter project
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一人称射击项目
- en: 'Let''s write a real game! This project will be bigger than any others we''ve
    done, so let''s start by specifying exactly what to accomplish. We''re going to
    build an arena-based first-person shooter game with the following features:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个真正的游戏！这个项目将比我们之前做的任何项目都要大，所以让我们首先明确我们要完成什么。我们将构建一个基于竞技场的第一人称射击游戏，具有以下功能：
- en: A world based on a voxel map
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于体素地图的世界
- en: A player that can look, run, and jump around in the world
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以在世界中四处查看、奔跑和跳跃的玩家
- en: Pointer lock and full-screen, so that the player is fully immersed as in a desktop
    or console game
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针锁定和全屏，以便玩家能够完全沉浸在桌面或控制台游戏中
- en: The player should be able to shoot at enemies that wander around, and the enemies
    should shoot back
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家应该能够射击四处游荡的敌人，而敌人应该反击
- en: The player's and enemies' health should deteriorate when shot, and players should
    respawn when they run out of health
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家被射击时，玩家和敌人的健康应该恶化，当玩家健康耗尽时，玩家应该重生。
- en: The player's screen should flash red when shot
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家被射击时，玩家的屏幕应该闪烁红色。
- en: There should be a **HUD** (**heads-up display**) with crosshairs and a health
    indicator
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个带有准星和健康指示器的**HUD**（抬头显示）。
- en: We do not care much about lighting or texturing, except that the player must
    be able to see and perceive distances in depth
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不太关心光照或纹理，除了玩家必须能够看到并感知深度距离。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code is too long to include here, but you can download it online
    from your account at [http://www.packtpub.com](http://www.packtpub.com) or have
    the files e-mailed to you at [http://www.packtpub.com/support](http://www.packtpub.com/support).
    The rest of this section covers interesting excerpts from the code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码太长，无法在此处包含，但您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户中在线下载，或者从[http://www.packtpub.com/support](http://www.packtpub.com/support)将文件通过电子邮件发送给您。本节其余部分涵盖了代码中的有趣摘录。
- en: The first step is to write the HTML code. In the previous examples, we've written
    all of our code in a single HTML file, but this is a bigger project so we should
    split the code into separate files and reference them from our `index.html` file.
    We'll also want to add some user-interface elements to the basic HTML document,
    notably including a `start` screen that the user must click in order to enter
    the game and a `hurt` div, which is just a translucent red overlay that we'll
    flash briefly on the screen as a helpful warning when the player gets hit by an
    enemy bullet.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写HTML代码。在之前的示例中，我们将所有代码都写在一个HTML文件中，但这是一个更大的项目，因此我们应该将代码拆分成单独的文件，并从我们的`index.html`文件中引用它们。我们还想在基本的HTML文档中添加一些用户界面元素，特别是包括一个用户必须点击才能进入游戏的`start`屏幕和一个`hurt`
    div，它只是一个透明的红色叠加层，当玩家被敌人子弹击中时，我们会在屏幕上短暂闪烁，作为有用的警告。
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll also break up the `main.js` file into a few different files when we start
    writing classes. For simplicity we've put everything in the same folder. In [Chapter
    5](ch05.html "Chapter 5. Design and Development"), *Design and Development*, we
    take a closer look at better organizational structures for large projects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写类时，也会将`main.js`文件拆分成几个不同的文件。为了简单起见，我们将所有内容都放在了同一个文件夹中。在[第5章](ch05.html
    "第5章。设计和开发")中，我们更深入地探讨了大型项目的更好组织结构。
- en: Designing a map
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计地图
- en: 'Now that we have a place to put some code, we need an interesting world to
    look at. Let''s design a map to use. For example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个放置代码的地方，我们需要一个有趣的世界来查看。让我们设计一个要使用的地图。例如：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our map is represented as a string where `X` indicates a wall and `S` indicates
    a location where players can spawn into the world. We split the string into an
    array for easier access, then decide how big each voxel should be (in this case,
    100 * 100 * 100 as indicated by the `HORIZONTAL_UNIT` and `VERTICAL_UNIT` variables)
    and track how big the map is overall using `XSIZE` and `ZSIZE`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地图表示为一个字符串，其中`X`表示墙壁，`S`表示玩家可以进入世界的位置。我们将字符串拆分成一个数组，以便更容易访问，然后决定每个体素的大小（在本例中，由`HORIZONTAL_UNIT`和`VERTICAL_UNIT`变量指示的100
    * 100 * 100），并使用`XSIZE`和`ZSIZE`跟踪地图的整体大小。
- en: 'Next, we need to use our map to generate the 3D world:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用我们的地图来生成3D世界：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is pretty straightforward—iterating over the map and adding something
    into the world at the specified row and column. Our `addVoxel` method looks similar
    to the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接——遍历地图并在指定的行和列中添加一些内容。我们的`addVoxel`方法看起来类似于以下代码：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In order to see our world, we'll also need to add lighting (the easiest approach
    is one or two `DirectionalLights` similar to what we used in the city project)
    and you may also want to add fog to help with depth perception. You can manually
    adjust the camera's `position` and `rotation` to see what you've just constructed,
    or temporarily add `FirstPersonControls` similar to what we used in the city project.
    Since we are only using our map to add walls, you should add a floor as we did
    in the city project as well, using a single large plane.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到我们的世界，我们还需要添加光照（最简单的方法是使用一个或两个类似于我们在城市项目中使用的`DirectionalLights`）和您可能还想添加雾来帮助深度感知。您可以手动调整摄像机的`position`和`rotation`来查看您刚刚构建的内容，或者临时添加类似于我们在城市项目中使用的`FirstPersonControls`。由于我们只使用我们的地图来添加墙壁，因此您还应该添加一个地板，就像我们在城市项目中做的那样，使用一个单一的大平面。
- en: Constructing a player
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建玩家
- en: 'Now that we have a world, let''s create a player that can move around in it.
    We''ll need a `Player` class to keep track of each player''s state, so let''s
    extend `THREE.Mesh` in a new file, which we''ll call `player.js`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个世界了，让我们创建一个可以在其中移动的玩家。我们需要一个`Player`类来跟踪每个玩家的状态，因此让我们在一个新文件中扩展`THREE.Mesh`，我们将这个文件称为`player.js`：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We implemented `Player` as a child of the `THREE.Mesh` class by calling the
    `Mesh` constructor from inside the `Player` constructor and copying over the `prototype`.
    This means that players automatically have geometry, materials, position, rotation,
    and scaling, and additionally we can implement our own features (such as velocity
    and acceleration). Note that the player functions similar to a controller because
    it contains code to move and look around, with the difference that the input event
    handlers are bound outside the class in order to make it reusable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`Player`构造函数内部调用`Mesh`构造函数并复制其`prototype`，将`Player`实现为`THREE.Mesh`类的一个子类。这意味着玩家自动具有几何形状、材质、位置、旋转和缩放，并且我们还可以实现自己的功能（例如速度和加速度）。请注意，玩家功能类似于控制器，因为它包含移动和四处张望的代码，不同之处在于输入事件处理程序绑定在类外部，以便使其可重用。
- en: One thing that may look strange here is changing the `rotation.order`. Rotation
    is tracked using a Euler representation, which consists of angles in radians around
    each axis in addition to the order in which the axial rotation should be applied.
    The default order is `'XYZ'`, which rotates up and down first (x), then left to
    right (y). In this configuration, the world will appear to tilt if the player
    looks horizontally after looking vertically. To visualize this, imagine tilting
    a donut so that the side away from you is up and the side near you is down; that
    is x rotation, or **pitch**. If you then move your finger around the donut from
    the front to the left, that is y rotation, or **yaw**. (Tilting the donut to the
    right would be z rotation, or **roll** **.**) Notice that if you were looking
    out from the middle of the donut towards your finger, your head would be tilted
    relative to the world. As a result, we have to change the Euler order to `'YXZ'`
    to make the camera rotate relative to the world instead of to itself. With this
    change, we move our finger first, then tilt the donut so our finger goes up or
    down instead of the front of the donut, and we end up with a level head.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能看起来有些奇怪的是改变`rotation.order`。旋转是通过欧拉表示法跟踪的，它包括围绕每个轴的弧度角以及轴向旋转应用的顺序。默认顺序是`'XYZ'`，首先旋转上下（x），然后左右（y）。在这种配置下，如果玩家在垂直查看后水平查看，世界将看起来倾斜。为了可视化这一点，想象倾斜一个甜甜圈，使其远离你的那一侧向上，靠近你的那一侧向下；这就是x旋转，或**俯仰**。如果你然后从前面到左边在甜甜圈周围移动你的手指，这就是y旋转，或**偏航**。（将甜甜圈向右倾斜将是z旋转，或**翻滚**。）请注意，如果你从甜甜圈的中间向外看向你手指，你的头部相对于世界是倾斜的。因此，我们必须将欧拉顺序更改为`'YXZ'`，以便使相机相对于世界而不是相对于自身旋转。通过这个改变，我们首先移动我们的手指，然后倾斜甜甜圈，使我们的手指向上或向下移动，而不是甜甜圈的前面，最终我们得到一个水平的头部。
- en: 'To actually implement this looking around, we''ll lock the mouse and track
    its movement. We''ll use libraries to make this easier since the APIs are a little
    wordy. You can get `PointerLock.js` at [https://github.com/IceCreamYou/PointerLock.js](https://github.com/IceCreamYou/PointerLock.js)
    and BigScreen from *Brad Dougherty* at [https://github.com/bdougherty/BigScreen](https://github.com/bdougherty/BigScreen).
    Once we have included these libraries, starting the game looks similar to the
    following code, which requests the browser to enter full screen and pointer lock
    mode before starting animation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际实现这种四处张望的功能，我们将锁定鼠标并跟踪其移动。由于API有些冗长，我们将使用库来简化这个过程。您可以从[https://github.com/IceCreamYou/PointerLock.js](https://github.com/IceCreamYou/PointerLock.js)获取`PointerLock.js`，以及来自*布拉德·多赫蒂*的BigScreen库，链接为[https://github.com/bdougherty/BigScreen](https://github.com/bdougherty/BigScreen)。一旦我们包含了这些库，启动游戏的过程将类似于以下代码，该代码在开始动画之前请求浏览器进入全屏和指针锁定模式：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Pointer Lock and Full Screen APIs can only be engaged when users take an
    action (clicking or hitting the keyboard) as a security precaution to prevent
    attackers from hijacking your screen, so we''re waiting for a click in this case.
    Once we''re in full screen, we can listen to the `mousemove` event to rotate the
    player:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 指针锁定和全屏API只能在用户采取行动（点击或按键）时启用，作为安全预防措施，以防止攻击者劫持您的屏幕，因此在这种情况下我们正在等待点击。一旦我们进入全屏，我们可以监听`mousemove`事件来旋转玩家：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `event.movementX` property and the `event.movementY` property are normalized
    across browsers here by the `PointerLock.js` library.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`event.movementX`属性和`event.movementY`属性通过`PointerLock.js`库在所有浏览器中进行了归一化。
- en: 'The `rotate()` method simply changes the player''s `_aggregateRotation` vector.
    We''re assuming here that the player has been instantiated, as shown in the following
    code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotate()`方法只是简单地改变玩家的`_aggregateRotation`向量。在这里，我们假设玩家已经被实例化，如下面的代码所示：'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yes, we just added the `camera` to the `player`. It turns out that any object
    that is a descendant of `THREE.Object3D` can have other objects added to it. Those
    child objects are accessible through the parent's `children` array, and they will
    be grouped together with the parent so that movement, rotation, and scaling are
    composed. (In other words, if a child's local position is `(0, 0, 5)` and the
    parent's position is `(0, 0, 10)`, then the child's position in the world will
    be `(0, 0, 15)`. Rotation and scale work similarly.) In this case, we use this
    composition to cause our camera to follow our player around.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们刚刚将`camera`添加到了`player`中。结果是，任何是`THREE.Object3D`的子对象都可以添加其他对象。这些子对象可以通过父对象的`children`数组访问，并且它们将与父对象一起分组，以便运动、旋转和缩放可以组合。换句话说，如果一个子对象的局部位置是`(0,
    0, 5)`，而父对象的位置是`(0, 0, 10)`，那么子对象在世界的位置将是`(0, 0, 15)`。旋转和缩放的工作方式类似。在这种情况下，我们使用这种组合来使我们的相机跟随玩家移动。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because child objects' position, rotation, and scaling are relative to the parent's
    position, rotation, and scaling, you could create a third-person camera by positioning
    the camera on the positive z axis (and probably a little higher on the y axis)
    and giving the `player` object a geometry and material (remember, `Player` inherits
    from `Mesh`, so you can instantiate a player with `new Player(geometry, material)`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为子对象的位置、旋转和缩放都是相对于父对象的位置、旋转和缩放而言的，所以你可以通过将相机放置在正z轴上（可能在y轴上稍微高一点）并给`player`对象一个几何形状和材质（记住，`Player`是从`Mesh`继承的，所以你可以使用`new
    Player(geometry, material)`来实例化一个玩家）来创建一个第三人称相机。
- en: Player movement
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家运动
- en: We'll finish off the code to look around in a moment, but because it's closely
    related to the player's movement, let's address that first.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会完成代码，以便四处查看，但由于它与玩家的移动密切相关，让我们先来解决这个问题。
- en: Physical movement
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理运动
- en: 'Getting movement right is a complex topic. Although simply adding a constant
    velocity to an object''s position can work for some simulations, more advanced
    games will want to have acceleration at play (for example, for gravity) and potentially
    other forces as well. The most straightforward approach to linear forces is to
    keep track of acceleration and velocity vectors and add them together:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正确实现运动是一个复杂的话题。虽然简单地给一个对象的位置加上一个恒定速度在某些模拟中可能有效，但更高级的游戏将希望有加速度（例如，用于重力）以及可能的其他力。线性力的最直接方法是跟踪加速度和速度向量并将它们相加：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is called **Euler** integration (pronounced oiler, not yew-ler). A simple
    modification gives us **Midpoint** integration, which yields a reasonable improvement
    in accuracy. All we need to do is apply the acceleration in halves before and
    after applying velocity:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**欧拉**积分（发音为“oiler”，而不是“yew-ler”）。一个简单的修改就给了我们**中点**积分，这可以在准确性上带来合理的改进。我们所需做的只是在使用速度之前和之后将加速度应用一半：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To understand how this works, consider the following graph:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解它是如何工作的，请考虑以下图表：
- en: '![Physical movement](img/8539OS_03_02.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![物理运动](img/8539OS_03_02.jpg)'
- en: Euler versus Midpoint integration
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉法与中点积分
- en: The goal of our integration formula is to stay as close to the true position
    as possible. In the graph, the vertical jumps are at our time-steps, where physics
    updates are calculated. The midpoint curve is just a shift of the Euler curve
    so that the area between the midpoint and true positions cancel out. More error
    is introduced when acceleration, jerk, and nonlinear forces are applied, but for
    our purposes (and in the space we have) the midpoint formula is a reasonable trade-off
    between simplicity and accuracy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们积分公式的目标是尽可能接近真实位置。在图中，垂直跳跃发生在我们的时间步长，即物理更新计算的地方。中点曲线只是将欧拉曲线平移，使得中点位置和真实位置之间的面积相互抵消。当应用加速度、急速和非线性力时，会引入更多的误差，但就我们的目的（以及我们的空间）而言，中点公式是在简单性和准确性之间的一种合理的折衷。
- en: The **fourth-order Runge-Kutta** method (also known as **RK4**) is another commonly
    used method for computing motion over time. RK4 extrapolates several intermediate
    states between frames, resulting in a more accurate final approximation for the
    state in the next frame. The trade-off for increased accuracy is increased complexity
    and decreased speed. Because of its complexity, we won't cover it here, but usually
    if you need something as sophisticated as this, you will want to delegate physics
    handling to one of the libraries addressed in the next section on collision.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**四阶龙格-库塔**方法（也称为**RK4**）是另一种常用的方法，用于计算随时间变化的运动。RK4在帧之间预测几个中间状态，从而为下一帧的状态提供更精确的最终近似。增加准确性的代价是增加了复杂性和降低了速度。由于其复杂性，我们在这里不会介绍它，但通常如果你需要像这样复杂的东西，你可能会希望将物理处理委托给下一节中提到的碰撞处理库之一。'
- en: Updating the player's movement and rotation
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新玩家的移动和旋转
- en: 'Let''s listen for the movement keys so that we know when to move the player:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们监听移动键，以便我们知道何时移动玩家：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We'll check these flags in every frame to see how much thrust to apply. We also
    need a `keyup` listener, which looks almost identical to the `keydown` listener
    except that it should set our directions back to `false` when the relevant keys
    are released.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每一帧检查这些标志，以确定应用多少推力。我们还需要一个`keyup`监听器，它几乎与`keydown`监听器相同，不同之处在于当相关键被释放时，它应该将我们的方向设置回`false`。
- en: 'And now, finally, we can implement the player''s `update` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，终于可以实施玩家的`update`方法了：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There's a lot going on here. The first thing to notice is that our definition
    of the method immediately invokes an anonymous function that returns our actual
    method definition. We do this to create some helper objects for efficiency. Most
    Three.js math happens in place (as opposed to returning a new object with the
    result of each operation), which means that to perform calculations with existing
    math objects such as the `acceleration` vector, we either need to clone them or
    copy values to a `helper` object that we can manipulate without side effects.
    Cloning creates too much garbage-collection churn, meaning that the browser will
    lag if it has to process all the objects we would be rapidly creating and then
    discarding. Instead, we define the `halfAccel` vector, for example, in a closure
    (so that it doesn't pollute the global namespace) and do our vector math with
    that. This pattern is used frequently in the Three.js library itself.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中。首先要注意的是，我们的方法定义立即调用一个匿名函数，该函数返回我们的实际方法定义。我们这样做是为了创建一些辅助对象以提高效率。大多数Three.js数学运算都是在原地进行的（而不是返回每个操作的结果的新对象），这意味着为了使用现有的数学对象（如`acceleration`向量）进行计算，我们要么需要克隆它们，要么将值复制到一个`helper`对象中，这样我们就可以在不产生副作用的情况下对其进行操作。克隆会产生过多的垃圾回收，这意味着如果浏览器必须处理我们快速创建然后丢弃的所有对象，它将会滞后。相反，我们定义了`halfAccel`向量，例如，在闭包中（这样它就不会污染全局命名空间），并使用它进行向量数学运算。这种模式在Three.js库本身中经常被使用。
- en: Almost everything else in the `update` method is addition and multiplication.
    To look around, we aggregate how far the mouse has moved between each frame, then
    add the corresponding amount of rotation when the player is updating. Also, the
    acceleration and velocity part should look familiar—it's the same midpoint strategy
    we just covered in the *Physical movement* section. We have to be sensitive to
    a few issues though. First, we restrict `r.x` in order to constrain how far the
    player can look up and down so that they don't get confused which way is up. Second,
    we want the concept of *forward* to be relative to the world instead of where
    the camera is looking, so that we can look up and walk forward without flying
    into the air in the direction we're looking. To do this, we reset the pitch (making
    the player look straight ahead instead of up or down) before adding the velocity
    to the position. Finally, we add friction, which allows the player to slow down
    and stop after moving in a given direction. In your actual game, you will probably
    want to use different levels of friction depending on whether your player is in
    the air or not.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在`update`方法中的其他所有操作都是加法和乘法。为了观察周围环境，我们汇总鼠标在每一帧之间的移动距离，然后在玩家更新时添加相应的旋转量。此外，加速度和速度部分应该看起来很熟悉——它与我们刚刚在*物理移动*部分提到的相同的中点策略。不过，我们还需要对一些问题保持敏感。首先，我们限制`r.x`以约束玩家向上和向下看的距离，这样他们就不会混淆上下方向。其次，我们希望*前进*的概念相对于世界而不是相机的方向，这样我们就可以向上看并向前走，而不会在所看方向上飞到空中。为此，我们在将速度添加到位置之前重置俯仰角（使玩家向前看而不是向上或向下看）。最后，我们添加摩擦力，这允许玩家在给定方向移动后减速并停止。在你的实际游戏中，你可能希望根据玩家是否在空中使用不同级别的摩擦力。
- en: Player collision
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家碰撞
- en: 'There are several different approaches to detecting collision:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 检测碰撞有几种不同的方法：
- en: '**Voxels**: As discussed in [Chapter 2](ch02.html "Chapter 2. Building a World"),
    *Building a World*, one common way to design worlds is to use a string or image
    to represent repeatable building blocks, such as LEGOs. When using this method,
    the fastest way to check for collision between an actor and the world is to simply
    check if the actor''s coordinates are inside the zone that the map designates
    for use by a building block. This avoids the complexity of comparing 3D shapes.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体素**：如[第2章](ch02.html "第2章。构建世界")中所述，*构建世界*，设计世界的一种常见方法是用字符串或图像来表示可重复的构建块，例如乐高积木。使用这种方法时，检查角色与世界之间的碰撞最快的方法是简单地检查角色的坐标是否在地图指定的用于构建块的区域之内。这避免了比较3D形状的复杂性。'
- en: '**Rays**: Just like we used the `Raycaster` class earlier to detect clicked
    objects, we can also use it to detect collision between multiple objects with
    the `intersectObjects()` method. To do this, we can cast rays in multiple directions
    from the object that needs to check for collision, such as the player; for example,
    we could cast a ray from the player''s position toward each of the player''s vertices.
    If an intersection occurs at a distance smaller than the distance from the player''s
    position to the vertex, a collision has occurred. There are several problems with
    this method. First, it''s inefficient for large numbers of vertices or dynamic
    objects. Second, objects can escape detection if they are not exactly in the direction
    of a ray. Lastly, rays check for intersection using an approximation of objects''
    shapes, so irregularly-shaped objects can be incorrectly selected. However, this
    is the simplest general-purpose approach that can work without additional libraries
    or knowledge about the world''s layout.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光线**：就像我们之前使用`Raycaster`类来检测点击的对象一样，我们也可以使用它来检测多个对象之间的碰撞，使用`intersectObjects()`方法。为此，我们可以从需要检查碰撞的对象（如玩家）向多个方向发射光线；例如，我们可以从玩家的位置向玩家的每个顶点发射光线。如果交点距离小于玩家位置到顶点的距离，则表示发生了碰撞。这种方法有几个问题。首先，对于大量顶点或动态对象来说，它效率不高。其次，如果对象不在光线的方向上，它们可能会逃避免检测。最后，光线使用对象形状的近似来检查交点，因此不规则形状的对象可能会被错误地选中。然而，这是最简单的一般性方法，可以在不使用额外库或了解世界布局的情况下工作。'
- en: '**Intersection**: We can manually compare objects'' geometries and positions
    to see if they overlap. Since detecting collision between complex 3D shapes is
    mathematically difficult, most games use simplified approximations instead of
    the actual geometry to make calculations easier. Even so, 3D collision detection
    algorithms are complex and slow unless we use very simple shapes such as boxes
    or spheres that don''t do a great job of approximating our objects. It''s also
    computationally expensive without some complex optimizations such as using a data
    structure called an **Octree** to make sure only nearby objects need to check
    for collision. If you want to try implementing your own collision, Three.js includes
    an Octree implementation in the `examples/js` folder.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交点**：我们可以手动比较对象的几何形状和位置，以查看它们是否重叠。由于检测复杂3D形状之间的碰撞在数学上是困难的，因此大多数游戏使用简化的近似值而不是实际几何形状来简化计算。即便如此，除非我们使用非常简单的形状（如盒子或球体，它们并不能很好地近似我们的对象），否则3D碰撞检测算法既复杂又慢。如果没有一些复杂的优化，如使用名为**八叉树**的数据结构来确保只有附近的对象需要检查碰撞，这也会很耗费计算资源。如果你想要尝试实现自己的碰撞检测，Three.js在`examples/js`文件夹中包含了一个八叉树的实现。'
- en: '**Libraries**: Luckily, we don''t have to do complex collision detection manually,
    as there are several libraries that can take care of the complications for us.
    They also handle collision response and associated physics. The leading contenders
    are:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库**：幸运的是，我们不必手动进行复杂的碰撞检测，因为有几个库可以为我们处理这些复杂性。它们还处理碰撞响应和相关物理。主要的竞争者包括：'
- en: '**Ammo.js** is a large but complete library compiled to JavaScript from C++.
    It is available at [https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/).'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ammo.js**是一个从C++编译到JavaScript的大型但完整的库。它可在[https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/)找到。'
- en: '**Cannon.js** is a smaller library written from scratch in JavaScript and inspired
    in part by concepts from Three.js. It is available at [https://github.com/schteppe/cannon.js](https://github.com/schteppe/cannon.js).'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cannon.js**是一个从头开始用JavaScript编写的较小库，部分灵感来自Three.js的概念。它可在[https://github.com/schteppe/cannon.js](https://github.com/schteppe/cannon.js)找到。'
- en: '**Physi.js** is a bridge between Ammo or Cannon and Three.js that also runs
    the physics simulation in a separate thread to avoid blocking the rendering. It
    is available at [https://github.com/chandlerprall/Physijs](https://github.com/chandlerprall/Physijs).'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Physi.js**是Ammo或Cannon与Three.js之间的桥梁，它还在单独的线程中运行物理模拟以避免阻塞渲染。它可在[https://github.com/chandlerprall/Physijs](https://github.com/chandlerprall/Physijs)找到。'
- en: For our shooter game, we'll use voxel collision and a little bit of manual intersection.
    Unfortunately, all the physics libraries are large, so we don't have space to
    cover their APIs here. However, Cannon.js and Physi.js have examples specifically
    for use with Three.js available from their project pages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的射击游戏，我们将使用体素碰撞和一些手动交点。不幸的是，所有物理库都很大，所以我们没有足够的空间在这里介绍它们的API。然而，Cannon.js和Physi.js在其项目页面上提供了专门用于与Three.js一起使用的示例。
- en: Voxel collision
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 体素碰撞
- en: 'If we try to walk around our world now, we''ll just fall through the floor.
    Let''s create a function to check for collision between the player and the voxel
    world:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试在世界中行走，我们只会穿过地板。让我们创建一个函数来检查玩家与体素世界之间的碰撞：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our `collideFloor` method keeps the player above the floor''s y position. Then,
    the `mapCellFromPosition` method looks up the map cell from the player''s position
    to determine whether the player is in a wall or open space. If the player is colliding
    with a wall, the `moveOutside()` method moves the player outside of it by shifting
    the player toward the closest cell. The cell-from-position lookup is just the
    reverse of what we used to place each voxel originally:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`collideFloor`方法确保玩家保持在地板的y位置之上。然后，`mapCellFromPosition`方法从玩家的位置查找地图单元格，以确定玩家是否在墙壁或开放空间中。如果玩家正在与墙壁碰撞，`moveOutside()`方法通过将玩家移向最近的单元格来将玩家移出墙壁。从位置查找单元格的过程与我们最初放置每个体素时使用的正好相反：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Bots
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器人
- en: 'Now that we''ve got the player working, it''s time to add enemy bots. Enemies
    can be `Player`s just as the user is, so apart from initializing them, the main
    thing we need to add is autonomous behavior. We don''t have the space here to
    go in depth on artificial intelligence strategies, so we''ll just set each bot''s
    `moveDirection` flags randomly every once in awhile:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让玩家工作起来，是时候添加敌人机器人了。敌人可以是像用户一样的`Player`，所以除了初始化它们之外，我们主要需要添加的是自主行为。我们没有足够的空间在这里深入讨论人工智能策略，所以我们只是偶尔随机设置每个机器人的`moveDirection`标志：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Bullets
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子弹
- en: 'Finally, let''s add shooting so we can pulverize those enemies! First, we''ll
    create a new `Bullet` class in `bullet.js` similar to what we did for the `Player`
    class. Bullets are just meshes with a `direction` vector and a `speed` scalar,
    so their `update` method can be pretty simple:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加射击功能，以便我们可以粉碎那些敌人！首先，我们将在`bullet.js`中创建一个新的`Bullet`类，类似于我们为`Player`类所做的那样。子弹只是具有`direction`向量和`speed`标量的网格，因此它们的`update`方法可以相当简单：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ll set bullets'' directions when they''re shot. Bullets can either be shot
    in the camera''s direction or from an enemy bot toward another player. To get
    the relevant direction, our `shoot` function will look similar to the following
    code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当子弹被射出时，我们将设置子弹的方向。子弹可以朝向摄像机的方向射出，或者从敌方机器人向玩家射出。为了获取相关方向，我们的`shoot`函数将类似于以下代码：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We get the direction from one player to another by subtracting their positions.
    If the user is shooting then we aren't necessarily aiming at anything, so we just
    want the direction in which the camera is looking. We retrieve this direction
    from the player's rotation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过减去他们的位置来获取一个玩家到另一个玩家的方向。如果用户正在射击，那么我们不一定瞄准任何东西，所以我们只需要摄像机正在看的方向。我们从玩家的旋转中检索这个方向。
- en: Updating the game loop
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏循环
- en: 'Bringing it all together, we should end up with a function like this, which
    executes all of our game''s behavior:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些整合在一起，我们应该得到一个类似以下的功能，它执行我们游戏的所有行为：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function calculates all physics (including movement and collision checking),
    triggers autonomous behavior such as the bots shooting at targets, and implements
    game logic (such as players dying when their health is too low). It is called
    in every frame from the animation loop. The delta parameter is the physics time-step,
    so it should always be the same value as discussed in the *Timing* section of
    this chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算所有物理（包括移动和碰撞检测），触发自主行为，如机器人向目标射击，并实现游戏逻辑（如玩家健康过低时死亡）。它在动画循环的每一帧中被调用。delta参数是物理时间步长，因此它应该始终与本章*时间*部分中讨论的相同值相同。
- en: 'That was a lot of code to write! We''re rewarded, though, with an awesome arena-based
    first-person shooter game that you can put online and send to all your friends.
    You can see how all that work might look in the following image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 写了这么多代码！不过，我们得到了一个很棒的基于竞技场的第一人称射击游戏，你可以将其上线并发送给所有你的朋友。你可以从以下图像中看到所有这些工作的样子：
- en: '![Updating the game loop](img/8539OS_03_03.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![更新游戏循环](img/8539OS_03_03.jpg)'
- en: A screenshot of the finished game
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏完成后的截图
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement user interaction and game physics.
    We also built a full-fledged first-person shooter game. In the next chapter, we'll
    add detail to our worlds with imported models, particle systems, sound, and post-processing
    effects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何实现用户交互和游戏物理。我们还构建了一个完整的单人第一人称射击游戏。在下一章中，我们将通过导入模型、粒子系统、声音和后期处理效果来丰富我们的世界。
