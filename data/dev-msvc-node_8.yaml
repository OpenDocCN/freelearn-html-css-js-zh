- en: Chapter 8. Deploying Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。部署微服务
- en: In this chapter, we are going to deploy microservices. We will use different
    technologies in order to provide the reader with the knowledge required to choose
    the right tool for every job. First, we will use PM2 and its deployment capabilities
    to run applications in remote servers. Then, we will play around Docker, which
    is one of the most advanced deployment platforms, and the entire ecosystem around
    containers. In this chapter, we will show how to automate all the deployments
    as highly as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将部署微服务。我们将使用不同的技术，以便为读者提供选择每项工作的正确工具所需的知识。首先，我们将使用PM2及其部署功能在远程服务器上运行应用程序。然后，我们将尝试Docker，这是最先进的部署平台之一，以及容器周围的整个生态系统。在本章中，我们将展示如何尽可能自动化所有部署。
- en: Concepts in software deployment
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件部署中的概念
- en: 'Deployments are usually the ugly friend of the **Software Development Life
    Cycle** (**SDLC**) party. There is a missing contact point between development
    and systems administration that DevOps is going to solve in the next few years.
    The cost of fixing bugs at different stages of SDLC is shown in the following
    figure:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 部署通常是**软件开发生命周期**（**SDLC**）派对的不受欢迎的朋友。开发和系统管理之间存在缺失的联系点，这是DevOps在未来几年将要解决的问题。在以下图表中显示了在SDLC不同阶段修复错误的成本：
- en: '![Concepts in software deployment](img/B04889_08_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![软件部署中的概念](img/B04889_08_01.jpg)'
- en: This diagram shows the cost of fixing a bug, depending on the stage of the SDLC
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表显示了根据SDLC阶段修复错误的成本
- en: Fail early is one of my favorite concepts in the lean methodology. In the change
    management world, the cost of fixing a bug in the different stages of the software
    life cycle is called the **cost of change curve**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在精益方法论中，尽早失败是我最喜欢的概念之一。在变更管理领域，软件生命周期不同阶段修复错误的成本被称为**变更成本曲线**。
- en: Roughly, fixing a bug in production is estimated to cost 150 times the resources
    as compared to the costs to fix it when taking requirements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，在生产环境中修复错误的成本估计是需求确定时修复错误成本的150倍。
- en: No matter what the figure is, which depends a lot on the methodology and technology
    that we use, the lesson learned is that we can save a lot of time by catching
    bugs early.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 无论数字是多少，这在很大程度上取决于我们使用的方法和技术，我们得出的教训是，通过及早发现错误，我们可以节省大量时间。
- en: From the continuous integration up to continuous delivery, the process should
    be automated as much as possible, where *as much as possible* means 100%. Remember,
    humans are imperfect and more prone to errors while carrying out manual repetitive
    tasks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从持续集成到持续交付，过程应尽可能自动化，*尽可能*意味着100%。记住，人类是不完美的，在进行手动重复任务时更容易出错。
- en: Continuous integration
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: '**Continuous integration** (**CI**) is the practice of integrating the work
    from different branches on daily basis (or more than once a day) and validating
    that the changes do not break existing features by running integration and unit
    tests.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是将来自不同分支的工作每天（或一天多次）集成在一起，并通过运行集成和单元测试来验证这些更改不会破坏现有功能的实践。'
- en: CI should be automated using the same infrastructure configuration as we will
    be using later in pre-production and production, so if there is any flaw, it can
    be caught early.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CI应该使用与我们将在预生产和生产中使用的相同基础架构配置进行自动化，这样如果有任何缺陷，就可以及早发现。
- en: Continuous delivery
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付
- en: '**Continuous delivery** (**CD**) is a software engineering approach that aims
    to build small, testable, and easily deployable pieces of functionality that can
    be delivered seamlessly at any time.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续交付**（**CD**）是一种旨在构建小型、可测试和易于部署的功能片段的软件工程方法，可以随时无缝交付。'
- en: This is what we are aiming for with the microservices. Again, we should be pushing
    to automate the delivery process as, if we are doing it manually, we are only
    looking for problems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在微服务中的目标。再次强调，我们应该推动自动化交付过程，因为如果我们手动操作，我们只会寻找问题。
- en: When talking from the microservices' perspective, automation on deployments
    is the key. We need to tackle the overhead of having a few dozen of services instead
    of a few machines, or we can find ourselves maintaining a cloud of services instead
    of adding value to our company.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从微服务的角度来看，部署的自动化是关键。我们需要解决拥有几十个服务而不是几台机器所带来的额外开销，否则我们可能会发现自己在维护一堆服务，而不是为公司增加价值。
- en: '**Docker** is our best ally here. With Docker, we are reducing the hassle of
    deploying a new software to pretty much moving a file (a container) around in
    different environments, as we will see later in this chapter.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker**是我们的最佳盟友。有了Docker，我们几乎可以将新软件部署到不同环境中的过程简化为移动一个文件（容器），这是我们将在本章后面看到的。'
- en: Deployments with PM2
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PM2进行部署
- en: PM2 is an extremely powerful tool. No matter what stage of development we are
    in, PM2 always has something to offer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PM2是一个非常强大的工具。无论我们处于开发的哪个阶段，PM2总是有所提供。
- en: In this phase of software development, the deployment is where PM2 really shines.
    Through a JSON configuration file, PM2 will manage a cluster of applications so
    that we can easily deploy, redeploy, and manage applications on remote servers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的这个阶段，部署是PM2真正发光的地方。通过一个JSON配置文件，PM2将管理一组应用程序，以便我们可以轻松地在远程服务器上部署、重新部署和管理应用程序。
- en: PM2 – ecosystems
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PM2 - 生态系统
- en: 'PM2 calls a group of applications ecosystem. Every ecosystem is described by
    a JSON file, and the easiest way to generate it is executing the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PM2将一组应用程序称为生态系统。每个生态系统都由一个JSON文件描述，生成它的最简单方法是执行以下命令：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should output something similar to the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出类似于以下代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The content of the `ecosystem.json` file varies, depending on the version of
    PM2, but what this file contains is the skeleton of a PM2 cluster:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecosystem.json`文件的内容因PM2的版本而异，但这个文件包含了PM2集群的框架：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file contains two applications configured for two environments. We are
    going to modify this skeleton to adapt it to our needs, modeling our entire ecosystem
    written in [Chapter 4](ch04.html "Chapter 4. Writing Your First Microservice in
    Node.js"), *Writing Your First Microservice in Node.js*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含了为两个环境配置的两个应用程序。我们将修改这个框架，以适应我们的需求，模拟我们在[第4章](ch04.html "第4章。在Node.js中编写你的第一个微服务")中编写的整个生态系统，*在Node.js中编写你的第一个微服务*。
- en: 'However, for now, let''s explain a bit for the configuration:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在，让我们解释一下配置：
- en: 'We have an array of applications (`apps`) defining two apps: API and WEB'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个应用程序数组(`apps`)，定义了两个应用程序：API和WEB
- en: 'As you can see, we have a few configuration parameters for each app:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们为每个应用程序有一些配置参数：
- en: '`name`: This is the name of the application'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是应用程序的名称'
- en: '`script`: This is the startup script of the app'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script`：这是应用程序的启动脚本'
- en: '`env`: These are the environment variables to be injected into the system by
    PM2'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`：这些是要由PM2注入到系统中的环境变量'
- en: '`env_<environment>`: This is same as `env`, but it is tailored per environment'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env_<environment>`：这与`env`相同，但是它是根据环境定制的'
- en: 'There are two environments defined in the default ecosystem under the `deploy`
    key, as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在默认生态系统下定义了两个环境，分别是`deploy`键下的两个环境：
- en: '`production`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`production`'
- en: '`dev`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`'
- en: As you can see, between these two environments, there are no significant changes
    except for the fact that we are configuring one environment variable in development
    and the folder where we deploy our application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在这两个环境之间，除了我们在开发环境中配置一个环境变量和我们部署应用程序的文件夹之外，没有什么显著的变化。
- en: Deploying microservices with PM2
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PM2部署微服务
- en: In [Chapter 4](ch04.html "Chapter 4. Writing Your First Microservice in Node.js"),
    *Writing Your First Microservice in Node.js*, we wrote a simple e-commerce in
    order to show the different concepts and common catches in microservices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。在Node.js中编写你的第一个微服务")中，*在Node.js中编写你的第一个微服务*，我们编写了一个简单的电子商务，以展示微服务中的不同概念和常见陷阱。
- en: Now, we are going to learn how to deploy them using PM2.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何使用PM2部署它们。
- en: Configuring the server
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置服务器
- en: First thing we need to do in order to deploy software with PM2 is to configure
    the remote machine and local machine to be able to talk using SSH, with a public/private
    key schema.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PM2部署软件的第一件事是配置远程机器和本地机器，以便使用SSH进行通信，采用公钥/私钥模式。
- en: 'The way of doing it is easy, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的方式很简单，如下所示：
- en: Generate one RSA key
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个RSA密钥
- en: Install it into the remote server
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其安装到远程服务器
- en: 'Let''s do it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做吧：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That should produce something similar to the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生类似于以下输出：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, if we go to the folder indicated in the preceding output, we can find
    the following two files:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们进入前面输出中指示的文件夹，我们可以找到以下两个文件：
- en: '`pm2_rsa`: The first one, `pm2_rsa`, is your private key. As you can read from
    the name, no one should have access to this key as they may steal your identity
    in the servers that trust this key.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm2_rsa`：第一个是`pm2_rsa`，是你的私钥。正如你从名称中所读到的，没有人应该有权访问这个密钥，因为他们可能在信任这个密钥的服务器中窃取你的身份。'
- en: '`pm2_rsa.pub`: The `pm2_rsa.pub` is your public key. This key can be handed
    over to anyone so that using asymmetric cryptography techniques, they can verify
    your identity (or who you say you are).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm2_rsa.pub`：`pm2_rsa.pub`是你的公钥。这个密钥可以交给任何人，使用非对称加密技术，他们可以验证你的身份（或者你所说的身份）。'
- en: 'What we are going to do now is copy the public key to the remote server so
    that when our local machine PM2 tries to talk to the server, it knows who we are
    and let''s get into the shell without password:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要做的是将公钥复制到远程服务器，这样当我们的本地机器PM2尝试与服务器通信时，它知道我们是谁，并且让我们在没有密码的情况下进入shell：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last step is to register your private key as a known identity in your local
    machine:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将你的私钥注册为本地机器中已知的身份：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's about it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: From now on, whenever you SSH into the remote server using as a user `youruser`,
    you won't need to enter the password in order to get into the shell.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每当你使用`youruser`作为用户SSH进入远程服务器时，你就不需要输入密码就可以进入shell。
- en: 'Once this configuration is done, there is very little to do in order to deploy
    any application into this server:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，就几乎没有什么需要做的，就可以将任何应用程序部署到这个服务器上：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first command will configure everything needed to accommodate the app. The
    second command will actually deploy the application itself as we configured earlier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令将配置所有需要的内容来容纳该应用程序。第二条命令将实际部署应用程序本身，就像我们之前配置的那样。
- en: Docker – a container for software delivery
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker - 用于软件交付的容器
- en: Virtualization has been one of the biggest trends in the past few years. Virtualization
    enables the engineer to share the hardware across different software instances.
    Docker is not really a virtualization software, but it is conceptually the same.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化是过去几年中最大的趋势之一。虚拟化使工程师能够在不同的软件实例之间共享硬件。Docker实际上并不是一个虚拟化软件，但在概念上是相同的。
- en: 'With a pure virtualization solution, a new OS runs on top of a hypervisor sitting
    on top of an existing operating system (host OS). Running the full OS means that
    we can be consuming a few gigabytes of hard drive in order to replicate the full
    stack from the kernel to the filesystem, which usually consumes a good chunk of
    resources. The structure of a virtualization solution is shown in the following
    image:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯虚拟化解决方案，一个新的操作系统运行在现有操作系统（主机操作系统）顶部的hypervisor上。运行完整的操作系统意味着我们可能需要消耗几GB的硬盘空间来复制从内核到文件系统的整个堆栈，这通常会消耗大量资源。虚拟化解决方案的结构如下图所示：
- en: '![Docker – a container for software delivery](img/B04889_08_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Docker - 用于软件交付的容器](img/B04889_08_02.jpg)'
- en: Layers diagram for a virtual machine environment
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机环境的层次图
- en: 'With Docker, we only replicate the filesystem and binaries so that there is
    no need to run the full stack of the OS where we don''t need it. Docker images
    are usually a few hundreds of megabytes, instead of gigabytes, and they are quite
    lightweight, therefore, we can run some containers on the same machine. The previous
    structure using Docker is shown as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，我们只复制文件系统和二进制文件，因此无需运行我们不需要的操作系统的完整堆栈。 Docker图像通常只有几百兆字节，而不是几十亿字节，它们非常轻量级，因此我们可以在同一台机器上运行一些容器。使用Docker的先前结构如下所示：
- en: '![Docker – a container for software delivery](img/B04889_08_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Docker-软件交付的容器](img/B04889_08_03.jpg)'
- en: Layers diagram for Docker
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的图层图
- en: With Docker, we also eliminate one of the biggest problems of software deployment,
    that is, **the** **configuration management**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，我们还消除了软件部署的最大问题之一，即**配置管理**。
- en: We are switching a complicated per-environment configuration management, where
    we need to worry about how the application is deployed/configured into a container
    that is basically like a software package that can be installed in any Docker-ready
    machine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在切换到一个复杂的每个环境配置管理，我们需要担心应用程序如何部署/配置到基本上类似于可以安装在任何Docker-ready机器上的软件包的容器中。
- en: The only Docker-ready OS nowadays is Linux, as Docker needs to make use of the
    advanced kernel features, forcing Windows and Mac users to run a virtual machine
    with Linux in order to provide support to run Docker containers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前唯一支持Docker的操作系统是Linux，因为Docker需要利用先进的内核功能，迫使Windows和Mac用户运行带有Linux的虚拟机，以提供对Docker容器的支持。
- en: Setting up the container
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置容器
- en: Docker comes with a very powerful and familiar way (for developers) of configuring
    the containers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了一种非常强大且熟悉的方式（对于开发人员来说）来配置容器。
- en: You can create containers based on an existing image (there are thousands of
    images on the Internet) and then modify the image to fulfil your needs by adding
    new software packages or altering the filesystem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以基于现有图像（互联网上有成千上万的图像）创建容器，然后通过添加新的软件包或更改文件系统来修改图像以满足您的需求。
- en: Once we are satisfied with it, we can use the new version of the image to create
    our containers using a version control system similar to **Git**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对此满意，我们可以使用图像的新版本使用类似**Git**的版本控制系统创建我们的容器。
- en: However, we need to understand how Docker works first.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们首先需要了解Docker的工作原理。
- en: Installing Docker
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Docker
- en: 'As it was mentioned before, Docker needs a virtual machine to provide support
    on Mac and Windows, therefore, the installation on these systems may vary. The
    best way to install Docker on your system is to go to the official website and
    follow the steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker需要虚拟机来在Mac和Windows上提供支持，因此这些系统上的安装可能有所不同。在您的系统上安装Docker的最佳方法是转到官方网站并按照步骤进行操作：
- en: '[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)'
- en: At the moment, it is a very active project, so you can expect changes every
    few weeks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这是一个非常活跃的项目，因此您可以预期每隔几周就会有变化。
- en: Choosing the image
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择图像
- en: 'By default, Docker comes with no images. We can verify this by running `docker
    images` on the terminal, which will produce an output very similar to the following
    screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker不带任何图像。我们可以通过在终端上运行`docker images`来验证这一点，这将产生与以下截图非常相似的输出：
- en: '![Choosing the image](img/B04889_08_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![选择图像](img/B04889_08_04.jpg)'
- en: It is an empty list. There are no images stored in the local machine. The first
    thing we need to do is search for an image. In this case, we are going to use
    **CentOS** as our base for creating the images. CentOS is very close to Red Hat
    Enterprise Linux, which seems to be one of the most extended distributions of
    Linux in the industry. They provide great support and there is plenty of information
    available on the Internet to troubleshoot problems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个空列表。本地机器中没有存储任何图像。我们需要做的第一件事是搜索图像。在这种情况下，我们将使用**CentOS**作为创建图像的基础。 CentOS非常接近Red
    Hat Enterprise Linux，似乎是行业中最广泛使用的Linux发行版之一。他们提供了很好的支持，并且有大量的信息可用于互联网上解决问题。
- en: 'Let''s search for a CentOS image as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤搜索CentOS图像：
- en: '![Choosing the image](img/B04889_08_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![选择图像](img/B04889_08_05.jpg)'
- en: As you can see, there is a long list of images based on CentOS, but only the
    first one is official.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个基于CentOS的图像的长列表，但只有第一个是官方的。
- en: This list of images is coming from something called the **Registry** in the
    Docker world. A Docker Registry is a simple repository of images available to
    the general public. You can also run your own Registry in order to prevent your
    images from going to the general one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像列表来自Docker世界中的**Registry**。Docker Registry是一个简单的图像存储库，可供公众使用。您也可以运行自己的Registry，以防止您的图像进入公共Registry。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information can be found at the following link:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在以下链接找到：
- en: '[https://docs.docker.com/registry/](https://docs.docker.com/registry/)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/registry/](https://docs.docker.com/registry/)'
- en: There is one column in the table in the preceding screenshot that should have
    caught your attention almost immediately, the column called **STARS**. This column
    represents the rating given by the users for a given image. We can narrow the
    search based on the number of stars that the users have given to an image by using
    the `-s` flag.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面截图中的表中有一列几乎立即应该引起您的注意，即**STARS**列。该列代表用户对给定图像的评分。我们可以根据用户给定图像的星级数量来缩小搜索范围，使用`-s`标志。
- en: 'If you run the following command, you will see a list of images rated with
    1000 or more stars:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行以下命令，您将看到一个带有1000或更多星级的图像列表：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful with the images you choose, there is nothing preventing a user to
    create an image with malicious software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 选择图像时要小心，没有任何阻止用户创建带有恶意软件的图像。
- en: 'In order to fetch the CentOS image to the local machine, we need to run the
    following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将CentOS图像获取到本地机器，我们需要运行以下命令：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output produced will be very similar to the following image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的输出将与下图非常相似：
- en: '![Choosing the image](img/B04889_08_06.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![选择镜像](img/B04889_08_06.jpg)'
- en: 'Once the command finishes, if we run Docker images again, we can see that **centos**
    is now appearing in the following list:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令完成，如果我们再次运行Docker images，我们可以看到**centos**现在出现在以下列表中：
- en: '![Choosing the image](img/B04889_08_07.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![选择镜像](img/B04889_08_07.jpg)'
- en: As we specified earlier, Docker does not use the full image, but it uses a reduced
    version of it, only virtualizing the last few layers of the OS. You can clearly
    see it, as the size of the image is not even 200 MB, which for a full version
    of CentOS, can go up to a few GB.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前指定的，Docker不使用完整的镜像，而是使用它的缩小版本，只虚拟OS的最后几层。你可以清楚地看到，因为镜像的大小甚至不到200MB，而对于完整版本的CentOS来说，可能会达到几GB。
- en: Running the container
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'Now that we have a copy of the image in our local machine, it is time to run
    it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在本地机器上有了镜像的副本，是时候运行它了：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will produce the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Running the container](img/B04889_08_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![运行容器](img/B04889_08_08.jpg)'
- en: As you can see, the prompt of the terminal has changed to something like `root@debd09c7aa3b`,
    which means that we are inside the container.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，终端的提示已经改变成了类似`root@debd09c7aa3b`的东西，这意味着我们在容器内部。
- en: From now on, every single command that we run will be executed inside a contained
    version of CentOS Linux.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们运行的每个命令都将在一个包含版本的CentOS Linux中执行。
- en: 'There is another interesting command in Docker:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中还有另一个有趣的命令：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we run this command in a new terminal (without exiting from the running
    container), we will get the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在新的终端中运行这个命令（而不退出正在运行的容器），我们将得到以下输出：
- en: '![Running the container](img/B04889_08_09.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![运行容器](img/B04889_08_09.jpg)'
- en: This output is self explanatory; it is an easy way to see what is going on in
    our Docker containers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出是不言自明的；这是一个简单的方法来看看我们的Docker容器中发生了什么。
- en: Installing the required software
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装所需的软件
- en: 'Let''s install Node.js in the container:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在容器中安装Node.js：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command will pull and execute the setup script for Node.js.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将拉取并执行Node.js的设置脚本。
- en: 'This will produce an output very similar to the following image:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个与下图非常相似的输出：
- en: '![Installing the required software](img/B04889_08_29.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![安装所需的软件](img/B04889_08_29.jpg)'
- en: 'Follow the instructions, as this will install node:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明操作，这将安装node：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is highly recommended to install the development tools, as the installation
    process of a few modules requires a compilation step. Let''s do it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议安装开发工具，因为安装一些模块需要编译步骤。让我们来做吧：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the command finishes, we are ready to run the node applications inside
    our container.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令完成，我们就可以在容器内运行节点应用程序了。
- en: Saving the changes
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存更改
- en: In the Docker world, an image is the configuration for a given container. We
    can use the image as a template to run as many containers as we want, however
    first, we need to save the changes made in the previous section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker世界中，镜像是给定容器的配置。我们可以使用镜像作为模板运行尽可能多的容器，但首先，我们需要保存在上一节中所做的更改。
- en: If you are a software developer, you probably are familiar with control version
    systems such as CVS, Subversion, or Git. Docker was built with their philosophy
    in mind—a container can be treated like a versionable software component and then
    changes can be committed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是软件开发人员，你可能熟悉诸如CVS、Subversion或Git之类的控制版本系统。Docker是根据它们的理念构建的——一个容器可以被视为一个可版本化的软件组件，然后可以提交更改。
- en: 'In order to do it, run the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，运行以下命令：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command will show a list of containers that have run in the past, as shown
    in the following image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将显示过去运行过的容器的列表，如下图所示：
- en: '![Saving the changes](img/B04889_08_10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![保存更改](img/B04889_08_10.jpg)'
- en: In my case, there are few containers, but the interesting one in this case is
    the second; this is where Node.js is installed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，有一些容器，但在这种情况下有趣的是第二个；这是Node.js安装的地方。
- en: 'Now, we need to commit the status of the container in order to create a new
    image with our changes. We do it by running the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要提交容器的状态，以创建一个包含我们更改的新镜像。我们通过运行以下命令来做到这一点：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s explain the command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这个命令：
- en: The `-a` flag indicates the author. In this case, `dgonzalez`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`标志表示作者。在这种情况下，是`dgonzalez`。'
- en: The following parameter is `container id`. As we indicated earlier, the second
    container has the corresponding ID `62e7336a4627`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个参数是`容器ID`。正如我们之前所指出的，第二个容器具有相应的ID`62e7336a4627`。
- en: The third parameter is a combination of the name given to the new image and
    the tag of the image. The tagging system can be very powerful when we are dealing
    with quite a few images, as it can get really complicated to identify small variations
    between them.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是给新镜像的名称和镜像的标签的组合。当我们处理相当多的镜像时，标记系统可能非常强大，因为要在它们之间识别小的变化可能会变得非常复杂。
- en: 'It might take a few seconds, but after finishing, the output of the command
    must be very similar to the following image:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要几秒钟，但完成后，命令的输出必须与下图非常相似：
- en: '![Saving the changes](img/B04889_08_11.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![保存更改](img/B04889_08_11.jpg)'
- en: 'This is the indication that we have a new image in our list with our software
    installed. Run `docker images` again and the output will confirm it, as shown
    in the following image:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们在我们的软件列表中有一个新的镜像。再次运行`docker images`命令，输出将确认这一点，如下图所示：
- en: '![Saving the changes](img/B04889_08_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![保存更改](img/B04889_08_12.jpg)'
- en: 'In order to run a container based on the new image, we can run the following
    command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了基于新镜像运行一个容器，我们可以运行以下命令：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will give us access to the shell in the container, and we can confirm that
    Node.js is installed by running `node -v`, which should output the version of
    Node, in this case, 4.2.4.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们在容器中访问shell，并且我们可以通过运行`node -v`来确认Node.js已安装，它应该输出Node的版本，在这种情况下是4.2.4。
- en: Deploying Node.js applications
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Node.js应用程序
- en: Now, it is time to deploy Node.js applications inside the container. In order
    to do it, we are going to need to expose the code from our local machine to the
    Docker container.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在容器内部部署Node.js应用程序了。为了做到这一点，我们需要将本地机器的代码暴露给Docker容器。
- en: 'The correct way of doing it is by mounting a local folder in the Docker machine,
    but first, we need to create the small application to be run inside the container,
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的做法是通过在Docker机器中挂载一个本地文件夹，但首先，我们需要创建要在容器内运行的小应用程序，如下所示：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is a simple application, using Express that basically renders `Hello Earth!`
    into a browser. If we run it from a terminal and we access `http://localhost:80/hello`,
    we can see the results.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的应用程序，使用Express基本上在浏览器中呈现`Hello Earth!`。如果我们从终端运行它并访问`http://localhost:80/hello`，我们就可以看到结果。
- en: Now, we are going to run it inside the container. In order to do it, we are
    going to mount a local folder as a volume in the Docker container and run it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在容器内运行它。为了做到这一点，我们将一个本地文件夹作为卷挂载到Docker容器中并运行它。
- en: Docker comes from the experience of sysadmins and developers that have lately
    melted into a role called DevOps, which is somewhere in between them. Before Docker,
    every single company had its own way of deploying apps and managing configurations,
    so there was no consensus on how to do things the right way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Docker源自系统管理员和开发人员的经验，他们最近融入了一个称为DevOps的角色，介于他们之间。在Docker之前，每家公司都有自己部署应用程序和管理配置的方式，因此没有共识如何正确地做事。
- en: Now with Docker, the companies have a way to provide uniformity to deployments.
    No matter what your business is, everything is reduced to build the container,
    deploy the application, and run the container in the appropriate machine.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了Docker，公司有了一种提供部署统一性的方式。无论您的业务是什么，一切都归结为构建容器、部署应用程序并在适当的机器上运行容器。
- en: 'Let''s assume that the application is in the `/apps/test/` folder. Now, in
    order to expose it to the container, we run the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设应用程序在`/apps/test/`文件夹中。现在，为了将其暴露给容器，我们运行以下命令：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, Docker can get very verbose with parameters, but let''s explain
    them, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Docker可以使用参数非常详细，但让我们解释一下，如下所示：
- en: The `-i` and `-t` flags are familiar to us. They capture the input and send
    the output to a terminal.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`和`-t`标志对我们来说很熟悉。它们捕获输入并将输出发送到终端。'
- en: The `-v` flag is new. It specifies a volume from the local machine and where
    to mount it in the container. In this case, we are mounting `/apps/test` from
    the local machine into `/test_app`. Please note the colon symbol to separate the
    local and the remote path.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`标志是新的。它指定了本地机器的一个卷以及在容器中的挂载位置。在这种情况下，我们将本地机器上的`/apps/test`挂载到`/test_app`。请注意冒号符号来分隔本地和远程路径。'
- en: The `-p` flag specifies the port on the local machine that will expose the remote
    port in the container. In this case, we expose the port `3000` in the container
    through the port `8000` in the Docker machine, so accessing `docker-machine:8000`
    from the host machine will end up accessing the port `3000` in the container.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`标志指定本地机器上将通过的远程端口。在这种情况下，我们通过Docker机器中的端口`8000`公开容器中的端口`3000`，因此从主机机器访问`docker-machine:8000`最终会访问容器中的端口`3000`。'
- en: The `centos-microservices:1.0` is the name and tag of the image that we have
    created in the preceding section.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centos-microservices:1.0`是我们在前一节中创建的镜像的名称和标签。'
- en: The `/bin/bash` is the command that we want to execute inside the container.
    The `/bin/bash` is going to give us access to the prompt of the system.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin/bash`是我们想在容器内执行的命令。`/bin/bash`将使我们访问系统的提示符。'
- en: 'If everything worked well, we should have gotten access to the system prompt
    inside the container, as shown in the following image:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该已经获得了进入容器内的系统提示，如下图所示：
- en: '![Deploying Node.js applications](img/B04889_08_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![部署Node.js应用程序](img/B04889_08_13.jpg)'
- en: As you can see in the image, there is a folder called `/test_app` that contains
    our previous application, called `small-script.js`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在图中所看到的，有一个名为`/test_app`的文件夹，其中包含我们之前的应用程序`small-script.js`。
- en: Now, it is time to access to the app, but first, let's explain how Docker works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候访问应用程序了，但首先，让我们解释一下Docker的工作原理。
- en: Docker is written in **Go**, which is a modern language created by Google, grouping
    all the benefits from a compiled language such as C++ with all the high-level
    features from a modern language such as Java.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是用**Go**编写的，这是谷歌创建的一种现代语言，将C++等编译语言的所有优点与Java等现代语言的所有高级特性结合在一起。
- en: It is fairly easy to learn and not hard to master. The philosophy of Go is to
    bring all the benefits of an interpreted language, such as reducing the compilation
    times (the complete language can be compiled in under a minute) to a compiled
    language.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 学习起来相当容易，掌握起来也不难。Go的哲学是将解释语言的所有优点带入编译语言，比如减少编译时间（完整的语言可以在不到一分钟内编译）。
- en: Docker uses very specific features from the Linux kernel that forces Windows
    and Mac users to use a virtual machine to run Docker containers. This machine
    used to be called **boot2docker**, but the new version is called **Docker Machine**,
    which contains more advanced features such as deploying containers in remote virtual
    machines. For this example, we will only use the local capabilities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用Linux内核的非常特定的功能，这迫使Windows和Mac用户使用虚拟机来运行Docker容器。这个机器过去被称为**boot2docker**，但新版本被称为**Docker
    Machine**，其中包含更高级的功能，比如在远程虚拟机中部署容器。在这个例子中，我们只会使用本地功能。
- en: Given that, if you run the app from within the container located in the `/test_app/`
    folder, and you are in Linux, accessing `http://localhost:8000/`, it would be
    enough to get into the application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，如果您在Linux中从位于`/test_app/`文件夹中的容器内运行应用程序，并访问`http://localhost:8000/`，就足以进入应用程序。
- en: 'When you are using Mac or Windows, Docker is running either in the Docker Machine
    or boot2docker so that the IP is given by this virtual machine, which is shown
    when the Docker terminal starts, as shown in the following image:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Mac或Windows时，Docker在Docker Machine或boot2docker中运行，因此IP是由这个虚拟机给出的，在Docker终端启动时显示，如下图所示：
- en: '![Deploying Node.js applications](img/B04889_08_14.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![部署Node.js应用程序](img/B04889_08_14.jpg)'
- en: As you can see, the IP is `192.168.99.100`, so in order to access our application,
    we need to visit the `http://192.168.99.100:9000/` URL.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，IP是`192.168.99.100`，因此为了访问我们的应用程序，我们需要访问`http://192.168.99.100:9000/` URL。
- en: Automating Docker container creation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化Docker容器创建
- en: If you remember, in the previous chapters, one of the most important concepts
    was automation. Automation is the key when working with microservices. Instead
    of operating one server, you probably will need to operate few dozens, reaching
    a point where you are almost fully booked on day-to-day tasks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，在前面的章节中，最重要的概念之一是自动化。自动化是在使用微服务时的关键。您可能不需要操作一个服务器，而是需要操作几十个服务器，达到几乎完全预订每日任务的程度。
- en: Docker designers had that in mind when allowing the users to create containers
    from a script written in a file called `Dockerfile`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当允许用户从名为`Dockerfile`的文件中编写脚本创建容器时，Docker设计者考虑到了这一点。
- en: 'If you have ever worked on coding C or C++, even in college, you are probably
    familiar with `Makefiles`. A `Makefile` file is a script where the developer specifies
    the steps to automatically build a software component. Here is an example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经在C或C++编码中工作过，甚至在大学里，您可能熟悉`Makefiles`。`Makefile`文件是一个脚本，开发人员在其中指定自动构建软件组件的步骤。以下是一个示例：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding `Makefile` contains a list of tasks and dependencies to be executed.
    For example, if we execute `make clean` on the same folder where the `Makefile`
    file is contained, it will remove the executable and all the files ending with
    `o`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Makefile`包含要执行的任务和依赖项的列表。例如，如果我们在包含`Makefile`文件的同一文件夹中执行`make clean`，它将删除可执行文件和所有以`o`结尾的文件。
- en: '`Dockerfile`, unlike `Makefile`, is not a list of tasks and dependencies (even
    though the concept is the same), it is a list of instructions to build a container
    from scratch to a ready status.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`不像`Makefile`，它不是任务和依赖项的列表（尽管概念是相同的），它是一系列指令，用于从头开始构建容器到就绪状态。'
- en: 'Let''s see an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These small few preceding lines are enough to build a container having Node.js
    installed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行简短的命令足以构建一个安装了Node.js的容器。
- en: 'Let''s explain it in the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的方式来解释：
- en: First, we choose the base image. In this case, it is `centos` as we used before.
    For doing this, we use the `FROM` command and then the name of the image.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们选择基础镜像。在这种情况下，它是`centos`，就像我们之前使用的一样。为此，我们使用`FROM`命令，然后是镜像的名称。
- en: '`MAINTAINER` specifies the name of the person who created the container. In
    this case, it is `David Gonzalez`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAINTAINER`指定创建容器的人的名称。在这种情况下，是`David Gonzalez`。'
- en: '`RUN`, as its name indicates, runs a command. In this case, we use it twice:
    once to add the repository to `yum`, and then to install Node.js.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`，顾名思义，运行一个命令。在这种情况下，我们使用它两次：一次是将存储库添加到`yum`，然后安装Node.js。'
- en: 'Dockerfiles can contain a number of different commands. The documentation for
    them is pretty clear, but let''s take a look at the most common (aside from the
    ones seen before):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfiles可以包含许多不同的命令。它们的文档非常清晰，但让我们看看最常见的命令（除了之前看到的命令）：
- en: '`CMD`: This is similar to run, but it actually gets executed after building
    the command. `CMD` is the command to be used to start an application once the
    container is instantiated.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：这类似于run，但实际上是在构建命令之后执行的。`CMD`是在实例化容器后用于启动应用程序的命令。'
- en: '`WORKDIR`: This is to be used in conjunction with `CMD`, it is the command
    used to specify the work directory for the next `CMD` command.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`：这是与`CMD`一起使用的，它是用于指定下一个`CMD`命令的工作目录的命令。'
- en: '`ADD`: This command is used to copy files from the local filesystem to the
    container instance filesystem. In the previous example, we can use `ADD` to copy
    the application from the host machine into the container, run `npm install` with
    the `CMD` command, and then run the app once again with the `CMD` command. It
    can also be used to copy the content from a URL to a destination folder inside
    the container.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：此命令用于将文件从本地文件系统复制到容器实例文件系统。在前面的示例中，我们可以使用`ADD`将应用程序从主机复制到容器中，使用`CMD`命令运行`npm
    install`，然后再次使用`CMD`命令运行应用程序。它还可以用于将内容从URL复制到容器内的目标文件夹。'
- en: '`ENV`: This is used to set environment variables. For example, you could specify
    a folder to store files uploaded by passing an environment variable to the container,
    as follows:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`：用于设置环境变量。例如，您可以通过向容器传递环境变量来指定一个文件夹来存储上传的文件，如下所示：'
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`EXPOSE`: This is used to expose ports to the rest of the containers in your
    cluster.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`：用于向集群中的其他容器公开端口。'
- en: 'As you can see, the **domain-specific language** (**DSL**) of `Dockerfiles`
    is quite rich and you can pretty much build every system required. There are hundreds
    of examples on the Internet to build pretty much everything: MySQL, MongoDB, Apache
    servers, and so on.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Dockerfiles`的**领域特定语言**（**DSL**）非常丰富，您几乎可以构建所需的每个系统。互联网上有数百个示例，可以构建几乎所有内容：MySQL、MongoDB、Apache服务器等等。
- en: It is strongly recommended to create containers through `Dockerfiles`, as it
    can be used as a script to replicate and make changes to the containers in the
    future, as well as being able to automatically deploy our software without much
    manual intervention.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议通过`Dockerfiles`创建容器，因为它可以用作脚本来复制和更改将来的容器，以及能够在不需要太多手动干预的情况下自动部署我们的软件。
- en: Node.js event loop – easy to learn and hard to master
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js事件循环-易学难精
- en: We all know that Node.js is a platform that runs applications in a single-threaded
    way; so, why don't we use multiple threads to run applications so that we can
    get the benefit of multicore processors?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道Node.js是以单线程方式运行应用程序的平台；那么，为什么我们不使用多个线程来运行应用程序，以便利用多核处理器的好处呢？
- en: Node.js is built upon a library called **libuv**. This library abstracts the
    system calls, providing an asynchronous interface to the program that uses it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是建立在一个名为**libuv**的库之上。这个库抽象了系统调用，为使用它的程序提供了一个异步接口。
- en: I come from a very heavy Java background, and there, everything is synchronous
    (unless you are coding with some sort of non-blocking libraries), and if you issue
    a request to the database, the thread is blocked and resumed once the database
    replies with the data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我来自一个非常重的Java背景，在那里，一切都是同步的（除非你使用某种非阻塞库进行编码），如果你向数据库发出请求，线程就会被阻塞，直到数据库回复数据后才会恢复。
- en: 'This usually works fine, but it presents an interesting problem: a blocked
    thread is consuming resources that could be used to serve other requests. The
    event loop of Node.js is shown in the following figure:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常运行良好，但它提出了一个有趣的问题：一个阻塞的线程正在消耗资源，这些资源本可以用来处理其他请求。Node.js的事件循环如下图所示：
- en: '![Node.js event loop – easy to learn and hard to master](img/B04889_08_15.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js事件循环-易学难精](img/B04889_08_15.jpg)'
- en: This is the Node.js event loop diagram
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Node.js事件循环图表
- en: JavaScript is, by default, an event-driven language. It executes the program
    that configures a list of event handlers that will react to given events, and
    after that, it just waits for the action to take place.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JavaScript是一个事件驱动的语言。它执行配置了一系列事件处理程序的程序，这些处理程序将对给定的事件做出反应，然后，它只是等待动作发生。
- en: 'Let''s take a look at a very familiar example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个非常熟悉的例子：
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then the JavaScript code is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后JavaScript代码如下：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, this is a very simple example. HTML that shows a button and
    snippet of JavaScript code that, using JQuery, shows an alert box when the button
    is clicked.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个非常简单的例子。HTML显示了一个按钮和一小段JavaScript代码，使用JQuery，在按钮被点击时显示一个警报框。
- en: 'This is the key: *when the button is clicked*.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键：*当按钮被点击时*。
- en: Clicking a button is an event, and the event is processed through the event
    loop of JavaScript using a handler specified in the JavaScript.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮是一个事件，这个事件通过JavaScript的事件循环使用JavaScript中指定的处理程序进行处理。
- en: At the end of the day, we only have one thread executing the events, and we
    never talk about parallelism in JavaScript, the correct word is concurrency. So,
    being more concise, we can say that Node.js programs are highly concurrent.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，我们只有一个线程执行事件，我们从不谈论JavaScript中的并行性，正确的词是并发。因此，更简洁地说，Node.js程序具有高度的并发性。
- en: Your application will always be executed in only one thread, and we need to
    keep that in mind while coding.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序将始终在一个线程中执行，我们在编码时需要牢记这一点。
- en: If you have been working in Java or .NET or any other language/frameworks designed
    and implemented with thread-blocking techniques, you might have observed that
    Tomcat, when running an application, spawns a number of threads listening to the
    requests.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在Java或.NET或任何其他设计和实现了线程阻塞技术的语言/框架中工作，你可能已经观察到，当Tomcat运行应用程序时，会生成一些线程来监听请求。
- en: In the Java world, each of these threads are called **workers**, and they are
    responsible to handle the request from a given user from the beginning to the
    end. There is one type of data structure in Java that takes the benefit of it.
    It is called **ThreadLocal** and it stores the data in the local thread so that
    it can be recovered later on. This type of storage is possible because the thread
    that starts the request is also responsible to finish it, and if the thread is
    executing any blocking operation (such as reading a file or accessing a database),
    it will wait until it is completed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中，这些线程中的每一个被称为**工作者**，它们负责从开始到结束处理来自特定用户的请求。在Java中有一种数据结构可以从中获益。它被称为**ThreadLocal**，它将数据存储在本地线程中，以便以后可以恢复。这种存储是可能的，因为启动请求的线程也负责完成它，如果线程正在执行任何阻塞操作（比如读取文件或访问数据库），它将等待直到完成。
- en: This is usually not a big deal, but when your software relies heavily on I/O,
    the problems can become serious.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常不是什么大问题，但当你的软件严重依赖I/O时，问题可能会变得严重。
- en: Another big point in favor of the non-blocking model of Node.js is the lack
    of context switch.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js非阻塞模型的另一个重要优点是缺乏上下文切换。
- en: 'When the CPU switches one thread with another, what happens is that all the
    data in the registers, and other areas of the memory, is stacked and allows the
    CPU to switch the context with a new process that has its own data to be placed
    in there, as shown in the following image:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU将一个线程与另一个线程进行切换时，发生的情况是寄存器中的所有数据以及内存的其他区域都被堆叠起来，允许CPU将上下文与一个新的进程进行切换，该进程有自己的数据要放在那里，如下图所示：
- en: '![Node.js event loop – easy to learn and hard to master](img/B04889_08_16.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js事件循环-易学难精](img/B04889_08_16.jpg)'
- en: This is a diagram showing context switching in threads from the theoretical
    point of view.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示线程上下文切换的图表，从理论的角度来看。
- en: 'This operation takes time, and this time is not used by the application. It
    simply gets lost. In Node.js, your application runs in only one thread, so there
    is no such context switching while running (it is still present in the background,
    but hidden to your program). In the following image, we can see what happens in
    the real world when a CPU switches a thread:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作需要时间，而这个时间并没有被应用程序利用。它只是丢失了。在Node.js中，你的应用程序只在一个线程中运行，因此在运行时没有这样的上下文切换（它仍然存在于后台，但对你的程序是隐藏的）。在下图中，我们可以看到在现实世界中当CPU切换一个线程时会发生什么：
- en: '![Node.js event loop – easy to learn and hard to master](img/B04889_08_17.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js事件循环-易学难精](img/B04889_08_17.jpg)'
- en: This is a diagram showing context switching in threads from the practical (shows
    the dead times) point of view.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示线程上下文切换的图表，从实际（显示死时间）的角度来看。
- en: Clustering Node.js applications
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类Node.js应用程序
- en: By now, you know how Node.js applications work, and certainly, some of the readers
    may have a question that if the app runs on a single thread, then what happens
    with the modern multicore processors?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道Node.js应用程序是如何工作的，当然，一些读者可能会有一个问题，即如果应用程序在单个线程上运行，那么现代多核处理器会发生什么？
- en: Before answering this question, let's take a look at the following scenario.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这个问题之前，让我们看一下以下的情景。
- en: 'When I was in high school, there was a big technology leap in CPUs: the segmentation.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我上高中时，CPU发生了一次重大的技术飞跃：分段。
- en: 'It was the first attempt to introduce parallelism at the instruction level.
    As you probably are aware, the CPU interprets assembler instructions and each
    of these instructions are composed of a number of phases, as shown in the following
    diagram:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在指令级别引入并行性的第一次尝试。如你可能知道的，CPU解释汇编指令，每个指令由许多阶段组成，如下图所示：
- en: '![Clustering Node.js applications](img/B04889_08_18.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![聚类Node.js应用程序](img/B04889_08_18.jpg)'
- en: Before the Intel 4x86, the CPUs were executing one instruction at the time,
    so taking the instruction model from the preceding diagram, any CPU could only
    execute one instruction every six CPU cycles.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intel 4x86之前，CPU一次只执行一条指令，因此根据前面图表中的指令模型，任何CPU每六个CPU周期只能执行一条指令。
- en: 'Then, the segmentation came into play. With a set of intermediate registers,
    the CPU engineers managed to parallelize the individual phases of instructions
    so that in the best-case scenario, the CPUs are able to execute one instruction
    per cycle (or nearly), as shown in the following diagram:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，分段开始发挥作用。通过一组中间寄存器，CPU工程师们设法并行化指令的各个阶段，以便在最佳情况下，CPU能够每个周期执行一条指令（或几乎如此），如下图所示：
- en: '![Clustering Node.js applications](img/B04889_08_19.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![聚类Node.js应用程序](img/B04889_08_19.jpg)'
- en: The image describes the execution of instructions in a CPU with a segmented
    pipeline
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该图描述了CPU中指令的执行过程，具有分段管道
- en: This technical improvement led to faster CPUs and opened the door to native
    hardware multithreading, which led to the modern n-core processors that can execute
    a large number of parallel tasks, but when we are running Node.js applications,
    we only use one core.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这一技术改进导致了更快的CPU，并打开了原生硬件多线程的大门，这导致了现代的n核处理器可以执行大量的并行任务，但当我们运行Node.js应用程序时，我们只使用一个核心。
- en: If we don't cluster our app, we are going to have a serious performance degradation
    when compared to other platforms that take the benefit of the multiple cores of
    a CPU.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不对应用程序进行集群，与利用CPU的多个核心的其他平台相比，我们的性能将严重下降。
- en: However, this time we are lucky, PM2 already allows you to cluster Node.js apps
    to maximize the usage of your CPUs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一次我们很幸运，PM2已经允许你对Node.js应用程序进行集群，以最大限度地利用你的CPU。
- en: Also, one of the important aspects of PM2 is that it allows you to scale applications
    without any downtime.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PM2的一个重要方面是它允许你在没有任何停机时间的情况下扩展应用程序。
- en: 'Let''s run a simple app in the cluster mode:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以集群模式运行一个简单的应用程序：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time we have used the native HTTP library for Node.js in order to handle
    the incoming HTTP requests.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们使用了Node.js的原生HTTP库来处理传入的HTTP请求。
- en: 'Now we can run the application from the terminal and see how it works:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从终端运行应用程序并看看它是如何工作的：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although it does not output anything, we can curl to the `http://localhost:3000/`
    URL in order to see how the server responds, as shown in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不输出任何东西，但我们可以通过curl访问`http://localhost:3000/`URL来查看服务器的响应，如下面的截图所示：
- en: '![Clustering Node.js applications](img/B04889_08_20.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![聚类Node.js应用程序](img/B04889_08_20.jpg)'
- en: As you can see, Node.js has managed all the HTTP negotiation and it has also
    managed to reply with the `Here we are!` phrase as it was specified in the code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Node.js已经处理了所有的HTTP协商，并且还成功地以代码中指定的`Here we are!`短语进行了回复。
- en: This service is quite trivial, but it is the principle on which more complex
    web services work, so we need to cluster the web service to avoid bottlenecks.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这项服务相当琐碎，但它是更复杂的Web服务工作的原则，因此我们需要对Web服务进行集群以避免瓶颈。
- en: 'Node.js has one library called `cluster` that allows us to programmatically
    cluster our application, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有一个名为`cluster`的库，允许我们以编程方式对应用程序进行集群，如下所示：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Personally, I find it much easier to use specific software such as PM2 to accomplish
    effective clustering, as the code can get really complicated while trying to handle
    the clustered instances of our app.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我发现使用特定软件如PM2来实现有效的集群要容易得多，因为在尝试处理我们应用程序的集群实例时，代码可能会变得非常复杂。
- en: 'Given this, we can run the application through PM2 as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，我们可以通过PM2运行应用程序如下：
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Clustering Node.js applications](img/B04889_08_21.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![聚类Node.js应用程序](img/B04889_08_21.jpg)'
- en: The `-i` flag in PM2, as you can see in the output of the command, is used to
    specify the number of cores that we want to use for our application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在PM2中，`-i`标志用于指定我们希望为我们的应用程序使用的核心数，如你在命令的输出中所见。
- en: 'If we run `pstree`, we can see the process tree in our system and check whether
    PM2 is running only one process for our app, as shown in the following image:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`pstree`，我们可以看到系统中的进程树，并检查PM2是否只为我们的应用程序运行了一个进程，如下图所示：
- en: '![Clustering Node.js applications](img/B04889_08_22.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![聚类Node.js应用程序](img/B04889_08_22.jpg)'
- en: In this case, we are running the app in only one process, so it will be allocated
    in one core of the CPU.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只在一个进程中运行应用程序，因此它将分配在CPU的一个核心中。
- en: In this case, we are not taking advantage of the multicore capabilities of the
    CPU that is running the app, but we still get the benefit of restarting the app
    automatically if one exception bubbles up from our algorithm.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有利用CPU的多核能力，但如果我们的算法出现异常，仍然可以获得自动重新启动应用程序的好处。
- en: 'Now, we are going to run our application using all the cores available in our
    CPU so that we maximize the usage of it, but first, we need to stop the cluster:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用CPU中所有可用的核心来运行我们的应用程序，以便最大限度地利用它，但首先，我们需要停止集群：
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Clustering Node.js applications](img/B04889_08_23.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![Clustering Node.js applications](img/B04889_08_23.jpg)'
- en: PM2, after stopping all the services
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: PM2在停止所有服务后
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we are in a position to rerun the application using all the cores of our
    CPU:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新运行应用程序，利用CPU的所有核心：
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Clustering Node.js applications](img/B04889_08_24.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![Clustering Node.js applications](img/B04889_08_24.jpg)'
- en: PM2 showing four services running in a cluster mode
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: PM2显示以集群模式运行的四个服务
- en: 'PM2 has managed to guess the number of CPUs in our computer, in my case, this
    is an iMac with four cores, as shown in the following screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: PM2已经成功猜测到了我们计算机的CPU核心数，就我而言，这是一台有四个核心的iMac，如下图所示：
- en: '![Clustering Node.js applications](img/B04889_08_25.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![Clustering Node.js applications](img/B04889_08_25.jpg)'
- en: 'As you can see in `pstree`, PM2 started four threads at the OS level, as shown
    in the following image:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在`pstree`中所看到的，PM2在操作系统级别启动了四个线程，如下图所示：
- en: '![Clustering Node.js applications](img/B04889_08_26.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![Clustering Node.js applications](img/B04889_08_26.jpg)'
- en: When clustering an application, there is an unwritten rule about the number
    of cores that an application should be using and this number is the number of
    cores minus one.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群应用程序时，有一个关于应用程序应该使用的核心数的不成文规定，这个数字是核心数减一。
- en: The reason behind this number is the fact that the OS needs some CPU power so
    that if we use all the CPUs in our application, once the OS starts carrying on
    with some other tasks, it will force context switching as all the cores will be
    busy and this will slow down the application.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字背后的原因是操作系统需要一些CPU功率，所以如果我们在应用程序中使用了所有的CPU，一旦操作系统开始执行一些其他任务，它将强制进行上下文切换，因为所有的核心都将忙碌，这将减慢应用程序的速度。
- en: Load balancing our application
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡我们的应用程序
- en: Sometimes, clustering our app is not enough and we need to scale our application
    horizontally.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅仅对应用程序进行集群处理是不够的，我们需要水平扩展我们的应用程序。
- en: There are a number of ways to horizontally scale an app. Nowadays, with cloud
    providers such as Amazon, every single provider has implemented their own solution
    with a number of features.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以水平扩展应用程序。如今，随着云服务提供商如亚马逊，每个提供商都实现了自己的解决方案，并具有许多功能。
- en: One of my preferred ways of implementing the load balancing is using **NGINX**.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的负载均衡实现方式之一是使用**NGINX**。
- en: NGINX is a web server with a strong focus on the concurrency and low memory
    usage. It is also the perfect fit for Node.js applications as it is highly discouraged
    to serve static resources from within a Node.js application. The main reason is
    to avoid the application from being under stress due to a task that could be done
    better with another software, such as NGINX (which is another example of specialization).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX是一个专注于并发和低内存使用的Web服务器。它也非常适合Node.js应用程序，因为从Node.js应用程序中提供静态资源是极不鼓励的。主要原因是避免应用程序因为一个可以用另一个软件更好地完成的任务而承受压力，比如NGINX（这是另一个专业化的例子）。
- en: 'However, let''s focus on load balancing. The following figure shows how NGINX
    works as a load balancer:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们专注于负载均衡。下图显示了NGINX作为负载均衡器的工作原理：
- en: '![Load balancing our application](img/B04889_08_27.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![Load balancing our application](img/B04889_08_27.jpg)'
- en: As you can see in the preceding diagram, we have two PM2 clusters load balanced
    by an instance of NGINX.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的图表中所看到的，我们有两个PM2集群通过一个NGINX实例进行负载均衡。
- en: The first thing we need to do is know how NGINX manages the configuration.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是了解NGINX如何管理配置。
- en: On Linux, NGINX can be installed via `yum`, `apt-get`, or any other package
    manager. It can also be built from the source, but the recommended method, unless
    you have very specific requirements, is to use a package manager.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，可以通过`yum`、`apt-get`或任何其他软件包管理器安装NGINX。它也可以从源代码构建，但除非你有非常特定的要求，否则推荐的方法是使用软件包管理器。
- en: 'By default, the main configuration file is `/etc/nginx/nginx.conf`, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，主配置文件是`/etc/nginx/nginx.conf`，如下所示：
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This file is pretty straightforward, it specifies the number of workers (remember,
    processes to serve requests), the location of error logs, number connections that
    a worker can have active at the time, and finally, the HTTP configuration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件非常简单，它指定了工作进程的数量（记住，用于处理请求的进程），错误日志的位置，工作进程在同一时间可以拥有的活动连接数，最后是HTTP配置。
- en: 'The last line is the most interesting one: we are informing NGINX to use `/etc/nginx/sites-enabled/*.conf`
    as potential configuration files.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是最有趣的：我们正在告诉NGINX使用`/etc/nginx/sites-enabled/*.conf`作为潜在的配置文件。
- en: With this configuration, every file ending in `.conf` under the specified folder
    is going to be part of the NGINX configuration.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，指定文件夹中以`.conf`结尾的每个文件都将成为NGINX配置的一部分。
- en: 'As you can see, there is a default file already existing there. Modify it to
    look as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，那里已经存在一个默认文件。将其修改为如下所示：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is all the configuration we need to build a load balancer. Let''s explain
    it in the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们构建负载均衡器所需的所有配置。让我们在下面解释一下：
- en: The `upstream app` directive is creating a group of services called `app`. Inside
    this directive, we specify two servers as we've seen in the previous image.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upstream app`指令创建了一个名为`app`的服务组。在这个指令中，我们指定了两个服务器，就像在前面的图片中看到的那样。'
- en: The `server` directive specifies to NGINX that it should be listening to all
    the requests from port `80` and passing them to the group of upstream called `app`.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server`指令指定NGINX应监听来自端口`80`的所有请求，并将它们传递给名为`app`的上游服务组。'
- en: Now, how does NGINX decide to send the request to which computer?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，NGINX如何决定将请求发送到哪台计算机？
- en: In this case, we could specify the strategy used to spread the load.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以指定用于分散负载的策略。
- en: By default, NGINX, when there is not a balancing method specifically configured,
    uses **Round Robin**.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当没有特定配置负载均衡方法时，NGINX使用**轮询**。
- en: One thing to bear in mind is that if we use round robin, our application should
    be stateless as we won't be always hitting the same machine, so if we save the
    status in the server, it might not be there in the following call.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，如果我们使用轮询，我们的应用程序应该是无状态的，因为我们不会总是命中同一台机器，所以如果我们在服务器上保存状态，可能在下一次调用时不会存在。
- en: Round Robin is the most elementary way of distributing load from a queue of
    work into a number of workers; it rotates them so that every node gets the *same
    amount of requests*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询是将工作队列中的负载以最基本的方式分配给多个工作节点的方法；它会使它们轮换，以便每个节点获得*相同数量的请求*。
- en: 'There are other mechanisms to spread the load, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他机制来分散负载，如下所示：
- en: '[PRE34]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Least connected**, as its name indicates, sends the request to the least
    connected node, equally distributing the load between all the nodes:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**最少连接**，顾名思义，将请求发送到连接最少的节点，平均分配负载到所有节点：'
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**IP hashing** is an interesting way of distributing the load. If you have
    ever worked with any web application, the concept of sessions is something present
    in almost any application. In order to remember who the user is, the browser sends
    a cookie to the server, which has stored who the user is in memory and what data
    he/she needs/can be accessed by that given user. The problem with the other type
    of load balancing is that we are not guaranteed to always hit the same server.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP散列**是一种有趣的负载分配方式。如果您曾经使用过任何Web应用程序，会发现会话的概念几乎存在于任何应用程序中。为了记住用户是谁，浏览器会向服务器发送一个cookie，服务器在内存中存储了用户是谁以及该用户需要/可以访问的数据。负载均衡的另一种类型的问题在于我们不能保证总是命中同一台服务器。'
- en: For example, if we are using Least connected as a policy for balancing, we could
    hit the server one in the first load, but then hit a different server on subsequent
    redirections that will result in the user not being displayed with the right information
    as the second server won't know who the user is.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用最少连接作为负载均衡的策略，我们可能在第一次负载中命中服务器一次，但在后续重定向中命中不同的服务器，这将导致用户无法显示正确的信息，因为第二个服务器不知道用户是谁。
- en: With IP hashing, the load balancer will calculate a hash for a given IP. This
    hash will somehow result in a number from 1 to *N*, where *N* is the number of
    servers, and then, the user will always be redirected to the same machine as long
    as they keep the same IP.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IP散列，负载均衡器将为给定的IP计算一个哈希值。这个哈希值将以某种方式导致一个从1到*N*的数字，其中*N*是服务器的数量，然后，只要用户保持相同的IP，用户将始终被重定向到同一台机器。
- en: 'We can also apply a weight to the load balancing, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对负载均衡应用权重，如下所示：
- en: '[PRE36]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will distribute the load in such way that, for every six requests, five
    will be directed to the first machine and one will be directed to the second machine.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以这样的方式分配负载，即对于每六个请求，五个将被定向到第一台机器，一个将被定向到第二台机器。
- en: 'Once we have chosen our preferred load balancing method, we can restart NGINX
    for the changes to take effect, but first, we want to validate them as shown in
    the following image:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了首选的负载均衡方法，就可以重新启动NGINX以使更改生效，但首先，我们希望验证它们，如下图所示：
- en: '![Load balancing our application](img/B04889_08_28.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![负载均衡我们的应用程序](img/B04889_08_28.jpg)'
- en: As you can see, the configuration test can be really helpful in order to avoid
    configuration disasters.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，配置测试可以在避免配置灾难方面非常有帮助。
- en: 'Once NGINX has passed `configtest`, it is guaranteed that NGINX will be able
    to `restart/start/reload` without any syntax problem, as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦NGINX通过了“configtest”，就可以保证NGINX能够在没有任何语法问题的情况下进行“重新启动/启动/重新加载”，如下所示：
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Reload will gracefully wait until the old threads are done, and then, reload
    the configuration and route the new requests with the new configuration.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载将优雅地等待旧线程完成，然后重新加载配置并使用新配置路由新请求。
- en: 'If you are interested in learning about NGINX, I found the following official
    documentation of NGINX quite helpful:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣了解NGINX，我发现以下官方文档对NGINX非常有帮助：
- en: '[http://nginx.org/en/docs/](http://nginx.org/en/docs/)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://nginx.org/en/docs/](http://nginx.org/en/docs/)'
- en: Health check on NGINX
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NGINX的健康检查
- en: Health checking is one of the important activities on a load balancer. What
    happens if one of the nodes suffers a critical hardware failure and is unable
    to serve more requests?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是负载均衡器上的重要活动之一。如果其中一个节点遭受严重的硬件故障，无法提供更多请求，会发生什么？
- en: 'In this case, NGINX comes with two types of health checks: **passive** and
    **active**.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，NGINX带有两种健康检查类型：**被动**和**主动**。
- en: Passive health check
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 被动健康检查
- en: Here, NGINX is configured as a reverse proxy (as we did in the preceding section).
    It reacts to a certain type of response from the upstream servers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，NGINX被配置为反向代理（就像我们在前一节中所做的那样）。它对来自上游服务器的某种类型的响应做出反应。
- en: If there is an error coming back, NGINX will mark the node as faulty, removing
    it from the load balancing for a certain period of time before reintroducing it*.*
    With this strategy, the number of failures will be drastically reduced as NGINX
    will be constantly removing the node from the load balancer.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，NGINX将标记节点为故障，从负载均衡中移除一段时间，然后重新引入*。通过这种策略，失败次数将大大减少，因为NGINX将不断地从负载均衡器中移除节点。
- en: There are a few configurable parameters, such as `max_fails` or `fail_timeout`,
    where we can configure the amount of failures required to mark a node as invalid
    or the time out for requests.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些可配置的参数，比如`max_fails`或`fail_timeout`，我们可以配置需要多少次失败才能将节点标记为无效，或者请求的超时时间。
- en: Active health check
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主动健康检查
- en: Active health checks, unlike passive health checks, actively issue connections
    to the upstream servers to check whether they are responding correctly to the
    experiencing problems.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与被动健康检查不同，主动健康检查会主动向上游服务器发出连接，以检查它们是否正确响应正在经历的问题。
- en: 'The most simplistic configuration for active health checks in NGINX is the
    following one:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX中用于主动健康检查的最简单配置如下：
- en: '[PRE38]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are two new lines in this config file, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置文件中有两行新的内容，如下所示：
- en: '`health_check`: This enables the active health check. The default configuration
    is to issue a connection every five seconds to the host and port specified in
    the `upstream` section.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`health_check`: 这启用了主动健康检查。默认配置是每五秒向在`upstream`部分指定的主机和端口发起连接。'
- en: '`zone app test`: This is required by the NGINX configuration when enabling
    the health check.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zone app test`: 当启用健康检查时，NGINX配置需要这个。'
- en: There is a wide range of options to configure more specific health checks, and
    all of them are available in NGINX configuration that can be combined to satisfy
    the needs of different users.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种选项可以配置更具体的健康检查，所有这些选项都可以在NGINX配置中找到，可以组合以满足不同用户的需求。
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned a wide range of technologies that we can use to
    deploy microservices. By now you know how to build, deploy, and configure software
    components in such a way that we are able to homogenize a very diverse range of
    technologies. The objective of this book is to provide you the concepts required
    to start working with microservices and enable the reader to know how to look
    for the needed information.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了一系列可以用来部署微服务的技术。到目前为止，您已经知道如何构建、部署和配置软件组件，使我们能够使非常多样化的技术同质化。本书的目标是为您提供开始使用微服务所需的概念，并使读者知道如何寻找所需的信息。
- en: Personally, I have struggled to find a book that provides a summary of all the
    aspects of the life cycle of microservices and I really hope that this book covers
    this empty space.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我一直在努力寻找一本提供微服务生命周期各个方面总结的书籍，我真的希望这本书填补了这个空白。
