- en: Creating Mobile Apps with React Native
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Native创建移动应用程序
- en: 'n this chapter, we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看以下食谱：
- en: Setting things up
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置事情
- en: Adding development tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加开发工具
- en: Using native components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本机组件
- en: Adapting to devices and orientation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应设备和方向
- en: Styling and laying out your components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式和布局您的组件
- en: Adding platform-specific code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加特定于平台的代码
- en: Routing and navigation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由和导航
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the last few chapters, we showed you how to use `React` to build web applications,
    and in this chapter, we'll use a close relative, `React Native`, to develop native
    apps that you can run on Android and iOS (Apple) phones.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们向您展示了如何使用`React`构建Web应用程序，在本章中，我们将使用一个紧密相关的`React Native`来开发可以在Android和iOS（苹果）手机上运行的本机应用程序。
- en: Setting things up
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置事情
- en: 'For development of mobile apps, there are several possible approaches:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动应用程序的开发，有几种可能的方法：
- en: '*Use native languages*, with possibilities such as Java or Kotlin for Android,
    or Objective C or Swift for iOS, using the native development tools for each platform.
    This can make sure that your app has the best fit for different phones, but will
    require multiple teams of developers, each with experience of a specific platform.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用本机语言*，例如Java或Kotlin用于Android，或Objective C或Swift用于iOS，使用每个平台的本机开发工具。这可以确保您的应用程序最适合不同的手机，但需要多个开发团队，每个团队都有特定平台的经验。'
- en: '*Use a pure website* that the user can visit with the phone''s browser. This
    is the simplest solution, but the application will have limitations, such as not
    being able to access most of the phone''s features because they cannot be used
    in HTML. Also, running with a wireless connection, which may vary in strength,
    can sometimes prove hard. You can use any framework for this development, such
    as `React`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯网站，用户可以通过手机浏览器访问。这是最简单的解决方案，但应用程序会有一些限制，比如无法访问大多数手机功能，因为它们无法在HTML中使用。此外，使用无线连接运行，信号强度可能会有所不同，有时可能会很困难。您可以使用任何框架进行开发，比如`React`。
- en: '*Develop a hybrid application*, which is a web page, bundled with a browser
    that includes a set of extensions so that you can use the phone''s internal features.
    For the user, this is a single standalone application, which runs even without
    a web connection, and that can use most of the phone''s features. These applications
    frequently use Apache Cordova, or a derived product, PhoneGap.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发混合应用程序*，这是一个网页，捆绑了一个浏览器，包括一组扩展，以便您可以使用手机的内部功能。对于用户来说，这是一个独立的应用程序，即使没有网络连接也可以运行，并且可以使用大多数手机功能。这些应用程序通常使用Apache
    Cordova或其衍生产品PhoneGap。'
- en: There's a fourth style, provided by `React Native`, which was developed by Facebook,
    along the lines of the existing `React`. Instead of rendering components to a
    browser's DOM, `React Native` (which, from now on, we'll shorten to *RN*) invokes
    native APIs to create internal components that are handled through your JS code.
    There are some differences between the usual HTML elements and RN's components,
    but they are not too hard to overcome. With this tool, you are actually building
    a native app that looks and behaves exactly as any other native application, except
    that you use a single language, JS, for both Android and iOS development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第四种风格，由Facebook开发的`React Native`，沿用了现有的`React`。`React Native`（从现在开始，我们将缩写为*RN*）不是将组件呈现到浏览器的DOM，而是调用本机API来创建通过您的JS代码处理的内部组件。通常的HTML元素和RN的组件之间存在一些差异，但并不难克服。使用这个工具，您实际上正在构建一个外观和行为与任何其他本机应用程序完全相同的本机应用程序，只是您使用了一种语言JS，用于Android和iOS开发。
- en: In this recipe, we'll set up a RN application so that we can start trying our
    hand at developing apps for mobile phones.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将设置一个RN应用程序，以便我们可以开始尝试开发手机应用程序。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are three ways to set up a RN application: completely manually, which
    you won''t want to do; secondly, with packages, using the `react-native-cli` command-line
    interface; or lastly, by using a package very similar to what we already used
    for `React`, `create-react-native-app` (from now on, we''ll refer to this as *CRAN*).
    A key difference between the two packages is that with the latter, you cannot
    include custom native modules, and if you need to do so, you''ll have to *eject*
    the project, which will also require setting up several other tools.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种设置RN应用程序的方法：完全手动设置，这是您不想做的；其次，使用`react-native-cli`命令行界面进行打包；或者最后，使用一个与我们已经用于`React`非常相似的包，`create-react-native-app`（从现在开始，我们将称其为*CRAN*）。这两个包之间的一个关键区别是，对于后者，您无法包含自定义的本地模块，如果需要这样做，您将不得不*弹出*项目，这也需要设置其他几个工具。
- en: You can read more about the two latter methods at [https://facebook.github.io/react-native/docs/getting-started.html](https://facebook.github.io/react-native/docs/getting-started.html),
    and if you want to be prepared for ejecting, go to [https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md](https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://facebook.github.io/react-native/docs/getting-started.html](https://facebook.github.io/react-native/docs/getting-started.html)了解更多关于后两种方法的信息，如果您想为弹出做好准备，可以访问[https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md](https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md)。
- en: 'We start by getting a command-line utility, which will include plenty of other
    packages:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要获取一个命令行实用程序，其中包括许多其他包：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Afterwards, we can create and run a simple project with just three commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用只有三个命令的简单项目创建和运行一个简单的项目：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You're set! Let's see how it works—and yes, we still have some more configuration
    to do, but it's good to check whether things are going well so far.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经准备好了！让我们看看它是如何工作的——是的，我们还有一些配置要做，但检查一下事情是否进行得很顺利是件好事。
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you run your app, it starts a server at your machine, at port `19000`
    or `19001`, to which you will connect using the `Expo` application, which you
    can find at [https://expo.io/learn](https://expo.io/learn), available for both
    Android or iOS. Install it by following the instructions onscreen:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，它会在您的机器上的端口`19000`或`19001`启动服务器，您将使用`Expo`应用程序连接到该服务器，您可以在[https://expo.io/learn](https://expo.io/learn)找到该应用程序，适用于Android或iOS。按照屏幕上的说明进行安装：
- en: '![](img/515f38da-eefb-46bc-9cea-c7b4cf0818d0.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/515f38da-eefb-46bc-9cea-c7b4cf0818d0.png)'
- en: The initial screen you get when you fire up your app
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序时获得的初始屏幕
- en: 'When you open the `Expo` app for the first time, it will look like the following
    screenshot. Note that both the phone and your machine must be in the same local
    network, and your machine must also allow connections to ports `19000` and `19001`;
    you may have to modify your firewall for this to work:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次打开`Expo`应用程序时，它将看起来像以下截图。请注意，手机和您的机器必须在同一本地网络中，并且您的机器还必须允许连接到端口`19000`和`19001`；您可能需要修改防火墙才能使其正常工作：
- en: '![](img/8954ddfd-4485-4498-a9a4-5800a256674b.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8954ddfd-4485-4498-a9a4-5800a256674b.png)'
- en: On loading the Expo app, you'll have to scan the QR code in order to connect
    to the server
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载Expo应用程序时，您需要扫描QR码以连接到服务器
- en: 'After you use the Scan QR Code option, there will be some synchronization,
    and soon you''ll get to see your basic code running with no problems:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扫描QR码选项后，将进行一些同步，很快您将看到您的基本代码运行正常：
- en: '![](img/3283acff-a484-42cc-9944-4631a406b48b.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3283acff-a484-42cc-9944-4631a406b48b.png)'
- en: Success—your code is up and running!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 成功——您的代码已经运行起来了！
- en: 'Furthermore, if you modify the `App.js` source code, the changes will be immediately
    reflected in your device, which means all is well! To make sure this happens,
    shake the phone to enable the debugging menu, and make sure that Live Reload and
    Hot Reloading are enabled. You''ll also require Remote JS Debugging for later.
    Your phone should look as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您修改`App.js`源代码，更改将立即反映在您的设备上，这意味着一切正常！为了确保这一点，摇动手机以启用调试菜单，并确保启用了实时重新加载和热重新加载。您还需要远程JS调试以备后用。您的手机应该如下所示：
- en: '![](img/d61a0ed6-b6f7-43ed-b90e-13d4a50bd516.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d61a0ed6-b6f7-43ed-b90e-13d4a50bd516.png)'
- en: These settings enable reloading and debugging
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置可以重新加载和调试
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: By using the `Expo` client, CRAN lets you develop for iOS, even if you don't
    own an Apple computer. (You cannot develop for Apple systems if you have a Windows
    or Linux machine; you must have a MacBook or similar; this is a restriction of
    Apple's.) Also, working on an actual device is better in some ways, because you
    can actually see what the final user will see—no question about it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Expo`客户端，CRAN可以让您为iOS开发，即使您没有苹果电脑。（如果您有Windows或Linux机器，则无法为苹果系统开发；您必须拥有MacBook或类似设备；这是苹果的限制。）此外，在实际设备上工作在某些方面更好，因为您可以实际看到最终用户将看到的内容——毫无疑问。
- en: However, there may be a couple of reasons why you would want to work differently,
    perhaps with an emulator on your computer that simulates real-life devices. Firstly,
    it may be difficult for you to get a dozen or so of the most popular devices in
    order to test your application on each of them. Secondly, it's more convenient
    to work on your own machine only, where you can easily debug, take screenshots,
    copy and paste, and so on. So, you could install Xcode or the Android SDK to enable
    yourself to work with emulated machines.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能有几个原因希望以不同方式工作，也许是在计算机上使用模拟真实设备的模拟器。首先，您可能很难获得十几个最受欢迎的设备，以便在每个设备上测试您的应用程序。其次，在自己的机器上工作更加方便，您可以轻松进行调试，截图，复制和粘贴等。因此，您可以安装Xcode或Android
    SDK以使自己能够使用模拟机器进行工作。
- en: We won't be going into details here, because there are a lot of combinations
    depending on your development OS and the target OS; rather, let's point you to
    the documentation at [https://facebook.github.io/react-native/docs/getting-started.html](https://facebook.github.io/react-native/docs/getting-started.html),
    where you should click on Building Projects with Native Code, and see what's needed
    in order to work with emulators. After having installed them, you will need the
    `Expo` client (as for your actual device) and then you'll be able to run your
    code on your own machine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细介绍，因为根据您的开发操作系统和目标操作系统有很多组合；相反，让我们指向文档[https://facebook.github.io/react-native/docs/getting-started.html](https://facebook.github.io/react-native/docs/getting-started.html)，在那里您应该点击使用本机代码构建项目，并查看与模拟器一起工作所需的内容。安装完毕后，您将需要`Expo`客户端（与您的实际设备一样），然后您将能够在自己的机器上运行代码。
- en: 'For instance, take a look at the Android emulator simulating a Nexus 5 in the
    following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下以下截图中模拟Nexus 5的Android模拟器：
- en: '![](img/58237379-2a4d-4820-8922-7acf6d4ec249.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58237379-2a4d-4820-8922-7acf6d4ec249.png)'
- en: An emulated Nexus 5 running Android, directly on your screen
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的屏幕上直接运行的模拟Nexus 5 Android
- en: 'With this emulator, you have exactly the same functionality as with an actual
    device. For example, you can also get the debugging menu, though opening it will
    be different; for example, on my Linux machine, I needed to press *Ctrl* + *M*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模拟器，您将具有与实际设备完全相同的功能。例如，您还可以获得调试菜单，尽管打开它的方式会有所不同；例如，在我的Linux机器上，我需要按*Ctrl*
    + *M*：
- en: '![](img/89419e1a-12c7-44da-92af-4c5e72d9d213.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89419e1a-12c7-44da-92af-4c5e72d9d213.png)'
- en: All the functionality that is available on your phone is also available with
    emulated devices
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在手机上可用的功能在模拟设备上也同样可用
- en: Using the **Android Virtual Device** (**AVD**) manager, you can create lots
    of different emulators for phones and tablets; you get similar functionality with
    Xcode, though that will only work on macOS computers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Android虚拟设备**（**AVD**）管理器，您可以为手机和平板电脑创建许多不同的模拟器；使用Xcode，您也可以获得类似的功能，尽管这仅适用于macOS计算机。
- en: Adding development tools
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加开发工具
- en: Now, let's now get a better configuration going. As in previous chapters, we
    want to have ESLint for code checking, `Prettier` for formatting, and `Flow` for
    data types. CRAN takes care of including `Babel` and `Jest`, so we won't have
    to do anything for those two.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更好地配置一下。与之前的章节一样，我们希望使用ESLint进行代码检查，`Prettier`进行格式化，`Flow`进行数据类型检查。CRAN负责包含`Babel`和`Jest`，所以我们不需要为这两个做任何事情。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: As opposed to what happened with `React`, where we had to add a special `rewiring`
    package in order to work with specific configurations, in RN, we can just add
    some packages and configuration files, and we'll be ready to go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与在`React`中需要添加特殊的`rewiring`包才能使用特定配置的情况相反，在RN中，我们只需要添加一些包和配置文件，就可以准备好了。
- en: Adding ESLint
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加ESLint
- en: 'For ESLint, we''ll have quite a list of packages we want. We used most of them
    in `React`, but there''s a special addition, `eslint-plugin-react-native`, which
    adds a few RN-specific rules:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ESLint，我们需要相当多的包。我们在`React`中使用了大部分，但还有一个特殊的添加，`eslint-plugin-react-native`，它添加了一些RN特定的规则：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you want to learn more about the (actually few) extra rules added by `eslint-plugin-react-native`,
    check out its GitHub page at [https://github.com/Intellicode/eslint-plugin-react-native](https://github.com/Intellicode/eslint-plugin-react-native).
    Most of them have to do with styles, and one is applied for platform-specific
    code, but we'll get to this later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解`eslint-plugin-react-native`添加的（实际上很少的）额外规则，请查看其GitHub页面[https://github.com/Intellicode/eslint-plugin-react-native](https://github.com/Intellicode/eslint-plugin-react-native)。其中大部分与样式有关，还有一个是用于特定平台代码的，但我们稍后会讨论这个。
- en: 'We''ll require a separate `.eslintrc` file, as we did with `React`. The appropriate
    contents includes the following, and I''ve highlighted the RN-specific additions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个单独的`.eslintrc`文件，就像我们在`React`中所做的一样。适当的内容包括以下内容，我已经突出显示了RN特定的添加内容：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding Flow
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Flow
- en: 'Having completed that, `ESLint` is set to recognize our code, but we have to
    configure `Flow` as well:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`ESLint`已经设置好识别我们的代码，但我们还需要配置`Flow`：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll have to add a couple of lines to the `scripts` section of `package.json`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`package.json`的`scripts`部分添加几行：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we have to initialize the working directories of `Flow`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要初始化`Flow`的工作目录：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we can use the same `.flowconfig` files that we used earlier for React:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用与之前React相同的`.flowconfig`文件：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are now set to use `Flow`, so we can keep working in the style we were accustomed
    to—we just have to add `Prettier` to format our code, and we'll be on our way!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用`Flow`，所以我们可以继续以我们习惯的方式工作——我们只需要添加`Prettier`来格式化我们的代码，然后我们就可以开始了！
- en: Adding Prettier
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Prettier
- en: 'There''s not much to re-installing `Prettier`, and all we need is a `npm` command,
    plus the `.prettierrc` file we''ve been working with. For the former, just use
    the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重新安装`Prettier`并没有太多的事情，我们只需要一个`npm`命令，再加上我们一直在使用的`.prettierrc`文件。对于前者，只需使用以下命令：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For configuration, we can use the contents of this `.prettierrc` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置，我们可以使用这个`.prettierrc`文件的内容：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we are set! We can check it's working; let's do that.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好了！我们可以检查它是否工作；让我们来做吧。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s check that everything is OK. We''ll start by looking at the `App.js`
    file that was created by CRAN, and we can immediately verify that the tools work—because
    a problem is detected! Have a look at the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一切是否正常。我们将首先查看CRAN创建的`App.js`文件，我们可以立即验证工具是否正常工作——因为检测到了一个问题！看一下以下截图：
- en: '![](img/66dd3473-9ef7-42f3-a8e2-f0a6a54816e6.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66dd3473-9ef7-42f3-a8e2-f0a6a54816e6.png)'
- en: We can verify that ESLint integration is working, because it highlights a problem
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证ESLint集成是否正常工作，因为它会突出显示一个问题
- en: 'The rule that fails is a new one, from `eslint-plugin-react-native`: `no-color-literals`,
    because we are using constants in styling, which could prove to be a maintenance
    headache in the future. We can solve that by adding a variable, and we''ll use
    a type declaration to make sure `Flow` is also running. The new code should be
    as follows—I''ve highlighted the required changes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的规则是来自`eslint-plugin-react-native`的新规则：`no-color-literals`，因为我们在样式中使用了常量，这可能在将来会成为一个维护的头疼。我们可以通过添加一个变量来解决这个问题，并且我们将使用类型声明来确保`Flow`也在运行。新的代码应该如下所示——我已经突出显示了所需的更改：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, now that we have restored all our tools, we can get started with actual
    code!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经恢复了所有的工具，我们可以开始实际的代码了！
- en: Using native components
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原生组件
- en: 'Working with RN is very much like working with `React`—there are components,
    state, props, life cycle events, and so on—but there is a key difference: your
    own components won''t be based on HTML, but on specific RN ones. For instance,
    you won''t be using `<div>` elements, but rather `<View>` ones, which will be
    then mapped by RN to a `UIView` for iOS, or to an `Android.View` for Android.
    Views can be nested inside views, just as `<div>` tags can be. Views support layout
    and styling, they respond to touch events and more, so they are basically equivalent
    to `<div>` tags, leaving aside the mobile environment behaviors and specifics.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RN的工作方式非常类似于使用`React`——有组件、状态、属性、生命周期事件等等，但有一个关键区别：你自己的组件不是基于HTML，而是基于特定的RN组件。例如，你不会使用`<div>`元素，而是使用`<View>`元素，然后RN将其映射到iOS的`UIView`或Android的`Android.View`。视图可以嵌套在视图中，就像`<div>`标签一样。视图支持布局和样式，它们响应触摸事件等等，因此它们基本上等同于`<div>`标签，除了移动环境的行为和特定性。
- en: 'There are more differences: components also have different properties than
    the HTML ones, and you''ll have to go through the documentation (at [https://facebook.github.io/react-native/docs/components-and-apis](https://facebook.github.io/react-native/docs/components-and-apis))
    to learn about all the possibilities for each specific component.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的不同之处：组件的属性也与HTML的不同，你需要查看文档（在[https://facebook.github.io/react-native/docs/components-and-apis](https://facebook.github.io/react-native/docs/components-and-apis)）来了解每个特定组件的所有可能性。
- en: You are not limited to using the components that RN provides you with. You can
    extend your project by using native components developed by other people; for
    this, a top notch source is the Awesome React Native list, at [http://www.awesome-react-native.com/](http://www.awesome-react-native.com/).
    Note that it's likely that you'll have to eject your project in order to do this,
    so check [https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md](https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md)
    for more.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅限于使用RN提供的组件。您可以通过使用其他人开发的本机组件来扩展您的项目；一个一流的来源是令人敬畏的React Native列表，网址为[http://www.awesome-react-native.com/](http://www.awesome-react-native.com/)。请注意，您可能需要弹出您的项目才能这样做，因此请查看[https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md](https://github.com/react-community/create-react-native-app/blob/master/EJECTING.md)获取更多信息。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s start by going over the list of RN components and APIs you may want
    to use, and afterward, we''ll move to some actual code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先浏览一下您可能想要使用的RN组件和API的列表，然后我们将转移到一些实际的代码：
- en: '| **RN Component** | **Replaces...** | **Objective** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **RN组件** | **替代...** | **目的** |'
- en: '| `ActivityIndicator` | animated GIF | A component to display a circular loading
    indicator |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `ActivityIndicator` | 动画GIF | 用于显示循环加载指示器的组件 |'
- en: '| `Button` | `button` | A component to handle touches (clicks) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Button` | `button` | 处理触摸（点击）的组件 |'
- en: '| `DatePickerAndroid` `TimePickerAndroid` | `input type="date"` `input type="time"`
    | An API that shows a popup where you can enter a date and a time; for Android
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `DatePickerAndroid` `TimePickerAndroid` | `input type="date"` `input type="time"`
    | 显示弹出窗口的API，您可以在其中输入日期和时间；适用于Android |'
- en: '| `DatePickerIOS` | `input type="date"` `input type="datetime-local"`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '| `DatePickerIOS` | `input type="date"` `input type="datetime-local"`'
- en: '`input type="time"` | A component where the user can enter a date and time;
    for iOS |'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`input type="time"` | 用户可以输入日期和时间的组件；适用于iOS |'
- en: '| `FlatList` | - | A list component that only renders elements that are visible;
    used for performance gains |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `FlatList` | - | 仅呈现可见元素的列表组件；用于提高性能 |'
- en: '| `Image` | `img` | A component to display an image |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `Image` | `img` | 用于显示图像的组件 |'
- en: '| `Picker` | `select` | A component to pick a value from a list |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Picker` | `select` | 从列表中选择值的组件 |'
- en: '| `Picker.Item` | `option` | A component to define values for the list |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `Picker.Item` | `option` | 用于定义列表的值的组件 |'
- en: '| `ProgressBarAndroid` | - | A component to show activity; for Android only
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `ProgressBarAndroid` | - | 用于显示活动的组件；仅适用于Android |'
- en: '| `ProgressViewIOS` | - | A component to show activity; for iOS only |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `ProgressViewIOS` | - | 用于显示活动的组件；仅适用于iOS |'
- en: '| `ScrollView` | - | Scrolling container that may contain multiple components
    and views |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ScrollView` | - | 可包含多个组件和视图的滚动容器 |'
- en: '| `SectionList` | - | Similar to `FlatList`, but allows for sectioned lists
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `SectionList` | - | 类似于`FlatList`，但允许分段列表 |'
- en: '| `Slider` | `input type="number"` | A component to select a value from a range
    of values |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Slider` | `input type="number"` | 从一系列值中选择值的组件 |'
- en: '| `StatusBar` | - | A component to manage the app status bar |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `StatusBar` | - | 管理应用程序状态栏的组件 |'
- en: '| `StyleSheet` | CSS | Apply styling to your app |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `StyleSheet` | CSS | 为您的应用程序应用样式 |'
- en: '| `Switch` | `input type="checkbox"` | A component to accept a Boolean value
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Switch` | `input type="checkbox"` | 用于接受布尔值的组件 |'
- en: '| `Text` | - | A component to display text |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Text` | - | 用于显示文本的组件 |'
- en: '| `TextInput` | `input type="text"` | A component to enter text using the keyboard
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `TextInput` | `input type="text"` | 用键盘输入文本的组件 |'
- en: '| `TouchableHighlight` `TouchableOpacity` | - | Wrapper to make views respond
    to touches |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `TouchableHighlight` `TouchableOpacity` | - | 使视图响应触摸的包装器 |'
- en: '| `View` | `div` | A basic structural feature for your app |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `View` | `div` | 应用程序的基本结构特征 |'
- en: '| `VirtualizedList` | - | An even more flexible version of `FlatList` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `VirtualizedList` | - | `FlatList`的更灵活版本 |'
- en: '| `WebView` | `iframe` | A component to render web content |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `WebView` | `iframe` | 用于呈现网络内容的组件 |'
- en: 'There are also many APIs that you may be interested in; some of them are as
    follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多您可能感兴趣的API；其中一些如下：
- en: '| **API** | **Description** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `Alert` | Displays an alert dialog with the given title and text |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Alert` | 显示具有给定标题和文本的警报对话框 |'
- en: '| `Animated` | Simplifies creating animations |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Animated` | 简化创建动画 |'
- en: '| `AsyncStorage` | An alternative to `LocalStorage` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `AsyncStorage` | `LocalStorage`的替代方案 |'
- en: '| `Clipboard` | Provides access for getting and setting clipboard content |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Clipboard` | 提供获取和设置剪贴板内容的访问权限 |'
- en: '| `Dimensions` | Provides access to the device dimensions and orientation changes
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Dimensions` | 提供设备尺寸和方向变化的访问权限 |'
- en: '| `Geolocation` | Provides access to geolocation; available only for ejected
    projects |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `Geolocation` | 提供地理位置访问权限；仅适用于已弹出的项目 |'
- en: '| `Keyboard` | Allows control of keyboard events |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Keyboard` | 允许控制键盘事件 |'
- en: '| `Modal` | Displays content above a view |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `Modal` | 显示在视图上方的内容 |'
- en: '| `PixelRatio` | Provides access to the device pixel density |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `PixelRatio` | 提供设备像素密度的访问 |'
- en: '| `Vibration` | Allows control of device vibration |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `Vibration` | 允许控制设备振动 |'
- en: To have as few problems as possible, you might prefer to eschew platform-specific
    components and APIs, and make do with the generic, compatible components. However,
    if you are determined to use some Android or iOS-specific elements, have a look
    at [https://facebook.github.io/react-native/docs/platform-specific-code](https://facebook.github.io/react-native/docs/platform-specific-code)
    for details on how to do it; it's not complex. Remember, however, that this will
    become harder to maintain, and will probably change some interactions or screen
    designs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能少出问题，您可能更喜欢避开特定平台的组件和API，并使用通用的兼容组件。但是，如果您决定使用一些特定于Android或iOS的元素，请查看[https://facebook.github.io/react-native/docs/platform-specific-code](https://facebook.github.io/react-native/docs/platform-specific-code)了解如何操作的详细信息；这并不复杂。但是请记住，这将变得更难以维护，并且可能会改变一些交互或屏幕设计。
- en: 'Now, let''s revisit an example we wrote for `React` in [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml),
    *Developing with React*, the countries and regions page, which will also let us
    use `Redux` and async calls, as in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding Your Application*. Since we are using `PropTypes`, we''ll need that
    package. Install it with the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新访问我们在[第6章](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml)中为`React`编写的示例，*使用React开发*，国家和地区页面，这也将让我们使用`Redux`和异步调用，就像[第8章](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml)中那样，*扩展你的应用程序*。由于我们使用了`PropTypes`，我们将需要该包。使用以下命令安装它：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we''ll have to reinstall some packages, starting with `Redux` and relatives.
    Actually, CRAN already includes `redux` and `react-redux`, so we don''t need those,
    but `redux-thunk` isn''t included. If you had created the project in a different
    fashion, without using CRAN, you would have needed to install all three packages
    manually. In both cases, the following command would do, because `npm` won''t
    install an already installed package:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将不得不重新安装一些包，从`Redux`和相关的开始。实际上，CRAN已经包括了`redux`和`react-redux`，所以我们不需要这些，但`redux-thunk`没有包括在内。如果你以不同的方式创建了项目，而没有使用CRAN，你将需要手动安装这三个包。在这两种情况下，以下命令都可以使用，因为`npm`不会安装已经安装的包：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll also be using `axios` for async calls, as we did earlier in this book:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在本书中早些时候使用`axios`进行异步调用：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By default, RN provides `fetch` instead of `axios`. However, RN includes the
    `XMLHttpRequest` API, which allows us to install `axios` with no problems. For
    more on network handling, check out [https://facebook.github.io/react-native/docs/network](https://facebook.github.io/react-native/docs/network).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，RN提供了`fetch`而不是`axios`。然而，RN包括了`XMLHttpRequest`API，这使我们可以毫无问题地安装`axios`。有关网络处理的更多信息，请查看[https://facebook.github.io/react-native/docs/network](https://facebook.github.io/react-native/docs/network)。
- en: 'Our final step will be to run the server code that we wrote back in [Chapter
    4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml), *Implementing RESTful Services
    with Node*, so that our app will be able to do async calls. Go to the directory
    for that chapter, and just enter the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步将是运行我们在[第4章](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml)中编写的服务器代码，*使用Node实现RESTful服务*，这样我们的应用程序将能够进行异步调用。转到该章节的目录，然后输入以下命令：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we're set! Let's now see how we can modify our code to make it appropriate
    for RN.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好了！现在让我们看看如何修改我们的代码，使其适用于RN。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Since RN uses its own components, your HTML experience will be of little use.
    Here, we''ll see some changes, but in order to derive the full benefits of all
    of RN''s possibilities, you''ll have to study its components on your own. Let''s
    start with the `<RegionsTable>` component, which was rather simple. We saw its
    original code in the *Defining Components* section of [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml),
    *Developing with React*; here, let''s focus on the differences, which are all
    constrained to the `render()` method. Earlier, we use `<div>` tags and displayed
    texts in them; here, with RN, we''re required to use the `<View>` and `<Text>`
    elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RN使用自己的组件，你的HTML经验将没有多少用处。在这里，我们将看到一些变化，但为了充分利用RN的所有可能性，你将需要自己学习它的组件。让我们从`<RegionsTable>`组件开始，它相当简单。我们在[第6章](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml)的*使用React开发*部分看到了它的原始代码；在这里，让我们专注于差异，这些差异都限制在`render()`方法中。之前，我们使用`<div>`标签并在其中显示文本；在这里，使用RN，我们需要使用`<View>`和`<Text>`元素：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that there are no changes in the rest of the component, and all your
    `React` knowledge is still valid; you just have to adjust the output of your rendering
    method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在组件的其余部分没有变化，你所有的`React`知识仍然有效；你只需要调整你的渲染方法的输出。
- en: 'Next, we''ll change the `<CountrySelect>` component to use `<Picker>`, which
    is sort of similar, but we''ll require some extra modifications. Let''s take a
    look at our component, highlighting the parts where changes are needed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改`<CountrySelect>`组件以使用`<Picker>`，这有点类似，但我们需要一些额外的修改。让我们看看我们的组件，突出显示需要进行更改的部分：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lots of changes! Let''s go through them in the order they occur:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 很多变化！让我们按照它们发生的顺序来看：
- en: 'An unexpected change: if you want a `<Picker>` component to display its current
    value, you must set its `selectedValue` property; otherwise, even if the user
    selects a country, the change won''t be seen onscreen. We''ll have to provide
    an extra prop, `currentCountry`, which we''ll get from the store, so we can use
    it as the `selectedValue` for our list.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个意外的变化：如果你想让`<Picker>`组件显示其当前值，你必须设置它的`selectedValue`属性；否则，即使用户选择了一个国家，变化也不会在屏幕上显示出来。我们将不得不提供一个额外的属性`currentCountry`，我们将从存储中获取它，这样我们就可以将它用作我们列表的`selectedValue`。
- en: The fired event when the user selects a value is also different; the event handler
    will be called directly with the chosen value, instead of with an event from which
    to work with `event.target.value`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户选择一个值时触发的事件也是不同的；事件处理程序将直接调用选择的值，而不是使用`event.target.value`来处理事件。
- en: We have to replace the `<select>` element with `<Picker>`, and provide a `prompt`
    text prop that will be used when the expanded list is shown onscreen.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须用`<Picker>`替换`<select>`元素，并提供一个`prompt`文本属性，当扩展列表显示在屏幕上时将使用它。
- en: We have to use `<Item>` elements for the individual options, noting that the
    `label` to be displayed is now a prop.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须使用`<Item>`元素来表示单个选项，注意要显示的`label`现在是一个属性。
- en: 'Let''s not forget the change when connecting the list of countries to the store;
    we''ll only have to add an extra property to the `getProps()` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记连接国家列表到存储时的更改；我们只需要在`getProps()`函数中添加一个额外的属性：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, all we need to do is see how the main app is set up. Our `App.js` code
    will be quite simple:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做的就是看一下主应用是如何设置的。我们的`App.js`代码将非常简单：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is pretty straightforward. The rest of the setup will be in the `main.js`
    file, which has some interesting details:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。其余的设置将在`main.js`文件中进行，其中有一些有趣的细节：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Apart from the usage of `<View>` wherever we would previously have used `<div>`
    (a change to which you should already have gotten used to), there''s an added
    detail: we don''t want the status bar to show, so we use the `<StatusBar>` element,
    and make sure to hide it.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在以前使用`<div>`的地方使用`<View>`（这是一个你应该已经习惯的变化）之外，还有一个额外的细节：我们不希望显示状态栏，因此我们使用`<StatusBar>`元素，并确保隐藏它。
- en: OK, that's it! When writing code for RN, at first you'll have to make some effort
    to remember what elements are the equivalent of your old and familiar HTML ones,
    and which props or events change, but aside from that, all your previous knowledge
    will still be valid. To finish, let's see our app running.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就是这样！在编写RN代码时，起初你需要努力记住哪些元素相当于你以前熟悉的HTML元素，哪些属性或事件发生了变化，但除此之外，你以前的所有知识仍然有效。最后，让我们看看我们的应用程序运行。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Just for variety, instead of using my mobile phone, as I did earlier in this
    chapter, I decided to use an emulated device. After starting the application with
    `npm start`, I started my device, and soon got the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了多样化，我决定使用模拟设备，而不是像本章前面那样使用我的手机。在使用`npm start`启动应用程序后，我启动了我的设备，很快就得到了以下结果：
- en: '![](img/7392d569-17d1-45d7-8300-ec9aab4cc490.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7392d569-17d1-45d7-8300-ec9aab4cc490.png)'
- en: Our application, just loaded, waiting for the user to select a country
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序刚刚加载，等待用户选择国家
- en: 'If the user touches the `<Picker>` element, a popup will be displayed, listing
    the countries that were received from our Node server, as shown in the following
    screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户触摸`<Picker>`元素，将显示一个弹出窗口，列出从我们的Node服务器接收到的国家，如下面的屏幕截图所示：
- en: '![](img/d9ed4754-6e5a-417c-a381-c5a689ab6f14.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9ed4754-6e5a-417c-a381-c5a689ab6f14.png)'
- en: Upon touching on the list of countries, a popup shows up so that the user can
    select the desired country
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸国家列表时，将显示一个弹出窗口，以便用户选择所需的国家。
- en: 'When the user actually taps on a country, the `onValueChange` event is fired,
    and after calling the server, the list of regions is displayed, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户实际点击一个国家时，将触发`onValueChange`事件，并在调用服务器后显示区域列表，如下所示：
- en: '![](img/d672fec4-b9a2-4230-b132-7e844a4e3bcb.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d672fec4-b9a2-4230-b132-7e844a4e3bcb.png)'
- en: After picking a country, the list of its regions is displayed, as in our earlier
    HTML React version
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个国家后，它的区域列表将显示出来，就像我们之前的HTML React版本一样
- en: 'Everything works, and is using native components; great! By the way, if you
    were not very sure about the `selectedValue` problem we described, just omit that
    prop, and when the user picks on a country, you''ll get a bad result:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很顺利，并且正在使用原生组件；太棒了！顺便说一句，如果你对我们描述的`selectedValue`问题不太确定，只需省略该属性，当用户选择一个国家时，你将得到一个糟糕的结果：
- en: '![](img/11023a1c-172f-4a30-b5ed-70782c1722d7.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11023a1c-172f-4a30-b5ed-70782c1722d7.png)'
- en: There are some differences, such as requiring the selectedValue prop to be present,
    or otherwise the currently picked value
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些差异，比如需要存在`selectedValue`属性，否则当前选择的值
- en: won't be updated—even though Brazil was selected, the picker doesn't show it
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不会更新-即使选择了巴西，选择器也不会显示它
- en: Here, we went through an example of writing RN code, and as we have seen, it
    doesn't differ much from simple `React` code, other from the fact that we don't
    get to use HTML, having us instead depending on different elements.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过一个编写RN代码的示例，正如我们所看到的，它与简单的`React`代码并没有太大不同，除了我们不能使用HTML之外，我们必须依赖不同的元素。
- en: 'We have seen two ways of running our code: with the `Expo` client on our mobile
    device, and with emulators on our computer. To experiment with RN, there are a
    couple of online playgrounds you may want to look at Snack, at [https://snack.expo.io/](https://snack.expo.io/),
    [and `Repl.it`, at ](https://snack.expo.io/)[https://repl.it/languages/react_native](https://repl.it/languages/react_native)[.
    In both of these environments, you can create files, edit code, and see the results
    of your experiments online.](https://snack.expo.io/)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种运行我们代码的方式：使用我们的移动设备上的`Expo`客户端，以及在我们的计算机上使用模拟器。要尝试RN，你可能想看看一些在线游乐场，比如Snack，[https://snack.expo.io/](https://snack.expo.io/)，[以及`Repl.it`，在](https://snack.expo.io/)[https://repl.it/languages/react_native](https://repl.it/languages/react_native)。在这两种环境中，你可以创建文件，编辑代码，并在线查看你的实验结果。
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One final step, after getting your app to run, is to create a standalone package
    that you could ideally distribute via the Apple and Google app stores. If you
    created your application manually, then the process can get a bit complicated,
    and you''ll even require an actual macOS computer, because you won''t be able
    to build for iOS otherwise: you''ll have to read how to produce an app with `Xcode`
    or the Android developers'' kit, which can be a bit complicated. With CRAN apps,
    instead, the process can be simplified, because `Expo` provides an app building capability
    so that you won''t have to. Check out [https://docs.expo.io/versions/latest/guides/building-standalone-apps.html](https://docs.expo.io/versions/latest/guides/building-standalone-apps.html)
    for specific instructions.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在让你的应用程序运行后的最后一步是创建一个独立的软件包，最好可以通过苹果和谷歌应用商店进行分发。如果你手动创建了你的应用程序，那么这个过程可能会变得有点复杂，你甚至需要一台真正的macOS电脑，因为否则你将无法为iOS构建：你将不得不阅读如何使用`Xcode`或Android开发者工具来制作应用程序，这可能有点复杂。相反，使用CRAN应用程序，这个过程可以简化，因为`Expo`提供了一个应用程序构建功能，这样你就不必自己构建。查看[https://docs.expo.io/versions/latest/guides/building-standalone-apps.html](https://docs.expo.io/versions/latest/guides/building-standalone-apps.html)获取具体的说明。
- en: In any case, no matter which way you decide to proceed for your build process,
    check out some of the suggestions to help ensure your app will be approved and
    well received at [https://docs.expo.io/versions/latest/guides/app-stores.html](https://docs.expo.io/versions/latest/guides/app-stores.html).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你决定如何进行构建过程，都要查看一些建议，以确保你的应用程序将被批准并受到良好的接待。[https://docs.expo.io/versions/latest/guides/app-stores.html](https://docs.expo.io/versions/latest/guides/app-stores.html)。
- en: Adapting to devices and orientation
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应设备和方向
- en: When we developed a responsive and adaptive web page back in the *Making your
    application adaptive for enhanced usability *section in [Chapter 7](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml),
    *Enhancing Your Application*, we had to deal with the possibility that the window
    size could be changed at any moment, and our page's contents had to relocate itself
    properly. With mobile devices, the screen size won't change, but you still have
    the possibility of a rotation (changing from portrait mode to landscape, and vice
    versa), so you still have to deal with at least one change. And, of course, if
    you want to make your app look good on all devices, it's probable that you'll
    have to take into account the screen size in order to decide how to accommodate
    your contents.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第7章](c2de8e53-ee4c-414c-8c67-f908021652cc.xhtml)的*增强您的应用程序*中开发了一个响应式和自适应的网页时，我们必须处理窗口大小可能随时改变的可能性，我们的页面内容必须正确地重新定位自己。对于移动设备，屏幕尺寸不会改变，但仍然有可能旋转（从纵向模式到横向模式，反之亦然），因此您仍然必须处理至少一个变化。当然，如果您希望使您的应用程序在所有设备上看起来很好，那么您可能需要考虑屏幕尺寸，以决定如何容纳您的内容。
- en: In this recipe, we'll look at a simple technique to make your application aware
    of different device types. This technique can be easily upgraded to also cover
    specific screen dimensions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将介绍一种简单的技术，使您的应用程序能够识别不同的设备类型。这种技术可以很容易地升级，以覆盖特定的屏幕尺寸。
- en: We'll look more at styling later; for the time being, we'll focus on getting
    the app to recognize the device type and orientation, and then in the next section,
    we'll follow up with specific style examples.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将更多地关注样式；目前，我们将专注于让应用程序识别设备类型和方向，然后在下一节中，我们将提供具体的样式示例。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If we want our app to adapt, we have to be able to answer several questions
    in our code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的应用程序适应，我们必须能够在我们的代码中回答几个问题：
- en: How can we tell if the device is a tablet or a handset?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何知道设备是平板还是手机？
- en: How can we learn if it's in the portrait or landscape modes?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何了解它是纵向模式还是横向模式？
- en: How do we code a component that will render differently depending on the device
    type?
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何编写一个组件，根据设备类型的不同进行不同的渲染？
- en: How can we make a component redraw itself automatically upon a screen orientation
    change?
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使一个组件在屏幕方向改变时自动重绘？
- en: 'Let''s go over all these questions now. Let''s first look at how we can learn
    about the device type and orientation. RN includes an API, `Dimensions`, that
    provides data that''s necessary to render the app, such as the screen dimensions.
    How can we, then, learn the device type and orientation? The second question is
    easier: since there are no square devices (at least so far!), it''s enough to
    see which of the two dimensions is bigger—if the height is bigger, then the device
    is in portrait mode, and otherwise it''s in landscape mode.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来讨论所有这些问题。让我们首先看看我们如何了解设备类型和方向。RN包括一个API，`Dimensions`，它提供了渲染应用程序所需的屏幕尺寸等数据。那么，我们如何了解设备类型和方向呢？第二个问题更容易：因为没有正方形设备（至少目前没有！），只需查看两个尺寸中哪个更大-如果高度更大，则设备处于纵向模式，否则设备处于横向模式。
- en: 'The first question, however, is harder. There''s no strict rule that defines,
    in terms of screen sizes, where handsets end and where tablets start, but if we
    look at information on devices and calculate form factors (the ratio of the longest
    side to the shortest side), a simple rule appears: if the calculated ratio is
    1.6 or below, it''s more likely a tablet, and higher ratios suggest handsets.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第一个问题更难。在屏幕尺寸方面，没有严格的规定来界定手机的结束和平板的开始，但是如果我们查看设备信息并计算形态因子（最长边与最短边的比率），一个简单的规则就出现了：如果计算出的比率为1.6或以下，则更可能是平板电脑，而更高的比率则表明是手机。
- en: If you need more specific data, check [http://iosres.com/](http://iosres.com/)
    for information on iOS devices, or [https://material.io/tools/devices](https://material.io/tools/devices)
    and [http://screensiz.es](http://screensiz.es) for a larger variety of devices,
    in particular for Android, which is used on devices with a much greater variety
    of screen sizes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更具体的数据，请查看[http://iosres.com/](http://iosres.com)获取有关iOS设备的信息，或查看[https://material.io/tools/devices](https://material.io/tools/devices)和[http://screensiz.es](http://screensiz.es)获取更多设备的信息，特别是用于Android的设备，其屏幕尺寸种类更多。
- en: 'With the following code, we basically return all the information provided by `Dimensions`,
    plus a couple of attributes (`.isTablet` and `.isPortrait`) to simplify the coding:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，我们基本上返回了`Dimensions`提供的所有信息，以及一些属性（`.isTablet`和`.isPortrait`）以简化编码：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the preceding code, we have all we'd need to draw a view in a manner that
    is suitable for all kinds of devices, sizes, and both possible orientations—but
    how would we use this data? Let's look at this now, and make our app adjust properly
    in all cases.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码，我们拥有了绘制适合所有设备、尺寸和两种可能方向的视图所需的一切，但我们如何使用这些数据呢？现在让我们来看看这一点，并使我们的应用程序在所有情况下都能适当调整。
- en: For more on the `Dimensions` API, read [https://facebook.github.io/react-native/docs/dimensions](https://facebook.github.io/react-native/docs/dimensions).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Dimensions` API的更多信息，请阅读[https://facebook.github.io/react-native/docs/dimensions](https://facebook.github.io/react-native/docs/dimensions)。
- en: 'We could directly use the information provided by `getDeviceData()` in our
    components, but that would pose some problems:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在组件中使用`getDeviceData()`提供的信息，但这会带来一些问题：
- en: The components would not be as functional as before, because they would have
    a hidden dependency in the function
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它们在函数中有一个隐藏的依赖，所以组件将不像以前那样功能强大
- en: As a result, testing components would then become a bit harder, because we'd
    have to mock the function
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，测试组件将变得更加困难，因为我们必须模拟该函数
- en: Most importantly, it wouldn't be so easy to set the components to re-render
    themselves when the orientation changes
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，当方向改变时，设置组件自动重新渲染将不会那么容易
- en: 'The solution for all of this is simple: let''s put the device data in the store,
    and then the relevant components (meaning those that need to change their way
    of rendering) can be connected to the data. We can create a simple component to
    do this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这一切的方法很简单：让我们将设备数据放入存储中，然后相关组件（需要改变渲染方式的组件）可以连接到数据。我们可以创建一个简单的组件来实现这一点：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The component won''t be seen onscreen, so we can add it to our main view anywhere.
    Connecting the component is the other necessary step; when the `onLayout` event
    fires (meaning the device''s orientation has changed), we''ll have to dispatch
    an action:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件不会显示在屏幕上，因此我们可以将其添加到我们的主视图中的任何位置。连接组件是另一个必要的步骤；当 `onLayout` 事件触发时（意味着设备的方向已经改变），我们将不得不调度一个动作：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Of course, we need to define both the actions and the reducer, as well as the
    store. Let''s look at how to do this—we''ll begin with the actions. The very minimum
    we''d need (apart from other actions needed by our hypothetical app) would be
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要定义动作和减速器，以及存储。让我们看看如何做到这一点——我们将从动作开始。除了我们假设的应用程序需要的其他动作之外，我们至少需要以下内容：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are exporting a thunk that will include the `deviceData` in it. Note that
    by allowing it to be provided as a parameter (or a default value being used instead,
    created by `getDeviceData()`), we will simplify testing; if we wanted to simulate
    a landscape tablet, we'd just provide an appropriate `deviceData` object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导出一个 thunk，其中将包含 `deviceData`。请注意，通过允许它作为参数提供（或者使用默认值，由 `getDeviceData()`
    创建），我们将简化测试；如果我们想模拟横向平板电脑，我们只需提供一个适当的 `deviceData` 对象。
- en: 'Finally, the reducer would look like the following (obviously, for a real app,
    there would be many more actions!):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，减速器将如下所示（显然，对于真实的应用程序，将会有更多的动作！）：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, now that we have our device information in the store, we can study how to
    code adaptive, responsive components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在存储中有了设备信息，我们可以研究如何编写自适应、响应式的组件。
- en: 'We can see how to code adaptive and responsive components by using a very basic
    component that simply displays whether it''s a handset or a tablet, and its current
    orientation. Having access to all of the `deviceData` objects means that we can
    take any kind of decisions: what to show, how many elements to display, what size
    to make them, and so on. We''ll be making this example short, but it should be
    clear how to expand it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一个非常基本的组件来看如何编写自适应和响应式组件，该组件只是显示它是手机还是平板电脑，以及它当前的方向。拥有所有 `deviceData`
    对象的访问权限意味着我们可以做出任何决定：显示什么、显示多少元素、使它们的大小如何等等。我们将使这个示例简短，但应该清楚如何扩展它：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Don't worry about the `textStyle` definition—soon we'll be getting into how
    it works, but for now I think it should be easy to accept that it defines bold,
    largish, text.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心 `textStyle` 的定义——很快我们将介绍它的工作原理，但现在我认为接受它定义了粗体、较大的文本应该很容易。
- en: 'Given `this.props.deviceData`, we can use the `.isTablet` prop to decide which
    method to call (`.renderTablet()` or `.renderHandset()`). In those methods, we
    can then use `.isPortrait` to decide what layout to use: portrait or landscape.
    Finally—although we don''t show this in our example—we could use `.width` or `.height`
    to show more or fewer components, or to calculate the components'' sizes, and
    so on. We only need to connect the component to the store as follows, and we''ll
    be set:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `this.props.deviceData`，我们可以使用 `.isTablet` 属性来决定调用哪个方法（`.renderTablet()`
    或 `.renderHandset()`）。在这些方法中，我们可以使用 `.isPortrait` 来决定使用什么布局：竖屏或横屏。最后——虽然我们在示例中没有显示这一点——我们可以使用
    `.width` 或 `.height` 来显示更多或更少的组件，或计算组件的大小等等。我们只需要将组件连接到存储，如下所示，就可以了：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have everything we need now; let's see it working!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了一切需要的东西，让我们看看它是如何工作的！
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We have prepared a (hidden) component that responds to orientation changes
    by dispatching an action to update the store, and we know how to code a component
    that will use the device information. Our main page could look as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备了一个（隐藏的）组件，通过调度一个动作来响应方向的变化以更新存储，我们知道如何编写一个将使用设备信息的组件。我们的主页面可能如下所示：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If I run the app on a (simulated) Nexus 5 device in portrait mode, we''d see
    something like the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在（模拟的）Nexus 5 设备上以竖屏模式运行应用程序，我们会看到类似以下的内容：
- en: '![](img/462a6b6b-3240-49e7-a2eb-49262cd0bed7.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/462a6b6b-3240-49e7-a2eb-49262cd0bed7.png)'
- en: Our device is recognized as a handset, currently in portrait (vertical) orientation
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设备被识别为一个手机，目前是竖屏（垂直）方向
- en: 'Rotating the device would produce a different view:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转设备会产生不同的视图：
- en: '![](img/5cabcc8a-cf15-49ce-86e2-0874fd81e69c.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cabcc8a-cf15-49ce-86e2-0874fd81e69c.png)'
- en: When the orientation changes, the store is updated and the app re-renders itself
    appropriately
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当方向改变时，存储会更新，应用程序会适当地重新渲染自己
- en: In our design, components never use the `Dimension` API by themselves—since
    they get the device information from the store, testing the components' behavior
    for different devices and orientations could be done functionally, without needing
    to mock anything.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中，组件从不自己使用 `Dimension` API——因为它们从存储中获取设备信息，所以可以在功能上测试不同设备和方向下的组件行为，而无需模拟任何东西。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To continue, write separate `something.handset.js` and `something.tablet.js`
    files that extend `SomethingBase` to define the `SomethingHandset` and `SomethingTablet`
    components. And, to finish, set up the `something.component.js` file that will
    be used to check whether the device is a handset or a tablet, and return either
    a `<SomethingHandset>` component or a `<SomethingTablet>` one:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续，编写单独的 `something.handset.js` 和 `something.tablet.js` 文件，这些文件扩展 `SomethingBase`
    来定义 `SomethingHandset` 和 `SomethingTablet` 组件。最后，设置 `something.component.js` 文件，用于检查设备是手机还是平板，并返回
    `<SomethingHandset>` 组件或 `<SomethingTablet>` 组件：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this style, you'd use and connect `<Something>` components in your code,
    which, internally, would really be the appropriate version for the current device's
    type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种样式，您可以在代码中使用和连接 `<Something>` 组件，而在内部，它们实际上是当前设备类型的适当版本。
- en: In computer science terms, this is called the *Factory* design pattern, where
    you are able to create an object without actually specifying its class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学术语中，这被称为*工厂*设计模式，您可以在不实际指定其类的情况下创建对象。
- en: Styling and laying out your components
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式和布局组件
- en: 'Applying CSS styles to your app is not difficult, but you''ll have to un-learn
    and re-learn some of the following concepts that are just plain different in RN,
    when compared to HTML:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将CSS样式应用到您的应用程序并不困难，但是与HTML相比，您将不得不放弃并重新学习一些概念，这些概念在RN中与HTML中的概念完全不同：
- en: In web pages, CSS style is global, and applies to all tags; in RN, styling is
    done locally on a component-by-component basis; there is no global styling. Also,
    you don't need *selectors*, because styles are directly associated to components.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网页中，CSS样式是全局的，适用于所有标签；在RN中，样式是在组件之间局部完成的；没有全局样式。此外，您不需要*选择器*，因为样式直接与组件相关联。
- en: 'There is no inheritance of styles: in HTML, children inherit some of their
    parent''s style by default, but in RN, if you want this to happen, you''ll have
    to provide the specific desired style to the children. However, if you wish, you
    can `export` styles and `import` them elsewhere.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有样式的继承：在HTML中，子元素默认继承其父元素的一些样式，但在RN中，如果您希望发生这种情况，您将不得不为子元素提供特定的所需样式。但是，如果您希望，您可以`export`样式并在其他地方`import`它们。
- en: 'RN styles are completely dynamic: you can use all JS functions to compute whichever
    values you wish to apply. You could even alter styles on the fly, so an app background
    color could be lighter during the day, gradually changing to darker colors at
    night, as time goes by. You won''t need anything like SASS or LESS; you can do
    math and use constants, because that''s pure JS.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RN样式完全是动态的：您可以使用所有JS函数来计算您希望应用的任何值。您甚至可以动态更改样式，因此应用程序的背景颜色可以在白天变得更浅，随着时间的推移逐渐变暗。您不需要像SASS或LESS那样的东西；您可以进行数学计算并使用常量，因为这是纯JS。
- en: 'There are some other minor differences as well:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他细微的差异：
- en: RN uses *camelCase* style (such as `fontFamily`) instead of CSS's *kebab-case*
    style (for example, `font-family`); that's easy enough to get used to. Also, not
    all usual CSS properties may be present (it depends on specific components), and
    some may be restricted as to their possible values.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RN使用*驼峰命名*风格（例如`fontFamily`）而不是CSS的*kebab-case*风格（例如`font-family`）；这很容易适应。此外，并非所有通常的CSS属性都可能存在（这取决于特定组件），有些可能受到其可能值的限制。
- en: 'RN has only two possible measurements: either percentages, or **density independent
    pixels** (**DP**). DP aren''t the classic screen pixels from the web; rather,
    they work well with every device, independently of their pixel density or **pixels
    per inch** (**ppi**), thus guaranteeing a common look for all screens.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RN只有两种可能的测量单位：百分比或**密度无关像素**（**DP**）。DP不是来自Web的经典屏幕像素；相反，它们适用于每种设备，独立于其像素密度或**每英寸像素**（**ppi**），从而确保所有屏幕具有统一的外观。
- en: The layout is done with flex, so positioning elements is simpler. You may not
    have the full set of options that are available for web pages, but what you get
    is absolutely enough for any kind of layout.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局使用flex完成，因此定位元素更简单。您可能没有网页可用的所有选项集，但您获得的对于任何类型的布局来说绝对足够。
- en: There's much to read about styling in RN (for starters, see [https://facebook.github.io/react-native/docs/style](https://facebook.github.io/react-native/docs/style)
    for an introduction, and [https://facebook.github.io/react-native/docs/height-and-width](https://facebook.github.io/react-native/docs/height-and-width)
    and [https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)
    for sizing and positioning elements), so here, in this recipe, we'll look at some
    specific examples by styling our countries-and-regions app.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关于RN中的样式有很多内容可供阅读（首先，请参阅[https://facebook.github.io/react-native/docs/style](https://facebook.github.io/react-native/docs/style)进行介绍，以及[https://facebook.github.io/react-native/docs/height-and-width](https://facebook.github.io/react-native/docs/height-and-width)和[https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)进行元素的大小和定位），因此，在这里，我们将通过为我们的国家和地区应用程序设置一些具体的示例来查看一些内容。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's try to enhance our app a bit. And, to complete what we earlier saw about
    adaptive and responsive displays, we are going to provide a different layout for
    portrait and landscape orientations. We won't need media queries or column based
    layouts; we'll make do with simple styling.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试稍微增强我们的应用程序。并且，为了完成我们之前看到的关于自适应和响应式显示的内容，我们将为纵向和横向方向提供不同的布局。我们不需要媒体查询或基于列的布局；我们将使用简单的样式。
- en: 'Let''s begin by creating styles for the `<Main>` component. We''ll be using
    the `<DeviceHandler>` we developed earlier; both components will be connected
    to the store. I didn''t want to do specific versions for tablets and handsets,
    but I wanted to display a different layout for portrait and landscape orientations.
    For the former, I basically used what I had developed earlier, but for the latter,
    I decided to split the screen in half, displaying the countries selector on the
    left and the regions list on the right. Oh, and you may notice that I opted to
    use inline styles, even if it''s not the preferred option; since components are
    usually short, you may place styles right in the JSX code without losing clarity.
    It''s up to you to decide whether you like it or not:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为`<Main>`组件创建样式开始。我们将使用我们之前开发的`<DeviceHandler>`；两个组件都将连接到存储。我不想为平板电脑和手机制作特定版本，但我想在纵向和横向方向上显示不同的布局。对于前者，我基本上使用了我之前开发的内容，但对于后者，我决定将屏幕一分为二，在左侧显示国家选择器，右侧显示地区列表。哦，您可能会注意到我选择使用内联样式，即使这不是首选选项；由于组件通常很短，您可以在JSX代码中直接放置样式而不会失去清晰度。这取决于您是否喜欢：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**When the device is in portrait orientation, I created a `<View>`, occupying
    all the screen (`flex:1`) and setting its components vertically using `flexDirection:"column"`,
    although this is actually the default value, so I could have omitted this. I didn''t
    specify a size for the `<CountrySelect>` component, but I set the `<RegionsTable>`
    to occupy all possible (remaining) space. The detailed code is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**当设备处于纵向方向时，我创建了一个占据整个屏幕的`<View>`（`flex:1`），并使用`flexDirection:"column"`垂直设置其组件，尽管这实际上是默认值，所以我可以省略这一步。我没有为`<CountrySelect>`组件指定大小，但我设置了`<RegionsTable>`以占据所有可能的（剩余的）空间。详细代码如下：'
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the landscape orientation, some changes were required. I set the direction
    for the contents of the main view to horizontal (`flexDirection:"row"`) and I
    added two equal-sized views within. For the first, with the country list, I set
    its contents vertically and centered, because I thought it looked better that
    way, instead of appearing at the top. I didn''t do anything in particular for
    the regions list that occupies the right side of the screen:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于横向方向，需要进行一些更改。我将主视图的内容方向设置为水平（`flexDirection:"row"`），并在其中添加了两个大小相同的视图。对于第一个国家列表，我将其内容设置为垂直并居中，因为我认为这样看起来更好，而不是出现在顶部。对于占据屏幕右侧的地区列表，我没有做任何特别的事情。
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you want a component to occupy a larger piece of space, increase its flex
    value; *flex* implies that components will flexibly expand or shrink according
    to the available space, which is shared among all components in direct proportion
    to their flex values. If I had wanted the countries list to occupy one third of
    the screen, leaving the other two thirds to the regions list, I would have set
    `flex:1` for it, and `flex:2` for the regions. Of course, you could also set heights
    and widths directly (in either DIP values or as percentages), as you could have
    done with CSS.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使组件占据更大的空间，增加其flex值；*flex*意味着组件将根据可用空间灵活地扩展或收缩，这些空间按照它们的flex值的直接比例共享。如果我想要国家列表占据屏幕的三分之一，将其他两分之一留给地区列表，我会为其设置`flex:1`，并为地区列表设置`flex:2`。当然，您也可以直接设置高度和宽度（无论是DIP值还是百分比），就像您在CSS中所做的那样。
- en: 'As for distributing children in a view, apart from `"center"`, which centers
    all children in the parent view, you also have several other options:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`"center"`之外，如果您想要在视图中分配子组件，还有其他几个选项：
- en: '`"flex-start"` places them together, at the start of the parent view; here,
    it''s top, given the vertical alignment'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"flex-start"`将它们放在一起，放在父视图的开始位置；在这里，是顶部，因为是垂直对齐的'
- en: '`"flex-end"` would have behaved similarly, but placed the children at the end
    (here, the bottom) of the parent view'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"flex-end"`的行为类似，但将子组件放置在父视图的末尾（这里是底部）'
- en: '`"space-between"` splits the extra space equally between the children components'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “space-between”在子组件之间均匀分割额外的空间
- en: '`"space-around"` also splits extra space equally, but includes space at the
    start and at the end of the parent view'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “space-around”也均匀分割额外的空间，但包括父视图开头和结尾的空间
- en: '`"space-evenly"` splits all space equally between children and dividing spaces'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “space-evenly”在子组件和分隔空间之间均匀分割所有空间
- en: After setting how the components will be laid out in the main flex direction,
    you can use `alignItems` to specify how the children will be aligned along the
    secondary flex direction (if `flexDirection` is `"row"`, then the secondary direction
    will be `"column"`, and vice versa). Possible values are `"flex-start"`, `"center"`,
    and `"flex-end"`, with similar meaning to what was just given, or you could use `"stretch"`,
    which will occupy all possible space.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 设置主要的flex方向后，您可以使用`alignItems`来指定子组件沿着次要的flex方向对齐的方式（如果`flexDirection`是`"row"`，那么次要方向将是`"column"`，反之亦然）。可能的值是`"flex-start"`，`"center"`和`"flex-end"`，意思与刚才给出的类似，或者您可以使用`"stretch"`，它将占据所有可能的空间。
- en: If you want to experiment with these options, go to [https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)
    and modify the code examples. You'll immediately see the effects of your changes,
    which is the easiest way to understand the effects and implications of each option.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试这些选项，请访问[https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)并修改代码示例。您将立即看到您的更改的效果，这是理解每个选项的效果和影响的最简单方法。
- en: 'Now, let''s style the regions table. For this, I had to make some changes,
    starting with the need for a `<ScrollView>` instead of a plain `<View>`, given
    that the list may be too long to fit in the screen. Also, to show you some styles
    and constants, I decided to go with separate style files. I started by creating
    a `styleConstants.js` file, which defines a color constant and a simple, full-sized
    style:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来设置地区表的样式。为此，我需要进行一些更改，首先是需要使用`<ScrollView>`而不是普通的`<View>`，因为列表可能太长而无法适应屏幕。另外，为了展示一些样式和常量，我决定使用单独的样式文件。我首先创建了一个`styleConstants.js`文件，其中定义了一个颜色常量和一个简单的全尺寸样式：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The interesting thing here, rather than the (assumedly quite Spartan) `fullSize`
    style, is the fact that you can export styles, or define simple JS constants that
    will be used elsewhere. In the regions list, I imported both the style and the
    color:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的地方，不是（假定相当简陋的）`fullSize`样式，而是您可以导出样式，或者定义将在其他地方使用的简单JS常量。在地区列表中，我导入了样式和颜色：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are some interesting details here in the preceding block of code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码块中有一些有趣的细节：
- en: As I said before, I'm using a `<ScrollView>` component to enable the user can
    browse through lists that are longer than the available space. A `<FlatList>`
    component would also have been a possibility, though for relatively short and
    simple lists as here, it wouldn't have made much of a difference.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我之前所说，我使用了`<ScrollView>`组件，以便用户可以浏览超出可用空间的列表。`<FlatList>`组件也是一种可能，尽管对于这里相对较短和简单的列表来说，它不会有太大的区别。
- en: I used the imported color to create a local style, `grayish`, which I used later.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用导入的颜色创建了一个本地样式`grayish`，稍后我会用到。
- en: I directly applied the imported `fullSize` style to the regions' `<ScrollView>`.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我直接将导入的`fullSize`样式应用到了区域的`<ScrollView>`上。
- en: I applied more than one style to the second `<ScrollView>`; if you provide an
    array of styles, they get applied in the order of appearance. In this case, I
    got a full-sized gray area. Note that the color is only applied if some regions
    are present; otherwise, the color is unchanged.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我给第二个`<ScrollView>`应用了多个样式；如果你提供一个样式数组，它们会按照出现的顺序应用。在这种情况下，我得到了一个全尺寸的灰色区域。请注意，只有在存在一些区域时颜色才会被应用；否则颜色不会改变。
- en: 'Note that the style can be created dynamically, and that allows for interesting
    effects. To use an example based upon one in RN''s documentation at [https://facebook.github.io/react-native/docs/stylesheet](https://facebook.github.io/react-native/docs/stylesheet),
    you could have a title changing style depending on a prop. In the following code,
    the style for the title would change depending on `this.props.isActive`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，样式可以动态创建，这可以产生有趣的效果。举个例子，基于RN文档中的一个例子，你可以根据prop改变标题的样式。在下面的代码中，标题的样式会根据`this.props.isActive`的值而改变：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You could produce even more interesting results; remember that you have the
    full power of JS available to you, and that a style sheet can be created on the
    fly, so you actually have limitless possibilities.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以产生更有趣的结果；记住你可以充分利用JS的全部功能，并且样式表可以动态创建，所以你实际上有无限的可能性。
- en: How it works...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'I fired up the emulator, and tried out the code. When in portrait orientation,
    the view is as shown in the following screenshot; note that I scrolled down, and
    the app correctly handles it:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我启动了模拟器，尝试了一下代码。在纵向方向时，视图如下截图所示；请注意我向下滚动了，应用程序正确处理了它：
- en: '![](img/ba75c98a-231f-48d8-b764-6aeb7e902262.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba75c98a-231f-48d8-b764-6aeb7e902262.png)'
- en: Our styled application, showing colors, styles, and a scrollable view
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样式化应用程序，显示颜色、样式和可滚动视图
- en: 'If you change the device''s orientation, our device handler logic captures
    the event, and the app is rendered differently. Here, we can see the split screen,
    with centered elements on the left and the scrollable view on the right, with
    its grayish background:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你改变设备的方向，我们的设备处理逻辑会捕获事件，并且应用程序会以不同的方式呈现。在这里，我们可以看到分屏，左边是居中的元素，右边是可滚动的视图，有灰色的背景：
- en: '![](img/959d3015-b0a8-474d-84f6-8ea1f452c282.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/959d3015-b0a8-474d-84f6-8ea1f452c282.png)'
- en: The landscape view gets a different layout, courtesy of new styling rules
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 横向视图得到了不同的布局，这要归功于新的样式规则
- en: As we've seen—and this was only an introduction to the many styling features
    provided by RN—you can get the same kind of results as with HTML and CSS, though
    here you are assuredly working with different elements and styles. The possibility
    of applying the full extent of JS to the definition of styles lets you forget
    about using tools such as SASS, because all the extra functionality that it would
    bring is already available through JS itself. Let's look at a further example
    of styling, this time for text, as we consider how to write code that's been specifically
    oriented to a given platform.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了——这只是RN提供的许多样式特性的简介，你可以获得与HTML和CSS相同类型的结果，尽管在这里你确实在使用不同的元素和样式。应用JS的全部功能来定义样式的可能性让你不再需要使用诸如SASS之类的工具，因为它所带来的所有额外功能已经通过JS本身可用。让我们看一个更进一步的样式示例，这次是针对文本的，因为我们考虑如何编写专门针对特定平台的代码。
- en: Adding platform-specific code
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加特定于平台的代码
- en: Working with the generic components is good enough for most development, but
    you may want to utilize some platform-specific feature, and RN provides a way
    to do so. Obviously, if you start along this trend, you may end with a bigger
    job, and it will be harder to maintain your code, but done judiciously, it can
    add some extra *pizzazz* to your app.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用组件对大多数开发来说已经足够了，但你可能想利用一些特定于平台的功能，RN提供了一种方法来实现这一点。显然，如果你开始沿着这个趋势发展，你可能会面临更大的工作量，并且更难维护你的代码，但如果明智地进行，它可以为你的应用增添一些额外的*亮点*。
- en: In this recipe, we'll look at how to adapt your app so that it will fit in better
    for whatever platform it runs on.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看如何调整你的应用，使其更适合在任何平台上运行。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The simplest way to recognize your platform is by using the `Platform` module,
    which includes a property, `Platform.OS`, which tells you whether you are running
    Android or iOS. Let''s go for a simple example. Imagine you wanted to use some
    monospaced font in your app. It happens that the right name for the relevant font
    family varies between platforms: it would be `"monospace"` in Android, but `"AmericanTypewriter"`
    (among others) on Apple devices. By checking `Platform.OS`, we can set the `.fontFamily`
    attribute of a style sheet appropriately, as in the following screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 识别你的平台最简单的方法是使用`Platform`模块，其中包括一个属性`Platform.OS`，告诉你当前是在Android还是iOS上运行。让我们来看一个简单的例子。假设你想在你的应用中使用一些等宽字体。恰好在不同平台上，相关字体系列的名称不同：在Android上是`"monospace"`，而在苹果设备上是`"AmericanTypewriter"`（等等）。通过检查`Platform.OS`，我们可以适当地设置样式表的`.fontFamily`属性，如下面的截图所示：
- en: '![](img/9d66a972-1aa4-4898-b9af-64b582ac2352.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d66a972-1aa4-4898-b9af-64b582ac2352.png)'
- en: Using Platform.OS is the simplest way to detect the platform of the device
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Platform.OS`是检测设备平台的最简单方法
- en: 'If you wanted to pick several attributes differently, you might want to use
    `Platform.select()` instead:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要不同地选择几个属性，你可能想使用`Platform.select()`：
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, `headings.title` and `headings.subtitle` will get the values appropriate
    to the current platform, either Android or iOS. Obviously, you could have managed
    this using `Platform.OS`, but this style may be shorter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`headings.title`和`headings.subtitle`将获得适合当前平台的值，无论是Android还是iOS。显然，你可以使用`Platform.OS`来管理这个，但这种样式可能更简洁。
- en: For more on the available font families in both Android and iOS devices, you
    may want to check the lists at [https://github.com/react-native-training/react-native-fonts](https://github.com/react-native-training/react-native-fonts).
    Take into account, however, that the list may change from version to version.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Android和iOS设备上可用字体系列的更多信息，您可以查看[https://github.com/react-native-training/react-native-fonts](https://github.com/react-native-training/react-native-fonts)上的列表。但是，请注意，列表可能会随着版本的变化而改变。
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just for variety, I decided to try out platform detection in Snack (at [https://snack.expo.io/](https://snack.expo.io/);
    we mentioned this tool earlier in this chapter) because it would be much faster
    and simpler than running code on two actual devices.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了多样化，我决定在Snack（在本章前面提到过的[https://snack.expo.io/](https://snack.expo.io/)）中尝试平台检测，因为这比在两台实际设备上运行代码要快得多，也更简单。
- en: 'I opened the page, and in the sample application that is provided, I just added
    the `.fontFamily` change I showed earlier, and tested the results for both platforms:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我打开了页面，在提供的示例应用程序中，我只是添加了我之前展示的`.fontFamily`更改，并测试了两个平台的结果：
- en: '![](img/4aeb80e4-59cd-4d07-8983-a1120078b60d.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4aeb80e4-59cd-4d07-8983-a1120078b60d.png)'
- en: The Snack emulators show the different look of my app, with distinct fonts for
    Android (left) and iOS (right)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Snack模拟器显示了我的应用程序的不同外观，Android（左）和iOS（右）具有不同的字体
- en: As we can see, issues with platform differences can be easily solved, and the
    end users of your app will get something that more closely match their expectations
    regarding colors, fonts, components, APIs, and whatnot.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，平台差异的问题可以很容易地解决，您的应用程序的最终用户将获得更符合其对颜色、字体、组件、API等方面期望的东西。
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The changes we saw in this recipe are rather small in scope. If you wanted some
    radically bigger differences, such as, for example, getting a date by using a
    `DatePickerIOS` component for iOS, but the `DatePickerAndroid` API for Android,
    there's another feature you should consider.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中看到的变化范围相当小。如果您想要一些更大的差异，比如，例如，使用`DatePickerIOS`组件在iOS上获取日期，但在Android上使用`DatePickerAndroid`
    API，那么还有另一个功能您应该考虑。
- en: 'Let''s say your own component was named `AppropriateDatePicker`. If you create
    two files, respectively named `appropriateDatePicker.component.ios.js` and `appropriateDatePicker.component.android.js`,
    then when you import your component with `import { AppropriateDatePicker } from
    "AppropriateDatePicker"`, the `.ios.js` version will be used for Apple, and the
    `.android.js` version for Android: simple!'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您自己的组件名为`AppropriateDatePicker`。如果您分别创建名为`appropriateDatePicker.component.ios.js`和`appropriateDatePicker.component.android.js`的两个文件，那么当您使用`import
    { AppropriateDatePicker } from "AppropriateDatePicker"`导入您的组件时，`.ios.js`版本将用于苹果设备，`.android.js`版本将用于安卓设备：简单！
- en: For a complete description of the `Platform` module and the platform-specific
    options, read [https://facebook.github.io/react-native/docs/platform-specific-code](https://facebook.github.io/react-native/docs/platform-specific-code).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Platform`模块和特定于平台的选项的完整描述，请阅读[https://facebook.github.io/react-native/docs/platform-specific-code](https://facebook.github.io/react-native/docs/platform-specific-code)。
- en: Routing and navigating
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和导航
- en: With the `React` router, you just used a `<Link>` component to navigate from
    one page to another, or used methods to programmatically open a different page.
    In RN, there is a different way of working, and the `react-navigation` package
    is practically the de facto standard. Here, you define a navigator (there are
    several kinds to pick from) and provide it with the screens (views) that it should
    handle, and then forget about it! The navigator will handle everything on its
    own, showing and hiding screens, adding tabs or a sliding drawer, or whatever
    it needs, and you don't have to do anything extra!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`React`路由器，您只需使用`<Link>`组件从一个页面导航到另一个页面，或者使用方法以编程方式打开不同的页面。在RN中，有一种不同的工作方式，`react-navigation`包实际上是事实上的标准。在这里，您定义一个导航器（有几种可供选择），并为其提供应该处理的屏幕（视图），然后忘记它！导航器将自行处理一切，显示和隐藏屏幕，添加选项卡或滑动抽屉，或者其他任何需要的功能，您不必做任何额外的工作！
- en: In this recipe, we'll revisit an example from earlier pages of this book, and
    show how the router is written differently, to highlight differences in style.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将重新访问本书前面页面的一个示例，并展示路由的不同写法，以突出风格上的差异。
- en: There's more to navigation than what we'll see here. Check out the API documentation
    at [https://reactnavigation.org/docs/en/api-reference.html](https://reactnavigation.org/docs/en/api-reference.html)
    for more, and beware if you Google around, because the `react-navigation` package
    has evolved, and many sites have references to old methods that are currently
    deprecated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 导航比我们在这里看到的更多。查看[https://reactnavigation.org/docs/en/api-reference.html](https://reactnavigation.org/docs/en/api-reference.html)上的API文档以获取更多信息，如果您在Google上搜索，请注意，因为`react-navigation`包已经发展，许多网站引用了当前已弃用的旧方法。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In the `React` part of this book, we built a complete routing solution, including
    public and protected routes, using a login view to enter the user's name and password.
    In a mobile application, since the user is more restricted, we can just make do
    by enabling a login at the beginning, and enabling the normal navigation afterward.
    All the work with usernames, passwords, and tokens is basically the same as before,
    so for now, let's only worry about navigation, which is different in RN, and forget
    the common details.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的`React`部分，我们构建了一个完整的路由解决方案，包括公共和受保护的路由，使用登录视图输入用户的用户名和密码。在移动应用程序中，由于用户受到更多限制，我们可以在开始时启用登录，并在之后启用正常导航。所有与用户名、密码和令牌相关的工作基本上与以前相同，所以现在让我们只关注在RN中不同的导航，并忘记常见的细节。
- en: 'For starters, let''s have some views—a empty screen with some centered text
    will do:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们有一些视图——一个带有一些居中文本的空屏幕就可以了：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, to simplify creating all the needed views, let''s have a `makeSimpleView()`
    function that will produce a component. We''ll include a *hamburger* icon at the
    top right, which will open and close the navigation drawer; we''ll see more on
    this later. We''ll use this function to create most of our views, and we''ll add
    a `SomeJumps` extra view, with three buttons that allow you to navigate directly
    to another view:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了简化创建所有所需的视图，让我们有一个`makeSimpleView()`函数，它将生成一个组件。我们将在右上角包括一个*汉堡*图标，它将打开和关闭导航抽屉；稍后我们会详细了解。我们将使用这个函数来创建大多数视图，并添加一个`SomeJumps`额外视图，其中包含三个按钮，允许您直接导航到另一个视图：
- en: '[PRE39]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, for simplicity, and given that we weren't using props or state, and that
    the view was simple enough, I used a functional definition for the `SomeJumps`
    component, instead of using a class, as in most other examples. If you want to
    revisit the concept, have a look at [https://reactjs.org/docs/components-and-props.html](https://reactjs.org/docs/components-and-props.html)[.](https://reactjs.org/docs/components-and-props.html)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了简单起见，鉴于我们没有使用props或state，并且视图足够简单，我使用了`SomeJumps`组件的函数定义，而不是使用类，就像大多数其他示例一样。如果您想重新访问这个概念，请查看[https://reactjs.org/docs/components-and-props.html](https://reactjs.org/docs/components-and-props.html)。
- en: Where does the `navigation` prop come from? We'll see more in the next section,
    but some explanation can be given here. Whenever you create a navigator, you provide
    it with a set of views to handle. All those views will get an extra prop, `navigation`,
    which has a set of methods you can use, such as toggling the visibility of the
    drawer, navigating to a given screen, and more. Read about this object at [https://reactnavigation.org/docs/en/navigation-prop.html](https://reactnavigation.org/docs/en/navigation-prop.html).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigation`属性来自哪里？我们将在下一节中看到更多，但这里可以给出一些解释。每当您创建一个导航器，您都会为其提供一组视图来处理。所有这些视图都将获得一个额外的属性`navigation`，它具有一组您可以使用的方法，例如切换抽屉的可见性，导航到给定屏幕等。在[https://reactnavigation.org/docs/en/navigation-prop.html](https://reactnavigation.org/docs/en/navigation-prop.html)上阅读有关此对象的信息。'
- en: 'Now, let''s create the drawer itself. This will handle the sidebar menu and
    show whatever view is needed. The `createDrawerNavigator()` function gets an object
    with the screens that will be handled, and a set of options; here, we just specified
    the color of the drawer itself and its width (there are plenty more possibilities,
    which are detailed at [https://reactnavigation.org/docs/en/drawer-navigator.html](https://reactnavigation.org/docs/en/drawer-navigator.html)):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建抽屉本身。这将处理侧边栏菜单并显示所需的任何视图。`createDrawerNavigator()`函数获取一个包含将要处理的屏幕的对象，以及一组选项；在这里，我们只指定了抽屉本身的颜色和宽度（还有很多可能性，详细信息请参阅[https://reactnavigation.org/docs/en/drawer-navigator.html](https://reactnavigation.org/docs/en/drawer-navigator.html)）：
- en: '[PRE40]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The result of `createDrawerNavigation()` is itself a component that will take
    care of showing whatever view is selected, showing and hiding the drawer menu,
    and so on. We only need to create the main application itself.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`createDrawerNavigation()`的结果本身是一个组件，它将负责显示所选的任何视图，显示和隐藏抽屉菜单等。我们只需要创建主应用程序本身。'
- en: 'Next, let''s creating our navigable application, since we now have a set of
    views and a drawer navigator to handle them. The main view for our application
    is then quite simple—check out its `.render()` method, and you''ll have to agree:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建可导航的应用程序，因为我们现在有一组视图和一个抽屉导航器来处理它们。我们应用程序的主视图非常简单-查看它的`.render()`方法，你会同意的：
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'An interesting point: since navigators are components. If you so wish, you
    can have a navigator within another navigator! For example, you could create a
    `TabNavigator`, and include it in a drawer navigator: when the corresponding option
    is selected, you''ll get a tabbed view onscreen, now governed by the tab navigator.
    You can compose navigators in any way you wish, allowing for very complex navigation
    structures, if you want.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的一点是：由于导航器是组件。如果您愿意，您可以在另一个导航器中包含一个导航器！例如，您可以创建一个`TabNavigator`，并将其包含在抽屉导航器中：当选择相应选项时，您将在屏幕上获得一个选项卡视图，现在由选项卡导航器管理。如果您愿意，您可以以任何希望的方式组合导航器，从而允许非常复杂的导航结构。
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you open the application, the initial route is shown. There are several
    options you can provide, such as `initialRouteName` to specify which should be
    the first shown view, `order` to rearrange the drawer items, and even a custom
    `contentComponent` if you want to draw the contents of the drawer by yourself;
    all in all, there is lots of flexibility. Your first screen should look like the
    following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开应用程序时，将显示初始路由。您可以提供多个选项，例如`initialRouteName`来指定应该显示的第一个视图，`order`来重新排列抽屉项，甚至自定义`contentComponent`如果您想自己绘制抽屉的内容；总而言之，有很多灵活性。您的第一个屏幕应该看起来像下面的样子：
- en: '![](img/bc4eddab-0191-4acb-95df-cd124a814ce0.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc4eddab-0191-4acb-95df-cd124a814ce0.png)'
- en: Our drawer navigator showing the initial screen
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的抽屉导航器显示初始屏幕
- en: 'The usual way to open a drawer is by sliding from the left (although you can
    also set the drawer to slide in from the right). We also provided the hamburger
    icon to toggle the drawer open and shut. Opening the drawer should look like the
    following screenshot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通常打开抽屉的方式是从左边滑动（尽管也可以设置抽屉从右边滑动）。我们还提供了汉堡图标来切换抽屉的打开和关闭。打开抽屉应该看起来像下面的截图：
- en: '![](img/16b3cbf8-1530-4245-b496-879b07e55249.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16b3cbf8-1530-4245-b496-879b07e55249.png)'
- en: The opened drawer shows the menu, with the current screen highlighted, and the
    rest of the screen darkened
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 打开的抽屉显示菜单，当前屏幕突出显示，其余屏幕变暗。
- en: 'Clicking on any menu item will hide the current view, and show the selected
    view instead. For instance, we could select the `Some jumps` screen, as shown
    here:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 单击任何菜单项将隐藏当前视图，并显示所选视图。例如，我们可以选择`Some jumps`屏幕，如下所示：
- en: '![](img/afb528b3-850d-4d6f-a81f-28ff8bf36299.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afb528b3-850d-4d6f-a81f-28ff8bf36299.png)'
- en: After selecting an option, the drawer menu slides close on its own, and the
    selected screen is shown
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 选择选项后，抽屉菜单会自动关闭，并显示所选屏幕
- en: In this particular screen, we show three buttons, all of which use the `props.navigation.navigate()`
    method to show a different screen. This shows that your navigation is not restricted
    to using the drawer, but that you can also directly browse in any way you want.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的屏幕中，我们展示了三个按钮，它们都使用`props.navigation.navigate()`方法来显示不同的屏幕。这表明你的导航不仅限于使用抽屉，而且你也可以以任何你想要的方式直接浏览。
- en: There's more...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'You''ll notice we didn''t make any reference to `Redux`, as we did in the `React`
    chapters. While use of this is possible, the `react-navigation` authors are tending
    toward *not* enabling this, and at [https://reactnavigation.org/docs/en/redux-integration.html](https://reactnavigation.org/docs/en/redux-integration.html),
    you can read the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在“React”章节中我们没有提到`Redux`，你可能已经注意到了。虽然使用它是可能的，但`react-navigation`的作者们倾向于*不*启用它，在[https://reactnavigation.org/docs/en/redux-integration.html](https://reactnavigation.org/docs/en/redux-integration.html)上你可以读到以下内容：
- en: '"Warning: in the next major version of React Navigation, to be released in
    Fall 2018, we will no longer provide any information about how to integrate with
    Redux and it may cease to work. Issues related to Redux that are posted on the
    React Navigation issue tracker will be immediately closed. Redux integration may
    continue to work, but it will not be tested against or considered when making
    any design decisions for the library."'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: “警告：在2018年秋季发布的React Navigation的下一个主要版本中，我们将不再提供任何关于如何与Redux集成的信息，它可能会停止工作。在React
    Navigation问题跟踪器上发布的与Redux相关的问题将立即关闭。Redux集成可能会继续工作，但在制定库的任何设计决策时，它将不会被测试或考虑。”
- en: This warning suggests that it wouldn't be a good idea to devote space to an
    integration that might just go away and stop working without notice. If you want
    to integrate `Redux`, read the preceding page I mentioned, but be careful when
    you update the navigation package, just in case something stops working. You have
    been warned!**
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告表明，把空间用于一个可能会突然停止工作的集成并不是一个好主意。如果你想集成`Redux`，请阅读我之前提到的页面，但在更新导航包时要小心，以防止某些功能停止工作。你已经被警告了！**
