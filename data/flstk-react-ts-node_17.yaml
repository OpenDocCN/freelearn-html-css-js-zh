- en: '*Chapter 14*: Setting Up Postgres and a Repository Layer with TypeORM'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：使用TypeORM设置Postgres和存储库层'
- en: In this chapter, we'll learn about setting up a repository layer using Postgres
    as our database and TypeORM as our library for accessing the database. We'll build
    our database schema and, with the help of TypeORM, we'll be able to perform **CRUD**
    (**Create, Read, Update, Delete**) operations for our application. This is a crucial
    chapter as the core activity of our backend will be to retrieve and update data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Postgres作为我们的数据库和TypeORM作为访问数据库的库来设置存储库层。我们将构建我们的数据库架构，并借助TypeORM，我们将能够为我们的应用程序执行**CRUD**（**创建，读取，更新，删除**）操作。这是一个关键的章节，因为我们的后端的核心活动将是检索和更新数据。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up our Postgres database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的Postgres数据库
- en: Understanding object relational mappers by using TypeORM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用TypeORM来理解对象关系映射器
- en: Building our repository layer using Postgres and TypeORM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Postgres和TypeORM构建我们的存储库层
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book will not be teaching you about relational databases. So, you should
    have a basic understanding of SQL, including simple querying and table structures,
    as well as web development using Node. We will once again be using Node and Visual
    Studio Code to write our code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会教授关系数据库知识。因此，你应该对SQL有基本的了解，包括简单的查询和表结构，以及使用Node进行Web开发。我们将再次使用Node和Visual
    Studio Code来编写我们的代码。
- en: The GitHub repository is available at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap14` folder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap14`文件夹中的代码。
- en: To set up the [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)
    code folder, go to your `HandsOnTypescript` folder and create a new folder called
    `Chap14`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置[*第14章*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216)的代码文件夹，请转到你的`HandsOnTypescript`文件夹，并创建一个名为`Chap14`的新文件夹。
- en: Setting up our Postgres database
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的Postgres数据库
- en: In this section, we will install and set up a Postgres database. Relational
    databases are still very relevant, and these days NoSQL databases are all the
    rage. However, according to StackOverflow, Postgres continues to be one of the
    world's most popular databases. Additionally, its performance is world class,
    beating MongoDB by a significant margin ([https://www.enterprisedb.com/news/new-benchmarks-show-postgres-dominating-mongodb-varied-workloads](https://www.enterprisedb.com/news/new-benchmarks-show-postgres-dominating-mongodb-varied-workloads)).
    So, Postgres is what we will be using as our database technology.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装和设置Postgres数据库。关系数据库仍然非常重要，而现在NoSQL数据库非常流行。然而，根据StackOverflow的说法，Postgres仍然是世界上最受欢迎的数据库之一。此外，它的性能是世界一流的，比MongoDB高出很大的边际（[https://www.enterprisedb.com/news/new-benchmarks-show-postgres-dominating-mongodb-varied-workloads](https://www.enterprisedb.com/news/new-benchmarks-show-postgres-dominating-mongodb-varied-workloads)）。因此，Postgres是我们将使用的数据库技术。
- en: 'Let''s install our Postgres database. We will use the installer provided by
    EDB. EDB is a third-party company that provides tools and services for supporting
    Postgres:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装我们的Postgres数据库。我们将使用EDB提供的安装程序。EDB是一家第三方公司，提供支持Postgres的工具和服务：
- en: Go to the URL [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)
    and select the download for your platform. I will be using version 12.4 for Mac,
    which is the latest Mac version as of the time of writing.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到网址[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)，并选择适合你平台的下载。我将使用Mac的12.4版本，这是我写作时的最新Mac版本。
- en: Accept all the defaults on the installer, including the list of components to
    be installed, as shown here:![Figure 14.1 – Postgres Setup screen
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受安装程序上的所有默认设置，包括要安装的组件列表，如下所示：![图14.1 - Postgres设置屏幕
- en: '](img/Figure_14.01_B15508.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.01_B15508.jpg)'
- en: Figure 14.1 – Postgres Setup screen
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 - Postgres设置屏幕
- en: Once your install finishes, start up the `pgAdmin` application. This application
    is the administrator application for Postgres. You should see a screen like this:![Figure
    14.2 – First view of pgAdmin
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，启动`pgAdmin`应用程序。这个应用程序是Postgres的管理员应用程序。你应该会看到这样的屏幕：![图14.2 - pgAdmin的第一个视图
- en: '](img/Figure_14.02_B15508.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.02_B15508.jpg)'
- en: Figure 14.2 – First view of pgAdmin
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 - pgAdmin的第一个视图
- en: As you can see, it is a web browser application. I have some other servers on
    my installation, but your install should not have any if this is your first `pgAdmin`
    install.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个Web浏览器应用程序。我在我的安装中有一些其他服务器，但如果这是你的第一个`pgAdmin`安装，你的安装应该没有任何服务器。
- en: Now, let's create a new server group called `HandsOnFullStackGroup` so we can
    keep our work separate from others. A server group is just a container to house
    multiple server instances, and each server can have multiple databases inside
    them. Note that a server **does not** indicate a single physical machine.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`HandsOnFullStackGroup`的新服务器组，这样我们就可以将我们的工作与其他人分开。服务器组只是一个容器，可以容纳多个服务器实例，每个服务器可以在其中拥有多个数据库。请注意，一个服务器**并不**表示一个单独的物理机器。
- en: First, select the option for **Server Group** by right-clicking over the **Servers**
    item, as shown here:![Figure 14.3 – pgAdmin adding a server group
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过右键单击**Servers**项目，选择**Server Group**选项，如下所示：![图14.3 - pgAdmin添加服务器组
- en: '](img/Figure_14.03_B15508.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.03_B15508.jpg)'
- en: Figure 14.3 – pgAdmin adding a server group
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 - pgAdmin添加服务器组
- en: Next, create a server by right-clicking on the new `SuperForumServers` on the
    first screen, as follows:![Figure 14.4 – The Create - Server tab
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在第一个屏幕上右键单击新的`SuperForumServers`，创建一个服务器，如下所示：![图14.4 - 创建 - 服务器选项卡
- en: '](img/Figure_14.04_B15508.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.04_B15508.jpg)'
- en: Figure 14.4 – The Create - Server tab
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 - 创建 - 服务器选项卡
- en: Now, select the second tab, `localhost` as the `postgres`. The Postgres account
    is the root administrator account, so you need to remember this password. Here's
    a screenshot of this tab:![Figure 14.5 – The Connection tab
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择第二个选项卡，`localhost`作为`postgres`。Postgres账户是根管理员账户，所以你需要记住这个密码。这是这个选项卡的截图：![图14.5
    – 连接选项卡
- en: '](img/Figure_14.05_B15508.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.05_B15508.jpg)'
- en: Figure 14.5 – The Connection tab
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 连接选项卡
- en: 'Select **Save** and your server will be created. You should see the following
    view:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**保存**，你的服务器将被创建。你应该会看到以下视图：
- en: '![Figure 14.6 – View of the new HandsOnFullStackGroup and SuperForumServers'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.6 – 新的HandsOnFullStackGroup和SuperForumServers视图'
- en: '](img/Figure_14.06_B15508.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.06_B15508.jpg)'
- en: Figure 14.6 – View of the new HandsOnFullStackGroup and SuperForumServers
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 新的HandsOnFullStackGroup和SuperForumServers视图
- en: Notice that there is already a database called **postgres** there. This database
    is empty, but can be used to store global data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，那里已经有一个名为**postgres**的数据库。这个数据库是空的，但可以用来存储全局数据。
- en: 'Now, let''s create the database for our application. However, before we can
    do that, we need to create a new account specifically to use in relation to our
    new database. Using the default administrator account, postgres, would not be
    a good idea as, if it were to be hacked, it would give the attacker access to
    our entire server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的应用程序创建数据库。但是，在我们这样做之前，我们需要创建一个新的账户，专门用于与我们的新数据库相关联。使用默认管理员账户postgres不是一个好主意，因为如果被黑客攻击，它将给予攻击者对整个服务器的访问权限：
- en: In `pgAdmin`, right-click on `superforumsvc`. Then, in the **Definition** tab,
    set your own password. Next, go to the **Privileges** tab and **make sure** to
    enable login. The rest you can keep as the default settings.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pgAdmin`中，右键单击`superforumsvc`。然后，在**定义**选项卡中，设置您自己的密码。接下来，转到**权限**选项卡，并**确保**启用登录。其余设置可以保持默认设置。
- en: Next, right-click on the `SuperForum` and select **superforumsvc** as **Owner**:![Figure
    14.7 – Creating the SuperForum database
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击`SuperForum`，选择**superforumsvc**作为**所有者**：![图14.7 – 创建SuperForum数据库
- en: '](img/Figure_14.07_B15508.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.07_B15508.jpg)'
- en: Figure 14.7 – Creating the SuperForum database
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 – 创建SuperForum数据库
- en: 'Then, click **Save**. Your view should now show this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**保存**。你的视图现在应该显示如下：
- en: '![Figure 14.8 – New database and user'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.8 – 新数据库和用户'
- en: '](img/Figure_14.08_B15508.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.08_B15508.jpg)'
- en: Figure 14.8 – New database and user
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 新数据库和用户
- en: Terrific! We now have a database. If we were not using an ORM, we would have
    to go through the tedious process of manually creating our tables and fields.
    But, as you'll see, TypeORM saves us from this grunt work, as well as providing
    us with great language features to query our database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在有了一个数据库。如果我们不使用ORM，我们将不得不经历手动创建表和字段的繁琐过程。但是，正如你将看到的，TypeORM可以帮我们省去这些苦工，同时为我们提供了很棒的语言特性来查询我们的数据库。
- en: In the next section, we'll dig into TypeORM. We'll learn about how it works
    and how it helps us, at many levels, to interact with our database.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解TypeORM。我们将学习它是如何工作的，以及它如何在许多层面上帮助我们与我们的数据库交互。
- en: Understanding object relational mappers by using TypeORM
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过使用TypeORM来理解对象关系映射器
- en: In this section, we'll learn what **Object Relational Mapper** (**ORM**) technology
    is. We'll also learn about TypeORM, one of the most popular ORM frameworks for
    JavaScript. ORM can make working with databases a lot easier and reduce some cognitive
    load for the developer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习什么是**对象关系映射器**（**ORM**）技术。我们还将了解TypeORM，这是JavaScript中最流行的ORM框架之一。ORM可以使与数据库的工作变得更加容易，并减少开发人员的一些认知负担。
- en: As a programmer, you know that different programming languages have types that
    are incompatible. For example, JavaScript, despite the name, cannot use or even
    access Java types directly. In order for either language to use the types from
    the other, we would need to do some sort of translation. In part, this is the
    reason for having services such as the Web API. The Web API provides all data
    to callers as a string format, like JSON. This allows any caller to use the data
    since it can be read by any language.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你知道不同的编程语言具有不兼容的类型。例如，尽管名字相似，JavaScript不能直接使用甚至访问Java类型。为了让任一语言使用另一语言的类型，我们需要进行某种形式的翻译。部分原因是有了诸如Web
    API这样的服务。Web API以字符串格式（如JSON）提供所有数据给调用者。这允许任何调用者使用数据，因为它可以被任何语言读取。
- en: Database to coding language conversion has similar type incompatibilities. So,
    normally after making a query that returns data, we would have to take each field's
    value from the database and manually write code to convert it to a specific type
    in the coding language. However, if we use an ORM, most of this work goes away.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库到编程语言的转换具有类似的类型不兼容性。因此，通常在进行返回数据的查询之后，我们需要从数据库中取出每个字段的值，并手动编写代码将其转换为编程语言中的特定类型。然而，如果我们使用ORM，大部分工作都会消失。
- en: An ORM is designed so that it *knows* how to map database fields into code fields
    and handles that translation work for us. Additionally, most ORMs have some sort
    of capability to autocreate tables and fields on the database based on entity
    structures created in code. You can think of entities as types on the coding language
    side that represent similar objects to tables on the database side. For example,
    if we have an entity called `User` in our JavaScript, it would be expected that
    we would have a table called `Users` on the database to match it (it's plural
    because a table holds more than one user).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ORM被设计成*知道*如何将数据库字段映射到代码字段，并为我们处理这些翻译工作。此外，大多数ORM都具有某种能力，根据在代码中创建的实体结构自动在数据库上创建表和字段。你可以将实体视为编程语言端表示与数据库端表类似对象的类型。例如，如果我们在JavaScript中有一个名为`User`的实体，那么我们期望在数据库中有一个名为`Users`的表与之匹配（它是复数形式，因为一个表可以容纳多个用户）。
- en: This feature alone can save an enormous amount of time and effort for developers,
    but on top of this, a good ORM will also have features to help build queries,
    insert parameters safely (reducing the chance of SQL injection attacks), and also
    handle transactions. Transactions are atomic database operations that must complete
    in their entirety or all the actions involved are undone.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此功能就可以为开发人员节省大量的时间和精力，但除此之外，一个良好的ORM还将具有帮助构建查询、安全插入参数（减少SQL注入攻击的机会）以及处理事务的功能。事务是必须完全完成的原子数据库操作，否则涉及的所有操作都将被撤消。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A SQL injection attack is an attempt by a malicious person to insert SQL code
    that is different from the one originally intended by the developers. It can result
    in issues such as data loss and application failure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击是恶意人员尝试插入与开发人员最初意图不同的SQL代码的尝试。它可能导致诸如数据丢失和应用程序失败等问题。
- en: For our application, we will be using TypeORM. TypeORM is a popular and highly
    rated ORM for TypeScript, with over 20,000 likes on GitHub. It provides all of
    the features mentioned and is easy to get started with, although becoming an advanced
    user does take considerable effort. It supports multiple databases, including
    Microsoft SQL, MySQL, and Oracle.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用TypeORM。TypeORM是一个受欢迎且备受好评的TypeScript ORM，在GitHub上有超过20,000个赞。它提供了所有提到的功能，并且很容易入门，尽管成为高级用户需要相当大的努力。它支持多个数据库，包括Microsoft
    SQL、MySQL和Oracle。
- en: It will save us a great deal of time with its rich feature set, and because
    many JavaScript projects use TypeORM, there is a large community of developers
    that can help if you run into issues when using it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它将通过其丰富的功能集为我们节省大量时间，并且因为许多JavaScript项目使用TypeORM，所以有一个庞大的开发人员社区可以在您使用它时提供帮助。
- en: In this section, we learned about ORM technology. We learned what it is and
    why it's important and valuable to use. In the next section, we will be using
    TypeORM to build our own project. Let's get started.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了ORM技术。我们了解了它是什么，以及为什么使用它是重要和有价值的。在下一节中，我们将使用TypeORM来构建我们自己的项目。让我们开始吧。
- en: Building our repository layer using Postgres and TypeORM
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Postgres和TypeORM构建我们的存储库层
- en: In this section, we'll learn about the importance of using a repository layer.
    Having a separate layer for a large and important part of our application can
    help make code refactoring easier. It is also helpful in terms of understanding
    how the app works since major sections are logically separated out.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解使用存储库层的重要性。为我们的应用程序的一个重要部分设置一个单独的层可以帮助简化代码重构。从逻辑上分离主要部分也有助于理解应用程序的工作原理。
- en: In [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017), *Understanding
    TypeScript*, we learned about **Object-Oriented Programming** (**OOP**). One of
    the major mechanisms for implementing OOP design is the use of abstraction. By
    creating our database access code in its own separate layer, we are using abstraction.
    As you may recall, one of the benefits of abstraction is that it hides the implementation
    of the code internally and exposes an interface to outside callers. Additionally,
    because all code related to accessing the database is in one place, we don't have
    to hunt around to find our database query code. We know which layer of our application
    this code lives in. Keeping code logically separate is known as the separation
    of concerns.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017)中，*理解TypeScript*，我们学习了**面向对象编程**（**OOP**）。实现OOP设计的主要机制之一是使用抽象。通过在其自己的单独层中创建我们的数据库访问代码，我们正在使用抽象。正如您可能记得的那样，抽象的好处之一是它隐藏了代码的内部实现并向外部调用者公开接口。此外，因为与访问数据库相关的所有代码都在一个地方，我们不必四处寻找我们的数据库查询代码。我们知道这段代码位于我们应用程序的哪个层中。保持代码逻辑上的分离被称为关注点分离。
- en: 'So, let''s get started with building our repository layer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始构建我们的存储库层：
- en: First, we need to copy our server code that we created in [*Chapter 13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208),
    *Setting Up Session State Using Express and Redis*. Go to the `Chapter13` folder
    in the source code and copy the `super-forum-server` folder into the `Chapter14`
    folder.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要复制我们在[*第13章*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208)中创建的服务器代码，*使用Express和Redis设置会话状态*。转到源代码中的`Chapter13`文件夹，并将`super-forum-server`文件夹复制到`Chapter14`文件夹中。
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to install TypeORM and its related dependencies. Run the following
    command:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装TypeORM及其相关依赖项。运行以下命令：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, before we can start creating our Entities database, we need to create
    a configuration file so that our TypeORM code can access our Postgres database.
    This means that we also have to update our `.env` file with our database configurations.
    Open the `.env` file and add these variables. Our server was installed locally,
    so `PG_HOST` has the value `localhost`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们开始创建我们的实体数据库之前，我们需要创建一个配置文件，以便我们的TypeORM代码可以访问我们的Postgres数据库。这意味着我们还需要更新我们的`.env`文件与我们的数据库配置。打开`.env`文件并添加这些变量。我们的服务器是在本地安装的，所以`PG_HOST`的值为`localhost`：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The port the server uses for communication is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器用于通信的端口如下：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our database account name is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库帐户名称如下：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use the password you created for your own database:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您为自己的数据库创建的密码：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our database name is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库名称如下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As mentioned before, TypeORM will create our tables and fields for us and maintain
    them as they change. `PG_SYNCHRONIZE` enables that feature:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TypeORM将为我们创建表和字段，并在其更改时对其进行维护。 `PG_SYNCHRONIZE`启用了该功能：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, once you go live in production, you must disable this feature so
    as to prevent unwanted database changes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦您在生产中投入使用，您必须禁用此功能，以防止不必要的数据库更改。
- en: 'The location of our Entity files, including subdirectories, is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实体文件的位置，包括子目录，如下：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The root directory for our entities is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实体的根目录如下：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`PG_LOGGING` determines whether to enable logging on the server:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`PG_LOGGING`确定是否在服务器上启用日志记录：'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Logs should be enabled in production in order to trace issues. However, logs
    can create huge files, so we won't enable it for our development.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中应该启用日志以跟踪问题。但是，日志可能会创建巨大的文件，所以我们不会在开发中启用它。
- en: 'Now we can create our TypeORM configuration file. In the root of our project,
    `Chap13/super-forum-server`, create the file `ormconfig.js` and add this code
    to it:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的TypeORM配置文件。在我们项目的根目录`Chap13/super-forum-server`中，创建名为`ormconfig.js`的文件，并将以下代码添加到其中：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, we get our `.env` configurations by requiring them:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过`require`获取我们的`.env`配置：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Which database type will we connect to? Since TypeORM supports multiple databases,
    we need to indicate this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接到哪种数据库类型？由于TypeORM支持多个数据库，我们需要指示这一点。
- en: 'The rest of the values use the configurations from our `.env` file, so they
    are self-explanatory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的值使用我们的`.env`文件中的配置，因此它们是不言自明的：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we're ready to start creating our entities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始创建我们的实体。
- en: 'Now that we''ve installed our dependencies and set up the configuration to
    the database, let''s create our first entity, the User. Change the directory to
    the `Chap14/super-forum-server` folder and then create, inside the `src` folder,
    a folder called `repo`. We''ll place all of our repository code there. Then, create
    a file inside `repo` called `User.ts` with the following code in it:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经安装了依赖项并设置了数据库的配置，让我们创建我们的第一个实体，用户。将目录更改为`Chap14/super-forum-server`文件夹，然后在`src`文件夹内创建一个名为`repo`的文件夹。我们将把所有的存储库代码放在那里。然后，在`repo`内创建一个名为`User.ts`的文件，并在其中添加以下代码：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These TypeORM imports will allow us to create our `User` entity class. `Entity`,
    `PrimaryGeneratedColumn`, and `Column` are what are known as decorators. Decorators
    are attributes placed just before a relevant line of code that provide additional
    configuration information about a field or object. You can think of them as a
    shortcut. Instead of writing some long lines of code, you can simply add a tag
    that sets configurations. We''ll see examples in this code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些TypeORM导入将允许我们创建我们的`User`实体类。`Entity`、`PrimaryGeneratedColumn`和`Column`被称为装饰器。装饰器是放置在相关代码行之前的属性，提供有关字段或对象的附加配置信息。你可以把它们看作是一种快捷方式。你可以简单地添加一个标签来设置配置，而不是编写一些长长的代码行。我们将在这段代码中看到例子：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a validator for length.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个长度的验证器。
- en: 'Next comes our first use of decorators. The `Entity` decorator tells TypeORM
    that the class that is about to be defined is an entity with the name `Users`.
    In other words, in our code we will have objects called `User` that map directly
    to tables in our database called `Users`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们第一次使用装饰器。`Entity`装饰器告诉TypeORM即将定义的类是一个名为`Users`的实体。换句话说，在我们的代码中，我们将有一个称为`User`的对象，它直接映射到我们数据库中称为`Users`的表：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In databases, every table must have a unique identifying field. This is what
    `PrimaryGeneratedColumn` indicates. The field name will be `id`. Notice that the
    """ in `id` is not capitalized. We''ll fix this issue later:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中，每个表必须有一个唯一的标识字段。这就是`PrimaryGeneratedColumn`的含义。字段名称将是`id`。请注意，`id`中的"""不是大写。我们稍后会解决这个问题：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we have our first use of the `Column` decorator:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将首次使用`Column`装饰器：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, it is used to define the database field `Email`, which will
    be called `email` in our TypeScript code. So again, decorators are being used
    to map our code objects to database entities. Now, let''s go through the `Column`
    decorator more closely. First, it defines that our column is of the `varchar`
    database type. Again, database types are different from code types, as shown here.
    Next, we see the `name` field, which is set to `Email`. This will be the exact
    name of this field in the `Users` table. Then we have `length`, which indicates
    the maximum allowed character count of this field. The `unique` attribute tells
    Postgres to enforce the fact that each `User` entry must have a unique email.
    And finally, we have `nullable` set to `false`, which means this field must have
    a value in the database:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它用于定义数据库字段`Email`，在我们的TypeScript代码中将被称为`email`。因此，装饰器再次被用来将我们的代码对象映射到数据库实体。现在，让我们更仔细地看一下`Column`装饰器。首先，它定义了我们的列是`varchar`数据库类型。再次强调，数据库类型与代码类型不同，如此处所示。接下来，我们看到`name`字段，设置为`Email`。这将是`Users`表中此字段的确切名称。然后我们有`length`，它表示此字段允许的最大字符数。`unique`属性告诉Postgres强制每个`User`条目必须具有唯一的电子邮件。最后，我们将`nullable`设置为`false`，这意味着此字段在数据库中必须有一个值：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we used the `Length` decorator to make sure that the field entered has
    a minimum and maximum character length:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Length`装饰器来确保输入的字段具有最小和最大字符长度：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The two fields, `userName` and `password`, have `varchar` as columns, with
    similar settings to `email`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字段，`userName`和`password`，都将`varchar`作为列，具有与`email`类似的设置：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, here we see a `confirmed` field that is of the `boolean` type. The `confirmed`
    field will show whether the newly registered user account has been email verified
    yet. Note, it''s pretty self-explanatory, but the default setting indicates that
    at the moment the record is inserted into the database, unless explicitly set,
    it will be set to `false`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到了一个`confirmed`字段，它是`boolean`类型。`confirmed`字段将显示新注册用户帐户是否已经通过电子邮件验证。请注意，这是相当不言自明的，但默认设置表明，当前记录插入数据库时，除非明确设置，它将被设置为`false`：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And finally, here's the `isDisabled` field, which will allow us to disable an
    account for management purposes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是`isDisabled`字段，它将允许我们出于管理目的禁用帐户。
- en: 'Great! Now we can see whether TypeORM will create our new `Users` table on
    our behalf. The last thing we need to do is connect to the Postgres database from
    our code. Update `index.ts` like this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！现在我们可以看到TypeORM是否会代表我们创建新的`Users`表。我们需要做的最后一件事是从我们的代码连接到Postgres数据库。像这样更新`index.ts`：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have imported the `createConnection` function from TypeORM:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从TypeORM导入了`createConnection`函数：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we've called `createConnection`. But notice that our code is now wrapped
    in a function called `main` that is `async`. The reason we needed this is that
    `createConnection` is an `async` call and requires an `await` prefix. So, we had
    to wrap it in an `async` function, which is what the `main` function does.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了`createConnection`。但请注意，我们的代码现在包裹在一个名为`main`的`async`函数中。我们需要这样做的原因是`createConnection`是一个`async`调用，需要一个`await`前缀。因此，我们不得不将其包装在一个`async`函数中，这就是`main`函数的作用。
- en: 'The remaining code is the same, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码是一样的，如下所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Again, the code is the same:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，代码是一样的：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And finally, we've called our `main` function to execute it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用了我们的`main`函数来执行它。
- en: 'Now, let''s run our application by running the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令来运行我们的应用程序：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, we have a small issue. Our `id` column is not using capitalization
    even though our other columns are. Let's fix that. Open the `User.ts` file again
    and simply change the name setting of the `PrimaryGeneratedColumn` decorator to
    be `Id` instead of `id` (only in the decorator; leave the `id` field name in our
    JavaScript). If your server is not running, start it again. But after it restarts,
    refresh the `id` column has been updated to `Id`. This is a terrific feature of
    TypeORM, as manually changing column names or constraints can sometimes be painful.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们有一个小问题。我们的`id`列尽管其他列都是大写，但没有使用大写。让我们来修复这个问题。再次打开`User.ts`文件，只需将`PrimaryGeneratedColumn`装饰器的名称设置更改为`Id`而不是`id`（只在装饰器中；在我们的JavaScript中保留`id`字段名称）。如果您的服务器没有运行，请重新启动。但重新启动后，刷新`id`列已更新为`Id`。这是TypeORM的一个很棒的功能，因为手动更改列名或约束有时可能很痛苦。
- en: 'Great! Now we just need to create our other entities: `Thread` and `ThreadItem`.
    Again, `Thread` is the initial starting post in our forum and `ThreadItems` are
    the responses. First, stop your server so that it doesn''t create our database
    items before we''re ready. Now, since this is mostly repetitive, I''ll just show
    the code here without comment.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！现在我们只需要创建我们的其他实体：`Thread`和`ThreadItem`。再次强调，`Thread`是我们论坛中的初始帖子，而`ThreadItems`是回复。首先，停止服务器，以免在我们准备好之前创建数据库项。现在，由于这大部分是重复的，我将在这里只显示代码而不加注释。
- en: 'The imports for both these files will be identical and as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件的导入将是相同的，如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Thread` entity looks like this for now (we''ll be adding more fields once
    we build our table relationships):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`实体目前看起来是这样的（一旦建立了表关系，我们将添加更多字段）：'
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ThreadItem` looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadItem`看起来是这样的：'
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, both entities are pretty straightforward. Now, restart your
    server and you should see the two new tables: **Threads** and **ThreadItems**:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，这两个实体都非常简单。现在重新启动服务器，您应该会看到两个新表：**Threads**和**ThreadItems**：
- en: '![Figure 14.10 – Threads and ThreadItems'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10 - Threads和ThreadItems'
- en: '](img/Figure_14.10_B15508.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.10_B15508.jpg)'
- en: Figure 14.10 – Threads and ThreadItems
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 - Threads和ThreadItems
- en: 'We still have many fields to add, such as the points column. But first, let''s
    build out some relationships between tables. For example, every table should have
    an association with a specific user. Let''s begin by adding these relationships:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有许多字段要添加，比如points列。但首先，让我们在表之间建立一些关系。例如，每个表都应该与特定的用户有关联。让我们从添加这些关系开始：
- en: 'First, stop your server. Then, in your `User.ts` file, add this to the bottom
    of your class. I''ll assume you know how to add any required imports by now and
    won''t mention them further:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，停止服务器。然后，在您的`User.ts`文件中，将此添加到您的类的底部。我假设您现在知道如何添加任何必需的导入，不再提及它们：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `OneToMany` decorator shows that for each individual `User`, there are potentially
    multiple `Threads` associated.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`OneToMany`装饰器显示每个单独的`User`可能有多个关联的`Threads`。'
- en: 'Now, add this to the bottom of your `Thread.ts` file''s `Thread` class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将这段代码添加到您的`Thread.ts`文件的`Thread`类的底部：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `ManyToOne` decorator shows that every `Thread`, of multiple threads, has
    only one `User` associated with it. Although teaching SQL is beyond the scope
    of this book, put simply, these relationships act as constraints on the database,
    meaning we are prevented from inserting data that does not make sense; for example,
    having multiple `Users` *owning* a single `Thread`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManyToOne`装饰器显示每个`Thread`只有一个与之关联的`User`。尽管教授SQL超出了本书的范围，但简单地说，这些关系作为数据库的约束，意味着我们无法插入没有意义的数据；例如，拥有多个`Users`*拥有*一个`Thread`。'
- en: 'Now, let''s establish the relationship of our `Thread` to `ThreadItems`. Add
    this code to the `Thread` class:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们建立`Thread`与`ThreadItems`之间的关系。将以下代码添加到`Thread`类中：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Again, this shows that one `Thread` can have multiple `ThreadItems` associated
    with it. Now, let''s update our `ThreadItem`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这表明一个`Thread`可以有多个与之关联的`ThreadItems`。现在，让我们更新我们的`ThreadItem`：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A `ThreadItem`, like a `Thread`, can only have one `User` associated with it
    as the owner:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadItem`和`Thread`一样，只能与一个`User`关联为所有者：'
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Each `ThreadItem` can only have one parent `Thread`. Now, if you restart the
    server, you should see these new relationships:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个`ThreadItem`只能有一个父`Thread`。现在，如果重新启动服务器，您应该会看到这些新的关系：
- en: '![Figure 14.11 – Relationships'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11 - 关系'
- en: '](img/Figure_14.11_B15508.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.11_B15508.jpg)'
- en: Figure 14.11 – Relationships
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 - 关系
- en: You will see in the `Threads` and `ThreadItems` tables that new columns have
    been added. For example, in `ThreadItems`, `userId` and `threadId` were added
    to indicate their respective relationships. However, in the `Users` table, nothing
    was added. This is because the `Users` table has a `OneToMany` relationship with
    the `Threads` table. Therefore, this relationship is indicated by the constraint
    shown in the image for the `CREATE TABLE public."Threads"` script. As you can
    see, there is a constraint for the `userId` column. So, by indicating that each
    thread has a single `User` associated with it, it implicitly indicates that each
    `User` can have one or more `Threads` that it owns.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到`Threads`和`ThreadItems`表中已添加了新列。例如，在`ThreadItems`中，添加了`userId`和`threadId`以指示它们的相关关系。但是，在`Users`表中没有添加任何内容。这是因为`Users`表与`Threads`表具有`OneToMany`关系。因此，此关系由图像中`CREATE
    TABLE public."Threads"`脚本所示的约束表示。正如您所看到的，`userId`列有一个约束。因此，通过指示每个线程都有一个与之关联的`User`，它隐含地指示每个`User`可以拥有一个或多个自己拥有的`Threads`。
- en: Now, let's set up our points system. In the case of points, that is, likes or
    dislikes, we need to allow users to be able to vote either up or down only once.
    However, there's no way to indicate that in terms of a single table. So, we'll
    create two new tables, `ThreadPoints` and `ThreadItemPoints`, which will have
    associations with relevant `Users`, `Threads`, and `ThreadItems`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的积分系统。在积分的情况下，即喜欢或不喜欢，我们需要允许用户只能投票一次。但是，没有办法在单个表的术语中指示这一点。因此，我们将创建两个新表，`ThreadPoints`和`ThreadItemPoints`，它们将与相关的`Users`，`Threads`和`ThreadItems`关联。
- en: 'First, shut down your server and then create the `ThreadPoint.ts` file. Then,
    add this code to it:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，关闭服务器，然后创建`ThreadPoint.ts`文件。然后，将以下代码添加到其中：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, what we''re doing here in this code is saying that this point is for a
    specific `User` and `Thread`. We are also indicating that if the `isDecrement`
    field is `true`, then this constitutes a dislike. This means that points have
    three possible states: no points at all, a like, or a dislike. We''ll write some
    code in our repository queries later to handle these three states.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这段代码中，我们在指定特定的`User`和`Thread`。我们还指出，如果`isDecrement`字段为`true`，则这构成了不喜欢。这意味着积分有三种可能的状态：没有积分，喜欢或不喜欢。我们稍后将编写一些代码来处理这三种状态的存储库查询。
- en: 'Now, add this code to the `User.ts` class:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`User.ts`类中：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Again, this code completes the associations in code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，此代码完成了代码中的关联。
- en: 'Next, add the following to the `Thread.ts` class:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下内容添加到`Thread.ts`类中：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This also completes the association with `ThreadPoint`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这也完成了与`ThreadPoint`的关联。
- en: 'Now, we need to do the same thing for `ThreadItemPoints`. Create `ThreadItemPoint.ts`
    and add the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为`ThreadItemPoints`做同样的事情。创建`ThreadItemPoint.ts`并添加以下代码：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is a pretty similar setup to `ThreadPoint`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`ThreadPoint`的设置非常相似。
- en: 'Now we update our `User` class by adding the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过添加以下内容来更新我们的`User`类：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And we update our `ThreadItem` class by adding this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过添加以下内容来更新我们的`ThreadItem`类：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And this completes the associations needed in relation to `ThreadItemPoint`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这也完成了与`ThreadItemPoint`相关的关联。
- en: 'We''re not done yet though. You may recall from [*Chapter 11*](B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167),
    *What We Will Learn – Online Forum Application*, that our threads will have categories,
    so we need to create that entity and its relationship as well:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有完成。您可能还记得[*第11章*](B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167)，*我们将学到什么-在线论坛应用*，我们的主题将有类别，因此我们还需要创建该实体及其关系：
- en: 'First, create the `ThreadCategory.ts` file and add this code to it:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建`ThreadCategory.ts`文件，并将以下代码添加到其中：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`ThreadCategory` has a pretty similar setup to the other entities.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadCategory`与其他实体有一个非常相似的设置。'
- en: 'Now, add this to the `Thread.ts` class:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下内容添加到`Thread.ts`类中：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This, of course, creates the relationship between `Thread` and `ThreadCategory`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这就建立了`Thread`和`ThreadCategory`之间的关系。
- en: Now, run the server and it should create the tables and associations.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行服务器，它应该创建表和关联。
- en: Now we've created the entities that we need and also their associations. But
    whenever we add data to a database, we want to log when it was created or changed.
    However, implementing this will create identical fields across all entities, and
    we don't want to write the same code over and over again.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所需的实体及其关联。但是，每当我们向数据库添加数据时，我们希望记录其创建或更改的时间。但是，实现这一点将在所有实体中创建相同的字段，我们不希望一遍又一遍地编写相同的代码。
- en: 'Well, since TypeScript allows us to use inheritance in classes, let''s create
    a base type that has these fields that we need and then have each entity simply
    inherit from this base class. Additionally, TypeORM requires that our entities
    inherit from its own base class in order to be able to connect to its API. So,
    then let''s add the TypeORM base class in our own base class as well:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript允许我们在类中使用继承，因此让我们创建一个具有我们需要的这些字段的基本类型，然后让每个实体简单地从这个基类继承。此外，TypeORM要求我们的实体必须从其自己的基类继承，以便能够连接到其API。因此，让我们在我们自己的基类中也添加TypeORM基类：
- en: 'Create a file called `Auditable.ts` and add this code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Auditable.ts`的文件，并添加以下代码：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`Getpgusername` is the service account `superforumsvc` and that''s what this
    field will default to, unless explicitly set:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Getpgusername`是服务账户`superforumsvc`，除非明确设置，否则该字段将默认为此：'
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This field will default to the current time and date, `now()`, unless explicitly
    set.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除非明确设置，否则该字段将默认为当前时间和日期`now()`。
- en: 'As you can see, the fields are pretty self-explanatory as to what they do.
    However, notice that our base class, `Auditable`, also extends the TypeORM base
    class called `BaseEntity`. This `BaseEntity` inheritance is what allows our entities
    to access the Postgres database through TypeORM:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，字段的作用是相当不言自明的。但是，请注意我们的基类`Auditable`还扩展了名为`BaseEntity`的TypeORM基类。这种`BaseEntity`继承是允许我们的实体通过TypeORM访问Postgres数据库的原因：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'OK, so that''s the new `Auditable` base class covered. Now we want to make
    our entities inherit it. This is simple. For example, in the `User` class, just
    add the `extends` keyword and add the `Auditable` class like this:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，这就是新的`Auditable`基类的内容。现在我们想让我们的实体继承它。这很简单。例如，在`User`类中，只需添加`extends`关键字并像这样添加`Auditable`类：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Repeat this process for every entity and then restart your server (remember
    to add your import statements as needed). Once you refresh your view, you should
    see the new fields like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个实体重复此过程，然后重新启动服务器（记得根据需要添加导入语句）。刷新视图后，您应该看到新的字段如下：
- en: '![Figure 14.12 – User updated for Auditable'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12-更新为可审计的用户'
- en: '](img/Figure_14.12_B15508.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.12_B15508.jpg)'
- en: Figure 14.12 – User updated for Auditable
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12-更新为可审计的用户
- en: 'Awesome! Now we can create our repository library that will actually call into
    our database. Since we created our Session State in the last chapter, [*Chapter
    13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208), *Setting Up Session State
    Using Express and Redis*, let''s create our authentication-related calls first:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们可以创建实际调用我们数据库的存储库库。由于我们在上一章中创建了我们的会话状态，[*第13章*]（B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208），*使用Express和Redis设置会话状态*，让我们首先创建与身份验证相关的调用：
- en: Before we create our main code, we need to do something first. You may recall
    from [*Chapter 11*](B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167), *What We
    Will Learn – Online Forum Application*, we used a function called `isPasswordValid`
    to check that the user's password was sufficiently long and complex. We will need
    to reuse that code on our server because, as I mentioned then, validation in general
    should be done on both the client and server. So, let's temporarily copy the `PasswordValidator.ts`
    file and the `common/validators` folder structure into our server project, and
    later I'll show a method for sharing code across multiple projects.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建我们的主要代码之前，我们需要先做一些事情。您可能还记得[*第11章*]（B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167），*我们将学到什么-在线论坛应用*，我们使用了一个名为`isPasswordValid`的函数来检查用户的密码是否足够长和复杂。因为，正如我当时提到的，通常应该在客户端和服务器上进行验证。因此，让我们暂时将`PasswordValidator.ts`文件和`common/validators`文件夹结构复制到我们的服务器项目中，稍后我将展示一种在多个项目之间共享代码的方法。
- en: 'Let''s also create a validator for email addresses. Create an `EmailValidator.ts`
    file in the same `common/validators` directory and add this code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还为电子邮件地址创建一个验证器。在相同的`common/validators`目录中创建一个`EmailValidator.ts`文件，并添加此代码：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, I've checked for an empty address.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我检查了一个空地址。
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And here, I've checked for the @ symbol.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我检查了@符号。
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And finally, here I've checked for white space.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这里我检查了空格。
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If no issue is found, an empty string is returned.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发现问题，将返回一个空字符串。
- en: 'Create the `UserRepo.ts` file and add this code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`UserRepo.ts`文件并添加此代码：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, we have our imports, including our validators.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们的导入，包括我们的验证器。
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`saltRounds` is for password encryption, as you''ll soon see.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`saltRounds`用于密码加密，很快您就会看到。'
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We will use the `UserResult` type to indicate whether an error occurred during
    authentication. As you can see, it is basically a wrapper around the `User` object.
    We're using this object as the return type of our functions. We're doing this
    because when making network calls or other complex calls, it's not unusual for
    something to go wrong. Therefore, having the ability to include error or status
    messages with our objects is beneficial. Note how both members, `messages` and
    `user`, are optional. This will come in handy once we start using this type.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`UserResult`类型指示身份验证期间是否发生错误。正如您所看到的，它基本上是`User`对象的包装器。我们正在将此对象用作我们函数的返回类型。我们这样做是因为在进行网络调用或其他复杂调用时，出现问题是很常见的。因此，具有在对象中包含错误或状态消息的能力是有益的。请注意，`messages`和`user`两个成员都是可选的。一旦我们开始使用这种类型，这将非常方便。
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is the start of our `register` function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`register`函数的开始。
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we've run our two validators, `isPasswordValid` and `isEmailValid`. Notice
    how we've used an object literal as our return object and not included the `user`
    member. Again, TypeScript only cares about the shape of our objects matching the
    shape of the type. So, in this case, since our `UserResult` member, `user`, is
    optional, we can create a `UserResult` object that does not include it. TypeScript
    is really flexible.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行了我们的两个验证器`isPasswordValid`和`isEmailValid`。请注意，我们使用对象字面量作为返回对象，而没有包含`user`成员。同样，TypeScript只关心我们对象的形状是否与类型的形状匹配。因此，在这种情况下，由于我们的`UserResult`成员`user`是可选的，我们可以创建一个不包括它的`UserResult`对象。TypeScript真的很灵活。
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we've encrypted our password using the `saltRounds` constant and `bcryptjs`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`saltRounds`常量和`bcryptjs`加密了我们的密码。
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: And then, if we pass our validations, we `create` our `User` entity and then
    immediately `save` it. These two methods are both from TypeORM, and note that
    when making changes to the Entities database, you `save` function or else it will
    not complete on the server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们通过了验证，我们将`create`我们的`User`实体，然后立即`save`它。这两种方法都来自TypeORM，请注意，当对实体数据库进行更改时，您需要使用`save`函数，否则它将无法在服务器上完成。
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Then, we return the new entity and again, since our call has no errors, we only
    return the `user` object without any `messages`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们返回新实体，再次，由于我们的调用没有错误，我们只返回不包含任何`messages`的`user`对象。
- en: 'Let''s try this new function, `register`, with a real network call. Update
    the `index.ts` file like this:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试这个新功能`register`，进行真正的网络调用。像这样更新`index.ts`文件：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Notice that we now import `bodyParser`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在导入了`bodyParser`。
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we have set up our `bodyParser`, so we can read `json` parameters from
    posts.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了我们的`bodyParser`，这样我们就可以从帖子中读取`json`参数。
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'All this code remains the same:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码保持不变：
- en: '[PRE63]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you can see, we removed the previous `get` route and replaced it with `post`
    on the register URL. This call now runs our `UserRepo` `register` function and,
    if it is successful, it sends a message back with the new user''s ID. If it''s
    not successful, it sends back the error message from the repo call. In this case,
    we just use the first message, as we''ll be removing these routes and replacing
    them with GraphQL in [*Chapter 15*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222),
    *Adding GraphQL Schema – Part I*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们删除了以前的`get`路由，并在注册URL上用`post`替换它。这个调用现在运行我们的`UserRepo` `register`函数，如果成功，它会发送一个带有新用户ID的消息。如果不成功，它会发送回来自存储库调用的错误消息。在这种情况下，我们只使用第一条消息，因为我们将删除这些路由，并在[*第15章*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222)中用GraphQL替换它们，*添加GraphQL模式-第一部分*：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now we''ll start testing. However, we need to switch to using Postman instead
    of curl. Postman is a free application that will allow us to make `GET` and `POST`
    calls to our server while accepting session cookies. It''s very easy to use:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始测试。但是，我们需要切换到使用Postman而不是curl。Postman是一个免费的应用程序，它允许我们向服务器发出`GET`和`POST`调用，并接受会话cookie。它非常容易使用：
- en: First, go to [https://www.postman.com/downloads](https://www.postman.com/downloads)
    and download and install Postman for your system.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到[https://www.postman.com/downloads](https://www.postman.com/downloads)，并下载并安装适用于您系统的Postman。
- en: 'Following installation, the first thing you should do is run a `GET` call on
    the root of the site using Postman. I''ve created a simple route for the root,
    in `index.ts`, that will initialize the session and its cookie. Run the `GET`
    call on our site like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，您应该首先在Postman上运行站点根目录的`GET`调用。我在`index.ts`中为根目录创建了一个简单的路由，它将初始化会话及其cookie。像这样在我们的站点上运行`GET`调用：
- en: '![Figure 14.13 – Running Postman on the root of the site'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.13-在站点根目录上运行Postman'
- en: '](img/Figure_14.13_B15508.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.13_B15508.jpg)'
- en: Figure 14.13 – Running Postman on the root of the site
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13-在站点根目录上运行Postman
- en: 'This is how you can run this same `GET` call:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以运行相同`GET`调用的方法：
- en: Below the top tab labelled **GET**, you should see a dropdown to the left. Select
    **GET** and add the local URL. There are no parameters, so just click **Send**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标有**GET**的顶部标签下，您应该看到左侧的一个下拉菜单。选择**GET**并添加本地URL。没有参数，所以只需点击**Send**。
- en: Then, toward the bottom-left, you will see another dropdown. Select **Cookies**
    and you should see our cookie called **superforum**.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在左下角，您将看到另一个下拉菜单。选择**Cookies**，您应该会看到我们的名为**superforum**的cookie。
- en: 'Now you have the cookie required to maintain the Session State. So, we can
    now continue our testing, starting with the `register` function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经获得了维护会话状态所需的cookie。因此，我们现在可以继续我们的测试，从`register`函数开始：
- en: Open a new tab, select `http://localhost:5000/register`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新标签，选择`http://localhost:5000/register`。
- en: Click on the **Headers** tab and insert **Content-Type**, as shown here:![Figure
    14.14 – Content-Type
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Headers**选项卡，并插入**Content-Type**，如下所示：![图14.14-内容类型
- en: '](img/Figure_14.14_B15508.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.14_B15508.jpg)'
- en: Figure 14.14 – Content-Type
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14-内容类型
- en: Now, select the `email`, although it's invalid, the `userName`, and a `password`,
    which is also invalid.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择`电子邮件`，尽管它是无效的，`用户名`和`密码`，也是无效的。
- en: But still, this failure is good, as we have confirmed our validation is working.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种失败仍然是好的，因为我们已经确认了我们的验证是有效的。
- en: Let's fix the password and try again. Update the password to `Test123!@#` and
    run it again like this:![Figure 14.16 – Trying to register again
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修复密码，然后再试一次。将密码更新为`Test123!@#`，然后再次运行它：![图14.16-尝试再次注册
- en: '](img/Figure_14.16_B15508.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.16_B15508.jpg)'
- en: Figure 14.16 – Trying to register again
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16-尝试再次注册
- en: Now you should see the message **Please enter valid email address**. Again,
    this is what we want, as clearly the email given is not valid.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该会看到消息**请输入有效的电子邮件地址**。再次强调，这正是我们想要的，因为显然给出的电子邮件是无效的。
- en: Let's try one more time. Update the email to `test@test.com` and run this:![Figure
    14.17 – Successful registration
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再试一次。将电子邮件更新为`test@test.com`，并运行此操作：![图14.17-成功注册
- en: '](img/Figure_14.17_B15508.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.17_B15508.jpg)'
- en: Figure 14.17 – Successful registration
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17-成功注册
- en: The output message, `10` as I was doing some testing in preparing this book.
    ID fields will normally start at `1`. If you don't see this result again, make
    sure you ran Postman on the root of our website while using a `GET` call.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 输出消息为`10`，因为我在准备本书时进行了一些测试。ID字段通常将从`1`开始。如果您再次看不到此结果，请确保在使用`GET`调用时在我们网站的根目录上运行Postman。
- en: Sweet! That worked! Now, let's look at our `Users` table to check that the user
    was indeed added:![Figure 14.18 – A new user added to the Users table
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！成功了！现在，让我们查看我们的`Users`表，以确保用户确实已添加：![图14.18-向用户表添加新用户
- en: '](img/Figure_14.18_B15508.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.18_B15508.jpg)'
- en: Figure 14.18 – A new user added to the Users table
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18-向用户表添加新用户
- en: You can run the query shown by right-clicking on the `Users` table in `pgAdmin`
    and selecting `Scripts > SELECT Script`. You can run the script by clicking on
    the play button at the top. But, as you can see, our user was inserted into the
    database.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过右键单击`pgAdmin`中的`Users`表并选择`Scripts > SELECT Script`来运行所示的查询。您可以通过点击顶部的播放按钮来运行脚本。但是，如您所见，我们的用户已插入到数据库中。
- en: 'Now, let''s update `UserRepo` with our `login` function. Add the following
    code to the end of `UserRepo`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用我们的`login`函数更新`UserRepo`。将以下代码添加到`UserRepo`的末尾：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Not much to show here. We try and find a user with the given `userName`. If
    not found, a message is sent back that the `user` is not found, using a function
    called `userNotFound`. I'm using a function because we will reuse this message
    later. It's a simple function, so I won't cover it here (it's in the source code).
    If the user is found, then we first see whether the account was confirmed. If
    not, we provide an error regarding it. Next, we check their password by using
    `bcryptjs`, since we used that tool to encrypt it during registration. If it does
    not match, we also provide an error regarding that. If all goes well and the `user`
    exists, we return the `user`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多要展示的。 我们尝试查找具有给定“userName”的用户。 如果找不到，则返回一条消息，指出未找到“user”，使用名为“userNotFound”的函数。
    我使用函数是因为我们稍后将重用此消息。 这是一个简单的函数，所以我不会在这里介绍它（它在源代码中）。 如果找到用户，那么我们首先看一下帐户是否已确认。 如果没有，我们会提供一个错误。
    接下来，我们通过使用`bcryptjs`来检查他们的密码，因为我们在注册时使用了该工具对其进行加密。 如果不匹配，我们还会提供一个错误。 如果一切顺利，用户存在，我们将返回用户。
- en: 'Let''s try running this as well. Update `index.ts` by adding this new route
    just below the register route:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也尝试运行这个。 通过在注册路线下方添加这个新路线来更新`index.ts`：
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is quite similar to our `register` route. However, here we save the user's
    `id` to the Session State and then send back a message using that session.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的“register”路线非常相似。 但是，在这里，我们将用户的“id”保存到会话状态中，然后使用该会话发送一条消息。
- en: Let's run this route and see what happens. Again, open a new tab in Postman
    and run the settings as shown here. **Remember** to add the **Content-Type** header
    in the **Headers** tab:![Figure 14.19 – Login route
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行这个路线，看看会发生什么。 再次在Postman中打开一个新标签，并按照这里显示的设置运行。 **记住**在**Headers**选项卡中**添加**
    **Content-Type**标头：![图14.19 - 登录路线
- en: '](img/Figure_14.19_B15508.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.19_B15508.jpg)'
- en: Figure 14.19 – Login route
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.19 - 登录路线
- en: Again, this is good to see as our validations are working.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是很好的，因为我们的验证正在起作用。
- en: Go to your `pgAdmin` and open the same screen you used to run the `SELECT` query
    to see our first inserted user. Then, run this SQL to update our user's `confirmed`
    column to be `true`:![Figure 14.20 – Update user's confirmed field
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的`pgAdmin`，打开您用于运行`SELECT`查询以查看我们第一个插入的用户的相同屏幕。 然后，运行此SQL以将我们的用户的“confirmed”列更新为“true”：![图14.20
    - 更新用户的确认字段
- en: '](img/Figure_14.20_B15508.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.20_B15508.jpg)'
- en: Figure 14.20 – Update user's confirmed field
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20 - 更新用户的确认字段
- en: Once you run your query, you should see the same message, as shown in *Figure
    14.20*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行查询后，您应该会看到与*图14.20*中显示的相同消息。
- en: 'Now, let''s run Postman to try and log in again:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行Postman再次尝试登录：
- en: '![Figure 14.21 – Logging in the user'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.21 - 登录用户'
- en: '](img/Figure_14.21_B15508.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.21_B15508.jpg)'
- en: Figure 14.21 – Logging in the user
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21 - 登录用户
- en: Now, our users can log in and, based on the returned message, we can now see
    that our Session State is being used. I've created the `logout` function and route
    in the source code. I won't show it here since it's simple.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用户可以登录，并且根据返回的消息，我们现在可以看到我们正在使用会话状态。 我已在源代码中创建了`logout`函数和路线。 我不会在这里展示它，因为它很简单。
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're attempt to save to the session fails, make sure that your Redis service
    is running.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试保存到会话失败，请确保您的Redis服务正在运行。
- en: 'Awesome! We''ve come a long way. We now have working session-based authentication,
    but we''re not done yet. We need to create ways of inserting `Threads` and `ThreadItems`,
    as well as retrieving them. Let''s start with `Threads`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！ 我们已经走了很长的路。 我们现在拥有基于会话的身份验证，但我们还没有完成。 我们需要创建插入`Threads`和`ThreadItems`以及检索它们的方法。
    让我们从`Threads`开始：
- en: Before we create our new `ThreadRepo` repository, let's build a small helper.
    In `UserRepo`, we had a type called `UserResult` that had an array of messages
    and a user as members. You'll notice that any repo of `Threads`, `ThreadItems`,
    and `Categories` will need a similar construction. It should have an array of
    messages and entities, although the entity returned will be an array of items
    and not just one.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新的“ThreadRepo”存储库之前，让我们构建一个小助手。 在“UserRepo”中，我们有一个名为“UserResult”的类型，其中包含一组消息和一个用户作为成员。
    您会注意到任何“Threads”、“ThreadItems”和“Categories”的存储库都需要类似的构造。 它应该有一组消息和实体，尽管返回的实体将是一组项目，而不仅仅是一个。
- en: This seems like a good place to use TypeScript Generics, so that we can share
    a single result type across all these entities. Let's create a new general-purpose
    result object type called `QueryResult`. We learned about TypeScript Generics
    in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025), *Exploring TypeScript*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是使用TypeScript泛型的好地方，这样我们可以在所有这些实体之间共享单个结果类型。 让我们创建一个名为`QueryResult`的新通用结果对象类型。
    我们在[*第2章*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)中学习了有关TypeScript泛型的知识，*探索TypeScript*。
- en: 'Create a file called `QueryArrayResult.ts` and add this code to it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`QueryArrayResult.ts`的文件，并将以下代码添加到其中：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, it's very similar to the original `UserResult`. However, this
    type uses a generic of type `T` to indicate any of our entities.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与原始的“UserResult”非常相似。 但是，此类型使用类型“T”的通用类型来指示我们的任何实体。
- en: Warning
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The `pg` dependency also has a type called `QueryArrayResult`. When importing
    our dependency, please make sure you import our file, and not `pg`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`pg`依赖项还有一个名为`QueryArrayResult`的类型。 在导入我们的依赖项时，请确保导入我们的文件，而不是`pg`。'
- en: 'Now, let''s use this new `QueryArrayResult` type in our `ThreadRepo`. Create
    a new file, `ThreadRepo.ts`, inside the `repo` folder and add the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`ThreadRepo`中使用这种新的`QueryArrayResult`类型。 在`repo`文件夹中创建一个名为`ThreadRepo.ts`的新文件，并添加以下代码：
- en: '[PRE68]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The parameters shown are needed because every `Thread` must be associated with
    a user and a category. Do note, however, that `userId` is coming from our session.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的参数是必需的，因为每个“线程”必须与用户和类别相关联。 请注意，“userId”是从我们的会话中获取的。
- en: '[PRE69]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here we validate our `title` and `message`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们验证我们的“title”和“message”。
- en: '[PRE70]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we take our session provided `userId` and try and find a matching `user`.
    We need this `user` object later to create our new `Thread`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取我们提供的会话`userId`，并尝试找到匹配的`user`。 我们稍后需要这个`user`对象来创建我们的新`Thread`。
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here we get a `category` object, because again we need to pass it during the
    creation of our new `Thread`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到一个`category`对象，因为我们在创建新的`Thread`时需要传递它。
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see, we pass `title`, `body`, `user`, and `category` in order to
    create our new `Thread`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们传递`title`、`body`、`user`和`category`来创建我们的新`Thread`。
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We are only returning messages as we don't need to return the actual object.
    Also, returning an object that is not required is inefficient in terms of API
    payload size.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只返回消息，因为我们不需要返回实际的对象。此外，返回不需要的对象在API负载大小方面是低效的。
- en: Before we can continue, we need to add some `ThreadCategories` to our database
    so that we can actually use the `createThread` function. Go to the source code
    and find the `utils/InsertThreadCategories.txt` file. Copy and paste these `insert`
    statements into a query screen of `pgAdmin` and run it. This will create the listed
    `ThreadCategories`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要向数据库中添加一些`ThreadCategories`，这样我们才能真正使用`createThread`函数。去源代码中找到`utils/InsertThreadCategories.txt`文件。将这些`insert`语句复制粘贴到`pgAdmin`的查询屏幕中并运行。这将创建列出的`ThreadCategories`。
- en: 'Next, we need to add our route for creating `Threads`. Add the following code
    to `index.ts`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加用于创建`Threads`的路由。将以下代码添加到`index.ts`中：
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this super simple call, we pass parameters to the `createThread` function.
    Again, our `userId` comes from our session, since a user should be logged in in
    order to be allowed to post, and then we simply return the result message.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个超级简单的调用中，我们向`createThread`函数传递参数。同样，我们的`userId`来自我们的会话，因为用户应该登录才能被允许发布，然后我们简单地返回结果消息。
- en: '[PRE75]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Let's try running this route. First, however, run the logout route in Postman.
    You'll find it on the `http://localhost:5000/logout` URL. I'm sure you can set
    up Postman yourself now. Once that is done, let's try and run the `createthread`
    route and hopefully, it should fail validation:![Figure 14.22 – Test createthread
    route
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试运行这个路由。不过，在此之前，先在Postman中运行登出路由。你可以在`http://localhost:5000/logout`URL中找到它。我相信你现在可以自己设置Postman。一旦完成，让我们尝试运行`createthread`路由，希望它应该会失败验证:![图14.22
    – 测试createthread路由
- en: '](img/Figure_14.22_B15508.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.22_B15508.jpg)'
- en: Figure 14.22 – Test createthread route
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22 – 测试createthread路由
- en: Yes, it failed validation as expected.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它如预期般失败了验证。
- en: Now, let's log in again so that our session gets created. Go ahead and do that
    with Postman again, and then run the `createthread` route again. This time, it
    should work with the message, **Thread created successfully**.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次登录，以便我们的会话得到创建。再次使用Postman进行操作，然后再次运行`createthread`路由。这次，它应该会显示消息，**Thread
    created successfully**。
- en: 'OK. Now we need two more functions, one to get a single `Thread` by its ID,
    and another to get all the threads for `ThreadCategory`. Add this code to `ThreadRepo`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的。现在我们需要另外两个函数，一个是根据其ID获取单个`Thread`，另一个是获取`ThreadCategory`的所有线程。将以下代码添加到`ThreadRepo`中：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This `getThreadById` function is pretty simple. It just looks for a single thread
    based on an ID.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`getThreadById`函数非常简单。它只是基于ID查找单个线程。
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This `getThreadsByCategoryId` function is much more interesting. `Thread.createQueryBuilder`
    is a special function in TypeORM that allows us to build more sophisticated queries.
    The function's `thread` parameter is an alias used to represent the Threads table
    in our query. So, if you look at the rest of the query, such as the `where` clause,
    you can see that we use `thread` as a prefix for fields or relationships. The
    `leftJoinAndSelect` function means that we want to do a SQL left join, but also
    we want to return the related entity, in this case, `ThreadCategory`, with the
    result set. `OrderBy` is pretty self-explanatory, and `getMany` just means to
    return all items.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`getThreadsByCategoryId`函数更有趣。`Thread.createQueryBuilder`是TypeORM中的一个特殊函数，允许我们构建更复杂的查询。函数的`thread`参数是一个别名，用于表示查询中的Threads表。因此，如果你看一下查询的其余部分，比如`where`子句，你会发现我们使用`thread`作为字段或关系的前缀。`leftJoinAndSelect`函数意味着我们要进行SQL左连接，但同时也要返回相关的实体，即`ThreadCategory`与结果集一起。`OrderBy`相当直观，`getMany`只是意味着返回所有项目。
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The rest of the code is pretty straightforward. Let''s test `getThreadsByCategoryId`
    as a route. Add this to the `index.ts` file:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的代码非常简单。让我们测试`getThreadsByCategoryId`作为一个路由。将其添加到`index.ts`文件中：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, we have made our call to `getThreadsByCategoryId` using the `categoryId`
    parameter.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`categoryId`参数调用了`getThreadsByCategoryId`。
- en: '[PRE80]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this `if else` code, we either have all titles displayed or the error displayed.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`if else`代码中，我们要么显示所有标题，要么显示错误。
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The rest of the code is as before. Run this in your Postman client and you
    should see this. Again, your ID numbers may vary:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的代码与之前一样。在你的Postman客户端中运行这个，你应该会看到这个。再次提醒，你的ID号码可能会有所不同：
- en: '![Figure 14.23 – Test threadsbycategory route'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.23 – 测试threadsbycategory路由'
- en: '](img/Figure_14.23_B15508.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.23_B15508.jpg)'
- en: Figure 14.23 – Test threadsbycategory route
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.23 – 测试threadsbycategory路由
- en: I'll leave the testing of `getThreadById` up to you, as it's pretty easy. Again,
    the source code is in our project repository.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把`getThreadById`的测试留给你，因为它很容易。同样，源代码在我们的项目存储库中。
- en: The code for `ThreadItems` is almost identical and is in our source code. So,
    I won't review it here. Now, we do need a few more functions for getting things
    such as `ThreadCategories` to populate our React app's `LeftMenu`. We also need
    to retrieve points for our `Threads` and `ThreadItems`. And we also need relevant
    `Thread` data for our `UserProfile` screen. However, those calls will repeat a
    lot of the concepts we learned in this section, and we'll have to create routes
    that we'll ultimately end up deleting once we start our GraphQL server code. Therefore,
    let's leave those for [*Chapter 15*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222),
    *Adding GraphQL Schema – Part I*, where we can also start integrating the backend
    GraphQL code with our React frontend.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadItems`的代码几乎相同，并且在我们的源代码中。所以，我不会在这里进行复习。现在，我们需要一些额外的函数来获取诸如`ThreadCategories`之类的东西，以填充我们的React应用程序的`LeftMenu`。我们还需要检索我们的`Threads`和`ThreadItems`的积分。我们还需要`UserProfile`屏幕的相关`Thread`数据。然而，这些调用将重复我们在本节学到的许多概念，而且我们将不得不创建路由，最终我们将在开始GraphQL服务器代码后删除。因此，让我们把这些留到[*第15章*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222)，*添加GraphQL模式-第一部分*，在那里我们还可以开始将后端GraphQL代码与我们的React前端集成。'
- en: In this section, we learned how to build a repository layer and make queries
    into Postgres using TypeORM. We'll be reusing our query skills once we start integrating
    GraphQL in the next chapter, so this is important knowledge that we'll continue
    to use.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何构建一个存储库层，并使用TypeORM进行Postgres查询。一旦我们开始在下一章中集成GraphQL，我们将会重复使用我们的查询技能，因此这是我们将继续使用的重要知识。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to set up a Postgres database and how to query
    it using an ORM, TypeORM. We also learned how to keep our code cleanly separated
    by using a repository layer.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何设置一个Postgres数据库以及如何使用ORM TypeORM进行查询。我们还学习了如何通过使用存储库层来保持我们的代码清晰分离。
- en: In the next chapter, we'll learn how to enable GraphQL on our server. We'll
    also finish our database queries and integrate our backend into our React frontend.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在我们的服务器上启用GraphQL。我们还将完成我们的数据库查询，并将我们的后端集成到我们的React前端中。
