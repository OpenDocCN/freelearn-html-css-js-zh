- en: '*Chapter 3*: Building Better Apps with ES6+ Features'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用ES6+功能构建更好的应用程序'
- en: In this chapter, we'll review certain important features of JavaScript in its
    latest ES6+ form (I've added the plus sign to indicate ES6 and beyond). It is
    important to understand that although this book uses TypeScript, the two languages
    are complementary. In other words, TypeScript does not replace JavaScript. It
    augments and enhances JavaScript, adding features that make it better. Therefore,
    we'll do a review of some of the most important features in the JavaScript language.
    We'll review variable scoping and the new `const` and `let` keywords. Also, we'll
    dive deeper into the `this` keyword and how we can switch it if needed. We'll
    also learn about the many new features in JavaScript, such as the new array functions
    and `async await`. This knowledge will give us a solid foundation upon which we
    can code in TypeScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾JavaScript在其最新的ES6+形式中的一些重要特性（我添加了加号表示ES6及更高版本）。重要的是要理解，尽管本书使用TypeScript，但这两种语言是互补的。换句话说，TypeScript并不取代JavaScript。它增强和增强了JavaScript，添加了使其更好的功能。因此，我们将回顾JavaScript语言中一些最重要的特性。我们将回顾变量作用域和新的`const`和`let`关键字。此外，我们将深入研究`this`关键字以及在需要时如何切换它。我们还将学习JavaScript中许多新功能，例如新的数组函数和`async
    await`。这些知识将为我们提供一个坚实的基础，使我们能够在TypeScript中编码。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Learning about ES6 variable types and JavaScript scoping
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习ES6变量类型和JavaScript作用域
- en: Learning about arrow functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习箭头函数
- en: Changing the `this` context
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`this`上下文
- en: Learning about spread, de-structuring, and rest
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习有关传播、解构和剩余
- en: Learning about new array functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习新的数组函数
- en: Learning about new collection types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习新的集合类型
- en: Learning about `async await`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习`async await`
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The requirements for this chapter are the same as for [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)*,
    Exploring TypeScript*. You should have a basic understanding of JavaScript and
    web technologies. You will once again be using Node and **Visual Studio Code**
    (**VSCode**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与[*第2章*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)* TypeScript探索*相同。您应该对JavaScript和Web技术有基本的了解。您将再次使用Node和**Visual
    Studio Code**（**VSCode**）。
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap3` folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap3`文件夹中的代码。
- en: 'Let''s set up this chapter''s code folder:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置本章的代码文件夹：
- en: Go to your `HandsOnTypescript` folder and create a new folder called `Chap3`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的`HandsOnTypescript`文件夹并创建一个名为`Chap3`的新文件夹。
- en: Open VSCode and go to `Chap3` folder you just created. Then, select **View**
    | **Terminal** and enable the terminal window within your VSCode window.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VSCode并转到您刚创建的`Chap3`文件夹。然后，选择**View** | **Terminal**并在VSCode窗口内启用终端窗口。
- en: Type the `npm init` command, as in the previous chapter, to initialize the project
    for `npm`, and accept all the defaults (you can also use `npm init -y` to accept
    all defaults automatically).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入`npm init`命令，就像上一章那样，初始化`npm`项目，并接受所有默认值（您也可以使用`npm init -y`自动接受所有默认值）。
- en: Type the `npm install typescript` command, as in the previous chapter, to install
    TypeScript.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入`npm install typescript`命令，就像上一章那样，安装TypeScript。
- en: Now we're ready to get started.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始了。
- en: Learning about ES6 variable types and JavaScript scoping
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习ES6变量类型和JavaScript作用域
- en: In this section, we will learn about JavaScript's scoping rules and some new
    variable types that help to clarify and improve upon some issues regarding these
    scope rules. This information is valuable since you will be creating variables
    constantly throughout your career as a software developer, and it is important
    to understand under what scope a variable can be accessed and under what circumstances
    it may be changed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习JavaScript的作用域规则和一些新的变量类型，这有助于澄清和改进有关这些作用域规则的一些问题。这些信息很有价值，因为作为软件开发人员，您将不断地创建变量，并且了解变量可以在什么范围内访问以及在什么情况下可能会更改是很重要的。
- en: 'In most other languages, variable scoping happens within any arbitrary set
    of brackets or *begin end* scope statements. However, scope in JavaScript is handled
    by the body of a function, which means when a variable is declared inside a function
    body using the `var` keyword, that variable is only accessible within that body.
    Let''s take a look at an example of this. Create a new file called `functionBody.ts`
    and add the following code to it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数其他语言中，变量作用域发生在任意一组括号或*begin end*作用域语句内。然而，在JavaScript中，作用域由函数体处理，这意味着当使用`var`关键字在函数体内声明变量时，该变量只能在该体内访问。让我们看一个例子。创建一个名为`functionBody.ts`的新文件，并将以下代码添加到其中：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In VSCode, you should see an error indication on the call to `console.log(val2)`,
    whereas the call to `console.log(val1)` works just fine. You might have thought
    that since `val1` is declared within the brackets of the `if` statement, it would
    not be accessible later. However, clearly it is. But on the other hand, `val2`
    scoped by the `go` function is not accessible outside of it. This shows that as
    far as variable declaration using `var` is concerned, it is functions that act
    as scoping containers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode中，您应该看到对`console.log(val2)`的调用的错误指示，而对`console.log(val1)`的调用却可以正常工作。您可能会认为，由于`val1`是在`if`语句的括号内声明的，所以稍后将无法访问它。然而，显然它是可以的。但另一方面，由`go`函数作用域的`val2`在外部是不可访问的。这表明就变量声明而言，使用`var`的函数充当作用域容器。
- en: 'This feature is actually the source of much confusion in JavaScript. So, in
    ES6, a new set of variable declaration prefixes have been created: `const` and
    `let`. Let''s review them here.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能实际上是JavaScript中很多混淆的根源。因此，在ES6中，创建了一组新的变量声明前缀：`const`和`let`。让我们在这里回顾一下。
- en: '`const` variables support something called block-level scoping. Block-level
    scoping is scoping between any squiggly brackets. For example, in our previous
    example, that would be the `if` statement. In addition, as the name implies, `const`
    creates a constant variable value that, once set, cannot be reset to something
    else. However, what this means is a little bit different from some other languages.
    In JavaScript, this means that the variable''s assignment cannot be changed. However,
    the variable itself can be edited. This is hard to imagine, so let''s look at
    some examples. Create a new file called `const.ts` and add the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`变量支持一种称为块级作用域的东西。块级作用域是在任何花括号之间的作用域。例如，在我们之前的例子中，那将是`if`语句。此外，顾名思义，`const`创建一个常量变量值，一旦设置，就不能重新设置为其他值。然而，这意味着的内容与其他一些语言有点不同。在JavaScript中，这意味着变量的赋值不能被更改。但是，变量本身可以被编辑。这很难想象，所以让我们看一些例子。创建一个名为`const.ts`的新文件，并添加以下代码：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In VSCode, this code will show an error for `val1 = 2`, but it will be OK for
    `val2.push('hello')`. The reason for this is that in the case of `val1`, the variable
    is actually being reset into an entirely new value, which is not allowed. However,
    for `val2`, the array value remains the same and a new element is being added
    to it. So, this is allowed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode中，这段代码将对`val1 = 2`显示错误，但对于`val2.push('hello')`则没有问题。原因是在`val1`的情况下，变量实际上被重置为一个全新的值，这是不允许的。然而，对于`val2`，数组值保持不变，并且新元素被添加到其中。因此，这是允许的。
- en: 'Now, let''s look at the `let` keyword. `let` variables are, like `const` variables,
    also block-scoped. However, they can be set and reset at will (of course, in TypeScript,
    the type needs to stay the same). Let''s show an example of `let`. Create a file
    called `let.ts` and add the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`let`关键字。`let`变量与`const`变量一样，也是块级作用域的。然而，它们可以随意设置和重置（当然，在TypeScript中，类型需要保持不变）。让我们展示一个`let`的例子。创建一个名为`let.ts`的文件，并添加以下代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, here, we have two sets of `let` variables. `val1` is not scoped in a block,
    but `val2` is scoped in an `if` block. As you can see, only the call to `console.log(val2)`
    is failing, since `val2` only exists inside the `if` block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们有两组`let`变量。`val1`没有在块中作用域，但`val2`在`if`块中作用域。正如你所看到的，只有对`console.log(val2)`的调用失败了，因为`val2`只存在于`if`块内部。
- en: So then, which variable declaration method do you use? The current best practice
    in the community is to prefer using `const`, as immutability is a beneficial attribute
    and also, using constants adds a tiny performance benefit. However, if you know
    that you need to be able to reset the variable later, then use `let` instead.
    Finally, avoid using `var`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你会使用哪种变量声明方法？社区中目前的最佳实践是优先使用`const`，因为不可变性是一个有益的属性，而且使用常量还会带来微小的性能优势。然而，如果你知道需要能够稍后重置变量，那么请使用`let`。最后，避免使用`var`。
- en: We've learned about scoping and the new `const` and `let` variable types in
    ES6\. Understanding scoping and knowing when to use `const` versus `let` is an
    important skill for doing modern JavaScript development. In newer JavaScript code,
    you'll see these keywords often. Next, we'll review the `this` context and arrow
    functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了作用域和ES6中新的`const`和`let`变量类型。理解作用域并知道何时使用`const`和何时使用`let`是进行现代JavaScript开发的重要技能。在较新的JavaScript代码中，你会经常看到这些关键字。接下来，我们将回顾`this`上下文和箭头函数。
- en: Learning about arrow functions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习箭头函数
- en: 'Arrow functions were a new addition to ES6\. Basically, they serve two main
    purposes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是ES6的一个新添加。基本上，它们有两个主要目的：
- en: They shorten the syntax for writing functions.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们缩短了编写函数的语法。
- en: They also automatically make the immediate scope parent, the `this` object,
    the arrow function's parent.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们还会自动使立即作用域父级成为`this`对象，箭头函数的父级。
- en: Let me explain `this` a bit more before continuing as it's critical knowledge
    for JavaScript developers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我更详细地解释一下`this`，因为这对JavaScript开发人员来说是至关重要的知识。
- en: In JavaScript, the `this` object, the owner object instance that member properties
    and methods belong to, can change based on the context of a call. So, when a function
    is called directly—for example, `MyFunction()`—the parent `this` would be the
    caller of the function; that is to say, the current scope's `this` object. For
    browsers, that would usually be the `window` object. However, in JavaScript, functions
    can also be used as object constructors—for example, `new MyFunction()`. In this
    case, the `this` object inside the function would be the object instance that
    was created from the `new MyFunction` constructor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`this`对象，即成员属性和方法所属的所有者对象实例，可以根据调用的上下文而改变。因此，当直接调用函数时，例如`MyFunction()`，父`this`将是函数的调用者；也就是说，当前作用域的`this`对象。对于浏览器来说，通常是`window`对象。然而，在JavaScript中，函数也可以用作对象构造函数，例如`new
    MyFunction()`。在这种情况下，函数内部的`this`对象将是从`new MyFunction`构造函数创建的对象实例。
- en: 'Let''s look at an example to clarify as this is a really important feature
    of JavaScript. Create a new file called `testThis.ts` and add the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来澄清一下，因为这是JavaScript的一个非常重要的特性。创建一个名为`testThis.ts`的新文件，并添加以下代码：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you compile and then run this code, you will see the following result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译然后运行这段代码，你会看到以下结果：
- en: '![Figure 3.1 – testThis result'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 - testThis结果'
- en: '](img/Figure_3.01_B15508.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B15508.jpg)'
- en: Figure 3.1 – testThis result
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - testThis结果
- en: So, when `MyFunction` is called directly, the immediate scope parent is going
    to be Node's global object, since we are not running in a browser. Next, if we
    create a new object from `MyFunction` using `new MyFunction()`, the `this` object
    becomes its own object instance since the function was used to create an object
    as opposed to being run directly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当直接调用`MyFunction`时，立即作用域父级将是Node的全局对象，因为我们不是在浏览器中运行。接下来，如果我们使用`new MyFunction()`从`MyFunction`创建一个新对象，`this`对象将成为它自己的对象实例，因为该函数被用来创建一个对象，而不是直接运行。
- en: 'Now that we have that out of the way, let''s see what an arrow function looks
    like. Create the `arrowFunction.ts` file and add the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了这一点，让我们看看箭头函数是什么样子的。创建`arrowFunction.ts`文件，并添加以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you compile and run this code, you'll see that `hello` is printed out. The
    syntax is very similar to a function type; however, they are not the same. If
    we look at the code, you can see a colon after the parameter parentheses and then
    the void type after the parameter parentheses. This is the return type of the
    function. In the case of function types, the return type is indicated after the
    `=>` symbol.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译并运行此代码，您将看到打印出`hello`。语法与函数类型非常相似；但它们并不相同。如果我们看一下代码，您会看到参数括号后面有一个冒号，然后是参数括号后面的void类型。这是函数的返回类型。在函数类型的情况下，返回类型在`=>`符号之后表示。
- en: Here are some additional things to note about arrow functions. All non-arrow
    functions in JavaScript have access to a collection called `arguments`. This is
    a collection of all the parameters given to the function. Arrow functions do not
    have their own `arguments` collection. However, they do have access to the immediate
    function parent's `arguments` collection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于箭头函数还有一些额外的事情需要注意。JavaScript中的所有非箭头函数都可以访问一个称为`arguments`的集合。这是给定给函数的所有参数的集合。箭头函数没有自己的`arguments`集合。但是，它们可以访问立即函数父级的`arguments`集合。
- en: 'The arrow function has several body styles. Here are examples of the three
    styles:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数有几种主体样式。以下是三种样式的示例：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s look at each of the three styles:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这三种样式：
- en: The first function, `func`, shows the case where only a single line of code
    is used in the function body, and nothing is returned, as you can see that the
    body has no closing braces or parentheses.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数`func`显示了函数体中只使用了一行代码，没有返回任何内容，您可以看到函数体没有闭合括号或括号。
- en: The second function, `func1`, shows when there is only a single line, but something
    is returned. In this case, the `return` keyword is not needed, and parentheses
    are needed only if an object is returned.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个函数`func1`显示了只有一行，但返回了一些内容的情况。在这种情况下，不需要`return`关键字，只有在返回对象时才需要括号。
- en: The final case is `func2`. In this case, squiggly brackets are needed because
    it is a multi-line statement (regardless of whether it returns or not).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个案例是`func2`。在这种情况下，需要花括号，因为这是一个多行语句（无论是否返回）。
- en: We covered arrow functions in this section. Arrow functions are used a great
    deal in modern JavaScript and TypeScript code, so it's beneficial to know about
    this feature in depth.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中介绍了箭头函数。箭头函数在现代JavaScript和TypeScript代码中被广泛使用，因此深入了解这个特性是有益的。
- en: Changing the this context
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改this上下文
- en: 'We already discussed the `this` context object in the previous section. As
    mentioned, in JavaScript, functions have access to an internal object called `this`
    that represents the caller of the function. Now, the confusing part of using `this`
    is that the value of `this` can change depending on how the function is called.
    So, JavaScript provides helpers that allow you to reset the `this` object of a
    function to the one you want, instead of the one given to you. There are several
    methods, including `apply` and `call`, but the most important one for us to learn
    is the `bind` keyword. This is important for us to know because `bind` is used
    often in React class-based components. It''s a bit early to show a full-blown
    React example. So, let''s start with something a little easier. Create a new file
    called `bind.ts` and add the following code to it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前一节讨论了`this`上下文对象。如前所述，在JavaScript中，函数可以访问一个称为`this`的内部对象，该对象表示函数的调用者。现在，使用`this`的令人困惑的部分是，`this`的值可能会根据函数的调用方式而改变。因此，JavaScript提供了一些帮助器，允许您将函数的`this`对象重置为您想要的对象，而不是给定的对象。有几种方法，包括`apply`和`call`，但我们要学习的最重要的是`bind`关键字。这对我们很重要，因为在React基于类的组件中经常使用`bind`。现在展示一个完整的React示例还为时过早。所以，让我们从一些更简单的东西开始。创建一个名为`bind.ts`的新文件，并将以下代码添加到其中：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see from this code, there are two distinct classes: `A` and `B`.
    Both of these classes have a `go` function that writes the specific class name
    to the log. Now, when we reset the `this` object''s `bind` of our `b` object''s
    `go` function to be the `a` object, it switches the `console.log(this.name)` statement
    to use `a` as the `this` object. So, if we compile and run, we get this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看出，有两个不同的类：`A`和`B`。这两个类都有一个`go`函数，将特定的类名写入日志。现在，当我们将`b`对象的`go`函数的`this`对象的`bind`重置为`a`对象时，它会将`console.log(this.name)`语句切换为使用`a`作为`this`对象。因此，如果我们编译并运行，我们会得到这个：
- en: '![Figure 3.2 – bind'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - bind'
- en: '](img/Figure_3.02_B15508.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B15508.jpg)'
- en: Figure 3.2 – bind
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - bind
- en: As you can see, `a.go()` writes `A` but `b.go()` also writes `A`, instead of
    `B`, since we switched `this` to be `a` instead of `b`. Note that also, in addition
    to taking the `this` argument, `bind` can also take any number of parameters thereafter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`a.go()`写入了`A`，但`b.go()`也写入了`A`，而不是`B`，因为我们将`this`切换为`a`而不是`b`。请注意，除了接受`this`参数外，`bind`还可以在此后接受任意数量的参数。
- en: 'You may be wondering what the difference between using `bind`, `call`, and
    `apply` is. `bind` is used to make the `this` context change and later, when the
    function is called, it will have the changed `this` object. However, `call` and
    `apply` are used at the time the function is called and immediately replace the
    `this` context at the time of calling. The difference between `call` and `apply`
    is that `call` takes an indeterminate number of parameters and `apply` takes an
    array of parameters. Let''s look at some examples. Create a file called `call.js`
    and add the following code to it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道使用`bind`、`call`和`apply`之间的区别是什么。`bind`用于更改`this`上下文，稍后在调用函数时，它将具有更改后的`this`对象。但是，`call`和`apply`是在调用函数时立即替换调用时的`this`上下文。`call`和`apply`之间的区别在于，`call`接受不确定数量的参数，而`apply`接受参数数组。让我们看一些示例。创建一个名为`call.js`的文件，并将以下代码添加到其中：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we are creating a new object called `callerObj` that has a field called
    `name`, which is `jon`. After that, we declare a `checkMyThis` function, which
    tests what `this` is currently and whether it has a name. Finally, we run both
    calls. Note that the second call looks weird but `checkMyThis.call` is an actual
    execution of the `checkMyThis` function. If we run this code, we will see something
    interesting. Run the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`callerObj`的新对象，它有一个名为`name`的字段，即`jon`。之后，我们声明一个`checkMyThis`函数，测试当前的`this`是什么，以及它是否有一个名字。最后，我们运行两个调用。请注意，第二个调用看起来很奇怪，但`checkMyThis.call`实际上是对`checkMyThis`函数的执行。如果我们运行这段代码，我们会看到一些有趣的东西。运行以下命令：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see the following result:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下结果：
- en: '![Figure 3.3 – node call'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – node call'
- en: '](img/Figure_3.03_B15508.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B15508.jpg)'
- en: Figure 3.3 – node call
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – node call
- en: The first execution of the `checkMyThis` function uses the global object by
    default, since it was not overridden. Again, for Node, it's Node's global object,
    but for browsers, it's the `window` object. We also see that the `name` and `age`
    fields are undefined, since Node's global object does not have the `name` field
    and the age was not passed as a parameter to `checkMyThis`. However, on the second
    execution of the function, the one that uses `call`, we see that the object has
    changed to a standard object type and it has a name of `jon`, which is the `name`
    field for `callerObj`, and an `age` field equal to `25`, which is the parameter
    we passed into `call`. You should note the order of the parameters list for `call`
    follows the order of the parameters list of the function being called. The usage
    of `apply` would be identical; however, it takes parameters as an array.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkMyThis`函数的第一次执行默认使用全局对象，因为它没有被覆盖。对于Node来说，是Node的全局对象，但对于浏览器来说，是`window`对象。我们还看到`name`和`age`字段是未定义的，因为Node的全局对象没有`name`字段，而age没有作为参数传递给`checkMyThis`。然而，在函数的第二次执行中，使用`call`，我们看到对象已经改变为标准对象类型，它有一个名为`jon`的`name`字段，这是`callerObj`的`name`字段，以及一个等于`25`的`age`字段，这是我们传递给`call`的参数。您应该注意`call`的参数列表的顺序遵循被调用函数的参数列表的顺序。`apply`的用法是相同的；但是，它将参数作为数组。'
- en: In this section, we learned about the difficulties of working with the `this`
    context and how to deal with this using `bind`. We will use `bind` extensively
    later once we start creating React components. But even beyond that specific use
    case, you will find that your code will sometimes need the ability to change the
    `this` context and possibly some parameters for your functions. So, this ability
    is a very useful feature to have.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了处理`this`上下文的困难以及如何使用`bind`来处理这个问题。一旦我们开始创建React组件，我们将广泛使用`bind`。但即使超出了特定的用例，您会发现您的代码有时需要能够更改`this`上下文，可能还需要一些函数的参数。因此，这种能力是一个非常有用的功能。
- en: Learning about spread, destructuring, and rest
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习spread、解构和rest
- en: In ES6+, there are new methods for handling object copying and displaying variables
    and parameters. These capabilities go a long way in making JavaScript code both
    shorter and easier to read. These features have become standard practice in modern
    JavaScript, so it is important that we know about them and use them properly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6+中，有新的方法来处理对象的复制和显示变量和参数。这些功能在使JavaScript代码更短、更易读方面发挥了重要作用。这些特性已经成为现代JavaScript的标准实践，因此我们需要了解它们并正确使用它们。
- en: Spread, Object.assign, and Array.concat
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spread、Object.assign和Array.concat
- en: The `Object.assign`, and `Array.concat` JavaScript features are fairly similar.
    Basically, you are appending multiple objects or arrays together into one object
    or array. However, strictly speaking, there are some differences.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`和`Array.concat` JavaScript功能非常相似。基本上，您将多个对象或数组追加到一个对象或数组中。但严格来说，有一些区别。'
- en: 'In the case of objects, there are two ways of merging or concatenating objects:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象的情况下，有两种合并或连接对象的方法：
- en: 'Spread—for example, `{ … obja, …objb }`: You are creating a non-modified copy
    of these two objects and then creating a brand-new object. Note that spread can
    handle more than just two objects.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Spread—例如，`{ … obja, …objb }`: 您正在创建这两个对象的非修改副本，然后创建一个全新的对象。请注意，spread可以处理不止两个对象。'
- en: '`Object.assign`—`(obja, objb)`: You are adding the properties from `objb` into
    `obja` and returning `obja`. Therefore, `obja` is being modified. Here''s an example.
    Create a new file called `spreadObj.ts` and add the following code:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.assign`—`(obja, objb)`: 将`objb`的属性添加到`obja`中并返回`obja`。因此，`obja`被修改。以下是一个示例。创建一个名为`spreadObj.ts`的新文件，并添加以下代码：'
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: tsc spreadObj –target 'es6'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: tsc spreadObj –target 'es6'
- en: node spreadObj
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: node spreadObj
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Figure 3.4 – spreadObj'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – spreadObj'
- en: '](img/Figure_3.04_B15508.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.04_B15508.jpg)'
- en: Figure 3.4 – spreadObj
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – spreadObj
- en: As you can see, `c` has both `aname` and `bname` properties but is a unique
    object unto itself. However, `d` is actually object `a` with the properties of
    object `b`, which is demonstrated by the `aname` variable being equal to `a1`
    after `a.aname = 'a1'` was set.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`c`既有`aname`和`bname`属性，但它是一个独特的对象。然而，`d`实际上是对象`a`具有对象`b`的属性，这由`a.aname
    = 'a1'`设置后`aname`变量等于`a1`来证明。
- en: 'Now, for merging or concatenating arrays, you also have two methods:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于合并或连接数组，您还有两种方法：
- en: 'The spread operator: Like spread for objects, it merges the arrays and returns
    a single new array. Original arrays are not modified.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开运算符：与对象的展开类似，它合并数组并返回一个新的单一数组。原始数组不会被修改。
- en: '`Array.concat`: Creates a new array by merging the two source arrays into a
    single array. Original arrays are not modified.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.concat`：通过将两个源数组合并成一个新数组来创建一个新数组。原始数组不会被修改。'
- en: 'Let''s take a look at an example using both methods. Create a file called `spreadArray.ts`
    and add the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用这两种方法的示例。创建一个名为`spreadArray.ts`的文件，并添加以下代码：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, array `c` is created using spread from two arrays: `a` and
    `b`. Then, array `d` is created using `a.concat(b)`. In this case, both resulting
    arrays are unique and do not refer to any of the original arrays. Let''s compile
    and run this code as we did before and see what we get:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，数组`c`是使用spread从两个数组`a`和`b`创建的。然后，数组`d`是使用`a.concat(b)`创建的。在这种情况下，两个结果数组都是唯一的，不引用任何原始数组。让我们像之前一样编译和运行这段代码，看看我们得到了什么：
- en: '![Figure 3.5 – spreadArray'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – spreadArray'
- en: '](img/Figure_3.05_B15508.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B15508.jpg)'
- en: Figure 3.5 – spreadArray
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – spreadArray
- en: You will see that `a.push(10)` has no effect on the `console.log('d after',
    d)` statement even though array `d` was created from array `a`. This shows that
    both spread and `concat` for arrays create new arrays.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现`a.push(10)`对`console.log('d after', d)`语句没有影响，即使数组`d`是从数组`a`创建的。这表明数组的spread和`concat`都会创建新的数组。
- en: Destructuring
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解构
- en: '**Destructuring** is the ability to display and directly use the internal properties
    of an object instead of relying on the object name alone. I''ll explain this later
    with an example, but please be aware that this is a very frequently used feature
    in modern JavaScript development, especially in React hooks, so we need to be
    comfortable with it.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**解构**是显示和直接使用对象内部属性的能力，而不仅仅依赖于对象名称。我稍后会用一个例子来解释这一点，但请注意，这是现代JavaScript开发中非常常用的功能，特别是在React
    hooks中，所以我们需要熟悉它。'
- en: 'Let''s look at an example of object destructuring. For this example, let''s
    just use a JavaScript file, as the example will be clearer that way. Create a
    new file called `destructuring.js` and add the following code to it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个对象解构的例子。对于这个例子，让我们只使用一个JavaScript文件，这样例子会更清晰。创建一个名为`destructuring.js`的新文件，并将以下代码添加到其中：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's pretend for a moment that the `getEmployee` function goes to a server
    and retrieves the information of an employee by `id`. Now, as you can see, the
    `employee` object has lots of fields and perhaps not every caller of the function
    will need every field. So, we use object destructuring to select only the fields
    we care about. Note, in addition, that we also give the field name an alias of
    `fullName` by using the colon.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一下`getEmployee`函数去服务器并通过`id`检索员工的信息。现在，正如您所看到的，`employee`对象有很多字段，也许并不是每个调用该函数的人都需要每个字段。因此，我们使用对象解构来选择我们关心的字段。此外，请注意，我们还使用冒号给字段名称取了一个别名`fullName`。
- en: 'Destructuring is also possible for arrays. Let''s add the following code to
    this file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以进行解构。让我们将以下代码添加到这个文件中：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the case of this example, the `getEmployeeWorkInfo` function returns an
    array of facts about the employee''s work location; but it returns it as an array.
    So, we can also destructure an array as well, but note that the order of the elements
    does matter at destructure time. Let''s look at the results for both functions.
    Note that we only need to call Node since this is a JavaScript file. Run the following
    command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`getEmployeeWorkInfo`函数返回一个关于员工工作位置的事实数组；但它以数组的形式返回。因此，我们也可以对数组进行解构，但请注意，在解构时元素的顺序是很重要的。让我们看看这两个函数的结果。请注意，由于这是一个JavaScript文件，我们只需要调用Node。运行以下命令：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will see the following results for both functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到这两个函数的以下结果：
- en: '![Figure 3.6 – Destructuring'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 解构'
- en: '](img/Figure_3.06_B15508.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B15508.jpg)'
- en: Figure 3.6 – Destructuring
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 解构
- en: As you can see, both functions have returned the correct relative data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这两个函数都返回了正确的相关数据。
- en: Rest
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 休息
- en: '`…` keyword. Any rest parameters are arrays and therefore have access to all
    array functions. The rest keyword refers to "the rest of the items" and not "pause"
    or ''''stop." This keyword allows more flexibility when creating your function
    signature, as it allows the caller to determine how many parameters they want
    to pass. Please note that only the last parameter can be a rest parameter. Here''s
    an example of using rest. Create a file called `rest.js` and add the following
    code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`关键字。任何rest参数都是数组，因此可以访问所有数组函数。rest关键字指的是"其余的项目"，而不是"暂停"或"停止"。这个关键字在创建函数签名时提供了更多的灵活性，因为它允许调用者确定他们想要传递多少参数。请注意，只有最后一个参数可以是rest参数。以下是使用rest的一个例子。创建一个名为`rest.js`的文件，并添加以下代码：'
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, `…others` refers to the rest of the parameters after `a`. This
    indicates that rest parameters do not have to be the only parameters for a function.
    So, if you run this code, you get the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`…others`指的是`a`之后的其余参数。这表明rest参数不必是函数的唯一参数。因此，如果您运行此代码，您会得到以下结果：
- en: '![Figure 3.7 – Rest'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – Rest'
- en: '](img/Figure_3.07_B15508.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07_B15508.jpg)'
- en: Figure 3.7 – Rest
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – Rest
- en: 'The `doSomething` function receives two parameters: the `a` variable and the
    `a` parameter, the rest parameter (which again is an array of parameters), and
    the last element of the rest parameter are written. Rest is not as frequently
    used as spread and destructuring. Nevertheless, you will see it, so you should
    be aware of it.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`doSomething`函数接收两个参数：`a`变量和`a`参数，rest参数（再次是参数数组），以及rest参数的最后一个元素。Rest并不像spread和解构那样经常使用。尽管如此，您会看到它，所以您应该意识到它。'
- en: In this section, we learned about JavaScript features that make code shorter
    and easier to read. The usage of these features is very common in modern JavaScript
    programming, so you'll benefit greatly from learning how to use these capabilities.
    In the next section, we'll learn about some very important array manipulation
    techniques that streamline dealing with arrays and are also very popularly used.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了使代码更简洁和易读的JavaScript特性。这些特性在现代JavaScript编程中非常常见，因此学会使用这些功能将使您受益匪浅。在下一节中，我们将学习一些非常重要的数组操作技术，这些技术可以简化处理数组，并且也非常常用。
- en: Learning about new array functions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习新的数组函数
- en: In this section, we will review the many methods added for manipulating arrays
    in ES6\. It is a very important section as you will have to deal with arrays frequently
    in JavaScript programming, and using these performance-optimized methods is preferable
    over creating your own. The use of these standard methods also makes code more
    consistent and readable by other developers on your team. We will take advantage
    of these methods extensively in both our React and Node development. Let's get
    started.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾ES6中用于操作数组的许多方法。这是一个非常重要的部分，因为你将经常在JavaScript编程中处理数组，并且使用这些性能优化的方法比创建自己的方法更可取。使用这些标准方法还可以使代码更一致和易读，其他开发人员在你的团队上也会更容易理解。我们将在React和Node开发中广泛利用这些方法。让我们开始吧。
- en: find
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: find
- en: 'The `find` keyword allows you to grab the first instance of an element from
    an array that matches your search criteria. Let''s look at a simple example. Create
    `find.ts` and add the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`关键字允许你从数组中抓取与搜索条件匹配的第一个元素。让我们看一个简单的例子。创建`find.ts`并添加以下代码：'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you look at the code for `find`, you can see that it takes a function as
    the parameter and the function is looking for an item with the name of `jon`.
    The function does a truth check to see whether the item''s name is equal to `jon`.
    If the item truth check is true, `find` will return that item. However, you can
    also see that there are two `jon` items in the array. Let''s compile and run this
    code and see which one returns. Run the following commands:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下`find`的代码，你会发现它接受一个函数作为参数，这个函数是在寻找名为`jon`的项目。该函数进行真值检查，以判断项目的名称是否等于`jon`。如果项目的真值检查为真，`find`将返回该项目。然而，你也可以看到数组中有两个`jon`项目。让我们编译并运行这段代码，看看哪一个会返回。运行以下命令：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After compiling and running the preceding commands, you should see the following
    result:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行上述命令后，你应该会看到以下结果：
- en: '![Figure 3.8 – find'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.8 – find'
- en: '](img/Figure_3.08_B15508.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.08_B15508.jpg)'
- en: Figure 3.8 – find
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.8 – find
- en: You can see in the output that the first `jon` item found is returned. This
    is how `find` works; it always gives back only one item—the first one found in
    the array.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在输出中看到第一个找到的`jon`项目被返回。这就是`find`的工作方式；它总是只返回一个项目——数组中找到的第一个项目。
- en: filter
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filter
- en: '`filter` is similar to `find` except it returns all items that match a search
    criterion. Let''s create a new file called `filter.ts` and add the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`与`find`类似，只是它返回所有匹配搜索条件的项目。让我们创建一个名为`filter.ts`的新文件，并添加以下代码：'
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the `filter` function can also take an optional second parameter
    for the index number of the item in the array. But moving on, internally, it looks
    identical to how `find` works in that there is a truth check to see whether a
    certain match is found. However, for `filter`, all matches get returned, as shown
    here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`filter`函数也可以接受数组中项目的索引号作为可选的第二个参数。但是，内部实现上，它看起来与`find`的工作方式相同，都是通过真值检查来判断是否找到了某个匹配项。然而，对于`filter`来说，所有匹配项都会被返回，如下所示：
- en: '![Figure 3.9 – filter'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.9 – filter'
- en: '](img/Figure_3.09_B15508.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.09_B15508.jpg)'
- en: Figure 3.9 – filter
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.9 – filter
- en: As you can see, for `filter`, all items that meet the filter criteria are returned,
    which in this sample case is both `jon` items.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于`filter`来说，所有满足过滤条件的项目都会被返回，这在这个示例中是两个`jon`项目。
- en: map
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map
- en: 'The `map` function is one of the more important array functions to know about
    for ES6 style coding. It appears frequently in React component creation in order
    to create a collection of component elements from an array of data. Note that
    the `map` function is different from the `Map` collection, which we''ll cover
    later in this chapter. Create a new file called `map.ts` and add the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数是ES6风格编码中需要了解的更重要的数组函数之一。它经常出现在React组件创建中，以便从数据数组中创建一组组件元素。请注意，`map`函数与`Map`集合不同，我们将在本章后面介绍。创建一个名为`map.ts`的新文件，并添加以下代码：'
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the `map` function has two parameters, `item` and `index` (you
    can call them whatever you like, but the order matters), and it maps custom return
    values to each array element. To be clear, `return` means to return each item
    back into a new array. It does not mean to return and stop running the iteration.
    If we run the code, it results in the following DOM string:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`map`函数有两个参数，`item`和`index`（你可以随意命名，但顺序很重要），它将自定义的返回值映射到每个数组元素。要清楚，`return`意味着将每个项目返回到一个新数组中。它并不意味着返回并停止运行迭代。如果我们运行代码，结果将是以下DOM字符串：
- en: '![Figure 3.10 – map'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.10 – map'
- en: '](img/Figure_3.10_B15508.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B15508.jpg)'
- en: Figure 3.10 – map
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.10 – map
- en: This function may in fact be the most common ES6 array function, so it is very
    important that you understand how it works. Try modifying the code and practice
    using it with different array item types.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数实际上可能是最常见的ES6数组函数，所以你非常重要要理解它是如何工作的。尝试修改代码并练习使用它与不同的数组项目类型。
- en: reduce
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: reduce
- en: 'The `reduce` function is an aggregator that takes each element in an array
    and, based on custom logic, creates a single final value. Let''s look at an example.
    Create a `reduce.js` file—again, we''ll use a JavaScript file to remove some noise
    from the TypeScript compiler and focus—and add the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数是一个聚合器，它接受数组中的每个元素，并根据自定义逻辑创建一个最终值。让我们看一个例子。创建一个`reduce.js`文件——同样，我们将使用JavaScript文件来减少TypeScript编译器的一些噪音，并专注于代码——并添加以下代码：'
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, let''s imagine we need to calculate the total tonnage capacity
    a trucking company can carry with all its trucks. So then, `allTrucks` lists out
    the tonnage of each of its trucks. Then, we use `allTrucks.reduce` to get the
    total capacity of all trucks. The `initialCapacity` variable is used only to have
    some starting point, which is currently set at `0`. Then, when we log out the
    final value, we see the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们想象一下我们需要计算一家卡车公司所有卡车的总吨位容量。然后，`allTrucks`列出了它所有卡车的吨位。然后，我们使用`allTrucks.reduce`来获得所有卡车的总容量。`initialCapacity`变量仅用于有一个起始点，目前设置为`0`。然后，当我们记录最终值时，我们会看到以下结果：
- en: '![Figure 3.11 – reduce'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 - reduce'
- en: '](img/Figure_3.11_B15508.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B15508.jpg)'
- en: Figure 3.11 – reduce
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 - reduce
- en: The total capacity of all the trucks is `24` since the sum of each truck's capacity
    is 24\. Notice the logic of the reducer can be anything; it does not have to be
    a sum. It could be a subtraction or any other logic that you may need. The core
    point is that at the end, you will have only a single value or object result.
    This is why it is called `reduce`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有卡车的总容量是`24`，因为每辆卡车的容量之和为24。请注意，reducer的逻辑可以是任何内容；它不一定要是求和。它可以是减法或者您可能需要的任何其他逻辑。核心点在于最终，您将只有一个单一的值或对象结果。这就是为什么它被称为`reduce`。
- en: some and every
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: some和every
- en: 'These functions are designed to test for certain criteria. So, they only return
    `true` or `false`. `some` tests to see whether *any* element in an array meets
    certain criteria and `every` tests whether *all* elements meet a certain criteria.
    Let''s take a look at both. Create a file called `someEvery.js` and add the following
    code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数旨在测试特定的条件。因此，它们只返回`true`或`false`。`some`用于检查数组中是否有*任何*元素满足特定条件，而`every`用于检查*所有*元素是否满足特定条件。让我们来看看两者。创建一个名为`someEvery.js`的文件，并添加以下代码：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The code is pretty straightforward and both conditions of `some` and `every`
    are tested. If you run this code, you''ll see the following result:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单，`some`和`every`的两个条件都被测试了。如果你运行这段代码，你会看到以下结果：
- en: '![Figure 3.12 – someEvery'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 - someEvery'
- en: '](img/Figure_3.12_B15508.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B15508.jpg)'
- en: Figure 3.12 – someEvery
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 - someEvery
- en: As you can see, the results are valid for each test.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果对每个测试都是有效的。
- en: In this section, we learned about the many new functions added to ES6 that help
    us deal with and use arrays in JavaScript more efficiently. You will definitely
    be using many of these functions in your own code later when we build our app.
    Next, we'll learn about some new collection types that can be used instead of
    arrays.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了ES6中添加的许多新函数，这些函数可以帮助我们更有效地处理和使用JavaScript中的数组。在构建应用程序时，您肯定会在自己的代码中使用许多这些函数。接下来，我们将学习一些可以用来替代数组的新集合类型。
- en: Learning about new collection types
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习新的集合类型
- en: ES6 has two new collection types, `Set` and `Map`, which can be useful for certain
    specific scenarios. In this section, we will learn about these two types and how
    to write code for them so that we can use them later when we start building our
    app.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ES6有两种新的集合类型，`Set`和`Map`，它们对于特定的场景可能会很有用。在本节中，我们将学习这两种类型以及如何为它们编写代码，以便在我们开始构建应用程序时稍后使用它们。
- en: Set
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Set
- en: '`Set` is a collection of unique values or objects. This is a good function
    to use when you simply want to see whether an item is contained in a large complex
    list. Let''s see an example. Create a new file called `set.js` and add the following
    code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`是一组唯一值或对象。当您只想查看一个项目是否包含在一个大型复杂列表中时，这是一个很好的函数。让我们看一个例子。创建一个名为`set.js`的新文件，并添加以下代码：'
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are many members for the `Set` object, but these are some of its most
    important features. As you can see, `Set` has a constructor that can take an array,
    which makes that array a unique set.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`对象有许多成员，但这些是它最重要的一些特性。正如您所看到的，`Set`有一个构造函数，可以接受一个数组，使该数组成为一个唯一集合。'
- en: Important Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In regard to sets, `size` is used to check quantity not length.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于集合，`size`用于检查数量而不是长度。
- en: 'At the bottom, notice how iterating `Set` is different from the normal way
    of using array indexes. Running this file will result in the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，请注意迭代`Set`与正常使用数组索引的方式不同。运行此文件将产生以下结果：
- en: '![Figure 3.13 – Set'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 - Set'
- en: '](img/Figure_3.13_B15508.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B15508.jpg)'
- en: Figure 3.13 – Set
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 - Set
- en: Conceptually, it is still quite similar to an array but is optimized for unique
    collections.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，它仍然与数组非常相似，但是针对唯一集合进行了优化。
- en: Map
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map
- en: '`Map` is a collection of key-value pairs. In other words, it''s a dictionary.
    Every member of `Map` has a unique key. Let''s create a sample `Map` object. Create
    a new file called `mapCollection.js` and add the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`是键值对的集合。换句话说，它是一个字典。`Map`的每个成员都有一个唯一的键。让我们创建一个示例`Map`对象。创建一个名为`mapCollection.js`的新文件，并添加以下代码：'
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, some of the calls are quite similar to `Set`. One difference,
    however, is the iteration loop at the bottom, which uses an array to indicate
    the key and value. Running this file results in the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一些调用与`Set`非常相似。然而，一个不同之处在于底部的迭代循环，它使用数组来指示键和值。运行此文件将产生以下输出：
- en: '![Figure 3.14 – mapCollection'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 - mapCollection'
- en: '](img/Figure_3.14_B15508.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B15508.jpg)'
- en: Figure 3.14 – mapCollection
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 - mapCollection
- en: It's pretty straightforward. First, a list of all `Map` objects is logged. Then,
    we get the `jim` item by using its key value with `get`. Next is `size`, and then
    finally an iteration over all elements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。首先，记录了所有`Map`对象的列表。然后，我们使用`get`通过其键值获取了`jim`项。接下来是`size`，最后是对所有元素的迭代。
- en: This section showed the two new collection types in ES6\. These types are not
    used that frequently but can come in handy should you have the needs that these
    collections address. In the next section, we'll discuss `async await`, which is
    an ES7 feature. `async await` has seen very rapid adoption by the JavaScript developer
    community because it makes difficult-to-read asynchronous code much more readable
    and makes it appear as if it is synchronous.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了ES6中的两种新集合类型。这些类型并不经常使用，但如果您有这些集合所需的需求，它们可能会派上用场。在下一节中，我们将讨论`async await`，这是一个ES7功能。`async
    await`已经被JavaScript开发者社区广泛采用，因为它使难以阅读的异步代码变得更加可读，并使其看起来像是同步的。
- en: Learning about async await
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于`async await`
- en: Before explaining `async` and `await`, let's explain what asynchronous code
    is. In most languages, code is usually synchronous, which means that statements
    run one after another. If you have statements `A`, `B`, and `C`, statement `B`
    cannot run until statement `A` is completed and statement `C` cannot run until
    statement `B` is completed. However, in asynchronous programming, if statement
    `A` is asynchronous, it will start but then immediately after that, statement
    `B` will start. So then, statement `B` never waits for `A` to complete before
    it runs. This is great for performance but makes code harder to read and fix.
    `async` `await` in JavaScript attempts to address some of these difficulties.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释`async`和`await`之前，让我们解释一下什么是异步代码。在大多数语言中，代码通常是同步的，这意味着语句一个接一个地运行。如果有语句`A`，`B`和`C`，语句`B`在语句`A`完成之前无法运行，语句`C`在语句`B`完成之前无法运行。然而，在异步编程中，如果语句`A`是异步的，它将开始，但紧接着，语句`B`将立即开始。因此，语句`B`在运行之前不会等待`A`完成。这对性能来说很好，但使代码更难阅读和修复。JavaScript中的`async`
    `await`试图解决其中一些困难。
- en: 'So, asynchronous programming provides faster performance because statements
    can run simultaneously without having to wait for each other. However, in order
    to understand asynchronous programming, we need to first understand callbacks.
    Callbacks are a core feature of Node.js programming since its inception, so it
    is important to understand. Let''s look at an example of callbacks. Create a new
    file called `callback.js` and enter the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，异步编程提供了更快的性能，因为语句可以同时运行，而无需等待彼此。然而，为了理解异步编程，我们首先需要理解回调。回调是Node.js编程自诞生以来的核心特性，因此理解它是很重要的。让我们看一个回调的例子。创建一个名为`callback.js`的新文件，并输入以下代码：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we look at this code, we can see that the `letMeKnowWhenComplete` function
    has two parameters. The first one indicates the size of an iteration to do a math
    calculation and the second one is the actual callback. As you can see from the
    code, `callback` is a function that is executed once the math work is complete,
    hence the name. To be precise, technically a callback is not actually asynchronous.
    However, it does provide capabilities that are effectively the same in that secondary
    work, the callback, is done exactly once the primary is complete without needing
    to wait or poll. So now, let's look at JavaScript's first method for doing asynchronous
    completion.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下这段代码，我们可以看到`letMeKnowWhenComplete`函数有两个参数。第一个参数表示要进行数学计算的迭代的大小，第二个参数是实际的回调。从代码中可以看出，`callback`是一个在数学工作完成后执行的函数，因此得名。准确地说，技术上回调实际上并不是异步的。然而，它提供了实际上相同的能力，即次要工作，即回调，在主要工作完成后立即完成，而无需等待或轮询。现在，让我们看一下JavaScript的第一种异步完成方法。
- en: 'The first capability JavaScript received to do asynchronous execution was with
    the `setTimeout` and `setInterval` functions. These functions are simple; they
    take a callback that is executed once a certain specified time completes. In the
    case of `setInterval`, the only difference is that it repeats. The reason why
    these functions are truly asynchronous is that when a timer runs, it runs outside
    of the current `setTimer.js` and enter the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript获得的第一个执行异步的能力是使用`setTimeout`和`setInterval`函数。这些函数很简单；它们接受一个回调，一旦指定的时间完成，就会执行。在`setInterval`的情况下，唯一的区别是它会重复。这些函数之所以真正是异步的原因是，当计时器运行时，它在当前的`setTimer.js`之外运行，并输入以下代码：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s review this code. I''ve added comments to separate out the main sections.
    First, under comment 1, we have a log message indicating that this code is starting.
    Then, under comment 2, we have `setTimeout`, which will execute our arrow function
    callback after waiting 3 seconds. When the callback runs, it will log that it
    finished. After `setTimeout`, we see another log message, under comment 3, asking
    whether the timer has finished yet. Now, when you run this code, a strange thing
    will happen, as shown in the following figure:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这段代码。我已经添加了注释来分隔主要部分。首先，在注释1下，我们有一个日志消息，指示这段代码正在开始。然后，在注释2下，我们有`setTimeout`，它将在等待3秒后执行我们的箭头函数回调。当回调运行时，它将记录它已经完成。在`setTimeout`之后，我们看到另一个日志消息，在注释3下，询问计时器是否已经完成。现在，当您运行这段代码时，将会发生一件奇怪的事情，如下图所示：
- en: '![Figure 3.15 – setTimer'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 - setTimer'
- en: '](img/Figure_3.15_B15508.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B15508.jpg)'
- en: Figure 3.15 – setTimer
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 - setTimer
- en: The last log message asking `Did I finish yet?` will run first, and then the
    log for `I waited and am done now`.' will complete. Why is that? `SetTimeout`
    is an asynchronous function, so when it executes, it allows whatever code was
    written after it to execute immediately (even though `setTimeout` is not done
    yet). That means in this case, the log in comment 3 actually runs before the callback
    in comment 2\. So then, if we imagine that comment 3 had some important code that
    needed to run right away, without waiting for comment 2, we can see how using
    an asynchronous call would be helpful for performance. Now, let's combine our
    understanding of callbacks and asynchronous calls and take a look at Promises.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个日志消息询问“我完成了吗？”将首先运行，然后完成日志“我等待并且现在完成了”。为什么呢？`SetTimeout`是一个异步函数，所以当它执行时，它允许之后写的任何代码立即执行（即使`setTimeout`还没有完成）。这意味着在这种情况下，注释3中的日志实际上在注释2中的回调之前运行。因此，如果我们想象注释3中有一些需要立即运行的重要代码，而不需要等待注释2，我们就可以看到使用异步调用对性能有多么有帮助。现在，让我们结合对回调和异步调用的理解，来看一下Promise。
- en: 'Before `async await`, asynchronous code was handled using Promises. A `Promise`
    is an object with a delayed completion at some indeterminate future time. An example
    of `Promise` code would be something like this. Create a file called `promise.js`
    and add the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`async await`之前，异步代码是使用Promises来处理的。`Promise`是一个在未来某个不确定的时间延迟完成的对象。`Promise`代码的一个例子可能是这样的。创建一个名为`promise.js`的文件，并添加以下代码：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this code, we first create a `Promise` object and internally, we use an asynchronous
    timer to execute a statement after 500 milliseconds. On the first try, we are
    deliberately failing the timer by calling `reject` and this causes the code below
    the `Promise` definition to go to the `catch` handler. Now, if we comment out
    `reject` and then uncomment `resolve`, the bottom code will then go to the `then`
    handler. Clearly, this code works, but if you imagine a much more complex `Promise`,
    having many `then` statements, or even many Promises, things become increasingly
    complex to read and understand.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先创建一个`Promise`对象，并在内部使用异步计时器在500毫秒后执行一个语句。在第一次尝试中，我们故意通过调用`reject`来使计时器失败，这会导致`Promise`定义下面的代码进入`catch`处理程序。现在，如果我们注释掉`reject`，然后取消注释`resolve`，底部的代码将进入`then`处理程序。显然，这段代码是有效的，但是如果想象一个更复杂的`Promise`，有许多`then`语句，甚至有许多Promise，那么阅读和理解将变得越来越复杂。
- en: 'This is where `async await` can help. It does two main things: it cleans up
    the code and makes it simpler and smaller and it also makes the code easier to
    follow as it *looks* like synchronous code. Let''s view an example. Create a new
    file called `async.js` and add the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`async await`的作用。它有两个主要作用：它清理了代码，使其更简单更小，并且使代码更易于理解，因为它*看起来*像同步代码。让我们看一个例子。创建一个名为`async.js`的新文件，并添加以下代码：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code has a function called `delayedResult`, which, as you can see, has
    the `async` prefix in front of it. Prefixing a function with `async` tells the
    runtime that this function will return a `Promise` and therefore should be handled
    asynchronously. After `delayedResult`, we see a function called `execAsyncFunc`
    that is both declared and executed simultaneously. If you are not familiar with
    it, this capability is called an `execAsyncFunc` function is also `async`-capable
    and as you can see, internally, it uses the `await` keyword. The `await` keyword
    tells the runtime that we are about to execute an asynchronous function, so it
    should wait on our behalf, and then, once the statement completes, give us the
    actual return value instead. If we run this code, we see the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个名为`delayedResult`的函数，正如您所看到的，它在前面有`async`前缀。在函数前面加上`async`告诉运行时，这个函数将返回一个`Promise`，因此应该异步处理。在`delayedResult`之后，我们看到一个名为`execAsyncFunc`的函数，它同时声明和执行。如果您不熟悉它，这种能力被称为`execAsyncFunc`函数也是`async`-capable，并且正如您所看到的，它内部使用了`await`关键字。`await`关键字告诉运行时，我们即将执行一个异步函数，因此它应该代表我们等待，然后，一旦语句完成，给我们实际的返回值。如果我们运行这段代码，我们会看到以下内容：
- en: '![Figure 3.16 – async'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 – 异步'
- en: '](img/Figure_3.16_B15508.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B15508.jpg)'
- en: Figure 3.16 – async
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 异步
- en: As you can see, the `result` variable contains the `I completed successfully`
    string instead of the `Promise` that `delayedResult` normally returns. This syntax
    is clearly much shorter and easier to read than having many nested `Promise` `then`
    statements. Please note that `async` and `await` have taken over asynchronous
    development in the JavaScript community. You must understand it well in order
    to succeed with modern JavaScript. We'll look at one more example to further our
    understanding.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`result`变量包含`I completed successfully`字符串，而不是`delayedResult`通常返回的`Promise`。这种语法显然比有许多嵌套的`Promise`
    `then`语句更短更易读。请注意，`async`和`await`已经在JavaScript社区中取代了异步开发。您必须深刻理解它，才能成功地使用现代JavaScript。我们将看一个更多的例子来加深理解。
- en: Important Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We had to use an IIFE for the `execAsyncFunc` function because in current JavaScript,
    top-level `await` is not allowed. Top-level `await` basically means being able
    to run a call to await a function that is not inside of another `async` function.
    In the ECMAScript 2020 version of JavaScript, this is enabled, but as of the time
    of writing, it is not yet completely supported across all browsers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为`execAsyncFunc`函数使用IIFE，因为在当前的JavaScript中，不允许顶层的`await`。顶层的`await`基本上意味着能够运行一个不在另一个`async`函数内部的函数的等待调用。在JavaScript的ECMAScript
    2020版本中，这是被启用的，但在撰写本文时，它尚未完全在所有浏览器中得到支持。
- en: 'Because `async await` is so important, let''s look at one more example. Let''s
    make a call to a network resource to get some data. We''ll use the `fetch` API,
    but since Node does not support it natively, we''ll need to install one more `npm`
    package first. Here are the steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`async await`非常重要，让我们再看一个例子。让我们调用一个网络资源来获取一些数据。我们将使用`fetch` API，但由于Node不支持它，我们需要先安装另一个`npm`包。以下是步骤：
- en: 'Run the following command in your terminal to install `fetch`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令以安装`fetch`：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a file called `fetch.js` and enter the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fetch.js`的文件，并输入以下代码：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice, in this example, the easy-to-read and natural flow of the code. As you
    can see, we are using the `fetch` API, which allows us to make asynchronous network
    calls. After importing `fetch`, we again create an `async` wrapper function to
    execute `await` calls to our `fetch` function. If you're wondering, the URL is
    a public API for Pokémon characters that requires no authentication. The first
    call to `await` is for the actual network call itself. Once that call completes,
    a check for success is made using `response.ok`. If successful, another call to
    `await` is made to convert the data into JSON format. Each call to `await` blocks
    the code at that point until the function completes and returns.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，代码的易读性和自然流程。正如您所看到的，我们正在使用`fetch` API，它允许我们进行异步网络调用。在导入`fetch`之后，我们再次创建一个`async`包装函数来执行对我们的`fetch`函数的`await`调用。如果您想知道，URL是一个不需要身份验证的宠物小精灵角色的公共API。第一次调用`await`是为了实际的网络调用本身。一旦该调用完成，使用`response.ok`进行成功检查。如果成功，再次调用`await`将数据转换为JSON格式。每次调用`await`都会阻塞代码，直到函数完成并返回。
- en: 'We are *awaiting* because we cannot continue without this data from the network
    API and therefore we have no choice but to wait. If you run this code, you will
    see the following data:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在*等待*，因为没有来自网络API的数据，所以我们别无选择，只能等待。如果运行此代码，您将看到以下数据：
- en: '![Figure 3.17 – fetch'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17 – 获取'
- en: '](img/Figure_3.17_B15508.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.17_B15508.jpg)'
- en: Figure 3.17 – fetch
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 - 获取
- en: When this code ran, you probably noticed a small delay before the code completed.
    This shows the code needed to wait until the network call for the data to complete.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码运行时，你可能会注意到代码完成之前有一小段延迟。这显示了代码需要等待数据的网络调用完成。
- en: In this section, we learned what asynchronous programming is. We also discussed
    both Promises, the foundation of asynchronous programming in JavaScript, and `async
    await`, which provides us with a means to streamline our asynchronous code. You
    will see `async await` used heavily in both React and Node development.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了什么是异步编程。我们还讨论了Promise，这是JavaScript中异步编程的基础，以及`async await`，它为我们提供了一种简化异步代码的方法。你将会在React和Node开发中大量看到`async
    await`的使用。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a lot of the newer, cutting-edge features of JavaScript
    programming, such as methods for merging objects and arrays with `async await`,
    a new and very popular way of working with asynchronous code. It is very important
    to understand these features as they are extensively used in modern JavaScript
    and React development.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看了很多JavaScript编程的新功能，比如用`async await`合并对象和数组的方法，这是一种新的非常流行的处理异步代码的方式。理解这些功能非常重要，因为它们在现代JavaScript和React开发中被广泛使用。
- en: In the next section, we will begin digging into single-page application development
    using React. We will start using many of the features that we learned about in
    this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将开始深入学习使用React进行单页应用程序开发。我们将开始使用本章学到的许多功能。
