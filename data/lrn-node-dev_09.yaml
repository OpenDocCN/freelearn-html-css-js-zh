- en: Deploying Applications to Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序部署到Web
- en: In this chapter, we'll worry about adding version control and deploying our
    applications because when it comes to creating real-world Node apps, deploying
    your app to the Web is obviously a pretty big part of that. Now in the real world,
    every single company uses some form of version control. It is essential to the
    software development process, and most of them aren't using Git. Git has become
    really popular, dominating the market share for version control. Git is also free
    and open source, and there is a ton of great educational material. They have a
    book on how to learn Git. It's free and Stack Overflow is filled with Git-specific
    questions and answers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将担心添加版本控制和部署我们的应用程序，因为当涉及到创建真实的Node应用程序时，将应用程序部署到Web上显然是其中非常重要的一部分。现实世界中，每家公司都使用某种形式的版本控制。这对软件开发过程至关重要，而且大多数公司都没有使用Git。Git已经变得非常流行，占据了版本控制的市场份额。Git也是免费和开源的，并且有大量优质的教育材料。他们有一本关于如何学习Git的书。它是免费的，Stack
    Overflow上充满了Git特定的问题和答案。
- en: We'll be using Git to save our project. We'll also be using it to back up our
    work to a service called GitHub, and finally we'll be using Git to deploy our
    project live to the Web. So we'll be able to take our web server and deploy it
    for anybody to visit. It won't just be available on localhost.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Git保存我们的项目。我们还将使用它将我们的工作备份到一个名为GitHub的服务中，最后我们将使用Git将我们的项目实时部署到Web上。因此，我们将能够将我们的Web服务器部署给任何人访问。它不仅仅可以在本地主机上使用。
- en: 'Specifically, we''ll look into the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将研究以下主题：
- en: Setting up and using Git
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用Git
- en: Setting up GitHub and SSH keys
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置GitHub和SSH密钥
- en: Deploying Node app to the web
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Node应用程序部署到Web
- en: The workflow of the entire development life cycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个开发生命周期的工作流程
- en: Adding version control
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加版本控制
- en: In this section, we'll learn how to set up and use Git, which is a version control
    system. Git will let us keep track of the changes to our project over time. This
    is really useful when something goes wrong and we need to revert to a previous
    state in the project where things were working. It's also super useful for backing
    up our work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何设置和使用Git，这是一个版本控制系统。Git将允许我们随着时间的推移跟踪我们项目的变化。当出现问题并且我们需要恢复到项目中以前工作正常的状态时，这非常有用。它还非常有用于备份我们的工作。
- en: Installing Git
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Git
- en: To get started, we will need to install Git on the computer, but luckily for
    us it is a really simple installation process. It's one of those installers where
    we just click on the Next button through a few steps. So let's go ahead and do
    that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要在计算机上安装Git，但幸运的是，这是一个非常简单的安装过程。这是一个我们只需通过几个步骤单击“下一步”按钮的安装程序。所以让我们继续做到这一点。
- en: We can grab the installer by heading over to the browser and going to [git-scm.com](http://git-scm.com).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过浏览器转到[git-scm.com](http://git-scm.com)来获取安装程序。
- en: Before we go ahead and install it, I want to show you the link to the book called
    Pro Git ([https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)). It
    is a free book and also available for online reading. It covers everything that
    Git has to offer. We'll be looking at some of the more basic features in this
    chapter, but we could easily create an entire course on Git. There actually are
    Udemy courses just on Git and GitHub, so if you want to learn more than what we
    cover in this book, I'd recommend reading this book or checking out a course,
    whatever your preferred learning method is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续安装之前，我想向您展示一本名为Pro Git的书的链接([https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2))。这是一本免费的书，也可以在线阅读。它涵盖了Git所提供的一切。在本章中，我们将研究一些更基本的功能，但我们可以很容易地创建一个关于Git的整个课程。实际上，Udemy上有专门关于Git和GitHub的课程，所以如果您想学习更多内容，我建议阅读这本书或参加课程，无论您的首选学习方法是什么。
- en: Click on the download button present on the right-hand side of the home page,
    for all the operating systems, whether it's Windows, Linux, or macOS. This should
    take us to the installer page and we should be able to get the installer downloading
    automatically. If you see any problem with [SourceForge.net](http://SourceForge.net),
    then we may have to actually click on it to download manually in order to start
    the download.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击主页右侧的下载按钮，适用于所有操作系统，无论是Windows、Linux还是macOS。这应该会带我们到安装程序页面，我们应该能够自动下载安装程序。如果您在[SourceForge.net](http://SourceForge.net)上遇到任何问题，那么我们可能需要实际点击它以手动下载以开始下载。
- en: Once the installer is downloaded, we can simply run it.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装程序下载完成后，我们可以简单地运行它。
- en: 'Next, move through the installer:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过安装程序：
- en: '![](img/f28f15a4-51a0-4b2c-833e-2db4f5206597.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f28f15a4-51a0-4b2c-833e-2db4f5206597.png)'
- en: 'Click on Continue and install the package:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“继续”并安装软件包：
- en: '![](img/c69a0917-3956-4c99-8cd1-213499b6467d.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c69a0917-3956-4c99-8cd1-213499b6467d.png)'
- en: 'Once it''s done, we can go ahead and actually test that things installed successfully:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们可以继续测试安装是否成功：
- en: '![](img/7ee9bd39-d428-431b-b851-b425179cb950.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ee9bd39-d428-431b-b851-b425179cb950.png)'
- en: Git on macOS
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS上的Git
- en: 'If you''re on macOS, you''ll need to launch the package installer and you might
    get the following message box saying that it''s from an unidentified developer:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，您需要启动软件包安装程序，可能会收到以下消息框，表示它来自未知开发者：
- en: '![](img/b642c42a-6ab9-40cf-974d-20ce383b5c53.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b642c42a-6ab9-40cf-974d-20ce383b5c53.png)'
- en: This is because it is distributed via a third party as opposed to being in the
    macOS App Store. We can go ahead and right-click on the package, then click on
    the Open button and confirm that we do indeed want to open it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它是通过第三方分发的，而不是在macOS应用商店中。我们可以右键单击软件包，然后单击“打开”按钮，并确认我们确实要打开它。
- en: Once you're at the installer, the process is going to be pretty simple. You
    can essentially click on Continue and Next throughout every step.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您到达安装程序，整个过程将非常简单。您可以在每个步骤中单击“继续”和“下一步”。
- en: Git on Windows
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows上的Git
- en: 'If you''re on Windows though, there is an important distinction. Inside the
    installer you''re going to see a screen just like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您使用的是Windows，有一个重要的区别。在安装程序中，您将看到一个与此类似的屏幕：
- en: '![](img/4550bcdb-51c6-4bb5-a53c-0948d0946423.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4550bcdb-51c6-4bb5-a53c-0948d0946423.png)'
- en: It is really important that you also install Git Bash as shown in the screenshot.
    Git Bash is a program that simulates a Linux-type Terminal, and it's going to
    be really essential when we create our SSH keys in the next section to uniquely
    identify our machine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，您还要安装Git Bash，如截图所示。Git Bash是一个模拟Linux类型终端的程序，在我们创建下一节中的SSH密钥时，它将非常重要，以便唯一标识我们的机器。
- en: Testing the installation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试安装
- en: 'Now, let''s move in to the Terminal to test the installation. From the Terminal
    we can go ahead and run `git --version`. This is going to print a new version
    of Git we have installed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入终端测试安装。从终端中，我们可以继续运行`git --version`。这将打印出我们安装的新版本的Git：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As shown in the following screenshot, we can see we have git version 2.14.3:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，我们可以看到我们有git版本2.14.3：
- en: '![](img/1e395129-2b63-495b-89ff-d32c34d8d6a3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e395129-2b63-495b-89ff-d32c34d8d6a3.png)'
- en: Now if you have your Terminal still open and you're getting an error like git
    command not found, I'd recommend trying to restart your Terminal. Sometimes that
    is required when you're installing new commands such as the `git` command, which
    we just installed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您的终端仍然打开，并且出现类似git命令未找到的错误，我建议尝试重新启动终端。有时在安装新命令（如刚刚安装的`git`命令）时，这是必需的。
- en: Turning the node-web-server directory into a Git repository
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将node-web-server目录转换为Git仓库
- en: 'With successful installation of Git, we are now ready to turn our `node-web-server`
    directory into a Git repository. In order to do this, we''ll the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Git成功后，我们现在可以将我们的`node-web-server`目录转换为Git存储库。为了做到这一点，我们将运行以下命令：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `git init` command needs to get executed from the root of our project,
    the folder that has everything that we want to keep track of. In our case, `node-web-server`
    is that folder. It has our `server.js` file, our `package.json` file, and all
    of our directories. So, from the server folder, we''ll run `git init`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`git init`命令需要在我们项目的根目录中执行，即包含我们要跟踪的所有内容的文件夹。在我们的情况下，`node-web-server`就是那个文件夹。它包含我们的`server.js`文件，我们的`package.json`文件和所有的目录。因此，从服务器文件夹中，我们将运行`git
    init`：'
- en: '![](img/cf1cdef2-0067-47d4-a89d-b857ffd358e7.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf1cdef2-0067-47d4-a89d-b857ffd358e7.png)'
- en: 'This creates a `.git` directory inside that folder. We can prove that by running
    the `ls -a` command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在该文件夹内创建一个`.git`目录。我们可以通过运行`ls -a`命令来证明：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As shown in the following screenshot, we get all of the directories including
    the hidden ones and right here I do indeed have .git:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，我们获得了所有目录，包括隐藏的目录，而我确实有.git：
- en: '![](img/025bc4ba-5321-442b-809f-a2f09d977e8e.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/025bc4ba-5321-442b-809f-a2f09d977e8e.png)'
- en: For Windows, go ahead and run these commands from the Git Bash.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，可以从Git Bash中运行这些命令。
- en: Now this directory is not something we should be manually updating. We'll be
    using commands from the Terminal in order to make changes to the Git folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个目录不是我们应该手动更新的东西。我们将使用终端中的命令来对Git文件夹进行更改。
- en: You don't want to be going in there manually messing around with things because
    there's a pretty good chance you're going to corrupt the Git repository and all
    of your hard work is going to become useless. Now obviously if it's backed up,
    it's not a big deal, but there really is no reason to go into that Git folder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您不希望手动进入那里搞乱事情，因为您很可能会破坏Git存储库，而您的辛苦工作将变得毫无意义。现在显然，如果有备份，这不是什么大问题，但实际上没有理由进入那个Git文件夹。
- en: Let's use the `clear` command to clear the Terminal output, and now we can start
    looking at exactly how Git works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`clear`命令清除终端输出，现在我们可以开始看Git的工作原理。
- en: Using Git
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Git
- en: 'As mentioned earlier, Git is responsible for keeping track of the changes to
    our project, but by default it doesn''t actually track any of our files. We have
    to tell Git exactly which files we want it to keep track of and there''s a good
    reason for this. There are files in every project that we''re most likely not
    going to want to add to our Git repo, and we''ll talk about which ones and why
    later. For now let''s go ahead and run the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Git负责跟踪项目的更改，但默认情况下它实际上不会跟踪任何文件。我们必须告诉Git确切地要跟踪哪些文件，这是有很好的理由的。每个项目中都有一些文件，我们很可能不想将其添加到Git仓库中，我们将在稍后讨论哪些文件以及为什么。现在让我们继续运行以下命令：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now all these commands need to get executed from inside of the root of the project.
    If you try to run this outside a repository, you'll get an error like git repository
    not found. What that means is that Git cannot find that `.git` directory in order
    to actually get the status of your repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些命令都需要在项目的根目录中执行。如果您尝试在存储库之外运行此命令，您将收到类似git repository not found的错误。这意味着Git找不到`.git`目录，无法实际获取存储库的状态。
- en: 'When we run this command, we''ll get some output that looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此命令时，我们将得到以下输出：
- en: '![](img/bf2f92bd-950c-4cce-8b8c-49efff90be6c.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf2f92bd-950c-4cce-8b8c-49efff90be6c.png)'
- en: The important pieces for now is the Untracked files header and all of the files
    underneath it. These are all of the files and folders that Git seized, but it's
    currently not tracking. Git doesn't know if you want to keep track of the changes
    to these files or if you want to ignore them from your repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重要的部分是未跟踪文件标题和其下的所有文件。这些都是Git捕获的所有文件和文件夹，但它目前没有跟踪。Git不知道您是否要跟踪这些文件的更改，或者您是否要将它们从存储库中忽略。
- en: Now the `views` folder, for example, is something we definitely want to keep
    track of. This is going to be essential to the project and we want to make sure
    that whenever someone downloads the repository, they get the `views` folder. The
    log file on the other hand doesn't really need to be included in Git. In general
    our log files are not going to be committed, since they usually contain information
    specific to a point in time when the server was running.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，例如，`views`文件夹是我们确实想要跟踪的。这对项目至关重要，我们希望确保每当有人下载存储库时，他们都会得到`views`文件夹。另一方面，日志文件实际上不需要包含在Git中。通常我们的日志文件不会被提交，因为它们通常包含特定时间点服务器运行时的信息。
- en: As shown in the preceding code output, we have `server.js`, our public folder,
    and `package.json`. These are all essential to the process of executing the app.
    These are definitely going to be added to our Git repository, and the first one
    above we have is the `node_modules` folder. The `node_modules` folder is what's
    called a generated folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的代码输出所示，我们有`server.js`，我们的public文件夹和`package.json`。这些都是执行应用程序过程中必不可少的。这些肯定会被添加到我们的Git仓库中，而我们上面有的第一个是`node_modules`文件夹。`node_modules`文件夹是所谓的生成文件夹。
- en: Generated folders are easily generated by running a command. In our case, we
    can regenerate this entire directory using `npm install`. We're not going to want
    to add Node modules to our Git repository because its contents differ depending
    on the version of npm you have installed and depending on the operating system
    you're using. It's best to leave off Node modules and let every person who uses
    your repository manually install the modules on the machine they're actually going
    to be running the app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件夹可以通过运行命令轻松生成。在我们的情况下，我们可以使用`npm install`重新生成整个目录。我们不想将Node模块添加到我们的Git仓库，因为它的内容取决于您安装的npm版本和您使用的操作系统。最好不要添加Node模块，让每个使用您的存储库的人手动在他们实际运行应用程序的计算机上安装模块。
- en: Adding untracked files to commit
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将未跟踪的文件添加到提交
- en: 'Now we have these six folders and files listed, so let''s go ahead and add
    the four folders and files we want to keep. To get started, we''ll use any `git
    add` command. The `git add` command lets us tell the Git we want to keep track
    of a certain file. Let''s type the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们列出了这六个文件夹和文件，所以让我们继续添加我们想要保留的四个文件夹和文件。首先，我们将使用任何`git add`命令。`git add`命令让我们告诉Git我们要跟踪某个文件。让我们输入以下命令：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After we do this, we can run it `git status` again, and this time we get something
    very different:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后，我们可以再次运行`git status`，这次我们得到了一个非常不同的结果：
- en: '![](img/6768c7e0-bc2a-4124-98be-a0504a0df1d4.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6768c7e0-bc2a-4124-98be-a0504a0df1d4.png)'
- en: 'Now we have an Initial commit header. This is new, and we have our old Untracked
    files header. Notice under Untracked files, we don''t have `package.json` anymore.
    That is moved up to the Initial commit header. These are all of the files that
    are going to be saved, also known as committed, when we make our first commit.
    Now we can move on adding the 3 others. We''ll use a `git add` command again to
    tell Git we want to track the public directory. We can run a `git status` command
    to confirm it was added as expected:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个初始提交标题。这是新的，我们有我们旧的未跟踪文件标题。请注意，在未跟踪的文件下，我们不再有`package.json`。它移到了初始提交标题下。这些都是在我们进行第一次提交时要保存的文件，也就是提交的文件。现在我们可以继续添加其他3个。我们将再次使用`git
    add`命令告诉Git我们要跟踪public目录。我们可以运行`git status`命令来确认它是否按预期添加了：
- en: '![](img/12564fb0-5e07-4cd3-9e23-983de41d424d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12564fb0-5e07-4cd3-9e23-983de41d424d.png)'
- en: As shown in the preceding screenshot, we can see the public/help.html file is
    now going to be committed to Git once we run a commit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到public/help.html文件现在将在我们运行提交后提交到Git。
- en: 'Next up we can add `server.js` with `git add server.js`, and we can add the
    `views` directory using `git add views`, just like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`git add server.js`添加`server.js`，并使用`git add views`添加`views`目录，就像这样：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll run a `git status` command to confirm:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行`git status`命令进行确认：
- en: '![](img/b5000133-53cd-4855-80f3-755e0b800deb.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5000133-53cd-4855-80f3-755e0b800deb.png)'
- en: Everything looks good. Now the Untracked files are going to sit around here
    until we do one of two things—we either add them to the Git repository or ignore
    them using a custom file that we're going to create inside Atom.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好。现在未跟踪的文件将一直保留在这里，直到我们执行以下两种操作之一——要么将它们添加到Git存储库中，要么使用我们将在Atom中创建的自定义文件来忽略它们。
- en: 'Inside Atom, we''d like to make a new file called `.gitignore`, in our root
    of our project. The `gitignore` file is going to be part of our Git repository
    and it tells get which folders and files you want to ignore. In this case we can
    go ahead and ignore `node_modules`, just like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，我们想要在我们项目的根目录中创建一个名为`.gitignore`的新文件。`gitignore`文件将成为我们的Git存储库的一部分，并告诉Git要忽略哪些文件和文件夹。在这种情况下，我们可以继续忽略`node_modules`，就像这样：
- en: '![](img/28a9f78a-7f62-42f9-b13e-6a8501af7dcf.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28a9f78a-7f62-42f9-b13e-6a8501af7dcf.png)'
- en: 'When we save the `gitignore` file and rerun `git status` from the Terminal,
    we''ll now get a really different result:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存`gitignore`文件并从终端重新运行`git status`时，我们现在会得到一个完全不同的结果：
- en: '![](img/ba523296-dcee-4f98-9716-1671a425921f.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba523296-dcee-4f98-9716-1671a425921f.png)'
- en: 'As shown, we can see we have a new untracked file—`.gitignore`—but the `node_modules`
    directory is nowhere in sight, and that''s exactly what we want. We want to remove
    this completely, making sure that it never ever gets added to the Git repo. Next
    up, we can go ahead and ignore that `server.log` file by typing its name, `server.log`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们有一个新的未跟踪文件—`.gitignore`—但`node_modules`目录不见了，这正是我们想要的。我们想要完全删除它，确保它永远不会被添加到Git仓库中。接下来，我们可以继续忽略`server.log`文件，通过输入它的名称，`server.log`：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll save `gitignore`, run `git status` from the Terminal one more time,
    and make sure everything looks great:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存`gitignore`，再次从终端运行`git status`，确保一切看起来都很好：
- en: '![](img/fa3d0f70-2563-406d-8cce-3b760f5b5c4a.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa3d0f70-2563-406d-8cce-3b760f5b5c4a.png)'
- en: As shown, we have a `gitignore` file as our only untracked file. The `server.log`
    file and `node_modules` are nowhere in sight.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们有一个`gitignore`文件作为我们唯一的未跟踪文件。`server.log`文件和`node_modules`都不见了。
- en: 'Now that we have `gitignore`, we are going to be adding it to Git using `git
    add .gitignore` and when we run `git status`, we should be able to see that all
    the files that show up are under the initial commit:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`gitignore`，我们将使用`git add .gitignore`将其添加到Git中，当我们运行`git status`时，我们应该能够看到所有显示的文件都在初始提交之下：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/58456adc-9681-47bd-8016-f76be91ff32f.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58456adc-9681-47bd-8016-f76be91ff32f.png)'
- en: So now it's time to make a commit. A commit really only requires two things.
    It requires some change in the repository. In this case, we're teaching Git how
    to track a ton of new files, so we are indeed changing something, and it requires
    a message. We've already handled the file part of things. We've told Git what
    we want to save, we just haven't actually saved it yet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行提交了。提交实际上只需要两件事。它需要存储库中的一些更改。在这种情况下，我们正在教Git如何跟踪大量新文件，所以我们确实在改变一些东西，还需要一个消息。我们已经处理了文件部分。我们告诉Git我们想要保存什么，只是还没有真正保存它。
- en: Making a commit
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行提交
- en: 'In order to make our first commit and save our first thing into the Git repository,
    we''ll run `git commit` and provide one flag, the `m` flag, which is short message.
    After that inside quotes, we can specify the message that we want to use for this
    commit. It''s really important to use these messages so when someone''s digging
    through the commit history, the list of all the changes to the project can be
    seen, which are actually useful. In this case, `Initial commit` is always a good
    message for your first commit:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行我们的第一个提交并将我们的第一件事保存到Git存储库中，我们将运行`git commit`并提供一个标志，即`m`标志，这是短消息。在引号内，我们可以指定我们想要用于此提交的消息。使用这些消息非常重要，因此当有人查看提交历史时，可以看到对项目的所有更改的列表，这实际上是有用的。在这种情况下，`Initial
    commit`总是一个很好的消息，用于你的第一个提交：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I''ll go ahead and hit *enter* and as shown in the following screenshot, we
    see all of the changes that happened to the repo:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续点击*enter*，如下面的截图所示，我们可以看到对存储库所做的所有更改：
- en: '![](img/8bee6774-3f98-4d2d-b49b-ffaa394bf715.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bee6774-3f98-4d2d-b49b-ffaa394bf715.png)'
- en: We have created a bunch of new files inside of the Git repository. These are
    all of the files that we told Git we want to keep track of and this is fantastic.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Git存储库中创建了一堆新文件。这些都是我们告诉Git我们想要跟踪的文件，这太棒了。
- en: We now have our very first commit, which essentially means that we've saved
    the project at its current state. If we make a big change to `server.js`, messing
    stuff up to not be able figure out how to get it back to the way it was, we can
    always get it back because we made a Git commit. Now we'll explore some more fancy
    Git things in the later sections. We'll be talking about how to do most of the
    things you want to do with Git, including deploying to Heroku and pushing to GitHub.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了我们的第一个提交，这基本上意味着我们已经保存了项目的当前状态。如果我们对`server.js`进行了重大更改，搞砸了，不知道如何恢复到原来的状态，我们总是可以恢复，因为我们做了一个Git提交。现在我们将在后面的部分探讨一些更高级的Git功能。我们将讨论如何使用Git做大部分你想做的事情，包括部署到Heroku和推送到GitHub。
- en: Setting up GitHub and SSH keys
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置GitHub和SSH密钥
- en: Now that you have a local Git repository, we'll look at how we can take that
    code and push it up to a third-party service called GitHub. GitHub is going to
    let us host our Git repositories remotely, so if our machine ever crashes we can
    get our code back, and it also has great collaboration tools, so we can open-source
    a project, letting others use our code, or we can keep it private so only people
    we choose to collaborate with can see the source code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个本地的Git存储库，我们将看看如何将代码推送到一个名为GitHub的第三方服务。GitHub将让我们远程托管我们的Git存储库，所以如果我们的机器崩溃了，我们可以找回我们的代码，它还有很棒的协作工具，所以我们可以开源一个项目，让其他人使用我们的代码，或者我们可以保持私有，只有我们选择合作的人可以看到源代码。
- en: Now in order to actually communicate between our machine and GitHub, we'll have
    to create something called an SSH key. SSH keys were designed to securely communicate
    between two computers. In this case, it will be our machine and the GitHub server.
    This will let us confirm that GitHub is who they say they are and it will let
    GitHub confirm that we indeed have access to the code we're trying to alter. This
    will all be done with SSH keys and we'll create them first, then we'll configure
    them, and finally we'll push our code up to GitHub.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在我们的机器和GitHub之间进行实际通信，我们将不得不创建一个称为SSH密钥的东西。SSH密钥旨在在两台计算机之间进行安全通信。在这种情况下，它将是我们的机器和GitHub服务器。这将让我们确认GitHub是他们所说的那样，它将让GitHub确认我们确实可以访问我们试图修改的代码。这将全部通过SSH密钥完成，我们将首先创建它们，然后配置它们，最后将我们的代码推送到GitHub。
- en: Setting up SSH keys
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置SSH密钥
- en: The process of setting up SSH keys can be a real burden. This is one of those
    topics where there's really small room for error. If you type any of the commands
    wrong, things are just not going to work as expected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设置SSH密钥的过程可能是一个真正的负担。这是一个那种话题，错误的余地真的很小。如果你输入任何错误的命令，事情就不会按预期工作。
- en: Now if you're on Windows, you'll need to do everything in this section from
    a Git Bash as opposed to the regular Command Prompt because we'll be using some
    commands that just are not available on Windows. They are, however, available
    on Linux and macOS. So if you're using either of those operating systems, you
    can continue using the Terminal you've been using throughout the book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用的是Windows，你需要在Git Bash中执行本节中的所有操作，而不是常规命令提示符，因为我们将使用一些在Windows上不可用的命令。但是，在Linux和macOS上是可用的。因此，如果你使用这两种操作系统中的任何一种，你可以继续使用本书中一直在使用的终端。
- en: SSH keys documentations
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH密钥文档
- en: 'Before we dive into the commands, I want to show you a quick guide that exists
    online in case you get stuck or you have any questions. You can Google GitHub
    SSH keys, and this is going to link you to an article called generating an SSH
    key: [https://help.github.com/articles/connecting-to-github-with-ssh/](https://help.github.com/articles/connecting-to-github-with-ssh/).
    Once you''re here, you''ll be able to click on the SSH breadcrumb, and this is
    going to bring you back to all of their articles on SSH keys:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入命令之前，我想向您展示一个快速指南，以防您遇到困难或有任何问题。您可以搜索GitHub SSH密钥，这将链接您到一篇名为生成SSH密钥的文章：[https://help.github.com/articles/connecting-to-github-with-ssh/](https://help.github.com/articles/connecting-to-github-with-ssh/)。一旦您到达这里，您就可以单击SSH面包屑，这将带您回到他们关于SSH密钥的所有文章：
- en: '![](img/435bd81e-9ce8-4538-96fe-64cbca643e25.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/435bd81e-9ce8-4538-96fe-64cbca643e25.png)'
- en: Out of these articles, the nested four are the ones we'll be focusing on checking
    if we have a key, generating a new key, adding the key to GitHub, and finally
    testing that everything worked as expected. If you run into any problems along
    any of these steps, you can always click on the guide for that step and you can
    pick the operating system you're using so you can see the appropriate commands
    for that OS. Now that you know this exists, let's go ahead and do it together.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文章中，我们将专注于检查是否有密钥，生成新密钥，将密钥添加到GitHub，最后测试一切是否按预期工作。如果您在这些步骤中遇到任何问题，您可以随时单击该步骤的指南，并且您可以选择您正在使用的操作系统，以便查看该操作系统的适当命令。既然您知道这一点，让我们一起来做吧。
- en: Working on commands
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作中的命令
- en: 'The first command we''ll run from the Terminal is going to check if we have
    an existing SSH key. Now if you don''t, that''s fine. We''ll go ahead and create
    one. If you do or you''re not sure you do, you can run the following command to
    confirm whether or not you have one: `ls` with the `al` flag. This is going to
    print all the files in a given directory, and the directory where SSH keys are
    stored by default on your machine is going to be at the user directory, which
    you can use (`~`) as a shortcut for `/.ssh`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从终端运行的第一个命令是检查是否有现有的SSH密钥。如果没有，那没关系。我们将继续创建一个。如果您不确定是否有密钥，您可以运行以下命令来确认您是否有密钥：`ls`与`al`标志。这将打印出给定目录中的所有文件，默认情况下，SSH密钥存储在您的计算机上的用户目录中，您可以使用（`~`）作为`/.ssh`的快捷方式：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run the command, you''ll see all of the contents inside of that SSH
    directory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行该命令时，您将看到SSH目录中的所有内容：
- en: '![](img/6b6e13c4-95a4-44bb-88bc-cb7c5aef7415.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b6e13c4-95a4-44bb-88bc-cb7c5aef7415.png)'
- en: In this case I've deleted all of my SSH keys so I have nothing inside my directory.
    I just have paths for the current directory and the previous one. Now that we
    have this in place and we've confirmed we don't have a key, we can go ahead and
    generate one. If you do already have a key, a file like `id_rsa`, you can go ahead
    and skip the process of generating the key.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我已经删除了所有我的SSH密钥，所以我的目录中没有任何内容。我只有当前目录和上一个目录的路径。既然我们已经做好了准备，并且确认我们没有密钥，我们可以继续生成一个。如果您已经有一个密钥，例如`id_rsa`文件，您可以跳过生成密钥的过程。
- en: Generating a key
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成密钥
- en: 'To make a key we''ll use the `ssh-keygen` command. Now the `ssh-keygen` takes
    three arguments. We''ll pass in `t` setting it equal to `rsa`. We''ll pass in
    `b` which is for bytes, setting that equal to `4096`. Make sure to match these
    arguments exactly, and we''ll be setting a capital `C` flag which will get set
    equal to your email:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个密钥，我们将使用`ssh-keygen`命令。现在`ssh-keygen`需要三个参数。我们将传入`t`，将其设置为`rsa`。我们将传入`b`，用于字节，将其设置为`4096`。确保精确匹配这些参数，我们将设置一个大写的`C`标志，该标志将设置为您的电子邮件：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now the scope of what's actually happening behind the scenes is not part of
    this book. SSH keys and setting up security, that could be an entire course in
    and of itself. We'll be using this command to simplify the entire process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实际发生在幕后的范围不在本书的讨论范围之内。SSH密钥和设置安全性，这可能是一个完整的课程。我们将使用此命令来简化整个过程。
- en: 'Now we can go ahead and hit *enter*, which will generate two new files in our
    `.ssh` folder. When you run this command, you''ll get greeted with a few steps.
    I want you to use the default for all of them:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续按*enter*键，这将在我们的`.ssh`文件夹中生成两个新文件。当您运行此命令时，您将受到几个步骤的欢迎。我希望您对所有步骤都使用默认设置：
- en: '![](img/88530059-be3b-483f-b0b5-8940e302fdfe.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88530059-be3b-483f-b0b5-8940e302fdfe.png)'
- en: 'Here they want to ask you if you want to customize the file name. I do not
    recommend doing that. You can just hit *enter*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 他们想要问您是否要自定义文件名。我不建议这样做。您可以直接按*enter*键：
- en: '![](img/e2ee020a-0ca3-49e8-8542-95d2a061ae15.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2ee020a-0ca3-49e8-8542-95d2a061ae15.png)'
- en: 'Next up they ask you for a passphrase, which we''ll not use. I''ll hit *enter*
    for no passphrase, then I need to confirm the passphrase, so I''ll just hit *enter*
    again:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，他们会要求您输入密码，我们将不使用密码。我将按下*enter*键，不设置密码，然后需要确认密码，所以我将再次按下*enter*键：
- en: '![](img/2d7558f9-87a6-4555-9c1c-b5f36368cb54.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d7558f9-87a6-4555-9c1c-b5f36368cb54.png)'
- en: As shown, we get a little message that our SSH key was properly created and
    that it was indeed saved in our folder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们收到了一条消息，说明我们的SSH密钥已经正确创建，并且确实保存在我们的文件夹中。
- en: With this in place, I can now cycle back through my previous commands running
    the `ls` command, and what do I get?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我现在可以通过之前的命令循环运行`ls`命令，我会得到什么？
- en: '![](img/6c4674f8-fa15-4d8d-b4e8-de584d2f7536.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c4674f8-fa15-4d8d-b4e8-de584d2f7536.png)'
- en: We get `id_rsa` and I get the `id_rsa.pub` file. The `id_rsa` file contains
    the private key. This is the key you should never give to anyone. It lives on
    your machine and your machine only. The `.pub` file, which is the public file.
    This one is the one you'll give to third-party services such as GitHub or Heroku,
    which we'll be doing in the next several sections.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了`id_rsa`和`id_rsa.pub`文件。`id_rsa`文件包含私钥。这是您绝对不应该给任何人的密钥。它只存在于您的计算机上。`.pub`文件是公共文件。这是您将提供给GitHub或Heroku等第三方服务的文件，我们将在接下来的几节中进行操作。
- en: Starting up the SSH agent
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动SSH代理
- en: 'Now that our keys are generated, the last thing we need to do is start up the
    SSH agent and add this key so it knows that it exists. We''ll do this by running
    two commands. These are:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的密钥已生成，我们需要做的最后一件事是启动SSH代理并添加此密钥，以便它知道它的存在。我们将通过运行两个命令来实现这一点。这些是：
- en: '`eval`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval`'
- en: '`ssh-add`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh-add`'
- en: 'First up we''ll run `eval`, and then we''ll open some quotes and inside the
    quotes, we''ll use the dollar sign and open and close some parentheses just like
    this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将运行`eval`，然后我们将打开一些引号，在引号内，我们将使用美元符号并打开和关闭一些括号，就像这样：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside our parentheses we''ll type `ssh-agent` with the `s` flag:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内，我们将键入带有`s`标志的`ssh-agent`：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will start up the SSH agent program and it will also print the process
    ID to confirm it is indeed running, and as shown, we get Agent pid 1116:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动SSH代理程序，并且还会打印进程ID以确认它确实正在运行，如所示，我们得到Agent pid 1116：
- en: '![](img/ceb07845-3dee-4a7c-afad-5a8c6633857f.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ceb07845-3dee-4a7c-afad-5a8c6633857f.png)'
- en: The process ID is obviously going to be different for everyone. As long as you
    get something back like this you are good to go.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 进程ID显然对每个人都是不同的。只要你得到这样的回复，你就可以继续了。
- en: 'Next up we have to tell the SSH agent where this file lives. We''ll do that
    using `ssh-add`. This takes the path to our private key file which we have in
    the user directory `/.ssh/id_rsa`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须告诉SSH代理此文件的位置。我们将使用`ssh-add`来实现这一点。这需要我们的私钥文件的路径，我们在用户目录`/.ssh/id_rsa`中有：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When I run this, I should get a message like identity added:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个时，我应该收到一个像身份添加的消息：
- en: '![](img/aafd390a-9a20-42b4-8bf4-fea82ce82d75.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aafd390a-9a20-42b4-8bf4-fea82ce82d75.png)'
- en: This means that the local machine now knows about this public/private key pair
    and it'll try to use these credentials when it communicates with a third-party
    service such as GitHub. Now that we have this in place, we are ready to configure
    GitHub. We'll make an account, set it up, and then we'll come back and test that
    things are working as expected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着本地计算机现在知道了这对公钥/私钥，并且在与GitHub等第三方服务通信时会尝试使用这些凭据。既然我们已经准备就绪，我们就可以配置GitHub了。我们将创建一个帐户，设置它，然后我们将回来测试一切是否按预期工作。
- en: Configuring GitHub
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置GitHub
- en: 'To configure GitHub, follow these steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置GitHub，请按照以下步骤操作：
- en: First head into the browser and go to [github.com](https://github.com/).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先进入浏览器，转到[github.com](https://github.com/)。
- en: Here log into your existing account or create a new one. If you need a new one,
    sign up for GitHub. If you have an existing one, go ahead and sign into it.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，登录到您现有的帐户或创建一个新帐户。如果您需要一个新帐户，请注册GitHub。如果您已经有一个现有的帐户，请继续登录。
- en: 'Once signed in, you should see the following screen. This is your GitHub dashboard:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦登录，您应该看到以下屏幕。这是您的GitHub仪表板：
- en: '![](img/8febedc9-307f-45a4-9a4f-7568c1be71a7.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8febedc9-307f-45a4-9a4f-7568c1be71a7.png)'
- en: 'From here, navigate to Settings, present at the top-left hand side, by the
    profile picture. Go to Settings | SSH and GPG keys | SSH keys:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，导航到设置，位于左上角，通过个人资料图片。转到设置| SSH和GPG密钥| SSH密钥：
- en: '![](img/4009ef30-e031-423f-a85b-b1e064d34d49.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4009ef30-e031-423f-a85b-b1e064d34d49.png)'
- en: From here we can add the public key, letting GitHub know that we want to communicate
    using SSH.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，我们可以添加公钥，让GitHub知道我们要使用SSH进行通信。
- en: 'Add the new SSH key:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的SSH密钥：
- en: '![](img/2d79ceaf-0649-4806-9ca6-e09327a7516a.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d79ceaf-0649-4806-9ca6-e09327a7516a.png)'
- en: 'Here, you need to do two things: give it a name, and add the key.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您需要做两件事：给它一个名称，并添加密钥。
- en: First add the name. The name can be anything you like. For example, I usually
    use one that uniquely identifies my computer since I have a couple. I'll use `MacBook
    Pro`, just like this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加名称。名称可以是任何你喜欢的东西。例如，我通常使用一个唯一标识我的计算机的名称，因为我有几台电脑。我会像这样使用`MacBook Pro`。
- en: '![](img/3bf11c47-360e-4ed1-a677-62e46f6361f9.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bf11c47-360e-4ed1-a677-62e46f6361f9.png)'
- en: Next up, add the key.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加密钥。
- en: To add the key, we need to grab the contents of the `id_rsa.pub` file, we generated
    in the previous sub-section. That file contains the information that GitHub needs
    in order to securely communicate between our machine and their machines. There
    are different methods to grab the key. In the browser, we have the Adding a new
    SSH key to your GitHub account article for our reference.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加密钥，我们需要获取在上一小节中生成的`id_rsa.pub`文件的内容。该文件包含GitHub需要的信息，以便在我们的计算机和他们的计算机之间进行安全通信。有不同的方法来获取密钥。在浏览器中，我们有添加新的SSH密钥到您的GitHub帐户文章供我们参考。
- en: '![](img/d0581d38-6875-4aa3-9164-0021295dcf7b.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0581d38-6875-4aa3-9164-0021295dcf7b.png)'
- en: This contains a command you can use to copy the contents of that file to your
    clipboard from right inside the Terminal. Now obviously it is different for the
    operating systems, macOS, Windows, and Linux, so run the command for your operating
    system.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这包含一个命令，您可以使用它从终端中直接复制该文件的内容到剪贴板。现在显然对于操作系统，macOS，Windows和Linux是不同的，所以运行适用于您的操作系统的命令。
- en: Use the `pbcopy` command which is available for macOS.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用macOS可用的`pbcopy`命令。
- en: Then, move into the Terminal and run it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入终端并运行它。
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This copies the contents of the file to the clipboard. You can also open the
    command up with a regular text editor and copy the contents of the file. We can
    use any method to copy the file. It doesn't matter how you do it. All that matters
    is you do.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将文件的内容复制到剪贴板。您还可以使用常规文本编辑器打开命令并复制文件的内容。我们可以使用任何方法来复制文件。重要的是你要做。
- en: Now move back into GitHub, click on the text area and paste it in.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到GitHub，点击文本区域并粘贴进去。
- en: '![](img/47824d09-e80c-418d-a5db-e8674a55dc52.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47824d09-e80c-418d-a5db-e8674a55dc52.png)'
- en: The contents of `id_rsa.pub` should start with `ssh-rsa` and it should end with
    that email you used.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`id_rsa.pub`的内容应该以`ssh-rsa`开头，并以您使用的电子邮件结尾。'
- en: Once you're done, go ahead and click on Add SSH key.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，继续点击“添加SSH密钥”。
- en: '![](img/c6dc5fb0-fbee-49b3-b111-947fd8ce6da7.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6dc5fb0-fbee-49b3-b111-947fd8ce6da7.png)'
- en: Now we can go ahead and test that things are working by running one command
    from the Terminal. Once again this command can be executed from anywhere on your
    machine. You don't need to be in your project folder to do this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续测试一下事情是否正常运行，通过在终端中运行一个命令。再次强调，这个命令可以在您的机器的任何地方执行。你不需要在你的项目文件夹中执行这个命令。
- en: Testing the configuration
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试配置
- en: 'To test the working of our GitHub configuration, we''ll use `ssh`, which tries
    to make a connection. We''ll use the `T` flag, followed by the URL we want to
    connect to you get at `git@github.com`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的GitHub配置的工作情况，我们将使用`ssh`，它尝试建立连接。我们将使用`T`标志，后面跟着我们要连接到的URL，获取`git@github.com`：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is going to test our connection. It will make sure that the SSH keys are
    properly set up and we can securely communicate with GitHub. When I run the command
    I get a message saying that The authenticity of host 'github.com (192.30.253.113)'
    can't be established.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将测试我们的连接。它将确保SSH密钥已正确设置，并且我们可以安全地与GitHub通信。当我运行命令时，我收到一条消息，说主机'github.com (192.30.253.113)'的真实性无法得到证实。
- en: '![](img/812f487e-a33e-405b-adc1-fd223a4fa200.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/812f487e-a33e-405b-adc1-fd223a4fa200.png)'
- en: 'We know that we want to communicate with [github.com](http://www.github.com).
    We''re expecting that communication to happen, so we can go ahead and enter `yes`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们想要与[github.com](http://www.github.com)进行通信。我们期望通信会发生，所以我们可以继续输入`yes`：
- en: '![](img/76f3a5f0-7184-4e53-9afa-214333fb2514.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76f3a5f0-7184-4e53-9afa-214333fb2514.png)'
- en: From here, we get a message from the GitHub servers as shown in the preceding
    screenshot. If you are seeing this message with your username then you are done.
    You're ready to create your first repository and push your code up.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们会收到GitHub服务器的消息，如前面的屏幕截图所示。如果你看到这条消息和你的用户名，那么你已经完成了。你已经准备好创建你的第一个存储库并推送你的代码。
- en: Now if you don't see this message, something went wrong along the way. Maybe
    the SSH key wasn't generated correctly or it's not getting recognized by GitHub.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你没有看到这条消息，那么在这个过程中出了问题。也许SSH密钥没有正确生成，或者GitHub没有识别它。
- en: Next, we'll move into GitHub, go back to the home page, and create a new repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进入GitHub，返回到主页，并创建一个新的存储库。
- en: Creating a new repository
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的存储库
- en: 'To create a new repository, follow these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的存储库，请按照以下步骤进行：
- en: 'On the GitHub home page, in the right-hand side corner, navigate to the New
    repository button, which should look like this (click on Start New Project if
    it''s a new one):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub主页的右上角，导航到新存储库按钮，它应该是这样的（如果是新的存储库，点击开始新项目）：
- en: '![](img/90b7620e-c249-4e79-a8d9-c938466f49d6.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90b7620e-c249-4e79-a8d9-c938466f49d6.png)'
- en: 'This will lead us to the new repository page:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到新的存储库页面：
- en: '![](img/a0488724-e8fe-4236-a050-8e537fcf4b92.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0488724-e8fe-4236-a050-8e537fcf4b92.png)'
- en: 'Here, all we need to do is give it a name. I''m going to call this one `node-course-2-web-server`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只需要给它一个名字。我要把这个叫做`node-course-2-web-server`：
- en: '![](img/4714c8c1-9b5c-4f49-aafa-094d37a0655f.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4714c8c1-9b5c-4f49-aafa-094d37a0655f.png)'
- en: Once you have a name, you could give it an optional description and you can
    pick whether you want to go with a public or private repository.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个名字，你可以给它一个可选的描述，你可以选择是公共存储库还是私有存储库。
- en: Now private repositories do put you on a $7 plan. I do recommend that if you're
    creating projects with other companies.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在私有存储库会让你选择$7的计划。如果你正在与其他公司创建项目，我建议你选择私有存储库。
- en: In this case though, we're creating pretty simple projects and it doesn't really
    matter if someone else finds the code, so go ahead and use a public repository
    by clicking that option.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不过，在这种情况下，我们正在创建非常简单的项目，如果其他人发现了代码也不会有太大关系，所以继续使用公共存储库的选项。
- en: '![](img/c74b276d-3e8f-4cfd-805b-00fb8ebd3879.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c74b276d-3e8f-4cfd-805b-00fb8ebd3879.png)'
- en: 'Once you have those two things filled out, click on the Create repository button:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你填写好这两个内容，点击创建存储库按钮：
- en: '![](img/becc7ab1-c7f4-4ea0-b896-3bd5e139ece7.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/becc7ab1-c7f4-4ea0-b896-3bd5e139ece7.png)'
- en: 'This is going to get brought to your repository page:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带你到你的存储库页面：
- en: '![](img/d6dead70-af67-4194-a4f1-c2fbe4b76e79.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6dead70-af67-4194-a4f1-c2fbe4b76e79.png)'
- en: It will give you a little setup because currently there is no code to view,
    so it will give you a few instructions depending on which situation you're in.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它会给你一些设置，因为目前没有代码可以查看，所以它会根据你所处的情况给你一些指示。
- en: Setting up the repository
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置存储库
- en: Now, out of the preceding three setup instructions, we don't need the one for
    creating a new repository. We are not going to use the one for importing our code
    from some other URL. What we have is an existing repository and we want to push
    it from the command line.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在前面的三个设置说明中，我们不需要创建新存储库的说明。我们也不会使用从其他URL导入我们的代码的说明。我们已经有一个现有的存储库，我们想要从命令行推送它。
- en: '![](img/f8204b97-d77b-4c95-b35e-91ecf2a17931.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8204b97-d77b-4c95-b35e-91ecf2a17931.png)'
- en: 'We''ll run these two commands from inside our project:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从项目内运行这两个命令：
- en: The first one adds a new remote to our Git repository
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个命令将向我们的Git存储库添加一个新的远程
- en: The second command is going to push it up to GitHub
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个命令将把它推送到GitHub
- en: 'Remotes let Git know which third-party URLs you want to sync up with. Maybe
    I want to push my code to GitHub to communicate with my co-workers. Maybe I also
    want to be able to push up to Heroku to deploy my app. That means you would want
    two remotes. In our case, we''ll just add one, so I''ll copy this URL, move into
    the Terminal, paste it, and hit *enter*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 远程让Git知道你想要同步的第三方URL。也许我想把我的代码推送到GitHub与我的同事进行交流。也许我还想能够推送到Heroku来部署我的应用程序。这意味着你会想要两个远程。在我们的情况下，我们只会添加一个，所以我会复制这个URL，进入终端，粘贴它，然后点击*enter*：
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have our `git remote` added, we can go ahead and run that second
    command. We''ll use the second command extensively throughout the book. In the
    Terminal, we can copy and paste the code for second command, and run it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了`git remote`，我们可以继续运行第二个命令。我们将在整本书中广泛使用第二个命令。在终端中，我们可以复制并粘贴第二个命令的代码，然后运行它：
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/c83f9342-1742-464d-ab08-8fa0a5612345.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c83f9342-1742-464d-ab08-8fa0a5612345.png)'
- en: 'As shown in the preceding screenshot, we can see everything went great. We
    were able to successfully write all of our data up to GitHub, and if we go back
    into the browser and refresh the page, we''re no longer going to see those setup
    instructions. Instead, we''re going to see our repository, kind of like a tree
    view:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们可以看到一切都进行得很顺利。我们成功地将所有数据写入GitHub，如果我们回到浏览器并刷新页面，我们将不再看到那些设置说明。相反，我们将看到我们的存储库，有点像树形视图：
- en: '![](img/fccc9e1b-31ab-493b-9752-9a30649564e1.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fccc9e1b-31ab-493b-9752-9a30649564e1.png)'
- en: Here we can see we have our `server.js` file, which is great. We don't see the
    log file or `node_module` file, which is good, because we ignored that. I have
    my public directory. Everything works really really well. We also have issues
    tracking, Pull requests. You can create a Wiki page which lets you set up instructions
    for your repository. There's a lot of really great features that GitHub has to
    offer. We'll be using just the very basic features.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到我们有`server.js`文件，这很好。我们看不到日志文件或`node_module`文件，这很好，因为我们忽略了它。我有我的公共目录。一切都运行得非常非常好。我们还有问题跟踪，拉取请求。您可以创建一个Wiki页面，用于为存储库设置说明。GitHub有很多非常棒的功能。我们将只使用最基本的功能。
- en: 'On our repository, we can see we have one commit and if we click on that one
    commit button, you can actually go to the commits page and here we see the initial
    commit message that we typed. We made that commit in the previous section:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的存储库中，我们可以看到我们有一个提交，如果我们点击那个提交按钮，实际上可以进入提交页面，在这里我们可以看到我们输入的初始提交消息。我们在上一节中进行了提交：
- en: '![](img/ebb35b17-82b5-4d6e-aef1-1d0cce8dc53d.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebb35b17-82b5-4d6e-aef1-1d0cce8dc53d.png)'
- en: This is going to let us keep track of all our code, revert if we make unwanted
    changes, and manage our repository. Now that we have our code pushed up, we are
    done.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我们跟踪所有我们的代码，如果我们进行了不需要的更改，可以回滚，并管理我们的存储库。现在我们的代码已经推送上去，我们完成了。
- en: Deploying the node app to the Web
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将node应用程序部署到Web
- en: In this section, you'll deploy your Node app live to the Web using Heroku. By
    the end of the section, you'll have the URL you can give anybody and they'll be
    able to go to that URL in their browser to view the application. We'll do this
    via Heroku.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用Heroku将您的Node应用程序实时部署到Web。在本节结束时，您将获得一个URL，您可以将其提供给任何人，他们将能够在其浏览器中访问该URL以查看应用程序。我们将通过Heroku完成这一点。
- en: Heroku is a website. It's a web app for managing web applications that are hosted
    in the cloud. It's a really great service. They make it almost effortless to create
    new apps, deploy your apps, update apps, and add cool add-on-things such as logging
    and error tracking, all of that is built in. Now Heroku, like GitHub, does not
    require a credit card to sign up and there is a free tier, which we'll use. They
    have paid plans for just about everything, but we can get away with the free tier
    for everything we'll do in this section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是一个网站。它是一个用于管理托管在云中的Web应用程序的Web应用程序。这是一个非常棒的服务。他们几乎可以毫不费力地创建新应用程序，部署您的应用程序，更新应用程序，并添加一些很酷的附加功能，如日志记录和错误跟踪，所有这些都是内置的。现在Heroku，就像GitHub一样，不需要信用卡即可注册，并且有免费的套餐，我们将使用。他们为几乎所有功能提供付费计划，但我们可以使用免费套餐来完成本节中的所有操作。
- en: Installing Heroku command-line tools
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Heroku命令行工具
- en: 'To kick things off, we''ll open up the browser and go to [heroku.com](https://www.heroku.com/).
    Here we can go ahead and sign up for a new account. Take a quick moment to either
    log in to your existing one or sign up for a new one. Once log in, it''ll show
    you the dashboard. Now your dashboard will look something like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将打开浏览器并转到[heroku.com](https://www.heroku.com/)。在这里，我们可以继续注册一个新帐户。花点时间要么登录您现有的帐户，要么注册一个新帐户。一旦登录，它会显示您的仪表板。现在您的仪表板将看起来像这样：
- en: '![](img/87c811c3-1195-476c-abc7-5007a55e5608.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87c811c3-1195-476c-abc7-5007a55e5608.png)'
- en: Although there might be a greeting telling you to create a new application,
    which you can ignore. I have a bunch of apps. You might not have these. That is
    perfectly fine.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能会有一个问候语告诉您创建一个新应用程序，但您可以忽略。我有很多应用程序。您可能没有这些，这完全没问题。
- en: The next thing we'll do is install the Heroku command-line tools. This will
    let us create apps, deploy apps, open apps, and do all sorts of really cool stuff
    from the Terminal, without having to come into the web app. That will save us
    time and make development a lot easier. We can grab the download by going to [toolbelt.heroku.com](https://devcenter.heroku.com/articles/heroku-cli).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是安装Heroku命令行工具。这将让我们能够在终端中创建应用程序，部署应用程序，打开应用程序，并且可以在终端中进行各种非常酷的操作，而不必进入Web应用程序。这将节省我们的时间并使开发变得更加容易。我们可以通过访问[toolbelt.heroku.com](https://devcenter.heroku.com/articles/heroku-cli)来获取下载。
- en: '![](img/d50fe3e5-ab59-4355-aa29-c8d5a32fa200.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d50fe3e5-ab59-4355-aa29-c8d5a32fa200.png)'
- en: Here we're able to grab the installer for whatever operating system, you happen
    to be running on. So, let's start the download. It's a really small download so
    it should happen pretty quickly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以获取适用于您正在运行的任何操作系统的安装程序。让我们开始下载。这是一个非常小的下载，所以应该很快。
- en: 'Once it''s done, we can go ahead and run through the process:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以继续进行以下步骤：
- en: '![](img/ff34b500-7688-4a9c-bd58-394173e8f79e.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff34b500-7688-4a9c-bd58-394173e8f79e.png)'
- en: This is a simple installer where you just click on Install. There is no need
    to customize anything. You don't have to enter any specific information about
    your Heroku account. Let's go ahead and complete the installer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的安装程序，您只需点击“安装”。无需自定义任何内容。您不必输入关于您的Heroku帐户的任何特定信息。让我们继续完成安装程序。
- en: '![](img/e96706f0-735c-483d-b391-77c533ded72b.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e96706f0-735c-483d-b391-77c533ded72b.png)'
- en: This will give us a new command from the Terminal that we can execute. Before
    we can do that, we do have to log in locally in the Terminal and that's exactly
    what we'll do next.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一个新的终端命令，我们可以执行。在我们执行之前，我们必须在终端中本地登录，这正是我们接下来要做的事情。
- en: Log in to Heroku account locally
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地登录Heroku帐户
- en: 'Now we will start off the Terminal. If you already have it running, you might
    need to restart it in order for your operating system to recognize the new command.
    You can test that it got installed properly by running the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将启动终端。如果您已经运行它，您可能需要重新启动它，以便您的操作系统识别新的命令。您可以通过运行以下命令来测试它是否已正确安装：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run this command, you''ll see that it''s installing the CLI for the
    first time and then we''ll get all the help information. This will tell us what
    commands we have access to and exactly how they work:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，您将看到它正在首次安装CLI，然后我们将获得所有的帮助信息。这将告诉我们我们可以访问哪些命令以及它们的确切工作方式：
- en: '![](img/df251077-46ab-48ec-848f-9c501116a932.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df251077-46ab-48ec-848f-9c501116a932.png)'
- en: 'Now we will need to log in to the Heroku account locally. This process is pretty
    simple. In the preceding code output, we have all of the commands available and
    one of them happens to be login. We can run `heroku login` just like this to start
    the process:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在本地登录Heroku账户。这个过程非常简单。在前面的代码输出中，我们有所有可用的命令，其中之一恰好是登录。我们可以像这样运行`heroku
    login`来开始这个过程：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I''ll run the `login` command and now we just use the email and password that
    we had set up before:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我将运行`login`命令，现在我们只需使用之前设置的电子邮件和密码：
- en: '![](img/7d1db6e9-234f-4622-b73e-ff0a59a8d0ea.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d1db6e9-234f-4622-b73e-ff0a59a8d0ea.png)'
- en: 'I''ll type in my email and password. Typing for Password is hidden because
    it''s secure. And when I do that you see Logged in as garyngreig@gmail.com shows
    up and this is fantastic:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我将输入我的电子邮件和密码。密码输入是隐藏的，因为它是安全的。当我这样做时，您会看到已登录为garyngreig@gmail.com显示出来，这太棒了：
- en: '![](img/98bda0a2-43c2-455e-a716-b413419aafc0.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98bda0a2-43c2-455e-a716-b413419aafc0.png)'
- en: Now we're logged in and we're able to successfully communicate between our machine's
    command line and the Heroku servers. This means we can get started creating and
    deploying applications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经登录，并且能够成功地在我们的机器命令行和Heroku服务器之间进行通信。这意味着我们可以开始创建和部署应用程序。
- en: Getting SSH key to Heroku
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取SSH密钥到Heroku
- en: 'Now before going ahead, we''ll use the `clear` command to clear the Terminal
    output and get our SSH key on Heroku, kind of like what we did with GitHub, only
    this time we can do it via the command line. So it''s going to be a lot easier.
    In order to add our local keys to Heroku, we''ll run the `heroku keys:add` command.
    This will scan our SSH directory and add the key up:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将使用`clear`命令清除终端输出，并将我们的SSH密钥放在Heroku上，有点像我们在GitHub上所做的，只是这次我们可以通过命令行来完成。所以这将更容易。为了将我们的本地密钥添加到Heroku，我们将运行`heroku
    keys:add`命令。这将扫描我们的SSH目录并添加密钥：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here you can see it found a key the `id_rsa.pub` file: Would you like to upload
    it to Heroku?.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到它找到了`id_rsa.pub`文件的密钥：您想将其上传到Heroku吗？。
- en: '![](img/dc07ba5a-58fb-4d94-8add-6f48a20f0abe.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc07ba5a-58fb-4d94-8add-6f48a20f0abe.png)'
- en: 'Type `Yes` and hit *enter*:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`Yes`并按*enter*：
- en: '![](img/8557ad60-5ff6-47f9-b610-2af46bc03f0f.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8557ad60-5ff6-47f9-b610-2af46bc03f0f.png)'
- en: 'Now we have our key uploaded. That is all it took. Much easier than it was
    to configure with GitHub. From here, we can use the `heroku keys` command to print
    all the keys currently on our account:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经上传了我们的密钥。就是这么简单。比配置GitHub要容易得多。从这里开始，我们可以使用`heroku keys`命令来打印当前在我们账户上的所有密钥：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/5f26c53d-81eb-455c-8a04-6c36a39ac379.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f26c53d-81eb-455c-8a04-6c36a39ac379.png)'
- en: 'We could always remove them using `heroku keys:remove` command followed by
    the email related to that key. In this case, we''ll keep the Heroku key that we
    have. Next up, we can test our connection using SSH with the `v` flag and `git@heroku.com`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以使用`heroku keys:remove`命令删除它们，后面跟着与该密钥相关的电子邮件。在这种情况下，我们将保留我们拥有的Heroku密钥。接下来，我们可以使用`v`标志和`git@heroku.com`测试我们的连接使用SSH：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will communicate with the Heroku servers:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与Heroku服务器通信：
- en: '![](img/8663a61d-95a4-452e-9a8e-5c7ebd46d3f2.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8663a61d-95a4-452e-9a8e-5c7ebd46d3f2.png)'
- en: 'As shown, we can see it''s asking that same question: The authenticity of the
    host ''heroku.com'' can''t be established, Are you sure you want to continue connecting?
    Type `Yes`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们可以看到它正在询问同样的问题：主机'heroku.com'的真实性无法确定，您确定要继续连接吗？输入`Yes`。
- en: 'You will see the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](img/f1b7981c-4ee5-4b44-bb73-694e952531d4.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1b7981c-4ee5-4b44-bb73-694e952531d4.png)'
- en: Now when you run that command, you'll get a lot of cryptic output. What you're
    looking for is authentication succeeded and then public key in parentheses. If
    things did not go well, you'll see the permission denied message with public key
    in parentheses. In this case, the authentication was successful, which means we
    are good to go. I'll run clear again, clearing the Terminal output.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您运行该命令时，您将得到大量的加密输出。您要寻找的是认证成功，然后在括号中的公钥。如果事情没有进行顺利，您将看到权限被拒绝的消息，括号中有公钥。在这种情况下，认证是成功的，这意味着我们可以继续。我将再次运行clear，清除终端输出。
- en: Setting up in the application code for Heroku
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Heroku的应用程序代码中设置
- en: Now we can turn our attention towards the application code because before we
    can deploy to Heroku, we will need to make two changes to the code. These are
    things that Heroku expects your app to have in place in order to run properly
    because Heroku does a lot of things automatically, which means you have to have
    some basic stuff set up for Heroku to work. It's not too complex—some really simple
    changes, a couple one-liners.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以把注意力转向应用程序代码，因为在我们可以部署到Heroku之前，我们需要对代码进行两处更改。这些是Heroku希望您的应用程序具备的东西，以便正常运行，因为Heroku会自动执行很多操作，这意味着您必须为Heroku设置一些基本的东西。这并不复杂——一些非常简单的更改，一些一行代码。
- en: Changes in the server.js file
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`server.js`文件中的更改
- en: 'First up in the `server.js` file down at the very bottom of the file, we have
    the port and our `app.listen` statically coded inside `server.js`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`server.js`文件的最底部，我们有端口和我们的`app.listen`静态编码在`server.js`中：
- en: '[PRE23]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We need to make this port dynamic, which means we want to use a variable. We'll
    be using an environment variable that Heroku is going to set. Heroku will tell
    your app which port to use because that port will change as you deploy your app,
    which means that we'll be using that environment variable so we don't have to
    swap out our code every time we want to deploy.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使这个端口动态化，这意味着我们想要使用一个变量。我们将使用Heroku将设置的环境变量。Heroku将告诉您的应用程序使用哪个端口，因为随着部署应用程序，该端口将发生变化，这意味着我们将使用该环境变量，这样我们就不必每次部署时都要更换我们的代码。
- en: With environment variables, Heroku can set a variable on the operating system.
    Your Node app can read that variable and it can use it as the port. Now all machines
    have environment variables. You can actually view the ones on your machine by
    running the `env` command on Linux or macOS or the `set` command on Windows.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境变量，Heroku可以在操作系统上设置一个变量。您的Node应用程序可以读取该变量，并将其用作端口。现在所有的机器都有环境变量。您实际上可以通过在Linux或macOS上运行`env`命令或在Windows上运行`set`命令来查看您的机器上的环境变量。
- en: 'What you''ll get when you do that is a really long list of key-value pairs,
    and this is all environment variables are:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当您这样做时，您将得到一个非常长的键值对列表，这就是所有环境变量的内容：
- en: '![](img/3a25bfd6-231b-4e72-a147-c99bec678e14.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a25bfd6-231b-4e72-a147-c99bec678e14.png)'
- en: Here, we have a LOGNAME environment variable set to Andrew. I have a HOME environment
    variable set to my home directory, all sorts of environment variables throughout
    my operating system.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我有一个LOGNAME环境变量设置为Andrew。我有一个HOME环境变量设置为我的主目录，还有各种各样的环境变量在我的操作系统中。
- en: 'One of these that Heroku is going to set is called `PORT`, which means we need
    to go ahead and grab that `port` variable and use it in `server.js` instead of
    3000\. Up at the very top of the `server.js` file, we''d to make a constant called
    `port`, and this will store the port that we''ll use for the app:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku将设置其中一个叫做`PORT`的变量，这意味着我们需要去获取那个`port`变量，并在`server.js`中使用它，而不是3000。在`server.js`文件的顶部，我们需要创建一个叫做`port`的常量，这将存储我们将用于应用程序的端口：
- en: '[PRE24]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the first thing we''ll do is grab a port from `process.env`. The `process.env`
    is an object that stores all our environment variables as key-value pairs. We''re
    looking for one that Heroku is going to set called `PORT`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的第一件事是从`process.env`中获取一个端口。`process.env`是一个存储所有环境变量的键值对的对象。我们正在寻找一个Heroku将设置的叫做`PORT`的变量：
- en: '[PRE25]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is going to work great for Heroku, but when we run the app locally, the
    `PORT` environment variable is not going to exist, so we''ll set a default using
    the OR (`||`) operator in this statement. If `process.env.port` does not exist,
    we''ll set port equal to `3000` instead:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这对Heroku来说将会很好，但是当我们在本地运行应用程序时，`PORT`环境变量将不存在，因此我们将使用这个语句中的OR (`||`)运算符来设置默认值。如果`process.env.port`不存在，我们将把端口设置为`3000`：
- en: '[PRE26]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have an app that''s configured to work with Heroku and to still run
    locally, just like it did before. All we have to do is take the `PORT` variable
    and use that in `app.listen` instead of `3000`. As shown, I''m going to reference
    `port` and inside our message, I''ll swap it out for template strings and now
    I can replace `3000` with the injected port variable, which will change over time:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个配置为与Heroku一起工作并在本地运行的应用程序，就像以前一样。我们所要做的就是取`PORT`变量，并在`app.listen`中使用它，而不是`3000`。如所示，我将引用`port`，并在我们的消息中，我将用模板字符串替换它，现在我可以用注入的端口变量替换`3000`，这将随时间变化：
- en: '[PRE27]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this in place, we have now fixed the first problem with our app. I''ll
    now run `node server.js` from the Terminal, like we did in the previous chapter:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在已经解决了应用程序的第一个问题。我现在将从终端中运行`node server.js`，就像我们在上一章中做的那样：
- en: '[PRE28]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We still get the exact same message: Server is up on port 3000, so your app
    will still works locally as expected:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会得到完全相同的消息：服务器在端口3000上运行，所以您的应用程序在本地仍然可以正常工作：
- en: '![](img/74024ce3-1f81-4925-8a6a-b45c66f20a81.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74024ce3-1f81-4925-8a6a-b45c66f20a81.png)'
- en: Changes in the package.json file
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在package.json文件中的更改
- en: Next up, we have to specify a script in `package.json`. Inside `package.json`,
    you might have noticed we have a `scripts` object, and in there we have a `test`
    script.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在`package.json`中指定一个脚本。在`package.json`中，您可能已经注意到我们有一个`scripts`对象，在其中我们有一个`test`脚本。
- en: 'This gets set by default for npm:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是npm默认设置的：
- en: '![](img/a1ceea77-ec80-431a-b609-5934b8e619c4.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1ceea77-ec80-431a-b609-5934b8e619c4.png)'
- en: We can create all sorts of scripts inside the `scripts` object that do whatever
    we like. A script is nothing more than a command that we run from the Terminal,
    so we could take this command, `node server.js`, and turn it into a script instead,
    and that's exactly what we're going to do.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`scripts`对象内创建各种脚本，做任何我们喜欢的事情。脚本只不过是我们从终端运行的命令，所以我们可以把这个命令`node server.js`转换成一个脚本，这正是我们要做的。
- en: 'Inside the `scripts` object, we''ll add a new script. The script needs to be
    called `start`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scripts`对象内，我们将添加一个新的脚本。脚本需要被命名为`start`：
- en: '![](img/b838a47f-aff9-48e1-a2a9-2ea8270104de.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b838a47f-aff9-48e1-a2a9-2ea8270104de.png)'
- en: 'This is a very specific, built-in script and we''ll set it equal to the command
    that starts our app. In this case, it will be `node server.js`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常特定的内置脚本，我们将把它设置为启动我们应用程序的命令。在这种情况下，它将是`node server.js`：
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is necessary because when Heroku tries to start our app, it will not run
    Node with your file name because it doesn't know what your file name is called.
    Instead, it will run the start script and the start script will be responsible
    for doing the proper thing; in this case, booting up that server file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必要的，因为当Heroku尝试启动我们的应用程序时，它不会使用您的文件名运行Node，因为它不知道您的文件名叫什么。相反，它将运行启动脚本，启动脚本将负责执行正确的操作；在这种情况下，启动服务器文件。
- en: 'Now we can run our app using that `start` script from the Terminal by using
    the following command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用终端中的`start`脚本来运行我们的应用程序，使用以下命令：
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When I do that, we get a little output related to npm and then we get Server
    is up on port 3000, and if we visit the app in the browser, everything works exactly
    as it did in the previous chapter:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当我这样做时，我们会得到与npm相关的一些输出，然后我们会得到服务器在端口3000上运行的消息，如果我们在浏览器中访问应用程序，一切都与上一章中完全相同：
- en: '![](img/20eb655f-3457-44f5-a41b-7ec954e7ce69.png)![](img/12aa3060-6ae5-4fd9-92ca-da30a03042bd.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20eb655f-3457-44f5-a41b-7ec954e7ce69.png)![](img/12aa3060-6ae5-4fd9-92ca-da30a03042bd.png)'
- en: 'The big difference is that we are now ready for Heroku. We could also run the
    test script using from the Terminal `npm test`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别是我们现在已经准备好使用Heroku了。我们也可以使用终端运行`npm test`来运行测试脚本：
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we have no tests specified and that is expected:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们没有指定任何测试，这是预期的：
- en: '![](img/504c1768-8ee0-44d9-aba9-cbf61852fef3.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/504c1768-8ee0-44d9-aba9-cbf61852fef3.png)'
- en: Making a commit in Heroku
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Heroku中进行提交
- en: 'The next step in the process will be to make the commit and then we can finally
    start getting it up on the Web. From the Terminal, we''ll use some of the Git
    commands we explored earlier in this chapter. First up, `git status`. When we
    run `git status`, we have something a little new:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的下一步将是进行提交，然后我们最终可以开始将其上载到Web上。从终端，我们将使用本章前面探讨过的一些Git命令。首先是`git status`。当我们运行`git
    status`时，我们会看到一些新的东西：
- en: '![](img/63fd7620-9bac-46ac-bf81-1809739a6d38.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63fd7620-9bac-46ac-bf81-1809739a6d38.png)'
- en: Instead of new files, we have modified files here as shown in the code output
    here. We have a modified `package.json` file and we have a modified `server.js`
    file. These are not going to be committed if we were to run a `git commit` just
    yet; we still have to use `git add`. What we'll do is run `git add` with the dot
    as the next argument. Dot is going to add every single thing showing up and get
    status to the next commit.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的代码输出中，我们不是有新文件，而是有修改过的文件。我们有一个修改过的`package.json`文件和一个修改过的`server.js`文件。如果我们现在运行`git
    commit`，这些将不会被提交；我们仍然需要使用`git add`。我们将运行`git add`并使用点作为下一个参数。点将添加所有显示的每一样东西，并将状态添加到下一个提交。
- en: 'Now I only recommend using the syntax of everything you have listed in the
    `Changes not staged for commit` header. These are the things you actually want
    to commit, and in our case, that is indeed what we want. If I run `git add` and
    then a rerun `git status`, we can now see what is going to be committed next,
    under the Changes to be committed header:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我只建议使用`Changes not staged for commit`标题中列出的所有内容的语法。这些是您实际想要提交的内容，在我们的情况下，这确实是我们想要的。如果我运行`git
    add`，然后重新运行`git status`，我们现在可以看到下一个将要提交的内容，在`Changes to be committed`标题下：
- en: '![](img/40663077-fbf3-49af-b2a6-b10557614460.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40663077-fbf3-49af-b2a6-b10557614460.png)'
- en: Here we have our `package.json` file and the `server.js` file. Now we can go
    ahead and make that commit.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有我们的`package.json`文件和`server.js`文件。现在我们可以继续进行提交。
- en: 'I''ll run a `git commit` command with the `m` flag so we can specify our message,
    and a good message for this commit would be something like `Setup start script
    and heroku port`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我将运行`git commit`命令，并使用`m`标志来指定我们的消息，对于这个提交，一个好的消息可能是`设置启动脚本和heroku端口`：
- en: '[PRE32]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we can go ahead and run that command, which will make the commit.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续运行该命令，这将进行提交。
- en: 'Now we can go ahead and push that up to GitHub using the `git push` command,
    and we can leave off the `origin` remote because the origin is the default remote.
    I''ll go ahead and run the following command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`git push`命令将其推送到GitHub，我们可以省略`origin`远程，因为origin是默认远程。我将继续运行以下命令：
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will push it up to GitHub, and now we are ready to actually create the
    app, push our code up, and view it over in the browser:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把它推送到GitHub，现在我们准备实际创建应用程序，将我们的代码推送上去，并在浏览器中查看它：
- en: '![](img/11cc1707-de4f-48ff-9f19-e019aa29aceb.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11cc1707-de4f-48ff-9f19-e019aa29aceb.png)'
- en: Running the Heroku create command
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Heroku创建命令
- en: 'The next step in the process will be to run a command called `heroku create`
    from the Terminal. `heroku create` needs to get executed from inside your application:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的下一步是从终端运行一个名为`heroku create`的命令。`heroku create`需要在应用程序内部执行：
- en: '[PRE34]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Just like we run our Git commands, when I run `heroku create`, a couple things
    are going to happen:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们运行Git命令一样，当我运行`heroku create`时，会发生一些事情：
- en: First up, it's going to make a real new application over in the Heroku web app
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它将在Heroku Web应用程序中创建一个真正的新应用程序
- en: It's also going to add a new remote to your Git repository
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还将向您的Git存储库添加一个新的远程
- en: 'Now remember we have an origin remote, which points to our GitHub repository.
    We''ll have a Heroku remote, which points to our Heroku Git repository. When we
    deploy to the Heroku Git repository, Heroku is going to see that. It will take
    the changes and it will deploy them to the Web. When we run Heroku create, all
    of that happens:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在记住我们有一个指向我们GitHub存储库的origin远程。我们将有一个指向我们Heroku Git存储库的Heroku远程。当我们部署到Heroku
    Git存储库时，Heroku将会看到。它将接受更改并将其部署到Web上。当我们运行Heroku create时，所有这些都会发生：
- en: '![](img/0ad124db-be01-4728-bdc8-0c3db0ef11b5.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ad124db-be01-4728-bdc8-0c3db0ef11b5.png)'
- en: 'Now we do still have to push up to this URL in order to actually do the deploying
    process, and we can do that using `git push` followed by `heroku`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们仍然需要将其推送到这个URL，以实际执行部署过程，我们可以使用`git push`后跟`heroku`来完成：
- en: '[PRE35]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The brand new remote was just added because we ran `heroku create`. Now pushing
    it this time around will go through the normal process. You'll then start seeing
    some logs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚添加的全新远程是因为我们运行了`heroku create`。现在这次推送将按照正常流程进行。然后您将开始看到一些日志。
- en: 'These are logs coming back from Heroku letting you know how your app is deploying.
    It''s going through the entire process, showing you what happens along the way.
    This will take about 10 seconds and at the very end we have a success message—Verifying
    deploy... done:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是来自Heroku的日志，让您知道您的应用程序是如何部署的。它正在进行整个过程，向您展示沿途发生了什么。这将花费大约10秒，在最后我们有一个成功的消息—验证部署...完成：
- en: '![](img/a1e756eb-5400-47c9-b211-2796c92b01b1.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1e756eb-5400-47c9-b211-2796c92b01b1.png)'
- en: 'It also verified that the app was deployed successfully and that did indeed
    pass. From here we actually have a URL we can visit ([https://sleepy-retreat-32096.herokuapp.com/](https://sleepy-retreat-32096.herokuapp.com/)).
    We can take it, copy it, and paste it in the browser. What I''ll do instead is
    use the following command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 它还验证了应用程序成功部署，并且确实通过了。从这里，我们实际上有一个可以访问的URL（[https://sleepy-retreat-32096.herokuapp.com/](https://sleepy-retreat-32096.herokuapp.com/)）。我们可以复制它，粘贴到浏览器中。我将使用以下命令：
- en: '[PRE36]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `heroku open` will open up the Heroku app in the default browser. When
    I run this, it will switch over to Chrome and we get our application showing up
    just as expected:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku open`将在默认浏览器中打开Heroku应用程序。当我运行这个命令时，它会切换到Chrome，我们的应用程序会如预期般显示出来：'
- en: '![](img/16c3c634-0e1b-4641-9328-a913db1d08a0.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16c3c634-0e1b-4641-9328-a913db1d08a0.png)'
- en: We can switch between pages and everything works just like it did locally. Now
    we have a URL and this URL was given to us by Heroku. This is the default way
    Heroku generates app URLs. If you have your own domain registration company, you
    can go ahead and configure its DNS to point to this application. This will let
    you use a custom URL for your Heroku app. You'll have to refer to the specific
    instructions for your domain registrar in order to do that, but it can indeed
    be done.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在页面之间切换，一切都像在本地一样工作。现在我们有一个URL，这个URL是由Heroku给我们的。这是Heroku生成应用程序URL的默认方式。如果您有自己的域名注册公司，您可以继续配置其DNS以指向此应用程序。这将让您为Heroku应用程序使用自定义URL。您将不得不参考您的域名注册商的具体说明来做到这一点，但这确实是可以做到的。
- en: Now that we have this in place, we have successfully deployed our Node applications
    live to Heroku, and this is just fantastic. In order to do this, all we had to
    do is make a commit to change our code and push it up to a new Git remote. It
    could not be easier to deploy our code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一步，成功地将我们的Node应用程序部署到Heroku上，并且这真是太棒了。为了做到这一点，我们所要做的就是提交更改我们的代码并将其推送到一个新的Git远程。部署我们的代码再也不会更容易了。
- en: 'You can also manage your application by going back over to the Heroku dashboard.
    If you give it a refresh, you should see that brand new URL somewhere on the dashboard.
    Remember mine was sleepy retreat. Yours is going to be something else. If I click
    on the sleepy retreat, I can view the app page:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过转到Heroku仪表板来管理您的应用程序。如果您刷新一下，您应该会在仪表板的某个地方看到全新的URL。记住我的是sleepy retreat。你的会是其他的。如果我点击sleepy
    retreat，我就可以查看应用程序页面：
- en: '![](img/db13379f-d9eb-44f0-9b39-6dd4bc8c2f3b.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db13379f-d9eb-44f0-9b39-6dd4bc8c2f3b.png)'
- en: Here we can do a lot of configuration. We can manage Activity and Access so
    we can collaborate with others. We have metrics, we have Resources, all sorts
    of really cool stuff. With this in place, we are now done with our basic deploying
    section.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以进行很多配置。我们可以管理活动和访问权限，这样我们就可以与他人合作。我们有指标，我们有资源，各种真正酷的东西。有了这个，我们现在已经完成了基本的部署部分。
- en: In the next section, your challenge will be to go through that process again.
    You'll add some changes to the Node app. You'll commit them, deploy them, and
    view them live in the Web. We'll get started by creating the local changes. That
    means I'll register a new URL right here using `app.get`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您的挑战将是再次经历这个过程。您将对Node应用程序进行一些更改。您将提交它们，部署它们，并在Web上实时查看它们。我们将首先创建本地更改。这意味着我将在这里使用`app.get`注册一个新的URL。
- en: We'll create a new page/projects, which is why I have that as the route for
    my HTTP get handler. Inside the second argument, we can specify our `callback`
    function, which will get called with request and response, and like we do for
    the other routes above, the root route and our about route, we'll be calling `response.render`
    to render our template. Inside the render arguments list, we'll provide two.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的页面/projects，这就是为什么我将其作为我的HTTP get处理程序的路由。在第二个参数中，我们可以指定我们的`callback`函数，它将被调用并传入请求和响应，就像我们对上面的其他路由，根路由和about路由一样，我们将调用`response.render`来渲染我们的模板。在渲染参数列表中，我们将提供两个。
- en: The first one will be the file name. The file doesn't exist, but we can still
    go ahead and call `render`. I'll call it `projects.hbs`, then we can specify the
    options we want to pass to the template. In this case, we'll set page title, setting
    it equal to `Projects` with a capital P. Excellent! Now with this in place, the
    server file is all done. There are no more changes there.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将是文件名。文件不存在，但我们仍然可以继续调用`render`。我会称它为`projects.hbs`，然后我们可以指定要传递给模板的选项。在这种情况下，我们将设置页面标题，将其设置为`Projects`，P要大写。太棒了！现在，服务器文件已经全部完成了。那里不会再有更多的更改了。
- en: What I'll do is go ahead and go to the `views` directory, creating a new file
    called `projects.hbs`. In here, we'll be able to configure our template. To kick
    things off, I'm going to copy the template from the about page. Since it's really
    similar, I'll copy it. Close about, paste it into projects, and I'm just going
    to change this text to project page text would go here. Then we can save the file
    and make our last change.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续前往`views`目录，创建一个名为`projects.hbs`的新文件。在这里，我们将能够配置我们的模板。首先，我将从about页面复制模板。因为它非常相似，我会复制它。关闭about，粘贴到projects，然后我只会更改这个文本为项目页面文本将在这里。然后我们可以保存文件并进行最后的更改。
- en: The last thing we want to do is update the header. We now have a brand new projects
    page that lives at `/projects`. So we'll want to go ahead and add that to the
    header links list. Right here, I'll create a new paragraph tag and then I'll make
    an anchor tag. The text for the link will be `Projects` with a capital P and the
    `href`, which is the URL to visit when that link is clicked. We'll set that equal
    to `/projects`, just like we did for about, where we set it equal to `/about`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的最后一件事是更新页眉。我们现在有一个位于`/projects`的全新项目页面。所以我们要继续并将其添加到页眉链接列表中。在这里，我会创建一个新的段落标签，然后我会创建一个锚标签。链接的文本将是`Projects`，P要大写，`href`是链接被点击时要访问的URL。我们将把它设置为`/projects`，就像我们为about设置为`/about`一样。
- en: Now that we have this in place, all our changes are done and we are ready to
    test things out locally. I'll fire up the app locally using Node with `server.js`
    as the file. To start, we're up on localhost 3000\. So over in the browser, I
    can move to the localhost tab, as opposed to the Heroku app tab, and click on
    Refresh. Right here we have Home, which goes to home, we have About which goes
    to about, and we have Projects which does indeed go to `/projects`, rendering
    the projects page. Project page text would go here. With this in place we're now
    done locally.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一切，所有的更改都已经完成，我们准备在本地测试。我将使用`server.js`文件在本地启动应用程序。首先，我们在localhost
    3000上启动。因此，在浏览器中，我可以切换到localhost标签页，而不是Heroku应用标签页，然后单击刷新。在这里，我们有主页，指向主页，我们有关于，指向关于，我们有项目，确实指向`/projects`，呈现项目页面。项目页面的文本将在这里。有了这个，我们现在在本地完成了。
- en: 'We have the changes, we''ve tested them, now it''s time to go ahead and make
    that commit. That will happen over inside the Terminal. I''ll shut down the server
    and run Git status. This will show me all the changes to my repository as of the
    last commit. I have two modified files: the server file and the header file, and
    I have my brand new projects file. All of this looks great. I want to add all
    of this to the next commit, so I can use a Git add with the `.` to do just that.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做出了更改，已经测试过了，现在是时候进行提交了。这将在终端内进行。我将关闭服务器并运行Git状态。这将显示我仓库中自上次提交以来的所有更改。我有两个修改过的文件：服务器文件和标题文件，还有我的全新项目文件。所有这些看起来都很好。我想将所有这些添加到下一个提交中，所以我可以使用`Git
    add .`来做到这一点。
- en: Now before I actually make the commit, I do like to test that the proper things
    got added by running Git status. Right here I can see my changes to be committed
    are showing up in green. Everything looks great. Next up, we'll run a Git commit
    to actually make the commit. This is going to save all of the changes into the
    Git repository. A message for this one would be something like adding a project
    page.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我实际进行提交之前，我确实想通过运行Git状态来测试是否添加了正确的内容。在这里，我可以看到要提交的更改显示为绿色。一切看起来都很好。接下来，我们将运行Git提交来实际进行提交。这将把所有更改保存到Git仓库中。这次提交的消息可能是添加一个项目页面。
- en: With a commit made, the next thing you needed to do was push it up to GitHub.
    This will back our code up and let others collaborate on it. I'll use Git push
    to do just that. Remember we can leave off the origin remote as origin is the
    default remote, so if you leave off a remote it'll just use that anyway.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 提交完成后，下一步需要做的是将其推送到GitHub。这将备份我们的代码并让其他人进行协作。我将使用Git push来做到这一点。记住，我们可以省略origin远程，因为origin是默认远程，所以如果你省略远程，它仍然会使用默认的远程。
- en: With our GitHub repository updated, the last thing to do is deploy to Heroku
    and we do that by pushing up the Git repository, using Git push, to the Heroku
    remote. When we do this, we get our long list of logs as the Heroku server goes
    through the process of installing our npm modules, building the app, and actually
    deploying it. Once it's done, we'll get brought back to the Terminal like we are
    here, and then we can open up the URL in the browser. Now I can copy it from here
    or run Heroku open. Since I already have a tab open with the URL in place, I'll
    simply give it a refresh. Now you might have a little delay as you refresh your
    app. Sometimes starting up the app right after a new app was deployed can take
    about 10 to 15 seconds. That will only happen as you first visit it. Other times
    where you click on the Refresh button, it should reload instantly.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了我们的GitHub仓库，最后要做的事情就是部署到Heroku，我们可以通过Git push将Git仓库推送到Heroku远程。当我们这样做时，我们会得到一长串日志，因为Heroku服务器正在安装我们的npm模块，构建应用程序，并实际部署它。一旦完成，我们将回到终端，然后可以在浏览器中打开URL。现在我可以从这里复制它，或者运行Heroku
    open。由于我已经在浏览器中打开了URL，我只需刷新一下。现在你可能会在刷新应用程序时遇到一些延迟。有时，在部署新应用程序后立即启动应用程序可能需要大约10到15秒。这只会在第一次访问时发生。其他时候，当你点击刷新按钮时，它应该立即重新加载。
- en: Now we have the projects page and if I visit it, everything looks awesome. The
    navbar is working great and the projects page is indeed rendering at `/projects`.
    With this in place, we are now done. We've gone through the process of adding
    a new feature, testing it locally, making a Git commit, pushing it up to GitHub,
    and deploying it to Heroku. We now have a workflow for building real-world web
    applications using Node.js. This also brings a close to this section.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了项目页面，如果我访问它，一切看起来都很棒。导航栏运行良好，项目页面确实在`/projects`处呈现。有了这个，我们现在完成了。我们已经完成了添加新功能、在本地测试、进行Git提交、推送到GitHub并部署到Heroku的过程。现在我们有了一个使用Node.js构建真实网络应用的工作流程。这也标志着本节的结束。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You also learned about Git, GitHub, and Heroku. These are the tools I prefer
    to use when I'm creating applications. I like to use Git because it's super popular.
    It's basically the only choice these days. I like to use GitHub because it has
    a great user interface. It has a ton of awesome features and pretty much everyone
    else is using it too. There's a great community. And I like to use Heroku because
    it is just dead simple to deploy new versions of your application. You can swap
    out any of these tools with any other tools. You can use services such Amazon
    Web Services to host. You could use Bitbucket as your GitHub alternative. These
    are perfectly fine solutions. All that really matters is you have some tools that
    are working for you, you have a Git repository backed up somewhere, whether it's
    GitHub or Bitbucket, and you have an easy way to deploy so you can make changes
    quickly and get them out to your users fast.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你也学到了Git、GitHub和Heroku。这些是我在创建应用程序时喜欢使用的工具。我喜欢使用Git，因为它非常流行。这基本上是当今唯一的选择。我喜欢使用GitHub，因为它有一个很棒的用户界面。它拥有大量令人惊叹的功能，几乎每个人都在使用它。有一个很棒的社区。我喜欢使用Heroku，因为它非常简单，可以轻松部署应用程序的新版本。你可以用其他工具替换这些工具。你可以使用亚马逊网络服务等服务进行托管。你可以使用Bitbucket作为GitHub的替代品。这些都是完全可以接受的解决方案。真正重要的是你有一些适合你的工具，你有一个Git仓库在某个地方备份，无论是GitHub还是Bitbucket，你有一个简单的部署方式，这样你就可以快速进行更改并将其快速推送给用户。
- en: In different sections, we looked at how to add files to Git and how to make
    that first commit. Next, we set up both GitHub and Heroku, then we looked at how
    to push our code and deploy it. Then, we looked at how we can communicate with
    Heroku to deploy our code. Then after that, we looked at some real-world workflows
    for creating new commits, pushing to GitHub, and deploying to Heroku.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的章节中，我们学习了如何将文件添加到Git以及如何进行第一次提交。接下来，我们设置了GitHub和Heroku，然后学习了如何推送我们的代码并部署它。然后，我们学习了如何与Heroku通信以部署我们的代码。之后，我们学习了一些实际的工作流程，用于创建新的提交，推送到GitHub，并部署到Heroku。
- en: In the next chapter, we'll look into testing our applications.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何测试我们的应用程序。
