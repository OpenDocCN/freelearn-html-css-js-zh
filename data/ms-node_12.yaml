- en: Creating Your Own C++ Add-ons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的C++插件
- en: '"If two (people) on the same job agree all the time, then one is useless. If
    they disagree all the time, then both are useless."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一工作的两个人总是意见一致，那么其中一个是无用的。如果他们总是意见不一致，那么两个都是无用的。
- en: – Darryl F. Zanuck
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Darryl F. Zanuck'
- en: 'A very common description of Node is this one: *NodeJS allows Javascript to
    be run on the server*. This is of course true; it is also misleading. The accomplishment
    of Node was in organizing and linking powerful C++ libraries in such a way that
    their efficiency could be harnessed without needing to comprehend their complexities,
    all accomplished by linking native C++ libraries, through V8, to the JavaScript-driven
    runtime that *is* Node. Node aimed to abstract away the complexity of multiuser,
    simultaneous multithreaded I/O management by wrapping that concurrency model into
    a single-threaded environment that was easy to understand, and already well understood
    by millions of web developers.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node的一个非常常见的描述是：*NodeJS允许在服务器上运行Javascript*。这当然是真的；但也是误导的。Node的成就在于以这样一种方式组织和链接强大的C++库，使它们的效率可以被利用，而不需要理解它们的复杂性，所有这些都是通过将本地C++库链接到*是*Node的JavaScript驱动运行时来实现的。Node的目标是通过将并发模型包装到一个易于理解的单线程环境中，来抽象出多用户、同时多线程I/O管理的复杂性，并且已经被数百万网络开发人员充分理解。
- en: 'The point is simply this: when you are working with Node, you are ultimately
    working with C++ bindings to your OS, a language whose suitability is for enterprise-level
    software development that no one would seriously question.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，当你使用Node时，你最终是在使用C++绑定到你的操作系统，这是一种适用于企业级软件开发的语言，没有人会认真质疑。
- en: This native bridge to C++ programs puts the lie to claims that Node is not enterprise-ready.
    These claims confuse what Javascript’s role in the Node stack actually is. The
    bindings to Redis and other database drivers regularly used in Node programs are
    C bindings—fast, and near the *metal*. As we’ve seen, Node’s simple process bindings
    (spawn, exec, and so on) facilitate a smooth integration of powerful system libraries
    with headless browsers and HTTP data streams. We are able to access the enormously
    powerful suite of native Unix programs as if they were part of the Node API itself.
    Also, of course, we can write our own add-ons.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种与C++程序的本地桥接证明了Node不适合企业级的说法是错误的。这些说法混淆了Javascript在Node堆栈中的实际角色。在Node程序中经常使用的Redis和其他数据库驱动程序的绑定是C绑定——快速，接近*底层*。正如我们所看到的，Node的简单进程绑定（spawn、exec等）促进了强大系统库与无头浏览器和HTTP数据流的平滑集成。我们能够访问一套强大的本地Unix程序，就好像它们是Node
    API的一部分。当然，我们也可以编写自己的插件。
- en: 'Paraphrasing Professor *Keith Devlin’s* description in "*Calculus: One of the
    Most Successful Technologies*" ([https://www.youtube.com/watch?v=8ZLC0egL6pc](https://www.youtube.com/watch?v=8ZLC0egL6pc)),
    these are some features of successful consumer technologies:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成功的消费者技术，这是一些特征的简述，由*Keith Devlin*教授在"*微积分：最成功的技术之一*"([https://www.youtube.com/watch?v=8ZLC0egL6pc](https://www.youtube.com/watch?v=8ZLC0egL6pc))中描述：
- en: It should remove difficulty or drudgery from the process of completing a task.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该消除完成任务的困难或单调乏味。
- en: It should be easy to learn and use.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该易于学习和使用。
- en: It should be easier to learn and use than the popular method, if one exists.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，它应该比流行的方法更容易学习和使用。
- en: Once learned, it can be used without constant expert guidance. A user remains
    able to remember and/or derive most or all of the rules governing interactions
    with the technology through time.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦学会，就可以在没有持续专家指导的情况下使用。用户仍然能够记住和/或推导出大部分或全部规则，以及随着时间的推移与技术的交互。
- en: It should be possible to use it without knowing how it works.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该可以在不知道它是如何工作的情况下使用。
- en: Hopefully, as you think about the class of problems Node aims to solve, and
    the form of the solution it provides, the mentioned five features are easily seen
    in the technology Node represents. Node is fun to learn and use, with a consistent
    and predictable interface. Importantly, "*under the hood"* Node runs enormously
    powerful tools that the developer need only understand in terms of their API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 希望当你考虑Node旨在解决的问题类别和它提供的解决方案形式时，你会很容易地在Node所代表的技术中看到上述五个特征。Node学习和使用起来很有趣，具有一致和可预测的界面。重要的是，“*在幕后*”Node运行着强大的工具，开发人员只需要理解它们的API。
- en: Wonderfully, Node, V8, libuv, and the other libraries composing the Node stack
    are open source, a significant fact that further distinguishes Node from many
    competitors. Not only can one contribute directly to the core libraries, one can
    *cut and paste* code blocks and other routines to use in one’s own work. In fact,
    you should see your growth into a better Node developer as a chance to simultaneously
    become a better C++ programmer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，Node、V8、libuv和组成Node堆栈的其他库都是开源的，这是一个重要的事实，进一步区别了Node与许多竞争对手。不仅可以直接向核心库做出贡献，还可以*剪切和粘贴*代码块和其他例程来用于自己的工作。事实上，你应该把自己成长为更好的Node开发人员看作是同时成为更好的C++程序员的机会。
- en: This is not a primer on C++, leaving you to pursue this study on your own. Don’t
    be intimidated! The C-family of languages are designed using forms and idioms,
    not unlike what you are already used to using with JavaScript. The syntax and
    flow control should look very familiar. You should be able to understand the design
    and goals of the following examples with little effort, and can dip into C++ programming
    to resolve the meaning of the parts that aren’t clear. Extending these examples
    iteratively is an excellent way to gently enter the world of C++ programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是C++的入门指南，让你自己去学习。不要感到害怕！C语言家族使用的形式和习惯用法与你已经习惯使用的JavaScript非常相似。语法和流程控制应该看起来非常熟悉。你应该能够轻松理解以下示例的设计和目标，并且可以通过C++编程来解决不清楚的部分的含义。逐步扩展这些示例是进入C++编程世界的一个很好的方式。
- en: Hello World
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，世界
- en: Let’s build our first add-on. In keeping with tradition, this add-on will result
    in a Node module that will print out "Hello World!" Even though this is a very
    simple example, it typifies the structure of all further C++ add-ons you will
    build. This allows you to incrementally experiment with new commands and structures,
    growing your knowledge in easy-to-understand steps.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的第一个插件。为了保持传统，这个插件将生成一个Node模块，将打印出“Hello World!”即使这是一个非常简单的例子，但它代表了您将构建的所有后续C++插件的结构。这使您可以逐步尝试新的命令和结构，以易于理解的步骤增加您的知识。
- en: 'For the steps that follow to work, you''ll need a C/C++ compiler and Python
    2.7 installed on your system. The tools to build native code on an operating system
    are specific to that operating system (and provided by the community or corporation
    that maintains or owns it). Here are instructions for some of the major operating
    systems:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使接下来的步骤起作用，您需要在系统上安装C/C++编译器和Python 2.7。在操作系统上构建本机代码的工具是特定于该操作系统的（由维护或拥有它的社区或公司提供）。以下是一些主要操作系统的说明：
- en: On macOS, for instance, Apple offers Xcode, an integrated development environment
    (IDE) that includes a compiler.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，在macOS上，苹果提供了Xcode，一个集成开发环境（IDE），其中包括一个编译器。
- en: For Windows, Microsoft's compiler comes with Visual Studio. There is also an
    npm package available for this purpose— `npm i -g windows-build-tools`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Windows，微软的编译器随Visual Studio一起提供。还有一个可用于此目的的npm包—`npm i -g windows-build-tools`。
- en: On Linux and elsewhere, **GCC, the GNU Compiler Collection**, is common. **GNU
    Make** and **Python** are also needed.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux和其他地方，**GCC，GNU编译器集合**很常见。还需要**GNU Make**和**Python**。
- en: 'C++ programmers might benefit from learning how V8 is embedded, from: [https://github.com/v8/v8/wiki/Embedder%27s-Guide](https://github.com/v8/v8/wiki/Embedder%27s-Guide).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序员可能会受益于学习V8的嵌入方式，网址为：[https://github.com/v8/v8/wiki/Embedder%27s-Guide](https://github.com/v8/v8/wiki/Embedder%27s-Guide)。
- en: When compiling native code, there's usually another piece of software—the build
    automation tool. This tool directs the steps the compiler takes to turn your source
    code into a native binary. One of the first, for C, was Make. You can type into
    your compiler directly, of course, but Make lets you rerun the same set of commands,
    keeps a record of what those commands are, and transfer those commands to another
    developer. Make was developed in April 1976, and it has been in continuous use
    ever since.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编译本地代码时，通常还有另一种软件——构建自动化工具。这个工具指导编译器执行的步骤，将您的源代码转换为本机二进制代码。对于C语言，最早的工具之一是Make。当然，您也可以直接输入编译器，但是Make可以让您重新运行相同的一组命令，记录这些命令是什么，并将这些命令传输给另一个开发人员。Make是在1976年4月开发的，自那时以来一直在持续使用。
- en: Visual Studio and Xcode don't use a script-based tool like Make. Instead, they
    keep build steps and settings in binary files, and let developers edit them by
    clicking on checkboxes and entering text in graphical dialog boxes. This approach
    appeared friendlier, but can be more cumbersome and error-prone.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio和Xcode不使用像Make这样基于脚本的工具。相反，它们将构建步骤和设置保存在二进制文件中，并允许开发人员通过单击复选框和在图形对话框中输入文本来编辑它们。这种方法看起来更友好，但可能更繁琐和容易出错。
- en: To make it easier, Google developed a tool called **GYP**, for **Generate Your
    Projects**. It's a meta-build system, taking information from you (in text format)
    and generating the build files the native compiler or IDE expects. Instead of
    opening up Visual Studio or Xcode and clicking around on menus and checkboxes,
    GYP will generate the required files for you. For any developer who has spent
    an evening (or several) hunting through settings to fix a broken native build,
    GYP is wonderful magic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更方便，谷歌开发了一个名为**GYP**的工具，用于**生成您的项目**。这是一个元构建系统，从您那里（以文本格式）获取信息，并生成本机编译器或IDE所需的构建文件。GYP将为您生成所需的文件，而不是打开Visual
    Studio或Xcode并在菜单和复选框上单击。对于任何一个花了一个晚上（或几个晚上）在设置中寻找以修复损坏的本机构建的开发人员来说，GYP是一种神奇的魔法。
- en: Google first created GYP to build Chrome and V8, but as an open source project,
    a community brought it to an ever-expanding list of new uses. To build native
    Node add-ons, the Node team creates and maintains `node-gyp`, which bundles Google's
    GYP. Use the mentioned commands to install `node-gyp` globally on your system,
    and verify that it's there by getting the version. You can find the installation
    instructions for `node-gyp` on the below mentioned link: [https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌最初创建了GYP来构建Chrome和V8，但作为一个开源项目，一个社区将其带到了一个不断扩大的新用途列表。为了构建本机Node插件，Node团队创建并维护了`node-gyp`，其中包含了谷歌的GYP。使用上述命令在系统上全局安装`node-gyp`，并通过获取版本来验证它是否存在。您可以在下面的链接中找到`node-gyp`的安装说明：[https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp)
- en: You may remember our discussion in the first chapter about the Unix design philosophy,
    and specifically, Doug McIlroy's directive to "*Write programs to handle text
    streams, because that is a universal interface.*"
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们在第一章中关于Unix设计哲学的讨论，特别是道格·麦克罗伊的指令“*编写处理文本流的程序，因为那是一个通用接口*”。
- en: For the task of compiler automation, Make followed this guideline in the 1970s,
    Apple and Microsoft broke the rule in the 1990s with their graphical IDEs and
    binary project files, and now in this decade, Google has restored it with GYP.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译器自动化的任务，Make在20世纪70年代遵循了这一准则，而苹果和微软在20世纪90年代打破了这一规则，他们使用了图形IDE和二进制项目文件，而现在在这个十年中，谷歌用GYP恢复了它。
- en: 'To understand where we''re going, it may be helpful to take a look at what
    we''ll have at the end. When we''re done, we''ll have a module definition folder
    with a handful of files in it. Here''s the structure we''ll create first:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们要去哪里，可能有助于看一下我们最终会得到什么。完成后，我们将拥有一个模块定义文件夹，其中包含一些文件。首先我们将创建的结构如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `/hello_module` module folder contains a C++ file (`hello.cc`), the *instruction* file
    for GYP (`binding.gyp`), and a convenience *wrapper* (`index.js`), whose purpose
    will be made clear shortly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`/hello_module`模块文件夹包含一个C++文件（`hello.cc`），GYP的*指令*文件（`binding.gyp`），以及一个方便的*包装器*（`index.js`），其目的将很快清楚。'
- en: 'Create a file named `hello.cc` with these contents:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`hello.cc`的文件，其中包含以下内容：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After including Node's C header, defining a namespace for our code, and declaring
    various parts of V8 that we'll need to use, there are three parts. The `void sayHello`
    function is the native function we will export. Below that, `init` is a required
    initialization function that sets up the exports for the Node module that this
    will all become (here, the function name `"sayHello"`, bound to its C++ counterpart),
    and `NODE_MODULE()` is a C++ macro that actually exports the module that GYP was
    configured to export. As it's a macro, there's no semicolon at the end of that
    line.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含了Node的C头文件之后，为我们的代码定义了一个命名空间，并声明了我们需要使用的V8的各个部分，有三个部分。`void sayHello`函数是我们将要导出的本地函数。在下面，`init`是一个必需的初始化函数，用于设置这将成为的Node模块的导出（这里，函数名`"sayHello"`绑定到它的C++对应部分），`NODE_MODULE()`是一个C++宏，实际上导出了GYP配置为导出的模块。由于它是一个宏，在该行的末尾没有分号。
- en: You are embedding C++ code into the V8 runtime, so that Javascript can be bound
    into the relevant scope. V8 must scope all the new allocations made in your code,
    and so, you’ll need to wrap the code you write, extending V8\. To this end, you’ll
    see several instances of the `Handle<Value>` syntax, wrapping C++ code in the
    examples that follow. Comparing these wrappers to what will be defined in the
    initialization function pushed out to `NODE_MODULE` should make it clear how Node
    is being bound to C++ methods via the V8 bridge.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在将C++代码嵌入V8运行时，以便Javascript可以绑定到相关的范围。V8必须对你的代码中进行的所有新分配进行范围限制，因此，你需要将你编写的代码包装起来，扩展V8。为此，你将看到在接下来的示例中，`Handle<Value>`语法的几个实例，将C++代码包装起来。将这些包装器与将在初始化函数中定义并推送到`NODE_MODULE`的内容进行比较，应该清楚地表明Node是如何通过V8桥接绑定到C++方法的。
- en: 'To learn more about how V8 embeds C++ code, check out: [https://github.com/v8/v8/wiki/Getting%20Started%20with%20Embedding](https://github.com/v8/v8/wiki/Getting%20Started%20with%20Embedding).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于V8嵌入C++代码的信息，请查看：[https://github.com/v8/v8/wiki/Getting%20Started%20with%20Embedding](https://github.com/v8/v8/wiki/Getting%20Started%20with%20Embedding)。
- en: 'Along with `hello.cc`, create `binding.gyp` with this code inside:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`hello.cc`，还要创建一个包含以下代码的`binding.gyp`：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In cases where you've got more than one source file to compile, simply add more
    filenames to the sources array.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有多个源文件需要编译的情况下，只需将更多的文件名添加到源数组中。
- en: This manifest tells GYP that we want to see `hello.cc` turned into compiled
    binary code in a file named `hello.node`  (`target_name`) in the `/Release` folder.
    We now have the C++ file and the compilation instructions we need to compile our
    first native add-on!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单告诉GYP我们希望看到`hello.cc`编译成一个名为`hello.node`的文件（`target_name`）在`/Release`文件夹中的编译二进制代码。现在我们有了C++文件和编译指令，我们需要编译我们的第一个本地插件！
- en: 'Run the following command in the `/hello_module` folder:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/hello_module`文件夹中运行以下命令：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Essentially, `configure` generates a Makefile, and the `build` command runs
    it. After you run the `configure` command, you can take a look inside the `/build`
    folder that GYP created to familiarize yourself; they''re all text files that
    you can inspect. On a Mac with Xcode installed, it''ll contain a handful of files,
    including a 300 line Makefile. If successful, the output from the `configure` command should
    look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`configure`生成一个Makefile，`build`命令运行它。在运行`configure`命令之后，你可以查看GYP创建的`/build`文件夹，以熟悉它们；它们都是你可以检查的文本文件。在安装了Xcode的Mac上，它将包含一些文件，包括一个300行的Makefile。如果成功，`configure`命令的输出应该看起来像这样：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, try the `build` command, which runs this Makefile. The output looks like
    this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试`build`命令，它会运行这个Makefile。输出看起来像这样：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you'll see a new `/build/Release` folder containing (among other things)
    the binary `hello.node` file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会看到一个新的`/build/Release`文件夹，其中包含（其他内容之间）二进制`hello.node`文件。
- en: 'To remove the `/build` folder, you can run `node-gyp clean`. As a build shortcut,
    you can use `node-gyp configure build` (one line) to configure and build in one
    step, or simply `node-gyp rebuild`, which runs `clean configure build` for you
    in one go. Further command-line options can be found at: [https://github.com/nodejs/node-gyp#command-options](https://github.com/nodejs/node-gyp#command-options).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除`/build`文件夹，可以运行`node-gyp clean`。作为一个构建快捷方式，你可以使用`node-gyp configure build`（一行）来配置和构建一步完成，或者简单地使用`node-gyp
    rebuild`，它会一次运行`clean configure build`。更多的命令行选项可以在这里找到：[https://github.com/nodejs/node-gyp#command-options](https://github.com/nodejs/node-gyp#command-options)。
- en: 'Now, always staying in the `/hello_module` folder, create the following `index.js`
    file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，始终保持在`/hello_module`文件夹中，创建以下`index.js`文件：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This file will function as the exporter for this module. Depending on how you
    write your C++ code, you might use this opportunity to craft your module's native
    interface into a Node-specific API. For now, let's just export the `hello` function
    directly, saving the developer the trouble of following our build folder structure
    when using `require`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件将作为这个模块的导出程序。根据你如何编写你的C++代码，你可能会利用这个机会将你的模块的本地接口制作成一个特定于Node的API。现在，让我们直接导出`hello`函数，省去开发者在使用`require`时遵循我们的构建文件夹结构的麻烦。
- en: 'To complete the "modularization", create a `package.json` file for this module,
    and set the "entry point" value to `index.js`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成"模块化"，为这个模块创建一个`package.json`文件，并将"入口点"值设置为`index.js`：
- en: 'Now, let''s demonstrate how to use this module in your code. Jump up a directory
    and create a file that will require the module we''ve just created. Consider the
    following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示如何在你的代码中使用这个模块。跳到上一级目录，创建一个文件，该文件将需要我们刚刚创建的模块。考虑以下示例：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using destructuring, we pull the `sayHello` function from the object our module
    returns. Now, execute that code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解构，我们从我们的模块返回的对象中提取`sayHello`函数。现在，执行这段代码：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You are now both a C++ programmer and a Node extender!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你既是C++程序员，也是Node扩展程序员了！
- en: Note how we're using the same familiar `require` statement, but in a subtly
    powerful way. Instead of bringing in a Node module coded in more JavaScript, it
    detects and loads our newly-minted native add-on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何以一种微妙而强大的方式使用相同熟悉的`require`语句。它不是引入更多JavaScript编写的Node模块，而是检测并加载我们新创建的本地附加程序。
- en: A calculator
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个计算器
- en: 'Of course, one would never bother to write an add-on to simply echo back strings.
    It is more likely that you will want to expose an API or interface to your Node
    programs. Let’s create a simple calculator, with two methods: add and subtract.
    In this example, we will demonstrate how to pass arguments from Javascript to
    methods within an add-on, and to send any results back.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，人们永远不会费心编写一个附加程序来简单地回显字符串。更有可能的是，您希望为您的Node程序公开API或接口。让我们创建一个简单的计算器，有两种方法：add和subtract。在这个例子中，我们将演示如何将参数从Javascript传递给附加程序中的方法，并将任何结果发送回来。
- en: 'The complete code for this example will be found in your code bundle. The meat
    of the program can be seen in this snippet, where we define an interface for our
    two methods, each one expecting to receive two numbers as arguments:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码将在您的代码包中找到。程序的核心部分可以在这个片段中看到，我们在这里为我们的两种方法定义了一个接口，每种方法都期望接收两个数字作为参数：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can quickly see that two methods have been scoped: `Add` and `Subtract`
    (Subtract is defined nearly identically with `Add`, with only a change of operator).
    Within the `Add` method, we see an `Arguments` object (reminiscent of Javascript’s
    arguments object) that is checked for length (we expect two arguments) and argument
    type (we want numbers: `!args[0]->IsNumber() || !args[1]->IsNumber()`). Take a
    good look at how this method closes out:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很快看到两种方法已经被限定范围：`Add`和`Subtract`（`Subtract`几乎与`Add`定义相同，只是操作符有所改变）。在`Add`方法中，我们看到一个`Arguments`对象（让人想起Javascript的arguments对象），它被检查长度（我们期望两个参数）和参数类型（我们想要数字：`!args[0]->IsNumber()
    || !args[1]->IsNumber()`）。仔细看看这个方法是如何结束的：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While there seems to be a lot going on, it is really rather simple: V8 is instructed
    to allocate space for a Number with name `num`, to be assigned the value of adding
    our two numbers together. When this operation has been completed, we close out
    the execution scope and return `num`. We don’t have to worry about memory management
    for this reference, as that is automatically handled by V8.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然似乎有很多事情要做，但实际上非常简单：V8被指示为一个名为`num`的数字分配空间，以便赋予我们两个数字相加的值。当这个操作完成后，我们关闭执行范围并返回`num`。我们不必担心这个引用的内存管理，因为这是由V8自动处理的。
- en: 'Finally, we see in the following chunk not only how this particular program
    defines its interface, but how, at a deep level, Node modules and the exports
    object are in fact associated:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下面的代码块中，我们不仅看到了这个特定程序如何定义它的接口，而且还看到了Node模块和exports对象在深层次上是如何关联的：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As in our "hello" example, here we see the new symbols (these are just types
    of strings) `add` and `subtract`, which represent the method names for our new
    Node module.  Their function signature is implemented using the easy-to-follow
    `FunctionTemplate::New(Add)->GetFunction())` blueprint.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的“hello”示例一样，在这里我们看到了新的符号（这些只是字符串类型）`add`和`subtract`，它们代表了我们的新Node模块的方法名称。它们的函数签名是使用易于遵循的`FunctionTemplate::New(Add)->GetFunction())`蓝图实现的。
- en: 'Using our calculator from a Node program is now easy:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易从Node程序中使用我们的计算器：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With just this simple start, we can already implement useful C++ modules. We'll
    go deeper now, and we'll get some help from **nan (Native Abstractions for Node)**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅从这个简单的开始，我们就可以实现有用的C++模块。现在，我们将深入一些，并且我们将从**nan（Node的本地抽象）**中得到一些帮助。
- en: Using NAN
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NAN
- en: '**nan** ([https://github.com/nodejs/nan](https://github.com/nodejs/nan)) is
    a collection of header files providing helpers and macros aimed at simplifying
    the creation of add-ons. According to the documentation, nan was created primarily
    in order to preserve compatibility of your C++ code across different Node versions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**nan**（[https://github.com/nodejs/nan](https://github.com/nodejs/nan)）是一个提供帮助程序和宏的头文件集，旨在简化附加程序的创建。根据文档，nan主要是为了保持您的C++代码在不同的Node版本之间的兼容性而创建的：'
- en: Thanks to the crazy changes in V8 (and some in Node core), keeping native add-ons
    compiling happily across versions, particularly 0.10 to 0.12 to 4.0, is a minor
    nightmare. The goal of this project is to store all logic necessary to develop
    native Node.js add-ons without having to inspect `NODE_MODULE_VERSION` and get
    yourself into a macro-tangle.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于V8（以及Node核心）的疯狂变化，跨版本保持本地附加程序编译的愉快，特别是从0.10到0.12到4.0，是一场小噩梦。这个项目的目标是存储开发本地Node.js附加程序所需的所有逻辑，而无需检查`NODE_MODULE_VERSION`并陷入宏纠缠。
- en: In the examples that follow, we will use nan to build some native add-ons. Let's
    rebuild our `hello world` example using nan.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用nan来构建一些本地附加程序。让我们使用nan重新构建我们的`hello world`示例。
- en: Hello, nan
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，nan
- en: 'Create a folder for your project, and add the following package.json file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的项目创建一个文件夹，并添加以下package.json文件：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ve added a couple of new things here, such as indicating that there exists
    a `gypfile`. More importantly, we create some convenience scripts for compiling
    and running our module: `build` and `start`. Also, of course, we indicate that
    the module''s main execution file is `index.js` (we''ll create that soon). Note
    as well that, when you `npm install` this package, GYP will notice the `binding.gyp`
    file and automatically build—a `/build` folder will be created along with the
    install.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了一些新东西，比如指示存在一个`gypfile`。更重要的是，我们为编译和运行我们的模块创建了一些方便的脚本：`build`和`start`。当然，我们还指出模块的主执行文件是`index.js`（我们很快就会创建）。还要注意，当您`npm
    install`这个包时，GYP会注意到`binding.gyp`文件并自动构建 - 一个`/build`文件夹将与安装一起创建。
- en: 'Now, create our GYP binding file. Note the addition of `include_dirs`. This
    ensures that `nan` headers are made available to the compiler:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建我们的GYP绑定文件。注意添加了`include_dirs`。这确保了`nan`头文件对编译器是可用的：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we rewrite the main C++ file to take advantage of the nan helpers:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重写主C++文件以利用nan的帮助程序：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we can see that the long list of inclusions isn't necessary. The rest
    of the code follows the same pattern as our original example, but with the initialization
    and function definitions now running through NAN-prefixed shortcuts. Note that,
    we can directly type the `sayHello` method on the module object (`NAN_EXPORT(target,
    sayHello)`), rather than requiring us to specify "sayHello" on the interface that
    a `require` statement will receive.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到长长的包含列表是不必要的。代码的其余部分遵循与我们原始示例相同的模式，但现在通过NAN前缀的快捷方式运行初始化和函数定义。请注意，我们可以直接在模块对象上键入`sayHello`方法（`NAN_EXPORT(target,
    sayHello)`），而不需要在`require`语句接收的接口上指定“sayHello”。
- en: 'The final step is to prove that this module can be bound to Node. Create the
    following `index.js` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是证明这个模块可以绑定到Node。创建以下`index.js`文件：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, all we have to do is build:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要做的就是构建：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we''ll run it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将运行它：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Asynchronous add-ons
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步插件
- en: In keeping with the typical pattern of a Node program, add-ons also implement
    the notion of asynchronous callbacks. As one might expect in a Node program, a
    C++ add-on performing an expensive and time-consuming operation should comprehend
    the notion of asynchronously executing functions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Node程序的典型模式，插件也实现了异步回调的概念。正如人们可能在Node程序中期望的那样，执行昂贵和耗时操作的C++插件应该理解异步执行函数的概念。
- en: Let's create a module that exposes two methods that ultimately call the same
    function, yet one method does it synchronously and the other asynchronously. This
    will allow us to demonstrate how to create native modules with callbacks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个模块，公开两种最终调用相同函数的方法，但一种是同步调用，另一种是异步调用。这将使我们能够演示如何创建带有回调的本机模块。
- en: 'We''re going to break our module up into 4 files, separating functionality.
    Create a new directory and copy the `package.json` file from the previous example
    (changing `name` to something else), and add the following `binding.gyp` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的模块分成4个文件，分离功能。创建一个新目录，并从上一个示例中复制`package.json`文件（将`name`更改为其他内容），然后添加以下`binding.gyp`文件：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we''re done, your module folder will look something like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您的模块文件夹将看起来像这样：
- en: '![](img/5a0c4968-9de2-4bbb-9b36-ccb770df644d.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a0c4968-9de2-4bbb-9b36-ccb770df644d.png)'
- en: We're going to create one file containing the asynchronous method (`async.cc`),
    one for synchronous (`sync.cc`), the common function each will call differently
    in `addon.h`, and the main `addon.cc` file that will "bind" everything together.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含异步方法（`async.cc`）的文件，一个包含同步方法（`sync.cc`）的文件，每个文件将在`addon.h`中以不同方式调用的公共函数，以及将所有内容“绑定”在一起的主`addon.cc`文件。
- en: 'Create `addons.h` in the module folder:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块文件夹中创建`addons.h`：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this file is where we will create a "mock" function, whose responsibility
    is simply to waste cycles (time). So, we create an inefficient function `Run`.
    Using the `volatile` keyword, we spook V8 into de-optimizing this function (we
    are warning V8 that this value will change unpredictably, scaring off the optimizer).
    The rest will simply run the number of requested cycles and reflect the value
    it was sent...slowly. This is the function that both our async and sync code will
    execute.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将创建一个“模拟”函数，其责任只是浪费周期（时间）。因此，我们创建一个低效的函数`Run`。使用`volatile`关键字，我们吓唬V8使其取消优化这个函数（我们警告V8这个值将不可预测地改变，吓跑了优化器）。其余部分将简单地运行请求的周期数并反映它发送的值...慢慢地。这是我们的异步和同步代码都将执行的函数。
- en: 'To execute `Run` synchronously, create the following sync.cc file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要同步执行`Run`，创建以下`sync.cc`文件：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we saw earlier, `info` will contain arguments passed to this `RunSync` method.
    Here, we grab the number of cycles requested, pass those arguments to `Run`, and
    return whatever that function call produced.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，`info`将包含传递给此`RunSync`方法的参数。在这里，我们获取请求的周期数，将这些参数传递给`Run`，并返回该函数调用产生的任何内容。
- en: 'Now, create the file for our asynchronous method, `async.cc`. Creating asynchronous
    code is slightly more complex:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建我们的异步方法`async.cc`的文件。创建异步代码稍微复杂：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Starting from the bottom, you see that we're creating a method that expects
    the first argument (info[0]) to be an integer, which is assigned to `cycles`.
    We then create a new `Callback` object as `callback`, and pass `callback` and
    `cycles` to the `Worker` constructor, passing the resulting instance to `AsyncQueueWorker`
    (setting up our asynchronous  method).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从底部开始，您会看到我们正在创建一个方法，该方法期望第一个参数（info[0]）是一个整数，该整数被赋给`cycles`。然后我们创建一个新的`Callback`对象作为`callback`，并将`callback`和`cycles`传递给`Worker`构造函数，将结果实例传递给`AsyncQueueWorker`（设置我们的异步方法）。
- en: Now, let's examine how to configure an asynchronous `Worker`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何配置异步`Worker`。
- en: Jump to the bottom of `Worker` and note the establishment of private attributes
    `cycles` and `result` for this class. In JavaScript, the equivalent would be to
    create a local variable context with `this.cycles` and `this.result` -- local
    variables to use in what follows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到`Worker`的底部，注意为这个类建立私有属性`cycles`和`result`。在JavaScript中，相当于创建一个具有`this.cycles`和`this.result`的本地变量上下文--在接下来的内容中使用的本地变量。
- en: 'To fulfill the worker template we need to implement two key functions: `Execute`
    and `HandleOKCallback`. `Execute` executes our `Run` function (from `addons.h`)
    in a worker thread (the power of C++ at work) and assigns to `result` the returned
    value. Once `Run` has completed we need to send this result back to the original
    JavaScript callback our Node module interface will have sent. `HandleOKCallback`
    prepares the argument list (`argv`) as expected by standard error-first Node callback
    pattern: we set the first error argument to `Null()`, and the second argument
    to the `result`. Via `callback->Call(2, argv)` the original callback is called
    with these 2 arguments, and proceeds accordingly.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足工作模板，我们需要实现两个关键函数：`Execute`和`HandleOKCallback`。`Execute`在工作线程中执行我们的`Run`函数（来自`addons.h`），并将返回的值赋给`result`。一旦`Run`完成，我们需要将这个结果发送回原始的JavaScript回调，我们的Node模块接口会发送。`HandleOKCallback`准备参数列表（`argv`），按照标准的错误优先Node回调模式的预期：我们将第一个错误参数设置为`Null()`，第二个参数设置为`result`。通过`callback->Call(2,
    argv)`，原始回调将使用这两个参数进行调用，并相应地进行处理。
- en: 'The last step is to create the module export file, `index.js`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建模块导出文件`index.js`：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you''ve created this file, go ahead and build your module via `npm run
    build`. (or `node-gyp rebuild`) and execute this file with `node index.js`. You
    should see something like this in your terminal:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完这个文件后，继续通过`npm run build`（或`node-gyp rebuild`）构建您的模块，并使用`node index.js`执行此文件。您应该在终端中看到类似以下的内容：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What''s the point of that? We''re proving that we can create C++ functions
    that run independently of the single Node process thread. If `addon.runAsync`
    was not running asynchronously, the output would have looked like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么意义呢？我们正在证明我们可以创建独立于单个Node进程线程的C++函数。如果`addon.runAsync`不是异步运行的，输出将如下所示：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, we see that the runtime logged 1, `runAsync` went off into threads
    land, `2` was logged, followed by the synchronous function `runSync`, blocking
    the event loop (which runs in the same single JavaScript thread). When finished,
    this sync function announces its result, and the loop continues with its next
    instruction to log 3, until, finally, pending callbacks are executed, when the
    result of `runAsync` makes an appearance, last.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们看到运行时记录了1，`runAsync`进入了线程，记录了2，然后是同步函数`runSync`，阻塞了事件循环（在同一个单一的JavaScript线程中运行）。完成后，这个同步函数宣布了它的结果，循环继续执行下一个指令记录3，最后，待处理的回调被执行，`runAsync`的结果最后出现。
- en: There is a lot of room here for exploration, even if you aren't a C++ programmer.
    From these simple building blocks, aided by `nan`, you can build add-ons with
    increasingly complex behavior. And, of course, the largest advantage is this ability
    to pass long running tasks off onto the OS, to run in a very fast, compiled language.
    Your Node project can now fully harness the power of C++.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不是C++程序员，这里还有很多探索的空间。借助`nan`这些简单的构建模块，您可以构建行为越来越复杂的插件。当然，最大的优势是能够将长时间运行的任务交给操作系统，在一个非常快速的编译语言中运行。您的Node项目现在可以充分利用C++的力量。
- en: Closing thoughts
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束语
- en: Being able to easily link C++ modules with your Node program is a powerful new
    paradigm. It may be tempting, then, to exuberantly begin writing C++ add-ons for
    every identifiable segment of your programs. While this might be a productive
    way to learn, it is not necessarily the best idea in the long run. While it is
    certainly true that, in general, compiled C++ will run more quickly than JavaScript
    code, remember that V8 is ultimately using another type of compilation on the
    JavaScript code it is running. JavaScript running within V8 runs very efficiently.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 能够轻松地将C++模块与Node程序链接起来是一种强大的新范式。因此，可能会有诱惑力，热情洋溢地开始为程序的每个可识别的部分编写C++插件。虽然这可能是学习的一种有效方式，但从长远来看，这并不一定是最好的主意。尽管通常编译后的C++运行速度比JavaScript代码更快，但要记住V8最终是在JavaScript代码上使用另一种类型的编译。在V8中运行的JavaScript非常高效。
- en: As well, we don’t want to lose the simplicity of organization and predictable
    single-threaded runtime of JavaScript when designing complex interactions within
    a high-concurrency environment. Remember that Node came into being partly as an
    attempt to save the developer from working with threads and related complexities
    when performing I/O. As such, try and keep some rules in mind.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不希望在高并发环境中设计复杂的交互时失去JavaScript的简单组织和可预测的单线程运行时。请记住，Node的出现部分是为了使开发人员在执行I/O时免于使用线程和相关复杂性。因此，请牢记一些规则。
- en: 'Will a C++ module actually run more quickly? The answer isn’t always yes. The
    extra step of jumping into a different execution context and then back into V8
    takes time. *Felix Geisendorfer’s* talk describing his work with building fast
    MySQL bindings provides some insight into how one should think when making these
    decisions, at: [http://www.youtube.com/watch?v=Kdwwvps4J9A](http://www.youtube.com/watch?v=Kdwwvps4J9A).
    In general, stick with JavaScript until you need to really do something deep and
    expensive where getting *closer to the metal* makes sense.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C++模块实际上会更快吗？答案并不总是肯定的。跳转到不同的执行上下文，然后再返回到V8需要时间。*Felix Geisendorfer*的演讲描述了他构建快速MySQL绑定的工作，提供了一些关于在做出这些决定时应该如何思考的见解，网址为：[http://www.youtube.com/watch?v=Kdwwvps4J9A](http://www.youtube.com/watch?v=Kdwwvps4J9A)。总的来说，除非真的需要做一些深入和昂贵的事情，需要更接近底层，否则应该坚持使用JavaScript。
- en: How does splitting up your code base affect maintainability? While it would
    be hard for any developer to suggest using less-efficient code, sometimes a negligible
    performance gain does not overcome an increase in complexity that can lead to
    harder-to-find bugs or difficulties with sharing or otherwise managing your code
    base (including with future team members you haven't even hired yet!).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分代码库如何影响可维护性？虽然很难有任何开发人员建议使用效率低下的代码，但有时微不足道的性能提升并不能克服复杂性的增加，这可能导致更难以找到的错误或在共享或管理代码库时出现困难（包括未来尚未雇佣的团队成员）。
- en: Node has merged a beautiful JavaScript API with an enormously powerful and easily
    extensible application stack. Given the ability to integrate C++ into your applications,
    there is no reason to exclude Node from the list of technologies to consider for
    your next project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Node已经将一个美丽的JavaScript API与一个非常强大且易于扩展的应用程序堆栈合并在一起。有了将C++集成到你的应用程序中的能力，没有理由将Node排除在下一个项目考虑的技术列表之外。
- en: Links and resources
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接和资源
- en: 'Additional guides and resources for writing Node add-ons can be found on the
    web:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编写Node插件的额外指南和资源可以在网上找到：
- en: The Node documentation for add-ons is excellent: [https://nodejs.org/dist/latest-v9.x/docs/api/addons.html](https://nodejs.org/dist/latest-v9.x/docs/api/addons.html)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node的插件文档非常出色：[https://nodejs.org/dist/latest-v9.x/docs/api/addons.html](https://nodejs.org/dist/latest-v9.x/docs/api/addons.html)
- en: The nan repository contains many examples: [https://github.com/nodejs/nan](https://github.com/nodejs/nan)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nan存储库包含许多示例：[https://github.com/nodejs/nan](https://github.com/nodejs/nan)
- en: An excellent resource for those learning C++: [http://www.learncpp.com/](http://www.learncpp.com/)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于学习C++的绝佳资源：[http://www.learncpp.com/](http://www.learncpp.com/)
- en: When you’re feeling more confident, the source code for Node’s core modules
    is an excellent place to both explore and learn from: [https://github.com/nodejs/node/tree/master/src](https://github.com/nodejs/node/tree/master/src)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你感到更有信心时，Node核心模块的源代码是一个很好的地方，可以进行探索和学习：[https://github.com/nodejs/node/tree/master/src](https://github.com/nodejs/node/tree/master/src)
