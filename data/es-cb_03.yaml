- en: Working with Promises
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与承诺一起工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Creating and waiting for Promises
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并等待承诺
- en: Resolving Promise results
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决承诺结果
- en: Rejecting Promise errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝承诺错误
- en: Chaining Promises
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链式调用承诺
- en: Starting a Promise chain with Promise.resolve
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Promise.resolve 开始承诺链
- en: Using Promise.all to resolve multiple Promises
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Promise.all 解析多个承诺
- en: Handling errors with Promise.catch
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Promise.catch 处理错误
- en: Simulating finally with the Promise API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Promise API 模拟 finally
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In earlier versions of JavaScript, the callback pattern was the most common
    way to organize asynchronous code. It got the job done, but it didn't scale well.
    With callbacks, as more asynchronous functions are added, the code becomes more
    deeply nested, and it becomes more difficult to add to, refactor, and understand
    the code. This situation is commonly known as **callback hell**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 的早期版本中，回调模式是最常见的组织异步代码的方式。它完成了工作，但扩展性不好。随着更多异步函数的添加，代码变得更加嵌套，添加、重构和理解代码变得更加困难。这种情况通常被称为
    **回调地狱**。
- en: Promises were introduced to improve on this situation. Promises allow the relationships
    of asynchronous operations to be rearranged and organized with more freedom and
    flexibility.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺被引入以改善这种情况。承诺允许异步操作之间的关系以更多自由和灵活性进行重新排列和组织。
- en: The recipes in this chapter demonstrate how to use promises to create and organize
    asynchronous functions, as well as how to handle error conditions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的配方展示了如何使用承诺创建和组织异步函数，以及如何处理错误情况。
- en: Creating and waiting for Promises
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并等待承诺
- en: Promises provide a way to compose and combine asynchronous functions in an organized
    and easier to read way. This recipe demonstrates a very basic usage of promises.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺提供了一种以有组织和易于阅读的方式组合和组合异步函数的方法。此配方演示了承诺的非常基本的使用。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设您已经有一个允许您在浏览器中创建和运行 ES 模块的开发空间。如果您没有，请参阅前两章。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行应用程序并导航到您的开发空间。
- en: Create a new folder named `03-01-creating-and-waiting-for-promises`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `03-01-creating-and-waiting-for-promises` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file that creates a promise and logs messages before and
    after the promise is created, as well as while the promise is executing and after
    it has been resolved:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，该文件创建一个承诺并在创建承诺前后以及承诺执行期间和解决后记录消息：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You will see the following output:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](img/7bdb1f62-5603-4bd8-a3dd-15c0de1a0388.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bdb1f62-5603-4bd8-a3dd-15c0de1a0388.png)'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By looking at the order of the log messages, you can clearly see the order of
    operations. First, the initial log is executed. Next, the promise is created with
    an executor method. The executor method takes `resolve` as an argument. The `resolve`
    function fulfills the promise.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看日志消息的顺序，您可以清楚地看到操作顺序。首先，执行初始日志。接下来，使用执行器方法创建承诺。执行器方法将 `resolve` 作为参数。`resolve`
    函数实现承诺。
- en: Promises adhere to an interface named **thenable**. This means that we can chain
    `then` callbacks. The callback we attached with this method is executed after
    the `resolve` function is called. This function executes asynchronously (not immediately
    after the Promise has been resolved).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺遵循名为 **thenable** 的接口。这意味着我们可以链式调用 `then` 回调。我们使用此方法附加的回调在调用 `resolve` 函数之后执行。此函数异步执行（不是在承诺解决后立即执行）。
- en: Finally, there is a log after the promise has been created.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在创建承诺后有一个日志记录。
- en: The order the logs messages appear reveals the asynchronous nature of the code.
    All of the logs are seen in the order they appear in the code, except the `Finished
    promise` message. That function is executed asynchronously after the `main` function
    has exited!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息出现的顺序揭示了代码的异步性质。所有日志都按其在代码中出现的顺序显示，除了“承诺完成”消息。该函数在 `main` 函数退出后异步执行！
- en: We'll be looking more at `resolve`, `then`, and other parts of the promise API
    in later recipes in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的示例中，我们将更详细地探讨 `resolve`、`then` 以及承诺 API 的其他部分。
- en: Resolving Promise results
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决承诺结果
- en: In the previous recipe, we saw how to use promises to execute asynchronous code.
    However, this code is pretty basic. It just logs a message and then calls `resolve`.
    Often, we want to use asynchronous code to perform some long-running operation,
    then return that value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了如何使用承诺来执行异步代码。然而，这段代码相当基础。它只是记录一条消息然后调用 `resolve`。通常，我们希望使用异步代码执行一些长时间运行的操作，然后返回该值。
- en: This recipe demonstrates how to use `resolve` in order to return the result
    of a long-running operation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例演示了如何使用 `resolve` 来返回长时间运行操作的结果。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例假设您已经有一个允许您在浏览器中创建和运行 ES 模块的开发空间。如果您没有，请参阅前两章。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行应用程序并导航到您的开发空间。
- en: Create a new folder named `3-02-resolving-promise-results.`
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `3-02-resolving-promise-results` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file that creates a promise and logs messages before and
    after the promise is created:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，该文件创建一个承诺并在创建承诺前后记录消息：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within the promise, resolve a random number after a 5-second timeout:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在承诺内部，在 5 秒超时后解决一个随机数：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Chain a `then` call off the promise. Pass a function that logs out the value
    of its only argument:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在承诺上链式调用一个 `then` 调用。传递一个函数，该函数输出其唯一参数的值：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![](img/ef489ed3-ef1d-4033-818f-ac8ae272c79a.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef489ed3-ef1d-4033-818f-ac8ae272c79a.png)'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Just as in the previous recipe, the promise was not fulfilled until `resolve`
    was executed (this time after 5 seconds). This time however, we passed the called 
    `resolve` immediately with a random number for an argument. When this happens,
    the argument is provided to the callback for the subsequent `then` function. We'll
    see in future recipes how this can be continued to create *promise chains*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一个示例中所示，承诺直到 `resolve` 执行（这次是在 5 秒后）才得到解决。然而，这次我们立即传递一个随机数作为 `resolve` 的参数。当这种情况发生时，该参数被提供给后续
    `then` 函数的回调。我们将在未来的示例中看到如何继续创建 *承诺链*。
- en: Rejecting Promise errors
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拒绝承诺错误
- en: In the previous recipe, we saw how to use `resolve` to provide a result from
    a successfully fulfilled promise. Unfortunately, the code doesn't always run as
    expected. Network connections can be down, data can be corrupted, and uncountable
    other errors can occur. We need to be able to handle those situations as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了如何使用 `resolve` 从成功解决的承诺中提供结果。不幸的是，代码并不总是按预期运行。网络连接可能会断开，数据可能会损坏，以及无法计数的其他错误可能会发生。我们需要能够处理这些情况。
- en: This recipe demonstrates how to use `reject` when errors arise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例演示了当出现错误时如何使用 `reject`。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例假设您已经有一个允许您在浏览器中创建和运行 ES 模块的开发空间。如果您没有，请参阅前两章。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行应用程序并导航到您的开发空间。
- en: Create a new folder named `3-03-rejecting-promise-errors`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `3-03-rejecting-promise-errors` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file that creates a promise, and logs messages before and
    after the promise is created and when the promise is fulfilled:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，该文件创建一个承诺，并在创建承诺前后以及承诺解决时记录消息：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a second argument to the promise callback named `reject`, and call `reject`
    with a new error:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向承诺回调添加一个名为 `reject` 的第二个参数，并使用新的错误调用 `reject`：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Chain a `catch` call off the promise. Pass a function that logs out its only
    argument:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在承诺上链式调用一个 `catch` 调用。传递一个函数，该函数输出其唯一的参数：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/71d45fae-07fe-42ff-ae36-1c9e231e02c4.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71d45fae-07fe-42ff-ae36-1c9e231e02c4.png)'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Previously we saw how to use `resolve` to return a value in the case of a successful
    fulfillment of a promise. In this case we called `reject` before `resolve`. This
    means that the Promise finished with an error before it could `resolve`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们看到了如何在承诺成功履行的情况下使用 `resolve` 返回一个值。在这种情况下，我们在 `resolve` 之前调用了 `reject`。这意味着承诺在能够
    `resolve` 之前就已经因为错误而结束了。
- en: When the Promise completes in an error state, the `then` callbacks are not executed.
    Instead we have to use `catch` in order to receive the error that the Promise
    rejects. You'll also notice that the `catch` callback is only executed after the
    `main` function has returned. Like successful fulfillment, listeners to unsuccessful
    ones execute asynchronously.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当承诺在错误状态下完成时，`then` 回调函数不会执行。相反，我们必须使用 `catch` 来接收承诺拒绝的错误。你也会注意到，`catch` 回调函数只有在
    `main` 函数返回之后才会执行。像成功的履行一样，对不成功的履行者的监听器也是异步执行的。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Handle errors with `Promise.catch`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Promise.catch` 处理错误
- en: Simulating `finally` with `Promise.then`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Promise.then` 模拟 `finally`
- en: Chaining Promises
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式调用承诺
- en: So far in this chapter, we've seen how to use promises to run single asynchronous
    tasks. This is helpful but doesn't provide a significant improvement over the
    callback pattern. The real advantage that promises offer comes when they are composed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了如何使用承诺来运行单个异步任务。这很有帮助，但与回调模式相比并没有带来显著改进。承诺真正的优势在于它们可以组合使用。
- en: In this recipe, we'll use promises to combine asynchronous functions in series.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用承诺来串联异步函数。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that  you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `3-04-chaining-promises.`
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `3-04-chaining-promises.` 的新文件夹
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html`，它从 `main.js` 加载并运行一个 `main` 函数。
- en: 'Create a `main.js` file that creates a promise. Resolve a random number from
    the promise:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，该文件创建一个承诺。从承诺中解析一个随机数：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Chain a `then` call off of the promise. Return `true` from the callback if
    the random value is greater than or equal to `0.5`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从承诺中链式调用一个 `then` 调用。如果随机值大于或等于 `0.5`，则从回调函数返回 `true`：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Chain a final `then` call after the previous one. Log out a different message
    if the argument is `true` or `false`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一个 `then` 调用之后链式调用一个最终的 `then` 调用。如果参数是 `true` 或 `false`，则输出不同的消息：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'If you are lucky, you''ll see the following output:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你很幸运，你会看到以下输出：
- en: '![](img/fa6229fe-69df-45ab-8719-cbe79bcfc45a.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa6229fe-69df-45ab-8719-cbe79bcfc45a.png)'
- en: 'If you are unlucky, we''ll see the following output:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运气不好，我们会看到以下输出：
- en: '![](img/4cc84fb5-4ee0-4b96-ab5e-7c04286e2736.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cc84fb5-4ee0-4b96-ab5e-7c04286e2736.png)'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We've already seen how to use `then` to wait for the result of a promise. Here,
    we are doing the same thing multiple times in a row. This is called a promise
    chain. After the promise chain is started with the new promise, all of the subsequent
    links in the promise chain return promises as well. That is, the callback of each
    `then` function is `resolve` like another promise.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `then` 等待承诺的结果。在这里，我们连续多次做同样的事情。这被称为承诺链。在启动新的承诺后，承诺链中的所有后续链接也返回承诺。也就是说，每个
    `then` 函数的回调就像另一个承诺一样是 `resolve`。
- en: See also
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Using `Promise.all` to resolve multiple Promises
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Promise.all` 解析多个承诺
- en: Handle errors with `Promise.catch`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Promise.catch` 处理错误
- en: Simulating `finally` with a final `Promise.then` call
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最终的 `Promise.then` 调用来模拟 `finally`
- en: Starting a Promise chain with Promise.resolve
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Promise.resolve 开始一个 Promise 链
- en: In this chapter's preceding recipes, we've been creating new `promise` objects
    with the constructor. This gets the jobs done, but it creates a problem. The first
    callback in the promise chain has a different shape than the subsequent callbacks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的食谱中，我们一直在使用构造函数创建新的`promise`对象。这完成了工作，但同时也产生了一个问题。承诺链中的第一个回调与后续的回调形状不同。
- en: In the first callback, the arguments are the `resolve` and `reject` functions
    that trigger the subsequent `then` or `catch` callbacks. In subsequent callbacks,
    the returned value is propagated down the chain, and thrown errors are captured
    by `catch` callbacks. This difference adds mental overhead. It would be nice to
    have all of the functions in the chain behave in the same way.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个回调中，参数是触发后续`then`或`catch`回调的`resolve`和`reject`函数。在后续的回调中，返回值沿着链向下传播，抛出的错误被`catch`回调捕获。这种差异增加了心理负担。如果链中的所有函数都以相同的方式表现，那就太好了。
- en: In this recipe, we'll see how to use `Promise.resolve` to start a promise chain.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看到如何使用`Promise.resolve`来启动承诺链。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `3-05-starting-with-resolve`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `3-05-starting-with-resolve`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`，该文件从`main.js`加载并运行一个`main`函数。
- en: 'Create a `main.js` file that calls `Promise.resolve` with an empty object as
    the first argument:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.js`的文件，该文件使用空对象作为第一个参数调用`Promise.resolve`：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Chain a `then` call off of `resolve`, and attach rocket boosters to the passed
    object:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`resolve`链中添加一个`then`调用，并将火箭助推器附加到传递的对象上：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a final `then` call to the chain that lets you know when the `boosters`
    have been added:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链中添加一个最终的`then`调用，以便知道何时添加了`boosters`：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在浏览器中打开以下链接：`http://localhost:8000/`。
- en: 'You should see the following output:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/98a3cf67-7a70-4730-8851-b09312f9362b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98a3cf67-7a70-4730-8851-b09312f9362b.png)'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Promise.resolve` creates a new promise that resolves the value passed to it.
    The subsequent `then` method will receive that resolved value as it''s argument.
    This method can seem a little roundabout but can be very helpful for composing
    asynchronous functions. In effect, the constituents of the promise chain don''t
    need to be aware that they are in the chain (including the first step). This makes
    transitioning from code that doesn''t use promises to code that does much easier.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.resolve`创建一个新的承诺，该承诺解析传递给它的值。后续的`then`方法将接收该解析值作为其参数。这个方法可能看起来有点绕，但可以非常有助于组合异步函数。实际上，承诺链的组成部分不需要意识到它们在链中（包括第一步）。这使得从不需要承诺的代码过渡到需要承诺的代码变得更加容易。'
- en: Using Promise.all to resolve multiple promises
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Promise.all解决多个承诺
- en: So far, we've seen how to use promises to perform asynchronous operations in
    sequence. This is useful when the individual steps are long-running operations.
    However, this might not always be the more efficient configuration. Quite often,
    we can perform multiple asynchronous operations at the same time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用承诺（promises）来按顺序执行异步操作。当单个步骤是长时间运行的操作时，这很有用。然而，这并不总是更有效的配置。很多时候，我们可以同时执行多个异步操作。
- en: In this recipe, we'll see how to use `Promise.all` to start multiple asynchronous
    operations, without waiting for the previous one to complete.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看到如何使用`Promise.all`来启动多个异步操作，而无需等待前一个操作完成。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `3-06-using-promise-all`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `3-06-using-promise-all`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`，该文件从`main.js`加载并运行一个`main`函数。
- en: 'Create a `main.js` file that creates an object named `rocket`, and calls `Promise.all`
    with an empty array as the first argument:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.js`文件，创建一个名为`rocket`的对象，并将空数组作为第一个参数调用`Promise.all`：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a function named `addBoosters` that creates an object with `boosters`
    to an object:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`addBoosters`的函数，该函数将`boosters`对象添加到另一个对象中：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a function named `performGuidanceDiagnostic` that returns a promise
    of a successfully completed task:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`performGuidanceDiagnostic`的函数，该函数返回一个成功完成的任务的承诺：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a function named `loadCargo` that adds a payload to the `cargoBay`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`loadCargo`的函数，该函数向`cargoBay`添加有效载荷：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use `Promise.resolve` to pass the `rocket` object to these functions within
    `Promise.all`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Promise.resolve`将这些函数中的`rocket`对象传递给`Promise.all`：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Attach a `then` call to the chain and log that the rocket is ready for launch:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`then`调用附加到链中，并记录火箭已准备好发射：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'You should see the following output:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/b12bfb42-682b-46de-8112-3776f098ffc0.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b12bfb42-682b-46de-8112-3776f098ffc0.png)'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Promise.all` is similar to `Promise.resolve`; the arguments are resolved as
    promises. The difference is that instead of a single result, `Promise.all` accepts
    an **iterable** argument, each member of which is resolved individually.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all`与`Promise.resolve`类似；参数被解析为承诺。区别在于，`Promise.all`接受一个**可迭代**参数，每个成员都单独解决。'
- en: In the preceding example, you can see that each of the promises is initiated
    immediately. Two of them are able to complete while `performGuidanceDiagnostic`
    continues. The promise returned by `Promise.all` is fulfilled when all the constituent
    promises have been resolved.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到每个承诺都是立即启动的。其中两个在`performGuidanceDiagnostic`继续进行时已经完成。当所有组成部分的承诺都已解决时，`Promise.all`返回的承诺得到满足。
- en: The results of the promises are combined into an array and propagated down the
    chain. You can see that three references to `rocket` are packed into the `results`
    argument. And you can see that the operations of each promise have been performed
    on the resulting object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的结果被组合成一个数组并向下传播。你可以看到三个对`rocket`的引用被打包到`results`参数中。你可以看到每个承诺的操作都已在对结果对象上执行。
- en: There's more
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'As you may have guessed, the results of the constituent promises don''t have
    to return the same value. This can be useful, for example, when performing multiple
    independent network requests. The index of the result for each promise corresponds
    to the index of the operation within the argument to `Promise.all`. In these cases,
    it can be useful to use array destructuring to name the argument of the `then`
    callback:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，组成部分的承诺不需要返回相同的值。这可能在执行多个独立的网络请求时很有用。每个承诺的结果索引对应于`Promise.all`参数中操作的索引。在这些情况下，使用数组解构来命名`then`回调的参数可能很有用：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Handling errors with Promise.catch
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Promise.catch处理错误
- en: In a previous recipe, we saw how to fulfill a promise with an error state using
    `reject`, and we saw that this triggers the next `catch` callback in the promise
    chain. Because promises are relatively easy to compose, we need to be able to
    handle errors that are reported in different ways. Luckily promises are able to
    handle this seamlessly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们看到了如何使用`reject`来满足具有错误状态的承诺，并看到这触发了承诺链中的下一个`catch`回调。由于承诺相对容易组合，我们需要能够处理以不同方式报告的错误。幸运的是，承诺能够无缝地处理这些问题。
- en: In this recipe, we'll see how `Promises.catch` can handle errors that are reported
    by being thrown or through rejection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到`Promises.catch`如何处理通过抛出或拒绝报告的错误。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `3-07-handle-errors-promise-catch`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`3-07-handle-errors-promise-catch`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`，该文件从`main.js`加载并运行一个`main`函数。
- en: 'Create a `main.js` file with a `main` function that creates an object named
    `rocket`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`main`函数的`main.js`文件，该函数创建一个名为`rocket`的对象：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a function `addBoosters` that throws an error:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个会抛出错误的`addBoosters`函数：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a function `performGuidanceDiagnostic` that returns a promise that rejects
    an error:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回拒绝错误的`performGuidanceDiagnostic`函数：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use `Promise.resolve` to pass the rocket object to these functions, and chain
    a `catch` off each of them:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Promise.resolve`将这些函数传递火箭对象，并在每个函数后面链式添加一个`catch`：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'You should see the following output:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/4b439577-7ac8-4d07-8f84-a3c6163bea50.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b439577-7ac8-4d07-8f84-a3c6163bea50.png)'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we saw before, when a promise is fulfilled in a rejected state, the callback
    of the `catch` functions is triggered. In the preceding recipe, we see that this
    can happen when the `reject` method is called (as with `performGuidanceDiagnostic`).
    It also happens when a function in the chain throws an error (as will `addBoosters`).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，当一个承诺在拒绝状态下被履行时，`catch`函数的回调会被触发。在先前的配方中，我们看到这会在调用`reject`方法时发生（例如，使用`performGuidanceDiagnostic`）。当链中的某个函数抛出错误时（例如`addBoosters`），也会发生这种情况。
- en: This has similar benefit to how `Promise.resolve` can normalize asynchronous
    functions. This handling allows asynchronous functions to not know about the promise
    chain, and announce error states in a way that is familiar to developers who are
    new to promises.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`Promise.resolve`如何使异步函数正常化有类似的益处。这种处理允许异步函数不知道承诺链，并以一种对新手承诺的开发者来说熟悉的方式宣布错误状态。
- en: This makes expanding the use of promises much easier.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得扩展承诺的使用变得更加容易。
- en: Simulating finally with the promise API
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺API模拟finally
- en: In a previous recipe, we saw how `catch` can be used to handle errors, whether
    a promise has rejected, or a callback has thrown an error. Sometimes, it is desirable
    to execute code whether or not an error state has been detected. In the context
    of `try`/`catch` blocks, the `finally` block can be used for this purpose. We
    have to do a little more work to get the same behavior when working with promises
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的配方中，我们看到了如何使用`catch`来处理错误，无论是承诺被拒绝，还是回调抛出错误。有时，我们希望无论是否检测到错误状态都执行代码。在`try`/`catch`块的情况下，`finally`块可以用于此目的。当与承诺一起工作时，我们必须做更多的工作才能获得相同的行为。
- en: In this recipe, we'll see how a final `then` call to execute some code in both
    successful and failing fulfillment states.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何通过承诺API模拟最终的`then`调用，以在成功和失败履行状态下执行一些代码。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `3-08-simulating-finally`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`3-08-simulating-finally`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`，它加载并运行来自`main.js`的`main`函数。
- en: 'Create a `main.js` file with a `main` function that logs out messages for before
    and after promise creation:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`main`函数的`main.js`文件，该函数在承诺创建前后记录消息：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a function named `addBoosters` that throws an error if its first parameter
    is `false`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`addBoosters`的函数，如果其第一个参数为`false`则抛出错误：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use `Promise.resolve` to pass a Boolean value that is `true` if a random number
    is greater than `0.5` to `addBoosters`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Promise.resolve`传递一个布尔值给`addBoosters`，如果随机数大于`0.5`则为`true`：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a `then` function to the chain that logs a success message:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链中添加一个记录成功信息的`then`函数：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add a `catch` to the chain and log out the error if thrown:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链中添加一个`catch`，如果抛出错误则记录下来：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a `then` after the `catch`, and log out that we need to make an announcement:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`catch`之后添加一个`then`，并记录我们需要发布公告：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'If you are lucky and the boosters are added successfully, you''ll see the following
    output:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运气好并且成功添加了助推器，你会看到以下输出：
- en: '![](img/8ee3df3b-4965-4107-98e1-3296c2962066.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ee3df3b-4965-4107-98e1-3296c2962066.png)'
- en: 'If you are unlucky, you''ll see an error message like the following:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运气不好，你会看到如下错误信息：
- en: '![](img/a58e2a09-c5ad-4405-bf52-42ac53443e84.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a58e2a09-c5ad-4405-bf52-42ac53443e84.png)'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We can see in the preceding output that whether or not the asynchronous function
    completes in an error state, the last `then` callback is executed. This is possible
    because the `catch` method doesn't stop the promise chain. It simply catches any
    error states from the previous links in the chain, and then propagates a new value
    forward.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的输出中看到，无论异步函数是否在错误状态下完成，最后的 `then` 回调都会被执行。这是可能的，因为 `catch` 方法不会停止承诺链。它只是捕获链中先前链接的任何错误状态，然后将新的值向前传播。
- en: The final `then` is then protected from being bypassed by an error state by
    this `catch`. And so, regardless of the fulfillment state of prior links in the
    chain, we can be sure that the callback of this final `then` will be executed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `then` 通过这个 `catch` 被保护，防止被错误状态绕过。因此，无论链中先前链接的履行状态如何，我们都可以确信这个最后的 `then`
    回调将被执行。
