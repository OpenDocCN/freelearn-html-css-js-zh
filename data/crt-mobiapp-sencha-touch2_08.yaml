- en: 'Chapter 8. Evolver: Using Profiles'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Evolver：使用配置文件
- en: With the growing popularity of mobile devices, web designers have had to deal
    with a wide variety of screen sizes. This is even tougher on web application developers
    who also need to allow for different functionality between devices. Sencha Touch
    offers an easy way of dealing with multiple devices, called profiles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动设备的日益普及，网页设计师不得不处理各种屏幕尺寸。这对需要在不同设备之间允许不同功能的网页应用开发者来说更加困难。Sencha Touch提供了一个简单的方法来处理多个设备，称为配置文件。
- en: Since the Sencha Touch framework is aware of which device it is running on,
    we can set up individual profiles for each device we want to support. Sencha Touch
    will then swap out components and functionality based on the device.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Sencha Touch框架知道它在哪个设备上运行，我们可以为每个我们想要支持的设备设置单独的配置文件。然后Sencha Touch将根据设备交换组件和功能。
- en: 'In this chapter we will look at:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨：
- en: An overview of profiles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件的概述
- en: Setting up profiles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置配置文件
- en: Testing profiles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试配置文件
- en: Loading custom CSS by device
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据设备加载自定义CSS
- en: We will create an application that reads pages and posts from a WordPress website
    and translates them into a custom application for mobile devices. We call this
    application, Evolver.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，从WordPress网站读取页面和帖子，并将它们转换为适用于移动设备的自定义应用程序。我们称这个应用程序为Evolver。
- en: Evolver will use separate profiles to create a view for iPhone and a different
    view for iPad. These views will have their own functionality and can be customized
    to suit the needs of the user and the device.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Evolver将使用不同的配置文件来为iPhone创建一个视图，并为iPad创建一个不同的视图。这些视图将具有自己的功能，并且可以根据用户和设备的需求进行定制。
- en: However, before we get too far ahead of ourselves, we should probably talk a
    little bit about what profiles do and when to use them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们过于深入之前，我们可能应该稍微谈谈配置文件的作用以及何时使用它们。
- en: An overview of profiles
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件的概述
- en: Profiles in Sencha Touch act much like a director, or a traffic cop. When the
    application loads, the profiles determine what kind of device they are being run
    on and load a different set of controllers and views based on the device (the
    stores and models typically do not change).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sencha Touch中，配置文件的作用类似于导演或交通警察。当应用程序加载时，配置文件会确定它们正在运行的设备类型，并根据设备（通常是存储和模型不会改变）加载不同的控制器和视图。
- en: 'As you may have guessed, this means that each profile (device) needs its own
    set of controllers and views. While they can, and do share elements such as stores
    and models, most of the display logic is unique to the device. This can seem like
    a lot of extra work, which leads to the question: when and why should you use
    profiles?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这意味着每个配置文件（设备）都需要自己的控制器和视图集。虽然它们可以，并且确实共享诸如存储和模型之类的元素，但大多数显示逻辑都是针对特定设备的。这可能会感觉像是一项额外的工作，这也引出了一个问题：何时以及为什么应该使用配置文件？
- en: Profile basics
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件基础
- en: As a general rule, it is usually a good idea to design an application specifically
    for a device or screen size. A smaller screen requires bigger fonts in order to
    be readable, but it also has less space for information. This means that it usually
    relies on multiple screens to get the information across to the user. A similar
    interface on a tablet device would be clunky and frustrating in most cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，为特定设备或屏幕尺寸设计应用程序通常是一个好主意。较小的屏幕需要更大的字体以便阅读，但同时也为信息提供了更少的空间。这意味着它通常依赖于多个屏幕将信息传达给用户。在平板电脑设备上，类似的界面在大多数情况下都会显得笨拙且令人沮丧。
- en: However, with a few simple applications, a change in CSS stylesheets will accomplish
    the necessary changes to the interface. A profile is not needed in this case and
    the stylesheet can simply be loaded based on the device being used. This method
    allows us to use the classes and IDs of our individual elements to control the
    overall appearance of our application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过一些简单的应用，CSS样式的更改就能实现界面所需的更改。在这种情况下不需要配置文件，可以直接根据使用的设备加载样式表。这种方法允许我们使用我们个别元素的类和ID来控制应用程序的整体外观。
- en: 'For most professional applications, a combination of profiles and stylesheet
    changes will better serve the end user. We can demonstrate this using some drawings
    of our Evolver application. Let''s start with our tablet version:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数专业应用，配置文件和样式表更改的组合将更好地服务于最终用户。我们可以通过一些Evolver应用程序的绘图来展示这一点。让我们从我们的平板电脑版本开始：
- en: '![Profile basics](img/8901OS_08_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![配置文件基础](img/8901OS_08_1.jpg)'
- en: Here we have a lot of screen real estate we can put to use. We can easily show
    our list of pages and posts, and still show the content of the selected item at
    the same time. We have room for multiple tabs and even a website logo.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有大量的屏幕空间可以利用。我们可以轻松显示我们的页面和帖子列表，同时还可以显示所选项目的内。我们有足够的空间放置多个标签，甚至是一个网站标志。
- en: 'If we were to view this kind of layout on a phone-sized screen, it would be
    far too small to effectively use or even read. As we noted before, a phone-sized
    screen needs larger fonts and multiple screens to display the data the user needs:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在手机大小的屏幕上查看这种布局，它将太小，无法有效使用，甚至难以阅读。正如我们之前提到的，手机大小的屏幕需要更大的字体和多个屏幕来显示用户所需的数据：
- en: '![Profile basics](img/8901OS_08_2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![个人资料基础](img/8901OS_08_2.jpg)'
- en: In this case we have two screens. The first is for our list of pages or posts.
    Our tabs at the bottom will determine which list the user sees. When the user
    selects an item from the list, we will use a second screen to display the content
    for the page or post. We will also provide a back button to allow the user to
    return to the mail list.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个屏幕。第一个是我们页面或帖子的列表。底部的标签将决定用户看到哪个列表。当用户从列表中选择一个项目时，我们将使用第二个屏幕来显示页面或帖子的内容。我们还将提供一个返回按钮，允许用户返回到邮件列表。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Sketches or Wireframes**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**草图或线框图**'
- en: Sketches like these are often called **wireframes**. It is a really good idea
    to draw out these types of ideas before you begin coding the application. They
    don't have to be fancy, they just need to make you think about how the application
    will be organized and how the user will get from one screen to the next. Wireframes
    can quickly highlight any issues you hadn't thought of yet, and they will save
    you a huge amount of time later on when you begin coding. It's also a good idea
    to show these wireframes to potential users. Non-technical people can often reveal
    areas of confusion for a user, and their questions and feedback will make your
    application more useful.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的草图通常被称为 **线框图**。在开始编码应用程序之前，将这些想法绘制出来是一个非常好的主意。它们不需要很复杂，只需要让你思考应用程序的组织方式以及用户如何从一个屏幕切换到下一个屏幕。线框图可以快速突出你尚未考虑的问题，并在你开始编码时节省大量时间。向潜在用户展示这些线框图也是一个好主意。非技术人士经常可以揭示用户的困惑区域，他们的疑问和反馈会使你的应用程序更有用。
- en: From looking at the two sketches, we can determine the views that we need and
    the different functions we will need in our controllers. For example, clicking
    on an item in the phone version will need to add a panel to a navigation view,
    while in the tablet version, clicking on an item will just replace the content
    in our main panel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这两个草图，我们可以确定我们需要哪些视图以及控制器中需要的不同功能。例如，在手机版本中点击一个项目需要向导航视图中添加一个面板，而在平板电脑版本中，点击一个项目只会替换我们主面板中的内容。
- en: Now that we have some idea of the different views and functions we want, we
    can take a look at how the profiles actually work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对想要的不同视图和功能有了些了解，我们可以看看个人资料实际上是如何工作的。
- en: Using profiles
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用个人资料
- en: The first part of our profile setup takes place in `app.js`. This file is typically
    where we load our initial stores and models, as well as set up a launch function
    to start the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们个人资料设置的第一个部分发生在 `app.js` 文件中。这个文件通常是加载我们的初始存储和模型的地方，以及设置一个启动函数来启动应用程序。
- en: 'With profiles, things work a bit differently. We start by declaring the profiles
    we wish to use like so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用个人资料时，事情的工作方式略有不同。我们首先声明我们希望使用的个人资料，如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The names for our two profiles are arbitrary and we can have as many as we like.
    They can be specific to an OS as well as device type. When we use profiles such
    as these, we typically do not use a launch function inside our `app.js` file.
    Since the profiles will have different starting screens, we place the launch function
    inside the individual profiles.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们两个个人资料的名字是任意的，我们可以有我们想要的任意多个。它们可以针对特定的操作系统以及设备类型。当我们使用这样的个人资料时，我们通常不在 `app.js`
    文件中使用启动函数。由于个人资料将具有不同的起始屏幕，我们将启动函数放在单独的个人资料中。
- en: The profiles should be placed in a directory called `profile`, inside the `app`
    directory of your application. They should be named the way you named them in
    your `app.js` file (in our case this would be `Phone.js` and `Tablet.js`).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 个人资料应该放在一个名为 `profile` 的目录中，位于应用程序的 `app` 目录内。它们的命名方式应该与你在 `app.js` 文件中命名的方式相同（在我们的例子中这将分别是
    `Phone.js` 和 `Tablet.js`）。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If it helps, you can think of the profile files as a way to have multiple `app.js`
    files, one per device.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有帮助，您可以想象配置文件文件就像是一种拥有多个 `app.js` 文件的方式，每个设备一个。
- en: 'These individual profiles will load our views and controllers, and they will
    launch our initial screen. However, the first thing we need to do is figure out
    which profile is active. We do this by creating an `isActive` function in our
    `Phone.js` file like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单独的配置文件将加载我们的视图和控制器，并将启动我们的初始屏幕。然而，我们首先需要做的是确定哪个配置文件是激活的。我们通过在 `Phone.js`
    文件中创建一个 `isActive` 函数来实现这一点，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This `isActive` function will return true if the application is running on
    a phone. We use a similar function in our `Tablet.js` profile:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该函数返回 true，则表示应用程序正在手机上运行。我们在 `Tablet.js` 配置文件中也使用了一个类似的功能：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our `app.js` file will load one of these profiles, if the `isActive` function
    returns true. Only one of these profiles should ever return true.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `isActive` 函数返回 true，则 `app.js` 文件将加载这些配置文件中的一个。只有一个配置文件应该始终返回 true。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about the `Ext.os.is` function in the Sencha Touch
    developer documentation located at [http://docs.sencha.com/touch/2-1/#!/api/Ext.env.OS-method-is](http://docs.sencha.com/touch/2-1/#!/api/Ext.env.OS-method-is).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在位于 [http://docs.sencha.com/touch/2-1/#!/api/Ext.env.OS-method-is](http://docs.sencha.com/touch/2-1/#!/api/Ext.env.OS-method-is)
    的 Sencha Touch 开发者文档中找到有关 `Ext.os.is` 函数的更多信息。
- en: Each profile will also contain its own views and controllers, as well as its
    own launch function. However, it is important to note that the `Ext.loader` function
    will automatically look for these items in a subfolder named after the profile.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置文件也将包含其自己的视图和控制器，以及其自己的启动函数。然而，重要的是要注意，`Ext.loader` 函数将自动在以配置文件命名的子文件夹中查找这些项目。
- en: 'For example, our tablet profile has a controller called `Main.js`. We include
    this in our profile the same way we normally would in `app.js`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的平板电脑配置文件有一个名为 `Main.js` 的控制器。我们以通常在 `app.js` 中包含的方式将其包含在我们的配置文件中：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, since this controller is inside a profile, the `Ext.loader` function
    will look for the file as `app/controllers/tablet/Main.js`. Conversely, in our
    phone profile, we still include the controller as `controllers: [''Main'']`, but
    the loader will automatically look for the file as `app/controllers/phone/Main.js`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，由于此控制器位于配置文件中，`Ext.loader` 函数将按 `app/controllers/tablet/Main.js` 查找文件。相反，在我们的手机配置文件中，我们仍然将控制器包含为
    `controllers: [''Main'']`，但加载器将自动按 `app/controllers/phone/Main.js` 查找文件。'
- en: 'You can override this behavior in a profile by using the full name of the controller
    like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用控制器的全称来覆盖此行为，例如：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would look for the `Main.js` file in the `app/controller` folder. This
    works the same for views, models, and stores as well.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `app/controller` 文件夹中查找 `Main.js` 文件。这对于视图、模型和存储也是一样的。
- en: 'You will also find that some files are common to both profiles. Rather than
    including them in our individual profiles, we can include these common files in
    `app.js`. For example, in our Evolver application, we will have models and stores
    for pages and posts. These will be common to both profiles, so we can add them
    as normal in `app.js`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会发现一些文件在两个配置文件中都是通用的。我们不是将它们包含在我们的单独配置文件中，而是可以将这些通用文件包含在 `app.js` 中。例如，在我们的
    Evolver 应用程序中，我们将有页面和帖子模型和存储。这些将适用于两个配置文件，因此我们可以在 `app.js` 中正常添加它们：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since these load from `app.js` (and not from one of our profiles), the loader
    will look for them in the `app/model` and `app/store` folders respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是从 `app.js`（而不是从我们的配置文件之一）加载的，因此加载器将在 `app/model` 和 `app/store` 文件夹中分别查找它们。
- en: As we noted before, the profiles also have individual launch functions in addition
    to the optional `launch` function in `app.js`. In a profile-based application,
    the `app.js launch` function is typically ignored since the profiles will likely
    launch different components to create the main screen. However, if the application
    requires it, you can use the `app.js launch` function as well, to perform clean
    up or load stores if desired.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，配置文件除了 `app.js` 中的可选 `launch` 函数外，还有各自的启动函数。在基于配置文件的应用程序中，`app.js`
    中的 `launch` 函数通常会被忽略，因为配置文件可能会启动不同的组件来创建主屏幕。但是，如果应用程序需要，您也可以使用 `app.js` 中的 `launch`
    函数，以执行清理或加载存储（如果需要的话）。
- en: 'The order works something like this (when the application starts):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序大致如下（当应用程序启动时）：
- en: The active profile is determined.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活配置文件已确定。
- en: Any controllers in the profile or in `app.js` are instantiated (meaning the
    `init` function is fired).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件或 `app.js` 中的任何控制器都将被实例化（这意味着将触发 `init` 函数）。
- en: The launch function in the profile fires.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件中的启动函数被触发。
- en: The launch function in `app.js` fires.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app.js`中的启动函数被触发。'
- en: It should be noted that both the profile and `app.js launch` functions are optional
    and will only be called if they are defined.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，个人资料和`app.js launch`功能都是可选的，并且只有在它们被定义的情况下才会被调用。
- en: Now that we have the profile basics out of the way, let's get a little more
    specific about our application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了个人资料的基本内容，让我们对我们的应用程序进行更具体的了解。
- en: Creating the Evolver application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Evolver应用程序
- en: The Evolver application takes an RSS feed from a WordPress website and translates
    the feed into data in a Sencha Touch store. We did something similar in our previous
    Feedback application with the RSS feed. However, we are going to need a bit of
    extra help to get all of the information we need out of WordPress.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Evolver应用程序从WordPress网站获取RSS源，并将源转换为Sencha Touch存储中的数据。我们在之前的Feedback应用程序中也使用过RSS源。然而，我们需要一些额外的帮助来从WordPress中获取所有所需的信息。
- en: About WordPress
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于WordPress
- en: For those of you who don't know about WordPress, it is a content management
    system that was initially designed for blogging. WordPress allows a user to easily
    create posts and pages using simple web-based forms. Posts tend to be shorter,
    time-sensitive items, while pages contain longer, more general information.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不了解WordPress的人来说，它是一个最初为博客设计的内容管理系统。WordPress允许用户通过简单的基于Web的表单轻松创建文章和页面。文章通常是较短的、时间敏感的项目，而页面则包含更长、更通用的信息。
- en: When WordPress began to gain popularity, users quickly began to use it for all
    kinds of websites from personal, to business and shopping. Current estimates are
    that the WordPress site numbers somewhere north of 55 million, comprising an estimated
    15 to 20 percent of the active websites on the Internet.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当WordPress开始流行时，用户迅速开始将其用于各种网站，从个人到商业和购物。目前的估计是，WordPress网站数量超过5500万，占互联网上活跃网站的15%到20%。
- en: 'With the ease of installation and massive amounts of customization, WordPress
    has become a darling of the small business community. The one drawback is that
    the design complexity of a typical WordPress website doesn''t always lend itself
    to a mobile-sized screen and platform. The following screenshot is an example
    of a standard WordPress style website:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安装简单和大量定制，WordPress已经成为小型商业社区的宠儿。唯一的缺点是，典型WordPress网站的设计复杂性并不总是适合移动屏幕和平台。以下截图是一个标准WordPress风格网站的示例：
- en: '![About WordPress](img/8901OS_08_3.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![关于WordPress](img/8901OS_08_3.jpg)'
- en: 'While this kind of layout appears fine on a desktop or laptop screen, it''s
    not a great use of space for a tablet, and way too much information for a phone-sized
    screen. We need a mobile-friendly version of the site that makes effective use
    of the advantages and limitations of tablet and phone platforms. The following
    screenshot is an example of the approach we want to take:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种布局在桌面或笔记本电脑屏幕上看起来不错，但对于平板电脑来说并不是很好的空间利用，对于手机大小的屏幕来说信息量过大。我们需要一个对移动设备友好的网站版本，能够有效利用平板和手机平台的优势和局限性。以下截图是我们想要采取的方法的示例：
- en: '![About WordPress](img/8901OS_08_4.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![关于WordPress](img/8901OS_08_4.jpg)'
- en: Since the data behind the WordPress website already lives in a MySQL database,
    we just need a way to get it into a data store so we can use it in Sencha Touch.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WordPress网站背后的数据已经存在于MySQL数据库中，我们只需要一种方法将其放入数据存储中，以便我们可以在Sencha Touch中使用它。
- en: The posts from WordPress are available in RSS format, but the pages are not.
    We are going to need to use a plugin for WordPress in order to get the pages we
    want as well. You will need to use your own WordPress website to make this work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress发布的文章以RSS格式提供，但页面不是。我们将需要使用WordPress插件来获取我们想要的页面。您需要使用自己的WordPress网站来实现这一点。
- en: Using the plugin
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用插件
- en: WordPress plugins allow you to extend the basic functions and features of WordPress.
    In most cases this process is as simple as searching and clicking on the install
    button. In this case, we will be installing Dan Phiffer's JSON API plugin. This
    plugin will allow us to make standard API calls into our WordPress site.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress插件允许您扩展WordPress的基本功能和特性。在大多数情况下，这个过程就像搜索并点击安装按钮一样简单。在这种情况下，我们将安装Dan
    Phiffer的JSON API插件。此插件将允许我们向我们的WordPress网站发出标准API调用。
- en: 'Let''s install the plugin and then we can see how it works with a bit of testing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装插件，然后我们可以通过一些测试来看看它是如何工作的：
- en: From your WordPress admin page, select **Plugins** from the menu.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的WordPress管理页面，从菜单中选择**插件**。
- en: On the **Plugins** page, click on the **Add New** button.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **插件** 页面上，点击 **添加新插件** 按钮。
- en: Enter `JSON API` in the **Search** field and click on **Search Plugins**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **搜索** 字段中输入 `JSON API` 并点击 **搜索插件**。
- en: Click on **Install** next to the **JSON API** plugin (it should be the first
    one in the list).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **安装** 按钮旁边的 **JSON API 插件**（它应该是列表中的第一个）。
- en: 'You can test to see if the plugin has been installed correctly by checking
    the following URL in your web browser(replace `yourwordpressdomain.com` with the
    address of your WordPress installation):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查以下 URL 来测试插件是否已正确安装（将 `yourwordpressdomain.com` 替换为你的 WordPress 安装地址）：
- en: '[http://yourwordpressdomain.com/api/get_page_index/](http://yourwordpressdomain.com/api/get_page_index/)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://yourwordpressdomain.com/api/get_page_index/](http://yourwordpressdomain.com/api/get_page_index/)'
- en: 'You should get back a JSON response string with the pages for your site. Note
    that this string comes back as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会收到一个包含你网站页面的 JSON 响应字符串。注意，这个字符串返回如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We need to keep in mind that the `pages` array actually contains the data we
    are looking for. This will get set as `rootProperty` of the store's reader component
    when we create our store.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，`pages` 数组实际上包含我们正在寻找的数据。当我们创建存储时，这将设置为存储的读取组件的 `rootProperty`。
- en: Setting up the profiles and app.js
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置配置文件和 app.js
- en: We will start with a basic Sencha Touch application, set up from our command-line
    SDK tools (as we did in some of our earlier chapters). This creates our application
    shell and our view, model, store, and controller folders.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基本的 Sencha Touch 应用程序开始，使用我们的命令行 SDK 工具设置（就像我们在一些早期的章节中所做的那样）。这会创建我们的应用程序外壳以及视图、模型、存储和控制器文件夹。
- en: 'In our `app.js` file, we will add lines for our profiles. We also have some
    common elements in both profiles, specifically, the models and stores for pages
    and profiles. Since these will need to load for both profiles, we can add them
    in our `Ext.application` declaration, rather than adding them twice, once in each
    profile file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `app.js` 文件中，我们将添加我们的配置文件行。我们还在两个配置文件中都有一些公共元素，特别是页面和配置文件的模型和存储。由于这些将需要为两个配置文件加载，我们可以在
    `Ext.application` 声明中添加它们，而不是在每个配置文件中各添加一次：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have our `app.js` file set up, we need to create a `profile` folder
    in our `app` directory. This is where our two profiles will go.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 `app.js` 文件，我们需要在 `app` 目录中创建一个 `profile` 文件夹。这是我们的两个配置文件将存放的地方。
- en: 'Our `Phone.js` profile looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Phone.js` 配置文件如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have three pieces here: the `config` section, our `isActive` function, and
    our `launch` function.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有三个部分：`config` 部分、`isActive` 函数和 `launch` 函数。
- en: Our `config` section has the profile `name`, `controllers` and `views` values.
    Remember that since we are in the profile, the loader will be looking for these
    files in `app/controller/phone` and `app/view/phone` respectively.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `config` 部分包含配置文件 `name`、`controllers` 和 `views` 的值。记住，由于我们处于配置文件中，加载器将在
    `app/controller/phone` 和 `app/view/phone` 分别查找这些文件。
- en: 'Notice that we also have two of our views listed with the full names: `Evolver.view.PostList`
    and `Evolver.view.PageList`. These views will actually be shared by both profiles,
    so we put them in the `app/views` folder. We could also just put them in `app.js`
    and it would accomplish the same thing. We included them here to demonstrate that
    the file location can be overridden if required.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还有两个带有完整名称的视图列在我们的列表中：`Evolver.view.PostList` 和 `Evolver.view.PageList`。这些视图实际上将由两个配置文件共享，因此我们将它们放在
    `app/views` 文件夹中。我们也可以只是将它们放在 `app.js` 中，这也会达到相同的效果。我们在这里包括它们是为了演示如果需要，可以覆盖文件位置。
- en: Our `isActive` function will return true if we are running on a phone.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `isActive` 函数将返回 true，如果我们正在手机上运行。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**isActive, device types, and Safari**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**isActive、设备类型和 Safari**'
- en: If you are testing on Safari with a desktop or laptop, you will run into some
    issues using this function. Despite the ability to set the user agent in Safari
    to iPad or iPod, the browser does not correctly report the device type to Sencha
    Touch.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用桌面或笔记本电脑上的 Safari 进行测试，使用此功能会遇到一些问题。尽管可以在 Safari 中设置用户代理为 iPad 或 iPod，但浏览器并没有正确地向
    Sencha Touch 报告设备类型。
- en: When you are testing, you will need to comment out the `return Ext.os.is.Phone`
    or `return Ext.os.is.Tablet` lines in the `isActive` function. Then you can set
    the `isActive` function in the profile you want to test to `return true;` and
    the other one to `return false;`. Just remember to uncomment the correct functions
    before moving to production.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，您需要在`isActive`函数中注释掉`return Ext.os.is.Phone`或`return Ext.os.is.Tablet`行。然后，您可以将您想要测试的配置文件中的`isActive`函数设置为`return
    true;`，另一个设置为`return false;`。只需记住在转移到生产环境之前取消注释正确的函数。
- en: If you are testing with the iOS or Android simulators, this is not an issue.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用iOS或Android模拟器进行测试，这不是问题。
- en: The `launch` function removes our loading indicator and creates an instance
    of our `Evolver.view.phone.Main` view at full screen size.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch`函数移除我们的加载指示器，并在全屏大小创建我们的`Evolver.view.phone.Main`视图实例。'
- en: 'Our `Tablet.js` profile follows the same pattern as our phone profile:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Tablet.js`配置文件遵循与手机配置文件相同的模式：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Much like the phone profile, the controllers and views will be loaded from a
    `tablet` folder in our `app/controllers` and `app/views` folders.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与手机配置文件类似，控制器和视图将从我们的`app/controllers`和`app/views`文件夹中的`tablet`文件夹加载。
- en: We are going to take a very brief look at the stores, models, and views for
    the application as there isn't much new here. Then, we will finish up with the
    controllers, where the action really happens.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里没有太多新内容，我们将简要地查看应用的存储、模型和视图。然后，我们将完成控制器部分，因为真正的动作就发生在那里。
- en: Setting up the models and stores
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置模型和存储
- en: Our models are very basic, and they are taken from the data that is sent back
    from the RSS feed for posts and the JSON API plugin for pages. We are only using
    some of that data, but you can easily look through the values that are returned
    from `yoursite/feeds/rss/` (posts) and `yoursite/api/get_page_index/` (pages)
    to see if there is any other interesting data you might want to use.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式非常基础，它们来自RSS订阅源返回的帖子数据和页面JSON API插件。我们只使用其中的一些数据，但您可以轻松地查看从`yoursite/feeds/rss/`（帖子）和`yoursite/api/get_page_index/`（页面）返回的值，以查看是否有其他您可能想要使用的数据。
- en: 'Our post model looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文章模型看起来像这样：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only thing new here is the use of mapping to indicate that, while we will
    refer to the strings as `author` and `content`, the data is actually received
    as `creator` and `encoded` respectively. This is often helpful to keep values
    consistent across the application, avoid naming conflicts, or simply preserve
    a coder's sanity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新变化是使用映射来指示，虽然我们将字符串称为`author`和`content`，但数据实际上以`creator`和`encoded`分别接收。这通常有助于在整个应用中保持值的一致性，避免命名冲突，或者简单地保持代码员的理智。
- en: 'The `postStore` attribute for this model is configured to run from the same
    server as the WordPress website you are using. This means we can use an `ajax`
    store instead of a `jsonp` store. If you want to use this from a different server,
    you will need to change the proxy to `jsonp` and use the JSON API to grab the
    posts instead of the standard WordPress RSS feed (which is in XML):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型的`postStore`属性配置为从您使用的WordPress网站相同的服务器运行。这意味着我们可以使用`ajax`存储而不是`jsonp`存储。如果您想从不同的服务器使用它，您需要将代理更改为`jsonp`，并使用JSON
    API来获取帖子，而不是标准的WordPress RSS订阅源（它位于XML中）：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `record: ''item''` configuration tells the reader to look in the XML for
    a collection of items to be used as the data for its records.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`record: ''item''` 配置指示读者在XML中查找用于其记录数据的一组项目。'
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**WordPress RSS feeds**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**WordPress RSS订阅源**'
- en: By default, RSS feeds in WordPress are set to only show a partial text of the
    post. You can change this in the **Admin** control panel of your WordPress site.
    In the **Admin** menu select **Settings** | **Reading** and change the feed settings
    from **Summary** to **Full Text**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，WordPress中的RSS订阅源仅显示文章的部分文本。您可以在WordPress网站的**管理**控制面板中更改此设置。在**管理**菜单中选择**设置**
    | **阅读**，并将订阅设置从**摘要**更改为**全文**。
- en: Since this store is not a JSONP store, it has to be run on the same server as
    the WordPress site it is pulling from. There is not an equivalent XMLP store,
    so testing on a local machine will require a bit of a workaround. During testing,
    you can download the RSS feed from your WordPress site to your local machine and
    read from the local XML file. Later, when you move to production, you can change
    the URL to the live link.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个存储库不是JSONP存储库，它必须运行在与它从WordPress网站拉取的同一服务器上。没有等效的XMLP存储库，因此在本地机器上进行测试需要一些变通方法。在测试期间，您可以从WordPress网站下载RSS源到您的本地机器，并从本地XML文件中读取。稍后，当您迁移到生产环境时，您可以更改URL到实时链接。
- en: 'Our `pageStore` is designed to use the JSON API plugin, so we will be taking
    in JSON instead of XML:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`pageStore`是为使用JSON API插件而设计的，因此我们将接收JSON而不是XML：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this store we are reading JSON from our API. The `get_page_index` function
    will return a hierarchical list of the pages for the website.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个存储库，我们从API读取JSON。`get_page_index`函数将返回网站页面的分层列表。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The JSON API plugin for WordPress has a number of helpful functions you can
    use to read and write data to your WordPress website. A full list of functions
    can be found here at [http://wordpress.org/extend/plugins/json-api/other_notes/](http://wordpress.org/extend/plugins/json-api/other_notes/).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress的JSON API插件提供了一些有用的函数，您可以使用这些函数读取和写入WordPress网站的数据。完整的函数列表可以在以下链接中找到：[http://wordpress.org/extend/plugins/json-api/other_notes/](http://wordpress.org/extend/plugins/json-api/other_notes/)。
- en: 'Our data model for the pages is using a limited set of the data supplied by
    the JSON API plugin:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为页面使用的数据模型使用了JSON API插件提供的有限数据集：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see a full list of all the data available by going to the API URL for
    your WordPress site ([http://yourWordPressSite.com/api/get_page_index/?dev=1](http://yourWordPressSite.com/api/get_page_index/?dev=1)).
    The `dev1` argument will format the JSON response and make it more readable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问WordPress网站的API URL来查看所有可用的数据列表（[http://yourWordPressSite.com/api/get_page_index/?dev=1](http://yourWordPressSite.com/api/get_page_index/?dev=1)）。`dev1`参数将格式化JSON响应并使其更易于阅读。
- en: Now that we have our stores and models, we can work on our views for displaying
    the data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储和模型，我们可以着手创建用于显示数据的视图。
- en: Creating the views
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视图
- en: Since we will be sharing the list views for our post and pages between our two
    profiles, let's start there. We will be using a data view instead of a list view,
    as this provides us with a few more display options than a simple list.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在两个配置文件之间共享我们的帖子列表和页面列表，让我们从这里开始。我们将使用数据视图而不是列表视图，因为这与简单的列表相比提供了更多的显示选项。
- en: 'Our `PostList.js` file looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PostList.js`文件如下所示：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Much like our standard list, `DataView` takes a data store and displays the
    items in order from the store. However, `DataView` is more flexible from a styling
    point of view, allowing the creation of tiled lists and other more interesting
    layouts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准列表类似，`DataView`接受数据存储并按顺序从存储中显示项目。然而，`DataView`在样式方面更为灵活，允许创建拼贴列表和其他更有趣的布局。
- en: This view reads from `postStore` and uses `itemTpl` to display the title, author,
    and date from each post. Each of our data items is styled with a particular class,
    which means we can display them in different ways depending on which stylesheet
    we load, or even turn them off completely. We will talk about these kinds of conditional
    stylesheets towards the end of the chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图从`postStore`读取并使用`itemTpl`显示每篇帖子的标题、作者和日期。我们每个数据项都使用特定的类进行样式化，这意味着我们可以根据加载的样式表以不同的方式显示它们，甚至可以完全关闭它们。我们将在本章的末尾讨论这些类型的条件样式表。
- en: 'Our `PageList` view follows a similar structure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PageList`视图遵循类似的架构：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This shared view reads from our `pageStore` and displays just the title and
    date. As noted, you can add any of the other data generated by the WordPress JSON
    API, and then use a conditional stylesheet to show it or hide it, based on the
    device the user is viewing from.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个共享视图从我们的`pageStore`读取并仅显示标题和日期。正如所注，您可以添加由WordPress JSON API生成的任何其他数据，然后使用条件样式表根据用户查看的设备显示或隐藏它。
- en: Our other views will be unique to either the phone or tablet profile. For the
    purposes of this chapter, each of the views are similar, each is a simple container
    with a template to format the record for display. Let's start with our phone details
    container.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的其他视图将针对手机或平板电脑配置文件而独特。在本章的目的上，每个视图都类似，每个都是一个简单的容器，包含一个模板来格式化记录以供显示。让我们从我们的手机详情容器开始。
- en: Creating the phone details view
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建手机详情视图
- en: Since this details container is part of our phone profile, it is named `Evolver.view.phone.PageDetails`
    and it will be in the `app/view/phone/` folder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个详情容器是我们电话配置文件的一部分，因此它被命名为`Evolver.view.phone.PageDetails`，并且它将位于`app/view/phone/`文件夹中。
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We also set a configuration for `scrollable` in this view. Since we are in a
    navigation view, which can be triggered with a swipe, we set the direction and
    direction lock to keep the swipe from triggering a page change.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也为此视图设置了`scrollable`配置。由于我们处于一个可以通过滑动触发的导航视图中，我们设置了方向和方向锁定，以防止滑动触发页面更改。
- en: Creating the tablet details view
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建平板电脑详情视图
- en: 'The tablet version of our `PageDetails.js` view looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`PageDetails.js`视图的平板版本看起来是这样的：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The only differences between the two are the name (`Evolver.view.tablet.PageDetails`)
    and the URL for the page which we include at the bottom of `tpl`. While a **View
    Original Page** link is common in most tablet-based apps, it's not really needed
    for a phone app since we are trying to avoid the original site in the first place.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本之间的唯一区别是名称（`Evolver.view.tablet.PageDetails`）和页面的URL，我们在`tpl`底部包含这个URL。虽然大多数基于平板的应用程序中都有“查看原始页面”的链接，但对于电话应用程序来说，这并不是必需的，因为我们首先试图避免原始网站。
- en: We will be handling the scrolling differently in the tablet version, so we do
    not include a `scrollable` configuration here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在平板版本中处理滚动的方式不同，所以我们在这里不包括`scrollable`配置。
- en: As previously noted, you could make these two containers as different as you
    want. You could make one of them a panel and the other a container if you prefer.
    Since only one of them will actually be included, we can even keep the same value
    for our `alias` attribute of `widget.pageDetails`. There will not be an `xtype`
    conflict because only the phone version or the tablet version will ever be active
    at one time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以使这两个容器尽可能不同。如果你愿意，你可以将其中一个做成面板，另一个做成容器。由于实际上只有一个会被包含，我们甚至可以保持`widget.pageDetails`的`alias`属性值相同。不会出现`xtype`冲突，因为电话版本或平板版本在任何时候都只会激活一个。
- en: Our `postDetails` object for phone and tablet follow the same format, so we
    won't bother covering them here. You can see them in the sample code for the chapter.
    Just remember that the phone versions go in `app/view/phone` and the tablet versions
    go in `app/view/tablet`. Also, the view naming conventions will follow the format
    of `Evolver.view.phone.viewName` and `Evolver.view.tablet.viewName`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为电话和平板电脑的`postDetails`对象遵循相同的格式，所以我们在这里不详细说明。你可以在章节的示例代码中看到它们。只需记住，电话版本放在`app/view/phone`中，平板版本放在`app/view/tablet`中。此外，视图命名约定将遵循`Evolver.view.phone.viewName`和`Evolver.view.tablet.viewName`的格式。
- en: Now, we need to put the individual pieces together into a main container for
    each of our profiles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将各个部分组合成一个主容器，用于我们的每个配置文件。
- en: The main views
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主视图
- en: 'From our original sketches, we have two different interfaces. The first one
    we will look at is the phone interface:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的原始草图来看，我们有两个不同的界面。我们将首先查看的是电话界面：
- en: '![The main views](img/8901OS_08_5.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![主视图](img/8901OS_08_5.jpg)'
- en: Since a phone screen has limited size, we need to create a more compact and
    layered interface. This will allow us to display all of our data, while still
    providing the user with readable text.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电话屏幕尺寸有限，我们需要创建一个更紧凑和分层的界面。这将允许我们显示所有数据，同时仍然为用户提供可读的文本。
- en: Creating the phone main view
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建电话主视图
- en: 'The phone `Main.js` interface will consist of a tab view with two DataViews
    (one for pages and one for posts). Each DataView is inside a navigation view.
    When we click an item in the DataView, the controller will pop our details container
    onto the navigation view, creating a back button automatically:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 电话`Main.js`界面将包含一个带有两个DataView（一个用于页面，一个用于帖子）的标签视图。每个DataView都在一个导航视图中。当我们点击DataView中的项目时，控制器将弹出我们的详情容器到导航视图中，自动创建一个返回按钮：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We give this view an `id` value of `mainView` to make it easy to address within
    our controller. You will notice that the navigation views have a `title` configuration,
    and the DataView inside each navigation view has its own `title` configuration
    as well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给这个视图一个`id`值为`mainView`，以便在控制器中轻松引用。你会注意到导航视图有一个`title`配置，并且每个导航视图内的DataView也有自己的`title`配置。
- en: The two navigation views are direct children of the overall tab panel. This
    means that the title on the tabs at the bottom of our main tab panel will use
    this title. The DataViews inside the navigation views each have a title bar component,
    which will display the title for each DataView at the top.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 两个导航视图是整体标签面板的直接子视图。这意味着我们主标签面板底部的标签上的标题将使用这个标题。导航视图内部的数据视图每个都有一个标题栏组件，它将在顶部显示每个数据视图的标题。
- en: By using a two-list strategy with the navigation view for popping on the details,
    we make the best use of our limited phone screen area. With our tablet profile,
    we have a bit more room to work with, so we can take a different approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用带有导航视图的弹出详情的双列表策略，我们最大限度地利用了我们有限的手机屏幕区域。在我们的平板配置中，我们有更多的工作空间，因此我们可以采取不同的方法。
- en: Creating the tablet main view
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建平板主视图
- en: 'Since we have additional room available on a tablet-sized screen, we can use
    a different view to take advantage of the extra space:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在平板尺寸的屏幕上有额外的空间，我们可以使用不同的视图来利用额外的空间：
- en: '![Creating the tablet main view](img/8901OS_08_6.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![创建平板主视图](img/8901OS_08_6.jpg)'
- en: 'Our tablet `Main.js` view has the two DataViews in a tab panel much like our
    phone profile version. However, the tablet version keeps a visible main content
    area where we can display the currently selected item. We also include an area
    above the content where we can place the website logo using the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们平板的`Main.js`视图在标签面板中有两个数据视图，这与我们的手机配置版本类似。然而，平板版本保持了一个可见的主内容区域，我们可以在这里显示当前选定的项目。我们还在内容上方包含了一个区域，我们可以使用以下代码放置网站标志：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We start by extending the basic `Ext.Panel` component and giving it a `fit`
    layout. Inside this panel are a tab panel and two containers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先扩展基本的`Ext.Panel`组件，并给它一个`fit`布局。在这个面板内部有一个标签面板和两个容器。
- en: The `tabpanel` component contains our two DataViews (pages and posts), just
    as we had them in the phone version of the application. We set this up to have
    a `width` value of `200`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`tabpanel`组件包含我们的两个数据视图（页面和帖子），就像我们在应用程序的手机版本中一样。我们将其设置为`width`值为`200`。'
- en: The content container is set to a `vbox` layout with three child containers.
    The top container for our logo will have a `height` value of `140` and an HTML
    link to the logo from our WordPress site. The `vbox` layout means that our other
    containers, with our content for posts and pages, will automatically resize to
    fit the rest of the available space.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 内容容器设置为具有三个子容器的`vbox`布局。用于我们标志的顶部容器将具有`height`值为`140`，以及从我们的WordPress网站到标志的HTML链接。`vbox`布局意味着我们的其他容器，包括我们的帖子内容和页面内容，将自动调整大小以适应剩余的空间。
- en: Notice that our `postdetails` container is hidden by default and the page details
    are visible. We will swap these two containers based on which DataView is selected
    in our controller.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的`postdetails`容器默认是隐藏的，而页面详情是可见的。我们将根据控制器中选定的数据视图来交换这两个容器。
- en: Creating the controllers
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建控制器
- en: The Evolver application uses a pair of DataViews (one for posts and one for
    pages), which are shared between both the phone and tablet profiles. In the case
    of the phone profile, the DataView needs to listen for the tap event and add a
    new details component to the navigation container. In the case of the tablet profile,
    the DataView is still listening for the tap event, but it needs to swap the two
    details containers based on which the DataView is selected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Evolver应用程序使用一对数据视图（一个用于帖子，一个用于页面），这些视图在手机和平板配置之间共享。在手机配置的情况下，数据视图需要监听触摸事件并向导航容器添加一个新的详情组件。在平板配置的情况下，数据视图仍然监听触摸事件，但需要根据选定的数据视图交换两个详情容器。
- en: 'By isolating the functionality from the display logic, we can make a single
    DataView perform two different actions (one in the phone version and another in
    the tablet version). We start this out in both our `phone.js` and `main.js` controllers,
    and our `tablet.js` and `main.js` controllers like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将功能与显示逻辑分离，我们可以使单个数据视图执行两种不同的操作（一个在手机版本中，另一个在平板版本中）。我们从`phone.js`和`main.js`控制器开始，以及`tablet.js`和`main.js`控制器如下：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The phone profile version is shown here, but at this point the tablet version
    is actually the same, just named `Evolver.controller.tablet.Main`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的是手机配置版本，但在这个阶段，平板版本实际上是相同的，只是命名为`Evolver.controller.tablet.Main`。
- en: Our references set up our short hand pointers to our components. Since `postList`
    and `pageList` are the same for both applications, and we consistently named our
    main container for both profiles, the references are the same in both controllers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的引用设置了指向我们组件的快捷指针。由于`postList`和`pageList`在两个应用程序中都是相同的，并且我们一致地为两个配置文件的主要容器命名，因此引用在两个控制器中都是相同的。
- en: We also use the same code for our `control` configurations, where both lists
    need to listen for the `itemTap` event to trigger our function. To make our lives
    easier, we also make the DataViews trigger the same function called `onListItemTap`.
    We can decide what needs to happen based on which list got tapped.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用相同的代码为我们的`control`配置，其中两个列表都需要监听`itemTap`事件以触发我们的函数。为了使我们的工作更简单，我们还让DataViews触发名为`onListItemTap`的相同函数。我们可以根据哪个列表被点击来决定需要发生什么。
- en: 'Here is where our two controllers diverge. Let''s start with the phone version
    of the `onListItemTap` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们两个控制器开始分叉的地方。让我们从`onListItemTap`函数的手机版本开始：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We do some interesting manipulations with the first part of this function to
    modify our content to display better on a phone-sized screen. Since the content
    coming back to us has full-sized images, it will often take up a huge amount of
    space on a phone-sized screen, making the layout kind of crummy.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此函数的第一部分进行一些有趣的操作，以修改我们的内容，使其在手机大小的屏幕上显示得更好。由于返回给我们的内容包含全尺寸图像，它通常会在手机大小的屏幕上占用大量空间，使得布局看起来有点糟糕。
- en: 'To solve this problem, we first grab the content out of the record with this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们首先使用以下方法从记录中获取内容：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we make two passes through the content to find and replace some of the
    image information so that we can manipulate the sizes the way we want. The first
    pass looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对内容进行两次遍历，以查找和替换一些图像信息，这样我们就可以按我们的意愿调整大小。第一次遍历看起来像这样：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will take an image tag with a `src` link that looks like [http://mydomain.com/images/image15.png](http://mydomain.com/images/image15.png)
    and turn it into `http://src.sencha.io/120/http://mydomain.com/images/image15.png`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把一个带有`src`链接的图像标签[http://mydomain.com/images/image15.png](http://mydomain.com/images/image15.png)转换成`http://src.sencha.io/120/http://mydomain.com/images/image15.png`。
- en: This format will grab the image and run it through `src.sencha.io` for processing
    before it is displayed. The value of 120 indicates that the image will be automatically
    resized to a maximum width of 120 pixels or about half the size of a typical phone
    screen.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式将抓取图像并将其通过`src.sencha.io`进行处理，然后再显示。120的值表示图像将自动调整大小，最大宽度为120像素，大约是典型手机屏幕大小的一半。
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**src.sencha.io**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**src.sencha.io**'
- en: src.sencha.io can be used to resize any image on the fly. There are a number
    of useful features to this service and more information can be found here at [http://docs.sencha.io/current/index.html#!/guide/src](http://docs.sencha.io/current/index.html#!/guide/src).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: src.sencha.io可以用来即时调整任何图像的大小。此服务有许多有用的功能，更多信息可以在[http://docs.sencha.io/current/index.html#!/guide/src](http://docs.sencha.io/current/index.html#!/guide/src)找到。
- en: 'The third and final transformation removes the original height and width configurations
    from the `<img>` tags using a regular expression to match and remove the values.
    By default, WordPress will insert `height` and `width` tags when an image is included
    as part of a post or a page:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次也是最后一次转换，使用正则表达式匹配并移除值，从`<img>`标签中移除原始的高度和宽度配置。默认情况下，WordPress会在将图片作为帖子或页面的一部分包含时插入`height`和`width`标签：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we just used our first bit of code to resize the actual image without removing
    the height and width configurations, the image will actually appear at the original
    size, just pixelated and ugly looking.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只使用我们第一段代码来调整实际图像的大小而不移除高度和宽度配置，图像实际上将以原始大小显示，只是像素化且看起来很丑陋。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Regular expressions**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: Regular Expressions, or **Regexes**, are an incredibly valuable tool for matching
    patterns in strings. You can find out more information on Regexes at [http://www.rexv.org/](http://www.rexv.org/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式，或**Regexes**，是匹配字符串模式的一个极其有价值的工具。您可以在[http://www.rexv.org/](http://www.rexv.org/)了解更多有关正则表达式的信息。
- en: 'Once, we have done all of our conversions, we set the content value of our
    record to our new and improved value:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了所有的转换，我们将记录的内容值设置为我们的新改进的值：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the conversion out of the way, we need to figure out which details container
    we need. Fortunately, we are passed the view that was clicked as part of our `itemTap`
    handler. We can use this to check to see which DataView is active:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 转换完成后，我们需要确定需要哪个详情容器。幸运的是，我们通过`itemTap`处理程序传递了被点击的视图。我们可以使用这个来检查哪个数据视图是活动的：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we have `postList`, we need to create a new post details container, and
    if not, we want to create a new page details container. Once we have the new container,
    we push it onto the active item with this code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`postList`，我们需要创建一个新的帖子详情容器，如果没有，我们想要创建一个新的页面详情容器。一旦我们有了新的容器，我们就用以下代码将其推送到活动项上：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use `this.getMainView()` to grab our main view using the reference we created
    earlier. By using `getActiveItem()`, we are assured of getting the DataView the
    user is looking at and pushing the container onto the correct navigation view.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`this.getMainView()`通过我们之前创建的引用来获取我们的主视图。通过使用`getActiveItem()`，我们确保获取用户正在查看的数据视图，并将容器推送到正确的导航视图中。
- en: 'That''s all there is to the phone profile''s `Main.js` controller file. The
    tablet version of the `Main.js` controller is exactly the same except for the
    `onListItemTap()` function, which looks like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是手机配置文件`Main.js`控制器文件的全部内容。`Main.js`控制器的平板电脑版本与手机版本完全相同，除了`onListItemTap()`函数，它看起来是这样的：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this function we do our conversion the way we did before in the phone version.
    This time we increase the maximum width to 240 pixels.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们以与手机版本中相同的方式进行转换。这次我们将最大宽度增加到240像素。
- en: 'Next, we grab our two details containers with the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下代码获取我们的两个详情容器：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once we have those, we use the `dataview id` just as we did before to get the
    currently active DataView. We then hide one and show the other after adding our
    record to it for display.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些，我们就使用与之前相同的方式使用`dataview id`来获取当前活动的数据视图。然后我们在添加记录以供显示后隐藏一个并显示另一个。
- en: As you can see from the two controllers, we can completely dictate the functions
    in the application, regardless of whether or not the view itself is shared between
    profiles. Combined with the ability to include different views based on a particular
    profile, we can easily target the application to a particular platform's strengths
    and overcome any potential weaknesses.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如从两个控制器中可以看到，我们可以完全指定应用程序中的函数，无论视图本身是否在配置文件之间共享。结合根据特定配置文件包含不同视图的能力，我们可以轻松地将应用程序针对特定平台的优势，并克服任何潜在弱点。
- en: However, as powerful as this is, there is still one other trick we can use to
    further customize our application based on platform or device, that is, conditional
    styling.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这很强大，我们还可以使用另一个技巧来进一步根据平台或设备自定义我们的应用程序，那就是条件样式。
- en: Conditional styling
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件样式
- en: You should be familiar with the use of CSS stylesheets to control the look of
    elements of your web page based on `id` or `class`. Since these can be applied
    to Sencha components and within xTemplates, we can use these classes and IDs to
    control the look of our application as well. We do this by checking the device's
    width using a media query.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉使用CSS样式表根据`id`或`class`来控制网页元素的外观。由于这些可以应用于Sencha组件和xTemplates中，我们可以使用这些类和ID来控制应用程序的外观。我们通过使用媒体查询检查设备的宽度来实现这一点。
- en: Media queries
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体查询
- en: Media queries are actually a part of the CSS standards and not a direct part
    of Sencha Touch. However, since Sencha Touch uses CSS, we can inherit this tool
    and use it as an easy way to make decisions based on the environment that the
    web page is being displayed in. While this functionality has been around for quite
    some time, it was not standard across all web browsers until recently. Fortunately
    for us, Sencha Touch is only supported on modern web browsers, so the late adoption
    of the standard does not affect us.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询实际上是CSS标准的一部分，而不是Sencha Touch的直接部分。然而，由于Sencha Touch使用CSS，我们可以继承这个工具，并使用它作为一个根据网页显示的环境做出决策的简单方法。虽然这个功能已经存在了一段时间，但直到最近它才在所有网络浏览器中成为标准。幸运的是，对于我们的Sencha
    Touch来说，它只支持现代网络浏览器，所以标准的较晚采用对我们没有影响。
- en: 'If you have used a lot of CSS in the past few years, you may have noticed the
    use of media in stylesheet links like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你过去几年使用了大量的CSS，你可能已经注意到了在样式表链接中使用媒体的方式，如下所示：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This setup would use `main.css` for displaying in the browser and `print.css`
    when printing the page out to a printer. This was typically used to remove navigation
    and extraneous page elements during printing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置将使用 `main.css` 在浏览器中显示，并在打印页面到打印机时使用 `print.css`。这通常用于在打印时移除导航和多余的页面元素。
- en: 'However, these same media queries can be used to include stylesheets based
    on the screen size like so:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些相同的媒体查询也可以根据屏幕大小包含样式表，如下所示：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This media query will load the stylesheet if the device is using a web browser
    (screen) with a maximum screen width of 480px (like an iPhone 3G).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备使用的是最大屏幕宽度为 480px 的网络浏览器（屏幕）（如 iPhone 3G），则此媒体查询将加载样式表。
- en: 'We can even take this a step further and change the stylesheet based on the
    orientation:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更进一步，根据方向更改样式表：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These two links will include `iPhonePortrait.css` when the iPhone is held in
    portrait orientation and `iPhoneLandscape.css` when held in landscape orientation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当 iPhone 以纵向模式持有时，这两个链接将包含 `iPhonePortrait.css`，当以横向模式持有时，将包含 `iPhoneLandscape.css`。
- en: Combining these CSS media queries with Sencha Touch's profiles allows us to
    target a particular device at a very granular level.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些 CSS 媒体查询与 Sencha Touch 的配置文件结合使用，使我们能够非常细致地针对特定设备。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'When designing applications for a mobile environment, it is extremely important
    to take advantage of any special features of the device and avoid any potential
    shortfalls the device may have. By tailoring an application directly to the device,
    you provide a better overall user experience. In this chapter, we showed you how
    to make the most of this ability by covering the following points:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当为移动环境设计应用程序时，充分利用设备的任何特殊功能并避免设备可能存在的任何潜在缺陷至关重要。通过直接针对设备定制应用程序，您提供更好的整体用户体验。在本章中，我们通过以下要点展示了如何充分利用这一能力：
- en: The basics and usage of profiles
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件的基本用法
- en: Setting up WordPress to work with Sencha Touch
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 WordPress 以与 Sencha Touch 一起工作
- en: Creating the basic Evolver application
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的 Evolver 应用程序
- en: Setting up the controllers to manage functionality on both phone and tablet
    devices
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置控制器以管理手机和平板设备上的功能
- en: Using media queries to further style your applications for a particular device
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用媒体查询进一步针对特定设备样式化您的应用程序
- en: In the next chapter we will take a look how to access some of the hardware capabilities
    of your device, specifically the camera. We also show you how to compile your
    application to take advantage of more of your device's features.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何访问您设备的一些硬件功能，特别是摄像头。我们还向您展示如何编译您的应用程序以利用更多设备的功能。
