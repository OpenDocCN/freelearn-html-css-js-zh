- en: Reusing Code with Many Different Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多种不同类型重用代码
- en: In previous chapters, we covered a lot of specific techniques. Among others,
    we have seen how modules are used to package code that defines types and values.
    We have also seen functions and function types, including their usage techniques,
    such as currying and partial application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了很多特定的技术。其中，我们看到了如何使用模块来封装定义类型和值的代码。我们还看到了函数和函数类型，包括它们的用法技术，如柯里化和部分应用。
- en: 'In this chapter, we are going to build on what we have seen so far, and cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于我们迄今为止所看到的，并涵盖以下主题：
- en: Polymorphism techniques in Reason
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reason中的多态技术
- en: Generic code with modules and functors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块和函子编写泛型代码
- en: Polymorphism in Reason
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reason中的多态性
- en: Polymorphism, a category of technique used in many programming languages, allows
    for writing code that can apply to different types or objects (in languages such
    as C++ or Java, for example). Looking at things precisely shows that there are
    several techniques or kinds of polymorphism.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性，是许多编程语言中使用的技巧类别，允许编写适用于不同类型或对象的代码（例如，在C++或Java等语言中）。精确地看待事物可以显示存在几种多态技术或类型。
- en: 'We will discuss two of those ways of doing polymorphism here:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论两种实现多态性的方法：
- en: Parametric polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数多态性
- en: Ad hoc polymorphism
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特设多态性**'
- en: Generic functions with parametric polymorphism
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有参数多态性的通用函数
- en: Parametric polymorphism allows a function or a data type to be written in a
    generic way, meaning that it can handle values in the same way regardless of their
    type. This is both interesting and powerful, since it implies that functions written
    using parametric polymorphism work on different data types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 参数多态性允许以通用方式编写函数或数据类型，这意味着它可以以相同的方式处理不同类型的值。这既有趣又强大，因为它意味着使用参数多态性编写的函数可以在不同的数据类型上工作。
- en: In C++, parametric polymorphism is usually known as **generic programming**
    or **compile-time polymorphism**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，参数多态性通常被称为**泛型编程**或**编译时多态性**。
- en: We can perform parametric polymorphism with types in ReasonML. There is a special
    feature we use to do it, **type variables**, which we already encountered in [Chapter
    7](e6bacad6-b207-4689-b068-088bed455956.xhtml), *Making Types that Represent Operations,*
    in one of the examples related to *function literals*. Instead of using a concrete
    type such as `int` or `string` for a parameter or result, we use  `type variable`.
    So, using  `type variable` as the type of a parameter would make sure that values
    of any type are accepted.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在ReasonML中使用类型进行参数多态性。我们有一个特殊的功能来实现这一点，**类型变量**，这在[第7章](e6bacad6-b207-4689-b068-088bed455956.xhtml)中已经遇到过，在*表示操作的类型*的例子中，与*函数字面量*相关。我们不是使用`int`或`string`等具体类型作为参数或结果，而是使用`类型变量`。因此，使用`类型变量`作为参数的类型将确保接受任何类型的值。
- en: A function that uses `type variables` is called a **generic function**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`类型变量`的函数被称为**通用函数**。
- en: 'Let''s explain with an example. The *identity* function is the usual simple
    example that helps explain what a generic function is. The identity function (let''s
    call it `id()`) just returns its input parameter. It is defined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来解释。*恒等*函数是解释通用函数是什么的简单例子。恒等函数（让我们称它为`id()`）只是返回其输入参数。它定义如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Based on that definition, ReasonML infers the type of the input parameter using
    `'a`, meaning it uses a type variable to indicate that values of any type are
    accepted. And the return type of the function is inferred in the same way, as
    the type of its parameter, the `'a` type variable. That is the behavior of a generic
    function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，ReasonML使用`'a`来推断输入参数的类型，这意味着它使用类型变量来表示接受任何类型的值。函数的返回类型也是以相同的方式推断的，即其参数的类型，即`'a`类型变量。这就是通用函数的行为。
- en: Whenever we have a type name starting with `'`, such as `'a` (meaning *any type*),
    this defines a type variable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们遇到以`'`开头的类型名时，例如`'a`（表示*任何类型*），这定义了一个类型变量。
- en: Here, is another example of such a function. We can think of a function `(lastElem)`
    that returns the last element of a list. The point is that the elements of the
    list could be of any type. In addition to that, since we must account for the
    empty list case, we will use the option type with type variable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，是此类函数的另一个示例。我们可以考虑一个返回列表最后一个元素的函数`(lastElem)`。关键是列表的元素可以是任何类型。此外，由于我们必须考虑空列表的情况，我们将使用带有类型变量的选项类型。
- en: 'We can write an interface for the function (see in the `src/Ch08/Ch08_GenericFunctionLastElementOfList.rei`
    file) as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为该函数编写一个接口（参见`src/Ch08/Ch08_GenericFunctionLastElementOfList.rei`文件），如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And, based on how lists work in Reason, we can define a **recursive** function
    (using the `rec` keyword), as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，基于Reason中列表的工作方式，我们可以定义一个**递归**函数（使用`rec`关键字），如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s test it with the following `Js.log` calls:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下`Js.log`调用进行测试：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As expected, the output (see the `src/Ch08/Ch08_GenericFunctionLastElementOfList.re`
    file) shows `4` and `d` as resulting values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，输出（参见`src/Ch08/Ch08_GenericFunctionLastElementOfList.re`文件）显示结果值为`4`和`d`。
- en: Ad hoc polymorphism or overloading
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特设多态或重载
- en: Ad hoc polymorphism is the other technique we are going to discuss now. It is
    also known as **overloading**, and it provides different implementations for the
    same operation, such as the `+` operation. To stick with this example, we may
    find in some programming languages, such as Python, that the `+` operation has
    an implementation for the addition of numbers, another one for string concatenation,
    and a third one for list or array concatenation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 特设多态是我们接下来要讨论的另一种技术。它也被称为**重载**，它为相同的操作提供不同的实现，例如`+`操作。为了继续这个例子，我们可能会在某些编程语言中，例如Python，发现`+`操作有用于数字加法的实现，另一个用于字符串连接，还有一个用于列表或数组连接。
- en: Ad hoc polymorphism is supported by almost all programming languages for built-in
    operations, such as `+`, `-`, and `*`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有编程语言都支持内置操作的多态，例如`+`、`-`和`*`。
- en: ReasonML does not currently support ad hoc polymorphism. So, for example, we
    have the distinct `+` operator for `int` addition, the `+.` one for float addition,
    and the `++` one for string concatenation. And, if needed, we have to manually
    convert values into the right types before applying a given operator to them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonML目前不支持特设多态。例如，我们有用于整数加法的不同`+`操作符，用于浮点数加法的`+.`操作符，以及用于字符串连接的`++`操作符。如果需要，我们必须在应用给定操作符之前手动将值转换为正确的类型。
- en: ReasonML may eventually support ad hoc polymorphism via the modular implicits
    currently being developed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonML最终可能通过目前正在开发的模块隐式来实现特设多态。
- en: Generic code with functors
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数式编程的通用代码
- en: As we have seen, modules are important in OCaml and ReasonML, helping to organize
    code into units with specified interfaces. In addition to that, we are going to
    see now that they can serve for building generic code using what are called **Functors**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，模块在OCaml和ReasonML中非常重要，有助于将代码组织成具有指定接口的单位。除此之外，我们现在将看到它们可以用所谓的**函数式**来构建通用代码。
- en: What is a functor?
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式？
- en: A functor is a function whose parameters are modules and whose result is a module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式是一种函数，其参数是模块，其结果是另一个模块。
- en: Functors allow us to extend existing modules with new functionality, without
    requiring a lot of repetitive code for the different types we have.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式允许我们通过新功能扩展现有模块，而无需为不同类型编写大量重复代码。
- en: 'The syntax of functors looks as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的语法如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With these characteristics, note the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些特性，请注意以下内容：
- en: The `F` functor has as parameters one or more `M1` modules and so on
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`函数式编程的参数是一个或多个`M1`模块等'
- en: Each parameter module must be typed via an interface (`I1` for `M1` and so on)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个参数模块必须通过接口进行类型化（`I1`用于`M1`等）
- en: The interface for the result type (`ResultI`) is optional
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果类型（`ResultI`）的接口是可选的
- en: Some examples will help us understand.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例将帮助我们理解。
- en: Example 1 – looking in the standard library
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例1 – 在标准库中查找
- en: The best example is the `Set` module that comes with the standard library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的例子是标准库中的`Set`模块。
- en: A `Set` type has an ordering (for example, in the set of the integer numbers,
    *1 < 2* and *2 > 1*), and elements are unique. Note that we have that in other
    languages, such as Python, too.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`类型有一个排序（例如，在整数集合中，*1 < 2*和*2 > 1*），并且元素是唯一的。注意，在其他语言，如Python中，也有这种情况。'
- en: To use sets in ReasonML and OCaml, you first have to make one. You do that by
    calling `Set.Make`, which is a functor. It takes as input another module that
    must have a `compare()` function implemented within it and returns our `Set` type
    module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在ReasonML和OCaml中使用集合，首先必须创建一个。你可以通过调用`Set.Make`来实现，这是一个函数式编程，它接受作为输入的另一个模块，该模块必须在其内部实现一个`compare()`函数，并返回我们的`Set`类型模块。
- en: 'We can write this, for example, for a set of integers:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为整数集编写如下代码：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We get a new module that provides functions for conveniently working with sets
    of integers, such as `IntSet.of_list()`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个新的模块，它提供了方便地处理整数集合的函数，例如 `IntSet.of_list()`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s display the result in the console:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制台中显示结果：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we use the `node` command to run the JS file generated by compiling that
    program file (`src/Ch08/Ch08_FunctorsExample1.re`), we get output showing the
    created `IntSet`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `node` 命令运行编译该程序文件（`src/Ch08/Ch08_FunctorsExample1.re`）生成的 JS 文件时，我们得到输出，显示了创建的
    `IntSet`：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this first example, we got an idea of how functors work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个第一个示例，我们了解到了函子的作用。
- en: Example 2
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 2
- en: Here's another example taken from the ReasonML documentation, also about sets,
    that we are going to discuss. We will show a `MakeSet` functor that takes in a
    module of the `Comparable` type and returns a new set that can contain such comparable
    items.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个从 ReasonML 文档中摘取的另一个示例，也是关于集合的，我们将对其进行讨论。我们将展示一个 `MakeSet` 函子，它接受一个 `Comparable`
    类型的模块并返回一个可以包含此类可比较项的新集合。
- en: 'We start by defining the `Comparable` type, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义 `Comparable` 类型，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we define the functor, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义函子，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is this code block explained:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个代码块的解释：
- en: (1) We use a list as our data structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: (1) 我们使用列表作为我们的数据结构。
- en: (2) If the item exists, return the same set.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: (2) 如果项目存在，则返回相同的集合。
- en: (3) Else, prepend to the set and return it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: (3) 否则，将元素添加到集合的前面并返回它。
- en: 'Now, let''s remember that we want to create a set, the items of which are pairs
    of integers. We create the input module, `IntPair`, which abides by the `Comparable`
    signature required by `MakeSet`, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们记住我们想要创建一个集合，其元素是整数对。我们创建输入模块 `IntPair`，它遵循 `MakeSet` 所需的 `Comparable`
    签名，如下所示：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This means that we can write the following, using the functor:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用函子编写以下内容：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To finish, let''s add some code to use the resulting module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一些代码来使用生成的模块：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This should be enough to get something interesting.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以得到一些有趣的结果。
- en: 'When we use the `node` command to run the JS file generated by compiling our
    Reason code file (`src/Ch08/Ch08_FunctorsExample2.re`), we get the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `node` 命令运行由编译我们的 Reason 代码文件（`src/Ch08/Ch08_FunctorsExample2.re`）生成的
    JS 文件时，我们得到以下输出：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What have we done? Using a functor, we were able to create a module, `SetOfIntPairs`,
    from another module. The new module has the `add` function, among other things.
    Using the module, we can create an empty set (`0` in the output), to which we
    can add pairs of `int` instances on demand (using the previously mentioned `add`
    function).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了什么？使用函子，我们能够从一个模块创建一个新的模块 `SetOfIntPairs`。新模块具有 `add` 函数等特性。使用该模块，我们可以创建一个空集（输出中的
    `0`），我们可以根据需要向其中添加 `int` 实例的成对（使用之前提到的 `add` 函数）。
- en: Example 3
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 3
- en: We will now use an example from Axel Rauschmayer that can be found in his repository,
    at [https://github.com/rauschma/reasonml-demo-functors](https://github.com/rauschma/reasonml-demo-functors).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用来自 Axel Rauschmayer 的一个示例，该示例可以在他的仓库中找到，网址为 [https://github.com/rauschma/reasonml-demo-functors](https://github.com/rauschma/reasonml-demo-functors)。
- en: To be precise, let's use the Printable pair functor example, with a small adaptation,
    to help us easily understand how this can be useful.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精确，让我们使用带有微小调整的可打印对函子示例，以帮助我们更容易地理解这如何有用。
- en: 'Before defining the functor, we must define the interface of its parameters.
    Here, we will have a single parameter, the `PrintablePair` module. For that, we
    will define a first type, `PrintableType`, that will be used by `PrintablePair`.
    We define it as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函子之前，我们必须定义其参数的接口。在这里，我们将有一个单个参数，即 `PrintablePair` 模块。为此，我们将定义一个第一类型 `PrintableType`，它将被
    `PrintablePair` 使用。我们定义它如下：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we add the definition of the `PrintablePair` type, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加 `PrintablePair` 类型的定义，如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can then define the functor, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义函子，如下所示：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we have the code where we are going to use the functor, starting with defining
    the `PrintableString` and `PrintableInt` modules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有代码，我们将使用函子，从定义 `PrintableString` 和 `PrintableInt` 模块开始。
- en: 'We define `PrintableString` as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `PrintableString` 如下：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And, we define `PrintableInt` as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义 `PrintableInt` 如下：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we add the rest of the code, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加其余的代码，如下所示：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we use the `node` command to run the generated JS code  (from the Reason
    file, `src/Ch08/Ch08_FunctorsExample3.re`), we get the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `node` 命令运行由 Reason 文件（`src/Ch08/Ch08_FunctorsExample3.re`）生成的 JS 代码时，我们得到以下输出：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are done!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen that ReasonML supports parametric polymorphism using `type variable`s,
    one of the language features. When using  `type variable` as the type of a function's
    parameter, values of any type are accepted for that parameter. This technique
    allows writing what we call generic functions and plays an important part in code
    reusability in ReasonML.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，ReasonML 支持使用 `类型变量` 进行参数多态性，这是语言特性之一。当使用 `类型变量` 作为函数参数的类型时，接受任何类型的值作为该参数。这种技术允许编写我们所说的泛型函数，并在
    ReasonML 中的代码复用中扮演着重要的角色。
- en: In contrast, ad hoc polymorphism, the other kind of polymorphism that is supported
    in popular programming languages, does not yet exist in ReasonML. But work is
    in progress to correct that lack in a future version.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在流行的编程语言中支持的另一种多态性——临时多态性，在 ReasonML 中尚不存在。但是，正在努力在未来版本中纠正这一不足。
- en: 'Modules also play an important role in code reuse. But, that''s not all. In
    addition to what they allow by themselves, ReasonML has a powerful feature that
    augments what we can do with them: *functors*. They are like special functions
    that take one or several modules as input and return a module. That opens up some
    possibilities in terms of programming generically.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在代码复用中也扮演着重要的角色。但，这并非全部。除了它们自身允许的功能之外，ReasonML 还有一个强大的特性，可以增强我们对模块的使用能力：*函子*。它们就像特殊的函数，接受一个或多个模块作为输入，并返回一个模块。这为编程泛型开辟了一些可能性。
- en: In the next chapter, we are going to explore ReasonML techniques for extending
    types to add behavior.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 ReasonML 的技术，用于扩展类型以添加行为。
