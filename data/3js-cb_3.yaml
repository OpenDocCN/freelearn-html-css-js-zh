- en: Chapter 3. Working with the Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 使用相机
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Making the camera follow an object
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让相机跟踪一个对象
- en: Zooming the camera to an object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放相机到对象
- en: Using a perspective camera
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用透视相机
- en: Using an orthographic camera
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正交相机
- en: Creating a 2D overlay
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建2D叠加层
- en: Rotating the camera around a scene
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕场景旋转相机
- en: Matching the rendered view to a resized browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将渲染视图匹配到调整大小的浏览器
- en: Converting world coordinates to screen coordinates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将世界坐标转换为屏幕坐标
- en: Selecting an object in the scene
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中选择一个对象
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most important objects in Three.js is the camera. With the camera,
    you define what part of the scene will be rendered and how the information will
    be projected on the screen. In this chapter, we'll show you a number of recipes
    that will allow you to add more complex camera functionality to your Three.js
    applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中，最重要的对象之一就是相机。通过相机，你定义了场景的哪一部分将被渲染，以及信息将如何投影到屏幕上。在本章中，我们将向您展示一些配方，这些配方将允许您向您的Three.js应用程序添加更复杂的相机功能。
- en: Making the camera follow an object
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让相机跟踪一个对象
- en: When you are creating games or visualizations with many moving objects, you
    might want to have the camera follow an object around. Normally, when you create
    a camera, it points to a single position and shows you the scene that falls within
    its field of view. In this recipe, we'll explain how you can create a camera that
    can follow any of your objects around.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建包含许多移动对象的游戏或可视化时，你可能想让相机围绕对象移动。通常情况下，当你创建一个相机时，它会指向一个单一的位置，并显示其视野内的场景。在这个配方中，我们将解释如何创建一个可以围绕任何对象移动的相机。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This recipe only makes use of core Three.js functions, so there isn''t any
    need to include external JavaScript libraries in your source code. If you want
    to see the final result of this recipe, you can open `03.01-camera-follow-object.html`
    in your browser, and you''ll see something similar to what is shown in the following
    screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方仅使用核心Three.js函数，因此不需要在源代码中包含外部JavaScript库。如果你想看到这个配方的最终结果，你可以在浏览器中打开 `03.01-camera-follow-object.html`，你将看到以下截图所示的内容：
- en: '![Getting ready](img/1182OS_03_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_03_01.jpg)'
- en: In this example, you can see that the camera is focused on the sphere. As the
    sphere moves across the scene, the camera moves around to stay focused on the
    position of the sphere.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到相机聚焦在球体上。随着球体在场景中移动，相机也会移动以保持对球体位置的聚焦。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this recipe, we only need to take three simple steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们只需要采取三个简单的步骤：
- en: 'The first thing we need to do is create the object that we want to follow.
    For this recipe, we create a simple `THREE.SphereGeometry` object and add it to
    the scene like this:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建我们想要跟踪的对象。对于这个配方，我们创建了一个简单的 `THREE.SphereGeometry` 对象，并将其添加到场景中，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in this short code snippet, we don't need to do anything special
    with the object we want to follow.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你在下面的代码片段中所见，我们不需要对我们想要跟踪的对象做任何特殊处理。
- en: 'The next step is that we need a camera that renders the scene and stays focused
    on the object we want to follow. The following JavaScript creates and positions
    this camera:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是，我们需要一个渲染场景并保持聚焦于我们想要跟踪的对象的相机。以下JavaScript代码创建并定位了这个相机：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a standard `THREE.PerspectiveCamera` object, which we also use in most
    of the other examples in this chapter. Once again, no special configuration is
    required.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个标准的 `THREE.PerspectiveCamera` 对象，我们也在本章的许多其他示例中使用它。再次强调，不需要任何特殊配置。
- en: 'For the final step, we define the render loop that will render the scene and
    also point the camera in the right direction for this recipe:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后一步，我们定义了渲染循环，它将渲染场景，并确保相机在这个配方中的正确方向：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `render` function, we use the `camera.lookAt` function to point the camera
    to the `position` function of the sphere. As we do this in every frame that we
    render, it will look like camera is exactly following the position of sphere.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `render` 函数中，我们使用 `camera.lookAt` 函数将相机指向球体的 `position` 函数。由于我们在每一帧渲染时都这样做，所以看起来相机正好跟随球体的位置。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`THREE.PerspectiveCamera` extends from the `THREE.Object3D` object. `THREE.Object3D`
    provides the `lookAt` function. When this function is called with the target position
    to look at, Three.js creates a transformation matrix (`THREE.Matrix4`) that aligns
    the position of the `THREE.Object3D` object with the target''s position. In the
    case of the camera, the result is that the target object is followed around the
    scene by the camera and is rendered in the middle of the screen.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.PerspectiveCamera` 从 `THREE.Object3D` 对象扩展而来。`THREE.Object3D` 提供了 `lookAt`
    函数。当这个函数使用要查看的目标位置调用时，Three.js 创建一个变换矩阵 (`THREE.Matrix4`)，使 `THREE.Object3D` 对象的位置与目标位置对齐。在摄像机的情况下，结果是目标对象被摄像机在场景中跟随，并在屏幕中间渲染。'
- en: There's more…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we use the `lookAt` function to point a camera to a specific
    object. You can apply this same recipe for all the Three.js objects that extend
    from Object3D. For instance, you can use this to make sure `THREE.SpotLight` always
    illuminates a specific object. Or, if you're creating animations, you could use
    this effect to make sure one character is always looking at the face of a different
    character.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `lookAt` 函数将摄像机指向一个特定的对象。您可以将这个相同的菜谱应用于所有从 Object3D 扩展的 Three.js
    对象。例如，您可以使用它来确保 `THREE.SpotLight` 总是照亮特定的对象。或者，如果您正在创建动画，您可以使用这个效果来确保一个角色总是看着另一个角色的脸部。
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: As the `lookAt` function uses matrix transformations to point one object to
    another, you could also do this without making use of the `lookAt` function. For
    this, you'll have to create a transformation matrix yourself. We've explained
    how to do this in the *Applying matrix transformations* recipe, which you can
    find in [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries
    and Meshes*.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `lookAt` 函数使用矩阵变换来指向一个对象，您也可以不使用 `lookAt` 函数来做这件事。为此，您将不得不自己创建一个变换矩阵。我们已经在
    *应用矩阵变换* 菜谱中解释了如何做这件事，您可以在 [第2章](ch02.html "第2章。几何体和网格")，*几何体和网格* 中找到它。
- en: Zooming the camera to an object
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将摄像机缩放到物体
- en: Usually, when you position a camera in your scene, you might move it around
    a bit or let it focus on different objects. In this recipe, we'll show you how
    you can zoom in to an object so that it almost fills the rendered view.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您在场景中定位摄像机时，您可能会移动它或让它聚焦在不同的物体上。在这个菜谱中，我们将向您展示如何缩放到一个物体，使其几乎填满渲染视图。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To zoom in, we use the standard functionality from the `THREE.PerspectiveCamera`
    object. We''ve provided an example that demonstrates the result you''ll get at
    the end of this recipe. To experiment with this example, open `03.02-zoom-camera-to-object.html`
    in your browser. You will see something similar to the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行缩放，我们使用 `THREE.PerspectiveCamera` 对象的标准功能。我们提供了一个示例，演示了您在本菜谱结束时将获得的结果。要尝试这个示例，请在您的浏览器中打开
    `03.02-zoom-camera-to-object.html`。您将看到以下截图类似的内容：
- en: '![Getting ready](img/1182OS_03_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_03_02.jpg)'
- en: 'Initially, you''ll see a small rotating cube in the center of the scene. If
    you click on the `updateCamera` button in the menu in the top-right section, the
    camera will update and show you the rotating cube fullscreen like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，您将在场景中心看到一个小的旋转立方体。如果您点击右上角菜单中的 `updateCamera` 按钮，摄像机将更新并显示一个全屏的旋转立方体，如下所示：
- en: '![Getting ready](img/1182OS_03_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_03_03.jpg)'
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To zoom the camera to an object, we need to take the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要将摄像机缩放到物体，我们需要采取以下步骤：
- en: 'The first thing we need to do is create and position the camera that we use
    to zoom in:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建并定位我们用来缩放的摄像机：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this is a standard `THREE.PerspectiveCamera` object, to which
    we give a position and add to the scene.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这是一个标准的 `THREE.PerspectiveCamera` 对象，我们给它一个位置并将其添加到场景中。
- en: 'To zoom in with the camera, we first need to determine the distance from the
    camera to the object and its height:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用摄像机进行缩放，我们首先需要确定物体与摄像机之间的距离及其高度：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous code snippet, we used `THREE.BoundingBoxHelper` to determine
    the `realHeight` function of cube and its distance to the camera.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们使用了 `THREE.BoundingBoxHelper` 来确定立方体的 `realHeight` 函数及其与摄像机的距离。
- en: 'With this information, we can determine the field of view (`fov`) for the camera
    so that it only shows the cube:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些信息，我们可以确定摄像机的视场 (`fov`)，使其只显示立方体：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What you can see in this code fragment is that we use one additional value,
    which is `control.correctForDepth`, to calculate the field of view. This value,
    which is set in the menu in the top-right section in the example, increases the
    resulting field of view slightly. We do this because in this calculation, we assume
    that the camera is facing the object straight on. If the camera isn't looking
    straight at the object, we need to compensate for this offset.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码片段中，您可以看到我们使用了一个额外的值，即 `control.correctForDepth`，来计算视场。此值在示例右上角的菜单中设置，略微增加了最终视场。我们这样做是因为在这个计算中，我们假设相机正对着对象。如果相机没有直视对象，我们需要补偿这个偏移。
- en: 'Now that we''ve got the field of view for the camera, we can assign this value
    to the `camera.fov` property:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为相机设置了视场，我们可以将此值分配给 `camera.fov` 属性：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As Three.js caches the `fov` property of the camera, we need to inform Three.js
    that the camera configuration has some changes. We do this with the `updateProjectionMatrix`
    function.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Three.js 缓存了相机的 `fov` 属性，我们需要通知 Three.js 相机配置有一些更改。我们通过 `updateProjectionMatrix`
    函数来完成此操作。
- en: At this point, the camera is completely zoomed in on the object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，相机已经完全缩放了对象。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'To understand how this works, we need to understand what the field of view
    property of a `THREE.PerspectiveCamera` object does. The following figure shows
    you the field of view property:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解它是如何工作的，我们需要了解 `THREE.PerspectiveCamera` 对象的视场属性。以下图显示了视场属性：
- en: '![How it works...](img/1182OS_03_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/1182OS_03_04.jpg)'
- en: As you can see in this figure, there is a separate horizontal and vertical field
    of view. Three.js only allows you to set the vertical one, and the horizontal
    field of view is determined based on the aspect ratio you define on a camera.
    When you look at this figure, you can also directly see how this recipe works.
    By changing the field of view, we shrink the near and far planes and limit what
    is being rendered, and this way, we can zoom in.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，存在一个单独的水平和垂直视场。Three.js 只允许您设置垂直视场，水平视场基于您在相机上定义的纵横比确定。当您查看此图时，您还可以直接看到此菜谱是如何工作的。通过改变视场，我们缩小了近平面和远平面，并限制了渲染的内容，这样我们就可以进行缩放。
- en: There's more…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There is an alternative way of zooming in besides the one shown here. Instead
    of changing the `fov` property of the camera, we can also move the camera closer
    to the object. In the latest version of Three.js, a `zoom` property is introduced;
    you can also use this property to zoom in on a scene, but you can't use it directly
    to zoom in on a single object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这里显示的缩放方式之外，还有另一种缩放方式。我们不仅可以改变相机的 `fov` 属性，还可以将相机移近对象。在 Three.js 的最新版本中，引入了一个
    `zoom` 属性；您也可以使用此属性来缩放场景，但不能直接用于缩放单个对象。
- en: Using a perspective camera
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用透视相机
- en: 'Three.js provides two cameras: a camera that renders the scene with a perspective
    projection (as we see images in the real world) and a camera that renders the
    scene with an orthogonal projection (fake 3D often used in games; for more information
    on this type of camera, check out the upcoming *Using an orthographic camera*
    recipe). In this recipe, we''ll look at the first of these two cameras and explain
    how you can use the perspective camera in your own scene.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了两种相机：一种是以透视投影（正如我们在现实世界中看到图像的方式）渲染场景的相机，另一种是以正交投影（常用于游戏的假3D；有关此类相机的更多信息，请查看即将到来的
    *使用正交相机* 菜谱）。在本菜谱中，我们将探讨这两种相机中的第一种，并解释您如何在您的场景中使用透视相机。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Working with the properties of a camera can be a bit confusing at times. To
    help you better understand the steps or this recipe, we''ve created a simple page
    that shows you the effect each of the camera properties has. Open up `03.03-use-an-perspective-camera.html`
    in the browser, and you''ll see something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与相机属性一起工作有时可能会有些困惑。为了帮助您更好地理解步骤或此菜谱，我们创建了一个简单的页面，展示了每个相机属性的效果。在浏览器中打开 `03.03-use-an-perspective-camera.html`，您将看到如下内容：
- en: '![Getting ready](img/1182OS_03_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_03_05.jpg)'
- en: With the last four properties available in the menu in the top-right section,
    you can set the properties of `THREE.PerspectiveCamera`, which is used to render
    this scene, and see the effect of each property immediately.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右上角菜单中可用的最后四个属性，您可以设置用于渲染此场景的 `THREE.PerspectiveCamera` 的属性，并立即看到每个属性的效果。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, we set up each of the camera properties separately. These properties
    can also be passed in with the constructor of `THREE.PerspectiveCamera`. In the
    *There's more…* section of this recipe, we'll show you how to do this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们分别设置每个相机的属性。这些属性也可以通过 `THREE.PerspectiveCamera` 的构造函数传入。在这个菜谱的 *还有更多…*
    部分中，我们将向您展示如何做到这一点。
- en: 'To set up `THREE.PerspectiveCamera` completely, we need to perform a couple
    of steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全设置 `THREE.PerspectiveCamera`，我们需要执行几个步骤：
- en: 'The first thing we need to do is instantiate the camera:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是实例化相机：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This creates the camera instance, which we configure in the upcoming steps.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了相机实例，我们将在接下来的步骤中进行配置。
- en: 'Now that we''ve got a camera, we first need to define the aspect ratio between
    the width of the viewport and the height:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了相机，我们首先需要定义视口宽度和高度之间的宽高比：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our recipe, we use the full width and height of the browser, so we specify
    the aspect ratio for the camera based on the `window.innerWidth` and `window.innerHeight`
    properties. If we use a `div` element with a fixed width and height, you should
    use the ratio between these values as the `aspect` function for the camera.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的菜谱中，我们使用浏览器的完整宽度和高度，因此我们根据 `window.innerWidth` 和 `window.innerHeight` 属性指定相机的宽高比。如果我们使用具有固定宽度和高度的
    `div` 元素，您应该使用这些值之间的比率作为相机的 `aspect` 函数。
- en: 'The next two properties we need to define are the `near` and `far` properties:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来需要定义的两个属性是 `near` 和 `far` 属性：
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These two properties define the area of the scene that this camera will render.
    With these two values, the camera will render the scene starting from a distance
    of `0.1` to a distance of `1000` from the position of the camera.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个属性定义了相机将要渲染的场景区域。使用这两个值，相机将从距离相机 `0.1` 到 `1000` 的距离渲染场景。
- en: 'The last of the properties that can be defined is the (vertical) field of view:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以定义的最后一个属性是（垂直）视野：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This property defines, in degrees, the area that the camera *sees*. For instance,
    humans have a horizontal field of view of 120 degrees, while in video games, often
    a field of view of around 90 or 100 degrees is used.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个属性以度为单位定义了相机 *看到的* 区域。例如，人类有 120 度的水平视野，而在视频游戏中，通常使用大约 90 或 100 度的视野。
- en: 'Whenever you update one of these four properties of the camera, you have to
    inform Three.js about such a change. You do this by adding the following line:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当您更新相机的这四个属性之一时，您必须通知 Three.js 关于这种变化。您可以通过添加以下行来完成此操作：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, all that is left to do is position the camera and add it to the scene:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，剩下要做的就是放置相机并将其添加到场景中：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, we can use this camera with any of the available renderers to
    render a scene like this: `renderer.render(scene, camera)`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以使用这个相机与任何可用的渲染器一起渲染一个像这样的场景：`renderer.render(scene, camera)`。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The best way to understand how these properties affect what is rendered on
    screen is by looking at the following figure, which shows you these properties:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这些属性如何影响屏幕上渲染的内容，最好的方法是查看以下图表，它展示了这些属性：
- en: '![How it works...](img/1182OS_03_06.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1182OS_03_06.jpg)'
- en: The position of **Near plane** in this figure is based on the `near` property
    of the camera. **Far plane** is based on the `far` property and the *fov* shown
    in the figure corresponds to the `fov` property. With the `fov` property, you
    define the vertical field of view. The horizontal field of view is based on the
    aspect ratio, which you define with the `aspect` property on the camera.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图中 **近平面** 的位置基于相机的 `near` 属性。**远平面** 基于相机的 `far` 属性和图中显示的 *fov*，这对应于 `fov`
    属性。使用 `fov` 属性，您定义了垂直视野。水平视野基于宽高比，您可以通过相机上的 `aspect` 属性来定义。
- en: There's more…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In this recipe, we set each of the properties separately. `THREE.PerspectiveCamera`
    also provides a constructor that you can use to set all these properties in one
    statement:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们分别设置每个属性。`THREE.PerspectiveCamera` 还提供了一个构造函数，您可以使用它在一个语句中设置所有这些属性：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also remember that `THREE.PerspectiveCamera` extends from the standard Three.js
    `THREE.Object3D` object. This means that this camera can be rotated and moved
    around just like any other object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，`THREE.PerspectiveCamera` 是从标准的 Three.js `THREE.Object3D` 对象扩展而来的。这意味着这个相机可以像任何其他对象一样旋转和移动。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In the *Zooming the camera to an object* recipe, we used the `fov` property
    of the camera to zoom in on an object, and in the *Using an orthographic camera*
    recipe, we will show you the second of the two cameras provided by Three.js, which
    is `THREE.OrthographicCamera`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *将相机缩放到对象* 配方中，我们使用了相机的 `fov` 属性来放大对象，而在 *使用正交相机* 配方中，我们将展示 Three.js 提供的两个相机中的第二个，即
    `THREE.OrthographicCamera`。
- en: Using an orthographic camera
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正交相机
- en: In most cases, you'll use `THREE.PerspectiveCamera` to render your scene. With
    such a camera, the result is a scene with a realistic-looking perspective. Three.js
    provides an alternative camera with `THREE.OrthographicCamera`. This camera uses
    an orthographic projection to render the scene. With this type of projection,
    all objects have the same size regardless of their distance to the camera. This
    is in contrast to `THREE.PerspectiveCamera`, where objects that are further away
    from the camera appear smaller. This was used often for fake 3D in games such
    as the Sims or older versions of SimCity (image taken from [http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/projection_images/iosmetric_sim_city.jpg](http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/projection_images/iosmetric_sim_city.jpg)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会使用 `THREE.PerspectiveCamera` 来渲染你的场景。使用这种相机，结果是具有逼真视角的场景。Three.js
    提供了一个替代相机 `THREE.OrthographicCamera`。这种相机使用正交投影来渲染场景。在这种投影类型中，所有对象的大小都相同，无论它们与相机的距离如何。这与
    `THREE.PerspectiveCamera` 相比，在相机更远处的对象看起来更小。这常用于游戏中的假3D效果，如《模拟人生》或更早版本的《模拟城市》（图片来自
    [http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/projection_images/iosmetric_sim_city.jpg](http://glasnost.itcarlow.ie/~powerk/GeneralGraphicsNotes/projection/projection_images/iosmetric_sim_city.jpg))。
- en: '![Using an orthographic camera](img/1182OS_03_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![使用正交相机](img/1182OS_03_07.jpg)'
- en: In this recipe, we'll show you how to configure `THREE.OrthographicCamera` so
    that you can create this fake 3D effect for your own scenes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将向您展示如何配置 `THREE.OrthographicCamera`，以便您可以为您的场景创建这种假3D效果。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, the only object from Three.js we use is `THREE.OrthographicCamera`.
    This camera is available in the standard Three.js distribution, so there is no
    need to include any external JavaScript files. We've provided an example that
    shows the Three.Orthographic Camera in action. You can use this camera to better
    understand the properties you can use to configure the camera. If you open `03.04-use-an-orthographic-camera.html`,
    you can see a number of cubes that are rendered with `THREE.OrthographicCamera`.
    With the menu in the top-right section, you can tune the configuration of the
    camera.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们使用的唯一来自 Three.js 的对象是 `THREE.OrthographicCamera`。这个相机在标准的 Three.js
    分发中可用，因此不需要包含任何外部 JavaScript 文件。我们提供了一个示例，展示了 Three.Orthographic Camera 的实际应用。你可以使用这个相机来更好地理解你可以用来配置相机的属性。如果你打开
    `03.04-use-an-orthographic-camera.html`，你可以看到使用 `THREE.OrthographicCamera` 渲染的多个立方体。在右上角的菜单中，你可以调整相机的配置。
- en: '![Getting ready](img/1182OS_03_08.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_03_08.jpg)'
- en: Now, let's look at the steps you need to take to set up this camera.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你需要采取哪些步骤来设置这个相机。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To set up an orthographic camera in Three.js, we need to perform a couple of
    very simple steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中设置正交相机需要执行几个非常简单的步骤：
- en: 'The first thing we need to do is create the camera instance:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建相机实例：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates `THREE.OrthographicCamera`, which is configured with some default
    values.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建 `THREE.OrthographicCamera`，它使用一些默认值进行配置。
- en: 'The next step is to define the boundaries for this camera:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义这个相机的边界：
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This defines the area that is rendered by this camera. In the *There's more…*
    section of this recipe, we'll explain how this works.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这定义了由这个相机渲染的区域。在本配方的 *还有更多…* 部分，我们将解释它是如何工作的。
- en: 'Finally, we have to set the `near` and `far` properties of the camera. These
    properties define which distance from the camera is rendered:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须设置相机的 `near` 和 `far` 属性。这些属性定义了从相机到渲染的距离：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we don''t pass in the arguments in the constructor, we have to inform
    Three.js that we changed the camera''s parameter. For this, we have to add the
    following line:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在构造函数中不传递参数时，我们必须通知 Three.js 我们已更改相机的参数。为此，我们必须添加以下行：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final step is to position and align the camera:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是定位和调整相机：
- en: '[PRE18]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can just use this camera like any other camera and render a scene like
    this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需像使用任何其他相机一样使用这个相机，并渲染出这样的场景：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The easiest way to understand how this camera works is by looking at the following
    figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个相机的工作原理的最简单方法是通过查看以下图示：
- en: '![How it works...](img/1182OS_03_09.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1182OS_03_09.jpg)'
- en: The box you see in this figure is the area an orthographic camera renders. In
    this figure, you can also see the `left`, `right`, `top`, and `bottom` properties
    we defined on the camera, which define the boundaries of this box. The final two
    properties, which are `near` and `far`, are used to define the near plane and
    the far plane. With these six properties, we can define the complete box that
    is rendered with `THREE.OrthographicCamera`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图中你看到的这个方块是正交相机渲染的区域。在这个图中，你还可以看到我们在相机上定义的`left`、`right`、`top`和`bottom`属性，这些属性定义了这个方块的边界。最后两个属性，即`near`和`far`，用于定义近平面和远平面。有了这六个属性，我们可以定义使用`THREE.OrthographicCamera`渲染的完整方块。
- en: There's more…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'We can also configure `THREE.OrthographicCamera` by passing in these arguments
    in the constructor:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过在构造函数中传入这些参数来配置`THREE.OrthographicCamera`：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An added advantage is that this way, you don't need to explicitly call `camera.updateProjectionMatrix()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个额外的优势是，这样你就不需要显式调用`camera.updateProjectionMatrix()`。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Three.js provides two types of camera. If you want to use `THREE.PerspectiveCamera`
    instead, look at the *Using a perspective camera* recipe, where the steps that
    you need to take to create and configure a perspective camera are explained.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Three.js提供了两种类型的相机。如果你想使用`THREE.PerspectiveCamera`，请查看*使用透视相机*食谱，其中解释了创建和配置透视相机的步骤。
- en: Creating a 2D overlay
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建2D叠加
- en: In most recipes, we only focus on the 3D aspect of Three.js. We show recipes
    that explain how 3D objects and scenes are rendered, how they can be viewed with
    different cameras, and how you can change how they look through materials. When
    you are creating games, you usually also have a 2D layer on top of your 3D scene.
    You can use this to show health bars, 2D maps, inventory, and much more. In this
    recipe, we'll show you how to create a 2D overlay using `THREE.OrthogonalCamera`
    and `THREE.PerspectiveCamera` together.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数食谱中，我们只关注Three.js的3D方面。我们展示了解释3D对象和场景如何渲染、如何使用不同的相机来查看它们以及如何通过材质来改变它们外观的食谱。当你创建游戏时，通常也会在你的3D场景之上有一个2D层。你可以用它来显示生命值条、2D地图、存货清单等等。在这个食谱中，我们将向你展示如何使用`THREE.OrthogonalCamera`和`THREE.PerspectiveCamera`一起创建2D叠加。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we require an image that we will use as an overlay. To demonstrate
    this recipe, we create a simple image that looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要一个用作叠加层的图像。为了演示这个食谱，我们创建了一个简单的图像，看起来像这样：
- en: '![Getting ready](img/1182OS_03_10.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_03_10.jpg)'
- en: 'In this recipe, we''ll combine this static image with a 3D scene to create
    the scene that can be seen by opening the `03.05-create-an-hud-overview.html`
    example in your browser:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将结合这个静态图像和一个3D场景来创建在浏览器中打开`03.05-create-an-hud-overview.html`示例时可以看到的场景：
- en: '![Getting ready](img/1182OS_03_11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/1182OS_03_11.jpg)'
- en: In this example, you can see that we've got a 3D rotating scene with a static
    2D overlay on top of it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你可以看到我们有一个3D旋转的场景，上面有一个静态的2D叠加层。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s look at the steps you need to take:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你需要采取的步骤：
- en: 'Let''s start with creating the 2D overlay. The overlay we use in this recipe
    is the one with a fixed width and height (800 by 600). So, before we create the
    cameras, let''s first create the `div` variable that serves as container for the
    rendered scene:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建2D叠加开始。在这个食谱中，我们使用的叠加层具有固定的宽度和高度（800 x 600）。因此，在我们创建相机之前，让我们首先创建一个`div`变量，它作为渲染场景的容器：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, let''s create the camera that we use to render the overlay. For this,
    we require `THREE.OrthographicCamera`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，让我们创建用于渲染叠加层的相机。为此，我们需要`THREE.OrthographicCamera`:'
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `WIDTH` and `HEIGHT` properties are defined as constants with values of
    800 and 600\. This code fragment creates and positions a standard `THREE.OrthographicCamera`
    object.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WIDTH`和`HEIGHT`属性被定义为具有800和600值的常量。这段代码创建并定位了一个标准的`THREE.OrthographicCamera`对象。'
- en: 'For the 2D overlay, we create a separate scene where we put the 2D elements:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于2D叠加，我们创建了一个单独的场景，我们将2D元素放入其中：
- en: '[PRE23]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The only thing we want to add to the 2D scene is the overlay image we showed
    in the *Getting ready* section of this recipe. As it''s a 2D image, we''ll use
    a `THREE.Sprite` object:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要添加到2D场景中的唯一东西是我们在本食谱的*准备就绪*部分展示的叠加图像。由于它是一个2D图像，我们将使用一个`THREE.Sprite`对象：
- en: '[PRE24]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`THREE.Sprite` is always rendered in the same size (1 by 1 pixels) regardless
    of its distance to the camera. To make the sprite fullscreen, we scale the *x*
    axis with 800 (`WIDTH`) and the *y* axis with 600 (`HEIGHT`). With `THREE.SpriteMaterial`,
    which we used in the previous code fragment, we point to the overlay image so
    that it is shown when we add `THREE.Sprite` to the scene.'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`THREE.Sprite`无论其与摄像机的距离如何，总是以相同的大小（1x1像素）渲染。为了使精灵全屏，我们将*x*轴缩放为800（`WIDTH`），将*y*轴缩放为600（`HEIGHT`）。使用我们在前面的代码片段中使用的`THREE.SpriteMaterial`，我们将叠加图像指向，以便在添加`THREE.Sprite`到场景时显示它。'
- en: 'At this point, we''ve got `THREE.OrthogonalCamera` and `THREE.Scene`, which
    show you the overlay as an 800 by 600 image. The next step is to create the 3D
    screen on which we want to apply this overlay. You don''t have to do anything
    special here; you can create a 3D scene by defining `THREE.PerspectiveCamera`
    and `THREE.Scene` and adding some lights and objects. For this recipe, we assume
    you''ve got a camera and a scene with the following names:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了`THREE.OrthogonalCamera`和`THREE.Scene`，它们以800x600的图像显示叠加层。下一步是在我们想要应用此叠加层的3D屏幕上创建。在这里，你不需要做任何特别的事情；你可以通过定义`THREE.PerspectiveCamera`和`THREE.Scene`并添加一些灯光和对象来创建3D场景。对于这个配方，我们假设你已经有一个具有以下名称的相机和场景：
- en: '[PRE25]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before we move to the render loop where we define that we want to render the
    2D scene as an overlay, we need to configure an additional property on the renderer:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将要进入的渲染循环中定义我们想要将2D场景作为叠加层渲染之前，我们需要在渲染器上配置一个额外的属性：
- en: '[PRE26]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: On `THREE.WebGLRenderer`, we set the `autoclear` property to `false`. This means
    that the screen isn't automatically cleared before renderer renders a scene.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`THREE.WebGLRenderer`上，我们将`autoclear`属性设置为`false`。这意味着在渲染器渲染场景之前，屏幕不会被自动清除。
- en: 'The final step is to alter the render loop. We first want to render the 3D
    scene, and without clearing the 3D-rendered output, render the overlay on the
    top:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是修改渲染循环。我们首先想要渲染3D场景，并且在不清除3D渲染输出之前，在顶部渲染叠加层：
- en: '[PRE27]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first thing we do in the render loop is clear the current output by calling
    the `clear` function on the renderer. We need to do this, as we disabled `autoclear`
    on renderer. Now, we render the 3D scene, and before we render the 2D overlay,
    we call the `clearDepth` function on the renderer. This makes sure the 2D overlay
    is rendered completely on top and won't intersect at places with the 3D scene.
    So finally, we render the 2D overlay by passing in `orthoScene` and `orthoCamera`.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在渲染循环中，我们首先通过在渲染器上调用`clear`函数来清除当前输出。我们需要这样做，因为我们禁用了渲染器的`autoclear`。现在，我们渲染3D场景，在渲染2D叠加层之前，我们在渲染器上调用`clearDepth`函数。这确保2D叠加层完全渲染在顶部，并且不会与3D场景在位置上相交。所以最后，我们通过传递`orthoScene`和`orthoCamera`来渲染2D叠加层。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: How this recipe works is actually very simple. We can use the same renderer
    to render multiple scenes with multiple different cameras in the same render loop.
    This way, we can position various render results on top of each other. With a
    `THREE.OrthoGraphic` camera and `THREE.Sprite`, it is easy to position an object
    at absolute positions on screen. By scaling it to the required size and applying
    a texture, we can display images using a renderer. This output, combined with
    a regular 3D result, allows you to create these kinds of overlays.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的原理实际上非常简单。我们可以使用相同的渲染器在同一个渲染循环中渲染多个场景，每个场景使用多个不同的摄像机。这样，我们可以在彼此之上定位各种渲染结果。使用`THREE.OrthoGraphic`摄像机和`THREE.Sprite`，很容易将对象定位在屏幕上的绝对位置。通过将其缩放至所需大小并应用纹理，我们可以使用渲染器显示图像。这种输出与常规3D结果相结合，允许你创建这类叠加层。
- en: See also
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'There are a couple of recipes that use an orthographic camera and more advanced
    tricks to compose the final rendering:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个配方使用正交摄像机和更高级的技巧来组合最终的渲染：
- en: In this chapter, we explored how to set up `THREE.OrthographicCamera` in the
    *Using an orthographic camera* recipe.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在*使用正交摄像机*配方中设置`THREE.OrthographicCamera`。
- en: In [Chapter 4](ch04.html "Chapter 4. Materials and Textures"), *Materials and
    Textures*, we'll show how you can use an HTML5 canvas and a HTML5 video as an
    input to a texture in the *Using HTML canvas as a texture* and *Using an HTML
    video as a texture* recipes.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。材料和纹理")中，我们将展示如何在*使用HTML canvas作为纹理*和*使用HTML视频作为纹理*配方中使用HTML5
    canvas和HTML5视频作为纹理的输入。
- en: In [chapter 6](ch06.html "Chapter 6. Point Clouds and Postprocessing"), *Point
    Clouds and Postprocessing*, we show you how to set up a more complex rendering
    pipeline in the *Setting up a postprocessing pipeline* recipe.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。点云和后期处理")中，*点云和后期处理*，我们在*设置后期处理管道*配方中向您展示了如何设置更复杂的渲染管道。
- en: Rotating the camera around a scene
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 围绕场景旋转相机
- en: In [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and
    Meshes*, we already showed you a number of recipes that explained how to rotate
    objects. In this recipe, we'll show you how to rotate the camera around a scene
    while the camera will keep looking at the center of the scene.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。几何体和网格")中，*几何体和网格*，我们已经向您展示了多个配方，解释了如何旋转对象。在这个配方中，我们将向您展示如何在保持相机始终注视场景中心的同时旋转相机。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll use the standard `THREE.PerspectiveCamera` object, which
    we rotate around a simple scene. To see the final result, open the `03.08-rotate-camera-around-scene-y-axis.html`
    example in your browser.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用标准的`THREE.PerspectiveCamera`对象，我们将它围绕一个简单的场景旋转。要查看最终结果，请在您的浏览器中打开`03.08-rotate-camera-around-scene-y-axis.html`示例。
- en: '![Getting ready](img/1182OS_03_12.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_03_12.jpg)'
- en: On this web page, you can see that the camera rotates around the scene while
    the floor, box, and lights stay at the same position.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网页上，你可以看到相机围绕场景旋转，而地板、箱子和灯光保持在同一位置。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To accomplish this, we only need to perform a couple of very simple steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们只需要执行几个非常简单的步骤：
- en: 'The first thing we need to do is create `THREE.PerspectiveCamera` and position
    it somewhere in the scene:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建`THREE.PerspectiveCamera`并将其放置在场景中的某个位置：
- en: '[PRE28]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To rotate the camera, we recalculate its position in the render loop as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要旋转相机，我们在渲染循环中重新计算其位置如下：
- en: '[PRE29]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this render function, we update the `camera.position.x` and `camera.position.z`
    variables, and by calling `camera.lookAt(scene.position)`, we make sure we keep
    looking at the center of the scene.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个渲染函数中，我们更新了`camera.position.x`和`camera.position.z`变量，并通过调用`camera.lookAt(scene.position)`，确保我们始终注视场景的中心。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: What we do here is some basic vector math. We execute a very small rotation
    of the camera using a rotation matrix. However, instead of the 3D and 4D matrices
    we used in other recipes, we just use a 2D matrix this time (represented with
    the two calculations in the **render** loop). After the rotation, we just need
    to make sure the camera is still looking at the correct position, so we use the
    `lookAt` function (which once again, internally uses matrix calculations to determine
    how to align the camera to the scene).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是一些基本的向量数学。我们使用旋转矩阵执行相机的一个非常小的旋转。然而，与其他配方中使用的3D和4D矩阵不同，这次我们只使用一个2D矩阵（用**渲染**循环中的两个计算表示）。旋转后，我们只需确保相机仍然注视正确的位置，所以我们使用`lookAt`函数（它再次内部使用矩阵计算来确定如何将相机对准场景）。
- en: There's more…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this recipe, we rotated around the scene's *y* axis. This results in a very
    smooth animation where the camera circles around the scene. We could, of course,
    also apply this to the other axes. We provided an example that you can view in
    the sources provided with this book. If you open `03.08-rotate-camera-around-scene-x-axis.html`
    in your browser, the camera rotates around the *x* axis instead of the *y* axis.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们围绕场景的*y*轴旋转。这产生了一个非常平滑的动画，其中相机围绕场景旋转。当然，我们也可以将此应用于其他轴。我们提供了一个可以在本书提供的源代码中查看的示例。如果你在浏览器中打开`03.08-rotate-camera-around-scene-x-axis.html`，相机会围绕*x*轴旋转而不是*y*轴。
- en: 'The only change you have to make is change the calculations in the render loop:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的唯一改变是在渲染循环中更改计算：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you look at this example in your browser, you might notice something strange.
    At a certain point, it'll look like the camera jumps around. The reason is that
    the camera tries to stay the right-side up, so it quickly changes orientation
    when it is at the top or bottom of its rotation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中查看这个示例时，你可能会注意到一些奇怪的现象。在某个时刻，它看起来像相机在跳跃。原因是相机试图保持直立，所以当它旋转到顶部或底部时，它会迅速改变方向。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries and
    Meshes*, we already discussed some rotation-related recipes. If you want to learn
    more about rotation or the matrix calculations required for it, look at the following
    recipes from [Chapter 2](ch02.html "Chapter 2. Geometries and Meshes"), *Geometries
    and Meshes*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。几何体和网格")中，*几何体和网格*，我们已经讨论了一些与旋转相关的食谱。如果你想要了解更多关于旋转或其所需的矩阵计算，请查看以下来自[第2章](ch02.html
    "第2章。几何体和网格")，*几何体和网格*的食谱：
- en: '*Rotating an object around its own axis*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*围绕对象的自身轴旋转*'
- en: '*Rotating an object around a point in space*'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在空间中的点周围旋转对象*'
- en: '*Applying matrix transformations*'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用矩阵变换*'
- en: Matching the rendered view to a resized browser
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将渲染视图与调整大小的浏览器匹配
- en: When you define a camera in Three.js, you need to define the aspect ratio; for
    a renderer, you need to define its output size. Normally, you do this once when
    you set up your initial scene. This works great until the user resizes their browser.
    In this case, the aspect ratio for the camera will probably change, as will the
    output size for the renderer. In this recipe, we'll show you the steps you need
    to take to react to changes to the screen size.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Three.js中定义一个相机时，你需要定义其纵横比；对于渲染器，你需要定义其输出大小。通常，你会在设置初始场景时只做一次。这工作得很好，直到用户调整浏览器的大小。在这种情况下，相机的纵横比可能会改变，渲染器的输出大小也可能会改变。在这个食谱中，我们将向你展示你需要采取的步骤来响应屏幕大小的变化。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: As with every recipe, we provide an example that you can use to test and experiment
    with for this recipe as well. Open `03.06-change-the-camera-on-screen-resize.html`
    in your browser and make the screen very small.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个食谱一样，我们提供了一个示例，你可以用它来测试和实验这个食谱。在你的浏览器中打开`03.06-change-the-camera-on-screen-resize.html`，并将屏幕调得很小。
- en: '![Getting ready](img/1182OS_03_13.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_03_13.jpg)'
- en: What you see is that the same amount of information is shown in the scene—only
    rendered smaller. When you now increase the screen size again, you'll see that
    Three.js always uses the complete available space.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到场景中显示的信息量相同——只是渲染得更小。当你现在再次增加屏幕大小时，你会看到Three.js总是使用完整的可用空间。
- en: '![Getting ready](img/1182OS_03_14.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1182OS_03_14.jpg)'
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we''ll add a resize handler to the web page, which reacts to
    resize events. Adding this handler only takes a couple of steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将向网页添加一个调整大小处理程序，该处理程序会对调整大小事件做出反应。添加此处理程序只需要几个步骤：
- en: 'The first thing we need to add is the function that we call when the resize
    event occurs. The following code fragment shows you the `onResize` function that
    we will call in the next step:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加的第一件事是在调整大小事件发生时调用的函数。以下代码片段显示了我们将要调用的`onResize`函数：
- en: '[PRE31]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this code snippet, we first recalculate the aspect ratio for the camera based
    on the new width and height. As Three.js caches certain aspects of the camera,
    we have to call the `updateProjectionMatrix()` function next to make sure the
    new aspect ratio is used. We also change the size for the renderer to the new
    width and height, so the complete screen space is used.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们首先根据新的宽度和高度重新计算相机的纵横比。由于Three.js缓存了相机的某些方面，我们必须调用`updateProjectionMatrix()`函数以确保使用新的纵横比。我们还更改了渲染器的大小为新宽度和高度，以便使用完整的屏幕空间。
- en: 'Now that we''ve got our update function, we need to define an event listener:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的更新函数，我们需要定义一个事件监听器：
- en: '[PRE32]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we add an event listener for the `resize` event. So whenever
    the screen is resized, the provided function, which is `onResize`, will be called.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们添加了一个对`resize`事件的监听器。所以每当屏幕调整大小时，提供的函数，即`onResize`，将被调用。
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Whenever something happens within a browser (a button is clicked on, the mouse
    is moved, the window is resized, and so on), browsers will throw an event. From
    JavaScript, you can register listeners to these events so that you can respond
    to them. In this recipe, we use the `resize` event to listen to any change in
    the window size. For more information on this event, you can look at the excellent
    documentation Mozilla provides at [https://developer.mozilla.org/en-US/docs/Web/Events/resize](https://developer.mozilla.org/en-US/docs/Web/Events/resize).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器内发生某些事情（按钮被点击，鼠标移动，窗口大小调整等）时，浏览器会抛出一个事件。从 JavaScript 中，你可以注册监听器来响应这些事件。在这个菜谱中，我们使用
    `resize` 事件来监听窗口大小的任何变化。有关此事件的更多信息，你可以查看 Mozilla 提供的出色文档，请参阅 [https://developer.mozilla.org/en-US/docs/Web/Events/resize](https://developer.mozilla.org/en-US/docs/Web/Events/resize)。
- en: Converting world coordinates to screen coordinates
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将世界坐标转换为屏幕坐标
- en: If you are creating a game that provides a 2D interface on top of a 3D world,
    for instance, as shown in the *Creating a 2D overlay* recipe, you might want to
    know how the 3D coordinates map to your 2D overlay. If you know the 2D coordinates,
    you can add all kinds of visual effects to the 2D overlay, such as tracking the
    code or letting the 2D overlay interact with the objects in the 3D scene.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个在 3D 世界之上提供 2D 界面的游戏，例如，如 *创建 2D 浮层* 菜谱中所示，你可能想知道 3D 坐标如何映射到你的 2D 浮层。如果你知道
    2D 坐标，你可以在 2D 浮层上添加各种视觉效果，例如跟踪代码或让 2D 浮层与 3D 场景中的对象交互。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You don''t need to perform any steps to get ready for this recipe. In this
    recipe, we can use the `THREE.Projector` object available in Three.js to determine
    the correct coordinates. You can view the result from this recipe in action by
    opening `03.07-convert-world-coordintate-to-screen-coordinates.html` in your browser
    as shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要执行任何步骤来为这个菜谱做准备。在这个菜谱中，我们可以使用 Three.js 中可用的 `THREE.Projector` 对象来确定正确的坐标。你可以通过在浏览器中打开
    `03.07-convert-world-coordintate-to-screen-coordinates.html` 来查看这个菜谱的结果，如下截图所示：
- en: '![Getting ready](img/1182OS_03_15.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_03_15.jpg)'
- en: The box appears at random positions when you open this example. When you click
    on the **calculateScreenCoordinate** button in the menu in the top-right section,
    the *x* and *y* coordinates of the center of the box will be shown.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开这个示例时，盒子出现在随机位置。当你点击右上角菜单中的 **calculateScreenCoordinate** 按钮时，盒子的中心 *x*
    和 *y* 坐标将会显示出来。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To convert world coordinates to screen coordinates, we use a couple of internal
    Three.js objects:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要将世界坐标转换为屏幕坐标，我们使用几个 Three.js 的内部对象：
- en: 'The first object we need is `THREE.Projector`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的第一个对象是 `THREE.Projector`：
- en: '[PRE33]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we use this projector to project the position of the cube onto the camera:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用这个投影仪将立方体的位置投影到相机上：
- en: '[PRE34]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `vector` variable will now contain the position of the object as it is seen
    by the `camera` object.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`vector` 变量现在将包含对象的位置，这是由 `camera` 对象看到的。'
- en: 'When you project a vector, as we did in step two, the resulting *x* and *y*
    values range from -1 to 1\. So in this final step, we convert these values to
    the current screen width and height:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你投影一个向量，就像我们在第二步中做的那样，得到的 *x* 和 *y* 值范围从 -1 到 1。所以在这个最后一步中，我们将这些值转换为当前的屏幕宽度和高度：
- en: '[PRE35]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, the `vector` variable will contain the screen coordinates of
    the center of `object`. You can now use these coordinates with standard JavaScript,
    HTML, and CSS to add effects.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，`vector` 变量将包含 `object` 中心的屏幕坐标。你现在可以使用这些坐标与标准的 JavaScript、HTML 和 CSS
    结合，添加效果。
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we use the same effect that Three.js uses to render the scene.
    When you render a scene, the objects are projected onto a camera, which determines
    what area needs to be rendered and where the objects appear. With the projector
    class, we can perform this projection for a single vector. The result is the position
    of this vector in two dimensions based on the used camera.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了 Three.js 渲染场景时使用的相同效果。当你渲染一个场景时，对象会被投影到一个相机上，这决定了需要渲染的区域以及对象出现的位置。通过投影器类，我们可以对单个向量执行这种投影。结果是，基于使用的相机，这个向量在二维空间中的位置。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In this recipe, we converted world coordinates to screen coordinates. This is
    actually rather easy, as we've got all the information (in three dimensions) to
    correctly determine the coordinates (in two dimensions). In the *Selecting an
    object in the scene* recipe, we convert a screen coordinate to a world coordinate,
    which is harder to do, as we don't have any depth information we can use.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将世界坐标转换为屏幕坐标。这实际上相当简单，因为我们已经拥有了所有必要的信息（在三维空间中）来正确确定坐标（在二维空间中）。在`在场景中选择对象`食谱中，我们将屏幕坐标转换为世界坐标，这更难做到，因为我们没有可以使用任何深度信息。
- en: Selecting an object in the scene
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在场景中选择对象
- en: A common requirement for Three.js applications is to interact with the scene.
    You might create a shooter where you want to use the mouse for aiming or an RPG
    where you need to interact with your environment. In this recipe, we'll show you
    how you can use the mouse to select objects that are rendered on screen.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Three.js应用程序来说，一个常见的需求是与场景交互。你可能创建了一个射击游戏，其中你想要使用鼠标进行瞄准，或者一个角色扮演游戏，其中你需要与环境交互。在这个食谱中，我们将向你展示如何使用鼠标选择屏幕上渲染的对象。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To apply this effect, we'll need a scene where we can select some objects. For
    this recipe, we've provided an example, which is `03.10-select-an-object-in-the-scene.html`.
    If you open this file in your browser, you'll see a number of objects moving around
    the scene.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个效果，我们需要一个场景，其中我们可以选择一些对象。对于这个食谱，我们提供了一个示例，它是`03.10-select-an-object-in-the-scene.html`。如果你在浏览器中打开这个文件，你会看到许多对象在场景中移动。
- en: '![Getting ready](img/1182OS_03_16.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1182OS_03_16.jpg)'
- en: You can use your mouse to select any of the objects on screen. The first time
    you click on them, they'll become transparent, and the next time, they'll become
    solid again.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用鼠标选择屏幕上的任何对象。第一次点击它们时，它们会变成透明，下一次点击时，它们又会变成实心。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll need to work through a couple of steps for this recipe:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，我们需要完成几个步骤：
- en: 'The first thing we need to do is set up the mouse listener. We want to fire
    a JavaScript function each time the mouse button is clicked on. To do this, we
    register the following listener:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要做的是设置鼠标监听器。我们希望在每次鼠标按钮被点击时触发一个JavaScript函数。为此，我们注册以下监听器：
- en: '[PRE36]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will tell the browser to fire the `onDocumentMouseDown` button whenever
    a `mousedown` event is detected.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将告诉浏览器在检测到`mousedown`事件时触发`onDocumentMouseDown`按钮。
- en: 'Next, we define the `onMouseDown` function as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`onMouseDown`函数如下：
- en: '[PRE37]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function will be called when you push the left mouse button. In the upcoming
    steps, we'll show you what to put into this function to detect which object is
    selected.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你按下鼠标左键时，这个函数将被调用。在接下来的步骤中，我们将向你展示如何将内容放入这个函数以检测哪个对象被选中。
- en: 'The first thing we need to do is convert the *x* and *y* coordinates of the
    mouse click to a position that `THREE.PerspectiveCamera` can understand:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要做的是将鼠标点击的*x*和*y*坐标转换为`THREE.PerspectiveCamera`可以理解的坐标：
- en: '[PRE38]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, vector will contain the *x* and *y* coordinates in coordinates
    the camera and Three.js understands.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，向量将包含*x*和*y*坐标，这些坐标是相机和Three.js理解的坐标。
- en: 'Now we can use another Three.js object, which is `THREE.Raycaster`, to determine
    which objects in our scene might be located at the position we clicked on:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用另一个Three.js对象，即`THREE.Raycaster`，来确定场景中哪些对象可能位于我们点击的位置：
- en: '[PRE39]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we first create `THREE.Raycaster` and use the `intersectObjects` function
    to determine whether `sphere`, `cylinder`, or `cube` are selected. If an object
    is selected, it will be stored in the `intersects` array.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建`THREE.Raycaster`并使用`intersectObjects`函数来确定是否选择了`sphere`、`cylinder`或`cube`。如果一个对象被选中，它将被存储在`intersects`数组中。
- en: 'Now we can process the `intersects` array. The first element will be the element
    closest to the camera, and in this recipe, this is the one we''re interested in:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以处理`intersects`数组。第一个元素将是离相机最近的元素，在这个食谱中，这是我们感兴趣的：
- en: '[PRE40]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this recipe, we just switch the opacity of an object whenever it is clicked
    on.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们只是在对象被点击时切换其不透明度。
- en: That's it. With this setup, you can select objects using your mouse.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。使用这个设置，你可以用鼠标选择对象。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe works by using `THREE.RayCaster`. With `THREE.RayCaster`, as the
    name implies, you shoot out a ray into the scene. The path of this ray is based
    on the properties of the camera, the position of the camera, and the objects provided
    to the `intersectObjects` function. For each of the provided objects, Three.js
    determines whether a ray cast using `THREE.RayCaster` can hit the specified object.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱通过使用 `THREE.RayCaster` 来工作。正如其名所示，使用 `THREE.RayCaster`，你会在场景中射出一束光线。这束光线的路径基于相机的属性、相机的位置以及提供给
    `intersectObjects` 函数的对象。对于提供的每个对象，Three.js 会确定使用 `THREE.RayCaster` 射出的光线是否能击中指定的对象。
- en: There's more
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'An interesting effect that can be added, and that better visualizes what is
    happening, is rendering the ray that is cast by `THREE.RayCaster`. You can very
    easily do this by just adding the following to step 5 of this recipe:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加的一个有趣的效果，并且能更好地可视化正在发生的事情，就是渲染由 `THREE.RayCaster` 射出的光线。你只需在本食谱的第 5 步中添加以下内容就可以很容易地做到这一点：
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There''s nothing too special in this code fragment. We just draw a line from
    the position of the camera (with a small offset to the *y* axis, or else we don''t
    see anything) to the position where the ray intersects. The result, which you
    can also see in the example discussed in the *Getting ready* section of this recipe,
    looks something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段并没有什么特别之处。我们只是从相机的位置（在 *y* 轴上有一个小的偏移，否则我们什么也看不到）画一条线到光线相交的位置。结果，你可以在本食谱中
    *准备就绪* 部分讨论的示例中看到，看起来像这样：
- en: '![There''s more](img/1182OS_03_17.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多](img/1182OS_03_17.jpg)'
- en: See also
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In this recipe, we convert a 2D coordinate into a 3D one. In the *Converting
    world coordinates to screen coordinates* recipe, we explain how to do the opposite.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将二维坐标转换为三维坐标。在 *将世界坐标转换为屏幕坐标* 的食谱中，我们解释了如何做相反的操作。
