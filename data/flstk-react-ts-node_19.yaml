- en: '*Chapter 16*: Adding a GraphQL Schema – Part II'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：添加GraphQL模式-第II部分'
- en: In this chapter, we're going to continue completing our client and server code.
    We will complete our Thread screens, which allow us to post new Threads and their
    responses, and also finish the Points system for the site. Please use the source
    code from [*Chapter 15*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222)*, Adding
    a GraphQL Schema – Part I*, to do this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续完成我们的客户端和服务器代码。我们将完成我们的Thread屏幕，允许我们发布新的Threads和它们的回复，并完成网站的积分系统。请使用[*第15章*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222)*，添加GraphQL模式-第I部分*中的源代码来完成此操作。
- en: Thread route
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thread路由
- en: 'In this section, we will update our `Thread` component, which provides our
    thread route. We''re going to be touching on a lot of files as we go through this.
    Follow these steps:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新我们的`Thread`组件，该组件提供我们的线程路由。在进行此操作时，我们将涉及许多文件。请按照以下步骤进行操作：
- en: 'Open `typeDefs` and edit the `Thread` and `ThreadItem` types. Then, add this
    field just below `views`:'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`typeDefs`并编辑`Thread`和`ThreadItem`类型。然后，在`views`下方添加此字段：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open the `ThreadRepo` file and update the `getThreadById` function, like
    this:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`ThreadRepo`文件并更新`getThreadById`函数，就像这样：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All we did here was add the following `relations` to our `findOne` query:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是在我们的`findOne`查询中添加了以下`relations`：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, update the `getThreadsByCategoryId` function''s call to `Thread.createQueryBuilder`,
    like this:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`getThreadsByCategoryId`函数调用`Thread.createQueryBuilder`，就像这样：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've included the relation for the User entity here. The rest of the code for
    this function remains the same.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包含了User实体的关系。此函数的其余代码保持不变。
- en: 'Now, open the `User.ts` file in your client app and update the `threads` and
    `threadItems` fields so that they''re optional. We need to do this so that we
    can add a `User` account that has not posted anything yet:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开您的客户端应用中的`User.ts`文件，并更新`threads`和`threadItems`字段，使它们成为可选的。我们需要这样做，以便我们可以添加一个尚未发布任何内容的`User`账户：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, open the `models/Thread.ts` and `models/ThreadItem.ts` files in the React
    client project and replace the `userName` and `userId` fields with a single field
    user, like this:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开React客户端项目中的`models/Thread.ts`和`models/ThreadItem.ts`文件，并用单个字段user替换`userName`和`userId`字段，就像这样：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also need to replace the references to the `userName` and `userId` fields
    in our `DataService.ts` file with a user object. Here, I''ve placed an object
    at the top of the file and used it throughout the file to replace those two fields:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在我们的`DataService.ts`文件中用用户对象替换`userName`和`userId`字段的引用。在这里，我在文件顶部放置了一个对象，并在整个文件中使用它来替换这两个字段：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Take a look at the `DataService.ts` file if you need any help, though this should
    be pretty trivial.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要帮助，请查看`DataService.ts`文件，尽管这应该是相当琐碎的。
- en: 'Now that we''ve updated our `User` schema type and our entities, we need to
    update some queries. In the `Main.tsx` file, update the `GetThreadsByCategoryId`
    and `GetThreadsLatest` queries, like this:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经更新了我们的`User`模式类型和我们的实体，我们需要更新一些查询。在`Main.tsx`文件中，更新`GetThreadsByCategoryId`和`GetThreadsLatest`查询，就像这样：
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: const GetThreadsLatest = gql`
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: const GetThreadsLatest = gql`
- en: query getThreadsLatest {
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查询getThreadsLatest {
- en: getThreadsLatest {
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: getThreadsLatest {
- en: '... on EntityResult {'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '... on EntityResult {'
- en: messages
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: messages
- en: '}'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '... on ThreadArray {'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '... on ThreadArray {'
- en: threads {
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: threads {
- en: id
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: id
- en: title
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: title
- en: body
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: body
- en: views
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: views
- en: points
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: points
- en: user {
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: user {
- en: userName
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: userName
- en: '}'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: threadItems {
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: threadItems {
- en: id
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: id
- en: '}'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: category {
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: category {
- en: id
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: id
- en: name
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: name
- en: '}'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '`;'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`;'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, in our `ThreadCard.tsx` file, find the following JSX:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的`ThreadCard.tsx`文件中，找到以下JSX：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace it with the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we need to make some more changes to our `RichEditor.tsx` file. Note that
    our Thread screen will be showing user submitted text. So, once a user has submitted
    what they wish to post, we will make it so that they cannot edit it afterward.
    We'll do this by making the read-only setting a prop.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要对我们的`RichEditor.tsx`文件进行一些更改。请注意，我们的Thread屏幕将显示用户提交的文本。因此，一旦用户提交了他们希望发布的内容，我们将使其无法在此后进行编辑。我们将通过将只读设置为一个属性来实现这一点。
- en: 'Turn the `RichEditorProps` interface into a class and update it, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RichEditorProps`接口转换为类并更新，就像这样：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'const RichEditor: FC<RichEditorProps> = ({ existingBody, readOnly field as
    a parameter. Now, inside the Editable component, add it as an attribute, like
    this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'const RichEditor: FC<RichEditorProps> = ({ existingBody, readOnly field as
    a parameter. Now, inside the Editable component, add it as an attribute, like
    this:'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, open the `src/components/routes/thread/Thread.tsx` file. This file is our
    main screen for loading the Thread route. Let's update this file.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`src/components/routes/thread/Thread.tsx`文件。这个文件是我们加载Thread路由的主要屏幕。让我们更新这个文件。
- en: 'Here, we''re adding a new `GetThreadById` query to get our relevant Thread:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新的`GetThreadById`查询来获取我们相关的Thread：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are using our `GetThreadById` query, along with our `useLazyQuery`
    Hook, and creating an executor function called `execGetThreadById`, which we will
    run a bit later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们的`GetThreadById`查询，以及我们的`useLazyQuery` Hook，并创建了一个名为`execGetThreadById`的执行函数，稍后我们将运行它。
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `thread` state object is what we will be using to populate our UI and share
    it with other components.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread`状态对象是我们将用来填充我们的UI并与其他组件共享的对象。'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`id` is the URL parameter representing the Thread''s `id` value.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`是代表Thread的`id`值的URL参数。'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will use this `readOnly` state to make our `RichEditor` read-only if we are
    dealing with an existing Thread record.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是现有的Thread记录，我们将使用这个`readOnly`状态使我们的`RichEditor`只读。
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we've run our `execGetThreadById` call by using the parameter given by
    the URL for the Thread's `id`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用URL给出的参数运行了我们的`execGetThreadById`调用，以获取Thread的`id`。
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once our `execGetThreadById` call is completed, a `threadData` object is returned.
    We can use this to set our local `thread` state.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了`execGetThreadById`调用，就会返回一个`threadData`对象。我们可以使用这个对象来设置我们的本地`thread`状态。
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we are using the `thread?.user` object to get our `userName` field, instead
    of `thread?.userName`, which is how we had it set up previously.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`thread?.user`对象来获取我们的`userName`字段，而不是`thread?.userName`，这是我们之前设置的方式。
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`ThreadCategory` has now been updated so that it will set `CategoryDropDown`
    to the `Category` option provided. We''ll look at this later.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadCategory`现在已经更新，这样它将把`CategoryDropDown`设置为提供的`Category`选项。我们稍后会看一下这个。'
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we passed the `readOnly` state value to `ThreadBody` since `ThreadBody`
    uses `RichEditor` internally.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`readOnly`状态值传递给了`ThreadBody`，因为`ThreadBody`在内部使用了`RichEditor`。
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we passed the `readOnly` state value to `ThreadResponsesBuilder`, which
    shows our ThreadItem responses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`readOnly`状态值传递给了`ThreadResponsesBuilder`，它显示了我们的ThreadItem responses。
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The remaining UI is the same as it was previously.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的UI与以前一样。
- en: 'Now, let''s look at the `ThreadCategory` component. Here''s how it looks now:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看`ThreadCategory`组件。现在它是这样的：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ve switched our interface definition so that it takes a `Category` object
    instead of a string. This allows us to pass it down to our `CategoryDropDown`
    component:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经切换了接口定义，使其接受`Category`对象而不是字符串。这使我们可以将其传递给我们的`CategoryDropDown`组件：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we''ve used `category?.name` of the `Category` object, whereas previously,
    we used `categoryName` as the necessary parameter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`Category`对象的`category?.name`，而以前我们使用`categoryName`作为必要的参数：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we''ve explicitly passed in the `preselectedCategory` prop from our component''s
    `category` prop:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确地传递了`preselectedCategory`属性，从我们组件的`category`属性中：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, update your `ThreadBody` component''s call to `RichEditor` by passing
    the `readOnly` field, like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过传递`readOnly`字段来更新`ThreadBody`组件对`RichEditor`的调用，就像这样：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we''ve added the `readOnly` field to our props type; that is, `ThreadBodyProps`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将`readOnly`字段添加到我们的props类型中；也就是`ThreadBodyProps`：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s update the `ThreadResponseBuilder` component, like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新`ThreadResponseBuilder`组件，就像这样：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Again, this is a `readOnly` prop definition. This is because this component
    uses a `ThreadResponse`, which internally uses `RichEditor`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是一个`readOnly`属性定义。这是因为这个组件使用了`ThreadResponse`，而`ThreadResponse`在内部使用了`RichEditor`：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we've used the Thread's `user` object to get the required `userName`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了Thread的`user`对象来获取所需的`userName`。
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here is our `readOnly` field being passed into `ThreadResponse`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`readOnly`字段被传递到`ThreadResponse`中。
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The rest of code is the same as it was previously.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码与以前一样。
- en: 'Finally, we have our `ThreadResponse` component, which is updated with the
    `readOnly` prop, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了我们的`ThreadResponse`组件，它使用了`readOnly`属性，就像这样：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here's the prop definition.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是属性定义。
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '}) => {'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '}) => {'
- en: return (
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <div>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <div>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <div>
- en: <UserNameAndTime userName={userName}           lastModifiedOn={lastModifiedOn}
    />
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <UserNameAndTime userName={userName} lastModifiedOn={lastModifiedOn} />
- en: '<span style={{ marginLeft: "1em" }}>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '<span style={{ marginLeft: "1em" }}>'
- en: <ThreadPointsInline points={points || 0} />
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <ThreadPointsInline points={points || 0} />
- en: </span>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: </span>
- en: </div>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="thread-body-editor">
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="thread-body-editor">
- en: <RichEditor existingBody={body}          readOnly={readOnly} />
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <RichEditor existingBody={body} readOnly={readOnly} />
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: </div>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: );
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '};'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It's a bit difficult to see since there's no significant visual clue, but you'll
    notice that on the thread route for any existing Thread, such as `http://localhost:5000/thread/1`,
    your editors for your Thread and any responses will all be in read-only mode,
    which means they can't be edited.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有明显的视觉线索，有点难以看到，但你会注意到在任何现有Thread的线程路由上，比如`http://localhost:5000/thread/1`，你的Thread和任何响应的编辑器都将处于只读模式，这意味着它们不能被编辑。
- en: Points system
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 积分系统
- en: 'Now that we''ve set everything up so that we can display points, we need a
    mechanism for setting them. This is what we''ll do now. Let''s get started:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了可以显示积分的一切，我们需要一个机制来设置它们。这就是我们现在要做的。让我们开始吧：
- en: Open the `Thread.tsx` file and take a look at the code. You will find a component
    called `ThreadPointsBar` near the end of the JSX. This is what shows the vertical
    bar of points in our `ThreadCard` and our `Thread.tsx` route.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Thread.tsx`文件，看一下代码。你会在JSX的末尾找到一个名为`ThreadPointsBar`的组件。这是我们的`ThreadCard`和`Thread.tsx`路由中显示积分垂直条的组件。
- en: We're going to add buttons to allow an increment or decrement of points. We've
    already built our backend and resolvers, so the work we'll be doing here will
    just tie that to our client code.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加按钮来允许增加或减少积分。我们已经构建了后端和解析器，所以我们在这里要做的工作只是将它与我们的客户端代码联系起来。
- en: 'Inside the `ThreadPointsBar.tsx` file, update the existing JSX, as follows.
    This is a significant change, so let''s break it down:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ThreadPointsBar.tsx`文件中，按照以下方式更新现有的JSX。这是一个重大的变化，让我们来分解一下：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we have our `updateThreadPoint` mutation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们的`updateThreadPoint` mutation。
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With that, we've converted our `ThreadPointsBarProps` interface into a class
    so that we can give some of the fields default values. Notice that, among the
    fields, we have a `refreshThread` function, which we'll use to force an update
    to our parent Thread so that once we update the points, this will be reflected
    in our UI. We'll go through the other fields as we use them. Also, we will no
    longer be sharing this prop with our `ThreadPointsInline` component, which I'll
    show later.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将我们的`ThreadPointsBarProps`接口转换成了一个类，这样我们就可以给一些字段设置默认值。请注意，在字段中，我们有一个`refreshThread`函数，我们将用它来强制更新我们的父Thread，这样一旦我们更新了积分，这将反映在我们的UI中。我们将在使用这些字段时逐一讨论其他字段。此外，我们将不再与我们的`ThreadPointsInline`组件共享这个属性，我稍后会展示。
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that our `useMutation` does not use `refetchQueries` to refresh Apollo
    Client. Normally, I would use this mechanism, but in testing, I found that the
    Apollo Client cache, which caches all GraphQL queries by default, was unable to
    refresh the Thread properly. These sorts of issues happen from time to time for
    all frameworks. It will be part of your job as a developer to figure out workarounds
    and solutions to these types of problems. So, instead of relying on `refetchQueries`,
    we will use our `refreshThread` function, which we can get from our parent, to
    force a refresh. I will show you the implementation of this function a little
    later in the `Thread` route component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的`useMutation`没有使用`refetchQueries`来刷新Apollo Client。通常情况下，我会使用这种机制，但在测试中，我发现Apollo
    Client缓存默认缓存所有GraphQL查询，无法正确刷新线程。所有框架都会遇到这些问题。作为开发人员，你的工作之一就是找到解决这些问题的方法和解决方案。因此，我们将使用我们的`refreshThread`函数，而不是依赖`refetchQueries`，我们可以从父级那里得到它，以强制刷新。稍后我会向你展示`Thread`路由组件中这个函数的实现。
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both these functions, `onClickIncThreadPoint` and `onClickDecThreadPoint`, are
    executing the `execUpdateThreadPoint` mutation before calling `refreshThread`.
    The `refreshThread && refreshThread()` syntax is one of JavaScript's capabilities
    that allows you to write less code. This syntax allows you to check that this
    optional function exists and if it does, execute it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数`onClickIncThreadPoint`和`onClickDecThreadPoint`在调用`refreshThread`之前执行`execUpdateThreadPoint`变异。`refreshThread
    && refreshThread（）`语法是JavaScript的一种能力，它允许你写更少的代码。这种语法允许你检查这个可选函数是否存在，如果存在，就执行它。
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we have a small bit of logic that uses the `allowUpdatePoints` prop,
    which decides whether to show or hide the icon container that allows the user
    to increment points. We must do the same for the decrement button as well:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一小段逻辑，使用`allowUpdatePoints`属性，决定是否显示或隐藏允许用户增加点数的图标容器。我们必须对减少按钮做同样的事情：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we've added two new icons, `faChevronUp` and `faChevronDown`. When clicked,
    they will increment or decrement the points of our Thread.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了两个新的图标，`faChevronUp`和`faChevronDown`。当点击时，它们将增加或减少我们线程的点数。
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The rest of the code remains the same. However, notice that our CSS has changed
    slightly. We've updated the existing `threadcard-points-item` class and added
    a new class called `threadcard-points-item-btn`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码保持不变。但是，请注意我们的CSS略有改变。我们更新了现有的`threadcard-points-item`类，并添加了一个名为`threadcard-points-item-btn`的新类。
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `threadcard-points-item` class is now a flexbox on a column so that it can
    show its content vertically.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`threadcard-points-item`类现在是一个列的flexbox，这样它可以垂直显示其内容。'
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `threadcard-points-item-btn` class converts our icon cursor into a pointer
    so that when a user hovers over it, the cursor becomes a hand, indicating that
    it can be clicked.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`threadcard-points-item-btn`类将我们的图标光标转换为指针，以便当用户悬停在上面时，光标变成手，表示可以点击。'
- en: 'Now that we''ve made these changes, we need to update some other relevant components.
    The first thing we want to do is disable `resultCaching` in our `ApolloClient`.
    Open the `index.tsx` file and update the `client` object, like this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经做出了这些改变，我们需要更新一些其他相关的组件。我们首先要做的是在我们的`ApolloClient`中禁用`resultCaching`。打开`index.tsx`文件并更新`client`对象，像这样：
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As the name suggests, this setting is supposed to disable query results from
    being cached. However, it does not do this on its own – we have to add another
    setting to our queries.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，此设置应该禁用查询结果的缓存。但是，它本身并不能做到这一点-我们必须向我们的查询添加另一个设置。
- en: Update the `Thread.tsx` file. We'll just show the code that has been changed.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Thread.tsx`文件。我们只显示已更改的代码。
- en: 'First, the `getThreadById` query has been updated slightly:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`getThreadById`查询略有更新：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: const [thread, setThread] = useState<ThreadModel |    undefined>();
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: const [thread，setThread] = useState<ThreadModel |    undefined>();
- en: const { id } = useParams();
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: const { id } = useParams（）;
- en: const [readOnly, setReadOnly] = useState(false);
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: const [readOnly，setReadOnly] = useState(false);
- en: const refreshThread = () => {
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新线程的常量=（）=》{
- en: if (id && id > 0) {
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: if（id && id > 0）{
- en: execGetThreadById({
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: execGetThreadById（{
- en: 'variables: {'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: variables：{
- en: id,
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: id，
- en: '},'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '}，'
- en: '});'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '}）;'
- en: '}'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: useEffect(() => {
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: useEffect（（）=》{
- en: if (id && id > 0) {
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: if（id && id > 0）{
- en: execGetThreadById({
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: execGetThreadById（{
- en: 'variables: {'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: variables：{
- en: id,
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: id，
- en: '},'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}，'
- en: '});'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}）;'
- en: '}'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}, [id, execGetThreadById]);'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '}，[id，execGetThreadById]）;'
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: useEffect(() => {
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: useEffect（（）=》{
- en: if (threadData && threadData.getThreadById) {
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（threadData && threadData.getThreadById）{
- en: setThread(threadData.getThreadById);
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: setThread(threadData.getThreadById);
- en: setReadOnly(true);
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: setReadOnly(true);
- en: '} else {'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: setThread(undefined);
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: setThread(undefined);
- en: setReadOnly(false);
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: setReadOnly(false);
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}, [threadData]);'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '}，[threadData]）;'
- en: return (
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: return（
- en: <div className="screen-root-container">
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="screen-root-container">
- en: <div className="thread-nav-container">
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="thread-nav-container">
- en: <Nav />
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <Nav />
- en: </div>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="thread-content-container">
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="thread-content-container">
- en: <div className="thread-content-post-container">
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="thread-content-post-container">
- en: <ThreadHeader
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <ThreadHeader
- en: userName={thread?.user.userName}
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: userName={thread？.user.userName}
- en: 'lastModifiedOn={thread ? thread.             lastModifiedOn : new Date()}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: lastModifiedOn={thread？线程。             lastModifiedOn：new Date（）}
- en: title={thread?.title}
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 标题={线程？.标题}
- en: />
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: <ThreadCategory category={thread?.category} />
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <ThreadCategory category={thread？.category} />
- en: <ThreadTitle title={thread?.title} />
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <ThreadTitle title={thread？.title} />
- en: <ThreadBody body={thread?.body}            readOnly={readOnly} />
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <ThreadBody body={thread？.body}            readOnly={readOnly} />
- en: </div>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="thread-content-points-container">
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="thread-content-points-container">
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <ThreadPointsBar
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <ThreadPointsBar
- en: points={thread?.points || 0}
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: points={thread？.points || 0}
- en: responseCount={
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: responseCount={
- en: thread && thread.threadItems && thread.               threadItems.length
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 线程&&线程。线程项&&线程。               threadItems.length
- en: '}'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: userId={thread?.user.id || "0"}
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: userId={thread？.user.id || "0"}
- en: threadId={thread?.id || "0"}
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: threadId={thread？.id || "0"}
- en: allowUpdatePoints={true}
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: allowUpdatePoints={true}
- en: refreshThread={refreshThread}
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: refreshThread={refreshThread}
- en: />
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </div>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="thread-content-response-container">
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="thread-content-response-container">
- en: <hr className="thread-section-divider" />
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <hr className="thread-section-divider" />
- en: <ThreadResponsesBuilder
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <ThreadResponsesBuilder
- en: threadItems={thread?.threadItems}
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: threadItems={thread？.threadItems}
- en: readOnly={readOnly}
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: readOnly={readOnly}
- en: />
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </div>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: );
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '};'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here's what the Thread route screen now looks like with our new points system
    in place:![Figure 16.1 – Thread route screen
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Thread路由屏幕看起来像这样，我们的新点数系统已经就位：![图16.1-Thread路由屏幕
- en: '](img/Figure_16.01_B15508.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.01_B15508.jpg)'
- en: Figure 16.1 – Thread route screen
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1-Thread路由屏幕
- en: If you try clicking the points buttons, you'll notice two things. For one, sometimes,
    the points change does not immediately show on the screen, despite all the work
    we did in eliminating caching as an issue. This is because we have a subtle bug
    in our Repository call, which I'll discuss in a bit. The other issue is that our
    user can add or remove more than one point at a time. This is another issue in
    our Styling layer. We'll revisit these two issues once our client code is complete.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试点击点按钮，您会注意到两件事。首先，有时，尽管我们在消除缓存问题上做了很多工作，但点数变化并没有立即显示在屏幕上。这是因为我们在Repository调用中有一个微妙的错误，我稍后会讨论。另一个问题是我们的用户可以一次添加或删除多个点。这是我们样式层中的另一个问题。一旦我们的客户端代码完成，我们将重新讨论这两个问题。
- en: 'Now, we need to update the points capability for our `ThreadItem` and `Thread`
    responses. We''ll start with `ThreadResponsesBuilder`. Update `useEffect`, like
    this:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们的`ThreadItem`和`Thread`响应的点数功能。我们将从`ThreadResponsesBuilder`开始。更新`useEffect`，像这样：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We are now passing the `ThreadReponse` component, which shows the Thread''s
    `ThreadItem`, `userId`, and `threadItemId`. In this component, we have the `ThreadPointsInline`
    component, which displays the like points for `ThreadItem` or `Thread`, depending
    on which was passed in, which I''ll clarify once we get to that control:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在传递了`ThreadReponse`组件，显示了Thread的`ThreadItem`，`userId`和`threadItemId`。在这个组件中，我们有`ThreadPointsInline`组件，根据传入的是`ThreadItem`还是`Thread`来显示点赞点数，一旦我们到达该控件，我会澄清：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, the `ThreadResponse` component can be updated. I'm only showing the changed
    code here.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`ThreadResponse`组件可以更新。我只在这里显示了更改的代码。
- en: 'First, add the following two fields to the `ThreadResponseProps` interface:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下两个字段添加到`ThreadResponseProps`接口中：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, in the JSX, we can add our `userId` and `threadItemId` fields:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在JSX中，我们可以添加我们的`userId`和`threadItemId`字段：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: </span>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: </span>
- en: </div>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: <div className="thread-body-editor">
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="thread-body-editor">
- en: <RichEditor existingBody={body}         readOnly={readOnly} />
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <RichEditor existingBody={body} readOnly={readOnly} />
- en: </div>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: </div>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: );
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, let's look at the changes we must make to the `ThreadPointsInline` component.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们必须对`ThreadPointsInline`组件进行的更改。
- en: 'Add the following import to the list of existing imports:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下导入添加到现有导入列表中：
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Take a look at the source code. For the most part, it''s a lot like the `ThreadPointsBar`
    CSS:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下源代码。在大多数情况下，它很像`ThreadPointsBar`的CSS：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we added our `updateThreadItemPoint` mutation definition.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了我们的`updateThreadItemPoint`mutation定义。
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This is now going to be our props list. Notice that we have a field for `threadId`.
    We will be using this `ThreadPointsInline` control to display our Thread points
    on mobile screens:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将是我们的props列表。请注意，我们有一个`threadId`字段。我们将使用这个`ThreadPointsInline`控件在移动屏幕上显示我们的Thread点数：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'There''s nothing particularly special here – both our `onClickIncThreadItemPoint`
    and `onClickDecThreadItemPoint` calls are doing similar things to the `ThreadPointsBar`
    component in that they call our update mutation and then refresh the Thread data:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别特殊的地方-我们的`onClickIncThreadItemPoint`和`onClickDecThreadItemPoint`调用都在`ThreadPointsBar`组件中做着类似的事情，它们调用我们的更新mutation然后刷新Thread数据：
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, in our JSX, we will do something similar to our `ThreadPointsBar` component
    and include icons that allow us to increment or decrement the entity points:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的JSX中，我们将做与我们的`ThreadPointsBar`组件类似的事情，并包括允许我们增加或减少实体点数的图标：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, if you load the `Thread` route screen again, you should see `ThreadItems`
    for our Thread. Again, your local data will vary, so please make sure your Thread
    contains `ThreadItem` data and their respective points, along with the icon buttons,
    as shown in the following screenshot:![Figure 16.2 – ThreadItem points
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您再次加载`Thread`路由屏幕，您应该会看到我们Thread的`ThreadItems`。再次强调，您的本地数据会有所不同，因此请确保您的Thread包含`ThreadItem`数据及其相应的点数，以及如下屏幕截图所示的图标按钮：![图16.2-ThreadItem点
- en: '](img/Figure_16.02_B15508.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.02_B15508.jpg)'
- en: Figure 16.2 – ThreadItem points
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2-ThreadItem点
- en: Again, if you click the increment and decrement buttons, you should see that
    we have the same issue that we had with the Thread points. Our points score does
    not always update, and the user can keep adding or removing points. Let's fix
    this issue now.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您点击增加和减少按钮，您会发现我们与Thread点数相同的问题。我们的点数得分并不总是更新，用户可以继续添加或删除点数。让我们现在解决这个问题。
- en: 'Go to your server project, open the `ThreadItemPointRepo.ts` file, find the
    `updateThreadItemPoint` function, and go to the first call to `threadItem.save()`.
    Add a prefix to all these calls in the function, like this:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的服务器项目，打开`ThreadItemPointRepo.ts`文件，找到`updateThreadItemPoint`函数，并转到对`threadItem.save()`的第一个调用。在函数中的所有这些调用之前添加一个前缀，就像这样：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Can you guess why this will fix the issue we're having? By calling `await` on
    the `save` call, we are forcing our function to wait until the save completes.
    Then, when we get our `ThreadItem` data, we are assured that it does indeed contain
    the newest `points` value. This is one of the tricky sides of using asynchronous
    code. It's faster, but you have to think about what you're doing; otherwise, you
    may run into issues like this.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到这将如何解决我们遇到的问题吗？通过在`save`调用上调用`await`，我们强制我们的函数等待保存完成。然后，当我们获取我们的`ThreadItem`数据时，我们可以确保它确实包含最新的`points`值。这是使用异步代码的棘手一面之一。它更快，但您必须考虑自己在做什么；否则，您可能会遇到这样的问题。
- en: Now, go ahead and update the `updateThreadPoint` function yourself, similar
    to what we just did with our `updateThreadItemPoint` function. Make sure to update
    every `save` function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续自己更新`updateThreadPoint`函数，类似于我们刚刚对`updateThreadItemPoint`函数所做的。确保更新每个`save`函数。
- en: Now, if you try incrementing or decrementing the points, you should see them
    update properly.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您尝试增加或减少积分，您应该会看到它们正确更新。
- en: 'Now, let''s fix the issue of users being able to keep adding or removing points.
    There''s actually multiple issues in this code path. Our two resolvers that update
    points, `updateThreadPoint` and `updateThreadItemPoint`, do not check for user
    authentication before trying to allow the user to update their points. This is
    obviously wrong. Additionally, our client-side code is actually passing the `userId`
    value of `Thread` or `ThreadItem` instead of the currently logged-in user. We
    can fix both issues together. First, update the `updateThreadPoint` resolver,
    like this:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们解决用户可以继续添加或删除积分的问题。在这段代码中实际上存在多个问题。我们的两个更新积分的解析器`updateThreadPoint`和`updateThreadItemPoint`在尝试允许用户更新他们的积分之前没有检查用户身份验证。这显然是错误的。此外，我们的客户端代码实际上传递了`Thread`或`ThreadItem`的`userId`值，而不是当前登录的用户。我们可以一起解决这两个问题。首先，更新`updateThreadPoint`解析器，就像这样：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We no longer take `userId` as a parameter for this resolver. This is because,
    as shown in the following code, we now check that the user is logged in via the
    `session.userId` field. Then, when we call our `updateThreadPoint` Repository
    query, we pass that `session.userId` field in as the `userId` parameter:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再将`userId`作为此解析器的参数。这是因为，如下面的代码所示，我们现在通过`session.userId`字段检查用户是否已登录。然后，当我们调用我们的`updateThreadPoint`存储库查询时，我们将`session.userId`字段作为`userId`参数传递：
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Make this same change for the `updateThreadItemPoint` resolver, since they are
    virtually identical calls. Also, don't forget to update our `typeDefs` so that
    the Mutation signatures for these calls no longer have the `userId` parameter.
    We'll also need to update the code paths in our client and remove the `userId`
    parameter there later.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`updateThreadItemPoint`解析器也进行相同的更改，因为它们几乎是相同的调用。还要不要忘记更新我们的`typeDefs`，以便这些调用的Mutation签名不再具有`userId`参数。我们还需要更新客户端中的代码路径，并稍后删除那里的`userId`参数。
- en: 'Now, add this code to the `updateThreadPoint` Repository call at the top of
    the implementation:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到实现的顶部的`updateThreadPoint`存储库调用中：
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This will prevent any odd values for `userId` getting passed in, and us thinking
    that the user is authenticated when they are not. Add the same code to the `updateThreadItemPoint`
    Repository call.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将防止`userId`传递任何奇怪的值，并且我们认为用户已经通过身份验证，而实际上并没有。将相同的代码添加到`updateThreadItemPoint`存储库调用中。
- en: Now, let's fix the client-side code and remove the `userId` parameter. The easiest
    way to do this is to remove the call from the `ThreadPointsBar` and `ThreadPointsInline`
    components. If you then save the code, you'll get the compiler telling you where
    the related calls are via `userId`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复客户端代码并删除`userId`参数。最简单的方法是从`ThreadPointsBar`和`ThreadPointsInline`组件中删除调用。然后保存代码，编译器会告诉您相关调用通过`userId`的位置。
- en: Let's start with `ThreadPointsBar`. Update it like this. Remove `userId` from
    the `UpdateThreadPoint` Mutation parameters. Then, remove it from the props of
    the component's `ThreadPointsBarProps` type. Next, remove it from the props parameters
    of `ThreadPointsBar`. Finally, remove `userId` from the calls to `execUpdateThreadPoints`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`ThreadPointsBar`开始。像这样更新它。从`UpdateThreadPoint` Mutation参数中删除`userId`。然后，从组件的`ThreadPointsBarProps`类型的props中删除它。接下来，从`ThreadPointsBar`的props参数中删除它。最后，从对`execUpdateThreadPoints`的调用中删除`userId`。
- en: Next, in the `Thread.tsx` route component, find the call to `ThreadPointsBar`
    and simply remove the `userId` props. Also, remove the `useSelector` call to get
    the user reducer as it's no longer being used.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Thread.tsx`路由组件中，找到对`ThreadPointsBar`的调用，并简单地删除`userId` props。还要删除`useSelector`调用以获取用户reducer，因为它不再被使用。
- en: The `ThreadPointsInline` component also needs the same kind of refactor, but
    I'll leave that change up to you since it's basically the same type of change
    we made for `ThreadPointsBar`. Again, try making the change while beginning with
    the `ThreadPointsInline` component and save your code. The compiler should tell
    you where the references to `userId` still exist.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPointsInline`组件也需要进行相同类型的重构，但我会把这个改变留给你，因为它基本上和我们为`ThreadPointsBar`做的改变是一样的。同样，尝试从`ThreadPointsInline`组件开始进行更改并保存您的代码。编译器应该会告诉您`userId`的引用仍然存在的位置。'
- en: With that, our points should update properly. The points should only update
    when the user is logged in, and only be able to change by one point, either incremented
    or decremented. The user should also not be allowed to change the points for their
    own `Thread` or `ThreadItem`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的积分应该可以正确更新。积分应该只在用户登录时更新，并且只能增加或减少一个积分。用户也不应该被允许更改他们自己的`Thread`或`ThreadItem`的积分。
- en: 'Now, let''s look at something else. When looking at the `Thread` route component
    in mobile mode, you will see that our points counts are no longer visible, as
    shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看其他的东西。在移动模式下查看`Thread`路由组件时，您会发现我们的积分计数不再可见，如下所示：
- en: '![Figure 16.3 – Thread route screen mobile mode'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3 - 移动模式下的Thread路由屏幕'
- en: '](img/Figure_16.03_B15508.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.03_B15508.jpg)'
- en: Figure 16.3 – Thread route screen mobile mode
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 - 移动模式下的Thread路由屏幕
- en: 'This, of course, is deliberate since there is so little horizontal room. So,
    let''s put our `ThreadPointsInline` component in this mobile screen and update
    it so that it can work for Threads as well as ThreadItems:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是故意的，因为水平空间很小。所以，让我们把我们的`ThreadPointsInline`组件放在这个移动屏幕上，并更新它，使它可以为Threads和ThreadItems工作：
- en: Because `ThreadPointsInline` is being refactored to use the `updateThreadPoint`
    Mutation that `ThreadPointBar` is using, we must move those calls into their own
    Hook and share them. Create a new file inside the Hooks folder called `useUpdateThreadPoint.ts`
    and add the respective Git source code to it.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`ThreadPointsInline`正在重构以使用`ThreadPointBar`正在使用的`updateThreadPoint` Mutation，我们必须将这些调用移到它们自己的Hook中并共享它们。在Hooks文件夹内创建一个名为`useUpdateThreadPoint.ts`的新文件，并将相应的Git源代码添加到其中。
- en: By doing this, we have simply copied most of the code from the `ThreadPointBar`
    component into here. Once we've done this, we return the event handlers to be
    used by our calling component; that is, `onClickIncThreadPoint` and `onClickDecThreadPoint`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们只是将大部分代码从`ThreadPointBar`组件复制到这里。完成这一步后，我们将返回事件处理程序供我们调用的组件使用；也就是`onClickIncThreadPoint`和`onClickDecThreadPoint`。
- en: 'Now, let''s refactor the `ThreadPointBar` component so that it can use this
    Hook. Update it like this:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重构`ThreadPointBar`组件，以便它可以使用这个Hook。将其更新如下：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, we''ve imported our new Hook and removed the Mutation for `UpdateThreadPoint`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了我们的新Hook，并移除了`UpdateThreadPoint`的Mutation：
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we've received the event handlers from our `useUpdateThreadPoint` Hook.
    The rest of the code is identical.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`useUpdateThreadPoint` Hook中接收了事件处理程序。其余的代码是相同的。
- en: 'Now, let''s refactor `ThreadPointsInline`, like this:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们像这样重构`ThreadPointsInline`：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here, we''ve gotten our event handlers from the `useUpdateThreadPoint` Hook:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`useUpdateThreadPoint` Hook中获取了我们的事件处理程序：
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the following code, there''s a tiny bit of logic that decides whether we
    will update the point of a `Thread` or `ThreadItem`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，有一小部分逻辑决定了我们是否会更新`Thread`或`ThreadItem`的点：
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We have the same point selection logic here as well:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里也有相同的点选择逻辑：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, if you run the `Thread` route in mobile mode, you''ll see this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在移动模式下运行`Thread`路由，你会看到这个：
- en: '![Figure 16.4 – Thread route screen on mobile with our points incrementor'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.4 - 移动端的Thread路由屏幕与我们的点增量器'
- en: '](img/Figure_16.04_B15508.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.04_B15508.jpg)'
- en: Figure 16.4 – Thread route screen on mobile with our points incrementor
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 - 移动端的Thread路由屏幕与我们的点增量器
- en: Note that I've made some styling updates to the `ThreadCategory` component so
    that it can be viewed on the Home route in mobile mode as well.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已对`ThreadCategory`组件进行了一些样式更新，以便在移动模式下在主页路由上查看它。
- en: 'Now, we can view existing Threads on our screen. However, we also need to be
    able to add new Threads, as well as ThreadItems. Let''s add those features now:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在屏幕上查看现有的Threads。但是，我们还需要能够添加新的Threads和ThreadItems。现在让我们添加这些功能：
- en: 'First, we need to make a small change to our `createThread` Repository call.
    Open the `ThreadRepo` file and update the last `return` statement for `createThread`,
    which looks as follows:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要对我们的`createThread` Repository调用进行一些小的更改。打开`ThreadRepo`文件，并更新`createThread`的最后一个`return`语句，如下所示：
- en: '[PRE75]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Change it so that it looks like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为如下所示：
- en: '[PRE76]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, if our `createThread` is successful, it will only return the ID. This minimizes
    payload sizes but gives our client what it needs to know.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的`createThread`成功，它将只返回ID。这样可以最小化有效载荷大小，但可以给客户端提供所需的信息。
- en: 'Next, we must make another small change to our `Thread` route. Open `App.tsx`
    and find the route for `Thread`. Update that route like this:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须对我们的`Thread`路由进行另一个小的更改。打开`App.tsx`，找到`Thread`的路由。将该路由更新如下：
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, we will add a `useHistory` so that we can modify the URL we are on:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个`useHistory`，以便我们可以修改我们所在的URL：
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, we have a new handler for the `Post` button click, which redirects the
    user to the thread screen without any `id`. I''ll show you why that''s important
    in a bit:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个新的处理程序用于`Post`按钮点击，它会将用户重定向到没有`id`的线程屏幕。我会稍后告诉你为什么这很重要：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here, we have our `button` declaration with that handler:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个带有处理程序的`button`声明：
- en: '[PRE80]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The rest of the code is the same as it was previously.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码与以前一样。
- en: 'Now, we need to update our `Thread.tsx` component so that when it sees we have
    no `id`, it knows to set itself up so that it can add a new Thread. However, in
    order to do this, we need to update some of its child components. Let''s start
    with `RichEditor`. Update this component as follows. I''ll only show the code
    that''s been changed here:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们的`Thread.tsx`组件，以便当它看到我们没有`id`时，它知道要设置自身，以便它可以添加一个新的Thread。但是，为了做到这一点，我们需要更新一些它的子组件。让我们从`RichEditor`开始。更新此组件如下。我只会在这里展示已更改的代码：
- en: '[PRE81]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`getTextFromNodes` is a new helper that will allow the Slate.js format of our
    Node array to be translated into a string:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTextFromNodes`是一个新的辅助函数，它将允许我们的Node数组的Slate.js格式被转换为字符串：'
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`InitialValue` is now an empty string:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitialValue`现在是一个空字符串：'
- en: '[PRE83]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We''ve added this additional prop so that when our editor has its text updated,
    that change will go up the component hierarchy to our `Thread.tsx` component.
    `Thread.tsx` needs to know the latest value so that it can send it as a parameter
    when it tries to create a new Thread. We''ll be repeating this *sendOut* pattern
    in these child components:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了这个额外的prop，这样当我们的编辑器的文本更新时，这个变化将向上组件层次结构传递到我们的`Thread.tsx`组件。`Thread.tsx`需要知道最新的值，以便在尝试创建新的Thread时将其作为参数发送。我们将在这些子组件中重复这种*sendOut*模式：
- en: '[PRE84]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `existingBody` prop is the initial value being sent in from the parent component.
    This value will come in when the `Thread.tsx` route screen is loaded from an existing
    Thread. This Thread is, of course, being loaded from our database, which means
    that the text data will be saved into our database as a string. This is because
    Postgres does not understand Slate.js' `Node` types. The side effect of this is
    that before `setValue` can receive this data, it must first be parsed in JSON
    format, which is why you can see `setValue(JSON.parse(existingBody))`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`existingBody`属性是从父组件发送过来的初始值。当从现有Thread加载`Thread.tsx`路由屏幕时，这个值将进来。这个Thread当然是从我们的数据库加载的，这意味着文本数据将被保存到我们的数据库中作为一个字符串。这是因为Postgres不理解Slate.js的`Node`类型。这样做的副作用是，在`setValue`可以接收这些数据之前，它必须首先以JSON格式进行解析，这就是为什么你可以看到`setValue(JSON.parse(existingBody))`。'
- en: '[PRE85]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we've set our `val` from the editor, but also sent it back to the parent
    component using `sendOutBody`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从编辑器中设置了我们的`val`，但也使用`sendOutBody`将其发送回父组件。
- en: '[PRE86]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The following is a trivial `placeholder` change.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个微不足道的`placeholder`更改。
- en: '[PRE87]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, we need to update `ThreadCategory` component. I''ll only show the code
    that has been changed here:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`ThreadCategory`组件。我只会在这里展示已更改的代码：
- en: '[PRE88]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here, we have the `sendOutSelectedCategory` function, which allows us to send
    back a category selection using the `sendOut` method:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`sendOutSelectedCategory`函数，它允许我们使用`sendOut`方法发送回类别选择：
- en: '[PRE89]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Next, we''ll update our `ThreadTitle` component, like this:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更新我们的`ThreadTitle`组件，就像这样：
- en: '[PRE90]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, we want to make our title read-only when we''ve loaded an existing Thread:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们加载现有的主题时，我们希望使我们的标题只读：
- en: '[PRE91]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Once again, here, we have the `sendOut` pattern using `sendOutTitle`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在这里，我们使用`sendOutTitle`使用`sendOut`模式：
- en: '[PRE92]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, we''ve set our title and also sent it out to our component''s parent:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经设置了我们的标题，并将其发送到我们组件的父级：
- en: '[PRE93]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here, we are using our new props:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了我们的新props：
- en: '[PRE94]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, let''s update `ThreadBody`, like this:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新`ThreadBody`，就像这样：
- en: '[PRE95]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Again, we need the `sendOut` pattern for the `sendOutBody` function:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要`sendOut`模式用于`sendOutBody`函数：
- en: '[PRE96]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we must send the `sendOutBody` function to our `RichEditor` since that
    control handles body updates:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将`sendOutBody`函数发送到我们的`RichEditor`，因为该控件处理正文更新：
- en: '[PRE97]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Finally, we have the `Thread.tsx` file. We must make a number of changes here.
    Let's look at all of them.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`Thread.tsx`文件。我们必须在这里做一些更改。让我们一起看看。
- en: 'You should be able to add the appropriate imports yourself; for example, here,
    we need the `getTextFromNodes` helper:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够自己添加适当的导入；例如，在这里，我们需要`getTextFromNodes`助手：
- en: '[PRE98]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Here, is our new `CreateThread` mutation:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的新`CreateThread` mutation：
- en: '[PRE99]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'A new reducer also needs to be added; that is, `threadReducer`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要添加一个新的reducer；即`threadReducer`：
- en: '[PRE100]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here''s our `user` object, which only appears if the user is logged in. We
    will only use this object when we''re creating a new Thread:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`user`对象，只有在用户登录时才会出现。我们只会在创建新主题时使用这个对象：
- en: '[PRE101]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here''s our reducer. These fields will be used to submit new Threads during
    creation mode:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的reducer。这些字段将用于在创建模式下提交新主题：
- en: '[PRE102]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The following code shows the status of our Thread creation attempt:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们尝试创建主题的状态：
- en: '[PRE103]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here''s our actual `CreateThread` Mutation caller, `execCreateThread`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们实际的`CreateThread` Mutation调用者，`execCreateThread`：
- en: '[PRE104]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We''ll be using `useHistory()` to switch to the newly created Thread''s route.
    For example, if the new Thread `id` is 25, then the route will be `"/thread/25"`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`useHistory()`来切换到新创建的主题路由。例如，如果新主题的`id`是25，那么路由将是`"/thread/25"`：
- en: '[PRE105]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Here, we are updating the reducer''s `userId`, in case the user has logged
    in:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在更新reducer的`userId`，以防用户已登录：
- en: '[PRE106]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Here, we have started adding the definitions for our handler functions in the
    `sendOut` pattern, which we''ve been using in our child components. In this case,
    `receiveSelectedCategory` receives the newly set `ThreadCategory` from the `CategoryDropDown`
    control:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经开始为我们在子组件中使用的`sendOut`模式添加处理程序函数的定义。在这种情况下，`receiveSelectedCategory`从`CategoryDropDown`控件接收新设置的`ThreadCategory`：
- en: '[PRE107]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `receiveTitle` and `receiveBody` functions also handle updates that are
    made to `title` and `body` from their respective child components:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiveTitle`和`receiveBody`函数还处理从它们各自的子组件进行的`title`和`body`更新：'
- en: '[PRE108]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `onClickPost` function handles the `id`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClickPost`函数处理`id`：'
- en: '[PRE109]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If the attempt fails, we show the user a server error:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试失败，我们会向用户显示服务器错误：
- en: '[PRE110]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If the screen is being shown on a mobile device and the thread exists, we show
    this control; otherwise, we don''t:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果屏幕显示在移动设备上并且主题存在，我们会显示此控件；否则，我们不会：
- en: '[PRE111]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The rest of these child components contain the same logic. If the `thread`
    object exists, we display a thread. If not, then we go into Thread Post mode:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 其他子组件中包含相同的逻辑。如果`thread`对象存在，我们显示一个主题。如果没有，那么我们进入主题发布模式：
- en: '[PRE112]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Here is our Thread **Post** button and status message. Again, if our thread
    object exists, we do not show these, whereas if the thread does, we show them.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的主题**发布**按钮和状态消息。同样，如果我们的主题对象存在，我们不显示这些，而如果主题存在，我们就显示它们。
- en: The rest of code is identical to what we had previously, so I won't show it
    here.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 其余代码与之前完全相同，所以我不会在这里展示它。
- en: Now, if we run the Thread route with no `id`, we get the following screen:![Figure
    16.6 – New Thread screen
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们在没有`id`的情况下运行主题路由，我们会得到以下屏幕：![图16.6 - 新主题屏幕
- en: '](img/Figure_16.06_B15508.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.06_B15508.jpg)'
- en: Figure 16.6 – New Thread screen
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 - 新主题屏幕
- en: Warning
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Since we are now saving Slate.js Nodes as JSON strings inside the `Body` field
    of our `Thread` table, before you can test the code, you must purge any existing
    `Thread` and `ThreadItem` data before you can display it again.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在将Slate.js Nodes保存为JSON字符串，存储在我们的`Thread`表的`Body`字段中，因此在测试代码之前，您必须清除任何现有的`Thread`和`ThreadItem`数据，然后才能再次显示它。
- en: 'There is an issue here. Since we now have JSON strings in the `Body` field
    of our database, when this data comes back, it will look like this on the Home
    screen:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题。由于我们现在在数据库的`Body`字段中有JSON字符串，当这些数据返回时，它将在主屏幕上看起来像这样：
- en: '![Figure 16.7 – Home screen'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7 - 主屏幕'
- en: '](img/Figure_16.07_B15508.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.07_B15508.jpg)'
- en: Figure 16.7 – Home screen
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 - 主屏幕
- en: Obviously, this is not what we want. Here, we need to update this text so that
    it's a normal string. Luckily, we can just use our existing `RichEditor` to display
    the text and keep all the formatting intact.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是我们想要的。在这里，我们需要更新这个文本，使其成为普通字符串。幸运的是，我们可以使用现有的`RichEditor`来显示文本并保持所有格式不变。
- en: 'Update the `RichEditor` component by putting a `readOnly` check on the `Toolbar`,
    like this:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`Toolbar`上放置一个`readOnly`检查来更新`RichEditor`组件，就像这样：
- en: '[PRE113]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Update the `ThreadCard` component by replacing the `<div>{thread.body}</div>`
    line in the JSX with the following:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用以下内容替换JSX中的`<div>{thread.body}</div>`行来更新`ThreadCard`组件：
- en: '[PRE114]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Again, make sure your import of `RichEditor` is also there.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，确保您的`RichEditor`的导入也在那里。
- en: 'You should now see something like this on the Home screen. Your own data will
    vary from what''s being shown here:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主屏幕上应该看到类似于这样的东西。您自己的数据将与此处显示的数据不同：
- en: '![Figure 16.8 – Home screen with body'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8 - 带有正文的主屏幕'
- en: '](img/Figure_16.08_B15508.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.08_B15508.jpg)'
- en: Figure 16.8 – Home screen with body
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 - 带有正文的主屏幕
- en: 'Note that this will also cause `RichEditor` on our Thread route screen to hide
    the Toolbar in `readOnly` mode. Now, we just need to allow new `ThreadItem` responses
    to be made and we''re done with this section. We will repurpose the `ThreadResponse`
    component so that it also allows ThreadItems to be submitted, instead of just
    being displayed:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这也会导致我们的Thread路由屏幕上的`RichEditor`在`readOnly`模式下隐藏工具栏。现在，我们只需要允许提交新的`ThreadItem`响应，然后我们就完成了这一部分。我们将重新设计`ThreadResponse`组件，以便它也允许提交ThreadItems，而不仅仅是显示：
- en: 'First, we need to make some minor adjustments to the server side. Open `ThreadItemRepo`
    and find `createThreadItem`. In the last `return` statement, update it, as follows:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要对服务器端进行一些微小的调整。打开`ThreadItemRepo`，找到`createThreadItem`。在最后的`return`语句中，更新如下：
- en: '[PRE115]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Just like what we did with our `createThread` function, we are returning the
    ThreadItem's `id`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`createThread`函数中所做的那样，我们返回ThreadItem的`id`。
- en: 'Now, inside `ThreadRepo`, update the call to `findOne`, like this:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`ThreadRepo`中，更新对`findOne`的调用，就像这样：
- en: '[PRE116]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now, we need to refactor the `ThreadItem.ts` model in our client-side code
    so that it takes a `thread` object instead of a `threadId`:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要重构我们客户端代码中的`ThreadItem.ts`模型，以便它接受一个`thread`对象而不是一个`threadId`：
- en: '[PRE117]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: By doing this, we receive the `Thread` object from the query we just updated.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们从刚刚更新的查询中接收了`Thread`对象。
- en: Now, update `ThreadResponse`, as shown in the source code. Make sure you have
    all your imports.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据源代码中所示，更新`ThreadResponse`。确保您有所有的导入。
- en: First, you'll see we have our new `CreateThreadItem` Mutation.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您会看到我们的新的`CreateThreadItem` Mutation。
- en: In the `ThreadResponseProps` interface, we can see that the `body` prop is the
    initial value of `RichEditor` before any changes are made. We'll also need to
    receive the parent `threadId` if we are going to submit a new `ThreadItem`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ThreadResponseProps`接口中，我们可以看到`body`属性是在进行任何更改之前`RichEditor`的初始值。如果我们要提交新的`ThreadItem`，我们还需要接收父`threadId`。
- en: After that, we need to get the `user` object from `useSelector`. We're doing
    this because the current user will be submitting new ThreadItems.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要从`useSelector`中获取`user`对象。我们这样做是因为当前用户将提交新的ThreadItems。
- en: Next, we have `execCreateThreadItem`, which is our Mutation executor for `CreateThreadItem`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`execCreateThreadItem`，这是我们的`CreateThreadItem`的Mutation执行器。
- en: Then, we have our status message, `postMsg`, for when the user attempts to save.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有我们的状态消息`postMsg`，当用户尝试保存时会显示。
- en: Then, we have the current editing body value, `bodyToSave`, inside `RichEditor`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`RichEditor`中有当前编辑的body值`bodyToSave`。
- en: Next, `useEffect` is used to initialize our `bodyToSave` value from the passed-in
    prop `body` so that we have an initial value to start with.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`useEffect`用于从传入的prop `body`初始化我们的`bodyToSave`值，以便我们有一个初始值可以开始。
- en: The `onClickPost` function allows us to do some validation checks before we
    attempt to submit our new `ThreadItem`. Once we've done this, we can submit and
    refresh our parent Thread.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClickPost`函数允许我们在尝试提交新的`ThreadItem`之前进行一些验证检查。一旦我们完成了这个，我们就可以提交并刷新我们的父Thread。'
- en: In the `receiveBody` function, we receive our updated text from our `RichEditor`
    component. We use this if we are submitting a new `ThreadItem`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在`receiveBody`函数中，我们从`RichEditor`组件中接收到我们更新的文本。如果我们要提交新的`ThreadItem`，我们会使用这个。
- en: In the returned JSX, we decide not to show `ThreadPointsInline` if we are not
    in `readOnly` mode. However, if we are in edit mode, we allow the Post button
    and the status message to be shown.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的JSX中，我们决定如果不是在`readOnly`模式下，就不显示`ThreadPointsInline`。但是，如果我们处于编辑模式，我们允许显示发布按钮和状态消息。
- en: 'Now, if we create a few `ThreadItem` posts, we should see something like this:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们创建了一些`ThreadItem`帖子，我们应该会看到类似这样的东西：
- en: '![Figure 16.9 – Submitted ThreadItem responses'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.9 - 提交的ThreadItem响应'
- en: '](img/Figure_16.09_B15508.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.09_B15508.jpg)'
- en: Figure 16.9 – Submitted ThreadItem responses
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 - 提交的ThreadItem响应
- en: That's it for the Thread route screen.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Thread路由屏幕的全部内容。
- en: We're almost there and you've done a phenomenal job thus far. We've covered
    so much material and code to get to this stage. You should feel wonderful about
    your progress. We have one more section to complete and then we're done with our
    app!
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了，到目前为止你做得非常出色。我们已经涵盖了很多材料和代码，以达到这个阶段。你应该为自己的进步感到很棒。我们还有一个部分要完成，然后我们就完成了我们的应用程序！
- en: 'The last item we need to configure is `RightMenu`. In this menu, we will list
    up to three of the top ThreadCategories, based on the number of Threads each `ThreadCategory`
    has attributed to it. This will involve a longer multi-part query and is a good
    exercise:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置的最后一项是`RightMenu`。在这个菜单中，我们将列出最多三个顶级ThreadCategories，根据每个`ThreadCategory`所归属的Threads的数量。这将涉及一个更长的多部分查询，是一个很好的练习：
- en: 'First, we need to add a new type called `CategoryThread` to the `typeDefs`
    file, like this:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`typeDefs`文件中添加一个名为`CategoryThread`的新类型，就像这样：
- en: '[PRE118]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note that `titleCreatedOn` is only there for checking the sort. We won't use
    it in our client-side code.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`titleCreatedOn`只是用于检查排序。我们不会在客户端代码中使用它。
- en: 'Now, add a new model to our repository folder called `CategoryThread.ts` and
    add the following code. Note that this class will not be an Entity in our database.
    Instead, it will be an aggregation class that will contain fields from multiple
    entities:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的存储库文件夹中添加一个名为`CategoryThread.ts`的新模型，并添加以下代码。请注意，这个类不会成为我们数据库中的实体。相反，它将是一个聚合类，将包含来自多个实体的字段：
- en: '[PRE119]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Now, get the code from the source and create the `CategoryThreadRepo.ts` file
    with that code.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从源代码中获取代码，并创建`CategoryThreadRepo.ts`文件。
- en: From the top, first, we have made our initial query to get `ThreadCategory`
    data from our database using `ThreadCategory.createQueryBuilder("threadCategory")`.
    Notice that we have also included our relationship to the Threads table.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始，首先，我们通过使用`ThreadCategory.createQueryBuilder("threadCategory")`从数据库中获取`ThreadCategory`数据进行了初始查询。请注意，我们还包括了与Threads表的关系。
- en: Now, we are about to post-process our query to get the results we want. We are
    not doing this work in our TypeORM query because, for more complex sorting and
    filtering, TypeORM is sometimes difficult and finicky to work with. Using standard
    JavaScript will get us what we need more easily.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对查询进行后处理，以获得我们想要的结果。我们没有在TypeORM查询中进行此工作，因为对于更复杂的排序和过滤，TypeORM有时很难处理。使用标准的JavaScript将更容易地得到我们需要的内容。
- en: In the call to `categories.sort`, on line 14, we are doing a descending sort
    based on the number of Thread records each `ThreadCategory` contains. Then, we
    take only the first three records of the result.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在第14行调用`categories.sort`时，我们根据每个`ThreadCategory`包含的Thread记录数量进行降序排序。然后，我们只取结果的前三条记录。
- en: Then, we take this result and sort the actual Thread records by their `createdOn`
    timestamp in descending order.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将获取的结果按照`createdOn`时间戳的降序对实际的Thread记录进行排序。
- en: By doing this, we get, at most, three Thread records for each category, ordered
    by their `createdOn` timestamps.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们最多会得到每个类别的三条Thread记录，按照它们的`createdOn`时间戳排序。
- en: Now, let's test this using GraphQL Playground:![Figure 16.10 – GetTopCategoryThread
    sort result
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用GraphQL Playground进行测试：![图16.10 – 获取热门分类主题排序结果
- en: '](img/Figure_16.10_B15508.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.10_B15508.jpg)'
- en: Figure 16.10 – GetTopCategoryThread sort result
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – 获取热门分类主题排序结果
- en: As you can see, the sorts and filters are working.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，排序和过滤都在起作用。
- en: Now, let's finish our client-side code. Open `CategoryThread.ts` and update
    `category` so that it's now `categoryName`. This will match our server-side model
    name for this field.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们完成客户端代码。打开`CategoryThread.ts`并更新`category`，使其成为`categoryName`。这将与我们服务器端模型中此字段的名称匹配。
- en: 'Open `TopCategory.tsx` and update the line shown in the return JSX:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TopCategory.tsx`并更新返回的JSX中显示的行：
- en: '[PRE120]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Change `category` so that it's now `categoryName`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 将`category`更改为`categoryName`。
- en: 'Now, open `RightMenu.tsx` and update it from the source code:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`RightMenu.tsx`并从源代码进行更新：
- en: After making the necessary imports, we need to define our GraphQL query, `GetTopCategoryThread`,
    and then use that query on line 20 by calling `useQuery` on it. Here, we're using
    that query.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行必要的导入后，我们需要定义我们的GraphQL查询`GetTopCategoryThread`，然后在第20行调用`useQuery`来使用该查询。在这里，我们正在使用该查询。
- en: Then, on line 26, `useEffect` has been updated to make use of the resulting
    `categoryThreadData`. The `groupBy` method from `lodash` is grouping our data
    by `categoryName` so that it's easier to work with. The original code for this
    was covered in [*Chapter 11*](B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167)*,
    What We Will Learn – Online Forum Application*.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第26行，`useEffect`已更新以使用结果的`categoryThreadData`。`lodash`中的`groupBy`方法正在将我们的数据按`categoryName`分组，以便更容易处理。这个操作的原始代码在[*第11章*](B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167)*中有所涉及，我们将学到的内容
    – 在线论坛应用程序*。
- en: Finally, we need to check for mobile width, which returns either `null` or our
    UI.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要检查移动宽度，它会返回`null`或我们的UI。
- en: 'Now, if we run our Home screen, we should see our `RightMenu` populated with
    data:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的主屏幕，我们应该会看到我们的`RightMenu`中填充了数据：
- en: '![Figure 16.11 – Home screen with popular categories shown'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.11 – 主屏幕显示热门分类'
- en: '](img/Figure_16.11_B15508.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.11_B15508.jpg)'
- en: Figure 16.11 – Home screen with popular categories shown
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 – 主屏幕显示热门分类
- en: Again, your local data will vary.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你的本地数据会有所不同。
- en: With that, we're done! There was a lot of code, and many frameworks and concepts.
    You've done an amazing job getting through it all. Take a much-deserved break.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们完成了！有很多代码，还有许多框架和概念。你已经做得非常出色。好好休息一下吧。
- en: In this section, we covered the client-side code of our app and how to glue
    it to our backend GraphQL server. We had to tweak our styling and make adjustments
    by refactoring our code. We also had to fix hard-to-find bugs. This is exactly
    what we'll be doing in real life, so this was great practice.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了应用程序的客户端代码以及如何将其与后端GraphQL服务器连接起来。我们不得不调整样式并通过重构代码进行调整。我们还必须修复难以找到的错误。这正是我们在现实生活中要做的事情，所以这是很好的练习。
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final coding chapter, we brought everything together by finishing our
    code and integrating the frontend React app with the backend GraphQL server. We've
    learned an enormous amount in this chapter and this book as a whole. You should
    feel proud of how far you've come.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后的编码章节中，我们通过完成代码并将前端React应用程序与后端GraphQL服务器集成，将所有内容整合在一起。在本章和整本书中，我们学到了大量知识。你应该为自己取得的进步感到自豪。
- en: My suggestion would be, before you move on to the final chapter, to try and
    make changes to the app. Come up with your own ideas for features and try building
    them. Ultimately, this is the only way you will really learn.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议，在进入最后一章之前，尝试对应用程序进行更改。想出自己的功能想法并尝试构建它们。最终，这是你真正学习的唯一方式。
- en: In the final chapter of this book, [*Chapter 17*](B15508_17_Final_JC_ePub.xhtml#_idTextAnchor259)*,
    Deploying an Application to AWS*, we will learn how to deploy our application
    to Linux and NGINX on the Azure cloud.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章[*第17章*](B15508_17_Final_JC_ePub.xhtml#_idTextAnchor259)*，将学习如何将应用程序部署到AWS*，我们将学习如何将我们的应用程序部署到Azure云上的Linux和NGINX。
