- en: Creating a Map
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建地图
- en: 'It''s been quite a ride so far. We''ve gone through all the different aspects
    that encompass the creation of a map. We''ve touched on the basics of SVG, JavaScript,
    and D3\. Now, it''s time to put all the pieces together and actually have a final
    deliverable product. In this chapter, we will cover the following topics through
    a series of experiments:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经经历了一段相当精彩的旅程。我们探讨了创建地图的所有不同方面。我们接触了SVG、JavaScript和D3的基础知识。现在，是时候将所有这些部件组合起来，并真正拥有一个最终交付的产品了。在本章中，我们将通过一系列实验来涵盖以下主题：
- en: Foundation - creating your basic map
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础 - 创建您的基本地图
- en: Experiment 1 - adjusting the bounding box
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 1 - 调整边界框
- en: Experiment 2 - creating choropleths
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 2 - 创建渐变图
- en: Experiment 3 - adding click events to our visualization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 3 - 向我们的可视化添加点击事件
- en: Experiment 4 - using updates and transitions to enhance our visualization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 4 - 使用更新和过渡来增强我们的可视化
- en: Experiment 5 - adding points of interest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 5 - 添加兴趣点
- en: Experiment 6 - adding visualizations as a point of interest
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验 6 - 将可视化作为兴趣点添加
- en: Foundation - creating your basic map
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础 - 创建您的基本地图
- en: In this section, we will walk through the basics of creating a standard map.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍创建标准地图的基础知识。
- en: The example can be viewed by opening the `example-1.html` file of this chapter
    provided with this book. If you already have the HTTP server running, you can
    point your browser to `http://localhost:8080/chapter-4/example-1.html`. On the
    screen is Mexico (Oscar's beloved country)!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开本书提供的本章节的`example-1.html`文件来查看示例。如果您已经启动了HTTP服务器，您可以将浏览器指向`http://localhost:8080/chapter-4/example-1.html`。屏幕上显示的是墨西哥（奥斯卡钟爱的国家）！
- en: '![](img/ea3f5f64-7d25-4a43-9eac-c4d892d1740b.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea3f5f64-7d25-4a43-9eac-c4d892d1740b.png)'
- en: Let's walk through the code to get a step-by-step explanation of how to create
    this map.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析代码，以了解如何创建此地图。
- en: 'The `width` and `height` can be anything you want. Depending on where your
    map will be visualized (cellphones, tablets, or desktops), you might want to consider
    providing a different `width` and `height`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`和`height`可以是您想要的任何值。根据您的地图将在哪里可视化（手机、平板电脑或桌面），您可能需要考虑提供不同的`width`和`height`：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next variable defines a projection algorithm that allows you to go from
    a cartographic space (latitude and longitude) to a Cartesian space (*x, y*)—basically
    a mapping of latitude and longitude to coordinates. You can think of a projection
    as a way to map the three-dimensional globe to a flat plane. There are many kinds
    of projections, but `geoMercator()` is normally the default value you will use:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变量定义了一个投影算法，它允许您从地图空间（纬度和经度）到笛卡尔空间（*x, y*）进行转换——基本上是将纬度和经度映射到坐标。您可以将投影视为将三维地球映射到平面的一种方式。有许多种类的投影，但`geoMercator()`通常是您将使用的默认值：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you were making a map of the USA, you could use a better projection called
    AlbersUsa. This is to better position Alaska and Hawaii. By creating a `geoMercator()`
    projection, Alaska would render proportionate to its size, rivaling that of the
    entire US. The `geoAlbersUsa()` projection grabs Alaska, makes it smaller, and
    puts it at the bottom of the visualization. The following screenshot is of `geoMercator()`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在制作美国的地图，您可以使用一个更好的投影，称为AlbersUsa。这是为了更好地定位阿拉斯加和夏威夷。通过创建`geoMercator()`投影，阿拉斯加将按其大小渲染，与美国全境相媲美。`geoAlbersUsa()`投影抓取阿拉斯加，使其变小，并将其放置在可视化的底部。以下截图是`geoMercator()`：
- en: '![](img/cad1c5b8-d456-4c31-a56a-c14577435bc7.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cad1c5b8-d456-4c31-a56a-c14577435bc7.png)'
- en: 'This next screenshot is of `geoAlbersUsa()`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图是`geoAlbersUsa()`：
- en: '![](img/5d55e359-bcb2-4460-b97c-f2562494bb42.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d55e359-bcb2-4460-b97c-f2562494bb42.png)'
- en: The D3 library currently contains many built-in projection algorithms. An overview
    of each one can be viewed at [https://github.com/d3/d3-geo/blob/master/README.md#projections](https://github.com/d3/d3-geo/blob/master/README.md#projections).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: D3库目前包含许多内置的投影算法。每个算法的概述可以在[https://github.com/d3/d3-geo/blob/master/README.md#projections](https://github.com/d3/d3-geo/blob/master/README.md#projections)查看。
- en: 'Next, we will assign the projection to our `geoPath()` function. This is a
    special D3 function that will map the JSON-formatted geographic data into SVG
    paths. The data format that the `geoPath()` function requires is named GeoJSON
    and will be covered in [Chapter 6](80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml),
    *Finding and Working with Geographic Data*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将投影分配给我们的`geoPath()`函数。这是一个特殊的D3函数，它将JSON格式的地理数据映射到SVG路径。`geoPath()`函数所需的数据格式称为GeoJSON，将在[第6章](80f84fe0-7828-4ecc-9973-3e2bdef7ab55.xhtml)中介绍，*寻找和使用地理数据*：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Including the dataset
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包括数据集
- en: 'The necessary data has been provided for you within the `data` folder, with
    the filename `geo-data.json`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所需数据已提供给您，位于`data`文件夹中，文件名为`geo-data.json`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We get the data from an AJAX call, as we saw in the previous chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从AJAX调用中获取数据，正如我们在上一章中看到的。
- en: After the data has been collected, we want to draw only those parts of the data
    that we are interested in. In addition, we want to automatically scale the map
    to fit the defined height and width of our visualization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据收集完毕后，我们只想绘制我们感兴趣的数据部分。此外，我们还想自动调整地图的比例，以适应我们可视化定义的高度和宽度。
- en: 'If you look at the console, you''ll see that `mexico` has an `objects` property.
    Nested inside the `objects` property is `MEX_adm1`. This stands for the administrative
    areas of Mexico. It is important to understand the geographic data you are using,
    because other data sources might have different names for the administrative areas
    property:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看控制台，你会看到`mexico`有一个`objects`属性。嵌套在`objects`属性内部的是`MEX_adm1`。这代表墨西哥的行政区域。理解你正在使用的地理数据非常重要，因为其他数据源可能对行政区域属性的命名不同：
- en: '![](img/511285b8-5b6a-4f9b-b242-6d08df5913d5.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/511285b8-5b6a-4f9b-b242-6d08df5913d5.png)'
- en: 'Notice that the `MEX_adm1` property contains a `geometries` array with 32 elements.
    Each of these elements represents a state in Mexico. Use this data to draw the
    D3 visualization:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`MEX_adm1`属性包含一个包含32个元素的`geometries`数组。这些元素中的每一个代表墨西哥的一个州。使用这些数据来绘制D3可视化：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we pass all of the administrative areas to the `topojson.feature()` function
    in order to extract and create an array of GeoJSON objects. The preceding `states`
    variable now contains the `features` property. This `features` array is a list
    of 32 GeoJSON elements, each representing the geographic boundaries of a state
    in Mexico. We will set an initial scale and translation to `1` and `[0,0]` respectively:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将所有行政区域传递给`topojson.feature()`函数，以便提取并创建一个GeoJSON对象数组。前面的`states`变量现在包含`features`属性。这个`features`数组是一个包含32个GeoJSON元素的列表，每个元素代表墨西哥一个州的地理边界。我们将初始比例和转换设置为`1`和`[0,0]`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This algorithm is quite useful. The bounding box is a spherical box that returns
    a two-dimensional array of min/max coordinates, inclusive of the geographic data
    passed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法非常有用。边界框是一个球形框，返回包含地理数据的最小/最大坐标的二维数组：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To quote the D3 documentation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 引用D3文档：
- en: '"The bounding box is represented by a two-dimensional array: [[left, bottom],
    [right, top]], where left is the minimum longitude, bottom is the minimum latitude,
    right is maximum longitude, and top is the maximum latitude."'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '"边界框由一个二维数组表示：[[左，下]，[右，上]]，其中左是最小经度，下是最小纬度，右是最大经度，上是最大纬度。"'
- en: This is very helpful if you want to programmatically set the scale and translation
    of the map. In this case, we want the entire country to fit in our `height` and
    `width`, so we determine the bounding box of every state in the country of Mexico.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以编程方式设置地图的比例和转换，这将非常有用。在这种情况下，我们希望整个国家都能适应我们的`height`和`width`，因此我们确定墨西哥国家中每个州的边界框。
- en: 'The scale is calculated by taking the longest geographic edge of our bounding
    box and dividing it by the number of pixels of this edge in the visualization:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 比例尺是通过将我们边界框的最长地理边长除以该边在可视化中的像素数来计算的：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This can be calculated by first computing the scale of the `width`, then the
    scale of the `height`, and, finally, taking the larger of the two. All of the
    logic is compressed into the single line given earlier. The three steps are explained
    in the following image:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过首先计算`width`的比例，然后计算`height`的比例，最后取两个中的较大值来计算。所有逻辑都压缩在前面给出的单行中。这三个步骤在下图中解释：
- en: '![](img/3ad83fa4-dff7-4993-a1ed-f0ff938b4805.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ad83fa4-dff7-4993-a1ed-f0ff938b4805.png)'
- en: The `95` value adjusts the scale because we are giving the map a bit of a breather
    at the edges in order to not have the paths intersect the edges of the SVG container
    item, basically reducing the scale by 5%.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`95` 这个值调整了比例，因为我们给地图边缘留出了一些空间，以便路径不会与 SVG 容器元素的边缘相交，基本上减少了 5% 的比例。'
- en: 'Now, we have an accurate scale of our map, given our set `width` and `height`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了地图的准确比例，这是基于我们设置的 `width` 和 `height`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we saw in [Chapter 2](029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml), *Creating
    Images from Simple Text*, when we scale in SVG, it scales all the attributes (even
    *x* and *y*). In order to return the map to the center of the screen, we will
    use the `translate()` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 2 章](029e4691-c89a-4f5d-a5b9-d8fad2f16df9.xhtml) 中看到的，*从简单的文本创建图像*，当我们对
    SVG 进行缩放时，它会缩放所有属性（甚至 *x* 和 *y*）。为了将地图返回到屏幕中心，我们将使用 `translate()` 函数。
- en: 'The `translate()` function receives an array with two parameters: the amount
    to translate in *x*, and the amount to translate in *y*. We will calculate *x*
    by finding the center *(topRight - topLeft)/2* and multiplying it by the scale.
    The result is then subtracted from the width of the SVG element.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`translate()` 函数接收一个包含两个参数的数组：沿 *x* 方向平移的量，以及沿 *y* 方向平移的量。我们将通过找到中心 *(topRight
    - topLeft)/2* 并乘以比例来计算 *x*。然后从 SVG 元素的宽度中减去这个结果。'
- en: Our *y* translation is calculated similarly but using the *bottomRight - bottomLeft*
    values divided by 2, multiplied by the scale, then subtracted from the `height`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 *y* 平移计算方式类似，但使用 *bottomRight - bottomLeft* 的值除以 2，乘以比例，然后从 `height` 中减去。
- en: 'Finally, we will reset the projection to use our new scale and translation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将重置投影以使用我们新的比例和平移：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we will create a map variable that will group all of the following SVG
    elements into a `<g>` SVG tag. This will allow us to apply styles and better contain
    all of the proceeding paths'' elements:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个地图变量，它将把所有下面的 SVG 元素组合到一个 `<g>` SVG 标签中。这将允许我们应用样式并更好地包含所有前面的路径元素：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we are back to the classic D3 enter, update, and exit pattern. We
    have our data, the list of Mexico states, and we will join this data to the `path`
    SVG element:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回到了经典的 D3 enter、update 和 exit 模式。我们有我们的数据，墨西哥各州的列表，我们将把这个数据连接到 `path` SVG
    元素上：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Enter` section and the corresponding `path` functions are executed on every
    data element in the array. As a refresher, each element in the array represents
    a state in Mexico. The `path` function has been set up to correctly draw the outline
    of each state, as well as scale and translate it to fit in our SVG container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enter` 部分和相应的 `path` 函数在数组中的每个数据元素上执行。作为一个提醒，数组中的每个元素代表墨西哥的一个州。`path` 函数已经被设置好，以正确绘制每个州的轮廓，并将其缩放和平移以适应我们的
    SVG 容器。'
- en: Congratulations! You have created your first map!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经创建了你的第一张地图！
- en: Experiment 1 – adjusting the bounding box
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 1 – 调整边界框
- en: Now that we have our foundation, let's start with our first experiment. For
    this experiment, we will manually zoom into a state of Mexico using what we learned
    in the previous section. The code can be found in `example-2.html` (`http://localhost:8080/chapter-4/example-2.html`);
    however, feel free to edit `example-1.html` to learn as you go.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基础，让我们开始我们的第一个实验。对于这个实验，我们将使用上一节学到的知识手动放大到墨西哥的一个州。代码可以在 `example-2.html`
    中找到（`http://localhost:8080/chapter-4/example-2.html`）；然而，你可以自由地编辑 `example-1.html`
    来边学边做。
- en: 'For this experiment, we will modify one line of code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，我们将修改一行代码：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we are telling the calculation to create a boundary based on the sixth
    element of the `features` array instead of every state in the country of Mexico.
    The boundaries data will now run through the rest of the scaling and translation
    algorithms to adjust the map to the one shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉计算基于 `features` 数组的第六个元素创建边界，而不是墨西哥国家的每个州。边界数据现在将运行通过其余的缩放和平移算法，以调整地图到下一张截图所示：
- en: '![](img/e7f20bfe-f9a6-4c5e-895a-60d03c6088a3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7f20bfe-f9a6-4c5e-895a-60d03c6088a3.png)'
- en: 'We have basically reduced the min/max of the boundary box to include the geographic
    coordinates for one state in Mexico (see the next screenshot), and D3 has scaled
    and translated this information for us automatically:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上将边界框的最小/最大值减少，以包含墨西哥一个州的地理坐标（见下一张截图），D3 会自动缩放和平移这些信息：
- en: '![](img/c4bc88ba-d830-4e64-ba46-31ae0abb8659.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4bc88ba-d830-4e64-ba46-31ae0abb8659.png)'
- en: This can be very useful in situations where you might not have the data that
    you need in isolation from the surrounding areas. Hence, you can always zoom into
    your geography of interest and isolate it from the rest.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这在您可能无法从周围区域独立获取所需数据的情况下非常有用。因此，您始终可以放大您感兴趣的地区，并将其从其他区域中分离出来。
- en: Experiment 2 – creating choropleths
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 2 – 创建渐变图
- en: 'One of the most common uses of D3.js maps is to make choropleths. This visualization
    gives you the ability to discern between regions, giving them a different color.
    Normally, this color is associated with some other value, for instance, levels
    of influenza or a company''s sales. The Choropleths are very easy to make in D3.js.
    In this experiment, we will create a quick choropleth based on the index value
    of the state in the array of all the states. Look at the following code, or use
    your browser and go here: `http://localhost:8080/chapter-4/example-3.html`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 地图的常见用途之一是制作渐变图。这种可视化方式让您能够区分不同地区，并为它们赋予不同的颜色。通常，这种颜色与某些其他值相关联，例如流感水平或公司的销售额。在
    D3.js 中制作渐变图非常简单。在这个实验中，我们将基于所有州数组中州的索引值创建一个快速的渐变图。查看以下代码，或使用您的浏览器并访问此处：`http://localhost:8080/chapter-4/example-3.html`。
- en: 'We will only need to modify two lines of code in the `Update` section of our
    D3 code. Right after the `enter()` section, add the following two lines:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要修改 D3 代码中 `Update` 部分的两行代码。在 `enter()` 部分之后，添加以下两行：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `color` variable uses another valuable D3 function named `scale`. Scales
    are extremely powerful when creating visualizations in D3; much more detail on
    scales can be found at: [https://github.com/d3/d3/blob/master/API.md#scales-d3-scale](https://github.com/d3/d3/blob/master/API.md#scales-d3-scale).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`color` 变量使用了另一个非常有价值的 D3 函数，名为 `scale`。在 D3 中创建可视化时，缩放功能非常强大；有关缩放的更多详细信息，请参阅：[https://github.com/d3/d3/blob/master/API.md#scales-d3-scale](https://github.com/d3/d3/blob/master/API.md#scales-d3-scale)。'
- en: For now, let's describe what this scale defines. Here, we created a new function
    called `color()`. This `color()` function looks for any number between `0` and
    `33` in an input domain. D3 linearly maps these input values to a color between
    red and yellow in the output range. D3 has included the capability to automatically
    map colors in a linear range to a gradient. This means that executing the new
    function, `color`, with `0` will return the color red, `color(15)` will return
    an orange color, and `color(33)` will return yellow.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们描述一下这个缩放定义了什么。在这里，我们创建了一个名为 `color()` 的新函数。这个 `color()` 函数在一个输入域中寻找介于
    `0` 和 `33` 之间的任何数字。D3 将这些输入值线性映射到输出范围中的红色和黄色之间的颜色。D3 包含了将线性范围内的颜色自动映射到渐变的特性。这意味着执行新的
    `color` 函数，使用 `0` 将返回红色，`color(15)` 将返回橙色，而 `color(33)` 将返回黄色。
- en: 'Here is a small table just for visual reference. It shows the color and its
    respective RGB value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小表格，仅用于视觉参考。它显示了颜色及其相应的 RGB 值：
- en: '![](img/82b7470e-4f6c-4bf4-a367-af9ce75323bb.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82b7470e-4f6c-4bf4-a367-af9ce75323bb.png)'
- en: Now, in the update section, we will set the `fill` property of the path to the
    new `color()` function. This will provide a linear scale of colors and use the
    index value `i` to determine what color should be returned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在更新部分，我们将路径的 `fill` 属性设置为新的 `color()` 函数。这将提供一个颜色线性缩放，并使用索引值 `i` 来确定应该返回什么颜色。
- en: 'If the color was determined by a different value of the datum, for instance `d.scales`,
    then you would have a choropleth where the colors actually represent sales. The
    preceding code should render something as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果颜色是由数据点的不同值确定的，例如 `d.scales`，那么您将有一个颜色实际上代表销售额的渐变图。前面的代码应该渲染如下：
- en: '![](img/d651273d-477a-41be-b137-488f9d9bb65d.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d651273d-477a-41be-b137-488f9d9bb65d.png)'
- en: Experiment 3 – adding click events to our visualization
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 3 – 为我们的可视化添加点击事件
- en: 'We''ve seen how to make a map and set different colors to the different regions
    of this map. Next, we will add a little bit of interactivity. This will illustrate
    a simple reference to bind click events to maps. For this experiment, we will
    build on the previous exercise, `example-3.html`. You can see the completed experiment
    at: `http://localhost:8080/chapter-4/example-4.html`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何制作地图并为地图的不同区域设置不同的颜色。接下来，我们将添加一些交互性。这将展示如何将点击事件绑定到地图上的简单示例。对于这个实验，我们将基于之前的练习，`example-3.html`。您可以在以下位置查看完成的实验：`http://localhost:8080/chapter-4/example-4.html`。
- en: 'First, we need a quick reference to each state in the country. To accomplish
    this, we will create a new function called `geoID` right below the `mexico` variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对国家中的每个州有一个快速参考。为此，我们将在`mexico`变量下方创建一个新的函数，名为`geoID`：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function takes in a `state` data element and generates a new selectable
    ID based on the `ID_1` property found in the data. The `ID_1` property contains
    a unique numeric value for every state in the array. If we insert this as an `id`
    attribute into the DOM, then we would create a quick and easy way to select each
    state in the country.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收一个`state`数据元素，并根据数据中找到的`ID_1`属性生成一个新的可选择的ID。`ID_1`属性包含数组中每个状态唯一的数值。如果我们将其作为`id`属性插入到DOM中，那么我们将创建一个快速且简单的方法来选择国家中的每个状态。
- en: 'The following is the `geoID()` function, creating another function called `click`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`geoID()`函数创建了一个名为`click`的另一个函数：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method makes it easy to separate what the `click` is doing. The `click`
    method receives the datum and changes the fill opacity value of all the states
    to `0.2`. This is done so that when you click on one state and then on the other,
    the previous state does not maintain the *clicked* style. Notice that the function
    call is iterating through all the elements of the DOM using the D3 update pattern.
    After making all the states transparent, we will set a fill opacity of `1` for
    the given clicked item. This removes all the transparent styling from the selected
    state. Notice that we are reusing the `geoID()` function that we created earlier
    to quickly find the state element in the DOM.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法使得分离`click`所做的工作变得容易。`click`方法接收数据项并改变所有州的填充不透明度值为`0.2`。这样做是为了当你点击一个州然后点击另一个州时，之前的州不会保持`clicked`样式。注意，函数调用正在使用D3更新模式遍历DOM的所有元素。在使所有州透明后，我们将给定点击项的填充不透明度设置为`1`。这将从所选州中移除所有透明样式。注意，我们正在重用之前创建的`geoID()`函数，以快速找到DOM中的州元素。
- en: 'Next, let''s update the `enter()` method to bind our new `click` method to
    every new DOM element that `enter()` appends:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新`enter()`方法，将我们的新`click`方法绑定到`enter()`附加的每个新DOM元素：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We also added an attribute called `id`; this inserts the results of the `geoID()`
    function into the `id` attribute. Again, this makes it very easy to find the clicked
    state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个名为`id`的属性；这会将`geoID()`函数的结果插入到`id`属性中。同样，这使得找到被点击的州变得非常容易。
- en: 'The code base should produce a map as follows. Check it out and make sure that
    you click on any of the states. You will see its color turn a little brighter
    than the surrounding states:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库应该生成如下所示的地图。检查一下，并确保点击任何州。你会看到它的颜色比周围州稍微亮一些：
- en: '![](img/54243b10-e8eb-4950-b0ed-c572707fd5bc.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54243b10-e8eb-4950-b0ed-c572707fd5bc.png)'
- en: Experiment 4 – using updates and transitions to enhance our visualization
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验4 – 使用更新和过渡来增强我们的可视化
- en: For our next experiment, we will take all of our combined knowledge and add
    some smooth transitions to the map. Transitions are a fantastic way to add style
    and smoothness to data changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个实验中，我们将结合所有知识，并为地图添加一些平滑的过渡。过渡是添加风格和流畅数据变化的绝佳方式。
- en: This experiment will, again, require us to start with `example-3.html`. The
    complete experiment can be viewed at `http://localhost:8080/chapter-4/example-5.html`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验再次需要我们从`example-3.html`开始。完整的实验可以在`http://localhost:8080/chapter-4/example-5.html`查看。
- en: If you remember, we leveraged the JavaScript `setInterval()` function to execute
    updates at a regular timed frequency. We will go back to this method now to assign
    a random number between 1 and 33 to our existing `color()` function. We will then
    leverage a D3 method to smoothly transition between the random color changes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们利用JavaScript的`setInterval()`函数以固定的时间频率执行更新。现在我们将回到这个方法，为现有的`color()`函数分配一个介于1和33之间的随机数。然后我们将利用D3方法在随机颜色变化之间进行平滑过渡。
- en: 'Right below the update section, add the following `setInterval()` block of
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新部分下方，添加以下`setInterval()`代码块：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method indicates that, for every `2000` milliseconds (2 seconds), the `map`
    update section should be executed and the color set to a random number between
    `1` and `32`. The new `transition` and `duration` methods transition from the
    previous state to the new state over `500` milliseconds. Open `example-5.html`
    in your browser and you should see the initial color based on the index of the
    state. After 2 seconds, the colors should smoothly transition to new values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法表示，对于每 `2000` 毫秒（2秒），应执行 `map` 更新部分，并将颜色设置为 `1` 到 `32` 之间的随机数。新的 `transition`
    和 `duration` 方法在 `500` 毫秒内从上一个状态过渡到新状态。在浏览器中打开 `example-5.html`，你应该看到基于状态索引的初始颜色。2秒后，颜色应平滑过渡到新值。
- en: Experiment 5 – adding points of interest
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验5 – 添加兴趣点
- en: So far, everything we have done has involved working directly with the geographic
    data and map. However, there are many cases where you will need to layer additional
    data on top of the map. We will begin slowly by first adding a few cities of interest
    to the map of Mexico.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切都涉及到直接处理地理数据和地图。然而，有许多情况需要你在地图上叠加额外的数据。我们将首先通过在墨西哥地图上添加一些感兴趣的城市来慢慢开始。
- en: 'This experiment will, again, require us to start with `example-3.html`. The
    complete experiment can be viewed at: `http://localhost:8080/chapter-4/example-6.html`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验再次需要我们从 `example-3.html` 开始。完整的实验可以在：`http://localhost:8080/chapter-4/example-6.html`
    上查看。
- en: 'In this experiment, we will add a `text` element to the page to identify the
    city. To make the text more visually appealing, we will first add some simple
    styling in the `<style>` section:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将在页面上添加一个 `text` 元素来标识城市。为了使文本更具视觉吸引力，我们首先在 `<style>` 部分添加一些简单的样式：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we need some data that will indicate the city name, the latitude, and
    longitude coordinates. For the sake of simplicity, we have added a file with a
    few starter cities. The file called `cities.csv` is in the same directory as the
    examples:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些数据来指示城市名称、纬度和经度坐标。为了简化，我们添加了一个包含几个起始城市的文件。名为 `cities.csv` 的文件与示例在同一目录中：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, add a few lines of code to bring in the data and plot the city locations
    and names on your map. Add the following block of code right below the exit section
    (if you are starting with `example-2.html`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加几行代码来引入数据，并在你的地图上绘制城市位置和名称。在退出部分（如果你从 `example-2.html` 开始）下方添加以下代码块：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's review what we just added.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们刚刚添加的内容。
- en: 'The `d3.csv` function will make an AJAX call to our data file and automatically
    format the entire file into an array of JSON objects. Each property of the object
    will take on the corresponding name of the column in the `.csv` file. For example,
    take a look at the following lines of code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.csv` 函数将向我们的数据文件发出AJAX调用，并将整个文件自动格式化为JSON对象的数组。对象的每个属性都将采用 `.csv` 文件中相应列的名称。例如，看看以下代码行：'
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we define two variables to hold our data join to the circle and text the
    SVG elements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义两个变量来保存我们的数据连接到圆形和文本SVG元素。
- en: Finally, we will execute a typical enter pattern to place the points as circles
    and the names as text SVG tags on the map. The *x* and *y* coordinates are determined
    by calling our previous `projection()` function with the corresponding latitude
    and longitude coordinates from the data file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将执行一个典型的输入模式，将点放置为圆形，并将名称作为文本SVG标签放置在地图上。*x* 和 *y* 坐标是通过调用我们之前的 `projection()`
    函数，并使用数据文件中的相应纬度和经度坐标来确定的。
- en: 'Note that the `projection()` function returns an array of *x* and *y* coordinates
    (*x, y*). The *x* coordinate is determined by taking the `0` index of the returned
    array. The *y* coordinate is determined from the index, `1`. For example, take
    a look at the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`projection()` 函数返回一个包含 *x* 和 *y* 坐标的数组 (*x, y*)。*x* 坐标是通过取返回数组的 `0` 索引来确定的。*y*
    坐标是从索引 `1` 中确定的。例如，看看以下代码：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `[0]` indicates the *x* coordinate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`[0]` 表示 *x* 坐标。
- en: 'Your new map should look like the one shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的地图应该看起来像以下截图所示：
- en: '![](img/26281754-34bd-4a14-9183-4822e7b289af.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26281754-34bd-4a14-9183-4822e7b289af.png)'
- en: Experiment 6 – adding visualizations as a point of interest
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验6 – 将可视化作为兴趣点添加
- en: 'For our final experiment, we will layer visualizations on top of visualizations!
    Starting from where we left off at `http://localhost:8080/chapter-4/example-6.html`,
    we will add a fictitious column to the data to indicate a metric of tequila consumption
    (the final version can be seen at `http://localhost:8080/chapter-4/example-7.html`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终实验，我们将在可视化之上叠加更多的可视化！从我们上次停止的地方`http://localhost:8080/chapter-4/example-6.html`开始，我们将向数据中添加一个虚构的列来表示龙舌兰的消费指标（最终版本可以在`http://localhost:8080/chapter-4/example-7.html`中查看）：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With just two more lines of code, we can have the city points portray meaning.
    In this experiment, we will scale the radius of the city circles in relation to
    the amount of tequila consumed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 只需两行代码，我们就可以让城市点表达意义。在这个实验中，我们将根据龙舌兰的消费量来调整城市圆的半径：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we will introduce a new scale that linearly distributes the input values
    from `1` to `100` to a radius length between `5` and `30`. This means that the
    minimum radius of a circle will be `5` and the maximum will be `30`, preventing
    the circles from growing too large or too small to be readable:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将引入一个新的比例，将输入值从`1`到`100`线性分布到`5`到`30`之间的半径长度。这意味着圆的最小半径将是`5`，最大半径将是`30`，防止圆变得过大或过小以至于无法阅读：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will change the preceding line of code to call the `radius` function
    instead of the hardcoded value of `4`. The code will now look like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改前面的代码行，将其改为调用`radius`函数而不是硬编码的`4`值。现在的代码将看起来像这样：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After these two small additions, your map should look like the one shown in
    the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个小添加之后，你的地图应该看起来像以下截图所示：
- en: '![](img/9e4296a3-1638-4667-9d41-64816815a38f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e4296a3-1638-4667-9d41-64816815a38f.png)'
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned how to build many different kinds of maps that cover different kinds
    of needs. The choropleths and data visualizations of maps are some of the most
    common geographic-based data representations that you will come across. We also
    added interactivity to our map through basic transitions and events. You will
    easily realize that, with all the information you've gathered so far, you can
    independently create engaging map visualizations. You can expand your knowledge
    by learning advanced interactivity techniques in the next chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何构建多种不同类型的地图，以满足不同的需求。色块图和地图的数据可视化是一些最常见的基于地理的数据表示形式，你将会遇到。我们还通过基本的过渡和事件为我们的地图添加了交互性。你将很容易意识到，凭借你迄今为止收集的所有信息，你可以独立创建引人入胜的地图可视化。你可以在下一章学习高级交互技术来扩展你的知识。
- en: Hang on tight!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请系好安全带！
