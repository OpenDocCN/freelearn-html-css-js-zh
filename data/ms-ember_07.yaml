- en: Chapter 7. Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 组件
- en: 'Up until this chapter, we learned the basic Ember.js concepts that equipped
    us with the necessary tools that enabled us to create full-fledged applications.
    From this chapter onwards, we will be guided through creating all sorts of sophisticated
    applications as we explore more advanced Ember.js features. This chapter will
    introduce us to Ember.js components, which enable us to create custom reusable
    elements, and will cover the following topics in this regard:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章为止，我们学习了 Ember.js 的基本概念，这些概念为我们提供了创建完整应用程序所需的工具。从本章开始，我们将通过探索更多高级 Ember.js
    功能，引导您创建各种复杂的应用程序。本章将介绍 Ember.js 组件，这些组件使我们能够创建自定义的可重用元素，并将涵盖以下相关主题：
- en: Understanding components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件
- en: Defining components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件
- en: Customizing components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义组件
- en: Using components as template layouts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件用作模板布局
- en: Defining actions inside a component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件内部定义动作
- en: Interfacing a component with the rest of the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件与应用程序的其他部分接口
- en: Understanding components
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解组件
- en: 'A web component is a reusable custom HTML tag. The World Wide Web Consortium
    is already working on custom web element (web components) specifications ([http://www.w3.org/TR/components-intro/](http://www.w3.org/TR/components-intro/))
    that will allow developers to create these custom HTML elements with custom behaviors
    as opposed to always relying on the provided standard HTML elements. This specification
    is still being worked on, but there are a number of JavaScript open source projects
    (shims) that can get you started before this specification is complete:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网络组件是一个可重用的自定义 HTML 标签。万维网联盟已经在制定自定义网络元素（网络组件）规范([http://www.w3.org/TR/components-intro/](http://www.w3.org/TR/components-intro/))，这将允许开发者创建具有自定义行为的这些自定义
    HTML 元素，而不是始终依赖于提供的标准 HTML 元素。此规范仍在制定中，但在规范完成之前，有一些 JavaScript 开源项目（shims）可以帮助您开始：
- en: '**Polymer**, available at [http://www.polymer-project.org/](http://www.polymer-project.org/)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合物**，可在[http://www.polymer-project.org/](http://www.polymer-project.org/)找到'
- en: '**Facebook React**, available at [http://facebook.github.io/react/docs/component-api.html](http://facebook.github.io/react/docs/component-api.html)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Facebook React**，可在[http://facebook.github.io/react/docs/component-api.html](http://facebook.github.io/react/docs/component-api.html)找到'
- en: '**Ember.js components**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ember.js 组件**'
- en: Ember.js provides mechanisms that will allow developers to create and complete
    these components in the near future of web technology. Once web components are
    standardized, Ember.js will continue enabling the easy creation of these custom
    elements. It's therefore an added advantage to start utilizing the Ember.js component
    APIs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 提供了机制，将允许开发者在网络技术近未来创建和完成这些组件。一旦网络组件标准化，Ember.js 将继续使创建这些自定义元素变得容易。因此，开始利用
    Ember.js 组件 API 是一个额外的优势。
- en: Defining a component
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义组件
- en: 'Components are a higher-level construct of Ember.js views, and therefore, to
    define one, we''ll need to define either or both of the following two Ember.js
    objects:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是 Ember.js 视图的高级结构，因此，要定义一个组件，我们需要定义以下两个 Ember.js 对象之一或两个：
- en: The component's class
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的类
- en: The component's template
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的模板
- en: 'The class is usually extended from the `Ember.Component` class in the following
    signature:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该类通常从以下签名中的 `Ember.Component` 类扩展：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `component` template is then defined and named using Ember.js conventions.
    For example, the template for the preceding component will be named as:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 组件模板随后使用 Ember.js 习惯用法进行定义和命名。例如，前面组件的模板将被命名为：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The bundled sample of this chapter includes a simple application that utilizes
    several components. This application allows users to upload and rate photos as
    shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章捆绑的示例包括一个简单应用程序，该应用程序利用了几个组件。此应用程序允许用户上传和评分照片，如下面的截图所示：
- en: '![Defining a component](img/00011.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![定义组件](img/00011.jpeg)'
- en: 'The application defines the following components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序定义了以下组件：
- en: Post input component
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子输入组件
- en: Post date component
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子日期组件
- en: Post rating component
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子评分组件
- en: User post component
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户帖子组件
- en: Post photo component
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子照片组件
- en: 'We already noticed that some of these components were defined by either a class
    or a template. For example, the `user-post` component did not define a class.
    Also, the template names were namespaced using a hyphen, while the class names
    were camelized. Therefore, it would have been incorrect to register the `user-post`
    component template as `userpost`. This rule corresponds to one of the following
    component attributes described by W3C:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经注意到，这些组件中的一些是由类或模板定义的。例如，`user-post`组件没有定义类。此外，模板名称使用连字符进行命名空间，而类名称使用驼峰式。因此，将`user-post`组件模板注册为`userpost`是不正确的。这个规则对应于W3C描述的以下组件属性之一：
- en: Component custom elements must be namespaced by a hyphen.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件自定义元素必须通过一个连字符进行命名空间。
- en: Components are sandboxed but can communicate through events. Therefore, the
    component and the host DOM JavaScript cannot manipulate each other.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是沙箱化的，但可以通过事件进行通信。因此，组件和宿主DOM JavaScript不能相互操作。
- en: 'Hence, the `post-input` component class and template, for example, were defined
    as:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，`post-input`组件类和模板被定义为：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once defined, a component can be included into any application template using
    the Handlebars expressions. For example, the first component is a button that
    is used to prompt the user to select an image from the disk:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，一个组件就可以使用Handlebars表达式包含到任何应用模板中。例如，第一个组件是一个按钮，用于提示用户从磁盘中选择一个图像：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, our router defines the `photos` route that handled requests at the home
    path as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的路由器定义了处理主页路径请求的`photos`路由：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Therefore, all we need to do is include the component in the corresponding
    `photos` template as:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要将组件包含在相应的`photos`模板中，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will result in the `components` template being swapped, resulting in:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致`components`模板被交换，从而导致：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do not worry about how the resulting element is a button. The important thing
    to note is that we just defined and used a custom HTML element without worrying
    about its underlying implementation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心生成的元素是一个按钮。重要的是要注意，我们只是定义并使用了一个自定义HTML元素，而不必担心其底层实现。
- en: Differentiating components from views
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分组件和视图
- en: Before we proceed, you might be wondering why components and views are different
    since both wrap templates. Well, components are indeed a subclass of views, but
    their controller context is isolated from the rest of the application. While application
    controllers can be assigned to any view, the defined component classes cannot
    be assigned to other components or views. Components define an interface the desired
    context must implement, and they are therefore more reusable and modular, as we
    will see in the next sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你可能想知道为什么组件和视图不同，因为两者都封装了模板。嗯，组件确实是视图的一个子类，但它们的控制器上下文与应用程序的其他部分是隔离的。虽然应用程序控制器可以被分配给任何视图，但定义的组件类不能分配给其他组件或视图。组件定义了一个接口，所需的上下文必须实现，因此它们更可重用和模块化，我们将在下一节中看到。
- en: Passing properties to components
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性传递给组件
- en: 'While we just mentioned that components are isolated from the rest of the application,
    there is room for them to communicate with the host application in several ways.
    First, they''re able to bind to proprieties in the host template context. For
    example, we just mentioned that the preceding button component is used to prompt
    the user to upload images. The component requires that an enumerable property,
    which will act as the photo store, be bound to its `posts` property:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚提到组件与应用程序的其他部分是隔离的，但它们可以通过几种方式与宿主应用程序进行通信。首先，它们能够绑定到宿主模板上下文中的属性。例如，我们刚刚提到，前面的按钮组件用于提示用户上传图像。该组件要求一个可枚举属性，该属性将作为照片存储库绑定到其`posts`属性：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This way, the component will be able to store the provided photos, as we will
    discuss in a later section. These selected photos will then be displayed to the
    user in the same template as:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，组件将能够存储提供的照片，我们将在后面的章节中讨论。然后，这些选定的照片将在同一模板中显示给用户：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we used yet another component, `user-post`, which rendered a given photo
    into the included page portion. Again, we did not need to worry about the underlying
    implementation of the component. We only needed to satisfy its interface's requirement
    of binding a photo to its `post` property.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了另一个组件，`user-post`，它将给定的照片渲染到包含页面的部分。同样，我们不需要担心组件的底层实现。我们只需要满足其接口对绑定照片到其`post`属性的要求。
- en: 'To understand how these components used the bound properties, let''s consider
    the `post-date` component that was used by the just discussed `user-post` component
    to display a humanized format of the post''s date. This component contains a single
    expression that displays the formatted date as:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些组件如何使用绑定的属性，让我们考虑 `post-date` 组件，该组件被刚才讨论的 `user-post` 组件用来显示帖子的日期的人性化格式。该组件包含一个表达式，显示格式化的日期为：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The expression is a computed property that uses the Moment.js library ([http://momentjs.com](http://momentjs.com))
    to format the date and is defined in the corresponding class as:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式是一个计算属性，它使用 Moment.js 库（[http://momentjs.com](http://momentjs.com)）来格式化日期，并在相应的类中定义为：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The dependent date property is then bound in the `user-post` component as:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `user-post` 组件中将依赖的日期属性绑定：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Customizing a component's element tag
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制组件的元素标签
- en: Since the W3C component specification is still being worked on, Ember.js components
    utilize the existing standard HTML elements. In [Chapter 3](part0029_split_000.html#page
    "Chapter 3. Routing and State Management"), *Routing and State Management*, we
    learned that a view's template is wrapped around an element, which by default
    is `div`. This element can then be customized using the view's `tagName` property.
    A component's template is also wrapped in the same way in a customizable element.
    For example, we promised to discuss how the `post-input` component mentioned previously
    was rendered into DOM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 W3C 组件规范仍在开发中，Ember.js 组件利用现有的标准 HTML 元素。在 [第 3 章](part0029_split_000.html#page
    "第 3 章。路由和状态管理")，*路由和状态管理* 中，我们了解到视图的模板被包裹在一个元素中，默认情况下是 `div`。然后可以使用视图的 `tagName`
    属性来定制该元素。组件的模板也以相同的方式包裹在可定制的元素中。例如，我们承诺要讨论之前提到的 `post-input` 组件是如何渲染到 DOM 中的。
- en: 'All we need to do is define the property in the corresponding class as:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是在该相应的类中定义属性：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Customizing a component's element class
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制组件的元素类
- en: 'Since components are views, their element''s class can be specified statically
    or dynamically using the `classNames` and `classNameBindings` array properties
    on the component''s class. For example, the `post-input` component defines a static
    class as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件是视图，它们的元素类可以使用组件类上的 `classNames` 和 `classNameBindings` 数组属性静态或动态指定。例如，`post-input`
    组件定义了一个静态类：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This results in the component being rendered as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致组件被渲染为：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the sample application, we mentioned that users are able to rate uploaded
    photos. The `user-post` component uses the `post-rating` component that serves
    as the rating widget:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序中，我们提到用户可以对上传的图片进行评分。`user-post` 组件使用 `post-rating` 组件作为评分小部件：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Each of the stars in the latter part is also a component (`post-rating-item`)
    and is listed horizontally to compose the widget as:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 后一部分中的每个星号也是一个组件（`post-rating-item`），它们水平排列以组成小部件：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As expected, the colored stars represent the range of the rating, and so, we
    use the `active` class in this case to style them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，彩色星号代表评分范围，因此在这种情况下，我们使用 `active` 类来设置它们的样式：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is an example of a dynamic class where the component will only acquire
    the class if the defined computed `active` class evaluates to `True`. We will
    discuss how this rating works in a later section, but one last thing to note is
    that in the case of dynamic classes, we can specify the class name to use. For
    example, we can implement the preceding case as:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个动态类的例子，其中组件只有在定义的计算 `active` 类评估为 `True` 时才会获取该类。我们将在稍后的部分讨论这个评分是如何工作的，但最后要注意的一点是，在动态类的情况下，我们可以指定要使用的类名。例如，我们可以将前面的情况实现为：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also implement it as:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其实现为：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Customizing a component's element attributes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制组件的元素属性
- en: 'A component''s element attribute values can also be bound to properties using
    the `attributeBindings` property. For example, consider our `post-photo` component
    that displays the images as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的元素属性值也可以通过使用 `attributeBindings` 属性绑定到属性上。例如，考虑我们的 `post-photo` 组件，它以以下方式显示图片：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, we use the `tagName` property to specify that its element is an image
    tag. We also specify that this element will have an `src` attribute that will
    be aliased to the bound `photo` property. The `user-post` component then uses
    this component to display the images as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `tagName` 属性指定其元素是一个图像标签。我们还指定该元素将有一个 `src` 属性，该属性将被别名到绑定的 `photo` 属性。然后
    `user-post` 组件使用此组件来显示图片：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Be sure to compare how the following element concepts are customized across
    views, components, and even templates:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要比较以下元素概念如何在视图、组件甚至模板中定制：
- en: Tag names
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签名
- en: Class attributes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类属性
- en: Attributes
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Managing events in components
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件中管理事件
- en: Just like views, components can catch user-generated events such as those from
    the keyboard, mouse, and touch devices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像视图一样，组件可以捕获用户生成的事件，例如来自键盘、鼠标和触摸设备的事件。
- en: 'There are two ways in which the handlers to these events can be defined, the
    first of which is to attach the `.on` function to the event-subscriber method.
    For example, the `post-input` component uses this function to define two handlers.
    This button component implements a file-picker dialog that can be opened from
    an invisible file input, as described at [https://github.com/component/file-picker](https://github.com/component/file-picker).
    As soon as the component gets rendered, the event is fired, which results in the
    hidden form element containing a single input file to be appended into DOM as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 定义这些事件处理器的两种方式，第一种是将 `.on` 函数附加到事件订阅方法上。例如，`post-input` 组件使用此函数定义了两个处理器。此按钮组件实现了一个可以从不可见的文件输入中打开的文件选择对话框，具体描述见[https://github.com/component/file-picker](https://github.com/component/file-picker)。组件一旦渲染，就会触发事件，导致包含单个输入文件的隐藏表单元素被附加到
    DOM 中，如下所示：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This form will be used later to upload the images. Next, we define the handler
    that will initiate the file dialog to open. Note that we use the `.on` method
    to subscribe to the button''s click event:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单将用于稍后上传图像。接下来，我们定义将启动文件对话框的处理器。请注意，我们使用 `.on` 方法订阅按钮的点击事件：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside this handler, we set up a listener that will get invoked when the user
    selects an image file, as shown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处理器内部，我们设置了一个监听器，当用户选择一个图像文件时会被调用，如下所示：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the handler which does the upload:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行上传的处理器：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This last handler adds the image to the photo controller as a new post. Note
    that we don't check the mime type of the uploads, so the user might upload other
    media types, such as videos. This check is left out as an implementation exercise
    to the reader.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个处理器将图像添加到照片控制器作为一个新的帖子。请注意，我们没有检查上传的 MIME 类型，因此用户可能会上传其他媒体类型，例如视频。这个检查被留给了读者作为实现练习。
- en: 'Secondly, we subscribe to these events to implement a method whose name corresponds
    to the target event, as shown by the rating widget component previously discussed.
    This component keeps count of the following two properties:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们订阅这些事件以实现一个名称与目标事件相对应的方法，正如之前讨论的评分小部件组件所示。此组件记录以下两个属性：
- en: '`selected`: This is the selected/hovered star position'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected`: 这是选中/悬停的星星位置'
- en: '`_selected`: This is the cached position of the last clicked star'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_selected`: 这是最后点击的星星的缓存位置'
- en: 'We mentioned that the widget is composed of the `post-rating-item` components
    that represent each of the stars. When the user hovers over any of them, we updated
    the `selected` property of the parent component as:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，小部件由代表每个星星的 `post-rating-item` 组件组成。当用户悬停在任何一个上时，我们更新父组件的 `selected` 属性，如下所示：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As shown, we defined a method that corresponded to the `mouseEnter` event.
    This handler sets the `active` property of all the rating item components to the
    left to `True`, since the trick here is to apply the style, as expected, to all
    stars to the left-hand side of the currently selected one:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们定义了一个与 `mouseEnter` 事件相对应的方法。此处理器将所有左侧的评分项组件的 `active` 属性设置为 `True`，因为这里的技巧是按照预期将样式应用到当前选中星星左侧的所有星星上：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On the other hand, those to the right-hand side lose the `active` class because
    their `active` property gets recalculated to `False`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，右侧的星星失去 `active` 类，因为它们的 `active` 属性被重新计算为 `False`。
- en: 'If the user doesn''t click on any of the stars, they expect the earlier rating
    to be restored. Therefore, leaving the currently focused component uses the cached
    `_selected` property to reset the `selected` property, as shown in the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有点击任何星星，他们期望恢复之前的评分。因此，离开当前聚焦的组件会使用缓存的 `_selected` 属性来重置 `selected` 属性，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Again, we only need to implement the `mouseLeave` event hook. Lastly, clicking
    on any of the components gives us the actual rating:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只需要实现 `mouseLeave` 事件钩子。最后，点击任何组件都会给出实际的评分：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that we cache the `_selected` property of the parent component since this
    will be used in the preceding checks. The `active` class updates the components
    state appropriately as:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们缓存了父组件的`_selected`属性，因为这个属性将在前面的检查中使用。`active`类根据以下方式适当地更新组件的状态：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Defining component actions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义组件动作
- en: 'We mentioned that components define classes that act as their controllers that
    are isolated from the rest of the application. For example, an application controller
    cannot define a component class as a dependency in its `needs` property. However,
    since they are considered as controllers, they can define handlers to action expressions
    defined in their corresponding templates in an `actions` object property. For
    example, let''s define a message box component that can be used in any application
    that needs to implement the chat functionality:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到组件定义的类充当它们的控制器，这些控制器与应用程序的其余部分隔离。例如，应用程序控制器不能将其组件类定义为`needs`属性中的依赖项。然而，由于它们被视为控制器，它们可以在`actions`对象属性中定义处理程序，以处理它们相应模板中定义的动作表达式。例如，让我们定义一个消息框组件，该组件可用于任何需要实现聊天功能的应用程序：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To use this component, one simply needs to provide the `Messages` container
    in which new messages will be stored. Here''s a possible example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此组件，只需提供一个`Messages`容器，其中将存储新消息。以下是一个可能的示例：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The component form defines an action that binds the `save` action handler of
    the component class to the form's `submit` event. When the user submits the form
    by hitting the *Enter* key, the handler sanitizes the message before pushing it
    to the provided container. You'll realize that these actions are similar to the
    ones we learned earlier in [Chapter 4](part0044_split_000.html#page "Chapter 4. Writing
    Application Templates"), *Writing Application Templates*. However, there's no
    event bubbling in components. A failure to locate the handler in the class will
    lead to an appropriate error being thrown.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 组件形式定义了一个动作，该动作将组件类的`save`动作处理程序绑定到表单的`submit`事件。当用户通过按下*Enter*键提交表单时，处理程序会在将其推送到提供的容器之前对消息进行清理。你会发现这些动作与我们之前在[第4章](part0044_split_000.html#page
    "第4章。编写应用模板")中学习的动作类似，即*编写应用模板*。然而，组件中没有事件冒泡。如果在类中找不到处理程序，将抛出适当的错误。
- en: Interfacing a component with the rest of the application
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将组件与应用程序的其余部分接口
- en: 'Components, as mentioned earlier, are not completely sandboxed, but they can
    interact with the rest of the application in the following ways:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，组件并非完全沙箱化，但它们可以通过以下方式与应用程序的其余部分进行交互：
- en: Bind to properties
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到属性
- en: Send actions
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送动作
- en: 'We have already seen how components are able to bind to other application properties
    by passing the properties in the template expressions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到组件如何通过在模板表达式中传递属性来绑定到其他应用程序属性：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Components also have the ability to send their actions to controllers in an
    application. To demonstrate this, let''s create a simple checkout button for an
    e-commerce site:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还具有将它们的行为发送到应用程序中的控制器的能力。为了演示这一点，让我们为电子商务网站创建一个简单的结账按钮：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding example, we intend to add a product to cart whenever its corresponding
    checkout button is clicked via an event handler. We utilize the component''s `sendAction`
    method to bubble this action to the parent controller. However, there are two
    things we need to fix in order to realize this. First, we need to rename our event
    handler in the controller to something descriptive. Moreover, the same `click`
    event handler can catch events from other elements as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们的意图是在点击相应的结账按钮时通过事件处理程序将产品添加到购物车。我们利用组件的`sendAction`方法将此动作冒泡到父控制器。然而，为了实现这一点，我们需要修复两件事。首先，我们需要将控制器中的事件处理程序重命名为更具描述性的名称。此外，相同的`click`事件处理程序可以捕获来自其他元素的事件：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we need to send the selected product to the `addToCart` handler with
    a little modification of the template:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过修改模板将选定的产品发送到`addToCart`处理程序：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This just lets the component be able to access the product. Finally, we send
    the product to the controller event handler as:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是让组件能够访问产品。最后，我们将产品发送到控制器事件处理程序：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that the first argument to `sendAction` is always `action` followed by
    the object(s) we wish to send.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sendAction`的第一个参数始终是`action`，后面跟着我们希望发送的对象（s）。
- en: Components as layouts
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件作为布局
- en: 'A component''s template can act as a layout for other application templates.
    These layouts are not specified in the view layer; they use block expressions
    instead. Additional content can then be inserted inside these templates without
    losing scope. For example, imagine we wish to create a component that will use
    the `content-editable` element. This kind of component will need to wrap a section
    of some HTML content as:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的模板可以作为其他应用程序模板的布局。这些布局在视图层中未指定；它们使用块表达式。然后可以在这些模板内部插入附加内容，而不会丢失作用域。例如，想象一下我们希望创建一个将使用
    `content-editable` 元素的组件。这类组件需要将某个 HTML 内容的部分包装为：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As shown, the component uses custom Handlebars tags that match its namespaced
    template name. The content inside and outside the component will still enjoy the
    same scope. Can you guess how this component will be implemented? One implementation
    will be to turn the wrapped content into `content-editable` when double-clicked
    or focused, and back to `div` when the mouse leaves the element as:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，该组件使用与命名空间模板名称匹配的自定义 Handlebars 标签。组件内部和外部的内容仍将享受相同的范围。你能猜出这个组件将如何实现吗？一种实现方式是将包装内容在双击或聚焦时转换为
    `content-editable`，当鼠标离开元素时恢复为 `div`，如下所示：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The two event-defined handlers toggle the `isEditing` property, which then results
    in the `content-editable` attribute to be added or removed from the element accordingly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 两个事件定义的处理程序切换 `isEditing` 属性，这随后导致 `content-editable` 属性相应地被添加或从元素中移除。
- en: 'To make things a little interesting, imagine we want to upgrade our `content-editable`
    component into a WYSIWYG editor. We will need to define a template that is used
    to host the different controls to manipulate the content, as shown in the following
    example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情变得更有趣，想象一下我们想要将我们的 `content-editable` 组件升级为一个所见即所得（WYSIWYG）编辑器。我们需要定义一个模板，用于托管用于操作内容的各种控件，如下面的示例所示：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, we define a toolbar that will house standard editor controls. We can
    bind action handlers, as discussed in the previous sections, to perform the manipulations;
    this will be a worthy attempt by the reader. In the content section, we use the
    `yield` expression we discussed in the previous chapter to tell the component
    to render the wrapped content in this portion of the template. With this powerful
    feature, both the component and the wrapped content can define expressions that
    bind to isolated contexts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个工具栏，用于存放标准编辑器控件。我们可以绑定之前章节中讨论的动作处理程序来执行操作；这将是一个值得读者尝试的练习。在内容部分，我们使用之前章节中讨论的
    `yield` 表达式来告诉组件在这个模板的部分渲染包装内容。有了这个强大的功能，组件和包装内容都可以定义绑定到隔离上下文的表达式。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'You''ll find components useful when you want to modularize your application.
    There are various open source tools that will enable you to ship these components
    to your application. In the last chapter of this book, we will learn how to ship
    these components and mixins into your application using the component''s ([http://github.com/component](http://github.com/component))
    asset manager and build. Therefore, it''s best practice to abstract modular objects
    in your application into either mixins or components. The following are some of
    the things we learned about components:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想模块化你的应用程序时，你会发现组件非常有用。有许多开源工具可以使你能够将这些组件发送到你的应用程序中。在本书的最后一章中，我们将学习如何使用组件的
    ([http://github.com/component](http://github.com/component)) 资产管理器和构建将这些组件和混入（mixins）发送到你的应用程序中。因此，将你的应用程序中的模块化对象抽象为混入或组件是最佳实践。以下是我们关于组件学到的一些内容：
- en: Defining components
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件
- en: Customizing component elements and attributes
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义组件元素和属性
- en: Managing actions inside components
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件内管理动作
- en: Interfacing components with the rest of the application
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件与应用程序的其他部分接口连接
- en: In the next chapter, we will learn how to sync data between Ember.js applications
    and REST backends. We will particularly learn how to use Ember.js data to simplify
    this need.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何同步 Ember.js 应用程序和 REST 后端之间的数据。我们将特别学习如何使用 Ember.js 数据来简化这一需求。
