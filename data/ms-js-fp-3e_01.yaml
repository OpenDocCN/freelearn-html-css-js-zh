- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Becoming Functional – Several Questions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为函数式——几个问题
- en: '**Functional programming** (or **FP**) has been around since the earliest days
    of computing and is going through a sort of revival because of its increased use
    with several frameworks and libraries, most particularly in **JavaScript**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**（或**FP**）自计算机的最早时期以来就存在，由于在多个框架和库中的使用增加，尤其是**JavaScript**，它经历了一种复兴。 '
- en: 'In this chapter, we shall do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下几件事：
- en: Introduce some concepts of FP to give a small taste of what it means
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些 FP 的概念，以给出其含义的一小部分体验
- en: Show the benefits (and problems) implied by the usage of FP and why we should
    use it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示使用函数式编程（FP）带来的好处（以及问题），以及为什么我们应该使用它
- en: Start thinking about why JavaScript can be considered an appropriate language
    for FP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始思考为什么 JavaScript 可以被认为是适合 FP 的语言
- en: Go over the language features and tools that you should be aware of to fully
    take advantage of everything in this book
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述你应该了解的语言特性和工具，以便充分利用本书中的所有内容
- en: By the end of this chapter, you’ll have the basic tools that we’ll be using
    throughout this book, so let’s get started by learning about FP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有我们将在这本书中使用的所有基本工具，所以让我们开始学习FP。
- en: What is functional programming?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: If you go back in computer history, you’ll find that the second oldest programming
    language still in use, Lisp, is based on FP. Since then, there have been many
    more functional languages, and FP has been applied more widely. But even so, if
    you ask people what FP is, you’ll probably get two widely dissimilar answers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾计算机历史，你会发现仍在使用的第二古老的编程语言 Lisp 是基于 FP 的。从那时起，出现了更多功能性的语言，FP 的应用也更加广泛。但即便如此，如果你问人们什么是
    FP，你可能会得到两个截然不同的答案。
- en: A bit of trivia
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一点趣闻
- en: For trivia or history buffs, the oldest programming language still in use is
    Fortran, which appeared in 1957, a year before Lisp. Quite shortly after Lisp
    came another long-lived language, COBOL, for business-oriented programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于喜欢 trivia 或历史的人来说，仍在使用的最古老的编程语言是 Fortran，它在 1957 年出现，比 Lisp 早一年。在 Lisp 之后不久，又出现了一种长寿的语言，COBOL，用于面向商业的编程。
- en: Depending on whom you ask, you’ll either learn that it’s a modern, advanced,
    enlightened approach to programming that leaves every other paradigm behind or
    that it’s mainly a theoretical thing, with more complications than benefits, that’s
    practically impossible to implement in the real world. And, as usual, the real
    answer is not in the extremes, but somewhere in between. Let’s start by looking
    at the theory versus practice and see how we plan to use FP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你询问的人不同，你可能会了解到它是一种现代、先进、开明的编程方法，超越了其他所有范式，或者它主要是一个理论上的东西，弊大于利，在现实世界中几乎无法实施。通常，真正的答案并不在极端，而是在两者之间。让我们先从理论与实践对比开始，看看我们计划如何使用FP。
- en: Theory versus practice
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论与实际
- en: In this book, we won’t be going about FP in a theoretical way. Instead, our
    point is to show you how some of its techniques and tenets can be successfully
    applied to common, everyday JavaScript programming. But – and this is important
    – we won’t be going about this dogmatically, but in a very practical way. We won’t
    dismiss useful JavaScript constructs simply because they don’t happen to fulfill
    the academic expectations of FP. Similarly, we won’t avoid practical JavaScript
    features just to fit the FP paradigm. We could almost say that we’ll be doing
    **Sorta Functional Programming** (**SFP**) because our code will be a mixture
    of FP features, more classical imperative ones, and **object-oriented** **programming**
    (**OOP**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会以理论的方式介绍FP。相反，我们的目的是向你展示一些其技术和原则如何成功地应用于常见的日常JavaScript编程。但——这一点很重要——我们不会教条地这样做，而是以一种非常实用的方式。我们不会因为它们不符合FP的学术期望而摒弃有用的JavaScript结构。同样，我们也不会为了避免符合FP范式而避免使用实用的JavaScript特性。我们几乎可以说，我们将进行**Sorta
    Functional Programming**（**SFP**），因为我们的代码将是FP特性、更传统的命令式特性和**面向对象**的**编程**（**OOP**）的混合体。
- en: 'Be careful, though: what we just said doesn’t mean that we’ll be leaving all
    the theory by the side. We’ll be picky, and just touch the main theoretical points,
    learn some vocabulary and definitions, and explain core FP concepts, but we’ll
    always be keeping in sight the idea of producing actual, useful JavaScript code,
    rather than trying to meet some mystical, dogmatic FP criteria.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，我们所说的并不意味着我们会把所有理论都放在一边。我们会挑剔地选择，只触及主要的理论点，学习一些词汇和定义，并解释核心的FP概念，但我们始终会着眼于产生实际、有用的JavaScript代码的想法，而不是试图满足某些神秘、教条的FP标准。
- en: OOP has been a way to solve the inherent complexity of writing large programs
    and systems, and developing clean, extensible, scalable application architectures;
    however, because of the scale of today’s web applications, the complexity of all
    code bases is continuously growing. Also, the newer features of JavaScript make
    it possible to develop applications that wouldn’t even have been possible just
    a few years ago; think of mobile (hybrid) apps that are made with Ionic, Apache
    Cordova, or React Native or desktop apps that are made with Electron, Tauri, or
    NW.js, for example. JavaScript has also migrated to the backend with Node.js or
    Deno, so today, the scope of usage for the language has grown in a serious way
    that deals with all the added complexity of modern designs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）一直是解决编写大型程序和系统固有的复杂性、开发干净、可扩展、可伸缩的应用程序架构的方法；然而，由于今天Web应用程序的规模，所有代码库的复杂性持续增长。此外，JavaScript的新特性使得开发几年前甚至不可能开发的应用程序成为可能；例如，使用Ionic、Apache
    Cordova或React Native制作的移动（混合）应用程序，或使用Electron、Tauri或NW.js制作的桌面应用程序。JavaScript还通过Node.js或Deno迁移到后端，因此，今天，该语言的使用范围在处理现代设计的附加复杂性方面有了重大增长。
- en: A different way of thinking
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同的思维方式
- en: 'FP is a different way of writing programs and can sometimes be difficult to
    learn. In most languages, programming is done imperatively: a program is a sequence
    of statements, executed in a prescribed fashion, and the desired result is achieved
    by creating objects and manipulating them, which usually means modifying the objects
    themselves. FP is based on producing the desired result by evaluating expressions
    built out of functions that are composed together. In FP, it’s common to pass
    functions around (such as passing parameters to other functions or returning functions
    as the result of a calculation), not use loops (opting for recursion instead),
    and skip side effects (such as modifying objects or global variables).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）是一种不同的编写程序的方式，有时可能难以学习。在大多数语言中，编程是命令式的：程序是一系列语句的序列，按照规定的方式执行，通过创建对象并操作它们来达到期望的结果，这通常意味着修改对象本身。FP基于通过评估由函数组成的表达式来产生期望的结果。在FP中，传递函数（例如将参数传递给其他函数或返回计算的结果作为函数）是常见的，不使用循环（选择递归代替），并跳过副作用（如修改对象或全局变量）。
- en: In other words, FP focuses on *what* should be done, rather than on *how* it
    should be done. Instead of worrying about loops or arrays, you work at a higher
    level, considering what needs to be done. After becoming accustomed to this style,
    you’ll find that your code becomes simpler, shorter, and more elegant, and can
    be easily tested and debugged. However, don’t fall into the trap of considering
    FP as the goal! Think of FP only as a means to an end, as with all software tools.
    Functional code isn’t good just for being functional, and writing bad code is
    just as possible with FP as with any other technique!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，函数式编程（FP）关注的是**应该做什么**，而不是**如何去做**。你不需要担心循环或数组，而是在一个更高的层面上工作，考虑需要完成的事情。习惯这种风格后，你会发现你的代码变得更加简单、更短、更优雅，并且可以轻松地进行测试和调试。然而，不要陷入将FP视为目标的陷阱！将FP仅视为达到目的的手段，就像所有软件工具一样。函数式代码并不仅仅因为其函数性而好，使用FP编写糟糕的代码与使用任何其他技术一样可能！
- en: FP and other programming paradigms
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程和其他编程范式
- en: Programming paradigms classify programming languages according to their features.
    However, some languages may be classified into multiple paradigms – as is the
    case of JavaScript itself!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编程范式根据编程语言的特征对编程语言进行分类。然而，一些语言可能被归类到多个范式——JavaScript本身就是这样！
- en: A primary division is *imperative* versus *declarative* languages. In the former,
    developers must instruct the machine on how to do its work, step by step. Programming
    may be *procedural* (if instructions are grouped into procedures) or *object-oriented*
    (if instructions are grouped with a related state).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的划分是**命令式**与**声明式**语言。在前者中，开发者必须逐步指导机器如何完成其工作。编程可能是**过程式**的（如果指令被分组为过程），或者**面向对象**的（如果指令与相关状态一起分组）。
- en: In declarative languages, in opposition, developers just declare properties
    that the sought result must satisfy, but not how to calculate it. Declarative
    languages may be *logic-based* (based on logic rules and constraints), *reactive*
    (based on data and event streams), or *functional* (based on the application and
    combination of functions). In a sense, we could say that imperative languages
    focus on *how*, while declarative languages focus on *what*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在声明式语言中，开发者只需声明所求结果必须满足的属性，但不必说明如何计算它。声明式语言可能是**基于逻辑**的（基于逻辑规则和约束）、**响应式**的（基于数据和事件流）或**函数式**的（基于应用和函数的组合）。从某种意义上说，我们可以说命令式语言关注**如何**，而声明式语言关注**什么**。
- en: 'JavaScript is multi-paradigm: it’s imperative (both procedural and object-oriented)
    but also allows declarative programming, both functional (like almost everything
    in this book! In particular, we will devote [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, to this topic) and reactive (we’ll see reactive FP
    in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing* *Design Patterns*).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是多范式的：它是命令式的（既过程式又面向对象），但也允许声明式编程，包括函数式（如本书中的几乎所有内容！特别是，我们将专门在[*第5章*](B19301_05.xhtml#_idTextAnchor084)，*声明式编程*）和响应式（我们将在[*第11章*](B19301_11.xhtml#_idTextAnchor204)，*实现设计模式*）中探讨这一主题）。
- en: 'Just to give you a basic example of the difference between imperative and declarative
    ways of solving a problem, let’s solve a simple problem: assume you have an array
    of personal data of people, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个命令式与声明式解决问题方式的区别的基本例子，让我们解决一个简单的问题：假设你有一组人的个人数据数组，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Imagine you want to extract the data for adults (at least 21 years old). Imperatively,
    you would do something like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要提取成年人的数据（至少21岁）。命令式地，你会做如下操作：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You have to initialize the output array (`result1`) for the selected people.
    Then, you must specify a loop, saying how the index variable (`i`) is to be initialized,
    tested, and updated. On each pass of the loop, you check the corresponding person’s
    age, and if the person is an adult, you push the data to the output array. In
    other terms, you specify, step by step, everything that the code will have to
    do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须初始化所选人员的输出数组（`result1`）。然后，你必须指定一个循环，说明索引变量（`i`）如何初始化、测试和更新。在循环的每次迭代中，你检查相应人员的年龄，如果该人员是成年人，则将数据推送到输出数组。换句话说，你逐步指定代码将执行的所有操作。
- en: 'Working declaratively, you’d rather write something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以声明式工作，你更愿意写如下内容：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line declares how to test if a person is an adult; the second line
    says that the result is the result of filtering the data array, picking those
    elements that satisfy the given predicate. (For `isAdult()`, we’re using an arrow
    function; we’ll see more on that in the *Arrow functions* section, later in this
    chapter.) You don’t have to initialize the output array, specify how to loop,
    or ensure that your array index doesn’t go beyond the array’s length, and so on
    – all those details are taken care of by the language, so you don’t need to.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了如何测试一个人是否是成年人；第二行说明结果是过滤数据数组的结果，选择满足给定谓词的元素。（对于`isAdult()`，我们使用箭头函数；我们将在本章后面的*箭头函数*部分了解更多。）你不需要初始化输出数组，指定如何循环，或确保你的数组索引不超过数组的长度等——所有这些细节都由语言处理，因此你不需要。
- en: Reading and understanding the imperative version requires knowledge of both
    the programming language and algorithms or techniques for looping; the declarative
    version is shorter to write, easier to maintain, and much more readable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读和理解命令式版本需要了解编程语言以及循环的算法或技术；声明式版本更易于编写，更易于维护，且可读性更强。
- en: What FP is not
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP 不是什么
- en: 'Since we’ve been talking quite a bit about what FP is, let’s also clear up
    some common misconceptions, and look at what FP is not:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经谈论了很多关于FP是什么的内容，让我们也澄清一些常见的误解，并看看FP不是什么：
- en: '*FP isn’t just an academic ivory tower thing*: The lambda calculus upon which
    it is based was developed by Alonzo Church in 1936 as a tool to prove an important
    result in theoretical computer science (which preceded modern computer languages
    by more than 20 years!); however, FP languages are being used today for all kinds
    of systems.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FP不仅仅是学术象牙塔中的事物*：FP所基于的λ演算是由Alonzo Church在1936年开发的，作为一种证明理论计算机科学中一个重要结果（这比现代计算机语言早了20多年！）的工具；然而，FP语言今天被用于各种系统。'
- en: '*FP isn’t the opposite of OOP*: It isn’t a case of choosing declarative or
    imperative ways of programming. You can mix and match as best suits you, and we’ll
    be doing this throughout this book, bringing together the best of all worlds.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FP不是面向对象（OOP）的对立面*：这并不是选择声明式或命令式编程方式的问题。你可以根据需要混合和匹配，我们将在整本书中这样做，将所有世界的最佳之处结合起来。'
- en: '*FP isn’t overly complex to learn*: Some of the FP languages are rather different
    from JavaScript, but the differences are mostly syntactic. Once you learn the
    basic concepts, you’ll see that you can get the same results in JavaScript as
    with FP languages.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FP学习并不复杂*：一些函数式编程（FP）语言与JavaScript相当不同，但差异主要在于语法。一旦你掌握了基本概念，你就会发现你可以在JavaScript中实现与FP语言相同的结果。'
- en: It may also be relevant to mention that several modern frameworks, such as the
    React and Redux combination, include FP ideas.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还可能需要提到的是，几个现代框架，如React和Redux的组合，都包含了FP思想。
- en: For example, in React, it’s said that the view (whatever the user gets to see
    at a given moment) is a function of the current state. You use a function to compute
    what HTML and CSS must be produced at each moment, thinking in a black-box fashion.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在React中，据说视图（用户在任何给定时刻能看到的内容）是当前状态的函数。你使用一个函数来计算在每一刻必须生成的HTML和CSS，以黑盒的方式思考。
- en: Similarly, in Redux, you have the concept of actions that are processed by reducers.
    An action provides some data, and a reducer is a function that produces the new
    state for the application in a functional way out of the current state and the
    provided data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在Redux中，你有由reducers处理的行为的概念。一个行为提供了一些数据，而reducer是一个函数，它以函数式的方式从当前状态和提供的数据中生成应用程序的新状态。
- en: So, both because of the theoretical advantages (we’ll be getting to those in
    the following section) and the practical ones (such as getting to use the latest
    frameworks and libraries), it makes sense to consider FP coding. Let’s get on
    with it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论是由于理论优势（我们将在下一节中讨论这些优势）还是实际优势（例如，能够使用最新的框架和库），考虑使用FP编码都是合理的。让我们继续前进。
- en: Why use FP?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用FP？
- en: Throughout the years, there have been many programming styles and fads. However,
    FP has proven quite resilient and is of great interest today. Why would you want
    to use FP? Rather, the first question to ask should be, what do you need? And
    only then, does FP get you that? We’ll answer these important questions in the
    following sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，出现了许多编程风格和潮流。然而，FP已经证明相当有弹性，并且今天非常受欢迎。你为什么想使用FP？相反，首先应该问的问题是，你需要什么？然后，FP才能满足你的需求？我们将在以下章节中回答这些重要问题。
- en: What we need
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要
- en: 'We can certainly agree that the following list of concerns is universal. Our
    code should have the following qualities:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以肯定地同意以下列表中的担忧是普遍的。我们的代码应该具有以下品质：
- en: '**Modular**: The functionality of your program should be divided into independent
    modules, each of which contains a part of the solution. Changes in a module or
    function shouldn’t affect the rest of the code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：你的程序的功能应该分为独立的模块，每个模块都包含解决方案的一部分。模块或函数中的更改不应影响其余代码。'
- en: '**Understandable**: A reader of your program should be able to discern its
    components, functions, and relationships without undue effort. This is closely
    linked with the **maintainability** of the code; your code will have to be maintained
    in the future, whether to be changed or to have new functionality added.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**：你的程序读者应该能够不费吹灰之力地辨别其组件、函数和关系。这与代码的**可维护性**密切相关；你的代码将来必须得到维护，无论是为了更改还是为了添加新功能。'
- en: '**Testable**: **Unit tests** try out small parts of your program, verifying
    their behavior independently of the rest of the code. Your programming style should
    favor writing code that simplifies the job of writing unit tests. Unit tests are
    also like documentation in that they can help readers understand what the code
    is supposed to do.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：**单元测试**尝试测试程序的小部分，验证其行为独立于其他代码。你的编程风格应该倾向于编写简化单元测试工作的代码。单元测试也像文档一样，可以帮助读者理解代码的预期功能。'
- en: '**Extensible**: It’s a fact that your program will someday require maintenance,
    possibly to add new functionality. Those changes should impact the structure and
    data flow of the original code only minimally (if at all). Small changes shouldn’t
    imply large, serious refactoring of your code.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：这是一个事实，你的程序总有一天需要维护，可能需要添加新功能。这些更改应该对原始代码的结构和数据流只有最小的影响（如果有的话）。小的更改不应该意味着对代码进行大规模的重大重构。'
- en: '**Reusable**: Code reuse has the goal of saving resources, time, and money,
    and reducing redundancy by taking advantage of previously written code. Some characteristics
    help with this goal, such as **modularity** (which we already mentioned), **high
    cohesion** (all the pieces in a module belong together), **low coupling** (modules
    are independent of each other), **separation of concerns** (the parts of a program
    should overlap in functionality as little as possible), and **information hiding**
    (internal changes in a module shouldn’t affect the rest of the system).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：代码重用的目标是节省资源、时间和金钱，通过利用先前编写的代码来减少冗余。一些特性有助于实现这一目标，例如**模块化**（我们之前已经提到过）、**高内聚**（模块中的所有部分都属于一起）、**低耦合**（模块相互独立）、**关注点分离**（程序的部分应该在功能上尽可能少地重叠）和**信息隐藏**（模块的内部更改不应影响系统的其他部分）。'
- en: What we get
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们所得到的
- en: So, does FP give you the five characteristics we just listed in the previous
    section?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，FP是否提供了我们之前章节中列出的五个特性？
- en: In FP, the goal is to write separate independent functions that are joined together
    to produce the final results.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在FP中，目标是编写独立的函数，然后将它们组合起来以产生最终结果。
- en: Programs that are written in a functional style usually tend to be cleaner,
    shorter, and easier to understand.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数式风格编写的程序通常更干净、更短，更容易理解。
- en: Functions can be tested on their own, and FP code has advantages in achieving
    this.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以单独测试，FP代码在这方面具有优势。
- en: You can reuse functions in other programs because they stand on their own, not
    depending on the rest of the system. Most functional programs share common functions,
    several of which we’ll be considering in this book.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在其他程序中重用函数，因为它们是独立的，不依赖于系统的其他部分。大多数函数式程序共享一些公共函数，其中一些我们将在本书中讨论。
- en: Functional code is free from side effects, which means you can understand the
    objective of a function by studying it without having to consider the rest of
    the program.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式代码没有副作用，这意味着你可以通过研究函数本身来理解其目标，而无需考虑整个程序。
- en: Finally, once you get used to the FP style of programming, code becomes more
    understandable and easier to extend. So, it seems that all five characteristics
    can be achieved with FP!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦你习惯了FP编程风格，代码就会变得更加可理解且易于扩展。因此，似乎我们可以通过FP实现所有五个特性！
- en: Why use FP?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用FP？
- en: For a well-balanced look at the reasons to use FP, I’d suggest reading *Why
    Functional Programming Matters*, by John Hughes; it’s available online at [www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf).
    It’s not geared toward JavaScript, but the arguments are easily understandable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面了解使用函数式编程（FP）的理由，我建议阅读约翰·休斯（John Hughes）的《Why Functional Programming Matters》；它可在[www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)在线获取。这本书并非针对JavaScript编写，但其中的论点易于理解。
- en: Not all is gold
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并非所有都是金子
- en: However, let’s strive for a bit of balance. Using FP isn’t a silver bullet that
    will automagically make your code better. Some FP solutions are tricky, and some
    developers greatly enjoy writing code and then asking, what does this do? If you
    aren’t careful, your code may become write-only and practically impossible to
    maintain; there goes understandable, extensible, and reusable out the door!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们努力寻求一种平衡。使用FP并不是一个银弹，它会自动让你的代码变得更好。一些FP解决方案可能很棘手，有些开发者喜欢编写代码后问自己，这会做什么？如果你不小心，你的代码可能会变得只能写不能读，实际上难以维护；这样一来，可理解性、可扩展性和可重用性就都消失了！
- en: 'Another disadvantage is that you may find it harder to find FP-savvy developers.
    (Quick question: how many *FP-sought* job ads have you ever seen?) The vast majority
    of today’s web code is written in imperative, non-functional ways, and most coders
    are used to that way of working. For some, having to switch gears and start writing
    programs differently may prove an unpassable barrier.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，你可能发现很难找到熟悉函数式编程（FP）的开发者。（快速问题：你见过多少 *FP-sought* 的招聘广告？）今天的大多数网络代码都是用命令式、非函数式的方式编写的，大多数程序员都习惯了这种方式。对于一些人来说，不得不转换思路并以不同的方式编写程序可能是一个难以逾越的障碍。
- en: Finally, if you try to go fully functional, you may find yourself at odds with
    JavaScript, and simple tasks may become hard to do. As we said at the beginning,
    we’ll opt for **SFP**, so we won’t be drastically rejecting any language features
    that aren’t 100% functional. After all, we want to use FP to simplify our coding,
    not to make it more complex!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你尝试完全采用函数式编程，你可能会发现自己在 JavaScript 上遇到了困难，简单的任务可能变得难以完成。正如我们一开始所说的，我们将选择
    **SFP**，因此我们不会彻底拒绝任何非 100% 函数式的语言特性。毕竟，我们想要使用 FP 来简化我们的编码，而不是让它变得更加复杂！
- en: 'So, while I’ll strive to show you the advantages of going functional in your
    code, as with any change, there will always be some difficulties. However, I’m
    fully convinced that you’ll be able to surmount them and that your organization
    will develop better code by applying FP. Dare to change! So, given that you accept
    that FP may apply to your problems, let’s consider the other question: can we
    use JavaScript in a functional way and is it appropriate?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我会努力向你展示在代码中采用函数式编程的优势，但就像任何改变一样，总会有些困难。然而，我坚信你能够克服这些困难，并且通过应用 FP，你的组织将能够编写更好的代码。敢于改变！所以，既然你接受
    FP 可能适用于你的问题，让我们考虑另一个问题：我们能否以函数式的方式使用 JavaScript，这是否合适？
- en: Is JavaScript functional?
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 是否是函数式的？
- en: 'At about this time, there is another important question that you should be
    asking: *is JavaScript a functional language?* Usually, when thinking about FP,
    the list of languages that are mentioned does not include JavaScript, but does
    include less common options, such as Clojure, Erlang, Haskell, and Scala; however,
    there is no precise definition for FP languages or a precise set of features that
    such languages should include. The main point is that you can consider a language
    to be functional if it supports the common programming style associated with FP.
    Let’s start by learning about why we would want to use JavaScript at all and how
    the language has evolved to its current version, and then see some of the key
    features that we’ll be using to work in a functional way.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在这个时候，你应该问自己另一个重要的问题：*JavaScript 是一种函数式语言吗？* 通常，当人们想到 FP 时，提到的语言列表并不包括 JavaScript，而是包括一些不太常见的选项，如
    Clojure、Erlang、Haskell 和 Scala；然而，并没有对 FP 语言或这些语言应包含的确切特征的定义。关键是，如果你认为一种语言支持与
    FP 相关的常见编程风格，那么你可以认为这种语言是函数式的。让我们先了解一下为什么我们要使用 JavaScript，以及这种语言是如何发展到当前版本的，然后看看我们将使用的一些关键特性，这些特性将帮助我们以函数式的方式工作。
- en: JavaScript as a tool
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 作为一种工具
- en: What is JavaScript? If you consider popularity indices, such as the ones at
    [www.tiobe.com/tiobe-index/](http://www.tiobe.com/tiobe-index/) or [pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html),
    you’ll find that JavaScript is consistently in the top 10 most popular languages.
    From a more academic point of view, the language is sort of a mixture, borrowing
    features from several different languages. Several libraries helped the growth
    of the language by providing features that weren’t so easily available, such as
    classes and inheritance (today’s version of the language does support classes,
    but that was not the case not too long ago), that otherwise had to be achieved
    by doing some prototype tricks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 JavaScript？如果你考虑像 [www.tiobe.com/tiobe-index/](http://www.tiobe.com/tiobe-index/)
    或 [pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html) 这样的流行度指数，你会发现 JavaScript
    持续位于最受欢迎的 10 种语言之列。从更学术的角度来看，这种语言是一种混合体，从几种不同的语言中借鉴了特性。几个库通过提供一些不太容易获得的特性（如类和继承——今天语言的版本支持类，但不久前并不支持），帮助了语言的增长，否则这些特性可能需要通过一些原型技巧来实现。
- en: What’s in a name?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 名字里有什么？
- en: The name *JavaScript* was chosen to take advantage of the popularity of Java
    – just as a marketing ploy! Its first name was *Mocha*, then, *LiveScript*, and
    only then *JavaScript*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript* 这个名字的选择是为了利用 Java 的流行度——这纯粹是一种营销策略！它的原名是 *Mocha*，然后是 *LiveScript*，最后才是
    *JavaScript*。'
- en: JavaScript has grown to be incredibly powerful. But, as with all power tools,
    it gives you a way to not only produce great solutions but also to do great harm.
    FP could be considered as a way to reduce or leave aside some of the worst parts
    of the language and focus on working in a safer, better way; however, due to the
    immense amount of existing JavaScript code, you cannot expect it to facilitate
    large reworkings of the language that would cause most sites to fail. You must
    learn to live with the good and the bad, and simply avoid the latter part.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 已经变得非常强大。但是，就像所有强大的工具一样，它不仅让你能够产生出色的解决方案，还能造成巨大的伤害。函数式编程（FP）可以被认为是一种减少或摒弃语言中最糟糕的部分，并专注于以更安全、更好的方式工作的方式；然而，由于现有的
    JavaScript 代码量巨大，你不能期望它促进对语言的大规模重构，这会导致大多数网站失败。你必须学会接受好的一面和不好的一面，并简单地避免后者。
- en: In addition, the language has a broad variety of available libraries that complete
    or extend the language in many ways. In this book, we’ll be focusing on using
    JavaScript on its own, but we will make references to existing, available code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该语言有各种各样的可用库，以多种方式完善或扩展了语言。在这本书中，我们将专注于使用 JavaScript，但我们会参考现有的、可用的代码。
- en: If we ask whether JavaScript is functional, the answer will be, once again,
    “sorta”. It can be seen as functional because of several features, such as first-class
    functions, anonymous functions, recursion, and closures – we’ll get back to this
    later. On the other hand, it also has plenty of non-FP aspects, such as side effects
    (impurity), mutable objects, and practical limits to recursion. So, when programming
    in a functional way, we’ll be taking advantage of all the relevant, appropriate
    language features, and we’ll try to minimize the problems caused by the more conventional
    parts of the language. In this sense, JavaScript will or won’t be functional,
    depending on your programming style!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们问 JavaScript 是否是函数式的，答案将再次是“有点”。它之所以被视为函数式，是因为它具有一些特性，如一等函数、匿名函数、递归和闭包——我们稍后会回到这一点。另一方面，它也有许多非函数式编程（FP）的方面，如副作用（不纯性）、可变对象和递归的实际限制。因此，当我们以函数式编程的方式编程时，我们将利用所有相关、适当的语言特性，并尝试最小化由语言更传统部分引起的问题。从这个意义上说，JavaScript
    是否是函数式的，将取决于你的编程风格！
- en: If you want to use FP, you should decide which language to use; however, opting
    for fully functional languages may not be so wise. Today, developing code isn’t
    as simple as just using a language; you will surely require frameworks, libraries,
    and other sundry tools. If we can take advantage of all the provided tools but
    at the same time introduce FP ways of working in our code, we’ll be getting the
    best of both worlds, regardless of whether JavaScript is functional!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用函数式编程（FP），你应该决定使用哪种语言；然而，选择完全功能性的语言可能并不那么明智。如今，编写代码并不仅仅是使用一种语言；你肯定需要框架、库和其他各种工具。如果我们能够利用所有提供的工具，同时在我们代码中引入函数式编程的工作方式，我们将能够兼顾两者之长，无论
    JavaScript 是否是函数式的！
- en: Going functional with JavaScript
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 进行函数式编程
- en: 'JavaScript has evolved through the years, and the version we’ll be using is
    (informally) called JS13, and (formally) ECMAScript 2022, usually shortened to
    ES2022 or ES13; this version was finalized in June 2022\. The previous versions
    were as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 经过多年的发展，我们将要使用的是（非正式地）称为 JS13，而（正式地）称为 ECMAScript 2022，通常简称为 ES2022
    或 ES13；这个版本于 2022 年 6 月最终确定。之前的版本如下：
- en: ECMAScript 1, June 1997
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 1，1997 年 6 月
- en: ECMAScript 2, June 1998, which was the same as the previous version, ECMAScript
    3, December 1999, with several new functionalities
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 2，1998 年 6 月，与之前的版本 ECMAScript 3 相同，1999 年 12 月发布，增加了几个新功能
- en: ECMAScript 5, December 2009 (and no, there never was an ECMAScript 4, because
    it was abandoned)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 5，2009 年 12 月（而且，实际上从未有过 ECMAScript 4，因为它被放弃了）
- en: ECMAScript 5.1, June 2011
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 5.1，2011 年 6 月
- en: ECMAScript 6 (or ES6; later renamed ES2015), June 2015 ECMAScript 7 (also ES7,
    or ES2016), June 2016 ECMAScript 8 (ES8 or ES2017), June 2017
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 6（或 ES6；后来更名为 ES2015），2015 年 6 月 ECMAScript 7（也称为 ES7，或 ES2016），2016
    年 6 月 ECMAScript 8（ES8 或 ES2017），2017 年 6 月
- en: ECMAScript 9 (ES9 or ES2018), June 2018
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 9（ES9 或 ES2018），2018 年 6 月
- en: ECMAScript 10 (ES10 or ES2019), June 2019
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 10（ES10 或 ES2019），2019 年 6 月
- en: ECMAScript 11 (ES11 or ES2020), June 2020
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 11（ES11 或 ES2020），2020 年 6 月
- en: ECMAScript 12 (ES12 or ES2021), June 2021
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 12（ES12 或 ES2021），2021 年 6 月
- en: What’s ECMA?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 ECMA？
- en: ECMA originally stood for European Computer Manufacturers Association, but nowadays,
    the name isn’t considered an acronym anymore. The organization is responsible
    for standards other than JavaScript as well, including JSON, C#, Dart, and others.
    For more details, go to its site at [www.ecma-international.org/](http://www.ecma-international.org/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ECMA 最初代表欧洲计算机制造商协会，但如今，这个名字不再被视为首字母缩略词。该组织还负责除 JavaScript 之外的其他标准，包括 JSON、C#、Dart
    等。有关更多详细信息，请访问其网站 [www.ecma-international.org/](http://www.ecma-international.org/)。
- en: You can read the standard language specification at [www.ecma-international.org/publications-and-standards/standards/ecma-262/](http://www.ecma-international.org/publications-and-standards/standards/ecma-262/).
    Whenever we refer to JavaScript in the text without further specification, ES13
    (ES2022) is what is being referred to; however, in terms of the language features
    that are used in this book, if you were just to use ES2015, then you’d mostly
    have no problems with this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [www.ecma-international.org/publications-and-standards/standards/ecma-262/](http://www.ecma-international.org/publications-and-standards/standards/ecma-262/)
    阅读标准的语言规范。当我们在文本中提到 JavaScript 而没有进一步说明时，指的是 ES13（ES2022）；然而，就本书中使用的语言特性而言，如果你只使用
    ES2015，那么你在这本书中遇到的问题将主要不会太多。
- en: No browsers fully implement ES13; most provide an older version, JavaScript
    5 (from 2009), with an (always growing) smattering of features from ES6 up to
    ES13\. This will prove to be a problem, but fortunately, a solvable one; we’ll
    get to this shortly. We’ll be using ES13 throughout this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 没有浏览器完全实现 ES13；大多数提供的是较旧的版本，即 JavaScript 5（2009 年发布），其中包含从 ES6 到 ES13 的（不断增长的）一些特性。这将会成为一个问题，但幸运的是，这是一个可解决的问题；我们很快就会讨论这个问题。本书将使用
    ES13。
- en: Differences, differences…
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 差异，差异……
- en: There are only a few differences between ES2016 and ES2015, such as the `Array.prototype.includes`
    method and the exponentiation operator, `**`. There are more differences between
    ES2017 and ES2016 – such as `async` and `await`, some string padding functions,
    and more – but they won’t impact our code. We will also be looking at alternatives
    for even more modern additions, such as `flatMap()`, in later chapters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ES2016 与 ES2015 之间只有少数差异，例如 `Array.prototype.includes` 方法和对数运算符 `**`。ES2017
    与 ES2016 之间有更多差异——例如 `async` 和 `await`，一些字符串填充函数等——但它们不会影响我们的代码。我们还会在后面的章节中探讨更多现代添加的替代方案，例如
    `flatMap()`。
- en: As we are going to work with JavaScript, let’s start by considering its most
    important features that pertain to our FP goals.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 JavaScript，让我们首先考虑与其函数式编程（FP）目标相关的最重要的特性。
- en: Key features of JavaScript
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 的关键特性
- en: 'JavaScript isn’t a purely functional language, but it has all the features
    that we need for it to work as if it were. The main features of the language that
    we will be using are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 不是一个纯粹的功能性语言，但它拥有我们需要的所有特性，使其能够像功能性语言一样工作。我们将使用的语言的主要特性如下：
- en: Functions as first-class objects
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: Recursion
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Closures
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Arrow functions
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Spread
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开操作
- en: Let’s see some examples of each one and find out why they will be useful to
    us. Keep in mind, though, that there are more features of JavaScript that we will
    be using; the upcoming sections just highlight the most important features in
    terms of what we will be using for FP.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个特性的示例，并找出它们为什么对我们有用。不过，请记住，JavaScript 还有我们将要使用的更多特性；接下来的章节只是突出我们用于函数式编程（FP）的最重要特性。
- en: Functions as first-class objects
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: Saying that functions are **first-class objects** (also called **first-class
    entities** or **first-class citizens**) means that you can do everything with
    functions that you can do with other objects. For example, you can store a function
    in a variable, you can pass it to a function, you can print it out, and so on.
    This is really the key to doing FP; we will often be passing functions as parameters
    (to other functions) or returning a function as the result of a function call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 说函数是 **一等对象**（也称为 **一等实体** 或 **一等公民**）意味着你可以用函数做任何可以用其他对象做的事情。例如，你可以将函数存储在变量中，你可以将其传递给另一个函数，你可以打印它，等等。这实际上是进行函数式编程的关键；我们经常会将函数作为参数（传递给其他函数）或作为函数调用的结果返回。
- en: 'If you have been doing async Ajax calls, then you have already been using this
    feature: a **callback** is a function that will be called after the Ajax call
    finishes and is passed as a parameter. Using jQuery, you could write something
    like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经进行过异步Ajax调用，那么你已经在使用这个特性了：**回调** 是一个在Ajax调用完成后将被调用并作为参数传递的函数。使用jQuery，你可以编写如下内容：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `$.get()` function receives a callback function as a parameter and calls
    it after the result is obtained.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.get()` 函数接收一个回调函数作为参数，并在结果获取后调用它。'
- en: The way to go
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前进的道路
- en: This is better solved, in a more modern way, by using promises or `async`/`await`,
    but for the sake of our example, the old way is enough. We’ll be getting back
    to promises, though, in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building
    Better Containers*, when we discuss monads; in particular, see the *Unexpected
    monads –* *promises* section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好解决，以更现代的方式，通过使用承诺或 `async`/`await`，但为了我们这个例子，旧的方式就足够了。不过，我们将在 [*第12章*](B19301_12.xhtml#_idTextAnchor221)，*构建更好的容器*
    中再次回到承诺，当我们讨论单子时；特别是，请参阅 *意外的单子 –* *承诺* 部分。
- en: 'Since functions can be stored in variables, you could also write something
    like the following. Pay attention to how we use the `doSomething` variable in
    the `$.``get(...)` call:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以存储在变量中，你也可以编写如下内容。请注意我们在 `$.get(...)` 调用中如何使用 `doSomething` 变量：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ll be seeing more examples of this in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第6章*](B19301_06.xhtml#_idTextAnchor107)，*生成函数* 中看到更多这样的例子。
- en: Recursion
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: '**Recursion** is the most potent tool for developing algorithms and a great
    aid for solving large classes of problems. The idea is that a function can, at
    a certain point, call itself and, when *that* call is done, continue working with
    whatever result it has received. This is usually quite helpful for certain classes
    of problems or definitions. The most often quoted example is the factorial function
    (the factorial of *n* is written as *n!*), as defined for nonnegative integer
    values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归** 是开发算法的最强大工具，也是解决大量问题的一个大帮手。其思想是，一个函数可以在某个时刻调用自己，当 *那个* 调用完成后，继续使用它所接收到的任何结果。这通常对某些类的问题或定义非常有帮助。最常引用的例子是阶乘函数（*n*
    的阶乘写作 *n!*），它定义为非负整数值：'
- en: If *n* is 0, then *n*! = 1
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *n* 是 0，那么 *n*! = 1
- en: If *n* is greater than 0, then *n*! = *n* * (*n*-1)!
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *n* 大于 0，那么 *n*! = *n* * (*n*-1)!
- en: Arranging things
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 排列事物
- en: The value of *n!* is the number of ways that you can arrange *n* different elements
    in a row. For example, if you want to place five books in line, you can pick any
    of the five for the first place, and then order the other four in every possible
    way, so 5! = 5*4!. To order those four, you can pick any of them for the first
    place, and then order the other three in every way, so 4! = 4*3!. If you continue
    to work on this example, you’ll end up with 5! = 5*4*3*2*1=120, and in general,
    *n*! is the product of all numbers up to *n*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*n!* 的值是你将 *n* 个不同的元素排列成一行的不同方式数量。例如，如果你想将五本书排成一行，你可以为第一个位置选择任何一本，然后以所有可能的方式排列剩下的四本，所以
    5! = 5*4!。要排列这四本，你可以为第一个位置选择任何一本，然后以所有可能的方式排列剩下的三本，所以 4! = 4*3!。如果你继续这个例子，你将得到
    5! = 5*4*3*2*1=120，并且一般来说，*n*! 是所有不超过 *n* 的数的乘积。'
- en: 'This can be immediately turned into code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以立即转换为代码：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Recursion will be a great aid for designing algorithms. By using recursion,
    you could do without any `while` or `for` loops – not that we want to do that,
    but it’s interesting that we can! We’ll be devoting the entirety of [*Chapter
    9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*, to designing algorithms
    and writing functions recursively.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 递归将是设计算法的一个大帮手。通过使用递归，你可以不用任何 `while` 或 `for` 循环——我们并不想那样做，但有趣的是我们可以做到！我们将把
    [*第9章*](B19301_09.xhtml#_idTextAnchor172)，*设计函数* 的全部内容都用于设计算法和递归编写函数。
- en: Closures
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closures are a way to implement data hiding (with private variables), which
    leads to modules and other nice features. The key concept of closures is that
    when you define a function, it can refer to not only its local variables but also
    to everything outside of the context of the function. We can write a counting
    function that will keep its `count` using a closure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是实现数据隐藏（使用私有变量）的一种方式，这导致了模块和其他一些很好的特性。闭包的关键概念是，当你定义一个函数时，它不仅可以引用其局部变量，还可以引用函数上下文之外的一切。我们可以编写一个计数函数，它将使用闭包保持其
    `count`：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even after `newCounter()` exits, the inner function still has access to `count`,
    but that variable is not accessible to any other parts of your code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`newCounter()`退出后，内部函数仍然可以访问`count`，但这个变量对代码的其他部分不可访问。
- en: This isn’t a very good example of FP – a function (`nc()`, in this case) isn’t
    expected to return different results when called with the same parameters!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个很好的FP示例——一个函数（在这种情况下是`nc()`）不应该在用相同的参数调用时返回不同的结果！
- en: We’ll find several uses for closures, such as **memoization** (see [*Chapter
    4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, and [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*) and the **module pattern** (see [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, and [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204),
    *Implementing Design Patterns*), among others.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会发现闭包有几种用途，例如**记忆化**（见[*第4章*](B19301_04.xhtml#_idTextAnchor069)，*行为规范*，以及[*第6章*](B19301_06.xhtml#_idTextAnchor107)，*生成函数*）和**模块模式**（见[*第3章*](B19301_03.xhtml#_idTextAnchor054)，*从函数开始*，以及[*第11章*](B19301_11.xhtml#_idTextAnchor204)，*实现设计模式*），等等。
- en: Arrow functions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 箭头函数
- en: '`(parameter, anotherparameter, ...etc) => { statements }` or `(parameter, anotherparameter,
    ...etc) => expression`. The first allows you to write as much code as you want,
    while the second is short for `{ return expression }`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`(parameter, anotherparameter, ...etc) => { statements }` 或 `(parameter, anotherparameter,
    ...etc) => expression`。前者允许你编写尽可能多的代码，而后者是 `{ return expression }` 的简写。'
- en: 'We could rewrite our earlier Ajax example as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将之前的Ajax示例重写如下：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A new version of the factorial code could be like the following code – the
    only difference is the usage of an arrow function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因子代码的新版本可能如下——唯一的区别是使用了箭头函数：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Functions, anonymous
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，匿名
- en: Arrow functions are usually called anonymous functions because of their lack
    of a name. If you need to refer to an arrow function, you’ll have to assign it
    to a variable or object attribute, as we did here; otherwise, you won’t be able
    to use it. We’ll learn more about this in the *Arrow functions – the modern way*
    section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out* *with
    Functions*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数通常被称为匿名函数，因为它们没有名字。如果你需要引用箭头函数，你必须将其分配给变量或对象属性，就像我们在这里做的那样；否则，你将无法使用它。我们将在[*第3章*](B19301_03.xhtml#_idTextAnchor054)*，*从函数开始*中的*箭头函数——现代方式*部分了解更多。
- en: 'You would probably write `fact2()` as a one-liner – can you see the equivalence
    to our earlier code? Using a ternary operator instead of `if` is quite common:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会将 `fact2()` 写成一行代码——你能看到与我们之前代码的等价性吗？使用三元运算符代替 `if` 是相当常见的：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this shorter form, you don’t have to write `return` – it’s implied.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种更简短的形式，你不需要写`return`，它是隐含的。
- en: Functions – the lambda way
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 函数——lambda方式
- en: In lambda calculus, a function such as *x* => 2**x* would be represented as
    λ*x.*2**x*. Although there are syntactical differences, the definitions are analogous.
    Functions with more parameters are a bit more complicated; (*x,y*)=>*x*+*y* would
    be expressed as λ*x*.λ*y*.*x*+*y*. We’ll learn more about this in the *Of lambdas
    and functions* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054), *Starting
    Out with Functions*, and in the *Currying* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*,*
    *Transforming Functions*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda演算中，一个如 *x* => 2**x* 的函数会被表示为 λ*x.*2**x*。尽管存在语法上的差异，但定义是相似的。具有更多参数的函数稍微复杂一些；（*x,y*）=>*x*+*y*
    会表示为 λ*x*.λ*y*.*x*+*y*。我们将在[*第3章*](B19301_03.xhtml#_idTextAnchor054)，*从函数开始*，以及[*第7章*](B19301_07.xhtml#_idTextAnchor128)*，*变换函数*中的*关于lambda和函数*部分了解更多。
- en: 'There’s one other small thing to bear in mind: when the arrow function has
    a single parameter, you can omit the parentheses around it. I usually prefer leaving
    them, but I’ve applied a JavaScript beautifier, *Prettier*, to the code, which
    removes them. It’s really up to you whether to include them or not! (For more
    on this tool, check out [github.com/prettier/prettier](http://github.com/prettier/prettier).)
    By the way, my options for formatting were `--print-width 75 -- tab-width` `2
    --no-bracket-spacing`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点需要注意：当箭头函数只有一个参数时，你可以省略其周围的括号。我通常喜欢保留它们，但我已经应用了一个JavaScript美化器，*Prettier*，来美化代码，它会移除它们。是否包含它们完全取决于你！（有关此工具的更多信息，请参阅[github.com/prettier/prettier](http://github.com/prettier/prettier)。）顺便说一句，我的格式化选项是`--print-width
    75 -- tab-width 2 --no-bracket-spacing`。
- en: Spread
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开
- en: 'The spread `...` operator (see [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator))
    lets you expand an expression in places where you would otherwise require multiple
    arguments, elements, or variables. For example, you can replace arguments in a
    function call, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符`...`（见[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator)）允许你在需要多个参数、元素或变量的地方展开一个表达式。例如，你可以替换函数调用中的参数，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also create or join arrays, as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建或连接数组，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It works with objects too:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它也适用于对象：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also use it to work with functions that expect separate parameters
    instead of an array. Common examples of this would be `Math.min()` and `Math.max()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用它来处理期望单独参数而不是数组的函数。常见的例子包括`Math.min()`和`Math.max()`：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are specifying that `maxArray()` shall receive an array of numbers as an
    argument.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`maxArray()`应该接收一个数字数组作为参数。
- en: 'You can also write the following equality since the `.apply()` method requires
    an array of arguments, but `.call()` expects individual arguments, which you can
    get by spreading:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以写出以下等式，因为`.apply()`方法需要一个参数数组，但`.call()`期望单独的参数，你可以通过展开来获取：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A mnemonic for arguments
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的助记符
- en: 'If you have problems remembering what arguments are required by `.apply()`
    and `.call()`, this mnemonic may help: *A is for Array, and C is for Comma*. See
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
    for more information.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记不住`.apply()`和`.call()`需要哪些参数，这个助记符可能有所帮助：*A代表Array（数组），C代表Comma（逗号）*。更多信息请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)和[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)。
- en: Using the spread operator helps with writing shorter, more concise code, and
    we will be taking advantage of it. We have seen all of the most important JavaScript
    features that we will be using. Let’s round off this chapter by looking at some
    tools that we’ll be working with.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用展开运算符有助于编写更短、更简洁的代码，我们将充分利用它。我们已经看到了我们将要使用的所有最重要的JavaScript特性。让我们通过查看我们将要使用的工具来结束这一章。
- en: How do we work with JavaScript?
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何使用JavaScript？
- en: This is all well and good, but as we mentioned before, it so happens that the
    JavaScript version available almost everywhere isn’t ES13, but rather the earlier
    JS5\. An exception to this is Node.js. It is based on Chrome’s V8 high-performance
    JavaScript engine, which already has several ES13 features available. Nonetheless,
    at the time of writing, ES13 coverage isn’t 100% complete, and there are features
    that you will miss. (Check out [nodejs.org/en/docs/es6/](http://nodejs.org/en/docs/es6/)
    for more on Node.js and v8.) This is surely changing since Internet Explorer is
    fading away (support for it ended in June 2022), having been replaced with Microsoft’s
    Edge browser, which shares Chrome’s engine. In any case, we must still deal with
    older, less powerful engines.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很不错，但正如我们之前提到的，实际上几乎到处可用的JavaScript版本并不是ES13，而是更早的JS5。一个例外是Node.js。它基于Chrome的V8高性能JavaScript引擎，该引擎已经提供了几个ES13特性。然而，在撰写本文时，ES13的覆盖范围并不是100%完整，并且有一些特性你会错过。（更多信息请查看[nodejs.org/en/docs/es6/](http://nodejs.org/en/docs/es6/)关于Node.js和v8。）由于Internet
    Explorer正在淡出（其支持已于2022年6月结束），已被Microsoft的Edge浏览器取代，后者与Chrome共享引擎，所以这一切都在改变。无论如何，我们仍然必须处理较旧、功能较弱的引擎。
- en: 'If you want to be sure of your choices before using any given new feature,
    check out the compatibility table at [kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    (see *Figure 1**.1*):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用任何给定的新特性之前想要确保你的选择是正确的，请查看[kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)上的兼容性表格（见*图1.1*）。
- en: '![Figure 1.1 – The latest JavaScript features may not be widely and fully supported,
    so you’ll have to check before using them](img/Figure_1.1_B19301.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 最新JavaScript特性可能并不被广泛和完全支持，所以在使用之前请检查](img/Figure_1.1_B19301.jpg)'
- en: Figure 1.1 – The latest JavaScript features may not be widely and fully supported,
    so you’ll have to check before using them
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 最新 JavaScript 功能可能并不广泛和完全支持，所以在使用之前您需要检查
- en: 'For Node.js specifically, check out [node.green/](http://node.green/), which
    takes its data from the Kangax table; see *Figure 1**.2*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Node.js 而言，请查看 [node.green/](http://node.green/)，它从 Kangax 表格中获取数据；参见 *图
    1.2*：
- en: '![Figure 1.2 – Compatibility table specifically for Node.js](img/Figure_1.2_B19301.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 专门针对 Node.js 的兼容性表格](img/Figure_1.2_B19301.jpg)'
- en: Figure 1.2 – Compatibility table specifically for Node.js
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 专门针对 Node.js 的兼容性表格
- en: So, what can you do if you want to code using the latest version, but the available
    one is an earlier, poorer one? Or what happens if most of your users are using
    older browsers, which don’t support the fancy features you’re keen on using? Let’s
    see some solutions for this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果您想使用最新版本的代码，但可用的版本是较早的、功能较差的版本，您能做什么呢？或者，如果大多数用户都在使用不支持您热衷使用的花哨功能的旧浏览器，会发生什么呢？让我们看看一些解决方案。
- en: Using transpilers
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用转换器
- en: To get out of this availability and compatibility problem, there are a couple
    of transpilers that you can use. Transpilers take your original ES13 code, which
    might use the most modern JavaScript features, and transforms it into equivalent
    JS5 code. It’s a source-to-source transformation, instead of source-to-object
    code that would be used in compilation. You can code using advanced ES13 features,
    but the user’s browsers will receive JS5 code. A transpiler will also let you
    keep up with upcoming versions of the language, despite the time needed by browsers
    to adopt new standards across desktop and mobile devices.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要摆脱这种可用性和兼容性问题，有几个转换器您可以使用。转换器会将您的原始 ES13 代码（可能使用最现代的 JavaScript 功能）转换成等效的 JS5
    代码。这是一种源到源转换，而不是在编译中使用的源到对象代码。您可以使用高级的 ES13 功能，但用户的浏览器将接收 JS5 代码。转换器还将让您跟上语言即将推出的版本，尽管浏览器需要时间在桌面和移动设备上采用新标准。
- en: On word origins
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关于词源
- en: 'If you wonder where the word *transpiler* came from, it is a portmanteau of
    *translate* and *compiler*. There are many such combinations in technological
    speak: *email* (*electronic* and *mail*), *emoticon* (*emotion* and *icon*), *malware*
    (*malicious* and *software*), *alphanumeric* (*alphabetic* and *numeric*), and
    many more.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道“转换器”这个词是从哪里来的，它是由“translate”（翻译）和“compiler”（编译器）组合而成的。在技术术语中有很多这样的组合：*email*（电子和邮件）、*emoticon*（情感和图标）、*malware*（恶意和软件）、*alphanumeric*（字母数字），等等。
- en: Currently, the most common transpiler for JavaScript is **Babel** ([babeljs.io/](http://babeljs.io/));
    years ago, we also had **Traceur** ([github.com/google/traceur-compiler](http://github.com/google/traceur-compiler)),
    but that’s not maintained any longer. Two other possibilities are **SWC** ([swc.rs/](http://swc.rs/))
    and **Sucrase** ([sucrase.io/](http://sucrase.io/)); in particular, the latter
    boasts a much faster transpilation speed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，最常用的 JavaScript 转换器是 **Babel** ([babeljs.io/](http://babeljs.io/))；几年前，我们还有
    **Traceur** ([github.com/google/traceur-compiler](http://github.com/google/traceur-compiler))，但现在不再维护了。其他两种可能性是
    **SWC** ([swc.rs/](http://swc.rs/)) 和 **Sucrase** ([sucrase.io/](http://sucrase.io/))；特别是后者拥有更快的转换速度。
- en: 'With tools such as **npm** or **webpack**, it’s fairly easy to configure things
    so that your code will get automatically transpiled and provided to end users.
    You can also carry out transpilation online; see *Figure 1**.3* for an example
    of Babel’s online environment:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **npm** 或 **webpack** 等工具，配置代码以便自动转换并提供给最终用户相对容易。您还可以在线进行转换；参见 *图 1.3* 中的
    Babel 在线环境示例：
- en: '![Figure 1.3 – The Babel transpiler converts ES13 code into compatible JS5
    code](img/Figure_1.3_B19301.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – Babel 转换器将 ES13 代码转换为兼容的 JS5 代码](img/Figure_1.3_B19301.jpg)'
- en: Figure 1.3 – The Babel transpiler converts ES13 code into compatible JS5 code
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – Babel 转换器将 ES13 代码转换为兼容的 JS5 代码
- en: There are specific ways of installing these tools for your programming environment,
    and usually, you won’t have to do it by hand; check out [www.typescriptlang.org/download](http://www.typescriptlang.org/download)
    for more information.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的编程环境安装这些工具有特定的方法，通常您不需要手动操作；更多信息请查看 [www.typescriptlang.org/download](http://www.typescriptlang.org/download)。
- en: Working online
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在线工作
- en: 'There are some more online tools that you can use to test out your JavaScript
    code. Check out **JSFiddle** ([jsfiddle.net/](http://jsfiddle.net/)), **CodePen**
    ([codepen.io/](http://codepen.io/)), and **JSBin** ([jsbin.com/](http://jsbin.com/)),
    among others. You can see an example of CodePen in *Figure 1**.4*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些在线工具可以帮助你测试你的 JavaScript 代码。查看 **JSFiddle** ([jsfiddle.net/](http://jsfiddle.net/))、**CodePen**
    ([codepen.io/](http://codepen.io/)) 和 **JSBin** ([jsbin.com/](http://jsbin.com/))
    等工具。你可以在 *图 1.4* 中看到一个 CodePen 的例子：
- en: '![Figure 1.4 – CodePen lets you try out modern JavaScript code (plus HTML and
    CSS) without requiring any other tools](img/Figure_1.4_B19301.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – CodePen 允许你尝试现代 JavaScript 代码（包括 HTML 和 CSS），无需其他任何工具](img/Figure_1.4_B19301.jpg)'
- en: Figure 1.4 – CodePen lets you try out modern JavaScript code (plus HTML and
    CSS) without requiring any other tools
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – CodePen 允许你尝试现代 JavaScript 代码（包括 HTML 和 CSS），无需其他任何工具
- en: Using these tools provides a very quick way to try out code or do small experiments
    – and I can truly vouch for this since I’ve tested much of the code in this book
    in this way!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具提供了一种非常快速的方式来尝试代码或进行小实验 – 我确实可以为此作证，因为我已经用这种方式测试了本书中的大部分代码！
- en: A step further – TypeScript
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再进一步 – TypeScript
- en: In the previous editions of this book, we went with straight JavaScript. Still,
    in the years since, Microsoft’s **TypeScript** ([www.typescriptlang.org/](http://www.typescriptlang.org/)),
    a superset of the language that is itself compiled into JavaScript, has gained
    a lot of following, is now standard with many frameworks, and you can use both
    for frontend and backend code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几版中，我们使用了纯 JavaScript。然而，自那以后，微软的 **TypeScript** ([www.typescriptlang.org/](http://www.typescriptlang.org/))，作为自身编译成
    JavaScript 的语言的超集，已经获得了大量的追随者，现在已成为许多框架的标准，并且你可以用于前端和后端代码。
- en: 'The main advantage of TypeScript is the ability to add (optional) static type
    checks to JavaScript, which helps detect programming errors at compile time. But
    beware: as with Babel, not all of ES13 will be available. However, it’s entirely
    sufficient for our purposes, allowing us to be more careful with coding.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的主要优势是能够为 JavaScript 添加（可选的）静态类型检查，这有助于在编译时检测编程错误。但请注意：与 Babel 一样，并非所有
    ES13 的功能都将可用。然而，对于我们来说，这已经足够了，使我们能够更加谨慎地进行编码。
- en: 'Most statistics about programming language popularity rank TypeScript in the
    top 10; *Figure 1**.5* (from [spectrum.ieee.org/top-programming-languages-2022](http://spectrum.ieee.org/top-programming-languages-2022))
    confirms this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关于编程语言流行度的统计数据都将 TypeScript 排在前十名；*图 1.5*（来自 [spectrum.ieee.org/top-programming-languages-2022](http://spectrum.ieee.org/top-programming-languages-2022)）证实了这一点：
- en: '![Figure 1.5 – Programming language popularity in 2022 according to IEEE Spectrum](img/Figure_1.5_B19301.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 根据 IEEE Spectrum 的 2022 年编程语言流行度](img/Figure_1.5_B19301.jpg)'
- en: Figure 1.5 – Programming language popularity in 2022 according to IEEE Spectrum
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 根据 IEEE Spectrum 的 2022 年编程语言流行度
- en: Going to the source
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 追根溯源
- en: Despite using TypeScript, in the rest of this book, we’ll keep referring to
    JavaScript, which is, after all, the language that is executed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用了 TypeScript，但在本书的其余部分，我们仍将参考 JavaScript，毕竟这是被执行的语言。
- en: You can also perform type checks by using Facebook’s **Flow** ([flow.org/](http://flow.org/)).
    However, there’s more support for using external libraries with TypeScript than
    with Flow. Also, the tooling and installation for development are simpler for
    TypeScript.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 Facebook 的 **Flow** ([flow.org/](http://flow.org/)) 来执行类型检查。然而，与 Flow
    相比，TypeScript 在使用外部库方面有更多的支持。此外，TypeScript 的工具和开发安装更为简单。
- en: Ignoring types?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略类型？
- en: There’s a proposal (that may go nowhere – be warned!) to allow JavaScript to
    process (by ignoring) types, so you would be able to run TypeScript directly,
    with no preprocessing or transpiling of any kind. For more on this, go to [tc39.es/proposal-type-annotations/](http://tc39.es/proposal-type-annotations/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个提议（可能不会实现 – 提醒您！）允许 JavaScript 通过忽略类型来处理，这样你就可以直接运行 TypeScript，而不需要进行任何预处理或转换。有关更多信息，请访问
    [tc39.es/proposal-type-annotations/](http://tc39.es/proposal-type-annotations/)。
- en: It should be made clear that TypeScript is more than just a type checker; it’s
    a language on its own (OK, it's very similar to JavaScript, but still…). For example,
    it adds interfaces, decorators, enumerated types, and more to the language, so
    you can use such features that are typical in other languages. In any case, if
    you don’t care for TypeScript, you can just ignore the types-related syntax, and
    then you’ll have plain JavaScript.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 应该明确的是，TypeScript 不仅仅是一个类型检查器；它是一门语言（好吧，它非常类似于 JavaScript，但仍然……）。例如，它为语言添加了接口、装饰器、枚举类型等，因此你可以使用在其他语言中典型的这些特性。无论如何，如果你不关心
    TypeScript，你只需忽略类型相关的语法，那么你将拥有纯 JavaScript。
- en: 'TypeScript is available via online tools, and you can also test it online on
    their playground ([www.typescriptlang.org/play/](http://www.typescriptlang.org/play/)).
    You can set options to be more or less strict with data type checks, and you can
    also run your code on the spot; see *Figure 1**.6* for more details:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 可通过在线工具获得，你还可以在他们的游乐场中在线测试它（[www.typescriptlang.org/play/](http://www.typescriptlang.org/play/))。你可以设置选项以对数据类型检查进行更严格或更宽松的处理，并且你还可以立即运行你的代码；请参阅*图
    1**.6*以获取更多详细信息：
- en: '![Figure 1.6 – You can check and transpile your code online, on TypeScript’s
    website](img/Figure_1.6_B19301.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 你可以在 TypeScript 的网站上在线检查和转译你的代码](img/Figure_1.6_B19301.jpg)'
- en: Figure 1.6 – You can check and transpile your code online, on TypeScript’s website
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 你可以在 TypeScript 的网站上在线检查和转译你的代码
- en: Later in this book, in the *Specifying data types* section of [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, we will consider a formal type system for FP languages
    (not just JavaScript) and we’ll find out that our TypeScript work has allayed
    most difficulties.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，在[*第 12 章*](B19301_12.xhtml#_idTextAnchor221) *构建更好的容器*的*指定数据类型*部分，我们将考虑函数式编程语言的正式类型系统（不仅仅是
    JavaScript），并且我们会发现我们的 TypeScript 工作已经消除了大多数困难。
- en: 'A final admission: at times, TypeScript may seem more of a hindrance than a
    help when you have to deal with complex data typing expressions. (Updating all
    the code in this book to TypeScript sometimes led me to doubt my sanity in using
    it!) However, in the long run, code written in TypeScript is less prone to bugs,
    because its static type checks detect and avoid many common errors.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的坦白：有时，当你必须处理复杂的数据类型表达式时，TypeScript 可能看起来更像是一种阻碍而不是一种帮助。（将本书中的所有代码更新为 TypeScript
    有时让我怀疑自己使用它的理智！）然而，从长远来看，用 TypeScript 编写的代码更不容易出错，因为它的静态类型检查可以检测并避免许多常见错误。
- en: Testing
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: We will also touch on testing, which is, after all, one of FP’s main advantages.
    In previous editions of this book, we went with **Jasmine** ([jasmine.github.io/](http://jasmine.github.io/)),
    but now, we’ve changed to Facebook’s **Jest** ([jestjs.io/](http://jestjs.io/))
    – which is built on top of Jasmine!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涉及测试，毕竟，测试是函数式编程的主要优势之一。在本书的前几版中，我们使用了**Jasmine** ([jasmine.github.io/](http://jasmine.github.io/))，但现在，我们已经改为使用
    Facebook 的**Jest** ([jestjs.io/](http://jestjs.io/)) – 它建立在 Jasmine 之上！
- en: 'Jest has grown in popularity due to its ease of use and broad applicability:
    you can test frontend and backend code equally well, with little configuration.
    (See [jestjs.io/docs/getting-started](http://jestjs.io/docs/getting-started) for
    its installation and configuration.) We won’t be writing tests for every single
    piece of code in this book, but while following the ideas of **test-driven development**
    (**TDD**), we’ll often do so.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 由于其易用性和广泛适用性而越来越受欢迎：你可以同样好地测试前端和后端代码，配置很少。（有关其安装和配置，请参阅[jestjs.io/docs/getting-started](http://jestjs.io/docs/getting-started)。）我们不会为本书中的每一块代码编写测试，但在遵循**测试驱动开发**（**TDD**）的思想时，我们通常会这样做。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen the basics of FP, a bit of its history, its advantages
    (and also some possible disadvantages, to be fair), why we can apply it in JavaScript
    (which isn’t usually considered a functional language), and what tools we’ll need
    to go through the rest of this book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了函数式编程的基础、它的一些历史、它的优势（以及一些可能的劣势，公平地说），为什么我们可以在 JavaScript（这通常不被认为是函数式语言）中应用它，以及我们完成本书剩余部分所需哪些工具。
- en: In [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*,
    we’ll go over an example of a simple problem, look at it in common ways, and end
    by solving it in a functional manner and analyzing the advantages of our method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B19301_02.xhtml#_idTextAnchor037) *函数式思考*中，我们将讨论一个简单问题的例子，以常见的方式审视它，并以函数式的方式解决它，并分析我们方法的优势。
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '1.1 **TypeScript, please!** Let’s keep our promise: convert the JavaScript
    examples provided in this chapter into TypeScript.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 **TypeScript，请！** 让我们遵守承诺：将本章提供的JavaScript示例转换为TypeScript。
- en: '1.2 **Classes as first-class objects**: We learned that functions are first-class
    objects, but did you know that classes also are? (Though, of course, speaking
    of classes as objects does sound weird.) Look at the following example and see
    what makes it tick! Be careful: there’s some purposefully weird code in it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 **类作为一等对象**：我们了解到函数是一等对象，但你是否知道类也是一等对象？（尽管，当然，将类称为对象听起来有点奇怪。）看看下面的例子，看看是什么让它运转！请注意：里面有一些故意写得很奇怪的代码：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '1.3 **Climbing factorial**: Our implementation of a factorial starts by multiplying
    by *n*, then by *n*-1, then *n*-2, and so on in what we could call a downward
    fashion. Can you write a new version of the factorial function that will loop
    upwards?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 **递减阶乘**：我们实现阶乘的方法是从乘以 *n* 开始，然后是 *n*-1，然后是 *n*-2，以此类推，这可以称为递减方式。你能编写一个新的阶乘函数，使其向上循环吗？
- en: '1.4 **Factorial errors**: Factorials, as we defined them, should only be calculated
    for non-negative integers. However, the function that we wrote in the *Recursion*
    section doesn’t check whether its argument is valid. Can you add the necessary
    checks? Try to avoid repeated, redundant tests!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 **阶乘错误**：根据我们的定义，阶乘只应该对非负整数进行计算。然而，我们在 *递归* 部分编写的函数并没有检查其参数是否有效。你能添加必要的检查吗？尽量避免重复和冗余的测试！
- en: '1.5 **Factorial testing**: Write complete tests for the function in the previous
    question. Try to achieve 100% coverage.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5 **阶乘测试**：为上一题中的函数编写完整的测试。尽量达到100%的覆盖率。
- en: 1.6 `newCounter()` to half its length. Can you see how?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6 将 `newCounter()` 缩短到一半。你能看到如何做到吗？
- en: 1.7 `newCounter()` function?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7 `newCounter()` 函数？
