- en: Colors, Depth Testing, and Alpha Blending
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色、深度测试和alpha混合
- en: In the previous chapter, we covered global versus local transformations, matrix
    stacks, animation timers, and various interpolation techniques. In this chapter,
    we start by examining how colors are structured and handled in WebGL and ESSL.
    We will discuss the use of colors in objects, lights, and scenes. Then, we will
    see how WebGL leverages the depth buffer for object occlusion when one object
    is in front of another, blocking it from view. Lastly, we will cover alpha blending,
    which allows us to combine the colors of objects when one is occluding the other,
    while also allowing us to create translucent objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了全局与局部变换、矩阵栈、动画计时器和各种插值技术。在本章中，我们首先检查颜色在WebGL和ESSL中的结构和处理方式。我们将讨论在对象、光源和场景中使用颜色。然后，我们将看到WebGL如何利用深度缓冲区来处理当一个对象在另一个对象前面时，遮挡另一个对象的情况。最后，我们将介绍alpha混合，它允许我们在一个对象遮挡另一个对象时组合对象的颜色，同时也允许我们创建半透明对象。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using colors in objects.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象中使用颜色。
- en: Assigning colors to light sources.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为光源分配颜色。
- en: Working with several light sources in the ESSL program.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ESSL程序中处理多个光源。
- en: Learning how to use the depth test and the z-buffer.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用深度测试和z缓冲区。
- en: Learning how to blend functions and equations.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用混合函数和方程。
- en: Creating transparent objects with face-culling.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用面剔除创建透明对象。
- en: Using Colors in WebGL
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WebGL中使用颜色
- en: 'WebGL supplies a fourth attribute to the RGB model. This attribute is called
    the **alpha channel**. The extended model then is known as the **RGBA** model,
    where A stands for alpha. The alpha channel contains a value between the range
    of `0.0` to `1.0`, just like the other three channels (red, green, and blue).
    The following diagram shows the RGBA color space. On the horizontal axis, you
    can see the different colors that can be obtained by combining the `R`, `G`, and
    `B` channels. The vertical axis corresponds to the alpha channel:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL为RGB模型提供了第四个属性。这个属性被称为**alpha通道**。扩展后的模型被称为**RGBA**模型，其中A代表alpha。alpha通道包含一个介于`0.0`到`1.0`之间的值，就像其他三个通道（红色、绿色和蓝色）一样。以下图表显示了RGBA颜色空间。在水平轴上，你可以看到通过组合`R`、`G`和`B`通道可以获得的不同颜色。垂直轴对应于alpha通道：
- en: '![](img/704d0e52-ba79-4864-b414-e77852adb878.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/704d0e52-ba79-4864-b414-e77852adb878.png)'
- en: The alpha channel carries extra information about a color. This information
    affects the way the color is rendered on the screen. In most cases, the alpha
    value will refer to the amount of opacity that the color contains. A completely
    opaque color will have an alpha value of `1.0`, whereas a completely transparent
    color will have an alpha value of `0.0`. This is the general case, but as we will
    see, we need to take other factors into account when we obtain translucent colors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: alpha通道携带有关颜色的额外信息。这些信息会影响颜色在屏幕上的渲染方式。在大多数情况下，alpha值将表示颜色包含的不透明度。完全不透明的颜色将具有`1.0`的alpha值，而完全透明的颜色将具有`0.0`的alpha值。这是一般情况，但正如我们将看到的，当我们获得半透明颜色时，我们需要考虑其他因素。
- en: Transparent Versus Translucent
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 透明与半透明
- en: Glass, for example, is transparent to all visible light. Translucent objects
    allow some light to travel through them. Materials such as frosted glass and some
    plastics are called translucent. When light strikes translucent materials, only
    some of the light passes through them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，玻璃对所有可见光都是透明的。半透明对象允许一些光通过它们。像磨砂玻璃和一些塑料这样的材料被称为半透明。当光线击中半透明材料时，只有一部分光线通过它们。
- en: 'We use colors everywhere in our WebGL 3D scenes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的WebGL 3D场景中到处使用颜色：
- en: '**Objects**: 3D objects can be colored by selecting one color for every pixel
    (fragment) or by selecting the color that the object will have based on the material''s
    diffuse property.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：3D对象可以通过为每个像素（片段）选择一个颜色或根据材料的漫反射属性选择对象将具有的颜色来进行着色。'
- en: '**Lights**: Even though we have been using white lights, there is no reason
    we can''t have lights whose ambient or diffuse properties contain other colors.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光源**：尽管我们一直在使用白光，但我们没有理由不能有环境或漫反射属性包含其他颜色的光源。'
- en: '**Scene**: The background of our scene has a color that we can change by calling
    `gl.clearColor`. Also, as we will see later on, there are special operations that
    need to be performed on objects'' colors to achieve translucent effects.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**：我们场景的背景有一个颜色，我们可以通过调用`gl.clearColor`来改变它。此外，正如我们稍后将会看到的，需要对对象的颜色执行特殊操作以实现半透明效果。'
- en: Use of Color in Objects
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象中颜色的使用
- en: As earlier chapters have addressed, the final color of a pixel is assigned in
    the fragment shader by setting an out ESSL variable. If all the fragments in the
    object have the same color, we can say the object has a constant color. Otherwise,
    the object is generally understood as having per-vertex color.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，像素的最终颜色是通过设置一个输出 ESSL 变量在片段着色器中分配的。如果一个对象中的所有片段具有相同的颜色，我们可以说该对象具有恒定颜色。否则，该对象通常被认为是具有顶点颜色。
- en: Constant Coloring
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恒定着色
- en: To obtain a constant color, we store the desired color in a uniform that is
    passed to the fragment shader. This uniform is usually called the object's **diffuse
    material property**. We can also combine object normals and light-source information
    to obtain a Lambert coefficient. We can use the Lambert coefficient to proportionally
    change the reflecting color depending on the angle on which the light hits the
    object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得恒定颜色，我们将所需颜色存储在一个传递到片段着色器的统一变量中。这个统一变量通常被称为对象的**漫反射材料属性**。我们还可以结合对象法线和光源信息来获取朗伯系数。我们可以使用朗伯系数按比例改变反射颜色，这取决于光线击中物体的角度。
- en: 'As the following diagram demonstrates, we lose depth perception when we do
    not use information about the normals to obtain a Lambert coefficient. Please
    note that we are using a diffusive lighting model:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，当我们不使用关于法线的信息来获取朗伯系数时，我们会失去深度感知。请注意，我们正在使用扩散光照模型：
- en: '![](img/7ae4717b-fd2b-48e5-b0b3-42c9dc57f24a.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ae4717b-fd2b-48e5-b0b3-42c9dc57f24a.png)'
- en: Per-Vertex Coloring
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点着色
- en: In medical and engineering visualization applications, it is common to find
    color maps that are associated with the vertices of the models we are rendering.
    These maps assign each vertex a color depending on its scalar value. An example
    of this idea includes the temperature charts that indicate cold temperatures as
    blue, and hot temperatures as red overlaid on a map.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在医疗和工程可视化应用中，我们常常会发现与我们要渲染的模型顶点相关的颜色图。这些图根据每个顶点的标量值分配颜色。这个想法的一个例子包括温度图表，它将蓝色表示为冷温度，将红色表示为热温度，并叠加在地图上。
- en: 'To implement per-vertex coloring, we need to define an attribute that stores
    the color for the vertex in the vertex shader:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现顶点着色，我们需要在顶点着色器中定义一个存储顶点颜色的属性：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The next step is to assign the `aVertexColor` attribute to a varying so that
    it can be passed to the fragment shader. Remember that varyings are automatically
    interpolated. Therefore, each fragment will have a color that is the weighted
    result of its contributing vertices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 `aVertexColor` 属性分配给一个变量，以便它可以传递到片段着色器。记住，变量是自动插值的。因此，每个片段的颜色将是其贡献顶点的加权结果。
- en: If we want our color map to be sensitive to lighting conditions, we can multiply
    each vertex color by the diffuse component of the light. The result is then assigned
    to the varying that will transfer the result to the fragment shader.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的颜色图对光照条件敏感，我们可以将每个顶点颜色乘以光的漫反射分量。然后将结果分配给将要传递结果到片段着色器的变量。
- en: 'The following diagram demonstrates two different possibilities for this case:
    on the left, the vertex color is multiplied by the light diffuse term without
    any weighting from the position of the light; on the right, the Lambert coefficient
    generates the expected shadows and gives information about the relative location
    of the light source:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了这种情况下的两种不同可能性：在左侧，顶点颜色乘以光漫射项，没有来自光位置的加权；在右侧，朗伯系数生成预期的阴影，并提供了光源相对位置的信息：
- en: '![](img/2b06ccc1-13ff-4af5-9c29-3b75e32dd3a1.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b06ccc1-13ff-4af5-9c29-3b75e32dd3a1.png)'
- en: Here, we are using a vertex buffer object that is mapped to the `aVertexColor`
    vertex shader attribute. We learned how to map VBOs in [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml),
    *Rendering*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用一个映射到 `aVertexColor` 顶点着色器属性的顶点缓冲区对象。我们已经在 [第 2 章](d2019a49-9e84-448c-8799-e296187476d1.xhtml)，*渲染*
    中学习了如何映射 VBO。
- en: Per-Fragment Coloring
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段着色
- en: We can also assign a random color to each pixel of the object we are rendering.
    Although ESSL does not have a pre-built random function, there are algorithms
    we can use to generate pseudo-random numbers. That being said, the purpose and
    usefulness of this technique are outside the scope of this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为我们渲染的对象的每个像素分配一个随机颜色。尽管 ESSL 没有预构建的随机函数，但我们可以使用算法来生成伪随机数。但话说回来，这种技术的目的和用途超出了本书的范围。
- en: 'Time for Action: Coloring the Cube'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：给立方体上色
- en: 'Let''s cover a simple example of coloring a geometry:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的着色几何形状的例子：
- en: 'Open the `ch06_01_cube.html` file using your browser. You will see a page similar
    to the following:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的浏览器打开`ch06_01_cube.html`文件。您将看到一个类似于以下页面的页面：
- en: '![](img/401dcbc1-d1ef-4cbd-8df5-8bd4e4a6eac4.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/401dcbc1-d1ef-4cbd-8df5-8bd4e4a6eac4.png)'
- en: 'In this exercise, we’re going to compare constant versus per-vertex coloring.
    Let''s talk about the page''s widgets:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将比较恒定颜色与顶点颜色。让我们谈谈页面的小部件：
- en: 'Lambert: When selected, it will include the Lambert coefficient in the calculation
    of the final color.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambert：当选中时，它将在最终颜色计算中包含Lambert系数。
- en: 'Per Vertex: The two different coloring methods explained before: per-vertex
    or constant.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顶点：之前解释过的两种着色方法：按顶点或恒定。
- en: 'Complex Cube: Loads a JSON object where the vertices are repeated with the
    goal of obtaining multiple normals and multiple colors per vertex. We will explain
    how this works later on.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂立方体：加载一个JSON对象，其中顶点被重复以获得每个顶点的多个法线和多个颜色。我们将在稍后解释这是如何工作的。
- en: 'Alpha Value: This slider is mapped to the `uAlpha` float uniform in the vertex
    shader. `uAlpha` sets the alpha value for the vertex color.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpha值：此滑块映射到顶点着色器中的`uAlpha`浮点统一变量。`uAlpha`设置顶点颜色的alpha值。
- en: 'Disable the use of the Lambert coefficient by clicking on Lambert. Rotate the
    cube by clicking and dragging. Notice the loss of depth perception when the Lambert
    coefficient is not included in the final color calculation. The Lambert button
    is mapped to the `uUseLambert` Boolean uniform. The code that calculates the Lambert
    coefficient can be found in the vertex shader included in the page:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击“Lambert”禁用Lambert系数的使用。通过点击并拖动来旋转立方体。注意当Lambert系数不包括在最终颜色计算中时，深度感知的损失。Lambert按钮映射到`uUseLambert`布尔统一变量。计算Lambert系数的代码可以在页面中包含的顶点着色器中找到：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the `uUseLambert` uniform is `false`, then `lambertTerm` remains as `1.0`,
    not affecting the final diffuse term here:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`uUseLambert`统一变量为`false`，则`lambertTerm`保持为`1.0`，不影响这里的最终漫反射项：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Otherwise, `Id` will have the Lambert coefficient factored in.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，`Id`将包含Lambert系数。
- en: 'Having Lambert disabled, click on the Per Vertex button. Rotate the cube to
    see how ESSL interpolates the vertex colors. The vertex shader key code fragment
    that allows us to switch from a constant diffuse color to per-vertex colors uses
    the `uUseVertexColors` Boolean uniform and the `aVertexColor` attribute. This
    fragment is shown here:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用Lambert后，点击“按顶点”按钮。旋转立方体以查看ESSL如何插值顶点颜色。允许我们从恒定漫反射颜色切换到顶点颜色的顶点着色器键代码片段使用`uUseVertexColors`布尔统一变量和`aVertexColor`属性。此片段在此处显示：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Take a look at the `common/models/geometries/cube-simple.json` file. There,
    the eight vertices of the cube are defined in the vertices array and there is
    an element in the scalars array for every vertex. As you may expect, each one
    of these elements corresponds to a respective vertex color, as shown in the following
    diagram:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`common/models/geometries/cube-simple.json`文件。在那里，立方体的八个顶点在顶点数组中定义，并且对于每个顶点都有一个标量数组中的元素。正如您可能预期的，这些元素中的每一个都对应于相应的顶点颜色，如下所示：
- en: '![](img/736f4d9b-81e0-4180-81ee-f3d13bf0f369.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/736f4d9b-81e0-4180-81ee-f3d13bf0f369.png)'
- en: 'Make sure that the Lambert button is not active and then click on the Complex
    Cube button. By repeating vertices in the vertex array in the corresponding JSON
    file, `common/models/geometries/cube-complex.json`, we can achieve independent
    face-coloring. The following diagram explains how the vertices are organized in
    `cube-complex.json`. Note that as the definition of colors occurs by vertex (since
    we are using the shader attribute), we need to repeat each color four times, because
    each face has four vertices. This idea is depicted in the following diagram:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Lambert按钮未激活，然后点击“复杂立方体”按钮。通过在相应的JSON文件`common/models/geometries/cube-complex.json`中的顶点数组中重复顶点，我们可以实现独立的面着色。以下图表解释了`cube-complex.json`中顶点的组织方式。请注意，由于我们使用着色器属性定义颜色，我们需要重复每个颜色四次，因为每个面有四个顶点。这一想法在以下图表中展示：
- en: '![](img/700279ed-b6ed-45c6-8799-5cdd1b5ea217.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/700279ed-b6ed-45c6-8799-5cdd1b5ea217.png)'
- en: Activate the Lambert button to see how the Lambert coefficient affects the color
    of the object. Try different button configurations to see what happens.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活Lambert按钮以查看Lambert系数如何影响物体的颜色。尝试不同的按钮配置以查看会发生什么。
- en: 'Let''s quickly explore the effect of changing the alpha channel to a value
    less than `1.0`. What do you see? Notice that the object does not become transparent
    but instead starts losing its color. To obtain transparency, we need to activate
    blending. We will discuss blending in depth later in this chapter. For now, uncomment
    these lines in the `configure` function, in the source code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们快速探索将alpha通道更改为小于`1.0`的值的效应。您看到了什么？请注意，对象并没有变得透明，而是开始失去颜色。要获得透明度，我们需要激活混合。我们将在本章的后面深入讨论混合。现在，在`configure`函数的源代码中取消注释这些行： '
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Save the page and reload it in your internet browser. If you select Per-Vertex,
    Complex Cube and reduce the alpha value to `0.5`, you will see something like
    the following screenshot:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存页面并在您的网络浏览器中重新加载。如果您选择顶点着色，复杂立方体并降低alpha值到`0.5`，您将看到以下截图类似的内容：
- en: '![](img/85d1a4d8-b3ee-4108-ab5a-a2aff15d10a3.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85d1a4d8-b3ee-4108-ab5a-a2aff15d10a3.png)'
- en: '***What just happened?***'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: 'We have studied two different ways of coloring objects: **constant coloring**
    and **per-vertex coloring**. In both cases, the final color of each fragment is
    assigned by exporting a color variable via an `out` qualifier in the fragment
    shader.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了两种不同的对象着色方法：**常量着色**和**顶点着色**。在两种情况下，每个片段的最终颜色都是由片段着色器中的`out`限定符导出的颜色变量来指定的。
- en: We saw that by activating the calculation of the Lambert coefficient, we obtain
    sensory depth information.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，通过激活Lambert系数的计算，我们获得了感知深度信息。
- en: We also saw that repeating vertices in our object allows us to obtain different
    coloring effects. For instance, we can color an object by faces instead of by
    vertices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，在我们的对象中重复顶点使我们能够获得不同的着色效果。例如，我们可以通过面而不是顶点来着色一个对象。
- en: Use of Color in Lights
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照中的颜色使用
- en: 'Colors are light properties. In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml),
    *Lights*, we learned that the number of light properties depends on the lighting-reflection
    model selected for a scene. For instance, using a Lambertian reflection model,
    we would only need to model one shader uniform: the light diffuse property/color.
    In contrast, if the Phong reflection model were selected, each light source would
    need to have three properties: the ambient, diffuse, and specular colors.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是光照属性。在第3章中，我们学习了光照属性的数量取决于为场景选择的照明-反射模型。例如，使用Lambertian反射模型，我们只需要建模一个着色器统一变量：光照漫反射属性/颜色。相比之下，如果选择Phong反射模型，每个光源都需要有三个属性：环境光、漫反射和镜面反射颜色。
- en: Positional Lights
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 位置光
- en: 'The light position is usually modeled as a uniform when the shader needs to
    know the position of the light. Therefore, a Phong model with a positional light
    would have four uniforms: ambient, diffuse, specular, and position.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当着色器需要知道光照的位置时，通常将光照位置建模为一个统一变量。因此，具有位置光的光照模型将具有四个统一变量：环境光、漫反射、镜面反射和位置。
- en: For directional lights, the fourth uniform is the light direction. For more
    information, refer to [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml),
    *Lights*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方向光，第四个统一变量是光的方向。更多信息，请参阅[第3章](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml)，*灯光*。
- en: We have seen that each light property is represented by a JavaScript four-element
    array with mappings to `vec4` uniforms in the shaders.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，每个光照属性都由一个映射到着色器中`vec4`统一变量的JavaScript四元素数组表示。
- en: 'As a quick reminder, which WebGL methods should we use to retrieve and set
    a uniform? In our case, the two methods we use to pass lights to the shaders are
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速提醒，我们应该使用哪些WebGL方法来检索和设置统一变量？在我们的情况下，我们用来将光照传递给着色器的两种方法如下：
- en: '`getUniformLocation`: Locates the uniform in the program and returns an index
    we can use to set the value.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUniformLocation`：在程序中定位统一变量并返回一个我们可以用来设置值的索引。'
- en: '`uniform4fv`: Since the light components are RGBA, we need to pass a four-element
    float vector.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniform4fv`：由于光照分量是RGBA，我们需要传递一个四元素浮点向量。'
- en: Scalability Problem
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性问题
- en: Given the desire to use more than one light in our scene, we need to define
    and map the number of appropriate uniforms of the lighting model of choice. If
    we have four properties per light (ambient, diffuse, specular, and location),
    we need to define four uniforms for each light. If we want to have three lights,
    we need to write, use, and map twelve uniforms! We need to resolve this complexity
    before it gets out of hand.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在场景中使用多个灯光，我们需要定义和映射所选光照模型的适当数量的统一变量。如果我们每个灯光有四个属性（环境、漫反射、镜面反射和位置），我们需要为每个灯光定义四个统一变量。如果我们想有三个灯光，我们需要编写、使用和映射十二个统一变量！在问题变得无法控制之前，我们需要解决这个问题。
- en: How Many Uniforms Can We Use?
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以使用多少统一变量？
- en: The OpenGL Shading Language ES specification delineates the number of uniforms
    that we are allowed to use.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL着色语言ES规范定义了我们允许使用的统一变量的数量。
- en: Section 4.3.4 Uniforms
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.3.4节 统一变量
- en: There is an implementation dependent limit on the amount of storage for uniforms
    that can be used for each type of shader. If this is exceeded, it will cause a
    compile-time or link-time error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种着色器类型，可用于统一变量的存储量有一个实现相关的限制。如果超过这个限制，将导致编译时或链接时错误。
- en: 'To find out the limit for your WebGL implementation, you can query WebGL using
    the `gl.getParameter` function with these constants:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出你的WebGL实现的限制，你可以使用`gl.getParameter`函数和这些常量查询WebGL：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The implementation limit is given by your browser and heavily depends on your
    graphics hardware. That said, even though your machine may have enough variable
    space, it does not necessarily mean that the problem is solved. We still have
    to define and map each of the uniforms and that can often lead to brittle and
    verbose code, as we will see in a later exercise.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实现限制由您的浏览器提供，并且很大程度上取决于您的图形硬件。话虽如此，即使您的机器可能有足够的变量空间，这也并不意味着问题已经解决。我们仍然需要定义和映射每个统一变量，这通常会导致脆弱和冗长的代码，正如我们将在后面的练习中看到的。
- en: Simplifying the Problem
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化问题
- en: In order to simplify the problem, we can assume that the ambient component is
    the same for all of the lights. This will reduce the number of uniforms—one fewer
    uniform for each light. However, this is not an extensible solution for more general
    cases where we cannot assume that the ambient light is constant.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们可以假设所有灯光的环境分量是相同的。这将减少统一变量的数量——每个灯光少一个统一变量。然而，这并不是一个适用于更一般情况的扩展解决方案，在这种情况下，我们不能假设环境光恒定。
- en: Before we start diving deeper into our scene with multiple lights, let's update
    our architecture to cover some of the concepts we've addressed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨具有多个灯光的场景之前，让我们更新我们的架构以涵盖我们已解决的一些概念。
- en: Architectural Updates
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构更新
- en: As we progress through this book, we continue to refine our architecture where
    appropriate to reflect what we’ve learned. On this occasion, we will improve how
    we pass uniforms to our program and add support for handling a large number of
    uniforms to define multiple lights.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过这本书的进展，我们继续在适当的地方改进我们的架构，以反映我们所学的知识。在这个场合，我们将改进传递统一变量到程序的方式，并添加支持处理大量统一变量以定义多个灯光。
- en: Adding Support for Light Objects
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对光对象的支持
- en: 'Let''s cover these changes in detail. We have created a new JavaScript module,
    `Lights.js`, that has two objects:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地介绍这些变化。我们创建了一个新的JavaScript模块`Lights.js`，它包含两个对象：
- en: '`Light`: Aggregates light properties (position, diffuse, specular, and so on)
    in a single entity.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Light`：将光属性（位置、漫反射、镜面反射等）聚合在一个单一实体中。'
- en: '`LightsManager`: Contains the lights in our scene. This allows us to retrieve
    each light by `index` or `name`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LightsManager`：包含场景中的灯光。这允许我们通过`index`或`name`检索每个灯光。'
- en: '`LightsManager` also contains the `getArray` method to flatten the arrays of
    properties by type:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`LightsManager`还包含`getArray`方法，通过类型将属性数组扁平化：'
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will be useful when we use uniform arrays later on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们稍后使用统一数组时很有用。
- en: Improving How We Pass Uniforms to the Program
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进传递统一变量到程序的方式
- en: We have also improved the way we pass uniforms to the program. In `configure`,
    we can see how we pass attributes and uniforms to `program.load` rather than manually
    attaching them to the instance like in the introductory chapters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还改进了传递统一变量的方式。在`configure`中，我们可以看到我们是如何将属性和统一变量传递给`program.load`，而不是像在介绍章节中那样手动将它们附加到实例上。
- en: 'The `configure` function is the appropriate place to load the program. We are
    also going to create a dynamic mapping between JavaScript variables and uniforms.
    With this in mind, we have updated the `program.load` method to receive two arrays:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure` 函数是加载程序的适当位置。我们还将创建 JavaScript 变量和统一变量之间的动态映射。考虑到这一点，我们已经更新了 `program.load`
    方法，使其接收两个数组：'
- en: '`attributes`: An array containing the names of the attributes that we will
    map between JavaScript and ESSL.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`：一个数组，包含我们将要在 JavaScript 和 ESSL 之间映射的属性名称。'
- en: '`uniforms`: An array containing the names of the uniforms that we will map
    between JavaScript and ESSL.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniforms`：一个数组，包含我们将要在 JavaScript 和 ESSL 之间映射的统一变量名称。'
- en: 'The implementation of the function now looks as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的实现现在如下所示：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last two lines correspond to the two new functions, `setAttributeLocations`
    and `setUniformLocations`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行对应于两个新函数，`setAttributeLocations` 和 `setUniformLocations`：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, these functions look up the attribute and uniform lists, respectively,
    and then attach the location as a property to the `Program` instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些函数分别查找属性和统一变量列表，然后将位置作为属性附加到 `Program` 实例上。
- en: In short, if we include the `uLightPosition` uniform name in the `uniforms`
    list to be passed to `program.load`, we will then have a `program.uLightPosition`
    property that will contain the location of the respective uniform! Neat!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果我们将 `uLightPosition` 统一变量名称包含在传递给 `program.load` 的 `uniforms` 列表中，那么我们就会有一个
    `program.uLightPosition` 属性，它将包含相应统一变量的位置！真不错！
- en: 'Once we load the program in the `configure` function, we can initialize the
    values of the uniforms immediately with the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 `configure` 函数中加载了程序，我们可以立即使用以下代码初始化统一变量的值：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Time for Action: Adding a Blue Light to a Scene'
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践：向场景添加蓝色光源
- en: We’re ready to take a look at the first example in this chapter. We will work
    on a scene with **per-fragment** lighting that has three light sources.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好查看本章的第一个示例。我们将在一个具有三个光源的**每片段**光照的场景中工作。
- en: 'Each light has a position and a diffuse color property. This means we have
    two uniforms per light. Perform the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个光源都有一个位置和漫反射颜色属性。这意味着每个光源都有两个统一变量。执行以下步骤：
- en: To keep things simple, we have assumed that the ambient color is the same for
    all three light sources. We have also removed the specular property. Open the
    `ch06_02_wall_initial.html` file in your browser.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持简单，我们假设所有三个光源的漫反射颜色相同。我们还去除了镜面反射属性。在您的浏览器中打开 `ch06_02_wall_initial.html`
    文件。
- en: 'You will see a scene such as the one displayed in the following screenshot
    where two lights (red and green) illuminate a black wall:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到如下截图所示的场景，其中两个光源（红色和绿色）照亮了一面黑色墙壁：
- en: '![](img/93aa40c3-3f69-485a-b1e6-247ca3900007.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93aa40c3-3f69-485a-b1e6-247ca3900007.png)'
- en: Open the `ch06_02_wall-initial.html` file using your code editor. We will update
    the vertex shader, the fragment shader, the JavaScript code, and the HTML code
    to add the blue light.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的代码编辑器打开 `ch06_02_wall-initial.html` 文件。我们将更新顶点着色器、片段着色器、JavaScript 代码和 HTML
    代码以添加蓝色光源。
- en: '**Updating the vertex shader**: Go to the vertex shader where you can see these
    two uniforms:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新顶点着色器**：转到可以看到这两个统一变量的顶点着色器：'
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s add the third uniform here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在那里添加第三个统一变量：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to define a varying to carry the interpolated light ray direction
    to the fragment shader. Remember here that we are using per-fragment lighting.
    Check where the varyings are defined:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定义一个变量来携带插值后的光线方向到片段着色器。记住，这里我们使用的是每片段光照。检查变量在哪里定义：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, add the third varying there:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在那里添加第三个变量：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s take a look at the body of the vertex shader. We need to update each
    of the light locations according to our position in the scene. We achieve this
    by writing the following:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看顶点着色器的主体。我们需要根据场景中的位置更新每个光源的位置。我们通过编写以下代码来实现：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the positions for the other two lights are also being calculated.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，其他两个光源的位置也在被计算。
- en: 'Let''s calculate the light ray for the updated position from our blue light
    to the current vertex. We do that by writing the following code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们计算从我们的蓝色光源到当前顶点的光线。我们通过编写以下代码来完成：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That is all we need to modify in the vertex shader.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们需要在顶点着色器中修改的所有内容。
- en: So far, we’ve included a new light position and we have calculated the light
    rays in the vertex shader. These rays will be interpolated by the fragment shader.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经包含了一个新的光源位置，并在顶点着色器中计算了光线。这些光线将由片段着色器进行插值。
- en: 'Let''s work out how the colors on the wall will change by including our new
    blue source of light. Scroll down to the fragment shader and add a new uniform—the
    blue diffuse property. Look for these uniforms declared right before the `main`
    function:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过包含我们新的蓝色光源源来计算墙上颜色的变化。滚动到片段着色器并添加一个新的统一变量——蓝色漫反射属性。查找在`main`函数之前声明的以下统一变量：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Insert the following line of code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入以下行：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To calculate the contribution of the blue light to the final color, we need
    to obtain the light ray we defined previously in the vertex shader. This varying
    is available in the fragment shader. You also need to declare it before the `main`
    function. Look for the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了计算蓝色光源对最终颜色的贡献，我们需要获取在顶点着色器中定义的先前光线。这个变量在片段着色器中可用。您还需要在`main`函数之前声明它。查找以下：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Insert the following code right under it:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其下方插入以下代码：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is assumed that the ambient component is the same for all the lights. This
    is reflected in the code by having only one `uLightAmbient` variable. The ambient
    term, `Ia`, is the product of `uLightAmbient` and the wall''s material ambient
    property:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设所有光源的环境分量都是相同的。这在代码中通过只有一个`uLightAmbient`变量来反映。环境项`Ia`是`uLightAmbient`和墙壁材料环境属性的乘积：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If `uLightAmbient` is set to `(1.0, 1.0, 1.0, 1.0)` and `uMaterialAmbient` is
    set to `(0.1, 0.1, 0.1, 1.0)`, then the resulting ambient term, `Ia`, will be
    really small. This means the contribution of the ambient light will be low in
    this scene. In contrast, the diffuse component will be different for every light.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`uLightAmbient`设置为`(1.0, 1.0, 1.0, 1.0)`且`uMaterialAmbient`设置为`(0.1, 0.1,
    0.1, 1.0)`，则结果环境项`Ia`将非常小。这意味着在这个场景中环境光的影响将很低。相比之下，漫反射分量对每个光源都是不同的。
- en: 'Let''s add the effect of the blue diffuse term. In the fragment shader main
    function, look for the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加蓝色漫反射项的效果。在片段着色器的主函数中，查找以下代码：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following line immediately under it:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其下方立即添加以下行：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Scroll down to the following:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到以下：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following line of code right under it:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其下方添加以下行：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Scroll to the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到以下：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Insert the following code after it:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其后插入以下代码：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Update `fragColor` so that it includes `Id3`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`fragColor`以包含`Id3`：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That''s all we need to do in the fragment shader. Let''s move on to our JavaScript
    code. So far, we have written the code that is needed to handle one more light
    inside our shaders. Let''s see how we create the blue light from the JavaScript
    side and how we map it to the shaders. Scroll down to the `configure` function
    and look for the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是在片段着色器中需要做的所有事情。让我们继续到我们的JavaScript代码。到目前为止，我们已经编写了处理着色器中一个额外光源所需的代码。让我们看看我们如何从JavaScript端创建蓝色光源并将其映射到着色器中。滚动到`configure`函数并查找以下代码：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Insert the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入以下代码：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Scroll to the point where the `uniforms` list is defined. As mentioned earlier,
    this new mechanism makes it easier to obtain locations for the uniforms. Add the
    two new uniforms that we are using for the blue light: `uDiffuseBlueLight` and
    `uPositionBlueLight`. The list should look like the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到定义`uniforms`列表的位置。如前所述，这种新机制使得获取统一变量的位置更容易。添加我们用于蓝色光源的两个新统一变量：`uDiffuseBlueLight`和`uPositionBlueLight`。列表应如下所示：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s pass the position and diffuse values of our newly defined light to `program`.
    Find the following lines, after the line that loads `program`, and make these
    necessary changes:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新定义的光源的位置和漫反射值传递给`program`。在加载`program`的行之后找到以下行，并做出必要的更改：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Uniform Arrays
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 统一数组
- en: Coding one uniform per light makes the code quite verbose. Later on, we will
    cover how to simplify the code using uniform arrays.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个光源使用一个统一的编码会使代码变得相当冗长。稍后我们将介绍如何使用统一数组来简化代码。
- en: 'Let''s update the `load` function. We need a new sphere to represent the blue
    light, the same way we have two spheres in the scene: one for the red light and
    the other for the green light. Append the following line:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新`load`函数。我们需要一个新的球体来表示蓝色光源，就像场景中已经有了两个球体一样：一个用于红色光源，另一个用于绿色光源。添加以下行：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we saw in the `load` function, we are loading the same geometry (sphere)
    three times. To differentiate the sphere that represents the light source, we
    are using local transforms for the sphere (initially centered at the origin).
    Scroll to the `render` function and find the following lines of code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在 `load` 函数中看到的，我们正在加载相同的几何体（球体）三次。为了区分代表光源的球体，我们正在使用球体的局部变换（最初以原点为中心）。滚动到
    `render` 函数并找到以下代码行：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That’s it! Save the page with a different name and test it in your browser:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！将页面保存为不同的名称并在浏览器中测试它：
- en: '![](img/3a945b06-e22f-48aa-8eaa-aae7adc1d908.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a945b06-e22f-48aa-8eaa-aae7adc1d908.png)'
- en: If you do not obtain the expected result, please go back and check the steps.
    You will find the completed exercise in the `ch06_03_wall-final.html` file.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有得到预期的结果，请返回并检查步骤。你可以在 `ch06_03_wall-final.html` 文件中找到完成的练习。
- en: '***What just happened?***'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: 'We have modified our sample scene by adding one more light: a blue light. We
    have updated the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一个额外的灯光：一个蓝色灯光，修改了我们的示例场景。我们更新了以下内容：
- en: The vertex shader
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: The fragment shader
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段着色器
- en: The `configure` function
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure` 函数'
- en: The `load` function
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load` 函数'
- en: The `draw` function
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw` 函数'
- en: As you can see, handling light properties one uniform at a time is not very
    efficient. Later in this chapter, we will study a more effective way to handle
    lights in a WebGL scene.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一次处理一个光属性并不非常高效。在本章的后面部分，我们将研究一种更有效的方法来处理 WebGL 场景中的灯光。
- en: 'Have a Go: Adding Interactivity'
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下：添加交互性
- en: We are going to add an additional slider to our controls widget to interactively
    change the position of the blue light we just added.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向我们的控件小部件添加一个额外的滑块，以交互式地改变我们刚刚添加的蓝色灯光的位置。
- en: We will use **dat.GUI**, one for each one of the blue light coordinates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **dat.GUI**，为每个蓝色光坐标创建一个。
- en: dat.GUI
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: dat.GUI
- en: 'You can find more information about dat.GUI on GitHub: [https://github.com/dataarts/dat.gui](https://github.com/dataarts/dat.gui).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到有关 dat.GUI 的更多信息：[https://github.com/dataarts/dat.gui](https://github.com/dataarts/dat.gui)。
- en: 'Create three sliders: one for the `X` coordinate, one for the `Y` coordinate,
    and a third one for the `Z` coordinate for the blue light.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个滑块：一个用于蓝色光的 `X` 坐标，一个用于 `Y` 坐标，第三个用于 `Z` 坐标。
- en: 'The final GUI should include the new blue light sliders, which should look
    like the following:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的 GUI 应该包括新的蓝色光滑块，它们应该看起来像以下这样：
- en: '![](img/5d92cd7e-8479-404e-ade0-37c642d68ea6.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d92cd7e-8479-404e-ade0-37c642d68ea6.png)'
- en: Use the sliders present in the page to guide your work.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用页面上的滑块来指导你的工作。
- en: You will find the completed exercise in the `ch06_03_wall-final.html` file.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在 `ch06_03_wall-final.html` 文件中找到完成的练习。
- en: Using Uniform Arrays to Handle Multiple Lights
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用均匀数组处理多个灯光
- en: As we've seen, handling light properties with individual uniforms makes the
    code verbose and difficult to maintain. Fortunately, ESSL provides several mechanisms
    we can use to solve the problem of handling multiple lights. One of them is **uniform
    arrays**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，使用单独的均匀量处理光属性使代码冗长且难以维护。幸运的是，ESSL 提供了我们可以用来解决处理多个灯光问题的几个机制。其中之一是 **均匀数组**。
- en: This technique allows us to handle multiple lights by introducing enumerable
    arrays of vectors in the shaders. This allows us to calculate light contributions
    by iterating through the light arrays in the shaders. We still need to define
    each light in JavaScript, but the mapping to ESSL becomes simpler since we aren’t
    defining one uniform per light property. Let's see how this technique works. We
    just need to make two simple changes in our code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通过在着色器中引入可枚举的向量数组，使我们能够处理多个灯光。这允许我们通过在着色器中迭代灯光数组来计算光贡献。我们仍然需要在 JavaScript
    中定义每个灯光，但由于我们不是为每个灯光属性定义一个均匀量，因此将映射到 ESSL 变得更简单。让我们看看这个技术是如何工作的。我们只需要在我们的代码中进行两个简单的更改。
- en: Uniform Array Declaration
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 均匀数组声明
- en: 'First, we need to declare the light uniforms as arrays inside our ESSL shaders.
    For example, the light position that contains three lights would look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的 ESSL 着色器内部声明光均匀数组。例如，包含三个灯光的光位置看起来是这样的：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It’s important to note that ESSL does not support dynamic initialization of
    uniform arrays. We could try something such as this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，ESSL 不支持动态初始化均匀数组。我们可以尝试以下方法：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If so, the shader will not compile, and you will obtain the following error:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，着色器将无法编译，你将获得以下错误：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, this construct is valid:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个结构是有效的：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We declare one uniform array per light property, regardless of how many lights
    we’re going to have. As a result, if we want to pass information about diffuse
    and specular components of five lights, for example, we need to declare two uniform
    arrays, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个灯光属性声明一个统一的数组，无论我们将有多少灯光。因此，如果我们想传递关于五个灯光的漫反射和镜面反射组件的信息，例如，我们需要声明两个统一的数组，如下所示：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: JavaScript Array Mapping
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript数组映射
- en: 'Next, we need to map the JavaScript variables where we have the light property
    information to the program. For example, we may want to map these three light
    positions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将包含灯光属性信息的JavaScript变量映射到程序中。例如，我们可能想要映射这三个灯光位置：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If so, we need to retrieve the uniform array location (just like in any other
    case):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们需要检索统一数组的位置（就像在其他任何情况下一样）：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The one difference is that we map these positions as a concatenated flat array:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于我们将这些位置映射为一个连接的扁平数组：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are two important points here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的点：
- en: The name of the uniform that is passed to `getUniformLocation` is the same as
    before. The fact that `uPositionLight` is now an array does not change a thing
    when you locate the uniform with `getUniformLocation`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`getUniformLocation`的统一变量的名称与之前相同。当使用`getUniformLocation`定位统一变量时，`uPositionLight`现在是一个数组这一事实并没有改变任何事情。
- en: 'The JavaScript array that we are passing to the uniform is a flat array. If
    you write something as follows, the mapping will not work:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们传递给统一的JavaScript数组是一个扁平数组。如果你按照以下方式编写，映射将不会工作：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So, if you have one variable per light, you should ensure that you concatenate
    them before passing them to the shader.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你为每个灯光有一个变量，你应该在将它们传递给着色器之前确保将它们连接起来。
- en: 'Time for Action: Adding a White Light to a Scene'
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间：向场景添加白光
- en: 'Let''s cover an example of how we''d add a new light to our scene:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何向场景中添加一个新灯光的例子：
- en: Open the `ch06_04_wall-light-arrays.html` file in your browser. This scene looks
    exactly like `ch06_03_wall-final.html`; however, the code is far less complex
    since we are now using uniform arrays. Let's see how using uniform arrays changes
    our code.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`ch06_04_wall-light-arrays.html`文件。这个场景看起来与`ch06_03_wall-final.html`完全一样；然而，代码要简单得多，因为我们现在正在使用统一数组。让我们看看使用统一数组是如何改变我们的代码的。
- en: Open the `ch06_04_wall-light-arrays.html` file in your code editor. Let's take
    a look at the vertex shader. Note the use of the constant integer expression const
    int, `numLights = 3;`, to declare the number of lights that the shader will handle.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开`ch06_04_wall-light-arrays.html`文件。让我们看看顶点着色器。注意使用常量整数表达式`const int
    numLights = 3;`来声明着色器将处理的灯光数量。
- en: 'There, you can also see that a uniform array is being used to operate on light
    positions. Note that we are using a varying array to pass the light rays (for
    each light) to the fragment shader:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里，你还可以看到正在使用统一数组来操作灯光位置。请注意，我们正在使用一个可变数组将光线（针对每个灯光）传递到片段着色器中：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This fragment of code calculates one varying light ray per light. Recall that
    the same code in the `ch06_03_wall-final.html` file looks like the following code:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码计算每个灯光的一个可变光线。回想一下，`ch06_03_wall-final.html`文件中的相同代码看起来如下：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once you compare these two snippets, the advantage of using uniform arrays (and
    varying arrays) should be clear.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦比较了这两个片段，使用统一数组（和可变数组）的优势应该就很明显了。
- en: 'The fragment shader also uses uniform arrays. In this case, the fragment shader
    iterates through the light diffuse properties to calculate the contribution of
    each one to the final color on the wall:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器也使用统一数组。在这种情况下，片段着色器遍历灯光的漫反射属性来计算每个灯光对最终颜色在墙面上的贡献：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For the sake of brevity, we won’t cover the verbose version from the `ch06_03_wall-final.html`
    exercise, but you should check it out for yourself and compare it with this one.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们不会涵盖`ch06_03_wall-final.html`练习中的冗长版本，但你应该亲自查看并与这个版本进行比较。
- en: 'In the `configure` function, the size of the JavaScript array containing the
    uniform names has decreased considerably by omitting the other unnecessary light
    attributes:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`configure`函数中，通过省略其他不必要的灯光属性，包含统一名称的JavaScript数组的大小已经显著减小：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The mapping between JavaScript lights and uniform arrays is now simpler because
    of the `getArray` method from the `LightsManager` class. As we described earlier,
    the `getArray` method concatenates the lights' data into one flat array.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`LightsManager`类的`getArray`方法，JavaScript灯光和统一数组之间的映射现在更简单了。正如我们之前所描述的，`getArray`方法将灯光的数据连接成一个扁平数组。
- en: The `load` and `render` functions look exactly the same. If we want to add a
    new light, we still need to load a new sphere with the `load` function (to represent
    the light source in our scene), and we still need to translate the sphere to the
    appropriate location in the `render` function.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`load` 和 `render` 函数看起来完全一样。如果我们想添加一个新光源，我们仍然需要使用 `load` 函数加载一个新的球体（在我们的场景中代表光源），我们仍然需要在
    `render` 函数中将球体转换到适当的位置。'
- en: 'Let''s see how much effort we need to add a new light. Go to the `configure`
    function and create a new light object, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看添加新光源需要多少工作量。转到 `configure` 函数并创建一个新的光源对象，如下所示：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add `whiteLight` to the `lights` instance:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `whiteLight` 添加到 `lights` 实例中：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Move to the `load` function and append this line:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到 `load` 函数并添加以下行：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Just like in the previous *Time for Action* section, add this to the `render`
    function:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在之前的 *Time for Action* 部分，将以下内容添加到 `render` 函数中：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Save the webpage with a different name and open it using your browser. We have
    also included the completed exercise in `ch06_05_wall-light-arrays-final.html`,
    including some minor improvements on keeping the light configuration more declarative.
    The following diagram shows the final result:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的名称保存网页，并使用您的浏览器打开它。我们还在 `ch06_05_wall-light-arrays-final.html` 中包含了完成的练习，包括一些对保持灯光配置更声明式的微小改进。以下图表显示了最终结果：
- en: '![](img/86bfe41a-08aa-4cac-b642-ba986109db16.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86bfe41a-08aa-4cac-b642-ba986109db16.png)'
- en: That’s all you need to do! If you want to control the white light properties
    with the controls widget, you would need to write the corresponding code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的全部！如果你想要使用控件部件控制白色光源的属性，你需要编写相应的代码。
- en: 'Time for Action: Directional Point Lights'
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Time for Action: Directional Point Lights'
- en: 'In [Chapter 3](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml), *Lights*, we compared
    directional and positional lights:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](0dcbfd9d-5446-48e9-90c1-841f4d160232.xhtml)，*灯光* 中，我们比较了方向光和位置光：
- en: '![](img/8f69327e-711a-452e-8a94-e6aafcd98af6.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f69327e-711a-452e-8a94-e6aafcd98af6.png)'
- en: In point lighting, for every point on the surface of our object, we compute
    the direction from the light to that point on the surface. We then do the same
    thing we did for directional lighting. Remember that we took the dot product of
    the surface normal (the direction the surface is facing) and the light direction.
    This gave us a value of `1` if the two directions matched, which means the fragment
    should be fully lit, `0` if the two directions were perpendicular, and `-1` if
    they were opposite. We directly used that value to multiply the color of the surface,
    which gave us lighting.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在点光源中，对于物体表面的每一个点，我们计算从光源到表面该点的方向。然后我们做与方向光相同的事情。记住，我们取了表面法线（表面面向的方向）和光方向的点积。如果两个方向匹配，这将给我们一个值为
    `1` 的值，这意味着片段应该完全照亮，如果两个方向垂直，则为 `0`，如果它们相反，则为 `-1`。我们直接使用那个值来乘以表面的颜色，这样就得到了光照。
- en: 'In this section, we will combine directional and positional lights. We are
    going to create a third type of light: a **directional point light**, commonly
    referred to as a **spot light**. This light has both positional and directional
    properties. We are ready to do this since our shaders can easily handle lights
    with multiple properties:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将结合方向光和位置光。我们将创建第三种光源：一种**方向点光源**，通常称为**聚光灯**。这种光具有位置和方向属性。我们已经准备好这样做，因为我们的着色器可以轻松处理具有多个属性的光源：
- en: '![](img/440f89a6-bcc1-4444-97bb-89827e6cb9dd.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/440f89a6-bcc1-4444-97bb-89827e6cb9dd.png)'
- en: 'The trick to creating these lights is to subtract the light-direction vector
    from the normal for each vertex. The resulting vector will create a different
    Lambert coefficient that will reflect into the cone generated by the light source:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些光源的技巧是从每个顶点的法线中减去光方向向量。得到的向量将创建一个不同的朗伯系数，该系数将反射到由光源产生的锥体中：
- en: 'Open `ch06_06_wall-spot-light.html` in your browser. As you can see, the three
    light sources now have a direction:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `ch06_06_wall-spot-light.html`。如您所见，现在有三个光源现在都有一个方向：
- en: '![](img/47c83dde-1688-4bdd-9428-4c54e6c5cd90.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47c83dde-1688-4bdd-9428-4c54e6c5cd90.png)'
- en: Open `ch06_06_wall-spot-light.html` in your source code editor.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的源代码编辑器中打开 `ch06_06_wall-spot-light.html`。
- en: 'To create a light cone, we need to obtain one Lambert coefficient per fragment.
    As we did in previous examples, we obtain these coefficients in the fragment shader
    by calculating the dot product between the inverted light ray and the normal that
    has been interpolated. Thus far, we have been using one varying to do this: `vNormal`.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个光锥，我们需要为每个片段获取一个朗伯系数。正如我们在之前的例子中所做的那样，我们通过计算反转光线的点积和插值后的法线来获取这些系数。到目前为止，我们一直使用一个变量来完成这个任务：`vNormal`。
- en: 'So far, one varying has sufficed since we did not need to update the normals,
    regardless of how many lights we have in the scene. However, to create directional
    point lights, we do have to update the normals as the direction of each light
    will create a different normal. Therefore, we replace `vNormal` with a **varying
    array**:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一个变量已经足够，因为我们不需要更新法线，无论场景中有多少灯光。然而，要创建方向性点光源，我们必须更新法线，因为每个光源的方向将创建不同的法线。因此，我们用**变量数组**替换`vNormal`：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The line that subtracts the light direction from the normal occurs inside the
    `for` loop. This is because we do this for every light in the scene, as every
    light has its own light direction:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减去光线方向从法线的行发生在`for`循环内部。这是因为我们为场景中的每个光源都这样做，因为每个光源都有自己的光线方向：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, the light direction is transformed by the Normal matrix while the light
    position is transformed by the Model-View matrix.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，光线方向通过法线矩阵变换，而光线位置通过模型-视图矩阵变换。
- en: 'In the fragment shader, we calculate the Lambert coefficients: one per light
    and fragment. The key difference is this line in the fragment shader:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们计算朗伯系数：每个光源和片段一个。关键的区别在于片段着色器中的这一行：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we obtain the interpolated updated normal per light.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们为每个光源获取插值后的更新后的法线。
- en: 'Let''s create a cut-off by restricting the allowed Lambert coefficients. There
    are at least two different ways to obtain a light cone in the fragment shader.
    The first one consists of restricting the Lambert coefficient to be higher than
    the `uCutOff` uniform (cut-off value). Let''s take a look at the fragment shader:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过限制允许的朗伯系数来创建一个截止值。在片段着色器中，至少有两种不同的方法来获取一个光锥。第一种方法是将朗伯系数限制在高于`uCutOff`统一变量（截止值）以上。让我们看看片段着色器：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The Lambert coefficient is the cosine of the angle between the reflected light
    and the surface normal. If the light ray is perpendicular to the surface, we obtain
    the highest Lambert coefficient, and as we move away from the center, the Lambert
    coefficients change following the cosine function until the light rays are completely
    parallel to the surface. This creates a cosine of `90` degrees between the normal
    and the light ray. This produces a Lambert coefficient of zero:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 朗伯系数是反射光线与表面法线之间角度的余弦值。如果光线垂直于表面，我们将获得最高的朗伯系数，并且当我们远离中心时，朗伯系数将按照余弦函数变化，直到光线完全平行于表面。这将在法线和光线之间产生`90`度的余弦值。这产生了一个为零的朗伯系数：
- en: '![](img/6b57e091-9bea-41b5-893f-7166d1123723.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b57e091-9bea-41b5-893f-7166d1123723.png)'
- en: 'Open `ch06_06_wall-spot-light.html` in your browser if you haven’t done so
    yet. Use the cut-off slider on the page. Notice how this affects the light cone
    by making it wider or narrower. After playing with the slider, you’ll probably
    notice that these lights don’t look very realistic. The reason is that the final
    color is the same regardless of what Lambert coefficient you obtained: as long
    as the Lambert coefficient is higher than the set cut-off value, you will obtain
    the full diffuse contribution from the three light sources.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有这样做，请在您的浏览器中打开`ch06_06_wall-spot-light.html`。使用页面上的截止滑块。注意这如何通过使光锥变宽或变窄来影响光锥。在调整滑块后，你可能注意到这些灯光看起来不太真实。原因是最终的颜色与您获得的朗伯系数无关：只要朗伯系数高于设置的截止值，您就会从三个光源中获得完整的漫反射贡献。
- en: 'To refine the result, open the web page using your source code editor. Then,
    go to the fragment shader and multiply the Lambert coefficient in the line that
    calculates the final color:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了细化结果，请使用您的源代码编辑器打开网页。然后，转到片段着色器，并将计算最终颜色的行中的朗伯系数相乘：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Save the web page with a different name (so you can keep the original) and
    then load it in your web browser. You will notice that the light colors are attenuated
    as you depart from the center of each light reflection on the wall. This may look
    better, but there’s a simpler way to create more realistic light cut-offs:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的名称保存网页（这样你可以保留原始版本），然后在你的网络浏览器中加载它。你会注意到，随着你离开墙上每个光源反射的中心，光颜色会衰减。这可能看起来更好，但有一个更简单的方法来创建更逼真的光截止值：
- en: '![](img/4a2fd092-74bf-4e9e-8572-1300cc67dd78.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a2fd092-74bf-4e9e-8572-1300cc67dd78.png)'
- en: 'Let''s create a cut-off by using an **exponential attenuation factor**. In
    the fragment shader, find the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用**指数衰减因子**来创建一个截止值。在片段着色器中找到以下代码：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Replace it with the following:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice that we’ve removed the `if` condition. This time, the attenuation factor
    is `pow(lambertTerm, 10.0 * uCutOff);`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们已经移除了`if`条件。这次，衰减因子是`pow(lambertTerm, 10.0 * uCutOff);`。
- en: 'This modification works as the factor attenuates the final color exponentially.
    If the Lambert coefficient is close to zero, the final color will be heavily attenuated:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种修改是有效的，因为因子以指数方式衰减最终颜色。如果Lambert系数接近零，最终颜色将被严重衰减：
- en: '![](img/a826c9ba-bc82-4ed7-b8eb-07be54f5b86e.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a826c9ba-bc82-4ed7-b8eb-07be54f5b86e.png)'
- en: 'Save the web page with a different name and load it in your browser. The improvement
    is dramatic:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的名称保存网页并在你的浏览器中加载它。改进是显著的：
- en: '![](img/2302d070-2526-44fb-bbf2-aeff5ac0a930.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2302d070-2526-44fb-bbf2-aeff5ac0a930.png)'
- en: 'We’ve included the completed exercises here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包括了完成的练习：
- en: '`ch06_07_wall-spot-light-proportional.html`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch06_07_wall-spot-light-proportional.html`'
- en: '`ch06_08_wall-spot-light-exponential.html`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch06_08_wall-spot-light-exponential.html`'
- en: '***What just happened?***'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We’ve learned how to implement directional point lights. We have also discussed
    attenuation factors that improve lighting effects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何实现方向性点光源。我们还讨论了改善光照效果的衰减因子。
- en: Use of Color in the Scene
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景中颜色的使用
- en: It’s time to discuss transparency and alpha blending. As mentioned before, the
    alpha channel can carry information about the opacity of the object color. However,
    as we saw in the cube example, it’s not possible to obtain a translucent object
    unless alpha blending is activated. Things get a bit more complicated when we
    have several objects in the scene. To manage these difficulties, we need to learn
    what to do in order to have a consistent scene with translucent and opaque objects.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论透明度和alpha混合了。如前所述，alpha通道可以携带关于物体颜色不透明度的信息。然而，正如我们在立方体示例中看到的，除非激活alpha混合，否则无法获得半透明物体。当场景中有多个物体时，事情会变得稍微复杂一些。为了管理这些困难，我们需要学习如何操作以使场景中的半透明和不透明物体保持一致。
- en: Transparency
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透明度
- en: The first approach to render transparent objects is to use **polygon stippling**.
    This technique consists of discarding some fragments so that you can see through
    the object. Think of this as punching little holes in the surface of your object.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染透明物体的第一种方法是使用**多边形 stippling**。这种技术包括丢弃一些片段，以便你可以透过物体看到。想象一下在你的物体表面打一些小孔。
- en: OpenGL supports polygon stippling through the `glPolygonStipple` function. This
    function is not available in WebGL. You could try to replicate this functionality
    by dropping some fragments in the fragment shader using the ESSL discard command.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL通过`glPolygonStipple`函数支持多边形 stippling。这个函数在WebGL中不可用。你可以尝试通过在片段着色器中使用
    ESSL discard 命令丢弃一些片段来复制这个功能。
- en: More commonly, we can use the alpha channel information to obtain translucent
    objects. However, as we’ve seen in the cube example, modifying the alpha values
    does not produce transparency automatically.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是，我们可以使用alpha通道信息来获得半透明物体。然而，正如我们在立方体示例中看到的，修改alpha值并不会自动产生透明度。
- en: Creating transparency corresponds to altering the fragments that we’ve already
    written to the framebuffer. Think, for instance, of a scene where there is one
    translucent object in front of an opaque object (from our camera view). In order
    for the scene to be rendered correctly, we need to be able to see the opaque object
    through the translucent object. Therefore, the fragments that overlap between
    the far and near objects need to be combined somehow to create the transparency
    effect.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 创建透明度相当于改变我们已写入帧缓冲区的片段。例如，考虑一个场景，其中有一个不透明物体前面的半透明物体（从我们的摄像机视角看）。为了正确渲染场景，我们需要能够通过半透明物体看到不透明物体。因此，远物体和近物体之间的重叠片段需要以某种方式组合，以创建透明效果。
- en: The same idea applies when there is only one translucent object in the scene.
    The only difference is that the far fragments correspond to the back face of the
    object and the near fragments correspond to the front face of the object. To produce
    the transparency effect in this case, the far and near fragments need to be combined.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景中只有一个半透明物体时，这个想法同样适用。唯一的区别是，远片段对应于物体的背面，而近片段对应于物体的正面。在这种情况下，为了产生透明效果，需要将远片段和近片段组合。
- en: 'To properly render transparent surfaces, we need to learn about two important
    WebGL concepts: **depth testing** and **alpha blending**.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确渲染透明表面，我们需要了解两个重要的WebGL概念：**深度测试**和**alpha混合**。
- en: Updated Rendering Pipeline
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新渲染管线
- en: Depth testing and alpha blending are two optional stages for fragments once
    they’ve been processed by the fragment shader. If the depth test is not activated,
    all the fragments are automatically available for alpha blending. If the depth
    test is enabled, those fragments that fail the test will automatically be discarded
    by the pipeline and will no longer be available for any other operation. This
    means that discarded fragments will not be rendered. This behavior is similar
    to using the ESSL discard command.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 深度测试和alpha混合是片段经过片段着色器处理后的两个可选阶段。如果深度测试未激活，所有片段将自动可用于alpha混合。如果启用深度测试，那些未通过测试的片段将被管线自动丢弃，并且将不再可用于任何其他操作。这意味着丢弃的片段将不会被渲染。这种行为类似于使用ESSL丢弃命令。
- en: 'The following diagram shows the order in which depth testing and alpha blending
    are performed:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了深度测试和alpha混合执行的顺序：
- en: '![](img/c72ca62c-eab7-4c54-bc9a-019313562a72.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c72ca62c-eab7-4c54-bc9a-019313562a72.png)'
- en: Now, let's see what depth testing is about and why it’s relevant to alpha blending.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看深度测试是什么以及为什么它与alpha混合相关。
- en: Depth Testing
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度测试
- en: Each fragment that has been processed by the fragment shader carries an associated
    depth value. Though fragments are two-dimensional since they’re rendered on the
    screen, the depth value keeps the information of how far the fragment is from
    the camera (screen). Depth values are stored in a special WebGL buffer named **depth
    buffer** or **z-buffer**. The `z` comes from the fact that `x` and `y` values
    correspond to the screen coordinates of the fragment, while the `z` value measures
    distance perpendicular to the screen.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由片段着色器处理的片段都携带一个相关的深度值。尽管片段是二维的，因为它们是在屏幕上渲染的，但深度值保留了片段与摄像机（屏幕）的距离信息。深度值存储在名为**深度缓冲区**或**z缓冲区**的特殊WebGL缓冲区中。`z`来自`x`和`y`值对应于片段的屏幕坐标，而`z`值测量垂直于屏幕的距离。
- en: 'After the fragment has been calculated by the fragment shader, it becomes available
    for depth testing. This only occurs if the depth test is enabled. Assuming that
    `gl` is the JavaScript variable that contains our WebGL context, we can enable
    depth testing by writing the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段被片段着色器计算之后，它将可用于深度测试。这仅在启用深度测试的情况下才会发生。假设`gl`是包含我们的WebGL上下文的JavaScript变量，我们可以通过编写以下代码来启用深度测试：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The depth test takes the depth value of a fragment into consideration and compares
    it to the depth value for the same fragment coordinates already stored in the
    depth buffer. The depth test determines whether that fragment is accepted for
    further processing in the rendering pipeline.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 深度测试考虑了片段的深度值，并将其与已存储在深度缓冲区中的相同片段坐标的深度值进行比较。深度测试确定该片段是否被接受在渲染管线中进行进一步处理。
- en: Only the fragments that pass the depth test will be processed. Any fragment
    that does not pass the depth test will be discarded.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过深度测试的片段将被处理。任何未通过深度测试的片段将被丢弃。
- en: In normal circumstances, when the depth test is enabled, only those fragments
    with a lower depth value than the corresponding fragments present in the depth
    buffer will be accepted.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，当启用深度测试时，只有那些深度值低于深度缓冲区中相应片段的片段将被接受。
- en: Depth testing is a commutative operation with respect to the rendering order.
    This means that no matter which object gets rendered first, as long as depth testing
    is enabled, we will always have a consistent scene.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 深度测试与渲染顺序是可交换的操作。这意味着无论哪个对象先被渲染，只要启用了深度测试，我们总是会得到一个一致的场景。
- en: 'Let''s illustrate this with an example. The following diagram contains a cone
    and a sphere. The depth test is disabled using the following code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点。以下图包含一个圆锥体和一个球体。使用以下代码禁用深度测试：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The sphere is rendered first. As expected, the cone fragments that overlap
    the cone are not discarded when the cone is rendered. This occurs because there
    is no depth test between the overlapping fragments:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先渲染球体。正如预期的那样，当渲染圆锥体时，与圆锥体重叠的圆锥体片段不会被丢弃。这是因为重叠片段之间没有深度测试：
- en: '![](img/25fad2cf-dab4-4ab0-89aa-f0926626d235.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25fad2cf-dab4-4ab0-89aa-f0926626d235.png)'
- en: Now, let's enable the depth test and render the same scene. The sphere is rendered
    first. Since all the cone fragments that overlap the sphere have a higher depth
    value (they are farther from the camera), these fragments fail the depth test
    and are discarded, creating a consistent scene.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启用深度测试并渲染相同的场景。首先渲染球体。由于所有与球体重叠的圆锥体片段的深度值更高（它们离摄像机更远），这些片段未能通过深度测试并被丢弃，从而创建了一个一致的场景。
- en: Depth Function
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度函数
- en: In some applications, we may be interested in changing the default behavior
    of depth testing, which discards fragments with a higher depth value than those
    fragments in the depth buffer. For that purpose, WebGL provides the `gl.depthFunc(function)`
    method.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，我们可能希望改变深度测试的默认行为，该行为会丢弃深度值高于深度缓冲区中相应片段的片段。为此，WebGL提供了`gl.depthFunc(function)`方法。
- en: 'This method has only one parameter, the `function` to use:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法只有一个参数，即要使用的`function`：
- en: '| **Parameter** | **Description** |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `gl.NEVER` | The depth test always fails. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `gl.NEVER` | 深度测试始终失败。|'
- en: '| `gl.LESS` | Only fragments with a depth lower than current fragments on the
    depth buffer will pass the test. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `gl.LESS` | 只有深度值低于深度缓冲区中当前片段的片段将通过测试。|'
- en: '| `gl.LEQUAL` | Fragments with a depth less than or equal to corresponding
    current fragments in the depth buffer will pass the test. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `gl.LEQUAL` | 深度值小于或等于深度缓冲区中相应当前片段的片段将通过测试。|'
- en: '| `gl.EQUAL` | Only fragments with the same depth as current fragments on the
    depth buffer will pass the test. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `gl.EQUAL` | 只有与深度缓冲区中当前片段具有相同深度的片段将通过测试。|'
- en: '| `gl.NOTEQUAL` | Only fragments that do not have the same depth value as fragments
    on the depth buffer will pass the test. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `gl.NOTEQUAL` | 只有那些与深度缓冲区中的片段深度值不同的片段将通过测试。|'
- en: '| `gl.GEQUAL` | Fragments with greater or equal depth value will pass the test.
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `gl.GEQUAL` | 深度值大于或等于的片段将通过测试。|'
- en: '| `gl.GREATER` | Only fragments with a greater depth value will pass the test.
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `gl.GREATER` | 只有深度值更大的片段将通过测试。|'
- en: '| `gl.ALWAYS` | The depth test always passes. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `gl.ALWAYS` | 深度测试始终通过。|'
- en: The depth test is disabled by default in WebGL. When enabled, if no depth function
    is set, the `gl.LESS` function is selected by default.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL中默认禁用深度测试。当启用时，如果没有设置深度函数，则默认选择`gl.LESS`函数。
- en: Alpha Blending
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alpha混合
- en: A fragment is available for alpha blending only if it has passed the depth test.
    By default, depth testing is disabled and makes all fragments available for alpha
    blending.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当片段通过了深度测试时，才可用于alpha混合。默认情况下，深度测试是禁用的，这使得所有片段都可用于alpha混合。
- en: 'Alpha blending is enabled using the following line of code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码行启用alpha混合：
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: For each available fragment, the alpha blending operation reads the color from
    the framebuffer by the appropriate fragment coordinates and creates a new color
    based on a linear interpolation between the previously calculated color in the
    fragment shader and the color from the framebuffer.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个可用的片段，alpha混合操作通过适当的片段坐标从帧缓冲区中读取颜色，并根据片段着色器中先前计算的颜色与帧缓冲区中的颜色之间的线性插值创建一个新的颜色。
- en: Alpha Blending
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha混合
- en: Alpha blending is disabled by default in WebGL.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL中默认禁用alpha混合。
- en: The Blending Function
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合函数
- en: With blending enabled, the next step is to define a blending function. This
    function will determine how fragment colors from the object (source) are combined
    with the fragment colors present in the framebuffer (destination).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用混合之后，下一步是定义一个混合函数。这个函数将确定从对象（源）中提取的片段颜色如何与帧缓冲区中现有的片段颜色（目标）结合。
- en: 'We combine source and destination colors as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将源和目标颜色组合如下：
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'More precisely:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说：
- en: '`S`: Source color (vec4)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`: 源颜色（vec4）'
- en: '`D`: Destination color (vec4)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D`: 目标颜色（vec4）'
- en: '`sW`: Source scaling factor'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sW`: 源缩放因子'
- en: '`dW`: Destination scaling factor'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dW`: 目标缩放因子'
- en: '`S.rgb`: RGB components of the source color'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S.rgb`: 源颜色的RGB分量'
- en: '`S.a`: Alpha component of the source color'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S.a`: 源颜色的alpha分量'
- en: '`D.rgb`: RGB components of the destination color'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D.rgb`: 目标颜色的RGB分量'
- en: '`D.a`: Alpha component of the destination color'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D.a`: 目标颜色的alpha分量'
- en: 'It’s important to note that the rendering order will determine the source and
    the destination fragments. Following the example from the previous section, if
    the sphere is rendered first, it will then become the destination of the blending
    operation because the sphere fragments are stored in the framebuffer at the time
    that the cone is rendered. In other words, alpha blending is a non-commutative
    operation with respect to rendering order:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，渲染顺序将决定源片段和目标片段。参考上一节的示例，如果首先渲染球体，那么它将成为混合操作的目标，因为当锥体被渲染时，球体片段已经被存储在帧缓冲区中。换句话说，从渲染顺序的角度来看，alpha混合是一个非交换的操作：
- en: '![](img/feef0be1-26ef-465c-b513-28e00b8bc4ec.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/feef0be1-26ef-465c-b513-28e00b8bc4ec.png)'
- en: Separate Blending Functions
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立混合函数
- en: It is also possible to determine how the RGB channels are going to be combined
    independently from the alpha channels. For that, we use the `gl.blendFuncSeparate`
    function.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以独立于alpha通道确定RGB通道如何组合。为此，我们使用`gl.blendFuncSeparate`函数。
- en: 'We define two independent functions this way:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这种方式定义两个独立的函数：
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'More precisely:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说：
- en: '`sW.rgb`: Source scaling factor (only RGB)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sW.rgb`: 源RGB分量'
- en: '`dW.rgb`: Destination scaling factor (only RGB)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dW.rgb`: 目标RGB的缩放因子（仅RGB）'
- en: '`sW.a`: Source scaling factor for the source alpha value'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sW.a`: 源alpha值的缩放因子'
- en: '`dW.a`: Destination scaling factor for the destination alpha value'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dW.a`: 目标alpha值的缩放因子'
- en: 'Then, we could have something such as the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可能得到以下内容：
- en: '[PRE64]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This would be translated into code as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被转换为以下代码：
- en: '[PRE65]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The parameters for the `gl.blendFuncSeparate` function are the same as `gl.blendFunc`.
    You can find more information on these functions later in this section.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl.blendFuncSeparate`函数的参数与`gl.blendFunc`相同。你可以在本节的后面找到更多关于这些函数的信息。'
- en: The Blend Equation
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合方程
- en: 'We could have a case where we do not want to interpolate the source and destination
    fragment colors with scale or add operations. For example, we may want to subtract
    one from the other. In this case, WebGL provides the `gl.blendEquation` function.
    This function receives one parameter that determines the operation on the scaled
    source and destination fragment colors. For example, `gl.blendEquation(gl.FUNC_ADD)`
    is calculated as such:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到不想使用缩放或加法操作来插值源和目标片段颜色的情况。例如，我们可能想要从其中一个中减去另一个。在这种情况下，WebGL提供了`gl.blendEquation`函数。这个函数接收一个参数，该参数确定对缩放后的源和目标片段颜色进行的操作。例如，`gl.blendEquation(gl.FUNC_ADD)`的计算如下：
- en: '[PRE66]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And, `gl.blendEquation(gl.FUNC_SUBTRACT)` corresponds to the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，`gl.blendEquation(gl.FUNC_SUBTRACT)`对应以下内容：
- en: '[PRE67]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'There is a third option, `gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT)`, that
    corresponds to the following:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个第三种选择，`gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT)`，对应以下内容：
- en: '[PRE68]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As expected, you can define the blending equation separately for the RGB channels
    and for the alpha channel. For that, we use the `gl.blendEquationSeparate` function.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，你可以分别为RGB通道和alpha通道定义混合方程。为此，我们使用`gl.blendEquationSeparate`函数。
- en: The Blend Color
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合颜色
- en: WebGL provides the `gl.CONSTANT_COLOR` and `gl.ONE_MINUS_CONSTANT_COLOR` scaling
    factors. These scaling factors can be used with `gl.blendFunc` and `gl.blendFuncSeparate`.
    However, we need to first establish the blend color. We do so by invoking `gl.blendColor`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL提供了`gl.CONSTANT_COLOR`和`gl.ONE_MINUS_CONSTANT_COLOR`缩放因子。这些缩放因子可以与`gl.blendFunc`和`gl.blendFuncSeparate`一起使用。然而，我们首先需要建立混合颜色。我们通过调用`gl.blendColor`来实现这一点。
- en: WebGL Alpha-Blending API
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL Alpha-Blending API
- en: 'The following table summarizes the WebGL functions that are relevant to performing
    alpha-blending operations:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了与执行alpha混合操作相关的WebGL函数：
- en: '| **WebGL function** | **Description** |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| **WebGL函数** | **描述** |'
- en: '| `gl.enable&#124;disable(gl.BLEND)` | Enable/disable blending. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `gl.enable|disable(gl.BLEND)` | 启用/禁用混合。|'
- en: '| `gl.blendFunc(sW, dW)` | Specify pixel arithmetic. Accepted values for `sW`
    and `dW` are as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '| `gl.blendFunc(sW, dW)` | 指定像素算术。`sW` 和 `dW` 的有效值如下：'
- en: '`ZERO`'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZERO`'
- en: '`ONE`'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE`'
- en: '`SRC_COLOR`'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC_COLOR`'
- en: '`DST_COLOR`'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DST_COLOR`'
- en: '`SRC_ALPHA`'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC_ALPHA`'
- en: '`DST_ALPHA`'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DST_ALPHA`'
- en: '`CONSTANT_COLOR`'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTANT_COLOR`'
- en: '`CONSTANT_ALPHA`'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTANT_ALPHA`'
- en: '`ONE_MINUS_SRC_ALPHA`'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_SRC_ALPHA`'
- en: '`ONE_MINUS_DST_ALPHA`'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_DST_ALPHA`'
- en: '`ONE_MINUS_SRC_COLOR`'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_SRC_COLOR`'
- en: '`ONE_MINUS_DST_COLOR`'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_DST_COLOR`'
- en: '`ONE_MINUS_CONSTANT_COLOR`'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_CONSTANT_COLOR`'
- en: '`ONE_MINUS_CONSTANT_ALPHA`'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ONE_MINUS_CONSTANT_ALPHA`'
- en: In addition, `sW` can also be `SRC_ALPHA_SATURATE`. |
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`sW` 还可以是 `SRC_ALPHA_SATURATE`。|
- en: '| `gl.blendFuncSeparate(sW_rgb, dW_rgb, sW_a, dW_a)` | Specify pixel arithmetic
    for RGB and alpha components separately. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `gl.blendFuncSeparate(sW_rgb, dW_rgb, sW_a, dW_a)` | 分别指定RGB和alpha组件的像素算术。|'
- en: '| `gl.blendEquation(mode)` | Specify the equation used for both the RGB blend
    equation and the alpha blend equation. Accepted values for mode are as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '| `gl.blendEquation(mode)` | 指定用于RGB混合方程和alpha混合方程的方程。`mode` 的有效值如下：'
- en: '`gl.FUNC_ADD`'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.FUNC_ADD`'
- en: '`gl.FUNC_SUBTRACT`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.FUNC_SUBTRACT`'
- en: '`gl.FUNC_REVERSE_SUBTRACT`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.FUNC_REVERSE_SUBTRACT`'
- en: '|'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `gl.blendEquationSeparate(modeRGB, modeAlpha)` | Set the RGB blend equation
    and the alpha blend equation separately. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `gl.blendEquationSeparate(modeRGB, modeAlpha)` | 分别设置RGB混合方程和alpha混合方程。|'
- en: '| `gl.blendColor(red, green, blue, alpha)` | Set the blend color. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `gl.blendColor(red, green, blue, alpha)` | 设置混合颜色。|'
- en: '| `gl.getParameter(name)` | Just like with other WebGL variables, it is possible
    to query blending parameters using `gl.getParameter`. Relevant parameters are
    as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '| `gl.getParameter(name)` | 就像其他WebGL变量一样，可以使用 `gl.getParameter` 查询混合参数。相关的参数如下：'
- en: '`gl.BLEND`'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.BLEND`'
- en: '`gl.BLEND_COLOR`'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.BLEND_COLOR`'
- en: '`gl.BLEND_DST_RGB`'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.BLEND_DST_RGB`'
- en: '`gl.BLEND_SRC_RGB`'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.BLEND_SRC_RGB`'
- en: '`gl.BLEND_DST_ALPHA`'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.BLEND_DST_ALPHA`'
- en: '`gl.BLEND_SRC_ALPHA`'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.BLEND_SRC_ALPHA`'
- en: '`gl.BLEND_EQUATION_RGB`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.BLEND_EQUATION_RGB`'
- en: '`gl.BLEND_EQUATION_ALPHA`'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gl.BLEND_EQUATION_ALPHA`'
- en: '|'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Alpha Blending Modes
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色混合模式
- en: 'Depending on the parameter selection for `sW` and `dW`, we can create different
    blending modes. In this section, we will see how to create additive, subtractive,
    multiplicative, and interpolative blending modes. All blending modes are derived
    from the previous formula:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对 `sW` 和 `dW` 的参数选择，我们可以创建不同的混合模式。在本节中，我们将了解如何创建加法、减法、乘法和插值混合模式。所有混合模式都源自之前的公式：
- en: '[PRE69]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The Blending Function
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合函数
- en: 'Additive blending simply adds the colors of the source and destination fragments,
    creating a lighter image. We obtain additive blending by writing the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 加法混合简单地将源片段和目标片段的颜色相加，创建一个更亮的图像。我们通过以下方式获得加法混合：
- en: '[PRE70]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This assigns the weights for source and destination fragments `sW` and `dW`
    to `1`. The color output will be as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这将源片段和目标片段的权重 `sW` 和 `dW` 分配为 `1`。颜色输出将如下所示：
- en: '[PRE71]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Since each color channel is in the `[0, 1]` range, blending will clamp all values
    over `1`. When all channels are `1`, this results in a white color.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个颜色通道都在 `[0, 1]` 范围内，混合将限制所有超过 `1` 的值。当所有通道都是 `1` 时，这会导致白色。
- en: Subtractive Blending
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减法混合
- en: 'Similarly, we can obtain subtractive blending by writing the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过以下方式获得减法混合：
- en: '[PRE72]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This will change the blending equation to the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变混合方程如下：
- en: '[PRE73]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: All negative values will be set to `0`. When all channels are negative, the
    result is black.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 所有负值都将设置为 `0`。当所有通道都是负值时，结果是黑色。
- en: Multiplicative Blending
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乘法混合
- en: 'We obtain multiplicative blending by writing the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下方式获得乘法混合：
- en: '[PRE74]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This will be reflected in the blending equation as the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在混合方程中反映为以下内容：
- en: '[PRE75]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The result will always be a darker blending.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将始终是较暗的混合。
- en: Interpolative Blending
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值混合
- en: 'If we set `sW` to `S.a` and `dW` to `1 - S.a`, then we get the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `sW` 设置为 `S.a` 并将 `dW` 设置为 `1 - S.a`，那么我们得到以下内容：
- en: '[PRE76]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This will create a linear interpolation between the source and destination
    color using the source alpha color, `S.a`, as the scaling factor. In code, this
    is translated as the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过使用源alpha颜色 `S.a` 作为缩放因子，在源颜色和目标颜色之间创建线性插值。在代码中，这被翻译为以下内容：
- en: '[PRE77]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Interpolative blending allows us to create a transparency effect as long as
    the destination fragments have passed the depth test. As expected, this requires
    that the objects be rendered from back to front.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 插值混合允许我们在目标片段通过深度测试的情况下创建透明效果。正如预期的那样，这要求对象从后向前渲染。
- en: In the next section, we will play with different blending modes on a simple
    scene composed of a cone and sphere.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在一个由圆锥体和球体组成的简单场景上尝试不同的混合模式。
- en: 'Time for Action: Blending Workbench'
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：混合工作台
- en: 'Let''s cover an example of these various blending functions in action:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示这些不同的混合函数的实际应用：
- en: 'Open the `ch06_09_blending.html` file in your browser. You will see an interface
    like the one in the following screenshot:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch06_09_blending.html`文件。您将看到一个类似于以下截图的界面：
- en: '![](img/26723570-509d-46d5-95fe-a2093208bd24.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26723570-509d-46d5-95fe-a2093208bd24.png)'
- en: This interface has most of the parameters that allow you to configure alpha
    blending. The default settings are source `gl.SRC_ALPHA` and destination `gl.ONE_MINUS_SRC_ALPHA`.
    These are parameters for interpolative blending. Which slider do you need to use
    to change the scaling factor for interpolative blending? Why?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此接口具有大多数允许您配置alpha混合的参数。默认设置是源`gl.SRC_ALPHA`和目标`gl.ONE_MINUS_SRC_ALPHA`。这些是插值混合的参数。您需要使用哪个滑块来更改插值混合的缩放因子？为什么？
- en: Change the sphere alpha slider to `0.5`. You will see some shadow-like artifacts
    on the surface of the sphere. This occurs because the sphere back face is now
    visible. To get rid of the back face, click on Back Face Culling.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球体alpha滑块更改为`0.5`。您将在球体表面看到一些类似阴影的碎片。这是因为球体的背面现在可见。要去除背面，请点击背面剔除。
- en: Click on the Reset button.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击重置按钮。
- en: Disable the Lambert Term and Floor buttons.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用Lambert项和地板按钮。
- en: Enable the Back Face Culling button.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用背面剔除按钮。
- en: Let's implement multiplicative blending. What values do source and destination
    need to have?
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现乘法混合。源和目标需要有什么值？
- en: Click and drag the `canvas`. Check that the multiplicative blending creates
    dark regions where the objects overlap.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动`canvas`。检查乘法混合在对象重叠处创建的暗区。
- en: Change the blending function to `gl.FUNC_SUBTRACT` using the provided drop-down
    menu.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的下拉菜单将混合函数更改为`gl.FUNC_SUBTRACT`。
- en: Change Source to `gl.ONE` and Destination to `gl.ONE`.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源更改为`gl.ONE`并将目标更改为`gl.ONE`。
- en: What blending mode is this? Click and drag the `canvas` to check the appearance
    of the overlapped regions.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是哪种混合模式？点击并拖动`canvas`以检查重叠区域的显示。
- en: Try different parameter configurations. Remember you can also change the blending
    function. If you decide to use a constant color or constant alpha, please use
    the color widget and the respective slider to modify the values of these parameters.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的参数配置。请记住，您也可以更改混合函数。如果您决定使用恒定颜色或恒定alpha，请使用颜色小部件和相应的滑块来修改这些参数的值。
- en: '***What just happened?***'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: You have seen how the additive, multiplicative, subtractive, and interpolative
    blending modes work with a simple exercise.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经通过一个简单的练习看到了加法、乘法、减法和插值混合模式的工作方式。
- en: You have seen that the combination of `gl.SRC_ALPHA` and `gl.ONE_MINUS_SRC_ALPHA`
    produces transparency.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，`gl.SRC_ALPHA`和`gl.ONE_MINUS_SRC_ALPHA`的组合产生了透明效果。
- en: Creating Transparent Objects
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建透明对象
- en: 'We’ve learned that in order to create transparency, we need to:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，为了创建透明效果，我们需要：
- en: Enable alpha blending and select the interpolative blending function
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用alpha混合并选择插值混合函数
- en: Render the faces of objects back to front
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从后向前渲染对象的表面
- en: How do we create transparent objects when there is nothing to blend them against?
    In other words, if there’s only one object, how can we make it transparent? One
    solution is to use **face-culling**.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有东西可以与之混合时，我们如何创建透明对象？换句话说，如果只有一个对象，我们如何使其透明？一个解决方案是使用**面剔除**。
- en: Face-culling allows us to *only* render the back or front face of an object.
    We used this technique in the previous section when we only rendered the front
    face by enabling the Back Face Culling button.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 面剔除允许我们**仅**渲染对象的背面或正面。我们在上一节中使用了这种技术，当时我们通过启用背面剔除按钮只渲染正面。
- en: 'Let''s use the color cube from earlier in this chapter. We are going to make
    it transparent. For that effect, we will perform the following:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用本章前面提到的颜色立方体。我们将使其变得透明。为了达到这个效果，我们将执行以下操作：
- en: Enable alpha blending and use the interpolative blending mode.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用alpha混合并使用插值混合模式。
- en: Enable face-culling.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用面剔除。
- en: Render the back face (by culling the front face).
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过剔除正面来渲染背面。
- en: Render the front face (by culling the back face).
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过剔除背面来渲染正面。
- en: 'Similar to other options in the pipeline, culling is disabled by default. We
    enable it by calling the following:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 与管道中的其他选项类似，剔除默认是禁用的。我们通过调用以下代码来启用它：
- en: '[PRE78]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: To render only the back faces of an object, we call `gl.cullFace(gl.FRONT)`
    before we call `drawArrays` or `drawElements`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅渲染物体的背面，我们在调用 `drawArrays` 或 `drawElements` 之前，需要调用 `gl.cullFace(gl.FRONT)`。
- en: Similarly, to render only the front face, we use `gl.cullFace(gl.BACK)` before
    the draw call.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要仅渲染正面，我们在绘制调用之前使用 `gl.cullFace(gl.BACK)`。
- en: 'The following diagram summarizes the steps needed to create a transparent object
    with alpha blending and face-culling:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了创建具有alpha混合和面剔除的透明物体所需的步骤：
- en: '![](img/28bfd5b0-2acb-4e74-9e47-37c2673177dd.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28bfd5b0-2acb-4e74-9e47-37c2673177dd.png)'
- en: In the following section, we will see the transparent cube in action and take
    a look at the code that makes it possible.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到透明立方体的实际效果，并查看使其成为可能的代码。
- en: 'Time for Action: Culling'
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：剔除
- en: 'Let''s cover an example showcasing culling in action:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示剔除操作：
- en: Open the `ch06_10_culling.html` file in your browser.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `ch06_10_culling.html` 文件。
- en: 'You will see that the interface is similar to the blending workbench exercise.
    However, on the top row, you will see these three options:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到界面与混合工作台练习相似。然而，在上行中，你会看到这三个选项：
- en: 'Alpha Blending: Enables or disables alpha blending.'
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpha混合：启用或禁用alpha混合。
- en: 'Render Front Face: If active, renders the front face.'
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染正面：如果处于活动状态，则渲染正面。
- en: 'Render Back Face: If active, renders the back face.'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染背面：如果处于活动状态，则渲染背面。
- en: 'Remember that for blending to work, objects need to be rendered back to front.
    Therefore, the back face of the cube is rendered first. This is reflected in the
    `draw` function:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，为了混合工作，物体需要从后向前渲染。因此，立方体的背面首先被渲染。这反映在 `draw` 函数中：
- en: '[PRE79]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Going back to the web page, notice how the interpolative blending function produces
    the expected transparent effect. Move the alpha value slider that appears under
    the button options to adjust the scaling factor for interpolative blending.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到网页，注意插值混合函数如何产生预期的透明效果。将出现在按钮选项下的alpha值滑块移动以调整插值混合的缩放因子。
- en: Review the interpolative blending function. In this case, the destination is
    the back face (rendered first) and the source is the front face. If the alpha
    source equals `1`, what would you obtain according to the function? Test the result
    by moving the alpha slider to zero.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查插值混合函数。在这种情况下，目标面是背面（先渲染的）而源面是正面。如果源alpha值为 `1`，根据该函数你会得到什么？通过将alpha滑块移动到零来测试结果。
- en: 'Let''s visualize the back face only. For that, disable the Render Front Face
    button. Increase the alpha value using the alpha value slider. Your screen should
    look like this:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们仅可视化背面。为此，禁用渲染正面按钮。使用alpha值滑块增加alpha值。你的屏幕应该看起来像这样：
- en: '![](img/0f601e12-975a-4aa6-b666-9ead2fbc6c8a.png)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f601e12-975a-4aa6-b666-9ead2fbc6c8a.png)'
- en: Click and drag the cube on the `canvas`. Notice how the back face is calculated
    every time you move the camera around.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动 `canvas` 上的立方体。注意每次你移动相机时背面是如何计算的。
- en: Click on the Render Front Face again to activate it. Change the blending function
    so you can obtain subtractive blending.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击渲染正面以激活它。更改混合函数以获得减法混合。
- en: Try different blending configurations using the controls provided in this exercise.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用本练习中提供的控件使用不同的混合配置。
- en: '***What just happened?***'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We have seen how face-culling and the alpha-blending interpolative mode can
    help us properly blend the faces of translucent objects.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到面剔除和alpha混合的插值模式如何帮助我们正确混合半透明物体的面。
- en: Now, let's see how to implement transparency when there are two objects on the
    screen. In this case, we have a wall that we want to make transparent. Behind
    it is a cone.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在屏幕上有两个物体时实现透明度。在这种情况下，我们有一个想要使其透明的墙。在其后面是一个圆锥体。
- en: 'Time for Action: Creating a Transparent Wall'
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：创建透明墙
- en: 'Let''s cover an example of how we''d make an object transparent:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示如何使一个物体透明：
- en: 'Open `ch06_11_transparency-initial.html` in your browser. We have two completely
    opaque objects: a cone behind a wall. Click and drag the `canvas` to move the
    camera behind the wall and see the cone, as shown in the following screenshot:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`ch06_11_transparency-initial.html`。我们有两个完全不透明的对象：一个圆锥体在墙壁后面。点击并拖动`canvas`将相机移动到墙壁后面，以看到圆锥体，如下面的截图所示：
- en: '![](img/a5ebfd61-ef0b-48fa-b084-e039c0ff0e7a.png)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5ebfd61-ef0b-48fa-b084-e039c0ff0e7a.png)'
- en: Change the wall alpha value by using the provided slider.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的滑块更改墙壁的alpha值。
- en: 'As you can see, modifying the alpha value does not produce any transparency.
    The reason for this is that alpha blending is not enabled. Let''s edit the source
    code to include alpha blending. Open the `ch06_11_transparency-initial.html` file
    in your source code editor. Scroll to the `configure` function and find these
    lines:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，修改alpha值不会产生任何透明度。这是因为alpha混合没有被启用。让我们编辑源代码以包含alpha混合。在您的源代码编辑器中打开`ch06_11_transparency-initial.html`文件。滚动到`configure`函数并找到以下行：
- en: '[PRE80]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Below them, append the following lines:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在它们下面，添加以下行：
- en: '[PRE81]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Save your changes as `ch06_12_transparency-final.html` and load this page on
    your web browser.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的更改保存为`ch06_12_transparency-final.html`，并在您的网络浏览器中加载此页面。
- en: As expected, the wall changes its transparency as you modify its alpha value
    using the respective slider.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如预期的那样，当您使用相应的滑块修改墙壁的alpha值时，墙壁的透明度会发生变化。
- en: Remember that in order for transparency to be effective, the objects need to
    be rendered back to front. Let's take a look at the source code. Open `ch06_12_transparency-final.html`
    in your source code editor.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，为了使透明度有效，对象需要从前到后进行渲染。让我们看一下源代码。在您的源代码编辑器中打开`ch06_12_transparency-final.html`。
- en: 'The cone is the farthest object in the scene. Hence, it is loaded first. You
    can check that by looking at the `load` function:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圆锥体是场景中最远的对象。因此，它首先被加载。您可以通过查看`load`函数来验证这一点：
- en: '[PRE82]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'It occupies a lower index in the `scene.objects` list. In the `render` function,
    the objects are rendered in the order in which they appear in the `scene.objects`
    list:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在`scene.objects`列表中的索引较低。在`render`函数中，对象按照它们在`scene.objects`列表中出现的顺序进行渲染：
- en: '[PRE83]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: What happens if we rotate the scene so that the cone is closer to the camera
    and the wall is farther away?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将场景旋转，使得圆锥体靠近相机而墙壁远离，会发生什么？
- en: Open `ch06_12_transparency-final.html` in your browser and rotate the scene
    such that the cone appears in front of the wall. Decrease the alpha value of the
    cone while the alpha value of the wall remains at `1.0`.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch06_12_transparency-final.html`，并旋转场景，使得圆锥体出现在墙壁前面。在圆锥体的alpha值降低的同时，保持墙壁的alpha值在`1.0`。
- en: 'As you can see, the blending is inconsistent. This does not have to do with
    alpha blending because in `ch06_12_transparency-final.html`, the blending is enabled.
    It has to do with the **rendering order**. Click on the Wall First button. The
    scene should appear consistent now:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，混合是不一致的。这与alpha混合无关，因为在`ch06_12_transparency-final.html`中，混合是启用的。这与**渲染顺序**有关。点击“墙壁优先”按钮。现在场景应该是一致的：
- en: '![](img/9dee8429-19a6-42ab-bd95-067b32bfe57f.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dee8429-19a6-42ab-bd95-067b32bfe57f.png)'
- en: The Cone First and Wall First buttons use a couple of new functions that we
    have included in the `Scene` class to change the rendering order. These functions
    are `renderSooner` and `renderFirst`.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “圆锥体优先”和“墙壁优先”按钮使用了我们在`Scene`类中包含的一些新函数来改变渲染顺序。这些函数是`renderSooner`和`renderFirst`。
- en: 'In total, we have added these functions to the `Scene` object to deal with
    rendering order:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总的来说，我们已经将这些功能添加到`Scene`对象中，以处理渲染顺序：
- en: '`renderSooner(objectName)`: Moves the `objectName` object one position higher
    in the `Scene.objects` list.'
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderSooner(objectName)`: 将`objectName`对象在`Scene.objects`列表中向上移动一个位置。'
- en: '`renderLater(objectName)`: Moves the `objectName` object one position lower
    in the `Scene.objects` list.'
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderLater(objectName)`: 将`objectName`对象在`Scene.objects`列表中向下移动一个位置。'
- en: '`renderFirst(objectName)`: Moves the `objectName` object to the first position
    of the list (index 0).'
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderFirst(objectName)`: 将`objectName`对象移动到列表的第一个位置（索引0）。'
- en: '`renderLast(objectName)`: Moves the `objectName` object to the last position
    of the list.'
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderLast(objectName)`: 将`objectName`对象移动到列表的最后一个位置。'
- en: '`renderOrder()`: Lists the objects in the `Scene.objects` list in the order
    in which they are rendered. This is the same order in which they are stored in
    the list. For any two given objects, the object with the lower index will be rendered
    first.'
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderOrder()`: 列出`Scene.objects`列表中的对象，按它们渲染的顺序排列。这是它们在列表中存储的相同顺序。对于任何两个给定的对象，索引较低的对象将首先渲染。'
- en: You can use these functions from the JavaScript console in your browser and
    see what effect these have on the scene.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用浏览器中的JavaScript控制台中的这些函数，并查看它们对场景的影响。
- en: '***What just happened?***'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We took a simple scene where we implemented alpha blending. After that, we analyzed
    the importance of the rendering order in creating consistent transparencies. Finally,
    we presented the new methods of the `Scene` object that control the rendering
    order.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了一个简单的场景，其中我们实现了alpha混合。之后，我们分析了渲染顺序在创建一致透明度中的重要性。最后，我们介绍了`Scene`对象的新方法，这些方法控制着渲染顺序。
- en: Summary
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let’s summarize what we learned in this chapter:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容：
- en: We learned how to extensively use colors with objects, lights, and in the scene.
    Specifically, we’ve learned that an object can be colored per vertex, per fragment,
    or can have a constant color.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何广泛地使用颜色，包括在对象、灯光和场景中。具体来说，我们了解到一个对象可以按顶点、片段或具有恒定颜色进行着色。
- en: We reviewed lights and the various approaches to lighting models.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了灯光和光照模型的多种方法。
- en: We covered how to create lights of different colors and leveraged concepts from
    directional and point lights to create spot lights. By introducing several light
    sources in our scene, we updated our architectural patterns and used uniform arrays
    to reduce the complexity of creating and mapping uniforms between JavaScript and
    ESSL.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了如何创建不同颜色的灯光，并利用方向光和点光源的概念来创建聚光灯。通过在我们的场景中引入多个光源，我们更新了我们的建筑模式，并使用统一数组来减少在JavaScript和ESSL之间创建和映射统一变量的复杂性。
- en: We learned that proper translucency requires more than just using alpha values
    in our color vectors. Because of this, we explored various blending behaviors,
    render sequences, and WebGL functions to create translucent objects.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到，适当的半透明度不仅仅需要在我们颜色向量中使用alpha值。正因为如此，我们探索了各种混合行为、渲染序列和WebGL函数来创建半透明对象。
- en: We learned how face-culling can help produce better results when there are multiple
    translucent objects present in the scene.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了面剔除如何帮助在场景中存在多个半透明对象时产生更好的结果。
- en: In the next chapter, we will learn how to leverage textures to help us render
    images in our scene.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何利用纹理来帮助我们渲染场景中的图像。
