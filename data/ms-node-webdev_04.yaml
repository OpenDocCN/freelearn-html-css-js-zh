- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Understanding Node.js Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Node.js 并发
- en: Server-side web development is characterized by processing large volumes of
    HTTP requests as quickly and efficiently as possible. JavaScript is different
    from other languages and platforms because it has a single thread of execution,
    which means that HTTP requests are processed one at a time. Behind the scenes,
    however, there is a lot more going on, and in this chapter, I explain why the
    JavaScript approach is unusual, how the Node.js API performs work on behalf of
    JavaScript code, and how additional execution threads can be created to handle
    computationally intense tasks. *Table 4.1* puts JavaScript concurrency in context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端 Web 开发的特点是尽可能快速和高效地处理大量 HTTP 请求。JavaScript 与其他语言和平台不同，因为它只有一个执行线程，这意味着
    HTTP 请求是逐个处理的。然而，在幕后，还有更多的事情在进行，在本章中，我将解释为什么 JavaScript 方法不寻常，Node.js API 如何代表
    JavaScript 代码执行工作，以及如何创建额外的执行线程来处理计算密集型任务。*表 4.1* 将 JavaScript 并发置于上下文中。
- en: 'Table 4.1: Putting Node.js concurrency in context'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1：将 Node.js 并发置于上下文中
- en: '| Question | Answer |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What is it? | Concurrency is the execution of multiple threads of code. Node.js
    has support for concurrency, but it hides the details from the developer. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 它是什么？ | 并发是代码多个线程的执行。Node.js 支持并发，但它隐藏了这些细节不向开发者展示。|'
- en: '| Why is it useful? | Concurrency allows servers to achieve greater throughput
    by accepting and processing multiple HTTP requests simultaneously. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它有用？ | 并发允许服务器通过同时接受和处理多个 HTTP 请求来实现更高的吞吐量。|'
- en: '| How is it used? | Node.js has a single thread of execution for JavaScript
    code called the main thread, and it relies on events to coordinate the work required
    to process different threads of work. The Node.js API makes extensive use of concurrent
    execution in its APIs, but this is largely hidden from the developer. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 如何使用？ | Node.js 为 JavaScript 代码提供了一个名为主线程的单个执行线程，它依赖于事件来协调处理不同线程所需的工作。Node.js
    API 在其 API 中广泛使用并发执行，但这在很大程度上对开发者隐藏。|'
- en: '| Are there any pitfalls or limitations? | Care must be taken not to block
    the main thread; otherwise, performance will be impaired. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 有没有陷阱或限制？ | 必须注意不要阻塞主线程；否则，性能将受到影响。|'
- en: '| Are there any alternatives? | No. The concurrency model is core to Node.js
    and understanding it is essential to create web applications that scale economically.
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 没有。并发模型是 Node.js 的核心，理解它是创建可扩展经济型 Web 应用程序的关键。|'
- en: '*Table 4.2* summarizes the chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 4.2* 总结了本章内容。'
- en: 'Table 4.2: Chapter summary'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2：本章总结
- en: '| Problem | Solution | Listing |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Perform tasks concurrently | Use the Node.js API and handle events with callback
    functions or promises. | *10-15* |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 并发执行任务 | 使用 Node.js API 并通过回调函数或承诺处理事件。 | *10-15* |'
- en: '| Wrap code as promises or callbacks | Use the `promisify` and `callbackify`
    functions. | *16, 17* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 将代码包装为承诺或回调 | 使用 `promisify` 和 `callbackify` 函数。 | *16, 17* |'
- en: '| Avoid blocking the main thread for simple tasks | Break up work into smaller
    chunks that can be interleaved with other work. | *21* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 避免阻塞主线程处理简单任务 | 将工作分解成更小的块，可以与其他工作交织进行。 | *21* |'
- en: '| Avoid blocking the main thread for complex tasks | Use worker threads. |
    *22-27* |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 避免阻塞主线程处理复杂任务 | 使用工作线程。 | *22-27* |'
- en: Preparing for this chapter
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: To create the project for this chapter, open a new command prompt, navigate
    to a convenient location, and create a folder named `webapp`. Run the command
    shown in *Listing 4.1* in the `webapp` folder to create the `package.json` file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建本章的项目，打开一个新的命令提示符，导航到一个方便的位置，并创建一个名为 `webapp` 的文件夹。在 `webapp` 文件夹中运行 *列表
    4.1* 中显示的命令，以创建 `package.json` 文件。
- en: 'Listing 4.1: Initializing the project'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1：初始化项目
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the commands shown in *Listing 4.2* in the `webapp` folder to install the
    packages that will be used to compile TypeScript files and monitor files for changes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webapp` 文件夹中运行 *列表 4.2* 中显示的命令，以安装用于编译 TypeScript 文件和监视文件更改的包。
- en: '**Tip**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)下载本章（以及本书中所有其他章节）的示例项目。有关如何获取帮助以运行示例的信息，请参阅*第
    1 章*。
- en: 'Listing 4.2: Installing tool packages'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.2*：安装工具包'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the commands shown in *Listing 4.3* in the `webapp` folder to add the packages
    that will configure the TypeScript compiler for Node.js projects and describe
    the types used by the Node.js API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webapp` 文件夹中运行*列表 4.3*中显示的命令，以添加配置 Node.js 项目的 TypeScript 编译器的包，并描述 Node.js
    API 使用的类型。
- en: Listing 4.3\. Adding the Compiler Configuration and Type Packages
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.3*：添加编译配置和类型包'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To configure the TypeScript compiler, create a file named `tsconfig.json` in
    the `webapp` folder with the contents shown in *Listing 4.4*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 TypeScript 编译器，在 `webapp` 文件夹中创建一个名为 `tsconfig.json` 的文件，其内容如*列表 4.4*所示。
- en: 'Listing 4.4: The contents of the tsconfig.json file in the webapp folder'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.4*：webapp 文件夹中 tsconfig.json 文件的内容'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This configuration file extends the one provided by the TypeScript developers
    for working with Node.js. The TypeScript files will be created in the `src` folder,
    and the compiled JavaScript will be written to the `dist` folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件扩展了 TypeScript 开发者为与 Node.js 一起工作提供的配置文件。TypeScript 文件将在 `src` 文件夹中创建，编译后的
    JavaScript 将写入 `dist` 文件夹。
- en: Open the `package.json` file and add the command shown in *Listing 4.5* to the
    `script` section to define the command that will start the build tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `package.json` 文件，并将*列表 4.5*中显示的命令添加到 `script` 部分，以定义将启动构建工具的命令。
- en: 'Listing 4.5: Adding a Script Command in the package.json File in the webapp
    Folder'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.5*：在 webapp 文件夹中的 package.json 文件中添加脚本命令'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a simple web application
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建简单的 Web 应用程序
- en: With the packages and build tools in place, it is time to create a simple web
    application. Create the `webapp/src` folder and add to it a file named `handler.ts`
    with the content shown in *Listing 4.6*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了包和构建工具之后，是时候创建一个简单的 Web 应用程序了。创建 `webapp/src` 文件夹，并向其中添加一个名为 `handler.ts`
    的文件，其内容如*列表 4.6*所示。
- en: 'Listing 4.6: The contents of the handler.ts file in the src Folder'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.6*：src 文件夹中 handler.ts 文件的内容'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This file defines the code that will process HTTP requests. I describe the HTTP
    features that Node.js provides in *Chapter 5*, but for this chapter, it is enough
    to know that the HTTP request is represented by an `IncomingMessage` object, and
    the response is created using the `ServerResponse` object. The code in *Listing
    4.6* responds to all requests with a simple `Hello World` message.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了将处理 HTTP 请求的代码。我在*第 5 章*中描述了 Node.js 提供的 HTTP 功能，但就本章而言，只需知道 HTTP 请求由一个
    `IncomingMessage` 对象表示，响应是通过使用 `ServerResponse` 对象创建的。*列表 4.6*中的代码对所有请求都返回一个简单的
    `Hello World` 消息。
- en: Next, add a file named `server.ts` to the `src` folder with the content shown
    in *Listing 4.7*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向 `src` 文件夹添加一个名为 `server.ts` 的文件，其内容如*列表 4.7*所示。
- en: 'Listing 4.7: The contents of the server.ts file in the src folder'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.7*：src 文件夹中 server.ts 文件的内容'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code creates a simple HTTP server that listens for HTTP requests on port
    5000 and processes them using the function defined in the `handler.ts` file in
    *Listing 4.6*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个简单的 HTTP 服务器，它监听端口 5000 上的 HTTP 请求，并使用*列表 4.6*中定义的 `handler.ts` 文件中的函数来处理它们。
- en: Add a file named `data.json` to the `webapp` folder with the content shown in
    *Listing 4.8*. This file will be used later in the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webapp` 文件夹中添加一个名为 `data.json` 的文件，其内容如*列表 4.8*所示。此文件将在本章后面使用。
- en: 'Listing 4.8: The contents of the data.json file in the webapp folder'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.8*：webapp 文件夹中 data.json 文件的内容'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the commands shown in *Listing 4.9* in the `webapp` folder to start the
    watcher that will monitor and compile TypeScript files and execute the JavaScript
    that is produced.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webapp` 文件夹中运行*列表 4.9*中显示的命令，以启动监视器，该监视器将监视和编译 TypeScript 文件，并执行生成的 JavaScript。
- en: 'Listing 4.9: Starting the project'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.9*：启动项目'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `server.ts` file in the `src` folder will be compiled to produce a pure
    JavaScript file named `server.js` in the `dist` folder, which will produce the
    following output when it is executed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 文件夹中的 `server.ts` 文件将被编译，生成一个名为 `dist` 文件夹中的 `server.js` 的纯 JavaScript
    文件，当它执行时将产生以下输出：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Open a web browser and navigate to `http://localhost:5000` to send a request
    to the HTTP server, which will produce the response shown in *Figure 4.1*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开网页浏览器并导航到`http://localhost:5000`以向HTTP服务器发送请求，这将产生*图4.1*中显示的响应。
- en: '![](img/B21959_04_01.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_01.png)'
- en: 'Figure 4.1: Running the example application'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：运行示例应用
- en: Understanding (simplified) server code execution
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解（简化的）服务器代码执行
- en: 'A disclaimer is required: this chapter omits some details, is a little loose
    with some explanations, and blurs the lines between some fine details.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个免责声明：本章省略了一些细节，对某些解释有些宽松，并且模糊了一些细微的界限。
- en: The topics covered in this chapter are complex, with endless nuance and detail
    and terminology that means different things on different platforms. And so, with
    brevity in mind, I have focused on what’s important for JavaScript web application
    development, even though that means glossing over some topics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的主题很复杂，有无数的细微差别和细节，以及在不同平台上意味着不同事物的术语。因此，考虑到简洁性，我专注于对JavaScript Web应用开发重要的事项，即使这意味着会忽略一些主题。
- en: Concurrency is a genuinely fascinating subject, and it can be a rewarding area
    of research. But before digging into the details, bear in mind that to be an effective
    JavaScript developer, you only need a basic overview of concurrency – like the
    one in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一个真正有趣的主题，并且可以是一个有回报的研究领域。但在深入细节之前，请记住，要成为一名有效的JavaScript开发者，你只需要对并发有一个基本的概述——就像本章中提到的。
- en: Understanding multi-threaded execution
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解多线程执行
- en: Server-side web applications need to be able to process many HTTP requests simultaneously
    to scale up economically so that a small amount of server capacity can be used
    to support a large number of clients.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端Web应用需要能够同时处理许多HTTP请求，以便经济地扩展规模，这样就可以使用少量的服务器容量来支持大量的客户端。
- en: The conventional approach is to take advantage of the multi-threaded features
    of modern server hardware by creating a pool of handler threads. When a new HTTP
    request arrives, it is added to a queue where it waits until one of the threads
    is available to process it. The thread processes the request, sends the response
    back to the client, and then returns to the queue for the next request.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的做法是利用现代服务器硬件的多线程功能，创建一个处理线程池。当一个新的HTTP请求到达时，它被添加到一个队列中，在那里它等待直到有一个线程可用来处理它。线程处理请求，将响应发送回客户端，然后返回队列等待下一个请求。
- en: The server hardware can execute multiple threads simultaneously, as illustrated
    in *Figure 4.2*, so that a large volume of requests can be received and processed
    concurrently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器硬件可以同时执行多个线程，如图*图4.2*所示，这样就可以并发接收和处理大量请求。
- en: '![](img/B21959_04_02.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_02.png)'
- en: 'Figure 4.2: Handling HTTP requests concurrently'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：并发处理HTTP请求
- en: This approach makes full use of the server hardware, but it requires developers
    to consider how requests might interfere with each other. A common problem is
    that one handler thread modifies data as it is being read by another thread, producing
    an unexpected result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法充分利用了服务器硬件，但它要求开发者考虑请求可能会相互干扰。一个常见的问题是，一个处理线程在另一个线程读取数据时修改数据，从而产生意外的结果。
- en: To avoid this kind of issue, most programming languages include keywords that
    are used to restrict interactions between threads. The details vary, but keywords
    like `lock` and `synchronize` are used to ensure that threads safely use shared
    resources and data by creating protected regions of code that can only be executed
    by one thread at a time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这类问题，大多数编程语言都包含用于限制线程之间交互的关键字。具体细节各异，但像`lock`和`synchronize`这样的关键字被用来确保线程通过创建只能由一个线程同时执行的代码保护区域来安全地使用共享资源和数据。
- en: Writing code that uses threads is a balance of safety and performance. Protected
    regions of code are potential performance bottlenecks, and if protections are
    applied too widely, then performance suffers and the number of requests that can
    be processed concurrently falls. However, requests may interfere with one another
    and produce unexpected results if protections are applied too sparsely.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编写使用线程的代码需要在安全和性能之间取得平衡。代码的保护区域可能是性能瓶颈，如果保护措施应用得太广泛，那么性能会受到影响，可以并发处理的请求数量也会减少。然而，如果保护措施应用得太少，请求可能会相互干扰并产生意外的结果。
- en: Understanding blocking and non-blocking operations
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解阻塞和非阻塞操作
- en: In most server-side applications, the thread processing an HTTP request spends
    most of its time waiting. This can be waiting for a database to produce a result,
    waiting for the next chunk of data from a file, or waiting for access to a protected
    region of code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数服务器端应用程序中，处理HTTP请求的线程大部分时间都在等待。这可能是在等待数据库生成结果，等待从文件中获取下一块数据，或者等待访问受保护的代码区域。
- en: When a thread is waiting, it is said to be *blocked*. A blocked thread is unable
    to do any other work until the operation it is waiting for has been completed,
    during which time the capacity of the server to process requests is reduced. In
    busy applications, there is a constant flow of new requests arriving, and having
    threads tied up doing nothing leads to queues of requests waiting to be processed
    and reduced overall throughput.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程在等待时，我们称它为*阻塞*。一个阻塞的线程在等待的操作完成之前无法执行任何其他工作，在此期间，服务器处理请求的能力会降低。在繁忙的应用程序中，新请求的流入是持续的，而让线程闲置不工作会导致请求队列堆积，从而降低整体吞吐量。
- en: 'One solution is to use *non-blocking* operations, also known as *asynchronous*
    operations. These terms can be confusing. The best way to understand them is with
    a real-world example: a pizza restaurant.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是使用*非阻塞*操作，也称为*异步*操作。这些术语可能会让人困惑。理解它们最好的方式是通过一个现实世界的例子：一家披萨餐厅。
- en: Imagine that, after taking an order, an employee in the restaurant went into
    the kitchen, assembled your pizza, put it in the oven, stood there waiting for
    it to cook for 10 minutes, and then served it to you. This is the blocking – or
    synchronous – approach to preparing pizza. Customers will be happy if they enter
    the restaurant when there is an employee available to take an order because they
    will get their pizza in the shortest amount of time. But no one else is happy.
    The other customers in the queue aren’t happy because they have to wait in the
    queue while pizzas for all of the customers ahead of them are assembled, cooked,
    and served, at which point an employee will be available to make their pizza.
    The restaurant owner is unhappy because the pizza throughput is equal to the number
    of employees, who spend most of their time waiting for pizza to cook.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在接单后，餐厅的一名员工走进厨房，组装你的披萨，把它放进烤箱，站在那里等待10分钟，然后把它端给你。这就是阻塞——或者说同步——的披萨制作方法。如果顾客在有空闲员工接单时进入餐厅，他们会很高兴，因为他们可以最快地得到披萨。但其他人不会高兴。排队等候的其他顾客不会高兴，因为他们必须等待，直到他们前面的所有顾客的披萨都组装好、烤好并上桌，这时才有员工可以为他们制作披萨。餐厅老板也不高兴，因为披萨的吞吐量等于员工数量，而员工大部分时间都在等待披萨烤熟。
- en: There is a more sensible approach. One employee – let’s name them Bob – is given
    the job of monitoring the oven. The other employees take orders, assemble the
    pizzas, and put them in the oven just as before, but rather than waiting for them
    to cook, they ask Bob to tell them when the pizza is cooked.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更合理的方法。一个员工——让我们称他为鲍勃——被分配了监控烤箱的任务。其他员工像以前一样接单、组装披萨，并将它们放入烤箱，但他们不会等待披萨烤熟，而是让鲍勃告诉他们披萨何时烤好。
- en: While Bob watches the pizzas in the oven, the employees can carry on working,
    taking the order of the next customer in the queue, preparing the next pizza,
    and so on. Bob can watch lots of pizzas, so the limit to the number of pizzas
    that can be produced is the size of the oven and not the number of employees.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当鲍勃在烤箱里观察披萨时，其他员工可以继续工作，为队列中的下一个顾客接单，准备下一个披萨，等等。鲍勃可以观察很多披萨，所以能生产的披萨数量限制是烤箱的大小，而不是员工数量。
- en: Cooking a pizza has become a non-blocking operation for everyone except Bob.
    There is no way around waiting for the oven, but the performance of the restaurant
    is improved by making one person do all the waiting. Everyone is happy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除了鲍勃之外的所有人来说，烤披萨已经变成了一种非阻塞操作。等待烤箱是没有办法绕过的，但通过让一个人做所有的等待，餐厅的效率得到了提高。每个人都感到高兴。
- en: 'Well, almost. The owner is happy because the restaurant produces more pizzas.
    The customers in the queue are happy because employees can start working on their
    pizza while Bob is watching earlier orders. But individual orders may take longer:
    Bob may tell another employee that a pizza is ready, but they won’t be able to
    serve it if they are busy with another customer. The overall restaurant performance
    improves, but individual orders may take longer to complete.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，几乎是这样。餐厅老板很高兴，因为餐厅能生产更多的披萨。排队等候的顾客也很高兴，因为员工可以在鲍勃查看早先订单的同时开始制作他们的披萨。但个别订单可能需要更长的时间：鲍勃可能会告诉另一个员工披萨已经准备好了，但如果他们正忙于服务其他顾客，他们可能无法提供服务。整体餐厅的表现有所提高，但个别订单可能需要更长的时间来完成。
- en: The same approach can be taken with HTTP requests, as shown in *Figure 4.3*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以采用与*图4.3*所示相同的方法来处理HTTP请求。
- en: '![](img/B21959_04_03.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_03.png)'
- en: 'Figure 4.3: Freeing request handlers from a blocking operation'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：从阻塞操作中释放请求处理器
- en: Instead of waiting for an operation to complete, handler threads rely on a monitor
    thread while they continue to process requests from the queue. When the blocking
    operation has finished, the monitor thread puts the request back in the queue
    so that a handler thread can continue processing the request.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器线程在继续处理队列中的请求的同时，依赖于监控线程而不是等待操作完成。当阻塞操作完成后，监控线程将请求放回队列，以便处理器线程可以继续处理该请求。
- en: The process of handing off an operation for monitoring is usually integrated
    into the API used to write web applications, so that performing a read from a
    file, for example, automatically releases the handler thread so it can do other
    work and can be trusted to put the request in the queue for processing when the
    file read operation is complete.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将操作委托给监控的过程通常集成到用于编写Web应用的API中，这样从文件中读取数据等操作会自动释放处理器线程，使其能够执行其他工作，并且可以信赖它在文件读取操作完成后将请求放入队列以进行处理。
- en: It is important to understand that the terms *non-blocking* and *asynchronous*
    are from the perspective of the handler thread. The operations still take time
    to complete, but the handler thread can do other work during that period. There
    are still blocking threads, but they are not the ones responsible for processing
    HTTP requests, which are the threads we care about the most.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，*非阻塞*和*异步*这两个术语是从处理器线程的角度出发的。操作仍然需要时间来完成，但在那段时间内处理器线程可以执行其他工作。仍然存在阻塞线程，但它们不是负责处理HTTP请求的线程，这是我们最关心的线程。
- en: Understanding JavaScript code execution
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解JavaScript代码执行
- en: JavaScript’s origins as a browser-based language have shaped the way that JavaScript
    code is written and executed. JavaScript was originally used to provide user interaction
    with HTML elements. Each type of element defines *events* that describe the different
    ways the user can interact with that element. A button element, for example, has
    events for when the user clicks the button, moves the pointer over the button,
    and so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种基于浏览器的语言，JavaScript的起源塑造了JavaScript代码的编写和执行方式。JavaScript最初用于提供用户与HTML元素的交互。每种类型的元素都定义了*事件*，描述了用户与该元素交互的不同方式。例如，按钮元素有用户点击按钮、将指针移至按钮上等事件。
- en: The programmer writes JavaScript functions, known as *callbacks*, and uses the
    browser’s API to associate those functions with specific events on elements. When
    the browser detects an event, it adds the callback to a queue so it can be executed
    by the JavaScript runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员编写称为*回调*的JavaScript函数，并使用浏览器的API将这些函数与元素上的特定事件关联起来。当浏览器检测到事件时，它会将回调添加到队列中，以便由JavaScript运行时执行。
- en: The JavaScript runtime has a single thread – called the *main thread* – that
    is responsible for executing the callbacks. The main thread runs in a loop, taking
    callbacks from the queue and executing them, which is referred to as the JavaScript
    *event loop*. The event loop is how the native code of the browser, which is written
    for a specific operating system, interacts with the JavaScript code, which runs
    on any compatible runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript运行时有一个单独的线程，称为*主线程*，负责执行回调。主线程在一个循环中运行，从队列中取出回调并执行它们，这被称为JavaScript的*事件循环*。事件循环是浏览器原生代码（为特定操作系统编写）与在任意兼容运行时上运行的JavaScript代码交互的方式。
- en: '**Note**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The event loop is more complicated but the idea of a queue of callbacks is close
    enough for effective JavaScript web development. The details are worth exploring
    if you, like me, find this sort of thing interesting. A good place to start is
    [https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环更复杂，但回调队列的概念对于有效的JavaScript网络开发已经足够接近。如果你像我一样对此类事物感兴趣，这些细节值得探索。一个不错的起点是[https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick)。
- en: Events often occur in clusters, such as when the pointer moves across several
    elements, and so the queue can contain multiple callbacks waiting to be executed,
    as shown in *Figure 4.4*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常成簇发生，例如当指针跨越多个元素时，因此队列可以包含多个等待执行的回调，如图*4.4*所示。
- en: '![](img/B21959_04_04.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_04.png)'
- en: 'Figure 4.4: The callback queue'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：回调队列
- en: Using a single thread means that any operation in a callback that takes time
    to complete causes the application to freeze as callbacks queue up waiting to
    be processed. To help manage this issue, many browser API features are non-blocking
    and use the callback pattern to deliver their results.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单线程意味着任何需要时间完成的回调操作都会导致应用程序冻结，因为回调队列正在等待处理。为了帮助管理这个问题，许多浏览器API特性是非阻塞的，并使用回调模式来传递它们的结果。
- en: Over the years, features have been added to the JavaScript language and the
    browser APIs, but the event loop and callback functions are used to execute JavaScript.
    The API the browser provides for HTTP requests, for example, defines a series
    of events that describe the request lifecycle, and these events are handled with
    callback functions, as shown in *Figure 4.5*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，JavaScript语言和浏览器API已经添加了功能，但事件循环和回调函数用于执行JavaScript。例如，浏览器提供的HTTP请求API定义了一系列描述请求生命周期的事件，这些事件通过回调函数处理，如图*4.5*所示。
- en: '![](img/B21959_04_05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_05.png)'
- en: 'Figure 4.5: Results from the browser API are processed with JavaScript callback
    functions'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：浏览器API的结果通过JavaScript回调函数处理
- en: Behind the scenes, the browser uses native threads to perform the HTTP request
    and wait for the response, which is then passed to the JavaScript runtime using
    a callback.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，浏览器使用原生线程执行HTTP请求并等待响应，然后通过回调将响应传递给JavaScript运行时。
- en: The JavaScript runtime only ever executes one callback, so the JavaScript language
    doesn’t need keywords like `lock` and `synchronize`. JavaScript code interacts
    with the browser through an API that hides away the implementation details and
    receives results consistently.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript运行时只执行一个回调，因此JavaScript语言不需要像`lock`和`synchronize`这样的关键字。JavaScript代码通过一个API与浏览器交互，该API隐藏了实现细节并一致地接收结果。
- en: Understanding Node.js code execution
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Node.js代码执行
- en: 'Node.js retains the main thread and the event loop, which means that server-side
    code is executed in the same way as client-side JavaScript. For HTTP servers,
    the main thread is the only request handler, and callbacks are used to handle
    incoming HTTP connections. The example application demonstrates the use of a callback
    to handle an HTTP request:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js保留了主线程和事件循环，这意味着服务器端代码以与客户端JavaScript相同的方式执行。对于HTTP服务器，主线程是唯一的请求处理器，回调用于处理传入的HTTP连接。示例应用程序演示了如何使用回调来处理HTTP请求：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The callback function passed to the `createServer` function will be invoked
    when Node.js receives an HTTP connection. The function defines parameters that
    represent the request that has been received and the response that will be returned
    to the client:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当Node.js收到HTTP连接时，传递给`createServer`函数的回调函数将被调用。该函数定义了代表已接收请求和将返回给客户端的响应的参数：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I describe the API Node.js provides for HTTP in *Chapter 5*, but the callback
    function uses its parameters to prepare the response that will be sent to the
    client. The details of how Node.js receives HTTP requests and returns HTTP responses
    are hidden away in native code, as shown in *Figure 4.6*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*第五章*中描述了Node.js提供的HTTP API，但回调函数使用其参数来准备将发送给客户端的响应。Node.js接收HTTP请求和返回HTTP响应的细节被隐藏在原生代码中，如图*4.6*所示。
- en: '![](img/B21959_04_06.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_06.png)'
- en: 'Figure 4.6: Handling HTTP requests in Node.js'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：在Node.js中处理HTTP请求
- en: Node.js may only have a single handler thread, but the performance can be excellent
    because modern server hardware is incredibly fast. Even so, a single thread doesn’t
    take full advantage of the multi-core and multi-processor hardware to which most
    applications are deployed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Node.js 可能只有一个处理线程，但由于现代服务器硬件非常快，性能可以非常出色。即便如此，单个线程并没有充分利用大多数应用程序部署的多核和多处理器硬件。
- en: To scale up, multiple instances of Node.js are started. HTTP requests are received
    by a load balancer (or ingress controller or primary node, depending on how the
    application is deployed, as described in *Part 3*) and distributed to the Node.js
    instances, as shown in *Figure 4.7*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展，启动多个 Node.js 实例。HTTP 请求由负载均衡器（或入口控制器或主节点，具体取决于应用程序的部署方式，如第 3 部分所述）接收，并分配给
    Node.js 实例，如图 4.7 所示。
- en: '![](img/B21959_04_07.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_04_07.png)'
- en: 'Figure 4.7: Scaling up with multiple Node.js instances'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：使用多个 Node.js 实例进行扩展
- en: The individual Node.js instances still have a single JavaScript thread but collectively
    they can process a higher volume of requests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 Node.js 实例仍然只有一个 JavaScript 线程，但它们可以集体处理更高的请求量。
- en: 'One important consequence of applying the JavaScript execution model to HTTP
    requests is that blocking the main thread stops all requests from being processed
    by that Node.js instance, creating the same kind of deadlock that can arise in
    client-side JavaScript. Node.js helps programmers avoid blocking the main thread
    in two ways: an API that performs many tasks asynchronously, known as the *worker
    pool*, and support for starting extra threads to execute blocking JavaScript code,
    known as *worker threads*. Both of these features are described in the sections
    that follow.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JavaScript 执行模型应用于 HTTP 请求的一个重要后果是，阻塞主线程将阻止该 Node.js 实例处理所有请求，从而产生类似于客户端 JavaScript
    中可能出现的死锁。Node.js 通过两种方式帮助程序员避免阻塞主线程：一个执行许多异步任务的 API，称为 *工作池*，以及支持启动额外的线程来执行阻塞
    JavaScript 代码，称为 *工作线程*。这两个特性将在接下来的章节中描述。
- en: Using the Node.js API
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js API
- en: Node.js replaces the API provided by the browser with one that supports common
    server-side tasks, such as processing HTTP requests and reading files. Behind
    the scenes, Node.js uses native threads, known as the worker pool, to perform
    operations asynchronously.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 用支持常见服务器端任务（如处理 HTTP 请求和读取文件）的 API 替换了浏览器提供的 API。在幕后，Node.js 使用称为工作池的本地线程来异步执行操作。
- en: To demonstrate, *Listing 4.10* uses the Node.js API to read the contents of
    a file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，*列表 4.10* 使用 Node.js API 读取文件内容。
- en: 'Listing 4.10: Using the Node.js API in the handler.ts File in the src Folder'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10：在 src 文件夹的 handler.ts 文件中使用 Node.js API
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As its name suggests, the `readFile` function reads the contents of a file.
    Use a web browser to request `http://localhost:5000` and you will see the output
    shown in *Figure 4.8*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`readFile` 函数读取文件的正文。使用网页浏览器请求 `http://localhost:5000`，你将看到图 4.8 所示的输出。
- en: '![](img/B21959_04_08.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_04_08.png)'
- en: 'Figure 4.8: Sending the contents of a file to the client'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：将文件内容发送到客户端
- en: The read operation is asynchronous and is implemented using a native thread.
    The contents of the file are passed to a callback function, which sends them to
    the HTTP client.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 读取操作是异步的，并使用本地线程实现。文件内容传递给一个回调函数，该函数将它们发送到 HTTP 客户端。
- en: 'There are three callbacks in the code. The first callback is the one passed
    to the `createServer` function, which is invoked when an HTTP request is received:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有三个回调函数。第一个回调是传递给 `createServer` 函数的，当接收到 HTTP 请求时被调用：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second callback is the one passed to the `readFile` function, which is
    invoked when the contents of the file have been read or if an error occurs:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个回调是传递给 `readFile` 函数的，当文件内容被读取或发生错误时被调用：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I used type annotations to help describe the way the results from reading the
    file are presented. The type of the first argument of the callback is `Error |
    null` and is used to indicate the outcome. If the first argument is `null`, then
    the operation has been completed successfully, and the contents of the file will
    be available in the second argument, whose type is `Buffer`. (Buffers are how
    Node.js represents arrays of bytes.) If the first argument isn’t `null`, then
    the `Error` object will provide details of the problem that prevented the file
    from being read.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用类型注解来帮助描述读取文件的结果的呈现方式。回调的第一个参数的类型是 `Error | null`，用于指示结果。如果第一个参数是 `null`，则操作已成功完成，文件的內容将在第二个参数中可用，其类型是
    `Buffer`。（Buffer 是 Node.js 表示字节数组的方式。）如果第一个参数不是 `null`，则 `Error` 对象将提供阻止读取文件的问题的详细信息。
- en: '**Note**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You may see two messages written to the command prompt when you send an HTTP
    request from a browser. Browsers often request the `favicon.ico` file to get an
    icon that can be displayed in the tab header, and this is the reason why you will
    sometimes see `File sent` appear twice in the output.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从浏览器发送 HTTP 请求时，您可能会在命令提示符中看到两条消息。浏览器通常会请求 `favicon.ico` 文件以获取可以在标签页标题中显示的图标，这就是为什么您有时会在输出中看到两次出现
    `File sent` 的原因。
- en: 'The third callback is invoked when the data read from the file has been sent
    to the client:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当从文件中读取的数据已发送到客户端时，将调用第三个回调：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Breaking up the process of producing an HTTP response with callbacks means that
    the JavaScript main thread doesn’t have to wait for the file system to read the
    contents of the file, and this allows requests from other clients to be processed,
    as illustrated in *Figure 4.9*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调分解生成 HTTP 响应的过程意味着 JavaScript 主线程不需要等待文件系统读取文件的内容，这允许处理来自其他客户端的请求，如图 *4.9*
    所示。
- en: '![](img/B21959_04_09.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_09.png)'
- en: 'Figure 4.9: Breaking down request handling with multiple callbacks'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：使用多个回调分解请求处理
- en: Handling events
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件
- en: Events are used to provide notifications that the state of the application has
    changed and provide an opportunity to execute a callback function to handle that
    change. Events are used throughout the Node.js API, although there are often convenience
    features that hide away the details. *Listing 4.11* revises the code that listens
    for HTTP requests to use events directly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 事件用于提供通知，表明应用程序的状态已更改，并提供执行回调函数以处理该更改的机会。事件在 Node.js API 中被广泛使用，尽管通常有一些便利功能隐藏了细节。*列表
    4.11* 修改了监听 HTTP 请求的代码，以直接使用事件。
- en: 'Listing 4.11: Handling Events in the server.ts File in the src Folder'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11：在 src 文件夹中的 server.ts 文件中处理事件
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Many of the objects created with the Node.js API extend the `EventEmitter` class,
    which denotes a source of events. The `EventEmitter` class defines the methods
    described in *Table 4.3* for receiving events.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用 Node.js API 创建的对象扩展了 `EventEmitter` 类，这表示事件源。`EventEmitter` 类定义了 *表 4.3*
    中描述的方法来接收事件。
- en: 'Table 4.3: Useful eventemitter methods'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3：有用的 eventemitter 方法
- en: '| Name | Description |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| This method registers a `callback` to be invoked whenever the specified event
    is emitted. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 此方法注册一个 `回调`，以便在指定事件被触发时执行。 |'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| This method stops invoking the `callback` when the specific event is emitted.
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 此方法在特定事件被触发时停止调用 `回调`。 |'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This method registers a `callback` to be invoked the next time the specified
    event is emitted but not thereafter. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 此方法注册一个`回调`，以便在指定事件被触发时执行，但之后不再执行。 |'
- en: 'Classes that extend `EventEmitter` define events and specify when they will
    be emitted. The `Server` class returned by the `createServer` method extends `EventEmitter`
    and it defines two events that are used in *Listing 4.11*: the `request` and `listening`
    events. The code in *Listing 4.7* and *Listing 4.11* has the same effect and the
    only difference is that the `createServer` function registers its function argument
    as a callback for the `request` event behind the scenes, while the `listen` method
    registers its function argument as a callback for the `listening` event.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `EventEmitter` 的类定义事件并指定它们何时被触发。由 `createServer` 方法返回的 `Server` 类扩展了 `EventEmitter`
    并定义了在 *列表 4.11* 中使用的两个事件：`request` 和 `listening` 事件。*列表 4.7* 和 *列表 4.11* 中的代码具有相同的效果，唯一的区别是
    `createServer` 函数在幕后将其函数参数注册为 `request` 事件的回调，而 `listen` 方法将其函数参数注册为 `listening`
    事件的回调。
- en: It is important to understand that events are an integral part of the Node.js
    API and that they can be used directly, with the methods described in *Table 4.3*,
    or indirectly through other features.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解事件是 Node.js API 的一个重要部分，并且可以直接使用 *表4.3* 中描述的方法使用，或者通过其他功能间接使用。
- en: Working with promises
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用承诺
- en: Promises are an alternative to callbacks and some parts of the Node.js API provide
    features using both callbacks and promises. A promise serves the same purpose
    as a callback, which is to define the code that will be executed when an asynchronous
    operation is completed. The difference is that code written with promises can
    often be simpler than the equivalent code using callbacks. One part of the API
    where Node.js provides promises and callbacks is for working with files, as shown
    in *Listing 4.12*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是回调和 Node.js API 的一些部分的替代方案。承诺与回调具有相同的目的，即定义异步操作完成后将执行的代码。不同之处在于，使用承诺编写的代码通常比使用回调编写的代码更简单。Node.js
    提供承诺和回调的 API 部分之一是用于处理文件，如 *列表4.12* 所示。
- en: 'Listing 4.12: Using a Promise in the handler.ts File in the src Folder'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12：在 src 文件夹的 handler.ts 文件中使用承诺
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This isn’t how promises are usually used, which is why the code looks more
    complex than earlier examples. But this code emphasizes the way that promises
    work. This is the statement that creates the promise:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常不是承诺的使用方式，这就是为什么代码看起来比之前的例子更复杂。但这段代码强调了承诺的工作方式。这是创建承诺的语句：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `readFile` function has the same name as the function used for callbacks
    but is defined in the `fs/promises` module. The result returned by the `readFile`
    function is `Promise<Buffer>`, which is a promise that will produce a `Buffer`
    object when its asynchronous operation is complete.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile` 函数与用于回调的函数具有相同的名称，但它在 `fs/promises` 模块中定义。`readFile` 函数返回的结果是 `Promise<Buffer>`，这是一个异步操作完成后将产生
    `Buffer` 对象的承诺。'
- en: '**Understanding when synchronous methods are useful**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解何时同步方法是有用的**'
- en: In addition to callbacks and promises, some parts of the Node.js API also offer
    synchronous features that block the main thread until they are complete. One example
    is the `readFileSync` function, which performs the same task as `readFile`, but
    blocks execution until the file contents have been read.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了回调和承诺之外，Node.js API 的某些部分也提供了同步功能，这些功能会在完成之前阻塞主线程。一个例子是 `readFileSync` 函数，它执行与
    `readFile` 相同的任务，但会阻塞执行直到文件内容被读取。
- en: In most cases, you should use the non-blocking features that Node.js provides
    to maximize the number of requests that Node.js can handle, but there are two
    situations when blocking operations make more sense. The first situation arises
    when you know for certain that the operations will be completed so quickly that
    it is quicker than setting up a promise or a callback. There is a resource and
    time cost associated with performing an asynchronous operation and this can sometimes
    be avoided. This situation doesn’t arise often, and you should carefully consider
    the potential performance impact.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你应该使用 Node.js 提供的非阻塞功能来最大化 Node.js 可以处理的请求数量，但有两种情况下阻塞操作更有意义。第一种情况出现在你知道操作将很快完成，以至于比设置承诺或回调更快时。执行异步操作会有资源和时间成本，有时可以避免这种情况。这种情况并不常见，你应该仔细考虑潜在的性能影响。
- en: The second situation is more common, and that’s when you know that the next
    block of code that the main thread will execute will be the result of the operation
    you are about to perform. You can see an example of this in *Chapter 6*, where
    I read configuration files synchronously before Node.js starts listening for HTTP
    requests.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况更为常见，那就是当你知道主线程将要执行的下一段代码将是你要执行的操作的结果时。你可以在 *第6章* 中看到一个例子，我在 Node.js 开始监听
    HTTP 请求之前同步地读取配置文件。
- en: 'Promises are either *resolved* or *rejected*. A promise that completes successfully
    and produces its result is resolved. The `then` method is used to register the
    function that will be invoked if the promise is resolved, meaning that the file
    has been read successfully, like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺要么是 *已解决* 的，要么是 *被拒绝* 的。一个成功完成并产生其结果的承诺是已解决的。`then` 方法用于注册当承诺解决时将被调用的函数，这意味着文件已成功读取，如下所示：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A rejected promise is one where an error has occurred. The `catch` method is
    used to register a function that handles the error produced by a rejected promise,
    like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 被拒绝的承诺是指发生了错误的承诺。使用 `catch` 方法来注册一个处理被拒绝的承诺产生的错误的函数，如下所示：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that using a promise doesn’t change the data types used to describe
    the outcomes: a `Buffer` is used to describe the data read from the file and an
    `Error` is used to describe errors.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用承诺不会改变用于描述结果的数据类型：使用 `Buffer` 来描述从文件中读取的数据，使用 `Error` 来描述错误。
- en: The use of the `then` and `catch` methods separates successful results from
    errors, unlike the callback API, which presents both and requires the callback
    function to work out what happened.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `then` 和 `catch` 方法将成功的结果与错误分开，这与回调 API 不同，后者将两者都展示出来，并要求回调函数确定发生了什么。
- en: The `then` and `catch` methods can be chained together, which is one small improvement
    in simplifying the code, as shown in *Listing 4.13*, and is a more typical way
    to use promises.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`then` 和 `catch` 方法可以串联在一起，这是简化代码的一个小改进，如 *列表 4.13* 所示，并且是使用承诺的更典型方式。'
- en: 'Listing 4.13: Chaining promise methods in the handler.ts file in the src folder'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13：在 src 文件夹中的 handler.ts 文件中链式调用承诺方法
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is a little neater, but the real improvement comes with the use of the
    `async` and `await` keywords, which allow asynchronous operations to be performed
    using syntax that doesn’t require nested functions or chained methods, as shown
    in *Listing 4.14*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更整洁，但真正的改进来自于使用 `async` 和 `await` 关键字，这使得可以使用不需要嵌套函数或链式方法的语法来执行异步操作，如 *列表
    4.14* 所示。
- en: 'Listing 4.14: Using the async and await Keywords in the handler.ts File in
    the src Folder'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14：在 src 文件夹中的 handler.ts 文件中使用 async 和 await 关键字
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the `async` and `await` keywords flattens the code by removing the need
    for the `then` method and its function. The `async` keyword is applied to the
    function used to handle requests:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async` 和 `await` 关键字通过移除对 `then` 方法和其函数的需求来简化代码。`async` 关键字应用于处理请求的函数：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `await` keyword is applied to statements that return promises, like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 关键字应用于返回承诺的语句，如下所示：'
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These keywords don’t change the behavior of the `readFile` function, which still
    reads a file asynchronously and still returns a `Promise<Buffer>`, but the JavaScript
    runtime takes the result asynchronously produced by the promise, a `Buffer` object
    in this case, assigns it to a constant named `data`, and then executes the statements
    that follow. The result is the same – and the way that the result is obtained
    is also the same – but the syntax is simpler and easier to read.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字不会改变 `readFile` 函数的行为，它仍然异步读取文件，并仍然返回一个 `Promise<Buffer>`，但 JavaScript
    运行时会异步地获取由 promise 产生的结果，在这个例子中是一个 `Buffer` 对象，将其分配给一个名为 `data` 的常量，然后执行后续的语句。结果是相同的——以及获取结果的方式也是相同的——但语法更简单，更容易阅读。
- en: This isn’t the final version of the code. To support error handling, the `catch`
    method used on `Promise` objects is replaced with a `try/catch` block when using
    the `await` keyword, as shown in *Listing 4.15*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是代码的最终版本。为了支持错误处理，当使用 `await` 关键字时，将 `Promise` 对象上使用的 `catch` 方法替换为 `try/catch`
    块，如 *列表 4.15* 所示。
- en: 'Listing 4.15: Adding error handling in the handler.ts file in the src folder'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15：在 src 文件夹中的 handler.ts 文件中添加错误处理
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The type of the value provided to the `catch` exception is `any`, not `Error`,
    because JavaScript doesn’t restrict the types that can be used to represent errors.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `catch` 异常的值的类型是 `any`，而不是 `Error`，因为 JavaScript 不限制用于表示错误的类型。
- en: '**Tip**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: One advantage of callbacks over promises is that callbacks can be invoked more
    than once for the same operation, allowing a series of updates to be provided
    while asynchronous work is being performed. Promises are intended to produce a
    single result without any interim updates. You can see an example of this difference
    at the end of the chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与承诺相比，回调的一个优点是回调可以在同一操作中多次被调用，允许在异步工作执行期间提供一系列更新。承诺旨在产生一个单一的结果，而不提供任何中间更新。你可以在本章末尾看到一个这种差异的例子。
- en: Wrapping callbacks and unwrapping promises
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装回调和展开承诺
- en: 'Not every part of the Node.js API supports both promises and callbacks, and
    that can lead to both approaches being mixed in the same code. You can see this
    problem in the example, where the `readFile` function returns a promise, but the
    `end` method, which sends data to the client and finishes the HTTP response, uses
    a callback:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'Not every part of the Node.js API supports both promises and callbacks, and
    that can lead to both approaches being mixed in the same code. You can see this
    problem in the example, where the `readFile` function returns a promise, but the
    `end` method, which sends data to the client and finishes the HTTP response, uses
    a callback:'
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The promise and callback APIs can be mixed without problems, but the result
    can be awkward code. To help ensure consistency, the Node.js API includes two
    useful functions in the `util` module, which are described in *Table 4.4*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: The promise and callback APIs can be mixed without problems, but the result
    can be awkward code. To help ensure consistency, the Node.js API includes two
    useful functions in the `util` module, which are described in *Table 4.4*.
- en: 'Table 4.4: The Functions for wrapping callbacks and unwrapping promises'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4：包装回调和展开 promise 的函数
- en: '| Name | Description |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| Name | Description |'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| This function creates a `Promise` from a function that accepts a conventional
    callback. The convention is that the arguments passed to the callback are an error
    object and the result of the operation. There is support for other arrangements
    of arguments using a custom symbol – see [https://nodejs.org/docs/latest/api/util.html#utilpromisifycustom](https://nodejs.org/docs/latest/api/util.html#utilpromisifycustom)
    for details. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| This function creates a `Promise` from a function that accepts a conventional
    callback. The convention is that the arguments passed to the callback are an error
    object and the result of the operation. There is support for other arrangements
    of arguments using a custom symbol – see [https://nodejs.org/docs/latest/api/util.html#utilpromisifycustom](https://nodejs.org/docs/latest/api/util.html#utilpromisifycustom)
    for details. |'
- en: '|'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| This function accepts a `Promise` object and returns a function that will
    accept a conventional callback. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| This function accepts a `Promise` object and returns a function that will
    accept a conventional callback. |'
- en: The idea behind these functions is good, but they have limitations, especially
    when trying to create promises from callbacks so that the `await` keyword can
    be used. The biggest restriction is that the `promisify` function doesn’t work
    seamlessly on class methods unless care is taken to deal with the way that JavaScript
    handles the `this` keyword. There is also an issue specific to TypeScript, where
    the compiler doesn’t correctly identify the types involved.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数背后的想法是好的，但它们有一些限制，尤其是在尝试从回调创建 promise 以使用 `await` 关键字时。最大的限制是，除非小心处理 JavaScript
    处理 `this` 关键字的方式，否则 `promisify` 函数在类方法上不会无缝工作。此外，TypeScript 也有一个特定的问题，编译器没有正确识别涉及的类型。
- en: Add a file named `promises.ts` to the `src` folder with the contents shown in
    *Listing 4.16*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹中添加一个名为 `promises.ts` 的文件，其内容如 *列表 4.16* 所示。
- en: 'Listing 4.16: The Contents of the promises.ts File in the src Folder'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16：src 文件夹中 promises.ts 文件的内容
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first step is to use `promisify` to create a function that returns a promise,
    which I do by passing the `ServerResponse.prototype.end` function to `promisify`.
    I use the `as` keyword to override the type inferred by the TypeScript compiler
    with a description of the method parameters and result:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'The first step is to use `promisify` to create a function that returns a promise,
    which I do by passing the `ServerResponse.prototype.end` function to `promisify`.
    I use the `as` keyword to override the type inferred by the TypeScript compiler
    with a description of the method parameters and result:'
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 4.17* imports the function defined in *Listing 4.16* and uses the
    promise it produces.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4.17* 导入了在 *列表 4.16* 中定义的函数，并使用了它产生的 promise。'
- en: 'Listing 4.17: Using a Promise in the handler.ts File in the src Folder'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17：src 文件夹中 handler.ts 文件中使用 Promise
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I have to use the `bind` method when using the `await` keyword on the function
    that `promisify` creates, like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `promisify` 创建的函数上使用 `await` 关键字时，我必须使用 `bind` 方法，如下所示：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `bind` method associates the `ServerResponse` object for which the function
    is being invoked. The result is a new function, which is invoked by passing the
    data that will be sent to the client:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `bind` method associates the `ServerResponse` object for which the function
    is being invoked. The result is a new function, which is invoked by passing the
    data that will be sent to the client:'
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result is that the `await` keyword can be used instead of the callback,
    even though it is a slightly awkward process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: The result is that the `await` keyword can be used instead of the callback,
    even though it is a slightly awkward process.
- en: Executing custom code
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行自定义代码
- en: All JavaScript code is executed by the main thread, which means that any operation
    that doesn’t use the non-blocking API provided by Node.js will block the thread.
    For the sake of consistency, add the statement shown in *Listing 4.18* to the
    `promises.ts` file to wrap the `write` method defined by the `ServerResponse`
    class in a promise.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有JavaScript代码都是由主线程执行的，这意味着任何不使用Node.js提供的非阻塞API的操作都会阻塞线程。为了保持一致性，将*列表4.18*中显示的语句添加到`promises.ts`文件中，以便将`ServerResponse`类定义的`write`方法包装在一个promise中。
- en: 'Listing 4.18: Adding a Function in the promises.ts File in the src Folder'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.18：在src文件夹中的promises.ts文件中添加函数
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 4.19* filters out the requests for the `favicon.ico` file, which was
    fine in earlier examples, but will add unwanted requests in this section.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4.19*过滤掉了对`favicon.ico`文件的请求，这在早期示例中是可行的，但在这个部分会添加不需要的请求。'
- en: 'Listing 4.19: Filtering Requests in the server.ts File in the src Folder'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.19：在src文件夹中的server.ts文件中过滤请求
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 4.20* demonstrates the problem of thread blocking by introducing a
    time-consuming operation that is implemented entirely in JavaScript.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4.20*通过引入一个完全在JavaScript中实现的耗时操作，展示了线程阻塞的问题。'
- en: 'Listing 4.20: A Blocking Operation in the handler.ts File in the src Folder'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.20：在src文件夹中的handler.ts文件中的阻塞操作
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Two `for` loops repeatedly increment a number value and, since this operation
    is written entirely in JavaScript, the main thread is blocked until both the loops
    have completed. To see the effect of the blocked thread, open two browser tabs
    and request [http://localhost:5000](http://localhost:5000) in both of them. You
    need to start the request in the second tab before the first one has finished,
    and you may need to adjust the `total` value to give yourself time. The `total`
    value in *Listing 4.20* takes three or four seconds to complete on my system,
    which is long enough to start requests in both browser tabs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`for`循环反复递增一个数值，由于这个操作完全是用JavaScript编写的，主线程在两个循环完成之前都会被阻塞。为了看到阻塞线程的效果，打开两个浏览器标签页，并在两个标签页中请求[http://localhost:5000](http://localhost:5000)。你需要在第一个请求完成之前在第二个标签页中开始请求，你可能需要调整`total`值来给自己留出时间。*列表4.20*中的`total`值在我的系统上需要三到四秒才能完成，这足以在两个浏览器标签页中开始请求。
- en: '**Avoiding the browser cache problem**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免浏览器缓存问题**'
- en: Some browsers, including Chrome, won’t make simultaneous requests for the same
    URL. This means that the request from the second browser tab won’t be started
    until the response from the first tab’s request has been received, which can make
    it look like requests are always blocking.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器，包括Chrome，不会对相同的URL发起并发请求。这意味着第二个浏览器标签页的请求不会开始，直到第一个标签页请求的响应被接收，这可能会让人误以为请求总是阻塞的。
- en: Browsers do this to see if the result from the first request can be added to
    their cache and used for subsequent requests. This is not usually an issue, but
    it can be confusing, especially for features like the ones discussed in this chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器这样做是为了查看第一个请求的结果是否可以添加到它们的缓存中，并用于后续请求。这通常不是问题，但它可能会令人困惑，特别是对于本章讨论的功能。
- en: You can avoid this problem by disabling the browser cache (Chrome has a **Disable
    Cache** checkbox on the **Network** tab in the *F12* developer tools window, for
    example) or requesting different URLs, such as `http://localhost:5000?id=1` and
    `http://localhost:5000?id=2`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过禁用浏览器缓存（例如，Chrome在*F12*开发者工具窗口的**网络**选项卡上有**禁用缓存**复选框）或请求不同的URL来避免这个问题，例如`http://localhost:5000?id=1`和`http://localhost:5000?id=2`。
- en: You will see that both browser tabs get results, as shown in *Figure 4.10*.
    Each request is identified by incrementing the `shared_counter` value, which makes
    it easy to correlate the output displayed in the browser with the Node.js console
    messages.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现两个浏览器标签页都会得到结果，如图*图4.10*所示。每个请求通过递增`shared_counter`值来标识，这使得将浏览器中显示的输出与Node.js控制台消息关联起来变得容易。
- en: '![](img/B21959_04_10.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_10.png)'
- en: 'Figure 4.10: Blocking the main thread'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：阻塞主线程
- en: 'Examine the Node.js console output and you will see that all of the iterations
    from the first request were completed before the work for the second request was
    started:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Node.js控制台输出，你会看到第一个请求的所有迭代都在开始第二个请求的工作之前完成：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a typical, albeit exaggerated, example of blocking the JavaScript thread,
    so that requests queue up waiting for their turn to be handled and the overall
    request throughput drops.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的、尽管有些夸张的阻塞JavaScript线程的例子，使得请求排队等待处理，整体请求吞吐量下降。
- en: Yielding control of the main thread
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放主线程的控制权
- en: One way to address blocking is to break up work into smaller chunks that are
    interleaved with other requests. The work is still done entirely with the main
    thread, but the blocking occurs in a series of shorter periods, which means that
    access to the main thread is more equitable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 解决阻塞的一种方法是将工作分解成更小的块，这些块与其他请求交织在一起。尽管工作仍然完全由主线程完成，但阻塞发生在一系列较短的周期中，这意味着对主线程的访问更加公平。
- en: '*Table 4.5* describes the functions that are available for telling Node.js
    to invoke a function in the future. (As before, I am simplifying things here to
    avoid getting into the low-level details of the Node.js event loop.)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 4.5* 描述了可用于告诉 Node.js 在未来调用函数的函数。（与之前一样，我在这里简化了事情，以避免涉及 Node.js 事件循环的低级细节。）'
- en: 'Table 4.5: The scheduling functions'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.5：调度函数
- en: '| Name | Description |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '| This function tells Node.js to add a function to the callback queue. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 此函数告诉 Node.js 将一个函数添加到回调队列中。 |'
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| This function tells Node.js to add a function to the callback queue that
    should not be invoked for at least a specified number of milliseconds. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 此函数告诉 Node.js 将一个函数添加到回调队列中，该函数至少需要等待指定的毫秒数后才能被调用。 |'
- en: These are *global* functions, which means they can be used without a module
    import. *Listing 4.21* uses the `setImmediate` function so that the counting operation
    is broken up into smaller blocks of work.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 *全局* 函数，这意味着可以在不进行模块导入的情况下使用。*列表 4.21* 使用了 `setImmediate` 函数，以便将计数操作分解成更小的工作块。
- en: 'Listing 4.21: Using the setImmediate Function in the handler.ts File in the
    src Folder'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.21：在 src 文件夹中的 handler.ts 文件中使用 setImmediate 函数
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `iterate` function performs one block of counting and then uses the `setImmediate`
    function to defer the next block. Use two browser tabs to request `http://localhost:5000`
    (or `http://localhost:5000?id=1` and `http://localhost:5000?id=2` if you have
    not disabled the browser cache) and you will see the console messages generated
    by Node.js show that the work performed for the two requests has been interleaved:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterate` 函数执行一个计数块，然后使用 `setImmediate` 函数延迟下一个块。使用两个浏览器标签页请求 `http://localhost:5000`（如果你没有禁用浏览器缓存，则请求
    `http://localhost:5000?id=1` 和 `http://localhost:5000?id=2`），你将看到由 Node.js 生成的控制台消息显示，为两个请求执行的工作已经交织在一起：'
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You may see a different sequence of iterations, but the important point is that
    the work for HTTP requests is broken up and interleaved.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到不同的迭代顺序，但重要的是 HTTP 请求的工作被分解并交织在一起。
- en: '**Avoiding the pure JavaScript promise pitfall**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免纯 JavaScript 承诺的陷阱**'
- en: 'A common mistake is to try and wrap blocking JavaScript code in a promise,
    like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是尝试将阻塞的 JavaScript 代码包裹在一个承诺（promise）中，如下所示：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are two pitfalls for the unwary developer with this approach. The first
    is that the *executor*, which is the function that performs the work, is performed
    synchronously. This may seem odd, but remember that all JavaScript code is executed
    synchronously, and the expectation is that the executor will be used to invoke
    asynchronous API methods that will produce results in the future and be added
    to the callback queue for eventual processing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对粗心的开发者有两个陷阱。第一个是 *执行器*，即执行工作的函数，是同步执行的。这看起来可能有些奇怪，但请记住，所有 JavaScript 代码都是同步执行的，预期执行器将用于调用将产生未来结果并最终添加到回调队列以进行处理的异步
    API 方法。
- en: The second pitfall is that the *follow-on* *function*, passed to the `then`
    method, is executed as soon as the executor completes, before the main thread
    returns to the callback queue to get another function to execute, with the effect
    that there is no interleaving of work.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个陷阱是传递给 `then` 方法的 *后续* *函数*，在执行器完成时立即执行，在主线程返回回调队列以获取另一个要执行的函数之前，这导致没有工作交织。
- en: Promises are a useful way of consuming an API that uses native threads to perform
    asynchronous work but they don’t help when executing pure JavaScript code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺（promises）是消费使用原生线程执行异步工作的 API 的有用方式，但它们在执行纯 JavaScript 代码时并没有帮助。
- en: Using worker threads
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工作线程
- en: The key limitation of the previous example is there is still only one main thread,
    and it still has to do all the work, regardless of how equitably that work is
    done.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例的关键限制是仍然只有一个主线程，并且它仍然必须完成所有工作，无论这项工作是如何公平地完成的。
- en: Node.js supports *worker threads*, which are additional threads for executing
    JavaScript code, albeit with restrictions. JavaScript doesn’t have the features
    for coordinating threads that are found in other languages, such as C# or Java,
    and trying to add them would be difficult. Instead, worker threads run in separate
    instances of the Node.js engine, executing code in isolation from the main thread.
    Communication between the main thread and worker threads is done using events,
    as shown in *Figure 4.11*, which fits nicely into the JavaScript event loop, so
    that the results produced by worker threads are processed by callback functions,
    just like any other JavaScript code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 支持 *工作线程*，这是用于执行 JavaScript 代码的额外线程，尽管存在一些限制。JavaScript 没有像 C# 或 Java
    那样用于线程协调的特性，尝试添加这些特性将会很困难。相反，工作线程在 Node.js 引擎的独立实例中运行，与主线程隔离执行代码。主线程和工作线程之间的通信是通过事件完成的，如
    *图 4.11* 所示，这很好地融入了 JavaScript 事件循环，因此工作线程产生的结果由回调函数处理，就像任何其他 JavaScript 代码一样。
- en: '![](img/B21959_04_11.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_04_11.png)'
- en: 'Figure 4.11: The main thread and worker threads'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：主线程和工作线程
- en: Worker threads are not the solution to every problem because there is overhead
    in creating and managing them, but they provide an effective way to execute JavaScript
    code without blocking the main thread.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程并非解决所有问题的方案，因为创建和管理它们会有开销，但它们提供了一种有效的方式来执行 JavaScript 代码而不阻塞主线程。
- en: '**Understanding worker threads versus the worker pool**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解工作线程与工作池**'
- en: 'There is a terminology overlap that can cause confusion because Node.js uses
    two similar terms: *worker threads* and the *worker pool*. Worker threads are
    the topic of this part of the chapter and are started by the programmer to perform
    JavaScript code without blocking the main thread. The worker pool is the set of
    threads that Node.js uses to implement the asynchronous features of its API, such
    as the functions used in this chapter to read files and write HTTP responses.
    You don’t interact directly with the worker pool, which is managed by Node.js
    automatically.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 使用了两个相似的术语：*工作线程* 和 *工作池*，因此存在术语重叠，可能会引起混淆。因为 Node.js 使用这两个术语：*工作线程*
    和 *工作池*。工作线程是本章这一部分的主题，由程序员启动以执行 JavaScript 代码而不阻塞主线程。工作池是 Node.js 用于实现其 API 异步特性的线程集合，例如本章中用于读取文件和写入
    HTTP 响应的函数。您不能直接与工作池交互，它由 Node.js 自动管理。
- en: Just to add to the confusion, worker threads are often grouped into a pool for
    performance reasons, allowing individual worker threads to be reused instead of
    used once and then discarded. I will explain how this is done in *Part 2*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加混淆，出于性能原因，工作线程通常被分组到一个池中，允许单个工作线程被重复使用，而不是使用一次后丢弃。我将在 *第 2 部分* 中解释如何做到这一点。
- en: Writing the worker code
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写工作线程代码
- en: The code that worker threads execute is defined separately from the rest of
    the JavaScript application. Add a file named `count_worker.ts` to the `src` folder
    with the content shown in *Listing 4.22*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程执行的代码与 JavaScript 应用程序的其他部分定义是分开的。在 `src` 文件夹中添加一个名为 `count_worker.ts` 的文件，其内容如
    *清单 4.22* 所示。
- en: 'Listing 4.22: The contents of the count_worker.ts file in the src folder'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.22：src 文件夹中 count_worker.ts 文件的内容
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Worker threads’ features are defined in the `worker_theads` module, and two
    of those features are used in *Listing 4.22*. The first, `workerData`, is an object
    or value used to pass configuration data from the main thread to the worker. In
    this case, the worker receives three values through `workerData`, which specify
    the request ID, the number of iterations, and the target value for each block
    of counting work:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程的特性定义在 `worker_threads` 模块中，其中两个特性在 *清单 4.22* 中被使用。第一个，`workerData`，是一个对象或值，用于从主线程传递配置数据到工作线程。在这种情况下，工作线程通过
    `workerData` 接收三个值，分别指定请求 ID、迭代次数以及每个计数工作块的目标值：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The other feature is `parentPort`, which is used to emit events that will be
    received by the main thread, like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特性是 `parentPort`，它用于发出主线程将接收的事件，如下所示：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `postMessage` method emits a message event and takes care of transferring
    the argument value from the worker thread’s JavaScript runtime to the main thread.
    The `parentPort` value may be `null`, which is why the `?` operator is required
    when calling the `postMessage` method.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`postMessage` 方法会触发一个消息事件，并负责将工作线程的 JavaScript 运行时中的参数值传输到主线程。`parentPort`
    的值可能是 `null`，这就是为什么在调用 `postMessage` 方法时需要使用 `?` 操作符。'
- en: Creating a worker thread
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建工作线程
- en: The next step is to update the request-handling code so that it creates a worker
    thread using the code defined in the previous section, as shown in *Listing 4.23*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是更新请求处理代码，以便使用上一节中定义的代码创建工作线程，如*列表4.23*所示。
- en: 'Listing 4.23: Using a worker thread in the handler.ts File in the src Folder'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.23：在src文件夹中的handler.ts文件中使用工作线程
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Worker threads are created by instantiating the `Worker` class, which is defined
    in the `worker_threads` module. The constructor arguments are the JavaScript code
    file to execute and a configuration object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程通过实例化`Worker`类创建，该类在`worker_threads`模块中定义。构造函数的参数是要执行的JavaScript代码文件和一个配置对象：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Node.js provides two global values that provide path information about the current
    module and are useful for specifying file paths, which are described in *Table
    4.6* for quick reference. To specify the code file created in *Listing 4.22*,
    I combine the `__dirname` value with the name of the compiled JavaScript file
    (not the TypeScript file, which can’t be executed directly by Node.js).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js提供了两个全局值，它们提供了关于当前模块的路径信息，并且对于指定文件路径很有用，这些信息在*表4.6*中描述，以便快速参考。要指定*列表4.22*中创建的代码文件，我将`__dirname`值与编译后的JavaScript文件名（而不是TypeScript文件，它不能直接由Node.js执行）结合起来。
- en: 'Table 4.6: The global values for the current module'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6：当前模块的全局值
- en: '| **Name** | **Description** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '|'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '| This value contains the file name of the current module. Remember this will
    be the name of the JavaScript file and not the TypeScript file. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 此值包含当前模块的文件名。请记住，这将是指JavaScript文件的名称，而不是TypeScript文件。 |'
- en: '|'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '| This value contains the name of the directory that contains the current module.
    Remember this will be the directory that contains the compiled JavaScript file
    and not the TypeScript file. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 此值包含包含当前模块的目录的名称。请记住，这将包含编译后的JavaScript文件而不是TypeScript文件的目录。 |'
- en: The configuration object passed to the `Worker` constructor supports configuration
    settings for managing the way a worker thread is executed, but the only option
    required for this example is `workerData`, which allows the data values used by
    the worker thread to be defined.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`Worker`构造函数的配置对象支持管理工作线程执行方式的配置设置，但本例中所需的唯一选项是`workerData`，它允许定义工作线程使用的数据值。
- en: '**Tip**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: See [https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options](https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options)
    for the other worker configuration options, although the others are rarely required.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有关其他工作配置选项，请参阅[https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options](https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options)，尽管其他选项很少需要。
- en: 'Worker threads communicate with the main thread by emitting events, which are
    handled by functions registered by the `on` method, like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程通过发出事件与主线程进行通信，这些事件由`on`方法注册的函数处理，如下所示：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first argument to the `on` method is a string that specifies the name of
    the event that will be handled. This handler is for the `message` event, which
    is emitted when the worker uses the `parentPort.postMessage` method. In this example,
    the `message` event signals that the worker thread has completed one of its counting
    iterations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`on`方法的第一个参数是一个字符串，指定了将要处理的事件的名称。此处理程序用于`message`事件，当工作线程使用`parentPort.postMessage`方法时发出。在这个例子中，`message`事件表示工作线程完成了一次计数迭代。'
- en: There are two other events handled in this example. The `exit` event is triggered
    by Node.js when the worker thread finishes, and the event provides an exit code
    that indicates whether the worker finished normally or was terminated with an
    error. There is also an `error` event, which is sent if the JavaScript code executed
    by the worker thread throws an uncaught exception.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中还处理了两个其他事件。`exit`事件由Node.js在工作线程完成时触发，该事件提供了一个退出代码，指示工作线程是否正常完成或因错误而终止。还有一个`error`事件，如果工作线程执行的JavaScript代码抛出未捕获的异常，则会发送该事件。
- en: 'Use two browser tabs to request `http://localhost:5000` (or `http://localhost:5000?id=1`
    and `http://localhost:5000?id=2` if you have not disabled the browser cache) and
    you will see Node.js console messages that show calculations performed for the
    requests overlapping, like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个浏览器标签请求`http://localhost:5000`（如果你没有禁用浏览器缓存，则可以是`http://localhost:5000?id=1`和`http://localhost:5000?id=2`），你将看到Node.js控制台消息显示请求重叠时进行的计算，如下所示：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The important difference from earlier examples is that work for requests is
    being performed in parallel, rather than all of the work being performed on a
    single thread.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期示例的重要区别在于，请求的工作是在并行执行的，而不是所有的工作都在单个线程上执行。
- en: Packaging worker threads into a callback
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将工作线程打包到回调中
- en: The code in *Listing 4.23* can be wrapped up so that it is consistent with the
    Node.js API, using a callback. For the callback, add a file named `counter_cb.ts`
    to the `src` folder with the content shown in *Listing 4.24*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.23 中的代码可以被封装，使其与 Node.js API 保持一致，使用回调。对于回调，将一个名为 `counter_cb.ts` 的文件添加到
    `src` 文件夹中，其内容如 *清单 4.24* 所示。
- en: 'Listing 4.24: The contents of the counter_cb.ts file in the src folder'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.24：src 文件夹中 counter_cb.ts 文件的内容
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Count` function accepts arguments that describe the work to be done, and
    a callback function that will be invoked when there is an error, when an iteration
    completes, and when all of the work is done. *Listing 4.25* updates the request-handling
    code to use the `Count` function.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count` 函数接受描述要执行的工作的参数，以及一个回调函数，该函数将在出现错误、迭代完成以及所有工作都完成时被调用。*清单 4.25* 更新了请求处理代码以使用
    `Count` 函数。'
- en: 'Listing 4.25: Using a callback function in the handler.ts file in the src folder'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.25：在 src 文件夹中的 handler.ts 文件中使用回调函数
- en: '[PRE56]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This example produces the same results as the previous example but is more consistent
    with the majority of the Node.js API, the key parts of which are described in
    the chapters that follow.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例产生的结果与上一个示例相同，但与大多数 Node.js API 更为一致，其关键部分将在接下来的章节中描述。
- en: Packaging worker threads into a promise
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将工作线程打包到承诺中
- en: Worker threads can also be wrapped up in a promise, although promises are not
    suited to receive interim updates in the way that callbacks are, and so using
    a promise will only produce a result when all of the work has been completed or
    when there is a problem. Add a file named `count_promise.ts` to the `src` folder
    with the content shown in *Listing 4.26*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程也可以被封装在一个承诺中，尽管承诺不像回调那样适合接收中间更新，因此使用承诺只有在所有工作都完成或出现问题时才会产生结果。将一个名为 `count_promise.ts`
    的文件添加到 `src` 文件夹中，其内容如 *清单 4.26* 所示。
- en: '**Note**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: It is possible to produce interim updates with promises, but it requires generating
    a series of promises that have to be used with the `await` keyword in a loop.
    The result is messy code that doesn’t behave the way that promises usually work
    and is best avoided. Use a callback if you need interim updates from a worker
    thread.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺可以产生中间更新，但这需要生成一系列承诺，这些承诺需要在循环中使用 `await` 关键字。结果是代码混乱，不符合承诺通常的行为，最好避免。如果需要从工作线程中获取中间更新，请使用回调。
- en: 'Listing 4.26: The contents of the count_promise.ts file in the src folder'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.26：src 文件夹中 count_promise.ts 文件的内容
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `Count` function returns a `Promise<void>` whose executor starts a worker
    thread and sets up handlers for the events it emits. The functions that handle
    the `exit` and `error` events resolve or reject the promise, which will either
    signal that the promise is complete or throw an exception. The handler function
    for the `message` event writes out console messages to show progress but doesn’t
    affect the outcome of the promise. *Listing 4.27* revises the request handler
    to use the promise-based version of the `Count` function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count` 函数返回一个 `Promise<void>`，其执行器启动一个工作线程并设置处理它发出的事件的处理器。处理 `exit` 和 `error`
    事件的函数解决或拒绝承诺，这将表示承诺已完成或抛出异常。`message` 事件的处理器将输出控制台消息以显示进度，但不会影响承诺的结果。*清单 4.27*
    修订了请求处理器以使用基于承诺的 `Count` 函数版本。'
- en: 'Listing 4.27: Using a promise in the handler.ts file in the src folder'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4.27：在 src 文件夹中的 handler.ts 文件中使用承诺
- en: '[PRE58]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is similar to earlier examples, except the response sent to the client
    doesn’t include any messages generated at the end of each block of work, as shown
    in *Figure 4.12*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这与早期示例类似，但发送给客户端的响应不包括每个工作块结束时生成的任何消息，如图 *图 4.12* 所示。
- en: '![](img/B21959_04_12.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_04_12.png)'
- en: 'Figure 4.12: The result from the promise-wrapped worker thread'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：承诺封装的工作线程的结果
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I described the way that JavaScript code is executed and explained
    the effect this has on HTTP request processing and why this approach is different
    from other platforms. I explained that JavaScript code is executed on a single
    main thread and demonstrated the features that Node.js provides for offloading
    work on other threads.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了 JavaScript 代码的执行方式，并解释了这对 HTTP 请求处理的影响以及为什么这种方法与其他平台不同。我解释了 JavaScript
    代码是在单个主线程上执行的，并展示了 Node.js 为在其他线程上卸载工作提供的功能。
- en: JavaScript code is executed on a single thread, known as the main thread
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 代码是在单个线程上执行的，这个线程被称为主线程
- en: The Node.js API uses native threads to perform many operations to avoid blocking
    the main thread
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js API 使用原生线程来执行许多操作，以避免阻塞主线程
- en: The Node.js API largely uses callbacks, but there is also some support for promises
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js API 主要使用回调，但也提供了一些对承诺（promises）的支持
- en: Node.js provides functions for converting callbacks and promises
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 提供了将回调和承诺进行转换的函数
- en: Node.js supports worker threads for executing JavaScript code without blocking
    the main thread
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 支持使用工作线程（worker threads）来执行 JavaScript 代码，而不会阻塞主线程
- en: In the next chapter, I will describe the features that Node.js provides for
    working with HTTP requests.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将描述 Node.js 为处理 HTTP 请求提供的功能
