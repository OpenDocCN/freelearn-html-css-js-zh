- en: Chapter 10. Routing, Touch Support, and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：路由、触摸支持和调试
- en: In this chapter, we will perform the last steps before we customize the theme
    and create the production build of our application. We will cover some different
    topics, such as enabling routing in our application, a quick overview about responsive
    design and Ext JS, touch support, debugging Ext JS apps, and a quick overview
    about testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将执行在自定义主题和创建应用程序的生产构建之前的最后几步。我们将涵盖一些不同的主题，例如在我们的应用程序中启用路由、关于响应式设计和Ext
    JS的快速概述、触摸支持、调试Ext JS应用程序以及关于测试的快速概述。
- en: 'So, in this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下内容：
- en: Ext JS routing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 路由
- en: Responsive design and touch support
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式设计和触摸支持
- en: Transforming Ext JS projects into mobile apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Ext JS项目转换为移动应用程序
- en: Debugging Ext JS applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Ext JS应用程序
- en: Tools for testing Ext JS applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Ext JS应用程序的工具
- en: Helpful tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的工具
- en: Where to find extra and open source plugins
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何找到额外的开源插件
- en: Ext JS routing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext JS 路由
- en: Routing is a capability introduced in Ext JS 5 that makes the process of handling
    history using the `Ext.util.History` class in the application easier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是Ext JS 5中引入的一项功能，它使得在应用程序中使用`Ext.util.History`类处理历史记录的过程变得更加容易。
- en: On a normal website, a user navigates to and from different pages as they click
    links or fill out forms. However, in a single-page application, a user's interaction
    doesn't load a new page. Instead, it is handled within a single page and components
    react to that interaction. So how do we still allow users to use the browser's
    forward and back buttons? Using routes allows the user to use this capability
    by mapping hash tokens to controller methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个普通网站上，用户通过点击链接或填写表单来导航到不同的页面。然而，在单页应用程序中，用户的交互不会加载新页面。相反，它是在单个页面内处理的，组件对这种交互做出反应。那么我们如何仍然允许用户使用浏览器的后退和前进按钮呢？使用路由允许用户通过将哈希令牌映射到控制器方法来使用这种功能。
- en: For example, we have a screen to manage the Films information. Using routing,
    we can allow the user to access this screen (if the user has proper entitlements)
    and automatically selects a particular row of the Films grid by accessing `https://localhost/masteringextjs/#films/3`.
    When the user accesses this link, we can instruct the application to open the
    **Films** tab and select the row of the film that has the ID **3**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个用于管理电影信息的屏幕。使用路由，我们可以允许用户访问此屏幕（如果用户有适当的权限）并通过访问`https://localhost/masteringextjs/#films/3`自动选择电影网格的特定行。当用户访问此链接时，我们可以指示应用程序打开**电影**标签并选择ID为**3**的电影行。
- en: To enable routes in our application, we are going to use the `Root` Controller
    that was created by Sencha Cmd automatically when we created the application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中启用路由，我们将使用由Sencha Cmd在创建应用程序时自动创建的`Root` Controller。
- en: Default token
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认令牌
- en: 'We are going to start by enabling a default token. When our application starts,
    it is going to redirect to the `#home` hash token. To do so, we are going to add
    the following code to the `Application.js` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先启用默认令牌。当我们的应用程序启动时，它将重定向到`#home`哈希令牌。为此，我们将向`Application.js`文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, inside the `Root` Controller, we will listen to this hash and redirect
    to the `onHome` method, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Root` Controller内部，我们将监听此哈希并重定向到`onHome`方法，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `onHome` method, we want to activate the first tab (**Home**) of
    the `Main Panel`. Use the following code to do this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onHome`方法内部，我们希望激活`Main Panel`的第一个标签（**首页**）。使用以下代码来完成此操作：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are using a `getMain` method (`#1`), which refers to a `ref` of the Controller.
    We need to declare it as well. We are going to declare `ref` configuration inside
    the `init` method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getMain`方法（`#1`），它指的是Controller的`ref`。我们需要声明它。我们将在`init`方法中声明`ref`配置：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Loading a Controller programmatically
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式加载Controller
- en: At the beginning of this book, you learned that the Controllers are loaded when
    the application is loaded (MVC). As our application has a **Login** screen, we
    do not want to enable the routes when the application is loaded. We only want
    to enable the routes after the user is logged in. The `Root` Controller is going
    to be loaded when the application loads, and we do not want that to happen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，你了解到当应用程序加载时（MVC）会加载控制器。由于我们的应用程序有一个**登录**屏幕，我们不想在应用程序加载时启用路由。我们只想在用户登录后启用路由。`Root`
    Controller将在应用程序加载时加载，我们不希望发生这种情况。
- en: 'Inside `Application.js` we are going to comment the `Root` Controller:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application.js`中，我们将注释掉`Root` Controller：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the `Main` View is loaded, we want to initialize the `Root` Controller.
    So we are going to `init` the `Root` Controller inside the `init` method of `main.MainController`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Main`视图加载时，我们想要初始化`Root`控制器。所以，我们将在`main.MainController`的`init`方法中`init``Root`控制器：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And this is how we create a Controller programmatically in Ext JS. The Router
    will be enabled only after the `Main` View is loaded. We could place all the routes
    inside `MainController`, but it would coexist with the existing code that we have
    in `MainController` already, and maintaining this code in the future could be
    a little difficult. This is also a design decision that we need to make: do we
    keep all the routes inside a single Controller or do we separate the code? Feel
    free to organize the code as you see fit. In big applications, it can be difficult
    to maintain many hash tokens organized in a single Controller.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在Ext JS中程序化创建控制器的方法。只有在`Main`视图加载后，路由器才会启用。我们可以在`MainController`内部放置所有路由，但它将与`MainController`中已有的现有代码共存，并且在未来维护此代码可能会有些困难。这也是我们需要做出的设计决策之一：我们是否将所有路由都放在单个控制器中，还是将代码分开？请随意组织代码，使其符合您的需求。在大型应用程序中，在单个控制器中维护许多组织良好的hash标记可能会有点困难。
- en: With the code we have so far, when we render `https://localhost/masteringextjs`
    application, it will be redirected automatically to `https://localhost/masteringextjs/#home`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有的代码，当我们渲染`https://localhost/masteringextjs`应用程序时，它将被自动重定向到`https://localhost/masteringextjs/#home`。
- en: Handling routes
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理路由
- en: Inside the `routes` configuration of the `Root` Controller**,** we will handle
    the possible routes for our application. We will use the `xtypes` we created for
    our application. It is a good thing we kept track of them in the `menu` table
    in our database (`className` column)!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Root`控制器**的`routes`配置中**，我们将处理我们应用程序的可能路由。我们将使用为我们应用程序创建的`xtypes`。好事是我们一直在跟踪它们在我们数据库的`menu`表中的`className`列！
- en: 'The following are the possible hash tokens we have in our application: `user`,
    `actorsgrid`, `categoriesgrid`, `languagesgrid`, `citiesgrid`, `countriesgrid`,
    `films`, and `salesfilmcategory`. We can define a method for each one of them
    as we developed for the `home` token. But what should be done when the user accesses
    any of these tokens open in the respective tab. So what we want to do is handle
    multiple tokens in a single method. This is the code we will add inside the `routes`
    configuration in the `Root` Controller:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应用程序中可能存在的hash标记：`user`、`actorsgrid`、`categoriesgrid`、`languagesgrid`、`citiesgrid`、`countriesgrid`、`films`和`salesfilmcategory`。我们可以为它们中的每一个定义一个方法，就像我们为`home`标记开发的那样。但是，当用户访问任何这些标记并在相应的标签页中打开时，应该做什么。所以，我们想要在单个方法中处理多个标记。这就是我们将在`Root`控制器的`routes`配置中添加的代码：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we want to handle several tokens in the same method, we can use `|` to
    separate them. Note that in the preceding code, we are declaring two methods:
    `onBeforeRoute` and `onRoute`. We might want to check whether the user has entitlements
    to access the screen (after all, what is stopping a smart user trying to access
    a screen that the user does not have permission via routing?). So we can handle
    it in the following code (however, this is not necessarily the best way to secure
    an application):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在同一个方法中处理多个标记时，我们可以使用`|`来分隔它们。注意，在前面的代码中，我们声明了两个方法：`onBeforeRoute`和`onRoute`。我们可能想要检查用户是否有权限访问屏幕（毕竟，什么阻止了一个聪明的用户试图通过路由访问用户没有权限的屏幕呢？）。所以，我们可以在以下代码中处理它（然而，这不一定是最安全的保护应用程序的方法）：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we are using generic code here and we want to send to the `className` parameter
    the user is trying to access to the server, we can retrieve it using the code
    in line `#1`. The `before` action method only receives one parameter, which is
    the `action` parameter. Depending on the result, we can resume it (`#2`), which
    means the user has access to the screen—and the `onRoute` method will be executed
    next. Or, we can stop the action (`#3` and `#4`), which means the `onRoute` method
    will not be executed next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里使用的是通用代码，并且我们希望将用户试图访问服务器的`className`参数发送到服务器，我们可以使用第`#1`行中的代码来检索它。`before`动作方法只接收一个参数，即`action`参数。根据结果，我们可以恢复它（`#2`），这意味着用户可以访问屏幕——`onRoute`方法将被执行。或者，我们可以停止动作（`#3`和`#4`），这意味着`onRoute`方法将不会执行。
- en: 'Let''s take a look at the method `onRoute` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`onRoute`方法：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method will call the `locateMenuItem` (`#6`) method passing the `mainmenu`
    reference (`#5`):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将调用`locateMenuItem`（`#6`）方法，传递`mainmenu`引用（`#5`）：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Refactoring the Menu code
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构菜单代码
- en: 'Let''s take a look at the `locateMenuItem` code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`locateMenuItem`代码：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previously mentioned method is searching for a node in each `menutree`
    we created for the menu of the application that matches the hash of the route.
    If we find the node, we call the `openTab` method (`#1`):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的方正在搜索我们为应用程序的菜单创建的每个`menutree`中的节点，以匹配路由的哈希。如果我们找到节点，我们将调用`openTab`方法（`#1`）：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we take a look at the code of the `onTreePanelItemClick` method from the
    `Menu` Controller, we will note that it is exactly the same as the `openTab` method.
    Although we are handling routes at the end of this book, it is best if we start
    handling them when we start developing the application. So, if you are planning
    on using routes, make sure routes is part of the design, because it might require
    some code changes if you decide to implement it after the application is developed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`Menu`控制器中`onTreePanelItemClick`方法的代码，我们将注意到它与`openTab`方法完全相同。尽管我们将在本书的末尾处理路由，但最好在我们开始开发应用程序时就处理它们。所以，如果你打算使用路由，确保路由是设计的一部分，因为如果你在应用程序开发之后决定实现它，可能需要进行一些代码更改。
- en: 'The `onTreePanelItemClick` method will have the following code now:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`onTreePanelItemClick`方法现在将有以下代码：'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the user clicks on the `Node` of the `Tree` of the menu we implemented,
    it is going to redirect to the hash of the `className` parameter of the `Node`,
    and the `Root` Controller will handle opening the tab.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击我们实现的菜单的`Tree`中的`Node`时，它将重定向到`Node`的`className`参数的哈希，并且`Root`控制器将处理打开标签页。
- en: Handling unmatched routes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不匹配的路由
- en: 'If the user tries to access a route that is not defined in the application,
    we can execute some code as well. In the `Root` Controller, we can add the following
    code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尝试访问应用程序中未定义的路由，我们也可以执行一些代码。在`Root`控制器中，我们可以添加以下代码：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And we can display an error message to the user, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向用户显示错误消息，如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Handling parameters
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理参数
- en: 'Now let''s develop more complex route handling. For the **Films** screen, let''s
    say we want the user to be able to select a row from the Films grid using a hash
    token, as demonstrated in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发更复杂的路由处理。对于**Films**屏幕，假设我们希望用户能够使用哈希令牌从Films网格中选择一行，如下面的截图所示：
- en: '![Handling parameters](img/0457OT_10_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![处理参数](img/0457OT_10_01.jpg)'
- en: 'We can define the following route:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义以下路由：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This means the user can try to access a URL with the format `https://localhost/masteringextjs/#films/2`.
    If the user tries to access `https://localhost/masteringextjs/#films/ace`, it
    is not valid because of the condition of the `id` parameter—it needs to be a numeric
    value. This means we can also define regular expressions to validate the parameters
    of hash tokens.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户可以尝试访问格式为`https://localhost/masteringextjs/#films/2`的URL。如果用户尝试访问`https://localhost/masteringextjs/#films/ace`，则由于`id`参数的条件，它是不有效的——它需要是一个数值。这意味着我们也可以定义正则表达式来验证哈希令牌的参数。
- en: 'Before we execute `onFilmSelect`, we want to do a few things:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行`onFilmSelect`之前，我们想做一些事情：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to open the **Films** screen (`#1`) and check whether the record the
    user wants to select exists in the Store. If the result is positive, continue
    the execution and if not, stop it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要打开**Films**屏幕（`#1`）并检查用户想要选择的记录是否存在于Store中。如果结果是正的，继续执行；如果不是，停止执行。
- en: 'The reference for `filmsGrid` is given here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`filmsGrid`的引用在这里给出：'
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, the reference for the `onFilmSelect` method is given here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`onFilmSelect`方法的引用在这里给出：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are going to fire the `selectfilm` event of `films-grid`, as shown in the
    following code; this requires some new code inside the `FilmsGrid` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将触发`films-grid`的`selectfilm`事件，如下面的代码所示；这需要在`FilmsGrid`类内部编写一些新代码：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are going to handle the listeners in the `FilmsController` class, as shown
    in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`FilmsController`类中处理监听器，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What we are doing in the preceding code is finding the record by `film_id` given
    and selecting it in `FilmsGrid`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在通过`film_id`查找记录并在`FilmsGrid`中选择它。
- en: 'When the user clicks on a row of the grid, the `onItemClick` method will be
    fired:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击网格的行时，将触发`onItemClick`方法：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are simply going to redirect the request to the `Route` Controller so that
    it can handle the selection with the code we developed in this topic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地重定向请求到`Route`控制器，以便它可以处理我们在此主题中开发的代码所进行的选取。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned before, routing can become very complex in some applications, so
    the best thing is to start handling them from the very beginning of development.
    For more details, please check out Sencha guides and documentation about routing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在某些应用程序中，路由可能会变得非常复杂，因此最好的做法是从开发初期就开始处理它们。更多详情，请参阅Sencha关于路由的指南和文档。
- en: Using the responsive design plugin
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应式设计插件
- en: Another new capability introduced in Ext JS 5 is the option to develop responsive
    applications. Mobile devices are part of our lives. We basically have a computer
    in our pockets. It is very common nowadays to have tablet or mobile compatible
    as an item listed in a user requirements document. Fortunately, Ext JS 5 provides
    good support and allows us to achieve this requirement without too much effort.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5引入了另一个新功能，即开发响应式应用程序的选项。移动设备已经成为我们生活的一部分。我们基本上在口袋里就有一个电脑。如今，在用户需求文档中将平板或移动设备兼容性作为一项内容列出是非常常见的。幸运的是，Ext
    JS 5提供了良好的支持，并允许我们无需太多努力就能实现这一需求。
- en: Ext JS 5 introduces the responsive plugin and mixin. The plugin can be used
    in any component, and the mixin can be used in any other class. This plugin responds
    dynamically to changes in screen size and orientation by controlling `responsiveConfig`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5引入了响应式插件和混合。插件可用于任何组件，混合可用于任何其他类。此插件通过控制`responsiveConfig`动态响应屏幕尺寸和方向的变化。
- en: 'For example, let''s do a quick example in our project. If the width of the
    screen is less than 768 pixels and the screen is in `tall` mode, we are going
    to hide the application menu and display a new button that is going to render
    the menu as displayed in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们在我们的项目中快速做一个示例。如果屏幕宽度小于768像素，并且屏幕处于`tall`模式，我们将隐藏应用程序菜单并显示一个新按钮，该按钮将显示如下截图所示的菜单：
- en: '![Using the responsive design plugin](img/0457OT_10_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用响应式设计插件](img/0457OT_10_02.jpg)'
- en: 'In the `Packt.view.main.Main` class, we are going to add the responsive plugin
    to the `west` region. The code is presented as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Packt.view.main.Main`类中，我们将向`west`区域添加响应式插件。代码如下所示：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inside `responsiveConfig`, we can add some conditions and set the component's
    configuration accordingly. We can change the layout, render a different component,
    and do whatever is needed in the application. With only the preceding code, if
    we execute the application and decrease the browser's width, we will see the menu
    will be hidden automatically when the criteria are met. It is really nice!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`responsiveConfig`内部，我们可以添加一些条件并相应地设置组件的配置。我们可以更改布局，渲染不同的组件，并在应用程序中完成所需的一切。仅使用前面的代码，如果我们执行应用程序并减小浏览器宽度，当满足条件时，我们将看到菜单会自动隐藏。这真是太棒了！
- en: 'In `Packt.view.main.Header`, we are going to add a new component as well, as
    follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Packt.view.main.Header`中，我们还将添加一个新的组件，如下所示：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The code for this component is presented as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的代码如下所示：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are reusing the menu we developed at the beginning of this book. Of course,
    we could develop a UX that is more user friendly, but we are just focusing on
    the functionality here for a quick test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重用本书开头开发的菜单。当然，我们可以开发一个更用户友好的UX，但在这里我们只是关注功能，进行快速测试。
- en: 'Google Chrome has a really nice feature if we need to work with responsive
    design. It is the capability of emulating the project in different devices to
    see how they are going to look. In Google Developer Tools, click on the mobile
    device icon as shown in the following screenshot and start the adventure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要处理响应式设计，Google Chrome有一个非常棒的功能。它能够模拟项目在不同设备上的显示效果，以便查看它们的外观。在Google开发者工具中，点击下面的截图所示的移动设备图标，开始您的探险之旅：
- en: '![Using the responsive design plugin](img/0457OT_10_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用响应式设计插件](img/0457OT_10_03.jpg)'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about Ext JS 5 and responsive design, please read [http://www.sencha.com/blog/designing-responsive-applications-with-ext-js](http://www.sencha.com/blog/designing-responsive-applications-with-ext-js)
    and check the source code of this example [http://goo.gl/odce6j](http://goo.gl/odce6j).
    Firefox also has a mobile view in its developer toolbar. Go to **Tools** | **Web
    Developer** | **Responsive Design View**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Ext JS 5和响应式设计的更多信息，请阅读[http://www.sencha.com/blog/designing-responsive-applications-with-ext-js](http://www.sencha.com/blog/designing-responsive-applications-with-ext-js)并检查此示例的源代码[http://goo.gl/odce6j](http://goo.gl/odce6j)。Firefox在其开发者工具栏中也有一个移动视图。转到**工具**
    | **Web开发者** | **响应式设计视图**。
- en: Enabling touch support
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用触摸支持
- en: In this section, we will quickly discuss responsive design. Since it is not
    the primary topic of this book, we will implement a very simple example that will
    give us an idea of what we need to do if we need to develop a responsive application
    with Ext JS. And speaking of responsive design, we know Ext JS is great to develop
    desktop applications (that will be executed from a desktop computer or a laptop),
    but mobiles have now become a very integral part of our lives. We will figure
    out the means to run the same application running on a desktop and also on a mobile
    device. We will also discuss how to enable touch support in our application as
    well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论响应式设计。由于这不是本书的主要内容，我们将实现一个非常简单的示例，以让我们了解如果我们需要使用Ext JS开发响应式应用程序时需要做什么。谈到响应式设计，我们知道Ext
    JS非常适合开发桌面应用程序（将在台式计算机或笔记本电脑上执行），但手机现在已经成为我们生活中不可或缺的一部分。我们将找出在桌面和移动设备上运行相同应用程序的方法。我们还将讨论如何在我们的应用程序中启用触摸支持。
- en: The major difference between running an application on a desktop and a mobile
    device is the events, among other details. On a desktop, when the user clicks
    on a button, we listen to the `click` event. On a touch mobile device, there is
    no `click` event; there is the `tap` event, because we are touching the screen
    and not working with a mouse.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面设备和移动设备上运行应用程序的主要区别在于事件，以及其他细节。在桌面上，当用户点击按钮时，我们监听`click`事件。在触摸式移动设备上，没有`click`事件；存在的是`tap`事件，因为我们是在触摸屏幕而不是使用鼠标。
- en: Another detail is the size of the components. The Ext JS classic theme is really
    nice, but small for touch screens. Throughout this book, we have been using the
    `Neptune` theme, which is the default theme set to the application when we created
    it with Sencha Cmd. The `Neptune` theme has larger components than the `classic`
    theme but still is not good enough to be used on touch devices. Let's experiment!
    If you have a touch device, try executing the application we developed throughout
    this book on it. If you do not have a touch device, you need not worry; you can
    do this experiment using the Google Chrome emulator mentioned in the preceding
    topic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细节是组件的大小。Ext JS经典主题确实很漂亮，但触摸屏上太小了。在本书的整个过程中，我们一直在使用`Neptune`主题，这是我们在使用Sencha
    Cmd创建应用程序时设置的默认主题。`Neptune`主题的组件比`classic`主题大，但仍然不足以在触摸设备上使用。让我们实验一下！如果您有触摸设备，请尝试在它上面运行本书中开发的整个应用程序。如果您没有触摸设备，您不必担心；您可以使用前面主题中提到的Google
    Chrome模拟器进行此实验。
- en: 'The following screenshot exemplifies the application being executed on an iPad
    mini:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了在iPad mini上运行的应用程序：
- en: '![Enabling touch support](img/0457OT_10_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![启用触摸支持](img/0457OT_10_04.jpg)'
- en: If we try to use the application as is, we will be able to use most of its capabilities.
    Because we are using a desktop theme, with small icons, it will not work 100%
    in a mobile device. For example, the `RowExpander` + button doesn't work very
    well because the + icon is very small for a mobile device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用当前的应用程序，我们将能够使用其大部分功能。因为我们使用的是桌面主题，图标较小，所以在移动设备上可能无法100%工作。例如，`RowExpander`
    + 按钮工作得不是很好，因为+图标对于移动设备来说太小了。
- en: 'Ext JS 5 introduces new themes that were designed specially for touch devices.
    There is a special version of the `Neptune` theme and also a special version of
    the `Crisp` theme (also introduced in Ext JS 5). We can add the touch support
    to our application by changing the theme in the `app.js` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5引入了专门为触摸设备设计的全新主题。有一个特殊的`Neptune`主题版本，还有一个特殊的`Crisp`主题版本（也是在Ext JS 5中引入的）。我们可以通过在`app.js`文件中更改主题来为我们的应用程序添加触摸支持：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With `sencha app watch` being executed in a terminal, try changing the theme
    to one of the previously mentioned options. Don''t forget to clean the browser''s
    cache to make sure you will get the new version of the CSS file next time you
    refresh the application. Now let''s try the application again, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中执行`sencha app watch`时，尝试将主题更改为之前提到的选项之一。别忘了清理浏览器的缓存，以确保您在下次刷新应用程序时获取到新的CSS文件版本。现在让我们再次尝试应用程序，如下所示：
- en: '![Enabling touch support](img/0457OT_10_05.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![启用触摸支持](img/0457OT_10_05.jpg)'
- en: Note how there is more space between the components now. This is to make sure
    we can tap (touch) the components.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意组件之间的空间现在更大了。这是为了确保我们可以点击（触摸）组件。
- en: We don't have a touch-optimized application. To make it 100 percent, we can
    review any size that we set (for example, column width) and use some responsive
    design techniques to have the application looking great in mobile devices!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有触摸优化的应用。为了使其达到 100%，我们可以审查我们设置的任何大小（例如，列宽），并使用一些响应式设计技术，使应用在移动设备上看起来很棒！
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: For more information, please visit [http://goo.gl/VnT7bT](http://goo.gl/VnT7bT).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问 [http://goo.gl/VnT7bT](http://goo.gl/VnT7bT)。
- en: From Ext JS to mobile
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Ext JS 到移动
- en: What if the product you are developing requires a special app implement, especially
    for touch devices? We are not talking about the techniques we implemented in the
    previous topic; we are talking about a mobile app for the same product. For example,
    Facebook has a version for desktop, but it also has an app for mobile devices.
    It might be what you need as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发的产品需要特殊的应用实现，尤其是针对触摸设备呢？我们不是在谈论我们在前一个主题中实现的技巧；我们是在谈论同一产品的移动应用。例如，Facebook
    有桌面版本，但也为移动设备提供了应用。这可能也是你需要的。
- en: 'We would like to introduce Sencha Touch, the cousin of Ext JS! Sencha Touch
    was the first HTML5 mobile framework on the market. And there''s more good news:
    you do not need to rewrite all of your code to have the same application also
    available to mobile devices.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想介绍 Sencha Touch，它是 Ext JS 的表亲！Sencha Touch 是市场上第一个 HTML5 移动框架。而且还有更多好消息：你不需要重写所有代码，就可以让同样的应用也适用于移动设备。
- en: Sencha Touch and Ext JS share the same API. The data package, such as models,
    stores and the core of the framework, is the same. Sencha Touch also uses MVC.
    The Controller and View (components) work in a way that is very similar to that
    of Ext JS Controller and View. Of course, the biggest difference is in the views
    since a web component is different from a mobile component. However, Sencha Touch
    also offers forms and lists, and we can find even grid components customized for
    mobile devices. The charts are also shared between the frameworks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch 和 Ext JS 共享相同的 API。数据包，如模型、存储和框架的核心，是相同的。Sencha Touch 也使用 MVC。控制器和视图（组件）的工作方式与
    Ext JS 控制器和视图非常相似。当然，最大的区别在于视图，因为网络组件与移动组件不同。然而，Sencha Touch 也提供了表单和列表，我们甚至可以找到为移动设备定制的网格组件。图表在框架之间也是共享的。
- en: 'The following diagram shows the analysis of how much code we can reuse after
    using Sencha Touch:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用 Sencha Touch 后我们可以重用多少代码的分析：
- en: '![From Ext JS to mobile](img/0457OT_10_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![从 Ext JS 到移动](img/0457OT_10_06.jpg)'
- en: 'The amount of code we can reuse is huge! And we also have two ways of implementing
    it: the first one is to have a mobile app, where the user will access a URL pointing
    to a Sencha Touch deploy (Sencha Touch and server-side code at the same domain).
    And the second option is to have the Sencha Touch code running on the user''s
    device (Sencha Touch offers native packaging to iOS and Android, but we can also
    have native Blackberry 10 and Windows Phone 8 native apps with Sencha Touch) and
    the server-side code running on a server on the Web. In this case, we can use
    CORS ([http://enable-cors.org/](http://enable-cors.org/)) to make the Ajax communication
    between the app and the server-side code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用的代码量是巨大的！我们还有两种实现方式：第一种是拥有一个移动应用，用户将访问指向 Sencha Touch 部署的 URL（Sencha Touch
    和服务器端代码在同一域名下）。第二种选择是将 Sencha Touch 代码运行在用户的设备上（Sencha Touch 为 iOS 和 Android 提供了原生打包，但我们也可以使用
    Sencha Touch 创建原生 Blackberry 10 和 Windows Phone 8 应用），服务器端代码运行在 Web 服务器上。在这种情况下，我们可以使用
    CORS ([http://enable-cors.org/](http://enable-cors.org/)) 来实现应用和服务器端代码之间的 Ajax
    通信。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: To learn more about Sencha Touch, please go to [http://www.sencha.com/products/touch/](http://www.sencha.com/products/touch/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 Sencha Touch 的信息，请访问 [http://www.sencha.com/products/touch/](http://www.sencha.com/products/touch/)。
- en: 'On mobile, it is also possible to access the hardware features such as contacts,
    camera, geolocation, and more. We can use an open source framework called **Apache
    Cordova** (or **Phonegap**, which is a Apache Cordova implementation). Sencha
    Cmd also has commands that support the integration with Cordova. The following
    links provide more information about this topic:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上，也可以访问硬件功能，如联系人、相机、地理位置等。我们可以使用一个名为 **Apache Cordova** 的开源框架（或 **Phonegap**，它是
    Apache Cordova 的实现）。Sencha Cmd 也具有支持与 Cordova 集成的命令。以下链接提供了更多关于此主题的信息：
- en: '[http://docs.sencha.com/touch/2.4/tutorials/cordova_camera.html](http://docs.sencha.com/touch/2.4/tutorials/cordova_camera.html)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.sencha.com/touch/2.4/tutorials/cordova_camera.html](http://docs.sencha.com/touch/2.4/tutorials/cordova_camera.html)'
- en: '[http://cordova.apache.org/](http://cordova.apache.org/)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://cordova.apache.org/](http://cordova.apache.org/)'
- en: '[http://phonegap.com/](http://phonegap.com/)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://phonegap.com/](http://phonegap.com/)'
- en: '[http://vimeo.com/76568053](http://vimeo.com/76568053)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://vimeo.com/76568053](http://vimeo.com/76568053)'
- en: Debugging Ext JS applications
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Ext JS 应用程序
- en: The art of debugging is as important as the art of programming. We usually write
    code that we think is going to work as soon as we execute it, but this is not
    true sometimes. We write the code, then we get an exception or JavaScript error,
    and then we need to dive into the code again to see where we went wrong. It's
    part of being a developer and it is also part of life!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的艺术与编程的艺术一样重要。我们通常编写我们认为一旦执行就会工作的代码，但有时这并不正确。我们编写代码，然后遇到异常或 JavaScript 错误，然后我们需要再次深入代码以查看我们哪里出了错。这是开发者工作的一部分，也是生活的一部分！
- en: Throughout this book, you learned that debugging is important, especially when
    we were learning an easier way to figure out the correct **Component Query** selector.
    When developing applications with Ext JS, it is mandatory to use a debug tool.
    This is so because it is not only for debugging, but you will also be able to
    learn more about the framework, and it is a great learning exercise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你了解到调试很重要，尤其是在我们学习一种更简单的方式来确定正确的 **组件查询** 选择器时。当使用 Ext JS 开发应用程序时，使用调试工具是强制性的。这是因为它不仅用于调试，你还将能够更多地了解框架，而且这是一项极好的学习练习。
- en: 'A few things we always need to remind ourselves of while creating Ext JS applications:
    case-sensitive matters—the `LoginScreen` class is different from `Loginscreen`.
    Be careful with reserved words ([http://mattsnider.com/reserved-words-in-javascript/](http://mattsnider.com/reserved-words-in-javascript/))—you
    cannot use them as namespaces, names of classes and packages, or as variable names.
    Check the spelling; this is very important—sometimes when we are typing, we can
    type an extra character (*fat finger* syndrome).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Ext JS 应用程序时，我们始终需要提醒自己的几点：大小写敏感——`LoginScreen` 类与 `Loginscreen` 不同。小心保留字（[http://mattsnider.com/reserved-words-in-javascript/](http://mattsnider.com/reserved-words-in-javascript/))——你不能将它们用作命名空间、类和包的名称，或者用作变量名。检查拼写；这非常重要——有时当我们输入时，可能会多输入一个字符（*大拇指指错*综合症）。
- en: If you have programmed in JavaScript for almost 10 years now, you will know
    that before, our only friend was the dear `alert` prompt. We used to put several
    alerts on the code, execute it, and then see which alert was not executed so that
    we could find where the error was. Now we have our dear friend `console`. Abuse
    the use of console for `log`, `warn`, and `error`!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在几乎已经用 JavaScript 编程了10年，你会知道在此之前，我们唯一的伙伴是亲爱的 `alert` 提示框。我们过去经常在代码中放置几个提示框，执行代码，然后查看哪个提示框没有被执行，以便我们可以找到错误所在。现在我们有我们亲爱的朋友
    `console`。滥用 `console` 的 `log`、`warn` 和 `error` 功能！
- en: We also have great tools to debug! The two most important are Google Developer
    Tools and Firebug for Firefox! Learn to use at least one of them (they are very
    similar).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还拥有出色的调试工具！其中最重要的两个是 Google 开发者工具和 Firefox 的 Firebug！至少学会使用其中一个（它们非常相似）。
- en: 'For example, let''s use Google Developer Tools. It comes with a few tabs; on
    the **Network** tab, we can see the files that were loaded as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用 Google 开发者工具。它包含几个标签页；在 **网络** 标签页上，我们可以看到如下加载的文件：
- en: '![Debugging Ext JS applications](img/0457OT_10_07.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Ext JS 应用程序](img/0457OT_10_07.jpg)'
- en: And speaking of files that are being loaded or not, this is a very huge deal!
    Simple mistakes, such as the name of the class (using MVC), path of CSS, and JS
    on the `index.html` file, can be verified using the **Console** or the **Network**
    tab. This tab is also very important as in some chapters we verified the parameters
    that were being sent to the server. Even though it might be the first time we
    are working with an Ext JS component, and we do not know how to handle the data
    that will be sent to the server, we can take a look at the parameters of the request
    in the **Network** tab, and then it is easier to read the correct parameters in
    the server. The same applies when we receive any information from the server,
    for example, check whether the JSON is coming as per Ext JS expectations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 至于正在加载或未加载的文件，这是一个非常大的问题！简单的错误，比如类的名称（使用 MVC）、CSS 路径和 `index.html` 文件中的 JS，可以使用
    **控制台** 或 **网络** 选项卡进行验证。这个选项卡也非常重要，因为在某些章节中，我们验证了发送到服务器的参数。即使这是我们第一次使用 Ext JS
    组件，并且我们不知道如何处理将发送到服务器的数据，我们也可以查看 **网络** 选项卡中的请求参数，然后更容易地读取服务器上的正确参数。当我们从服务器接收任何信息时，这也适用，例如，检查
    JSON 是否符合 Ext JS 的预期。
- en: On the **Elements** tab, we can see details; the HTML code that was generated
    by the Ext JS code and also the CSS that is being applied to the components. This
    is very useful when we want to apply some custom CSS and debug why the style was
    not applied.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **元素** 选项卡中，我们可以看到详细信息；由 Ext JS 代码生成的 HTML 代码以及应用于组件的 CSS。当我们想要应用一些自定义 CSS
    并调试为什么样式没有被应用时，这非常有用。
- en: '![Debugging Ext JS applications](img/0457OT_10_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Ext JS 应用程序](img/0457OT_10_08.jpg)'
- en: When we move the mouse over, the portion related to that HTML is highlighted
    on the screen. We also have the **CSS** and **Script** tabs. We can change the
    CSS and script in real time and see the changes applied in real time! This is
    simply amazing! So, it is very important to learn how to use a debug tool.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将鼠标移过时，与该 HTML 相关的部分会在屏幕上突出显示。我们还有 **CSS** 和 **脚本** 选项卡。我们可以实时更改 CSS 和脚本，并实时看到应用的变化！这真是太神奇了！因此，学习如何使用调试工具非常重要。
- en: 'In the **Sources** tab, we can take the source code that was loaded in the
    form of the project''s structure. This tab is very important for us because it
    allows us to use the debugging capabilities of the browser to debug our code.
    The debugging technique is very similar to what is used with server-side languages;
    we add a breakpoint, execute the code, and then watch and inspect variable values
    and see what happens in every line of the source code, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **源** 选项卡中，我们可以以项目结构的形式获取加载的源代码。对我们来说，这个选项卡非常重要，因为它允许我们使用浏览器的调试功能来调试我们的代码。调试技术非常类似于在服务器端语言中使用的技术；我们添加断点，执行代码，然后观察和检查变量值，查看源代码的每一行发生了什么，如下所示：
- en: '![Debugging Ext JS applications](img/0457OT_10_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Ext JS 应用程序](img/0457OT_10_09.jpg)'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn more about Firebug, please visit [http://getfirebug.com/](http://getfirebug.com/).
    And to learn more about Google Developer Tools, please visit: [https://developers.google.com/chrome-developer-tools/](https://developers.google.com/chrome-developer-tools/)
    and [https://developer.chrome.com/extensions/tut_debugging](https://developer.chrome.com/extensions/tut_debugging).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 Firebug 的信息，请访问 [http://getfirebug.com/](http://getfirebug.com/)。想了解更多关于
    Google 开发者工具的信息，请访问：[https://developers.google.com/chrome-developer-tools/](https://developers.google.com/chrome-developer-tools/)
    和 [https://developer.chrome.com/extensions/tut_debugging](https://developer.chrome.com/extensions/tut_debugging)。
- en: 'And, of course, there are the special add-ons we talked about in [Chapter 7](ch07.html
    "Chapter 7. Static Data Management"), *Static Data Management*: Sencha add-on
    for Chrome and Illumination for developers for Firebug.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有我们在第 7 章[静态数据管理](ch07.html "第 7 章。静态数据管理")中提到的特殊附加组件：Sencha 为 Chrome 提供的附加组件和
    Illumination 为 Firebug 开发者提供的附加组件。
- en: Mastering one debugging tool is important as mastering the art of programming
    in Ext JS. After all, we don't know if we will have the opportunity to work on
    a project from scratch or we will need to maintain other developers' code. In
    this case, knowing how to debug is a must-have skill! Choose your favorite weapon
    and have fun coding and debugging!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握一个调试工具与掌握 Ext JS 编程的艺术同样重要。毕竟，我们不知道我们是否会有机会从头开始工作在一个项目上，或者我们需要维护其他开发者的代码。在这种情况下，知道如何调试是一项必备技能！选择你喜欢的工具，享受编码和调试的乐趣！
- en: Testing Ext JS applications
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Ext JS 应用程序
- en: Testing is a very important part when developing applications or providing maintenance.
    When we do not write tests, we need to verify each use case manually, and if we
    change anything on the code, we will need to perform all the testing manually
    again. The same happens when we need to maintain the code; developers usually
    test only what has been changed, but the correct thing to do would be regression
    tests to see whether the change did not break anything else. So spending some
    time writing tests can be a win at the end. You will spend a little bit more time
    writing code, but then you will be able to run all the tests with a single click
    and then verify what is broken and what is still working.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在开发应用程序或提供维护时是一个非常重要的部分。当我们不编写测试时，我们需要手动验证每个用例，如果我们对代码进行了任何更改，我们还需要手动重新执行所有测试。当我们需要维护代码时，情况也是如此；开发者通常只测试更改的部分，但正确的方法应该是回归测试，以查看更改是否破坏了其他任何东西。因此，花一些时间编写测试最终可能是有益的。你将花费更多的时间编写代码，但然后你将能够通过单次点击运行所有测试，并验证哪些部分出了问题，哪些部分仍在正常工作。
- en: We are also very used to performing unit tests on the server-side code. Java,
    PHP, Ruby, C# communities offer a lot of options to perform unit tests on the
    server-side code, and sometimes, we can forget to test the frontend code (in this
    case Ext JS). But do not worry; there are a few tools we can use to include Ext
    JS on the tests as well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也非常习惯于在服务器端代码上执行单元测试。Java、PHP、Ruby、C# 社区提供了很多选项来执行服务器端代码的单元测试，有时我们可能会忘记测试前端代码（在这种情况下是
    Ext JS）。但不用担心；有一些工具我们可以使用，以便将 Ext JS 也包含在测试中。
- en: 'One tool that is very popular for JavaScript testing in general is **Jasmine**
    ([http://jasmine.github.io/](http://jasmine.github.io/)). Jasmine is a testing
    tool that is used for **Behavior-Driven Development** (**BDD**)—([http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development)).
    In Ext JS documentation, you can find two guides explaining how to test Ext JS
    applications with Jasmine: [http://docs.sencha.com/extjs/4.2.0/#!/guide/testing](http://docs.sencha.com/extjs/4.2.0/#!/guide/testing)
    and [http://docs.sencha.com/extjs/4.2.0/#!/guide/testing_controllers](http://docs.sencha.com/extjs/4.2.0/#!/guide/testing_controllers).
    Although the guides were written for Ext JS 4.x, they can also be applied to Ext
    JS 5.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般的 JavaScript 测试来说，一个非常受欢迎的工具是 **Jasmine** ([http://jasmine.github.io/](http://jasmine.github.io/))。Jasmine
    是一个用于 **行为驱动开发**（**BDD**）的测试工具（[http://en.wikipedia.org/wiki/Behavior_driven_development](http://en.wikipedia.org/wiki/Behavior_driven_development)）。在
    Ext JS 文档中，你可以找到两篇指南，解释如何使用 Jasmine 测试 Ext JS 应用程序：[http://docs.sencha.com/extjs/4.2.0/#!/guide/testing](http://docs.sencha.com/extjs/4.2.0/#!/guide/testing)
    和 [http://docs.sencha.com/extjs/4.2.0/#!/guide/testing_controllers](http://docs.sencha.com/extjs/4.2.0/#!/guide/testing_controllers)。尽管这些指南是为
    Ext JS 4.x 编写的，但它们也可以应用于 Ext JS 5。
- en: There is also a testing framework designed specially for a Sencha application
    called **Siesta** ([http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/)).
    Siesta can also be used to test JavaScript code in general, but the cool side
    of Siesta is that it provides a special API so that we can test Ext JS applications,
    including tests on user interface components. Siesta comes with some great examples
    that can be used to start writing our own test cases.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个专门为 Sencha 应用程序设计的测试框架，称为 **Siesta** ([http://www.bryntum.com/products/siesta/](http://www.bryntum.com/products/siesta/))。Siesta
    还可以用于测试一般的 JavaScript 代码，但 Siesta 的酷之处在于它提供了一个特殊的 API，这样我们就可以测试 Ext JS 应用程序，包括对用户界面组件的测试。Siesta
    随带了一些优秀的示例，我们可以使用这些示例来开始编写自己的测试用例。
- en: Helpful tools
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的工具
- en: In this topic, we will present some tools that can help developers a lot while
    implementing Ext JS applications. You can find all the links of the tools mentioned
    here at the end of this topic.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将介绍一些可以帮助开发者实现 Ext JS 应用程序的工具。你可以在这个主题的末尾找到提到的所有工具的链接。
- en: The first tool is **JSLint**. JSLint is a tool that can help you to find JavaScript
    errors and can also help you to clean your code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一款工具是 **JSLint**。JSLint 是一款可以帮助你查找 JavaScript 错误并帮助你清理代码的工具。
- en: The second tool is **YSlow**. YSlow analyzes web pages and tells you why they're
    slow based on the rules for high performance websites. YSlow is a Firefox add-on
    integrated with the popular Firebug web development tool.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第二款工具是 **YSlow**。YSlow 分析网页，并基于高性能网站的规则告诉你它们为什么运行缓慢。YSlow 是一个与流行的 Firebug 网页开发工具集成的
    Firefox 插件。
- en: Ext JS is a JavaScript framework, and JavaScript performance is a topic that
    is a concern for a lot of companies. The minimum the user needs to load on the
    browser, the better. That is why it is very important to make a production build
    using Sencha Cmd and not simply deploy all the application files on production.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 是一个 JavaScript 框架，JavaScript 性能是许多公司关心的话题。用户在浏览器上需要加载的最小内容越好。这就是为什么使用
    Sencha Cmd 进行生产构建非常重要，而不是简单地将所有应用程序文件部署到生产环境中。
- en: Sencha Cmd is also going to minify the Ext JS CSS file to a smaller CSS, and
    we can also include only the CSS for the components that we are going to really
    use (just in case we create a custom theme). It is also important to create any
    application custom CSS inside the `sass/etc` or `sass/var` folders so that the
    CSS can also be added to the main CSS file generated by Sencha Cmd.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd 还会压缩 Ext JS CSS 文件到一个更小的 CSS 文件，我们也可以只包含我们将要真正使用的组件的 CSS（以防我们创建了一个自定义主题）。同样重要的是，在
    `sass/etc` 或 `sass/var` 文件夹中创建任何应用程序自定义 CSS，以便 CSS 也可以添加到由 Sencha Cmd 生成的主 CSS
    文件中。
- en: '**CSS Sprites** is another very important topic. Font icons such as Font Awesome
    are really nice, but sometimes that is a need to use image icons. In this case,
    we can create a CSS Sprite, which involves creating a single image with all the
    icons. And on the CSS, we simply have a single image and pass a `background-position`
    property of the icon we want to display, like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSS Sprites** 是另一个非常重要的主题。字体图标，如 Font Awesome，确实很棒，但有时需要使用图像图标。在这种情况下，我们可以创建一个
    CSS Sprite，这涉及到创建一个包含所有图标的单个图像。在 CSS 中，我们只需一个图像，并传递一个 `background-position` 属性来显示我们想要的图标，如下所示：'
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are a few tools that can also help us to create CSS Sprites, such as **SpritePad**,
    **SpriteMe**, and **Compass Sprite Generator**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具也可以帮助我们创建 CSS Sprites，例如 **SpritePad**、**SpriteMe** 和 **Compass Sprite
    Generator**。
- en: 'Here are all the links for the tools mentioned in this section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本节中提到的所有工具的链接：
- en: '**JSLint**: [http://www.jslint.com/](http://www.jslint.com/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSLint**：[http://www.jslint.com/](http://www.jslint.com/)'
- en: '**YSlow**: [http://developer.yahoo.com/yslow/](http://developer.yahoo.com/yslow/)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YSlow**：[http://developer.yahoo.com/yslow/](http://developer.yahoo.com/yslow/)'
- en: '**SpritePad**: [http://wearekiss.com/spritepad](http://wearekiss.com/spritepad)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SpritePad**：[http://wearekiss.com/spritepad](http://wearekiss.com/spritepad)'
- en: '**SpriteMe**: [http://www.spriteme.org/](http://www.spriteme.org/)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SpriteMe**：[http://www.spriteme.org/](http://www.spriteme.org/)'
- en: '**Compass Sprite Generator**: [http://compass-style.org/help/tutorials/spriting/](http://compass-style.org/help/tutorials/spriting/)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Compass Sprite Generator**：[http://compass-style.org/help/tutorials/spriting/](http://compass-style.org/help/tutorials/spriting/)'
- en: Always remember that Ext JS is JavaScript, so we need to care about performance
    as well. With all these little tips posted on this topic, an Ext JS application
    can improve its performance as well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，Ext JS 是 JavaScript，因此我们还需要关注性能。通过在这个主题上发布的所有这些小贴士，一个 Ext JS 应用程序可以提高其性能。
- en: 'And last but not least, there are two tools from Sencha: **Sencha** **Architect**
    and **Sencha** **Eclipse** **Plugin**. Sencha Architect is a visual designer tool
    that is very similar to Visual Studio: you drag and drop, and you can see how
    the application looks, and the entire configuration that you need to do is done
    using the **Config** panel. Only methods, functions, and templates are free to
    enter whatever code you like. The good thing about Sencha Architect is that it
    helps to follow all the best practices and the code is very well organized. You
    can also develop all the Ext JS code using Sencha Architect, and on the server
    side, you can continue using the IDE you like the most (Eclipse, Aptana, Visual
    Studio, and others).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，Sencha 提供了两个工具：**Sencha Architect** 和 **Sencha Eclipse Plugin**。Sencha
    Architect 是一个类似于 Visual Studio 的可视化设计工具：你可以拖放元素，并可以看到应用程序的外观，以及你需要完成的整个配置都是通过
    **Config** 面板来完成的。只有方法、函数和模板可以自由输入你喜欢的代码。Sencha Architect 的好处在于它有助于遵循所有最佳实践，并且代码组织得非常好。你还可以使用
    Sencha Architect 开发所有的 Ext JS 代码，并且在服务器端，你可以继续使用你最喜爱的 IDE（Eclipse、Aptana、Visual
    Studio 等）。
- en: And Sencha Eclipse Plugin is a plugin for the Eclipse IDE that has the autocomplete
    feature enabled. Both Sencha Architect and Sencha Eclipse Plugin are paid tools.
    But you can download a trial version for testing at [http://www.sencha.com/products/complete/](http://www.sencha.com/products/complete/)
    or [http://www.sencha.com/products/architect/](http://www.sencha.com/products/architect/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Eclipse插件是Eclipse IDE的一个插件，它启用了自动完成功能。Sencha Architect和Sencha Eclipse插件都是付费工具。但你可以下载试用版进行测试，地址为[http://www.sencha.com/products/complete/](http://www.sencha.com/products/complete/)或[http://www.sencha.com/products/architect/](http://www.sencha.com/products/architect/)。
- en: Another great IDE to develop Sencha applications is **WebStorm** (or **IntelliJ
    IDEA**). WebStorm also has the autocomplete feature (if we set it up), support
    for Sass and Compass (used by Ext JS for theming), and JSLint to validate the
    JavaScript code, among other features. It is also a paid tool, but you can download
    a trial version for testing at [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/).
    The source of this book was written with IntelliJ IDEA.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于开发Sencha应用程序的出色IDE是**WebStorm**（或**IntelliJ IDEA**）。WebStorm还具备自动完成功能（如果设置正确），支持Sass和Compass（Ext
    JS用于主题的库），以及JSLint来验证JavaScript代码，以及其他功能。它也是一个付费工具，但你可以下载试用版进行测试，地址为[https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/)。本书的源代码是用IntelliJ
    IDEA编写的。
- en: Third-party components and plugins
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方组件和插件
- en: 'Although Ext JS provides great components, we usually will also want to develop
    our own components or maybe use other developers'' components. The Ext JS community
    is great regarding this subject. A lot of developers share their own components,
    extensions, and plugins with the community. There are two main places you can
    find them:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ext JS提供了优秀的组件，但我们通常还希望开发自己的组件，或者可能使用其他开发者的组件。在这一点上，Ext JS社区做得很好。许多开发者与社区分享他们自己的组件、扩展和插件。你可以从以下两个主要地方找到它们：
- en: '**Sencha Market**: [https://market.sencha.com/](https://market.sencha.com/)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sencha市场**：[https://market.sencha.com/](https://market.sencha.com/)'
- en: '**Sencha Forum**: [http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins](http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sencha论坛**：[http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins](http://www.sencha.com/forum/forumdisplay.php?82-Ext-User-Extensions-and-Plugins)'
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to enable routing, and you also quickly overviewed
    responsible design and touch support for Ext JS applications. You learned about
    the importance of knowing how to debug an Ext JS application and about some tools
    that can help us with this task. You also learned that performance is really important
    and that we can do a lot more to improve the performance of our Ext JS application
    with the help of some free tools. We also listed where to find great plugins,
    extensions, and new components that we can use in our projects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何启用路由，并且也快速概述了Ext JS应用程序的责任设计和触摸支持。你了解了了解如何调试Ext JS应用程序的重要性，以及一些可以帮助我们完成这项任务的工具。你还了解到性能非常重要，并且我们可以借助一些免费工具做更多的事情来提高我们Ext
    JS应用程序的性能。我们还列出了在哪里可以找到优秀的插件、扩展和新组件，这些我们可以在项目中使用。
- en: In the next chapter, we will customize the theme for our application, and we
    will perform the production build.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的应用程序定制主题，并执行生产构建。
