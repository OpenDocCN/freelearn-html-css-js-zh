- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Node.js Platform
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 平台
- en: 'Some principles and design patterns literally define the developer experience
    with the Node.js platform and its ecosystem. The most peculiar one is probably
    its asynchronous nature, which makes heavy use of asynchronous constructs such
    as callbacks and promises. In this introductory chapter, we will explore where
    Node.js gets its asynchronous behavior from. This is not just good-to-know theoretical
    information: knowing how Node.js works at its core will give you a strong foundation
    for understanding the reasoning behind more complex topics and patterns that we
    will cover later in the book.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些原则和设计模式实际上定义了开发者与 Node.js 平台及其生态系统的体验。其中最独特的一个可能是其异步性，它大量使用了异步构造，如回调和承诺。在本章介绍中，我们将探讨
    Node.js 的异步行为从何而来。这不仅仅是了解的理论信息：了解 Node.js 在其核心是如何工作的，将为你理解我们将在本书后面章节中涵盖的更复杂主题和模式背后的推理提供一个坚实的基础。
- en: 'Another important aspect that characterizes Node.js is its philosophy. Approaching
    Node.js is, in fact, far more than simply learning a new technology: it''s also
    embracing a culture and a community. You will see how this greatly influences
    the way we design our applications and components, and the way they interact with
    those created by the community.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个定义 Node.js 的重要方面是其哲学。实际上，接近 Node.js 远不止是学习一项新技术：它还意味着拥抱一种文化和社区。你将看到这一点如何极大地影响我们设计应用程序和组件的方式，以及它们与社区创建的组件的交互方式。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下内容：
- en: The Node.js philosophy or the "Node way"
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 哲学或“Node 风格”
- en: The reactor pattern—the mechanism at the heart of the Node.js asynchronous event-driven
    architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应器模式——Node.js 异步事件驱动架构的核心机制
- en: What it means to run JavaScript on the server compared to the browser
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上运行 JavaScript 与在浏览器上运行 JavaScript 的区别
- en: The Node.js philosophy
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 哲学
- en: Every programming platform has its own philosophy, a set of principles and guidelines
    that are generally accepted by the community, or an ideology for doing things
    that influence both the evolution of the platform and how applications are developed
    and designed. Some of these principles arise from the technology itself, some
    of them are enabled by its ecosystem, some are just trends in the community, and
    others are evolutions of ideologies borrowed from other platforms. In Node.js,
    some of these principles come directly from its creator—Ryan Dahl—while others
    come from the people who contribute to the core or from charismatic figures in
    the community, and, finally, some are inherited from the larger JavaScript movement.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编程平台都有自己的哲学，一套被社区普遍接受的原则和指南，或者是一种做事的意识形态，它影响着平台的发展以及应用程序的开发和设计。其中一些原则源于技术本身，一些原则是由其生态系统所启用的，一些原则只是社区中的趋势，而其他原则则是从其他平台借鉴的意识形态的演变。在
    Node.js 中，一些原则直接来自其创造者——Ryan Dahl，一些原则来自对核心做出贡献的人，或者来自社区中的魅力人物，最后，一些原则是从更大的 JavaScript
    运动中继承而来的。
- en: None of these rules are imposed and they should always be applied with common
    sense; however, they can prove to be tremendously useful when we are looking for
    a source of inspiration while designing our software.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则都不是强制的，并且它们应该始终以常识为基础应用；然而，当我们寻找设计软件时的灵感来源时，它们可以证明是非常有用的。
- en: You can find an extensive list of software development philosophies on Wikipedia
    at [nodejsdp.link/dev-philosophies](http://nodejsdp.link/dev-philosophies).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在维基百科上找到关于软件开发哲学的详尽列表，请访问 [nodejsdp.link/dev-philosophies](http://nodejsdp.link/dev-philosophies)。
- en: Small core
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小型核心
- en: The Node.js core—understood as the Node.js runtime and built-in modules—has
    its foundations built on a few principles. One of these is having the smallest
    possible set of functionalities, while leaving the rest to the so-called **userland** (or **userspace**),
    which is the ecosystem of modules living outside the core. This principle has
    an enormous impact on the Node.js culture, as it gives freedom to the community
    to experiment and iterate quickly on a broader set of solutions within the scope
    of the userland modules, instead of having one slowly evolving solution that is
    built into the more tightly controlled and stable core. Keeping the core set of
    functionalities to the bare minimum, then, is not only convenient in terms of
    maintainability, but also in terms of the positive cultural impact that it brings
    to the evolution of the entire ecosystem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的核心——理解为Node.js运行时和内置模块——建立在几个原则之上。其中之一是拥有尽可能小的功能集，而将其他功能留给所谓的**用户空间**（或**userspace**），即存在于核心之外的模块生态系统。这一原则对Node.js文化产生了巨大影响，因为它赋予了社区在用户空间模块范围内快速实验和迭代的自由，而不是有一个缓慢发展的解决方案被构建在更严格控制和稳定的核心中。因此，将核心功能集保持到最基本，不仅便于维护，而且对整个生态系统的演变产生了积极的文化影响。
- en: Small modules
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小型模块
- en: Node.js uses the concept of a **module** as the fundamental means for structuring
    the code of a program. It is the building block for creating applications and
    reusable libraries. In Node.js, one of the most evangelized principles is designing
    small modules (and packages), not only in terms of raw code size, but, most importantly,
    in terms of scope.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使用**模块**的概念作为构建程序代码的基本手段。它是创建应用程序和可重用库的基石。在Node.js中，最被推崇的原则之一是设计小型模块（和包），不仅从原始代码大小来看，更重要的是在范围上。
- en: 'This principle has its roots in the Unix philosophy, and particularly in two
    of its precepts, which are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则源于Unix哲学，尤其是在其两条戒律中，具体如下：
- en: '"Small is beautiful."'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “小即是美。”
- en: '"Make each program do one thing well."'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “让每个程序只做一件事，做好。”
- en: Node.js has brought these concepts to a whole new level. Along with the help
    of its module managers—with **npm** and **yarn** being the most popular—Node.js
    helps to solve the *dependency hell* problem by making sure that two (or more)
    packages depending on different versions of the same package will use their own
    installations of such a package, thus avoiding conflicts. This aspect allows packages
    to depend on a high number of small, well-focused dependencies without the risk
    of creating conflicts. While this can be considered unpractical or even totally
    unfeasible in other platforms, in Node.js, this practice is the norm. This enables
    extreme levels of reusability; they are so extreme, in fact, that sometimes we
    can find packages comprising of a single module containing just a couple of lines
    of code—for example, a regular expression for matching emails such as [nodejsdp.link/email-regex](http://nodejsdp.link/email-regex).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js将这些概念提升到了全新的水平。借助其模块管理器——其中**npm**和**yarn**是最受欢迎的——Node.js通过确保两个（或更多）依赖于同一包不同版本的包将使用它们自己的安装包，从而避免冲突，帮助解决*依赖地狱*问题。这一方面使得包可以依赖大量小型、专注的依赖项，而不会产生冲突的风险。虽然这在其他平台上可能被认为是不切实际的，甚至完全不可行，但在Node.js中，这种做法是常态。这使重用性达到了极端水平；实际上，有时我们可以找到只包含几行代码的单个模块的包——例如，用于匹配电子邮件的正则表达式[nodejsdp.link/email-regex](http://nodejsdp.link/email-regex)。
- en: 'Besides the clear advantage in terms of reusability, a small module is also:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在可重用性方面的明显优势外，小型模块也是：
- en: Easier to understand and use
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更易于理解和使用
- en: Simpler to test and maintain
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易测试和维护
- en: Small in size and perfect for use in the browser
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尺寸小，非常适合在浏览器中使用
- en: Having smaller and more focused modules empowers everyone to share or reuse
    even the smallest piece of code; it's the **Don't Repeat Yourself** (**DRY**)
    principle applied at a whole new level.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有更小、更专注的模块使每个人都能共享或重用哪怕是最小的代码片段；这是在全新层面上应用的**不要重复自己**（**DRY**）原则。
- en: Small surface area
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表面积小
- en: In addition to being small in size and scope, a desirable characteristic of
    Node.js modules is exposing a minimal set of functionalities to the outside world.
    This has the effect of producing an API that is clearer to use and less susceptible
    to erroneous usage. In fact, most of the time the user of a component is only
    interested in a very limited and focused set of features, without needing to extend
    its functionality or tap into more advanced aspects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在大小和范围上较小之外，Node.js模块的一个理想特性是向外界暴露最小的一组功能。这产生了一个更易于使用且不太可能被错误使用的API。事实上，大多数时候，组件的用户只对非常有限和专注的一组功能感兴趣，而不需要扩展其功能或深入了解更高级的方面。
- en: In Node.js, a very common pattern for defining modules is to expose only one
    functionality, such as a function or a class, for the simple fact that it provides
    a single, unmistakably clear entry point.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，定义模块的一个非常常见的模式是只暴露一个功能，比如一个函数或一个类，仅仅是因为它提供了一个单一、明确无误的入口点。
- en: Another characteristic of many Node.js modules is the fact that they are created
    to be used, rather than extended. Locking down the internals of a module by forbidding
    any possibility of an extension might sound inflexible, but it actually has the
    advantage of reducing use cases, simplifying implementation, facilitating maintenance,
    and increasing usability. In practice, this means preferring to expose functions
    instead of classes, and being careful not to expose any internals to the outside
    world.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Node.js模块的另一个特点是它们被创建出来是为了使用，而不是扩展。通过禁止任何扩展的可能性来锁定模块的内部可能听起来不够灵活，但实际上它具有减少用例、简化实现、促进维护和提高可用性的优势。在实践中，这意味着更倾向于暴露函数而不是类，并且要小心不要向外界暴露任何内部内容。
- en: Simplicity and pragmatism
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单性和务实性
- en: 'Have you ever heard of the **Keep It Simple, Stupid** (**KISS**) principle?
    Richard P. Gabriel, a prominent computer scientist, coined the term "worse is
    better" to describe the model whereby less and simpler functionality is a good
    design choice for software. In his essay *The Rise of "Worse is Better"* he says:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否听说过**简单至上，傻瓜也明白**（**KISS**）原则？理查德·P·加贝尔，一位杰出的计算机科学家，提出了“越差越好”这个术语来描述这样一个模型：软件的设计选择更少、更简单的功能是一个好的设计选择。在他的文章《“越差越好”的兴起》中他说道：
- en: '"The design must be simple, both in implementation and interface. It is more
    important for the implementation to be simple than the interface. Simplicity is
    the most important consideration in a design."'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “设计必须简单，无论是在实现上还是在接口上。实现简单比接口简单更重要。简单性是设计中最重要的考虑因素。”
- en: 'Designing simple, as opposed to perfect, fully featured software is a good
    practice for several reasons: it takes less effort to implement, it allows shipping
    faster with fewer resources, it''s easier to adapt, and, finally, it''s easier
    to maintain and understand. The positive effects of these factors encourage community
    contributions and allow the software itself to grow and improve.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与设计完美、功能齐全的软件相比，设计简单的软件有多个原因：它需要更少的实施努力，它允许以更少的资源更快地发货，它更容易适应，最后，它更容易维护和理解。这些因素的积极影响鼓励社区贡献，并允许软件本身成长和改进。
- en: In Node.js, the adoption of this principle is also facilitated by JavaScript,
    which is a very pragmatic language. In fact, it's common to see simple classes,
    functions, and closures replacing complex class hierarchies. Pure object-oriented
    designs often try to replicate the real world using the mathematical terms of
    a computer system without considering the imperfection and complexity of the real
    world itself. Instead, the truth is that our software is always an approximation
    of reality, and we will probably have more success by trying to get something
    working sooner and with reasonable complexity, instead of trying to create near-perfect
    software with huge effort and tons of code to maintain.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，这种原则的采用也得益于JavaScript，这是一种非常务实的语言。事实上，常见的是简单的类、函数和闭包取代复杂的类层次结构。纯面向对象的设计通常试图使用计算机系统的数学术语来复制现实世界，而不考虑现实世界本身的缺陷和复杂性。相反，事实是，我们的软件总是现实的一种近似，我们可能会通过尽早以合理的复杂性实现某些功能而取得更大的成功，而不是通过巨大的努力和大量的代码来创建几乎完美的软件。
- en: Throughout this book, you will see this principle in action many times. For example,
    a considerable number of traditional design patterns, such as Singleton or Decorator,
    can have a trivial, even if sometimes not bulletproof, implementation, and you
    will see how an uncomplicated, practical approach is (most of the time) preferred
    to a pure, flawless design.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，您将多次看到这个原理在行动。例如，许多传统设计模式，如 Singleton 或 Decorator，可以有简单甚至有时不是万无一失的实现，您将看到简单、实用的方法（大多数时候）比纯、完美的设计更受欢迎。
- en: Next, we will take a look inside the Node.js core to reveal its internal patterns
    and event-driven architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解 Node.js 的核心，揭示其内部模式和事件驱动架构。
- en: How Node.js works
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 的工作原理
- en: In this section, you will gain an understanding of how Node.js works internally
    and be introduced to the reactor pattern, which is the heart of the asynchronous
    nature of Node.js. We will go through the main concepts behind the pattern, such
    as the single-threaded architecture and the non-blocking I/O, and you will see
    how this creates the foundation for the entire Node.js platform.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解 Node.js 内部的工作原理，并介绍反应器模式，这是 Node.js 异步性质的核心。我们将探讨该模式背后的主要概念，如单线程架构和非阻塞
    I/O，您将看到这些如何为整个 Node.js 平台奠定基础。
- en: I/O is slow
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 很慢
- en: I/O (short for input/output) is definitely the slowest among the fundamental
    operations of a computer. Accessing the RAM is in the order of nanoseconds (10E-9
    seconds), while accessing data on the disk or the network is in the order of milliseconds
    (10E-3 seconds). The same applies to the bandwidth. RAM has a transfer rate consistently
    in the order of GB/s, while the disk or network varies from MB/s to optimistically
    GB/s. I/O is usually not expensive in terms of CPU, but it adds a delay between
    the moment the request is sent to the device and the moment the operation completes.
    On top of that, we have to consider the human factor. In fact, in many circumstances,
    the input of an application comes from a real person—a mouse click, for example—so
    the speed and frequency of I/O doesn't only depend on technical aspects, and it
    can be many orders of magnitude slower than the disk or network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: I/O（代表输入/输出）无疑是计算机基本操作中最慢的。访问 RAM 的时间量级为纳秒（10E-9 秒），而访问磁盘或网络上的数据的时间量级为毫秒（10E-3
    秒）。同样适用于带宽。RAM 的传输速率始终在 GB/s 的量级，而磁盘或网络则从 MB/s 到乐观的 GB/s 不等。I/O 在 CPU 方面通常不昂贵，但它会在请求发送到设备的那一刻和操作完成的那一刻之间增加延迟。除此之外，我们还需要考虑人为因素。实际上，在许多情况下，应用程序的输入来自真实的人——例如鼠标点击——因此
    I/O 的速度和频率不仅取决于技术方面，而且可能比磁盘或网络慢几个数量级。
- en: Blocking I/O
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞 I/O
- en: 'In traditional blocking I/O programming, the function call corresponding to
    an I/O request will block the execution of the thread until the operation completes.
    This can range from a few milliseconds, in the case of disk access, to minutes
    or even more, in the case of data being generated from user actions, such as pressing
    a key. The following pseudocode shows a typical blocking thread performed against
    a socket:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的阻塞 I/O 编程中，对应 I/O 请求的功能调用将阻塞线程的执行，直到操作完成。这可能在磁盘访问的情况下只需要几毫秒，而在用户操作（如按下一个键）生成数据的情况下，可能需要几分钟甚至更长时间。下面的伪代码展示了针对套接字执行的典型阻塞线程：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is trivial to notice that a web server that is implemented using blocking
    I/O will not be able to handle multiple connections in the same thread. This is
    because each I/O operation on a socket will block the processing of any other
    connection. The traditional approach to solving this problem is to use a separate
    thread (or process) to handle each concurrent connection.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易注意到，使用阻塞 I/O 实现的 Web 服务器无法在同一个线程中处理多个连接。这是因为套接字上的每个 I/O 操作都会阻塞其他任何连接的处理。解决这个问题的传统方法是为每个并发连接使用单独的线程（或进程）。
- en: This way, a thread blocked on an I/O operation will not impact the availability
    of the other connections, because they are handled in separate threads.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在 I/O 操作上阻塞的线程不会影响其他连接的可用性，因为它们是在单独的线程中处理的。
- en: 'The following illustrates this scenario:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了这种情况：
- en: '![](img/B15729_01_01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_01_01.png)'
- en: 'Figure 1.1: Using multiple threads to process multiple connections'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：使用多个线程处理多个连接
- en: '*Figure 1.1* lays emphasis on the amount of time each thread is idle and waiting
    for new data to be received from the associated connection. Now, if we also consider
    that any type of I/O can possibly block a request—for example, while interacting
    with databases or with the filesystem—we will soon realize how many times a thread
    has to block in order to wait for the result of an I/O operation. Unfortunately,
    a thread is not cheap in terms of system resources—it consumes memory and causes
    context switches—so having a long-running thread for each connection and not using
    it for most of the time means wasting precious memory and CPU cycles.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.1*强调了每个线程空闲并等待从相关连接接收新数据的时间量。现在，如果我们还考虑到任何类型的I/O都可能阻塞请求——例如，在与数据库或文件系统交互时——我们很快就会意识到线程需要阻塞多少次才能等待I/O操作的完成。不幸的是，线程在系统资源方面并不便宜——它消耗内存并导致上下文切换——因此，对于每个连接都保持长时间运行而大部分时间不使用，意味着浪费了宝贵的内存和CPU周期。'
- en: Non-blocking I/O
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非阻塞I/O
- en: In addition to blocking I/O, most modern operating systems support another mechanism
    to access resources, called non-blocking I/O. In this operating mode, the system
    call always returns immediately without waiting for the data to be read or written.
    If no results are available at the moment of the call, the function will simply
    return a predefined constant, indicating that there is no data available to return
    at that moment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阻塞I/O之外，大多数现代操作系统还支持另一种访问资源的机制，称为非阻塞I/O。在这种操作模式下，系统调用总是立即返回，而不等待读取或写入数据。如果在调用时没有结果可用，函数将简单地返回一个预定义的常量，表示在那个时刻没有数据可以返回。
- en: For example, in Unix operating systems, the `fcntl()` function is used to manipulate
    an existing file descriptor (which in Unix represents the reference used to access
    a local file or a network socket) to change its operating mode to non-blocking
    (with the `O_NONBLOCK` flag). Once the resource is in non-blocking mode, any read
    operation will fail with the return code `EAGAIN` if the resource doesn't have
    any data ready to be read.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Unix操作系统中，`fcntl()`函数用于操作现有的文件描述符（在Unix中表示用于访问本地文件或网络套接字的引用），将其操作模式更改为非阻塞（使用`O_NONBLOCK`标志）。一旦资源处于非阻塞模式，如果资源没有准备好的数据可供读取，任何读取操作都会因返回代码`EAGAIN`而失败。
- en: 'The most basic pattern for dealing with this type of non-blocking I/O is to
    actively poll the resource within a loop until some actual data is returned. This
    is called **busy-waiting**. The following pseudocode shows you how it''s possible
    to read from multiple resources using non-blocking I/O and an active polling loop:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此类非阻塞I/O的最基本模式是在循环中主动轮询资源，直到返回一些实际数据。这被称为**忙等待**。下面的伪代码展示了如何使用非阻塞I/O和一个主动轮询循环从多个资源中读取数据：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, with this simple technique, it is possible to handle different
    resources in the same thread, but it's still not efficient. In fact, in the preceding
    example, the loop will only consume precious CPU for iterating over resources
    that are unavailable most of the time. Polling algorithms usually result in a
    huge amount of wasted CPU time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用这种简单技术，可以在同一个线程中处理不同的资源，但这仍然不够高效。实际上，在前面的例子中，循环只会消耗宝贵的CPU资源来迭代大部分时间不可用的资源。轮询算法通常会导致大量的CPU时间浪费。
- en: Event demultiplexing
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件解复用
- en: Busy-waiting is definitely not an ideal technique for processing non-blocking
    resources, but luckily, most modern operating systems provide a native mechanism
    to handle concurrent non-blocking resources in an efficient way. We are talking
    about the **synchronous event demultiplexer** (also known as the **event notification
    interface**).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 忙等待绝对不是处理非阻塞资源的理想技术，但幸运的是，大多数现代操作系统都提供了一种原生机制来高效地处理并发非阻塞资源。我们谈论的是**同步事件解复用器**（也称为**事件通知接口**）。
- en: If you are unfamiliar with the term, in telecommunications, **multiplexing**
    refers to the method by which multiple signals are combined into one so that they
    can be easily transmitted over a medium with limited capacity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这个术语，在电信中，**复用**指的是将多个信号组合成一个，以便它们可以容易地通过有限容量的介质传输。
- en: '**Demultiplexing** refers to the opposite operation, whereby the signal is
    split again into its original components. Both terms are used in other areas (for
    example, video processing) to describe the general operation of combining different
    things into one and vice versa.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**解复用**指的是相反的操作，即信号再次被分解成其原始成分。这两个术语在其他领域（例如，视频处理）中也用于描述将不同事物组合在一起以及相反的一般操作。'
- en: 'The synchronous event demultiplexer that we were talking about watches multiple
    resources and returns a new event (or set of events) when a read or write operation
    executed over one of those resources completes. The advantage here is that the
    synchronous event demultiplexer is, of course, synchronous, so it blocks until
    there are new events to process. The following is the pseudocode of an algorithm
    that uses a generic synchronous event demultiplexer to read from two different
    resources:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的同步事件解复用器监视多个资源，并在对其中任何一个资源执行读取或写入操作完成后返回一个新事件（或事件集）。这里的优势当然是同步事件解复用器是同步的，因此它会阻塞，直到有新事件可以处理。以下是一个使用通用同步事件解复用器从两个不同资源读取的算法的伪代码：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s see what happens in the preceding pseudocode:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的伪代码中发生了什么：
- en: The resources are added to a data structure, associating each one of them with
    a specific operation (in our example, a `read)`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源被添加到数据结构中，将每个资源与一个特定的操作（在我们的例子中是`read`）关联起来。
- en: The demultiplexer is set up with the group of resources to be watched. The call
    to `demultiplexer.watch()` is synchronous and blocks until any of the watched
    resources are ready for `read`. When this occurs, the event demultiplexer returns
    from the call and a new set of events is available to be processed.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解复用器被设置为监视资源组。对`demultiplexer.watch()`的调用是同步的，并且会阻塞，直到任何被监视的资源准备好进行`read`。当发生这种情况时，事件解复用器从调用中返回，并有一组新事件可供处理。
- en: Each event returned by the event demultiplexer is processed. At this point,
    the resource associated with each event is guaranteed to be ready to read and
    to not block during the operation. When all the events are processed, the flow
    will block again on the event demultiplexer until new events are again available
    to be processed. This is called the **event loop**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件解复用器返回的每个事件都会被处理。在这个时候，与每个事件关联的资源保证可以读取，并且在操作期间不会阻塞。当所有事件都处理完毕后，流将再次在事件解复用器上阻塞，直到有新事件可以再次处理。这被称为**事件循环**。
- en: 'It''s interesting to see that, with this pattern, we can now handle several
    I/O operations inside a single thread, without using the busy-waiting technique.
    It should now be clearer why we are talking about demultiplexing; using just a
    single thread, we can deal with multiple resources. *Figure 1.2* will help you
    visualize what''s happening in a web server that uses a synchronous event demultiplexer
    and a single thread to handle multiple concurrent connections:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这个模式，我们现在可以在单个线程内处理多个I/O操作，而不使用忙等待技术。现在应该更清楚为什么我们在谈论解复用；仅使用单个线程，我们就可以处理多个资源。*图1.2*将帮助您可视化使用同步事件解复用器和单个线程处理多个并发连接的Web服务器中正在发生的事情：
- en: '![](img/B15729_01_02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15729_01_02.png)'
- en: 'Figure 1.2: Using a single thread to process multiple connections'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：使用单个线程处理多个连接
- en: As this shows, using only one thread does not impair our ability to run multiple
    I/O-bound tasks concurrently. The tasks are spread over time, instead of being
    spread across multiple threads. This has the clear advantage of minimizing the
    total idle time of the thread, as is clearly shown in *Figure 1.2*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，仅使用一个线程并不会妨碍我们并发运行多个I/O密集型任务的能力。任务在时间上分散，而不是在多个线程上分散。这显然具有减少线程总空闲时间的优势，这在*图1.2*中表现得非常明显。
- en: But this is not the only reason for choosing this I/O model. In fact, having
    a single thread also has a beneficial impact on the way programmers approach concurrency
    in general. Throughout the book, you will see how the absence of in-process race
    conditions and multiple threads to synchronize allows us to use much simpler concurrency
    strategies.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是选择这种I/O模型唯一的原因。实际上，拥有一个线程也对程序员处理并发的一般方式产生了积极影响。在整个书中，您将看到没有进程内竞态条件和多个线程同步的缺失如何使我们能够使用更简单的并发策略。
- en: The reactor pattern
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应器模式
- en: We can now introduce the reactor pattern, which is a specialization of the algorithms
    presented in the previous sections. The main idea behind the reactor pattern is
    to have a handler associated with each I/O operation. A handler in Node.js is
    represented by a `callback` (or `cb` for short) function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以介绍反应器模式，它是前几节中提出的算法的特化。反应器模式背后的主要思想是每个 I/O 操作都有一个处理程序。在 Node.js 中，处理程序由一个
    `callback`（或简称 `cb`）函数表示。
- en: 'The handler will be invoked as soon as an event is produced and processed by
    the event loop. The structure of the reactor pattern is shown in *Figure 1.3*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件循环产生并处理事件时，处理程序将被调用。反应器模式的结构在*图 1.3*中显示：
- en: '![](img/B15729_01_03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_01_03.png)'
- en: 'Figure 1.3: The reactor pattern'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：反应器模式
- en: 'This is what happens in an application using the reactor pattern:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在使用反应器模式的应用程序中发生的情况：
- en: The application generates a new I/O operation by submitting a request to the **Event
    Demultiplexer**. The application also specifies a handler, which will be invoked
    when the operation completes. Submitting a new request to the **Event Demultiplexer** is
    a non-blocking call and it immediately returns control to the application.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序通过向**事件分配器**提交请求来生成新的 I/O 操作。应用程序还指定了一个处理程序，当操作完成时将调用该处理程序。向**事件分配器**提交新请求是一个非阻塞调用，并且它立即将控制权返回给应用程序。
- en: When a set of I/O operations completes, the **Event Demultiplexer** pushes a set
    of corresponding events into the **Event Queue**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一组 I/O 操作完成时，**事件分配器**会将一组相应的事件推入**事件队列**。
- en: At this point, the **Event Loop** iterates over the items of the **Event Queue**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，**事件循环**遍历**事件队列**中的项目。
- en: For each event, the associated handler is invoked.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个事件，都会调用相关的处理程序。
- en: The handler, which is part of the application code, gives back control to the **Event
    Loop** when its execution completes (**5a**). While the handler executes, it can
    request new asynchronous operations (**5b**), causing new items to be added to
    the **Event Demultiplexer** (**1**).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当处理程序（它是应用程序代码的一部分）执行完成后，会将其控制权交还给**事件循环**（**5a**）。在处理程序执行期间，它可以请求新的异步操作（**5b**），这会导致新的项目被添加到**事件分配器**（**1**）。
- en: When all the items in the **Event Queue** are processed, the **Event Loop** blocks
    again on the **Event Demultiplexer**, which then triggers another cycle when a new
    event is available.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**事件队列**中的所有项目都处理完毕后，**事件循环**再次在**事件分配器**上阻塞，当有新事件可用时，它将触发另一个循环。
- en: The asynchronous behavior has now become clear. The application expresses interest
    in accessing a resource at one point in time (without blocking) and provides a
    handler, which will then be invoked at another point in time when the operation
    completes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 异步行为现在变得清晰。应用程序在某个时间点表达了对访问资源的兴趣（不阻塞）并提供了处理程序，当操作完成时，处理程序将在另一个时间点被调用。
- en: A Node.js application will exit when there are no more pending operations in
    the event demultiplexer, and no more events to be processed inside the event queue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件分配器中没有挂起的操作，且事件队列中没有更多事件要处理时，Node.js 应用程序将退出。
- en: 'We can now define the pattern at the heart of Node.js:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义 Node.js 核心的模式：
- en: '**The reactor pattern**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**反应器模式**'
- en: Handles I/O by blocking until new events are available from a set of observed
    resources, and then reacts by dispatching each event to an associated handler.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阻塞直到从一组观察到的资源中可用新事件来处理 I/O，然后通过将每个事件调度到相关处理程序来做出反应。
- en: Libuv, the I/O engine of Node.js
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Libuv，Node.js 的 I/O 引擎
- en: Each operating system has its own interface for the event demultiplexer: `epoll` on
    Linux, `kqueue` on macOS, and the I/O completion port (IOCP) API on Windows. On
    top of that, each I/O operation can behave quite differently depending on the
    type of resource, even within the same operating system. In Unix operating systems,
    for example, regular filesystem files do not support non-blocking operations,
    so in order to simulate non-blocking behavior, it is necessary to use a separate
    thread outside the event loop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有自己的事件分配器接口：Linux 上的 `epoll`，macOS 上的 `kqueue`，以及 Windows 上的 I/O 完成端口
    (IOCP) API。在此基础上，每个 I/O 操作在相同操作系统中根据资源类型的不同可能会有相当不同的行为。例如，在 Unix 操作系统中，常规文件系统文件不支持非阻塞操作，因此为了模拟非阻塞行为，有必要在事件循环之外使用单独的线程。
- en: All these inconsistencies across and within the different operating systems
    required a higher-level abstraction to be built for the event demultiplexer. This
    is exactly why the Node.js core team created a native library called **libuv**,
    with the objective to make Node.js compatible with all the major operating systems
    and normalize the non-blocking behavior of the different types of resource. Libuv
    represents the low-level I/O engine of Node.js and is probably the most important
    component that Node.js is built on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些跨不同操作系统以及操作系统内部的不一致性都需要为事件解多路复用器构建一个更高级别的抽象。这正是 Node.js 核心团队创建了一个名为 **libuv**
    的本地库的原因，目的是使 Node.js 与所有主要操作系统兼容并规范化不同类型资源的非阻塞行为。Libuv 代表了 Node.js 的底层 I/O 引擎，可能是
    Node.js 构建上最重要的组件。
- en: Other than abstracting the underlying system calls, libuv also implements the
    reactor pattern, thus providing an API for creating event loops, managing the
    event queue, running asynchronous I/O operations, and queuing other types of task.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了抽象化底层系统调用外，libuv 还实现了反应器模式，从而提供创建事件循环、管理事件队列、运行异步 I/O 操作和排队其他类型任务的 API。
- en: A great resource to learn more about libuv is the free online book created by
    Nikhil Marathe, which is available at [nodejsdp.link/uvbook](http://nodejsdp.link/uvbook).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 libuv 的信息，一个很好的资源是由 Nikhil Marathe 创建的免费在线书籍，可在 [nodejsdp.link/uvbook](http://nodejsdp.link/uvbook)
    获取。
- en: The recipe for Node.js
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 的配方
- en: 'The reactor pattern and libuv are the basic building blocks of Node.js, but
    we need three more components to build the full platform:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 反应器模式和 libuv 是 Node.js 的基本构建块，但我们需要三个更多组件来构建完整的平台：
- en: A set of bindings responsible for wrapping and exposing libuv and other low-level
    functionalities to JavaScript.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组绑定，负责封装和暴露 libuv 和其他底层功能到 JavaScript。
- en: '**V8**, the JavaScript engine originally developed by Google for the Chrome
    browser. This is one of the reasons why Node.js is so fast and efficient. V8 is
    acclaimed for its revolutionary design, its speed, and for its efficient memory
    management.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**V8**，最初由 Google 为 Chrome 浏览器开发的 JavaScript 引擎。这也是 Node.js 为什么如此快速和高效的原因之一。V8
    因其革命性的设计、速度和高效的内存管理而受到赞誉。'
- en: A core JavaScript library that implements the high-level Node.js API.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个核心 JavaScript 库，实现了高层的 Node.js API。
- en: 'This is the recipe for creating Node.js, and the following image represents
    its final architecture:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建 Node.js 的配方，以下图像展示了其最终架构：
- en: '![](img/B15729_01_04.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15729_01_04.png)'
- en: 'Figure 1.4: The Node.js internal components'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：Node.js 内部组件
- en: This concludes our journey through the internal mechanisms of Node.js. Next,
    we'll take a look at some important aspects to take into consideration when working
    with JavaScript in Node.js.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Node.js 内部机制的探索之旅。接下来，我们将查看在 Node.js 中使用 JavaScript 时需要考虑的一些重要方面。
- en: JavaScript in Node.js
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 中的 JavaScript
- en: One important consequence of the architecture we have just analyzed is that
    the JavaScript we use in Node.js is somewhat different from the JavaScript we
    use in the browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚分析的架构的一个重要后果是，我们在 Node.js 中使用的 JavaScript 与我们在浏览器中使用的 JavaScript 有所不同。
- en: The most obvious difference is that in Node.js we don't have a DOM and we don't
    have a `window` or a `document`. On the other hand, Node.js has access to a set
    of services offered by the underlying operating system that are not available
    in the browser. In fact, the browser has to implement a set of safety measures
    to make sure that the underlying system is not compromised by a rogue web application.
    The browser provides a higher-level abstraction over the operating system resources,
    which makes it easier to control and contain the code that runs in it, which will
    also inevitably limit its capabilities. In turn, in Node.js we can virtually have
    access to all the services exposed by the operating system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的区别是，在 Node.js 中我们没有 DOM，也没有 `window` 或 `document`。另一方面，Node.js 可以访问底层操作系统提供的一组服务，这些服务在浏览器中不可用。实际上，浏览器必须实施一系列安全措施，以确保底层系统不会被恶意网络应用程序破坏。浏览器在操作系统资源上提供了一个更高级别的抽象，这使得控制并包含在其中运行的代码变得更容易，这也不可避免地限制了其功能。相反，在
    Node.js 中，我们可以几乎访问操作系统暴露的所有服务。
- en: In this overview, we'll take a look at some key facts to keep in mind when using
    JavaScript in Node.js.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个概述中，我们将查看在使用 Node.js 中的 JavaScript 时需要记住的一些关键事实。
- en: Run the latest JavaScript with confidence
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有信心运行最新的 JavaScript
- en: One of the main pain points of using JavaScript in the browser is that our code
    will likely run on a variety of devices and browsers. Dealing with different browsers
    means dealing with JavaScript runtimes that may miss some of the newest features
    of both the language or the web platform. Luckily, today this problem can be somewhat
    mitigated by the use of transpilers and polyfills. Nonetheless, this brings its
    own set of disadvantages and not everything can be polyfilled.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript 在浏览器中的一大痛点是我们的代码可能会在各种各样的设备和浏览器上运行。处理不同的浏览器意味着要处理可能缺少语言或网络平台一些最新功能的
    JavaScript 运行时。幸运的是，今天这个问题可以通过使用转译器和 polyfills 一定程度上得到缓解。尽管如此，这也带来了一组自己的缺点，并不是所有内容都可以用
    polyfills 来填充。
- en: All these inconveniences don't apply when developing applications on Node.js.
    In fact, our Node.js applications will most likely run on a system and a Node.js
    runtime that are well known in advance. This makes a huge difference as it allows
    us to target our code for a specific JavaScript and Node.js version, with the
    absolute guarantee that we won't have any surprises when we run it on production.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不便之处在开发 Node.js 应用程序时都不适用。事实上，我们的 Node.js 应用程序很可能会在一个事先已知系统和 Node.js 运行时上运行。这带来了巨大的差异，因为它允许我们针对特定的
    JavaScript 和 Node.js 版本进行代码编写，绝对保证在生产环境中运行时不会有任何意外。
- en: This factor, in combination with the fact that Node.js ships with very recent
    versions of V8, means that we can use with confidence most of the features of
    the latest ECMAScript specification (ES for short; this is the standard on which
    the JavaScript language is based) without the need for any extra transpilation
    step.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个因素，加上 Node.js 附带的是非常新的 V8 版本，意味着我们可以有信心地使用最新 ECMAScript 规范（简称 ES；这是 JavaScript
    语言基于的标准）的大多数功能，而无需任何额外的转译步骤。
- en: Please bear in mind, though, that if we are developing a library meant to be
    used by third parties, we still have to take into account that our code may run
    on different versions of Node.js. The general pattern in this case is to target
    the oldest active **long-term support** (**LTS**) release and specify the `engines`
    section in our `package.json`, so that the package manager will warn the user
    if they are trying to install a package that is not compatible with their version
    of Node.js.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，如果我们正在开发一个打算供第三方使用的库，我们仍然需要考虑到我们的代码可能运行在不同的 Node.js 版本上。在这种情况下的一般模式是针对最旧的活跃
    **长期支持**（**LTS**）版本，并在我们的 `package.json` 中的 `engines` 部分指定，这样包管理器就会警告用户，如果他们尝试安装一个与其
    Node.js 版本不兼容的包。
- en: You can find out more about the Node.js release cycles at [nodejsdp.link/node-releases](http://nodejsdp.link/node-releases).
    Also, you can find the reference for the `engines` section of `package.json` at
    [nodejsdp.link/package-engines](http://nodejsdp.link/package-engines). Finally,
    you can get an idea of what ES feature is supported by each Node.js version at
    [nodejsdp.link/node-green](http://nodejsdp.link/node-green).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [nodejsdp.link/node-releases](http://nodejsdp.link/node-releases) 上了解更多关于
    Node.js 发布周期的信息。此外，您可以在 [nodejsdp.link/package-engines](http://nodejsdp.link/package-engines)
    上找到 `package.json` 的 `engines` 部分的参考。最后，您可以在 [nodejsdp.link/node-green](http://nodejsdp.link/node-green)
    上了解每个 Node.js 版本支持哪些 ES 功能。
- en: The module system
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块系统
- en: From its inception, Node.js shipped with a module system, even when JavaScript
    still had no official support for any form of it. The original Node.js module
    system is called CommonJS and it uses the `require` keyword to import functions,
    variables, and classes exported by built-in modules or other modules located on
    the device's filesystem.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从其诞生之初，Node.js 就附带了一个模块系统，即使当时 JavaScript 还没有官方支持任何形式的模块系统。原始的 Node.js 模块系统被称为
    CommonJS，它使用 `require` 关键字来导入由内置模块或其他位于设备文件系统上的模块导出的函数、变量和类。
- en: CommonJS was a revolution for the JavaScript world in general, as it started
    to get popular even in the client-side world, where it is used in combination
    with a module bundler (such as Webpack or Rollup) to produce code bundles that
    are easily executable by the browser. CommonJS was a necessary component for Node.js
    to allow developers to create large and better organized applications on a par
    with other server-side platforms.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 对于 JavaScript 世界来说是一场革命，因为它开始在客户端世界流行起来，在那里它与模块打包器（如 Webpack 或 Rollup）结合使用，以生成浏览器可以轻松执行的代码包。CommonJS
    是 Node.js 的一个必要组件，它允许开发者创建与服务器端平台相当的大型且组织良好的应用程序。
- en: Today, JavaScript has the so-called ES modules syntax (the `import` keyword
    may be more familiar) from which Node.js inherits just the syntax, as the underlying
    implementation is somewhat different from that of the browser. In fact, while
    the browser mainly deals with remote modules, Node.js, at least for now, can only
    deal with modules located on the local filesystem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScript 有所谓的 ES 模块语法（`import` 关键字可能更为熟悉），Node.js 只是继承了这种语法，因为其底层实现与浏览器有所不同。实际上，虽然浏览器主要处理远程模块，但至少目前
    Node.js 只能处理位于本地文件系统上的模块。
- en: We'll talk about modules in more detail in the next chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地讨论模块。
- en: Full access to operating system services
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全访问操作系统服务
- en: As we already mentioned, even if Node.js uses JavaScript, it doesn't run inside
    the boundaries of a browser. This allows Node.js to have bindings for all the
    major services offered by the underlying operating system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，尽管 Node.js 使用 JavaScript，但它并不运行在浏览器的边界内。这使得 Node.js 能够绑定到底层操作系统提供的所有主要服务。
- en: For example, we can access any file on the filesystem (subject to any operating
    system-level permission) thanks to the `fs` module, or we can write applications
    that use low-level TCP or UDP sockets thanks to the `net` and `dgram` modules.
    We can create HTTP(S) servers (with the `http` and `https` modules) or use the
    standard encryption and hashing algorithms of OpenSSL (with the `crypto` module).
    We can also access some of the V8 internals (the `v8` module) or run code in a
    different V8 context (with the `vm` module).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过 `fs` 模块访问文件系统上的任何文件（受操作系统级别的任何权限限制），或者我们可以通过 `net` 和 `dgram` 模块编写使用低级
    TCP 或 UDP 套接字的程序。我们可以创建 HTTP(S) 服务器（使用 `http` 和 `https` 模块）或使用 OpenSSL 的标准加密和哈希算法（使用
    `crypto` 模块）。我们还可以访问一些 V8 内部功能（使用 `v8` 模块）或在不同的 V8 上下文中运行代码（使用 `vm` 模块）。
- en: We can also run other processes (with the `child_process` module) or retrieve
    our own application's process information using the `process` global variable.
    In particular, from the `process` global variable, we can get a list of the environment
    variables assigned to the process (with `process.env`) or the command-line arguments
    passed to the application at the moment of its launch (with `process.argv`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `child_process` 模块运行其他进程或通过 `process` 全局变量检索我们自己的应用程序进程信息。特别是，从 `process`
    全局变量中，我们可以获取分配给进程的环境变量列表（使用 `process.env`）或应用程序启动时传递给应用程序的命令行参数（使用 `process.argv`）。
- en: Throughout the book, you'll have the opportunity to use many of the modules
    described here, but for a complete reference, you can check the official Node.js
    documentation at [nodejsdp.link/node-docs](http://nodejsdp.link/node-docs).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将有机会使用这里描述的许多模块，但为了获得完整的参考，你可以查看官方 Node.js 文档，网址为 [nodejsdp.link/node-docs](http://nodejsdp.link/node-docs)。
- en: Running native code
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行原生代码
- en: One of the most powerful capabilities offered by Node.js is certainly the possibility
    to create userland modules that can bind to native code. This gives to the platform
    a tremendous advantage as it allows us to reuse existing or new components written
    in C/C++. Node.js officially provides great support for implementing native modules
    thanks to the N-API interface.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 提供的最强大功能之一无疑是创建用户模块的可能性，这些模块可以绑定到原生代码。这使得平台获得了巨大的优势，因为它允许我们重用用 C/C++
    编写的现有或新组件。Node.js 通过 N-API 接口正式提供了对实现原生模块的强大支持。
- en: But what's the advantage? First of all, it allows us to reuse with little effort
    a vast amount of existing open source libraries, and most importantly, it allows
    a company to reuse its own C/C++ legacy code without the need to migrate it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但优势是什么？首先，它允许我们几乎不费吹灰之力地重用大量现有的开源库，最重要的是，它允许公司重用其自己的 C/C++ 旧代码，而无需迁移它。
- en: Another important consideration is that native code is still necessary to access
    low-level features such as communicating with hardware drivers or with hardware
    ports (for example, USB or serial). In fact, thanks to its ability to link to
    native code, Node.js has become popular in the world of the **Internet of things**
    (**IoT**) and homemade robotics.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是，访问诸如与硬件驱动程序或硬件端口（例如 USB 或串行端口）通信之类的低级功能仍然需要原生代码。事实上，得益于其链接到原生代码的能力，Node.js
    在物联网（**IoT**）和家用机器人领域变得流行。
- en: Finally, even though V8 is very (very) fast at executing JavaScript, it still
    has a performance penalty to pay compared to executing native code. In everyday
    computing, this is rarely an issue, but for CPU-intensive applications, such as
    those with a lot of data processing and manipulation, delegating the work to native
    code can make tons of sense.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管 V8 在执行 JavaScript 时非常（非常）快，但它与执行原生代码相比仍然需要付出性能代价。在日常计算中，这很少成为问题，但对于需要大量数据处理和操作的计算密集型应用程序来说，将工作委托给原生代码可能非常有意义。
- en: We should also mention that, nowadays, most JavaScript **virtual machines**
    (**VMs**) (and also Node.js) support **WebAssembly** (**Wasm**), a low-level instruction
    format that allows us to compile languages other than JavaScript (such as C++
    or Rust) into a format that is "understandable" by JavaScript VMs. This brings
    many of the advantages we have mentioned, without the need to directly interface
    with native code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该提到，如今，大多数 JavaScript **虚拟机**（**VMs**）（以及 Node.js）都支持 **WebAssembly**（**Wasm**），这是一种低级指令格式，允许我们将除
    JavaScript 之外的语言（如 C++ 或 Rust）编译成 JavaScript VMs 可以“理解”的格式。这带来了我们提到的许多优势，而无需直接与原生代码接口。
- en: You can learn more about Wasm on the official website of the project at [nodejsdp.link/webassembly](http://nodejsdp.link/webassembly).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目的官方网站上了解更多关于 Wasm 的信息：[nodejsdp.link/webassembly](http://nodejsdp.link/webassembly)。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have seen how the Node.js platform is built upon a few
    important principles that shape both its internal architecture and the code we
    write. You have learned that Node.js has a minimal core, and that embracing the
    "Node way" means writing modules that are smaller, simpler, and that expose only
    the minimum functionality necessary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了 Node.js 平台是如何建立在几个重要的原则之上的，这些原则既塑造了其内部架构，也塑造了我们编写的代码。你了解到 Node.js
    具有最小的核心，而拥抱“Node 方式”意味着编写更小、更简单且仅暴露必要最小功能的模块。
- en: 'Next, you discovered the reactor pattern, which is the pulsating heart of Node.js,
    and dissected the internal architecture of the platform runtime to reveal its
    three pillars: V8, libuv, and the core JavaScript library.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你发现了反应器模式，这是 Node.js 的跳动心脏，并剖析了平台运行时的内部架构，揭示了其三个支柱：V8、libuv 和核心 JavaScript
    库。
- en: Finally, we analyzed some of the main characteristics of using JavaScript in
    Node.js compared to the browser.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们分析了在 Node.js 中使用 JavaScript 与浏览器相比的一些主要特点。
- en: Besides the obvious technical advantages enabled by its internal architecture,
    Node.js is attracting so much interest because of the principles you have just
    discovered and the community orbiting around it. For many, grasping the essence
    of this world feels like returning to the origins, to a more humane way of programming
    in both size and complexity, and that's why developers end up falling in love
    with Node.js.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其内部架构带来的明显技术优势外，Node.js 因为你刚刚发现的原理以及围绕它的社区而受到广泛关注。对于许多人来说，把握这个世界的本质就像回到了起源，回到一种在规模和复杂性上都更加人性化的编程方式，这也是开发者最终爱上
    Node.js 的原因。
- en: In the next chapter, we will go deep into one of the most fundamental and important
    topics of Node.js, its module system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 Node.js 最基本和最重要的主题之一，即它的模块系统。
