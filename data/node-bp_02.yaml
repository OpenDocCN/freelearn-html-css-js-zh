- en: Chapter 2. Developing a Basic Site with Node.js and Express
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 使用 Node.js 和 Express 开发基本网站
- en: In the previous chapter, we learned about common programming paradigms and how
    they apply to Node.js. In this chapter, we will continue with the **Express**
    framework. It's one of the most popular frameworks available and is certainly
    a pioneering one. Express is still widely used and several developers use it as
    a starting point.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们学习了常见的编程范式以及它们如何应用于 Node.js。在这一章中，我们将继续介绍 **Express** 框架。它是可用的最受欢迎的框架之一，无疑是一个开创性的框架。Express
    仍然被广泛使用，许多开发者将其作为起点。
- en: Getting acquainted with Express
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 Express
- en: 'Express ([http://expressjs.com/](http://expressjs.com/)) is a web application
    framework for Node.js. It is built on top of Connect ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)),
    which means that it implements middleware architecture. In the previous chapter,
    when exploring Node.js, we discovered the benefit of such a design decision: the
    framework acts as a plugin system. Thus, we can say that Express is suitable for
    not only simple but also complex applications because of its architecture. We
    may use only some of the popular types of middleware or add a lot of features
    and still keep the application modular.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Express ([http://expressjs.com/](http://expressjs.com/)) 是一个 Node.js 的网络应用程序框架。它建立在
    Connect ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/))
    之上，这意味着它实现了中间件架构。在前一章中，当我们探索 Node.js 时，我们发现了这种设计决策的好处：框架充当插件系统。因此，我们可以说，由于其架构，Express
    不仅适合简单应用，也适合复杂应用，因为我们可能只使用一些流行的中间件类型，或者添加很多功能，同时仍然保持应用程序模块化。
- en: 'In general, most projects in Node.js perform two functions: run a server that
    listens on a specific port, and process incoming requests. Express is a wrapper
    for these two functionalities. The following is basic code that runs the server:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数 Node.js 项目执行两个功能：运行一个监听特定端口的服务器，并处理传入的请求。Express 是这两个功能的包装器。以下是在服务器上运行的简单代码：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is an example extracted from the official documentation of Node.js. As
    shown, we use the native module `http` and run a server on the port `1337`. There
    is also a request handler function, which simply sends the `Hello world` string
    to the browser. Now, let''s implement the same thing but with the Express framework,
    using the following code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从 Node.js 官方文档中提取的示例。如图所示，我们使用原生模块 `http` 在端口 `1337` 上运行服务器。还有一个请求处理函数，它简单地将
    `Hello world` 字符串发送到浏览器。现在，让我们使用以下代码实现相同的事情，但使用 Express 框架：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It''s pretty much the same thing. However, we don''t need to specify the response
    headers or add a new line at the end of the string because the framework does
    it for us. In addition, we have a bunch of middleware available, which will help
    us process the requests easily. Express is like a toolbox. We have a lot of tools
    to do the boring stuff, allowing us to focus on the application''s logic and content.
    That''s what Express is built for: saving time for the developer by providing
    ready-to-use functionalities.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是同一件事。然而，我们不需要指定响应头或在字符串末尾添加新行，因为框架会为我们处理这些。此外，我们有一系列可用的中间件，这将帮助我们轻松处理请求。Express
    就像是一个工具箱。我们有很多工具来做那些无聊的事情，让我们能够专注于应用程序的逻辑和内容。这正是 Express 的构建目的：通过提供现成的功能来为开发者节省时间。
- en: Installing Express
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Express
- en: There are two ways to install Express. We'll will start with the simple one
    and then proceed to the more advanced technique. The simpler approach generates
    a template, which we may use to start writing the business logic directly. In
    some cases, this can save us time. From another viewpoint, if we are developing
    a custom application, we need to use custom settings. We can also use the boilerplate,
    which we get with the advanced technique; however, it may not work for us.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Express 有两种方法。我们将从简单的方法开始，然后继续到更高级的技术。简单的方法会生成一个模板，我们可以用它直接开始编写业务逻辑。在某些情况下，这可以为我们节省时间。从另一个角度来看，如果我们正在开发一个自定义应用程序，我们需要使用自定义设置。我们还可以使用高级技术获得的样板代码；然而，它可能不适合我们。
- en: Using package.json
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 package.json
- en: 'Express is like every other module. It has its own place in the packages register.
    If we want to use it, we need to add the framework in the `package.json` file.
    The ecosystem of Node.js is built on top of the Node Package Manager. It uses
    the JSON file to find out what we need and installs it in the current directory.
    So, the content of our `package.json` file looks like the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Express就像其他模块一样。它在包注册表中有自己的位置。如果我们想使用它，我们需要在`package.json`文件中添加这个框架。Node.js生态系统建立在Node包管理器之上。它使用JSON文件来查找我们需要的内容，并将其安装到当前目录中。因此，我们的`package.json`文件的内容如下所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These are the required fields that we have to add. To be more accurate, we have
    to say that the mandatory fields are `name` and `version`. However, it is always
    good to add descriptions to our modules, particularly if we want to publish our
    work in the registry, where such information is extremely important. Otherwise,
    the other developers will not know what our library is doing. Of course, there
    are a bunch of other fields, such as contributors, keywords, or development dependencies,
    but we will stick to limited options so that we can focus on Express.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们必须添加的必填字段。更准确地说，我们必须说必填字段是`name`和`version`。然而，总是给我们的模块添加描述是个好主意，尤其是如果我们想在注册表中发布我们的工作，那里的信息非常重要。否则，其他开发者将不知道我们的库在做什么。当然，还有许多其他字段，如贡献者、关键词或开发依赖项，但我们将坚持有限选项，以便我们可以专注于Express。
- en: 'Once we have our `package.json` file placed in the project''s folder, we have
    to call `npm install` in the console. By doing so, the package manager will create
    a `node_modules` folder and will store Express and its dependencies there. At
    the end of the command''s execution, we will see something like the following
    screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`package.json`文件放置在项目的文件夹中，我们必须在控制台中调用`npm install`。这样做，包管理器将创建一个`node_modules`文件夹，并将Express及其依赖项存储在那里。命令执行结束后，我们将看到如下截图：
- en: '![Using package.json](img/00005.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用package.json](img/00005.jpeg)'
- en: 'The first line shows us the installed version, and the proceeding lines are
    actually modules that Express depends on. Now, we are ready to use Express. If
    we type `require(''express'')`, Node.js will start looking for that library inside
    the local `node_modules` directory. Since we are not using absolute paths, this
    is normal behavior. If we miss running the `npm install` command, we will be prompted
    with `Error: Cannot find module ''express''`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行显示了安装的版本，接下来的行实际上是Express所依赖的模块。现在，我们已经准备好使用Express了。如果我们输入`require(''express'')`，Node.js将开始在本地`node_modules`目录中寻找这个库。由于我们没有使用绝对路径，这是正常的行为。如果我们没有运行`npm
    install`命令，我们将收到`Error: Cannot find module ''express''`的提示。'
- en: Using a command-line tool
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行工具
- en: There is a command-line instrument called `express-generator`. Once we run `npm
    install -g express-generator`, we will install and use it as every other command
    in our terminal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`express-generator`的命令行工具。一旦我们运行`npm install -g express-generator`，我们就会安装并像在终端中的其他命令一样使用它。
- en: 'If you use the framework in several projects, you will notice that some things
    are repeated. We can even copy and paste them from one application to another,
    and this is perfectly fine. We may even end up with our own boilerplate and can
    always start from there. The command-line version of Express does the same thing.
    It accepts few arguments and based on them, creates a skeleton for use. This can
    be very handy in some cases and will definitely save some time. Let''s have a
    look at the available arguments:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个项目中使用这个框架，你会注意到有些事情是重复的。我们甚至可以从一个应用程序复制粘贴到另一个应用程序，这是完全正常的。我们甚至可能最终拥有自己的样板代码，并且总是可以从那里开始。Express的命令行版本做的是同样的事情。它接受少量参数，并根据这些参数创建一个用于的骨架。在某些情况下，这可能会非常方便，并且肯定会节省一些时间。让我们看看可用的参数：
- en: '`-h, --help`: This signifies output usage information.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h, --help`: 这表示输出使用信息。'
- en: '`-V, --version`: This shows the version of Express.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-V, --version`: 这将显示Express的版本。'
- en: '`-e, --ejs`: This argument adds the EJS template engine support. Normally,
    we need a library to deal with our templates. Writing pure HTML is not very practical.
    The default engine is set to JADE.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e, --ejs`: 这个参数添加了EJS模板引擎支持。通常，我们需要一个库来处理我们的模板。编写纯HTML并不实用。默认引擎设置为JADE。'
- en: '`-H, --hogan`: This argument is Hogan-enabled (another template engine).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H, --hogan`: 这个参数启用了Hogan模板引擎（另一个模板引擎）。'
- en: '`-c, --css`: If we want to use the CSS preprocessors, this option lets us use
    **LESS** (short for **Leaner CSS**) or Stylus. The default is plain CSS.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c, --css`：如果我们想使用 CSS 预处理器，这个选项允许我们使用 **LESS**（简称 **Leaner CSS**）或 Stylus。默认是纯
    CSS。'
- en: '`-f, --force`: This forces Express to operate on a nonempty directory.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f, --force`：这个选项强制 Express 在非空目录上运行。'
- en: 'Let''s try to generate an Express application skeleton with LESS as a CSS preprocessor.
    We use the following line of command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用 LESS 作为 CSS 预处理器来生成一个 Express 应用程序骨架。我们使用以下命令行：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A new `myapp` folder is created with the file structure, as seen in the following
    screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个新的 `myapp` 文件夹，其结构如图所示：
- en: '![Using a command-line tool](img/00006.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用命令行工具](img/00006.jpeg)'
- en: 'We still need to install the dependencies, so `cd myapp && npm install` is
    required. We will skip the explanation of the generated directories for now and
    will move to the created `app.js` file. It starts with initializing the module
    dependencies, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要安装依赖项，因此需要执行 `cd myapp && npm install`。现在我们将跳过对生成的目录的解释，并转到创建的 `app.js`
    文件。它从初始化模块依赖项开始，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our framework is `express`, and `path` is a native Node.js module. The middleware
    are `favicon`, `logger`, `cookieParser`, and `bodyParser`. The `routes` and `users`
    are custom-made modules, placed in local for the project folders. Similarly, as
    in the **Model-View-Controller** (**MVC**) pattern, these are the controllers
    for our application. Immediately after, an `app` variable is created; this represents
    the Express library. We use this variable to configure our application. The script
    continues by setting some key-value pairs. The next code snippet defines the path
    to our views and the default template engine:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的框架是 `express`，而 `path` 是一个原生 Node.js 模块。中间件包括 `favicon`、`logger`、`cookieParser`
    和 `bodyParser`。`routes` 和 `users` 是自定义模块，放置在项目的本地文件夹中。同样，在 **模型-视图-控制器** (**MVC**)
    模式下，这些是应用程序的控制器。紧接着，创建了一个 `app` 变量；这代表了 Express 库。我们使用这个变量来配置我们的应用程序。脚本继续通过设置一些键值对。接下来的代码片段定义了视图的路径和默认模板引擎：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The framework uses the methods `set` and `get` to define the internal properties.
    In fact, we may use these methods to define our own variables. If the value is
    a Boolean, we can replace `set` and `get` with `enable` and `disable`. For example,
    see the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架使用 `set` 和 `get` 方法来定义内部属性。实际上，我们可以使用这些方法来定义我们自己的变量。如果值是布尔型，我们可以用 `enable`
    和 `disable` 替换 `set` 和 `get`。例如，请看以下代码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next code adds middleware to the framework. We can see the code as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码向框架中添加了中间件。我们可以如下看到代码：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first middleware serves as the favicon of our application. The second is
    responsible for the output in the console. If we remove it, we will not get information
    about the incoming requests to our server. The following is a simple output produced
    by `logger`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个中间件充当我们应用程序的 favicon。第二个负责控制台输出。如果我们移除它，我们将无法获取服务器接收到的请求信息。以下是由 `logger`
    产生的一个简单输出：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `json` and `urlencoded` middleware are related to the data sent along with
    the request. We need them because they convert the information in an easy-to-use
    format. There is also a middleware for the cookies. It populates the request object,
    so we later have access to the required data. The generated app uses LESS as a
    CSS preprocessor, and we need to configure it by setting the directory containing
    the `.less` files. We will talk about LESS in [Chapter 10](part0074_split_000.html#page
    "Chapter 10. Writing Flexible and Modular CSS"), *Writing Flexible and Modular
    CSS*, where will cover this in detail. Eventually, we define our static resources,
    which should be delivered by the server. These are just few lines, but we''ve
    configured the whole application. We may remove or replace some of the modules,
    and the others will continue working. The next code in the file maps two defined
    routes to two different handlers, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`json` 和 `urlencoded` 中间件与随请求发送的数据相关。我们需要它们，因为它们将信息转换为易于使用的格式。还有一个用于 cookie
    的中间件。它填充请求对象，这样我们就可以稍后访问所需的数据。生成的应用程序使用 LESS 作为 CSS 预处理器，我们需要通过设置包含 `.less` 文件的目录来配置它。我们将在第
    [10 章](part0074_split_000.html#page "第 10 章。编写灵活和模块化的 CSS")，*编写灵活和模块化的 CSS* 中讨论
    LESS，我们将详细说明这一点。最终，我们定义了我们的静态资源，这些资源应由服务器提供。这些只是一些简单的行，但我们已经配置了整个应用程序。我们可以移除或替换一些模块，而其他模块将继续工作。文件中的下一代码将两个定义的路由映射到两个不同的处理器，如下所示：'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the user tries to open a missing page, Express still processes the request
    by forwarding it to the error handler, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尝试打开一个缺失的页面，Express仍然会通过将其转发到错误处理器来处理请求，如下所示：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The framework suggests two types of error handling: one for the development
    environment and another for the production server. The difference is that the
    second one hides the stack trace of the error, which should be visible only for
    the developers of the application. As we can see in the following code, we are
    checking the value of the `env` property and handling the error differently:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 框架建议两种错误处理方式：一种用于开发环境，另一种用于生产服务器。区别在于第二种方式隐藏了错误的堆栈跟踪，这应该只对应用程序的开发者可见。正如我们可以在以下代码中看到的那样，我们正在检查`env`属性的值，并不同地处理错误：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the end, the `app.js` file exports the created Express instance, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`app.js`文件导出创建的Express实例，如下所示：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To run the application, we need to execute `node ./bin/www`. The code requires
    `app.js` and starts the server, which by default listens on port `3000`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，我们需要执行`node ./bin/www`。代码需要`app.js`并启动服务器，默认情况下服务器监听端口`3000`。
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `process.env` declaration provides an access to variables defined in the
    current development environment. If there is no `PORT` setting, Express uses 3000
    as the value. The required `debug` module uses a similar approach to find out
    whether it has to show messages to the console.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.env`声明提供了对当前开发环境中定义的变量的访问。如果没有`PORT`设置，Express将使用3000作为值。所需的`debug`模块使用类似的方法来确定是否需要向控制台显示消息。'
- en: Managing routes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理路由
- en: 'The input of our application is the routes. The user visits our page at a specific
    URL and we have to map this URL to a specific logic. In the context of Express,
    this can be done easily, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的输入是路由。用户访问我们的页面时会在特定的URL，我们必须将这个URL映射到特定的逻辑。在Express的上下文中，这可以很容易地完成，如下所示：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We even have control over the HTTP''s method, that is, we are able to catch
    POST, PUT, or DELETE requests. This is very handy if we want to retain the address
    path but apply a different logic. For example, see the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以控制HTTP的方法，也就是说，我们能够捕获POST、PUT或DELETE请求。如果我们想保留地址路径但应用不同的逻辑，这非常有用。例如，请看以下代码：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is something interesting about the routing in Express. We may pass not
    just one but many handlers. This means that we can create a chain of functions
    that correspond to one URL. For example, it we need to know if the user is logged
    in, there is a module for that. We can add another method that validates the current
    user and attaches a variable to the request object, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Express中的路由有一些有趣的特点。我们不仅可以传递一个处理器，还可以传递多个处理器。这意味着我们可以创建一个与一个URL对应的函数链。例如，如果我们需要知道用户是否已登录，有一个模块可以做到这一点。我们可以添加另一个方法来验证当前用户并将变量附加到请求对象上，如下所示：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Validator` class is a class that checks the current user''s session. The
    idea is simple: we add another handler, which acts as an additional middleware.
    After performing the necessary actions, we call the `next` function, which passes
    the flow to the next handler, `getUser`. Because the request and response objects
    are the same for all the middlewares, we have access to the `userLogged` variable.
    This is what makes Express really flexible. There are a lot of great features
    available, but they are optional. At the end of this chapter, we will make a simple
    website that implements the same logic.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validator`类是一个检查当前用户会话的类。想法很简单：我们添加另一个处理器，它充当额外的中间件。在执行必要的操作后，我们调用`next`函数，它将流程传递给下一个处理器`getUser`。因为对于所有中间件，请求和响应对象都是相同的，所以我们有权访问`userLogged`变量。这正是Express真正灵活的原因。有很多很棒的功能可用，但它们是可选的。在本章的结尾，我们将创建一个简单的网站，实现相同的逻辑。'
- en: Handling dynamic URLs and the HTML forms
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理动态URL和HTML表单
- en: 'The Express framework also supports dynamic URLs. Let''s say we have a separate
    page for every user in our system. The address to those pages looks like the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Express框架也支持动态URL。假设我们为系统中的每个用户都有一个单独的页面。这些页面的地址如下所示：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, `45` is the unique number of the user in our database. It''s of course
    normal to use one route handler for this functionality. We can''t really define
    different functions for every user. The problem can be solved by using the following
    syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`45`是我们数据库中用户的唯一编号。当然，使用一个路由处理器来处理这种功能是正常的。我们真的不能为每个用户定义不同的函数。这个问题可以通过使用以下语法来解决：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The route is actually like a regular expression with variables inside. Later,
    that variable is accessible in the `req.params` object. We can have more than
    one variable. Here is a slightly more complex example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 路由实际上就像一个包含变量的正则表达式。稍后，这个变量可以在 `req.params` 对象中访问。我们可以有多个变量。以下是一个稍微复杂一点的例子：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we open `http://localhost:3000/user/451/profile/edit`, we see `User (451):
    edit` as a response. This is how we can get a nice looking, SEO-friendly URL.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们打开 `http://localhost:3000/user/451/profile/edit`，我们会看到 `User (451): edit`
    作为响应。这就是我们如何得到一个看起来很好，SEO 友好的 URL 的方法。'
- en: 'Of course, sometimes we need to pass data via the GET or POST parameters. We
    may have a request like `http://localhost:3000/user?action=edit`. To parse it
    easily, we need to use the native `url` module, which has few helper functions
    to parse URLs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时我们需要通过 GET 或 POST 参数传递数据。我们可能有一个像 `http://localhost:3000/user?action=edit`
    这样的请求。为了轻松解析它，我们需要使用本地的 `url` 模块，它有几个辅助函数来解析 URL：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the module parses the given URL, our GET parameters are stored in the
    `.query` object. The POST variables are a bit different. We need a new middleware
    to handle that. Thankfully, Express has one, which is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块解析了给定的 URL，我们的 GET 参数就存储在 `.query` 对象中。POST 变量略有不同。我们需要一个新的中间件来处理它。幸运的是，Express
    提供了一个，如下所示：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `express.bodyParser()` middleware populates the `req.body` object with the
    POST data. Of course, we have to change the HTTP method from `.get` to `.post`
    or `.all`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.bodyParser()` 中间件将 POST 数据填充到 `req.body` 对象中。当然，我们必须将 HTTP 方法从 `.get`
    改为 `.post` 或 `.all`。'
- en: 'If we want to read cookies in Express, we may use the `cookieParser` middleware.
    Similar to the body parser, it should also be installed and added to the `package.json`
    file. The following example sets the middleware and demonstrates its usage:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 Express 中读取 cookies，我们可以使用 `cookieParser` 中间件。与 body parser 类似，它也应该被安装并添加到
    `package.json` 文件中。以下示例设置了中间件并演示了其用法：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Returning a response
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回响应
- en: 'Our server accepts requests, does some stuff, and finally, sends the response
    to the client''s browser. This can be HTML, JSON, XML, or binary data, among others.
    As we know, by default, every middleware in Express accepts two objects, `request`
    and `response`. The `response` object has methods that we can use to send an answer
    to the client. Every response should have a proper content type or length. Express
    simplifies the process by providing functions to set HTTP headers and sending
    content to the browser. In most cases, we will use the `.send` method, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器接受请求，做一些处理，最后将响应发送到客户端的浏览器。这可以是 HTML、JSON、XML 或二进制数据等。众所周知，默认情况下，Express
    中的每个中间件都接受两个对象，`request` 和 `response`。`response` 对象有我们可以用来向客户端发送答案的方法。每个响应都应该有一个适当的内容类型或长度。Express
    通过提供设置 HTTP 头和向浏览器发送内容的功能来简化这个过程。在大多数情况下，我们将使用 `.send` 方法，如下所示：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we pass a string, the framework sets the `Content-Type` header to `text/html`.
    It''s great to know that if we pass an object or array, the content type is `application/json`.
    If we develop an API, the response status code is probably going to be important
    for us. With Express, we are able to set it like in the following code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递一个字符串时，框架将 `Content-Type` 头设置为 `text/html`。了解如果我们传递一个对象或数组，内容类型将是 `application/json`
    是很有帮助的。如果我们开发 API，响应状态码可能对我们来说很重要。使用 Express，我们能够像以下代码片段那样设置它：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s even possible to respond with a file from our hard disk. If we don''t
    use the framework, we will need to read the file, set the correct HTTP headers,
    and send the content. However, Express offers the `.sendfile` method, which wraps
    all these operations as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以响应来自我们硬盘上的文件。如果我们不使用框架，我们需要读取文件，设置正确的 HTTP 头，并发送内容。然而，Express 提供了 `.sendfile`
    方法，它将这些操作封装如下：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Again, the content type is set automatically; this time it is based on the filename's
    extension.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，内容类型是自动设置的；这次它是基于文件扩展名来确定的。
- en: 'When building websites or applications with a user interface, we normally need
    to serve an HTML. Sure, we can write it manually in JavaScript, but it''s good
    practice to use a template engine. This means we save everything in external files
    and the engine reads the markup from there. It populates them with some data and,
    at the end, provides ready-to-show content. In Express, the whole process is summarized
    in one method, `.render`. However, to work properly, we have to instruct the framework
    regarding which template engine to use. We already talked about this in the beginning
    of this chapter. The following two lines of code, set the path to our views and
    the template engine:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建具有用户界面的网站或应用程序时，我们通常需要提供HTML。当然，我们可以手动在JavaScript中编写它，但使用模板引擎是良好的实践。这意味着我们将所有内容保存在外部文件中，引擎从那里读取标记。它用一些数据填充它们，最后提供准备好显示的内容。在Express中，整个过程总结为一个方法，`.render`。然而，为了正常工作，我们必须指导框架使用哪个模板引擎。我们已经在本章的开始讨论了这一点。以下两行代码设置了我们的视图路径和模板引擎：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s say we have the following template (`/views/index.jade`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下模板（`/views/index.jade`）：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Express provides a method to serve templates. It accepts the path to the template,
    the data to be applied, and a callback. To render the previous template, we should
    use the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Express提供了一个提供模板的方法。它接受模板的路径、要应用的数据和一个回调。要渲染前面的模板，我们应该使用以下代码：
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The HTML produced looks as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的HTML看起来如下：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we pass a third parameter, `function`, we will have access to the generated
    HTML. However, it will not be sent as a response to the browser.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递一个第三个参数，`function`，我们将能够访问生成的HTML。然而，它不会作为响应发送到浏览器。
- en: The example-logging system
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-日志系统
- en: 'We''ve seen the main features of Express. Now let''s build something real.
    The next few pages present a simple website where users can read only if they
    are logged in. Let''s start and set up the application. We are going to use Express''
    command-line instrument. It should be installed using `npm install -g express-generator`.
    We create a new folder for the example, navigate to it via the terminal, and execute
    `express --css less site`. A new directory, `site`, will be created. If we go
    there and run `npm install`, Express will download all the required dependencies.
    As we saw earlier, by default, we have two routes and two controllers. To simplify
    the example, we will use only the first one: `app.use(''/'', routes)`. Let''s
    change the `views/index.jade` file content to the following HTML code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Express的主要功能。现在让我们构建一些真实的东西。接下来的几页展示了一个简单的网站，用户只有在登录后才能阅读。让我们开始并设置应用程序。我们将使用Express的命令行工具。它应该使用`npm
    install -g express-generator`来安装。我们为示例创建一个新的文件夹，通过终端导航到它，并执行`express --css less
    site`。将创建一个新的目录，`site`。如果我们去那里并运行`npm install`，Express将下载所有必需的依赖项。正如我们之前看到的，默认情况下，我们有两条路由和两个控制器。为了简化示例，我们将只使用第一个：`app.use('/',
    routes)`。让我们将`views/index.jade`文件的内容更改为以下HTML代码：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, if we run `node ./bin/www` and open `http://127.0.0.1:3000`, we will see
    the page. Jade uses indentation to parse our template. So, we should not mix tabs
    and spaces. Otherwise, we will get an error.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行`node ./bin/www`并打开`http://127.0.0.1:3000`，我们将看到页面。Jade使用缩进来解析我们的模板。因此，我们不应该混合制表符和空格。否则，我们会得到一个错误。
- en: Next, we need to protect our content. We check whether the current user has
    a session created; if not, a login form is shown. It's the perfect time to create
    a new middleware.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要保护我们的内容。我们检查当前用户是否创建了一个会话；如果没有，则显示登录表单。这是创建新中间件的最佳时机。
- en: 'To use sessions in Express, install an additional module: `express-session`.
    We need to open our `package.json` file and add the following line of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Express中使用会话，安装一个额外的模块：`express-session`。我们需要打开我们的`package.json`文件并添加以下代码行：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we do that, a quick run of `npm install` will bring the module to our
    application. All we have to do is use it. The following code goes to `app.js`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，快速运行`npm install`就会将模块带到我们的应用程序中。我们唯一要做的就是使用它。以下代码将进入`app.js`：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that we changed the original `app.use(''/'', routes)` line. The `session`
    middleware is initialized and added to Express. The `verifyUser` function is called
    before the page rendering. It uses the `req.session` object, and checks whether
    there is a `loggedIn` variable defined and if its value is `true`. If we run the
    script again, we will see that the `show login form` textis shown for every request.
    It''s like this because no code sets the session exactly the way we want it. We
    need a form where users can type their username and password. We will process
    the result of the form and if the credentials are correct, the `loggedIn` variable
    will be set to `true`. Let''s create a new `Jade` template, `/views/login.jade`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们更改了原始的 `app.use('/', routes)` 行。初始化并添加到 Express 的 `session` 中间件。在页面渲染之前调用
    `verifyUser` 函数。它使用 `req.session` 对象，并检查是否定义了 `loggedIn` 变量，并且其值是否为 `true`。如果我们再次运行脚本，我们会看到对于每个请求都会显示“显示登录表单”文本。这是因为没有代码以我们想要的方式设置会话。我们需要一个表单，用户可以在其中输入他们的用户名和密码。我们将处理表单的结果，如果凭证正确，则将
    `loggedIn` 变量设置为 `true`。让我们创建一个新的 `Jade` 模板，`/views/login.jade`：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Instead of sending just a text with `res.send("show login form");` we should
    render the new template, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是只发送带有 `res.send("show login form");` 的文本，我们应该渲染新的模板，如下所示：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We choose POST as the method for the form. So, we need to add the middleware
    that populates the `req.body` object with the user''s data, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 POST 作为表单的方法。因此，我们需要添加中间件，以便用用户的数据填充 `req.body` 对象，如下所示：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Process the submitted username and password as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式处理提交的用户名和密码：
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The valid credentials are set to `admin/admin`. In a real application, we may
    need to access a database or get this information from another place. It's not
    really a good idea to place the username and password in the code; however, for
    our little experiment, it is fine. The previous code checks whether the passed
    data matches our predefined values. If everything is correct, it sets the session,
    after which the user is forwarded to the home page.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的凭证设置为 `admin/admin`。在实际应用中，我们可能需要访问数据库或从其他地方获取此信息。将用户名和密码放在代码中并不是一个好主意；然而，对于我们的这个小实验来说，这是可以的。之前的代码检查传递的数据是否与预定义的值匹配。如果一切正确，它将设置会话，之后用户将被转发到主页。
- en: 'Once you log in, you should be able to log out. Let''s add a link for that
    just after the content on the index page (`views/index.jade`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你应该能够注销。让我们在索引页面的内容之后添加一个链接（`views/index.jade`）：
- en: '[PRE38]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once users clicks on this link, they will be forward to a new page. We just
    need to create a handler for the new route, remove the session, and forward them
    to the index page where the login form is reflected. Here is what our logging
    out handler looks like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击此链接时，他们将被转发到新页面。我们只需要为新的路由创建一个处理器，删除会话，并将他们转发到登录表单所在的索引页面。以下是我们注销处理器的样子：
- en: '[PRE39]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Setting `loggedIn` to `false` is enough to make the session invalid. The redirect
    sends users to the same content page they came from. However, this time, the content
    is hidden and the login form pops up.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `loggedIn` 设置为 `false` 就足以使会话无效。重定向将用户发送到他们来自的相同内容页面。然而，这次内容被隐藏，登录表单弹出。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about one of most widely used Node.js frameworks,
    Express. We discussed its fundamentals, how to set it up, and its main characteristics.
    The middleware architecture, which we mentioned in the previous chapter, is the
    base of the library and gives us the power to write complex but, at the same time,
    flexible applications. The example we used was a simple one. We required a valid
    session to provide page access. However, it illustrates the usage of the body
    parser middleware and the process of registering the new routes. We also updated
    the `Jade` templates and saw the results in the browser.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了最广泛使用的 Node.js 框架之一，Express。我们讨论了其基础、如何设置它以及其主要特性。我们在上一章中提到的中间件架构是库的基础，并赋予我们编写复杂但同时又灵活的应用程序的能力。我们使用的示例很简单。我们需要一个有效的会话来提供页面访问。然而，它说明了
    body parser 中间件的使用和注册新路由的过程。我们还更新了 `Jade` 模板，并在浏览器中看到了结果。
- en: The next chapter will show us how Node.js collaborated with AngularJS, a popular
    framework made by Google for client-side JavaScript applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将展示 Node.js 如何与 Google 为客户端 JavaScript 应用程序制作的流行框架 AngularJS 协作。
