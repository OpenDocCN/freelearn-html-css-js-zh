- en: Chapter 7. Building a Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章. 构建游戏
- en: We've come to the final chapter of this book, and if I may speak in first-person
    for a moment, this was my favorite application to build. Everybody loves a game,
    and if word games are your thing, you'll have fun with this too. Most of the applications
    we've written so far have been single-view applications; the only screen the user
    sees is the view that performs the main action of the application. However, full
    web applications often have other views that aren't the main purpose of the application,
    but serve to fill it out. We have one or two such views in this application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经来到了这本书的最后一章，如果我可以暂时以第一人称来谈谈，这是我最喜欢构建的应用程序。每个人都喜欢游戏，如果你喜欢文字游戏，你也会喜欢这个。我们迄今为止编写的应用程序大多数都是单视图应用程序；用户看到的唯一屏幕是执行应用程序主要动作的视图。然而，完整的Web应用程序通常还有其他不是应用程序主要目的的视图，但有助于完善应用程序。在这个应用程序中，我们有一个或两个这样的视图。
- en: 'So, here are a few of the topics we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是本章我们将涵盖的一些主题：
- en: Review all the primary uses of the Backbone components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习所有Backbone组件的主要用途
- en: Add non-Backbone pages to fill out the application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加非Backbone页面以完善应用程序
- en: Build an app that uses data not provided by the user
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个使用用户未提供的数据的应用程序
- en: Write (simple) game logic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写（简单）的游戏逻辑
- en: What are we building?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们正在构建什么？
- en: Once again, we'll start by describing what we're planning the build. It's going
    to be a word game, modeled after a very simple iPhone game I enjoy, called *7
    Little Words* ([http://www.7littlewords.com/](http://www.7littlewords.com/)).
    Each game (or round, if you will) has seven words that are broken into parts of
    two, three, or four letters. Your job is to reassemble the words based on the
    short definitions that you're given. To make it clear, I have no affiliation with
    this iPhone game, I just like playing it!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将从描述我们计划构建的内容开始。这将是一款文字游戏，模仿我非常喜欢的一款非常简单的iPhone游戏，名为 *7 Little Words* ([http://www.7littlewords.com/](http://www.7littlewords.com/))。每一局游戏（或者可以说是回合，如果你愿意这样称呼的话）包含七个单词，这些单词被分成两个、三个或四个字母的部分。你的任务是根据你给出的简短定义重新组装这些单词。为了使问题更清晰，我并没有与这款iPhone游戏有任何关联，我只是喜欢玩它！
- en: However, we're going to take it a little farther than that game does, by assigning
    different point values to words, and also timing our users. This way, players
    can compare scores and times to make things a little more competitive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将比那个游戏做得更深入，通过为单词分配不同的分数值，并且还计时我们的用户。这样，玩家可以比较分数和时间，使比赛更具竞争性。
- en: 'Here''s a screenshot of what the game view of our application will look like
    when it is finished. At the bottom, you can see the tokens that the user will
    choose to combine into a word. There''s a textbox in the middle that shows the
    word the user has assembled. Then, they''ll click on the **Guess** button to see
    if the word matches one of the definitions above:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完成后的应用程序游戏视图的截图。在底部，你可以看到用户将选择组合成单词的标记。中间有一个文本框，显示用户已经组装的单词。然后，他们点击 **猜测**
    按钮来查看单词是否与上面的定义之一匹配：
- en: '![What are we building?](img/6997OS_07_05.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![我们正在构建什么？](img/6997OS_07_05.jpg)'
- en: User accounts
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户账户
- en: 'We''ll start as we did in the last chapter; by adding user account to our basic
    application. We won''t go over the whole process again; you can copy it from the
    previous chapter''s application. There''s only one change we have to make. In
    the `app.post(''/create'')` route, we create a `userAttrs` object that we store
    in the database. Users of this application will have three application-specific
    values to store:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像上一章一样开始；通过向我们的基本应用程序添加用户账户。我们不会再次详细讲解整个过程；你可以从上一章的应用程序中复制它。我们只需要做一个小改动。在
    `app.post('/create')` 路由中，我们创建一个 `userAttrs` 对象并将其存储在数据库中。这个应用程序的用户将有三项特定于应用程序的值需要存储：
- en: '`score`: This is their highest score'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score`：这是他们的最高分'
- en: '`time`: This is their lowest time'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`：这是他们的最低时间'
- en: '`games`: This is an array of the games they have played'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`games`：这是一个包含他们所玩游戏的数组'
- en: 'Here''s the code to create the `userAttrs` object:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建 `userAttrs` 对象的代码：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this in place, and all the other user account creation code we've previously
    created, we have the shell of an application, ready to customize.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，加上我们之前创建的所有其他用户账户创建代码，我们就有了一个应用程序的框架，可以开始定制。
- en: Templates
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Our server-side templates have been pretty basic in previous applications.
    We''ve only ever had a single `index.ejs` file, and maybe a `login.ejs` file.
    However, in a big application, you''ll probably have several different server
    templates. When that''s the case, you want to remove code duplication as much
    as possible. How you go about this is dependent on which server-side template
    system you use. Since we''re using `ejs` ([https://github.com/visionmedia/ejs](https://github.com/visionmedia/ejs)),
    we''ll do this via **includes**. So, in our project''s `views` directory, make
    a file called `header.ejs`. Here''s what goes in there:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的应用中，我们的服务器端模板相当基础。我们只有单个`index.ejs`文件，也许还有一个`login.ejs`文件。然而，在一个大型应用中，你可能会拥有多个不同的服务器端模板。当这种情况发生时，你希望尽可能减少代码重复。你如何进行取决于你使用的服务器端模板系统。由于我们使用的是`ejs`([https://github.com/visionmedia/ejs](https://github.com/visionmedia/ejs))，我们将通过**包含**来实现这一点。所以，在我们的项目`views`目录中创建一个名为`header.ejs`的文件。以下是文件中的内容：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Basic and expected, right? Now, we''re also going to have a `footer.ejs` file
    in the `views` directory, which will close these tags:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基本且符合预期，对吧？现在，我们还在`views`目录中添加了一个`footer.ejs`文件，它将关闭这些标签：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you could just remember to add these two lines to the bottom
    of every template you create that uses the `header.ejs` include (or, if you''re
    hip with the HTML5 lack-of-strictness, leave them out entirely), but I like the
    symmetry that comes from having both the `header.ejs` and `footer.ejs` files.
    For example, our `login.ejs` file in the `views` directory, which has both the
    login and signup forms:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以只是记住在创建每个使用`header.ejs`包含文件的模板时，将这些两行添加到模板的底部（或者，如果你对HTML5的宽松性很熟悉，也可以完全省略它们），但我喜欢同时拥有`header.ejs`和`footer.ejs`文件带来的对称性。例如，我们位于`views`目录中的`login.ejs`文件，它包含了登录和注册表单：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'See what I mean about symmetry? We can use the same technique in the `index.ejs`
    file in the `views` directory, which will start out like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你明白我说的对称性吗？我们可以在`views`目录中的`index.ejs`文件中使用相同的技巧，它将开始如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we''ll be splitting models, views, and the router into separate
    files again. This will be especially important in this application because of
    some of the complex code the models will use. So now that we have a `index.ejs`
    file in the `views` directory, we can render the index route. In the `server.js`
    file, this code should be your final route:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将再次将模型、视图和路由器拆分到单独的文件中。这在当前应用中尤为重要，因为模型将使用一些复杂的代码。所以现在我们在`views`目录中有一个`index.ejs`文件，我们可以渲染索引路由。在`server.js`文件中，这段代码应该是你的最终路由：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that we're not passing any values into the index template; this application
    won't require anything like that. This might sound strange. Since it is supposed
    to be a more advanced application, wouldn't you expect it to need more data out
    of the gate? If your application needs to shuttle a lot of data from the server
    to the browser, it is sometimes a smarter move not to move the data all at once;
    it could seriously slow down your load time. A better technique is to load the
    data when it is needed, and that's what we'll do here. Also, it is possible that
    you might need the user to make a decision before you know exactly what data you
    need; this is another reason to delay loading data, and this is true in our case
    as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有向索引模板传递任何值；这个应用不需要这样的东西。这听起来可能有些奇怪。既然它是一个更高级的应用，难道你不期望它一开始就需要更多的数据吗？如果你的应用需要从服务器传输大量数据到浏览器，那么一次传输所有数据可能不是最佳选择；这可能会严重影响你的加载时间。更好的技术是在需要时加载数据，这正是我们将要做的。此外，可能在你确切知道需要哪些数据之前，你需要让用户做出决定；这也是延迟加载数据的另一个原因，在我们的案例中也是如此。
- en: Creating the game data
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏数据
- en: 'Speaking of loading data, the next step is to create the data for our game—the
    words the users will spell. This is actually the only application in this book
    that begins with data, instead of only working with the data that users give to
    the application. The actual raw data will be in the `words.json` file in the root
    of our project. One of the keys to this being a good game is to have plenty of
    words to choose from. Here''s how the file starts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 说到加载数据，下一步是创建我们游戏的数据——用户将要拼写的单词。实际上，这是本书中唯一一个从数据开始的应用，而不是仅仅处理用户提供给应用的数据。实际的原始数据将存储在我们项目的根目录下的`words.json`文件中。这个游戏成为好游戏的关键之一是有大量的单词可供选择。以下是文件开始的部分：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, every word has an ID. Then, the important properties are the words
    and definitions. The definition is what the user will see, and the word is what
    they'll have to piece together. The level is a number between 1 and 3, with level
    1 words being the easiest and level 3 words being the toughest. You can write
    your own list, or download this list from Github ([https://gist.github.com/andrew8088/9627996](https://gist.github.com/andrew8088/9627996)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每个单词都有一个ID。然后，重要的属性是单词和定义。定义是用户将看到的，而单词是他们需要拼凑的。级别是一个介于1到3之间的数字，其中级别1的单词是最简单的，级别3的单词是最难的。你可以编写自己的列表，或者从GitHub下载这个列表（[https://gist.github.com/andrew8088/9627996](https://gist.github.com/andrew8088/9627996)）。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: During the development of this application, one idea was to use a dictionary
    API (such as [dictionaryapi.com](http://dictionaryapi.com)) to randomly select
    words from a much larger database. However, this isn't really practical, because
    we need a short, crossword-puzzle-like definition, and standard dictionary definitions
    just don't cut it. Also, most APIs don't have a way of selecting a random word.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发这个应用程序的过程中，一个想法是使用字典API（如[dictionaryapi.com](http://dictionaryapi.com)）从更大的数据库中随机选择单词。然而，这实际上并不实用，因为我们需要一个简短的、类似于填字游戏的定义，而标准的字典定义根本不够。此外，大多数API都没有选择随机单词的方法。
- en: 'Once we have our list of words, we''ll need to create the actual database.
    Add this to the top of the `server.js` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了单词列表，我们需要创建实际的数据库。将以下内容添加到`server.js`文件的顶部：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We also require the Underscore library here; you'll see what we need it for
    in a moment. We need the very same file that we use on the client side. This won't
    work for every file; it just happens that the latest version of Underscore (at
    the time of writing this book, 1.6.0) is written to work on both the client and
    the server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里也需要Underscore库；你很快就会看到我们为什么需要它。我们需要与客户端相同的文件。这不会适用于每个文件；碰巧在撰写这本书的时候（1.6.0版本），Underscore的最新版本被编写为可以在客户端和服务器上运行。
- en: 'Each game played by a user will have eight words; this means that we need to
    pull eight words randomly, but all of the same difficulty level, from the database.
    To do this, we''ll add a `getWords` function to the server file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用户每玩一次游戏都会有八个单词；这意味着我们需要从数据库中随机抽取八个单词，但所有单词的难度级别相同。为此，我们将在服务器文件中添加一个`getWords`函数：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function will take a level number and a callback function. Then, we'll
    get all the words in the database for that level. We'll then shuffle the array
    of records, using Underscore's `shuffle` method. After we shuffle the array, we'll
    slice the first eight items off the array and pass them to the callback.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将接受一个级别数字和一个回调函数。然后，我们将获取数据库中该级别的所有单词。接下来，我们将使用Underscore的`shuffle`方法对记录数组进行洗牌。洗牌后，我们将从数组中取出前八个项目并传递给回调。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should be said that this is probably not an optimal way to get eight random
    words from most databases. Since I wrote the Bourne database system for small
    datasets, and it keeps all records in memory, what we do here should be fast.
    However, there will probably be better ways, depending on the database system
    you're using.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出，这可能不是从大多数数据库中获取八个随机单词的最佳方式。由于我为小型数据集编写了Bourne数据库系统，并且它将所有记录都保存在内存中，所以我们在这里所做的应该很快。然而，根据你使用的数据库系统，可能还有更好的方法。
- en: 'Now that we have a way of getting the words, we need to create a route for
    that:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了获取单词的方法，我们需要为它创建一个路由：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The level for the game is part of the URL. We convert it to a number, and then
    call our `getWords` function. Once we have the words, we can send them back to
    the browser as JSON.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的级别是URL的一部分。我们将它转换为数字，然后调用我们的`getWords`函数。一旦我们有了单词，我们就可以将它们作为JSON发送回浏览器。
- en: Writing the models
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模型
- en: 'Because of the nature of this application, we will have more models than usual.
    The two obvious ones are the `Word` model and its collection, `Game`. These hardly
    require explanation. However, remember that we''ll split words into parts, which
    we''ll call tokens. For this, we''ll have a `Token` model and a `Tokens` collection.
    These are actually the simplest parts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用程序的性质，我们将比通常有更多的模型。两个明显的模型是`Word`模型及其集合`Game`。这些几乎不需要解释。然而，请记住，我们将单词分成部分，我们将称之为标记。为此，我们将有一个`Token`模型和`Tokens`集合。这些实际上是简单的部分：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since these are just shells for the chopped-up words, there doesn''t need to
    be much to them. All the primary logic will be in the `Word` and `Game` classes.
    Let''s start with the `Word` class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些只是被切碎的单词的壳，它们不需要太多。所有的主要逻辑都将包含在`Word`和`Game`类中。让我们从`Word`类开始：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Every `Word` instance will need to be assigned a point value. It's not that
    tricky; just add the length of the word and its difficulty level. Later, multiply
    this value with another that's based on time. The other method calls the `Word.split`
    function, passing it the word. This is where the code gets a little more complex.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Word`实例都需要分配一个点值。这并不复杂；只需加上单词的长度和难度级别。稍后，将这个值乘以基于时间的另一个值。另一种方法调用`Word.split`函数，传递给它的单词。这就是代码变得稍微复杂的地方。
- en: 'However, before we get to splitting up words, notice that the `split` method
    is a static or class-level method. This isn''t something we''ve seen before in
    Backbone; but Backbone makes it very simple to add static methods. So far, we''ve
    only ever passed one parameter to the `Backbone.Model.extend` method; an object
    of instance-level properties and methods. However, the method can take a second
    object, with class properties and methods:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始分割单词之前，请注意`split`方法是一个静态或类级别方法。这在我们之前看到的Backbone中并不常见；但Backbone使得添加静态方法变得非常简单。到目前为止，我们只向`Backbone.Model.extend`方法传递了一个参数；一个包含实例级别属性和方法的对象。然而，这个方法可以接受第二个对象，包含类属性和方法：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This isn't just for models; it works with collections, views, and even routers.
    So, add a class properties object to the preceding `Word` model; we'll be using
    it in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅适用于模型；它还适用于集合、视图，甚至路由器。所以，给前面的`Word`模型添加一个类属性对象；我们将在下一节中使用它。
- en: Splitting up words
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割单词
- en: 'Randomly splitting the words into tokens is not as easy as you think. We want
    to do it randomly, so that each time a game is played, a word may be split up
    differently. We want to split every word into tokens of two, three, or four letters.
    You might think, then, that we could randomly select one of those numbers. However,
    we don''t really want equal amounts of all three sizes; we''d like fewer two-letter
    tokens. This requires a weighted random selection, so we first have to write a
    function for that. The way to represent our weighted options is through an array
    like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词随机分割成标记并不是像你想的那么简单。我们希望随机进行，这样每次玩游戏时，单词的分割方式可能都不同。我们希望将每个单词分割成两个、三个或四个字母的标记。你可能认为，那么我们可以随机选择这些数字中的一个。然而，我们并不真的想要所有三种尺寸的数量相等；我们希望有两个字母标记更少。这需要加权随机选择，因此我们首先必须编写一个函数来实现这一点。表示我们的加权选项的方式是通过如下数组：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each array within this array has two elements. The first is the value we want
    to use; this could be a string, an object, or anything. The second value is the
    chance that this will be the value chosen. As you can see from this array, the
    value 2 will be chosen 20 percent of the time, and values 3 and 4 will be chosen
    40 percent of the time, each. So, here''s the function that takes that array as
    a parameter. Remember to put this in the class properties object of the `Word`
    model:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组中的每个数组都有两个元素。第一个是我们想要使用的值；这可以是一个字符串、一个对象或任何东西。第二个值是这个值被选中的概率。正如你可以从这个数组中看到的那样，值2将有20%的概率被选中，值3和4将各有40%的概率被选中。所以，这是一个接受该数组作为参数的函数。记住要将这个函数放在`Word`模型的类属性对象中：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first step is to add up the percentage values in the arrays. In our case,
    these values add up to 1, but they don''t have to; if they add up to some other
    value, this will still work. We do this by calling the native reduce method on
    the array, summing up all seconds elements. The next step is to create a new array,
    which the weight values sum up as they go along. For example, our weight values
    are 0.2, 0.4, and 0.4\. For these values, we need to create an array like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是计算数组中的百分比值。在我们的例子中，这些值加起来是1，但它们不必是；如果它们加起来是某个其他值，这仍然有效。我们通过在数组上调用原生的`reduce`方法来实现这一点，将所有第二个元素相加。下一步是创建一个新数组，随着加权值的累加，我们将创建一个数组，例如：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we create a `sum` variable and an array called `list`. Then, we loop over
    the items, adding the value to the `sum` variable, and then pushing that `sum`
    variable into the `list` array. We now have the array we need. Finally, we''ll
    return a function. The function will start by getting a random number between
    0 and the total. Then, we''ll loop over the list, checking each item to see whether
    it is less than or equal to the random number. Once we get a match on that, we''ll
    return the value from the original items parameter, using the same index number.
    That''s all for our weighted random generator. Now, we''re ready to use this in
    the function that splits the word into tokens. This is the `split` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个`sum`变量和一个名为`list`的数组。然后，我们遍历项目，将值添加到`sum`变量中，然后将该`sum`变量推入`list`数组中。我们现在有了所需的数组。最后，我们将返回一个函数。该函数将首先获取一个介于0和总数之间的随机数。然后，我们将遍历列表，检查每个项目是否小于或等于随机数。一旦我们找到匹配项，我们将使用相同的索引号从原始项目参数中返回值。这就是我们的加权随机生成器的全部内容。现在，我们准备在分割单词成标记的函数中使用它。这是`split`函数：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function takes a word and splits it into tokens. First, we split the string
    into an array, and then create an array to hold the tokens. Next, we create three
    random generators, which we'll need at different points. Then, we have a `while`
    loop, for when the length of the word is greater than zero. If the length of the
    word is greater than five characters, we'll use the generator that will return
    a 2, 3, or 4\. If the word is five characters long, we'll use the generator that
    returns either 2 or 3\. If it's four characters long, we'll use the generator
    that will return either 2 or 4\. The final `else` statement will be used if the
    word is shorter than four characters; we'll use the length of the word.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个单词并将其分割成标记。首先，我们将字符串分割成一个数组，然后创建一个数组来保存标记。接下来，我们创建三个随机生成器，我们将在不同的点需要它们。然后，我们有一个`while`循环，用于当单词长度大于零时。如果单词长度大于五个字符，我们将使用返回2、3或4的生成器。如果单词是五个字符长，我们将使用返回2或3的生成器。如果它是四个字符长，我们将使用返回2或4的生成器。最后的`else`语句将用于单词长度小于四个字符的情况；我们将使用单词的长度。
- en: All of this ensures that the word will be split up into tokens of two, three,
    or four characters; it also makes sure that we'll never get a one-letter token,
    by slicing off all but one of the letters. The last step in the `while` loop is
    to use the word array's `splice` method. This method will mutate the original
    array, taking those letters out of the array and returning them (this is how the
    word length changes in the `while` loop condition). Once we've split up the word
    into tokens, we return the array of tokens. This is the function used in the `Word`
    class's parts method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些确保单词将被分割成两个、三个或四个字符的标记；这也确保我们永远不会得到一个字母的标记，通过移除除了一个字母之外的所有字母。`while`循环的最后一步是使用单词数组的`splice`方法。这个方法将改变原始数组，将这些字母从数组中取出并返回（这就是单词长度在`while`循环条件中变化的原因）。一旦我们将单词分割成标记，我们返回标记数组。这是在`Word`类的`parts`方法中使用的函数。
- en: 'The collection class for this is `Game`. This will start out very simply:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合的类是`Game`。这将从非常简单开始：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This really is just the start. One of these collection instances will handle
    much more, but we'll get there. We start by setting the model class for this collection,
    and then we create the `initialize` method. A collection object will be responsible
    for tracking time and points, so we give it a `seconds` and `score` property.
    Since our game will have levels, we also have a `level` property. Then, we have
    the `getWords` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上只是一个开始。这些集合实例中之一将处理更多内容，但我们终将到达那里。我们首先为这个集合设置模型类，然后创建`initialize`方法。集合对象将负责跟踪时间和分数，因此我们给它一个`seconds`和`score`属性。由于我们的游戏将有等级，所以我们还有一个`level`属性。然后，我们有`getWords`方法。
- en: As we know, we aren't sending a set of words with the initial page load, so
    this is the method that will do that. This makes an AJAX request to the route
    we created to send the words. The `Backbone.ajax` method actually wraps the `jQuery.ajax`
    method. It returns a promise, which we learned about in [Chapter 6](ch06.html
    "Chapter 6. Building a Podcast Application"), *Building a Podcast Application*,
    here. We call its `then` method, passing it the collection's `reset` method. This
    method will replace any models in the collection with the array of models passed
    as a parameter. The `then` method will return the promise object, so we return
    it. This way, we can perform an action after the words have been loaded.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，我们并不是在页面初始加载时发送一组单词，因此这是完成这一任务的方法。它会对我们创建的用于发送单词的路由发起一个AJAX请求。`Backbone.ajax`方法实际上是对`jQuery.ajax`方法的封装。它返回一个承诺，我们在[第6章](ch06.html
    "第6章. 构建播客应用程序")中学习了承诺的概念，即*构建播客应用程序*，在这里。我们调用它的`then`方法，传递给它集合的`reset`方法。这个方法会用作为参数传递的模型数组替换集合中的任何模型。`then`方法将返回承诺对象，因此我们返回它。这样，我们就可以在单词加载后执行操作。
- en: Finally, notice the `tokens` method; in here, we call the collection's `invoke`
    method. This method takes the name of another method and calls it on each model
    in the collection. This will return an array of values; in this case, the values
    will be an array of tokens, the split-up words. An array of arrays isn't useful,
    so we'll use Underscore's `flatten` method to flatten the nested arrays into a
    single array of tokens. Then, we return a `Tokens` collection instance, mapping
    the `tokens` array into an array of objects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意`tokens`方法；在这里，我们调用集合的`invoke`方法。这个方法接受另一个方法的名称，并在集合中的每个模型上调用它。这将返回一个值数组；在这种情况下，值将是一个标记数组，即分割后的单词。一个数组数组没有用，所以我们将使用Underscore的`flatten`方法将嵌套数组展平成一个标记的单个数组。然后，我们返回一个映射到对象数组的`Tokens`集合实例。
- en: Writing the tokens view
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写标记视图
- en: 'Now that we have the models more or less in place, we''re ready to start writing
    the actual views. Let''s start with something simple: the tokens. We start with
    the `TokensView` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将模型大致准备好，我们准备开始编写实际的视图。让我们从一个简单的东西开始：标记。我们从`TokensView`类开始：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Writing this class is very simple. We get the collection of tokens from the
    game, call the built-in `shuffle` method to shuffle the tokens, and then render
    them each with the `addToken` method. This method renders a `TokenView` instance
    and appends it to the element. So that''s the next stop—the `TokenView` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个类非常简单。我们从游戏中获取标记集合，调用内置的`shuffle`方法来打乱标记，然后使用`addToken`方法将它们每个都渲染出来。这个方法渲染一个`TokenView`实例并将其附加到元素上。所以下一个步骤就是——`TokenView`类：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each `TokenView` instance will have a class: `token`. The `render` method is
    pretty basic—it just puts the text of the token in the element. However, notice
    the first line of the method; we''re giving the model a view property that points
    to this view. This is something we haven''t done before; we have never given a
    model a link to the view that renders it. This isn''t always considered a good
    thing; it''s often better to keep a clean separation between the model and the
    view. However, sometimes this can be a good thing, as we''ll see in this case.
    Either way, it''s very easy to do. When this element is clicked on, the `choose`
    method will be called. This method triggers the `token` event, using the model
    as a parameter. We''ve triggered events before, but this is the first time we''ve
    used the `Backbone.trigger` method. We can use this to trigger and listen for
    events globally across all our code. After we trigger the event, we''ll hide the
    view. We have `hide` and `show` views here as well. These add or remove a class
    on the element to hide or show the token respectively.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`TokenView`实例都将有一个类：`token`。`render`方法相当基础——它只是将标记的文本放入元素中。然而，请注意方法的第1行；我们正在给模型添加一个指向这个视图的视图属性。这是我们之前没有做过的事情；我们从未给模型添加指向渲染它的视图的链接。这并不总是被认为是一件好事；通常更好的做法是保持模型和视图之间的清晰分离。然而，有时这可以是一件好事，正如我们将在本例中看到的那样。无论如何，这样做非常简单。当这个元素被点击时，将调用`choose`方法。这个方法使用模型作为参数触发`token`事件。我们之前已经触发过事件，但这是第一次我们使用`Backbone.trigger`方法。我们可以使用这个方法在所有代码中全局触发和监听事件。在触发事件后，我们将隐藏视图。我们这里也有`hide`和`show`视图。这些在元素上添加或删除一个类来分别隐藏或显示标记。
- en: 'Normally, this would be the point where we start the router, so we can render
    our view and then style it. However, we''re going to go a different route this
    time. Often, when building a more complex application, you''re on a roll with
    whatever you''re working on—the views, in our case—and you don''t want to switch
    mindsets. What I''ll do in a case like this is put a `script` tag in the `index.ejs`
    file to test the view we just created:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这会是启动路由器的点，这样我们就可以渲染我们的视图并对其进行样式化。然而，这次我们将走不同的路线。在构建更复杂的应用程序时，你可能会对正在处理的工作——在我们的例子中是视图——充满热情，并且你不想改变思维模式。在这种情况下，我会在`index.ejs`文件中放置一个`script`标签来测试我们刚刚创建的视图：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It''s quick and dirty; we create a `Game` object, get a set of words, and then
    append a new `TokensView` instance to the page. You should see something like
    this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它快速而简单；我们创建一个`Game`对象，获取一组单词，然后将一个新的`TokensView`实例添加到页面上。你应该会看到类似这样的结果：
- en: '![Writing the tokens view](img/6997OS_07_01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![编写标记视图](img/6997OS_07_01.jpg)'
- en: 'If you click on the individual tokens and open your developer tools, you''ll
    see that they get the `hidden` class, just like we coded. Of course, nothing else
    happens right now, but that''s because we don''t have anything listening for the
    `''token''` event. It''s a good start, and it''s enough to begin the styling.
    So, open the `style.css` file of the `public` directory. Let''s start with this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击单个标记并打开你的开发者工具，你会看到它们获得了`hidden`类，就像我们编码的那样。当然，现在还没有其他事情发生，这是因为我们没有为`'token'`事件添加监听器。这是一个好的开始，并且足够开始样式化。所以，打开`public`目录下的`style.css`文件。让我们从这里开始：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''re starting this by pulling in a Google font. There are several to choose
    from at [https://www.google.com/fonts](https://www.google.com/fonts); we''re going
    with Lato. On the `<body>` element, we''ll set the font, font color, and background.
    Then, we''ll set a width on the main `<div>` element, the one most of our application
    will be inside. Next, we''ll add some styling to our anchor elements:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从引入一个Google字体开始。在[https://www.google.com/fonts](https://www.google.com/fonts)上有几个可供选择；我们选择了Lato。在`<body>`元素上，我们将设置字体、字体颜色和背景。然后，我们将在主`<div>`元素上设置宽度，这是我们应用程序大部分内容所在的位置。接下来，我们将对我们的锚点元素添加一些样式：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All the links will get a bit of styling—no underline, some bolding, and a new
    color—but only anchors in the main element will get the hover styling. This is
    because we''re soon going to create a navigation bar (outside the main element),
    and we don''t want the links to be underlined when hovered over. Now, we''re ready
    to style the tokens, which we do with this code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有链接都会有一些样式——没有下划线，一些加粗，以及新的颜色——但只有主元素中的锚点会得到悬停样式。这是因为我们很快将创建一个导航栏（在主元素外部），我们不希望当悬停时链接被下划线。现在，我们已经准备好为标记添加样式，我们使用以下代码来完成：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We style the token as, basically, an orange block. We space them out evenly;
    we use the *n*th-child selectors to remove the margin from the outer edges of
    the other blocks. We add a hover effect to the blocks. Finally, we add the `hidden`
    class. Now, a refresh of the page should result in something like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将标记样式化为基本的橙色块。我们将它们均匀地间隔开；我们使用*n*th-child选择器来移除其他块的外边缘的边距。我们为块添加一个悬停效果。最后，我们添加了`hidden`类。现在，刷新页面应该会得到类似这样的结果：
- en: '![Writing the tokens view](img/6997OS_07_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![编写标记视图](img/6997OS_07_02.jpg)'
- en: Looking pretty good, don't you think? Now, we're ready for the next view, the
    ones that display the clues, that is, the definitions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，不是吗？现在，我们准备好进行下一个视图，即显示线索的视图，也就是定义。
- en: Views of the clues
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线索视图
- en: 'The clues for the words—the definitions—will need to appear above the tokens.
    The `CluesView` class is pretty simple:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 单词的线索——即定义——需要出现在标记上方。`CluesView`类相当简单：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The clues will be in a table. In the `render` method, we''ll loop over the
    collection, rendering a `ClueView` class for each `Word` model. The `ClueView`
    class is where all the action takes place. Here''s the `ClueView` class''s code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 线索将显示在表格中。在`render`方法中，我们将遍历集合，为每个`Word`模型渲染一个`ClueView`类。`ClueView`类是所有动作发生的地方。以下是`ClueView`类的代码：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This view will use a table row element, and it's the first view we have that
    uses a template. To render the template, we'll just pass the JSON version of that
    model to the `template` function. In the `initialize` method, we listen for the
    `correct` event to occur. This is the event that will be triggered when the player
    has correctly guessed one of the words. This is another global event that we'll
    fire at another location. When it happens, we'll call the `correct` method. This
    method will receive as a parameter the `Word` model for the correct word. Even
    though only one word has been guessed, all the `ClueView` instances will be listening
    for the correct event. So, the first step will be to compare words and to find
    the right `ClueView` instance. If the model for this view matches, we'll add the
    `correct` class. Then, we'll remove the `clue` class from part of the template
    and add the word.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图将使用表格行元素，这是我们第一个使用模板的视图。为了渲染模板，我们只需将模型的 JSON 版本传递给 `template` 函数。在 `initialize`
    方法中，我们监听 `correct` 事件的发生。这是当玩家正确猜出一个单词时将被触发的事件。这是另一个全局事件，我们将在另一个位置触发。当它发生时，我们将调用
    `correct` 方法。这个方法将作为参数接收正确单词的 `Word` 模型。尽管只有一个单词被猜出，但所有的 `ClueView` 实例都将监听 `correct`
    事件。所以，第一步将是比较单词并找到正确的 `ClueView` 实例。如果这个视图的模型匹配，我们将添加 `correct` 类。然后，我们将从模板的一部分移除
    `clue` 类并添加单词。
- en: 'Speaking of the template, add this to the `index.ejs` file in the `views` directory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 说到模板，将以下内容添加到 `views` 目录中的 `index.ejs` 文件：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you know, this will go inside our table row element. The first `<td>` element
    will have the definition. The second will start by displaying the number of letters
    in the word, as another small clue. As we''ve seen, when they correctly guess
    the word, the clue will be replaced with the word itself. Before we check this
    out in the browser, let''s add some styling to the `style.css` file in the `public`
    directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，这将放在我们的表格行元素内部。第一个 `<td>` 元素将包含定义。第二个将首先显示单词中的字母数量，作为另一个小线索。正如我们所见，当他们正确猜出单词时，线索将被单词本身替换。在我们检查浏览器中的效果之前，让我们在
    `public` 目录中的 `style.css` 文件中添加一些样式：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We'll straighten up the `table` element and the first `<td>` cell in each row.
    When the second `<td>` cell has the number of letters in it, the `clue` class
    will reduce the font size a little. Then, when the word is correctly guessed,
    we'll remove that class and add `correct` to the whole `<tr>` element, coloring
    it and making it bold.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整理 `table` 元素以及每行的第一个 `<td>` 单元格。当第二个 `<td>` 单元格包含字母数量时，`clue` 类将稍微减小字体大小。然后，当单词被正确猜出时，我们将移除该类，并将
    `correct` 添加到整个 `<tr>` 元素上，使其着色并加粗。
- en: 'Now, back in the `index.ejs` file, you can render this view in that same quick
    and dirty way. Replace the content inside the `getWords` callback with this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `index.ejs` 文件，你可以以同样的快速且简单的方式渲染这个视图。将 `getWords` 回调函数内的内容替换为以下内容：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, refresh the page. It should look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，刷新页面。它应该看起来像这样：
- en: '![Views of the clues](img/6997OS_07_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![线索视图](img/6997OS_07_03.jpg)'
- en: 'We can''t yet see the correct word styling, because we can''t yet guess words.
    That brings us to the next step: the guess view.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看不到正确单词的样式，因为我们还无法猜测单词。这带我们到了下一步：猜测视图。
- en: Creating the guess view
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建猜测视图
- en: 'This will be the longest view in our application, because it''s got the most
    to do. Let''s start this one with the template:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的应用中最长的视图，因为它要做的事情最多。让我们从这个模板开始：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It looks simple. The first `<div>` element is where the token text will appear
    as the player clicks on tokens. The second `<div>` element will be a button; when
    they click on it, their guess will be "submitted". If the guess is one of the
    words, it will appear alongside the correct definition. Otherwise, the tokens
    will reappear with the other tokens. This is the code for the `GuessView` class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单。第一个 `<div>` 元素是玩家点击标记时标记文本将出现的地方。第二个 `<div>` 元素将是一个按钮；当玩家点击它时，他们的猜测将被“提交”。如果猜测是其中的一个单词，它将出现在正确的定义旁边。否则，标记将重新出现，与其他标记一起。这是
    `GuessView` 类的代码：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here's the start; we'll give this element a class called `guess`, and we'll
    get the preceding template that we just created. In the `initialize` method, we'll
    listen for the `token` event. Remember, when one of the tokens is clicked on,
    this event will trigger globally. Here, we catch that event and run our `add`
    method. The other thing going on in the `initialize` method is the creation of
    a `currentTokens` property. This will keep track of the tokens the user selects
    before they actually make a guess. In the `render` method, we'll get the template
    (which is just a string in this case, because there's no template data in this
    view), and then create a property that points to the `<div>` element we're using
    as a text field. This property is used in the `add` method; the method gets the
    `Token` model as a parameter. We'll cache the token in the `currentTokens` array,
    and append its text to the element.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是开始；我们将给这个元素添加一个名为 `guess` 的类，并获取我们刚刚创建的先前的模板。在 `initialize` 方法中，我们将监听 `token`
    事件。记住，当点击其中一个标记时，这个事件将在全局范围内触发。在这里，我们捕获这个事件并运行我们的 `add` 方法。`initialize` 方法中发生的另一件事是创建一个
    `currentTokens` 属性。这将跟踪用户在实际猜测之前选择的标记。在 `render` 方法中，我们将获取模板（在这种情况下，它只是一个字符串，因为在这个视图中没有模板数据），然后创建一个指向我们用作文本字段的
    `<div>` 元素的属性。这个属性在 `add` 方法中使用；该方法将 `Token` 模型作为参数。我们将缓存标记在 `currentTokens` 数组中，并将文本追加到元素中。
- en: 'Before we continue with this, let''s style it. You know where to go—the `style.css`
    file in the `public` directory:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们给它添加样式。你知道该去哪里——`public` 目录下的 `style.css` 文件：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Both the inside `<div>` elements have the class `btn`; we'll float them to the
    left and apply height, width, and coloring. Then, for the one with both the `btn`
    and `text` classes, we'll adjust the background color and width. When the actual
    button `<div>` is hovered over, we'll change the background color a bit, as buttons
    should do.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 两个内部的 `<div>` 元素都有 `btn` 类；我们将它们浮动到左边并应用高度、宽度和着色。然后，对于同时具有 `btn` 和 `text` 类的元素，我们将调整背景颜色和宽度。当实际的按钮
    `<div>` 被悬停时，我们将稍微改变背景颜色，因为按钮应该这样做。
- en: 'Now, let''s render this view. Back in the `index.ejs` file change the `getWords`
    callback one more time:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们渲染这个视图。回到 `index.ejs` 文件，再次更改 `getWords` 回调：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open this in the browser and click on a couple of tokens. You should see something
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开此页面并点击几个标记。你应该会看到类似这样的内容：
- en: '![Creating the guess view](img/6997OS_07_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![创建猜测视图](img/6997OS_07_04.jpg)'
- en: 'After playing with this, you should see two changes we need to make to this
    view. The big obvious one is that our **Guess** button doesn''t do anything. The
    smaller, design-related problem is that the red border of our `GuessView` class''s
    `<div>` element doesn''t change color when the button is hovered over. Since they''re
    the same color, this would be a nice touch. However, we can''t use CSS to change
    an attribute on a parent element when a child element is hovered over. Don''t
    worry, JavaScript is here to rescue the situation. Add these two events to the
    `GuessView` class''s events property:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩弄这个之后，你应该会看到我们需要对这个视图进行两个更改。一个明显的大问题是我们的 **Guess** 按钮没有任何作用。更小、与设计相关的问题是，我们的
    `GuessView` 类的 `<div>` 元素的红色边框在按钮被悬停时不会改变颜色。由于它们是相同的颜色，这将是一个很好的触感。然而，当子元素被悬停时，我们无法使用
    CSS 来更改父元素的属性。别担心，JavaScript 就在这里来拯救这个情况。将这些两个事件添加到 `GuessView` 类的事件属性中：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When the button receives the `mouseover` or `mouseout` event, we''ll call the
    `color` method. This method is really simple; all it does is toggle the `border`
    class on that parent element:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮接收到 `mouseover` 或 `mouseout` 事件时，我们将调用 `color` 方法。这个方法非常简单；它所做的只是切换那个父元素的
    `border` 类：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Of course, this means that we''ll have to add a `border` class to our CSS file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着我们不得不在我们的 CSS 文件中添加一个 `border` 类：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s focus on the more important problem; allowing the player to make
    an actual guess. We already have the `GuessView` class ready for the click on
    the **Guess** button. When this happens, we call the `guess` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注更重要的问题；允许玩家进行实际的猜测。我们已经有了准备好的 `GuessView` 类，用于点击 **Guess** 按钮。当这发生时，我们调用
    `guess` 方法：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first step is to check this word against the collection. We do this by calling
    the collection's `guess` method. We haven't written this yet, but it will return
    an object with two properties. The first is the `word` property. If the guess
    is a word in the collection, this property will be the `Word` model itself; otherwise,
    it will be `undefined`. If there is a `Word` model, we'll trigger the `correct`
    event, passing along the `Word` model. Remember, the `ClueView` instances are
    listening for this event. If `results.word` is `undefined`, this means the tokens
    did not spell one of the words, and they need to be replaced. So, we'll loop over
    the tokens and call the `show` method on the `view` property that we gave them
    when rendering those views. In either case, we'll empty the `currentTokens` property
    and clear the text from the `guessText` property. The last step is to check for
    a `complete` property on the `results` object. If this is `true`, the player just
    completed the last word and finished the game. If the game is done, we'll trigger
    a `completed` event, passing the game object as a parameter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检查这个单词是否在集合中。我们通过调用集合的`guess`方法来完成这个操作。我们还没有写这个，但它将返回一个具有两个属性的对象。第一个是`word`属性。如果猜测是集合中的单词，则此属性将是`Word`模型本身；否则，它将是`undefined`。如果有`Word`模型，我们将触发`correct`事件，传递`Word`模型。记住，`ClueView`实例正在监听此事件。如果`results.word`是`undefined`，这意味着标记没有拼出集合中的任何一个单词，需要替换。因此，我们将遍历标记并调用我们在渲染这些视图时给它们的`view`属性的`show`方法。在两种情况下，我们都会清空`currentTokens`属性并清除`guessText`属性的文本。最后一步是检查`results`对象上的`complete`属性。如果是`true`，则意味着玩家刚刚完成了最后一个单词并完成了游戏。如果游戏结束，我们将触发一个`completed`事件，并将游戏对象作为参数传递。
- en: 'The last step is to write the `Game` collection''s `guess` method. Back in
    the `models.js` file of the `public` directory, add this method to the `Game`
    class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是编写`Game`集合的`guess`方法。回到`public`目录下的`models.js`文件，将此方法添加到`Game`类中：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by creating a `results` object with the `word` and `complete` properties.
    The `complete` property will be `false` by default; for the `word` property, we
    will search the collection to find a word model that matches the text we passed
    into this method. The `findWhere` method will return `undefined` if no word is
    found. However, if a `Word` model is found, we'll give that model a temporary
    property. We'll set `correct` to `true`. Since the player has just guessed a word
    correctly, the next step is to update the score. We create a `score` variable;
    it starts with the basic `points` property on the `Word` model. Then, we need
    to calculate the multiplier. As we saw earlier, a `Game` instance will have a
    `seconds` property; soon, we'll see how this will count up.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个带有`word`和`complete`属性的`results`对象。默认情况下，`complete`属性将是`false`；对于`word`属性，我们将搜索集合以找到与传递给此方法的文本匹配的单词模型。如果找不到单词，`findWhere`方法将返回`undefined`。然而，如果找到一个`Word`模型，我们将给该模型一个临时属性。我们将`correct`设置为`true`。由于玩家刚刚正确猜了一个单词，下一步是更新分数。我们创建一个`score`变量；它从`Word`模型上的基本`points`属性开始。然后，我们需要计算乘数。如我们之前看到的，`Game`实例将有一个`seconds`属性；很快，我们将看到它是如何增加的。
- en: For now, we'll divide the seconds count by 15, round it with `parseInt`, and
    subtract it from 10\. Then, if that results in a number less than or equal to
    `0`, we'll reset `mult` to `1`. This way, any correct guesses in the first 15
    seconds will get a 10x multiplier, anything in the second 15 seconds will get
    a 9x multipler, and so on. After 2 minutes and 30 seconds, the multiplier will
    be 1\. Then, we'll increment the `score` property by the word `score` times the
    multiplier. Finally, we'll compare the number of words with the `correct` property
    to the total number of words in the collection. If these are equal, `results.complete`
    will be `true`, because all the words have been guessed correctly. Finally, we'll
    return the `results` object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将秒数除以15，用`parseInt`进行四舍五入，然后从10中减去。然后，如果结果是小于或等于`0`的数字，我们将`mult`重置为`1`。这样，前15秒内任何正确的猜测都将获得10倍乘数，第二15秒内的任何猜测将获得9倍乘数，依此类推。2分30秒后，乘数将是1。然后，我们将`score`属性增加单词`score`乘以乘数。最后，我们将`correct`属性的数量与集合中的总单词数进行比较。如果这些相等，`results.complete`将是`true`，因为所有单词都已被正确猜测。最后，我们将返回`results`对象。
- en: 'Now, with this in place, we can refresh the page and actually play our game.
    Go ahead, give it a whirl! Here''s what it should look like:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个，我们可以刷新页面并实际玩游戏。试试看！它应该看起来像这样：
- en: '![Creating the guess view](img/6997OS_07_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建猜测视图](img/6997OS_07_05.jpg)'
- en: Pretty impressive, don't you think? We can pretty much play our game. However,
    there are a lot of details to take care of. While we are playing the game here,
    we aren't actually keeping score yet. So that's the next step.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 非常令人印象深刻，不是吗？我们几乎可以玩我们的游戏了。然而，还有很多细节需要处理。当我们在这里玩游戏时，我们实际上还没有开始记分。所以这是下一步。
- en: Building the info view
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建信息视图
- en: 'The next class is for what we''ll call the `InfoView` class. This will have
    both the time counter and the current score. We''ll start with the template. Add
    this to the `index.ejs` file in the `views` directory: we''re creating two `<span>`
    elements: one for the time and another for the points. Here''s the code of the
    template:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类是我们将要称为`InfoView`的类。这将包括时间计数器和当前分数。我们从模板开始。将以下内容添加到`views`目录中的`index.ejs`文件：我们正在创建两个`<span>`元素：一个用于时间，另一个用于分数。以下是模板的代码：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, before we write the view class, we need to add a few more methods to our
    `Game` collection class. The `guess` method that we wrote earlier keeps track
    of the player''s score. We also want a `Game` instance to track the time. The
    counter will be inside the game instance, but the `InfoView` class will have to
    actually show the time. This is the `start` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们编写视图类之前，我们需要向我们的`Game`集合类添加几个更多的方法。我们之前写的`guess`方法跟踪玩家的分数。我们还想让`Game`实例跟踪时间。计数器将位于游戏实例内部，但`InfoView`类实际上需要显示时间。这就是`start`方法：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `start` method is what the `InfoView` class will use. It takes a `callback`
    function as a parameter and assigns it as a property of the instance. Then, it
    calls the `loop` method. This method increments the `seconds` count, and then
    calls the `callback` function, passing it the result of the `time` method (that''s
    next). Then, we''ll set a timeout for this method to be called again in one second;
    we have to bind `loop` to `this`, so the value of `this` will remain the same
    each time we call it. The `time` method just returns the `seconds` count as a
    nice timestamp:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`方法是`InfoView`类将使用的。它接受一个`callback`函数作为参数，并将其分配为实例的属性。然后，它调用`loop`方法。这个方法增加`seconds`计数，然后调用`callback`函数，传递`time`方法的结果（这是下一个）。然后，我们为这个方法设置一个超时，以便一秒后再次调用它；我们必须将`loop`绑定到`this`，这样每次调用时`this`的值都将保持不变。`time`方法只是返回`seconds`计数作为一个漂亮的时间戳：'
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It's pretty basic math. We can use the division and modulus operators, and the
    `parseInt` function, to create a time string. So, when the `seconds` count is
    42, the string will be "00:42"; 73 will be "01:13". If the time is over an hour
    (which is unlikely, but possible), we'll add the hour count to the front. This
    time, string is the value that will be passed to the callback.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常基础。我们可以使用除法和取模运算符，以及`parseInt`函数，来创建一个时间字符串。所以，当`seconds`计数为42时，字符串将是"00:42"；73将是"01:13"。如果时间超过一小时（这不太可能，但有可能），我们将小时计数添加到前面。这个字符串是传递给回调函数的值。
- en: 'Now, let''s look at the actual class. We''ll give the element the class `info`,
    and we''ll fetch the template. This is the code of the `InfoView` class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实际的类。我们将给元素分配`info`类，并获取模板。这是`InfoView`类的代码：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `render` method begins by using the template string, and then creating two
    properties for the timer element and the score element. Then, we call the `collection.start`
    method that we have just written. Remember that this method takes a callback that
    will receive the time string, so, we can just pass it the jQuery `text` method
    bound to our `this.time` element. This will now count the time for us.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法首先使用模板字符串，然后为计时器元素和分数元素创建两个属性。然后，我们调用我们刚刚编写的`collection.start`方法。记住，这个方法接受一个将接收时间字符串的回调函数，所以，我们可以直接传递绑定到我们的`this.time`元素的jQuery
    `text`方法。现在，这将为我们计时。'
- en: 'Before we look at the `initialize` method, let''s add a little bit of styling
    to this. Add this to the `style.css` file in the `public` directory:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`initialize`方法之前，让我们给这个添加一点样式。将以下内容添加到`public`目录中的`style.css`文件：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It''s nothing big; we just up the font size and add some margin. Now, add an
    `InfoView` instance to the quick and dirty test we''ve been using:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是什么大问题；我们只是增加了字体大小并添加了一些边距。现在，将一个`InfoView`实例添加到我们一直在使用的快速测试中：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Load this in the browser, and you should see something like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中加载这个，你应该会看到类似这样的内容：
- en: '![Building the info view](img/6997OS_07_06.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![构建信息视图](img/6997OS_07_06.jpg)'
- en: 'Now, in the `initialize` method, we listen for two application-wide events.
    When the player guesses a word correctly and the `correct` event is triggered,
    we''ll call the `updateScore` method. As you can see, this will set the text of
    the score element by using the `score` property that we''re updating on the collection
    object. The other event we''re listening for is the `completed` event, which will
    be triggered when the game is completed. When this happens, we call the `stop`
    method on the collection object. This method has two jobs to do. First, it must
    stop the timer, and secondly, it must log the game to the server. This is the
    last method to add to the `Game` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`initialize`方法中，我们监听两个应用程序级别的事件。当玩家猜对一个单词并触发`correct`事件时，我们将调用`updateScore`方法。正如你所见，这将通过在集合对象上更新的`score`属性来设置分数元素的文本。我们正在监听的另一个事件是`completed`事件，当游戏结束时将被触发。当发生这种情况时，我们在集合对象上调用`stop`方法。这个方法有两个任务要做。首先，它必须停止计时器，其次，它必须将游戏记录到服务器上。这是要添加到`Game`类的最后一个方法：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we create the timeout in the `loop` method, we assign it to the `this.timeout`
    property. In this `stop` method, we can clear the timeout to stop the timer. Then,
    we store the current game data to the server. Instead of doing this the Backbone
    way—by creating a model and using an instance of it to send the data to the server—we
    just use the `Backbone.ajax` method to POST this data to the server. If you''d
    rather use a model, it''s very simple. First, create the model class in your `models.js`
    file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`loop`方法中创建超时时，我们将它分配给`this.timeout`属性。在这个`stop`方法中，我们可以清除超时以停止计时器。然后，我们将当前游戏数据存储到服务器上。我们不会像Backbone那样做——通过创建一个模型并使用其实例将数据发送到服务器——我们只是使用`Backbone.ajax`方法将此数据POST到服务器。如果你更愿意使用模型，这非常简单。首先，在你的`models.js`文件中创建模型类：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, replace the `Backbone.ajax` call with a `GameInfo` instance:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`Backbone.ajax`调用替换为`GameInfo`实例：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''re not actually going to do it this way, because we don''t use the `GameInfo`
    class anywhere else. However, the beauty of these methods is that the server-side
    code is identical in both cases. Open the `server.js` file again, and add this
    router:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不会这样做，因为我们没有在任何其他地方使用`GameInfo`类。然而，这些方法的美丽之处在于，两种情况下的服务器端代码是相同的。再次打开`server.js`文件，并添加这个路由器：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we check to see that the user is logged in; we do this because we need
    the `req.user` object in this method, and we don't want to get an error. If a
    user is logged in, we'll put together a game object, with the time, score, and
    date that we sent from the browser. Then, we'll push that game object into the
    user's game array. You might recall that the user object has score and time properties
    of its own; these are for their highest score and lowest time. If the score or
    time from this game is better than the user's best, we'll update their best results.
    Finally, we'll store the updated record in the database. Of course, the last step
    is to return the game as JSON, but we won't really use that on the browser.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查用户是否已登录；我们这样做是因为我们需要这个方法中的`req.user`对象，我们不想得到错误。如果用户已登录，我们将组合一个游戏对象，包含从浏览器发送的时间、分数和日期。然后，我们将该游戏对象推入用户的游戏数组中。你可能还记得，用户对象有自己的分数和时间属性；这些是为他们的最高分和最低时间。如果这个游戏的分数或时间比用户的最好成绩好，我们将更新他们的最佳成绩。最后，我们将更新记录存储到数据库中。当然，最后一步是将游戏作为JSON返回，但我们实际上不会在浏览器上使用它。
- en: Wrapping our views in a GameView class
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的视图包裹在`GameView`类中
- en: 'At this point, for the user to play the game, we are rendering four views.
    Let''s wrap these views up into a single view: the `GameView` class. It is a pretty
    short view, but it will clean up the code in our router, once we start the router.
    Here''s the code for the `GameView` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，为了让用户玩游戏，我们正在渲染四个视图。让我们将这些视图组合成一个单一的视图：`GameView`类。这是一个相当简短的视图，但它将清理我们路由器中的代码。以下是`GameView`类的代码：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `render` method, we''ll create the four views, and append them to the
    element. We can test this view very easily—just replace the `callback` function
    code that creates the four views with this single line:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法中，我们将创建四个视图，并将它们附加到元素上。我们可以非常容易地测试这个视图——只需将创建四个视图的`callback`函数代码替换为这一行：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Nothing will look any different in the browser, and that's exactly what we want.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中看起来不会有任何不同，这正是我们想要的。
- en: Starting the router
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动路由器
- en: 'We''re finally ready to begin building the router. As you might recall from
    the `index.ejs` file in the `views` directory, we pull in a `router.js` script,
    and so, create a `router.js` file in the `public` directory. Let''s start with
    this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好开始构建路由器了。你可能还记得 `views` 目录中的 `index.ejs` 文件，我们引入了一个 `router.js` 脚本，因此，在
    `public` 目录中创建一个 `router.js` 文件。让我们从以下内容开始：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As in our previous applications, the `initialize` method will take an `options`
    object, which will set the main element for the application. In the `routes` object,
    you will see that we create two routes. To play the game, we can go to either
    `/play` or, say, `/play/2`: both routes call the `play` method. This method creates
    a `Game` collection object; if a level was selected via the route path, we''ll
    set it; otherwise, we''ll stick with the default level (level 1). Then, we can
    get the words and create the `GameView` instance once we have those words.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的应用程序一样，`initialize` 方法将接受一个 `options` 对象，这将设置应用程序的主要元素。在 `routes` 对象中，你会看到我们创建了两个路由。要玩游戏，我们可以访问
    `/play` 或者，比如说 `/play/2`：这两个路由都会调用 `play` 方法。这个方法创建一个 `Game` 集合对象；如果通过路由路径选择了某个等级，我们会设置它；否则，我们将保持默认等级（等级
    1）。然后，一旦我们有了这些单词，我们就可以获取单词并创建 `GameView` 实例。
- en: 'The next step is to get rid of our quick and dirty test and replace it with
    the use of our router. In the `index.ejs` file of the `views` directory, this
    is what the final script tag (the inline script) should look like:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是去掉我们的快速且简单的测试，并用我们的路由器来替换它。在 `views` 目录的 `index.ejs` 文件中，最终的脚本标签（内联脚本）应该看起来像这样：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, you can go back to the browser and try the routes `/play` or `/play/3`.
    You should be able to play the game just as before.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以回到浏览器中尝试 `/play` 或 `/play/3` 这两条路由。你应该能够像以前一样玩这个游戏。
- en: Creating the home view
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主页视图
- en: 'When a user first comes to our website, we don''t want to display the game
    view right away. Most web applications will have some kind of home view, or welcoming
    view, explaining the purpose of the application. We could make that a server-side
    template, but we''re going to make it a Backbone view instead. Here''s the code
    of the `HomeView` class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户第一次来到我们的网站时，我们不想立即显示游戏视图。大多数网络应用程序都会有一些主页视图，或者欢迎视图，解释应用程序的目的。我们可以将其作为一个服务器端模板，但我们将使用
    Backbone 视图。以下是 `HomeView` 类的代码：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We get the template with the `id` property of `home` from the `index.ejs` file.
    The `render` method is simple. The `events` object listens for clicks on anchor
    elements and calls the `chooseLevel` method. We''ve seen a method like this before;
    it just prevents the default action—the page refreshing—and uses `Backbone.history`
    to change the view instead. Finally, here''s the template for this view:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `index.ejs` 文件中获取具有 `home` 属性的模板。`render` 方法很简单。`events` 对象监听锚元素的点击，并调用
    `chooseLevel` 方法。我们之前已经见过这样的方法；它只是阻止默认操作——页面刷新——并使用 `Backbone.history` 来更改视图。最后，这是这个视图的模板：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s style the `<h1>` elements a little bit. You know where this goes—in
    the `style.css` file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微样式化一下 `<h1>` 元素。你知道在哪里——在 `style.css` 文件中：
- en: '[PRE54]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we need to use this view in the router. Open the `router.js` file in the
    `public` directory and add the `index` route:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在路由器中使用这个视图。打开 `public` 目录中的 `router.js` 文件，并添加 `index` 路由：
- en: '[PRE55]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we''ll add the `index` function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加 `index` 函数：
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, you should be able to go to the root route and see this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够访问根路由并看到这个：
- en: '![Creating the home view](img/6997OS_07_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![创建主页视图](img/6997OS_07_07.jpg)'
- en: Building a scoreboard
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建分数板
- en: 'We''ve already built the primary view for this application. However, every
    complete web application will have several views that aren''t specific to the
    main purpose of the application, but help round out its usefulness. In our application,
    this will be a scoreboard view; a place where players can see each other''s best
    time and score. Let''s start on the server side this time, in the `server.js`
    file. Add this route before the catch-all route:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为这个应用程序构建了主要视图。然而，每个完整的网络应用程序都将有几个视图，这些视图并不特定于应用程序的主要目的，但有助于完善其有用性。在我们的应用程序中，这将是一个分数板视图；一个玩家可以看到彼此的最佳时间和分数的地方。让我们这次从服务器端开始，在
    `server.js` 文件中。在通配符路由之前添加这个路由：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We start by getting all the users in the database. Then, we loop over each user,
    adding a `totalScore` property to each one. We loop over the `games` array for
    each user and sum up the score for each game, creating the `totalScore` property.
    Note that we don't actually change anything in the database; we just create a
    temporary property here. Then, we sort the `userRecords` array; by default, the
    array's `sort` method will sort alphabetically, so we pass a function here that
    sorts the users from highest- to lowest-scoring. Then, we'll render the `scoreboard.ejs`
    template in the `views` directory, passing it the `userRecords` object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取数据库中的所有用户。然后，我们遍历每个用户，为每个用户添加一个`totalScore`属性。我们遍历每个用户的`games`数组，并为每个游戏累加得分，创建`totalScore`属性。注意，我们实际上没有在数据库中更改任何东西；我们只是在本地创建了一个临时属性。然后，我们排序`userRecords`数组；默认情况下，数组的`sort`方法将按字母顺序排序，所以我们在这里传递一个函数来按得分从高到低排序用户。然后，我们将渲染`views`目录中的`scoreboard.ejs`模板，并传递`userRecords`对象。
- en: 'Here is the code of the `scoreboard.ejs` template:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`scoreboard.ejs`模板的代码：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As with our other full-page templates, we''ll open and close with the header
    and footer includes. Then, we''ll create the main element. This element has a
    table element inside it. We start with a `<thead>` element, with four column headers:
    the player''s name, total score, best game score, and best time. Then, inside
    the `<tbody>` element, we loop over the `user` array and add a row for each user.
    We use one of the EJS''s features here: filters. For example, we print the `user.username`
    property, but we filter it through the `capitalize` filter so that the first letter
    will be, you guessed it, capitalized. Then, the `user.time` property is a seconds
    count, so we filter it through the `time` filter to display it as a human-friendly
    string. However, this isn''t a built-in filter, so we''ll have to write it ourselves.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的其他全页模板一样，我们将使用页眉和页脚包含文件来打开和关闭。然后，我们将创建主要元素。这个元素内部有一个表格元素。我们从一个`<thead>`元素开始，包含四个列标题：玩家的名字、总分、最佳游戏得分和最佳时间。然后，在`<tbody>`元素内部，我们遍历`user`数组，并为每个用户添加一行。在这里，我们使用了EJS的一个特性：过滤器。例如，我们打印`user.username`属性，但通过`capitalize`过滤器过滤它，所以第一个字母将会是大写的。然后，`user.time`属性是一个秒数，所以我们通过`time`过滤器过滤它，以显示一个对人类友好的字符串。然而，这不是一个内置的过滤器，所以我们将不得不自己编写它。
- en: 'Back in the `server.js` file, we first require the `ejs` library that Express
    uses behind the scenes:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`文件中，我们首先需要Express在幕后使用的`ejs`库：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, we have to write the filter function. We can actually just copy and adjust
    the time method from the `Game` class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须编写过滤器函数。实际上，我们只需复制并调整`Game`类中的时间方法即可：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The last step for the scoreboard is to add some styling to the user''s table.
    Once again, turn to the `style.css` file in the `public` directory:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 计分板的最后一步是为用户的表格添加一些样式。再次回到`public`目录中的`style.css`文件：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It''s nothing too fancy, but it will do the job. We''ll add some padding and
    color the background, and we''re done! Here''s the final product:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它并不复杂，但能完成工作。我们将添加一些填充并着色背景，然后完成！这是最终产品：
- en: '![Building a scoreboard](img/6997OS_07_08.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![构建计分板](img/6997OS_07_08.jpg)'
- en: Writing the navigation
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写导航
- en: 'The next part of our application will pull things together; it is the navigation
    bar. In previous applications, the navigation has been its own Backbone view,
    but this is not the case this time. Instead, we''ll create a new server-side template
    just for navigation. We''ll be able to use this as an include, as we did with
    the header and footer templates. So, create the `nav.ejs` file in the `views`
    directory and put the following code in it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的下一部分将整合所有内容；它是导航栏。在之前的程序中，导航是其自己的Backbone视图，但这次不是这样。相反，我们将创建一个专门用于导航的新服务器端模板。我们将能够像使用页眉和页脚模板一样使用它。所以，在`views`目录中创建一个`nav.ejs`文件，并将以下代码放入其中：
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It''s a basic list; there isn''t much navigating to do in our application.
    But of course, we''ll need to add some styling. Here''s the last addition to the
    `style.css` file in the `public` directory:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的列表；在我们的应用程序中不需要做太多的导航。但当然，我们需要添加一些样式。这是`public`目录中`style.css`文件的最后一次添加：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This styling creates a nice navigation bar at the top of the page, with a nice
    hover effect on each link. The last part adds a color to the first item to make
    it appear like a logo. Now, add this as an include, under the header include of
    both the `index.ejs` and `scoreboard.ejs` files, like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种样式在页面顶部创建了一个漂亮的导航栏，每个链接都有漂亮的悬停效果。最后一部分给第一个项目添加了颜色，使其看起来像标志。现在，将其作为包含项添加到`index.ejs`和`scoreboard.ejs`文件的头包含项下，如下所示：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'That''s it! Here''s what it looks like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！下面是它的样子：
- en: '![Writing the navigation](img/6997OS_07_09.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![编写导航](img/6997OS_07_09.jpg)'
- en: Adding new words
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新单词
- en: 'Let''s add one more feature to our application; the ability to add new words
    to the word list. We won''t allow just any user to do this, only administrators.
    How exactly can we make a user an administrator? Well, we''ll cheat. Open the
    `users.json` file directly, and add an `"admin":true` property to the user object
    of our choice. Then, we''ll open the `server.js` file; first is the GET route
    for `/new`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的应用程序添加一个新功能；将新单词添加到单词列表中的能力。我们不会允许任何用户这样做，只有管理员。我们如何将用户变成管理员呢？嗯，我们将作弊。直接打开`users.json`文件，并为我们选择的用户对象添加一个`"admin":true`属性。然后，我们将打开`server.js`文件；首先是`/new`的GET路由：
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If there''s a user logged in, and that user is an administrator, then we''ll
    render the new word template. Otherwise, we''ll redirect to the root route. Create
    the `new.ejs` file in the `views` directory, and write this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有用户登录，并且该用户是管理员，那么我们将渲染新单词模板。否则，我们将重定向到根路由。在`views`目录中创建`new.ejs`文件，并写入以下内容：
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We will post to the `/new` route when the form is submitted. We have an input
    element for the word and its definition (we could use a text area here, but an
    input element will encourage a short definition). Then, we have a set of radio
    buttons for choosing the level. Since this will post to the same route, we need
    a POST route on the server side to catch the new word:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，我们将发布到`/new`路由。我们有一个用于单词及其定义的输入元素（我们在这里可以使用文本区域，但输入元素将鼓励简短的定义）。然后，我们有一组单选按钮用于选择难度级别。由于这将发布到相同的路由，我们需要在服务器端创建一个POST路由来捕获新单词：
- en: '[PRE67]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If there's an admin user logged in, we'll create a word object, `w`. Then, we'll
    check the word's database to see if the word already exists; if it doesn't, we'll
    insert it. Finally, we'll return to the form so that the administrator can insert
    another word if they want to.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有管理员用户登录，我们将创建一个单词对象`w`。然后，我们将检查单词数据库以查看单词是否已存在；如果不存在，我们将插入它。最后，我们将返回到表单，以便管理员可以插入另一个单词（如果他们想的话）。
- en: 'Finally, let''s add this path to the navigation, but only when an administrator
    is logged in. In the `nav.ejs` file of the `views` directory, add this as the
    last list item:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将此路径添加到导航中，但仅当管理员登录时。在`views`目录的`nav.ejs`文件中，将其作为最后一个列表项添加：
- en: '[PRE68]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, everywhere we call the `res.render` function on the templates that use
    `nav.ejs` (that''s `new.ejs`, `scoreboard.ejs`, and `index.ejs`), we add the `admin`
    value to the values passed to the template. For example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在调用`res.render`函数的所有模板中，我们使用`nav.ejs`（这是`new.ejs`、`scoreboard.ejs`和`index.ejs`），将`admin`值添加到传递给模板的值中。例如：
- en: '[PRE69]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If a user is logged in and they are an administrator, admin will be `true`.
    Otherwise, it will be `false`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户登录并且他们是管理员，则`admin`将为`true`。否则，它将为`false`。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This brings us to the end of the last chapter. The first big idea we looked
    at in this chapter is not loading any application data with the initial page load.
    If your application uses a lot of data, this can often be a good idea. Not only
    does this shorten the initial page load, but it also prevents you from loading
    data that the user doesn't need (for example, if the user never uses a specific
    feature of the application, the data needed for that feature never loads).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了上一章的结尾。在本章中，我们首先探讨的大想法是在初始页面加载时不加载任何应用程序数据。如果你的应用程序使用大量数据，这通常是一个好主意。这不仅缩短了初始页面加载时间，而且还可以防止你加载用户不需要的数据（例如，如果用户从未使用应用程序的特定功能，该功能所需的数据永远不会加载）。
- en: 'The other thing to remember from this chapter is that a Backbone application
    may not be just Backbone pages. Our scoreboard page is a good example of this.
    It wouldn''t have been difficult to create that page via Backbone—just create
    a `User` model and a `Users` collection and a couple of views—but since the user
    records don''t really have any client-side relevance, apart from being logged
    in, we took the simpler route of doing it from the server side. Your web app will
    likely have other pages too that don''t need data: a contact page, an FAQ page,
    that kind of thing. Don''t forget about these details!'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要记住的另一件事是，Backbone应用程序可能不仅仅是Backbone页面。我们的得分板页面就是这样一个很好的例子。通过Backbone创建这个页面并不困难——只需创建一个`User`模型、一个`Users`集合和几个视图即可——但由于用户记录除了登录之外在客户端实际上没有任何相关性，所以我们选择了从服务器端进行更简单的实现方式。你的Web应用程序可能还有其他不需要数据的页面：比如联系页面、常见问题解答页面等。不要忘记这些细节！
- en: Most of what we've covered in this chapter is a review of the primary ways of
    using Backbone's main components, the model, the collection, the view, and the
    router. As with anything, the beauty of having a complete understanding of the
    way something works is that you are then free to bend it in whatever way you choose.
    Throughout this book, we look at several different ways of doing almost anything
    in Backbone. If you take only one thing away from it all, let it be this; it's
    just JavaScript, and there are countless other ways not mentioned here to create
    patterns of your own. It could be said that programming is just as much about
    self-expression as anything else, and a skilled programmer isn't afraid to experiment.
    Here's just one example for the road. What if the `initialize` method of a view
    class ended by calling the `render` method? Have fun with your Backbone applications!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所涵盖的大部分内容是对Backbone主要组件（模型、集合、视图和路由器）的初级使用方法的回顾。就像任何事物一样，完全理解某物的工作方式的美妙之处在于你可以自由地以任何你选择的方式去调整它。在这本书的整个过程中，我们探讨了在Backbone中几乎做任何事情的不同方法。如果你只能从中带走一样东西，让它成为这一点；这只是JavaScript，而且有无数其他未提及的方式来创建你自己的模式。可以说，编程就像自我表达一样重要，一个熟练的程序员不会害怕去实验。这里就举一个例子。如果一个视图类的`initialize`方法以调用`render`方法结束会怎样？享受你的Backbone应用程序吧！
