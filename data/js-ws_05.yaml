- en: 5\. Beyond the Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 超越基础
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to identify the difference between
    JavaScript's mutable and immutable types; manipulate each of the built-in data
    types confidently; convert data from one type to another; format data types for
    presentation; and differentiate between an expression and a statement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够识别JavaScript的可变和不可变类型之间的区别；自信地操作每个内置数据类型；将数据从一种类型转换为另一种类型；格式化数据类型以供展示；以及区分表达式和语句。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you were given a tour of JavaScript, its runtimes,
    and its history. Using a high-level topography, that chapter will have given you
    an idea as to what JavaScript is, what it can do, and its ubiquity within the
    internet software development industry.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您被带上了对JavaScript、其运行时和历史的游览。通过高级概览，那一章应该已经让您对JavaScript是什么、它能做什么以及它在互联网软件开发行业中的普遍性有了大致的了解。
- en: Understanding code can be difficult for beginners. JavaScript is no exception.
    Its flexibility, extensive language syntax, and varying coding patterns can prove
    daunting to the uninitiated.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，理解代码可能很困难。JavaScript也不例外。它的灵活性、广泛的语言语法和不同的编码模式可能会让初学者感到难以应对。
- en: This chapter will take you a step closer to writing your own software applications
    in JavaScript. By explaining the fundamentals, you will be empowered to not only
    understand what scripts do, but how to reason about problems using JavaScript
    syntax.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您更接近于用JavaScript编写自己的软件应用程序。通过解释基础知识，您将能够不仅理解脚本做什么，而且如何使用JavaScript语法进行问题推理。
- en: 'In this chapter, you will take a close look at JavaScript''s type system. All
    programming languages have a type system. Types literally dictate the type of
    data stored in a variable or function parameter. Types are typically separated
    into two categories: **primitive** and **complex** types.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将仔细研究JavaScript的类型系统。所有编程语言都有类型系统。类型实际上决定了变量或函数参数中存储的数据类型。类型通常分为两类：**原始**类型和**复杂数据类型**。
- en: In JavaScript, all primitive data types are immutable. This means that the value
    cannot be changed in memory. New values can be assigned to a variable, but the
    underlying data stored in memory cannot be modified directly. This differs from
    the case in languages such as C++, where values can be directly altered in memory
    using pointers and helper functions. In JavaScript, when passing a primitive value
    from one variable to another, the data is copied in memory to the new variable.
    Therefore, updating one variable does not affect the other.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，所有原始数据类型都是不可变的。这意味着值在内存中不能被改变。可以给变量分配新值，但存储在内存中的底层数据不能直接修改。这与C++等语言的情况不同，在这些语言中，可以使用指针和辅助函数直接在内存中更改值。在JavaScript中，当从一个变量传递原始值到另一个变量时，数据会在内存中复制到新变量。因此，更新一个变量不会影响另一个变量。
- en: Complex data types work differently. They are also known as reference types.
    Reference types include the **Object** type and all of its derivatives, such as
    **Array**, **Date**, and **Function**. All reference types are passed by reference,
    hence the name. Therefore, if an object is modified through one reference, all
    the other references that share the same object will see it as updated too, since
    all of the references point to the same data in memory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂数据类型的工作方式不同。它们也被称为引用类型。引用类型包括**Object**类型及其所有派生类型，例如**Array**、**Date**和**Function**。所有引用类型都是通过引用传递的，因此得名。因此，如果一个对象通过一个引用被修改，所有共享相同对象的其它引用也会看到它被更新，因为所有的引用都指向内存中的相同数据。
- en: A complex type is simply a type that has more functionality than a primitive.
    For instance, a `Date` value provides additional means of representation, while
    objects can contain many nested values, such as primitives and other complex types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂数据类型简单来说就是比原始类型具有更多功能的类型。例如，`Date`值提供了额外的表示方式，而对象可以包含许多嵌套值，例如原始类型和其他复杂数据类型。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Function types will not be explained in detail in this chapter and will instead
    be covered in a later chapter when prototypes are introduced.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型在本章中不会详细解释，而是在介绍原型时将在后面的章节中介绍。
- en: All primitives, and preexisting reference types are known as built-in data types.
    Each of these types has a corresponding object that provides functions for manipulating
    that type. These functions may be applied externally to data by passing the value
    as a parameter to a function, or they may be applied by calling the function as
    if it were a method of that type. The latter is also applicable to several primitives,
    despite them not existing as literal objects within the JavaScript type system.
    However, this is made possible through the syntactical context of the data. More
    will be explained about this feature throughout this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始类型和现有的引用类型都被称为内置数据类型。每种类型都有一个相应的对象，该对象提供用于操作该类型的函数。这些函数可以通过将值作为参数传递给函数来应用于外部数据，或者可以通过将函数作为该类型的成员方法来调用。后者也适用于几个原始类型，尽管它们在JavaScript类型系统中不是作为字面对象存在的。然而，这是通过数据的语法上下文实现的。关于这一特性将在本章中进一步解释。
- en: Creating Variables
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建变量
- en: Variable creation is the means to assign a value to a symbol. In this circumstance,
    a symbol is a textual representation of the data, much like a container, which
    can be used to move data through your program. It also improves the legibility
    of your code. There are multiple ways to create variables, including assignment
    to the global scope or through the use of either the `var`, `let`, or `const`
    keywords.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 变量创建是将值赋给符号的手段。在这种情况下，符号是数据的文本表示，类似于一个容器，可以用来在程序中移动数据。它也提高了代码的可读性。创建变量的方式有多种，包括对全局作用域的赋值或使用`var`、`let`或`const`关键字。
- en: A Note on Referencing
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于引用的说明
- en: Even at this early stage, it must be highlighted that JavaScript's referencing
    functionality can get rather confusing. The presence of `closures`, `prototypes`,
    `global` and `local memory stacks`, `variable assignment variations`, and `function
    invocation options` can leave even seasoned programmers scratching their heads.
    Each of the aforementioned features supports JavaScript as a formidable and flexible
    programming language that's able to challenge most other platforms for almost
    any purpose. While it does deepen JavaScript's learning curve, mastering these
    concepts can be extremely rewarding.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个早期阶段，也必须强调JavaScript的引用功能可能会相当令人困惑。存在`闭包`、`原型`、`全局`和`局部内存栈`、`变量赋值变体`以及`函数调用选项`，这些都可能让经验丰富的程序员感到困惑。上述所有功能都支持JavaScript成为一个强大且灵活的编程语言，几乎可以挑战其他大多数平台用于任何目的。虽然这确实加深了JavaScript的学习曲线，但掌握这些概念可以带来极大的回报。
- en: This chapter highlights the very basics of data referencing and attempts to
    not confuse matters any more than necessary. Only referencing with regard to data
    at the global level will be discussed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章强调了数据引用的非常基础的知识，并试图尽可能不使问题复杂化。只讨论与全局级别数据相关的引用。
- en: Global Assignment
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局赋值
- en: Assigning a variable without the use of `var`, `let`, or `const` will place
    the variable into the global scope. This value will then be accessible anywhere
    in your application unless a variable of the same name exists within that scope.
    Redeclaring the same variable name without the use of a preceding keyword will
    overwrite the global reference, even if it's assigned within a different scope.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`var`、`let`或`const`来赋值变量将变量放入全局作用域。此值将在应用程序的任何地方都可以访问，除非该作用域中存在同名的变量。不使用前缀关键字重新声明相同的变量名将覆盖全局引用，即使它是在不同的作用域中赋值的。
- en: Declaring globally in a browser environment is equivalent to declaring the value
    on the global window object as a field.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器环境中全局声明相当于在全局window对象上声明一个字段。
- en: Declaring with var
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`var`声明
- en: Preceding variable assignment with the `var` keyword places the variable into
    function scope. This means the variable only exists at the same function as the
    assignment, but not outside that function. Declaring with `var` in the global
    scope is equivalent to declaring without the `var` keyword.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量赋值前加上`var`关键字将变量放入函数作用域。这意味着变量只存在于赋值所在的函数中，而不在该函数之外。在全局作用域中使用`var`声明等同于不使用`var`关键字声明。
- en: Redeclaring a variable with `var`, but in a nested scope, will not overwrite
    the variable of the same name in the outer scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`重新声明变量，但在嵌套作用域中，不会覆盖外部作用域中同名的变量。
- en: Using the `var` keyword, variables can be scoped (declared) even after they
    are used within the same scope. This is due to variable hoisting. Hoisting was
    explained in *Chapter 4*, JavaScript Libraries and Framework*s*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 关键字，变量可以在它们在同一作用域内使用之后进行作用域（声明）。这是由于变量提升。提升在 *第4章*，JavaScript库和框架中进行了解释。
- en: Declaring with let
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `let` 声明
- en: The `let` keyword has a narrower scope. While `var` is considered to be functionally
    scoped, the `let` keyword is block scoped. This means that variables that are
    created with `var` exist throughout a function's scope level, while let-declared
    variables are created and used at the block level, such as in `if` conditional
    blocks or `for` loops.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 关键字的作用域更窄。虽然 `var` 被认为是函数作用域，但 `let` 关键字是块作用域。这意味着使用 `var` 创建的变量在整个函数作用域级别存在，而使用
    `let` 声明的变量在块级别创建和使用，例如在 `if` 条件块或 `for` 循环中。'
- en: 'For example, using `let`, a variable can be temporarily overwritten within
    a `for loop` while not changing a variable of the same name in the outer function.
    However, if `var` is used instead, the outer variable will be changed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `let`，可以在 `for` 循环内临时覆盖变量，而不会改变外部函数中具有相同名称的变量。然而，如果使用 `var`，则外部变量将被更改：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, the variable declared in the `for loop` matches the
    symbol declared outside of it. As such, the same variable reference is modified.
    However, in the following example, the result is different, as the let-declared
    variable only exists within the context of the for loop, meaning the outside variable
    of the same name is left untouched:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`for` 循环中声明的变量与外部声明的符号匹配。因此，相同的变量引用被修改。然而，在下面的示例中，结果不同，因为 `let` 声明的变量仅存在于
    `for` 循环的上下文中，这意味着相同名称的外部变量保持不变：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Contrary to `var`, let-declared variables are not hoisted. If a scope declares
    a variable with `let`, accessing that variable before that let declaration statement
    (within the same scope or in any inner scope) will raise an error (this is regardless
    of whether a variable with the same name has been created in an outer scope):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `var` 不同，`let` 声明的变量不会被提升。如果一个作用域使用 `let` 声明了一个变量，那么在 `let` 声明语句之前（在同一作用域或任何内部作用域）访问该变量将引发错误（这无论外部作用域中是否已创建了具有相同名称的变量）：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Declaring with const
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `const` 声明
- en: The `const` keyword works with the same scoping and hoisting rules as the `let`
    keyword. The difference with `const` is that it is assumed the variable will not
    change throughout its lifetime. Using `const` allows the JavaScript engine to
    make certain optimizations at compile time since it expects the data to remain
    constant at runtime.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 关键字与 `let` 关键字具有相同的作用域和提升规则。与 `const` 的区别在于，它假定变量在其整个生命周期内不会改变。使用 `const`
    允许JavaScript引擎在编译时进行某些优化，因为它期望在运行时数据保持不变。'
- en: It is possible to create a new variable assignment with the same name in a nested
    function scope, but it will not be possible to modify a variable of the same name
    using global scoping rules.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套函数作用域中，可以创建具有相同名称的新变量赋值，但使用全局作用域规则将无法修改具有相同名称的变量。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Declaring a variable with var or let, but without assigning a value, will result
    in the variable containing `undefined`. The undefined value will be covered a
    little later in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 或 `let` 声明变量，但未分配值，将导致变量包含 `undefined`。将在本章稍后介绍 `undefined` 值。
- en: 'Exercise 5.01: Variables and Scope'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.01：变量和作用域
- en: 'In this exercise, we will use the browser''s JavaScript **Read-Eval-Print Loop**
    (**REPL**) to experiment with variable assignment and scope. Let''s get started:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用浏览器的JavaScript **读取-评估-打印循环**（**REPL**）来实验变量赋值和作用域。让我们开始吧：
- en: Launch your browser and open the developer tools console. In Chrome, you can
    do this by pressing the *F12* key.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的浏览器并打开开发者工具控制台。在Chrome中，您可以通过按 *F12* 键来完成此操作。
- en: 'Ensure the `Console` tab is selected:![Figure 5.1: The Console tab'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已选择 `Console` 选项卡：![图 5.1：控制台选项卡
- en: '](img/C14377_05_01.jpg)'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 C14377_05_01.jpg](img/C14377_05_01.jpg)'
- en: 'Figure 5.1: The Console tab'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.1：控制台选项卡
- en: 'At the `prompt`, enter the following commands, pressing *Enter* at the end
    of each line:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `prompt` 中输入以下命令，每行输入后按 *Enter* 键：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `console.log` command writes the value of `i` to the console.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`console.log` 命令将 `i` 的值写入控制台。'
- en: 'Next, create a function that also initializes a variable of the same name,
    as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个函数，该函数也初始化具有相同名称的变量，如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Invoke the function to print the variable that exists within the function scope.
    If you then print the global variable, you will see it has not been modified:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用函数以打印函数作用域内存在的变量。如果您然后打印全局变量，您将看到它没有被修改：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, try the `let` keyword:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试使用 `let` 关键字：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `let` assignment only exists for the lifetime of the block
    that follows the if statement.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，`let` 赋值仅存在于 if 语句之后的代码块的生命周期内。
- en: 'Close the browser tab. Open a new tab and open the console again (otherwise,
    you won''t be able to re-assign `i` as a variable). Now, try the same with `var`.
    You will see that the variable declaration raises an error because it conflicts
    with the `i` variable outside of the conditional block:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器标签页。打开一个新的标签页并再次打开控制台（否则，您将无法重新分配 `i` 作为变量）。现在，尝试使用 `var`。您将看到变量声明引发了错误，因为它与条件块外的
    `i` 变量冲突：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Figure 5.2: Exercise 5.01 output'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.2：练习 5.01 输出'
- en: '](img/C14377_05_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_02.jpg)'
- en: 'Figure 5.2: Exercise 5.01 output'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：练习 5.01 输出
- en: Understanding the scope surrounding a variable is important for the correct
    execution of your application, as well as for minimizing bugs. Try to keep a mental
    note of the positioning and use of each variable as you work. Utilizing functional
    paradigms, as discussed in *Chapter 13*, *JavaScript Programming Paradigms*, will
    also help alleviate any discrepancies in variable scoping.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 理解变量周围的范围对于正确执行您的应用程序以及最小化错误非常重要。在工作过程中，尽量在心中记住每个变量的位置和使用情况。利用第 13 章中讨论的函数范式，*JavaScript
    编程范式*，也将有助于缓解变量作用域中的任何差异。
- en: Identifying a Variable's Type
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别变量的类型
- en: So far, you have created variables and output their value to the browser's console.
    In order to get the most out of the content of this chapter, however, it would
    be helpful to be able to identify the content of a variable. JavaScript is known
    as a weakly typed language because a variable can hold a `string` one moment,
    but then an `integer` the
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了变量并将它们的值输出到浏览器的控制台。然而，为了充分利用本章的内容，能够识别变量的内容将非常有帮助。JavaScript 被称为弱类型语言，因为一个变量可以在某一刻持有
    `string`，然后又变成 `integer`。
- en: next. By being able to identify the type of value stored in a variable, you
    prevent errors occurring where you attempt to process a value you expected to
    be of a different type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个。通过能够识别变量中存储的值的类型，您可以防止尝试处理预期为不同类型的值时发生错误。
- en: The `typeof` keyword exists to do just that. By preceding a variable with the
    `typeof` keyword, the returned value is the type of the variable represented as
    a `string`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 关键字就是为了做这件事。通过在变量前加上 `typeof` 关键字，返回的值是表示为 `string` 的变量类型。'
- en: 'The `typeof` keyword evaluates with the following type mapping:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 关键字使用以下类型映射进行评估：'
- en: '![Figure 5.3: Types and responses'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3：类型和响应'
- en: '](img/C14377_05_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_03.jpg)'
- en: 'Figure 5.3: Types and responses'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：类型和响应
- en: 'The `null` type evaluates as "`object`". This anomaly originates from the earliest
    incarnations of JavaScript where data types were tagged internally with an integer
    value. Object types were tagged with 0, while the `null` value existed as a `null
    pointer` (or `0x00` as a value). As the two expressions were identical, determining
    the type of `null` resulted in the same type as Object. This same anomaly still
    exists in JavaScript today. Therefore, when determining whether a type is an Object,
    we must also compare it with `null`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 类型评估为 "`对象`"。这种异常源于 JavaScript 的早期版本，其中数据类型被内部标记为整数值。对象类型被标记为 0，而 `null`
    值存在为一个 `null 指针`（或 `0x00` 作为值）。由于这两个表达式相同，确定 `null` 的类型导致了与对象相同的类型。这种相同的异常至今仍然存在于
    JavaScript 中。因此，在确定一个类型是否为对象时，我们还需要将其与 `null` 进行比较：'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Exercise 5.02: Evaluating Types from Variables'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.02：从变量中评估类型
- en: 'In this exercise, we will create a function that outputs the type of whatever
    variable is passed to it. Let''s get started:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，该函数输出传递给它的任何变量的类型。让我们开始吧：
- en: 'At the command prompt, enter the following line to declare the function signature:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中，输入以下行以声明函数签名：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function accepts a single variable, which will be the variable to analyze.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数接受一个变量，该变量将被用作分析变量。
- en: 'Due to the Null value caveat, you must check for this, first. Here, compare
    `val` to `Null` and output the appropriate message. If the value is indeed `Null`,
    then the function must be returned so that no further comparisons can be made:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于存在 `Null` 值的注意事项，你必须首先检查这一点。在这里，比较 `val` 与 `Null` 并输出相应的信息。如果值确实是 `Null`，那么函数必须返回，以便不再进行比较：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you are comparing `val` to `Null` and outputting the appropriate message.
    If the value is indeed `Null`, then the function must be returned so that no further
    comparisons can be made.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你正在比较 `val` 与 `Null` 并输出相应的信息。如果值确实是 `Null`，那么函数必须返回，以便不再进行比较。
- en: 'If the value is `not Null`, then you can safely return the type of the value
    itself:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值不是 `Null`，那么你可以安全地返回值的类型本身：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`console.log(...)` will output however many values are passed into it and concatenate
    them onto the same line. Here, you output the generic message but then concatenate
    it with the type of the variable. Since no value is required to be passed from
    this function, and as there is no more logic to perform, no return statement is
    required to close out the function.'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`console.log(...)` 将输出传递给它的任何值，并将它们连接到同一行。在这里，你输出一个通用信息，但随后将其与变量的类型连接起来。由于不需要从这个函数传递任何值，并且没有更多的逻辑要执行，因此不需要返回语句来关闭函数。'
- en: 'To test this function, execute it in the console with different values:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这个函数，请在控制台中用不同的值执行它：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code will result in the following output:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Figure 5.4: Exercise 5.02 output'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：练习 5.02 输出'
- en: '](img/C14377_05_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：练习 5.02 输出](img/C14377_05_04.jpg)'
- en: 'Figure 5.4: Exercise 5.02 output'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：练习 5.02 输出
- en: The function you have just created is rather light in terms of introspection.
    It essentially enables you to determine the general type of a passed in value,
    but it isn't powerful enough to differentiate object types, including JavaScript's
    built-in objects. Whether you pass in a `Date` or an `Array`, you will get the
    same output.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建的函数在自我检查方面相当轻量。它本质上使你能够确定传入值的通用类型，但它不足以区分对象类型，包括 JavaScript 的内置对象。无论你传入一个
    `Date` 或一个 `Array`，你都会得到相同的输出。
- en: You will discover how to be more thorough in determining data types later in
    this module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本模块的后面部分发现如何更彻底地确定数据类型。
- en: Fixed Types
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定类型
- en: Fixed types are types that have no variation of value. Unlike numbers, which
    may have any combination of digits, an optional minus sign (for negative numbers),
    a decimal point, or a scientific notation, a fixed type is always one simple value
    or value group.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 固定类型是没有值变化的类型。与数字不同，数字可以有任何数字组合，可选的负号（用于负数），小数点或科学记数法，固定类型始终是一个简单的值或值组。
- en: In JavaScript, the available fixed types include `null`, `undefined`, and `Booleans`
    (`true` and `false`). These values are `static` and cannot change. If a variable
    contains one of these values, it is then strictly equal to the value itself. Fixed
    types are more of a representation of a situation than actual data. For instance,
    `true` is a fixed representation of truthfulness and `false` is a fixed representation
    of falsehood. The values are not quantifiable in the real world but are representative
    of logic that software directly deals with.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，可用的固定类型包括 `null`、`undefined` 和 `Booleans`（`true` 和 `false`）。这些值是静态的，不能改变。如果一个变量包含这些值之一，那么它就严格等于该值本身。固定类型更多的是一种情况的表示，而不是实际的数据。例如，`true`
    是真实性的固定表示，而 `false` 是虚假性的固定表示。这些值在现实世界中是不可量化的，但它们代表了软件直接处理的逻辑。
- en: The null Value
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`null` 的值'
- en: '`null`, in mathematical terms, denotes a value that is not present. In JavaScript,
    `null` is a static value that''s used to mean no value. In other languages, this
    would be equivalent to nil or void.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学术语中，`null` 表示一个不存在的值。在 JavaScript 中，`null` 是一个静态值，用来表示没有值。在其他语言中，这相当于 nil
    或 void。
- en: '`null` is a useful value for dereferencing variables or for returning a value
    from a function when no value can be returned. For instance, a function may return
    an object from an array if the item is present but may return `null` if it is
    not.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 是一个有用的值，用于取消引用变量或在没有值可以返回时从函数返回值。例如，一个函数可能从数组中返回一个对象，如果项目存在，但如果没有，则返回
    `null`。'
- en: The undefined Value
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未定义的值
- en: '`undefined` is similar to `null` in many ways and, due to this, the two values
    are often misused. `undefined` is the value contained in any variable that is
    declared first, but not assigned a value. It is also the value that''s been returned
    from a function that does not explicitly return a value using the `return` keyword
    and it is the value that''s returned from a statement (an action with no resulting
    value).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`在许多方面与`null`相似，因此这两个值经常被误用。`undefined`是任何未分配值的变量的值。它也是函数返回的值，该函数没有使用`return`关键字显式返回值，以及它是从没有结果值的语句（一个没有结果的动作）返回的值。'
- en: When working with `undefined`, you should always anticipate it, but never assign
    it to a variable or return it explicitly from a function. In such circumstances,
    you should use `null`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理`undefined`时，你应该始终预期它，但绝不要将其分配给变量或从函数中显式返回。在这种情况下，你应该使用`null`。
- en: Boolean Values
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: '`Boolean` is a term named after George Boole, a nineteenth-century English
    mathematician and philosopher. It is used to denote the values `true` and `false`.
    These values may be assigned to variables and are strictly equivalent to their
    value, like null.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`布尔`（Boolean）这个术语是以19世纪英国数学家和哲学家乔治·布尔（George Boole）的名字命名的。它用来表示`true`和`false`这两个值。这些值可以分配给变量，并且与它们的值严格等价，就像`null`一样。'
- en: Booleans are unique among the types supported by JavaScript because they are
    indirectly comparable to other types and expressions. The logical operators described
    in *Chapter 3*, *Programming Fundamentals*, of this book, for instance, all result
    in a `Boolean` value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值在JavaScript支持的所有类型中是独特的，因为它们可以与其他类型和表达式间接比较。例如，本书第3章“编程基础”中描述的逻辑运算符都会返回一个`Boolean`值。
- en: Boolean Operators
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: Boolean operators are operators that, when combined into an expression, return
    a `Boolean` value. Most Boolean operators are "`binary`" operators that accept
    two values, each of which sit either side of the operator. Like other operators,
    each value can be an expression and can be of any value type. As `Boolean` operators
    themselves form expressions, they can be used as input to other `Boolean` operators.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符是当组合成表达式时返回`Boolean`值的运算符。大多数布尔运算符是“二元”运算符，接受两个值，每个值位于运算符的两侧。像其他运算符一样，每个值都可以是一个表达式，可以是任何值类型。由于布尔运算符本身形成表达式，因此可以用作其他布尔运算符的输入。
- en: Boolean operators fit into two categories; namely, comparison operators and
    logical operators.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符可以分为两类；即比较运算符和逻辑运算符。
- en: Comparison Operators
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Comparison operators are used for comparing one value, or the result of an expression,
    with another. The operator in this circumstance may be considered a rule. If the
    rule succeeds, then the response of the combined expression returns `true`. Otherwise,
    it returns `false`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符用于比较一个值或表达式的结果与另一个值。在这种情况下，运算符可以被视为一条规则。如果规则成功，则组合表达式的响应返回`true`。否则，它返回`false`。
- en: 'Comparison operators include the following symbols:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符包括以下符号：
- en: '![Figure 5.5: Comparison operators and their descriptions'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5：比较运算符及其描述]'
- en: '](img/C14377_05_05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_05_05.jpg]'
- en: 'Figure 5.5: Comparison operators and their descriptions'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5：比较运算符及其描述]'
- en: Comparison operators are often used as the condition parameters of if conditionals
    and while loop statements. If or while the condition expression returns true,
    the body block of the expression will execute.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符通常用作if条件语句和while循环语句的条件参数。如果或当条件表达式返回`true`时，表达式的主体块将执行。
- en: 'The following example expressions will all return the value true:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例表达式都将返回值`true`：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you look at the last example in the list, you may be a little surprised.
    The `==` operator is a "value comparison operator". In the example shown, the
    numeric value 1 and the string value "1" are considered the same value. As such,
    the equality operator, which is a "value comparison" operator, will compare them
    as equal.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看列表中的最后一个示例，你可能会有点惊讶。`==`运算符是一个“值比较运算符”。在显示的示例中，数值1和字符串值“1”被认为是相同的值。因此，作为“值比较”运算符的等价运算符将它们视为相等。
- en: 'In order to determine whether values are of the same type, as well as the same
    value, "strict comparison operators" should be used:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定值是否属于同一类型以及是否具有相同的值，应使用“严格比较运算符”：
- en: '![Figure 5.6: Equality operators and their descriptions'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6：等价运算符及其描述]'
- en: '](img/C14377_05_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_05_06.jpg]'
- en: 'Figure 5.6: Equality operators and their descriptions'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：相等运算符及其描述
- en: Logical Operators
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Logical operators are often used to concatenate `Boolean` expressions together.
    For instance, when comparing the qualities of a `string` value, you may wish to
    execute code if the `string` is longer than one value but shorter than another.
    In order to do this, you need to join two comparison expressions using the `&&`
    operator. In another condition, you may wish to execute the code if only one of
    the expressions is `true`, in which case, you would use the `||` operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符通常用于将 `Boolean` 表达式连接起来。例如，当比较一个 `string` 值的质量时，你可能希望如果 `string` 的长度大于一个值但小于另一个值时执行代码。为了做到这一点，你需要使用
    `&&` 运算符将两个比较表达式连接起来。在另一个条件下，你可能希望只有一个表达式为 `true` 时执行代码，在这种情况下，你会使用 `||` 运算符。
- en: 'The following table lists each of the logical operators and what they do:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了每个逻辑运算符及其功能：
- en: '![Figure 5.7: Logical operators and their description'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7：逻辑运算符及其描述'
- en: '](img/C14377_05_07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_07.jpg)'
- en: 'Figure 5.7: Logical operators and their description'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：逻辑运算符及其描述
- en: 'Exercise 5.03: Odds and Evens'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.03：奇数和偶数
- en: In this exercise, we will process a series of numbers and output messages describing
    whether a number is either odd or even.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将处理一系列数字，并输出描述数字是奇数还是偶数的消息。
- en: 'We''ll fulfill this exercise using a function so that you can experiment with
    different starting values. Let''s get started:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用函数来完成这个练习，这样你就可以尝试不同的起始值。让我们开始吧：
- en: 'At the command prompt, create the `odd_or_even` function with a couple of parameters:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符下，创建一个带有几个参数的 `odd_or_even` 函数：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `last` parameter will be the ceiling value of the numerical series, while
    the `counter` parameter is both the starting value and the current index variable
    for each loop.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`last` 参数将是数值序列的上限值，而 `counter` 参数既是每个循环的起始值，也是当前索引变量。'
- en: 'Next, create your loop using the `while` keyword. while will process a block
    of code as long as the conditional expression is truthy. As the conditional in
    this exercise, you will simply compare `counter` with the `last` parameter:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `while` 关键字创建你的循环。`while` 将在条件表达式为真时处理代码块。在这个练习中，你将简单地比较 `counter` 与
    `last` 参数：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the `counter` variable is ever larger than the `last` parameter, then the
    `while` loop will exit, which will also exit the function.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `counter` 变量的值大于 `last` 参数，则 `while` 循环将退出，这也会退出函数。
- en: 'With the `while` conditional in place, you can now begin describing the counter
    value with each iteration. To do this, you simply examine the value of `counter`
    and respond with an appropriate message, depending on its content:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `while` 条件成立后，你现在可以开始描述每次迭代的计数器值。为此，你只需检查 `counter` 的值，并根据其内容给出适当的消息：
- en: '[PRE17]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, increment the `counter` variable by `1` before you close the `while` loop
    block. If you fail to increment, the condition of the `while` loop would always
    be `true`, and the loop will never exit. Also, each iteration of the loop would
    process identically, which is not the result you require:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭 `while` 循环块之前，现在将 `counter` 变量增加 `1`。如果你没有增加，`while` 循环的条件将始终为 `true`，循环将永远不会退出。此外，循环的每次迭代都会处理相同的内容，这不是你想要的结果：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Close out both the `while` block and the function. There is no need to return
    anything from this function as we are not interested in any final values:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `while` 块和函数。由于我们对该函数的任何最终值不感兴趣，因此不需要从这个函数中返回任何内容：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, execute the function, passing a `counter` value and `last` value as required.
    The output should accurately describe all the numbers from `counter` to `last`,
    inclusively.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照要求传递 `counter` 值和 `last` 值来执行函数。输出应该准确地描述从 `counter` 到 `last` 的所有数字，包括
    `last` 本身。
- en: 'Here''s the output:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Figure 5.8: Exercise 5.03 output'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8：练习 5.03 输出'
- en: '](img/C14377_05_08.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_08.jpg)'
- en: 'Figure 5.8: Exercise 5.03 output'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：练习 5.03 输出
- en: Have a go at changing the passed parameters when calling the function. However,
    be sure to keep `counter` to a value less than or equal to the `last` parameter
    or the `while` loop will not execute.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在调用函数时更改传递的参数。但是，请确保将 `counter` 的值保持在小于或等于 `last` 参数的范围内，否则 `while` 循环将不会执行。
- en: Testing the Truth of Values
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试值的真伪
- en: When writing programs with JavaScript, you will often need to compare values,
    typically when working with conditionals. Often, values will be compared with
    other values, but it is just as likely that you will need to check the truthiness
    of a value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当用JavaScript编写程序时，你将经常需要比较值，通常是在处理条件时。通常，值会与其他值进行比较，但你也可能需要检查值的真值。
- en: 'Testing for truthiness can mean many things:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 测试真值可以意味着许多事情：
- en: Is there a value present?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在值？
- en: Are there any items in an array?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组中是否有任何项？
- en: Does the string have a length greater than 0?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的长度是否大于0？
- en: Does the passed expression return `true`?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递的表达式返回`true`吗？
- en: 'JavaScript provides a means to pass in a solitary value to conditional statements
    to test for truthiness. However, this can sometimes be an area of confusion. For
    instance, examine the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了一种方法，可以将单个值传递给条件语句以测试其真值。然而，这有时可能会引起混淆。例如，检查以下示例：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `if` statement body executes if the conditional is truthy. In the first
    example in the preceding code, the numeric value zero is seen as falsey. As the
    second and third examples show, `false` is equal to numeric zero, but only non-strictly.
    However, in the third example, the numeric value zero is not strictly equivalent
    to `false`. The reason for this is that there is a difference between a `false`
    value and a falsey value. A `false` value is always false, but a falsey value
    may be one of several values, including the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件是真值，则执行`if`语句的主体。在前面的代码的第一个例子中，数值零被视为假值。正如第二个和第三个例子所示，`false`等于数值零，但只是非严格相等。然而，在第三个例子中，数值零并不严格等同于`false`。这是因为`false`值和假值之间有一个区别。`false`值始终是`false`，但假值可能是几个值之一，包括以下内容：
- en: 'false'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`undefined`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`null`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: -0, +0, or NaN
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-0`、`+0`或`NaN`'
- en: An `empty` string
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空字符串
- en: If the value is not in the preceding list, then it is considered truthy.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值不在前面的列表中，则被认为是真值。
- en: The NOT Operator
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NOT运算符
- en: 'The `!` or `NOT` operator is rather unique. It is considered a "unary" operator
    because it only accepts one value to the right of it. By using the `NOT` operator,
    you essentially negate the value that precedes it. Here''s an example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`或`NOT`运算符相当独特。它被认为是一个“一元”运算符，因为它只接受它右侧的一个值。通过使用`NOT`运算符，你实际上是否定了它前面的值。以下是一个例子：'
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, the `falseValue` variable will contain a value of
    `false`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`falseValue`变量将包含一个`false`的值。
- en: A very useful feature of the `NOT` operator is the "`double NOT`." This is when
    two `NOT` operators are combined to double negate an expression; a true expression
    is negated to `false`, then back to `true`, while a `false` expression is negated
    to `true`, then back to `false`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOT`运算符的一个非常有用的特性是“双重NOT”。这是指两个`NOT`运算符组合起来双重否定一个表达式；一个真表达式被否定为`false`，然后又回到`true`，而一个`false`表达式被否定为`true`，然后又回到`false`。'
- en: 'When working with truthy or falsey expressions, using the `double NOT` operator
    alters the resulting value of these expressions to actual Boolean values. Here''s
    an example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理真值或假值表达式时，使用`双重NOT`运算符会改变这些表达式的结果值，使其成为实际的布尔值。以下是一个例子：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Boolean Operator Precedence
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔运算符优先级
- en: All operators have an order of execution known as "**precedence**." This precedence
    is also apparent in mathematics and is a means to ensure that expressions are
    executed in a predictable manner.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有运算符都有一个执行顺序，称为“优先级”。这种优先级在数学中也很明显，它是一种确保表达式以可预测的方式执行的手段。
- en: 'Consider the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding example could be read in two different ways. This is the first
    way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可以有两种不同的解读方式。这是第一种解读方式：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the second way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二种解读方式：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you follow the code from left to right, as in the first example of interpretation,
    it will return `false`, because the `&&` operator is executed last. There, the
    code will be reduced to the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从左到右遵循代码，就像前面的第一个例子一样，它将返回`false`，因为`&&`运算符是最后执行的。在那里，代码将简化为以下内容：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second interpretation, however, will produce a different result:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二种解释会产生不同的结果：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To prevent such ambiguity, operator order precedence exists. Precedence is
    applicable to all the operators in the JavaScript language, but we''ll list just
    those that are applicable to `Boolean` expressions here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种歧义，存在运算符优先级规则。优先级适用于JavaScript语言中的所有运算符，但在这里我们只列出适用于`Boolean`表达式的那些运算符：
- en: '![Figure 5.9: Boolean operators and their associativity'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9：布尔运算符及其结合性'
- en: '](img/C14377_05_09.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_05_09.jpg)'
- en: 'Figure 5.9: Boolean operators and their associativity'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：布尔运算符及其关联性
- en: In the preceding table, the top row has the highest precedence and so is evaluated
    first, while the bottom row has the lowest precedence and is evaluated last.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，最上面的行具有最高的优先级，因此首先评估，而最下面的行具有最低的优先级，最后评估。
- en: Boolean Operator Associativity
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔运算符关联性
- en: In the previous table, each operator is given an associativity description.
    Associativity relates to the execution direction of an expression. Most operators
    have "left-to-right" associativity, which means the left-hand side expression
    is executed before the right-hand side expression. The `NOT` operator, however,
    executes its right-hand expression first.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，每个运算符都被赋予了关联性描述。关联性与表达式的执行方向有关。大多数运算符具有“从左到右”的关联性，这意味着左侧表达式会在右侧表达式之前执行。然而，`NOT`
    运算符首先执行其右侧表达式。
- en: 'Associativity can be very important, especially when side effects occur within
    an expression. In the following example, the expressions present on either side
    of a `||` operator log the parameter and return it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关联性可能非常重要，尤其是在表达式中发生副作用时。在以下示例中，位于 `||` 运算符两边的表达式记录参数并返回它：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When executed, if the `log_and_return` function returns a truthy value, then
    only the first execution will occur and so only that call logs a message with
    `log_and_return`: concatenated with the value passed in. Since the `||` operator
    is left-to-right associative, the entire expression is considered truthy if the
    left-hand side returns `true`. As such, the right-hand side is never executed.
    For this particular operator, the right-hand side only ever executes if the left-hand
    side is false. This behavior is also called a short circuit.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，如果 `log_and_return` 函数返回一个真值，那么只有第一次执行会发生，因此只有那个调用使用 `log_and_return` 记录一条消息：与传入的值连接。由于
    `||` 运算符是左到右关联的，如果左侧返回 `true`，则整个表达式被认为是真值。因此，右侧永远不会执行。对于这个特定的运算符，右侧只有在左侧为假时才会执行。这种行为也称为短路。
- en: 'Since the side effect of **logAndReturn** is only logging the value, this provides
    a useful tool for debugging. However, consider a function that receives an object
    as a parameter, modifies it, and then returns a value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **logAndReturn** 的副作用仅仅是记录值，这为调试提供了一个有用的工具。然而，考虑一个接收对象作为参数、修改它然后返回值的函数：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Both objects follow the same structure and the `make_happy` function could possibly
    work with either object. However, when the conditional is called, only `john`
    will be updated since the `||` condition in the conditional expression is satisfied
    on its left-hand side.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象遵循相同的结构，`make_happy` 函数可能可以与任一对象一起工作。然而，当调用条件时，只有 `john` 会被更新，因为条件表达式中的
    `||` 条件在其左侧满足。
- en: The right-hand side is never executed. Therefore, if the code is dependent on
    both objects being modified at a later date, it will fail.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧永远不会执行。因此，如果代码依赖于稍后修改两个对象，它将失败。
- en: This same caveat is true for the `&&` operator. Since an `&&` operator expression
    is considered `true` if both sides are truthy, then both sides will only execute
    if the left-hand side execution returns `true`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `&&` 运算符，同样的警告也是适用的。由于 `&&` 运算符表达式只有在两边都为真时才被认为是 `true`，因此只有当左侧执行返回 `true`
    时，两边才会执行。
- en: 'The associative execution rule for the `||` operator is particularly useful
    when working with variables. In some circumstances, it is preferable to assign
    a default value to a variable if, and only if, it does not already contain a value.
    In this instance, using the `||` operator can make light work of this task:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `||` 运算符的关联执行规则在处理变量时特别有用。在某些情况下，如果变量尚未包含值，则最好为其分配一个默认值。在这种情况下，使用 `||` 运算符可以轻松完成这项任务：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the variable already contains a value, then it will keep that value. However,
    if its value is `null`, `undefined`, or some other falsey value, then it will
    be assigned the value 5.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量已经包含值，则它将保持该值。但是，如果其值为 `null`、`undefined` 或其他假值，则它将被分配值为 5。
- en: 'Similarly, using the `&&` operator is great if you wish to execute a function
    if a preceding variable is truthy:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你希望在一个先前的变量为真时执行一个函数，使用 `&&` 运算符是很好的选择：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Exercise 5.04: Free Home Delivery Eligibility Validation'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.04：免费送货资格验证
- en: 'In this exercise, we will create a function that will determine whether the
    customers of a grocery store are eligible for free home delivery. The store only
    delivers to customers who are located within 5 miles of the store. To make this
    exercise more interesting, the store recently decided to provide free delivery
    for customers located within 10 miles of the store, but only if those customers
    have an active membership for their loyalty program. Moreover, if customers are
    within 1 mile of the store, they aren''t eligible for free home delivery, regardless
    of their membership status. Let''s get started:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，用于确定杂货店的客户是否有资格享受免费送货上门服务。商店只为位于商店 5 英里范围内的客户送货。为了让这个练习更有趣，商店最近决定为位于商店
    10 英里范围内的客户提供免费送货服务，但前提是这些客户必须拥有其忠诚度计划的活跃会员资格。此外，如果客户位于商店 1 英里以内，无论其会员状态如何，都不符合免费送货上门的资格。让我们开始吧：
- en: 'Define your function signature. The function should accept the distance of
    the customer''s house from the store and their membership status:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的函数签名。该函数应接受客户家与商店的距离以及他们的会员状态：
- en: '[PRE33]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Based on the store's criteria, the function will return `true` if the customer
    is eligible for free delivery and `false` if they are not. Functions that describe
    something in a `Boolean` fashion are often labeled `is`, such as `isValid`, `isEnabled`,
    or `isGoingToReturnABoolean`.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据商店的标准，如果客户有资格享受免费送货，则函数返回 `true`；如果他们不符合，则返回 `false`。描述某种内容的 `Boolean` 形式的函数通常被标记为
    `is`，例如 `isValid`、`isEnabled` 或 `isGoingToReturnABoolean`。
- en: 'There are two ways to build the body of this function; either break the problem
    up into small chunks and test the parameters bit by bit or create a single conditional
    that detects all the appropriate outcomes. We''ll work with the latter in order
    to appropriately demonstrate the content of this chapter thus far. The following
    if statement is a negative check – it checks whether a customer is not eligible
    for free home delivery:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建这个函数的主体有两种方式；要么将问题分解成小块并逐步测试参数，要么创建一个检测所有适当结果的单一条件。我们将使用后者来适当展示本章迄今为止的内容。以下
    `if` 语句是一个否定检查——它检查客户是否有资格享受免费送货上门服务：
- en: '[PRE34]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is the crux of the exercise. The `Boolean` operators are executed in the
    following order, but only those that are necessary to determine the overall result.
    First and always is the relative check for houses within `1` mile of the store.
    If the house is within `1` mile of the store, the overall result is `true`, and
    the rest of the expression is not evaluated at all. Only if the distance is `1`
    mile or more is the overall result not determined yet and the following goes ahead.
    Only if the membership status is active does the check for a distance greater
    than `10` miles come. Otherwise, if the membership status is inactive, there comes
    the check for a `distance` of greater than `5` miles. Then, those results are
    with the less-than-1-mile check. Due to operator precedence, no grouping using
    parentheses was required.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是练习的核心。布尔运算符按以下顺序执行，但只有那些确定整体结果所必需的运算符。首先是检查房屋是否位于商店 `1` 英里范围内的相对检查。如果房屋位于商店
    `1` 英里以内，则整体结果为 `true`，并且不会评估整个表达式的其余部分。只有当距离为 `1` 英里或更多时，整体结果尚未确定，然后才会继续进行。只有当会员状态为活跃时，才会检查是否超过
    `10` 英里。否则，如果会员状态不活跃，则会检查是否超过 `5` 英里。然后，这些结果将与小于 `1` 英里的检查相结合。由于运算符优先级，不需要使用括号进行分组。
- en: 'If the conditional evaluates as truthy, then we want to report that the person
    is not eligible for free delivery:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果条件评估为真值，则我们希望报告该人员不符合免费送货的资格：
- en: '[PRE35]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since the function will simply halt here, if the conditional block is executed,
    simply return `true` for anything that slips past:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于函数将在这里简单地停止，如果条件块被执行，只需为任何通过的内容返回 `true`：
- en: '[PRE36]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the function complete, try different parameter variations to test it:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数完成后，尝试不同的参数变体来测试它：
- en: '[PRE37]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 5.10: Exercise 5.04 output'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10：练习 5.04 输出'
- en: '](img/C14377_05_10.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_05_10.jpg]'
- en: 'Figure 5.10: Exercise 5.04 output'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：练习 5.04 输出
- en: Why You Shouldn't Compare Boolean and Non-Boolean Expressions
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么你不应该比较布尔值和非布尔表达式
- en: 'While many non-Boolean values and objects are considered truthy, they may not
    be equal to `Boolean` `true`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多非布尔值和对象被认为是真值，但它们可能不等于 `Boolean` `true`：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A good rule of thumb is to convert the non-Boolean expression into a `Boolean`
    type with `!!` – the double negation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是使用 `!!`（双重否定）将非布尔表达式转换为 `Boolean` 类型：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Why You Shouldn't Chain Comparison Expressions
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么不应该链式比较表达式
- en: 'Repeated applications of the same operator to more than two expressions are
    called chaining. Usually, this is practical and clear:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对同一运算符在两个以上表达式上的重复应用称为链式操作。通常，这既实用又清晰：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It may also be tempting to use this process with comparison operators, but
    that would give a surprising, and incorrect, result. In such circumstances, the
    intermediary result of the first `Boolean` comparison would provide a `Boolean`
    outcome. Therefore, when it is compared with the next number in the chain, it
    will be converted by the JavaScript engine into a `1` (if it is `true`) or a `0`
    (if it is `false`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比较运算符进行此过程可能也很诱人，但这样做会得到一个令人惊讶且不正确的结果。在这种情况下，第一次布尔比较的中间结果将提供一个布尔结果。因此，当它与链中的下一个数字进行比较时，JavaScript
    引擎会将其转换为`1`（如果是`true`）或`0`（如果是`false`）：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similar confusion arises when using comparison operators:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用比较运算符时，也会出现类似的混淆：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Therefore, avoid chaining any comparison operators unless you're explicitly
    working with `Boolean` values.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非你明确地处理布尔值，否则请避免链式任何比较运算符。
- en: The Ternary Operator
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'So far, we have looked at unary and binary operators, but another operator
    is also supported in JavaScript. Known simply as the ternary operator, it performs
    a similar role to `if...else`, but in a much more compact fashion. The `ternary`
    operator consists of a question mark (`?`) and a colon (`:`), which are used to
    denote a conditional expression `?`, a true expression with if `false` expression.
    For example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了一元和二元运算符，但JavaScript还支持另一个运算符。这个运算符简单地称为三元运算符，它执行与`if...else`类似的功能，但以更紧凑的方式。三元运算符由一个问号（`?`）和一个冒号（`:`）组成，用于表示条件表达式`?`，一个`if`条件下的真表达式和一个`false`条件下的表达式。例如：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This, of course, is the same as the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这与以下内容相同：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The primary difference here is that the `ternary` operator is an expression
    in itself. This differs from `if`, which is a statement (it does not return a
    value).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于三元运算符本身就是一个表达式。这与`if`不同，`if`是一个语句（它不返回值）。
- en: The conditional segment of the `ternary` operator does not need to be enclosed
    in parentheses but is often seen as such so that it closely resembles an `if`
    expression. The rules for each of the three expressions are simply that they must
    be expressions; you cannot use `if`, `while`, or another such statement, otherwise
    an error will be thrown.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符的条件部分不需要括号包围，但通常被视为如此，以便它紧密地类似于`if`表达式。每个三个表达式的规则很简单，即它们必须是表达式；你不能使用`if`、`while`或另一个此类语句，否则会抛出错误。
- en: 'As ternary operators are expressions, they can be nested. Each question mark
    segment of the operator expects a colon segment to follow, much like nesting groups
    of brackets. Therefore, it is possible, and acceptable, to do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于三元运算符是表达式，因此它们可以嵌套。运算符的每个问号部分都期望跟随一个冒号部分，就像嵌套括号组一样。因此，执行以下操作是可能的，也是可接受的：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is equivalent to the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下内容：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`Ternary` operators are very useful for keeping your code succinct. Sometimes,
    utilizing a complete `if...else` statement detracts from the purpose of the code
    and makes it harder to understand. Feel free to use the `ternary` operator where
    you see fit.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符对于保持代码简洁非常有用。有时，使用完整的`if...else`语句会削弱代码的目的，并使其更难以理解。请随意在需要的地方使用三元运算符。
- en: Working with Numbers
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数字
- en: All numbers in JavaScript are 64-bit floating-point values. Unlike other languages,
    there is no internal differentiation between floating-point values and integers.
    JavaScript provides several objects containing functions that are orientated specifically
    around floating-point values and integers. However, these objects are semantic.
    Therefore, applying integer-specific functions to a number will still result in
    a floating-point value.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的所有数字都是64位浮点值。与其他语言不同，JavaScript中没有内部区分浮点值和整数的差异。JavaScript提供了几个包含特定于浮点值和整数的函数的对象。然而，这些对象是语义上的。因此，将整数特定的函数应用于一个数字仍然会得到一个浮点值。
- en: Numbers are the simplest form of data represented by the JavaScript engine.
    Number values are immutable, which means their value cannot be modified in memory.
    If you assign a new number to a variable, you are simply overwriting the old value
    with the new. The existing value is not modified.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 数值是JavaScript引擎表示的数据的最简单形式。数值是不可变的，这意味着它们的值在内存中不能被修改。如果您将新数值赋给变量，您只是在用新值覆盖旧值。现有值不会被修改。
- en: Since `numbers` are passed to variables by value, it is not possible for two
    variables to point to the same `number` address space. Therefore, working with
    `number` values is considered pure, providing you do not reassign values to variables.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`数字`是通过值传递给变量的，因此两个变量不可能指向相同的`数字`地址空间。因此，处理`数字`值被认为是纯的，前提是你不重新分配变量的值。
- en: Arithmetic Limitations
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术限制
- en: 'Floating-point values can pose something of a problem in JavaScript. Due to
    their `binary` encoding, which is how the `number` is represented in bits within
    the JavaScript engine, simply adding two floats together may not produce the result
    you are expecting. Consider the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值在JavaScript中可能会引起一些问题。由于它们的`二进制`编码，这是JavaScript引擎在位中表示`数字`的方式，简单地相加两个浮点数可能不会产生你期望的结果。考虑以下：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, the response should be `0.3`, but it is not. The underlying runtime simply
    does not handle values in a way that allows them to be accurate, even with a single
    `decimal` place.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，响应应该是`0.3`，但它不是。底层运行时简单地没有以允许它们准确的方式处理值，即使只有一位小数。
- en: 'If accuracy is necessary for your application, there are a number of tricks
    that provide the correct output. With regards to the preceding example, simply
    converting the values into decimals before the addition will yield better accuracy.
    You can then convert the resulting value back into a floating-point number afterward,
    like so:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果精度对您的应用程序是必要的，有一些技巧可以提供正确的输出。关于前面的例子，简单地在加法之前将值转换为十进制将提高精度。然后您可以像这样将结果值转换回浮点数：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The same is also true for multiplication and division:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，乘法和除法也存在相同的问题：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'However, if you convert into an `integer` first, then the result is more accurate:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您首先将其转换为`整数`，则结果更准确：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This limitation is not restricted to JavaScript. In fact, any language that
    works with 64-bit IEEE 754 floating-point numbers will have the same limitations.
    There are numerous libraries available on the internet that help with these issues,
    if you would prefer not to tackle them yourself.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制不仅限于JavaScript。实际上，任何使用64位IEEE 754浮点数的语言都会有相同的限制。互联网上有许多库可以帮助解决这些问题，如果您不愿意自己解决。
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The largest integer values that JavaScript can represent as numbers are `9,007,199,254,740,991`
    and -`9,007,199,254,740,991`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript可以表示的最大整数值是`9,007,199,254,740,991`和`-9,007,199,254,740,991`。
- en: The Number Object
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Number对象
- en: 'As we mentioned previously, numbers in JavaScript are primitives. As such,
    they have no properties or methods. Contrary to this, however, the JavaScript
    engine maintains an awareness of where numerical literals and variables are used
    within your application and provides syntactic support for methods via the `number`
    object. It is even possible to extend this object using prototypes, which will
    be explained in full in Part Four. Any extension imposed on the `Number` object
    will be usable against numeric values in your application:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，JavaScript中的数值是原始类型。因此，它们没有属性或方法。然而，与此相反的是，JavaScript引擎维护了对您的应用程序中数值字面量和变量使用的了解，并通过`number`对象提供语法支持。甚至可以通过原型扩展此对象，这将在第四部分中详细解释。对`Number`对象施加的任何扩展都将可用于您的应用程序中的数值：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that while it may seem as though numerical values are objects, this is
    not actually the case. In memory, numbers are very simple values. The `Number`
    object, and its implementation by the JavaScript runtime, merely provides many
    of the benefits afforded with objects against these values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然数值可能看起来像是对象，但实际上并非如此。在内存中，数值是非常简单的值。`Number`对象及其由JavaScript运行时实现的实现，仅仅提供了与这些值相关的许多对象的好处。
- en: Number Functions
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值函数
- en: The `Number` object contains an assortment of functions that work with numeric
    values. Like all objects, the `Number` object provides a constructor that, if
    invoked with the `new` keyword, creates a `Number` object instance. Numbers that
    are created with the `Number` constructor are actual objects, which is contrary
    to the previous statement, that is, that numbers are not objects, and is the cause
    of a lot of confusion. To make things even more interesting, the resulting object
    instance can be treated just like any other number.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number` 对象包含一系列用于处理数值的函数。像所有对象一样，`Number` 对象提供了一个构造函数，如果使用 `new` 关键字调用，则创建一个
    `Number` 对象实例。使用 `Number` 构造函数创建的数字实际上是对象，这与前面的陈述相反，即数字不是对象，这也是造成很多困惑的原因。更有趣的是，结果对象实例可以像任何其他数字一样处理。'
- en: 'In addition to the constructor is the `Number` function. This is used in the
    same manner as the `Number` constructor but without the `new` keyword. Invoking
    this function returns a `number`, not an `object`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数之外，还有 `Number` 函数。这个函数的使用方式与 `Number` 构造函数相同，但不需要 `new` 关键字。调用此函数返回一个
    `number`，而不是 `object`：
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In all the instances detailed in the preceding code, the resulting values can
    be worked with in the same manner and with the same rules, except when dealing
    with truthy conditionals. Typically, conditionals see the value `0` (zero) as
    a falsey value, but the value returned from `new Number(0)` is truthy, even though
    it is also zero.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中详细说明的所有情况下，结果值可以以相同的方式和规则进行处理，除了处理真值条件。通常，条件将值 `0`（零）视为假值，但从 `new Number(0)`
    返回的值是真值，尽管它也是零。
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Likewise, when comparing by type, the value that's returned from `new Number(0)`
    is an object, not a number, so strict comparisons against numeric literals will
    fail.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当按类型比较时，从 `new Number(0)` 返回的值是一个对象，而不是数字，因此与数字字面量的严格比较将失败。
- en: 'Both the `Number` function and constructor will accept any value type. If the
    value type cannot be converted into a number, then `NaN` (not a number) is returned:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number` 函数和构造函数都接受任何值类型。如果值类型不能转换为数字，则返回 `NaN`（不是一个数字）：'
- en: '[PRE54]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When working with JavaScript, it is advised not to use the `Number` constructor
    at all so that your code is more readable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 JavaScript 时，建议根本不要使用 `Number` 构造函数，以便代码更易于阅读。
- en: 'Aside from the `Number` function and constructor, the global `Number` object
    also provides a variety of functions to help us identify or parse numeric values:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Number` 函数和构造函数之外，全局的 `Number` 对象还提供了一系列函数，帮助我们识别或解析数值：
- en: '![Figure 5.11: Number functions and their descriptions'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11：数字函数和它们的描述]'
- en: '](img/C14377_05_11.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_05_11.jpg]'
- en: 'Figure 5.11: Number functions and their descriptions'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：数字函数和它们的描述
- en: 'Each of these functions is `static` and so must be preceded with the global
    `Number` object (which acts as a class in many languages), except when using `parseFloat`
    or `parseInt`. These functions are also global and therefore can be invoked without
    the preceding `Number`, like so:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都是 `static` 的，因此必须用全局的 `Number` 对象（在许多语言中充当类）作为前缀，除非使用 `parseFloat` 或 `parseInt`。这些函数也是全局的，因此可以像这样调用，而不需要前面的
    `Number`：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Number Methods
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字方法
- en: 'Since the JavaScript parser semantically identifies numeric values, it is possible
    to invoke instance methods of the Number object against them, just like we can
    with actual objects. The majority of these methods are used to format `numeric`
    values as `string` representations, which is very useful for presentation in web
    pages:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 解析器在语义上识别数值，因此可以像对实际对象一样调用 Number 对象的实例方法。这些方法中的大多数用于将 `numeric`
    值格式化为 `string` 表示形式，这对于在网页中的展示非常有用：
- en: '![Figure 5.12: Number methods and their descriptions'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12：数字方法和它们的描述]'
- en: '](img/C14377_05_12.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14377_05_12.jpg]'
- en: 'Figure 5.12: Number methods and their descriptions'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12：数字方法和它们的描述]'
- en: 'Using a combination of the `Number` functions and methods, it is possible to
    convert to and from numeric values as necessary, though some precision may be
    lost:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合使用 `Number` 函数和方法，可以在必要时将数值转换为其他数值，尽管可能会丢失一些精度：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'However, calling those functions on integer literals (rather than floats) fails:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在整数字面量（而不是浮点数）上调用这些函数会失败：
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When JavaScript sees the first dot right after one or more digits, it assumes
    you want to write a float literal. There are some workarounds to this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 在一个或多个数字之后看到第一个点时，它假设你想要写一个浮点字面量。有一些解决方案可以解决这个问题：
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Number Properties
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字属性
- en: 'The global `Number` object provides a variety of constant properties, which
    is useful when comparing your numeric values. The most important of these is `NaN`.
    Being able to identify numeric discrepancies outside of the JavaScript runtime''s
    ability to calculate provides you with a means to reduce bugs in your code. For
    instance, observe the following example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 全局`Number`对象提供了各种常量属性，这在比较你的数值时很有用。其中最重要的是`NaN`。能够在JavaScript运行时之外识别数值差异，为你提供了减少代码中错误的方法。例如，观察以下示例：
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When executed, the result of `num` is the constant value known as Infinity.
    Since it is not possible to add, deduct, multiply, or divide other values from
    infinity, any further math against that value will also be Infinity. Therefore,
    being able to deduce this restriction within your code will provide an early warning
    that something may be amiss in your logic.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，`num`的结果是被称为无穷大的常量值。由于无法从无穷大添加、减去、乘以或除以其他值，因此对该值进行的任何进一步数学运算也将是无穷大。因此，能够在代码中推断出这种限制将提供早期警告，表明你的逻辑可能存在问题。
- en: 'Other properties of Number include the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的其他属性包括以下内容：
- en: '![Figure 5.13: Number properties and their descriptions'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13：数字属性及其描述'
- en: '](img/C14377_05_13.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_13.jpg)'
- en: 'Figure 5.13: Number properties and their descriptions'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：数字属性及其描述
- en: 'Both `MAX_SAFE_INTEGER` and `MIN_SAFE_INTEGER` are interesting values. Consider
    the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAX_SAFE_INTEGER`和`MIN_SAFE_INTEGER`都是有趣的价值。考虑以下代码：'
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Surprisingly, the result of the preceding expression is `true`. This is simply
    because the numbers exceed safety boundaries and are therefore no longer accurately
    represented. The precision that's used in both sides of the preceding expression
    results in the same value and thus are considered equal.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到的是，前面表达式的结果是`true`。这仅仅是因为数字超出了安全边界，因此不再被准确表示。前面表达式的两边使用的精度相同，因此被认为是相等的。
- en: 'Exercise 5.05: Currency Formatter'
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.05：货币格式化器
- en: 'In this exercise, we will create a function that can take a numeric value parameter
    as a `number` or `string` and format it into a price value with two-decimal precision.
    In order to prepend a `currency` symbol, the function will accept it as a parameter.
    Let''s get started:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，该函数可以将数值参数作为`number`或`string`格式化为具有两位小数的价格值。为了在前面添加货币符号，该函数将接受它作为参数。让我们开始吧：
- en: 'Define your function signature. This function will accept two parameters. The
    first of these will be the decimal value and the second will be the currency symbol:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的函数签名。这个函数将接受两个参数。其中第一个将是小数值，第二个将是货币符号：
- en: '[PRE61]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When executing, the first task that the function performs should be to validate
    the quality of the passed parameter values. The `value` parameter must be able
    to be converted into a numeric value, while the `currency` parameter should be
    a character `string`. If the `currency` is falsey, such as when no parameter has
    been passed, then we can default its value to the dollar symbol:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行时，函数执行的第一项任务应该是验证传入参数的质量。`value`参数必须能够转换为数值，而`currency`参数应该是一个字符`string`。如果`currency`是假的，例如没有传递参数，那么我们可以将其默认值设置为美元符号：
- en: '[PRE62]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When responding to errors, there are many ways we can notify the caller that
    something went wrong. In this instance, we''ll simply return `null`. This way,
    the caller will know that anything other than a `string` response means that something
    wasn''t quite right:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在响应错误时，我们可以用多种方式通知调用者出了问题。在这个例子中，我们简单地返回`null`。这样，调用者就会知道除了`string`响应之外，任何其他响应都意味着有些地方不太对劲：
- en: '[PRE63]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now that we know the parameters are usable, combine them into the correct format
    and return the value:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道参数是可用的，将它们组合成正确的格式并返回值：
- en: '[PRE64]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you go ahead and execute this function, you will see the appropriate responses:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你继续执行这个函数，你会看到相应的响应：
- en: '[PRE65]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![Figure 5.14: Exercise 5.05 output'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14：练习 5.05 输出'
- en: '](img/C14377_05_14.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_14.jpg)'
- en: 'Figure 5.14: Exercise 5.05 output'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14：练习 5.05 输出
- en: We can see the output once all four functions are run in the preceding figure.
    In this exercise, we created a function that took a numeric value parameter as
    a `number` or `string` and formatted it into a price value with two-decimal precision.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的图中看到运行所有四个函数后的输出。在这个练习中，我们创建了一个函数，该函数接受数值参数作为`number`或`string`，并将其格式化为具有两位小数的价格值。
- en: Working with Strings
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字符串
- en: Like `numbers`, `strings` are simple immutable data types that are managed within
    the JavaScript runtime as a list of binary values, which are representable as
    characters. Since they are immutable, they cannot be altered. If you modify a
    `string`, using one of the various methods provided, you are actually creating
    a new string with the changes applied.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与`数字`一样，`字符串`是简单的不可变数据类型，在JavaScript运行时作为二进制值的列表进行管理，这些值可以表示为字符。由于它们是不可变的，因此不能被更改。如果你使用提供的方法之一修改`字符串`，实际上是在创建一个新的字符串，并应用了更改。
- en: 'The literal representation of strings is a list of characters surrounded by
    quotes. These quotes can be double quotes, single quotes (apostrophes), or backticks:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的文本表示是由引号包围的字符列表。这些引号可以是双引号、单引号（撇号）或反引号：
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Strings can be thought of as a long list of single characters, much like arrays,
    which will be discussed later. As such, it is possible to query individual, or
    groups of, characters:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将字符串视为一个由单个字符组成的很长列表，就像数组一样，这将在后面讨论。因此，可以查询单个字符或字符组：
- en: '[PRE67]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding code is not a literal representation, but simply an analogy of
    how strings may be perceived. Since strings are lists, it is possible to retrieve
    characters from them using the character index. This is performed by enclosing
    the index with square bracket symbols. The index of a character string starts
    at `0` (zero):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不是文本的文本表示，而只是字符串可能被感知的类比。由于字符串是列表，因此可以使用字符索引从它们中检索字符。这是通过用方括号符号包围索引来完成的。字符字符串的索引从`0`（零）开始：
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Since strings are immutable, you cannot assign a replacement character to an
    index, like so:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是不可变的，因此你不能像这样将替换字符分配给索引：
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It is not possible to modify a `string`. Instead, you can only create a new
    one based on the original. You can either reconstruct it using operators or use
    one of the many `string` functions provided by the `String` object, which will
    be described shortly.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 无法修改`字符串`。相反，你只能根据原始内容创建一个新的。你可以使用运算符重新构造它，或者使用`String`对象提供的许多`字符串`函数之一，这将在稍后描述。
- en: Special Characters
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊字符
- en: Since strings are contained in quotes, placing the same quotes within the string
    can be problematic. Simply typing the quote in the string is the same as terminating
    that string. This will then mean that any proceeding characters may be seen as
    malformed JavaScript code or, possibly worse, executable JavaScript code.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串包含在引号中，因此在字符串内放置相同的引号可能会出现问题。简单地在字符串中键入引号就等同于终止该字符串。这意味着后续的字符可能被视为格式不正确的JavaScript代码，或者更糟，可能是可执行的JavaScript代码。
- en: 'One way to avoid terminating the `string` is to use a different quote to the
    type used to contain the `string`. For instance, if the string is contained in
    double quotes, then single quotes can be used freely. Likewise, containing the
    `string` in single quotes will allow double quotes to be used freely:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 避免终止`字符串`的一种方法是在包含`字符串`时使用不同类型的引号。例如，如果字符串包含在双引号中，则可以自由使用单引号。同样，在单引号中包含`字符串`将允许自由使用双引号：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will work for simple text but is not as foolproof for strings that need
    to contain both quote types.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于简单的文本是有效的，但对于需要包含两种引号类型的字符串来说并不那么保险。
- en: 'The JavaScript language provides a means to `escape` characters included within
    strings so that they are treated differently. This is performed by preceding the
    character to escape with a backslash (`\`) character. In the case of quotes, escaping
    ensures that the quote character is not seen as the string termination character:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言提供了一种方法来`转义`字符串中包含的字符，以便它们被以不同的方式处理。这是通过在要转义的字符之前加上反斜杠（`\`）字符来完成的。在引号的情况下，转义确保引号字符不被视为字符串终止字符：
- en: '[PRE71]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `escape character` can be used with several other characters for varying
    effects. It is even used to escape the escape character, for times when a backslash
    must exist within a `string`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`转义字符`可以与几个其他字符一起使用，以产生不同的效果。它甚至被用来转义转义字符，在这种情况下，反斜杠必须存在于`字符串`中：'
- en: '[PRE72]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Other supported escape characters include the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持的转义字符包括以下内容：
- en: '![Figure 5.15: Escape Characters'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.15：转义字符'
- en: '](img/C14377_05_15.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_15.jpg)'
- en: 'Figure 5.15: Escape Characters'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：转义字符
- en: Concatenation
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: Concatenating is a means of combining elements, end to end, to form a new element.
    With regards to strings, this is simply combining strings together to form a larger
    string.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是将元素首尾相连以形成新元素的一种方法。就字符串而言，这仅仅是把字符串连接起来形成更长的字符串。
- en: 'String concatenation is performed using the plus (`+`) symbol. This is known
    as method overloading:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接使用加号（`+`）符号进行。这被称为方法重载：
- en: '[PRE73]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When concatenating strings, it is important to pay attention to the presence
    of space characters. No additional characters are added at the point of concatenation.
    Therefore, if you require spaces between combined strings, you must add these
    yourself.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接字符串时，需要注意空格字符的存在。在连接点不会添加任何额外的字符。因此，如果你需要在组合的字符串之间添加空格，你必须自己添加。
- en: Since strings are immutable, concatenating strings creates a new string, which
    you can assign to a variable or pass as a parameter to a function. The original
    strings remain unaffected.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是不可变的，连接字符串会创建一个新的字符串，你可以将其分配给变量或作为参数传递给函数。原始字符串不受影响。
- en: Template Literals
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板字符串
- en: Template literals are a more recent addition to the JavaScript language. Surrounding
    strings with backtick quotes (`` ` ``) alter the translation of the literal by
    the JavaScript engine and afford some additional new features.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串是 JavaScript 语言中较新的一个特性。使用反引号（`` ` ``）包围字符串可以改变 JavaScript 引擎对字符串字面量的翻译，并提供了额外的功能。
- en: 'The first interesting feature, and the one that''s the most commonly used,
    is the ability to interpolate expressions within a `string`. This is performed
    by embedding blocks within the string preceded with the dollar (`$`) character.
    Combining strings in this fashion provides the benefit of making string literals
    easier to read, but can also greatly simplify more complex string concatenation
    requirements:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有趣的功能，也是最常用的功能，是能够在字符串中插入表达式。这是通过在字符串中嵌入以美元（`$`）字符开头的块来实现的。以这种方式组合字符串的好处是使字符串字面量更容易阅读，但也可以极大地简化更复杂的字符串连接需求：
- en: '[PRE74]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Another useful feature of template literals is the ability to use physical
    line breaks. By applying line breaks to the JavaScript code, those same breaks
    appear within the resolved string:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串的另一个有用特性是能够使用物理换行符。通过在 JavaScript 代码中应用换行符，这些相同的换行符将出现在解析后的字符串中：
- en: '[PRE75]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Finally, a template expression can contain inner template literals within it
    too, thereby providing a nested template literal implementation. You'll see them
    in the next example. This caters to more complex expressions within the `string`
    itself, such as conditionals or loops.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模板表达式可以包含嵌套的模板字符串，从而提供嵌套模板字符串的实现。你将在下一个示例中看到它们。这适用于字符串本身中的更复杂表达式，例如条件或循环。
- en: The result of template literals is a feature within JavaScript that lends itself
    very nicely to processing pages, and other string data content, in a manner that
    is more manageable. Where JavaScript developers once looked toward third-party
    libraries to perform such feats, such libraries are no longer required.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串的结果是 JavaScript 中的一个特性，非常适合以更可管理的方式处理页面和其他字符串数据内容。在 JavaScript 开发者曾经寻求第三方库来执行此类任务时，这些库现在不再需要。
- en: 'Exercise 5.06: Email Templates'
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.06：电子邮件模板
- en: 'In this exercise, you will create a function that accepts the components of
    an email sending service and combines them into an email body template. To make
    things more interesting, only adults are eligible to post comments on the website.
    Accordingly, the message text will change. Let''s get started:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个函数，该函数接受电子邮件发送服务的组件并将它们组合成电子邮件正文模板。为了使事情更有趣，只有成年人有资格在网站上发表评论。相应地，消息文本将改变。让我们开始吧：
- en: 'Start off by creating a function signature. The parameters of the function
    determine the values that can be entered into the email body. As stated in the
    description, we will require an `age` parameter:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个函数签名。函数的参数决定了可以输入到电子邮件正文的值。如描述中所述，我们需要一个`age`参数：
- en: '[PRE76]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'With this in place, check the passed parameters now. If any are invalid, the
    function will simply return `null`:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此基础上，现在检查传递的参数。如果有任何无效的参数，函数将简单地返回`null`：
- en: '[PRE77]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we're checking whether the number can be used as a valid numerical value
    and whether the `name` and `comments` are `strings`. We could also choose to check
    the length of the strings to ensure they have content, but that is not necessary
    for this exercise.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们检查数字是否可以用作有效的数值，以及`name`和`comments`是否是`字符串`。我们也可以选择检查字符串的长度以确保它们有内容，但在这个练习中这不是必要的。
- en: 'Now that we have valid parameters, we''ll need to create our `body` text with
    the alluded-to nested template expression:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了有效的参数，我们需要创建包含提到的嵌套模板表达式的`body`文本：
- en: '[PRE78]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, a `ternary` operator expression is used to populate the content
    of the interpolation in the `status` line. It would also be possible to invoke
    a function here, but it would not have been acceptable to use an actual `if` condition.
    The reason for this is that an `if` condition is composed of one or more blocks,
    which is not accepted in template interpolation syntax.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，一个三元运算符表达式用于填充 `status` 行的插值内容。在这里调用一个函数也是可能的，但使用实际的 `if` 条件是不被接受的。这样做的原因是
    `if` 条件由一个或多个块组成，这在模板插值语法中是不被接受的。
- en: 'Finally, we can close the function by returning the variable. If you now execute
    the function and pass in some arbitrary parameters, you should see the complete
    interpolated string:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过返回变量来关闭函数。如果你现在执行该函数并传入一些任意的参数，你应该能看到完整的插值字符串：
- en: '[PRE79]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The expected output will be as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 5.16 – Exercise 5.06 output'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – 练习 5.06 输出'
- en: '](img/C14377_05_16.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.16](img/C14377_05_16.jpg)'
- en: 'Figure 5.16: Exercise 5.06 output'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16：练习 5.06 输出
- en: How and where you choose to concatenate or interpolate strings is up to you.
    When tackling a problem, consider whether the code is more readable using one
    form of quotation over another, especially if more than one developer will be
    working with the code.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择如何和在哪里连接或插值字符串取决于你。在解决问题时，考虑使用一种引号形式而不是另一种形式是否会使代码更易于阅读，特别是如果有多个开发者将使用该代码。
- en: The String Object
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串对象
- en: Like number values, character strings also come with a useful object called
    the String object. Similarly, the String object provides numerous functions, methods,
    and properties oriented around strings.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字值一样，字符字符串也附带一个有用的对象，即 `String` 对象。同样，`String` 对象提供了围绕字符串的许多函数、方法和属性。
- en: Also similar to the `Number` object is the `String` function, which converts
    any passed value into a `string`. The `String` function works by calling the value's
    `toString` function, which we'll discuss a little later.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 同样类似于 `Number` 对象的是 `String` 函数，它将任何传入的值转换为字符串。`String` 函数通过调用值的 `toString`
    函数来实现，我们稍后会讨论这一点。
- en: The length Property
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度属性
- en: 'The `String` object, and thus strings themselves, have only one property: the
    `length` property. As the name suggests, the `length` property returns the `length`
    of the `string` as an `integer`. As the indexing of a `string` starts at zero,
    the length is always one more than the last character index:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 对象，以及字符串本身，只有一个属性：`length` 属性。正如其名所示，`length` 属性返回字符串的长度作为一个整数。由于字符串的索引从零开始，长度总是比最后一个字符索引多一个：'
- en: '[PRE80]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `length` property is particularly useful for iterating over the `string`,
    or when working with many of the `string` methods when its `length` is not already
    known.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 属性在迭代字符串或处理其长度尚未已知的大多数字符串方法时特别有用。'
- en: String Methods
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串方法
- en: The `String` object does not have any `static` functions, but it does support
    strings with numerous available methods – far more than those available in the
    `Number` object. This chapter will not attempt to cover them all but will look
    at the more useful methods.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 对象没有任何 `static` 方法，但它支持许多可用的字符串方法——比 `Number` 对象中可用的方法多得多。本章不会尝试涵盖所有这些方法，但会查看更有用的方法。'
- en: Working with and manipulating strings is a common requirement in JavaScript;
    not just for displaying text, but for working with data in general. It is often
    necessary to clip, sort, modify, add, and remove segments of strings using varying
    criteria. As such, JavaScript provides just about every method you could think
    of to make these tasks simple.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中处理和操作字符串是一个常见的需求；不仅用于显示文本，而且用于处理数据。通常需要根据不同的标准剪切、排序、修改、添加和删除字符串的片段。因此，JavaScript
    提供了你可能想到的几乎所有方法来简化这些任务。
- en: 'The following table lists the most commonly used methods that are provided
    by the String object:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了由 `String` 对象提供的最常用的方法：
- en: '![Figure 5.17: String Methods'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.17：字符串方法'
- en: '](img/C14377_05_17.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.17](img/C14377_05_17.jpg)'
- en: 'Figure 5.17: String Methods'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17：字符串方法
- en: 'Exercise 5.07: Sentence Reversal'
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.07：句子反转
- en: 'In this exercise, you will create a function that accepts a string of any size,
    trims any whitespace characters, reverses its content, and then capitalizes the
    first character of the string or of those following a period character. The result
    should look like a normal sentence from a reversed dimension. The purpose of the
    exercise is to understand data transformation. Transforming data is ubiquitous
    in software development. The JavaScript runtime transforms data when it reads
    your code and converts it into a running application. Being able to transform
    data in a simple manner will prove to be a valuable skill. Let''s get started:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个函数，该函数接受任何大小的字符串，删除任何空白字符，反转其内容，然后将字符串中或跟在句号字符之后的第一个字符转换为大写。结果应该看起来像来自反转维度的正常句子。这个练习的目的是理解数据转换。在软件开发中，数据转换无处不在。JavaScript
    运行时在读取你的代码并将其转换为运行中的应用程序时转换数据。能够以简单的方式转换数据将证明是一项宝贵的技能。让我们开始吧：
- en: 'Start off with the function signature. We only want to accept a single parameter,
    which we''ll call `str`; this is an abbreviation of "string":'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数签名开始。我们只想接受一个参数，我们将称之为`str`；这是“字符串”的缩写：
- en: '[PRE81]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, perform the simplest task first, that is, removing any trailing whitespace
    characters from the beginning and end of the string. While doing this, you should
    also ensure that you are actually working with a string value:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，先执行最简单的任务，即从字符串的开始和结束处删除任何尾随的空白字符。在执行此操作时，你还应确保你实际上正在处理一个字符串值：
- en: '[PRE82]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'With the parameter prepared, you should now start a loop. The loop will build
    a new string by walking the parameter string in reverse. Therefore, you will also
    need to declare four additional variables, namely, a temporary variable to hold
    the resulting value, a variable to keep track of the current string index, a variable
    to store the current character, and a variable to keep track of whether the next
    non-whitespace character is at the start of a sentence:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数准备就绪后，你现在应该开始一个循环。这个循环将通过反向遍历参数字符串来构建一个新的字符串。因此，你还需要声明四个额外的变量，即一个临时变量来保存结果值，一个变量来跟踪当前字符串索引，一个变量来存储当前字符，以及一个变量来跟踪下一个非空白字符是否在句子的开始处：
- en: '[PRE83]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding code, we ensure that the counter starts at one less than the
    `length` of the string (the last index of the string) and that the loop iterates
    as long as the counter is greater than or equal to `0` (zero).
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们确保计数器从字符串的`length`减一的位置开始（字符串的最后一个索引）并且循环只要计数器大于或等于`0`（零）就继续迭代。
- en: 'With the loop in progress, store the character at the index into the `chr`
    variable:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环进行时，将索引处的字符存储到`chr`变量中：
- en: '[PRE84]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With the character stored, check whether the previous iteration is found at
    the end of a sentence. If it was, then you will need to uppercase the next non-whitespace
    character. Otherwise, you will need to `lowercase` it:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储字符之后，检查前一个迭代是否出现在句子的末尾。如果是，那么你需要将下一个非空白字符转换为大写。否则，你需要将其`小写`：
- en: '[PRE85]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If the character is the start of a sentence, then the `isStart` flag needs to
    be set back to `false` so that the next iteration doesn't repeat the uppercasing.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果字符是句子的开始，那么`isStart`标志需要被重置为`false`，这样下一个迭代就不会重复大写转换。
- en: 'Since the uppercasing occurred for the previous iteration, check whether you
    should flag a new sentence in this iteration:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于上一次迭代发生了大写转换，检查是否应该在这个迭代中标记一个新的句子：
- en: '[PRE86]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You detect the start of a new sentence by checking for the period character.
    If it is the start of a new sentence, then you set the `isStart` flag, but you
    also need to determine whether this is the very end of the original string. The
    reason for this is that you do not want to copy the last period of the original
    string to the start of the new string, or the result will start with a period,
    which will not make sense. If it is, you simply skip the character altogether
    by decrementing the `index` and continuing the loop.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你通过检查句号字符来检测新句子的开始。如果是新句子的开始，那么你设置`isStart`标志，但你还需要确定这是原始字符串的非常末尾。这样做的原因是，你不想将原始字符串的最后一个句号复制到新字符串的开始处，否则结果将以句号开头，这没有意义。如果是这样，你只需通过递减`index`并继续循环来完全跳过该字符。
- en: 'If the period was not at the end of the original string, make some adjustments.
    You will not want the new sentences to end with a space and then a period – you
    will require the reversal of that. Since the space will have already been applied
    to the result, you need to backtrack by one character and re-add the required
    output. As the result string has now been modified, you will need to continue
    to the next iteration once more:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果句点不在原始字符串的末尾，做一些调整。你不会想让新的句子以空格和句点结尾——你需要反转这一点。由于空格已经应用于结果，你需要回退一个字符并重新添加所需的输出。由于结果字符串现在已经修改，你需要再次继续到下一次迭代：
- en: '[PRE87]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If the loop does not continue, then the current iteration results in a regular
    character, which should simply be appended to the result. Decrement the index
    for the next iteration and close out the loop. End the function by returning the
    result to the caller:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果循环没有继续，则当前迭代的结果是一个普通字符，它应该简单地附加到结果上。为下一次迭代递减索引并关闭循环。通过将结果返回给调用者来结束函数：
- en: '[PRE88]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, go ahead and execute the function. Try passing multiple sentences to it
    inside a single string to see the full result:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行该函数。尝试在单个字符串中传递多个句子以查看完整结果：
- en: '[PRE89]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '![Figure 5.18 – Exercise 5.07 output'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18 – 练习5.07输出]'
- en: '](img/C14377_05_18.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_05_18.jpg]'
- en: 'Figure 5.18: Exercise 5.07 output'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18：练习5.07输出
- en: There you have it. You have just created a string manipulation function using
    methods from the `String` global object. Certainly, the function will not win
    any awards and may not work well if provided with strings containing consecutive
    whitespace characters, but it does work.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。你刚刚使用`String`全局对象的方法创建了一个字符串操作函数。当然，这个函数可能不会赢得任何奖项，并且如果提供了包含连续空白字符的字符串，可能工作得不是很好，但它确实可以工作。
- en: The toString Method
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`toString`方法'
- en: 'Every primitive type in JavaScript can be converted into a string using the
    `String` function. When working with more complex types, however, this is not
    always the case. For instance, with a typical object, converting it into a `string`
    will produce a set result, regardless of the object''s content:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，每个原始类型都可以使用`String`函数转换为字符串。然而，当处理更复杂类型时，情况并不总是如此。例如，对于一个典型的对象，将其转换为`string`将产生一个固定的结果，无论对象的内容如何：
- en: '[PRE90]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The reason for this is that the JavaScript engine doesn't understand how you
    wish the data to be parsed. It could simply be that you require the output to
    form a table of keys and values, or you may simply want a list of the values themselves
    and to discard the keys. The possibilities are endless.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于JavaScript引擎不理解你希望如何解析数据。这可能仅仅是因为你需要输出形成一个键值表，或者你可能只想得到值列表并丢弃键。可能性是无限的。
- en: As such, JavaScript provides the concept of the `toString` value method.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript提供了`toString`值方法的概念。
- en: '`toString` is a method that exists on all data types but is required to be
    overridden on some of the complex types, providing that you have your own parsing
    logic. When calling the `String` function and passing it a value, you are in fact
    invoking the `toString` method on that value:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString`是一个存在于所有数据类型上的方法，但在某些复杂类型上需要被覆盖，前提是你有自己的解析逻辑。当你调用`String`函数并传递一个值时，实际上是在调用该值的`toString`方法：'
- en: '[PRE91]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Overriding the `toString` method is simply a case of supplying an alternative
    function of the same name to the data value. For instance, to override the `toString`
    method in a custom object, you could simply do the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖`toString`方法只是提供一个同名的替代函数给数据值。例如，要覆盖自定义对象中的`toString`方法，你可以简单地这样做：
- en: '[PRE92]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Working with complex objects and object functions will be described fully later
    in this chapter.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面将详细描述处理复杂对象和对象函数。
- en: Numbers with Strings
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串中的数字
- en: '`Numbers` and `strings` are both primitive data types and both overload the
    `+` (addition) operator. However, there is much more of a relationship between
    the two that can prove useful or catch you out if you are not careful.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`数字`和`字符串`都是原始数据类型，并且都重载了`+`（加法）运算符。然而，两者之间还有更多的联系，这可能会在你不小心的时候对你有所帮助或造成困扰。'
- en: Interestingly, numbers and strings in JavaScript can often be interchangeable,
    thanks to an intelligent context-based system. Depending on the circumstances,
    JavaScript will attempt to deduce the resulting type of an expression based on
    the available parameters.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，JavaScript中的数字和字符串通常可以互换，这要归功于一个智能的基于上下文的系统。根据情况，JavaScript将尝试根据可用的参数推断表达式的结果类型。
- en: 'You have already seen that strings can be concatenated using the `+` operator,
    but numbers can also be concatenated into strings:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，可以使用 `+` 运算符连接字符串，但数字也可以连接成字符串：
- en: '[PRE93]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When the JavaScript parser identifies a numeric value and a string value passed
    as expressions to the `+` operator, it will convert the number into a string so
    that the result is a simple string concatenation. This is otherwise known as context-based
    casting.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 解析器识别出传递给 `+` 运算符的数值和字符串值时，它将数字转换为字符串，以便结果是一个简单的字符串连接。这通常被称为基于上下文的类型转换。
- en: 'When the string expression is also a representation of a numerical value and
    is used with other numerical associated operators, such as `/` or `*`, the reverse
    action will occur. At such times, JavaScript''s context-based casting will instead
    convert the string number into an actual number. Here''s an example:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串表达式也是数值的表示，并且与其他数值相关运算符（如 `/` 或 `*`）一起使用时，将发生相反的操作。在这种情况下，JavaScript 的基于上下文的类型转换将字符串数字转换为实际数字。以下是一个示例：
- en: '[PRE94]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: JavaScript will always convert the non-string value into a string when we use
    the `+` operator in order to produce an expected result. It would be too confusing
    if the `+` operator worked differently based on the content of the string expression.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `+` 运算符以产生预期结果时，JavaScript 总是将非字符串值转换为字符串。如果 `+` 运算符根据字符串表达式的内容以不同的方式工作，将会非常混乱。
- en: 'Numbers can also be mathematically calculated when both expressions are a string,
    but again, this will only occur if you''re not utilizing the `+` operator:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个表达式都是字符串时，数字也可以进行数学计算，但再次强调，这只会发生在你没有使用 `+` 运算符的情况下：
- en: '[PRE95]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If it is expected that you will need to add together two numbers represented
    as strings, such as values read from text input fields, always convert them into
    numbers first:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期需要将表示为字符串的两个数字相加，例如从文本输入字段读取的值，始终先将它们转换为数字：
- en: '[PRE96]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Working with Functions
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与函数一起工作
- en: As you've already seen, JavaScript functions are blocks of code with signatures
    naming the variables that were passed to them when invoked. As with any block,
    functions have their own stacks that encapsulate and protect data declared within
    them.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，JavaScript 函数是带有签名的代码块，命名了在调用时传递给它们的变量。与任何块一样，函数有自己的栈，封装并保护了它们内部声明的数据。
- en: In JavaScript, functions are considered first-class types. This means that,
    much like any other type, they can be assigned to variables, passed as parameters
    to other functions, and returned from functions. They are also able to call themselves,
    which is known as recursive and is the quality that helps make JavaScript a functional
    language.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数被视为一等类型。这意味着，就像任何其他类型一样，它们可以被分配给变量，作为参数传递给其他函数，并从函数中返回。它们还可以自我调用，这被称为递归，并且是帮助使
    JavaScript 成为一个函数式语言的特征。
- en: 'There are many forms of function in JavaScript:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中有许多函数形式：
- en: Anonymous functions
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Named functions
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数
- en: Arrow functions
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Generator functions
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数
- en: The differences between them are mostly slight syntactical changes that affect
    how they are used. We will briefly cover each of the function types in this chapter.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的区别主要是一些细微的语法变化，这些变化影响了它们的使用方式。在本章中，我们将简要介绍每种函数类型。
- en: Anonymous Functions
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'Since functions in JavaScript are first class, they exist as a transferable
    resource, much like primitives and objects. Until now, functions have been declared
    and assigned, which means they have a callable name. However, a function is also
    an expression with two states: its `declared format` and its `invocation`.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 中的函数是一等类型，它们就像原始类型和对象一样，是一种可转移的资源。到目前为止，函数已经被声明和分配，这意味着它们有一个可调用的名称。然而，函数也是一个具有两种状态的表达式：它的
    `声明格式` 和它的 `调用`。
- en: 'A function can exist without providing a name in the signature, whereby it
    has the following format:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以在签名中不提供名称而存在，这样它就有以下格式：
- en: '[PRE97]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In JavaScript, it is possible to code a function without providing a name at
    declaration time. Creating functions in this way allows them to be created in
    place, such as in a call to another function:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，可以在声明时不提供函数名称来编写函数。以这种方式创建函数允许它们在调用其他函数时就地创建：
- en: '[PRE98]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Functions can also be assigned to variables and, of course, be received as
    parameters in a function call. Once an anonymous function has been assigned to
    a variable, it becomes a named `function`, since the variable constitutes its
    name:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以分配给变量，当然，在函数调用中也可以作为参数接收。一旦匿名函数被分配给变量，它就变成了一个命名的`函数`，因为变量构成了它的名称：
- en: '[PRE99]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In fact, up until now, you have been writing functions with a global scope.
    Declaring a named function simply means that a variable of the same name will
    be declared in the current scope and will point to that function. For instance,
    the following two syntaxes are equivalent:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，到目前为止，您一直在编写具有全局作用域的函数。声明一个命名函数仅仅意味着在当前作用域中声明一个同名的变量，并将它指向该函数。例如，以下两种语法是等价的：
- en: '[PRE100]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Declaring a function without assigning a name can be considered a function
    literal. Since the function exists at the point of definition, it can also be
    executed in place. How could that be useful? It can encapsulate entire programs
    and avoid dirtying the global namespace:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个没有分配名称的函数可以被认为是函数字面量。由于函数存在于定义点，它也可以就地执行。这有什么用呢？它可以封装整个程序并避免污染全局命名空间：
- en: '[PRE101]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Namespace dirtying is a term to describe functions and variables declared globally.
    While doing so is not disallowed, it can be problematic. If two libraries within
    the same web page create global variables of the same name, there can be unexpected
    results. Creating applications that honor a clean global environment will be discussed
    in a later chapter.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间污染是一个用来描述全局声明的函数和变量的术语。虽然这样做并不被禁止，但可能会出现问题。如果同一网页内的两个库创建了同名全局变量，可能会出现意外的结果。将在后面的章节中讨论创建尊重干净全局环境的应用程序。
- en: Callbacks
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调
- en: An important use case for anonymous functions has often been asynchronous execution
    callbacks. When calling code that does not immediately return a value, but also
    does not stop the execution of code that immediately proceeds it, that code is
    considered `asynchronous`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数的一个重要用例通常是异步执行的回调。当调用不会立即返回值，但也不会停止立即后续代码的执行时，该代码被认为是“异步”的。
- en: 'Applications that contain asynchronous code need a means to alert the rest
    of the application once the asynchronous code has finished running and a value
    must be returned. In JavaScript, callbacks have long been used for this purpose:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 包含异步代码的应用程序需要一种方法来在异步代码运行完成后通知应用程序的其他部分，并且必须返回一个值。在JavaScript中，回调长期以来一直被用于这个目的：
- en: '[PRE102]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The issue with callbacks is that should numerous asynchronous calls need to
    occur sequentially, the resulting code file has a tendency to indent catastrophically.
    This issue is sometimes fondly known as the pyramid of doom or callback hell:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的问题在于，如果需要发生多个顺序执行的异步调用，生成的代码文件往往会过度缩进。这个问题有时被亲切地称为“末日金字塔”或“回调地狱”：
- en: '[PRE103]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As you can see, each new request indents a further two characters. It is not
    uncommon for an application to possess callback chains of several tens of requests,
    thereby reaching the far side of the screen while coding. Developers can choose
    not to indent, as indentation is not a requirement, but not doing so results in
    harder-to-read code. To resolve this, generator functions were introduced. You
    will learn more about generator functions later in this chapter.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每次新的请求都会缩进两个字符。在编码过程中，一个应用程序拥有几十个请求的回调链并不罕见，这会导致代码在屏幕的另一侧。开发者可以选择不缩进，因为缩进不是必需的，但这样做会导致代码难以阅读。为了解决这个问题，引入了生成器函数。您将在本章后面了解更多关于生成器函数的内容。
- en: 'Exercise 5.08: Functional Parameters'
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.08：函数参数
- en: 'In this exercise, you will create a function that accepts two parameters: a
    primitive data type and a function. This function will then combine those parameters
    and return a function as a result. The returned function will work identically
    to the function that was passed as a parameter, with the exception that it will
    always receive the original primitive parameter as its argument. Let''s get started:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个接受两个参数的函数：一个原始数据类型和一个函数。然后，该函数将结合这些参数并返回一个函数作为结果。返回的函数将与其作为参数传递的函数工作方式相同，唯一的区别是它总是将原始原始参数作为其参数。让我们开始吧：
- en: 'Start off by creating the function signature. You know that it will accept
    two parameters and, since it will act as a kind of currying process (a term used
    in functional programming), that''s the name that will be used here:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建函数签名。你知道它将接受两个参数，并且由于它将作为某种柯里化过程（一个在函数式编程中使用的术语），所以这里将使用这个名字：
- en: '[PRE104]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: There is nothing special here. The `curry` function is just like any named function.
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里没有什么特别的。`curry` 函数就像任何命名函数一样。
- en: In this circumstance, it's not important what value the first parameter contains.
    Even if it contained `null`, that would still be valid in this instance, so you
    can accept whatever comes through.
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个参数包含的值并不重要。即使它包含 `null`，在这个例子中仍然有效，所以你可以接受任何传入的值。
- en: 'Now, check if the second parameter is a function. Otherwise, when it is invoked,
    an error may occur if it is some other value type:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查第二个参数是否是函数。如果不是，当它被调用时，如果它是其他值类型，可能会发生错误：
- en: '[PRE105]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now for the fun part. The intention is to always populate the parameter list
    of the passed-in function with the first parameter of this function, however many
    times it is called. To do this, use a local function definition:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候来点乐趣了。目的是始终用这个函数的第一个参数填充传入函数的参数列表，无论它被调用多少次。为此，使用局部函数定义：
- en: '[PRE106]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As you can see, the result here is a function that, whenever it is called, will
    simply call the `fun` function. The `prim` parameter will always remain the same
    here, so the invocation will always produce the same result.
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这里的结果是一个函数，每次调用它时，都会简单地调用 `fun` 函数。`prim` 参数在这里始终不变，所以调用将始终产生相同的结果。
- en: 'Now, return the new function:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回新的函数：
- en: '[PRE107]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Let''s give this a spin. Try calling the function while trying different values
    as parameters:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试一试。尝试调用函数，同时尝试不同的参数值：
- en: '[PRE108]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The expected output will be as follows:'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出将如下所示：
- en: '![Figure 5.19 – Exercise 5.08 output'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.19 – 练习 5.08 输出'
- en: '](img/C14377_05_19.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_05_19.jpg]'
- en: 'Figure 5.19: Exercise 5.08 output'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19：练习 5.08 输出
- en: Arrow Functions
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Arrow functions, sometimes called `fat arrow` functions, are a simplified syntax
    for function declaration:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数，有时称为 `fat arrow` 函数，是函数声明的简化语法：
- en: '[PRE109]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'As shown in the preceding example, arrow functions don''t need to provide a
    block of code and can instead be replaced with an expression. If an expression
    is used, then no `return` keyword is required since expressions already return
    a value. However, the `return` keyword is required if a block is used, since blocks
    are not expressions:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，箭头函数不需要提供代码块，可以用表达式代替。如果使用表达式，则不需要 `return` 关键字，因为表达式已经返回了一个值。然而，如果使用代码块，则需要
    `return` 关键字，因为代码块不是表达式：
- en: '[PRE110]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'As well as functioning without a block, arrow functions can also be declared
    without the parentheses surrounding the parameter list:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以不使用代码块外，箭头函数还可以不使用参数列表周围的括号来声明：
- en: '[PRE111]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'However, the preceding code only works if the parameters are a list of one.
    This is because a list of two or more parameters forms a rather ambiguous statement.
    For instance, consider the following:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的代码只有在参数是一个列表的情况下才能工作。这是因为两个或更多参数的列表会形成一个相当模糊的声明。例如，考虑以下内容：
- en: '[PRE112]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'When reading the preceding declaration, the compiler will not know which of
    the following declaration strings you are trying to achieve:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读前面的声明时，编译器将不知道你试图实现以下哪个声明字符串：
- en: '[PRE113]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Note
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The first two examples will give an error since they attempt to define an arrow
    function in a `var` statement, but without being assigned to a variable.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子将产生错误，因为它们试图在 `var` 语句中定义箭头函数，但没有将其分配给变量。
- en: Arrow Function Caveats
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数注意事项
- en: While arrow functions appear much cleaner and more flexible than regular function
    declarations, there are disadvantages to their use. The first disadvantage is
    that arrow functions cannot be used as an object constructor and it's ill-advised
    to use them as object methods. The reason for this has to do with the second limitation;
    arrow functions have no access to their own this, arguments, or super objects
    (discussed later in this chapter).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然箭头函数看起来比常规函数声明更干净、更灵活，但它们的使用也有缺点。第一个缺点是箭头函数不能用作对象构造函数，并且不建议将它们用作对象方法。原因与第二个限制有关；箭头函数没有访问它们自己的
    this、arguments 或 super 对象（将在本章后面讨论）。
- en: The purpose of arrow functions is simply to enable a cleaner syntax when working
    with anonymous functions. Arrow functions were the first syntactical weapon against
    callback hell, which we described previously. As such, arrow functions should
    be used wisely.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的目的是简单地在工作于匿名函数时提供一个更简洁的语法。箭头函数是我们之前描述的回调地狱的第一个语法武器。因此，箭头函数应该被明智地使用。
- en: Generator Functions
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器函数
- en: Generators are a recent and rather complex addition to the JavaScript language.
    They are incredibly useful functions once you begin to understand them, though
    that may take some effort. Generators do not facilitate any means that cannot
    be carried out in some other fashion within the JavaScript language. As such,
    this section will merely touch upon the subject of generator functions in order
    to alert you to their usefulness.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是JavaScript语言中最近且相当复杂的一个新增功能。一旦你开始理解它们，它们将是非常有用的函数，尽管这可能需要一些努力。生成器不提供任何其他方式无法在JavaScript语言中执行的手段。因此，本节将仅简要介绍生成器函数的主题，以提醒你它们的有用性。
- en: 'Generators provide additional power to sequence iteration. Here''s an example:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器为序列迭代提供了额外的功能。以下是一个例子：
- en: '[PRE114]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The preceding code is an iterator. The loop iterates three times, from `0` to
    `2`. Each time the iteration occurs, the `callback` function is called, and the
    iteration result is passed to it.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个迭代器。循环迭代三次，从`0`到`2`。每次迭代发生时，都会调用`callback`函数，并将迭代结果传递给它。
- en: Now, the problem with loops is that they are a closed stack. For any custom
    code to execute within the loop, the loop needs to have knowledge of what to do
    with the iterated data. This is a restriction that generators aim to overcome.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，循环的问题在于它们是一个封闭的栈。对于任何需要在循环内执行的定制代码，循环需要知道如何处理迭代数据。这是生成器试图克服的限制。
- en: 'Generator functions are declared much like named and anonymous functions, but
    with a slight difference; an asterisk must be placed after the `function` keyword:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数的声明与命名函数和无名函数类似，但有一点不同；在`function`关键字之后必须放置一个星号：
- en: '[PRE115]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The arrow function format cannot be used for generator functions.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数格式不能用于生成器函数。
- en: 'When creating the function body, the same rules for named and anonymous functions
    apply. However, there are some differences. Take a look at the following example,
    based on the preceding loop:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数体时，命名函数和无名函数遵循相同的规则。然而，也有一些不同之处。看看以下基于前面循环的例子：
- en: '[PRE116]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In particular, note the `yield` keyword. `yield` is a keyword that's been borrowed
    from multithreaded languages such as C++. Its usage in those languages is similar
    to its usage here. Essentially, by calling `yield`, you are asking the runtime
    engine to pass control back to the caller. In JavaScript, "passing back of control"
    includes sending a value to the caller. In the preceding example, a value will
    be sent each time the function yields, which will be three times in total.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`yield`关键字。`yield`是一个从诸如C++这样的多线程语言中借用的关键字。在这些语言中的用法与这里的用法相似。本质上，通过调用`yield`，你是在请求运行时引擎将控制权交还给调用者。在JavaScript中，“控制权交还”包括向调用者发送一个值。在上面的例子中，每次函数`yield`时都会发送一个值，总共会发送三次。
- en: 'To use the function, you must create an instance of the generator by invoking
    the function:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该函数，你必须通过调用函数来创建生成器的一个实例：
- en: '[PRE117]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Once you have a generator instance, you can acquire a value:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了生成器实例，你可以获取一个值：
- en: '[PRE118]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'You can call the `next` function many times, until the stream is exhausted.
    Once exhausted, the returned value will be undefined:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以多次调用`next`函数，直到流耗尽。一旦耗尽，返回的值将是`undefined`：
- en: '[PRE119]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The return value of the `next()` function is an object with two fields:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`函数的返回值是一个包含两个字段的对象：'
- en: '[PRE120]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `object` is hidden from the previous examples and we simply return the
    value in order to keep things simple. The done value will return true as long
    as there are more yields to return from the generator. Once the generator is exhausted,
    it will return the following for all successive calls to `next()`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`object`是隐藏的，我们只是返回值以保持事情简单。只要生成器还有更多的`yield`可以返回，`done`值就会返回`true`。一旦生成器耗尽，它将在所有后续对`next()`的调用中返回以下内容：
- en: '[PRE121]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'One point to keep in mind is that the `yield` keyword may be called as many
    times as necessary in the `generator` function. In the previous example, the `yield`
    keyword was used in a loop, but it may just as easily be called elsewhere, too:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`yield` 关键字可以在 `generator` 函数中调用任意多次。在前面的例子中，`yield` 关键字是在循环中使用的，但它也可以在其他地方调用：
- en: '[PRE122]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Generator functions may also use the `return` keyword. If `return` is used,
    then the returned value will be retrieved with a call to `next()`, just like yielded
    values. However, calling return will end the generator, meaning that no more values
    will be returned from calls to `next()`, even if further `yield` keywords exist
    in the function.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数也可以使用 `return` 关键字。如果使用 `return`，那么返回的值将通过调用 `next()` 来检索，就像产生的值一样。然而，调用
    `return` 将结束生成器，这意味着即使函数中存在更多的 `yield` 关键字，也不会从对 `next()` 的调用中返回更多值。
- en: The this Keyword
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`this` 关键字'
- en: All functions, apart from arrow functions, have access to additional objects
    related to the functions' stack. As we mentioned previously, functions provide
    a stack that ring-fences the memory that's used by variables that are declared
    within it, while allowing access to variables declared in the functions or blocks
    surrounding the function being called. This is otherwise known as encapsulation
    and protects the outer stacks from being inadvertently corrupted by function body-related
    processes, while also protecting the data within the function from outside processes.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数（除了箭头函数）都可以访问与函数调用栈相关的额外对象。正如我们之前提到的，函数提供了一个栈，它将声明在其中的变量的内存圈起来，同时允许访问在调用函数的函数或块中声明的变量。这通常被称为封装，它保护外部栈免受函数体相关过程的意外破坏，同时也保护函数内部的数据免受外部过程的侵害。
- en: 'The `this` keyword exists as a means to be able to directly target the context
    present within the execution of the function. While the variables that are declared
    within a function are direct members of the functions stack, the context of the
    function body may specifically be that of another block or object and may even
    be changed at invocation time to be a specific context other than the one the
    function is defined within:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 关键字存在是为了能够在函数执行过程中直接指向当前上下文。虽然函数内部声明的变量是该函数调用栈的直接成员，但函数体的上下文可能具体是另一个块或对象，甚至可能在调用时改变为函数定义之外的特定上下文：'
- en: '![Figure 5.20: Global, object, and function diagram'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.20：全局、对象和函数图'
- en: '](img/C14377_05_20.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_20.jpg)'
- en: 'Figure 5.20: Global, object, and function diagram'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20：全局、对象和函数图
- en: The arguments Keyword
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`arguments` 关键字'
- en: Another keyword that's available to functions is the `arguments` keyword. When
    defining a function signature, the parameters listed within the brackets of the
    signature are known as "named parameters" while the values that are passed to
    the function during invocation are considered the "functions arguments". Named
    parameters map to arguments, where possible, during the execution of the function.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对函数可用的关键字是 `arguments` 关键字。在定义函数签名时，签名括号内列出的参数被称为“命名参数”，而在调用函数时传递给函数的值被认为是“函数参数”。命名参数在函数执行期间尽可能映射到参数。
- en: 'When calling a function, you may pass in as many or as few arguments as you
    like, but they do not need to total the number of parameters listed in the function
    signature. If you specify fewer parameters than are named in the function signature,
    those parameters that are not provided for will simply have a value of undefined:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，你可以传递任意多或少的参数，但它们不需要与函数签名中列出的参数总数相等。如果你指定的参数少于函数签名中命名的参数，那么未提供的参数将简单地具有
    `undefined` 的值：
- en: '[PRE123]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: If, on the other hand, you specify more parameters than are listed for that
    function, those parameters are still made available to the function, despite not
    having enough named parameters; they are simply not named. In such circumstances,
    you can access the additional parameters using the arguments keyword.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，另一方面，你指定的参数多于该函数列出的参数，那么这些参数仍然对函数可用，尽管没有足够的命名参数；它们只是没有被命名。在这种情况下，你可以使用 `arguments`
    关键字访问额外的参数。
- en: Note
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `arguments` keyword is very much like an array. You can access it like an
    array, and you can use it in functions that expect an array. It even has built-in
    array-like functions. However, the `arguments` keyword is not an array.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`关键字非常类似于一个数组。您可以像访问数组一样访问它，并且您可以在期望数组的功能中使用它。它甚至有内置的类似数组的函数。然而，`arguments`关键字不是一个数组。'
- en: 'To access additional function parameters, you can target them specifically
    by index against the `arguments` keyword. For instance, if four arguments were
    passed to the function, you could access the `fourth` argument with the following
    code:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问额外的函数参数，您可以通过索引针对`arguments`关键字进行特定目标。例如，如果向函数传递了四个参数，您可以使用以下代码访问`第四个`参数：
- en: '[PRE124]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'As you''ll see later with arrays, you can find out just how many arguments
    were passed to the function invocation by calling the `length` property:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您稍后将在数组中看到的那样，您可以通过调用`length`属性来找出传递给函数调用的参数数量：
- en: '[PRE125]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `arguments` object can be extremely useful when working with functions of
    a more dynamic nature.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 当与更动态的函数一起工作时，`arguments`对象可以非常有用。
- en: Call and Apply
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用和Apply
- en: As we mentioned previously, JavaScript is an exceptionally flexible language.
    Since functions are first-class citizens in JavaScript, facilities are provided
    by the language to manipulate functions.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，JavaScript是一种非常灵活的语言。由于函数在JavaScript中是一等公民，因此语言提供了操作函数的设施。
- en: Two of the most commonly used tools for this endeavor are `call` and `apply`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项工作中，最常用的两个工具是`call`和`apply`。
- en: 'Both `call` and apply function in very much the same way: by enabling the invocation
    of functions while changing the function stack''s context.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`call`和`apply`函数非常相似：通过启用函数的调用并改变函数调用栈的上下文。'
- en: 'The differences between `call` and `apply` are simply that `call` is solely
    used to manipulate the invoked functions context and `apply` is used for the same
    thing and also to supply an arbitrary number of arguments:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`call`和`apply`之间的区别仅仅是`call`仅用于操作被调用函数的上下文，而`apply`用于相同的目的，并且还可以提供任意数量的参数：'
- en: '[PRE126]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: As you can see, to use `call`, you need to know the number of arguments at development
    time. The arguments that are used in `apply` can be of any `length` and do not
    have to be known.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，要使用`call`，您需要在开发时知道参数的数量。在`apply`中使用的参数可以是任何`长度`，并且不必知道。
- en: 'Exercise 5.09: Dynamic Currying'
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.09：动态Currying
- en: 'This exercise will be a continuation of the previous exercise. Since you now
    know much more about how functions work in JavaScript, we will take the `curry`
    concept to a much higher level by supporting arbitrary numbers of arguments. Let''s
    get started:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这项练习将是之前练习的延续。由于您现在对JavaScript中函数的工作方式了解得更多，我们将通过支持任意数量的参数将`curry`概念提升到更高的水平。让我们开始吧：
- en: 'Start off with your `function` signature. However, since you would like to
    support an arbitrary number of arguments, the function parameter will need to
    come first. Also, as the remaining parameters are `arbitrary`, there is no need
    to define them:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的`函数签名`开始。然而，由于您希望支持任意数量的参数，函数参数需要放在第一位。此外，由于剩余的参数是`任意的`，因此没有必要定义它们：
- en: '[PRE127]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Check that the first parameter is a `function` before continuing with the rest
    of the logic:'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在继续执行其余逻辑之前，请检查第一个参数是否是一个`函数`：
- en: '[PRE128]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'As you may have guessed, you will use the arguments object to acquire the parameters.
    However, you will need to manipulate the arguments list since you will not want
    to pass the function parameter to itself. As we mentioned previously, the `arguments`
    object is not an array, so you''ll need to convert it into one first by manipulating
    it with an `array` function:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所猜测的，您将使用参数对象来获取参数。然而，您需要操作参数列表，因为您不希望将函数参数传递给自己。正如我们之前提到的，`arguments`对象不是一个数组，所以您需要通过使用`array`函数来操作它，首先将其转换为数组：
- en: '[PRE129]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In order to convert `arguments` into an `array`, you need to call a native function
    of `array` instances that copies the array. The `slice` function creates a shallow
    copy of an array. In this case, it doesn't know that the `arguments` object is
    not an array, but still works fine, which is perfect for this use case. The `args.shift()`
    code removes the first item in the array using the newly created array's shift
    function. Since arrays are mutable, like objects, the `args` array value is permanently
    modified.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了将 `arguments` 转换为 `array`，你需要调用 `array` 实例的原生函数来复制数组。`slice` 函数创建了一个数组的浅拷贝。在这种情况下，它不知道
    `arguments` 对象不是一个数组，但仍然可以正常工作，这对于这个用例来说非常完美。`args.shift()` 代码使用新创建的数组的 `shift`
    函数移除数组中的第一个元素。由于数组是可变的，就像对象一样，`args` 数组值被永久修改。
- en: 'Now that you have your parameters list, create your function wrapper, like
    you did previously. This time, however, the `fun` parameter will be invoked using
    `apply`:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你有了参数列表，创建你的函数包装器，就像你之前做的那样。然而，这次，`fun` 参数将使用 `apply` 来调用：
- en: '[PRE130]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Since parameters will be supplied to the `curry` function and the returned function,
    the arguments of each must be joined into a single array. This is what `concat`
    does. The resulting array is then used as the arguments of the `fun` function.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于参数将被提供给 `curry` 函数和返回的函数，因此每个函数的参数必须合并成一个单独的数组。这正是 `concat` 函数的作用。然后，得到的数组被用作
    `fun` 函数的参数。
- en: 'Finally, return the new function and close the `curry` function:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回新的函数并关闭 `curry` 函数：
- en: '[PRE131]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Now, let''s give this a spin:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们试一试：
- en: '[PRE132]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The expected output will be as follows:'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 5.21: Exercise 5.09 output'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.21：练习 5.09 输出'
- en: '](img/C14377_05_21.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_21.jpg)'
- en: 'Figure 5.21: Exercise 5.09 output'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21：练习 5.09 输出
- en: What you have just achieved is no small feat. `Currying` is a powerful tool
    in functional programming, and you have achieved this task with very few lines
    of code.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚取得的成就并不小。`Currying` 是函数式编程中的一个强大工具，而你用非常少的代码就完成了这个任务。
- en: 'Activity 5.01: Simple Number Comparison'
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.01：简单的数字比较
- en: 'A lot has been covered so far, so it''s time for an activity. In this activity,
    you have been tasked with writing a function that will receive the grades for
    a student''s coursework for an entire year as percentages. The function must average
    the result of each grade in order to determine whether the student has passed
    the course for the entire year. The calculation will assume the following:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止已经涵盖了大量的内容，因此是时候进行一个活动了。在这个活动中，你被要求编写一个函数，该函数将接收一个学生整个学年的课程成绩作为百分比。该函数必须计算每个成绩的平均值，以确定学生是否通过了整个学年的课程。计算将假设以下情况：
- en: An average below 35% is an F grade.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均分低于 35% 为 F 级。
- en: An average of 35 – 44% is a D grade.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均分在 35% – 44% 之间为 D 级。
- en: An average of 45% – 59% is a C grade.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均分在 45% – 59% 之间为 C 级。
- en: An average of 60% – 74% is a B grade.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均分在 60% – 74% 之间为 B 级。
- en: An average of 75% and over is an A grade.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均分在 75% 及以上为 A 级。
- en: Grades for each coursework assignment may be passed as a `Number` or a `String`.
    No other data type is expected, so error handling is not necessary.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 每个课程作业的成绩可以作为一个 `Number` 或 `String` 传递。不需要其他数据类型，因此不需要错误处理。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的概要步骤如下：
- en: Create a function. Argument labels aren't necessary as we won't know how many
    arguments there will be.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数。由于我们不知道会有多少个参数，因此不需要参数标签。
- en: Extract the arguments for the function.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取函数的参数。
- en: Get the number of arguments that were passed and store it as a variable.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取传递的参数数量并将其存储为一个变量。
- en: Add all the arguments together and calculate the average. Store this in a variable.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有参数相加并计算平均值。将这个值存储在一个变量中。
- en: Note
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: The final condition will always be true if the others have failed, so the condition
    itself can be skipped. Each condition will not be evaluated if the previous condition
    has been returned from the function.
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果其他条件都失败了，最终条件始终为真，因此可以跳过该条件。如果函数已经从上一个条件返回，则不会评估每个条件。
- en: Determine the `grade` from the student based on the `average` and return it.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据学生的 `average` 确定成绩并返回。
- en: Note
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: The solution to this activity can be found on page 724\.
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第 724 页找到。
- en: This activity should highlight the flexibility and simplicity of common problem-solving
    using JavaScript functions and data types. There are, in fact, many ways to solve
    this problem, but attempting this in a logical, easy-to-read manner is always
    preferable.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动应该强调使用 JavaScript 函数和数据类型解决常见问题的灵活性和简单性。实际上，解决这个问题的方法有很多，但以逻辑、易于阅读的方式尝试总是更可取的。
- en: Working with Objects
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与对象一起工作
- en: In JavaScript, objects are the primary configurable data structures from which
    all other complex data types extend, including `Array` and `Date`. Objects work
    like a `hash map`; they contain `key`/`value` properties that can contain any
    data type, including functions and other objects.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，对象是主要的可配置数据结构，所有其他复杂的数据类型都从中扩展，包括`Array`和`Date`。对象像`哈希表`一样工作；它们包含`键`/`值`属性，可以包含任何数据类型，包括函数和其他对象。
- en: 'An object is defined using curly braces, much like a block:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 对象使用花括号定义，类似于一个块：
- en: '[PRE133]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The values that are added to an object are "members" of that object. Those
    members are accessible using dot notation:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到对象中的值是该对象的“成员”。这些成员可以通过点符号访问：
- en: '[PRE134]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The key of a property may be specified with or without quotes. However, the
    result is exactly the same:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的键可以带引号或不带引号，但结果完全相同：
- en: '[PRE135]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: JavaScript is known as a prototype language, which means its object-oriented
    capabilities are provided by prototyping values to objects prior to instantiation.
    As such, JavaScript objects support the `prototype` keyword. Prototypes are too
    advanced for this chapter and will be discussed at length in further chapters.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 被称为原型语言，这意味着它的面向对象能力是通过在实例化之前将原型值赋给对象来提供的。因此，JavaScript 对象支持`prototype`关键字。原型在本章中过于高级，将在后续章节中详细讨论。
- en: Objects as Hashtables
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象作为哈希表
- en: 'Objects are very much like key/value `hashtables`: you assign a value to an
    object with a given `name` or `key`. These values are arbitrary, and they can
    be primitives, functions, objects, arrays, and so on. Once an object has been
    defined, you can further assign properties to them using dot notation:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 对象非常类似于键/值`哈希表`：你可以使用给定的`名称`或`键`为对象分配一个值。这些值是任意的，可以是原始数据类型、函数、对象、数组等等。一旦定义了一个对象，你可以使用点符号进一步为它们分配属性：
- en: '[PRE136]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'As well as assigning values via dot notation, they can also be assigned by
    named index, much like an `array`:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过点符号分配值之外，它们还可以通过命名索引分配，就像一个`数组`：
- en: '[PRE137]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The result is exactly the same, but there are some differences between these
    approaches.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 结果完全相同，但这些方法之间有一些差异。
- en: 'When using dot notation, the parameters of an object must use standard variable
    naming rules. These include the following:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用点符号时，对象的参数必须使用标准的变量命名规则。这些包括以下内容：
- en: Only use letters, digits, underscores, and dollar symbols.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能使用字母、数字、下划线和美元符号。
- en: Must start with a letter, dollar, or underscore symbol.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须以字母、美元符号或下划线符号开头。
- en: Names are case-sensitive (a and A are different variables).
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称区分大小写（a 和 A 是不同的变量）。
- en: Must not match a reserved word, such as "`while`" or "`if`".
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能匹配保留字，如"`while`"或"`if`"。
- en: Objects keys, however, are not limited by this convention. By using square brackets
    and passing the name as a `string`, the scope for naming keys becomes much broader.
    In fact, you can seemingly use any `ASCII` character of your choice, including
    whitespace characters, with up to `227` characters in length. That's `134,217,728`
    characters!
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对象的键不受此约定的限制。通过使用方括号并传递名称作为`字符串`，命名键的范围变得更为广泛。实际上，你可以似乎使用任何选择的`ASCII`字符，包括空白字符，长度最多可达`227`个字符。那就是`134,217,728`个字符！
- en: '[PRE138]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Aside from strings, digits may also be used as keys. This results in objects
    appearing much like arrays. In fact, for the most part, arrays themselves are
    simply objects, albeit with some superpowers of their own.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串之外，数字也可以用作键。这导致对象看起来很像数组。实际上，大部分数组本身也是对象，尽管它们有一些自己的超级能力。
- en: Note
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Just as strings can be used with square brackets, values can be written and
    read from objects dynamically simply by using variables (or expressions) between
    square brackets instead.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串可以使用方括号一样，值可以通过使用方括号之间的变量（或表达式）动态地写入和读取对象。
- en: Object Keys and Memory
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象键和内存
- en: When working with objects as data stores, it can be tempting to add and retrieve
    all kinds of data. Objects are extremely versatile containers and their use is
    the foundation of many applications. However, as with any language platform, data
    consumes memory. Every time a new key is added to an object, more memory is used
    on the host computer.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当将对象作为数据存储使用时，可能会诱使您添加和检索各种数据。对象是极其灵活的容器，它们的使用是许多应用程序的基础。然而，与任何语言平台一样，数据会消耗内存。每次向对象添加新的键时，主机计算机都会使用更多的内存。
- en: JavaScript uses a rather intelligent `garbage collector`; whose job is to clean
    up discarded data. The issue is, however, that data may not be considered discarded
    if a reference to it exists in an object. If it isn't handled properly, then memory
    will continue to be consumed as you add more data, eventually resulting in your
    browser crashing. This is known as a memory leak!
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用一个相当智能的`垃圾回收器`；其任务是清理废弃的数据。然而，问题在于，如果对象中存在对该数据的引用，则数据可能不会被考虑为废弃。如果处理不当，那么随着你添加更多数据，内存将继续被消耗，最终可能导致浏览器崩溃。这被称为内存泄漏！
- en: 'One way to remove a reference to data from an object is to simply replace it
    with something else. For instance, it is common in JavaScript applications to
    see `null` assigned to object parameters when they are no longer needed. The problem
    with this approach, though, is that while the original value has been detached
    from the object, the new `null` value has now taken its place. null is a value,
    after all. This may not be overly problematic as all `null` values point to the
    same data space, but the contained value is not the only part of the property
    occupying memory; the `key` is also an overhead:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象中删除数据引用的一种方法是将它替换为其他内容。例如，在JavaScript应用程序中，当对象参数不再需要时，通常会将`null`赋值给它们。然而，这种方法的问题在于，虽然原始值已经从对象中分离出来，但新的`null`值已经占据了它的位置。毕竟，null是一个值。这可能不会造成太大的问题，因为所有的`null`值都指向相同的数据空间，但包含的值并不是占用内存的唯一部分；`key`也是一个开销：
- en: '[PRE139]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'In order to fully delete the reference from the object, which includes `key`
    and `value`, the `delete` keyword should be utilized:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全删除对象中的引用，包括`key`和`value`，应该使用`delete`关键字：
- en: '[PRE140]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Object and Pass-By Reference
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象和按引用传递
- en: As we mentioned at the beginning of this chapter, primitive values are immutable
    and exist by value. When passing them to functions or modifying them, a new copy
    is made of the data, which occupies a different location in memory.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，原始值是不可变的，并且按值存在。当将它们传递给函数或修改它们时，数据会创建一个新的副本，这占据了内存中的不同位置。
- en: Objects differ from primitive values in this regard.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，对象与原始值不同。
- en: 'Objects are `mutable` data. This means that instead of a copy of the object
    data being passed to functions or variable assignments within your applications,
    a reference to the original object data is always passed. When modifying an object,
    it is the actual original object being altered. No new object is created:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是`可变`数据。这意味着在您的应用程序中，传递给函数或变量赋值的不是对象数据的副本，而是一直传递原始对象数据的引用。当修改对象时，实际上是修改了原始对象。不会创建新的对象：
- en: '[PRE141]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The reason objects work so differently is that copying object data is slow and
    CPU-intensive. Since objects can be nested, attempting to copy an object that
    has a tree of descendants linked to it can be agonizingly laborious for the host
    machine and is therefore completely impractical.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 对象之所以如此不同，是因为复制对象数据既慢又占用CPU资源。由于对象可以是嵌套的，尝试复制一个具有链接到其上的后代树的对象可能会使主机机器感到痛苦，因此完全不切实际。
- en: Since objects are presented differently, care must be taken with their use.
    Modifying object data by passing the object to functions can be the cause of hard-to-find
    bugs.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象的表现形式不同，在使用它们时必须小心。通过将对象传递给函数来修改对象数据可能是难以发现的错误的原因。
- en: Object Iteration
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象迭代
- en: Since objects work like `hash arrays`, it makes sense that functions exist to
    work with objects as `iterables`. The JavaScript language provides a number of
    functions for use when iterating over objects, but it also provides operators
    to this end, as seen with the in operator.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象像`hash arrays`一样工作，因此存在函数来处理对象作为`iterable`是有意义的。JavaScript语言提供了一些函数用于在迭代对象时使用，但它也提供了运算符来实现这一点，如`in`运算符所示。
- en: 'The in operator converts an object into an `iterable` by iterating over its
    keys:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符通过遍历其键将对象转换为`iterable`：'
- en: '[PRE142]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The same feat can also be accomplished with the `Object.keys(myObj)` function.
    The difference here is that it returns the object''s keys as an array, so it also
    has other usefulness when working with objects:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的功能也可以通过 `Object.keys(myObj)` 函数实现。这里的区别在于它返回一个包含对象键的数组，因此在处理对象时也有其他用途：
- en: '[PRE143]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'It can also be used like so:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以这样使用：
- en: '[PRE144]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'As well as a means to get the object keys as an array, there is a function
    to retrieve the object''s values as an array, too:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取对象键作为数组之外，还有一个函数可以用来获取对象的值作为数组：
- en: '[PRE145]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Finally, should you require both keys and values as associated pairs, JavaScript
    provides the entries function to do just that. The `key`/`value` pairs are provided
    as arrays, with the first item being the key and the second item being the value:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你需要作为关联对同时获取键和值，JavaScript 提供了 entries 函数来实现这一点。`key`/`value` 对作为数组提供，第一个元素是键，第二个元素是值：
- en: '[PRE146]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Object Accessors
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象访问器
- en: As you may have seen, writing to and reading from objects is allowed freely,
    but it may not be what you want. Let's suggest, for example, that you wish to
    create a `gameState` object that will keep track of the player's score and the
    remaining `enemies` in play. By allowing data to be read and written randomly,
    you provide an avenue for bugs to creep into your application.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能看到的，对对象的读写是允许的，但这可能不是你想要的。例如，假设你希望创建一个 `gameState` 对象，用来跟踪玩家的得分和剩余的 `enemies`。通过允许随机读写数据，你为错误潜入你的应用程序提供了途径。
- en: 'Let''s look at an example:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE147]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Now, one solution to restricting access to these properties would be to incorporate
    functions. Here''s an example:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，限制对这些属性访问的一个解决方案是结合使用函数。以下是一个例子：
- en: '[PRE148]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Here, the member variables have been renamed to start with an underscore. This
    is a common practice as it is deemed that any values starting with an underscore
    are values that should not be accessed directly. In *Chapter 4*, *JavaScript Libraries
    and Frameworks*, you will find out how to protect object variables absolutely,
    such that direct access becomes impossible.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，成员变量已经被重命名为以下划线开头。这是一种常见的做法，因为任何以下划线开头的值都被认为是不应该直接访问的值。在 *第4章*，*JavaScript
    库和框架* 中，你将了解到如何绝对保护对象变量，使得直接访问变得不可能。
- en: Now, while the preceding implementation is perfectly reasonable, the properties
    of the objects are no longer assignable but invoked. If you needed to read back
    the values of those properties, you would need yet another set of functions, and
    those would also need to be invoked. In short, it's not very clean.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然前面的实现是合理的，但对象的属性不再可赋值，而是被调用。如果你需要读取这些属性的值，你需要另一组函数，并且这些函数也需要被调用。简而言之，这并不干净。
- en: JavaScript provides a solution to this conundrum through the use of accessors,
    also known as getters and setters. Accessors are a way to add functions that can
    be used like variables, whereby a getter allows for the retrieval of data and
    a setter enables the setting of data.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 通过使用访问器（也称为获取器和设置器）来解决这个问题。访问器是一种添加可以像变量一样使用的函数的方式，其中获取器允许检索数据，而设置器允许设置数据。
- en: 'The syntax for accessors is as follows:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器的语法如下：
- en: '[PRE149]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Let''s rework the previous example to utilize getters and setters:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新整理之前的例子，以利用获取器和设置器：
- en: '[PRE150]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Here, we can see that the `get.score()` allows getting the score and `set.score(value)`
    allows to set a value to the data.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `get.score()` 允许获取得分，而 `set.score(value)` 允许设置数据值。
- en: '[PRE151]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Here, a bit of creative license has been utilized. The `score` can be read
    and written to, just like any other value, except when writing, instead of replacing
    the value, the value is added to the original value, like so:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一些创造性的许可。`score` 可以像任何其他值一样读取和写入，但在写入时，不是替换值，而是将值添加到原始值上，如下所示：
- en: '[PRE152]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The `enemies` value can be read as normal, but by calling `killEnemies`, passing
    a value will deduct it from the current value, but passing no total will deduct
    `1` from the value:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`enemies` 的值可以正常读取，但通过调用 `killEnemies` 并传递一个值，可以从当前值中减去它，如果没有传递总量，则从值中减去 `1`：'
- en: '[PRE153]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Finally, reading the player''s lives property will return the current number
    of lives, but reading `killPlayer` will either deduct a life or it will reset
    it back to `3` lives should there be no enemies left. This may be useful, for
    instance, if you wanted to reset the player''s lives after they''ve completed
    the game:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，读取玩家的生命属性将返回当前的生命数，但读取`killPlayer`将减去一个生命，或者如果没有剩余敌人，它将重置生命回到`3`。这可能很有用，例如，如果你想在玩家完成游戏后重置玩家的生命：
- en: '[PRE154]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Note that if you assign the value of a setter to another variable, that other
    variable will contain whatever was passed to the setter, not the value that was
    determined within the setter logic. If no value is passed, then the accessor is
    not a getter, and so `undefined` is returned.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你将设置器的值赋给另一个变量，那么另一个变量将包含传递给设置器的任何内容，而不是设置器逻辑中确定的值。如果没有传递值，那么访问器不是获取器，因此返回`undefined`。
- en: 'Exercise 5.10: Converting Objects to toString'
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.10：将对象转换为toString
- en: 'In this exercise, you will create a function within an object that provides
    a "pretty print" facility when using the object in circumstances that require
    a `string` value. The function will utilize the `toString` capability, which we
    detailed earlier in this chapter:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将在对象内部创建一个函数，当在需要`string`值的情况下使用该对象时，该函数提供“格式化打印”功能。该函数将利用我们在本章前面详细介绍的`toString`功能：
- en: 'To begin, create an object with a bunch of different values. Add some nested
    objects to make things more interesting:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个包含许多不同值的对象。添加一些嵌套对象以使事情更有趣：
- en: '[PRE155]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Now, if you output this with `console.log`, then it should show up just fine
    as the console is designed to parse complex objects for debugging purposes. However,
    if you concatenate the object data into a string, you''ll get unwanted results:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你使用`console.log`输出这个结果，它应该会正常显示，因为控制台是为了调试目的而设计来解析复杂对象的。然而，如果你将对象数据连接成一个字符串，你会得到不期望的结果：
- en: '[PRE156]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'To rectify this, create a function that parses objects into a string representation:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了纠正这个问题，创建一个函数，将对象解析成字符串表示：
- en: '[PRE157]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The first thing you do here is accept both the passing of an object and utilize
    the current object context. This way, the function can be called against the object
    it exists in it, but also as a passed parameter. You'll need to do this so that
    you can recursively `stringify` any child objects that exist within the parent.
    The `indent` parameter is used to keep track of the child object indentation.
    For each level of child, you meet, you will want to indent it further still. This
    helps you visualize your object structure when printed. Finally, you also need
    the `res` variable to store the resulting string representation as it's being
    built.
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里做的第一件事是接受对象的传递并利用当前对象上下文。这样，函数就可以在它存在的对象上调用，也可以作为传递的参数调用。你需要这样做，以便可以递归地`stringify`父对象中存在的任何子对象。`indent`参数用于跟踪子对象的缩进。对于遇到的每个子级，你都会想要进一步缩进它。这有助于你在打印时可视化对象结构。最后，你还需要`res`变量来存储正在构建的结果字符串表示。
- en: 'Iterate through all of the object''s keys and build the string representation:'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历对象的所有键并构建字符串表示：
- en: '[PRE158]'
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Now, this is where things get a little tricky. If a value for the `k` key is
    also an object, you will want to pretty print that, too. Therefore, just pass
    it to the same function:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，事情变得有点棘手。如果`k`键的值也是一个对象，你也会想要格式化打印它。因此，只需将其传递给同一个函数：
- en: '[PRE159]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: To nest the child, the key for that child is prefixed with the value of the
    current indent parameter. An open curly brace is used to denote an object in the
    returned string. The indent is then increased in length and passed to the recursive
    call to the `objToString` function for the nested iteration. The child print is
    then closed with a closing curly brace, which is also indented.
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了嵌套子对象，该子对象的键会加上当前缩进参数的值作为前缀。在返回的字符串中使用开大括号来表示对象。然后增加缩进长度，并将其传递给`objToString`函数的递归调用以进行嵌套迭代。子对象打印后，使用闭合大括号关闭，该大括号也进行了缩进。
- en: 'If the value of the key is not an object, then it might be a function. You
    will want to skip those as you can''t cleanly print them. Everything else can
    be appended like a string, but will also need to be indented in case it''s the
    value of a field in a child object:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果键的值不是一个对象，那么它可能是一个函数。你将想要跳过这些函数，因为你不能干净地打印它们。其他所有内容都可以像字符串一样附加，但还需要缩进，以防它是子对象字段中的值：
- en: '[PRE160]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Next, apply a delimiter so that each of the keys is separated. A newline character
    should suffice:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，应用一个分隔符，以便每个键都分开。换行符就足够了：
- en: '[PRE161]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Finally, close the loop and return the value:'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，关闭循环并返回值：
- en: '[PRE162]'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'To make this work, append the `objToString` function to the starting object
    as a `toString` function:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这起作用，将 `objToString` 函数附加到起始对象作为 `toString` 函数：
- en: '[PRE163]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Finally, to test this out, simply concatenate the object to a string, forcing
    the object to be cast to a string value:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了测试这一点，只需将对象连接成一个字符串，强制将对象转换为字符串值：
- en: '[PRE164]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The output should be as follows:'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE165]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The expected output will be as follows:'
  id: totrans-693
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出将如下所示：
- en: '![Figure 5.22: Exercise 5.10 output'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.22：练习 5.10 输出'
- en: '](img/C14377_05_22.jpg)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_22.jpg)'
- en: 'Figure 5.22: Exercise 5.10 output'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22：练习 5.10 输出
- en: You have created a useable object `stringifier` function that works with complex
    objects of any depth.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了一个可用的 `stringifier` 函数，它可以与任何深度的复杂对象一起使用。
- en: Working with Arrays
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组操作
- en: 'Arrays are another complex object type built on top of objects. Unlike objects,
    arrays are designed to work with lists of data. Arrays may be created in several
    ways. The first is known as an Array literal and, similarly to object literals,
    is simply a means of passing a defined Array value to a variable:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是建立在对象之上的另一种复杂对象类型。与对象不同，数组旨在与数据列表一起工作。数组可以通过几种方式创建。第一种称为数组字面量，类似于对象字面量，它只是将定义的数组值传递给变量的简单方法：
- en: '[PRE166]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The values of an array have no keys, and are instead accessed using integer
    indexes with the square bracket form:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的值没有键，而是使用整数索引以方括号形式访问：
- en: '[PRE167]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'As with other types, the array type also has a constructor function that''s
    used to create array instances. The array constructor can be passed values to
    prepopulate the `Array`. Therefore, the following examples are equivalent:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型一样，数组类型也有一个构造函数，用于创建数组实例。数组构造函数可以传递值来预填充 `Array`。因此，以下示例是等效的：
- en: '[PRE168]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'However, when using the constructor form, passing a single integer value will
    create an array with a set number of values set to undefined:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用构造函数形式时，传递单个整数值将创建一个具有固定数量的值设置为 `undefined` 的数组：
- en: '[PRE169]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Note that the `Array` constructor can lead to unintended results, should the
    developer intend to create an `Array` with one value as a single integer type.
    As such, it is considered a good practice to initialize all arrays using the literal
    form.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果开发者打算创建一个只有一个整数值的 `Array`，则 `Array` 构造函数可能会导致意外的结果。因此，使用字面量形式初始化所有数组被视为一种良好的实践。
- en: Arrays and Mutability
  id: totrans-708
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组和可变性
- en: Like objects, arrays are mutable objects. If you update an array that is passed
    into a function, the original `Array` is also modified.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象一样，数组是可变对象。如果您更新了一个传递给函数的数组，原始的 `Array` 也会被修改。
- en: The `Array` object has a number of built-in functions that are useful in maintaining
    immutability when using arrays. They do not make the array immutable but provide
    a means to work with arrays while ensuring that they are copied rather than modified.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 对象有几个内置函数，在维护数组使用时的不可变性时很有用。它们不会使数组不可变，但提供了一种在确保它们被复制而不是修改的情况下与数组一起工作的方法。'
- en: The Array's immutability functions will be discussed at length in *Chapter 4*,
    *JavaScript Libraries and Frameworks*, when functional programming methodologies
    are discussed.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的不可变函数将在 *第 4 章*，*JavaScript 库和框架* 中详细讨论，当讨论函数式编程方法时。
- en: Array Iteration
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组迭代
- en: 'Arrays can be iterated in much the same way as objects. If you''re using the
    `for...in` syntax, the element of the `Array` is the index, which is the same
    result when working with objects that have numerical keys:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以像对象一样迭代。如果您使用的是 `for...in` 语法，则 `Array` 的元素是索引，这与处理具有数值键的对象时的结果相同：
- en: '[PRE170]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This format works well if you need to iterate an array from start to finish,
    but this isn't very flexible. To aid the traversal of an Array, JavaScript provides
    a number of additional features.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要从开始到结束迭代一个数组，这种格式效果很好，但这并不灵活。为了帮助遍历数组，JavaScript 提供了多个附加功能。
- en: 'Since an array is a linear list, it has a `length`. The array object provides
    the length property, which returns the number of elements in the array:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是一个线性列表，它有一个 `length` 属性。数组对象提供了一个长度属性，它返回数组中的元素数量：
- en: '[PRE171]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The starting index of an array is always `0`, while the `length` of an array
    is always one more than the last index of the `Array`.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的起始索引始终是 `0`，而数组的 `length` 属性始终比数组的最后一个索引多 `1`。
- en: 'As well as retrieving a value from an array by index, it is also possible to
    search an array for a value and return its index using the `indexOf` function.
    `indexOf` takes a single parameter, that is, the value to find within the array:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过索引从数组中检索值之外，还可以使用`indexOf`函数在数组中搜索值并返回其索引。`indexOf`接受一个参数，即要数组中查找的值：
- en: '[PRE172]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '`indexOf` will return the index of the value if it is found but will return
    `-1` if it does not. A match can be at `index 0` or above, up to but exclusive
    of `arr.length`. To use a result of `indexOf(...)` in a conditional statement,
    compare it and check whether it''s higher than `-1`:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到值，`indexOf`将返回值的索引，如果没有找到，则返回`-1`。匹配可以位于`index 0`或以上，直到但不包括`arr.length`。要在条件语句中使用`indexOf(...)`的结果，比较它并检查它是否大于`-1`：
- en: '[PRE173]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Note that `indexOf` looks for the matching value of an element. Therefore,
    complex types will only be found within the Array if they exist within the Array
    by reference. Here''s an example:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`indexOf`寻找元素的匹配值。因此，只有当复杂类型在数组中通过引用存在时，它们才能在数组中找到。以下是一个示例：
- en: '[PRE174]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Since complex types of identical structure are not considered the same by value,
    it is not possible to find occurrences of complex objects within an Array in this
    manner.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结构相同但复杂的类型在值上不被认为是相同的，因此不可能以这种方式在数组中找到复杂对象的实例。
- en: If multiple occurrences of a value exist within an Array, `indexOf` will return
    the first discovered item index. All other instances of that value will be ignored.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组中存在多个该值的实例，`indexOf`将返回第一个找到的项目索引。该值的所有其他实例都将被忽略。
- en: A companion of the `indexOf` function is the `lastIndexOf` function. This function
    works identically to `indexOf`, with the exception that the index search starts
    at the end of the Array.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`函数的伴随函数是`lastIndexOf`函数。这个函数与`indexOf`函数工作方式相同，唯一的区别是索引搜索从数组的末尾开始。'
- en: Built-In Array Functions
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置数组函数
- en: 'The array type provides many more functions that are useful in traversing,
    copying, concatenating, and presenting array structures. The following table lists
    some important and useful functions that are available as members of the array
    type:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型提供了许多在遍历、复制、连接和呈现数组结构时非常有用的函数。以下表格列出了作为数组类型成员的一些重要且有用的函数：
- en: '![Figure 5.23: Built-in array functions and their descriptions'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.23：内置数组函数及其描述'
- en: '](img/C14377_05_23.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_05_23.jpg)'
- en: 'Figure 5.23: Built-in array functions and their descriptions'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23：内置数组函数及其描述
- en: Working with Dates
  id: totrans-733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日期
- en: The Date object is an important type in JavaScript but is a complicated type
    in any language. Like the `Array` type, the `Date` type is built on top of a JavaScript
    object.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`对象在JavaScript中是一个重要的类型，但在任何语言中都是一个复杂的类型。就像`Array`类型一样，`Date`类型是建立在JavaScript对象之上的。'
- en: 'Dates have no literal format. As such, they must be created using the `Date`
    constructor. There are four ways to do this:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 日期没有文字格式。因此，它们必须使用`Date`构造函数创建。有四种方法可以做到这一点：
- en: An empty constructor creates a date with the current date and time.
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空构造函数创建一个包含当前日期和时间的日期。
- en: The constructor may be passed an integer representing the number of milliseconds
    to have passed since the beginning of `January 1st, 1970`.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数可以传递一个整数，表示自`1970年1月1日`开始经过的毫秒数。
- en: 'Supplying multiple integer parameters will specify date segments, for example:'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多个整数参数将指定日期段，例如：
- en: (year, month, day, hour, minute, second, millisecond)
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (年，月，日，小时，分钟，秒，毫秒)
- en: (year, month, day, hour, minute, second)
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (年，月，日，小时，分钟，秒)
- en: (year, month, day, hour, minute)
  id: totrans-741
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (年，月，日，小时，分钟)
- en: (year, month, day, hour)
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (年，月，日，小时)
- en: (year, month, day)
  id: totrans-743
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (年，月，日)
- en: (year, month)
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (年，月)
- en: Be aware that the month is specified by the numbers `0` - `11`.
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，月份由数字`0`至`11`指定。
- en: 'Supplying a string representation of a date:'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供日期的字符串表示：
- en: ISO 8601 date format ("`2019-04-25`" or "`2019-04-25T12:00:00Z`", where months,
    days, and time are padded to two-digit lengths)
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ISO 8601日期格式（例如`"2019-04-25"`或`"2019-04-25T12:00:00Z"`，其中月份、日期和时间填充为两位数字长度）
- en: US short date format ("`04/25/2019`" with padded day and month)
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 美国短日期格式（例如`"04/25/2019"`，日期和月份填充）
- en: US long date format ("`Apr 25 2019`" and so on)
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 美国长日期格式（例如`"Apr 25 2019"`等）
- en: Note
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot create a `Date` instance by simply passing the year value as an integer
    since the JavaScript engine will not know whether you meant year or milliseconds.
    However, you can create a Date instance from simply passing a year string.
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不能仅仅通过传递年值作为整数来创建一个`Date`实例，因为JavaScript引擎将不知道你是指年还是毫秒。然而，你可以通过简单地传递一个年字符串来创建一个`Date`实例。
- en: 'Once a `Date` object has been constructed, it can be queried. The `Date` object
    provides numerous functions for extracting the elements of the `date`. The following
    table lists the functions that are available:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了`Date`对象，就可以对其进行查询。`Date`对象提供了许多用于提取`date`元素的函数。以下表格列出了可用的函数：
- en: '![Figure 5.24: The Date object methods and their descriptions'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.24：Date对象方法和它们的描述](img/C14377_05_24.jpg)'
- en: '](img/C14377_05_24.jpg)'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.24：Date对象方法和它们的描述](img/C14377_05_24.jpg)'
- en: 'Figure 5.24: The Date object methods and their descriptions'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24：Date对象方法和它们的描述
- en: Note
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Each of the functions provided by Date returns a value starting from 0, with
    the exception of the `getDate` method. This often leads to confusion and bugs,
    so be sure to keep this in mind.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`提供的每个函数返回一个从0开始的值，除了`getDate`方法。这通常会导致混淆和错误，所以请务必记住这一点。'
- en: 'Each of the functions detailed in the preceding table also has a set equivalent,
    with the exception of `getDay`. Therefore, to update the hour of the `Date` instance,
    you simply call `setHour` and pass it an integer:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在前表中详细说明的每个函数都有一个等效的集合，除了`getDay`。因此，要更新`Date`实例的小时，你只需调用`setHour`并传递一个整数：
- en: '[PRE175]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Parsing Date Strings
  id: totrans-760
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析日期字符串
- en: As we mentioned previously, the `Date` constructor can accept a date string
    and convert it into an instance of the `Date` object. Dates are represented internally
    within the Date type as integers. Thus, the `getDate` method returns the true
    interpretation of the date value.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`Date`构造函数可以接受一个日期字符串并将其转换为`Date`对象的一个实例。日期在`Date`类型内部以整数的形式表示。因此，`getDate`方法返回日期值的真正解释。
- en: 'If you have a valid date string, as detailed previously, you can convert it
    into a date by calling the `parse` method:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个有效的日期字符串，如前所述，你可以通过调用`parse`方法将其转换为日期：
- en: '[PRE176]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'However, the return value of the `Date.parse` method does not return a `Date`
    instance. Instead, it returns the number of milliseconds since `January 1st, 1970`
    until that date. In order to create a `Date` instance, you must, therefore, pass
    that resulting value to the `Date` constructor:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Date.parse`方法的返回值并不返回一个`Date`实例。相反，它返回自`1970年1月1日`到该日期的毫秒数。因此，为了创建一个`Date`实例，你必须将这个结果值传递给`Date`构造函数：
- en: '[PRE177]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Formatting Dates into Strings
  id: totrans-766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日期格式化为字符串
- en: 'The `Date` object provides its own `toString` function. If you attempt to use
    a `Date` instance as a `string`, you will receive a formatted string instead:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`对象提供了自己的`toString`函数。如果你尝试将`Date`实例用作`string`，你将收到一个格式化的字符串：'
- en: '[PRE178]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'However, this is often not the format you require. If you wish to provide your
    own date string format, you can override the `toString` function of the object,
    much like in the *Working with Object* section of this chapter. Here''s an example:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这通常不是你需要的格式。如果你希望提供自己的日期字符串格式，你可以覆盖对象的`toString`函数，就像在本章的*与对象一起工作*部分中一样。以下是一个示例：
- en: '[PRE179]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The output of this code will be as follows:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出将如下所示：
- en: '[PRE180]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Date Math
  id: totrans-773
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期数学
- en: JavaScript provides no functions for comparing, adding, or subtracting dates.
    However, working out date differences or combining dates is not hard in JavaScript.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有提供比较、添加或减去日期的函数。然而，在JavaScript中计算日期差异或组合日期并不困难。
- en: 'Typically, there are two tasks that need to be considered when comparing dates:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在比较日期时需要考虑两个任务：
- en: What the difference is between two dates
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个日期之间的差异是什么
- en: Adding or subtracting time to/from a date
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向/从日期添加或减去时间
- en: 'The first task is relatively simple. Since the date can be converted into a
    simple integer representing the number of milliseconds since `January 1st, 1970`,
    the dates you wish to difference can simply be represented as milliseconds and
    that value can be compared. Here''s an example:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务相对简单。由于日期可以转换为表示自`1970年1月1日`以来的毫秒数的简单整数，因此你希望差异的日期可以简单地表示为毫秒，并且可以比较这个值。以下是一个示例：
- en: '[PRE181]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Now, with the number of milliseconds in each, you can convert that into a time
    unit. For example, if you wanted to find out the number of days that difference
    represents, you would simply do the following:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了每个时间单位的毫秒数，你可以将其转换为时间单位。例如，如果你想找出这个差异代表的天数，你只需做以下操作：
- en: '[PRE182]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: To get the unit, you simply start with milliseconds and work up. Therefore,
    a day is `1,000 milliseconds * 60 seconds * 60 minutes * 24 hours`.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取单位，你只需从毫秒开始，逐步向上。因此，一天是`1,000毫秒 * 60秒 * 60分钟 * 24小时`。
- en: 'Adding or subtracting time from dates is also very simple. The set* methods
    provided by the `Date` object provide a means for us to roll over values that
    exceed the next largest unit. For instance, if the current date is `April 25,
    2019`, adding `10` days will change the date to `May 5, 2019`. This feature is
    applicable to all of the `set` functions. Thus, to add time, simply get the unit
    of time you wish to add to and add to it:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 从日期中添加或减去时间也非常简单。`Date`对象提供的`set`方法为我们提供了一种方法，可以滚动超过下一个最大单位值的值。例如，如果当前日期是`2019年4月25日`，添加`10`天将日期更改为`2019年5月5日`。此功能适用于所有`set`函数。因此，要添加时间，只需获取你想要添加的时间单位并添加即可：
- en: '[PRE183]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Activity 5.02: Creating a To-Do Model'
  id: totrans-785
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第5.02节：创建待办模型
- en: Let's utilize all the information we have learned about in this chapter and
    see what we have retained. For this activity, imagine that you are working with
    a team of developers and your project is to create a stateful model that stores
    entries for a To-Do application. The model will be a primary function, though
    other functions can be created and used by it. The function will need to store
    one or more entries and will receive "actions" that tell the state to change.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用本章所学到的所有信息，看看我们记住了什么。为此活动，想象你正在与一组开发者合作，你的项目是创建一个存储待办应用条目的状态模型。该模型将是一个主函数，尽管可以创建并使用其他函数。该函数需要存储一个或多个条目，并将接收“动作”来告诉状态改变。
- en: 'These actions will include the following:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动作将包括以下内容：
- en: Create a new To-Do
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的待办事项
- en: Remove a To-Do
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个待办事项
- en: Modify a To-Do
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改一个待办事项
- en: Actions will be passed to the state with a given action keyword of either `CREATE`,
    `REMOVE`, or `MODIFY`.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 动作将以给定的动作关键字`CREATE`、`REMOVE`或`MODIFY`传递给状态。
- en: 'Each To-Do item in the state will have the following fields:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 状态中的每个待办事项都将有以下字段：
- en: '![Figure 5.25: Activity fields'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25：活动字段'
- en: '](img/C14377_05_25.jpg)'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_05_25.jpg]'
- en: 'Figure 5.25: Activity fields'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25：活动字段
- en: The data will be passed to the state function with the action type. If the action
    is a `CREATE` action, then all of the preceding fields will be passed, with the
    exception of the `id` field. If it is a `REMOVE` action, then only the `id` is
    passed. It will be passed as a string value. Finally, if the `MODIFY` action is
    passed, then all of the data is passed, with the exception of the `created_at`
    value. This is because the `created_at` value shouldn't change.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 数据将以动作类型传递给状态函数。如果动作是`CREATE`动作，则将传递所有前面的字段，除了`id`字段。如果是`REMOVE`动作，则只传递`id`。它将以字符串值传递。最后，如果传递了`MODIFY`动作，则将传递所有数据，除了`created_at`值。这是因为`created_at`值不应该改变。
- en: An important part of this task is to ensure that the state data is treated as
    immutable since the project manager is a fan of functional programming and wants
    to ensure that as few bugs as possible are added to the application. No objects,
    including `Arrays` and `Dates`, should be changed in this activity. Instead, new
    objects, `Arrays`, and `Dates` must be created, replacing the old values. This
    must also be true of the Array containing the `TODO` entries.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务的一个重要部分是确保状态数据被视为不可变，因为项目经理是函数式编程的粉丝，并希望确保尽可能少地将错误添加到应用程序中。在此活动中，不应更改任何对象，包括`数组`和`日期`。相反，必须创建新的对象、`数组`和`日期`，以替换旧值。这同样适用于包含`TODO`条目的数组。
- en: Note
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Array `concat` function returns a new Array, but any objects within it will
    still be references to the original values.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`的`concat`函数返回一个新的`Array`，但其中任何对象仍然是原始值的引用。'
- en: Finally, when each action is received, the state function will need to pretty-print
    the data to the console. For `CREATE` actions, this will be the incoming data
    and for `REMOVE` actions, this will be the removed data. For `MODIFY` actions,
    both the removed and created data should be printed.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当接收到每个动作时，状态函数需要将数据以美观的格式打印到控制台。对于`CREATE`动作，这将是对传入数据的打印，对于`REMOVE`动作，这将是对删除数据的打印。对于`MODIFY`动作，应打印删除和创建的数据。
- en: If all goes to plan, you will be able to add, remove, and modify entries in
    your state function without worrying about corrupted data. You can prove this
    by modifying the values you send to the state function. If the entries in the
    state function are also modified, your model is not immutable.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，你将能够在不担心数据损坏的情况下向你的状态函数添加、删除和修改条目。你可以通过修改发送到状态函数的值来证明这一点。如果状态函数中的条目也被修改，则你的模型不是不可变的。
- en: This activity highlights a common means to handle application data effectively
    and in a way that will not introduce bugs to your application. By managing data
    in a pure manner, you will ensure that your development practices produce reliable
    results in a short period of time.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动突出了处理应用程序数据的一种常见方法，这种方法既有效，又不会向应用程序引入错误。通过以纯方式管理数据，你将确保你的开发实践在短时间内产生可靠的结果。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的概述步骤如下：
- en: 'Create the function signature to accept the following:'
  id: totrans-804
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数签名以接受以下内容：
- en: The current state, which is the current list of To-Do items
  id: totrans-805
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前状态，即当前待办事项列表
- en: The action, which is simply a string value
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作，它只是一个字符串值
- en: The data to apply to the state change
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用到状态变化的数据
- en: 'The function signature will look as follows:'
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数签名将如下所示：
- en: '[PRE184]'
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Here, `state` is the current Array of `ToDo` items in the model, `action` is
    either `CREATE`, `MODIFY`, or `REMOVE`, and `data` is either new `ToDo` data or
    simply the parameter to match a `ToDo` item to remove.
  id: totrans-810
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`state` 是模型中当前 `ToDo` 项的数组，`action` 是 `CREATE`、`MODIFY` 或 `REMOVE` 之一，而
    `data` 是新的 `ToDo` 数据或匹配要删除的 `ToDo` 项的参数。
- en: Create a conditional for each action type. Then, in the body of the condition,
    manipulate the state as needed. Remember to return the new state within the condition
    body. You may want to create a secondary function that does the lookup of a `ToDo`
    within the state as you'll need this functionality in the `MODIFY` and `REMOVE`
    actions.
  id: totrans-811
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每种动作类型创建一个条件。然后，在条件的主体中，根据需要操作状态。请记住，在条件主体中返回新的状态值。你可能需要创建一个辅助函数来在状态中查找 `ToDo`，因为你需要在
    `MODIFY` 和 `REMOVE` 动作中使用此功能。
- en: Remember, this function should always return a new state value. That way, it
    is possible to cleanly test the function predictably and ensure that it works
    as intended.
  id: totrans-812
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，这个函数应该始终返回一个新的状态值。这样，就可以干净利落地测试函数，并确保它按预期工作。
- en: 'An example of how this function may be called is as follows:'
  id: totrans-813
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数可能被调用的示例如下：
- en: '[PRE185]'
  id: totrans-814
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Note
  id: totrans-815
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 726\.
  id: totrans-816
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第 726 页找到。
- en: Summary
  id: totrans-817
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A lot has been covered in this chapter. You should now have a deeper understanding
    of the types provided by JavaScript, but also the subtle ways in which each type
    is related. Understanding how data is represented in a language provides a solid
    foundation for building applications more quickly and with fewer bugs.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。你现在应该对 JavaScript 提供的类型有更深入的了解，但也要了解每种类型之间微妙的关系。了解数据在语言中的表示方式为快速构建应用程序并减少错误提供了坚实的基础。
- en: As well as understanding the data types, you also saw how to manipulate them,
    both with methods and with helper functions provided by the JavaScript engine.
    You also saw how to convert data into different types, in order to enable data
    interoperability.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 除了了解数据类型外，你还看到了如何使用方法以及 JavaScript 引擎提供的辅助函数来操作它们。你还看到了如何将数据转换为不同类型，以便实现数据互操作性。
- en: Finally, you saw how you can debug your data using the console and using string-based
    data formatting capabilities provided by the language.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你看到了如何使用控制台和语言提供的基于字符串的数据格式化功能来调试你的数据。
- en: In the next chapter, you will start down the path of user interactivity and
    see how events can be triggered to force your code to do something. You will also
    be introduced to the relationship between the JavaScript language and the HTML
    DOM in the browser environment.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始学习用户交互的道路，并了解如何触发事件来强制你的代码执行某些操作。你还将了解到在浏览器环境中，JavaScript 语言与 HTML
    DOM 之间的关系。
