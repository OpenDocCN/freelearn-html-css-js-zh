- en: Chapter 4. Using Materials to Customize 3D Objects Appearance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：使用材料定制3D对象外观
- en: The objects that we call *materials* are essential in 3D rendering. They are
    used to render objects on the screen and how they are rendered. This means that
    the materials are used to apply textures and transformations such as waves, for
    example, manage transparency and more. In other words, materials are interfaces
    that are used to easily customize the 3D object's appearance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为*材料*的对象在3D渲染中至关重要。它们被用来在屏幕上渲染对象以及它们的渲染方式。这意味着材料被用来应用纹理和变换，例如波浪，例如管理透明度等等。换句话说，材料是用于轻松定制3D对象外观的接口。
- en: 'The following is an example with Babylon.js:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Babylon.js的示例：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Discussing the awesome theory behind the materials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论材料背后的神奇理论
- en: Using the Babylon.js standard material
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Babylon.js标准材料
- en: Using textures with materials
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用材料与纹理
- en: Discussing the awesome theory behind the materials
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论材料背后的神奇理论
- en: The materials are used to customize 3D objects appearance; however, behind them
    lie two programs called **shaders**. The goal of materials is to hide this notion
    of shaders and simply work with the values in the material object. In other words,
    the values in the material can be the emissive color of the object, the diffuse
    color, the transparency level and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 材料被用来定制3D对象的外观；然而，在其背后隐藏着两个被称为**着色器**的程序。材料的目标是隐藏这种着色器的概念，并简单地与材料对象中的值一起工作。换句话说，材料中的值可以是物体的发射颜色、漫反射颜色、透明度等级等等。
- en: 'In fact, to go further with the theory, there are several types of shader,
    as shown in the following list:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，要进一步探讨理论，有几种类型的着色器，如下列所示：
- en: '**Vertex Shader**: This works directly on the 3D object geometry.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这直接作用于3D对象几何形状。'
- en: '**Pixel Shader**: This works directly on the pixels on the screen.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素着色器**：这直接作用于屏幕上的像素。'
- en: '**Geometry Shader** (not available on WebGL): This works on the 3D object geometry;
    however, here it is able to directly add polygons to the geometry of the 3D object
    according to the output of the vertex shader.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几何着色器**（在WebGL中不可用）：这作用于3D对象几何形状；然而，在这里它能够根据顶点着色器的输出直接向3D对象的几何形状中添加多边形。'
- en: '**Compute Shader** (not available on WebGL): This doesn''t work directly on
    the 3D objects and pixels. It is just used to compute some user-defined data using
    the GPU instead of the CPU. For example, a compute shader will take a texture
    as the input (you can see that as a big matrix) and output the results of the
    program in another texture. The compute shader is highly used, for example, to
    compute realistic ocean waves or neural networks.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算着色器**（在WebGL中不可用）：这不能直接在3D对象和像素上工作。它只是用来使用GPU而不是CPU计算一些用户定义的数据。例如，计算着色器将一个纹理作为输入（你可以将其视为一个大矩阵）并将程序的输出结果输出到另一个纹理中。计算着色器被高度用于计算逼真的海洋波浪或神经网络。'
- en: '**Tesselation Shader** (not available on WebGL): This allows us to compute **Level
    of Detail** (**LOD**) directly on the GPU instead of the CPU (fairly new in the
    modern rendering pipelines, such as Direct3D 11 and OpenGL 4.0).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细分着色器**（在WebGL中不可用）：这允许我们在GPU上直接计算**细节级别**（**LOD**），而不是在CPU上（在现代渲染管线中如Direct3D
    11和OpenGL 4.0中相对较新）。'
- en: In our case and with WebGL, only the vertex and pixel shaders are used to render
    3D scenes on the screen; however, it would not be surprising to see the other
    types of shaders being implemented in WebGL in the future.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例和WebGL中，只有顶点和像素着色器被用来在屏幕上渲染3D场景；然而，在将来看到其他类型的着色器在WebGL中实现并不会令人惊讶。
- en: The theory
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论
- en: The meshes that we created in the previous chapters contain vertex buffers and
    index buffers. The vertex buffers describe the 3D positions of the vertices. The
    main problem is how to project the vertices in a 3D space into a 2D space, which
    is the screen space. Indeed, to draw elements on the screen, GPUs are used through
    programs to transform the vertices positions into 2D positions on the screen.
    These programs are the vertex shader and the pixel shader. They are written with
    a language named GLSL, which is the OpenGL shading language used with WebGL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中创建的网格包含顶点缓冲区和索引缓冲区。顶点缓冲区描述了顶点的3D位置。主要问题是如何将3D空间中的顶点投影到2D空间，即屏幕空间。实际上，为了在屏幕上绘制元素，GPU通过程序将顶点位置转换成屏幕上的2D位置。这些程序是顶点着色器和像素着色器。它们是用一种名为GLSL的语言编写的，这是与WebGL一起使用的OpenGL着色语言。
- en: The vertex shader
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: The vertex shader is used to transform the vertices positions. It is executed
    by the GPU for each vertex and can be used for an infinite number of functions.
    For example, to create waves on a large ocean plane, we will use the vertex shader
    to compute the wave function for each vertex instead of using the TS code that
    is executed on the CPU side–leave the job to the real worker.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器用于转换顶点位置。它由GPU为每个顶点执行，可以用于无限数量的功能。例如，为了在大型海洋平面上创建波浪，我们将使用顶点着色器计算每个顶点的波浪函数，而不是使用在CPU端执行的TS代码——把工作留给真正的工人。
- en: Once the vertex shader computes a triangle (a face) on the screen, thanks to
    the index buffer, the pixel shader is called to illuminate the pixels used by
    the current triangle (current face) of the current mesh that is rendered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦顶点着色器在屏幕上计算出一个三角形（一个面），多亏了索引缓冲区，像素着色器就会被调用，以照亮当前渲染的当前网格（当前面）当前三角形（当前面）使用的像素。
- en: The pixel shader
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素着色器
- en: The pixel shader has the same structure as the vertex shader; it is written
    with the same language (GLSL) and is called for each pixel used by the current
    triangle on the screen. The main function of the pixel shader is to return a color
    computed in the RGBA format, which can be determined from a user-defined value
    or directly from a texture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 像素着色器具有与顶点着色器相同的结构；它使用相同的语言（GLSL）编写，并且为屏幕上当前三角形使用的每个像素调用。像素着色器的主要功能是返回一个以RGBA格式计算的颜色，该颜色可以从用户定义的值或直接从纹理中确定。
- en: Using the Babylon.js standard material
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Babylon.js标准材质
- en: Babylon.js allows you to create materials, which means that it can create the
    custom materials with custom shaders; however, it provides a standard material
    with already-developed shaders that are designed to be adapted by many customizations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 允许你创建材质，这意味着它可以创建具有自定义着色器的自定义材质；然而，它提供了一个已经开发好的标准材质，该材质设计为可以通过许多自定义来适应。
- en: In fact, when you add a light to a Babylon.js scene, the light properties such
    as diffuse color, are sent to the materials of the scene to compute the light
    contributions on the meshes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当你向Babylon.js场景添加灯光时，灯光属性，如漫反射颜色，会被发送到场景的材质中，以计算网格上的光贡献。
- en: The standard material and its common properties
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准材质及其常见属性
- en: 'In Babylon.js, each mesh has a material and the meshes can share the same material.
    Creating a standard material and assigning it to a mesh with Babylon.js is as
    easy as writing the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Babylon.js中，每个网格都有一个材质，网格可以共享相同的材质。使用Babylon.js创建标准材质并将其分配给网格，就像编写以下代码一样简单：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Simply create a new `StandardMaterial` object by giving a name to the material
    and the scene where you want to add the material and assign it `the.material`
    property of a mesh. Once the material is created, you can start modifying the
    values and then customize the mesh appearance. The default material by default
    looks similar to the following image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给材质命名以及指定你想要添加材质的场景，简单地创建一个新的`StandardMaterial`对象，并将它分配给网格的`the.material`属性。一旦材质创建完成，你就可以开始修改值并自定义网格外观。默认材质默认看起来类似于以下图像：
- en: '![The standard material and its common properties](img/image_04_001.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![标准材质及其常见属性](img/image_04_001.png)'
- en: 'The diffuse color: The diffuse color represents the color of the object, as
    follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漫反射颜色：漫反射颜色表示物体的颜色，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![The standard material and its common properties](img/image_04_002.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![标准材质及其常见属性](img/image_04_002.png)'
- en: 'The specular color: The specular color represents the light color reflected
    by the object (this is mixed with the diffuse color), as shown in the following:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜面颜色：镜面颜色表示物体反射的光的颜色（这与漫反射颜色混合），如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![The standard material and its common properties](img/image_04_003.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![标准材质及其常见属性](img/image_04_003.png)'
- en: 'The emissive color: The emissive color represents the color emitted by the
    object (this is mixed with the specular color and the diffuse color), as follows:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发光颜色：发光颜色表示物体发出的颜色（这与镜面颜色和漫反射颜色混合），如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![The standard material and its common properties](img/image_04_004.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![标准材质及其常见属性](img/image_04_004.png)'
- en: 'Manage transparency: To manage transparency, the standard material provides
    a .alpha property in the [0, 1] interval, as follows:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理透明度：为了管理透明度，标准材质在[0, 1]区间提供了一个.alpha属性，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![The standard material and its common properties](img/image_04_005.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![标准材质及其常见属性](img/image_04_005.png)'
- en: Using the fog
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用雾效
- en: 'The standard material allows you to apply the fog effect that is related to
    the current scene that is rendered. To enable the fog on an object, simply set
    `the.fogEnabled` property to true on the materials and the scene, as shown in
    the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标准材质允许你应用与当前渲染场景相关的雾效。要在一个对象上启用雾，只需在材质和场景上设置 `the.fogEnabled` 属性为 true，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s start with the following scene:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下场景开始：
- en: '![Using the fog](img/image_04_006.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![使用雾效](img/image_04_006.png)'
- en: 'The fog in a scene can be customized. There are several types of fog, as shown
    in the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的雾可以自定义。以下列出了几种雾的类型：
- en: Linear fog (`BABYLON.Scene.FOGMODE_LINEAR`)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性雾 (`BABYLON.Scene.FOGMODE_LINEAR`)
- en: Exponential (`BABYLON.Scene.FOGMODE_EXP`)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数 (`BABYLON.Scene.FOGMODE_EXP`)
- en: Exponential 2 (faster than the previous) (`BABYLON.Scene.FOGMODE_EXP2`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数 2（比之前更快）(`BABYLON.Scene.FOGMODE_EXP2`)
- en: 'With the linear mode, the two properties—`scene.fogStart` and `scene.fogEnd`—can
    be set. Consider the following, as an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性模式下，可以设置两个属性——`scene.fogStart` 和 `scene.fogEnd`。以下是一个示例：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Using the fog](img/image_04_007.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![使用雾效](img/image_04_007.png)'
- en: 'Change the fog color using the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法更改雾的颜色：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Using the fog](img/image_04_008.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用雾效](img/image_04_008.png)'
- en: With the exponential mode, the `scene.fogDensity` property can be set.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在指数模式下，可以设置 `scene.fogDensity` 属性。
- en: 'Consider the following as an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Using the fog](img/image_04_009.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用雾效](img/image_04_009.png)'
- en: Using textures with materials
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用材质使用纹理
- en: This chapter is the right place to introduce the usage of textures. Textures
    are images (`.png`,`.jpeg`, and so on) that graphics libraries are able to apply
    to meshes. There are several types of texturing methods handled by Babylon.js,
    such as video textures, cube textures, and so on. Now, let's explain how to use
    textures with materials.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是介绍纹理使用的合适位置。纹理是图像（`.png`、`.jpeg` 等），图形库能够将其应用到网格上。Babylon.js 处理了多种纹理方法，例如视频纹理、立方体纹理等。现在，让我们解释如何使用材质来使用纹理。
- en: Load and apply a texture
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载并应用纹理
- en: 'As you may have already guessed, loading and applying a texture to a mesh can
    be easy with Babylon.js. The standard material provides a way, as for colors,
    to apply a diffuse texture (for example, specular, emissive, and ambient textures).
    Simply set the `.diffuseTexture` property to the reference of your texture, as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经猜到的，使用 Babylon.js 加载并将纹理应用到网格上可以很容易。标准材质提供了一种方法，就像颜色一样，可以应用漫反射纹理（例如，镜面、发射和环境纹理）。只需将
    `.diffuseTexture` 属性设置为纹理的引用，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create the `myTexture` object, let''s take a look at the `BABYLON.Texture`
    class, as shown in the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `myTexture` 对象，让我们看看以下所示的 `BABYLON.Texture` 类：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is done now. The diffuse texture will now be applied to the mesh. Consider
    the `floor_diffuse.png` image in the example files as an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了。漫反射纹理现在将被应用到网格上。以下是一个示例，考虑示例文件中的 `floor_diffuse.png` 图像：
- en: '![Load and apply a texture](img/image_04_010.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_010.png)'
- en: 'Now, let''s play with the texture''s properties. In the example files, there
    is a `cloud.png` texture that contains an alpha channel (transparency). If you
    apply the cloud texture, the result is as shown in the following image:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩一下纹理的属性。在示例文件中，有一个包含 alpha 通道（透明度）的 `cloud.png` 纹理。如果你应用云纹理，结果如下所示：
- en: '![Load and apply a texture](img/image_04_011.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_011.png)'
- en: 'The black part represents the alpha channel and looks like an artifact that
    pollutes the rendering part of the sphere. In fact, the textures are applied on
    meshes thanks to the pixel shaders, and you must tell the shaders that the textures
    can contain an alpha channel. This job can be done thanks to the `.hasAlpha` property
    of the texture, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色部分代表 alpha 通道，看起来像污染球体渲染部分的伪影。实际上，纹理是通过像素着色器应用到网格上的，你必须告诉着色器纹理可以包含 alpha 通道。这项工作可以通过纹理的
    `.hasAlpha` 属性来完成，如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result is the following image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Load and apply a texture](img/image_04_012.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_012.png)'
- en: You can see that the back faces of the sphere are not rendered. This is due
    to the optimization of the graphics libraries as it is not necessarily needed
    (in most cases) to render the triangles of the back faces that the cameras cannot
    see. It is called `back-face culling`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到球体的背面没有被渲染。这是由于图形库的优化，因为在大多数情况下，渲染摄像机看不到的背面三角形的三角形并不是必需的。这被称为“背面裁剪”。
- en: 'To disable the `back-face culling`, simply set the `.backFaceCulling` property
    of the material to false, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用`背面裁剪`，只需将材质的`.backFaceCulling`属性设置为false，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is as shown in the following image:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如以下图像所示：
- en: '![Load and apply a texture](img/image_04_013.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_013.png)'
- en: 'Since textures are applied by the pixel shaders, a lot of parameters can be
    set thanks to the materials, for example, the vertical and horizontal scales of
    the texture. Let''s start with the following texture:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纹理是通过像素着色器应用的，因此可以通过材质设置许多参数，例如纹理的垂直和水平缩放。让我们从以下纹理开始：
- en: '![Load and apply a texture](img/image_04_014.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_014.png)'
- en: 'The `.uScale` and`.vScale` properties of a texture allow us to apply a repeat
    pattern to the mesh. The 1.0 default value means that the texture is repeated
    once on the mesh. Let''s see the following result with `5.0`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的`.uScale`和`.vScale`属性允许我们向网格应用重复图案。1.0的默认值意味着纹理在网格上重复一次。让我们看看以下`5.0`的结果：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Load and apply a texture](img/image_04_015.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_015.png)'
- en: 'As for the textures scales, you can create an offset to adjust the texture''s
    positions on the mesh according to the `.uScale` and`.vScale` properties, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 至于纹理缩放，你可以创建一个偏移量来根据`.uScale`和`.vScale`属性调整纹理在网格上的位置，如下所示：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Load and apply a texture](img/image_04_016.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![加载并应用纹理](img/image_04_016.png)'
- en: The bump mapping
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凹凸贴图
- en: 'In the texturing methods that Babylon.js is handling, we can the find the bump mapping
    technique. This technique is used to create a relief on a surface and have more
    realistic surfaces using two different textures: the diffuse texture and a *normal
    texture*. This technique is famous as it doesn''t modify the original geometry
    of the mesh and is only computed by the shaders using the two textures.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Babylon.js处理的纹理方法中，我们可以找到凹凸贴图技术。这项技术用于在表面上创建凸起，并使用两种不同的纹理（漫反射纹理和法线纹理）创建更逼真的表面。这项技术因其不修改网格的原始几何形状，而仅通过着色器使用两种纹理进行计算而闻名。
- en: 'The diffuse and normal textures are provided by the artists and are built by
    some artist''s tools to help the production. An example of normal texture is as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射纹理和法线纹理由艺术家提供，并由一些艺术家工具构建，以帮助生产。以下是一个法线纹理的示例：
- en: '![The bump mapping](img/image_04_017.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![凹凸贴图](img/image_04_017.png)'
- en: In fact, the pixel shader applies the diffuse texture and modifies the pixels
    in the function of the normal texture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，像素着色器应用漫反射纹理并修改根据法线纹理的像素。
- en: 'Let''s see the normal mapping effect. This is without normal mapping:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看法线贴图效果。这是没有法线贴图的情况：
- en: '![The bump mapping](img/image_04_018.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![凹凸贴图](img/image_04_018.png)'
- en: 'With normal mapping, the image will look similar to the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用法线贴图，图像将类似于以下：
- en: '![The bump mapping](img/image_04_019.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![凹凸贴图](img/image_04_019.png)'
- en: 'Applying the normal mapping effect with Babylon.js is as easy as applying a
    diffuse texture. Let''s explain this with the following two lines of code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Babylon.js应用法线贴图效果与应用漫反射纹理一样简单。让我们用以下两行代码来解释：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The internal effect of the material is able to adapt the rendering in the function
    of the properties. Then, if the `.bumpTexture` property is set, the effect will
    compute the bump mapping technique.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 材料内部效果能够根据属性来调整渲染。然后，如果设置了`.bumpTexture`属性，效果将计算凹凸贴图技术。
- en: Advanced texturing
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级纹理
- en: The standard material of Babylon.js allows us to apply a reflection texture.
    If this texture is set, the internal effect of the material will create a reflection
    effect using this texture.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js的标准材质允许我们应用反射纹理。如果设置了此纹理，材质的内部效果将使用此纹理创建反射效果。
- en: The cube texture
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 立方体贴图
- en: The cube texture is special. An interesting use of the reflection texture with
    a cube texture is the skybox mesh. A skybox is composed of six faces and tends
    to reproduce the environment around a scene, typically the sky. To handle the
    six faces with a texture, the cube texture will load six textures and apply them
    to the mesh.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图是特殊的。使用立方体贴图和反射纹理的一个有趣用途是天空盒网格。天空盒由六个面组成，通常用于重现场景周围的环境，通常是天空。为了处理六个面，立方体贴图将加载六个纹理并将它们应用到网格上。
- en: 'Let''s load a cube texture with Babylon.js, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Babylon.js加载一个立方体贴图，如下所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The parameters are as shown in the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下所示：
- en: The path to the six textures. Each texture name must begin with `TropicalSunnyDay`
    in this example, followed by the six directions of the cube: `nx`, `ny`, `nz`, `px`, `py`,
    and `pz`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个纹理的路径。在这个例子中，每个纹理名称必须以`TropicalSunnyDay`开头，后跟立方体的六个方向：`nx`、`ny`、`nz`、`px`、`py`和`pz`。
- en: The scene where to add the cube texture.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加立方体纹理的场景。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: the default extension for the cube texture is .jpg. You can learn of
    the precise extension by passing a third parameter, which is an array of String.
    Consider the following as an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：立方体纹理的默认扩展名是 .jpg。您可以通过传递一个包含字符串的数组作为第三个参数来了解确切的扩展名。以下是一个例子：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s create a skybox. A skybox is a cube with `back-face culling` disabled
    as the camera will be in the cube, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个天空盒。天空盒是一个立方体，其背面裁剪被禁用，因为摄像机将在立方体内，如下所示：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the result, the cube texture is applied to the cube; however, we can find
    some artifacts in the links between parts of the cube texture:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，立方体纹理被应用于立方体；然而，我们可以在立方体纹理部分之间找到一些伪影：
- en: '![The cube texture](img/image_04_020.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![立方体纹理](img/image_04_020.png)'
- en: These artefacts are due to the coordinates mode of the texture. In fact, the
    textures are applied to meshes by the 2D coordinates provided by the mesh's geometry.
    As for the vertex buffer and the index buffer, the geometry contains a coordinate
    buffer commonly named the **UVs** buffer, and several methods exist to apply a
    certain coordinate pattern. In this case, the skybox coordinate mode should be
    applied. This is possible with `the.coordinatesMode` property, as follows
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些伪影是由于纹理的坐标模式引起的。实际上，纹理是通过网格几何体提供的 2D 坐标应用于网格的。至于顶点缓冲区和索引缓冲区，几何体包含一个通常称为 **UVs
    缓冲区的坐标缓冲区**，存在几种方法来应用特定的坐标模式。在这种情况下，应该应用天空盒坐标模式。这可以通过`the.coordinatesMode`属性实现，如下所示：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the coordinates mode is set, the result looks great, as shown in the following
    image:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置坐标模式，结果看起来很棒，如下面的图像所示：
- en: '![The cube texture](img/image_04_021.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![立方体纹理](img/image_04_021.png)'
- en: 'The result of the skybox outside the cube is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 天空盒外部的结果如下所示：
- en: '![The cube texture](img/image_04_022.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![立方体纹理](img/image_04_022.png)'
- en: The mirror texture
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜面纹理
- en: 'Let''s explain the usage of a reflection texture with a new texture type named
    **Mirror Texture**. With Babylon.js, it is possible to reflect the world using
    a mirror texture. The mirror texture is particular as it is created by Babylon.js
    and can render the scene into a texture. Behind the reflection texture, a new
    texture type is used: the render target texture. Render target textures are used
    to directly render meshes into a texture for further use. Now, let''s create a
    mirror texture, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个新的纹理类型**镜面纹理**来解释反射纹理的使用。使用 Babylon.js，可以使用镜面纹理来反射世界。镜面纹理是特别的，因为它是由 Babylon.js
    创建的，可以将场景渲染成纹理。在反射纹理后面，使用了一种新的纹理类型：渲染目标纹理。渲染目标纹理用于直接将网格渲染到纹理中，以便进一步使用。现在，让我们创建一个镜面纹理，如下所示：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The parameters are as shown in the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下所示：
- en: 'The texture name: The name of the texture created by Babylon.js.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理名称：Babylon.js 创建的纹理的名称。
- en: 'The texture size: The bigger the texture, the cleaner the mirror texture is.
    Unfortunately, bigger the texture, bigger will be its impact on the performance.
    The values 512 or 1024 (512 x 512 or 1024 x 1024 pixels) are good sizes for a
    mirror texture.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理大小：纹理越大，镜面纹理越清晰。不幸的是，纹理越大，对性能的影响也越大。512 或 1024（512 x 512 或 1024 x 1024 像素）是镜面纹理的好大小。
- en: The scene where to add the texture.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加纹理的场景。
- en: 'Now, to reflect the world, the mirror texture needs a last parameter: the mirror
    plane. If we take the ground as an example, we want the ground to reflect the
    world above itself:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了反射世界，镜面纹理需要一个最后一个参数：镜面平面。以地面为例，我们希望地面反射其自身之上的世界：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A plane has four properties: `a`, `b`, `c`, and `d`. The first three properties
    represent the normal vector, where `d` is the distance to the origin. The `FromPositionAndNormal`
    static method is a helper to create a plane. The parameters are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个平面有四个属性：`a`、`b`、`c`和`d`。前三个属性代表法向量，其中`d`是到原点的距离。`FromPositionAndNormal`静态方法是一个辅助方法来创建一个平面。参数如下：
- en: The plane's position vector. Here, the origin (`x=0`, `y=0`, `z=0`).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面的位置向量。在这里，原点（`x=0`、`y=0`、`z=0`）。
- en: In the example files, the plane position is (`x=0`, `y=-5`, `z=0`). Therefore,
    the plane's position must be (`x=0`, `y=5`, `z=0`).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在示例文件中，平面的位置是（`x=0`、`y=-5`、`z=0`）。因此，平面的位置必须是（`x=0`、`y=5`、`z=0`）。
- en: The plane's normal vector. Here, the origin is (`x=0`, `y=-1`, `z=0`).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面的法向量。在这里，原点是(`x=0`，`y=-1`，`z=0`)。
- en: 'Then, the code lines become the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码行变成了以下内容：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To configure the render target texture in the mirror texture, we must provide
    an array of `BABYLON.AbstractMesh`. This array is used to render only the meshes
    indexed in the array. The array is already created by the mirror texture and the
    property''s name is`.renderList`. Then, the mirror texture will only expose the
    added meshes in the array, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要在镜面纹理中配置渲染目标纹理，我们必须提供一个`BABYLON.AbstractMesh`数组。这个数组用于仅渲染数组中索引的网格。这个数组已经由镜面纹理创建，属性名为`.renderList`。然后，镜面纹理将仅暴露数组中添加的网格，如下所示：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result with a ground (plane at the same position) and the reflected spheres
    is as shown in the following image:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在地面上（与平面处于相同位置）和反射球体上的结果如下所示：
- en: '![The mirror texture](img/image_04_023.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![镜面纹理](img/image_04_023.png)'
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you saw what materials are, the theory about what is happening
    backstage, and how to use the standard materials of Babylon.js. You saw that using
    a material in Babylon.js is also easy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了材质是什么，后台发生的理论，以及如何使用Babylon.js的标准材质。你看到在Babylon.js中使用材质也很简单。
- en: 'The example files tend to reproduce the notions viewed in this chapter: colors,
    alpha, textures, fog, back-face culling, and so on. Now, you can practice with
    materials and customize appearance of meshes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例文件倾向于重现本章中看到的概念：颜色、透明度、纹理、雾效、背面裁剪等。现在，你可以使用材质并自定义网格的外观。
- en: 'As a concrete example, the materials are highly used in all the 3D scenes and
    configured by 3D artists: if we take a scene of Babylon.js made by Michel Rousseau,
    where he used two meshes and two different materials to reproduce the following
    image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体例子，材质在所有3D场景中都被高度使用，并由3D艺术家配置：如果我们以Michel Rousseau制作的Babylon.js场景为例，他在其中使用了两个网格和两种不同的材质来重现以下图像：
- en: '![Summary](img/image_04_024.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![总结](img/image_04_024.png)'
- en: 'The first mesh is the body of the vase with a standard material applied to
    it and the second mesh represents the embers with another standard material applied
    to them. Each material is configured with a different diffuse texture. If we set
    the body as `isVisible = false`, we can see how the embers look in reality, as
    shown in the following image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个网格是花瓶的主体，应用了标准材质，第二个网格代表余烬，应用了另一种标准材质。每个材质都配置了不同的漫反射纹理。如果我们设置主体为`isVisible
    = false`，我们可以看到余烬在现实中的样子，如下所示：
- en: '![Summary](img/image_04_025.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![总结](img/image_04_025.png)'
- en: 'Finally, all the meshes rendered in this scene are using standard materials,
    configured with different values and textures, to finally look similar to the
    following image:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个场景中渲染的所有网格都使用标准材质，配置了不同的值和纹理，最终看起来类似于以下图像：
- en: '![Summary](img/image_04_026.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![总结](img/image_04_026.png)'
- en: In the next chapter, you'll create your first scene with an FPS camera and collisions
    management. You will learn how to manage collisions between objects and how to
    manage physics with Babylon.js.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将使用FPS相机和碰撞管理创建你的第一个场景。你将学习如何管理对象之间的碰撞以及如何使用Babylon.js管理物理。
