- en: About Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 Node.js
- en: Node.js is an exciting new platform for developing web applications, application
    servers, any sort of network server or client, and general purpose programming.
    It is designed for extreme scalability in networked applications through an ingenious
    combination of server-side JavaScript, asynchronous I/O, and asynchronous programming.
    It is built around JavaScript anonymous functions, and a single execution thread
    event-driven architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是一个令人兴奋的新平台，用于开发 Web 应用、应用服务器、各种网络服务器或客户端，以及通用编程。它通过巧妙结合服务器端 JavaScript、异步
    I/O 和异步编程，旨在实现网络应用的极端可伸缩性。它围绕 JavaScript 匿名函数和单线程事件驱动架构构建。
- en: While only a few years old, Node.js has quickly grown in prominence and it's
    now playing a significant role. Companies, both small and large, are using it
    for large-scale and small-scale projects. PayPal, for example, has converted many
    services from Java to Node.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只有几年历史，Node.js 已经迅速崛起，现在正发挥着重要作用。大小公司都在使用它进行大规模和小规模项目。例如，PayPal 已经将许多服务从 Java
    转换为 Node.js。
- en: The Node.js architecture departs from a typical choice made by other application
    platforms. Where threads are widely used to scale an application to fill the CPU,
    Node.js eschews threads because of their inherent complexity. It's claimed that
    with single-thread event-driven architectures, memory footprint is low, throughput
    is high, the latency profile under load is better, and the programming model is
    simpler. The Node.js platform is in a phase of rapid growth, and many are seeing
    it as a compelling alternative to the traditional web application architectures
    using Java, PHP, Python, or Ruby on Rails.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的架构与传统应用平台的选择有所不同。在其他应用平台中，线程被广泛用于扩展应用以填充 CPU，而 Node.js 由于线程固有的复杂性而放弃了线程。据说，使用单线程事件驱动架构，内存占用低，吞吐量高，负载下的延迟性能更好，编程模型更简单。Node.js
    平台正处于快速增长的阶段，许多人将其视为传统使用 Java、PHP、Python 或 Ruby on Rails 的 Web 应用架构的有力替代品。
- en: At its heart, it is a standalone JavaScript engine with extensions making it
    suitable for general purpose programming and with a clear focus on application
    server development. Even though we're comparing Node.js to application server
    platforms, it is not an application server. Instead, Node.js is a programming
    run-time akin to Python, Go, or Java SE. While there are web application frameworks
    and application servers written in Node.js, it is simply a system to execute JavaScript
    programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，它是一个独立的 JavaScript 引擎，通过扩展使其适用于通用编程，并明确关注应用服务器开发。尽管我们正在将 Node.js 与应用服务器平台进行比较，但它本身并不是一个应用服务器。相反，Node.js
    是一种类似于 Python、Go 或 Java SE 的编程运行时。尽管有使用 Node.js 编写的 Web 应用框架和应用服务器，但它仅仅是一个执行 JavaScript
    程序的系统。
- en: It is implemented around a non-blocking I/O event loop and a layer of file and
    network I/O libraries, all built on top of the V8 JavaScript engine (from the
    Chrome web browser). The rapid performance and feature improvements implemented
    in Chrome quickly flow through to the Node.js platform. Additionally, a team of
    folks are working on a Node.js implementation that runs on top of Microsoft's ChakraCore
    JavaScript engine (from the Edge web browser). That would give the Node.js community
    greater flexibility by not being reliant on one JavaScript engine provider. Visit
    [https://github.com/nodejs/node-chakracore](https://github.com/nodejs/node-chakracore)
    to take a look at the project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 它是基于非阻塞 I/O 事件循环和文件及网络 I/O 库层实现的，所有这些都是在 Chrome 浏览器背后的 V8 JavaScript 引擎之上构建的。Chrome
    中实现的快速性能和功能改进迅速传递到 Node.js 平台。此外，一个团队正在开发一个在 Microsoft 的 ChakraCore JavaScript
    引擎（来自 Edge 浏览器）之上运行的 Node.js 实现。这将通过不依赖于单一 JavaScript 引擎提供商来为 Node.js 社区提供更大的灵活性。访问
    [https://github.com/nodejs/node-chakracore](https://github.com/nodejs/node-chakracore)
    查看该项目。
- en: The Node.js I/O library is general enough to implement any sort of server executing
    any TCP or UDP protocol, whether it's **domain name system** (**DNS** ), HTTP, 
    **internet relay chat** (**IRC**), or FTP. While it supports developing internet
    servers or clients, its biggest use case is in regular websites, in place of technology
    such as an Apache/PHP or Rails stack, or to complement existing websites. For
    example, adding real-time chat or monitoring existing websites can be easily done
    with the Socket. IO library for Node.js. Its lightweight, high-performance nature
    often sees Node.js used as a **glue** service.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的I/O库足够通用，可以执行任何类型的服务器，执行任何TCP或UDP协议，无论是**域名系统**（**DNS**），HTTP，**互联网中继聊天**（**IRC**），还是FTP。虽然它支持开发互联网服务器或客户端，但其最大的用例是在常规网站上，替代Apache/PHP或Rails堆栈，或补充现有网站。例如，使用Socket.IO库为Node.js添加实时聊天或监控现有网站可以轻松完成。它的轻量级和高性能特性通常使Node.js被用作**粘合剂**服务。
- en: A particularly intriguing combination is deploying small services using Docker
    into cloud hosting infrastructure. A large application can be divided into what's
    now called microservices that are easily deployed at scale using Docker. The result
    fits agile project management methods since each microservice can be easily managed
    by a small team that collaborates at the boundary of their individual API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别吸引人的组合是将使用Docker部署的小型服务部署到云托管基础设施中。一个大型应用程序可以分解成现在称为微服务的形式，这些服务可以使用Docker轻松地大规模部署。结果是适合敏捷项目管理方法，因为每个微服务都可以由一个小团队轻松管理，该团队在其各自的API边界上进行协作。
- en: 'This book will give you an introduction to Node.js. We presume the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将为你介绍Node.js。我们假设以下：
- en: You already know how to write software
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经知道如何编写软件
- en: You are familiar with JavaScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你熟悉JavaScript
- en: You know something about developing web applications in other languages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对用其他语言开发Web应用程序有所了解
- en: 'We will cover the following topics in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to Node.js
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js简介
- en: Why you should use Node.js
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该使用Node.js
- en: The architecture of Node.js
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的架构
- en: Performance, utilization, and scalability with Node.js
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js的性能、利用率和可伸缩性
- en: Node.js, microservice architecture, and testing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js、微服务架构和测试
- en: Implementing the Twelve-Factor App model with Node.js
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js实现十二要素应用模型
- en: We will dive right into developing working applications and recognize that often
    the best way to learn is by rummaging around in working code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接进入开发工作应用程序，并认识到通常最好的学习方法是通过在工作代码中翻找。
- en: The capabilities of Node.js
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的功能
- en: Node.js is a platform for writing JavaScript applications outside web browsers.
    This is not the JavaScript we are familiar with in web browsers! For example,
    there is no DOM built into Node.js, nor any other browser capability.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个在Web浏览器之外编写JavaScript应用程序的平台。这并不是我们在Web浏览器中熟悉的JavaScript！例如，Node.js中没有内置DOM，也没有其他浏览器功能。
- en: 'Beyond its native ability to execute JavaScript, the bundled modules provide
    capabilities of this sort:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其执行JavaScript的本地能力之外，捆绑的模块提供了以下这类功能：
- en: Command-line tools (in shell script style)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行工具（以shell脚本风格）
- en: An interactive-terminal style of program that is **Read-Eval-Print Loop** (**REPL**)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种交互式终端风格的程序，即**读取-评估-打印循环**（**REPL**）
- en: Excellent process control functions to oversee child processes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀的进程控制功能，用于监督子进程
- en: A buffer object to deal with binary data
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于处理二进制数据的缓冲对象
- en: TCP or UDP sockets with comprehensive event-driven callbacks
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有全面事件驱动回调的TCP或UDP套接字
- en: DNS lookup
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS查找
- en: An HTTP, HTTPS and HTTP/2 client/server layered on top of the TCP library filesystem
    access
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TCP库文件系统访问之上构建的HTTP、HTTPS和HTTP/2客户端/服务器层
- en: Built-in rudimentary unit testing support through assertions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过断言提供的内置基本单元测试支持
- en: The network layer of Node.js is low level while being simple to use. For example,
    the HTTP modules allow you to write an HTTP server (or client) using a few lines
    of code. This is powerful, but it puts you, the programmer, very close to the
    protocol requests and makes you implement precisely those HTTP headers that you
    should return in request responses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的网络层是低级别的，但使用简单。例如，HTTP模块允许你使用几行代码编写HTTP服务器（或客户端）。这很强大，但它让你，即程序员，非常接近协议请求，并要求你精确实现那些你应该在请求响应中返回的HTTP头。
- en: Typical web application developers don't need to work at a low level of the
    HTTP or other protocols. Instead, we tend to be more productive, working with
    higher-level interfaces. For example, PHP coders assume that Apache (or other
    HTTP servers) is already there providing the HTTP protocol, and that they don't
    have to implement the HTTP server portion of the stack. By contrast, a Node.js
    programmer does implement an HTTP server to which their application code is attached.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 Web 应用程序开发者不需要在 HTTP 或其他协议的低级别工作。相反，我们倾向于更高效地工作，使用高级接口。例如，PHP 开发者假设 Apache（或其他
    HTTP 服务器）已经存在，提供 HTTP 协议，并且他们不需要实现堆栈的 HTTP 服务器部分。相比之下，Node.js 程序员确实实现了 HTTP 服务器，并将他们的应用程序代码附加到该服务器上。
- en: To simplify the situation, the Node.js community has several web application
    frameworks, such as Express, providing the higher-level interfaces required by
    typical programmers. You can quickly configure an HTTP server with baked-in capabilities such
    as sessions, cookies, serving static files, and logging, letting developers focus
    on their business logic. Other frameworks provide OAuth 2 support, or focus on
    REST APIs, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化情况，Node.js 社区有几个 Web 应用程序框架，如 Express，为典型程序员提供所需的更高级接口。你可以快速配置具有内置功能（如会话、cookies、静态文件服务、日志记录）的
    HTTP 服务器，让开发者专注于他们的业务逻辑。其他框架提供 OAuth 2 支持，或专注于 REST API，等等。
- en: Node.js is not limited to web service application development. The community
    around Node.js has taken it in many other directions,
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 并不仅限于 Web 服务应用开发。围绕 Node.js 的社区已经将其应用于许多其他方向，
- en: '**Build tools**: Node.js has become a popular choice for developing command-line
    tools used in software development, or communicating with service infrastructure.
    Grunt and Gulp are widely used by frontend developers to build assets for websites.
    Babel is widely used for transpiling modern ES-2016 code to run on older browsers.
    Popular CSS optimizers and processors, such as PostCSS, are written in Node.js.
    Static website generation systems such as Metalsmith, Punch, and AkashaCMS, run
    at the command line and generate website content that you upload to a web server.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建工具**：Node.js 已成为开发用于软件开发或与服务基础设施通信的命令行工具的流行选择。Grunt 和 Gulp 被前端开发者广泛用于构建网站资产。Babel
    被广泛用于将现代 ES-2016 代码转换为在旧浏览器上运行的代码。流行的 CSS 优化器和处理器，如 PostCSS，是用 Node.js 编写的。静态网站生成系统，如
    Metalsmith、Punch 和 AkashaCMS，在命令行上运行并生成上传到 Web 服务器的网站内容。'
- en: '**Web UI testing**: Puppeteer gives you control over a headless-Chrome web
    browser instance. With it, you can develop Node.js scripts controlling a modern
    full-featured web browser. Typical use cases involve web scraping and testing
    web applications.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web UI 测试**：Puppeteer 允许你控制一个无头-Chrome 网络浏览器实例。利用它，你可以开发控制现代全功能网络浏览器的 Node.js
    脚本。典型的用例包括网络爬取和测试 Web 应用程序。'
- en: '**Desktop applications**: Both Electron and **node-webkit** (**NW.j**s) are
    frameworks for developing desktop applications for Windows, macOS, and Linux.
    These frameworks utilize a large chunk of Chrome, wrapped by Node.js libraries,
    to develop desktop applications using web UI technologies. Applications are written
    with modern HTML5, CSS3, and JavaScript, and can utilize leading-edge web frameworks,
    such as Bootstrap, React, or AngularJS. Many popular applications have been built
    using Electron, including the Slack desktop client application, the Atom and Microsoft
    Visual Code programming editors, the Postman REST client, the GitKraken GIT client, and
    Etcher, which makes it incredibly easy to burn OS images to flash drives to run
    on single-board computers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**桌面应用程序**：Electron 和 **node-webkit**（**NW.js**）是用于开发 Windows、macOS 和 Linux
    桌面应用程序的框架。这些框架利用了大量的 Chrome，并通过 Node.js 库进行包装，使用 Web UI 技术开发桌面应用程序。应用程序使用现代的 HTML5、CSS3
    和 JavaScript 编写，并可以利用领先的 Web 框架，如 Bootstrap、React 或 AngularJS。许多流行的应用程序都是使用 Electron
    开发的，包括 Slack 桌面客户端应用程序、Atom 和 Microsoft Visual Code 编程编辑器、Postman REST 客户端、GitKraken
    GIT 客户端，以及 Etcher，它使得将操作系统镜像烧录到闪存驱动器以在单板计算机上运行变得极其简单。'
- en: '**Mobile applications**: The Node.js for Mobile Systems project lets you develop
    smartphone or tablet computer applications using Node.js, for both iOS and Android.
    Apple''s App Store rules preclude incorporating a JavaScript engine with JIT capabilities,
    meaning that normal Node.js cannot be used in an iOS application. For iOS application
    development, the project uses Node.js-on-ChakraCore to skirt around the App Store
    rules. For Android application development the project uses regular Node.js on
    Android. At the time of writing, the project is in an early stage of development,
    but it looks promising.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动应用**：Node.js for Mobile Systems 项目允许你使用 Node.js 开发智能手机或平板电脑应用，适用于 iOS 和
    Android。苹果的 App Store 规则禁止包含具有 JIT 功能的 JavaScript 引擎，这意味着正常的 Node.js 不能用于 iOS
    应用。对于 iOS 应用开发，该项目使用 Node.js-on-ChakraCore 来规避 App Store 规则。对于 Android 应用开发，该项目使用常规的
    Node.js 在 Android 上。截至写作时，该项目处于早期开发阶段，但看起来很有希望。'
- en: '**Internet of Things** (**IoT**): Reportedly, it is a very popular language
    for Internet-of-Things projects, and Node.js does run on most ARM-based single-board
    computers. The clearest example is the NodeRED project. It offers a graphical
    programming environment, letting you draw programs by connecting blocks together.
    It features hardware-oriented input and output mechanisms, for example, to interact
    with **General Purpose I/O** (**GPIO**) pins on Raspberry Pi or Beaglebone single-board
    computers.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**物联网**（**IoT**）：据报道，它是一种非常流行的物联网项目语言，Node.js 也能在大多数基于 ARM 的单板计算机上运行。最明显的例子是
    NodeRED 项目。它提供了一个图形编程环境，允许你通过连接模块来绘制程序。它具有面向硬件的输入和输出机制，例如，与树莓派或 Beaglebone 单板计算机上的通用输入/输出（**GPIO**）引脚进行交互。'
- en: Server-side JavaScript
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端 JavaScript
- en: Quit scratching your head already! Of course you're doing it, scratching your head
    and mumbling to yourself, "What's a browser language doing on the server?" In
    truth, JavaScript has a long and largely unknown history outside the browser.
    JavaScript is a programming language, just like any other language, and the better
    question to ask is "Why should JavaScript remain trapped inside browsers?".
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 别再挠头了！当然你在做，挠你的头，自言自语，“浏览器语言怎么会出现在服务器上？”事实上，JavaScript 在浏览器之外有着漫长且在很大程度上不为人知的历史。JavaScript
    是一种编程语言，就像任何其他语言一样，更好的问题是“为什么 JavaScript 应该被困在浏览器内部？”。
- en: Back in the dawn of the web age, the tools for writing web applications were
    at a fledgling stage. Some were experimenting with Perl or TCL to write CGI scripts,
    and the PHP and Java languages had just been developed. Even then, JavaScript
    saw use on the server side. One early web application server was Netscape's LiveWire
    server, which used JavaScript. Some versions of Microsoft's ASP used JScript,
    their version of JavaScript. A more recent server-side JavaScript project is the
    RingoJS application framework in the Java universe. Java 6 and Java 7 were both
    shipped with the Rhino JavaScript engine. In Java 8, Rhino was dropped in favor
    of the newer Nashorn JavaScript engine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回到网络时代的初期，编写网络应用的工具还处于起步阶段。有些人正在尝试使用 Perl 或 TCL 来编写 CGI 脚本，而 PHP 和 Java 语言刚刚被开发出来。即使那时，JavaScript
    也已经在服务器端得到了应用。一个早期的网络应用服务器是 Netscape 的 LiveWire 服务器，它使用了 JavaScript。微软的一些 ASP
    版本使用了 JScript，这是他们版本的 JavaScript。在 Java 宇宙中，还有一个更近期的服务器端 JavaScript 项目，即 RingoJS
    应用框架。Java 6 和 Java 7 都配备了 Rhino JavaScript 引擎。在 Java 8 中，Rhino 被新的 Nashorn JavaScript
    引擎所取代。
- en: In other words, JavaScript outside the browser is not a new thing, even if it
    is uncommon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，浏览器之外的 JavaScript 并不是什么新鲜事物，即使它并不常见。
- en: Why should you use Node.js?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你为什么应该使用 Node.js？
- en: Among the many available web application development platforms, why should you
    choose Node.js? There are many stacks to choose from; what is it about Node.js
    that makes it rise above the others? We will see in the following sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多可用的网络应用开发平台中，为什么你应该选择 Node.js？有很多技术栈可供选择；是什么让 Node.js 脱颖而出，超越其他平台？我们将在接下来的章节中看到。
- en: Popularity
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行度
- en: Node.js is quickly becoming a popular development platform with adoption by
    plenty of big and small players. One of those is PayPal, who are replacing their
    incumbent Java-based system with one written in Node.js. For PayPal's blog post
    about this, visit [https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/](https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/).
    Other large Node.js adopters include Walmart's online e-commerce platform, LinkedIn,
    and eBay.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js正迅速成为流行的开发平台，许多大小玩家都在采用。其中之一是PayPal，他们正在用Node.js编写的新系统替换现有的基于Java的系统。有关PayPal的这篇博客文章，请访问[https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/](https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/)。其他大型Node.js采用者包括沃尔玛的在线电子商务平台、领英和eBay。
- en: According to NodeSource, Node.js usage is growing rapidly (visit [https://nodesource.com/node-by-numbers](https://nodesource.com/node-by-numbers)). The
    measures include increasing bandwidth for downloading Node.js releases, increasing
    activity in Node.js-related GitHub projects, and more.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据NodeSource的数据，Node.js的使用正在快速增长（访问[https://nodesource.com/node-by-numbers](https://nodesource.com/node-by-numbers)）。这些指标包括下载Node.js发布版的带宽增加、Node.js相关GitHub项目的活动增加以及更多。
- en: It's best to not just follow the crowd because the crowd claims their software
    platform does cool things. Node.js does some cool things, but more important is
    its technical merit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要仅仅跟随潮流，因为潮流声称他们的软件平台可以做酷的事情。Node.js确实做一些酷的事情，但更重要的是它的技术优势。
- en: JavaScript at all levels of the stack
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在堆栈的所有级别上使用JavaScript
- en: Having the same programming language on the server and client has been a long-time
    dream on the web. This dream dates back to the early days of Java, where Java
    applets were to be the frontend to server applications written in Java, and JavaScript
    was originally envisioned as a lightweight scripting language for those applets.
    Java never fulfilled its hype as a client-side programming language, for various
    reasons. We ended up with JavaScript as the principle in-browser, client-side
    language, rather than Java. Typically, the frontend JavaScript developers were
    in a different language universe than the server-side team, who was likely to
    be coding in PHP, Java, Ruby, or Python.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器和客户端使用相同的编程语言一直是网络上的一个长期梦想。这个梦想可以追溯到Java的早期，当时Java小程序被设想为用Java编写的服务器应用程序的前端，而JavaScript最初被设想为这些小程序的轻量级脚本语言。由于各种原因，Java从未实现其作为客户端编程语言的炒作。我们最终得到了JavaScript作为主要的浏览器端、客户端语言，而不是Java。通常，前端JavaScript开发者与后端团队处于不同的语言宇宙中，后端团队可能使用PHP、Java、Ruby或Python进行编码。
- en: Over time, in-browser JavaScript engines became incredibly powerful, letting
    us write ever-more complex browser-side applications. With Node.js, we may finally
    be able to implement applications with the same programming language on the client
    and server by having JavaScript at both ends of the web, in the browser and server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，浏览器中的JavaScript引擎变得极其强大，使我们能够编写越来越复杂的浏览器端应用程序。通过Node.js，我们可能最终能够在客户端和服务器两端都使用JavaScript，从而在浏览器和服务器上实现使用相同编程语言的应用程序。
- en: 'A common language for frontend and backend offers several potential benefits:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端使用相同的语言提供了几个潜在的好处：
- en: The same programming staff can work on both ends of the wire
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样的编程人员可以在网络两端工作
- en: Code can be migrated between server and client more easily
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以在服务器和客户端之间更容易地迁移
- en: Common data formats (JSON) exist between server and client
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端之间存在共同的数据格式（JSON）
- en: Common software tools exist for server and client
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端存在共同的软件工具
- en: Common testing or quality reporting tools for server and client
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端的常见测试或质量报告工具
- en: When writing web applications, view templates can be used on both sides
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写网络应用程序时，可以在两端使用视图模板
- en: The JavaScript language is very popular due to its ubiquity in web browsers.
    It compares favorably against other languages while having many modern, advanced
    language concepts. Thanks to its popularity, there is a deep talent pool of experienced
    JavaScript programmers out there.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其在网络浏览器中的普遍存在，JavaScript语言非常受欢迎。它在与其他语言的比较中表现良好，同时拥有许多现代、高级的语言概念。由于其受欢迎程度，有经验的JavaScript程序员人才库非常深厚。
- en: Leveraging Google's investment in V8
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用谷歌对V8的投资
- en: To make Chrome a popular and excellent web browser, Google invested in making
    V8 a super-fast JavaScript engine. Google, therefore, has a huge motivation to
    keep on improving V8. V8 is the JavaScript engine for Chrome, and it can also
    be executed standalone. Node.js is built on top of the V8 JavaScript engine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Chrome成为一个受欢迎且优秀的网络浏览器，谷歌投资于将V8打造成为一个超级快速的JavaScript引擎。因此，谷歌有巨大的动力不断改进V8。V8是Chrome的JavaScript引擎，也可以独立执行。Node.js建立在V8
    JavaScript引擎之上。
- en: As Node.js becomes more important to the V8 team, there's a potential synergy
    of faster V8 performance wins as more people focus on V8 improvements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Node.js对V8团队的重要性日益增加，随着更多的人关注V8的改进，有可能实现更快V8性能的协同效应。
- en: Leaner, asynchronous, event-driven model
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更精简、异步、事件驱动的模型
- en: We'll get into this later. The Node.js architecture, a single execution thread,
    an ingenious event-oriented asynchronous-programming model, and a fast JavaScript
    engine, has less overhead than thread-based architectures.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会深入探讨这个问题。Node.js的架构，一个单一的执行线程，一个巧妙的事件驱动异步编程模型，以及一个快速的JavaScript引擎，比基于线程的架构开销更小。
- en: Microservice architecture
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: A new sensation in software development is the microservice idea. Microservices
    are focused on splitting a large web application into small, tightly-focused services
    that can be easily developed by small teams. While they aren't exactly a new idea,
    they're more of a reframing of old client-server computing models, the microservice
    pattern fits well with agile project management techniques, and gives us more
    granular application deployment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的一个新趋势是微服务理念。微服务专注于将大型网络应用拆分为小型、高度专注的服务，这些服务可以由小型团队轻松开发。虽然这并不是一个全新的想法，但它更多的是对旧客户端-服务器计算模型的重构，微服务模式与敏捷项目管理技术很好地结合，并为我们提供了更细粒度的应用部署。
- en: Node.js is an excellent platform for implementing microservices. We'll get into
    this later.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个实现微服务的优秀平台。我们稍后会深入探讨这个问题。
- en: Node.js is stronger for having survived a major schism and hostile fork
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js因为经历了重大分裂和敌对分支而变得更加强大
- en: During 2014 and 2015, the Node.js community faced a major split over policy,
    direction, and control. The **io.js** project was a hostile fork driven by a group
    who wanted to incorporate several features and change who's in the decision-making
    process. The end result was a merge of the Node.js and io.js repositories, an
    independent Node.js foundation to run the show, and the community is working together
    to move forward in a common direction.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年和2015年期间，Node.js社区在政策、方向和控制方面面临了一次重大的分裂。**io.js**项目是由一群希望整合几个特性并改变决策过程的人推动的一个敌对分支。最终结果是Node.js和io.js仓库的合并，成立了一个独立的Node.js基金会来管理事务，社区正共同努力朝着共同的方向前进。
- en: A concrete result of healing that rift is the rapid adoption of new ECMAScript language
    features. The V8 engine is adopting those new features quickly to advance the
    state of web development. The Node.js team, in turn, is adopting those features
    as quickly as they show up in V8, meaning that Promises and `async` functions
    are quickly becoming a reality for Node.js programmers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 治愈这一裂痕的一个具体结果是新ECMAScript语言特性的快速采用。V8引擎正在快速采用这些新特性以推进Web开发的状态。反过来，Node.js团队也在V8中快速采用这些特性，这意味着Promise和`async`函数正迅速成为Node.js程序员的现实。
- en: The bottom line is that the Node.js community not only survived the io.js fork,
    but the community and the platform it nurtures grew stronger as a result.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，Node.js社区不仅存活了下来，而且由于io.js分支，社区及其培养的平台变得更加强大。
- en: Threaded versus event-driven architecture
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程与事件驱动架构的比较
- en: Node.js's blistering performance is said to be because of its asynchronous event-driven
    architecture, and its use of the V8 JavaScript engine. That's a nice thing to
    say, but what's the rationale for the statement?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 据说Node.js的卓越性能归因于其异步事件驱动架构以及使用V8 JavaScript引擎。这听起来很好，但这个声明的依据是什么？
- en: The V8 JavaScript engine is among the fastest JavaScript implementations. As
    a result, Chrome is widely used not just to view website content, but to run complex
    applications. Examples include Gmail, the Google GSuite applications (Docs, Slides,
    and so on), image editors such as Pixlr, and drawing applications such as draw.io
    and Canva. Both Atom and Microsoft's Visual Studio Code are excellent IDE's that
    just happen to be implemented in Node.js and Chrome using Electron. That these
    applications exist and are happily used by a large number of people is testament
    to V8's performance. Node.js benefits from V8 performance improvements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: V8 JavaScript引擎是JavaScript实现中最快的之一。因此，Chrome不仅被广泛用于查看网站内容，还被用于运行复杂的应用程序。例如，Gmail、Google
    GSuite应用程序（文档、幻灯片等）、图像编辑器如Pixlr以及绘图应用程序如draw.io和Canva。Atom和微软的Visual Studio Code都是优秀的IDE，它们恰好是用Node.js和Chrome中的Electron实现的。这些应用程序的存在以及大量人群的愉快使用是对V8性能的证明。Node.js从V8的性能改进中受益。
- en: The normal application server model uses blocking I/O to retrieve data, and
    it uses threads for concurrency. Blocking I/O causes threads to wait on results. 
    That causes a churn between threads as the application server starts and stops
    the threads to handle requests. Each suspended thread (typically waiting on an
    I/O operation to finish) consumes a full stack trace of memory, increasing memory
    consumption overhead. Threads add complexity to the application server as well
    as server overhead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的应用服务器模型使用阻塞I/O来检索数据，并使用线程来实现并发。阻塞I/O会导致线程在等待结果时停滞。这导致在应用服务器启动和停止线程以处理请求时，线程之间产生波动。每个挂起的线程（通常在等待I/O操作完成）会消耗完整的堆栈跟踪内存，从而增加内存消耗开销。线程不仅增加了应用服务器的复杂性，还增加了服务器开销。
- en: Node.js has a single execution thread with no waiting on I/O or context switching.
    Instead, there is an event loop looking for events and dispatching them to handler
    functions. The paradigm is that any operation that would block or otherwise take
    time to complete must use the asynchronous model. These functions are to be given
    an anonymous function to act as a handler callback, or else (with the advent of
    ES2015 promises), the function would return a Promise. The handler function, or
    Promise, is invoked when the operation is complete. In the meantime, control returns
    to the event loop, which continues dispatching events.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有一个单独的执行线程，没有等待I/O或上下文切换。相反，有一个事件循环在寻找事件并将它们分派给处理函数。范式是任何会阻塞或需要时间来完成操作的任何操作都必须使用异步模型。这些函数应该提供一个匿名函数作为处理回调，或者（随着ES2015
    promises的出现），函数会返回一个Promise。处理函数或Promise在操作完成时被调用。在此期间，控制权返回到事件循环，它继续分派事件。
- en: At the Node.js interactive conference in 2017, IBM's Chris Bailey made a case
    for Node.js being an excellent choice for highly scalable microservices. Key performance
    characteristics are I/O performance, measured in transactions per second, startup
    time, because that limits how quickly your service can scale up to meet demand,
    and memory footprint, because that determines how many application instances can
    be deployed per server. Node.js excels on all those measures; with every subsequent
    release each, is either improving or remaining fairly steady. Bailey presented
    figures comparing Node.js to a similar benchmark written in Spring Boot showing
    Node.js to perform much better. To view his talk, see [https://www.youtube.com/watch?v=Fbhhc4jtGW4](https://www.youtube.com/watch?v=Fbhhc4jtGW4).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在2017年的Node.js交互式会议上，IBM的Chris Bailey提出了Node.js是高度可扩展微服务的优秀选择。关键性能特征是I/O性能，以每秒事务数衡量，启动时间，因为这限制了你的服务可以多快地扩展以满足需求，以及内存占用，因为这决定了每个服务器可以部署多少个应用程序实例。Node.js在这些方面都表现出色；随着每个后续版本的发布，它要么在改进，要么保持相当稳定。Bailey展示了将Node.js与用Spring
    Boot编写的类似基准进行比较的数字，表明Node.js的表现要好得多。要观看他的演讲，请参阅[https://www.youtube.com/watch?v=Fbhhc4jtGW4](https://www.youtube.com/watch?v=Fbhhc4jtGW4)。
- en: 'To help us wrap our heads around why this would be, let''s return to Ryan Dahl,
    the creator of Node.js, and the key inspiration leading him to create Node.js.
    In his *Cinco de NodeJS* presentation in May 2010, [https://www.youtube.com/watch?v=M-sc73Y-zQA](https://www.youtube.com/watch?v=M-sc73Y-zQA),
    Dahl asked us what happens while executing a line of code such as this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解为什么会这样，让我们回到Node.js的创造者Ryan Dahl，以及激发他创造Node.js的关键灵感。在2010年5月的*Cinco
    de NodeJS*演讲中，[https://www.youtube.com/watch?v=M-sc73Y-zQA](https://www.youtube.com/watch?v=M-sc73Y-zQA)，Dahl询问我们在执行类似以下代码的行时会发生什么：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, the program pauses at that point while the database layer sends the
    query to the database, which determines the result and returns the data. Depending
    on the query, that pause can be quite long; well, a few milliseconds, which is
    an eon in computer time. This pause is bad because that execution thread can do
    nothing while waiting for the result to arrive. If your software is running on
    a single-threaded platform, the entire server would be blocked and unresponsive.
    If instead, your application is running on a thread-based server platform, a thread
    context switch is required to satisfy any other requests that arrive. The greater
    the number of outstanding connections to the server, the greater the number of
    thread context switches. Context switching is not free because more threads require
    more memory per thread state and more time for the CPU to spend on thread management
    overhead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，程序会在那个点暂停，因为数据库层将查询发送到数据库，数据库确定结果并返回数据。根据查询的不同，这个暂停可能相当长；好吧，几毫秒，这在计算机时间中是一个漫长的时代。这个暂停很不好，因为执行线程在等待结果到来时什么都不能做。如果你的软件运行在单线程平台上，整个服务器将会被阻塞并且无响应。如果相反，你的应用程序运行在基于线程的服务器平台上，则需要线程上下文切换来满足任何到达的其他请求。服务器上未完成的连接数越多，线程上下文切换的次数就越多。上下文切换不是免费的，因为更多的线程需要更多的内存来存储每个线程的状态，以及CPU在线程管理开销上花费更多的时间。
- en: Simply using an asynchronous, event-driven I/O, Node.js removes most of this
    overhead while introducing very little of its own.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用异步的事件驱动I/O，Node.js就消除了大部分这种开销，同时引入了很少的自身开销。
- en: 'Using threads to implement concurrency often comes with admonitions such as
    these: *expensive and error-prone*, *the error-prone synchronization primitives
    of Java*, or *designing concurrent software can be complex and error prone*. The
    complexity comes from the access to shared variables and various strategies to
    avoid deadlock and competition between threads. The *synchronization primitives
    of Java* are an example of such a strategy, and obviously many programmers find
    them difficult to use. There''s the tendency to create frameworks such as `java.util.concurrent`
    to tame the complexity of threaded concurrency, but some might argue that papering
    over complexity does not make things simpler.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程来实现并发通常伴随着这样的警告：*昂贵且容易出错*、*Java的错误易发同步原语*，或者*设计并发软件可能很复杂且容易出错*。复杂性来自于对共享变量的访问以及避免线程死锁和竞争的各种策略。Java的*同步原语*是这种策略的一个例子，显然许多程序员发现它们很难使用。有创建框架如`java.util.concurrent`的倾向，以驯服线程并发的复杂性，但有些人可能会认为掩盖复杂性并不会使事情变得更简单。
- en: Node.js asks us to think differently about concurrency. Callbacks fired asynchronously
    from an event loop are a much simpler concurrency model—simpler to understand,
    simpler to implement, simpler to reason about, and simpler to debug and maintain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js要求我们以不同的方式思考并发。从事件循环异步触发的回调是一个更简单的并发模型——更容易理解、更容易实现、更容易推理、更容易调试和维护。
- en: Ryan Dahl points to the relative access time of objects to understand the need
    for asynchronous I/O. Objects in memory are more quickly accessed (in the order
    of nanoseconds) than objects on disk or objects retrieved over the network (milliseconds
    or seconds). The longer access time for external objects is measured in zillions
    of clock cycles, which can be an eternity when your customer is sitting at their
    web browser ready to move on if it takes longer than two seconds to load the page.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ryan Dahl指出，对象相对访问时间可以理解异步I/O的需求。内存中的对象访问速度更快（以纳秒计），比磁盘上的对象或通过网络检索的对象（毫秒或秒）快。外部对象的较长时间访问以数百万个时钟周期来衡量，当你的客户坐在他们的网络浏览器上，如果页面加载时间超过两秒，他们可能就会离开。
- en: 'In Node.js, the query discussed previously will read as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，之前讨论的查询将如下所示：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The programmer supplies a function that is called (hence the name *callback
    function*) when the result (or error) is available. Instead of a thread context
    switch, this code returns almost immediately to the event loop. That event loop
    is free to handle other requests. The Node.js runtime keeps track of the stack
    context leading to this callback function, and eventually an event will fire causing
    this callback function to be called.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员提供一个函数，当结果（或错误）可用时会被调用（因此得名*回调函数*）。而不是线程上下文切换，此代码几乎立即返回到事件循环。该事件循环可以自由处理其他请求。Node.js运行时跟踪导致此回调函数的堆栈上下文，最终某个事件会触发，导致此回调函数被调用。
- en: 'Advances in the JavaScript language are giving us new options to implement
    this idea. The equivalent code looks like so when used with ES2015 Promise''s:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言的进步为我们提供了实现这个想法的新选项。当使用ES2015 Promise时，等效代码看起来是这样的：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following with an ES-2017 `async` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用ES-2017 `async`函数的例子：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All three of these code snippets perform the same query written earlier. The
    difference is that the query does not block the execution thread, because control
    passes back to the event loop. By returning almost immediately to the event loop,
    it is free to service other requests. Eventually, one of those events will be
    the response to the query shown previously, which will invoke the callback function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个代码片段执行的是之前写过的相同查询。区别在于查询不会阻塞执行线程，因为控制权返回到事件循环。通过几乎立即返回到事件循环，它可以自由地服务其他请求。最终，那些事件中的一个将是之前显示的查询的响应，这将调用回调函数。
- en: With the callback or Promise approach, the `result` is not returned as the result
    of the function call, but is provided to a callback function that will be called
    later. The order of execution is not one line after another, as it is in synchronous
    programming languages. Instead, the order of execution is determined by the order
    of the callback function execution.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调或Promise方法，`result`不是作为函数调用的结果返回，而是提供给稍后将被调用的回调函数。执行顺序不是一行接一行，就像在同步编程语言中那样。相反，执行顺序由回调函数的执行顺序决定。
- en: When using an `async` function, the coding style LOOKS like the original synchronous
    code example. The `result` is returned as the result of the function call, and
    errors are handled in a natural manner using `try/catch`. The `await` keyword
    integrates asynchronous results handling without blocking the execution thread.
    A lot is buried under the covers of the `async/await` feature, and we'll be covering
    this model extensively throughout the book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`async`函数时，编码风格看起来就像原始的同步代码示例。`result`作为函数调用的结果返回，错误使用`try/catch`以自然的方式处理。`await`关键字集成了异步结果处理，而不会阻塞执行线程。`async/await`功能之下隐藏了很多东西，我们将在整本书中广泛地介绍这个模型。
- en: Commonly, web pages bring together data from dozens of sources. Each one has
    a query and response as discussed earlier. Using asynchronous queries, each query
    can happen in parallel, where the page construction function can fire off dozens
    of queries—no waiting, each with their own callback—and then go back to the event
    loop, invoking the callbacks as each is done. Because it's in parallel, the data
    can be collected much more quickly than if these queries were done synchronously
    one at a time. Now, the reader on the web browser is happier because the page
    loads more quickly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网页会从数十个来源收集数据。每个来源都有一个前面讨论过的查询和响应。使用异步查询，每个查询可以并行发生，其中页面构建函数可以触发数十个查询——无需等待，每个都有自己的回调——然后返回到事件循环，在完成每个查询时调用回调。因为它是并行的，所以数据可以比如果这些查询是同步地一个接一个地完成收集得更快。现在，网页浏览器的读者会更高兴，因为页面加载得更快。
- en: Performance and utilization
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和利用率
- en: Some of the excitement over Node.js is due to its throughput (the requests per
    second it can serve). Comparative benchmarks of similar applications, for example,
    Apache, show that Node.js has tremendous performance gains.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对Node.js的一些兴奋之处归因于其吞吐量（它每秒可以服务的请求数）。例如，与Apache等类似应用的比较基准显示，Node.js有巨大的性能提升。
- en: 'One benchmark going around is this simple HTTP server (borrowed from [https://nodejs.org/en/](https://nodejs.org/en/)),
    which simply returns a `Hello World` message directly from memory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 流传的一个基准是一个简单的HTTP服务器（借鉴自[https://nodejs.org/en/](https://nodejs.org/en/))，它直接从内存中返回一个`Hello
    World`消息：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is one of the simpler web servers that you can build with Node.js. The
    `http` object encapsulates the HTTP protocol, and its `http.createServer` method
    creates a whole web server, listening on the port specified in the `listen` method.
    Every request (whether a `GET` or `POST` on any URL) on that web server calls
    the provided function. It is very simple and lightweight. In this case, regardless
    of the URL, it returns a simple `text/plain` that is the `Hello World` response.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Node.js中可以构建的较简单的Web服务器之一。`http`对象封装了HTTP协议，它的`http.createServer`方法创建了一个完整的Web服务器，监听`listen`方法中指定的端口。该Web服务器上的每个请求（无论是任何URL上的`GET`或`POST`）都会调用提供的函数。它非常简单且轻量。在这种情况下，无论URL如何，它都返回一个简单的`text/plain`，即`Hello
    World`响应。
- en: Ryan Dahl showed a simple benchmark ([https://www.youtube.com/watch?v=M-sc73Y-zQA](https://www.youtube.com/watch?v=M-sc73Y-zQA))
    that returned a 1-megabyte binary buffer; Node.js gave 822 req/sec, while Nginx
    gave 708 req/sec, for a 15% improvement over Nginx. He also noted that Nginx peaked
    at four megabytes memory, while Node.js peaked at 64 megabytes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ryan Dahl 展示了一个简单的基准测试 ([https://www.youtube.com/watch?v=M-sc73Y-zQA](https://www.youtube.com/watch?v=M-sc73Y-zQA))，返回了一个
    1 兆字节的二进制缓冲区；Node.js 提供了 822 req/sec，而 Nginx 提供了 708 req/sec，比 Nginx 提高了 15%。他还指出，Nginx
    的内存峰值达到四兆字节，而 Node.js 的内存峰值达到 64 兆字节。
- en: The key observation was that Node.js, running an interpreted JIT-compiled high-level
    language, was about as fast as Nginx, built of highly optimized C code, while
    running similar tasks. That presentation was in May 2010, and Node.js has improved
    hugely since then, as shown in Chris Bailey's talk that we referenced earlier.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关键观察结果是，Node.js，运行一个解释的 JIT 编译的高级语言，在执行类似任务时与由高度优化的 C 代码构建的 Nginx 大约一样快。那次演示是在
    2010 年 5 月，自那时以来，Node.js 已经取得了巨大的进步，正如我们之前提到的 Chris Bailey 的演讲中所示。
- en: Yahoo! search engineer Fabian Frank published a performance case study of a
    real-world search query suggestion widget implemented with Apache/PHP and two
    variants of Node.js stacks ([http://www.slideshare.net/FabianFrankDe/nodejs-performance-case-study](http://www.slideshare.net/FabianFrankDe/nodejs-performance-case-study)).
    The application is a pop-up panel showing search suggestions as the user types
    in phrases, using a JSON-based HTTP query. The Node.js version could handle eight
    times the number of requests per second with the same request latency. Fabian
    Frank said both Node.js stacks scaled linearly until CPU usage hit 100%. In another
    presentation ([http://www.slideshare.net/FabianFrankDe/yahoo-scale-nodejs](http://www.slideshare.net/FabianFrankDe/yahoo-scale-nodejs)),
    he discussed how Yahoo! Axis is running on Manhattan + Mojito and the value of
    being able to use the same language (JavaScript) and framework (YUI/YQL) on both
    frontend and backend.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo! 的搜索工程师 Fabian Frank 发布了一篇关于使用 Apache/PHP 和两种 Node.js 栈变体实现的现实世界搜索查询建议小部件的性能案例研究
    ([http://www.slideshare.net/FabianFrankDe/nodejs-performance-case-study](http://www.slideshare.net/FabianFrankDe/nodejs-performance-case-study))。该应用程序是一个弹出面板，当用户输入短语时显示搜索建议，使用基于
    JSON 的 HTTP 查询。Node.js 版本能够处理每秒八倍数量的请求，同时保持相同的请求延迟。Fabian Frank 表示，这两个 Node.js
    栈线性扩展，直到 CPU 使用率达到 100%。在另一个演示 ([http://www.slideshare.net/FabianFrankDe/yahoo-scale-nodejs](http://www.slideshare.net/FabianFrankDe/yahoo-scale-nodejs))
    中，他讨论了 Yahoo! Axis 是如何运行在 Manhattan + Mojito 上，以及能够在前后端都使用相同的语言（JavaScript）和框架（YUI/YQL）的价值。
- en: LinkedIn did a massive overhaul of their mobile app using Node.js for the server-side
    to replace an old Ruby on Rails app. The switch let them move from 30 servers
    down to three, and allowed them to merge the frontend and backend team because
    everything was written in JavaScript. Before choosing Node.js, they'd evaluated
    Rails with Event Machine, Python with Twisted, and Node.js, choosing Node.js for
    the reasons that we just discussed. For a look at what LinkedIn did, see [http://arstechnica.com/information-technology/2012/10/a-behind-the-scenes-look-at-linkedins-mobile-engineering/](http://arstechnica.com/information-technology/2012/10/a-behind-the-scenes-look-at-linkedins-mobile-engineering/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: LinkedIn 使用 Node.js 对其移动应用进行了大规模的重构，用 Node.js 替换了旧的 Ruby on Rails 应用程序，用于服务器端。这次切换使他们从
    30 台服务器减少到三台，并且由于所有内容都是用 JavaScript 编写的，他们得以合并前端和后端团队。在选择 Node.js 之前，他们评估了带有 Event
    Machine 的 Rails、带有 Twisted 的 Python 以及 Node.js，并基于我们刚才讨论的原因选择了 Node.js。要了解 LinkedIn
    所做的工作，请参阅 [http://arstechnica.com/information-technology/2012/10/a-behind-the-scenes-look-at-linkedins-mobile-engineering/](http://arstechnica.com/information-technology/2012/10/a-behind-the-scenes-look-at-linkedins-mobile-engineering/)。
- en: Most existing advice on Node.js performance tips tends to have been written
    for older V8 versions that used the CrankShaft optimizer. The V8 team has completely
    dumped CrankShaft, and it has a new optimizer called TurboFan. For example, under
    CrankShaft, it was slower to use `try/catch`, `let/const`, generator functions,
    and so on. Therefore, common wisdom said to not use those features, which is depressing
    because we want to use the new JavaScript features because of how much it has
    improved the JavaScript language. Peter Marshall, an Engineer on the V8 team at
    Google, gave a talk at Node.js Interactive 2017 claiming that, under TurboFan,
    you should just write natural JavaScript. With TurboFan, the goal is for across-the-board
    performance improvements in V8\. To view the presentation, see [https://www.youtube.com/watch?v=YqOhBezMx1o](https://www.youtube.com/watch?v=YqOhBezMx1o).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关于Node.js性能建议的现有内容往往是为较老的V8版本所写，这些版本使用了CrankShaft优化器。V8团队已经完全放弃了CrankShaft，并引入了一个名为TurboFan的新优化器。例如，在CrankShaft下，使用`try/catch`、`let/const`、生成器函数等会变慢。因此，普遍的智慧是不要使用这些特性，这令人沮丧，因为我们想使用新的JavaScript特性，因为它们极大地改进了JavaScript语言。谷歌V8团队的一名工程师Peter
    Marshall在Node.js Interactive 2017上发表了一次演讲，声称在TurboFan下，你应该只编写自然的JavaScript。使用TurboFan的目标是在V8中实现全面性能提升。要查看演讲，请参阅[https://www.youtube.com/watch?v=YqOhBezMx1o](https://www.youtube.com/watch?v=YqOhBezMx1o)。
- en: A truism about JavaScript is that it's no good for heavy computation work, because
    of the nature of JavaScript. We'll go over some ideas related to this in the next
    section. A talk by Mikola Lysenko at Node.js Interactive 2016 went over some issues
    with numerical computing in JavaScript, and some possible solutions. Common numerical
    computing involves large numerical arrays processed by numerical algorithms that
    you might have learned in Calculus or Linear Algebra classes. What JavaScript
    lacks is multi-dimensional arrays, and access to certain CPU instructions. The
    solution he presented is a library to implement multi-dimensional arrays in JavaScript,
    along with another library full of numerical computing algorithms. To view the
    presentation, see [https://www.youtube.com/watch?v=1ORaKEzlnys](https://www.youtube.com/watch?v=1ORaKEzlnys).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JavaScript的一个普遍真理是它不适合重计算工作，因为JavaScript的本质。我们将在下一节中讨论一些与此相关的内容。Mikola Lysenko在Node.js
    Interactive 2016的一次演讲中讨论了JavaScript中数值计算的一些问题以及一些可能的解决方案。常见的数值计算涉及通过数值算法处理的大数值数组，这些算法你可能已经在微积分或线性代数课程中学到。JavaScript缺乏的是多维数组以及访问某些CPU指令。他提出的解决方案是一个库，用于在JavaScript中实现多维数组，以及另一个包含大量数值计算算法的库。要查看演讲，请参阅[https://www.youtube.com/watch?v=1ORaKEzlnys](https://www.youtube.com/watch?v=1ORaKEzlnys)。
- en: The bottom line is that Node.js excels at event-driven I/O throughput. Whether
    a Node.js program can excel at computational programs depends on your ingenuity
    in working around some limitations in the JavaScript language. A big problem with
    computational programming is that it prevents the event loop from executing and,
    as we will see in the next section, that can make Node.js look like a poor candidate
    for anything.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Node.js在事件驱动I/O吞吐量方面表现卓越。一个Node.js程序是否能在计算程序方面表现出色，取决于你在绕过JavaScript语言某些限制方面的独创性。计算编程的一个大问题是它会阻止事件循环执行，正如我们将在下一节中看到的，这可能会使Node.js看起来不适合任何东西。
- en: Is Node.js a cancerous scalability disaster?
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js是不是一个有害的可扩展性灾难？
- en: 'In October 2011, software developer and blogger Ted Dziuba wrote a blog post
    (since pulled from his blog) titled *Node.js is a cancer*, calling it a *scalability
    disaster*. The example he showed for proof is a CPU-bound implementation of the
    Fibonacci sequence algorithm. While his argument was flawed, he raised a valid
    point that Node.js application developers have to consider the following: where
    do you put the heavy computational tasks?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在2011年10月，软件开发者和博主Ted Dziuba撰写了一篇博客文章（后来从他的博客中撤下），标题为*Node.js is a cancer*，称其为*可扩展性灾难*。他用来证明的例子是一个CPU密集型的斐波那契数列算法实现。尽管他的论点存在缺陷，但他提出了一个有效的观点，即Node.js应用程序开发者必须考虑以下问题：你将把重计算任务放在哪里？
- en: A key to maintaining high throughput of Node.js applications is ensuring that
    events are handled quickly. Because it uses a single execution thread, if that
    thread is bogged down with a big calculation, Node.js cannot handle events, and
    event throughput will suffer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 维护Node.js应用程序高吞吐量的关键是确保事件处理得快。因为它使用单个执行线程，如果这个线程被大计算拖累，Node.js就无法处理事件，事件吞吐量将受到影响。
- en: 'The Fibonacci sequence, serving as a stand-in for heavy computational tasks,
    quickly becomes computationally expensive to calculate, especially for a naïve
    implementation such as this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列，作为重型计算任务的替代品，计算起来很快就会变得非常昂贵，尤其是对于像这样的天真实现：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Yes, there are many ways to calculate fibonacci numbers more quickly. We are
    showing this as a general example of what happens to Node.js when event handlers
    are slow, and not to debate the best ways to calculate mathematics functions.
    Consider this server:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有许多方法可以更快地计算斐波那契数。我们展示这个例子是为了说明当事件处理器变慢时Node.js会发生什么，而不是为了讨论计算数学函数的最佳方法。考虑以下服务器：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For sufficiently large values of `n` (for example, `40`), the server becomes
    completely unresponsive because the event loop is not running, and instead this
    function is blocking event processing because it is grinding through the calculation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于足够大的`n`值（例如，`40`），服务器会完全无响应，因为事件循环没有运行，而是这个函数因为正在缓慢地进行计算而阻塞了事件处理。
- en: Does this mean that Node.js is a flawed platform? No, it just means that the
    programmer must take care to identify code with long-running computations and
    develop solutions. These include rewriting the algorithm to work with the event
    loop, or rewriting the algorithm for efficiency, or integrating a native code
    library, or foisting computationally expensive calculations on to a backend server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着Node.js是一个有缺陷的平台？不，这只意味着程序员必须小心地识别出具有长时间运行的代码，并开发解决方案。这些包括将算法重写为与事件循环一起工作，或者为了效率重写算法，或者集成本地代码库，或者将计算密集型计算推到后端服务器上。
- en: 'A simple rewrite dispatches the computations through the event loop, letting
    the server continue to handle requests on the event loop. Using callbacks and
    closures (anonymous functions), we''re able to maintain asynchronous I/O and concurrency
    promises:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的重写通过事件循环调度计算，让服务器能够继续在事件循环上处理请求。使用回调和闭包（匿名函数），我们能够保持异步I/O和并发承诺：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because this is an asynchronous function, it necessitates a small refactoring
    of the server:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个异步函数，所以需要对服务器进行一些小的重构：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Dziuba's valid point wasn't expressed well in his blog post, and it was somewhat
    lost in the flames following that post. Namely, that while Node.js is a great
    platform for I/O-bound applications, it isn't a good platform for computationally
    intensive ones.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Dziuba在博客文章中并没有很好地表达他的有效观点，而且在文章之后的评论中也有所遗失。具体来说，尽管Node.js是一个优秀的I/O密集型应用程序平台，但它并不是计算密集型应用程序的好平台。
- en: Later in this book, we'll explore this example a little more deeply.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将更深入地探讨这个例子。
- en: Server utilization, the business bottom line, and green web hosting
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器利用率、商业底线和绿色网络托管
- en: The striving for optimal efficiency (handling more requests per second) is not
    just about the geeky satisfaction that comes from optimization. There are real
    business and environmental benefits. Handling more requests per second, as Node.js
    servers can do, means the difference between buying lots of servers and buying
    only a few servers. Node.js potentially lets your organization do more with less.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 追求最优效率（每秒处理更多请求）并不仅仅是为了从优化中获得的技术满足感。这还带来了真正的商业和环境效益。每秒处理更多请求，正如Node.js服务器所能做到的那样，意味着在购买大量服务器和仅购买少量服务器之间的区别。Node.js有可能让您的组织用更少的资源做更多的事情。
- en: Roughly speaking, the more servers you buy, the greater the cost, and the greater
    the environmental impact of having those servers. There's a whole field of expertise
    around reducing costs and the environmental impact of running web server facilities,
    to which that rough guideline doesn't do justice. The goal is fairly obvious—fewer
    servers, lower costs, and a reduced environmental impact through utilizing more
    efficient software.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大体上，你购买的服务器越多，成本就越高，这些服务器的环境影响也越大。有一个专门的领域是关于降低运行Web服务器设施的成本和环境影响的，而这个粗略的指导原则并没有做到这一点。目标相当明显——更少的服务器，更低的成本，通过利用更高效的软件来减少环境影响。
- en: Intel's paper, *Increasing Data Center Efficiency with Server Power Measurements* ([https://www.intel.com/content/dam/doc/white-paper/intel-it-data-center-efficiency-server-power-paper.pdf](https://www.intel.com/content/dam/doc/white-paper/intel-it-data-center-efficiency-server-power-paper.pdf)),
    gives an objective framework for understanding efficiency and data center costs.
    There are many factors, such as buildings, cooling systems, and computer system
    designs. Efficient building design, efficient cooling systems, and efficient computer
    systems (data center efficiency, data center density, and storage density) can
    lower costs and environmental impact. But you can destroy those gains by deploying
    an inefficient software stack compelling you to buy more servers than you would
    if you had an efficient software stack. Alternatively, you can amplify gains from
    data center efficiency with an efficient software stack that lets you decrease
    the number of servers required.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的白皮书，*通过服务器功率测量提高数据中心效率* ([https://www.intel.com/content/dam/doc/white-paper/intel-it-data-center-efficiency-server-power-paper.pdf](https://www.intel.com/content/dam/doc/white-paper/intel-it-data-center-efficiency-server-power-paper.pdf))，提供了一个理解效率和数据中心成本的客观框架。有许多因素，例如建筑、冷却系统和计算机系统设计。高效的建筑设计、高效的冷却系统以及高效的计算机系统（数据中心效率、数据中心密度和存储密度）可以降低成本和环境影响。但如果你部署了一个低效的软件栈，迫使你购买比拥有高效软件栈时更多的服务器，那么你可能会破坏这些收益。或者，你可以通过一个高效的软件栈来放大数据中心效率的收益，这个软件栈允许你减少所需服务器的数量。
- en: This talk about efficient software stacks isn't just for altruistic environmental
    purposes. This is one of those cases where being green can help your business
    bottom line.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这场关于高效软件栈的讨论并不仅仅是为了环保的利他目的。这是一个绿色环保能够帮助提升企业盈利能力的案例。
- en: Embracing advances in the JavaScript language
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥抱 JavaScript 语言的进步
- en: The last couple of years have been an exciting time for JavaScript programmers.
    The TC-39 committee that oversees the ECMAScript standard has added many new features,
    some of which are syntactic sugar, but several of which have propelled us into
    a whole new era of JavaScript programming. By itself, the `async/await` feature
    promises us a way out of what's called Callback Hell, or the situation we find
    ourselves in when nesting callbacks within callbacks. It's such an important feature
    that it should necessitate a broad rethinking of the prevailing callback-oriented
    paradigm in Node.js and the rest of the JavaScript ecosystem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 过去的几年对 JavaScript 程序员来说是非常激动人心的。负责监督 ECMAScript 标准的 TC-39 委员会添加了许多新特性，其中一些是语法糖，但有几个特性推动了我们进入
    JavaScript 编程的全新时代。仅 `async/await` 功能就承诺了我们摆脱所谓的回调地狱的方法，或者是我们发现自己嵌套回调的情况。这是一个如此重要的特性，以至于它应该促使我们对
    Node.js 和 JavaScript 生态系统中的主流回调范式进行广泛的重新思考。
- en: 'Refer back a few pages to this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾几页之前的内容：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This was an important insight on Ryan Dahl's part, and is what propelled Node.js's
    popularity. Certain actions take a long time to run, such as database queries,
    and should not be treated the same as operations that quickly retrieve data from
    memory. Because of the nature of the JavaScript language, Node.js had to express
    this asynchronous coding construct in an unnatural way. The results do not appear
    at the next line of code, but instead appear within this callback function. Further,
    errors have to be handled in an unnatural way, inside that callback function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Ryan Dahl 的重要洞察，也是推动 Node.js 流行起来的原因。某些操作需要很长时间才能运行，例如数据库查询，不应与快速从内存中检索数据的操作同等对待。由于
    JavaScript 语言的特性，Node.js 必须以不自然的方式表达这种异步编程结构。结果不会出现在下一行代码中，而是在这个回调函数中显示。此外，错误必须以不自然的方式在回调函数内部处理。
- en: The convention in Node.js is that the first parameter to a callback function
    is an error indicator, and the subsequent parameters are the results. This is
    a useful convention that you'll find all across the Node.js landscape. However,
    it complicates working with results and errors because both land in an inconvenient
    location — that callback function. The natural place for errors and results to
    land is on the subsequent line(s) of code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中，约定回调函数的第一个参数是一个错误指示器，后续的参数是结果。这是一个有用的约定，你会在 Node.js 的各个领域找到它。然而，它使得处理结果和错误变得复杂，因为它们都落在了不方便的位置——那个回调函数。错误和结果的自然落点应该在代码的后续行。
- en: We descend further into **callback hell** with each layer of callback function
    nesting. The seventh layer of callback nesting is more complex than the sixth
    layer of callback nesting. Why? If nothing else, it's that the special considerations
    for error handling become ever more complex as callbacks are nested more deeply.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在回调函数嵌套的每一层都进一步陷入**回调地狱**。第七层回调嵌套比第六层回调嵌套更复杂。为什么？如果不是其他原因，那至少是因为随着回调嵌套的深度增加，错误处理的特殊考虑变得日益复杂。
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead, ES2017 async functions return us to this very natural expression of
    programming intent. Results and errors land in the correct location, while preserving
    the excellent event-driven asynchronous programming model that made Node.js great.
    We'll see later in the book how this works.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，ES2017 异步函数使我们回归到这种非常自然的编程意图的表达方式。结果和错误落在正确的位置，同时保留了使 Node.js 变得伟大的优秀事件驱动异步编程模型。我们将在本书的后面部分看到它是如何工作的。
- en: 'The TC-39 committee added many more new features to JavaScript, such as:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TC-39 委员会为 JavaScript 添加了许多新特性，例如：
- en: An improved syntax for Class declarations making object inheritance and getter/setter
    functions very natural.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的类声明语法，使得对象继承和 getter/setter 函数变得非常自然。
- en: A new module format that is standardized across browsers and Node.js.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种新的模块格式，它在浏览器和 Node.js 中得到标准化。
- en: New methods for strings, such as the template string notation.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的字符串方法，例如模板字符串表示法。
- en: New methods for collections and arrays — for example, operations for `map`/`reduce`/`filter`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合和数组的新方法——例如，`map`/`reduce`/`filter` 操作。
- en: The `const` keyword to define variables that cannot be changed, and the `let`
    keyword to define variables whose scope is limited to the block in which they're
    declared, rather than hoisted to the front of the function.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const` 关键字用于定义不可改变的变量，而 `let` 关键字用于定义作用域仅限于声明它们的代码块的变量，而不是提升到函数的前面。'
- en: New looping constructs, and an iteration protocol that works with those new
    loops.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的循环结构，以及与这些新循环一起工作的迭代协议。
- en: A new kind of function, the arrow function, which is lighter weight meaning
    less memory and execution time impact
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种新的函数类型，箭头函数，它更轻量级，意味着更少的内存和执行时间影响
- en: The Promise object represents a result that is promised to be delivered in the
    future. By themselves, Promises can mitigate the callback hell problem, and they
    form part of the basis for `async` functions.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promise 对象代表一个承诺在未来交付的结果。单独来看，Promise 可以减轻回调地狱问题，并且它们构成了 `async` 函数的基础部分。
- en: Generator functions are an intriguing way to represent asynchronous iteration
    over a set of values. More importantly, they form the other half of the basis
    for async functions.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数是表示对一组值进行异步迭代的一种有趣方式。更重要的是，它们构成了异步函数基础的一部分。
- en: You may see the new JavaScript described as ES6 or ES2017\. What's the preferred
    name to describe the version of JavaScript that is being used?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到新的 JavaScript 被描述为 ES6 或 ES2017。那么，描述正在使用的 JavaScript 版本的首选名称是什么？
- en: ES1 through ES5 marked various phases of JavaScript's development. ES5 was released
    in 2009, and is widely implemented in modern browsers. Starting with ES6, the
    TC-39 committee decided to change the naming convention because of their intention
    to add new language features every year. Therefore, the language version name
    now includes the year, hence ES2015 was released in 2015, ES2016 was released
    in 2016, and ES2017 was released in 2017.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ES1 到 ES5 标记了 JavaScript 发展的各个阶段。ES5 于 2009 年发布，在现代浏览器中得到广泛实现。从 ES6 开始，TC-39
    委员会决定改变命名约定，因为他们打算每年添加新的语言特性。因此，语言版本名称现在包括年份，所以 ES2015 于 2015 年发布，ES2016 于 2016
    年发布，ES2017 于 2017 年发布。
- en: Deploying ES2015/2016/2017/2018 JavaScript code
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 ES2015/2016/2017/2018 JavaScript 代码
- en: The pink elephant in the room is that, because of how JavaScript is delivered
    to the world, we cannot just start using the latest ES2017 features. In frontend
    JavaScript, we are limited by the fact that old browsers are still in use. Internet
    Explorer version 6 has fortunately been almost completely retired, but there are
    still plenty of old browsers installed on older computers that are still serving
    a valid role for their owners. Old browsers mean old JavaScript implementations,
    and if we want our code to work, we need it to be compatible with old browsers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 室内那只粉红色的象意味着，由于JavaScript的交付方式，我们无法直接开始使用最新的ES2017特性。在前端JavaScript中，我们受限于旧浏览器仍在使用的事实。幸运的是，Internet
    Explorer版本6几乎已经完全退役，但仍有大量旧浏览器安装在一些仍在为用户发挥有效作用的旧电脑上。旧浏览器意味着旧的JavaScript实现，如果我们想让我们的代码工作，我们需要它兼容旧浏览器。
- en: Using code rewriting tools such as Babel, some of the new features can be retrofitted
    to function on some of the older browsers. Frontend JavaScript programmers can
    adopt (some of) the new features at the cost of a more complex build toolchain,
    and the risk of bugs introduced by the code rewriting process. Some may wish to
    do that, while others will prefer to wait a while.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码重写工具，如Babel，可以将一些新特性回滚到一些较旧的浏览器上。前端JavaScript程序员可以在付出更复杂的构建工具链和代码重写过程中引入的bug风险代价下采用（一些）新特性，有些人可能愿意这样做，而其他人则可能更愿意等待一段时间。
- en: The Node.js world doesn't have this problem. Node.js has rapidly adopted ES2015/2016/2017
    features as quickly as they were implemented in the V8 engine. With Node.js 8,
    we can now use async functions as a native feature, and most of the ES2015/2016
    features became available with Node.js version 6\. The new module format is now
    supported in Node.js version 10.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js世界没有这个问题。Node.js已经迅速采用了ES2015/2016/2017特性，就像它们在V8引擎中实现的那样快。在Node.js 8中，我们现在可以使用异步函数作为一个原生特性，而ES2015/2016的大部分特性在Node.js版本6时就已经可用。新的模块格式现在在Node.js版本10中得到了支持。
- en: In other words, while frontend JavaScript programmers can argue that they must
    wait a couple of years before adopting ES2015/2016/2017 features, Node.js programmers
    have no need to wait. We can simply use the new features without needing any code
    rewriting tools.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，尽管前端JavaScript程序员可以争论他们必须等待几年才能采用ES2015/2016/2017特性，但Node.js程序员没有必要等待。我们可以简单地使用新特性，而不需要任何代码重写工具。
- en: Node.js, the microservice architecture, and easily testable systems
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js、微服务架构和易于测试的系统
- en: New capabilities, such as cloud deployment systems and Docker, make it possible
    to implement a new kind of service architecture. Docker makes it possible to define
    server process configuration in a repeatable container that's easy to deploy by
    the millions into a cloud hosting system. It lends itself best to small single-purpose
    service instances that can be connected together to make a complete system. Docker
    isn't the only tool to help simplify cloud deployments; however, its features
    are well attuned to modern application deployment needs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 新的能力，如云部署系统和Docker，使得实现一种新的服务架构成为可能。Docker使得在可重复的容器中定义服务器进程配置成为可能，这种容器易于部署到云托管系统中，适用于小型单一用途服务实例，可以将它们连接起来形成一个完整的系统。Docker不是唯一帮助简化云部署的工具；然而，其特性非常适合现代应用程序部署的需求。
- en: Some have popularized the microservice concept as a way to describe this kind
    of system. According to the [microservices.io](http://microservices.io/) website,
    a microservice consists of a set of narrowly focused, independently deployable
    services. They contrast this with the monolithic application deployment pattern
    where every aspect of the system is integrated into one bundle (such as a single
    WAR file for a Java EE app server). The microservice model gives developers much
    needed flexibility.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人已经将微服务概念普及为描述这类系统的一种方式。根据[microservices.io](http://microservices.io/)网站，微服务由一组专注于特定领域、可独立部署的服务组成。他们将此与单体应用程序部署模式进行对比，在这种模式中，系统的每个方面都集成到一个捆绑包中（例如，Java
    EE应用程序服务器的单个WAR文件）。微服务模型为开发者提供了急需的灵活性。
- en: 'Some advantages of microservices are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的某些优势如下：
- en: Each microservice can be managed by a small team
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务都可以由一个小团队管理
- en: Each team can work on its own schedule, so long as the service API compatibility
    is maintained
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个团队都可以根据自己的时间表工作，只要保持服务API的兼容性
- en: Microservices can be deployed independently, such as for easier testing
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以独立部署，例如，为了更容易测试
- en: It's easier to switch technology stack choices
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易切换技术栈选择
- en: 'Where does Node.js fit in with this? Its design fits the microservice model
    like a glove:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 在其中扮演什么角色？其设计就像手套一样适合微服务模型：
- en: Node.js encourages small, tightly focused, single-purpose modules
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 鼓励小型、紧密聚焦、单一用途的模块
- en: These modules are composed into an application by the excellent npm package
    management system
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些模块通过优秀的 npm 包管理系统组合成一个应用程序
- en: Publishing modules is incredibly simple, whether via the NPM repository or a
    Git URL
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布模块非常简单，无论是通过 NPM 仓库还是 Git URL
- en: Node.js and the Twelve-Factor app model
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 和十二要素应用模型
- en: Throughout this book, we'll call out aspects of the Twelve-Factor App model,
    and ways to implement those ideas in Node.js. This model is published on [http://12factor.net](http://12factor.net),
    and is a set of guidelines for application deployment in the modern cloud computing
    era. It's not that the  Twelve-Factor App model is the be-all and end-all of application
    architecture paradigms. It's a set of useful ideas, clearly birthed after many
    late nights spent debugging complex applications, which offer useful ideas that
    could save us all a lot of effort by having easier-to-maintain and more reliable
    systems.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将指出十二要素应用模型的一些方面，以及如何在 Node.js 中实现这些想法。这个模型发布在 [http://12factor.net](http://12factor.net)，是一套适用于现代云计算时代的应用部署指南。十二要素应用模型并不是应用架构范例的终极解决方案。它是一套有用的想法，显然是在许多深夜调试复杂应用之后产生的，这些想法通过更容易维护和更可靠的系统为我们所有人节省了大量精力。
- en: The guidelines are straightforward, and once you read them, they will seem like
    pure common sense. As a best practice, the Twelve-Factor App model is a compelling
    strategy for delivering the kind of fluid self-contained cloud-deployed applications
    called for by our current computing environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 指南简单明了，一旦你阅读了它们，它们就会显得像纯粹的常识。作为一个最佳实践，十二要素应用模型是我们当前计算环境所要求的流动自包含云部署应用的引人入胜的策略。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter. Specifically, you saw that JavaScript has
    a life outside web browsers and you learned about the difference between asynchronous
    and blocking I/O. We then covered the attributes of Node.js and where it fits
    in the overall web application platform market and threaded versus asynchronous
    software. Lastly, we saw the advantages of fast event-driven asynchronous I/O,
    coupled with a language with great support for anonymous closures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中学到了很多。具体来说，你看到了 JavaScript 在网络浏览器之外也有生命，并且你了解了异步和阻塞 I/O 之间的区别。然后我们介绍了 Node.js
    的属性以及它在整体网络应用平台市场中的位置，以及线程与异步软件的比较。最后，我们看到了快速事件驱动异步 I/O 的优势，以及与支持匿名闭包的语言相结合的优势。
- en: Our focus in this book is real-world considerations of developing and deploying
    Node.js applications. We'll cover as many aspects as we can of developing, refining,
    testing, and deploying Node.js applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本书关注的是开发和部署 Node.js 应用程序的实际考虑因素。我们将尽可能涵盖开发、精炼、测试和部署 Node.js 应用程序的各个方面。
- en: Now that we've had this introduction to Node.js, we're ready to dive in and
    start using it. In Chapter 2, *Setting up Node.js*, we'll go over setting up a
    Node.js environment, so let's get started.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Node.js 有了一个介绍，我们准备深入学习和使用它。在第二章 *设置 Node.js* 中，我们将介绍如何设置 Node.js 环境，让我们开始吧。
