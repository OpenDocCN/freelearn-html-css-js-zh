- en: Chapter 1. Instant Testing with CasperJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 使用CasperJS进行即时测试
- en: Welcome to *Instant Testing with CasperJS*. This book will cover how to practice
    efficient and solid web page testing using CasperJS. CasperJS is a cross-platform,
    command-line utility that is able to load and script any web page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用*CasperJS即时测试*。这本书将涵盖如何使用CasperJS进行高效和扎实的网页测试。CasperJS是一个跨平台的命令行工具，能够加载和脚本化任何网页。
- en: Installing CasperJS (Simple)
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装CasperJS（简单）
- en: In this recipe, we will cover the steps to install CasperJS and its dependencies
    on Windows, Mac OS X, and Linux.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将介绍如何在Windows、Mac OS X和Linux上安装CasperJS及其依赖项的步骤。
- en: Getting ready
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The CasperJS sources are managed on GitHub. So, to get them on our local machine,
    we need Git.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS的源代码在GitHub上管理。因此，为了在我们的本地机器上获取它们，我们需要Git。
- en: 'To install Git on Windows, we can use msysGit to deploy the Git command-line
    utility plus a graphical interface:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows上安装Git，我们可以使用msysGit来部署Git命令行工具以及图形界面：
- en: Go to [http://msysgit.github.io/](http://msysgit.github.io/).
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://msysgit.github.io/](http://msysgit.github.io/)。
- en: Go to the **Downloads** page.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**下载**页面。
- en: Download the latest version.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载最新版本。
- en: Run the installer.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序。
- en: 'To install Git on Mac, the easiest way is to use Git for OS X graphical interface:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上安装Git，最简单的方法是使用Git for OS X图形界面：
- en: Go to [https://code.google.com/p/git-osx-installer/](https://code.google.com/p/git-osx-installer/).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://code.google.com/p/git-osx-installer/](https://code.google.com/p/git-osx-installer/)。
- en: Go to the **Downloads** page.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**下载**页面。
- en: Download the latest version.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载最新版本。
- en: Run the installer.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序。
- en: 'You can also install Git from the MacPorts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从MacPorts安装Git：
- en: Make sure MacPorts is installed (if not, go to [http://www.macports.org/](http://www.macports.org/)
    and follow the instructions).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已安装MacPorts（如果没有，请访问[http://www.macports.org/](http://www.macports.org/)并遵循说明）。
- en: 'From a command line, enter the following command:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下命令：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install Git on Linux, use the following commands:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux上安装Git，请使用以下命令：
- en: 'For Debian/Ubuntu, enter the following command:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Debian/Ubuntu，输入以下命令：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Fedora, enter the following command:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Fedora，输入以下命令：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First of all, we need to install PhantomJS.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装PhantomJS。
- en: 'Perform the following steps to install PhantomJS on Windows:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行以下步骤在Windows上安装PhantomJS：
- en: Go to [http://phantomjs.org/download.html](http://phantomjs.org/download.html).
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://phantomjs.org/download.html](http://phantomjs.org/download.html)。
- en: Download the Windows version.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Windows版本。
- en: Extract its content.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取其内容。
- en: 'Add the `phantomjs.exe` path to the `PATH` environment variable, assuming it
    is located at `C:\PhantomJS`:'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`phantomjs.exe`路径添加到`PATH`环境变量中，假设它位于`C:\PhantomJS`：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Perform the following steps to install PhantomJS on Mac and Linux:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行以下步骤在Mac和Linux上安装PhantomJS：
- en: Go to [http://phantomjs.org/download.html](http://phantomjs.org/download.html).
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://phantomjs.org/download.html](http://phantomjs.org/download.html)。
- en: Download the appropriate version (Mac OS X / Linux 32 bits / Linux 64 bits).
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载合适的版本（Mac OS X / Linux 32位 / Linux 64位）。
- en: Extract its content.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取其内容。
- en: 'Make `bin/phamtomjs` available in your system path using the following command:'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令使`bin/phamtomjs`在您的系统路径中可用：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we should be able to run `phantomjs` from a command line:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们应该能够从命令行运行`phantomjs`：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we can install CasperJS using Git. We need to locally clone the official
    CasperJS repository from GitHub.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用Git安装CasperJS。我们需要从GitHub本地克隆官方的CasperJS仓库。
- en: 'This can be achieved using the following command:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过以下命令实现：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should produce an output similar to the following command:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该产生类似于以下命令的输出：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To check out the last stable version, we need to run the following Git command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检出最新稳定版本，我们需要运行以下Git命令：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will get the following message:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将得到以下信息：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's check if CasperJS is properly installed.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查CasperJS是否正确安装。
- en: 'To check if CasperJS is installed properly on Windows, use the following commands:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检查Windows上的CasperJS是否正确安装，请使用以下命令：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To check if CasperJS is installed properly on Mac OS X / Linux, use the following
    commands:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检查Mac OS X / Linux上的CasperJS是否正确安装，请使用以下命令：
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We should obtain the following result:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该获得以下结果：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To complete the installation, we will now make sure that the `casperjs` executable
    is available in our system path.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成安装，我们现在将确保`casperjs`可执行文件在我们的系统路径中可用。
- en: 'To complete the installation on Windows add the following path to `casperjs.bat`
    to the `PATH` environment variable, assuming the repository is located in `C:\casperjs`:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在 Windows 上完成安装，请将以下路径添加到 `casperjs.bat` 中的 `PATH` 环境变量中，假设仓库位于 `C:\casperjs`：
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To complete the installation on Mac and Linux, link `bin/casperjs` in `/usr/local/bin`
    using the following command:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在 Mac 和 Linux 上完成安装，请使用以下命令将 `bin/casperjs` 链接到 `/usr/local/bin`：
- en: '[PRE14]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can check if `casperjs` is in the system path using the following command:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查 `casperjs` 是否在系统路径中：
- en: '[PRE15]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The setup is now complete.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 设置现在已完成。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just after cloning the repository, we launched a Git command to get the Version
    1.1 (which was still a beta version at the time we were writing those lines).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在克隆仓库后，我们启动了一个 Git 命令以获取版本 1.1（在我们编写这些行的时候，它仍然是一个测试版本）。
- en: 'If we had not launched the Git command, we would still have had a correct CasperJS
    setup, but be careful; Git has downloaded all the CasperJS revisions since the
    very beginning of CasperJS''s development till today, and *has automatically checked
    out the last one*. So, we try using the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有启动 Git 命令，我们仍然会有一个正确的 CasperJS 设置，但请注意；Git 已经下载了自 CasperJS 开发初期至今的所有 CasperJS
    修订版本，并且*自动检出最新版本*。因此，我们尝试使用以下命令：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will obtain something similar to the following result:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到类似以下的结果：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It means that we are running the current development version and using a development
    version is probably not what we want as it might be unstable or even broken.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们正在运行当前的开发版本，使用开发版本可能不是我们想要的，因为它可能是不稳定的，甚至可能损坏。
- en: That is why we need to check out the 1.1 tagged revision specifically.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要检出特定标记的 1.1 版本修订。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Now, let's discuss some installation options.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一些安装选项。
- en: Installing CasperJS with Homebrew on Mac OS X
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Mac OS X 上使用 Homebrew 安装 CasperJS
- en: 'Homebrew is a package manager for Mac OS X. It is a very handy way to deploy
    PhantomJS and CasperJS using the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew 是 Mac OS X 的包管理器。它是一种非常方便的方式来部署 PhantomJS 和 CasperJS，使用以下命令：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Installing PhantomJS on Ubuntu
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上安装 PhantomJS
- en: Be careful; on Ubuntu, if we install PhantomJS from the distribution packages,
    we will get an old version (Version 1.4 or 1.6, depending on our Ubuntu version).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意；在 Ubuntu 上，如果我们从发行版软件包中安装 PhantomJS，我们将得到一个旧版本（版本 1.4 或 1.6，取决于我们的 Ubuntu
    版本）。
- en: But CasperJS needs at least PhantomJS 1.7\. So, package installation is not
    an option.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但 CasperJS 至少需要 PhantomJS 1.7。因此，包安装不是一个选项。
- en: Using the CasperJS Ruby executable
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CasperJS Ruby 可执行文件
- en: On Mac OS X and Linux, the default `casperjs` executable is a Python script.
    Python should be available on our system (unless we use an exotic Linux distribution),
    so it makes no problem.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 和 Linux 上，默认的 `casperjs` 可执行文件是一个 Python 脚本。Python 应该在我们的系统中可用（除非我们使用异类的
    Linux 发行版），所以这不会造成问题。
- en: 'Nevertheless, if we prefer to launch CasperJS using a Ruby script, we do have
    one in `./rubybin`. So, we just need to make it available in our system path this
    way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们更喜欢使用 Ruby 脚本来启动 CasperJS，我们确实有一个在 `./rubybin` 中。因此，我们只需要以这种方式使它在系统路径中可用：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Getting started with CasperJS (Simple)
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CasperJS（简单）入门
- en: This recipe will explain how to write basic CasperJS tests and will help us
    get familiar with the CasperJS approach.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将解释如何编写基本的 CasperJS 测试，并帮助我们熟悉 CasperJS 的方法。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will build simple web pages in order to run our CasperJS
    tests in an appropriate context.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建简单的网页，以便在适当的环境中运行我们的 CasperJS 测试。
- en: As we need to serve just static content (HTML, CSS, JavaScript), we need a very
    basic HTTP server and the simplest existing HTTP server is the Python 2 SimpleHTTTPServer,
    as it is part of the standard Python installation (so that no extra deployment
    is needed), and it does not need any system configuration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要仅提供静态内容（HTML、CSS、JavaScript），我们需要一个非常基本的 HTTP 服务器，最简单的现有 HTTP 服务器是 Python
    2 SimpleHTTTPServer，因为它包含在标准的 Python 安装中（因此不需要额外的部署），并且它不需要任何系统配置。
- en: 'On Mac OS X and Linux, Python 2 is part of the system; we just launch the following
    command line from the folder containing our web content:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 和 Linux 上，Python 2 是系统的一部分；我们只需从包含我们的网页内容的文件夹中启动以下命令行：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding command should return this message:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该返回以下信息：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The message means that our local web server is running on the `8000` port and
    we can access it with our web browser using the following URL:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这条信息意味着我们的本地网络服务器正在 `8000` 端口上运行，我们可以使用以下 URL 使用我们的网络浏览器访问它：
- en: '`http://localhost:8000/`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`'
- en: 'On Windows, we can do the very same thing but Python is not installed by default,
    so we first need to install it this way:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们可以做同样的事情，但 Python 默认并未安装，因此我们首先需要以这种方式安装它：
- en: Go to [http://www.python.org/getit/](http://www.python.org/getit/).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [http://www.python.org/getit/](http://www.python.org/getit/)。
- en: Download the Python 2.7 Windows installer.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Python 2.7 Windows 安装程序。
- en: Run it.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它。
- en: 'Add Python to our system path:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Python 添加到我们的系统路径中：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We are now ready to write CasperJS tests. For our first test, we will not need
    our local web server as we will use the Wikipedia website:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好编写 CasperJS 测试了。对于我们的第一个测试，我们不需要我们的本地 web 服务器，因为我们将使用维基百科网站：
- en: 'Let''s create the following file and name it `example1.js`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建以下文件，并将其命名为 `example1.js`：
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When we run our script, we get the following output:![How to do it...](img/9431OS_01_01.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行我们的脚本时，我们得到以下输出：![如何操作...](img/9431OS_01_01.jpg)
- en: 'Let''s see how it works:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: In the first line, we get a new `'casper'` instance.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一行，我们获取一个新的 `'casper'` 实例。
- en: Then, in the second line, we start this instance and open the Wikipedia page.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在第二行，我们启动这个实例并打开维基百科页面。
- en: We give the `start()` method a function that will be executed once the page
    is loaded. In this function, the context (`this`) is the `casper` instance. Here,
    we just use the `echo()` method to display the current page title (obtained using
    `getTitle()`).
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们给 `start()` 方法一个函数，该函数将在页面加载后执行。在这个函数中，上下文（`this`）是 `casper` 实例。这里，我们只是使用
    `echo()` 方法显示当前页面的标题（使用 `getTitle()` 获取）。
- en: In the last line, we launch the registered steps.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一行，我们启动已注册的步骤。
- en: 'Now, let''s change a little bit of our script in order to perform a search
    on Wikipedia about `''javascript''`:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们稍微修改一下我们的脚本，以便在维基百科上搜索 `'javascript'`：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's run it:![How to do it...](img/9431OS_01_02.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行它：![如何操作...](img/9431OS_01_02.jpg)
- en: 'We have made two changes:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们做了两个修改：
- en: We used the `fill()` method to submit our search keyword to the Wikipedia search
    form
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了 `fill()` 方法将我们的搜索关键字提交到维基百科搜索表单。
- en: We added a new step in our script using the `then()` method to make sure that
    we wait for the search result to be returned; we also displayed the current URL
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `then()` 方法在脚本中添加了一个新步骤，以确保我们等待搜索结果返回；我们还显示了当前 URL。
- en: As we can see, it works perfectly as we obtained the URL of the Wikipedia article
    about JavaScript. Now, let's "assert" the world!
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，它工作得非常完美，因为我们获得了关于 JavaScript 的维基百科文章的 URL。现在，让我们“断言”一下世界吧！
- en: We just wrote a basic CasperJS script, but it is not a very efficient test script
    as a test script is supposed to check if an expected behavior is properly performed
    by the web page that we are testing.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚编写了一个基本的 CasperJS 脚本，但它不是一个非常高效的测试脚本，因为测试脚本应该检查我们正在测试的网页是否正确地执行了预期的行为。
- en: To do that, CasperJS provides a tester API, which can be accessed via the `test`
    property of our CasperJS instance.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了做到这一点，CasperJS 提供了一个测试器 API，可以通过我们的 CasperJS 实例的 `test` 属性访问。
- en: 'Let''s create the following example page and name it `example2.html`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建以下示例页面，并将其命名为 `example2.html`：
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's launch our SimpleHTTPServer and see what the page looks like by going
    to `http://localhost:8000/example2.html`.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们启动我们的 SimpleHTTPServer，通过访问 `http://localhost:8000/example2.html` 来查看页面看起来是什么样子。
- en: It shows a **Click me** button and if we click on it, its label is changed to
    **Done**.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它显示了一个 **点击我** 按钮，如果我们点击它，它的标签将变为 **完成**。
- en: 'The following is a CasperJS test that could validate this behavior:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一个 CasperJS 测试，可以验证这种行为：
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's save this script as `example2.js` and run it using the `casperjs test`
    command:![How to do it...](img/9431OS_01_03.jpg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这个脚本保存为 `example2.js`，并使用 `casperjs test` 命令运行它：![如何操作...](img/9431OS_01_03.jpg)
- en: The `casperjs test` command allows us to use the `casper.test` property, which
    provides all the testing methods.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`casperjs test` 命令允许我们使用 `casper.test` 属性，它提供了所有的测试方法。'
- en: When using the `casperjs test` command, we do not need to create the `casper`
    instance, but we need to call the `begin` method and end the test with the `done`
    method.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用 `casperjs test` 命令时，我们不需要创建 `casper` 实例，但我们需要调用 `begin` 方法，并用 `done` 方法结束测试。
- en: First, with `assertVisible`, we make sure that our button is visible. The most
    common way to designate an element is by providing an accurate CSS selector.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `assertVisible`，我们确保我们的按钮是可见的。指定元素最常见的方式是提供一个准确的 CSS 选择器。
- en: Then, we use `assertSelectorHasText` to check the text content of the button
    before and after clicking on it. We can see that all our tests pass.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`assertSelectorHasText`来检查点击按钮前后按钮的文本内容。我们可以看到所有我们的测试都通过了。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `begin` method takes a description and the number of expected tests (beside
    the test itself) as parameters. The number of successful and failed tests are
    displayed in the final line.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`begin`方法接受一个描述和预期测试次数（除了测试本身）作为参数。成功和失败的测试次数将在最后一行显示。'
- en: 'Now, let''s break our tests by changing the second `assertSelectorHasText`
    tester as shown in the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过更改第二个`assertSelectorHasText`测试器来破坏我们的测试，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从[http://www.PacktPub.com](http://www.PacktPub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: And the result is as follows:![How to do it...](img/9431OS_01_04.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果如下：![如何做到这一点...](img/9431OS_01_04.jpg)
- en: We clearly see that our two assertions still pass, but one is now failing.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们清楚地看到我们的两个断言仍然通过，但现在有一个失败了。
- en: Timing is everything
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间就是一切
- en: When developing with JavaScript, we often need to chain two pieces of code (for
    instance, first we load some JSON data, then we update the page content using
    that data). But, each step is generally non-blocking, which means that the rest
    of the code will continue to execute even if the step is not complete, and there
    is no way to predict when the first step will be complete.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JavaScript开发时，我们经常需要链式调用两段代码（例如，首先我们加载一些JSON数据，然后我们使用这些数据更新页面内容）。但是，每一步通常是非阻塞的，这意味着即使步骤未完成，其余的代码也会继续执行，而且无法预测第一步何时完成。
- en: The most solid and common approach to solve this problem is the *callback* mechanism.
    We put the second piece of code in a function and pass it as a parameter to the
    first one, so that it can call that function when it finishes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最稳健和常见的方法是**回调**机制。我们将第二段代码放在一个函数中，并将其作为参数传递给第一个函数，这样它就可以在完成时调用该函数。
- en: As a result, there is no linear and predictably-ordered execution of the code.
    This makes testing a little bit tricky.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，代码没有线性且可预测的执行顺序。这使得测试变得有些棘手。
- en: 'The following is an example (`example3.html`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例（`example3.html`）：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The demo account we are using here to access the Geonames.org service has a
    daily limit, if the limit is reached, we can go [http://www.geonames.org/login](http://www.geonames.org/login)
    and create our own account. The preceding code will create a page that contains
    a text input field, a button, and an empty div with an ID as `''results''`. When
    we click on the button, the JavaScript function `geonamesSearch` does the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的演示账户用于访问Geonames.org服务，有一个每日限制，如果达到限制，我们可以访问[http://www.geonames.org/login](http://www.geonames.org/login)并创建我们自己的账户。前面的代码将创建一个包含文本输入字段、按钮和一个ID为`'results'`的空div的页面。当我们点击按钮时，JavaScript函数`geonamesSearch`执行以下操作：
- en: It puts the `'searching'` class on the `results` div and inserts the **Searching...**
    mention
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将`'searching'`类添加到`results`div，并插入**正在搜索...**的提及
- en: It reads the text input's current value
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它读取文本输入的当前值
- en: It calls the GeoNames JSON web services to get the place names matching the
    value that you input
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用GeoNames JSON网络服务以获取与您输入的值匹配的地点名称
- en: This JSON call is performed by jQuery and we provide it with a callback function
    that will be called when the GeoNames web service will respond and read the results
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个JSON调用是由jQuery执行的，我们提供了一个回调函数，当GeoNames网络服务响应并读取结果时将被调用
- en: If there is no result, it changes the `results` div class to `'noresults'` and
    its text to **No matching place.**
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有结果，它将`results`div类的值更改为`'noresults'`，并将其文本更改为**没有匹配的地点**。
- en: If there are some results, it sets the class to `'success'` and displays the
    matching place names
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有一些结果，它将类设置为`'success'`并显示匹配的地点名称
- en: We can try it with our web browser and see it work nicely.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们的网络浏览器尝试它，看看它是否工作得很好。
- en: 'Now, let''s test this page with the following script (`example3.js`), which
    enters the value `''barcelona''` and asserts that we do get **Barcelona (Catalonia)**
    in the results:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下脚本（`example3.js`）测试这个页面，该脚本输入值 `'barcelona'` 并断言我们确实得到了结果中的 **巴塞罗那（加泰罗尼亚）**：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need to set up a regular user agent to make sure that `geonames.org` will
    accept to process our request.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置一个常规用户代理，以确保 `geonames.org` 会接受处理我们的请求。
- en: 'If we run it, we get a failure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，我们会得到一个失败：
- en: '![Timing is everything](img/9431OS_01_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![时机就是一切](img/9431OS_01_05.jpg)'
- en: Why is that? Because our `this.click()` triggers the `geonamesSearch` function
    and immediately after that we try to assert the result content. However, as the
    GeoNames web service did not have enough time to respond, the content is not yet
    the one expected at the time the assertion is performed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？因为我们的 `this.click()` 触发了 `geonamesSearch` 函数，紧接着我们就尝试断言结果内容。然而，由于 GeoNames
    网络服务没有足够的时间响应，所以在断言执行时内容还不是我们预期的。
- en: To manage these kinds of cases, CasperJS offers us the ability to wait before
    executing the rest of our tests.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理这类情况，CasperJS 提供了在执行其余测试之前等待的能力。
- en: 'The following is a working test script:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个工作测试脚本：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can see that the tests pass successfully now:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，现在测试已经成功通过：
- en: '![Timing is everything](img/9431OS_01_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![时机就是一切](img/9431OS_01_06.jpg)'
- en: With `waitForSelector`, we make sure that the assertion will be performed only
    when the `results` div will have the `'success'` class, and it will happen only
    once our JSON loading callback function has been called.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `waitForSelector`，我们确保断言只有在 `results` div 具有 `'success'` 类时才会执行，并且只有在我们的
    JSON 加载回调函数被调用后才会发生。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `waitForSelector` method will not wait forever; it does have a timeout (with
    a default value of 5000 milliseconds, which can be changed) and we can provide
    a second function that will be called if the timeout is reached before the selector
    is satisfied.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForSelector` 方法不会无限期等待；它确实有一个超时时间（默认值为 5000 毫秒，可以更改），并且我们可以提供一个在选择器满足之前达到超时时间的第二个函数。'
- en: Live recording
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时录制
- en: Writing tests can take time. A quick and convenient way to produce tests is
    to record an actual usage sequence directly from our web browser (just like the
    Firefox Selenium plug-in).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试可能需要时间。一个快速方便的方法是直接从我们的网页浏览器中录制实际的用法序列（就像 Firefox 的 Selenium 插件一样）。
- en: To record web sequences as CasperJS tests, we can use a Chrome extension named
    **Resurrectio**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要将网页序列录制为 CasperJS 测试，我们可以使用一个名为 **Resurrectio** 的 Chrome 扩展程序。
- en: 'We install it from the Chrome Web Store (go to [https://chrome.google.com/webstore/](https://chrome.google.com/webstore/),
    search for `resurrectio`, and then click on the add button), and it just appends
    a new button next to the URL bar:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 Chrome 网上应用店安装它（访问 [https://chrome.google.com/webstore/](https://chrome.google.com/webstore/)，搜索
    `resurrectio`，然后点击添加按钮），它会在 URL 栏旁边添加一个新按钮：
- en: We click on the **Resurrectio** button to start a recording:![Live recording](img/9431OS_01_07.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击 **Resurrectio** 按钮开始录制：![实时录制](img/9431OS_01_07.jpg)
- en: We can then navigate or perform any regular action in our window.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在窗口中导航或执行任何常规操作。
- en: By right-clicking, we can add some assertions or screenshots:![Live recording](img/9431OS_01_08.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击，我们可以添加一些断言或截图：![实时录制](img/9431OS_01_08.jpg)
- en: By clicking again on the **Resurrectio** button, we can stop the recording and
    then export the previous sequence as a a CasperJS test:![Live recording](img/9431OS_01_09.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过再次点击 **Resurrectio** 按钮来停止录制，然后可以将之前的序列导出为 CasperJS 测试：![实时录制](img/9431OS_01_09.jpg)
- en: 'Nevertheless, be careful; in some cases, we might need to manually modify the
    generated test because of the following reasons:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意；在某些情况下，我们可能需要手动修改生成的测试，原因如下：
- en: It might contain a lot of useless assertions (due to extra clicks during the
    recording).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能包含很多无用的断言（由于录制过程中的额外点击）。
- en: It might be too heavy and verbose, making it more difficult to maintain. So,
    we would prefer to simplify it to focus on the most meaningful aspects.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能过于冗长和复杂，使得维护变得更加困难。因此，我们更愿意简化它，以关注最有意义的方面。
- en: All assertions cannot be registered from Resurrectio, and we might need different
    assertions.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有断言都可以从 Resurrectio 注册，我们可能需要不同的断言。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: One of the key advantages of CasperJS is its ability to chain test steps, knowing
    that these steps will be executed in the order they have been registered in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS 的一个关键优点是它能够链式执行测试步骤，因为这些步骤将按照它们注册的顺序执行。
- en: 'As explained previously, the way to chain steps in JavaScript is by using callback
    functions as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 JavaScript 中通过使用回调函数来链式调用步骤，如下所示：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we were using PhantomJS directly, that would be how our tests would look,
    and it would not be very convenient to read or maintain.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接使用 PhantomJS，那么我们的测试看起来会是这样，并且阅读或维护起来可能不太方便。
- en: But with CasperJS, using the `then()` or `waitFor()` methods, we can declare
    successive steps without this infinite callback nesting cascade.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用 CasperJS，通过 `then()` 或 `waitFor()` 方法，我们可以声明连续的步骤，而无需这种无限回调嵌套级联。
- en: CasperJS does that callback chaining for us behind the scenes, creating much
    more readable test scripts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS 在幕后为我们处理回调链，创建出更多可读性的测试脚本。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's see a few more details about the different features we have just used
    here.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚使用的一些不同特性的更多细节。
- en: XPath selectors
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XPath 选择器
- en: By default, CasperJS uses CSS3 selectors, but we can use XPath selectors if
    we prefer or if we have to.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CasperJS 使用 CSS3 选择器，但如果我们更喜欢或者必须使用的话，也可以使用 XPath 选择器。
- en: XPath selectors are less readable than CSS3 selectors but they are more powerful
    (for instance, while matching text contents or putting conditions on the DOM element's
    ascendants or descendants).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: XPath 选择器比 CSS3 选择器可读性差，但功能更强大（例如，在匹配文本内容或对 DOM 元素的祖先或后代设置条件时）。
- en: 'To use XPath selectors, we just need to load the CasperJS `selectXPath` utility:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 XPath 选择器，我们只需要加载 CasperJS 的 `selectXPath` 工具：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Assertion methods
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言方法
- en: The CasperJS tester API offers a large collection of assertion methods.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS 测试器 API 提供了大量断言方法。
- en: 'We can assert conditions and function results in the following ways:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式断言条件和函数结果：
- en: The `assert(Boolean condition[, String message])` method asserts that the condition
    is strictly `true`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert(Boolean condition[, String message])` 方法断言条件严格为 `true`'
- en: The `assertNot(mixed subject[, String message])` method asserts that the condition
    is not `true`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNot(mixed subject[, String message])` 方法断言条件不是 `true`'
- en: The `assertTruthy(Mixed subject[, String message])` method asserts that the
    subject is `truthy`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTruthy(Mixed subject[, String message])` 方法断言主题是 `truthy`'
- en: The `assertFalsy(Mixed subject[, String message])` method asserts that the subject
    is `falsy`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalsy(Mixed subject[, String message])` 方法断言主题是 `falsy`'
- en: Note
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Let's explain what `true`, `false`, `truthy,` and `falsy` is.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们解释一下 `true`、`false`、`truthy` 和 `falsy` 是什么意思。
- en: In JavaScript, `true` and `false` are the two Boolean values stricto sensu.
    Values such as `null`, `undefined`, the empty string `''`, the number `0`, the
    number `NaN` are `falsy`, which means that if they are evaluated in a condition,
    they will return `false`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`true` 和 `false` 是两个严格的布尔值。例如，`null`、`undefined`、空字符串 `''`、数字
    `0`、数字 `NaN` 都是 `falsy`，这意味着如果它们在条件中评估，将返回 `false`。
- en: And any other values are `truthy`, which means that if they are evaluated in
    a condition, they will return `true`.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而其他任何值都是 `truthy`，这意味着如果它们在条件中评估，将返回 `true`。
- en: The `assertEquals(mixed testValue, mixed expected[, String message])` method
    asserts that the two parameters are equal
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals(mixed testValue, mixed expected[, String message])` 方法断言两个参数相等'
- en: The `assertNotEquals(mixed testValue, mixed expected[, String message])` method
    asserts that the two parameters are not equal
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotEquals(mixed testValue, mixed expected[, String message])` 方法断言两个参数不相等'
- en: The `assertEval(Function fn[, String message, Mixed arguments])` method asserts
    that the function evaluated in the page DOM returns `true`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEval(Function fn[, String message, Mixed arguments])` 方法断言在页面 DOM 中评估的函数返回
    `true`'
- en: 'Example:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE33]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `assertEvalEquals(Function fn, mixed expected[, String message, Mixed arguments])`
    method asserts that the function evaluated in the DOM page returns the expected
    value
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEvalEquals(Function fn, mixed expected[, String message, Mixed arguments])`
    方法断言在 DOM 页面中评估的函数返回预期的值'
- en: The `assertMatch(mixed subject, RegExp pattern[, String message])` method asserts
    that the value matches the regular expression
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertMatch(mixed subject, RegExp pattern[, String message])` 方法断言值与正则表达式匹配'
- en: The `assertRaises(Function fn, Array args[, String message])` method asserts
    that the function called with the provided arguments raises an error
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRaises(Function fn, Array args[, String message])` 方法断言使用提供的参数调用的函数引发错误'
- en: The `assertType(mixed value, String type[, String message])` method asserts
    that the value type is the expected one
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertType(mixed value, String type[, String message])` 方法断言值的类型是预期的类型'
- en: 'We can assert the DOM elements in the following ways:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式断言 DOM 元素：
- en: The `assertExists(String selector[, String message])` method asserts that the
    selector matches at least one element in the page
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertExists(String selector[, String message])` 方法断言选择器至少匹配页面中的一个元素'
- en: The `assertDoesntExist(String selector[, String message])` method asserts that
    the selector does not match any element in the page
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertDoesntExist(String selector[, String message])` 方法断言选择器不匹配页面中的任何元素'
- en: The `assertField(String inputName, String expected[, String message])` method
    asserts that the form field has the expected value
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertField(String inputName, String expected[, String message])` 方法断言表单字段具有预期的值'
- en: The `assertVisible(String selector[, String message])` method asserts that the
    element is visible
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertVisible(String selector[, String message])` 方法断言元素是可见的'
- en: The `assertNotVisible(String selector[, String message])` method asserts that
    the matched element is not visible
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotVisible(String selector[, String message])` 方法断言匹配的元素不可见'
- en: The `assertSelectorHasText(String selector, String text[, String message])`
    method asserts that the matched element contains the expected text
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertSelectorHasText(String selector, String text[, String message])` 方法断言匹配的元素包含预期的文本'
- en: The `assertSelectorDoesntHaveText(String selector, String text[, String message])`
    method asserts that the matched element does not contain the given text
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertSelectorDoesntHaveText(String selector, String text[, String message])`
    方法断言匹配的元素不包含给定的文本'
- en: 'We can assert the page information in the following ways:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式断言页面信息：
- en: The `assertHttpStatus(Number status[, String message])` method asserts that
    the current HTTP status is the expected one
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertHttpStatus(Number status[, String message])` 方法断言当前HTTP状态是预期的'
- en: The `assertResourceExists(Function testFx[, String message])` method asserts
    that the resource exists on the page
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertResourceExists(Function testFx[, String message])` 方法断言资源在页面上存在'
- en: Note
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The parameter can be a string (the resource name), a regular expression (supposed
    to match at least one existing resource), or a function (supposed to return `true`
    for at least one of the existing resources).
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数可以是一个字符串（资源名称）、一个正则表达式（预期至少匹配一个现有资源）或一个函数（预期至少返回现有资源中的一个为`true`）。
- en: The `assertTextExists(String expected[, String message])` method asserts that
    the page contains the expected text
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTextExists(String expected[, String message])` 方法断言页面包含预期的文本'
- en: The `assertTextDoesntExist(String unexpected[, String message])` method asserts
    that the page does not contain the given text
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTextDoesntExist(String unexpected[, String message])` 方法断言页面不包含给定的文本'
- en: The `assertTitle(String expected[, String message])` method asserts that the
    page title is the expected one
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTitle(String expected[, String message])` 方法断言页面标题是预期的'
- en: The `assertTitleMatch(RegExp pattern[, String message])` method asserts that
    the page title matches the given regular expression
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTitleMatch(RegExp pattern[, String message])` 方法断言页面标题与给定的正则表达式匹配'
- en: The `assertUrlMatch(Regexp pattern[, String message])` method asserts that the
    page URL matches the given regular expression
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertUrlMatch(Regexp pattern[, String message])` 方法断言页面URL与给定的正则表达式匹配'
- en: The WaitFor methods
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`WaitFor` 方法'
- en: 'The following is the list of the CasperJS `waitFor` methods:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了CasperJS的`waitFor`方法：
- en: The `waitForText(String|RegExp pattern[, Function then, Function onTimeout,
    Number timeout])` method waits until the text is present
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitForText(String|RegExp pattern[, Function then, Function onTimeout, Number
    timeout])` 方法等待直到文本出现'
- en: The `waitForSelector(String selector[, Function then, Function onTimeout, Number
    timeout])` method waits until the selector is satisfied
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitForSelector(String selector[, Function then, Function onTimeout, Number
    timeout])` 方法等待直到选择器满足条件'
- en: The `waitWhileSelector(String selector[, Function then, Function onTimeout,
    Number timeout])` method waits until the selector is not satisfied anymore
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitWhileSelector(String selector[, Function then, Function onTimeout, Number
    timeout])` 方法等待直到选择器不再满足条件'
- en: The `waitUntilVisible(String selector[, Function then, Function onTimeout, Number
    timeout])` method waits until the selected element is visible
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitUntilVisible(String selector[, Function then, Function onTimeout, Number
    timeout])` 方法等待直到选定的元素可见'
- en: The `waitWhileVisible(String selector[, Function then, Function onTimeout, Number
    timeout])` method waits until the selected element is not visible anymore
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitWhileVisible(String selector[, Function then, Function onTimeout, Number
    timeout])` 方法等待直到选定的元素不再可见'
- en: The `waitFor(Function testFx[, Function then, Function onTimeout, Number timeout])`
    method waits until the function returns true
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitFor(Function testFx[, Function then, Function onTimeout, Number timeout])`
    方法等待直到函数返回`true`'
- en: The `waitForResource(Function testFx[, Function then, Function onTimeout, Number
    timeout])` method waits until the function matches an existing resource
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitForResource(Function testFx[, Function then, Function onTimeout, Number
    timeout])`方法等待函数匹配现有资源'
- en: The `waitForPopup(String|RegExp urlPattern[, Function then, Function onTimeout,
    Number timeout])` method waits until the pattern matches a pop-up URL
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitForPopup(String|RegExp urlPattern[, Function then, Function onTimeout,
    Number timeout])`方法等待模式匹配弹出URL'
- en: The wait() method
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`wait()`方法'
- en: 'In the list of `waitFor` methods, we have not mentioned the following one:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`waitFor`方法列表中，我们还没有提到以下一个：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It just waits for a certain amount of time (in milliseconds).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是等待一定的时间（以毫秒为单位）。
- en: But as discussed previously, in JavaScript, *time is nothing and timing is everything*.
    Similarly, in JavaScript, waiting for a given amount of time brings no guarantee
    to the accuracy of our test.Generally, we use `wait()` when we are desperate.
    For instance, if we have no way to modify the tested page, we cannot append an
    interesting signal to observe such as the `'noresult'` and `'success'` classes
    in our example.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但如前所述，在JavaScript中，*时间无关紧要，而时机至关重要*。同样，在JavaScript中，等待给定的时间并不能保证我们测试的准确性。通常，当我们绝望时，我们会使用`wait()`。例如，如果我们无法修改测试页面，我们无法添加一个有趣的信号来观察，例如我们示例中的`'noresult'`和`'success'`类。
- en: Nevertheless, let's just note a relevant usage of the `wait()` method. When
    our page contains some progressive JPEG images and we want to capture a new image
    (see the *Beyond testing (Advanced)* recipe), we need to wait for some time before
    capturing, in order to let our images render entirely.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们记录一下`wait()`方法的一个相关用法。当我们的页面包含一些渐进式JPEG图像，并且我们想要捕获一张新图像（参见*超越测试（高级）*菜谱）时，我们需要在捕获之前等待一段时间，以便让我们的图像完全渲染。
- en: Installing Resurrectio from the GitHub sources
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从GitHub源安装Resurrectio
- en: Resurrectio is not entirely stable yet, so it might be interesting to use the
    current development version.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Resurrectio目前还不完全稳定，因此使用当前的开发版本可能很有趣。
- en: 'To do so, you have to clone the `resurrectio` GitHub repository:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，你必须克隆`resurrectio`GitHub仓库：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It will produce a `./resurrectio` folder.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它将生成一个`./resurrectio`文件夹。
- en: 'Then, in Chrome, perform the following steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在Chrome中执行以下步骤：
- en: Go to **Tools** | **Extensions**.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**工具** | **扩展**。
- en: Check the **Developer mode** checkbox.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**开发者模式**复选框。
- en: Click on the **Load unpacked extension** button.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**加载未打包扩展**按钮。
- en: Select the `./resurrectio` folder.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`./resurrectio`文件夹。
- en: Writing advanced tests (Intermediate)
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高级测试（中级）
- en: This recipe will detail how to simulate rich web interactions using CasperJS,
    in order to achieve more complex testing.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将详细介绍如何使用CasperJS模拟丰富的Web交互，以实现更复杂的测试。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following sections cover the various steps in writing advanced tests.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将涵盖编写高级测试的各个步骤。
- en: Downloading files
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载文件
- en: 'First, let''s learn how to download files. The most common way to download
    a file from a web page is by providing a link to this file as follows (`example4.html`):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何下载文件。从网页下载文件最常见的方法是提供指向该文件的链接，如下所示（`example4.html`）：
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s create the following CasperJS script (`example4.js`):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建以下CasperJS脚本（`example4.js`）：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It should open our page, click on the first link, log the current page URL,
    reopen the page, click on the second link, and log the current page URL.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该打开我们的页面，点击第一个链接，记录当前页面URL，重新打开页面，点击第二个链接，并记录当前页面URL。
- en: To complete our test, let's create a folder named `files`, add two dummy files
    in this folder (`text.txt` and `text.pdf`), and start our SimpleHTTPServer web
    server.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的测试，让我们创建一个名为`files`的文件夹，在这个文件夹中添加两个虚拟文件（`text.txt`和`text.pdf`），并启动我们的SimpleHTTPServer网络服务器。
- en: 'Let''s run the script:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行脚本：
- en: '![Downloading files](img/9431OS_01_10.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![下载文件](img/9431OS_01_10.jpg)'
- en: When we clicked on the first link, we actually opened the `.txt` file as a page,
    but when we clicked on the second one, we opened the file that was kept in the
    original location. If we check the current folder content, we will see that nothing
    has been downloaded.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击第一个链接时，我们实际上是以页面形式打开了`.txt`文件，但当我们点击第二个链接时，我们打开了原始位置保留的文件。如果我们检查当前文件夹内容，我们会看到没有任何文件被下载。
- en: So the `click()` method will not help us in downloading any file; it will navigate
    to the corresponding link if PhantomJS is able to open it, or it will open the
    file that was kept in the original location, producing no error and no output.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`click()` 方法不会帮助我们下载任何文件；如果 PhantomJS 能够打开它，它将导航到相应的链接，或者它将打开原始位置中保留的文件，不会产生错误和输出。
- en: 'The right way to download a file is by using the `download()` method. Let''s
    fix our test using the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件的正确方法是使用 `download()` 方法。让我们使用以下代码修复我们的测试：
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The outcome looks as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Downloading files](img/9431OS_01_11.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![下载文件](img/9431OS_01_11.jpg)'
- en: Now that our files have been downloaded, let's discover how to upload files.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经下载了文件，让我们来看看如何上传文件。
- en: Uploading files
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传文件
- en: To perform a file upload during a test, we will use the `fill()` method. The
    `fill()` method allows us to fill in a form and optionally, to submit it. Plus,
    it is able to manage file inputs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试期间执行文件上传，我们将使用 `fill()` 方法。`fill()` 方法允许我们填写表单，并且可选地提交它。此外，它还能够管理文件输入。
- en: 'The following is an example (`example5.js`):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例（`example5.js`）：
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can perform the following steps with this test:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下步骤进行此测试：
- en: Go to [http://imagebin.org](http://imagebin.org).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [http://imagebin.org](http://imagebin.org)。
- en: Click on the **Add your image now!** link.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **立即添加您的图片** 链接。
- en: Then, fill in the image submission form.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，填写图片提交表单。
- en: Assert that we obtain a page containing our image.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言我们获得了一个包含我们图片的页面。
- en: Display this page URL.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示此页面 URL。
- en: As we can see, the `'image'` field is managed the same way as the other fields;
    its value is just the path to our local image.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`'image'` 字段与其他字段的管理方式相同；其值只是我们本地图片的路径。
- en: After passing the first parameter containing the fields values, we pass `true`
    as a second parameter to `fill()`, so that the form is submitted.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递包含字段值的第一个参数之后，我们将 `true` 作为第二个参数传递给 `fill()`，以便提交表单。
- en: 'Before running the test, we make sure that we put an image named `test.png`
    in our current folder and when we run the test, the following is what we get:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，我们确保将一个名为 `test.png` 的图片放在我们的当前文件夹中，当我们运行测试时，以下是我们得到的结果：
- en: '![Uploading files](img/9431OS_01_12.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![上传文件](img/9431OS_01_12.jpg)'
- en: Authentication
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证
- en: 'Let''s see how we can manage authentication. When we try to open a page that
    requires authentication, we get a 401 HTTP error (`example6.js`):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何管理认证。当我们尝试打开需要认证的页面时，我们得到一个 401 HTTP 错误（`example6.js`）：
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The outcome is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Authentication](img/9431OS_01_13.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![认证](img/9431OS_01_13.jpg)'
- en: 'Now, let''s use the `setHttpAuth()` method to log in properly:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `setHttpAuth()` 方法正确登录：
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is what we get:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的结果：
- en: '![Authentication](img/9431OS_01_14.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![认证](img/9431OS_01_14.jpg)'
- en: 'The `setHttpAuth()` method can only be used for HTTP authentication. When our
    targeted page uses a web form authentication, we just need to fill the authentication
    form. The following is an example (`example7.js`):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`setHttpAuth()` 方法只能用于 HTTP 认证。当我们的目标页面使用表单认证时，我们只需填写认证表单。以下是一个示例（`example7.js`）：'
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output looks as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Authentication](img/9431OS_01_15.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![认证](img/9431OS_01_15.jpg)'
- en: Keyboard and mouse events
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键盘和鼠标事件
- en: 'Simulating keyboard and mouse events is another very common use case. Let''s
    consider the following page (`example8.html`):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟键盘和鼠标事件是另一个非常常见的用例。让我们考虑以下页面（`example8.html`）：
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we launch our simple HTTP server, we can try opening the page at `http://localhost:8000/example8.html`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动我们的简单 HTTP 服务器，我们可以尝试打开 `http://localhost:8000/example8.html` 页面。
- en: When we enter a value in the input text, a message is displayed under the input
    text, indicating the number of characters we have entered.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在输入框中输入值时，会在输入框下方显示一条消息，指示我们已输入的字符数。
- en: 'To test this behavior, we can use the `sendKeys()` method (`example8.js`):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此行为，我们可以使用 `sendKeys()` 方法（`example8.js`）：
- en: '[PRE44]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we run the code, we will see the following result. If you enter `Eric`
    in the text input, the message will display **You have entered 4 characters**:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们将看到以下结果。如果您在文本输入框中输入 `Eric`，则消息将显示 **您已输入 4 个字符**：
- en: '![Keyboard and mouse events](img/9431OS_01_16.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![键盘和鼠标事件](img/9431OS_01_16.jpg)'
- en: The `sendKeys()` method inserted the text into the text input and also triggered
    the `onkeyup` event.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendKeys()` 方法将文本插入到文本输入框中，并触发了 `onkeyup` 事件。'
- en: The `sendKeys()` method can produce a key event on any element of the page (not
    necessarily inputs).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendKeys()`方法可以在页面的任何元素上产生一个按键事件（不一定是输入）。'
- en: 'Let''s change the page `example8.html` so that the header becomes editable:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将页面`example8.html`修改为使标题可编辑：
- en: '[PRE45]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now if we click on the header, we can change its text content.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们点击标题，我们可以更改其文本内容。
- en: 'Let''s modify our test script:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的测试脚本：
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, perform the following steps with this test:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤进行此测试：
- en: Click on the header and enter a new text at its beginning
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击标题并在其开头输入新文本
- en: Assert the new header content
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言新的标题内容
- en: 'The output will be as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Keyboard and mouse events](img/9431OS_01_17.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![键盘和鼠标事件](img/9431OS_01_17.jpg)'
- en: Note
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we have an extra assertion in our test script now, we have changed the `begin()`
    method's second parameter from `1` to `2`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在在测试脚本中有一个额外的断言，我们将`begin()`方法的第二个参数从`1`更改为`2`。
- en: Regarding mouse events, we have already used the `casper.click()` method. It
    takes a selector as a parameter and triggers a click event on the designated element.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 关于鼠标事件，我们已经在测试脚本中使用了`casper.click()`方法。它接受一个选择器作为参数，并在指定的元素上触发点击事件。
- en: We use it to click on links or buttons, for instance.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用它来点击链接或按钮，例如。
- en: We can also trigger other mouse events using the `mouseEvent()` method; its
    first parameter is the event type and the second is the targeted element selector.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`mouseEvent()`方法触发其他鼠标事件；它的第一个参数是事件类型，第二个参数是目标元素选择器。
- en: 'It can trigger the following events:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以触发以下事件：
- en: '`mouseup`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseup`'
- en: '`mousedown`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mousedown`'
- en: '`click`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click`'
- en: '`mousemove`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mousemove`'
- en: '`mouseover`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseover`'
- en: '`mouseout`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseout`'
- en: 'Let''s create the following web page (`example9.html`):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建以下网页（`example9.html`）：
- en: '[PRE47]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It presents a list of headers and when the mouse goes over any of them, a counter
    is incremented.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了一个标题列表，当鼠标悬停在任何一个标题上时，计数器会增加。
- en: 'We can test this page using `mouseEvent()`, as shown in the following test
    (`example9.js`):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`mouseEvent()`测试此页面，如下面的测试（`example9.js`）所示：
- en: '[PRE48]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The outcome is as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Keyboard and mouse events](img/9431OS_01_18.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![键盘和鼠标事件](img/9431OS_01_18.jpg)'
- en: But CasperJS also provides a specific `'mouse'` module to control the mouse
    directly. It allows to move the mouse and to control the click (down, up, click,
    double-click).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 但是CasperJS还提供了一个特定的`'mouse'`模块来直接控制鼠标。它允许移动鼠标和控制点击（按下、释放、点击、双击）。
- en: 'It might be useful if we want to test complex mouse interaction such as drag-and-drop.
    The following is a web page that provides a draggable box (`example10.html`) using
    the jQueryUI `draggable()` method:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要测试像拖放这样的复杂鼠标交互，这可能很有用。以下是一个提供可拖动框（`example10.html`）的网页，它使用jQueryUI的`draggable()`方法：
- en: '[PRE49]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can test this page using the CasperJS mouse module (`example10.js`):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用CasperJS鼠标模块（`example10.js`）测试此页面：
- en: '[PRE50]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output will be as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Keyboard and mouse events](img/9431OS_01_19.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![键盘和鼠标事件](img/9431OS_01_19.jpg)'
- en: 'We can see that there are a lot of interesting things in this test:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在这个测试中有许多有趣的事情：
- en: We set the viewport size (using the `viewportSize` option). In our case, it
    is useful because we need to make sure that we have enough room to move the box
    where we want.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设置了视口大小（使用`viewportSize`选项）。在我们的例子中，这很有用，因为我们需要确保我们有足够的空间移动到我们想要的位置。
- en: We use jQuery to get the current position of the box! As jQuery is loaded in
    our tested page, we can use it through `assertEval()`, as *it runs the code in
    the tested page*.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用jQuery获取盒子的当前位置！由于jQuery已加载到我们的测试页面中，我们可以通过`assertEval()`使用它，因为它在测试页面上运行代码。
- en: We use `down()`, then `move()`, and then `up()` to produce a drag-and-drop move
    from point (5,5) to point (400,200).
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`down()`，然后`move()`，然后`up()`从点(5,5)到点(400,200)产生拖放移动。
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Even if they might seem quite similar, there are differences between `casper.click()`
    and `casper.mouse.click()`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们可能看起来非常相似，`casper.click()`和`casper.mouse.click()`之间还是有区别的。
- en: First of all, `casper.click()` only accepts a selector as a parameter, while
    `casper.mouse.click()` accepts either a selector or a (x, y) position.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`casper.click()`只接受一个选择器作为参数，而`casper.mouse.click()`接受一个选择器或一个(x, y)位置。
- en: But more importantly, they do not work the same way; `casper.click()` creates
    an event and *dispatches* it to the targeted event, but `casper.mouse.click()`
    does not deal with any element and just *produces a mouse action* at the given
    position.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是，它们的工作方式并不相同；`casper.click()` 创建一个事件并将其 *分发* 到目标事件，而 `casper.mouse.click()`
    不处理任何元素，只是在给定位置 *产生鼠标动作*。
- en: If `casper.click()` is not able to dispatch the event (because of a `preventDefault()`
    method hanging somewhere), it will default to the `casper.mouse.click()` method.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `casper.click()` 无法分发事件（因为某个地方的 `preventDefault()` 方法挂起），它将默认使用 `casper.mouse.click()`
    方法。
- en: Note
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`casper.mouseEvent()` works exactly as `casper.click()`.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`casper.mouseEvent()` 与 `casper.click()` 的工作方式完全相同。'
- en: There's more...
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's explore a few more details about the different features we have just used
    in the previous section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下在上一个部分中使用的不同功能的更多细节。
- en: Passing parameters to the download() method
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将参数传递给 download() 方法
- en: 'The `download()` method might also accept two extra parameters as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`download()` 方法也可能接受两个额外的参数，如下所示：'
- en: '[PRE51]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So, we can produce an HTTP request using the method we want and pass the needed
    arguments in the data object.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用我们想要的方法产生 HTTP 请求，并在数据对象中传递所需的参数。
- en: setHttpAuth might have surprising timing
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setHttpAuth 可能会有令人惊讶的时间延迟
- en: 'Consider that we come back to our test (`example6.js`) about `setHttpAuth()`
    and try to chain the two versions as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们回到关于 `setHttpAuth()` 的测试（`example6.js`），并尝试将两个版本串联起来：
- en: '[PRE52]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We would expect the tests to be successful due to the following conditions:
    we get a 401 error if we are anonymous and are able to view the page if we log
    in.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计测试会成功，因为以下条件：如果我们匿名，我们会收到 401 错误；如果我们登录，我们能够查看页面。
- en: 'But, the following is what we obtain:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们得到的结果如下：
- en: '![setHttpAuth might have surprising timing](img/9431OS_01_20.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![setHttpAuth 可能会有令人惊讶的时间延迟](img/9431OS_01_20.jpg)'
- en: The first test fails; we do not get a 401 error, but we get a 200 status instead!
    This means we are actually logged in.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试失败了；我们没有收到 401 错误，而是收到了 200 状态码！这意味着我们实际上已经登录了。
- en: Why is that? It's because CasperJS chains the steps that are enclosed into `then()`
    blocks. If `setHttpAuth()` is not enclosed in a `then()` block, it will be effective
    right from the beginning (the `start()` call) to the end.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样呢？这是因为 CasperJS 会将包含在 `then()` 块中的步骤串联起来。如果 `setHttpAuth()` 没有包含在 `then()`
    块中，它将从开始（`start()` 调用）到结束都有效。
- en: 'Let''s enclose it in a `then()` block as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下 `then()` 块中包含它：
- en: '[PRE53]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And now, the tests pass as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试通过了如下所示：
- en: '![setHttpAuth might have surprising timing](img/9431OS_01_example6-4.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![setHttpAuth 可能会有令人惊讶的时间延迟](img/9431OS_01_example6-4.jpg)'
- en: Best practices (Intermediate)
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践（中级）
- en: This section will discuss the essential best practices for web functional testing
    with CasperJS.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论使用 CasperJS 进行 Web 功能测试的基本最佳实践。
- en: Testing the real thing
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试真实的事物
- en: Our software quality depends on our tests' accuracy. Testing is always good,
    but if we don't test the software's behavior accurately, we might miss out on
    some potential problems. To create accurate tests, we must forget about the system
    and how it works, and we must focus on user interactions.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的软件质量取决于我们测试的准确性。测试总是好的，但如果我们没有准确测试软件的行为，我们可能会错过一些潜在的问题。为了创建准确的测试，我们必须忘记系统及其工作方式，我们必须专注于用户交互。
- en: It might sound obvious but it is not, because most of the time we design and
    code the system and do not use it (as a standard user) a lot.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能很明显，但实际上并非如此，因为大多数时候我们设计和编写系统，但并不经常像标准用户那样使用它。
- en: 'Let''s consider a typical example of a basic web form. Here is an important
    thing to know about web forms: *users never submit web forms*. They actually do
    the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个基本的网页表单的典型例子。关于网页表单，这里有一个重要的事情要知道：*用户永远不会提交网页表单*。他们实际上做的是以下事情：
- en: Enter values into inputs
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入框中输入值
- en: Click on the **Submit** button
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击 **提交** 按钮
- en: These actions do produce a form submission, but the users don't actually submit
    the form by themselves; their web browsers do it for them. Or, let's say the system
    does it for them.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作确实会产生表单提交，但用户实际上并没有自己提交表单；是他们的网络浏览器或系统为他们做了这件事。
- en: Obviously, if we want to test this system, we cannot rely on its supposed behavior.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们想测试这个系统，我们不能依赖于它的假设行为。
- en: That is why our tests must produce the real user interactions and then assert
    that the resulting behavior is correct.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们的测试必须产生真实的用户交互，然后断言产生的行为是正确的。
- en: 'Let''s have a look at the following example (`example11.html`):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例（`example11.html`）：
- en: '[PRE54]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This page shows the following three forms:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面显示了以下三个表单：
- en: The first one contains first name, last name, and age, and a **Save** button
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个包含名字、姓氏和年龄，以及一个**保存**按钮
- en: The second one has the same fields but no **Save** button
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个有相同的字段，但没有**保存**按钮
- en: The third one has all the fields and a **Save** button, but the `age` field
    is hidden
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个包含所有字段和一个**保存**按钮，但**年龄**字段是隐藏的
- en: If we launch our simple HTTP server, the first one will work fine, but the other
    two will not be usable.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动我们的简单HTTP服务器，第一个将正常工作，但其他两个将不可用。
- en: 'Now, let''s test it as follows (`example11-1.js`):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式测试它（`example11-1.js`）：
- en: '[PRE55]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This test uses `casper.fill()` to submit the form with a value for each field
    and then asserts so we obtain the three values in the resulting URL.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用`casper.fill()`提交表单，并为每个字段提供一个值，然后断言以获取结果URL中的三个值。
- en: Tip
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this test, we use `casper.cli.options` to read options passed to the `casperjs`
    command; this way, we can use the same script to test the three different forms.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用`casper.cli.options`读取传递给`casperjs`命令的选项；这样，我们可以使用相同的脚本测试三个不同的表单。
- en: 'Let''s run it. The following screenshot shows the output:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它。以下截图显示了输出结果：
- en: '![Testing the real thing](img/9431OS_01_example11-1.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![测试真实事物](img/9431OS_01_example11-1.jpg)'
- en: The tests pass with the first form as expected, but they also pass with the
    other two!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 测试如预期地通过了第一个表单，但它们也通过了其他两个！
- en: Why is that? It's because the `fill()` method is blind to the mistakes we have
    introduced in the forms; it just performs a submission without checking if a real
    user could actually do the same.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？这是因为`fill()`方法对我们在表单中引入的错误视而不见；它只是执行提交，而不检查一个真实用户是否真的能做同样的事情。
- en: 'The following is a test that is closer to real user interaction (`example11-2.js`):'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个更接近真实用户交互的测试（`example11-2.js`）：
- en: '[PRE56]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here we use `sendKeys()` to enter the values in the inputs, and we use the `click()`method
    to click on the **Submit** button. This is basically what the user would do with
    his or her keyboard and mouse.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`sendKeys()`在输入框中输入值，并使用`click()`方法点击**提交**按钮。这基本上就是用户会用他们的键盘和鼠标做的事情。
- en: 'Now let''s run it. The following screenshot shows the output:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行它。以下截图显示了输出结果：
- en: '![Testing the real thing](img/9431OS_01_example11-2.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![测试真实事物](img/9431OS_01_example11-2.jpg)'
- en: This is much better; now our tests fail at the second and third forms.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多；现在我们的测试在第二个和第三个表单中失败了。
- en: This does not mean that we must never use the `fill()` method. That was just
    an example. The main point here is that we must always be careful to keep as close
    as possible to the user interactions. But of course, we also need to create concise
    and maintainable tests.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们永远不能使用`fill()`方法。那只是一个例子。这里的主要观点是我们必须始终小心，尽可能接近用户交互。但当然，我们还需要创建简洁且易于维护的测试。
- en: 'So a good approach is to write several kinds of tests, such as the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个好的方法是编写几种不同类型的测试，如下所示：
- en: Some precise tests focusing on the user interactions (where we will use `sendKeys()`
    and `click()` instead of `fill()`, for instance) to make sure each page is usable
    by itself
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些针对用户交互的精确测试（例如，我们将使用`sendKeys()`和`click()`而不是`fill()`），以确保每个页面都能独立使用
- en: Some concise tests focusing on screen chaining and usage scenarios (where we
    can use `fill()`, for instance) to make sure the complete application is working
    fine
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些针对屏幕链和用例场景的简洁测试（例如，我们可以使用`fill()`），以确保整个应用程序运行良好
- en: Surviving design changes
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应对设计变更
- en: Some people prefer to write tests at the end of their development, when they
    know everything is pretty much stable.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人喜欢在开发结束时编写测试，那时他们知道一切几乎都很稳定。
- en: But the best time to write tests is from the beginning to the end of the development.
    This has already been demonstrated in a lot of books, but one of the most obvious
    reasons is that we usually produce the biggest part of our bugs during the development
    phase, and tests are a great help to fight bugs.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 但编写测试的最佳时间是从开发开始到结束。这已经在很多书中得到了证明，但最明显的原因之一是我们通常在开发阶段产生我们最大的部分错误，而测试是帮助对抗错误的一大助力。
- en: 'Unfortunately, people who write tests at the end are right: the website is
    (usually) more stable after development than during development.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，那些在开发结束时编写测试的人是正确的：网站在开发后（通常）比开发期间更稳定。
- en: One of the aspects that might change a lot is the design. Design changes should
    not impact application features. But sometimes they do, and there may be a lot
    of reasons for it, such as a CSS attribute can make a button invisible, modification
    in an element's ID can break a JavaScript call, and so on. But we do not mind
    this much, because if the design breaks any feature, our tests will warn us immediately.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会改变很多的一个方面是设计。设计变更不应该影响应用程序功能。但有时它们确实会，可能有很多原因，比如一个 CSS 属性可以使按钮不可见，一个元素的 ID
    的修改可能会破坏一个 JavaScript 调用，等等。但我们并不太在意这一点，因为如果设计破坏了任何功能，我们的测试会立即警告我们。
- en: The problem is that sometimes our tests fail even if the design changes haven't
    broken any features. This is very bad because it implies that we cannot trust
    our tests to know whether something is broken or not.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，有时即使设计变更没有破坏任何功能，我们的测试也会失败。这非常糟糕，因为它意味着我们无法信任我们的测试来知道某物是否损坏。
- en: Why our tests would fail if all the features have been preserved? This is just
    because our tests are less design-proof than our web page features, and the writing
    of design-proof tests depends mainly on selectors.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有特性都得到了保留，为什么我们的测试会失败？这仅仅是因为我们的测试比我们的网页特性更不具设计鲁棒性，而设计鲁棒测试的编写主要依赖于选择器。
- en: Indeed, our test inner logic (for example, if we click *here*, we should get
    *that*) should not be impacted by design changes.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们的测试内部逻辑（例如，如果我们点击 *这里*，我们应该得到 *那个*）不应该受到设计变更的影响。
- en: But what could easily break if we are not careful enough is the way we define
    *here* and *that*. They will be defined using selectors. We must choose selectors
    that focus on the logic and not on the layout.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们不够小心，很容易破坏的是我们定义 *这里* 和 *那个* 的方式。它们将使用选择器来定义。我们必须选择关注逻辑而不是布局的选择器。
- en: 'The following are some examples:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '| Instead of | Prefer | Because |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| 替换为 | 更喜欢 | 因为 |'
- en: '| --- | --- | --- |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `"div#form-container span input"` | `"form[name=''registration''] input[name=''firstname'']"`
    | We only depend on form elements and their names |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `"div#form-container span input"` | `"form[name=''registration''] input[name=''firstname'']"`
    | 我们只依赖于表单元素及其名称 |'
- en: '| `"div ul li:first-child a"` | `"#results .result:first-child a"` | We use
    IDs and classes instead of tag names |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `"div ul li:first-child a"` | `"#results .result:first-child a"` | 我们使用 ID
    和类而不是标签名 |'
- en: '| `"a#reset-btn"` | `x("//a[normalize-space(text())=''Reset'']")` | We use
    the link text instead of its ID (and to do this, we switch to the XPath selector)
    |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `"a#reset-btn"` | `x("//a[normalize-space(text())=''Reset'']")` | 我们使用链接文本而不是其
    ID（为此，我们切换到 XPath 选择器） |'
- en: 'By doing this, we can change our design, switch from Bootstrap to Foundation,
    reorganize the layout, and so on, and be sure that if the tests fail, they do
    for a good reason: because we have actually broken the logic.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以更改我们的设计，从 Bootstrap 切换到 Foundation，重新组织布局，等等，并且可以确信如果测试失败，它们是因为一个很好的原因：因为我们实际上破坏了逻辑。
- en: Creating test suites
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试套件
- en: Until now, we have created single test scripts for our different example pages,
    but when we test our real applications, we will need to test a lot of different
    features and scenarios.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为不同的示例页面创建了单个测试脚本，但当我们测试我们的真实应用程序时，我们需要测试许多不同的特性和场景。
- en: It will definitely work if we do it in a single long test script, but obviously,
    it will be more difficult to refactor it, maintain it, share it with a team, and
    so on.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在单个长测试脚本中这样做，它肯定能工作，但显然，重构它、维护它、与团队共享它等等会更困难。
- en: So, quite a simple, good practice is to split our different feature tests and
    testing scenarios into separate scripts. And fortunately, CasperJS provides the
    `casperjs test` command so we can run all our tests at once.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个相当简单、良好的实践是将我们的不同特性测试和测试场景拆分到单独的脚本中。幸运的是，CasperJS 提供了 `casperjs test` 命令，这样我们就可以一次性运行所有测试。
- en: 'Let''s reuse our `example8.html` page from the previous chapter. This page
    proposes two features: an editable header and a simple form with text input.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重用上一章中的 `example8.html` 页面。这个页面提出了两个特性：一个可编辑的标题和一个简单的带有文本输入的表单。
- en: Let's imagine that we want to create two different tests for these two features.
    So let's create a folder (named `suit`, for instance), and in this folder, create
    the files `test_editable_header.js` and `test_form.js`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们想要为这两个特性创建两个不同的测试。所以，让我们创建一个文件夹（例如命名为 `suit`），在这个文件夹中创建文件 `test_editable_header.js`
    和 `test_form.js`。
- en: 'Create `test_editable_header.js` as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `test_editable_header.js` 如下：
- en: '[PRE57]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create `test_form.js js` as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `test_form.js js` 如下：
- en: '[PRE58]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And now, let''s launch our tests:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动我们的测试：
- en: '![Creating test suites](img/9431OS_01_example12-1.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![创建测试套件](img/9431OS_01_example12-1.jpg)'
- en: As we can see in the preceding screenshot, we have passed our folder path to
    the `casperjs test` command, and it has run all the tests contained in this folder.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们已经将文件夹路径传递给`casperjs test`命令，并且它已经运行了该文件夹中包含的所有测试。
- en: 'The `casperjs test` command offers interesting options, as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`casperjs test`命令提供了以下有趣选项：'
- en: '`--fail-fast`: This is used to stop the test suite at the *first error*'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--fail-fast`：这个选项用于在测试套件中的第一个错误处停止测试。'
- en: '`--pre=pre-test.js`: This is used to run a test *before* executing the test
    suite'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--pre=pre-test.js`：这个选项用于在执行测试套件之前运行一个测试。'
- en: '`--post=post-test.js`: This is used to run a test *after* executing the test
    suite'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--post=post-test.js`：这个选项用于在执行测试套件之后运行一个测试。'
- en: '`--includes=file1.js,file2.js`: This is used to include some tests *before*
    running *each test* in the suite'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--includes=file1.js,file2.js`：这个选项用于在运行套件中的每个测试之前包含一些测试。'
- en: '`--direct`: This is used to output the log message in the console'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--direct`：这个选项用于在控制台输出日志消息。'
- en: '`--log-level=<level>`: This is used to choose the log level (`DEBUG`, `INFO`,
    `WARNING`, or `ERROR`)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--log-level=<level>`：这个选项用于选择日志级别（`DEBUG`、`INFO`、`WARNING`或`ERROR`）。'
- en: '`--xunit=<filename>`: This is used to export the test results to the xUnit
    format'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--xunit=<filename>`：这个选项用于将测试结果导出为xUnit格式。'
- en: The `--pre` and `--post` options are typically used to implement a pre-test
    setup and post-test tear down, respectively.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`--pre`和`--post`选项通常用于实现测试前的设置和测试后的清理。'
- en: For instance, if our system allows users to modify their preferences and we
    want to test it, the pre-test setup will create a fake user profile so we can
    test profile preference change. The post-test tear down will remove this fake
    user profile, so the next time we run the test suite, it will not break because
    the profile already exists.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的系统允许用户修改他们的首选项，并且我们想要测试它，预测试设置将创建一个假用户配置文件，这样我们就可以测试配置文件首选项的变化。测试后的清理将删除这个假用户配置文件，这样下次我们运行测试套件时，它不会因为配置文件已经存在而中断。
- en: Running CasperJS on Jenkins
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Jenkins上运行CasperJS
- en: Writing tests is a good starting point, but then we have to make sure we run
    them often enough. One of the **Continuous Integration** (**CI**) principles is
    to run the tests each time we commit a change in the source repository. To do
    this, we need a CI tool, and Jenkins is one of the most widely used ones.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试是一个好的起点，但随后我们必须确保我们经常运行它们。**持续集成**（**CI**）的一个原则是每次我们在源仓库中提交更改时都运行测试。为此，我们需要一个CI工具，Jenkins就是其中最广泛使用的一个。
- en: Note
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will not cover the detailed Jenkins installation and configuration here as
    it is not a desktop application but a service exposed by a server. We assume it
    is deployed on one of our servers.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细讲解Jenkins的安装和配置，因为它不是一个桌面应用程序，而是由服务器暴露的服务。我们假设它已经部署在我们的服务器之一上。
- en: To run our CasperJS tests on Jenkins, we need first to make sure that PhantomJS
    and CasperJS are installed on the machine where Jenkins is running (refer to the
    *Installing CasperJS* section).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Jenkins上运行我们的CasperJS测试，我们首先需要确保PhantomJS和CasperJS已经安装在了Jenkins运行所在的机器上（参考*安装CasperJS*部分）。
- en: 'Then, we open the Jenkins web interface and click on **New Job** as shown in
    the following screenshot:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打开Jenkins的Web界面，并点击如下截图所示的**新建任务**：
- en: '![Running CasperJS on Jenkins](img/9431OS_01_jenkins1.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![在Jenkins上运行CasperJS](img/9431OS_01_jenkins1.jpg)'
- en: 'In the **Build** section, we add a new **Execute shell** step:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在**构建**部分，我们添加一个新的**执行shell**步骤：
- en: '![Running CasperJS on Jenkins](img/9431OS_01_jenkins2.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![在Jenkins上运行CasperJS](img/9431OS_01_jenkins2.jpg)'
- en: Then we click on **Save** and enter our test command in the **Build** section.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们点击**保存**，并在**构建**部分输入我们的测试命令。
- en: 'Assuming our tests are in a folder named `tests` at the root of our repository,
    we would enter the following:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的测试位于我们仓库根目录下名为`tests`的文件夹中，我们会输入以下内容：
- en: '[PRE59]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following screenshot shows the textbox in which we will add the preceding
    command:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了我们将添加上述命令的文本框：
- en: '![Running CasperJS on Jenkins](img/9431OS_01_jenkins3.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![在Jenkins上运行CasperJS](img/9431OS_01_jenkins3.jpg)'
- en: 'We can now launch a build manually or let Jenkins launch builds automatically
    (depending on the triggers we have chosen). Jenkins will directly interpret the
    CasperJS output, and we will get a build history showing failures and successes
    as follows:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以手动启动构建，或者让Jenkins根据我们选择的触发器自动启动构建。Jenkins将直接解释CasperJS的输出，我们将会得到一个显示失败和成功的构建历史记录，如下所示：
- en: '![Running CasperJS on Jenkins](img/9431OS_01_jenkins4.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![在Jenkins上运行CasperJS](img/9431OS_01_jenkins4.jpg)'
- en: 'We can also see the details of a given build as in the following screenshot:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到如下截图所示的特定构建的详细信息：
- en: '![Running CasperJS on Jenkins](img/9431OS_01_jenkins5.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![在 Jenkins 上运行 CasperJS](img/9431OS_01_jenkins5.jpg)'
- en: Running CasperJS on Travis-CI
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Travis-CI 上运行 CasperJS
- en: 'Travis-CI is a Cloud service that can be hooked to our GitHub repositories.
    It is free for public repositories. Each time we push changes to GitHub, Travis-CI
    does the following:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Travis-CI 是一种云服务，可以连接到我们的 GitHub 仓库。对于公共仓库，它是免费的。每次我们向 GitHub 推送更改时，Travis-CI
    都会执行以下操作：
- en: Creates a blank virtual machine
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空白虚拟机
- en: Checks the current sources from GitHub
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查来自 GitHub 的当前源代码
- en: Deploys our application
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署我们的应用程序
- en: Runs the tests
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: Notifies the user (via e-mail, IRC, and so on)
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过电子邮件、IRC 等方式通知用户
- en: It also does the same when we receive a pull request on our GitHub repository
    so we know whether the submitted pull request breaks the tests or not before merging
    it. This information is displayed directly on GitHub.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 GitHub 仓库收到拉取请求时，它也会做同样的事情，这样我们就可以在合并之前知道提交的拉取请求是否破坏了测试。此信息将直接显示在 GitHub
    上。
- en: 'To run CasperJS tests on Travis-CI, we need to do the following:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Travis-CI 上运行 CasperJS 测试，我们需要做以下几步：
- en: Go to [travis-ci.org](http://travis-ci.org) and sign in with our GitHub account.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [travis-ci.org](http://travis-ci.org) 并使用我们的 GitHub 账户登录。
- en: Go to **Profile** and copy the token.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **配置文件** 并复制令牌。
- en: Go to the GitHub repository, click on **Settings / Service Hooks**, choose **Travis-CI**,
    enter our GitHub ID and the previously copied Travis token, check **Active**,
    and click on **Update**.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 GitHub 仓库，点击 **设置 / 服务钩子**，选择 **Travis-CI**，输入我们的 GitHub ID 和之前复制的 Travis
    令牌，勾选 **激活**，然后点击 **更新**。
- en: Add a `.travis.yml` file in the root of our repository.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的仓库根目录添加一个 `.travis.yml` 文件。
- en: This `.travis.yml` file is used to explain to Travis how to deploy the test
    environment and how to run the tests.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `.travis.yml` 文件用于向 Travis 解释如何部署测试环境以及如何运行测试。
- en: We just need to deploy CasperJS because PhantomJS is preinstalled on Travis.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要部署 CasperJS，因为 PhantomJS 已经在 Travis 上预安装了。
- en: Tip
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since PhantomJS is completely headless, there is no need run Xvfb.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PhantomJS 是完全无头浏览器，因此不需要运行 Xvfb。
- en: 'The following is a typical `.travis.yml` file:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的是一个典型的 `.travis.yml` 文件：
- en: '[PRE60]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the `install` section, we download the CasperJS code and check the last stable
    version. In the `before_script` section, we set up PhantomJS to allow access to
    external URLs, and in the `script` section, we launch the tests.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `install` 部分中，我们下载 CasperJS 代码并检查最后一个稳定版本。在 `before_script` 部分中，我们设置 PhantomJS
    以允许访问外部 URL，在 `script` 部分中，我们启动测试。
- en: Just like Jenkins, Travis-CI will interpret the CasperJS output result as a
    success or failure, and we will be notified accordingly. Our tests can target
    a local server, and if so, our `.travis.yml` file will need to deploy the needed
    HTTP server and its components.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Jenkins 一样，Travis-CI 将将 CasperJS 输出的结果解释为成功或失败，并且我们会相应地收到通知。我们的测试可以针对本地服务器，如果是这样，我们的
    `.travis.yml` 文件需要部署所需的 HTTP 服务器及其组件。
- en: But the tests can also target an external URL, and if so, we have to make sure
    the code is updated on the real server as soon as it is pushed to GitHub. This
    can be done conveniently using GitHub pages.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 但测试也可以针对外部 URL，如果是这样，我们必须确保代码在推送到 GitHub 后立即更新到真实服务器。这可以通过 GitHub Pages 方便地完成。
- en: Beyond testing (Advanced)
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除此之外（高级）
- en: This section will present other CasperJS usages apart from testing.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍除测试之外的其他 CasperJS 用法。
- en: Web scripting
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网页脚本
- en: Web scripting means to run a script that will use web pages as a backend service.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 网页脚本意味着运行一个脚本，该脚本将使用网页作为后端服务。
- en: Of course, scripting a web page is quite a brutal way to obtain a service. Using
    a REST API (or any API) would be much more elegant. But in some cases there is
    no API. CasperJS is able to simulate user interaction on our web pages in order
    to test them.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，用脚本编写网页是一种相当粗暴的方式来获取服务。使用 REST API（或任何 API）会更为优雅。但在某些情况下没有 API。CasperJS 能够模拟我们在网页上的用户交互，以便测试它们。
- en: But obviously, we can use its abilities to simulate user interaction on any
    web page in order to automate a process. That is why CasperJS is a very efficient
    web scripting tool.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 但显然，我们可以利用其能力来模拟任何网页上的用户交互，以自动化一个过程。这就是为什么 CasperJS 是一个非常高效的网页脚本工具。
- en: 'Let''s say we want a script to tell us how many unread messages we have in
    our Gmail inbox. We could use a script like the following (`example12.js`):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个脚本来告诉我们 Gmail 邮箱中有多少未读消息。我们可以使用以下脚本（`example12.js`）：
- en: '[PRE61]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In this script, we log in and get the HTML code for the **Inbox** link (in
    the left menu) as it contains the number of unread e-mails, like the following:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们登录并获取**收件箱**链接（在左侧菜单中）的HTML代码，因为它包含未读电子邮件的数量，如下所示：
- en: '[PRE62]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To extract the number, we use a regular expression, `/\((\d+)\)/`, that will
    look for any number enclosed in brackets.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取数字，我们使用正则表达式`/\((\d+)\)/`，它将寻找任何括号内的数字。
- en: 'And the following is what we get:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们得到的结果：
- en: '![Web scripting](img/9431OS_01_example12-2.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![Web scripting](img/9431OS_01_example12-2.jpg)'
- en: 'Now let''s try to get a local weather report (`example13.js`):'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取本地天气预报（`example13.js`）：
- en: '[PRE63]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we just load the Yahoo! Weather home page and then extract the information
    we want (the current temperature, our location, and the immediate forecast). After
    we have done this, we get the following:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是加载了Yahoo!天气预报的主页，然后提取我们想要的信息（当前温度、我们的位置和即时的预报）。完成这些后，我们得到以下结果：
- en: '![Web scripting](img/9431OS_01_example13-1.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![Web scripting](img/9431OS_01_example13-1.jpg)'
- en: Nice!
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！
- en: But be careful; if Yahoo! decides to change its weather page's layout, the selectors
    we have used might become invalid and our service would be down. This is the main
    weakness of the web scripting approach. And, in this very use case (getting Yahoo!
    Weather reports), we will build a much safer service by using the excellent Yahoo!
    Query Language REST API.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意；如果Yahoo!决定更改其天气页面的布局，我们使用的选择器可能变得无效，我们的服务就会中断。这是网络脚本方法的主要弱点。而且，在这个非常用例（获取Yahoo!天气预报）中，我们将通过使用优秀的Yahoo!查询语言REST
    API来构建一个更安全的服务。
- en: Nevertheless, web scripting might sometimes be a light and convenient solution
    when we are facing complex cross-platform integration issues.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们面对复杂的跨平台集成问题时，网络脚本可能有时是一个轻便且方便的解决方案。
- en: Screenshot production
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 截图生成
- en: 'CasperJS is able to produce an image from the current page using the following
    two methods:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS可以使用以下两种方法从当前页面生成图像：
- en: '`this.capture(String filepath)`: This takes a screenshot of the entire page'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.capture(String filepath)`: 这将捕获整个页面的截图'
- en: '`this.captureSelector(String filepath, String selector)`: This restricts the
    capture to a specific element'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.captureSelector(String filepath, String selector)`: 这将捕获特定元素'
- en: 'A simple example (`example14.js`) is as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子（`example14.js`）如下：
- en: '[PRE64]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If we run it, it'll work just fine, but we will obtain a very large image because
    this Wikipedia page is very long and we have captured it entirely.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，它将正常工作，但我们将获得一个非常大的图像，因为维基百科页面非常长，我们已经完全捕获了它。
- en: 'Being able to obtain a screenshot of a very long page is not always easy, so
    this feature can be helpful. If we want to reduce the captured area, we can set
    the viewport size and use `captureSelector` on the `html` element as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 能够获取一个非常长的页面的截图并不总是容易，所以这个功能可能很有帮助。如果我们想减少捕获区域，我们可以设置视口大小，并在`html`元素上使用`captureSelector`，如下所示：
- en: '[PRE65]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: And now we get a smaller image.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了一个更小的图像。
- en: A typical usage of the capture methods is obviously **debugging**; when we do
    not know why our CasperJS is not working as expected, before spending time logging
    everything or inspecting all the elements, a simple screenshot might show us that
    we just forgot to perform a valid authentication due to which we are still blocked
    at the login page.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获方法的一个典型用法显然是**调试**；当我们不知道为什么我们的CasperJS没有按预期工作，在花费时间记录一切或检查所有元素之前，一个简单的截图可能显示我们只是忘记执行有效的身份验证，因此我们仍然被阻止在登录页面。
- en: Another interesting usage is **documentation**. Writing a good user manual often
    involves inserting a lot of screenshots. Producing these screenshots can be quite
    long and painful, and it will be even more painful when we have to update them
    because the design may have changed since the last time we published the user
    manual.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的用法是**文档**。编写一个好的用户手册通常需要插入很多截图。生成这些截图可能相当耗时且痛苦，而且当我们不得不更新它们时，痛苦会更大，因为自上次发布用户手册以来，设计可能已经发生了变化。
- en: 'So, how about using CasperJS to generate all the screenshots we need automatically
    from the current version of our web application? The principle is simple: we write
    a CasperJS script that reproduces the usage scenarios described in our documentation,
    we obtain a set of images, and we fuse them with our documentation text. Markdown,
    reStructuredText4, Textile, or similar formats are good candidates.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用 CasperJS 自动从我们当前版本的 Web 应用程序中生成所有所需的截图怎么样？原理很简单：我们编写一个 CasperJS 脚本来重现我们在文档中描述的使用场景，我们获得一系列图片，并将它们与我们的文档文本融合。Markdown、reStructuredText4、Textile
    或类似格式都是不错的选择。
- en: 'Resurrectio (see the *Getting started with CasperJS (Simple)* section) proposes
    to export any recorded sequence in two versions: a CasperJS version (which has
    our actual test scripts) and a reStructuredText version (which only contains comments
    and screenshots).'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: Resurrectio（见 *CasperJS 入门（简单）* 部分）建议以两种版本导出任何记录的序列：一个 CasperJS 版本（其中包含我们的实际测试脚本）和一个
    reStructuredText 版本（其中只包含注释和截图）。
- en: So we can run the test, obtain the screenshots, and compile our reStructuredText
    (with `rst2html`, `rst2doc`, `rst2pdf`, or so on) to get our document. Every time
    the design changes, we just re-run the test, recompile the text, and the document
    is updated automatically.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以运行测试，获取截图，并编译我们的 reStructuredText（使用 `rst2html`、`rst2doc`、`rst2pdf` 等）以获取我们的文档。每次设计更改时，我们只需重新运行测试、重新编译文本，文档就会自动更新。
- en: We can also use the capture methods from dynamically generated rendering to
    *produce static contents*.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用动态生成的渲染的捕获方法来 *生成静态内容*。
- en: For instance, if we use **d3.js** ([http://d3js.org/](http://d3js.org/)) to
    draw gorgeous charts on our web page but would like to insert them in a newsletter
    or allow an old web browser to see them, we can turn them into images using CasperJS.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想使用 **d3.js** ([http://d3js.org/](http://d3js.org/)) 在网页上绘制精美的图表，但又希望将它们插入到通讯稿中或允许旧版网页浏览器查看，我们可以使用
    CasperJS 将它们转换为图片。
- en: 'Let''s take the following example from the [d3js.org](http://d3js.org) tutorial
    (`example15.html`):'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 [d3js.org](http://d3js.org) 教程的以下示例（`example15.html`）来看一下：
- en: '[PRE66]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It reads a CSV file that contains population by age group and draws a donut
    chart using SVG.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 它读取包含按年龄分组的人口数据的 CSV 文件，并使用 SVG 绘制饼图。
- en: 'Let''s provide the needed data (`data.csv`):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提供所需的数据 (`data.csv`)：
- en: '[PRE67]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now we can launch our simple HTTP server and have a look. It will work well
    if we are using Chrome, for instance, but won't work with Internet Explorer 8.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动我们的简单 HTTP 服务器并查看。如果我们使用 Chrome 等浏览器，它将工作得很好，但与 Internet Explorer 8
    不兼容。
- en: 'CasperJS can be used to capture this chart so we can serve an equivalent image
    to the web browser that is not able to render SVG (`example15.js`):'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS 可以用来捕获这个图表，这样我们可以向无法渲染 SVG 的网页浏览器提供等效的图片（`example15.js`）：
- en: '[PRE68]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And the following is what we get:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的结果：
- en: '![Screenshot production](img/9431OS_01_example15-1.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![截图生产](img/9431OS_01_example15-1.jpg)'
- en: CasperJS can also be a smart way to provide a **server-side printing service**.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS 还可以是一种提供 **服务器端打印服务** 的智能方式。
- en: When we want our users to print our web pages, the most common and simple approach
    for them to use would be the web browser `print` feature. If we need to customize
    the rendering for printing (hide the navigation bar, change some colors or fonts,
    and so on), we can easily do so using a specific CSS for print (by mentioning
    `media="print"` inside the `link` tag). However, sometimes this is not enough.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望用户打印我们的网页时，他们最常见和简单的方法是使用网络浏览器的 `打印` 功能。如果我们需要为打印自定义渲染（隐藏导航栏、更改一些颜色或字体等），我们可以很容易地使用特定的打印
    CSS（通过在 `link` 标签中提及 `media="print"`）来实现。然而，有时这还不够。
- en: Background images are a typical instance of where standard printing can be annoying;
    background images are hidden during printing, and it makes sense as we prefer
    to print text on a white background. But if we use them for a specific goal, such
    as filling the different bars of a bar chart, the printed result will be disappointing.
    (In our case, all the bars will be white, so we will not be able to distinguish
    between them.)
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 背景图像是标准打印可能令人烦恼的典型例子；打印时隐藏背景图像，这很合理，因为我们更喜欢在白色背景上打印文本。但如果我们为了特定目的使用它们，例如填充条形图的各个条，打印结果将令人失望。（在我们的例子中，所有条都将变为白色，因此我们将无法区分它们。）
- en: We will also have problems when we want to change the displayed information
    between screen and print. For instance, our page might contain a map with few
    markers. On the screen, we display a label when the mouse goes over a marker,
    but on print, we would prefer that all the labels are displayed.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在屏幕和打印之间更改显示的信息时，我们也会遇到问题。例如，我们的页面可能包含带有少量标记的地图。在屏幕上，当鼠标悬停在标记上时，我们显示一个标签，但在打印时，我们更希望显示所有标签。
- en: In these problematic cases, a good solution is to use CasperJS as a **backend
    printing service**. The purpose is to highlight a service that takes as a parameter
    any URL, which returns an image capture of the corresponding page ready to be
    printed.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些问题案例中，一个很好的解决方案是使用 CasperJS 作为 **后端打印服务**。其目的是突出一个接受任何 URL 作为参数的服务，该服务返回对应页面的图像捕获，以便打印。
- en: 'Our service will simply run a CasperJS script that will open the provided URL
    and then capture it:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务将简单地运行一个 CasperJS 脚本，该脚本将打开提供的 URL 并捕获它：
- en: '[PRE69]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As we cannot use the `media="print"` attribute to apply some print-specific
    CSS (as CasperJS will open the page in the screen mode), we can dynamically add
    a specific class on the body element before capturing so we can easily style the
    rendering:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能使用 `media="print"` 属性来应用一些特定的打印 CSS（因为 CasperJS 将以屏幕模式打开页面），我们可以在捕获之前动态地向
    body 元素添加一个特定的类，这样我们就可以轻松地设置渲染样式：
- en: '[PRE70]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And if we want to allow a specific process to be performed before capturing
    (such as displaying all the marker labels on a map as discussed before), we might
    wait for a specific selector to be available. The list of selectors is as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在捕获之前允许执行特定的过程（例如，如前所述，在地图上显示所有标记标签），我们可能需要等待特定的选择器可用。选择器的列表如下：
- en: 'In our target page, we add a JavaScript in charge of setting up the page for
    printing and adding a marker class on the `body` element as desired:'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的目标页面上，我们添加一段 JavaScript，负责设置打印页面并在 `body` 元素上添加所需的标记类：
- en: '[PRE71]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In CasperJS, we wait for this marker class to appear before capturing the output:'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CasperJS 中，我们在捕获输出之前等待这个标记类出现：
- en: '[PRE72]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This service can be implemented with any web framework (we just need to be able
    to make a system call to run our CasperJS script).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务可以用任何 Web 框架实现（我们只需要能够调用系统来运行我们的 CasperJS 脚本）。
- en: '**Django Screamshot** is a Django implementation and can be found at [https://github.com/makinacorpus/django-screamshot](https://github.com/makinacorpus/django-screamshot).'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**Django Screamshot** 是 Django 的一个实现，可以在 [https://github.com/makinacorpus/django-screamshot](https://github.com/makinacorpus/django-screamshot)
    找到。'
