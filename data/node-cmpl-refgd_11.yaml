- en: Unit Testing and Functional Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和功能测试
- en: nit testing has become a primary part of good software development practice.
    It is a method by which individual units of source code are tested to ensure proper
    functioning. Each unit is theoretically the smallest testable part of an application.
    In a Node.js application, you might consider each module as a unit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试已成为良好软件开发实践的重要组成部分。这是一种通过测试源代码的各个单元来确保其正确功能的方法。每个单元在理论上都是应用程序中最小的可测试部分。在一个
    Node.js 应用程序中，你可能将每个模块视为一个单元。
- en: In unit testing, each unit is tested separately, isolating the unit under test
    as much as possible from other parts of the application. If a test fails, you
    would want it to be due to a bug in your code rather than a bug in the package
    that your code happens to use. A common technique is to use mock objects or mock
    data to isolate individual parts of the application from one another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，每个单元都是单独测试的，尽可能地将测试单元与其他应用程序部分隔离。如果测试失败，你希望它是因为你的代码中的错误，而不是你代码所使用的包中的错误。一个常见的技巧是使用模拟对象或模拟数据来隔离应用程序的各个部分。
- en: Functional testing, on the other hand, doesn't try to test individual components,
    but instead it tests the whole system. Generally speaking, unit testing is performed
    by the development team, and functional testing is performed by a **Quality Assurance**
    (**QA**) or **Quality Engineering** (**QE**) team. Both testing models are needed
    to fully certify an application. An analogy might be that unit testing is similar
    to ensuring that each word in a sentence is correctly spelled, while functional
    testing ensures that the paragraph containing that sentence has a good structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，功能测试并不试图测试单个组件，而是测试整个系统。一般来说，单元测试由开发团队执行，而功能测试由质量保证（**QA**）或质量工程（**QE**）团队执行。这两种测试模型都是完全认证应用程序所必需的。一个类比可能是，单元测试类似于确保句子中的每个单词都拼写正确，而功能测试则确保包含该句子的段落具有良好的结构。
- en: 'In this chapter, we''ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Assertions as the basis of software tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言作为软件测试的基础
- en: The Mocha unit testing framework and the Chai assertions library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha 单元测试框架和 Chai 断言库
- en: Using tests to find bugs and fixing the bug
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试来查找错误并修复错误
- en: Using Docker to manage test infrastructure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 管理测试基础设施
- en: Testing a REST backend service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 REST 后端服务
- en: UI testing in a real web browser using Puppeteer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Puppeteer 在真实网页浏览器中进行 UI 测试
- en: Improving UI testability with element ID attributes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元素 ID 属性提高 UI 可测试性
- en: Assert – the basis of testing methodologies
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言 – 测试方法的基础
- en: Node.js has a useful built-in testing tool, the `assert` module. Its functionality
    is similar to assert libraries in other languages. Namely, it's a collection of
    functions for testing conditions, and if the conditions indicate an error, the `assert`
    function throws an exception.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 有一个有用的内置测试工具，即 `assert` 模块。它的功能与其他语言的 `assert` 库类似。也就是说，它是一组用于测试条件的函数，如果条件指示有错误，则
    `assert` 函数会抛出异常。
- en: At its simplest, a test suite is a series of `assert` calls to validate the
    behavior of a thing being tested. For example, a test suite could instantiate the
    user authentication service, then make an API call, using `assert` methods to
    validate the result, then make another API call, validating its results, and so
    on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况下，测试套件是一系列 `assert` 调用来验证被测试事物的行为。例如，测试套件可以实例化用户身份验证服务，然后进行 API 调用，使用
    `assert` 方法验证结果，然后进行另一个 API 调用，验证其结果，依此类推。
- en: 'Consider a code snippet like this, which you could save in a file named `deleteFile.js`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个代码片段，例如，你可以将其保存为名为 `deleteFile.js` 的文件：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing to notice is this contains several layers of asynchronous callback
    functions. That presents a couple of challenges:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这里包含了几层异步回调函数。这带来了一些挑战：
- en: Capturing errors from deep inside a callback, to ensure the test scenario fails
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从回调函数的深处捕获错误，以确保测试场景失败
- en: Detecting conditions where the callbacks are never called
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测回调函数从未被调用的情况
- en: 'The following is an example of using `assert` for testing. Create a file named `test-deleteFile.js` containing
    the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `assert` 进行测试的示例。创建一个名为 `test-deleteFile.js` 的文件，包含以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is what's called a negative test scenario, in that it's testing whether
    requesting to delete a nonexistent file throws an error.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为负测试场景，因为它测试的是请求删除一个不存在的文件是否会抛出错误。
- en: If you are looking for a quick way to test, the `assert` module can be useful
    when used this way. If it runs and no messages are printed, then the test passes.
    But, did it catch the instance of the `deleteFile` callback never being called?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一种快速测试的方法，当这样使用时，`assert` 模块可能很有用。如果它运行并且没有打印出消息，那么测试就通过了。但是，它是否捕捉到了
    `deleteFile` 回调从未被调用的情况？
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `assert` module is used by many of the test frameworks as a core tool for
    writing test cases. What the test frameworks do is create a familiar test suite
    and test case structure to encapsulate your test code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 模块被许多测试框架用作编写测试用例的核心工具。测试框架所做的是创建一个熟悉的测试套件和测试用例结构来封装你的测试代码。'
- en: There are many styles of assertion libraries available in Node.js. Later in
    this chapter, we'll use the Chai assertion library ([http://chaijs.com/](http://chaijs.com/))
    which gives you a choice between three different assertion styles (should, expect,
    and assert).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 中有众多断言库的风格。在本章的后面部分，我们将使用 Chai 断言库 ([http://chaijs.com/](http://chaijs.com/))，它为你提供了三种不同的断言风格（should、expect
    和 assert）的选择。
- en: Testing a Notes model
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Notes 模型
- en: Let's start our unit testing journey with the data models we wrote for the Notes
    application. Because this is unit testing, the models should be tested separately from
    the rest of the Notes application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为 Notes 应用程序编写的数据模型开始我们的单元测试之旅。因为这是单元测试，模型应该与 Notes 应用程序的其余部分分开进行测试。
- en: In the case of most of the Notes models, isolating their dependencies implies
    creating a mock database. Are you going to test the data model or the underlying
    database? Mocking out a database means creating a fake database implementation, which
    does not look like a productive use of our time. You can argue that testing a
    data model is really about testing the interaction between your code and the database,
    that mocking out the database means not testing that interaction, and therefore
    we should test our code against the database engine used in production.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Notes 模型的大多数情况下，隔离它们的依赖意味着创建一个模拟数据库。你是要测试数据模型还是底层数据库？模拟数据库意味着创建一个假的数据库实现，这并不像是我们时间的高效利用。你可以争论说，测试数据模型实际上是在测试你的代码与数据库之间的交互，模拟数据库意味着没有测试这种交互，因此我们应该针对生产中使用的数据库引擎测试我们的代码。
- en: With that line of reasoning in mind, we'll skip mocking out the database, and
    instead run the tests against a database containing test data. To simplify launching
    the test database, we'll use Docker to start and stop a version of the Notes application
    stack that's set up for testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这样的推理，我们将跳过模拟数据库，而是对包含测试数据的数据库运行测试。为了简化测试数据库的启动，我们将使用 Docker 启动和停止一个为测试设置的
    Notes 应用程序堆栈版本。
- en: Mocha and Chai­ – the chosen test tools
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocha 和 Chai – 选择的测试工具
- en: If you haven't already done so, duplicate the source tree to use in this chapter.
    For example, if you had a directory named `chap10`, create one named `chap11`
    containing everything from `chap10`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，复制源树以用于本章。例如，如果你有一个名为 `chap10` 的目录，创建一个名为 `chap11` 的目录，其中包含 `chap10`
    中的所有内容。
- en: In the `notes` directory, create a new directory named `test`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `notes` 目录下，创建一个名为 `test` 的新目录。
- en: Mocha ([http://mochajs.org/](http://mochajs.org/)) is one of many test frameworks
    available for Node.js. As you'll see shortly, it helps us write test cases and
    test suites, and it provides a test results reporting mechanism. It was chosen
    over the alternatives because it supports Promises. It fits very well with the
    Chai assertion library mentioned earlier. And, we'll need to use ES6 modules from
    test suites written in CommonJS, and therefore we must use the `esm` module.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha ([http://mochajs.org/](http://mochajs.org/)) 是许多适用于 Node.js 的测试框架之一。正如你很快就会看到的，它帮助我们编写测试用例和测试套件，并提供测试结果报告机制。它之所以被选中，是因为它支持
    Promises。它与前面提到的 Chai 断言库非常契合。此外，我们需要使用 ES6 模块从 CommonJS 编写的测试套件中，因此我们必须使用 `esm`
    模块。
- en: You may find references to an earlier `@std/esm` module. That module has been
    deprecated, with `esm` put in its place.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现对早期 `@std/esm` 模块的引用。该模块已被弃用，`esm` 取而代之。
- en: 'While in the `notes/test` directory, type this to install Mocha, Chai, and
    `esm`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `notes/test` 目录中时，输入以下命令来安装 Mocha、Chai 和 `esm`：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notes model test suite
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes 模型测试套件
- en: Because we have several Notes models, the test suite should run against any
    model. We can write tests using the Notes model API we developed, and an environment
    variable should be used to declare the model to test.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有多个Notes模型，测试套件应该针对任何模型运行。我们可以使用我们开发的Notes模型API编写测试，并使用环境变量来声明要测试的模型。
- en: Because we've written the Notes application using ES6 modules, we have a small
    challenge to overcome. Mocha only supports running tests in CommonJS modules,
    and Node.js (as of this writing) does not support loading an ES6 module from a
    CommonJS module. An ES6 module can use `import` to load a CommonJS module, but
    a CommonJS module cannot use `require` to load an ES6 module. There are various
    technical reasons behind this, the bottom line is that we're limited in this way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用ES6模块编写了Notes应用程序，我们面临一个小挑战。Mocha只支持在CommonJS模块中运行测试，而Node.js（截至本文写作时）不支持从CommonJS模块加载ES6模块。ES6模块可以使用`import`来加载CommonJS模块，但CommonJS模块不能使用`require`来加载ES6模块。背后有各种技术原因，但最终结果是我们在这种限制下。
- en: Because Mocha requires that tests be CommonJS modules, we're in the position
    of having to load an ES6 module into a CommonJS module.  A module, `esm`, exists
    which allows that combination to work. If you'll refer back, we installed that
    module in the previous section. Let's see how to use it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Mocha要求测试必须是CommonJS模块，我们处于必须将ES6模块加载到CommonJS模块中的位置。存在一个名为`esm`的模块，它允许这种组合工作。如果你回顾一下，我们在上一节中安装了该模块。让我们看看如何使用它。
- en: 'In the `test` directory, create a file named `test-model.js` containing this
    as the outer shell of the test suite:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test`目录中，创建一个名为`test-model.js`的文件，包含以下内容作为测试套件的顶层结构：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The support to load ES6 modules is enabled by the `require('esm')` statement
    shown here. It replaces the standard `require` function with one from the `esm`
    module. That parameter list at the end enables the feature to load ES6 modules
    in a CommonJS module. Once you've done this, your CommonJS module can load an
    ES6 module as evidenced by `require('../models/notes')` a couple of lines later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这里显示的`require('esm')`语句启用了加载ES6模块的支持。它用`esm`模块中的一个替换了标准的`require`函数。末尾的参数列表启用了在CommonJS模块中加载ES6模块的功能。一旦这样做，你的CommonJS模块就可以通过`require('../models/notes')`在几行之后加载一个ES6模块。
- en: The Chai library supports three flavors of assertions. We're using the `assert`
    style here, but it's easy to use a different style if you prefer. For the other
    styles supported by Chai, see [http://chaijs.com/guide/styles/](http://chaijs.com/guide/styles/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Chai库支持三种断言风格。我们在这里使用的是`assert`风格，但如果你更喜欢其他风格，也很容易切换。有关Chai支持的其他风格，请参阅[http://chaijs.com/guide/styles/](http://chaijs.com/guide/styles/)。
- en: Chai's assertions include a very long list of useful assertion functions, see [http://chaijs.com/api/assert/](http://chaijs.com/api/assert/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Chai的断言包括一个非常长的有用断言函数列表，请参阅[http://chaijs.com/api/assert/](http://chaijs.com/api/assert/)。
- en: The Notes model to test must be selected with the `NOTES_MODEL` environment
    variable. For the models that also consult environment variables, we'll need to
    supply that configuration as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试的Notes模型必须通过`NOTES_MODEL`环境变量来选择。对于也咨询环境变量的模型，我们还需要提供该配置。
- en: With Mocha, a test suite is contained within a `describe` block. The first argument
    is descriptive text, which you use to tailor the presentation of test results.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mocha，测试套件包含在一个`describe`块中。第一个参数是描述性文本，你用它来定制测试结果的展示。
- en: 'Rather than maintaining a separate test database, we can create one on the
    fly while executing tests. Mocha has what are called hooks, which are functions
    executed before or after test case execution. The hook functions let you, the
    test suite author, set up and tear down required conditions for the test suite
    to operate as desired. For example, to create a test database with known test
    content:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是维护一个单独的测试数据库，我们可以在执行测试时动态创建一个。Mocha有所谓的钩子，这些是在测试用例执行前后执行的函数。钩子函数让你，测试套件的作者，设置和撤销测试套件操作所需的条件。例如，为了创建一个包含已知测试内容的测试数据库：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This defines a `beforeEach` hook, which is executed before every test case.
    The other hooks are `before`, `after`, `beforeEach`, and `afterEach`. The each
    hooks are triggered before or after each test case execution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个`beforeEach`钩子，它在每个测试用例之前执行。其他的钩子包括`before`、`after`、`beforeEach`和`afterEach`。每个钩子在测试用例执行前后被触发。
- en: This is meant to be a cleanup/preparation step before every test. It uses our
    Notes API to first delete all notes from the database (if any) and then create
    a set of new notes with known characteristics. This technique simplifies tests
    by ensuring that we have known conditions to test against.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它是一个在每个测试之前的清理/准备步骤。它使用我们的笔记 API 首先从数据库中删除所有笔记（如果有），然后创建一组具有已知特征的新的笔记。这种技术通过确保我们有已知条件来测试，从而简化了测试。
- en: We also have a side effect of testing the `model.keylist` and `model.create`
    methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个副作用是测试 `model.keylist` 和 `model.create` 方法。
- en: 'In Mocha, a series of test cases are encapsulated with a `describe` block,
    and written using an `it` block. The `describe` block is meant to describe that
    group of tests, and the `it` block is for checking assertions on a specific aspect
    of the thing being tested. You can nest the `describe` blocks as deeply as you
    like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mocha 中，一系列测试用例被封装在一个 `describe` 块中，并使用 `it` 块编写。`describe` 块的目的是描述那一组测试，而
    `it` 块是用来检查被测试事物的特定方面的断言。你可以根据需要将 `describe` 块嵌套得尽可能深：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The idea is to call Notes API functions, then to test the results to check whether
    they matched the expected results.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是调用笔记 API 函数，然后测试结果以检查它们是否与预期结果匹配。
- en: This `describe` block is within the outer `describe` block. The descriptions
    given in the describe and `it` blocks are used to make the test report more readable.
    The `it` block forms a pseudo-sentence along the lines of *it (the thing being
    tested) should do this or that*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `describe` 块位于外部的 `describe` 块内。`describe` 和 `it` 块中给出的描述用于使测试报告更易于阅读。`it`
    块形成了一个类似于 *it (被测试的事物) 应该这样做或那样做* 的伪句子。
- en: It is important with Mocha to not use arrow functions in the `describe` and `it` blocks.
    By now, you will have grown fond of arrow functions because of how much easier
    they are to write. But, Mocha calls these functions with a `this` object containing
    useful functions for Mocha. Because arrow functions avoid setting up a `this` object,
    Mocha would break.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mocha 中，重要的是不要在 `describe` 和 `it` 块中使用箭头函数。到现在为止，你可能会因为箭头函数的易用性而喜欢它们。但是，Mocha
    使用一个包含对 Mocha 有用函数的 `this` 对象来调用这些函数。因为箭头函数避免了设置 `this` 对象，所以 Mocha 会崩溃。
- en: Even though Mocha requires regular functions for the `describe` and `it` blocks,
    we can use arrow functions within those functions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Mocha 需要 `describe` 和 `it` 块中的常规函数，我们也可以在这些函数中使用箭头函数。
- en: How does Mocha know whether the test code passes? How does it know when the
    test finishes? This segment of code shows one of the three methods.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 如何知道测试代码是否通过？它是如何知道测试何时完成的？这段代码展示了三种方法之一。
- en: Generally, Mocha is looking to see if the function throws an exception, or whether
    the test case takes too long to execute (a timeout situation). In either case,
    Mocha will indicate a test failure. That's of course simple to determine for non-asynchronous
    code. But, Node.js is all about asynchronous code, and Mocha has two models for
    testing asynchronous code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Mocha 寻找函数是否抛出异常，或者测试用例是否执行时间过长（超时情况）。在任何情况下，Mocha 都会指示测试失败。当然，对于非异步代码来说，这很简单就能确定。但是，Node.js
    全是关于异步代码的，Mocha 有两种异步代码测试模型。
- en: In the first (not seen here), Mocha passes in a callback function, and the test
    code is to call the callback function. In the second, as seen here, it looks for
    a Promise being returned by the test function, and determines pass/fail on whether
    the Promise is in the *resolve* or *reject* state.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个（此处未展示）中，Mocha 传入一个回调函数，测试代码是调用这个回调函数。在第二个，如这里所示，它寻找测试函数返回的 Promise，并确定是否通过取决于
    Promise 是否处于 *resolve* 或 *reject* 状态。
- en: In this case, we're using `async` functions, because they automatically return
    a Promise. Within the functions, we're calling asynchronous functions using `await,` ensuring
    any thrown exception is indicated as a rejected Promise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `async` 函数，因为它们会自动返回一个 Promise。在函数内部，我们使用 `await` 调用异步函数，确保任何抛出的异常都会被指示为拒绝的
    Promise。
- en: 'Another item to note is the question asked earlier: what if the callback function
    we''re testing is never called?  Or, what if a Promise is never resolved?  Mocha
    starts a timer and if the test case does not finish before the timer expires,
    Mocha fails the test case.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事项是之前提出的问题：如果我们正在测试的回调函数从未被调用怎么办？或者，如果 Promise 从未解决怎么办？Mocha 启动一个计时器，如果测试用例在计时器到期之前没有完成，Mocha
    会失败该测试用例。
- en: Configuring and running tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和运行测试
- en: 'We have more tests to write, but let''s first get set up to run the tests.
    The simplest model to test is the in-memory model. Let''s add this to the `scripts`
    section of `notes/test/package.json`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有更多的测试要写，但让我们首先设置好运行测试的环境。最简单的模型要测试的是内存模型。让我们将其添加到`notes/test/package.json`的`scripts`部分：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To install dependencies, we must run `npm install` in both the `notes/test`
    and `notes` directories. That way both the dependencies for the test code, and
    the dependencies for Notes, are installed in their correct place.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装依赖项，我们必须在`notes/test`和`notes`目录中运行`npm install`。这样，测试代码的依赖项和Notes的依赖项都安装在了正确的位置。
- en: 'Then, we can run it as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式运行它：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `mocha` command is used to run the test suite.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mocha`命令运行测试套件。
- en: The structure of the output follows the structure of the `describe` and `it`
    blocks. You should set up the descriptive text strings so it reads nicely.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的结构遵循`describe`和`it`块的结构。你应该设置描述性文本字符串，使其读起来更舒服。
- en: More tests for the Notes model
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes模型的更多测试
- en: 'That wasn''t enough to test much, so let''s go ahead and add some more tests:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不够测试很多，所以让我们继续添加一些更多的测试：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that for the negative tests – where the test passes if an error is thrown
    – we run it in a `try/catch` block. The `throw new Error` line in each case should
    not execute because the preceding code should throw an error. Therefore, we can
    check if the message in that thrown error is the message which arrives, and fail
    the test if that's the case.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于负测试——如果抛出错误则测试通过——我们将其运行在`try/catch`块中。每个情况中的`throw new Error`行不应该执行，因为前面的代码应该抛出错误。因此，我们可以检查抛出的错误中的消息是否是接收到的消息，如果是这种情况，则测试失败。
- en: 'Now, the test report:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试报告：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In these additional tests, we have a couple of negative tests. In each test
    that we expect to fail, we supply a `notekey` that we know is not in the database,
    and we then ensure that the model gives us an error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些附加测试中，我们有一些负测试。在每个我们期望失败的测试中，我们提供一个我们知道不在数据库中的`notekey`，然后确保模型给我们一个错误。
- en: 'The Chai Assertions API includes some very expressive assertions. In this case,
    we''ve used the `deepEqual` method which does a deep comparison of two objects.
    In our case, it looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Chai断言API包括一些非常表达式的断言。在这种情况下，我们使用了`deepEqual`方法，它对两个对象进行深度比较。在我们的情况下，它看起来像这样：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This reads nicely in the test code, but more importantly a reported test failure
    looks very nice. Since these are currently passing, try introducing an error by
    changing one of the expected value strings. Upon rerunning the test, you''ll see:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这在测试代码中读起来很舒服，但更重要的是，报告的测试失败看起来非常漂亮。由于这些目前都在通过，尝试通过更改其中一个预期值字符串来引入一个错误。重新运行测试后，你会看到：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the top is the status report of each test case. For one test, instead of
    a check mark is a number, and the number corresponds to the reported details at
    the bottom. Mocha presents test failures this way when the `spec` reporter is
    used. Mocha supports other test report formats, some of which produce data that
    can be sent into test status reporting systems. For more information, see [https://mochajs.org/#reporters](https://mochajs.org/#reporters).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最上面是每个测试案例的状态报告。对于某个测试，不是用勾号表示，而是用数字，这个数字对应于底部报告的详细信息。当使用`spec`报告器时，Mocha就是这样呈现测试失败的。Mocha支持其他测试报告格式，其中一些可以产生可以发送到测试状态报告系统的数据。有关更多信息，请参阅[https://mochajs.org/#reporters](https://mochajs.org/#reporters)。
- en: In this case, the failure was detected by a `deepEqual` method, which presents
    the detected object inequality in this way.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，失败是通过`deepEqual`方法检测到的，它以这种方式呈现检测到的对象不等式。
- en: Testing database models
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据库模型
- en: That was good, but we obviously won't run Notes in production with the in-memory
    Notes model. This means that we need to test all the other models.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们显然不会在生产中使用内存中的Notes模型。这意味着我们需要测试所有其他模型。
- en: 'Testing the LevelUP and filesystem models is easy, just add this to the scripts
    section of `package.json`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 测试LevelUP和文件系统模型很容易，只需将其添加到`package.json`的脚本部分：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then run the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will produce a successful test result.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个成功的测试结果。
- en: 'The simplest database to test is SQLite3, since it requires zero setup. We
    have two SQLite3 models to test, let''s start with `notes-sqlite3.js`. Add the
    following to the scripts section of `package.json`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的数据库来测试是SQLite3，因为它不需要任何设置。我们有两个SQLite3模型要测试，让我们从`notes-sqlite3.js`开始。将以下内容添加到`package.json`的脚本部分：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command sequence puts the test database in the `chap11.sqlite3` file. It
    first initializes that database using the `sqlite3` command-line tool. Note that
    we've connected its input to `/dev/null` because the `sqlite3` command will prompt
    for input otherwise. Then, it runs the test suite passing in environment variables
    required to run against the SQLite3 model.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令序列将测试数据库放入`chap11.sqlite3`文件。它首先使用`sqlite3`命令行工具初始化该数据库。请注意，我们已经将其输入连接到`/dev/null`，因为否则`sqlite3`命令会提示输入。然后，它运行测试套件，传递运行针对SQLite3模型所需的环境变量。
- en: 'Running the test suite does find two errors:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试套件确实找到了两个错误：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The failing test calls `model.read("badkey12")`, a `key` which we know does
    not exist. Writing negative tests paid off. The failing line of code at `models/notes-sqlite3.mjs`
    (line 64) reads as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的测试调用`model.read("badkey12")`，一个我们知道不存在的`key`。编写负面测试是值得的。在`models/notes-sqlite3.mjs`（第64行）中失败的代码行如下：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It's easy enough to insert `console.log(util.inspect(row));` just before this
    and learn that, for the failing call, SQLite3 gave us `undefined` for `row`, explaining
    the error message.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之前插入`console.log(util.inspect(row));`非常简单，可以了解到，对于失败的调用，SQLite3为我们提供了`undefined`的`row`，解释了错误信息。
- en: The test suite calls the `read` function multiple times with a `notekey` value
    that does exist. Obviously, when given an invalid `notekey` value, the query gives
    an empty results set and SQLite3 invokes the callback with both the `undefined`
    error and the `undefined` row values. This is common behavior for database modules.
    An empty result set isn't an error, and therefore we received no error and an
    undefined `row`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件多次调用`read`函数，使用一个确实存在的`notekey`值。显然，当提供一个无效的`notekey`值时，查询会返回一个空的结果集，SQLite3会调用回调函数，同时传递`undefined`错误和`undefined`的行值。这是数据库模块的常见行为。空结果集不是错误，因此我们没有收到错误，也没有`undefined`的`row`。
- en: 'In fact, we saw this behavior earlier with `models/notes-sequelize.mjs`. The
    equivalent code in `models/notes-sequelize.mjs` does the right thing, and it has
    a check, which we can adapt. Let''s rewrite the `read` function in `models/notes-sqlite.mjs`
    to this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在`models/notes-sequelize.mjs`中看到了这种行为。`models/notes-sequelize.mjs`中的等效代码做了正确的事情，并且有一个检查，我们可以将其改编。让我们将`models/notes-sqlite.mjs`中的`read`函数重写为以下内容：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is simple, we just check whether `row` is `undefined` and, if so, throw
    an error. While the database doesn't see an empty results set as an error, Notes
    does. Furthermore, Notes already knows how to deal with a thrown error in this
    case. Make this change and that particular test case passes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，我们只需检查`row`是否为`undefined`，如果是，就抛出一个错误。虽然数据库不会将空结果集视为错误，但Notes会。此外，Notes已经知道如何处理这种情况下的抛出错误。进行这个更改，特定的测试用例就通过了。
- en: 'There is a second similar error in the `destroy` logic. The test to destroy
    a nonexistent note fails to produce an error at this line:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`destroy`逻辑中还有一个类似的错误。测试销毁一个不存在的笔记时，在这一行没有产生错误：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we inspect the other models, they''re throwing errors for a nonexistent
    key. In SQL, it obviously is not an error if this SQL (from `models/notes-sqlite3.mjs`)
    does not delete anything:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查其他模型，它们对于不存在的键会抛出错误。在SQL中，如果这个SQL（来自`models/notes-sqlite3.mjs`）没有删除任何东西，显然这不是一个错误：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Unfortunately, there isn''t a SQL option to make this SQL statement fail if
    it does not delete any records. Therefore, we must add a check to see if a record
    exists. Namely:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有SQL选项可以在不删除任何记录时使这个SQL语句失败。因此，我们必须添加一个检查来查看记录是否存在。具体来说：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Therefore, we read the note and as a byproduct we verify the note exists. If
    the note doesn't exist, `read` will throw an error, and the `DELETE` operation
    will not even run.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们读取了笔记，作为副产品我们也验证了笔记的存在。如果笔记不存在，`read`将抛出一个错误，并且`DELETE`操作甚至不会运行。
- en: These are the bugs we referred to in Chapter 7, *Data Storage and Retrieval*.
    We simply forgot to check for these conditions in this particular model. Thankfully,
    our diligent testing caught the problem. At least, that's the story to tell the
    managers rather than telling them that we forgot to check for something we already
    knew could happen.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们提到的第7章*数据存储和检索*中的错误。我们只是忘记在这个特定模型中检查这些条件。幸运的是，我们勤奋的测试捕捉到了这个问题。至少，这是我们要告诉经理们的故事，而不是告诉他们我们忘记检查我们已经知道可能发生的事情。
- en: 'Now that we''ve fixed `models/notes-sqlite3.mjs`, let''s also test `models/notes-sequelize.mjs`
    using the SQLite3 database. To do this, we need a connection object to specify
    in the `SEQUELIZE_CONNECT` variable. While we can reuse the existing one, let''s
    create a new one. Create a file named `test/sequelize-sqlite.yaml` containing
    this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修复了`models/notes-sqlite3.mjs`，让我们也使用SQLite3数据库测试`models/notes-sequelize.mjs`。为此，我们需要一个连接对象来在`SEQUELIZE_CONNECT`变量中指定。虽然我们可以重用现有的一个，但让我们创建一个新的。创建一个名为`test/sequelize-sqlite.yaml`的文件，包含以下内容：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This way, we don't overwrite the production database instance with our test
    suite. Since the test suite destroys the database it tests, it must be run against
    a database we are comfortable destroying. The logging parameter turns off the
    voluminous output `Sequelize` produces so that we can read the test results report.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们不会用我们的测试套件覆盖生产数据库实例。由于测试套件会销毁它测试的数据库，它必须运行在我们愿意销毁的数据库上。日志参数关闭了`Sequelize`产生的庞大输出，这样我们就可以阅读测试结果报告。
- en: 'Add the following to the scripts section of `package.json`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`package.json`的脚本部分：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then run the test suite:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行测试套件：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We pass with flying colors!  We've been able to leverage the same test suite
    against multiple Notes models. We even found two bugs in one model. But, we have
    two test configurations remaining to test.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们轻松过关！我们已经能够利用相同的测试套件针对多个笔记模型进行测试。我们甚至在其中一个模型中发现了两个错误。但是，我们还有两个测试配置需要测试。
- en: 'Our test results matrix reads as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试结果矩阵如下：
- en: '`models-fs`: PASS'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-fs`: 通过'
- en: '`models-memory`: PASS'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-memory`: 通过'
- en: '`models-levelup`: PASS'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-levelup`: 通过'
- en: '`models-sqlite3`: 2 failures, now fixed'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-sqlite3`: 2次失败，现已修复'
- en: '`models-sequelize`: with SQLite3: PASS'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-sequelize`: 使用SQLite3：通过'
- en: '`models-sequelize`: with MySQL: untested'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-sequelize`: 使用MySQL：未测试'
- en: '`models-mongodb`: untested'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-mongodb`: 未测试'
- en: The two untested models both require the setup of a database server. We avoided
    testing these combinations, but our manager won't accept that excuse because the
    CEO needs to know we've completed the test cycles. Notes must be tested in a similar
    configuration to the production environment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个未测试的模型都需要设置数据库服务器。我们避免测试这些组合，但我们的经理不会接受这个借口，因为CEO需要知道我们已经完成了测试周期。笔记必须在类似生产环境的配置中进行测试。
- en: In production, we'll be using a regular database server, of course, with MySQL
    or MongoDB being the primary choices. Therefore, we need a way that incurs a low
    overhead to run tests against those databases. Testing against the production
    configuration must be so easy that we should feel no resistance in doing so, to
    ensure that tests are run often enough to make the desired impact.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，我们当然会使用常规数据库服务器，MySQL或MongoDB是首选。因此，我们需要一种低开销的方式来运行对这些数据库的测试。对生产配置的测试必须非常容易，以至于我们不应该有任何阻力，以确保测试经常运行，以达到预期的效果。
- en: Fortunately, we've already had experience of a technology that supports easily
    creating and destroying the deployment infrastructure. Hello, Docker!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经有了一种支持轻松创建和销毁部署基础设施技术的经验。你好，Docker！
- en: Using Docker to manage test infrastructure
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker管理测试基础设施
- en: One advantage Docker gives is the ability to install the production environment
    on our laptop. It's then very easy to push the same Docker setup to the cloud-hosting
    environment for staging or production deployment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Docker给我们带来的一个优点是能够在我们的笔记本电脑上安装生产环境。然后，将相同的Docker设置推送到云托管环境进行预发布或生产部署就变得非常容易。
- en: What we'll do in this section is demonstrate reusing the Docker Compose configuration
    defined previously for test infrastructure, and to automate executing the Notes
    test suite inside the containers using a shell script. Generally speaking, it's
    important to replicate the production environment when running tests. Docker can
    make this an easy thing to do.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示重用之前为测试基础设施定义的Docker Compose配置，并使用shell脚本自动化在容器内执行笔记测试套件。一般来说，在运行测试时复制生产环境是很重要的。Docker可以使这一点变得容易实现。
- en: Using Docker, we'll be able to easily test against a database, and have a simple
    method for starting and stopping a test version of our production environment. Let's
    get started.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，我们将能够轻松地对数据库进行测试，并有一个简单的方法来启动和停止生产环境的测试版本。让我们开始吧。
- en: Docker Compose to orchestrate test infrastructure
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose编排测试基础设施
- en: We had a great experience using Docker Compose to orchestrate Notes application
    deployment. The whole system, with four independent services, is easily described
    in `compose/docker-compose.yml`. What we'll do is duplicate the Compose file,
    then make a couple of small changes required to support test execution.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用 Docker Compose 进行笔记应用程序部署编排时获得了很好的体验。整个系统，包含四个独立的服务，可以很容易地在 `compose/docker-compose.yml`
    中描述。我们将要做的是复制 Compose 文件，然后进行一些必要的更改以支持测试执行。
- en: Let's start by making a new directory, `test-compose`, as a sibling to the `notes`,
    `users`, and `compose` directories. Copy `compose/docker-compose.yml` to the newly
    created `test-compose` directory. We'll be making several changes to this file
    and a couple of small changes to the existing Dockerfiles.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的目录 `test-compose` 开始，作为 `notes`、`users` 和 `compose` 目录的兄弟目录。将 `compose/docker-compose.yml`
    复制到新创建的 `test-compose` 目录。我们将对这个文件进行一些更改，并对现有的 Dockerfile 进行一些小的更改。
- en: We want to change the container and network names so our test infrastructure
    doesn't clobber the production infrastructure. We'll constantly delete and recreate
    the test containers, so as to keep the developers happy, we'll leave development
    infrastructure alone and perform testing on separate infrastructure. By maintaining
    separate test containers and networks, our test scripts can do anything they like
    without disturbing the development or production containers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望更改容器和网络名称，以便我们的测试基础设施不会破坏生产基础设施。我们将不断删除并重新创建测试容器，为了使开发者满意，我们将保持开发基础设施不变，并在单独的基础设施上执行测试。通过维护独立的测试容器和网络，我们的测试脚本可以随心所欲地执行，而不会干扰开发或生产容器。
- en: 'Consider this change to the `db-auth` and `db-notes` containers:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对 `db-auth` 和 `db-notes` 容器进行的以下更改：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the same as earlier, but with `-test` appended to container and network
    names.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前相同，但容器和网络名称后添加了 `-test`。
- en: That's the first change we must make, append `-test` to every container and
    network name in `test-compose/docker-compose.yml`. Everything we'll do with tests
    will run on completely separate containers, hostnames, and networks from those
    of the development instance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个必须做出的更改，在 `test-compose/docker-compose.yml` 中的每个容器和网络名称后添加 `-test`。我们将进行的所有测试都将运行在完全独立的容器、主机名和网络中，与开发实例的完全不同。
- en: This change will affect the `notes-test` and `userauth-test` services because
    the database server hostnames are now `db-auth-test` and `db-notest-test`. There
    are several environment variables or configuration files to update.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改将影响 `notes-test` 和 `userauth-test` 服务，因为数据库服务器的主机名现在是 `db-auth-test` 和 `db-notest-test`。有几个环境变量或配置文件需要更新。
- en: Another consideration is the environment variables required to configure the
    services.  Previously, we defined all environment variables in the Dockerfiles. 
    It's extremely useful to reuse those Dockerfiles so we know we're testing the
    same deployment as is used in production.  But we need to tweak the configuration
    settings to match the test infrastructure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是配置服务所需的环境变量。之前，我们在 Dockerfile 中定义了所有环境变量。重用这些 Dockerfile 非常有用，因为我们知道我们正在测试与生产中使用的相同的部署。但我们需要调整配置设置以匹配测试基础设施。
- en: 'The database configuration shown here is an example. The same Dockerfiles are
    used, but we also define environment variables in `test-compose/docker-compose.yml`.
    As you might expect, this overrides the Dockerfile environment variables with
    the values set here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的数据库配置是一个示例。我们使用相同的 Dockerfile，但我们还在 `test-compose/docker-compose.yml` 中定义了环境变量。正如你所期望的，这会覆盖
    Dockerfile 中的环境变量，使用这里设置的值：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Again, we changed the container and network names to append `-test`. We moved
    some of the environment variables from Dockerfile to `test-compose/docker-compose.yml`.
    Finally, we added some data volumes to mount host directories inside the container.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将容器和网络名称更改为添加 `-test`。我们将一些环境变量从 Dockerfile 移动到 `test-compose/docker-compose.yml`。最后，我们在容器内挂载了一些数据卷。
- en: Another thing to do is to set up directories to store test code. A common practice
    in Node.js projects is to put test code in the same directory as the application
    code. Earlier in this chapter, we did so, implementing a small test suite in the `notes/test`
    directory. As it stands, `notes/Dockerfile` does not copy that directory into
    the container. The test code must exist in the container to execute the tests.
    Another issue is it's helpful to not deploy test code in production.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是要设置目录来存储测试代码。在Node.js项目中，一个常见的做法是将测试代码放在与应用程序代码相同的目录中。在本章的早期，我们就是这样做的，在`notes/test`目录中实现了一个小的测试套件。目前，`notes/Dockerfile`没有将这个目录复制到容器中。测试代码必须存在于容器中才能执行测试。另一个问题是，不部署测试代码在生产环境中是有帮助的。
- en: 'What we can do is to ensure that `test-compose/docker-compose.yml` mounts `notes/test`
    into the container:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保`test-compose/docker-compose.yml`将`notes/test`挂载到容器中：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This gives us the best of both worlds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们得到了两者的最佳结合。
- en: The test code is in `notes/test` where it belongs
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码位于`notes/test`中，这是它应该所在的位置
- en: The test code is not copied into the production container
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码不会被复制到生产容器中
- en: In test mode, the `test` directory appears where it belongs
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试模式下，`test`目录出现在它应该出现的地方
- en: We have a couple of configuration files remaining for the `Sequelize` database
    connection to set up.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些配置文件剩余，用于设置`Sequelize`数据库连接。
- en: 'For the `userauth-test` container, the `SEQUELIZE_CONNECT` variable now refers
    to a configuration file that does not exist, thanks to overriding the variable
    in `user/Dockerfile`. Let''s create that file as `test-compose/userauth/sequelize-docker-mysql.yaml`,
    containing the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`userauth-test`容器，`SEQUELIZE_CONNECT`变量现在指向一个不存在的配置文件，这是由于在`user/Dockerfile`中覆盖了变量。让我们创建该文件，命名为`test-compose/userauth/sequelize-docker-mysql.yaml`，包含以下内容：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The values match the variables passed to the `db-userauth-test` container.
    Then we must ensure this configuration file is mounted into the `userauth-test`
    container:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值与传递给`db-userauth-test`容器的变量相匹配。然后我们必须确保此配置文件被挂载到`userauth-test`容器中：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For `notes-test` we have a configuration file, `test/sequelize-mysql.yaml`,
    to put in the `notes/test` directory:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`notes-test`，我们有一个配置文件，`test/sequelize-mysql.yaml`，需要放入`notes/test`目录：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, this matches the configuration variables in `db-notes-test`. In `test-compose/docker-compose.yml`,
    we mount that file into the container.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这匹配了`db-notes-test`中的配置变量。在`test-compose/docker-compose.yml`中，我们将该文件挂载到容器中。
- en: Executing tests under Docker Compose
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker Compose下执行测试
- en: Now we're ready to execute some of the tests inside a container. We've used
    a Docker Compose file to describe the test environment for the Notes application,
    using the same architecture as in the production environment. The test scripts
    and configuration has been injected into the containers. The question is, how
    do we automate test execution?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好在容器内执行一些测试了。我们使用Docker Compose文件描述了Notes应用程序的测试环境，使用与生产环境相同的架构。测试脚本和配置已注入到容器中。问题是，我们如何自动化测试执行？
- en: The technique we'll use is to run a shell script, and use `docker exec -it` to
    execute commands to run the test scripts. This is somewhat automated, and with
    some more work it can be fully automated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的技术是运行一个shell脚本，并使用`docker exec -it`来执行命令以运行测试脚本。这有点自动化，经过更多的工作，它可以完全自动化。
- en: 'In `test-compose`, let''s make a shell script called `run.sh` (on Windows,
    `run.ps1`):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test-compose`中，让我们创建一个名为`run.sh`的shell脚本（在Windows上为`run.ps1`）：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It's common practice to run tests out of a continuous integration system such
    as Jenkins. Continuous integration systems automatically run builds or tests against
    software products. The build and test results data is used to automatically generate
    status pages.  Visit [https://jenkins.io/index.html](https://jenkins.io/index.html),
    which is a good starting point for a Jenkins job.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续集成系统（如Jenkins）中运行测试是一种常见的做法。持续集成系统会自动对软件产品进行构建或测试。构建和测试结果数据用于自动生成状态页面。访问[https://jenkins.io/index.html](https://jenkins.io/index.html)，这是一个Jenkins作业的良好起点。
- en: That makes the first real step to building the containers, followed by bringing
    them up. The script sleeps for a few seconds to give the containers time to fully
    instantiate themselves.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们构建容器的第一步，然后是启动它们。脚本暂停几秒钟，以便容器有时间完全实例化自己。
- en: The subsequent commands all follow a particular pattern that is important to
    understand. The commands are executed in the `/notesapp/test` directory thanks
    to the `--workdir` option. Remember that directory is injected into the container
    by the Docker Compose file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的所有命令都遵循一个特定的模式，这是需要理解的重要点。由于`--workdir`选项，命令在`/notesapp/test`目录下执行。请记住，该目录是通过Docker
    Compose文件注入到容器中的。
- en: Using `-e DEBUG=` we've disabled the `DEBUG` options. If those options are set,
    we'd have excess unwanted output in the test results, so using this option ensures
    that debugging output doesn't occur.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-e DEBUG=`我们已禁用`DEBUG`选项。如果设置了这些选项，测试结果中会有过多的不必要输出，所以使用此选项确保不会出现调试输出。
- en: Now that you understand the options, you can see that the subsequent commands
    are all executed in the `test` directory using the `package.json` in that directory.
    It starts by running `npm install`, and then running each of the scenarios in
    the test matrix.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了选项，您可以看到后续的所有命令都是在`test`目录下使用该目录中的`package.json`执行的。它首先运行`npm install`，然后运行测试矩阵中的每个场景。
- en: 'To run the tests, simply type:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，只需输入：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That's good, we've got most of our test matrix automated and pretty well squared
    away. There is a glaring hole in the test matrix and plugging that hole will let
    us see how to set up MongoDB under Docker.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经将大部分测试矩阵自动化，并且处理得相当好。测试矩阵中有一个明显的漏洞，填补这个漏洞将让我们看到如何在Docker下设置MongoDB。
- en: MongoDB setup under Docker and testing Notes against MongoDB
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker下设置MongoDB和测试Notes对MongoDB
- en: In Chapter 7,* Data Storage and Retrieval*, we developed MongoDB support for
    Notes, and since then we've focused on `Sequelize`. To make up for that slight,
    let's make sure we at least test our MongoDB support. Testing on MongoDB would
    simply require defining a container for the MongoDB database and a little bit
    of configuration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章*数据存储和检索*中，我们为Notes开发了MongoDB支持，并且从那时起我们一直专注于`Sequelize`。为了弥补这个小小的不足，让我们确保至少测试我们的MongoDB支持。在MongoDB上进行测试只需定义一个MongoDB数据库容器和一点配置。
- en: Visit [https://hub.docker.com/_/mongo/](https://hub.docker.com/_/mongo/) for
    the official MongoDB container. You'll be able to retrofit this to allow deploying
    the Notes application running on MongoDB.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://hub.docker.com/_/mongo/](https://hub.docker.com/_/mongo/)获取官方MongoDB容器。您将能够将其修改为允许部署运行在MongoDB上的Notes应用程序。
- en: 'Add this to `test-compose/docker-compose.yml`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`test-compose/docker-compose.yml`：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That's all that's required to add a MongoDB container to a Docker Compose file.
    We've connected it to `frontnet` so that the `notes` (`notes-test`) container
    can access the service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是添加MongoDB容器到Docker Compose文件所需的所有内容。我们已经将其连接到`frontnet`，以便`notes`（`notes-test`）容器可以访问该服务。
- en: 'Then in `notes/test/package.json` we add a line to facilitate running tests
    on MongoDB:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`notes/test/package.json`中添加一行以方便在MongoDB上运行测试：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Simply by adding the MongoDB container to `frontnet-test`, the database is available
    at the URL shown here. Hence, it's simple to now run the test suite using the
    Notes MongoDB model.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将MongoDB容器添加到`frontnet-test`，数据库就可以通过这里显示的URL访问。因此，现在运行使用Notes MongoDB模型的测试套件变得很简单。
- en: The `--no-timeouts` option was necessary to avoid a spurious error while testing
    the suite against MongoDB. This option instructs Mocha to not check whether a
    test case execution takes too long.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在对MongoDB测试套件进行测试时，使用`--no-timeouts`选项是必要的，以避免出现虚假错误。此选项指示Mocha不要检查测试用例执行是否过长。
- en: 'The final requirement is to add this line in `run.sh` (or `run.ps1` for Windows):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的要求是在`run.sh`（或Windows上的`run.ps1`）中添加这一行：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That, then, ensures MongoDB is tested during every test run.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，就确保了MongoDB在每次测试运行时都会被测试。
- en: 'We can now report to the manager the final test results matrix:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向经理报告最终的测试结果矩阵：
- en: '`models-fs`: PASS'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-fs`：通过'
- en: '`models-memory`: PASS'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-memory`：通过'
- en: '`models-levelup`: PASS'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-levelup`：通过'
- en: '`models-sqlite3`: Two failures, now fixed, PASS'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-sqlite3`：两个失败，现已修复，通过'
- en: '`models-sequelize` with SQLite3: PASS'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-sequelize`与SQLite3：通过'
- en: '`models-sequelize` with MySQL: PASS'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-sequelize`与MySQL：通过'
- en: '`models-mongodb`: PASS'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models-mongodb`：通过'
- en: 'The manager will tell you "good job" and then remember that the Models are
    only a portion of the Notes application. We''ve left two areas completely untested:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 经理会告诉您“做得好”，然后记住模型只是Notes应用程序的一部分。我们留下了两个区域完全未测试：
- en: The REST API for the user authentication service
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户身份验证服务的REST API
- en: Functional testing of the user interface
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面功能测试
- en: Let's get on with those testing areas.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行这些测试区域。
- en: Testing REST backend services
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试REST后端服务
- en: It's now time to turn our attention to the user authentication service. We've
    mentioned tests of this service, saying that we'll get to them later. We had developed
    some scripts for ad hoc testing, which have been useful all along. But later is
    now, and it's time to get cracking on some real tests.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将注意力转向用户认证服务了。我们提到了对这个服务的测试，说我们稍后会讨论。我们开发了一些临时测试脚本，这些脚本一直很有用。但现在“稍后”就是现在，是时候开始进行一些真正的测试了。
- en: There's a question of which tool to use for testing the authentication service.
    Mocha does a good job of organizing a series of test cases, and we should reuse
    it here. But the thing we have to test is a REST service. The customer of this
    service, the Notes application, uses it through the REST API, giving us a perfect
    rationalization to test at the REST interface. Our ad hoc scripts used the SuperAgent
    library to simplify making REST API calls. There happens to be a companion library,
    SuperTest, that is meant for REST API testing. Read its documentation here: [https://www.npmjs.com/package/supertest](https://www.npmjs.com/package/supertest).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试认证服务应该使用哪个工具，这是一个问题。Mocha 在组织一系列测试用例方面做得很好，我们应该在这里重用它。但我们必须测试的是一个 REST 服务。这个服务的客户，即笔记应用，通过
    REST API 使用它，这为我们提供了一个完美的理由在 REST 接口上进行测试。我们使用的临时脚本使用了 SuperAgent 库来简化 REST API
    调用。碰巧有一个配套库，SuperTest，它是专门用于 REST API 测试的。在这里阅读其文档：[https://www.npmjs.com/package/supertest](https://www.npmjs.com/package/supertest)。
- en: 'We''ve already made the `test-compose/userauth` directory. In that directory,
    create a file named `test.js`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `test-compose/userauth` 目录。在该目录中，创建一个名为 `test.js` 的文件：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This sets up Mocha and the SuperTest client. The `URL_USERS_TEST` environment
    variable specifies the base URL of the server to run the test against. You'll
    almost certainly be using `http://localhost:3333` given the configuration we've
    used earlier in the book. SuperTest initializes itself a little differently to
    SuperAgent. The SuperTest module exposes a function that we call with the  `URL_USERS_TEST` environment
    variable, then we use THAT `request` object throughout the rest of the script
    to make REST API requests.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了 Mocha 和 SuperTest 客户端。`URL_USERS_TEST` 环境变量指定了运行测试的服务器的基准 URL。鉴于我们在本书中早期使用的配置，你几乎肯定会使用
    `http://localhost:3333`。SuperTest 与 SuperAgent 的初始化方式略有不同。SuperTest 模块暴露了一个函数，我们使用
    `URL_USERS_TEST` 环境变量调用它，然后在整个脚本中使用那个 `request` 对象来发起 REST API 请求。
- en: 'This variable was already set in `test-compose/docker-compose.yml` with the
    required value. The other thing of importance is a pair of variables to store
    the authentication user ID and key:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量已经在 `test-compose/docker-compose.yml` 中设置，并包含了所需值。另一个重要的事情是一对变量，用于存储认证用户
    ID 和密钥：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you remember, the `beforeEach` function is run immediately before every
    test case, and `afterEach` is run afterward. These functions use the REST API
    to create our test user before running the test, and then afterward to destroy
    the test user. That way our tests can assume this user will exist:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`beforeEach` 函数在每次测试用例之前立即运行，而 `afterEach` 在之后运行。这些函数使用 REST API 在运行测试之前创建我们的测试用户，然后在之后销毁测试用户。这样我们的测试就可以假设这个用户将存在：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we can turn to testing some API methods, such as the `/list` operation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转向测试一些 API 方法，例如 `/list` 操作。
- en: We have already guaranteed that there is an account, in the `beforeEach` method,
    so `/list` should give us an array with one entry.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `beforeEach` 方法中保证了账户的存在，所以 `/list` 应该会给我们一个包含一个条目的数组。
- en: 'This follows the general pattern for using Mocha to test a REST API method.
    First, we use SuperTest''s `request` object to call the API method, and `await`
    its result. Once we have the result, we use `assert` methods to validate it is
    what is expected:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了使用 Mocha 测试 REST API 方法的一般模式。首先，我们使用 SuperTest 的 `request` 对象调用 API 方法，并
    `await` 其结果。一旦我们得到结果，我们使用 `assert` 方法来验证它是否符合预期：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We are checking the `/find` operation in two ways:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在以两种方式检查 `/find` 操作：
- en: Looking for the account we know exists – failure is indicated if the user account
    is not found
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找我们已知存在的账户——如果用户账户未找到，则表示失败
- en: Looking for the one we know does not exist – failure is indicated if we receive
    something other than an error or an empty object
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找我们知道不存在的账户——如果我们收到错误或空对象以外的任何东西，则表示失败
- en: 'Add this test case:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个测试用例：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, we should check the `/destroy` operation. We already check this operation
    in the `afterEach` method, where we `destroy` a known user account. We need to
    also perform the negative test and verify its behavior against an account we know
    does not exist.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该检查 `/destroy` 操作。我们已经在 `afterEach` 方法中检查了这个操作，其中我们 `destroy` 一个已知的用户账户。我们还需要执行负测试并验证其行为与一个我们知道不存在的账户的行为。
- en: The desired behavior is that either an error is thrown, or the result shows
    an HTTP `status` indicating an error. In fact, the current authentication server
    code gives a 500 status code along with some other information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的行为是抛出一个错误，或者结果显示一个表示错误的 HTTP `状态`。实际上，当前的认证服务器代码会返回一个 500 状态码和一些其他信息。
- en: 'In `test-compose/docker-compose.yml`, we need to inject this script, `test.js`,
    into the `userauth-test` container. We''ll add that here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test-compose/docker-compose.yml` 中，我们需要将此脚本 `test.js` 注入到 `userauth-test`
    容器中。我们在这里添加它：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We have a test script, and have injected that script into the desired container
    (`userauth-test`). The next step is to automate running this test. One way is
    to add this to `run.sh` (aka `run.ps1` on Windows):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个测试脚本，并且已经将其注入到所需的容器中（`userauth-test`）。下一步是自动化运行这个测试。一种方法是将此添加到 `run.sh`（在
    Windows 上称为 `run.ps1`）中：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, if you run the `run.sh` test script you'll see the required packages get
    installed, and then this test suite execution.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行 `run.sh` 测试脚本，你会看到所需的包被安装，然后执行这个测试套件。
- en: Automating test results reporting
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试结果报告
- en: It's cool we have automated test execution, and Mocha makes the test results
    look nice with all those check marks. What if the management wants a graph of
    test failure trends over time?  Or there could be any number of reasons to report
    test results as data rather than a user-friendly printout on the console.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有自动化测试执行真是太酷了，Mocha 通过所有那些勾选标记使测试结果看起来很棒。如果管理层想要一个随时间变化的测试失败趋势图呢？或者可能有无数的理由将测试结果作为数据而不是在控制台上友好的打印输出。
- en: Mocha uses what's called a Reporter to report test results. A Mocha Reporter
    is a module that prints data in whatever format it supports. Information is on
    the Mocha website:  [https://mochajs.org/#reporters](https://mochajs.org/#reporters).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 使用所谓的报告器来报告测试结果。Mocha 报告器是一个模块，以它支持的任何格式打印数据。相关信息可以在 Mocha 网站上找到：[https://mochajs.org/#reporters](https://mochajs.org/#reporters)。
- en: 'You will find the current list of available `reporters` like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样找到当前可用的 `reporters` 列表：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then you use a specific `reporter` like so:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用特定的 `reporter` 如下所示：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Test Anything Protocol** (**TAP**) is a widely used test results format,
    increasing the possibility of finding higher level reporting tools. Obviously,
    the next step would be to save the results into a file somewhere, after mounting
    a host directory into the container.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试任何协议**（**TAP**）是一个广泛使用的测试结果格式，增加了找到高级报告工具的可能性。显然，下一步是将结果保存到某个文件中，在将主机目录挂载到容器之后。'
- en: Frontend headless browser testing with Puppeteer
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppeteer 进行前端无头浏览器测试
- en: A big cost area in testing is manual user interface testing. Therefore, a wide
    range of tools have been developed to automate running tests at the HTTP level.
    Selenium is a popular tool implemented in Java, for example. In the Node.js world,
    we have a few interesting choices. The *chai-http* plugin to Chai would let us
    interact at the HTTP level with the Notes application, while staying within the
    now-familiar Chai environment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中的一个大成本领域是手动用户界面测试。因此，已经开发了一系列工具来自动化在 HTTP 层面上运行测试。例如，Selenium 是一个流行的用 Java
    实现的工具。在 Node.js 世界中，我们有几个有趣的选择。Chai 的 *chai-http* 插件允许我们在 Chai 环境中与 Notes 应用程序进行
    HTTP 层面的交互，同时保持熟悉的环境。
- en: However, for this section, we'll use Puppeteer ([https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer)).
    This tool is a high-level Node.js module to control a headless Chrome or Chromium
    browser, using the DevTools protocol. That protocol allows tools to instrument,
    inspect, debug, and profile Chromium or Chrome.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于本节，我们将使用 Puppeteer ([https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer))。这个工具是一个高级
    Node.js 模块，用于通过 DevTools 协议控制无头 Chrome 或 Chromium 浏览器。该协议允许工具对 Chromium 或 Chrome
    进行仪器化、检查、调试和性能分析。
- en: Puppeteer is meant to be a general purpose test automation tool, and has a strong
    feature set for that purpose. Because it's easy to make web page screenshots with
    Puppeteer, it can also be used in a screenshot service.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 旨在成为一个通用的测试自动化工具，并且为此目的拥有强大的功能集。由于 Puppeteer 很容易制作网页截图，它也可以用于截图服务。
- en: Because Puppeteer is controlling a real web browser, your user interface tests
    will be very close to live browser testing without having to hire a human to do
    the work. Because it uses a headless version of Chrome, no visible browser window
    will show on your screen, and tests can be run in the background, instead. A downside
    to this attractive story is that Puppeteer only works against Chrome. Meaning
    that an automated test against Chrome does not test your application against other
    browsers, such as Opera or Firefox.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Puppeteer 控制的是真实的网络浏览器，因此你的用户界面测试将非常接近于实际浏览器测试，无需雇佣人类来完成这项工作。因为它使用的是无头版本的
    Chrome，所以屏幕上不会显示任何可见的浏览器窗口，测试可以在后台运行。然而，这个吸引人的故事的缺点是 Puppeteer 只能在 Chrome 上工作。这意味着针对
    Chrome 的自动化测试并不能测试你的应用程序在其他浏览器上的表现，例如 Opera 或 Firefox。
- en: Setting up Puppeteer
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Puppeteer
- en: 'Let''s first set up the directory and install the packages:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置目录并安装包：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'During installation, you''ll see that Puppeteer causes the download of Chromium
    like so:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，你会看到 Puppeteer 会像这样下载 Chromium：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `puppeteer` module will launch that Chromium instance as needed, managing
    it as a background process, and communicating with it using the DevTools protocol.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppeteer` 模块将根据需要启动那个 Chromium 实例，将其作为后台进程管理，并使用 DevTools 协议与之通信。'
- en: 'In the script we''re about to write, we need a user account that we can use
    to log in and perform some actions. Fortunately, we already have a script to set
    up a test account. In `users/package.json`, add this line to the scripts section:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们即将编写的脚本中，我们需要一个用户账户，我们可以用它来登录并执行一些操作。幸运的是，我们已经有了一个设置测试账户的脚本。在 `users/package.json`
    文件中，在 scripts 部分添加以下行：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''re about to write this test script, but let''s finish the setup, the final
    bit of which is adding these lines to `run.sh`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将编写这个测试脚本，但让我们先完成设置，最后一步是将以下行添加到 `run.sh` 文件中：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When executed, these two lines ensure that the test user is set up, and it then
    runs the user interface tests.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，这两行确保测试用户被设置，然后运行用户界面测试。
- en: Improving testability in the Notes UI
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高 Notes UI 的可测试性
- en: While the Notes application displays well in the browser, how do we write test
    software to distinguish one page from another?  The key requirement is for test
    scripts to inspect the page, determine which page is being displayed, and read
    the data on the page. That means each HTML element must be easily addressable
    using a CSS selector.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Notes 应用程序在浏览器中显示良好时，我们如何编写测试软件来区分不同的页面？关键要求是测试脚本需要检查页面，确定显示的是哪个页面，并读取页面上的数据。这意味着每个
    HTML 元素都必须能够通过 CSS 选择器轻松访问。
- en: While developing the Notes application, we forgot to do that, and the **Software
    Quality Engineering** (**SQE**) manager has requested our assistance. At stake
    is the testing budget, which will be stretched further the more the SQE team can
    automate their tests.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Notes 应用程序时，我们忘记了这一点，而 **软件质量工程** (**SQE**) 经理要求我们提供帮助。这关系到测试预算，而 SQE 团队可以自动化的测试越多，预算就会越紧张。
- en: All that's necessary is to add a few `id` or `class` attributes to HTML elements
    to improve testability. With a few identifiers, and a commitment to maintain those
    identifiers, the SQE team can write repeatable test scripts to validate the application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的只是给 HTML 元素添加一些 `id` 或 `class` 属性来提高可测试性。有了几个标识符，并承诺维护这些标识符，SQE 团队可以编写可重复的测试脚本以验证应用程序。
- en: 'In `notes/partials/header.hbs`, change these lines:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `notes/partials/header.hbs` 文件中，修改以下行：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In `notes/views/index.hbs`, make these changes:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `notes/views/index.hbs` 文件中，进行以下修改：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In `notes/views/login.hbs`, make these changes:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `notes/views/login.hbs` 文件中，进行以下修改：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In `notes/views/notedestroy.hbs`, make these changes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `notes/views/notedestroy.hbs` 文件中，进行以下修改：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In `notes/views/noteedit.hbs`, make these changes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `notes/views/noteedit.hbs` 文件中，进行以下修改：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In `notes/views/noteview.hbs`, make these changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `notes/views/noteview.hbs` 文件中，进行以下修改：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What we've done is add `id=` attributes to selected elements in the templates.
    We can now easily write CSS selectors to address any element. The engineering
    team can also start using these selectors in UI code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是在模板中选定的元素上添加了 `id=` 属性。现在我们可以轻松地编写 CSS 选择器来定位任何元素。工程团队也可以开始在 UI 代码中使用这些选择器。
- en: Puppeteer test script for Notes
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes 的 Puppeteer 测试脚本
- en: 'In `test-compose/notesui`, create a file named `uitest.js` containing the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test-compose/notesui` 目录中，创建一个名为 `uitest.js` 的文件，包含以下内容：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is the start of a Mocha test suite. In the `before` function, we set up
    Puppeteer by launching a Puppeteer instance, starting a new Page object, and telling
    that Page to go to the Notes application home page. That URL is passed in using
    the named environment variable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Mocha 测试套件的开始。在 `before` 函数中，我们通过启动 Puppeteer 实例、创建一个新的 Page 对象，并指示该 Page
    访问笔记应用程序的主页来设置 Puppeteer。该 URL 使用命名环境变量传递。
- en: 'It''s useful to first think about scenarios we might want to verify with the
    Notes applications:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑我们可能想要使用 Notes 应用程序验证的场景是有用的：
- en: Log into the Notes application
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录到 Notes 应用程序
- en: Add a note to the application
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用程序添加笔记
- en: View an added note
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看附加说明
- en: Delete an added note
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除添加的笔记
- en: Log out
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注销
- en: And so on
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等
- en: 'Here''s code for an implementation of the Login scenario:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是登录场景实现的代码：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This test sequence handles the Login Scenario. It shows you a few of the Puppeteer
    API methods. Documentation of the full API is at [https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md).
    The Page object encapsulates the equivalent of a browser tab in Chrome/Chromium.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试序列处理登录场景。它展示了几个 Puppeteer API 方法。完整 API 文档位于 [https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md)。Page
    对象封装了 Chrome/Chromium 中浏览器标签页的等效功能。
- en: The `waitForSelector` function does what it says – it waits until an HTML element
    matching the CSS selector appears, and it will wait over one or more page refreshes.
    There are several variants of this function to allow waiting for several kinds
    of things. This function returns a Promise, making it worth our time to use async
    functions in our test code. The Promise will resolve to an `ElementHandle`, which
    is a wrapper around an HTML element, or else throw an exception, which would conveniently
    make the test fail.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForSelector` 函数如其名所示——它等待匹配 CSS 选择器的 HTML 元素出现，并且它将在一个或多个页面刷新中等待。此函数有几个变体，允许等待多种类型的事物。此函数返回一个
    Promise，这使得在我们的测试代码中使用异步函数变得值得。Promise 将解析为 `ElementHandle`，这是一个围绕 HTML 元素的包装器，或者抛出一个异常，这会方便地使测试失败。'
- en: The named element, `#btnloginlocal`, is in `partials/header.hbs`, and will show
    up only when a user is not logged in. Hence, we will have determined that the
    browser is currently displaying a Notes page, and that it is not logged in.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的元素 `#btnloginlocal` 在 `partials/header.hbs` 中，只有在用户未登录时才会显示。因此，我们可以确定浏览器当前正在显示
    Notes 页面，并且未登录。
- en: The `click` method does what it suggests, and causes a mouse button click on
    the referenced HTML element. If you want to emulate a tap, such as for a mobile
    device, there is a `tap` method for that purpose.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`click` 方法如其所暗示的那样，在引用的 HTML 元素上触发鼠标按钮点击。如果您想模拟触摸，例如用于移动设备，有一个 `tap` 方法用于此目的。'
- en: 'The next stage of the test sequence picks up from that click. The browser should
    have gone to the Login page, and therefore this CSS selector should become valid: 
     `#notesLoginPage #notesLoginForm`. What we do next is type text for our test
    user ID and password into the corresponding form elements, and then click on the
    Log In button.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '测试序列的下一个阶段从点击那里开始。浏览器应该已经跳转到登录页面，因此此 CSS 选择器应该有效：`#notesLoginPage #notesLoginForm`。我们接下来要做的是在相应的表单元素中输入测试用户的用户
    ID 和密码，然后点击登录按钮。'
- en: The next test stage picks up from there, and the browser should be on the home
    page as determined by this CSS selector: `#notesHomePage`. If we were logged in
    successfully, the page should have Log Out (`#btnLogout`) and ADD Note buttons
    (`#btnAddNote`).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试阶段从那里开始，浏览器应该根据此 CSS 选择器位于主页上：`#notesHomePage`。如果我们成功登录，页面应该有注销（`#btnLogout`）和添加笔记按钮（`#btnAddNote`）。
- en: In this case, we've used a different function, `$`, to check if the ADD Note
    button exists. Unlike the `wait` functions, `$` simply queries the current page
    without waiting. If the named CSS Selector is not in the current page, it simply
    returns `null` rather than throwing an exception. Therefore, to determine that
    the element exists, we use `assert.exists` rather than relying on the thrown exception.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了一个不同的函数 `$` 来检查添加笔记按钮是否存在。与 `wait` 函数不同，`$` 仅查询当前页面而不等待。如果命名的 CSS
    选择器不在当前页面中，它将简单地返回 `null` 而不是抛出异常。因此，为了确定元素是否存在，我们使用 `assert.exists` 而不是依赖于抛出的异常。
- en: Running the login scenario
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行登录场景
- en: 'Now that we have one test scenario entered, let''s give it a whirl. In one
    window, start the Notes test infrastructure:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经输入了一个测试场景，让我们试一试。在一个窗口中，启动 Notes 测试基础设施：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then in another window:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在另一个窗口中：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `NOTES_HOME_URL` variable is what the script looks for to direct the Chromium
    browser to use the Notes application. To run the tests, we should use Docker Compose
    to launch the test infrastructure, and then ensure the test user is installed
    in the user database.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOTES_HOME_URL` 变量是脚本查找以指导 Chromium 浏览器使用笔记应用程序的内容。为了运行测试，我们应该使用 Docker Compose
    启动测试基础设施，并确保测试用户已安装到用户数据库中。'
- en: The Add Note scenario
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加备注的场景
- en: 'Add this to `uitest.js`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `uitest.js`：
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is a more involved scenario, in which we:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更复杂的场景，其中我们：
- en: Click on the ADD Note button
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“添加备注”按钮
- en: Wait for the note edit screen to show up
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待备注编辑屏幕出现
- en: Fill in the text for the note and click the Save button
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填写备注的文本并点击“保存”按钮
- en: Validate the note view page to ensure that's correct
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证备注查看页面以确保正确无误
- en: Validate the home page to ensure that's correct.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证主页以确保正确无误。
- en: Most of this is using the same Puppeteer functions as before, but with a couple
    of additions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这大部分是使用与之前相同的 Puppeteer 函数，但增加了一些功能。
- en: The `$eval` function looks for the element matching the CSS selector, and invokes
    the callback function on that element. If no element is found an error is thrown
    instead. As used here, we are retrieving the text from certain elements on the
    screen, and validating that it matches what the test entered as the note. That's
    an end-to-end test of adding and retrieving notes.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`$eval` 函数查找匹配 CSS 选择器的元素，并在该元素上调用回调函数。如果没有找到元素，则会抛出错误。在此处使用时，我们从屏幕上的某些元素中检索文本，并验证它是否与测试输入的备注匹配。这是一个添加和检索备注的端到端测试。'
- en: The next difference is using `goto` instead of clicking on `#btnGoHome`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个区别是使用 `goto` 而不是点击 `#btnGoHome`。
- en: As you add test scenarios to the test script, you'll find it easy for Puppeteer
    to have a spurious timeout, or for the login process to mysteriously not work,
    or other spurious errors.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向测试脚本添加测试场景时，您会发现 Puppeteer 很容易产生虚假的超时，或者登录过程神秘地不起作用，或者出现其他虚假错误。
- en: 'Rather than go over the remaining scenarios, we''ll spend the next section
    discussing how to mitigate such issues. But first we need to prove the scenario
    does work even if we have to run the test 10 times to get this result:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细说明剩余的场景，而是在下一节中讨论如何缓解此类问题。但首先我们需要证明即使我们必须运行测试 10 次才能得到这个结果，该场景仍然有效：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Mitigating/preventing spurious test errors in Puppeteer scripts
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓解/预防 Puppeteer 脚本中的虚假测试错误
- en: The goal is to fully automate the test run, in order to avoid having to hire
    a human to babysit the test execution and spend time rerunning tests because of
    spurious errors. To do so, the tests need to be repeatable without any spurious
    errors. Puppeteer is a complex system – there is a Node.js module communicating
    with a Chromium instance running Headless in the background – and it seems easy
    for timing issues to cause a spurious error.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是完全自动化测试运行，以避免需要雇佣人类来监视测试执行并花费时间重新运行测试，因为虚假错误。为此，测试需要在没有任何虚假错误的情况下可重复。Puppeteer
    是一个复杂的系统——有一个 Node.js 模块与在后台运行的无头 Chromium 实例进行通信——并且似乎时间问题很容易导致虚假错误。
- en: Configuring timeouts
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置超时
- en: 'Both Mocha and Puppeteer allow you to set timeout values, and a long timeout
    value can avoid triggering an error, if some action simply requires a long time
    to run. At the top of the test suite, we used this Mocha function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 和 Puppeteer 都允许您设置超时值，并且一个较长的超时值可以避免触发错误，如果某些操作需要较长时间运行。在测试套件的顶部，我们使用了这个
    Mocha 函数：
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That gives 10 seconds for every test case. If you want to use a longer timeout,
    increase that number.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这为每个测试案例提供了 10 秒的时间。如果您想使用更长的超时，请增加该数值。
- en: The `puppeteer.launch` function can take a timeout value in its options object.
    By default, Puppeteer uses a 30-second timeout on most operations, and they all
    take an options object with a setting to change that timeout period. In this case,
    we've added the `slowMo` option to slow down operations on the browser.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppeteer.launch` 函数可以在其选项对象中接受超时值。默认情况下，Puppeteer 在大多数操作上使用 30 秒的超时，并且它们都带有选项对象，可以更改该超时期间。在这种情况下，我们添加了
    `slowMo` 选项来减慢浏览器上的操作。'
- en: Tracing events on the Page and the Puppeteer instance
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪页面和 Puppeteer 实例上的事件
- en: Another useful tactic is to generate a trace of what happened so you can puzzle
    away. Inserting `console.log` statements is tedious and makes your code look a
    little ugly. Puppeteer offers a couple of methods to trace the actions and to
    dynamically turn off tracing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的策略是生成发生事件的跟踪，这样您就可以进行推理。插入 `console.log` 语句很繁琐，并且会使您的代码看起来有些丑陋。Puppeteer
    提供了一些方法来跟踪操作，并动态地关闭跟踪。
- en: 'In `uitest.js,` add this code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `uitest.js` 中，添加以下代码：
- en: '[PRE62]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: That is, the Page object offers several event listeners in which we can output
    details about various events, including HTTP requests and responses. We can even
    print out the HTML text of the response. The `ignoreURL` function lets us suppress
    a few select URLs so we're not inundated with unimportant requests and responses.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 即，页面对象提供了几个事件监听器，我们可以输出有关各种事件的详细信息，包括 HTTP 请求和响应。我们甚至可以打印出响应的 HTML 文本。`ignoreURL`
    函数让我们抑制一些选定的 URL，这样我们不会收到大量不重要的请求和响应。
- en: You can trace Puppeteer itself using its DEBUG environment variable. See the
    README for more information: [https://github.com/GoogleChrome/puppeteer.](https://github.com/GoogleChrome/puppeteer)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Puppeteer 的 DEBUG 环境变量来跟踪 Puppeteer 本身。更多信息请参阅 README：[https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer)
- en: Inserting pauses
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入暂停
- en: 'It can be useful to insert a long pause at certain points to give the browser
    time to do something. Try this function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些点上插入较长的暂停，以便浏览器有时间执行某些操作是有用的。尝试这个函数：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is how we implement the equivalent of a `sleep` function using Promises.
    Using `setTimeOut` this way, along with a timeout value, simply causes a delay
    for the given number of milliseconds.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用 Promises 实现类似 `sleep` 函数的方法。使用 `setTimeOut` 以这种方式，结合超时值，只是简单地延迟指定的毫秒数。
- en: 'To use this function, simply insert this into the test scenarios:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，只需将其插入到测试场景中：
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A variant on this is to wait for things to fully render in the browser. For
    example, you might have seen a pause before the Home icon in the upper-left corner
    fully renders. That pause can cause spurious errors, and this function can wait
    until that button fully renders itself:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种变体是等待浏览器中内容完全渲染。例如，您可能已经看到在左上角的 Home 图标完全渲染之前有一个暂停。这个暂停可能会引起虚假的错误，而这个函数可以等待该按钮完全渲染：
- en: '[PRE65]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To use it:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它：
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you don't want to maintain this extra function, it's easy enough to add the
    `waitForSelector` call into your test cases instead.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想维护这个额外的函数，将 `waitForSelector` 调用添加到您的测试用例中也很容易。
- en: Avoiding WebSockets conflicts
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免WebSocket冲突
- en: An error, `Cannot find context with specified id undefined`, can be thrown by
    Puppeteer. According to an issue in the Puppeteer issue queue, this can arise
    from unplanned interactions between Puppeteer and WebSockets:  [https://github.com/GoogleChrome/puppeteer/issues/1325](https://github.com/GoogleChrome/puppeteer/issues/1325) 
    This issue in turn affects the Socket.IO support in the Notes application, and
    therefore it may be useful to disable Socket.IO support during test runs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 可能会抛出一个错误，`Cannot find context with specified id undefined`。根据 Puppeteer
    问题队列中的一个问题，这可能是由于 Puppeteer 和 WebSocket 之间的意外交互引起的：[https://github.com/GoogleChrome/puppeteer/issues/1325](https://github.com/GoogleChrome/puppeteer/issues/1325)
    这个问题反过来会影响笔记应用程序中的 Socket.IO 支持，因此，在测试运行期间禁用 Socket.IO 支持可能是有用的。
- en: 'It''s fairly simple to allow disabling of Socket.IO. In `app.mjs,` add this
    exported function:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 允许禁用 Socket.IO 相对简单。在 `app.mjs` 中，添加这个导出的函数：
- en: '[PRE67]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This looks for an environment variable to cause the function to return `true`
    or `false`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会查找环境变量以使函数返回 `true` 或 `false`。
- en: 'In `routes/index.mjs` and `routes/notes.mjs,` add this line:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/index.mjs` 和 `routes/notes.mjs` 中，添加以下行：
- en: '[PRE68]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We do this to import the preceding function. It also demonstrates some of the
    flexibility we get from ES6 Modules, because we can import just the required functions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了导入前面的函数。这也展示了我们从 ES6 模块中获得的一些灵活性，因为我们可以只导入所需的函数。
- en: 'In `routes/index.mjs` and `routes/notes.mjs`, for every router function that
    calls `res.render` to send results, use the `enableSocketio` function as so:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/index.mjs` 和 `routes/notes.mjs` 中，对于每个调用 `res.render` 以发送结果的路由函数，使用
    `enableSocketio` 函数如下：
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Hence, we've imported the function and for every view we pass `enableSocketio`
    as data to the view template.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经导入了该函数，并且对于每个视图，我们将 `enableSocketio` 作为数据传递给视图模板。
- en: 'In `views/index.hbs` and `views/noteview.hbs`, we have a section of JavaScript
    code to implement SocketIO-based semi-real-time features. Surround each such section
    like so:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `views/index.hbs` 和 `views/noteview.hbs` 中，我们有一个 JavaScript 代码段来实现基于 SocketIO
    的半实时功能。像这样包围每个这样的部分：
- en: '[PRE70]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: By eliminating the client-side SocketIO code, we ensure the user interface does
    not open a connection to the SocketIO service. The point of this exercise was
    to avoid using WebSockets to avoid issues with Puppeteer.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消除客户端的 SocketIO 代码，我们确保用户界面不会打开到 SocketIO 服务的连接。这个练习的目的是避免使用 WebSockets，以避免与
    Puppeteer 相关的问题。
- en: 'Similarly, in `views/noteview.hbs` support disabling the Comment button like
    so:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 `views/noteview.hbs` 中，可以这样禁用评论按钮：
- en: '[PRE71]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The final step would be to set the environment variable, `NOTES_DISABLE_SOCKETIO`,
    in the Docker Compose file.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在 Docker Compose 文件中设置环境变量，`NOTES_DISABLE_SOCKETIO`。
- en: Taking screenshots
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获截图
- en: 'One of Puppeteer''s core features is to take screenshots, either as PNG or
    PDF files. In our test scripts, we can take screenshots to track what was on the
    screen at any given time during the test. For example, if the Login scenario spuriously
    fails to log in, we can see that in the screenshots:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 的核心功能之一是捕获截图，可以是 PNG 或 PDF 文件。在我们的测试脚本中，我们可以捕获截图以跟踪测试过程中任何给定时间屏幕上的内容。例如，如果登录场景意外失败，我们可以在截图看到这一点：
- en: '[PRE72]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Simply add code snippets like this throughout your test script. The filename
    shown here follows a convention where the first segment names the test scenario,
    the number is a sequence number within the test scenario, and the last describes
    the step within the test scenario.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试脚本中添加类似这样的代码片段。这里显示的文件名遵循一种约定，其中第一个部分命名测试场景，数字是测试场景内的序列号，最后一个是测试场景内的步骤描述。
- en: Taking screenshots also provides another stage of validation. You may want to
    do visual validation of your application as well. The `pixelmatch` module can
    compare two PNG files, and therefore a set of so-called Golden Images can be maintained
    for comparison during test runs.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获截图也提供了另一阶段的验证。你可能还想对你的应用程序进行视觉验证。`pixelmatch` 模块可以比较两个 PNG 文件，因此可以在测试运行期间维护一组所谓的黄金图像进行比较。
- en: For an example of using Puppeteer this way, see: [https://meowni.ca/posts/2017-puppeteer-tests/](https://meowni.ca/posts/2017-puppeteer-tests/).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用 Puppeteer 的示例，请参阅：[https://meowni.ca/posts/2017-puppeteer-tests/](https://meowni.ca/posts/2017-puppeteer-tests/)。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We''ve covered a lot of territory in this chapter, looking at three distinct
    areas of testing: unit testing, REST API testing, and UI functional tests. Ensuring
    that an application is well tested is an important step on the road to software
    success. A team that does not follow good testing practices is often bogged down
    with fixing regression after regression.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容，探讨了三个不同的测试领域：单元测试、REST API 测试和 UI 功能测试。确保应用程序经过良好测试是通往软件成功之路的重要一步。一个不遵循良好测试实践的团队往往会陷入修复回归问题的困境。
- en: We've talked about the potential simplicity of simply using the assert module
    for testing. While the test frameworks, such as Mocha, provide great features,
    we can go a long way with a simple script.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了仅使用 assert 模块进行测试的潜在简单性。虽然测试框架，如 Mocha，提供了许多功能，但我们可以通过简单的脚本走得很远。
- en: There is a place for test frameworks, such as Mocha, if only to regularize our
    test cases, and to produce test results reports. We used Mocha and Chai for this,
    and these tools were quite successful. We even found a couple of bugs with a small
    test suite.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架，例如 Mocha，有其存在的理由，即使只是为了规范我们的测试用例，并生成测试结果报告。我们使用了 Mocha 和 Chai 来完成这项工作，并且这些工具非常成功。我们甚至通过一个小型的测试套件发现了几处错误。
- en: When starting down the unit testing road, one design consideration is mocking
    out dependencies. But it's not always a good use of our time to replace every
    dependency with a mock version.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始单元测试的道路上，一个设计考虑因素是模拟依赖项。但并不是总是值得花费我们的时间用模拟版本替换每个依赖项。
- en: To ease the administrative burden of running tests, we used Docker to automate
    setting up and tearing down the test infrastructure. Just as Docker was useful
    in automating deployment of the Notes application, it's also useful in automating
    test infrastructure deployment.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻运行测试的管理负担，我们使用了 Docker来自动设置和拆除测试基础设施。正如 Docker 在自动化部署笔记应用程序时很有用一样，它也有助于自动化测试基础设施的部署。
- en: Finally, we were able to test the Notes web user interface in a real web browser.
    We can't trust that unit testing will find every bug; some bugs will only show
    up in the web browser. Even so, we've only touched the beginning of what could
    be tested in Notes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们能够在真实网络浏览器中测试笔记网络用户界面。我们不能相信单元测试会找到每一个错误；一些错误只有在网络浏览器中才会出现。即便如此，我们只是触及了
    Notes 中可能测试的冰山一角。
- en: In this book, we've covered the gamut of Node.js development, giving you a strong
    foundation from which to start developing Node.js applications.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们涵盖了Node.js开发的各个方面，为你提供了一个强大的基础，从这里开始开发Node.js应用程序。
- en: In the next chapter, we'll explore RESTful web services.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨RESTful网络服务。
