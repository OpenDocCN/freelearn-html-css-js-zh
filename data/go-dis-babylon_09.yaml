- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Calculating and Displaying Scoring Results
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算和显示评分结果
- en: Whether a game is implemented as a piece of software or a cut-out piece of cardboard,
    almost all games, regardless of origin or format, feature intrinsic ways to give
    players feedback on their performance throughout a game session. Whether it reflects
    the number of goals scored or the player’s ability to keep a steel ball from dropping
    between bumpers, the scoring process is where a game connects to its players at
    a most visceral level.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论游戏是以软件的形式实现，还是以剪裁的纸板的形式实现，几乎所有的游戏，无论其来源或格式如何，都有内在的方式在游戏过程中向玩家提供关于其表现的反馈。无论是反映进球数还是玩家保持钢球在挡块之间不落下的能力，评分过程是游戏与玩家在最直观层面上连接的地方。
- en: 'In this chapter, we’ll be introducing two new powerful tools for your game
    development toolbox, both completely new to version 5 of Babylon.js: the `src/route-planning/route-plan-gui.js`
    and recall that there is a large amount of boilerplate, typo-prone, and ultimately
    tedious code that needs to be written just to get a bare-bones basic GUI displayed.
    Much of the code involved is of the *make this object that color, and place it
    here* variety, making it more difficult to visualize how components and elements
    will look at runtime. The GUIE allows a developer or designer to separate the
    presentation from the behavioral logic of the application – a concept very familiar
    to most developers! In addition to the GUIE, we’re going to introduce another
    incredibly powerful tool – the coroutine.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍两个新的强大工具，这两个工具都是Babylon.js版本5的新特性：`src/route-planning/route-plan-gui.js`。回想一下，为了仅显示一个基本的GUI，就需要编写大量的样板代码、易出错的代码，以及最终令人厌烦的代码。涉及的代码大多属于“使这个对象变成这种颜色，并放置在这里”的类型，这使得在运行时难以可视化组件和元素的外观。GUIE允许开发人员或设计师将应用程序的表示与行为逻辑分开——这是一个大多数开发者都非常熟悉的概念！除了GUIE之外，我们还将介绍另一个极其强大的工具——协程。
- en: A coroutine behaves and is constructed in a fashion that will be very familiar
    to those who have read the *Space-Truckers – The State Machine* section of [*Chapter
    4*](B17266_04_Final_AM.xhtml#_idTextAnchor070), *Creating the Application*, but
    instead of having the specific purpose of managing our application state, a coroutine
    is built from an arbitrarily defined function generator (see [*Chapter 4*](B17266_04_Final_AM.xhtml#_idTextAnchor070),
    *Creating* *the Application*, for a refresher on `function*` generators in JavaScript)
    and attached to a `BabylonJS.Observable`. Most of the time, this Observable will
    be the Scene’s `onBeforeRenderObservable`, meaning that the coroutine executes
    before every frame, but any Observable can run a coroutine. The behavior of the
    `yield` keyword in conjunction with some other elements that we’ll look at shortly
    makes coroutines a perfect tool to use when a game’s logic needs to span multiple
    rendered frames, a quality we’re going to be using to our advantage to display
    the scoring results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的行为和构建方式对于那些阅读过[*第4章*](B17266_04_Final_AM.xhtml#_idTextAnchor070)，“空间卡车手 -
    状态机”部分的人来说非常熟悉，但与专门用于管理我们的应用程序状态的具体目的不同，协程是由一个任意定义的函数生成器构建的（有关JavaScript中`function`生成器的复习，请参阅[*第4章*](B17266_04_Final_AM.xhtml#_idTextAnchor070)，“创建应用程序”），并将其附加到`BabylonJS.Observable`上。大多数时候，这个Observable将是场景的`onBeforeRenderObservable`，这意味着协程在每一帧之前执行，但任何Observable都可以运行协程。`yield`关键字与我们将很快看到的某些其他元素结合使用的行为使得协程成为在游戏逻辑需要跨越多个渲染帧时使用的完美工具，我们将利用这一特性来显示评分结果。
- en: As part of and in addition to our examinations of the GUIE and coroutines, we’ll
    build out a reusable dialog system that will serve as the base for our Scoring
    Dialog and Results screen before putting score tracking logic into the rest of
    the game. Though this might seem like a backward approach, having the ability
    to display scores first will help us discover what needs to be tracked and calculated
    by the rest of the application. Is there much still that could and should be done?
    Of course! There will always be more to do, but an important skill in software
    development is knowing which things *must* be done versus which things only *need*
    to be done.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对GUIE和协程的考察的一部分，我们将在将评分跟踪逻辑放入游戏的其他部分之前，构建一个可重用的对话框系统，该系统将作为我们的评分对话框和结果屏幕的基础。尽管这可能看起来像是一种倒退的方法，但首先能够显示分数将帮助我们了解应用程序的其他部分需要跟踪和计算什么。还有多少事情可以做，而且应该做？当然！总会有更多的事情要做，但在软件开发中，知道哪些事情*必须*做，以及哪些事情只需要*做*，是一项重要的技能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the Babylon.js GUI Editor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Babylon.js GUI编辑器
- en: Building a Reusable Dialog Box Component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可重用对话框组件
- en: Calculating Scores
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算分数
- en: Creating the Scoring Dialog Using Coroutines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程创建评分对话框
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'There aren’t any new or additional requirements from the software or hardware
    side of things that are needed for this chapter, but there are some topics in
    the Babylon.js documentation or elsewhere that might be handy as we explore some
    of these areas:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，软件或硬件方面没有新的或额外的要求，但在Babylon.js文档或其他地方有一些主题，在我们探索这些领域时可能会很有用：
- en: The Babylon.js 2D GUI system at [https://doc.babylonjs.com/divingDeeper/gui](https://doc.babylonjs.com/divingDeeper/gui)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babylon.js 2D GUI系统在[https://doc.babylonjs.com/divingDeeper/gui](https://doc.babylonjs.com/divingDeeper/gui)
- en: Coroutines (Babylon.js) at [https://doc.babylonjs.com/divingDeeper/events/coroutines](https://doc.babylonjs.com/divingDeeper/events/coroutines)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程（Babylon.js）在[https://doc.babylonjs.com/divingDeeper/events/coroutines](https://doc.babylonjs.com/divingDeeper/events/coroutines)
- en: GUI Editor user’s guide/manual at [https://doc.babylonjs.com/toolsAndResources/tools/guiEditor](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI编辑器用户指南/手册在[https://doc.babylonjs.com/toolsAndResources/tools/guiEditor](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor)
- en: Introducing the Babylon.js GUI Editor
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Babylon.js GUI编辑器
- en: Boilerplate code is a term given to code that has the characteristics of being
    simple, standardized, and frequently repeated. As a software developer, it’s generally
    best not to write that type of code yourself for some very good reasons. First,
    the nature of boilerplate code is that it is repetitive, making it prone to syntax
    or other superficial logical defects (that is, typos, fat-fingers, and more).
    Second, it’s tough to maintain, since when changes need to be introduced, those
    changes are generally needed throughout the expanse of the boilerplate. Finally
    (at least for our purposes), it’s really, really, *really* boring to read and
    write code of this nature.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代码是指具有简单、标准化和经常重复特性的代码。作为软件开发人员，出于一些非常好的原因，通常最好自己不编写这种类型的代码。首先，模板代码的本质是重复的，这使得它容易受到语法或其他表面逻辑缺陷（即，拼写错误、手指粗大等）的影响。其次，维护起来很困难，因为当需要引入更改时，这些更改通常需要在模板代码的整个范围内进行。最后（至少对我们来说），阅读和编写这种类型的代码真的很无聊。
- en: To solve these (and other related) problems, the Babylon.js team created the
    GUIE. As just one of a huge number of new tools and features introduced with v5.0
    of Babylon.js the GUIE fills an important niche in the Babylon.js ecosystem. Like
    its brethren, the Animation Curve Editor, the Node Material Editor, and the Playground,
    the GUIE and its associated snippet server are hosted online at [https://gui.babylonjs.com](https://gui.babylonjs.com)
    and possess similar dual capabilities to work with unique IDs and revisions for
    persistence or directly with JSON files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题（以及其他相关问题），Babylon.js团队创建了GUIE。作为Babylon.js v5.0版本中引入的众多新工具和功能之一，GUIE在Babylon.js生态系统中填补了一个重要的空白。就像它的兄弟一样，动画曲线编辑器、节点材质编辑器和Playground，GUIE及其关联的片段服务器托管在[https://gui.babylonjs.com](https://gui.babylonjs.com)，并且具有类似的双重能力，可以与唯一ID和修订版一起工作以实现持久性，或者直接与JSON文件一起工作。
- en: Important note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'There are two basic kinds of GUIs that Babylon.js supports: 2D and 3D. The
    2D GUI renders to a utility layer using an Advanced Dynamic Texture (see *The
    Advanced Dynamic Texture* section), whereas the 3D GUI system renders meshes on
    a utility layer. The content in this chapter and through much of this book focuses
    mainly on the 2D GUI. However, the 2D and 3D systems have very similar APIs. See
    [https://doc.babylonjs.com/divingDeeper/gui/gui3D](https://doc.babylonjs.com/divingDeeper/gui/gui3D)
    for more on the 3D GUI system.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js支持两种基本的GUI类型：2D和3D。2D GUI使用高级动态纹理（见*高级动态纹理*部分）渲染到实用层，而3D GUI系统在实用层上渲染网格。本章以及本书的大部分内容主要关注2D
    GUI。然而，2D和3D系统具有非常相似的API。有关3D GUI系统的更多信息，请参阅[https://doc.babylonjs.com/divingDeeper/gui/gui3D](https://doc.babylonjs.com/divingDeeper/gui/gui3D)。
- en: Before we start looking at the GUIE’s interface and capabilities, it will be
    useful if we start with either a refresher or a primer on how the Babylon.js GUI
    components operate at the level of the **Advanced Dynamic Texture** (**ADT**).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看GUIE的界面和功能之前，如果我们先从复习或入门开始，了解Babylon.js GUI组件在**高级动态纹理**（**ADT**）层面的工作方式，这将是有用的。
- en: The Advanced Dynamic Texture
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级动态纹理
- en: Throughout this book, we’ve been making use of ADTs and the 2D GUI system, but
    to this point, we haven’t tried to peek inside an ADT and see what it does. To
    do so, let’s peel off the *Advanced* part of the term and focus first on the more
    basic **Dynamic Texture** (**DT**).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们一直在使用 ADT 和 2D GUI 系统，但到目前为止，我们还没有尝试窥视 ADT 的内部，看看它做了什么。要做到这一点，让我们先去掉“高级”这个词的部分，首先关注更基础的**动态纹理**（**DT**）。
- en: A DT is a design-time integration component that exposes the HTML5 Canvas drawing
    API on one end of it; on the other, on the Babylon.js side, it exposes a `BABYLON.DynamicTexture`.
    Because it derives from a regular `BABYLON.Texture`, it is typically rendered
    by assigning the DT to an appropriate Texture slot in a Material. The Playground
    at [https://playground.babylonjs.com/#5ZCGRM#2](https://playground.babylonjs.com/%235ZCGRM%232)
    demonstrates the basics of how this works for drawing simple text, but any Canvas
    API is accessible via the DT’s `getContext` function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: DT 是一个设计时集成组件，在一端暴露了 HTML5 Canvas 绘图 API；在 Babylon.js 一端，它暴露了一个 `BABYLON.DynamicTexture`。因为它派生自常规的
    `BABYLON.Texture`，它通常通过将 DT 分配到材料中适当的纹理槽来渲染。在 [https://playground.babylonjs.com/#5ZCGRM#2](https://playground.babylonjs.com/%235ZCGRM%232)
    的游乐场中演示了如何使用 DT 绘制简单文本的基本原理，但任何 Canvas API 都可以通过 DT 的 `getContext` 函数访问。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See [https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
    to learn more about the Canvas API and its different functions and capabilities,
    and [https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture](https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture)
    to learn more about the BablyonJS DT.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
    了解更多关于画布 API 及其不同功能和能力的信息，以及 [https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture](https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture)
    了解更多关于 BabylonJS DT 的信息。
- en: Accessing the Canvas APIs in this way allows for a huge amount of flexibility
    for developers wishing to render strings or other UI elements but at the cost
    of requiring those same developers to have to manage a large amount of what is
    essentially boilerplate code. Sound familiar? The BABYLON.GUI system is a higher
    layer of abstraction over the Canvas APIs on one end of the integration, and like
    its antecedent **Dynamic Texture**, the **Advanced Dynamic Texture** comprises
    the other.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式访问画布 API 为希望渲染字符串或其他 UI 元素的开发者提供了巨大的灵活性，但代价是要求这些开发者必须管理大量本质上属于模板代码的内容。听起来熟悉吗？Babylon.GUI
    系统是集成一端在画布 API 之上的更高层抽象，就像其前身**动态纹理**一样，**高级动态纹理**构成了另一端。
- en: 'Put one way, an ADT is a **procedural texture** generated and managed by the
    BABYLON.GUI APIs. That’s it. If it feels like this is somewhat of a letdown considering
    how much build-up there’s been to this definition, then you’re in luck because
    the details are far more involved than a simple procedural texture. We can start
    by picturing how an ADT fits into the overall scene and rendering process:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，ADT 是由 Babylon.GUI API 生成和管理的**过程纹理**。就是这样。如果觉得这个定义有些令人失望，考虑到之前的铺垫，那么你很幸运，因为细节要复杂得多，远不止一个简单的过程纹理。我们可以从想象
    ADT 如何融入整体场景和渲染过程开始：
- en: '![Figure 9.1 – The Canvas API and Babylon.js render layers that host a multitude
    of different features, such as the Inspector, Glow Layers, Gizmos, and more](img/Figure_9.01_B17266.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 画布 API 和 Babylon.js 渲染层，它们承载着众多不同的功能，如检查器、发光层、Gizmos 等](img/Figure_9.01_B17266.jpg)'
- en: Figure 9.1 – The Canvas API and Babylon.js render layers that host a multitude
    of different features, such as the Inspector, Glow Layers, Gizmos, and more
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 画布 API 和 Babylon.js 渲染层，它们承载着众多不同的功能，如检查器、发光层、Gizmos 等
- en: If we follow the analogy of an HTML Canvas being like a cloth canvas used for
    painting, a layer is like a distinct coat of paint on the canvas; multiple layers
    overlap and blend to create the whole piece. As with a real-world canvas, the
    order in which pixels (or swatches of paint) are laid down is important to the
    final appearance – whichever color is placed last on the canvas is generally going
    to be the dominant color for that pixel.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 HTML 画布类比为用于绘画的布画布，那么一个层就像画布上的一层独立的油漆；多个层重叠和混合以创建整个作品。正如现实世界的画布一样，像素（或油漆块）放置的顺序对于最终外观很重要——通常情况下，最后放置在画布上的颜色将是该像素的占主导地位的颜色。
- en: The ADT is rendered as one of those layers when created using `AdvancedDynamicTexture.CreateFullScreenUI`,
    with the `isForeground` property of the ADT determining whether its layer is rendered
    in front of all other layers. Crucially, this also means that the ADT can be affected
    by the same sorts of factors that affect other layers (for example, Layer Masks
    and Post-Processes; see [*Chapter 8*](B17266_08_Final_AM.xhtml#_idTextAnchor166),
    *Building the Driving Game*, the *Loading Assets Asynchronously* section for more).
    When a full-screen UI isn’t the right tool for the job, `AdvancedDynamicTexture`
    can be used identically to any texture by creating it using the `AdvancedDynamicTexture.CreateMeshTexture`
    function. This is what we did in [*Chapter 8*](B17266_08_Final_AM.xhtml#_idTextAnchor166),
    *Building the Driving Game*, in the *Making the Minimap* section, so it’s a good
    sign that we’re ready to progress up the ladder to the point where we can start
    using better tools to work with `AdvancedDynamicTexture` regardless of its type.
    In a similar vein, the GUIE will save us enormous amounts of time and effort,
    so let’s take a brief tour and get cranking!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`AdvancedDynamicTexture.CreateFullScreenUI`创建时，ADT被渲染为那些层之一，ADT的`isForeground`属性决定了其层是否在所有其他层之前渲染。关键的是，这也意味着ADT会受到与其他层相同类型因素的影响（例如，层遮罩和后处理；参见[*第8章*](B17266_08_Final_AM.xhtml#_idTextAnchor166)，*构建驾驶游戏*，*异步加载资源*部分了解更多）。当全屏UI不是合适的工具时，可以通过使用`AdvancedDynamicTexture.CreateMeshTexture`函数创建它，就像使用任何纹理一样使用`AdvancedDynamicTexture`。这就是我们在[*第8章*](B17266_08_Final_AM.xhtml#_idTextAnchor166)，*构建驾驶游戏*，*制作迷你地图*部分所做的那样，所以这是一个好兆头，表明我们准备好向更高层次迈进，开始使用更好的工具来处理`AdvancedDynamicTexture`，无论其类型如何。同样，GUIE将为我们节省大量的时间和精力，所以让我们简要地浏览一下，并开始工作吧！
- en: UI Design with the GUIE
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GUIE进行UI设计
- en: As always, the latest documentation on the Babylon.js GUIE can be found at [https://doc.babylonjs.com/toolsAndResources/tools/guiEditor](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor),
    but some basic principles are still worth going over. The top-most horizontal
    menu, featuring the *hamburger* icon, has controls for managing the zoom level,
    copying and pasting controls, and more.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，Babylon.js GUIE的最新文档可以在[https://doc.babylonjs.com/toolsAndResources/tools/guiEditor](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor)找到，但一些基本原理仍然值得回顾。最顶部的水平菜单，带有*汉堡*图标，包含用于管理缩放级别、复制和粘贴控件等功能的控制项。
- en: 'Clicking on empty space in the navigation panel displays the properties for
    the ADT. These are used to render the layout canvas in addition to buttons for
    loading and saving the GUI in various formats. The following screenshot contains,
    from right to left, the different areas of the GUI editor – the navigation tree,
    layout canvas, and property panes, respectively:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航面板的空白区域单击会显示ADT的属性。这些属性除了用于渲染布局画布外，还包括用于以各种格式加载和保存GUI的按钮。以下截图从右到左显示了GUI编辑器的不同区域
    – 导航树、布局画布和属性面板，分别：
- en: '![Figure 9.2 – The GUIE’s three primary workspace areas, from left to right:
    navigation panel, layout canvas, and property pane. The layout shows the currently
    selected layoutGrid container element. Source: https://gui.babylonjs.com/#923BBT#37](img/Figure_9.2_B17866.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – GUIE的三个主要工作区域，从左到右：导航面板、布局画布和属性面板。布局显示了当前选中的layoutGrid容器元素。来源：https://gui.babylonjs.com/#923BBT#37](img/Figure_9.2_B17866.jpg)'
- en: 'Figure 9.2 – The GUIE’s three primary workspace areas, from left to right:
    navigation panel, layout canvas, and property pane. The layout shows the currently
    selected layoutGrid container element. Source: [https://gui.babylonjs.com/#923BBT#37](https://gui.babylonjs.com/%23923BBT%2337)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – GUIE的三个主要工作区域，从左到右：导航面板、布局画布和属性面板。布局显示了当前选中的layoutGrid容器元素。来源：[https://gui.babylonjs.com/#923BBT#37](https://gui.babylonjs.com/%23923BBT%2337)
- en: The control tree can be seen on the left-hand navigation pane, separated from
    the layout canvas by the vertical list of control icons available to insert. Probably
    one of the more important sets of these controls is going to be the various types
    of containers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 控制树可以在左侧的导航面板中看到，与布局画布由可插入的控件图标的垂直列表隔开。这些控件中可能更重要的一组是各种类型的容器。
- en: From **StackPanels** to **Grids** with a sprinkling of **ScrollViewers** and
    **Rectangles** to round things out, the container elements behave exactly as you
    may expect them to if you are accustomed to the concepts. The GUI shown in *Figure
    9.2* is a simple dialog box design, with content broken out into the three separate
    rows of the layoutGrid Grid Control. That control, in turn, is contained within
    the Rectangle dialogBorder, which is contained within the dialogRoot Container
    for the entire UI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从**StackPanels**到**Grids**，再加上一些**ScrollViewers**和**Rectangles**来使布局更加完整，容器元素的行为正如你所期望的那样，如果你习惯了这些概念。图9.2所示的GUI是一个简单的对话框设计，内容被拆分到布局Grid的三个单独的行中。这个控件反过来又包含在Rectangle对话框边框中，而对话框边框又包含在整个UI的dialogRoot容器中。
- en: If you’re not familiar with containers and their behavior, a review of the BJS
    Docs section on containers might be worth a quick (and informative!) read at [https://doc.babylonjs.com/divingDeeper/gui/gui#containers](https://doc.babylonjs.com/divingDeeper/gui/gui#containers).
    Resizing and laying out visual elements can be done by dragging around handles
    in the visual layout pane or by directly setting properties to specific values
    – use the former to get an approximation and the latter to “dial in” to pixel-perfect
    precision!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉容器及其行为，快速阅读BJS文档中关于容器的部分可能值得（并且信息量丰富！）在[https://doc.babylonjs.com/divingDeeper/gui/gui#containers](https://doc.babylonjs.com/divingDeeper/gui/gui#containers)。可以通过在视觉布局面板中拖动处理柄或直接设置特定值来调整和布局视觉元素
    – 使用前者来获得近似值，使用后者来达到像素级的精确度！
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The current list of supported controls and links to their associated documentation
    sections can be found at [https://doc.babylonjs.com/toolsAndResources/tools/guiEditor#supported-controls](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor#supported-controls).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当前支持的控件列表及其相关文档部分的链接可以在[https://doc.babylonjs.com/toolsAndResources/tools/guiEditor#supported-controls](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor#supported-controls)找到。
- en: 'Row indices start at zero, so the middle row is row number one and contains
    the primary content of the dialog. The following diagram illustrates how the layoutGrid’s
    three rows allocate 25%, 50%, and 25% of the available height between them, respectively:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 行索引从零开始，因此中间行是第一行，包含对话框的主要内容。以下图表说明了layoutGrid的三个行如何分别分配25%、50%和25%的可用高度：
- en: '![Figure 9.3 – A simplified view of the layoutGrid and its child controls.
    The top and bottom rows each get 25% of the available height, while the middle
    row is allocated the remaining 50% of the available height at render time'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – layoutGrid及其子控件的简化视图。顶部和底部行各占可用高度的25%，而中间行在渲染时分配剩余的50%可用高度](img/Figure_9.03_B17866.jpg)'
- en: '](img/Figure_9.03_B17866.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 9.3 – A simplified view of the layoutGrid and its child controls. The
    top and bottom rows each get 25% of the available height, while the middle row
    is allocated the remaining 50% of the available height at render time
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – layoutGrid及其子控件的简化视图。顶部和底部行各占可用高度的25%，而中间行在渲染时分配剩余的50%可用高度
- en: Let’s go through the rows in turn. The first row contains the `titleText` control;
    as its name suggests, it is exactly what it seems like it is – a container for
    displaying the dialog’s title heading. The second, middle row contains the primary
    display content and therefore needs the most room for its scroll viewer (to allow
    arbitrarily long or wide child content – a useful quality to note for later…)
    and its own `userCancel` and `userAccept` buttons. These will be hooked up to
    click logic in the next section and will be spaced using relative (percentage)
    positioning to ensure the buttons stick to their respective sides.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次查看每一行。第一行包含`titleText`控件；正如其名称所暗示的，它正是你所期望的那样 – 一个用于显示对话框标题的容器。第二行，中间行包含主要显示内容，因此需要为它的滚动查看器（允许任意长或宽的子内容
    – 这是一个值得注意的有用特性，稍后将会用到）以及它自己的`userCancel`和`userAccept`按钮留出最多的空间。这些按钮将在下一节中与点击逻辑连接，并且将使用相对（百分比）定位来确保按钮保持在它们各自的侧面。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: HTML/CSS folks are probably angrily wondering why we’re not using columns and
    span cells, or a justified alignment with a horizontal StackPanel. Those would
    indeed be wonderful approaches – if cell spanning or full justification alignment
    were available, but as they are not (at the time of writing), alternative approaches
    must be sought!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HTML/CSS开发者可能愤怒地想知道为什么我们不使用列和跨单元格，或者使用水平StackPanel的对齐方式。这些方法确实很棒——如果可用跨单元格或全对齐对齐，但它们目前不可用（在撰写本文时），因此必须寻求替代方法！
- en: 'The final stop on our GUIE tour is less of a feature of the editor and more
    of a very strongly recommended workflow practice of naming the controls in the
    tree:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们GUIE之旅的最后一站与其说是编辑器的功能，不如说是一个强烈推荐的命名工作流程实践，即在树中命名控件：
- en: '![Figure 9.4 – Control tree structure with named controls. Having clear, indicative
    names is crucial to effectively integrating the GUIE with applications. The child
    elements of the layoutGrid Grid container display their respective [row:column]
    indices in the tree'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 命名控件的控件树结构。拥有清晰、指示性的名称对于有效地将GUIE与应用程序集成至关重要。布局网格容器中的子元素在树中显示它们各自的[row:column]索引'
- en: '](img/Figure_9.4_B17866.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B17866.jpg)'
- en: Figure 9.4 – Control tree structure with named controls. Having clear, indicative
    names is crucial to effectively integrating the GUIE with applications. The child
    elements of the layoutGrid Grid container display their respective [row:column]
    indices in the tree
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 命名控件的控件树结构。拥有清晰、指示性的名称对于有效地将GUIE与应用程序集成至关重要。布局网格容器中的子元素在树中显示它们各自的[row:column]索引
- en: If you have read a certain type of genre fantasy, then you will know that having
    the name of something gives one power over the thing being named, and our GUI
    control tree is no different! Our integration pattern for combining the GUI definition
    with JavaScript logic will hinge on using the power of a control’s name to summon
    it forth when needed, but instead of relying on magic spells and summoning circles,
    we’ll see how to use `Control.findByName` as part of the tidy integration options
    made possible by features in both the Babylon.js GUI and its core framework!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读过某种类型的奇幻体裁，那么你就会知道，拥有某物的名称赋予了对该物的控制力，我们的GUI控件树也不例外！我们将GUI定义与JavaScript逻辑结合的集成模式将依赖于使用控件名称的权力在需要时召唤它，但我们将看到如何使用`Control.findByName`作为Babylon.js
    GUI及其核心框架中功能提供的整洁集成选项的一部分！
- en: Integration with the GUIE
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与GUIE的集成
- en: It’s time to move past the GUIE and see how we can make use of its output in
    a simple Playground setting. The Playground at https://playground.babylonjs.com/#WIVN8Z#6
    is what we’ll be using as the starting point for this section; we’ll build it
    out and finish it up in the next section; that is, *Building a Reusable Dialog
    Box Component*. For now, let’s run the Playground and click or tap anywhere in
    the display area to summon a Dialog Box. Clicking one of the buttons will either
    dismiss or spawn a new dialog box, depending on which is clicked.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候超越GUIE，看看我们如何在简单的Playground设置中利用其输出了。位于https://playground.babylonjs.com/#WIVN8Z#6的Playground将是我们本节的开端；我们将在下一节中构建并完成它；也就是说，*构建可重用对话框组件*。现在，让我们运行Playground，并在显示区域中的任何地方点击或轻触以召唤一个对话框。点击其中一个按钮将关闭或生成一个新的对话框，具体取决于点击的是哪个。
- en: Now, let’s focus on the `createScene` function. It’s very short – under 40 lines
    of code, with most of the code devoted to subscribing to various Observables of
    the `DialogBox` component and the scene’s `onPointerObservable`. Defining the
    initial dialog `opts` object and creating the `DialogBox` instance rounds out
    the scene creation logic of our Playground, leaving us free to focus our attention
    on how to convert the `const DIALOG_GUI_SNIPPET = "923BBT#32"` line into an interactive
    component, bringing us one step closer to seeing how `DialogBox` works.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于`createScene`函数。它非常简短——少于40行代码，其中大部分代码用于订阅`DialogBox`组件和场景的`onPointerObservable`的各种Observables。定义初始对话框`opts`对象并创建`DialogBox`实例，完成了我们的Playground的场景创建逻辑，使我们能够专注于如何将`const
    DIALOG_GUI_SNIPPET = "923BBT#32"`这一行转换为交互式组件，使我们更接近了解`DialogBox`的工作原理。
- en: 'Right above the `DialogBox` class definition – line 60 – is where the `CONTROL_NAMES`
    constant is defined:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DialogBox`类定义的正上方——第60行——定义了`CONTROL_NAMES`常量：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Recall when we mentioned the importance of names. This is where that discussion
    becomes important! It also becomes the only place in our code that needs to know
    anything specific about how our GUI is structured, allowing us to modify our GUI
    to a certain extent without the need to make corresponding changes to our application
    code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们提到名称的重要性。这就是那个讨论变得重要的地方！它也成为了我们代码中唯一需要了解我们 GUI 结构具体信息的部分，这使得我们可以在一定程度上修改我们的
    GUI，而无需对应用程序代码进行相应的更改。
- en: 'OK – now, we have a map of control names that we can use to access controls
    via code, but we haven’t loaded up anything for our code to access yet. We’ll
    need to create an instance of an `AdvancedDynamicTexture` – fullscreen mode is
    fine – and we also want to make sure that the text and lines are crisp and sharp
    at whatever size it ends up being rendered:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——现在，我们有一个可以用来通过代码访问控件的控件名称映射，但我们还没有加载任何内容供我们的代码访问。我们需要创建一个 `AdvancedDynamicTexture`
    的实例——全屏模式是可以的——并且我们还想确保文本和线条在最终渲染的任何大小上都是清晰和锐利的：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using `NEAREST_NEAREST` as the sampling method when scaling the texture gives
    the best results for text while the `true` flag for the last parameter enables
    adaptive scaling for a nice look whatever the scale. Now that we have something
    to host the GUI, it’s time to go ahead and load said GUI into the ADT.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在缩放纹理时使用 `NEAREST_NEAREST` 作为采样方法可以获得最佳文本效果，而最后一个参数的 `true` 标志则启用自适应缩放，以获得无论缩放如何都看起来很好的效果。现在我们已经有了可以托管
    GUI 的东西，是时候将此 GUI 加载到 ADT 中了。
- en: 'Because we want to use `DIALOG_GUI_SNIPPET` as the source to load our GUI from,
    we’ll need to use the `parseFromSnippetAsync` method from an instance of `AdvancedDynamicTexture`.
    Since the function is asynchronous, this means we can await its completion from
    an appropriately marked `async` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想将 `DIALOG_GUI_SNIPPET` 作为源来加载我们的 GUI，所以我们需要使用 `AdvancedDynamicTexture`
    实例中的 `parseFromSnippetAsync` 方法。由于该函数是异步的，这意味着我们可以从适当标记的 `async` 函数中等待其完成：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once `advancedTexture` has completed loading the GUI definition from the snippet
    server (and, in the preceding case, opting out of rescaling the texture), it can
    be accessed from `advancedTexture.getControlByName()`. To avoid repetition in
    our code, we can define property accessors in a class or object to wrap the logic
    for getting or setting these control values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `advancedTexture` 从片段服务器完成加载 GUI 定义（并且在前面的情况下，选择不重新缩放纹理），它就可以通过 `advancedTexture.getControlByName()`
    访问。为了避免代码中的重复，我们可以在类或对象中定义属性访问器来封装获取或设置这些控件值的逻辑：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, there are two examples of retrieving a control, as well
    as a control’s text value. Additionally, the final property shows a similar process
    for setting the text value of the `titleText` control. These property accessors
    and others like them form a core part of the `DialogBox` class, which is the topic
    of the next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有两个获取控件的示例，以及一个控件文本值的示例。此外，最后一个属性显示了设置 `titleText` 控件的文本值的类似过程。这些属性访问器和类似的其他组件构成了
    `DialogBox` 类的核心部分，这是下一节的主题。
- en: The `AdvancedDynamicTexture.getControlByName`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdvancedDynamicTexture.getControlByName`。'
- en: Now, using this combination of tools, data, and code, it’s time to put theory
    into practice. We need an easier way to implement the concept of a dialog box
    in our application, and there are at least two places that need dialog box functionality
    – route confirmation and scoring. This problem speaks to the need to build something
    once that can be used in multiple situations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个工具、数据和代码的组合，是时候将理论付诸实践了。我们需要一种更简单的方法来实现对话框的概念，在我们的应用程序中至少有两个地方需要对话框功能——路线确认和评分。这个问题说明了需要构建一次可以使用在多种情况下的东西。
- en: Building a Reusable Dialog Box Component
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可重用对话框组件
- en: A reusable component is capable of utilization in multiple places and contexts
    within a particular code base. Designing a reusable component is different from
    designing a single-purpose one in several ways. The most relevant one of these
    ways is that the reusable component’s functionality must be designed to be customizable
    by users without the basic code needing to be reinvented for it to be worked with.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可重用组件能够在特定代码库的多个位置和上下文中使用。设计一个可重用组件与设计一个单一用途组件在几个方面有所不同。其中最相关的一点是，可重用组件的功能必须设计成用户可定制的，而无需为使用它而重新编写基本代码。
- en: We examined parts of `DialogBox` previously when we looked at how to wrap `advancedTexture.getControlByName`
    in a get or set accessor, so let’s build off that to make an important reminder/note.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看如何将 `advancedTexture.getControlByName` 包装在获取或设置访问器中时，我们已经检查了 `DialogBox`
    的某些部分，因此让我们在此基础上制作一个重要的提醒/笔记。
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `CONTROL_NAMES` enumeration lists all the properties implemented by the
    `DialogBox` class, but there are more properties than there are controls. Getting
    or setting a property such as `titleText` or `bodyText` operates against a text
    control’s `text` property directly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONTROL_NAMES` 枚举列出了 `DialogBox` 类实现的全部属性，但属性的数量多于控件的数量。获取或设置如 `titleText`
    或 `bodyText` 这样的属性是直接操作文本控件的 `text` 属性。'
- en: The key parts of our component are going to be the initialization (construction)
    logic, which is important because it needs to parse the GUI data, entrance, and
    exit management, and event handling things such as button clicks. After examining
    how each of these works, we’ll put the individual pieces together to build the
    route confirmation dialog prompt.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件的关键部分将是初始化（构造）逻辑，这很重要，因为它需要解析GUI数据、入口和退出管理，以及处理按钮点击等事件。在检查了这些功能的运作方式之后，我们将把这些单独的部分组合起来，以构建路线确认对话框提示。
- en: Constructing the DialogBox Class
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建DialogBox类
- en: 'The constructor function for the `DialogBox` class accepts an options object
    and a Scene instance as its two parameters. These parameters are mostly for pre-populating
    the dialog box’s content, but the `displayOnLoad` parameter is a behavioral flag
    that instead controls whether or not `DialogBox` is supposed to be visible when
    it’s finished loading and initializing. When the value is `false`, then the `show()`
    method must be explicitly invoked to display the dialog:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogBox` 类的构造函数接受一个选项对象和一个场景实例作为其两个参数。这些参数主要用于预先填充对话框的内容，但 `displayOnLoad`
    参数是一个行为标志，它控制 `DialogBox` 在加载和初始化完成后是否应该可见。当值为 `false` 时，必须显式调用 `show()` 方法来显示对话框：'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The constructor logic ensures that the dialog box will have any required pieces
    of content populated, even if they’re not specified by the caller. Previously,
    we looked at the creation of `AdvancedDynamicTexture`, along with how to populate
    the GUI elements using `parseFromSnippetAsync`. This is a pattern that we’re using
    for the Playground to load from the snippet server. For the application, we will
    load a JSON file defining the UI using `advancedTexture.parseContent()` – a non-async
    method that also obviates the need to run the initialization logic in the callback
    from `scene.executeWhenReady`, which we used in the Playground. This is the only
    meaningful difference between our Playground’s `DialogBox` class and what will
    eventually end up in the Space-Truckers Application. This highlights the power
    of iterative code design using the PG!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数逻辑确保对话框将包含任何必需的内容，即使它们没有被调用者指定。之前，我们查看 `AdvancedDynamicTexture` 的创建，以及如何使用
    `parseFromSnippetAsync` 填充GUI元素。这是我们用于Playground从片段服务器加载的模式。对于应用程序，我们将使用 `advancedTexture.parseContent()`
    加载定义UI的JSON文件——这是一个非异步方法，它还消除了在 `scene.executeWhenReady` 的回调中运行初始化逻辑的需要，我们在Playground中使用了它。这是我们Playground的
    `DialogBox` 类和最终将出现在 Space-Truckers 应用程序中的唯一有意义的区别。这突出了使用PG进行迭代代码设计的强大功能！
- en: 'The rest of the constructor is devoted to subscribing to and wiring the subcomponents
    of the `DialogBox` class. Our two buttons have their click event handlers wrapped
    by the class and the respective `onAcceptedObservable` and `onCancelledObservable`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的其余部分致力于订阅和连接 `DialogBox` 类的子组件。我们的两个按钮的点击事件处理程序被类包装，并且分别由 `onAcceptedObservable`
    和 `onCancelledObservable` 处理：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To avoid leaking resources, we are capturing the Observers that have been returned
    from the subscription methods in non-public class members (denoted with the `#`
    prefix), which we clean up in the `dispose` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免资源泄露，我们在非公共类成员（用 `#` 前缀表示）中捕获了从订阅方法返回的观察者，并在 `dispose` 方法中进行清理：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Any ongoing asynchronous operations must be canceled along, with any coroutines
    (see the *Creating the Scoring Dialog with Coroutines* section for a definition).
    The `createScene` function of our Playground demonstrates how this works when
    the initial confirmation `DialogBox` is disposed of in the `onAccept` handler,
    spawning a new `DialogBox` in its place.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 任何正在进行的异步操作都必须取消，包括任何协程（有关协程的定义，请参见 *使用协程创建评分对话框* 部分）。我们的游乐场中的 `createScene`
    函数演示了当初始确认 `DialogBox` 在 `onAccept` 处理程序中被销毁时，如何实现这一点，其位置被新的 `DialogBox` 替换。
- en: 'Our basic `DialogBox` defines two explicit interaction points with users: the
    accept and cancel buttons. It also defines two behaviors: show and hide. Next,
    we’ll learn how the two relate to each other and how to make the show and hide
    methods complete only after the `DialogBox` class has finished transitioning.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本 `DialogBox` 定义了与用户交互的两个显式交互点：接受和取消按钮。它还定义了两种行为：显示和隐藏。接下来，我们将学习这两个是如何相互关联的，以及如何确保显示和隐藏方法仅在
    `DialogBox` 类完成转换后完成。
- en: Handling Button Clicks and Changing Visibility
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理按钮点击和更改可见性
- en: 'In addition to handling the `acceptButton` and `cancelButton` click events,
    the `onAccepted` and `onCancelled` functions both offer customizers for the `DialogBox`
    class to run custom logic before notifying external observers of the event – the
    default behavior shows this by hiding the dialog before triggering the Observable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理 `acceptButton` 和 `cancelButton` 的点击事件外，`onAccepted` 和 `onCancelled` 函数还为
    `DialogBox` 类提供了自定义器，以便在通知外部观察者事件之前运行自定义逻辑——默认行为通过在触发 Observable 之前隐藏对话框来显示这一点。
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both `onAccepted` and `OnCancelled` return a `Promise` that resolves when the
    dialog box has finished hiding itself. If the caller cares about waiting for the
    dialog to fully show or hide itself, it can either use the standard async or Promise
    resolution patterns – that is, `await myDialog.show()` or `myDialog.hide().then(…)`.
    As for the logic to show or hide `DialogBox`, it uses the `BABYLON.setAndStartTimer`
    utility function to trigger the fade-in or fade-out of the `DialogBox` class in
    conjunction with the `Scalar.SmoothStep` function (note that some code has been
    elided in the following listing for space reasons):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAccepted` 和 `OnCancelled` 都返回一个 `Promise`，当对话框完成隐藏时解决。如果调用者关心等待对话框完全显示或隐藏，可以使用标准的异步或
    Promise 解决模式——即 `await myDialog.show()` 或 `myDialog.hide().then(…)`。至于显示或隐藏 `DialogBox`
    的逻辑，它使用 `BABYLON.setAndStartTimer` 工具函数与 `Scalar.SmoothStep` 函数一起触发 `DialogBox`
    类的淡入或淡出（注意，由于空间原因，以下列表中省略了一些代码）：'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, most of the action happens in the `onTick` and `onEnded`
    callbacks of the `setAndStartTimer` option. The dialog starts with an alpha of
    `1` and ends after a period of `#fadeInTransitionDurationMs` (800 ms or so) with
    an alpha of `0`. In between, values are interpolated using the `onTick` argument’s
    `completeRate`, giving a value from `0` to `1` regarding how far the timer has
    progressed to finishing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，大部分动作发生在 `setAndStartTimer` 选项的 `onTick` 和 `onEnded` 回调中。对话框以不透明度 `1`
    开始，并在经过一段时间的 `#fadeInTransitionDurationMs`（大约 800 毫秒）后以不透明度 `0` 结束。在此期间，使用 `onTick`
    参数的 `completeRate` 进行插值，给出一个从 `0` 到 `1` 的值，表示计时器完成进度的距离。
- en: The `onEnded` callback removes the `DialogBox` class from foreground rendering
    (see *The Advanced Dynamic Texture* section, earlier in this chapter) and sets
    the GUI’s `isVisible` to `false` before resolving the original Promise. On the
    other hand, `breakCondition` ensures that if the `DialogBox` instance is disposed
    of before completing the hide or show animation, the timer won’t attempt to call
    disposed of objects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEnded` 回调将 `DialogBox` 类从前景渲染中移除（参见本章前面的 *高级动态纹理* 部分），并在解决原始 Promise 之前将
    GUI 的 `isVisible` 设置为 `false`。另一方面，`breakCondition` 确保如果 `DialogBox` 实例在完成隐藏或显示动画之前被销毁，计时器不会尝试调用已销毁的对象。'
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `show()` function is almost identical to the `hide()` function, except that
    it is more like a mirror inverse image than it is a clone. This is because it
    starts as being fully transparent and ends up being completely hidden.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`show()` 函数几乎与 `hide()` 函数相同，但它更像是一个镜像反转图像，而不是一个克隆。这是因为它从完全透明开始，最终完全隐藏。'
- en: 'Let’s review how to use the `DialogBox` class in five easy steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何使用 `DialogBox` 类的五个简单步骤：
- en: 'Create an `opts` object containing, at a minimum, a `guiData` field containing
    a snippet ID:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含至少一个 `guiData` 字段的 `opts` 对象，其中包含一个片段 ID：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instantiate a new instance of `DialogBox`, passing in the previously created
    `opts` object and a reference to the Scene:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个新的 `DialogBox` 实例，传入之前创建的 `opts` 对象和场景的引用：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Attach observers to the dialog box’s `onAcceptedObservable` and `onCancelledObservable`
    to respond to user input (in this case, calling `createScoringDialog`):'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将观察者附加到对话框的 `onAcceptedObservable` 和 `onCancelledObservable` 以响应用户输入（在这种情况下，调用
    `createScoringDialog`）：
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Call the `show` method to display the `DialogBox` class if the (optional) `displayOnLoad`
    flag is not set to `true`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果（可选的）`displayOnLoad` 标志未设置为 `true`，则调用 `show` 方法以显示 `DialogBox` 类：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To dismiss or hide the dialog, click `cancelButton` or call the `hide()` function.
    To defer action until the `DialogBox` class has completely faded out, the Promise
    that’s returned from `hide` can be awaited:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要取消或隐藏对话框，请点击 `cancelButton` 或调用 `hide()` 函数。要延迟操作直到 `DialogBox` 类完全淡出，可以等待从
    `hide` 返回的 Promise：
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With our reusable `DialogBox` completed in proof-of-concept form, let’s quickly
    look at the practice of integrating with the Space-Truckers Application by looking
    at how the route planning screen uses it to prompt the player to move to the next
    phase of gameplay.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的可重用 `DialogBox` 完成概念验证形式后，让我们快速看一下如何通过查看路线规划屏幕如何使用它来提示玩家进入游戏玩法下一阶段，来了解与
    Space-Truckers 应用程序集成的实践。
- en: Prompting Users after Successful Route Planning
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在成功规划路线后提示用户
- en: Not too many changes need to be made to the `DialogBox` class from the Playground.
    However, as mentioned in the *Constructing the DialogBox Class* section, we’ll
    be changing from using a snippet loaded from a remote server to a JSON file loaded
    from the game’s assets folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从游乐场对 `DialogBox` 类的更改不需要太多。然而，如 *构建 DialogBox 类* 部分所述，我们将从使用从远程服务器加载的片段切换到从游戏资源文件夹加载的
    JSON 文件。
- en: 'After saving the GUI JSON definition from the GUIE, the definition is added
    to the `/src/guis` folder as `gui-dialog-buttons-scroll.json`. One important change
    is needed, though, so open up the file and find any external resources (*`.png`)
    to change their URLs from absolute to relative ones pointing to the appropriate
    file in the `assets` folder. For example, the image that’s used as the `DialogBox`
    background will look like this after being modified:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GUIE 保存 GUI JSON 定义后，定义被添加到 `/src/guis` 文件夹中的 `gui-dialog-buttons-scroll.json`。不过，需要做一个重要的更改，所以打开文件并找到任何外部资源（*`.png`），将它们的
    URL 从绝对路径更改为指向 `assets` 文件夹中适当文件的相对路径。例如，用作 `DialogBox` 背景的图像在修改后看起来会是这样：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `DialogBox` class itself is housed next door to the GUI JSON, in `guiDialog.js`,
    and as per our change from the snippet server to JSON, we must add that import
    to the top of the file before passing it into the `DialogBox` constructor as the
    `guiData` property value:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogBox` 类本身位于 GUI JSON 旁边，在 `guiDialog.js` 文件中，并且根据我们从片段服务器切换到 JSON 的变更，我们必须在将
    `guiData` 属性值传递给 `DialogBox` 构造函数之前，将此导入添加到文件顶部：'
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Pivoting to `SpaceTruckerPlanningScreen`, we need to add an `import` for `DialogBox`
    to the file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 `SpaceTruckerPlanningScreen`，我们需要在文件中添加对 `DialogBox` 的 `import`：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A new `routeConfirmationDialog` attribute has been added to `SpaceTruckerPlanningScreen`,
    initialized near the end of the constructor function with logic that should be
    very familiar if you have read the entirety of this chapter thus far:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpaceTruckerPlanningScreen` 已添加一个新的 `routeConfirmationDialog` 属性，在构造函数的末尾初始化，其中包含的逻辑如果你已经阅读了本章的全部内容，应该非常熟悉：'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, there is no doubt that the actual copy used in the confirmation dialog
    box could use some work, but it does the job for now – maybe you’ll be the one
    to submit a Pull Request to change it to something a bit more interesting?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，毫无疑问，实际用于确认对话框中的复制品可能需要一些改进，但至少目前它能完成任务——也许你会是那个提交拉取请求将其改为更有趣内容的人？
- en: On the topic of interesting, the `onAcceptedObservable` handler for the dialog
    does several interesting things. First, it notifies any interested parties that
    the player has accepted the route. Then, it updates `gameState` to reflect the
    new reality before hiding `routeConfirmationDialog` and allowing whatever logic
    is subscribed to `routeAcceptedObservable` to take things from that point. This
    is not too different from the Playground example, and not too much time is needed
    to get that up and running either! We’ll want to hold onto that feeling for now
    though because next, we’re going to be making a series of targeted changes to
    the application to gather, process, and calculate scoring data for the game.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在有趣的话题上，对话框的`onAcceptedObservable`处理程序做了几件有趣的事情。首先，它通知任何感兴趣的各方玩家已经接受了路线。然后，它更新`gameState`以反映新的现实，在隐藏`routeConfirmationDialog`并允许订阅`routeAcceptedObservable`的任何逻辑从该点开始处理之前。这与Playground示例没有太大不同，而且也不需要太多时间就能启动！但我们现在想保留这种感觉，因为接下来，我们将对应用程序进行一系列有针对性的更改，以收集、处理和计算游戏得分数据。
- en: Calculating Scores
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算得分
- en: Much of the fun that comes from playing a game is through the different ways
    that a game can provide feedback to the player – positive or negative. This is
    a great opportunity for game designers to connect with players at an emotional
    level. Connecting positive events and outcomes to a player’s actions creates a
    feedback loop between the game and the player, and one of the oldest and truest
    connections in gaming is the concept of a point score that accumulates throughout
    gameplay.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从玩游戏中获得的大部分乐趣来自于游戏可以以不同方式向玩家提供反馈——积极的或消极的。这是游戏设计师与玩家在情感层面上建立联系的大好机会。将积极的事件和结果与玩家的行为联系起来，在游戏和玩家之间创建了一个反馈循环，而在游戏中最古老、最真实的关系之一就是积分累积的概念。
- en: The scoring system used in `DialogBox` that is initially empty, but which displays
    each category of scores in a line-by-line fashion before giving the final score.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DialogBox`中使用的评分系统最初是空的，但在给出最终得分之前，它会逐行显示每个类别的得分。
- en: Before building out the logic to capture and calculate scores, it’s useful to
    define the desired scoring data model in a sample score. This is the desired output
    of the scoring process logic, irrespective of how that logic generates the data.
    This will clue us into what sorts of changes are needed elsewhere in the application
    to support the scoring system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建捕获和计算得分的逻辑之前，定义一个示例得分中的所需得分数据模型是有用的。这是评分过程逻辑的期望输出，无论该逻辑如何生成数据。这将让我们了解在应用程序的其他地方需要做出哪些更改以支持评分系统。
- en: Scoring System Design
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 得分系统设计
- en: 'The score data that is generated and used by **Space-Truckers** can be broken
    down into three broad groups: **score factors**, **multipliers**, and **final
    scores**. Score factors are categories reflecting base attributes of both route
    planning and driving performance. The number of encounters, length of the route,
    and initial launch force are all fixed and set in the Route Planning Phase, but
    the cargo condition is dynamic up until the player reaches their destination in
    the driving phase (sample values have been provided for context):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由**Space-Truckers**生成并使用的得分数据可以分为三大类：**得分因素**、**乘数**和**最终得分**。得分因素是反映路线规划和驾驶性能基本属性的类别。遭遇次数、路线长度和初始发射力都是在路线规划阶段固定并设置的，但在驾驶阶段（直到玩家到达目的地）货物的状况是动态的（为了提供背景，已提供了一些示例值）：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Below `scoreFactors` are the multipliers. These values are used by the scoring
    calculations to modify one or more `scoreFactors` in various ways that we’ll get
    into in the next section, *Adding Up and Tallying Scores*. However, before we
    move on, there’s just one more thing to do. One last – you may even say final
    – section to cover. `finalScores` are the categorized and summed up values that
    come out of the combination of `scoreFactor` and multipliers. This is what will
    ultimately be displayed to the players in a “here’s the bottom line…” type of
    fashion.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`scoreFactors`是乘数。这些值被用于评分计算，以各种方式修改一个或多个`scoreFactors`，我们将在下一节“累加和统计分数”中详细介绍。然而，在我们继续之前，还有一件事要做。最后一个——你甚至可以说是一个最终——部分要涵盖。`finalScores`是从`scoreFactor`和乘数组合中得出的分类和汇总的值。这就是最终将以“这里是底线……”这样的方式显示给玩家的内容。
- en: Continuing to ignore any sort of details on how the scoring data is captured
    is still a useful tactic because although we may know the general shape of the
    scoring data, until we know how to calculate those scores, we won’t know precisely
    what and where data needs to be captured.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略任何关于如何捕获评分数据的细节仍然是一种有用的策略，因为尽管我们可能知道评分数据的一般形状，但直到我们知道如何计算这些分数，我们不会确切知道需要捕获哪些数据和位置。
- en: Adding Up and Tallying Scores
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 累加和统计分数
- en: 'The scoring logic is contained within the `src/scoring/spaceTruckerScoreManager.js`
    file. Similar to how we are compartmentalizing using the sample score shown previously,
    consumers of this component only need to call the default export `computeScores`
    and pass in a route data structure to get a `score` object in return. The `computeScores`
    function is a simple orchestration function – its only purpose is to coordinate
    the invocation of the various other functions that are calculating the individual
    scoring areas:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 评分逻辑包含在 `src/scoring/spaceTruckerScoreManager.js` 文件中。类似于我们之前使用示例评分进行隔间化的方式，使用此组件的消费者只需要调用默认导出
    `computeScores` 并传入一个路由数据结构，就可以返回一个 `score` 对象。`computeScores` 函数是一个简单的协调函数——它的唯一目的是协调调用其他各种计算单个评分区域的函数：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `createDefaultScoring` function in the second line of the preceding listing
    is a `0` or blank values. As the `score` object is passed between each of the
    various `calculateXXXScoreToRef` methods, its values are built up and used by
    successive function calls.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个列表的第二行中的 `createDefaultScoring` 函数包含 `0` 或空白值。随着 `score` 对象在各个 `calculateXXXScoreToRef`
    方法之间传递，其值通过连续的函数调用逐步构建和使用。
- en: The `ToRef` suffix on these function names indicates that they will be mutating
    a parameter (usually the last parameter provided by convention) rather than creating
    a new instance of one. This is most seen with `Vector` and `Matrix` objects but
    consistency in naming is crucial to the long-term health of a code base! Following
    that are individual subsections that go through the details of each aspect of
    the scoring calculations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数名称上的 `ToRef` 后缀表示它们将修改一个参数（通常是按照惯例提供的最后一个参数），而不是创建一个新实例。这在 `Vector` 和 `Matrix`
    对象中最为常见，但命名的一致性对于代码库的长期健康至关重要！接下来是各个子节，它们将详细说明评分计算的各个方面。
- en: Because we’re still in the development process, we’re not going to worry too
    much about getting these calculations balanced and tweaked to the extent we may
    want. What we need to do is establish a basic way to provide a dynamic scoring
    experience that is easy to come back to later when we’re ready to balance and
    tweak.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍在开发过程中，我们不会过于担心使这些计算平衡和调整到我们可能想要的程度。我们需要做的是建立一个基本的方法来提供一种动态评分体验，这样我们稍后准备好平衡和调整时可以轻松返回。
- en: Encounter Scores
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遭遇分数
- en: 'We start by calculating the encounter score. Right off, we know that we want
    to get a list of encounters and that we will want to use that list to add up the
    individual modifiers for each encounter to get the final encounter modifier. If
    we assume that the route parameter contains a `pathPoints` object collection (see
    the `/src/driving/spaceTruckerDrivingScreen.calculateRouteParameters` function
    for details) and that any given entry in the `pathPoints` collection may or may
    not have an associated encounter containing a decimal `scoreModifier` value, then
    we can use a simple `map` and `reduce` operation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算遭遇分数。一开始，我们就知道我们想要得到一个遭遇列表，并且我们将想要使用这个列表来累加每个遭遇的单独修正值，以得到最终的遭遇修正值。如果我们假设路由参数包含一个
    `pathPoints` 对象集合（有关详细信息，请参阅 `/src/driving/spaceTruckerDrivingScreen.calculateRouteParameters`
    函数），并且 `pathPoints` 集合中的任何给定条目可能或可能不包含一个关联的遭遇，该遭遇包含一个十进制的 `scoreModifier` 值，那么我们可以使用简单的
    `map` 和 `reduce` 操作：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code calls `map` with a simple extraction function that retrieves
    the `scoreModifier` value – a number. Next, it passes the array of `scoreModifier`
    numbers to the `reduce` function. `Array.reduce` (if you aren’t already familiar
    with it) is a useful aggregation tool that takes a function as its primary parameter.
    Looping (or iterating) over the array, `arr`, the function is invoked for each
    `curr` element in turn, with the results of the `prev` operation being passed
    along with the value of the `curr` element at the `cidx` position. This is just
    a fancy way of saying that the `reduce` operation sums up the total of all the
    elements in an array of numbers! This aggregated value becomes `encounterModifier`,
    which is used in conjunction with the overall number of encounters to determine
    the total encounters score value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了一个简单的提取函数调用`map`，该函数检索`scoreModifier`值——一个数字。接下来，它将`scoreModifier`数字数组传递给`reduce`函数。`Array.reduce`（如果你还不熟悉）是一个有用的聚合工具，它将一个函数作为其主要参数。在遍历数组`arr`时，函数会依次对每个`curr`元素调用，将`prev`操作的结果与`cidx`位置的`curr`元素值一起传递。这仅仅是一种花哨的说法，即`reduce`操作会计算一个数字数组的所有元素的总和！这个聚合值成为`encounterModifier`，它与总的遭遇次数一起用来确定总的遭遇得分值。
- en: Route Scores
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路线得分
- en: 'Route scoring calculations are performed slightly differently from encounter
    scoring. The main factor for route scoring is the length of the overall route
    (how far the cargo had to travel before arriving), but there are several equally
    important modifiers. When it comes to `transitTime` of the route, there are two
    relevant values: the planned transit time and the actual (driving phase) transit
    time. The ratio between those values, when added to a constant, gives us `transit.factor`,
    an important multiplier that’s used in two ways. First, it is applied to `distanceTraveled`;
    after it is applied to the `launchForce` value, which is used during the Route
    Planning Phase. The first is subtracted from the second to produce the final Route
    Score value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 路线得分计算与遭遇得分计算略有不同。路线得分的主要因素是整体路线的长度（货物在到达之前需要行驶多远），但还有几个同样重要的修正因子。当涉及到路线的`transitTime`时，有两个相关的值：计划中的运输时间和实际的（驾驶阶段）运输时间。这两个值的比率加上一个常数，给出了`transit.factor`，这是一个重要的乘数，它以两种方式使用。首先，它应用于`distanceTraveled`；然后应用于`launchForce`值，这在路线规划阶段使用。第一个值从第二个值中减去，以产生最终的路线得分值：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Cargo Scores
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 货物得分
- en: 'Cargo scoring is based primarily on the condition of the cargo upon arrival,
    meaning that it reflects player performance from the Driving phase. The cargo
    starts with a condition value of 100\. When collisions with encounters or with
    sufficient velocity occur, the route path can reduce that value (see the *Capturing
    Scoring Data* section for more), which is used as the basis for the Cargo Score
    after it’s been scaled by the condition multiplier:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 货物得分主要基于货物到达时的状态，这意味着它反映了玩家在驾驶阶段的表现。货物开始时的状态值为100。当发生遭遇或足够快的碰撞时，路线路径可以降低该值（有关更多信息，请参阅*捕获得分数据*部分），该值在经过状态乘数缩放后用作货物得分的基础：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Bonus Scoring
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奖励得分
- en: 'If the player delivers their cargo in pristine condition, extra rewards are
    in order. In that case, the Delivery Bonus is applied to `finalScores`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家以完美的状态交付他们的货物，那么将获得额外的奖励。在这种情况下，交付奖金应用于`finalScores`：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Final Scoring
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终得分
- en: 'Once all the various sub-scores have been tallied and multiplied, it’s time
    to sum them all up to get our total value. After populating with `BASE_DELIVERY_SCORE`,
    we use `Object.values` to produce an array of numbers that we (sound familiar?)
    pass to another `reduce` operation to give the `Final Total` score value:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有各种子得分都被计算并相乘，就是时候将它们全部加起来以得到我们的总得分。在填充了`BASE_DELIVERY_SCORE`之后，我们使用`Object.values`生成一个数字数组，我们（听起来熟悉？）将其传递给另一个`reduce`操作以得到最终的“总分”得分值：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Putting these computations together helps give us an idea of what data is already
    available in the route and what needs to be collected. There’s more information
    about a game session than just the route path, after all!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些计算组合起来有助于我们了解路线中已经可用的数据以及需要收集的数据。毕竟，关于游戏会话的信息远不止路线路径！
- en: Capturing Scoring Data
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获得分数据
- en: With the sample scoring data serving as a guide, we can work backward to identify
    the places in the application where scoring data is generated before capturing
    it. This may result in the need to update or change existing data structures and
    code, but that’s OK because we will also make the needed changes to allow players
    to complete the driving phase and see their final scores displayed in their full
    glory!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以样本评分数据作为指导，我们可以逆向工作，以确定在捕获之前生成评分数据的应用程序中的位置。这可能会导致需要更新或更改现有的数据结构和代码，但没关系，因为我们也将对所需的更改进行修改，以便玩家能够完成驾驶阶段，并看到他们最终得分以全貌显示！
- en: Enriching the Route Data
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 丰富路线数据
- en: 'The first and possibly the biggest change is that we’ve added a new `routeData`
    property to `SpaceTruckerPlanningScreen`, which packages up all data needed by
    the scoring calculations later in the game (see the *Adding Up and Tallying Scores*
    section for more):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，也可能是最大的变化是，我们为`SpaceTruckerPlanningScreen`添加了一个新的`routeData`属性，它包装了游戏后期评分计算所需的所有数据（有关更多信息，请参阅*累计和总计分数*部分）：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`routePath` of the `Cargo` object tracks encounters and other path-specific
    data, while the other values provide a baseline travel time and the length of
    the route. Encounters were already being captured as part of `cargoData` associated
    with the encounter, but the additional `scoreModifier` field is needed for every
    encounter listed in the `route-planning/gameData.js` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo`对象的`routePath`跟踪遭遇和其他路径特定数据，而其他值提供基线旅行时间和路线长度。遭遇已经被作为与遭遇相关的`cargoData`的一部分捕获，但需要为在`route-planning/gameData.js`文件中列出的每个遭遇添加额外的`scoreModifier`字段：'
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There’s still more to do, but this completes the data collection aspect of scoring.
    Next, we need to add a trigger that will initiate the scoring process (provided
    the player has finished the route…) and show the Scoring Dialog.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的工作要做，但这已经完成了评分方面的数据收集部分。接下来，我们需要添加一个触发器来启动评分过程（前提是玩家已经完成了路线…）并显示评分对话框。
- en: Completing the Driving Phase
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成驾驶阶段
- en: 'So far, the `SpaceTruckerDrivingScreen.killTruck` function has indiscriminately
    performed the grim responsibilities implied in its name. Today, though, is different.
    Today, the Grim Reaper of trucks gets a conscience:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`SpaceTruckerDrivingScreen.killTruck`函数一直在无差别地执行其名称所暗示的严酷职责。然而，今天却不同。今天，卡车的死神有了良心：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the method is called by the `onMeshIntersectExit` action trigger, it checks
    the absolute (World reference) position of the mesh against the closest Path3D
    segment of the route. See [*Chapter 8*](B17266_08_Final_AM.xhtml#_idTextAnchor166),
    *Building the Driving Game*, the *Generating the Driving Path* section for more
    on Path3D and how it relates to the route path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法被`onMeshIntersectExit`动作触发器调用时，它会将网格的绝对（世界参考）位置与路线最近的Path3D段进行比较。参见[*第8章*](B17266_08_Final_AM.xhtml#_idTextAnchor166)，*构建驾驶游戏*，*生成驾驶路径*部分，了解更多关于Path3D及其与路线路径的关系。
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Path3D exposes positions as a normalized route with positions between 0 (beginning)
    and 1 (end).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Path3D以介于0（开始）和1（结束）之间的标准化路线形式公开位置。
- en: 'Should the truck happen to exit its route path (thus triggering this method)
    too far from its destination, the Grim Task of reaping continues as it did in
    the past. Let’s not dwell on the past and instead look to the alternative, happy
    future that involves calling the `completeRound` method of the `SpaceTruckerDrivingScreen`
    class. The first two things that need to happen are that we want to hide the driving
    phase GUI, which we do by setting the appropriate `layerMask` to `0`. Next, we
    transition the screen to the `DRIVING_STATE.RouteComplete` state to prevent further
    updates to the simulation that may impact scoring, which, speaking of, is what
    immediately follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卡车意外地离目的地太远而退出其路线路径（从而触发此方法），那么收割的严酷任务将继续像过去一样进行。让我们不要沉溺于过去，而是展望涉及调用`SpaceTruckerDrivingScreen`类的`completeRound`方法的美好未来。需要发生的头两件事是我们想要隐藏驾驶阶段的GUI，我们通过将适当的`layerMask`设置为`0`来实现这一点。接下来，我们将屏幕过渡到`DRIVING_STATE.RouteComplete`状态，以防止对可能影响评分的模拟进行进一步更新，说到评分，这紧接着就是：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once the scoring data has been gathered and computed, `createScoringDialog`
    (from `/src/scoring/scoringDialog.js`) is invoked to do the necessary `DialogBox`
    creation and management; all that remains for `completeRound` to do is hook up
    the `onAcceptedObservable` and `onCancelledObservable` properties to the appropriate
    logic. Then, we are good to go from the standpoint of the driving screen!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集并计算了得分数据，就会调用`createScoringDialog`（来自`/src/scoring/scoringDialog.js`）来完成必要的`DialogBox`创建和管理；`completeRound`需要做的只是将`onAcceptedObservable`和`onCancelledObservable`属性连接到适当的逻辑。然后，从驾驶屏幕的角度来看，我们就准备就绪了！
- en: 'The `createScoringDialog` function is a nice analogy to this book; it starts
    with the familiar, then mixes in something completely unexpected and/or unfamiliar
    as it progresses until, by the end, it seems like everything works by magic. Let’s
    finish this section by looking at the familiar parts of the function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`createScoringDialog`函数与这本书非常相似；它从熟悉的部分开始，然后在进展过程中加入一些完全出乎意料或不熟悉的内容，直到最后，似乎一切都像魔法一样运作。让我们通过查看函数的熟悉部分来结束这一节：'
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is slightly different from the Playground at [https://playground.babylonjs.com/#SQG1LV#28](https://playground.babylonjs.com/%23SQG1LV%2328),
    but only because the PG doesn’t have `SpaceTruckerSoundManager` to retrieve and
    manage the sound used by the next section. There’s nothing unusual in this code
    until the very last line. What a fantastic opportunity as well to introduce one
    of the more exciting features of Babylon.js v5 – coroutines!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[https://playground.babylonjs.com/#SQG1LV#28](https://playground.babylonjs.com/%23SQG1LV%2328)中的Playground略有不同，但这仅仅是因为PG没有`SpaceTruckerSoundManager`来检索和管理下一节使用的声音。在这段代码的最后几行之前，并没有什么不寻常的地方。这也是介绍Babylon.js
    v5中更令人兴奋的功能之一的绝佳机会——协程！
- en: The logic involved in calculating the scores themselves is as simple as possible
    and no more – it requires nothing but the data passed into it directly to operate,
    but that data needs to come from somewhere. The different categories of scores
    are sourced from different components of the game; encounters contribute to their
    multiplier, transit times are calculated in both driving and route planning, and
    the cargo’s health is tracked by the truck during driving. Each of these factors
    and multipliers contributes to the overall final scores that get displayed in
    the Scoring Dialog.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 计算得分本身的逻辑尽可能简单，不再复杂——它只需要直接传递给它的数据来操作，但那些数据需要从某个地方来。不同的得分类别来自游戏的不同组件；遭遇增加它们的乘数，行驶和路线规划中的通行时间被计算，而卡车在行驶过程中跟踪货物的健康状况。这些因素和乘数都贡献于最终得分，这些得分会在得分对话框中显示。
- en: Creating the Scoring Dialog Using Coroutines
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程创建得分对话框
- en: 'If you have come from a background working with Unity, Unreal, or other game
    engines, you might be familiar with the concept of a coroutine. A coroutine in
    those contexts is defined much the same way as it is in Babylon.js: a stateful
    method that runs across multiple frames of rendering.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Unity、Unreal或其他游戏引擎的工作背景，你可能熟悉协程的概念。在这些环境中，协程的定义与在Babylon.js中定义的方式非常相似：一个跨多个渲染帧运行的状态方法。
- en: Though it may imply the presence of multiple threads, typically, in most frameworks
    (for example, Unity and most certainly JavaScript!), this is not the case. The
    C# programming language uses Iterators along with the **yield** keyword to implement
    coroutines, but in JavaScript, we use a (spoiler alert!) **function* generator**.
    Bet no one saw that callback to [*Chapter 4*](B17266_04_Final_AM.xhtml#_idTextAnchor070),
    *Creating the Application* coming! Instead of using them as part of our application’s
    state machine, we’re going to define the logic that will make the score dialog’s
    scoring entries count upwards from zero, along with playing a cash-register type
    of sound. Lastly, we’ll crank things up to 11 by looking at a standalone Playground
    sample to show how it’s possible to devise a controller system composed of multiple,
    independently reusable behaviors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可能暗示了多个线程的存在，但在大多数框架中（例如Unity和当然还有JavaScript！），通常并非如此。C#编程语言使用迭代器以及**yield**关键字来实现协程，但在JavaScript中，我们使用一个（剧透警告！）**函数*生成器**。没有人能预料到[*第4章*](B17266_04_Final_AM.xhtml#_idTextAnchor070)，“创建应用程序”中的回调吧！我们不会将它们作为应用程序状态机的一部分来使用，而是要定义使得分对话框的得分条目从零开始计数的逻辑，同时播放收银机类型的声响。最后，我们将通过查看一个独立的Playground示例来将事情推向高潮，展示如何设计由多个独立可重用行为组成的控制器系统。
- en: Reviewing Function Generators
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查函数生成器
- en: 'For a more detailed overview of JavaScript function generators, see [*Chapter
    4*](B17266_04_Final_AM.xhtml#_idTextAnchor070), *Creating the Application*, the
    *Space-Truckers – The State Machine* section. Here’s a quick example of a `function`
    generator to help remind us how they work and how to use them. Let’s say that
    our designers have devised a color palette for printing the rows of a report.
    We can define a `nextColor()` star function that will produce a new hex color
    string at every iteration:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaScript函数生成器的更详细概述，请参阅 [*第4章*](B17266_04_Final_AM.xhtml#_idTextAnchor070)，*创建应用程序*，*太空卡车手——状态机*
    部分。这里有一个快速示例，帮助提醒我们它们是如何工作的以及如何使用它们。假设我们的设计师为打印报告的行设计了一套调色板。我们可以定义一个 `nextColor()`
    星函数，它将在每次迭代时产生一个新的十六进制颜色字符串：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When a function is generated by calling `nextColor()`, it will always produce
    a color from the list, in order, when requested. Where does this come into play?
    The `createScoringBlock(label)` function is responsible for creating and styling
    the actual GUI element that is displayed in the scoring `DialogBox`, calling `colorPicker.next()`
    to produce a new value each time it is called:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过调用 `nextColor()` 生成函数时，它将始终按顺序从列表中产生一个颜色，当请求时。这在哪里发挥作用？`createScoringBlock(label)`
    函数负责创建和样式化实际显示在得分 `DialogBox` 中的GUI元素，每次调用时都调用 `colorPicker.next()` 来产生一个新的值：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There’s our brief review of `function*` concepts, all packed up nice and tidy.
    Now, let’s see how those fit into coroutines and Babylon.js by looking deeper
    into `scoringDialog.js`, where we’ll unwrap `scoringAnimationCo` and put it to
    work in our `DialogBox`!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对 `function*` 概念的简要回顾，所有内容都整理得很好。现在，让我们深入到 `scoringDialog.js` 中，看看这些如何在协程和Babylon.js中发挥作用，我们将解开
    `scoringAnimationCo` 并将其用于我们的 `DialogBox` 中！
- en: Counting Player Scores with a Coroutine
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用协程计算玩家得分
- en: Coroutines are neat because they allow the developer to express complex behavior
    via relatively simple logic (when done right). Any time a coroutine wants to return
    control to the caller, it calls `yield` – with or without arguments (see the *Advanced
    Coroutine Usage* section). The timing and manner in which a `BABYLON.Observable`
    for that CoRo.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 协程很棒，因为它们允许开发者通过相对简单的逻辑（当正确实现时）表达复杂的行为。每当协程想要将控制权返回给调用者时，它都会调用 `yield` ——带有或没有参数（见
    *高级协程使用* 部分）。协程的 `BABYLON.Observable` 的返回时间和方式。
- en: Important note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: New in the Babylon.js v5 Observable API is the `Observable.runCoroutineAsync`
    and `Observable.cancelAllCoroutines` functions. See [https://doc.babylonjs.com/divingDeeper/events/coroutines](https://doc.babylonjs.com/divingDeeper/events/coroutines)
    for more!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js v5 可观察API中的新功能是 `Observable.runCoroutineAsync` 和 `Observable.cancelAllCoroutines`
    函数。有关更多信息，请参阅 [https://doc.babylonjs.com/divingDeeper/events/coroutines](https://doc.babylonjs.com/divingDeeper/events/coroutines)。
- en: If attached to one of the Scene’s render event Observables, the CoRo will run
    every frame, whenever the host Observable is triggered. If attached to `scene.onPointerObservable`,
    the CoRo will fire any time the pointer moves or interacts with the scene. This
    is incredibly powerful when combined with the way that JavaScript closures work
    – since an iterator function is a stateful construct, it can remember and track
    past events and conditions as they evolve over multiple frames of simulation/rendering.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将协程附加到场景的渲染事件可观察对象之一，每当宿主可观察对象被触发时，协程将在每一帧运行。如果附加到 `scene.onPointerObservable`，则每当指针移动或与场景交互时，协程都会触发。当与JavaScript闭包的工作方式结合使用时，这非常强大——由于迭代函数是一个有状态的构造，它可以记住并跟踪在多个模拟/渲染帧中演变的事件和条件。
- en: 'This makes a coroutine ideal for implementing a sort-of “cash register” style
    of tallying up the player’s scores and presenting the final totals in conjunction
    with the `DialogBox` class created earlier as part of the `createScoringDialog`
    function. The coroutine logic can be deceptively simple: given a score object
    generated by the Scoring Manager (see the *Adding Up and Tallying Scores* section)
    and a scene, loop over each property of the Final Scores property and display
    its value in the `DialogBox` class by counting up to it from zero:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得协程非常适合实现一种类似“收银台”风格的累计玩家得分，并配合之前作为 `createScoringDialog` 函数一部分创建的 `DialogBox`
    类来展示最终总计。协程逻辑可能看起来很简单：给定由得分管理器生成的得分对象（见 *累计和总计得分* 部分）和场景，遍历最终得分属性中的每个属性，并通过从零开始计数来在
    `DialogBox` 类中显示其值：
- en: '![Figure 9.5 – A logical flowchart of the scoringAnimationCo behavior. Circles
    represent yield statements with the optional use of Tools.DelayAsync. Rectangles
    list the actions taken'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – `scoringAnimationCo` 行为的逻辑流程图。圆圈代表带有可选 `Tools.DelayAsync` 使用的 `yield`
    语句。矩形列出采取的行动'
- en: '](img/Figure_9.05_B17866.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.05_B17866.jpg](img/Figure_9.05_B17866.jpg)'
- en: Figure 9.5 – A logical flowchart of the scoringAnimationCo behavior. Circles
    represent yield statements with the optional use of Tools.DelayAsync. Rectangles
    list the actions taken
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – `scoringAnimationCo` 行为的逻辑流程图。圆圈代表带有可选 `Tools.DelayAsync` 使用的 `yield`
    语句。矩形列出采取的行动
- en: 'The preceding diagram shows that several other pieces need to be handled: the
    height of the `bodyStack` StackPanel needs to be adjusted to account for the new
    row that was added to it, the scrollbar that contains the `bodyStack` control
    needs to be set to its new maximum value to ensure that the current line of text
    is fully visible, and so on.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示还需要处理几个其他部分：`bodyStack` StackPanel 的高度需要调整以适应添加到其中的新行，包含 `bodyStack`
    控件的滚动条需要设置为新的最大值，以确保当前文本行完全可见，等等。
- en: 'Despite the seeming complexity of this logic, it comprises well under 100 lines
    of code! If we only look at the actual logic of the coroutine and exclude the
    state management code, we have even fewer lines of code to write:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个逻辑看起来很复杂，但它包含的代码行数远远不到 100 行！如果我们只看协程的实际逻辑，而不包括状态管理代码，我们甚至需要更少的代码来编写：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The value for `MAX_COUNT` was arbitrarily determined via experimentation; it
    controls the length of the counting animation. The progress is governed by the
    `SmoothStep` function, which starts slow before speeding up greatly just before
    coming to a gentle stop at the end. Every time `Tools.DelayAsync` is passed as
    the argument to `yield`, the coroutine will pause itself for the indicated amount
    of time – or as close to it as possible – before resuming execution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAX_COUNT` 的值是通过实验任意确定的；它控制计数动画的长度。进度由 `SmoothStep` 函数控制，该函数开始时速度较慢，然后在接近结束时加速，然后缓慢停止。每次将
    `Tools.DelayAsync` 作为 `yield` 的参数传递时，协程将暂停自身一段时间——尽可能接近指定的时间——然后继续执行。'
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Because frame delta times don’t always add up to the exact amount of time specified,
    a coroutine can be paused for slightly longer than the indicated amount of time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于帧时间增量并不总是等于指定的确切时间，协程可以暂停的时间可能会略微长于指定的时间。
- en: 'When all is said and done and the final `returns` rather than `yields`, indicating
    completion and signaling to the hosting `onBeforeRenderObservable` that it’s OK
    to clean up and dispose of that coroutine function instance. From the perspective
    of the code that started things off, we have two simple lines – one to create
    the iterator function and another to start it running:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都说完了，最终返回的是 `returns` 而不是 `yields`，这表示完成并通知宿主的 `onBeforeRenderObservable`
    可以清理并销毁该协程函数实例。从启动代码的角度来看，我们只有两行简单的代码——一行用于创建迭代函数，另一行用于启动它运行：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this scenario, we don’t want to block execution and wait until the coroutine
    completes to continue executing `createScoringDialog`, but if we were doing something
    different, such as making asynchronous HTTP calls as part of a coroutine, it would
    be prudent to await or capture the returned Promise of `runCoRoutineAsync`. Thus,
    it can be used and passed around just like any other asynchronous operation, allowing
    for more advanced scenarios and complex behaviors.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们不想阻塞执行并等待协程完成，然后继续执行 `createScoringDialog`，但如果我们在做不同的事情，比如作为协程的一部分进行异步
    HTTP 调用，那么等待或捕获 `runCoRoutineAsync` 返回的 Promise 将是明智的。因此，它可以像任何其他异步操作一样使用和传递，允许更高级的场景和复杂的行为。
- en: Advanced Coroutine Usage
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级协程使用
- en: 'Unless you’re a passenger on the Titanic, there’s good news: this is just the
    tip of the iceberg! Because coroutines leverage the underlying mechanics of function
    iterators, it’s possible to use the `yield*` operator to chain together multiple
    `function*` iterations into a single coroutine, as exemplified in the Playground
    at [https://playground.babylonjs.com/#5Z2QLW#1](https://playground.babylonjs.com/%235Z2QLW%231).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是泰坦尼克号的乘客，否则有好消息：这只是冰山一角！因为协程利用了函数迭代器的底层机制，可以使用 `yield*` 操作符将多个 `function*`
    迭代链接成一个单一的协程，如 [https://playground.babylonjs.com/#5Z2QLW#1](https://playground.babylonjs.com/%235Z2QLW%231)
    中的游乐场所示。
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)
    for more details and examples of using the `yield*` operator.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)
    获取更多关于使用 `yield*` 操作符的详细信息及示例。
- en: 'The `yield*` operator is used in the context of a `function*` body, and provides
    a way to “pass through” the results of another iterator function – or, and this
    is easily missed part of the definition (emphasis added):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield*` 操作符在 `function*` 体的上下文中使用，并提供了一种“传递”另一个迭代函数结果的方法——或者，这是定义中容易忽略的部分（强调添加）：'
- en: “The yield* expression is used to delegate to another generator or iterable
    object.”
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: “`yield*` 表达式用于委托给另一个生成器或可迭代对象。”
- en: Although not used in our example, this would allow a developer to, for example,
    write a coroutine that produced a stream of values from an array populated by
    device sensors, among many other applications. In our example, we are using the
    `yield*` operator analogously as we may extract reusable code into a function
    by invoking another `function*`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在我们的例子中没有使用，但这将允许开发者编写一个协程，例如，从由设备传感器填充的数组中生成值流，以及其他许多应用。在我们的例子中，我们类似于通过调用另一个
    `function*` 将可重用代码提取到函数中，使用 `yield*` 操作符。
- en: 'Seemingly a small detail, this ability to execute other iterator functions
    allows us to use the powerful Compositional pattern of software design to put
    simple building blocks together to express complex behavior. We start with the
    `function* think()` coroutine. It is named appropriately because its job is to
    decide what the sphere mesh is going to do next:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是一个小细节，但这种执行其他迭代函数的能力使我们能够使用软件设计的强大组合模式，将简单的构建块组合起来以表达复杂的行为。我们从 `function*
    think()` 协程开始。它被适当地命名，因为它的任务是决定球体网格接下来要做什么：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Think of the preceding code as the *primary controller* or, more colloquially,
    the AI for a game object. It can read the environment and make decisions on what
    to do. In our case, it waits for a second and a half before invoking the `moveToTarget`
    function (listed in the following code snippet) with the desired target position.
    This moves the sphere from wherever it is positioned in the middle of the right-hand
    side of the perimeter Plane. After another short delay, the `patrolCo` function
    is invoked.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码视为*主要控制器*，或者更通俗地说，是游戏对象的AI。它可以读取环境并做出决定。在我们的情况下，它等待一秒半后，使用以下代码片段中列出的 `moveToTarget`
    函数和期望的目标位置调用该函数。这使球体从其位于右侧边界的中间位置移动。在短暂的延迟之后，调用 `patrolCo` 函数。
- en: '`function* patrolCo` is another compositional element that combines multiple
    `moveToTarget` iterations, along with logic, to change the color of the sphere
    on every movement direction change:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`function* patrolCo` 是另一个组合元素，它结合了多个 `moveToTarget` 迭代以及逻辑，以在每次移动方向改变时改变球体的颜色：'
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Each set of `yield*` statements delegates execution to the `moveToTarget` function,
    which is the real workhorse of this example. This behavior does what it says on
    the tin – it moves the subject (the sphere mesh, in our case) of the behavior
    as close as it can to the given target world position. A `maxDelta` value caps
    the amount of ground the sphere can cover in any given frame (due to the coroutine
    being hosted and executed by `onBeforeRenderObservable`):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每组 `yield*` 语句将执行委托给 `moveToTarget` 函数，这是本例中的真正的工作马。这种行为正如其名——它将行为的主语（在我们的例子中是球体网格）尽可能移动到给定的目标世界位置。`maxDelta`
    值限制了球体在任何给定帧中可以覆盖的地面量（由于协程是由 `onBeforeRenderObservable` 承载和执行的）：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The direction of movement is computed by subtracting the two relevant position
    vectors, the result of which is used to determine whether the sphere has arrived
    at its destination, as well as moving the sphere by adding a scaled vector pointing
    toward `targetPosition`. Upon arrival, the iterator function returns control to
    the calling iterator function – either `patrolCo()` or `think()`, which then proceeds
    to the next step in its iterator chain.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 移动方向是通过减去两个相关位置向量来计算的，其结果用于确定球体是否到达目的地，以及通过添加指向 `targetPosition` 的缩放向量来移动球体。到达后，迭代函数将控制权返回给调用迭代函数——无论是
    `patrolCo()` 还是 `think()`，然后继续其迭代链中的下一步。
- en: This simple example can easily be extended with additional behavior and logic,
    simply by adding additional `function*` definitions. Like a library or toolbox
    of behaviors, simple behaviors such as `moveToTarget` are stitched together into
    more complex behaviors such as `patrolCo`, which is, in turn, orchestrated by
    the overall `think` function iterator endlessly pondering the game’s world. An
    entire non-player actor/controller can be quickly put together in this fashion!
    Hopefully, by presenting the concepts in an isolated Playground, it’s easier to
    see how composition can make the whole greater than the sum of its parts.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例可以很容易地通过添加额外的 `function*` 定义来扩展额外的行为和逻辑。就像一个行为库或工具箱，简单的行为如 `moveToTarget`
    被缝合成更复杂的行为，如 `patrolCo`，而 `patrolCo` 又由不断沉思游戏世界的整体 `think` 函数迭代器编排。可以快速以这种方式构建一个完整的非玩家演员/控制器！希望通过在隔离的游乐场中展示这些概念，更容易看到组合如何使整体大于部分之和。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve accomplished a lot in this chapter. Starting with the `DialogBox` was
    designed and saved to both the snippet server and JSON. After learning how to
    use it in conjunction with the `DialogBox` component and tested it by adding the
    Route Planning confirmation dialog.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们取得了许多成果。从设计并保存 `DialogBox` 到片段服务器和 JSON 开始。学习如何与 `DialogBox` 组件一起使用它，并通过添加路线规划确认对话框进行测试。
- en: Armed with those initial results, we turned to the scoring system used in Space-Truckers
    and the logic needed to calculate each area of the scoring game. The data to accomplish
    this became apparent throughout, so we made the needed modifications to the **Space-Trucker
    Application** to capture scoring data. Because we already have the foundational
    dialog structure in place, it’s easy to create the **Scoring Dialog** from both
    captured and sample scoring data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些初步结果，我们转向 Space-Truckers 中使用的评分系统以及计算游戏每个评分区域的逻辑。完成这项任务所需的数据在过程中变得明显，因此我们对
    **Space-Trucker 应用程序** 进行了必要的修改以捕获评分数据。由于我们已经建立了基础对话框结构，因此很容易从捕获和样本评分数据中创建 **评分对话框**。
- en: 'It’s not enough to simply display the scores in our Scoring Dialog, though,
    so we employed another new feature in v5 of Babylon.js: `BablyonJS.Observable`
    (but mostly used in `onBeforeRenderObservable`), coroutines allow complex multi-frame
    logic to be simply written and executed. Through `scoringAnimationCo`, each line
    of the Final Scores object is displayed and counted to its final value from zero.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅在我们的评分对话框中显示分数是不够的，所以我们还在 Babylon.js v5 中引入了另一个新功能：`BablyonJS.Observable`（但主要在
    `onBeforeRenderObservable` 中使用），协程允许简单地编写和执行复杂的跨帧逻辑。通过 `scoringAnimationCo`，最终得分对象的每一行都会从零开始显示并计算到最终值。
- en: Moving away from the Scoring Dialog, we wrapped up this chapter by learning
    how to use coroutines with multiple `moveToTarget` and `patrolCo`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 离开评分对话框，我们通过学习如何使用多个 `moveToTarget` 和 `patrolCo` 的协程来结束本章。
- en: In the next chapter, we’re going to look at the space of Space-Truckers by diving
    into environments, **Image-Based Lighting** (**IBL**), and how to use **Physically-Based
    Rendering** (**PBR**) with Babylon.js. From workflows for converting images for
    use with IBL to adding post-processes for effect, we’ll see how easy it is to
    take a few lines of code and make something attractive and performant!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过深入研究环境、**基于图像的照明**（**IBL**）以及如何使用 Babylon.js 的**基于物理的渲染**（**PBR**）来探讨
    Space-Truckers 的空间。从为 IBL 转换图像的工作流程到添加后处理效果，我们将看到如何通过几行代码轻松地制作出既吸引人又高效的内容！
- en: Extended Topics
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: 'It’s important not to focus too much on the particulars of the `DialogBox`
    design UI – this book isn’t a book on graphic design, much to everyone’s relief
    – so here are some ideas and resources for taking your UI adventures to the next
    level:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要过多关注 `DialogBox` 设计 UI 的细节——这本书不是一本关于图形设计的书，这让大家如释重负——所以这里有一些想法和资源，可以帮助你将
    UI 冒险提升到下一个层次：
- en: 'The Babylon.js team ran a summer event in August 2022 that urged community
    members to submit the amazing UI builds they had created with the GUIE. Two “starter”
    templates were provided for people that didn’t have an existing project:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babylon.js 团队在 2022 年 8 月举办了一场夏季活动，鼓励社区成员提交他们使用 GUIE 创建的令人惊叹的 UI 构建。为那些没有现有项目的人提供了两个“入门”模板：
- en: '[https://playground.babylonjs.com/#QCH724#1](https://playground.babylonjs.com/%23QCH724%231)'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://playground.babylonjs.com/#QCH724#1](https://playground.babylonjs.com/%23QCH724%231)'
- en: '[https://playground.babylonjs.com/#QCH724#1](https://playground.babylonjs.com/%23QCH724%231)'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://playground.babylonjs.com/#QCH724#1](https://playground.babylonjs.com/%23QCH724%231)'
- en: These two samples are for a main menu system and an in-game menu and inventory
    system – what sorts of things can you build when you combine those as a starting
    point with what you’ve learned in this chapter?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个样本分别是一个主菜单系统和游戏内菜单及库存系统——当你以本章所学为基础，将它们结合起来时，你可以构建出哪些类型的东西呢？
- en: The Space-Truckers Main Menu is very much imperatively coded as opposed to the
    GUIE JSON files, which are declarative. As we’ve seen, a declarative data-driven
    UI is much easier to build and maintain, so try applying that knowledge to the
    Main Menu by replacing some of the GUI components created in code with a `DialogBox`.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间卡车主菜单在很大程度上是命令式编写的，而不是像GUIE JSON文件那样的声明式。正如我们所见，声明式数据驱动的UI构建和维护要容易得多，所以尝试将这种知识应用到主菜单上，通过用`DialogBox`替换一些在代码中创建的GUI组件来实现。
- en: 'Composable coroutines can provide a simple and easy way to add interesting
    behaviors to a game or application. Add a way for an arbitrary encounter instance
    in the Driving Phase to run a coroutine “behavior.” The encounter itself should
    provide the coroutine, but it will need to be provided with current game state
    information:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可组合的协程可以提供一种简单易行的方法来为游戏或应用程序添加有趣的行为。为驾驶阶段中的任意遭遇实例添加一种运行协程“行为”的方式。遭遇本身应该提供协程，但它需要提供当前游戏状态信息：
- en: 'Three components working together can help cleanly separate and define this
    functionality:'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个组件协同工作可以帮助干净地分离和定义此功能：
- en: A Behavior component that does the “thinking”
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行“思考”的行为组件
- en: A Think Context that provides a vehicle for state information
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提供状态信息的“思考”上下文
- en: A set of actions that the behavior(s) can perform (for example, “Move,” “Eat,”
    “Disperse,” “Acquire Target,” and so on)
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为可以执行的一系列动作（例如，“移动”、“进食”、“散开”、“获取目标”等等）
- en: An encounter coroutine may load a mesh and material, set some values, and perform
    other initialization tasks before beginning its behavioral “think” loop.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遭遇协程可能加载网格和材质，设置一些值，并在开始其行为“思考”循环之前执行其他初始化任务。
- en: Actions can be other coroutine behaviors, such as patrolling behavior.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作可以是其他协程行为，例如巡逻行为。
