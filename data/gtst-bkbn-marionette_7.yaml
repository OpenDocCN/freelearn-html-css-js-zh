- en: Chapter 7. Changing and Growing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。改变和成长
- en: 'In the previous chapter, we explored various functions that could be combined
    to produce a system that is fully integrated, but loosely coupled. In this chapter,
    we will cover some external pieces of Marionette that are very valuable, and as
    we progress, you will discover how to change some default features of the framework
    and combine `Marionette.js` with external libraries to make your application perform
    better. Here is a list of the topics that we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了可以组合起来产生一个完全集成但松散耦合的系统的各种函数。在本章中，我们将介绍一些对 Marionette 非常有价值的外部组件，随着我们的进展，你将发现如何更改框架的一些默认功能，并将
    `Marionette.js` 与外部库结合使用，以使你的应用表现更佳。以下是我们将涵盖的主题列表：
- en: Using **Asynchronous Module Definitions** (**AMD**)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **异步模块定义** (**AMD**)
- en: Using the `Require.js` library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Require.js` 库
- en: Configuring `Require.js`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 `Require.js`
- en: Using the text plugin to load the templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本插件加载模板
- en: Using AMD
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AMD
- en: Using the AMD, API will help us to load scripts on demand, specify the module
    dependencies, and reduce the script definition order problem. In [Chapter 5](ch05.html
    "Chapter 5. Divide and Conquer – Modularizing Everything"), *Divide and Conquer
    – Modularizing Everything*, we discussed why building large applications can easily
    get out of hand. There are multiple aspects to consider, but managing the script
    modules is a common scenario. We need to make sure that all the scripts are loaded
    in the right order, combine them, and reduce the number of requests to the servers.
    This seems to be simple but as the application grows, it is really complex to
    keep track.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AMD，API 将帮助我们按需加载脚本，指定模块依赖关系，并减少脚本定义顺序问题。在 [第 5 章](ch05.html "第 5 章。分而治之——全面模块化")
    “分而治之——全面模块化”中，我们讨论了构建大型应用如何容易失控。需要考虑多个方面，但管理脚本模块是一个常见的场景。我们需要确保所有脚本按正确顺序加载、合并，并减少对服务器的请求次数。这似乎很简单，但随着应用的扩展，跟踪它变得非常复杂。
- en: 'To illustrate the scenario, we will use a part of the script section from the
    `Index.html` file before we implement an AMD solution as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明场景，在我们实现以下 AMD 解决方案之前，我们将使用 `Index.html` 文件中的脚本部分的一部分：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This list contains files for just a small proof of the concept and we have already
    started to accumulate a lot of scripts. As we add more modules, services, models,
    views, and so on, it will start to get less comprehensive and really hard to maintain.
    For example, at some point, we may lose track of the files that are not being
    used anymore. In the preceding code, all the scripts are downloaded when the page
    is loaded, even if the current view is not using them. Our code is modular, but
    still it is not easy to write encapsulated code that can be loaded on the fly,
    injected as dependency, and shared with other modules. Let's review how we can
    fix this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表仅包含少量用于证明概念的文件，我们已经开始积累大量的脚本。随着我们添加更多的模块、服务、模型、视图等，它将开始变得不那么全面，并且真正难以维护。例如，在某个时刻，我们可能会失去对不再使用的文件的跟踪。在先前的代码中，所有脚本在页面加载时都会被下载，即使当前视图没有使用它们。我们的代码是模块化的，但仍然不容易编写可以即时加载、作为依赖注入并与其他模块共享的封装代码。让我们回顾一下我们如何解决这个问题。
- en: Using the Require.js library
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Require.js 库
- en: James Burke introduced the `Require.js` library and it has a great community.
    The author is an expert in script loading and a contributor to the AMD specification.
    This book assumes that you know the basics of AMD and so before jumping to the
    implementation of our application, it will provide you with some basics of the
    configuration and boilerplate required while using `Require.js`. To get the latest
    build of `Require.js`, please go to the project website, [http://requirejs.org/docs/download.html](http://requirejs.org/docs/download.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: James Burke 介绍了 `Require.js` 库，它有一个庞大的社区。作者在脚本加载方面是专家，也是 AMD 规范的贡献者。本书假设你已了解
    AMD 的基础知识，因此在跳转到我们应用的实现之前，它将为你提供使用 `Require.js` 时所需的配置和样板代码的基础知识。要获取 `Require.js`
    的最新构建版本，请访问项目网站，[http://requirejs.org/docs/download.html](http://requirejs.org/docs/download.html)。
- en: Configuring Require.js
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Require.js
- en: 'To get started with `Require.js`, we will create a file named `main.js`. Of
    course, you can give this file a more appropriate name that follows your naming
    conventions and business domain. We will write the following code inside the `main.js`
    file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 `Require.js`，我们将创建一个名为 `main.js` 的文件。当然，你可以给这个文件一个更合适的名字，使其符合你的命名约定和业务领域。我们将在
    `main.js` 文件中编写以下代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s replace all the script references from our `Index.html` file for the
    next script reference as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `Index.html` 文件中的所有脚本引用替换为下一个脚本引用，如下所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this script reference, we pass the name of the file (in our example, the
    `main.js` file) that has all the required configuration to the `data-main` attribute.
    Please note that it's just the name of the file (`main`) and not its extension
    (`.js`) that is passed, because `Require.js` assumes that it will be working only
    with JavaScript files; therefore, the extension is not needed. The source (`src`)
    should point to the path where the `Require.js` file is located.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本引用中，我们将包含所有所需配置的文件名（在我们的例子中是 `main.js` 文件）传递给 `data-main` 属性。请注意，传递的是文件名（`main`）而不是其扩展名（`.js`），因为
    `Require.js` 假设它只与 JavaScript 文件一起工作；因此，不需要扩展名。源（`src`）应指向 `Require.js` 文件所在的路径。
- en: Now, we are ready to complete a small test to see if we are on the right path.
    Open the browser and in the console, you should see the log message when you load
    the `Index.html` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备进行一个小测试，以查看我们是否走上了正确的道路。打开浏览器并在控制台，当你加载 `Index.html` 文件时，你应该会看到日志消息。
- en: Now, let's review each section of the content of the `main.js` file to get a
    better understanding of what's going on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾 `main.js` 文件内容的每个部分，以更好地理解正在发生的事情。
- en: In the preceding code snippet, we put all the libraries that we will use under
    the `paths` section of the `require.config` function. On the left-hand side, we
    assigned the alias of the library and on the right-hand side, we indicated the
    path of the file—the path that will be relative to the `baseUrl` value assigned,
    in this case, the `src` folder.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将我们将要使用的所有库放在了 `require.config` 函数的 `paths` 部分下。在左侧，我们分配了库的别名，在右侧，我们指明了文件的路径——这个路径相对于分配的
    `baseUrl` 值，在这种情况下，是 `src` 文件夹。
- en: The second property of this function is called **shim**. The primary use of
    `shim` is for libraries that do not support AMD, but you still need to manage
    their dependencies. A perfect example for this is `Underscore.js`. In this case,
    `Underscore.js` is exported as `_` and it does not depend on another library to
    be loaded. We have a different scenario with `Backbone.js` that requires Underscore
    to work correctly. We have to specify `Underscore.js` as a dependency because
    it is possible that `Backbone.js` would try to do something with it before it
    is loaded.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第二个属性称为 **shim**。`shim` 的主要用途是针对不支持 AMD 的库，但你仍然需要管理它们的依赖项。一个完美的例子是 `Underscore.js`。在这种情况下，`Underscore.js`
    被导出为 `_`，并且它不依赖于另一个库来加载。我们有一个不同的场景与 `Backbone.js` 有关，它需要 `Underscore` 才能正确工作。我们必须指定
    `Underscore.js` 作为依赖项，因为 `Backbone.js` 在加载之前可能会尝试使用它。
- en: 'The `require` function is placed at the end of the file as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 函数放置在文件末尾，如下所示：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code will be the starting point of our application. It is a function
    definition that gets the exported values as parameters. At this point, we are
    just logging a message, but now let's do something more useful.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将成为我们应用程序的起点。这是一个函数定义，它将导出的值作为参数。在这个阶段，我们只是在记录一条消息，但现在让我们做一些更有用的事情。
- en: Defining our application module
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的应用程序模块
- en: 'Now that the core dependencies are configured using `Require.js`, and once
    those are loaded and ready, we can define our Marionette application and set up
    the region initializers, commands, and request/response handlers. This is because
    we need the inside of a single file that we will name `app.js` with the idea of
    keeping all the login details related to the Marionette application object inside
    of this file. In the following code, our application is defined and ready to work
    as an AMD module. The following is the content of our `app.js` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经使用 `Require.js` 配置了核心依赖项，一旦它们被加载并准备就绪，我们就可以定义我们的 Marionette 应用程序并设置区域初始化器、命令和请求/响应处理器。这是因为我们需要一个名为
    `app.js` 的单个文件内部，目的是将所有与 Marionette 应用程序对象相关的登录细节都放在这个文件中。在下面的代码中，我们的应用程序被定义并准备好作为一个
    AMD 模块工作。以下是我们 `app.js` 文件的内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The book's application that we just defined will be used in the `main.js` file
    when we start the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义的书籍应用程序将在启动应用程序时在 `main.js` 文件中使用。
- en: 'When we add a new file we need to know where it is located and also its alias
    name. We specify this by going to the `paths` section of the `main.js` file definition.
    After this change your `paths` section should look like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加新文件时，我们需要知道它的位置以及它的别名。我们通过访问`main.js`文件定义中的`paths`部分来指定这一点。在此更改后，您的`paths`部分应如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we are ready to use this file to start our Marionette application in the
    `require` function of the `main.js` file as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好使用此文件在`main.js`文件的`require`函数中启动我们的Marionette应用程序，如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note how we injected the book's dependency to start the Marionette application
    and used the `start()` method of the Marionette application object to fire the
    initializers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将书籍的依赖注入以启动Marionette应用程序，并使用Marionette应用程序对象的`start()`方法来触发初始化器。
- en: Writing the subapplications using Require.js
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Require.js编写子应用程序
- en: 'The module that we defined is our root app that takes care of starting up the
    subapplications. The next example shows how we can define the subapplications
    using `Require.js`. As you can see, we can easily adapt our preceding code to
    use the `require` function by sending our script definitions to a configuration
    file and injecting the necessary object into our module definition. The following
    code is from the `CartApp` subapplication:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的模块是我们的根应用程序，负责启动子应用程序。下一个示例将展示我们如何使用`Require.js`定义子应用程序。如您所见，我们可以轻松地将前面的代码适配以使用`require`函数，通过将脚本定义发送到配置文件并将必要的对象注入到模块定义中。以下代码来自`CartApp`子应用程序：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Modularizing all your components
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有组件模块化
- en: In the following example, we will show how to write a module for a view to be
    loaded with `Require.js`, but the same concept applies for all the objects/components.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将展示如何编写一个用于加载`Require.js`的视图模块，但同样的概念适用于所有对象/组件。
- en: In the following code, we define a view called `CategoryView.js` and gave it
    the alias name of `categoryView` in the `main.js` file so that other files can
    use it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们定义了一个名为`CategoryView.js`的视图，并在`main.js`文件中给它命名为`categoryView`的别名，这样其他文件就可以使用它。
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding example defined a well-scoped object. When a module does not have
    any dependencies and it is just a collection, we pass an object literal to `define()`.
    In our scenario, our module has dependencies, so the first argument should be
    an array of dependency names—in this case, `app` is the alias of our application—and
    the second argument should be a definition function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例定义了一个作用域良好的对象。当模块没有任何依赖项且仅是一个集合时，我们通过将对象字面量传递给`define()`函数。在我们的场景中，我们的模块有依赖项，因此第一个参数应该是一个依赖项名称数组——在这种情况下，`app`是应用程序的别名——第二个参数应该是一个定义函数。
- en: Adding the text plugin
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加文本插件
- en: So far, we have defined the template property of our views using the ID of the
    template. This template is inside a script tag and has always been present in
    the DOM. But putting all the templates in the HTML file of a SPA won't scale and
    will give us the same maintenance problem that we had with all the script references
    in the `Index.html` file. A solution to this problem is to use the text plugin.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已使用模板的ID定义了视图的模板属性。这个模板位于一个脚本标签内，并且始终存在于DOM中。但是，将所有模板放入SPA的HTML文件中不会扩展，并且会给我们带来与`Index.html`文件中所有脚本引用相同的维护问题。解决这个问题的方法就是使用文本插件。
- en: 'You can download the text plugin from the `Require.js` page. The following
    is the link for the download:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Require.js`页面下载文本插件。以下为下载链接：
- en: '[http://requirejs.org/docs/download.html#text](http://requirejs.org/docs/download.html#text).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://requirejs.org/docs/download.html#text](http://requirejs.org/docs/download.html#text)。'
- en: As with any other script file, we need to give it an alias in the `main.js`
    file and its path in order to start using it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他脚本文件一样，我们需要在`main.js`文件中给它一个别名以及其路径，以便开始使用它。
- en: The responsibility of the text plugin is to get the template from the server
    and pass it to our view so that we don't need it in the HTML file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 文本插件的责任是从服务器获取模板并将其传递给我们的视图，这样我们就不需要在HTML文件中包含它。
- en: In the following code, we passed the relative path to the template using the
    `!text/path` syntax and the function that creates the view receives the exported
    name of the template as a parameter; in this case, `CategoryTemplate`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们使用`!text/path`语法传递了模板的相对路径，并且创建视图的函数接收模板的导出名称作为参数；在这种情况下，`CategoryTemplate`。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This approach is more maintainable when building a large-scale application,
    but perhaps you want to keep the initial templates in your HTML file for performance
    benefits and the rest of your templates inside the right file structure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建大型应用程序时，这种方法更易于维护，但也许你希望为了性能优势，将初始模板保留在HTML文件中，其余的模板放在正确的文件结构中。
- en: Structuring your files
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件结构化
- en: There are many different options to define the layout of your files and probably
    this will be defined depending on the size and type of your project. At the end
    of the day, the goal should be to create a folder structure that is easy to understand,
    implement, and maintain.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的选项可以定义文件布局，这可能会根据项目的大小和类型而定义。最终，目标应该是创建一个易于理解、实施和维护的文件夹结构。
- en: In the following example, we categorize the source into common folders, such
    as models and collections, and specific folders for the application pieces (views
    and controllers).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将源文件分类到常见的文件夹中，例如模型和集合，以及为应用程序组件（视图和控制台）指定的特定文件夹。
- en: The static dependencies such as CSS, images, and JavaScript libraries required
    by our code should go under a different directory. It could prevent unintentional
    modifications to the library code and give us a better understanding of the real
    business domain.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码所需的静态依赖项，如CSS、图像和JavaScript库，应放在不同的目录下。这可以防止意外修改库代码，并让我们更好地理解实际的业务领域。
- en: 'The following image shows the base structure where we will fit our files:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了我们将文件放置的基础结构：
- en: '![Structuring your files](img/425OS_07_01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![文件结构化](img/425OS_07_01.jpg)'
- en: 'Having said that, let''s dive into some of the details of our application.
    The following image shows how you might layout your application structure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们深入了解我们应用程序的一些细节。以下图片显示了您可能如何布局应用程序结构：
- en: '![Structuring your files](img/425OS_07_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![文件结构化](img/425OS_07_02.jpg)'
- en: In the preceding image, we showed the structure of our book store application.
    This structure makes sense in this particular case. But the good thing is that
    we created small meaningful files that can interact with each other in an easier
    and elegant way, instead of having big files with the logic of different components
    contained.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图片中，我们展示了我们的书店应用程序的结构。这种结构在这个特定情况下是有意义的。但好事是，我们创建了小而有意义的文件，它们可以以更简单、更优雅的方式相互交互，而不是包含不同组件逻辑的大文件。
- en: Using handlebars as a template engine in Marionette
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Marionette中使用handlebars作为模板引擎
- en: One of the selling points of Backbone is that it plays well with the other libraries
    and this also holds true for Marionette . If we want to use a different template
    engine, we can do it with ease.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone的一个卖点是与其他库配合良好，这一点对于Marionette也是适用的。如果我们想使用不同的模板引擎，我们可以轻松做到。
- en: For this specific example, we will use handlebars, which we can be downloaded
    from [http://handlebarsjs.com/](http://handlebarsjs.com/).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的例子，我们将使用handlebars，我们可以从[http://handlebarsjs.com/](http://handlebarsjs.com/)下载。
- en: 'Once we have downloaded the `Handlebars.js` file, we can add it to our `Index.html`
    file by using the following line:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下载了`Handlebars.js`文件后，我们可以通过以下行将其添加到`Index.html`文件中：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Or, we can do so by specifying an alias and path for it in the `main.js` file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在`main.js`文件中指定它的别名和路径。
- en: 'The syntax difference from the underscore templates is that a handlebars expression
    is `{{`, followed by some content, and then by `}}` instead of `<%= expression
    %>` of the `require` function. So, a template in handlebars looks like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与underscore模板的语法差异在于，handlebars表达式是`{{`，然后是一些内容，然后是`}}`，而不是`require`函数的`<%=
    expression %>`。因此，handlebars模板看起来如下：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to use this template in a Marionette view, we must call the following
    syntax:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Marionette视图中使用此模板，我们必须调用以下语法：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding line will grab the template from the DOM and compile it into
    a function that will later be used by Marionette to render the view . The following
    will be the full code for `ItemView`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行将从DOM中获取模板并将其编译成一个函数，该函数稍后将由Marionette用于渲染视图。以下将是`ItemView`的完整代码：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To see this working please go to the JSFiddle example at [http://jsfiddle.net/rayweb_on/gXemX/](http://jsfiddle.net/rayweb_on/gXemX/).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此功能的工作情况，请访问[http://jsfiddle.net/rayweb_on/gXemX/](http://jsfiddle.net/rayweb_on/gXemX/)的JSFiddle示例。
- en: And that's it! There is no global change needed to start using a different template
    engine. We can also use both the engines if we want because the definition of
    the template is at the view level.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！开始使用不同的模板引擎不需要进行全局更改。如果我们想的话，我们也可以同时使用这两个引擎，因为模板的定义是在视图层面。
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that in order to manage the increasing complexity
    of our application, we must break it down into separate files. This increasing
    number of files leads to another problem that `Require.js` solves in an elegant
    way. The `Backbone.js` development clearly benefits from the use of `Marionette.js`,
    along with other libraries, such as `Require.js` and `Handlebars.js`, among others.
    This will definitely make our development environment more solid and at the same
    time, flexible to changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到为了管理我们应用日益增加的复杂性，我们必须将其分解成单独的文件。这个文件数量的增加导致另一个问题，而`Require.js`以优雅的方式解决了这个问题。`Backbone.js`的开发明显受益于`Marionette.js`的使用，以及其他库，例如`Require.js`和`Handlebars.js`等。这无疑会使我们的开发环境更加稳固，同时，对变化也更加灵活。
