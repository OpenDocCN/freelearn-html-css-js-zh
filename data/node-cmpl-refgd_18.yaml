- en: Securing the Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护应用安全
- en: Once deployed in production, an application is exposed to a large number of
    requests. Inevitably, some of them will be malicious. This brings the requirement
    of granting explicit access permissions only to authenticated users, that is,
    authenticating a selected number of consumers to have access to your service.
    Most of the consumers will use the service only for data provisioning. However,
    a few will need to be able to provide new, or modify the existing, catalog data.
    To ensure that only appropriate consumers will be able to execute the `POST`,
    `PUT`, and `DELETE` requests, we will have to introduce the concept of authorization
    into our application, which will grant only explicitly selected users modification
    permissions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在生产环境中部署，应用就会暴露给大量的请求。不可避免地，其中一些将是恶意的。这带来了仅授予认证用户明确访问权限的需求，也就是说，认证一定数量的消费者以访问你的服务。大多数消费者将只使用服务进行数据提供。然而，少数消费者需要能够提供新的或修改现有的目录数据。为了确保只有适当的消费者能够执行`POST`、`PUT`和`DELETE`请求，我们必须在我们的应用中引入授权的概念，这将仅授予明确选定的用户修改权限。
- en: Data services may provide sensitive private information, such as email addresses;
    the HTTP protocol, being a text protocol, may not be secure enough. The information
    transmitted through it is subject to **man-in-the-middle** attacks, which can
    lead to data leakage. To prevent such cases, **Transport Layer Security **(**TLS**)
    should be used. The HTTPS protocol encrypts the transmitted data, ensuring that
    only appropriate consumers who have the right decryption key will be able to consume
    the data exposed by the service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务可能提供敏感的私人信息，例如电子邮件地址；HTTP协议作为一个文本协议，可能不够安全。通过它传输的信息可能受到**中间人攻击**，这可能导致数据泄露。为了防止这种情况，应该使用**传输层安全（TLS**）。HTTPS协议加密传输的数据，确保只有拥有正确解密密钥的适当消费者才能消费服务公开的数据。
- en: 'In this chapter, we will look at how Node.js enables the following security
    features:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Node.js如何启用以下安全功能：
- en: Basic authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: Passport-based basic authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于护照的基本身份验证
- en: Passport-based third-party authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于护照的第三方认证
- en: Authorization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: Transport layer security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层安全
- en: Authentication
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: An application considers a user authenticated when their identity has been successfully
    validated against a trusted store. Such trusted stores can either be any kind
    of specially maintained database, storing the credentials of the application (basic
    authentication), or a third-party service that checks a given identity against
    its own trusted store (third-party authentication).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用认为用户的身份在经过一个受信任的存储成功验证后，就认为用户已经认证。这些受信任的存储可以是任何类型的特别维护的数据库，存储着应用的凭据（基本身份验证），或者是一个第三方服务，该服务会检查给定的身份是否与其自己的受信任存储相匹配（第三方认证）。
- en: Basic authentication
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: 'HTTP basic authentication is one of the most popular and straightforward authentication
    mechanisms available out there. It relies on HTTP headers in the request, which
    provide the user''s credentials. Optionally, the server may reply with a header,
    forcing the clients to authenticate themselves. The following diagram shows a
    client-server interaction when basic authentication is carried out:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基本身份验证是现有最流行和最直接的认证机制之一。它依赖于请求中的HTTP头，这些头提供了用户的凭据。服务器可以选择回复一个头，强制客户端进行认证。以下图显示了在执行基本身份验证时的客户端-服务器交互：
- en: '![](img/5d1da2ce-4ecb-44c8-b8cb-bbfc01a8a690.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d1da2ce-4ecb-44c8-b8cb-bbfc01a8a690.png)'
- en: Whenever an HTTP request is sent to an endpoint secured by HTTP basic authentication,
    the server replies with an HTTP `401 Unauthorized` status code, and, optionally,
    with a `WWW-Authenticate` header. This header forces the client to send another
    request, containing the `Authorization` header, which specifies that the authentication
    method is `basic`. This request is followed by a base64-encoded key/value pair,
    providing the username and the password to authenticate with. Optionally, the
    server can specify a message to the client with the `realm` attribute.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每当向由HTTP基本身份验证保护的目标发送HTTP请求时，服务器会回复一个HTTP `401 未授权`状态码，并且可选地，还会回复一个`WWW-Authenticate`头。这个头会强制客户端发送另一个请求，包含`Authorization`头，指定认证方法是`basic`。这个请求后面跟着一个base64编码的键/值对，提供用于认证的用户名和密码。可选地，服务器可以指定一个带有`realm`属性的消息给客户端。
- en: This attribute specifies that resources sharing the same `realm` value should
    support the same authentication means. In the preceding diagram, the `realm` message
    is `MyRealmName`. The client authenticates by sending the `Authentication` header
    with the value of `Basic YWRtaW46YWRtaW4`, specifying that `Basic` authentication
    is used, followed by the base64-encoded value. In the diagram, the literal `YWRtaW46YWRtaW4`
    decoded in base64 represents the `admin:admin` literal. In case such a username/password
    combination is successfully authenticated, the HTTP server will respond with the
    JSON payload of the requested items. If the authentication fails, the server will
    respond with the `401 Unauthorized` status code, but this time without including
    the `WWW-Authenticate` header.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定具有相同 `realm` 值的资源应支持相同的认证方式。在前面的图中，`realm` 消息是 `MyRealmName`。客户端通过发送包含值
    `Basic YWRtaW46YWRtaW4` 的 `Authentication` 标头来进行认证，指定使用 `Basic` 认证，后跟 base64 编码的值。在图中，base64
    解码的 `YWRtaW46YWRtaW4` 文本表示 `admin:admin` 文本。如果此类用户名/密码组合成功认证，HTTP 服务器将以请求项的 JSON
    有效负载响应。如果认证失败，服务器将以 `401 Unauthorized` 状态码响应，但这次不包含 `WWW-Authenticate` 标头。
- en: Passport
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Passport
- en: There are plenty of authentication methods to choose from nowadays. Perhaps
    the most popular methods are basic authentication, where each user has their own
    username and password, and third-party authentication, where users can identify
    themselves with their already-existing account for an external public service,
    such as personal social services such as LinkedIn, Facebook, and Twitter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多认证方法可供选择。可能最受欢迎的方法是基本认证，其中每个用户都有自己的用户名和密码，以及第三方认证，用户可以使用他们已经存在的账户来识别自己，例如个人社交服务如
    LinkedIn、Facebook 和 Twitter。
- en: Choosing the most appropriate type of authentication for a web API depends mainly
    on its consumers. Apparently, an application consuming an API to fetch data is
    not likely to authenticate with a personal social account. This approach is more
    suitable when the API is used via a frontend directly by a human being.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最适合 Web API 的认证类型主要取决于其消费者。显然，一个消费 API 以获取数据的程序不太可能使用个人社交账户进行认证。这种方法更适合 API
    通过前端直接由人类使用的情况。
- en: Implementing a solution capable of switching between different authentication
    methods easily is a complex and time-consuming task. In fact, it can become hardly
    possible if not considered at the initial design phase of an application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一种能够轻松在不同的认证方法之间切换的解决方案是一个复杂且耗时的工作。实际上，如果不考虑应用程序的初始设计阶段，这可能几乎是不可能的。
- en: '**Passport** is a piece of authentication middleware for Node.js, created especially
    for use-cases where the means of authentication should be easily switched from
    one to another. It has modular architecture that enables the usage of a specific
    authentication provider, called **strategy**. The strategy takes care of implementing
    a chosen authentication approach.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Passport** 是一个针对 Node.js 的认证中间件，专门为那些需要轻松在一种认证方式之间切换的场景而创建。它具有模块化架构，使得可以使用特定的认证提供者，称为
    **strategy**。策略负责实现所选的认证方法。'
- en: There are plenty of authentication strategies to choose from, for example, a
    regular basic authentication strategy or social platform-based strategies for
    services such as Facebook, LinkedIn, and Twitter. Refer to the official Passport
    website, [http://www.passportjs.org/](http://www.passportjs.org/), for a complete
    list of the available strategies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多认证策略可供选择，例如，常规的基本认证策略或基于社交平台的策略，如 Facebook、LinkedIn 和 Twitter。有关可用策略的完整列表，请参考官方
    Passport 网站，[http://www.passportjs.org/](http://www.passportjs.org/)。
- en: Passport's basic authentication strategy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Passport 的基本认证策略
- en: Now it is time to look at how to utilize Passport's strategies; we will start
    with the basic authentication strategy; it is a logical choice now that we know
    how basic authentication works.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看如何利用 Passport 的策略了；我们将从基本的认证策略开始；既然我们已经知道了基本认证是如何工作的，这是一个逻辑上的选择。
- en: 'As usual, we will start by installing the relevant modules with the NPM package
    manager. We will need the `passport` module, which provides the base functionality
    that allows you to plug in different authentication strategies, and a concrete
    strategy for basic authentication, provided by the `passport-http` module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将使用 NPM 包管理器安装相关的模块。我们需要 `passport` 模块，它提供了基础功能，允许你插入不同的认证策略，以及由 `passport-http`
    模块提供的具体的基本认证策略：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we have to instantiate both the Passport middleware and the basic authentication
    strategy. `BasicStrategy` takes as an argument a callback function, which checks
    whether the provided username/password combination is valid. Finally, passport''s
    authenticate method is provided as a middleware function to the express route,
    assuring that unauthenticated requests will be rejected with an appropriate `401
    Unauthorized` status:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须实例化Passport中间件和基本认证策略。`BasicStrategy`将一个回调函数作为参数，该函数检查提供的用户名/密码组合是否有效。最后，Passport的authenticate方法作为中间件函数提供给express路由，确保未经认证的请求会被拒绝，并返回适当的`401未授权`状态：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `BasicStrategy` constructor takes a handler function as an argument. It
    gives us access to the username and password supplied by the client, and to the
    Passport middleware''s `done()` function, which notifies Passport with whether
    the user has been successfully authenticated. Invoke the `done()` function with
    `user` as an argument in order to grant authentication, or pass the `error` argument
    to it to revoke the authentication:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicStrategy`构造函数接受一个处理函数作为参数。它为我们提供了访问客户端提供的用户名和密码，以及Passport中间件的`done()`函数，该函数通知Passport用户是否已成功认证。通过将`user`作为参数调用`done()`函数来授予认证，或者通过传递`error`参数来撤销认证：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, use the `passort` `authenticate()` function in the router middleware
    to attach it to a specific HTTP method-handler function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在路由中间件中使用`passort` `authenticate()`函数将其附加到特定的HTTP方法处理器函数。
- en: In our case, we specify that we don't want to store any authentication details
    in a session. This is because, when using basic authentication, there is no need
    to store any user information in a session, as each request contains the `Authorization`
    header that provides the login details.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们指定我们不想在会话中存储任何认证细节。这是因为，当使用基本认证时，没有必要在会话中存储任何用户信息，因为每个请求都包含提供登录详情的`Authorization`头。
- en: Passport's OAuth Strategy
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Passport的OAuth策略
- en: OAuth is an open standard for third party authorization, it defines a delegation
    protocol used fer authorizing against a third party authentication providers.
    OAuth uses special tokens, once issued,  identify the user instead of user credentials.
    Let's look closer at OAuth workflow, with a sample scenario. The main actors in
    the scenario are - a **user** interacting with a **web application,** which consumes
    a restful service from a **back-end** system  providing some kind of data. The
    web application delegates its authorization to a separate **third-party authorization
    server.**
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一个第三方授权的开放标准，它定义了一个用于授权第三方认证提供者的委托协议。OAuth使用特殊的令牌，一旦颁发，就代替用户凭据来识别用户。让我们更详细地看看OAuth工作流程，以及一个示例场景。场景中的主要参与者是一个**用户**，他与**Web应用程序**交互，该应用程序从提供某种数据的**后端**系统中消费RESTful服务。Web应用程序将它的授权委托给一个单独的**第三方授权服务器**。
- en: '![](img/75f57608-98ed-4992-994a-8398fea14145.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75f57608-98ed-4992-994a-8398fea14145.png)'
- en: The user requests a web application which requires authentication to establish
    communication with the back-end service. This is the initial request thus the
    user is still not authenticated, so they get redirected to a login page asking
    for their credentials for the relevant third party account.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户请求一个需要认证的Web应用程序，以与后端服务建立通信。这是初始请求，因此用户尚未认证，所以他们会被重定向到登录页面，要求他们提供相关第三方账户的凭据。
- en: After a successful authentication an authorization code is issued by the authentication
    server to the web application. This authorization code is a composite combination
    between an issued client-id and a secret issued by the provider. They should be
    sent from a web application to the authentication server and is exchanged for
    an access token that has a limited lifetime.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功认证后，认证服务器向Web应用程序颁发一个授权码。这个授权码是颁发给客户端的客户端ID和提供者颁发的秘密的组合。它们应该从Web应用程序发送到认证服务器，并交换为有限生命周期的访问令牌。
- en: The Web application uses the authentication token for authentication until it
    gets expired. Afterwards it has to request a new token using the authorization
    code.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络应用程序使用认证令牌进行认证，直到其过期。之后，它必须使用授权码请求一个新的令牌。
- en: Passport.js hides the complexity behind this process with a separate strategy
    module automating the OAuth workflow. It is available in the `npm` repository
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js通过一个单独的策略模块隐藏了此过程的复杂性，该模块自动化OAuth工作流程。它在`npm`仓库中可用。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create an instance of the strategy and supply it with the urls for requesting
    tokens and for authenticating it together, it is your personal consumer key and
    a secret phrase of your choice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建策略的实例，并为其提供请求令牌和进行身份验证的 URL，以及它个人的消费者密钥和您选择的秘密短语。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Passport.js provides separate strategy wrapping different providers, like linkedin
    or github. They ensure that your application stays up to date with the token issuing
    URLs. Once you have made up your mind about the provider you want to support,
    you should check for specific strategies for them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js 提供了针对不同提供者的独立策略包装，例如领英或 GitHub。它们确保您的应用程序与令牌发行 URL 保持最新。一旦您决定了想要支持的提供者，您应该检查它们的具体策略。
- en: Passport's third-party authentication strategies
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Passport 的第三方身份验证策略
- en: Today, almost everyone owns at least one personal public social media account,
    such as Twitter, Facebook, and LinkedIn. Recently, it has become really popular
    for websites to allow their visitors to authenticate themselves via one of their
    social accounts by just clicking on an icon to bind their social service account
    to a service-internal automatically generated account.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，几乎每个人都至少拥有一个个人公开的社交媒体账户，例如 Twitter、Facebook 和领英。最近，网站允许他们的访客通过点击图标来通过他们的社交账户进行身份验证，从而将他们的社交服务账户绑定到服务内部自动生成的账户，这已经成为一种非常流行的做法。
- en: This approach is very convenient for web users who are usually permanently logged
    into at least one of their accounts. If they are not currently logged in, clicking
    on an icon will redirect them to their social service login page, and, after a
    successful login, another redirection takes place, ensuring that the user gets
    the content they originally requested. When it comes to exposing data via a web
    API, this approach is not really an option.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于通常永久登录至少一个账户的 Web 用户来说非常方便。如果他们当前未登录，点击图标将把他们重定向到他们的社交服务登录页面，并在成功登录后发生另一次重定向，确保用户获得他们最初请求的内容。当涉及到通过
    Web API 暴露数据时，这种方法并不是一个真正的选择。
- en: Publicly exposed APIs cannot predict whether they are to be consumed by a human
    or by an application. Also, APIs aren't usually consumed directly by humans. Thus,
    third-party authentication is the only option when you, as API authors, are convinced
    that the exposed data will be directly available to the end users who have requested
    it manually through a frontend from an internet browser. Once they have successfully
    logged into their social account, a unique user identifier will be stored in a
    session, so your service will need to be able to handle such sessions appropriately.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 公开暴露的 API 无法预测它们将被人类还是应用程序消费。此外，API 通常不会直接由人类消费。因此，当您作为 API 作者确信公开的数据将直接可供通过前端从互联网浏览器手动请求它的最终用户时，第三方身份验证是唯一的选择。一旦他们成功登录到他们的社交账户，一个唯一的用户标识符将被存储在会话中，因此您的服务需要能够适当地处理此类会话。
- en: 'To enable session support for storing user login information with Passport
    and Express, you have to initialize the Express session middleware before initializing
    Passport and its session middleware:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Passport 和 Express 的会话支持以存储用户登录信息，您必须在初始化 Passport 和其会话中间件之前初始化 Express
    会话中间件：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, specify the user whose details Passport should serialize/deserialize
    into or out of the session. For that purpose, Passport provides the `serializeUser()`
    and `deserializeUser()` functions, which store complete user information in a
    session:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，指定 Passport 应将用户详细信息序列化/反序列化到或从会话中的用户。为此，Passport 提供了 `serializeUser()` 和
    `deserializeUser()` 函数，它们将完整用户信息存储在会话中：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The order of initializing the session handling of the Express and Passport middleware
    is important. The Express session should be passed to the application first and
    should be followed by the Passport session.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化 Express 和 Passport 中间件的会话处理顺序很重要。Express 会话应首先传递给应用程序，然后是 Passport 会话。
- en: After enabling session support, you have to decide which third-party authentication
    strategy to rely on. Basically, third-party authentication is enabled via a plugin
    or application created by the third-party provider, for example, a social service
    site. We will briefly look at creating a LinkedIn application that allows authentication
    via the OAuth standard.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用会话支持后，您必须决定依赖哪种第三方身份验证策略。基本上，第三方身份验证是通过第三方提供者创建的插件或应用程序启用的，例如社交服务网站。我们将简要了解创建一个允许通过
    OAuth 标准进行身份验证的领英应用程序。
- en: 'Usually, this is done via a pair of public key and a secret (token) associated
    with the social media application. Creating a LinkedIn application is easy—you
    just have to log into [http://www.linkedin.com/secure/developer](http://www.linkedin.com/secure/developer)
    and fill out a brief application information form. You will be given a secret
    key and a token to enable the authentication. Perform the following steps to enable
    LinkedIn authentication:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是通过一对与社交媒体应用程序关联的公钥和密钥（令牌）来完成的。创建LinkedIn应用程序很简单——您只需登录到[http://www.linkedin.com/secure/developer](http://www.linkedin.com/secure/developer)并填写简短的应用信息表单。您将获得一个密钥和一个令牌以启用身份验证。执行以下步骤以启用LinkedIn身份验证：
- en: Install the `linkedin-strategy` module—`npm install linkedin-strategy`
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`linkedin-strategy`模块—`npm install linkedin-strategy`
- en: 'Get an instance of the LinkedIn strategy and initialize it to the Passport
    middleware by the `use()` function after session support has been enabled:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启用会话支持后，通过`use()`函数获取LinkedIn策略的实例并将其初始化为Passport中间件：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Explicitly specify that the LinkedIn strategy should be used as Passport for
    each individual route, ensuring that session handling is enabled:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确指定LinkedIn策略应作为每个单独路由的护照使用，确保会话处理已启用：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Provide a means for a user to log out by exposing a logout URI, making use
    of `request.logout`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一种方式，允许用户通过公开注销URI来注销，使用`request.logout`：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The given third-party URLs and service data are subject to change. You should
    always refer to the service policy when providing third-party authentication.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的第三方URL和服务数据可能会发生变化。在提供第三方身份验证时，您应始终参考服务策略。
- en: Authorization
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: So far, the catalog data service uses basic authentication to protect its routes
    from unknown users; however, a catalog application should allow only few white-listed
    users to modify the items inside the catalog. To restrict access to the catalog,
    we will introduce the concept of authorization, that is, a subset of authenticated
    users, with appropriate permission allowed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，目录数据服务使用基本身份验证来保护其路由免受未知用户的影响；然而，目录应用程序应仅允许少数白名单用户修改目录中的条目。为了限制对目录的访问，我们将引入授权的概念，即一组经过身份验证的用户子集，允许他们拥有适当的权限。
- en: 'When Passport''s `done()` function is invoked to authenticate a successful
    login, it takes as an argument a `user` instance of the user that has been granted
    authentication. The `done()` function adds that user model instance to the `request`
    object, and, in this way, provides access to it via the `request.user` property,
    after successful authentication. We will make use of that property to implement
    a function performing the authorization check after successful authentication:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当Passport的`done()`函数被调用以进行成功的登录认证时，它将作为参数接收一个已授权用户的`user`实例。`done()`函数将此用户模型实例添加到`request`对象中，并通过`request.user`属性提供对它的访问，在成功认证后。我们将利用该属性在成功认证后实现一个执行授权检查的函数：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The HTTP 403 Forbidden status code can be easily confused with 405 Not allowed.
    However, the 405 Not Allowed status code indicates that a specific HTTP verb is
    not supported by the requested resource, so it should be used only in that context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 403 Forbidden状态码很容易与405 Not Allowed混淆。然而，405 Not Allowed状态码表示请求的资源不支持特定的HTTP动词，因此它应仅在该上下文中使用。
- en: The `authorize()` function will close the `response` stream, returning the `403
    Forbidden` status code, which indicates that the logged-in user is recognized
    but has insufficient permissions. This revokes access to the resource. This function
    has to be used in each route that carries out data manipulation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorize()`函数将关闭`response`流，返回`403 Forbidden`状态码，这表示已识别的登录用户权限不足。这会撤销对资源的访问。此函数必须在执行数据操作的每个路由中使用。'
- en: 'Here''s an example of how a `post` route implements authorization:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个`post`路由实现授权的示例：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After `authorize()` is invoked, we check whether the `response` object still
    allows writing to its output by checking the value of the closed property of the
    `response` object. It will return `true` once the end function of the `response`
    object has been called, which is exactly what the `authorize()` function does
    when the user lacks admin permissions. Thus, we can rely on the closed property
    in our implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`authorize()`之后，我们检查`response`对象是否仍然允许写入其输出，通过检查`response`对象的closed属性值。一旦调用`response`对象的end函数，它将返回`true`，这正是`authorize()`函数在用户缺乏管理员权限时所做的。因此，我们可以在我们的实现中依赖closed属性。
- en: Transport layer security
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层安全
- en: Publicly available information in the web easily becomes the subject of different
    types of cyber attacks. Often it is not enough just to keep the so-called "bad
    guys" out. Sometimes, they won't bother gaining authentication at all and may
    prefer to carry out a **man-in-the-middle** (**MiM**) attack, pretending to be
    the final receiver of a message and sniffing the communication channel that transmits
    the data—or, even worse, altering the data while it flows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 网上公开的信息很容易成为不同类型网络攻击的目标。通常，仅仅阻止所谓的“坏人”是不够的。有时，他们甚至懒得获取认证，可能更愿意执行**中间人攻击**（**MiM**），假装自己是消息的最终接收者，窃听传输数据的通信通道——或者更糟糕的是，在数据传输过程中篡改数据。
- en: Being a text-based protocol, HTTP transfers data in a human-readable format,
    which makes it an easy victim of MiM attacks. Unless transferred in an encrypted
    format, all the catalog data of our service is vulnerable to MiM attacks. In this
    section, we will switch our transport from an insecure HTTP protocol to the secure
    HTTPS protocol.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种基于文本的协议，HTTP以人类可读的格式传输数据，这使得它很容易成为MiM攻击的受害者。除非以加密格式传输，否则我们服务的所有目录数据都容易受到MiM攻击。在本节中，我们将从不安全的HTTP协议切换到安全的HTTPS协议。
- en: HTTPS is secured by asymmetric cryptography, also known as **public-key encryption**.
    It is based on a pair of keys that are mathematically related. The key used for
    encryption is called **public key**, and the key used for decryption is called
    **private key**. The idea is to freely provide the encryption key to partners
    who have to send encrypted messages and to perform decryption with the private
    key.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS由非对称加密技术保护，也称为**公钥加密**。它基于一对在数学上相关的密钥。用于加密的密钥称为**公钥**，用于解密的密钥称为**私钥**。其想法是向必须发送加密消息并使用私钥进行解密的合作伙伴自由提供加密密钥。
- en: 'A typical public-key encryption communication scenario between two parties,
    *A* and *B*, will be the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 两个当事人，*A*和*B*之间典型的公钥加密通信场景如下：
- en: Party *A* composes a message, encrypts it with Party B's public key, and sends
    it
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事人*A*编写消息，使用当事人*B*的公钥对其进行加密，并发送。
- en: Party *B* decrypts the message with its own private key and processes it
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事人*B*使用自己的私钥解密消息并处理它。
- en: Party *B* composes a response message, encrypts it with Party *A*'s public key,
    and then sends it
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事人*B*编写响应消息，使用当事人*A*的公钥对其进行加密，然后发送。
- en: Party *A* decrypts the response message with its own private key
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事人*A*使用自己的私钥解密响应消息。
- en: 'Now that we know how public-key encryption works, let''s go through a sample
    of HTTPS client-server communication, as shown in this diagram:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了公钥加密的工作原理，让我们通过这个图表中的HTTPS客户端-服务器通信示例来了解一个样本：
- en: '![](img/7e9cca56-58bb-4d83-ac09-b630c429fe3a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e9cca56-58bb-4d83-ac09-b630c429fe3a.png)'
- en: The client sends an initial request against an SSL-secured endpoint. The server
    responds to that request by sending its public key to be used for encrypting further
    incoming requests. Then, the client has to check the validity and verify the identity
    of the received key. After successful verification of the server's public key,
    the client has to send its own public key back to the server. Finally, after the
    key exchange procedure is complete, the two parties can start communicating securely.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向一个SSL加密的端点发送初始请求。服务器通过发送用于加密进一步传入请求的公钥来响应该请求。然后，客户端必须检查公钥的有效性并验证接收到的公钥的身份。在成功验证服务器的公钥后，客户端必须将其自己的公钥发送回服务器。最后，在密钥交换过程完成后，双方可以开始安全通信。
- en: HTTPS relies on trust; thus, it is vital to have a reliable way of checking
    whether a specific public key belongs to a specific server. Public keys are exchanged
    within an X.509 certificate, which has a hierarchical structure. This structure
    enables clients to check whether a given certificate has been generated from a
    trusted root certificate. Clients should trust only certificates that have been
    issued by a known **certificate authority** (**CA**).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS依赖于信任；因此，有一个可靠的方式来检查特定的公钥是否属于特定的服务器至关重要。公钥在X.509证书中进行交换，该证书具有分层结构。这种结构使客户端能够检查给定的证书是否由受信任的根证书生成。客户端应仅信任由已知**证书颁发机构**（**CA**）签发的证书。
- en: Before switching our service to use the HTTPS transport, we need a public/private
    key pair. Since we are not a certificate authority, we will have to use OpenSSL
    tooling to generate test keys for us.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的服务切换到使用HTTPS传输之前，我们需要一个公钥/私钥对。由于我们不是证书颁发机构，我们将不得不使用OpenSSL工具为我们生成测试密钥。
- en: 'OpenSSL is available for download at [http://www.openssl.org/](http://www.openssl.org/),
    where source code distributions are available for all popular operating systems.
    OpenSSL can be installed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 可在 [http://www.openssl.org/](http://www.openssl.org/) 下载，那里提供了所有流行操作系统的源代码发行版。以下是如何安装
    OpenSSL 的说明：
- en: 'Binary distribution is available for download for Windows, and Debian and Ubuntu
    users can make use of the packaged distribution by executing the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制发行版可供下载，Windows 用户可以通过执行以下命令来使用打包的发行版：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Windows users will have to set an environment variable, OPENSSL_CNF, specifying
    the location of the `openssl.cnf` configuration file, typically located in the
    share directory in the installation archive.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户必须设置一个环境变量，OPENSSL_CNF，指定 `openssl.cnf` 配置文件的位置，通常位于安装存档中的共享目录中。
- en: 'Now let''s generate a test key/value pair with OpenSSL:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用 OpenSSL 生成一个测试的键/值对：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: OpenSSL will prompt some details required for generating the certificate, such
    as country code, city, and fully qualified domain name. Afterward, it will generate
    a private key in the `catalog.pem` file and a public key certificate that will
    be valid for a year in the `catalog.crt` file. We will be using these newly generated
    files, so copy them into a new subdirectory, called `ssl`, in the catalog data
    service directory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 将提示生成证书所需的一些详细信息，例如国家代码、城市和完全合格的域名。之后，它将在 `catalog.pem` 文件中生成一个私钥，并在
    `catalog.crt` 文件中生成一个有效期为一年的公钥证书。我们将使用这些新生成的文件，所以将它们复制到目录 `ssl` 中，该目录位于目录数据服务目录下。
- en: 'Now we have everything needed to modify our service to use HTTPS:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了修改我们的服务以使用 HTTPS 所需的一切：
- en: 'First, we need to switch and use the HTTPS module instead of HTTP and specify
    the port that we want to use to enable HTTPS communication:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要切换并使用 HTTPS 模块而不是 HTTP，并指定我们想要用于启用 HTTPS 通信的端口：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we have to read the private key from the `catalog.cem` file and the certificate
    from `catalog.crt` into an array:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须从 `catalog.cem` 文件中读取私钥，并从 `catalog.crt` 文件中读取证书到数组中：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we pass the array containing the key pair to the HTTPS instance when
    creating the server and start listening through the specified port:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在创建服务器时将包含密钥对的数组传递给 HTTPS 实例，并通过指定的端口开始监听：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's all you need to do to enable HTTPS for an Express-based application.
    Save your changes and give it a try by requesting `https://localhost:3443/catalog/v2`
    in a browser. You will be shown a warning message informing you that the server
    you are connecting to is using a certificate that is not issued by a trusted certificate
    authority. That's normal, as we generated the certificate on our own, and we are
    not a CA for sure, so just ignore that warning.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要为基于 Express 的应用程序启用 HTTPS，你需要做的就这些。保存你的更改，并在浏览器中请求 `https://localhost:3443/catalog/v2`
    来尝试一下。你将看到一个警告信息，告知你你正在连接的服务器使用的证书不是由受信任的证书颁发机构签发的。这是正常的，因为我们自己生成了证书，我们肯定不是 CA，所以只需忽略那个警告。
- en: Before deploying a service on a production environment, you should always ensure
    that you use a server certificate issued by a trusted CA.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在将服务部署到生产环境之前，你应该始终确保你使用的是受信任的 CA 签发的服务器证书。
- en: Self-test questions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'Go through the following questions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些问题：
- en: Is HTTP basic authentication secure against man-in-the-middle attacks?
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 基本认证能否抵御中间人攻击？
- en: What are the benefits of Transport Layer Security?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层安全协议的好处是什么？
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to protect exposed data by enabling a means
    of authentication and authorization. This is a critical aspect of any publicly
    available data service. In addition, you learned how to prevent man-in-the-middle
    attacks using the secured layer transport protocol between a service and its users.
    As a developer of such services, you should always consider the most appropriate
    security features that your application should support.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过启用身份验证和授权手段来保护暴露的数据。这是任何公开数据服务的关键方面。此外，你还学习了如何通过在服务和其用户之间使用安全层传输协议来防止中间人攻击。作为此类服务的开发者，你应该始终考虑应用程序应支持的最合适的安全功能。
- en: I hope this was a useful experience! You gained enough knowledge and practical
    experience, which should have made you much more confident in understanding how
    RESTful APIs work and how they are designed and developed. I strongly encourage
    you to go through the code evolution chapter by chapter. You should be able to
    further refactor it, adopting it to your own coding style. Of course, some parts
    of it can be further optimized, as they repeat quite often. That is an intentional
    decision rather than good practice, as I wanted to emphasize their importance.
    You should always strive to improve your code-base, making it easier to maintain.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这是一个有用的经历！你们获得了足够的知识和实践经验，这应该使你们在理解 RESTful API 的工作原理以及它们是如何设计和开发的方面更加自信。我强烈建议你们逐章阅读代码演变部分。你们应该能够进一步重构它，使其适应自己的编码风格。当然，其中一些部分可以进一步优化，因为它们重复出现的频率相当高。这是一个有意的决定，而不是良好的实践，因为我想要强调它们的重要性。你们应该始终努力改进代码库，使其更容易维护。
- en: Finally, I would like to encourage you to always follow the development of the
    `Node.js` modules you use in your applications. Node.js has an extraordinary community
    that is eager to grow rapidly. There is always something exciting going on there,
    so ensure that you don't miss it. Good luck!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想鼓励你们始终关注你们在应用程序中使用到的 `Node.js` 模块的发展。Node.js 拥有一个渴望快速成长的非凡社区。那里总是有令人兴奋的事情发生，所以请确保不要错过。祝你好运！
