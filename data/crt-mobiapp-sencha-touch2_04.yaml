- en: Chapter 4. Weight Weight
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。体重 体重
- en: In this chapter we will explore an optional add-on package to the Sencha Touch
    Framework. The package is called Sencha Charts and it enables us to create charts
    using a data store.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Sencha Touch 框架的可选附加包。该包称为 Sencha Charts，它使我们能够使用数据存储来创建图表。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Building the basic application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基本应用程序
- en: Defining the data stores
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据存储
- en: Setting up the Sencha Charts package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Sencha Charts 包
- en: Connecting the stores to Sencha Charts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将商店连接到 Sencha Charts
- en: Configuring and displaying the charts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和显示图表
- en: Sencha Charts overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sencha Charts 概览
- en: The basic Sencha Touch Framework has a number of components for displaying data.
    However, business and other intensive software products often require something
    a bit more robust. By using Sencha Touch Charts, we can also display complex graphical
    data as part of our applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 Sencha Touch 框架提供了一些用于显示数据的组件。然而，商业和其他密集型软件产品通常需要更健壮的解决方案。通过使用 Sencha Touch
    Charts，我们还可以将复杂图形数据作为我们应用程序的一部分来显示。
- en: 'The following screenshot exemplifies an overview of chart and graph types for
    displaying data:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了用于显示数据的图表和图形类型的概览：
- en: '![Sencha Charts overview](img/8901OS_04_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Sencha Charts 概览](img/8901OS_04_01.jpg)'
- en: 'These new components use data stores to display a wide range of chart and graph
    types including:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新组件使用数据存储来显示各种图表和图形类型，包括：
- en: Pie
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图
- en: Bar
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柱状图
- en: Line
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折线图
- en: Scatter
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图
- en: Area
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面积图
- en: Candlestick
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K 线图
- en: Radar
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雷达图
- en: Gauge
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表盘
- en: We will be using a few of these charts to provide a more user-friendly display
    for our application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些图表中的几个来为我们的应用程序提供更友好的显示。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: As of writing, the Sencha Charts package is only available as a part of Sencha
    Complete, or the open source version (GPL) of Sencha Touch 2.1 download. For this
    chapter, we will be using the open source version, which can be downloaded for
    free from the web page at [http://www.sencha.com/products/touch/download/](http://www.sencha.com/products/touch/download/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 截至编写时，Sencha Charts 包仅作为 Sencha Complete 的一部分提供，或者 Sencha Touch 2.1 的开源版本（GPL）下载。对于本章，我们将使用开源版本，可以从网页
    [http://www.sencha.com/products/touch/download/](http://www.sencha.com/products/touch/download/)
    免费下载。
- en: Later on in the chapter, we will cover the basic setup for using Sencha Charts,
    but first, we will take a look at setting up the basic application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将介绍使用 Sencha Charts 的基本设置，但首先，我们将查看设置基本应用程序的过程。
- en: The basic application
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本应用程序
- en: We will use the Sencha Charts package to create a program for tracking weight,
    exercise, calories, and water consumption. We will also allow the user to tag
    entries for adding additional information to the charts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Sencha Charts 包来创建一个跟踪体重、锻炼、卡路里和水分摄入的程序。我们还将允许用户为图表添加额外的信息。
- en: 'The application consists of four basic pieces as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由以下四个基本部分组成：
- en: A form for entering data
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于输入数据的表单
- en: An overview that will provide a group of charts on a single page
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个概览，将在单页面上提供一组图表
- en: A details section for viewing a specific chart in greater detail
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个详细部分，用于查看特定图表的详细信息
- en: A configuration section that will allow the user to set goals for our four categories,
    and define the units of measurement for weight and water consumption
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个配置部分，允许用户为我们的四个类别设置目标，并定义体重和水分摄入量的计量单位
- en: We will start by setting up the basic application and building our form.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置基本应用程序并构建我们的表单。
- en: Setting up the application and building the form
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序和构建表单
- en: 'We will be using the Sencha Command SDK to create the application as described
    in the previous chapter. You will need to execute this command from the `Sencha
    Touch` directory. The basic command is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一章中描述的 Sencha Command SDK 来创建应用程序。您需要从 `Sencha Touch` 目录执行此命令。基本命令如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you prefer, you can create the initial directories and files yourself. Your
    file and directory structure should look something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以自己创建初始目录和文件。您的文件和目录结构应该看起来像这样：
- en: '![Setting up the application and building the form](img/8901OS_04_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![设置应用程序和构建表单](img/8901OS_04_02.jpg)'
- en: The previous screenshot shows the structure that is automatically generated
    with the `sencha app create` command.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了使用 `sencha app create` 命令自动生成的结构。
- en: The `touch` directory contains a copy of the Sencha Touch Framework including
    our chart functions.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch` 目录包含 Sencha Touch 框架的副本，包括我们的图表功能。'
- en: The `resources` directory will contain our images and CSS files.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`目录将包含我们的图片和CSS文件。'
- en: The `app` directory will contain the bulk of our code.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`目录将包含我们大部分的代码。'
- en: 'To begin, we need to define our main view. This file will be called `main.js`
    and it belongs to the `views` folder. The `main.js` file is a simple tab panel
    with four items:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们的主视图。这个文件将被称为`main.js`，它属于`views`文件夹。`main.js`文件是一个简单的标签面板，包含四个项目：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need to make sure that this component is added into our `app.js` file
    in the `views` section of our `Ext.application` function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保将此组件添加到我们的`app.js`文件中，在`Ext.application`函数的`views`部分：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remember that the name we list under the view is not the file name (`Main.js`),
    it''s the last part of the define statement at the top of our code: `WeightWeight.view.Main`.
    Once we have this setup, let''s create four placeholder files, one for each panel
    in our tab view.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在视图下列出的名称不是文件名（`Main.js`），而是我们代码顶部定义语句的最后一部分：`WeightWeight.view.Main`。一旦我们设置好这个，让我们为我们的标签视图中的每个面板创建四个占位符文件。
- en: We need to create a placeholder for `dataentry`, `overview`, `details`, and
    `configform` panels. These files will contain starter code for each panel or form
    in our application. This will let us test our application without getting errors
    for missing files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为`dataentry`、`overview`、`details`和`configform`面板创建占位符。这些文件将包含我们应用程序中每个面板或表单的起始代码。这将使我们能够在不出现缺失文件错误的情况下测试我们的应用程序。
- en: 'Let''s have a look at how to test our application by using the starter code
    for each panel:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过每个面板的起始代码来测试我们的应用程序：
- en: 'Create a `dataentry.js` file in the `views` directory. This will be a form
    panel so the starter code should be set as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`views`目录下创建一个`dataentry.js`文件。这将是一个表单面板，因此起始代码应设置如下：
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to create an `overview.js` file with a simple panel in the `views`
    directory and set the code as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`views`目录中创建一个`overview.js`文件，并设置一个简单的面板，代码如下：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `view/details.js` file is also a panel like the previous `overview.js`
    file. The code is as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`view/details.js`文件与之前的`overview.js`文件类似，也是一个面板。代码如下：'
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And finally, the `views/config.js` file, which is also a form panel like the
    `dataentry.js` file. The code is as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是`views/config.js`文件，它也是一个与`dataentry.js`文件类似的表单面板。代码如下：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once all the views are created, we need to remember to add them to the `views`
    section in our `app.js` file (where we added `Main` previously). In the `app js`
    file, set the `views` section as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有视图都创建完成，我们需要记住将它们添加到`app.js`文件中的`views`部分（我们之前添加了`Main`）。在`app js`文件中，将`views`部分设置如下：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We should now be able to load the code and test our panels.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够加载代码并测试我们的面板。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Small steps**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**小步骤**'
- en: Creating code can be a very involved process. It is often helpful to make small
    changes and then test, rather than changing a few hundred lines of code and then
    testing. By changing small amounts of code, you should be able to track down problems
    quicker when they occur. In this case, by creating these starter files, we can
    test to make sure that Sencha is locating the files correctly and that the application
    starts without errors. We can then work on one file at a time and limit the places
    where we need to look when things go boom.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码可能是一个非常复杂的过程。通常，先进行小幅度修改并测试，而不是修改几百行代码后再测试，这样做往往更有帮助。通过修改少量代码，当问题发生时，你应该能够更快地追踪到问题。在这种情况下，通过创建这些起始文件，我们可以测试以确保Sencha正确地定位文件，并且应用程序可以无错误地启动。然后我们可以一次处理一个文件，并限制在出现问题时需要查找的地方。
- en: '![Setting up the application and building the form](img/8901OS_04_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![设置应用程序和构建表单](img/8901OS_04_03.jpg)'
- en: At this point, our application should simply start and allow us to switch between
    our views. This confirms that the application is working and then we can start
    creating our form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序应该简单地启动并允许我们在视图之间切换。这确认了应用程序正在工作，然后我们可以开始创建我们的表单。
- en: Creating the data entry form
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据输入表单
- en: 'Our data entry form consists of:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据输入表单包括：
- en: 'Three fields: `datepickerfield` for setting the date, `numberfield` for each
    of our four categories (weight, water, calories, and exercise), and `hiddenfield`
    for storing our tag value for the entry.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个字段：`datepickerfield`用于设置日期，`numberfield`用于我们四个类别（体重、水分、卡路里和锻炼）中的每一个，以及`hiddenfield`用于存储我们的条目标签值。
- en: 'Three buttons: One for adding tags, one for saving, and one for canceling and
    clearing the form.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个按钮：一个用于添加标签，一个用于保存，一个用于取消并清除表单。
- en: We will also place the **Cancel** and **Save** buttons inside an Hbox layout
    container. This will let us display the buttons side by side.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将把 **取消** 和 **保存** 按钮放在一个 Hbox 布局容器内。这将使我们能够并排显示按钮。
- en: 'We will replace the line in `view/DataEntry.js` that says `html: ''Data Entry''`
    so that the code looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将替换 `view/DataEntry.js` 中的那一行，该行说 `html: ''Data Entry''`，以便代码看起来像这样：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have also provided margins for each of our items to add spacing to the form,
    making it more readable. The end result should look something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们的每个项目提供了边距，以在表单中添加间距，使其更易于阅读。最终结果应该看起来像这样：
- en: '![Creating the data entry form](img/8901OS_04_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据录入表单](img/8901OS_04_04.jpg)'
- en: The next view we need to create is the one for adding our tags. We will use
    a sheet to achieve this.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的下一个视图是添加我们的标签的视图。我们将使用一个表格来完成这个任务。
- en: Creating the AddTag view
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AddTag 视图
- en: 'The `AddTag` view is embedded in an `ActionSheet` component. This view will
    allow us to add new tags or select from the previous ones, and the `ActionSheet`
    component will display the view as an overlay that slides up from the bottom of
    the screen. The form contains a single field called `textfield`, a `list` view,
    and two buttons. Create the file in the `views` directory and call it `AddTag.js`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddTag` 视图嵌入在一个 `ActionSheet` 组件中。这个视图将允许我们添加新的标签或从之前的标签中选择，`ActionSheet`
    组件将作为从屏幕底部滑上的覆盖层显示视图。表单包含一个名为 `textfield` 的单行文本字段、一个 `list` 视图和两个按钮。在 `views`
    目录中创建文件，并命名为 `AddTag.js`：'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have used the `alias` configuration to give this component an `xtype` property.
    This will let us quickly create and remove it within our program. We have also
    given the component an `id` property so that we can reference it in our controller.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 `alias` 配置为这个组件提供了一个 `xtype` 属性。这将使我们能够在程序中快速创建和删除它。我们还为组件提供了一个 `id`
    属性，以便我们可以在控制器中引用它。
- en: 'The end result should look something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该看起来像这样：
- en: '![Creating the AddTag view](img/8901OS_04_05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![创建 AddTag 视图](img/8901OS_04_05.jpg)'
- en: The `list` component is a placeholder for now. We will finish it later once
    we have our data stores set up.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 组件目前是一个占位符。一旦我们设置了数据存储，我们将在之后完成它。'
- en: The next view we need to set up is the config form. This will be similar to
    our data entry form with a few different field types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置的下一个视图是配置表单。这将类似于我们的数据录入表单，但有一些不同的字段类型。
- en: Creating the config form
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建配置表单
- en: 'We will start by editing the `Config.js` placeholder file that we set up earlier
    in the chapter. The code for it is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编辑本章中较早设置的 `Config.js` 占位符文件。它的代码如下：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `alias` property allows us to call the panel by a custom xtype of config
    form. This is the `xtype` property we used in our `Main.js` file for the fourth
    panel. The `title` and `iconCls` properties control how the navigation for this
    panel appears in the main view.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias` 属性允许我们通过自定义的 xtype 或配置表单来调用面板。这是我们 `Main.js` 文件中第四个面板使用的 `xtype` 属性。`title`
    和 `iconCls` 属性控制了此面板在主视图中的导航显示方式。'
- en: 'Next, we need to add some items to our panel. We will start by adding number
    fields for `Starting Weight` and `Target Weight`. By using a `numberfield` component
    we make sure that the number keyboard will appear on most mobile devices. To keep
    the field organized, we will put them in a `fieldset` component. This will go
    in the empty `items` config:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向我们的面板添加一些项目。我们将从添加 `Starting Weight`（起始重量）和 `Target Weight`（目标重量）的数字字段开始。通过使用
    `numberfield` 组件，我们确保在大多数移动设备上会出现数字键盘。为了保持字段组织有序，我们将它们放在一个 `fieldset` 组件中。这将放入空的
    `items` 配置中：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will add a set of spinner fields. The `spinnerfield` component allows
    the user to increment the field values using **+** and **-** buttons. These will
    also be in a `fieldset` component like the previous ones:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一组旋转字段。`spinnerfield` 组件允许用户使用 **+** 和 **-** 按钮增加字段值。这些也将像之前的那样放在一个
    `fieldset` 组件中：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the `spinnerfield` component also allows us to set a `stepValue`
    configuration, which controls how much the field will increase or decrease when
    the buttons are pressed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`spinnerfield` 组件还允许我们设置 `stepValue` 配置，这控制了当按钮被按下时字段增加或减少的量。
- en: 'Lastly, we will add our units of measurement section with radio buttons for
    different selections as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加我们的单位测量部分，包含不同选择的单选按钮，如下所示：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The end form should look something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结束表单应该看起来像这样：
- en: '![Creating the config form](img/8901OS_04_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![创建配置表单](img/8901OS_04_06.jpg)'
- en: Now that we have our two forms, let's start working on the controllers for them.
    We'll start with the data entry controller.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个表单，让我们开始为它们编写控制器。我们将从数据输入控制器开始。
- en: Creating the DataEntry controller
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 DataEntry 控制器
- en: 'Let''s start off with a bare controller like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这样一个裸控制器开始：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start off by extending the basic controller and then adding a `config` section
    that will contain the rest of our initial setup code. The `refs` section will
    contain references to other components we need, and the `control` section will
    assign functions to our buttons and other components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先扩展基本控制器，然后添加一个 `config` 部分，该部分将包含我们其余的初始设置代码。`refs` 部分将包含我们需要的其他组件的引用，而
    `control` 部分将为我们的按钮和其他组件分配函数。
- en: 'The `refs` section is where we will add a reference to our `AddTag` sheet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`refs` 部分是我们将添加 `AddTag` 表格引用的地方：'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is occasionally written out in a longer form as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时会以更长的形式写出，如下所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both ways will work just fine. The reference looks for a component selector,
    in this case a component with an `id` value of `addTagSheet`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方式都可以正常工作。参考寻找一个组件选择器，在这种情况下是一个具有 `id` 值为 `addTagSheet` 的组件。
- en: 'By creating this reference using the `id` configuration of our `AddTag` sheet,
    we can access it anywhere in the controller by typing the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `AddTag` 表格的 `id` 配置创建这个参考，我们可以在控制器中的任何地方通过输入以下代码来访问它：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Notice that despite the fact that we use `tagSheet` as the reference, the `get`
    function capitalizes the first letter in our reference to `getTagSheet`. Since
    JavaScript is case sensitive, if you tried using gettagSheet, JavaScript will
    return an error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们使用了 `tagSheet` 作为参考，但 `get` 函数将我们的参考的第一个字母大写为 `getTagSheet`。由于 JavaScript
    区分大小写，如果你尝试使用 gettagSheet，JavaScript 将返回一个错误。
- en: 'Now that we have our reference, we need to add controls to the **Add Tag**
    button in our `DataEntry` form and the two buttons on our `AddTag` sheet. The
    code is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了参考，我们需要在我们的 `DataEntry` 表格中的 **添加标签** 按钮和 `AddTag` 表格上的两个按钮中添加控件。代码如下：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each of our controls has three parts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个控件都有三个部分：
- en: A DOM selector that tells the program which component we want to bind to
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 DOM 选择器，告诉程序我们想要绑定到哪个组件
- en: The event we want it to listen for
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望它监听的事件
- en: The function to fire when the event occurs
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事件发生时触发的功能
- en: We will add additional controls later on when we create our data stores. For
    now, let's add in the functions that need to fire when these three buttons are
    clicked.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建数据存储时添加额外的控件。现在，让我们添加在点击这三个按钮时需要触发的函数。
- en: 'The first is a `showAddTag` function. It calls our `AddTag` sheet and displays
    it. The function is added after the end of the `config` section and looks similar
    to the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是 `showAddTag` 函数。它调用我们的 `AddTag` 表格并显示它。该函数添加在 `config` 部分的末尾，看起来类似于以下代码：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we check to see if there is already a sheet in the memory (using the
    `this.getTagSheet()` function automatically created by our reference in the `refs`
    section), and if not, then we create a new one using the `Ext.Widget()` function
    to create a new component with an `xtype` property of `addtag`. We then add this
    sheet to the view port and show it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查内存中是否已经有一个表格（使用 `this.getTagSheet()` 函数，该函数由 `refs` 部分中的参考自动创建），如果没有，则使用
    `Ext.Widget()` 函数创建一个新的具有 `xtype` 属性为 `addtag` 的组件来创建一个新的表格。然后我们将此表格添加到视图中并显示它。
- en: 'The **Cancel** button in our `AddTag` sheet has a very simple function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `AddTag` 表格中的 **取消** 按钮具有一个非常简单的功能：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is also used as our autogenerated reference function to grab the open sheet
    and close it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这也用作我们自动生成的参考函数，用于获取打开的表格并关闭它。
- en: 'For now, we will duplicate this function for our last `saveAddTag` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为最后的 `saveAddTag` 函数复制此函数：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will simply hide that sheet as well. We will add the code to save our tag
    data once we get our stores created. For now, save and test the code to make sure
    that the sheet appears and hides as expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地隐藏该表格。一旦我们创建了存储，我们将添加保存标签数据的代码。现在，保存并测试代码以确保表格按预期出现和隐藏。
- en: 'The end result should look something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该看起来像这样：
- en: '![Creating the DataEntry controller](img/8901OS_04_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![创建 DataEntry 控制器](img/8901OS_04_07.jpg)'
- en: Now that we have the basic forms, we need to create our stores and models. This
    will provide us with places to store the data from our various forms.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本表单，我们需要创建我们的存储和模型。这将为我们提供存储来自各种表单的数据的地方。
- en: Defining the models and stores
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模型和存储
- en: 'For this project, we will be using the local storage offered by HTML5 to store
    our data. We will begin by defining the model for our data entry form. We will
    just call this one `Entry.js` and it goes in the `models` folder. The code is
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用HTML5提供的本地存储来存储我们的数据。我们将首先定义我们的数据条目模型的模型。我们将称这个为`Entry.js`，它放在`models`文件夹中。代码如下：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The model is pretty straightforward, defining the various data types and names.
    One thing to be aware of is the `entryDate` field, which has a `type` field of
    `date`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模型相当简单，定义了各种数据类型和名称。需要注意的一点是`entryDate`字段，它有一个`type`字段为`date`。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you use a date type in a model, you should always declare a `dateFormat
    component`. This tells the model how to store and retrieve the data. It also provides
    a common translation for the components that grab data from the model. Failure
    to set the `dateFormat` component often leads to foul language and extreme frustration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模型中使用日期类型时，你应该始终声明一个`dateFormat`组件。这告诉模型如何存储和检索数据。它还提供了从模型获取数据的组件的通用翻译。未能设置`dateFormat`组件通常会导致粗俗的语言和极度沮丧。
- en: 'The next model we need is a model for the tags. The `Tag.js` file goes in the
    `models` folder and it is pretty simple. It only has an `id` field and a `text`
    field:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们需要的是标签的模型。`Tag.js`文件放在`models`文件夹中，它相当简单。它只有一个`id`字段和一个`text`字段：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As before, we just use a `localstorage` proxy and give it a unique ID. This
    ID makes sure that the data is stored in its own separate table.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们只使用一个`localstorage`代理并给它一个唯一的ID。这个ID确保数据存储在其自己的单独表中。
- en: 'The last model we need is our `Config.js` model. This model follows the same
    format as a local storage proxy and the fields from our `config` form. The code
    is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个模型是我们的`Config.js`模型。这个模型遵循与本地存储代理和我们的`config`表单字段相同的格式。代码如下：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We also include some default values as part of the model. These values will
    get pulled into the form when we create a new config record.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在模型中包含了一些默认值。这些值将在我们创建新的配置记录时被拉入表单中。
- en: 'Once we have our models, we need to create our data store. The `EntryStore.js`
    file is created and it goes into the `stores` folder. The code is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了模型，我们需要创建我们的数据存储。`EntryStore.js`文件被创建，并放入`stores`文件夹中。代码如下：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a very basic store that we will expand later. For now, we will be using
    the model to do most of the heavy lifting. We give the store a `storeId` value
    of `EntryStore`, so that we can easily address it with our `DataEntry` controller.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的存储，我们将在以后扩展。现在，我们将使用模型来做大部分繁重的工作。我们给存储一个`storeId`值为`EntryStore`，这样我们就可以用我们的`DataEntry`控制器轻松地引用它。
- en: 'Next, we need a store for our tags. Since we only need very limited control
    over the tag store (it only feeds the list in our `AddTag` form), we are going
    to add the store as part of the component itself. Open the `AddTag.js` file and
    modify the `list` entry so that it looks similar to the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个用于我们的标签的存储。由于我们只需要对标签存储有非常有限的控制（它只向我们的`AddTag`表单中的列表提供数据），我们将把存储作为组件本身的一部分添加。打开`AddTag.js`文件并修改`list`条目，使其看起来类似于以下代码：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This simple store format creates the store as part of the `list` entry and does
    not need to be added to our `app.js` file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的存储格式将存储作为`list`条目的部分创建，不需要添加到我们的`app.js`文件中。
- en: 'Speaking of the `app.js` file, we should add other models and stores near the
    top of the `Ext.Application` function as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 说到`app.js`文件，我们应该在`Ext.Application`函数的顶部附近添加其他模型和存储，如下所示：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a model or store is within its own file, then it needs to be added into the
    `app.js` file. But, since the simple store format for our `list` is part of the
    component itself, we don't need to add it to the `app.js` file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模型或存储在其自己的文件中，那么它需要添加到`app.js`文件中。但是，由于我们`list`的简单存储格式是组件本身的一部分，所以我们不需要将其添加到`app.js`文件中。
- en: In the case of our `Config` model, there will only be one config record for
    the application. This means that we don't actually need a store to use it. We
    will take care of that back in our controllers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Config`模型的情况下，将只有一个配置记录用于应用程序。这意味着我们实际上不需要存储来使用它。我们将在控制器中处理这个问题。
- en: Meanwhile, back in the controllers
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时，回到控制器中
- en: Back in our controllers, it's time to put those stores to work for us, saving
    and displaying our data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制器中，现在是时候让那些存储为我们工作了，保存并显示我们的数据。
- en: 'Let''s start with our `DataEntry` controller. First, we are going to add a
    few more references, so that we can get to our components easier. Update the `DataEntry.js`
    references as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`DataEntry`控制器开始。首先，我们将添加一些额外的引用，这样我们就可以更容易地访问我们的组件。按照以下方式更新`DataEntry.js`的引用：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This provides us with easy access to our tag adding sheet, the list of tags,
    the input and hidden fields, as well as the button that opens the sheet. We also
    add references to our data entry form and both of its buttons.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了轻松访问我们的标签添加表单、标签列表、输入和隐藏字段以及打开表单的按钮。我们还添加了对我们数据输入表单及其两个按钮的引用。
- en: 'Here, in the `control` section we need to assign events and functions to each
    of these items. We can also use our reference names here to address the controls
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`control`部分，我们需要为这些项目分配事件和函数。我们也可以在这里使用我们的引用名称来引用控件，如下所示：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that we used the reference name for most of these. However, for the `Save`
    and `Cancel` buttons on our `tagSheet`, we used the component query reference.
    This is because we don't really need any additional control over those two pieces.
    They are basically single purpose components.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们大多数情况下使用了引用名称。然而，对于我们的`tagSheet`上的`Save`和`Cancel`按钮，我们使用了组件查询引用。这是因为我们并不真的需要对这些两个组件有任何额外的控制。它们基本上是单用途组件。
- en: 'For example, our `showAddTag` and `cancelAddTag` functions both need to be
    able to grab the sheet itself in order to show and hide it. Since we have a reference
    of `TagSheet` assigned to it, we can call it with the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`showAddTag`和`cancelAddTag`函数都需要能够获取表单本身以便显示和隐藏它。由于我们有一个`TagSheet`的引用分配给它，我们可以使用以下代码调用它：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since we don't modify the `Save` and `Cancel` buttons once they have been created,
    there is no need to create a reference for them. However, we will be making some
    modifications to our `AddTagButton` when we save our tag, so we created a reference
    for that one.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一旦创建了`Save`和`Cancel`按钮就不会对其进行修改，因此没有必要为它们创建引用。然而，当我们在保存标签时，将对我们的`AddTagButton`进行一些修改，因此我们为它创建了一个引用。
- en: 'Let''s update our `saveAddTag` function and see how that''s done. Change the
    function as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`saveAddTag`函数，看看它是如何完成的。按照以下方式更改函数：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Right from the start we begin using the `get` functions automatically created
    by our references. We get the value of the `textfield` in our form using `this.getTagInput().getValue()`
    and then we get the store we use for our tag list by calling the `this.getTagList().getStore()`
    function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就开始自动使用由我们的引用创建的`get`函数。我们使用`this.getTagInput().getValue()`获取我们表单中`textfield`的值，然后通过调用`this.getTagList().getStore()`函数获取我们用于标签列表的存储。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, the list store is the one we created as part of the component instead
    of a separate `store.js` file. However, since we can get to the list, and the
    list knows what store it is using, we have easy access to everything we need.
    The reference to the parent also gives us quick access to its children.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，列表存储是我们作为组件的一部分创建的，而不是单独的`store.js`文件。然而，由于我们可以访问列表，并且列表知道它使用的是哪个存储，我们可以轻松访问我们所需的一切。对父级的引用也为我们提供了快速访问其子项的途径。
- en: 'Next, we check to see if the user entered anything into the field (if the value
    of `tag != ""`) and if so, we set the text on our button to say **Tag:** and whatever
    the user entered. This provides the user with easy feedback as to what tag is
    on the current entry, so if we tag our entry as **Tired**, then the button will
    look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查用户是否在字段中输入了任何内容（如果`tag`的值不为空），如果是，我们将按钮上的文本设置为`Tag:**`和用户输入的内容。这为用户提供了一个关于当前条目上标签的简单反馈，因此如果我们把条目标记为`Tired`，那么按钮将看起来像这样：
- en: '![Meanwhile, back in the controllers](img/8901OS_04_08.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![与此同时，在控制器中](img/8901OS_04_08.jpg)'
- en: Next, we set the value of our hidden field to the same value. We do this because
    we will need to load our form into a record to save it. We can load values from
    a form field but we cannot load values from a button name. We use the hidden field
    to hold the value within the form for later use.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将隐藏字段的值设置为相同的值。我们这样做是因为我们需要将我们的表单加载到记录中以保存它。我们可以从表单字段中加载值，但不能从按钮名称中加载值。我们使用隐藏字段来在表单中保存值以供以后使用。
- en: 'Next, we need to find out if the tag is the one that we have entered previously,
    or if it is something new. To do this, we need to search the store using `store.findExact(''text'',
    tag)`. This will return `-1` if the value of `tag` is not found in the `text`
    field for any of the store''s data. If we don''t find the tag, we add it to our
    store using the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找出标签是否是我们之前输入的，或者它是否是新的。为了做到这一点，我们需要使用`store.findExact('text', tag)`在存储中搜索。如果`tag`的值在任何存储数据的`text`字段中找不到，它将返回`-1`。如果我们找不到标签，我们使用以下代码将其添加到我们的存储中：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Lastly, if the user has cleared the `textfield` out leaving it blank, we remove
    the previous tag text from the button and clear out the value of the hidden field.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用户清除了`textfield`并使其为空，我们将从按钮中移除之前的标签文本并清除隐藏字段的值。
- en: 'Our next function controls when the user selects an existing tag from the list
    of tags in the sheet (instead of entering a new one):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数控制当用户从表格中的标签列表中选择一个现有标签时（而不是输入一个新的）：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the user selects an item in the list, we put the text of the item in the
    text field for saving. The `saveAddTag` function will take care of the rest.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在列表中选择一个项目时，我们将项目的文本放入文本字段以保存。`saveAddTag`函数将处理其余部分。
- en: 'We have a similar function that deselects the items in the list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类似的功能，用于取消选择列表中的项目：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our text field has a clear icon that removes the value of the field. We tie
    into the `clearicontap` event that we set up in our `controllers` section to fire
    this `deselectTag` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们文本字段有一个清除图标，可以移除字段的值。我们将其与我们在`controllers`部分中设置的`clearicontap`事件关联起来，以触发这个`deselectTag`函数。
- en: 'Now that we have our tags taken care of, we will be able to save the full entry.
    We do this by adding the following function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理好了标签，我们将能够保存完整的条目。我们通过添加以下函数来完成这项工作：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function grabs the values from our form and creates a new entry for our
    store. Since the form names match the names of our model, we can use `Ext.Create`
    to create a new entry record and assign the values directly. We then add the new
    record to the store and sync. Finally, we alert the user that the new data has
    been saved.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从我们的表单中获取值并为我们的存储创建一个新的条目。由于表单的名称与我们的模型名称匹配，我们可以使用`Ext.Create`来创建一个新的条目记录并直接分配值。然后我们将新的记录添加到存储中并同步。最后，我们向用户提醒新数据已被保存。
- en: 'Our final function clears the fields in our form by using the following function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的函数通过以下函数清除我们表单中的字段：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function resets our form and the text of the button. This function will
    be fired by the **Cancel** button in our data entry form.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数重置我们的表单和按钮的文本。这个函数将由我们的数据输入表单中的**取消**按钮触发。
- en: This wraps up the `DataEntry.js` controller. We can now move on to the `Config.js`
    controller.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`DataEntry.js`控制器的编写。我们现在可以继续到`Config.js`控制器。
- en: Config.js
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Config.js
- en: 'Create a new file in the `controllers` folder called `Config.js` (make sure
    to also add it to the `app.js` file in the list of controllers). We will start
    with just the basic controller:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`controllers`文件夹中创建一个名为`Config.js`的新文件（确保也将它添加到`app.js`文件中的控制器列表中）。我们将从基本的控制器开始：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This sets up the controller with our views, models, and references. It also
    assigns a function to our form so that when it is initialized it calls `getSavedConfig`.
    This function is also the first one we need to create.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了我们的控制器，包括我们的视图、模型和引用。它还为一个表单分配了一个函数，以便在初始化时调用`getSavedConfig`。这个函数也是我们需要创建的第一个。
- en: Before we get started, we should keep in mind a few things about `config`. This
    will be like a set of preferences for the application. There will only be one
    record for `config`, which is why we don't need to create a store. We can use
    the `Config.js` model to create, load, and save the record directly. Let's take
    a look at how this gets done.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们应该记住一些关于`config`的事情。这将会像是一组应用的首选项。对于`config`将只有一个记录，这就是为什么我们不需要创建一个存储。我们可以使用`Config.js`模型直接创建、加载和保存记录。让我们看看这是如何完成的。
- en: 'Beneath the `config` section, we need to add the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config`部分下方，我们需要添加以下代码：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we create an instance of our `Config` model and attempt to load the first
    record from the HTML5 local storage (remember this should also be the only record).
    There are two possible outcomes here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Config`模型的实例，并尝试从HTML5本地存储中加载第一条记录（记住这应该也是唯一的记录）。这里有两种可能的结果：
- en: If the load fails, it means that this is the first time the user has accessed
    the `Config` section and we have no record. In this case, we will call another
    function called `createSavedConfig`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果加载失败，这意味着这是用户第一次访问 `Config` 部分，我们没有记录。在这种情况下，我们将调用另一个名为 `createSavedConfig`
    的函数。
- en: If the load succeeds then we need to load the data into our form for display.
    This will happen in the `bindRecordToForm` function.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果加载成功，那么我们需要将数据加载到我们的表单中以进行显示。这将在 `bindRecordToForm` 函数中发生。
- en: By setting the scope of the function to `this` (meaning the controller itself),
    we can make these two functions part of the controller and call them with `this.createSavedConfig`
    and `this.bindRecordToForm` respectively.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将函数的作用域设置为 `this`（即控制器本身），我们可以使这两个函数成为控制器的一部分，并分别使用 `this.createSavedConfig`
    和 `this.bindRecordToForm` 调用它们。
- en: 'We''ll start by adding our new functions beneath the previous `getSavedConfig`
    function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在之前的 `getSavedConfig` 函数下方添加我们的新函数开始：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This function creates a new empty record with the default values we defined
    in the `config` object and then saves the record. If this is successful, we call
    our next function, which binds the data record to our form:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一个具有我们在 `config` 对象中定义的默认值的新空记录，然后保存该记录。如果这成功，我们将调用我们的下一个函数，该函数将数据记录绑定到我们的表单：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function is called by both `getSavedConfig` and `createSavedConfig`, which
    pass along the data record automatically. We set this record to be our `savedConfig`,
    which allows us to get at the config data from anywhere in the controller.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数由 `getSavedConfig` 和 `createSavedConfig` 调用，它们会自动传递数据记录。我们将这个记录设置为我们的 `savedConfig`，这样我们就可以在任何控制器位置获取配置数据。
- en: Next we grab the form and use `setRecord` to populate the form with our data.
    Once the form is populated, we also need a way to save the data. To do this, we
    are going to use an interesting technique called **delegate**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们获取表单并使用 `setRecord` 用我们的数据填充表单。一旦表单被填充，我们还需要一种保存数据的方法。为此，我们将使用一种称为 **代理**
    的有趣技术。
- en: 'Delegate allows us to set listeners and functions on specific children within
    the form. In this case, we do `form.on({ delegate: ''field''`, which lets us set
    a group of listeners on every field in our form:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '代理允许我们在表单中的特定子元素上设置监听器和函数。在这种情况下，我们执行 `form.on({ delegate: ''field''`，这让我们可以在我们表单的每个字段上设置一组监听器：'
- en: The `numberfield` component understands the `change` event
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numberfield` 组件理解 `change` 事件'
- en: The `spinnerfield` component understands the `spin` event
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spinnerfield` 组件理解 `spin` 事件'
- en: The `checkboxfield` component understands the `check` event
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkboxfield` 组件理解 `check` 事件'
- en: Each of these events will call `this.updateValue` to save the data. While the
    other fields pass along both the field and value automatically, the checkboxes
    actually only pass the field when the `check` event fires. This means we do a
    tiny bit of extra work to get them to pass both field and value to our next function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件中的每一个都会调用 `this.updateValue` 来保存数据。虽然其他字段会自动传递字段和值，但复选框实际上只有在 `check` 事件触发时才传递字段。这意味着我们需要做一点额外的工作，以便它们将字段和值传递给我们的下一个函数。
- en: 'Our `updateValue` function takes the field and value passed in our previous
    function, and saves the data for us:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `updateValue` 函数接受在前一个函数中传递的字段和值，并为我们保存数据：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This saves our data to local storage. Now that we have a way to save data and
    our goals, we can start looking at the charting functions for displaying the data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们的数据保存到本地存储。现在我们有了保存数据和目标的方法，我们可以开始查看用于显示数据的图表功能。
- en: Getting started with Sencha Touch Charts
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用 Sencha Touch Charts
- en: As we noted at the beginning of the chapter, Sencha Touch Charts is currently
    only available as part of Sencha Complete or the open source version of Sencha
    Touch 2.1\. Previously, Sencha Touch Charts was a separate download, which had
    to be installed and configured as part of your application in order to function.
    This is no longer required.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章开头所提到的，Sencha Touch Charts 目前仅作为 Sencha Complete 或 Sencha Touch 2.1 的开源版本的一部分提供。以前，Sencha
    Touch Charts 是一个单独的下载，必须作为您应用程序的一部分安装和配置才能使用。现在这不再需要了。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should also be noted that if you are using the standalone commercial version
    of Sencha Touch 2.1 (which is not part of the Sencha Complete package), you will
    not be able to use the new Sencha Charts functions. While this standalone commercial
    version of Sencha Touch 2.1 includes an empty `src/charts` directory, it does
    not have any of the actual chart functionality.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意的是，如果你使用的是独立的商业版Sencha Touch 2.1（它不属于Sencha Complete套件），你将无法使用新的Sencha Charts功能。虽然这个独立的商业版Sencha
    Touch 2.1包含一个空的`src/charts`目录，但它没有任何实际的图表功能。
- en: Creating the overview chart
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建概览图
- en: The overview chart is a single-line chart, tracking weight and exercise. Our
    chart will have three axes, with weight ranges displayed on the left, date ranges
    displayed across the bottom, and exercise time ranges along the right.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 概览图是一个单线图，追踪体重和锻炼。我们的图表将有三条轴，体重范围显示在左侧，日期范围显示在底部，锻炼时间范围在右侧。
- en: 'The following screenshot describes the preceding explanation in more detail:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图更详细地描述了前面的解释：
- en: '![Creating the overview chart](img/8901OS_04_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![创建概览图](img/8901OS_04_09.jpg)'
- en: 'We will start with a few changes to our placeholder for the `OverviewChart.js`
    view:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对`OverviewChart.js`视图的占位符进行一些更改开始：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we've replaced the `html` configuration and included a single `chart`
    item as part of our panel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经替换了`html`配置，并将单个`chart`项作为我们面板的一部分包含进来。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Previous versions of the Sencha Touch Chart software used a `chartPanel` object,
    which automatically included the `chart` item as part of the panel. The current
    Version 2.1 treats the `chart` item as a separate object, which allows the `chart`
    item to be embedded in a panel or a container.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch Chart软件的早期版本使用了一个`chartPanel`对象，该对象自动将`chart`项作为面板的一部分。当前的2.1版本将`chart`项视为一个单独的对象，这允许`chart`项嵌入到面板或容器中。
- en: We have given the `chart` item a `store` value to grab data from, and positioned
    the `legend` section at the `bottom` of the chart.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`chart`项指定了一个`store`值以获取数据，并将`legend`部分定位在图表的底部。
- en: Adding the axes
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加轴
- en: 'The next piece we need to add is our axes. As we mentioned earlier, there are
    three for this graph. The code for them goes inside the `chart` section of the
    `config` definition (below our `legend` definition):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要添加的是我们的轴。正如我们之前提到的，这个图有三个轴。它们的代码位于`config`定义中的`chart`部分（在我们的`legend`定义下方）：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first axis has a `title` section of `weight` and it's a `numeric` axis.
    We position it on the left-hand side and then tell the axis which fields we are
    tracking (in this case, `weight`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个轴有一个`title`部分为`weight`，它是一个`numeric`轴。我们将它定位在左侧，然后告诉轴我们正在跟踪哪些字段（在这种情况下，`weight`）。
- en: As you might have guessed from the name `fields`, this means we can have multiple
    items tracked along the same axis. This works well if you have multiple items
    with the same numeric range of data. In this case, we have too much variation
    in the range of `exercise` and `weight`, so we keep them on different axes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从名称`fields`中猜测的那样，这意味着我们可以沿着同一轴跟踪多个项目。如果您有多个具有相同数值数据范围的项，这将工作得很好。在这种情况下，`exercise`和`weight`的范围变化太大，所以我们把它们放在不同的轴上。
- en: The `exercise` axis is set up in a similar fashion, but positioned on the right.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`exercise`轴以类似的方式设置，但位于右侧。'
- en: The `date` axis is a bit different. It has a type of `date` and a `dateFormat`
    for display.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`轴略有不同。它有一个`date`类型和用于显示的`dateFormat`。'
- en: Next, we need to set up the series.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置系列。
- en: Creating the series
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建系列
- en: The `series` section goes inside the chart configuration and beneath our axes
    section. The `series` section describes how the data points should align on the
    graph and how they should be formatted.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`series`部分位于图表配置内部，并在我们的轴部分之下。`series`部分描述了数据点应在图上如何对齐以及它们应该如何格式化。'
- en: 'Our overview graph is a line graph display, tracking weight and exercise over
    time. We need one entry for weight and a second one for exercise:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的概览图是一个折线图显示，追踪随着时间的推移体重和锻炼情况。我们需要为体重创建一个条目，并为锻炼创建第二个条目：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This defines our two series (`Weight` and `Exercise`). The `type` configuration
    defines which kind of series we are using. The `xField` configuration determines
    which data field is tracked along the horizontal axis (`entryDate` for both) and
    the `yField` configuration determines which field is tracked along the vertical
    axis (`weight` for the first series and `exercise` for the second). The `axis`
    configuration tells the series which part of the graph to map its values to.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们的两个系列（`Weight`和`Exercise`）。`type`配置定义了我们使用的是哪种类型的系列。`xField`配置确定沿着水平轴跟踪哪个数据字段（两个都是`entryDate`）和`yField`配置确定沿着垂直轴跟踪哪个字段（第一个系列是`weight`，第二个系列是`exercise`）。`axis`配置告诉系列将值映射到图形的哪个部分。
- en: The `style` section determines how the line for our series will appear. The
    `marker` section gives us the appearance of each data point along the line. The
    `highlightCfg` section uses `scale` to increase the size of a selected marker,
    so when the user clicks on a data point, the marker will increase to 1.25 times
    its normal size.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`部分确定我们的系列线条将如何显示。`marker`部分给出了线条上每个数据点的外观。`highlightCfg`部分使用`scale`来增加选中标记的大小，因此当用户点击数据点时，标记将增加到正常大小的1.25倍。'
- en: 'The `marker` section itself is actually a `sprite` reference, which means that
    we can use any of the available Sencha Touch `sprite` objects for our `marker`.
    These include things such as:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`marker`部分本身实际上是一个`sprite`引用，这意味着我们可以为我们的`marker`使用任何可用的Sencha Touch `sprite`对象。这些包括如下内容：'
- en: Circles
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形
- en: Ellipses
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆
- en: Images
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Rectangles
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形
- en: Text
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: 'A full list of available sprites and their configuration options can be found
    at [http://docs.sencha.com/touch/2-1/](http://docs.sencha.com/touch/2-1/) in the
    **draw** | **sprite** section of the API. To use these sprites, you just need
    to set the type configuration to the sprite name. The name for each sprite can
    be found at the top of the documentation as seen in the following screenshot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的`sprite`及其配置选项的完整列表可以在API的**draw** | **sprite**部分找到，网址为[http://docs.sencha.com/touch/2-1/](http://docs.sencha.com/touch/2-1/)。要使用这些`sprite`，只需将类型配置设置为`sprite`名称。每个`sprite`的名称可以在文档的顶部找到，如下面的截图所示：
- en: '![Creating the series](img/8901OS_04_10.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![创建系列](img/8901OS_04_10.jpg)'
- en: Once the `type` config is set for the `marker` section, you can use any of the
    sprite's configuration options to customize the marker's appearance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为`marker`部分设置了`type`配置，就可以使用任何`sprite`的配置选项来自定义标记的外观。
- en: Now that the series configuration is complete, we can also add some interactions
    to the graph to make it more interesting.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 系列配置完成后，我们还可以向图形添加一些交互，使其更有趣。
- en: The interactions section
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`interactions`部分'
- en: 'The `interactions` section allows us to respond to the user''s taps and gestures
    to expand the amount of information we provide. The current types of interactions
    include the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`interactions`部分允许我们响应用户的点击和手势来扩展我们提供的信息量。当前交互类型包括以下几种：'
- en: '`ItemCompare`: This lets the user select two items and see a data comparison'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemCompare`：这允许用户选择两个项目并查看数据比较'
- en: '`ItemHightlight`: This lets the user tap and highlight a series of data items
    in the chart'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemHighlight`：这允许用户点击并突出显示图表中的数据系列'
- en: '`ItemInfo`: This lets the user tap and get a detailed view of the data record'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemInfo`：这允许用户点击并获取数据记录的详细视图'
- en: '`PanZoom`: This lets the user pinch the chart to zoom in and out, or let them
    tap and drag to pan'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PanZoom`：这允许用户通过捏合图表来放大和缩小，或者通过点击和拖动来平移'
- en: '`PieGrouping`: This lets the user select and merge consecutive pie slices'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PieGrouping`：这允许用户选择并合并连续的饼图切片'
- en: '`Rotate`: This lets the user tap and drag around the center of the pie or radar
    charts to rotate the chart'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rotate`：这允许用户点击并拖动饼图或雷达图的中心来旋转图表'
- en: '`ToggleStacked`: This lets the user toggle between stacked and grouped orientations
    on a bar or column series chart'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToggleStacked`：这允许用户在柱状图或柱形图系列之间切换堆叠和分组方向'
- en: 'For this application, we will allow the user to tap the data points and get
    back all of the details for that particular day. We set up an interaction with
    a `type` value of `iteminfo` and define a `tpl` tag, which is used to display
    the data in the panel. The interaction receives the entire data record for the
    tapped data point so the `tpl` tag can use any of our values for weight, exercise,
    water, calories, or tags:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我们将允许用户轻触数据点，并获取该特定日期的所有详细信息。我们设置了一个`type`值为`iteminfo`的交互，并定义了一个`tpl`标签，该标签用于在面板中显示数据。交互接收被轻触数据点的整个数据记录，以便`tpl`标签可以使用我们的任何值，如重量、锻炼、水分、卡路里或标签：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This template will display our detailed item info. Next, we need to add the
    listener that will show the window when we click on one of the data points in
    our `OverviewChart`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板将显示我们的详细项目信息。接下来，我们需要添加一个监听器，当我们在`OverviewChart`中点击一个数据点时，它会显示窗口：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The listener starts by setting `var record = item.record;` and then getting
    the date out of the record so that we can format it properly for our `setTitle`
    function at the end of the listener.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器首先设置`var record = item.record;`然后从记录中获取日期，以便我们可以在监听器的末尾正确地格式化它用于`setTitle`函数。
- en: Next, we grab our single config record so that we can get the units of measurement
    for weight and water consumption. Then we set the data for the panel to the combined
    `record` and `configRecord` objects (using `Ext.apply()`). This gets both sets
    of data into our `tpl` for display.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们获取单个配置记录，以便我们可以获取重量和水分消耗的单位。然后我们将面板的数据设置为组合的`record`和`configRecord`对象（使用`Ext.apply()`）。这会将两组数据都放入我们的`tpl`中以便显示。
- en: Lastly, since this is a special floating panel in Sencha Touch, it has no `title`
    attribute, but we can create one using the first docked component in the panel.
    We set this `title` to the formatted date we grabbed at the top of the function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于这是一个Sencha Touch中的特殊浮动面板，它没有`title`属性，但我们可以使用面板中第一个停靠的组件来创建一个。我们将这个`title`设置为函数顶部获取的格式化日期。
- en: '![The interactions section](img/8901OS_04_11.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![交互部分](img/8901OS_04_11.jpg)'
- en: You should be able to save your work now and click on any of the data points
    to see our new detailed item info.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该能够保存您的作品并点击任何数据点以查看我们新的详细项目信息。
- en: The last thing we want to cover is creating the details view.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要介绍的是创建详细视图。
- en: Creating the details view
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建详细视图
- en: For the details chart, we have decided to make something a little more reusable.
    Our overall details view will contain three similar charts and a radar chart.
    Since we don't want to create the same chart over and over, we need a view we
    can call up with a different configuration for each of our charts. This will be
    a simple bar style chart with two axes; one for the date and one for the amount.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于详细图表，我们决定制作一个稍微更可重用的东西。我们的整体详细视图将包含三个类似的图表和一个雷达图。由于我们不希望反复创建相同的图表，我们需要一个可以调用不同配置的视图。这将是一个简单的条形图，有两个轴；一个用于日期，一个用于金额。
- en: '![Creating the details view](img/8901OS_04_12.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![创建详细视图](img/8901OS_04_12.jpg)'
- en: This reusable chart will be our `goalChart` view. We will create the `goalChart`
    view with its own `xtype`, which will allow us to reuse it with different configurations.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可重用的图表将是我们的`goalChart`视图。我们将创建一个具有自己`xtype`的`goalChart`视图，这将允许我们使用不同的配置重用它。
- en: Creating the goalChart view
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建目标图表视图
- en: 'We start by creating a `goalChart` view and setting it up to load our `config`
    file when it initializes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`goalChart`视图，并在初始化时设置它来加载我们的`config`文件：
- en: '[PRE47]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we set our panel's store to the `EntryStore` that contains all of our
    data (this gives us access to every record). Next, our `constructor` function
    will take whatever configuration options are passed to it, and applies them to
    the panel using `Ext.apply(this, config);`. This is where we will set an individual
    `title`, `dataField`, `goalField`, and `colorSet` for each chart.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将面板的store设置为包含所有数据的`EntryStore`（这使我们能够访问每条记录）。接下来，我们的`constructor`函数将接受传递给它的任何配置选项，并使用`Ext.apply(this,
    config);`将其应用于面板。这就是我们将为每个图表设置一个单独的`title`、`dataField`、`goalField`和`colorSet`的地方。
- en: Once these options are set, the panel then loads the goals and measurements
    from our single `configRecord` in much the same way as our previous chart panel.
    This time when the `Config` successfully loads, we call a new function called
    `createChart`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了这些选项，面板随后将以与我们之前图表面板相同的方式加载来自单个`configRecord`的目标和测量值。这次当`Config`成功加载时，我们调用一个新的函数`createChart`。
- en: 'The `createChart` function comes right after our `constructor` function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`createChart`函数紧随我们的`constructor`函数之后：'
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `createChart` function starts by creating a second `store` called the `goalStore`
    and gives it three fields as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`createChart`函数首先创建一个名为`goalStore`的第二个`store`，并给它以下三个字段：'
- en: '`entryDate`: This is the date field from our store'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entryDate`：这是我们的存储中的日期字段'
- en: '`goal`: This is the the goal passed from our `configRecord`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goal`：这是从我们的`configRecord`传递过来的目标'
- en: '`this.dataField`: This will be passed to us as one of our config options when
    we use the `goalChart` view'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.dataField`：当我们使用`goalChart`视图时，这将被作为我们的配置选项之一传递给我们'
- en: We then loop through our data in the main store (`EntryData`) and look for any
    values in the field that match the value we received for `this.dataField`. As
    we find matches, we add them to our `goalStore`. The `goalStore` is the actual
    store that will feed the chart.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历主存储（`EntryData`）中的数据，并查找字段中与`this.dataField`收到的值匹配的任何值。当我们找到匹配项时，我们将它们添加到我们的`goalStore`中。`goalStore`是实际将数据提供给图表的存储。
- en: 'For example, we could use the following code to create a `goalChart` view:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下代码创建一个`goalChart`视图：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `goalChart` view would use the `dataField` value to look for any data we
    have for `exercise` and create the chart. It would also use the `goalField` value
    of `exercisePerDay` to grab that number from our config record and add it to the
    display.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`goalChart`视图将使用`dataField`值来查找我们拥有的任何关于`exercise`的数据，并创建图表。它还会使用`goalField`值`exercisePerDay`从我们的配置记录中获取该数字并将其添加到显示中。'
- en: 'The final part of our `goalChart` sets up the series and axes much like the
    previous one:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`goalChart`的最后一部分设置系列和轴，与之前的类似：
- en: '[PRE50]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The main difference from the previous charts is that we have some values that
    will be supplied by our `config`, and we use the `Ext.factory` function to create
    the chart object.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的图表相比，主要的不同之处在于我们有一些值将由我们的`config`提供，我们使用`Ext.factory`函数来创建图表对象。
- en: Note
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, our use of `Ext.factory` is equivalent to `Ext.create`, but `Ext.factory`
    can also be used to update the configuration of existing objects. We chose to
    use `Ext.factory` here, rather than `Ext.create`, solely because most of the Sencha
    Charts examples refer to `Ext.factory` when creating charts, and we wanted to
    be consistent.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Ext.factory`的方式等同于`Ext.create`，但`Ext.factory`也可以用来更新现有对象的配置。我们选择在这里使用`Ext.factory`而不是`Ext.create`，仅仅是因为大多数Sencha
    Charts示例在创建图表时都引用了`Ext.factory`，我们希望保持一致性。
- en: 'Now we can re-use the chart for our exercise, water, and weight charts just
    by setting different `config` values for:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需通过为以下内容设置不同的`config`值，就可以重用图表来创建我们的锻炼、水和体重图表：
- en: '`dataField`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataField`'
- en: '`goalField`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goalField`'
- en: '`chartTitle`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chartTitle`'
- en: '`colorSet`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorSet`'
- en: Take a look at the `DetailChart.js` file in our example code to see how this
    works.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看我们示例代码中的`DetailChart.js`文件，以了解这是如何工作的。
- en: The last chart we need to touch on is the word chart.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要最后提到的图表是单词图表。
- en: Creating the word chart
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建单词图表
- en: The `wordChart` view is set up much like our `goalChart` with its own `constructor`
    and `createChart` function. However, the goal chart uses our tags to create a
    different type of chart called a radar chart. Our `wordChart.js` file checks for
    the number of occurrences of specific words and uses the information to draw our
    radar chart.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`wordChart`视图的设置与我们的`goalChart`类似，有自己的`constructor`和`createChart`函数。然而，目标图表使用我们的标签创建一个不同类型的图表，称为雷达图。我们的`wordChart.js`文件检查特定单词的出现次数，并使用这些信息绘制我们的雷达图。'
- en: '![Creating the word chart](img/8901OS_04_13.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![创建单词图表](img/8901OS_04_13.jpg)'
- en: 'The beginning of the `wordChart.js` file looks almost the same as our `goalChart`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`wordChart.js`文件的开头几乎与我们的`goalChart`相同：'
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After the end of the `constructor`, we set up our `createChart` function:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`constructor`结束之后，我们设置我们的`createChart`函数：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This grabs our `configRecord` like we did previously and then filters our `store`
    to find only the records that have `tag` data. We then `group` the fields by `tag`
    so that we can generate a `count` for each `tag`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像我们之前做的那样抓取我们的`configRecord`，然后过滤我们的`store`以找到只有具有`tag`数据的记录。然后我们按`tag`字段`group`字段，以便我们可以为每个`tag`生成一个`count`。
- en: Next we create a second `store`, much like in our `goalCharts` and we transfer
    our tag names and our counts into the second `store`. This one is called our `wordStore`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建第二个`store`，就像在我们的`goalCharts`中一样，并将我们的标签名称和计数转移到第二个`store`中。这个`store`被称为我们的`wordStore`。
- en: 'Now that we have a `wordStore` that consists only of the tag name and the number
    of times it occurs, we can use it to feed our new chart. Again, we use the `Ext.Factory`
    to create our store:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个只包含标签名称和出现次数的`wordStore`，我们可以用它来为我们的新图表提供数据。同样，我们使用`Ext.Factory`来创建我们的存储：
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The radar style chart uses an `xtype` value of `polar` as part of its chart
    configuration.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 雷达风格图表在其图表配置中使用了`xtype`值为`polar`。
- en: Tip
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Polar** charts include circular chart systems such as the pie and radar style
    charts, whereas **Cartesian** charts are line-based charts such as the area and
    bar charts.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**极坐标**图表包括饼图和雷达风格图表等圆形图表系统，而**笛卡尔**图表是基于线条的图表，如面积图和柱状图。'
- en: In the `series` section, the `type` value for our chart is then set to `radar`,
    which gives us our specific chart appearance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在`series`部分，我们为我们的图表设置`type`值为`radar`，这为我们提供了特定的图表外观。
- en: 'As with our previous charts, we also set `marker` and `style` configurations.
    Finally, we finish our `wordChart` by setting up the axes, closing out the chart
    object, and adding it to our panel:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的图表一样，我们也设置了`marker`和`style`配置。最后，我们通过设置轴、关闭图表对象并将其添加到面板来完成`wordChart`：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have two axes here: a `numeric` axis for our tag counts and a `category`
    axis for our tag names. We map these axes to the correct `field` and set `grid`
    to `true`. This will give us an underlying grid for our radar chart.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两个轴：一个用于标签计数的`numeric`轴和一个用于标签名称的`category`轴。我们将这些轴映射到正确的`field`，并将`grid`设置为`true`。这将为我们雷达图提供一个底部的网格。
- en: 'The `style` setting of `estStepSize: 1` ensures that all of our words will
    show up around the edge of our radar chart, without skipping any words.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`设置中的`estStepSize: 1`确保所有单词都将显示在雷达图的边缘，不会跳过任何单词。'
- en: 'Now that our `wordChart` is finished, we need to assemble all of our charts
    into a single page for our full details view:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`wordChart`已经完成，我们需要将所有图表组装成一个页面，以供我们的完整详细信息视图使用：
- en: '![Creating the word chart](img/8901OS_04_14.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![创建词云图](img/8901OS_04_14.jpg)'
- en: 'Back in our `details.js` placeholder file, we need to set up a new layout and
    add our four charts. As you can see in the screenshot, we have our four charts
    arranged in a square on the page with one chart in each corner. The easiest way
    to accomplish this is with a set of nested `hbox` and `vbox` layouts:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`details.js`占位符文件，我们需要设置一个新的布局并添加我们的四个图表。正如您在屏幕截图中所见，我们在页面上以正方形排列了四个图表，每个角落一个图表。完成这个任务最简单的方法是使用一组嵌套的`hbox`和`vbox`布局：
- en: '![Creating the word chart](img/8901OS_04_15.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![创建词云图](img/8901OS_04_15.jpg)'
- en: 'As you can see in the previous image, our details panel will have a `layout`
    section of `hbox`, with two containers inside, one on top of the other. In our
    `config` section, add the layout as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一张图片中所见，我们的详细信息面板将有一个`layout`部分为`hbox`，其中包含两个容器，一个在另一个上面。在我们的`config`部分，添加布局如下：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `stretch` and `center` values ensure that our containers will expand to
    fill the available space and occupy the center of our details panel. The `flex`
    value makes the inner containers equal in size. These two containers will have
    a layout of `vbox`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretch`和`center`值确保我们的容器将扩展以填充可用空间并占据详细信息面板的中心。`flex`值使内部容器大小相等。这两个容器将具有`vbox`布局。'
- en: 'We add these two containers in an `items` section within our `config` section:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`config`部分的`items`部分添加了这两个容器：
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The two containers form a top and bottom layout with two charts each. The goal
    charts each have slightly different configurations so that they display exercise,
    calories, and water consumption. We also color them differently to provide more
    visual appeal. The `wordchart` uses a similar configuration to include only the
    data from our tags.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个容器形成了顶部和底部布局，每个容器中各有两个图表。目标图表具有略微不同的配置，以便显示锻炼、卡路里和水的消耗。我们还用不同的颜色来增强视觉效果。`wordchart`使用类似的配置，仅包含我们标签的数据。
- en: With this last panel completed, you should be able to enter data into the application
    and test all of the charts.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 完成最后一个面板后，您应该能够将数据输入到应用程序中并测试所有图表。
- en: Homework
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: Take some time to play around with the different types of charts and see what
    is available. The Sencha website has an excellent guide for using charts and interactions
    at [http://docs.sencha.com/touch/2-1/#!/guide/drawing_and_charting](http://docs.sencha.com/touch/2-1/#!/guide/drawing_and_charting).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间尝试不同的图表类型，看看有哪些可用选项。Sencha网站提供了一个优秀的指南，用于使用图表和交互功能，请参阅[http://docs.sencha.com/touch/2-1/#!/guide/drawing_and_charting](http://docs.sencha.com/touch/2-1/#!/guide/drawing_and_charting)。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter we talked about:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了：
- en: Setting up the basic application to create the different views for the application
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本应用程序以创建应用程序的不同视图
- en: Creating the stores that will hold the data and feed our charts
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建将存储数据并为我们提供图表的存储库
- en: Setting up the controllers for the application
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置应用程序的控制器
- en: Creating the overview chart
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建概述图表
- en: Creating the details chart
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建详细图表
- en: In the next chapter we will look at creating a simple application to work with
    an external API.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何创建一个简单的应用程序来处理外部API。
