- en: Mapping with Canvas and D3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Canvas 和 D3 进行映射
- en: 'It''s time to leave our house and tree. I know it''s sad, but we''ll move on
    to potentially more exciting things to build. You covered a lot of ground in the
    previous chapter. You learned how to draw with Canvas, how to animate with Canvas,
    and a pattern to combine the D3 life cycle with Canvas. As D3 is usually in cahoots
    with SVG, you also learned about a few key differences between SVG and Canvas.
    Understanding the advantages and limitations of either approach is key to making
    informed decisions about which mode of rendering to use. Here''s what we will
    go through in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候离开我们的房子和树了。我知道这很悲伤，但我们将继续探索可能更有趣的事情来构建。在上一章中，你学到了如何使用 Canvas 绘制，如何使用 Canvas
    动画，以及如何将 D3 生命周期与 Canvas 结合的模式。由于 D3 通常与 SVG 合作，你也了解了一些 SVG 和 Canvas 之间的关键差异。了解任何一种方法的优缺点对于做出关于使用哪种渲染模式的明智决策至关重要。以下是本章我们将要探讨的内容：
- en: We'll start off with a summary of the key reasons for using either SVG or Canvas.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先总结使用 SVG 或 Canvas 的关键原因。
- en: We will then move on to review steps to build a flight path visualization with
    SVG, before building one with Canvas.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将继续回顾使用 SVG 构建飞行路径可视化的步骤，然后再使用 Canvas 构建。
- en: Along the way, we will focus on measuring the performance to get a good understanding
    of how far we can go with either approach.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此过程中，我们将关注性能测量，以了解我们可以使用这两种方法走多远。
- en: This will further contrast and compare the two approaches conceptually and technically.
    It will also allow us to demonstrate the main reason for choosing Canvas over
    SVG – animation of a great many points.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这将进一步从概念和技术上对比和比较这两种方法。它还将使我们能够展示选择 Canvas 而不是 SVG 的主要原因——大量点的动画。
- en: Choosing Canvas or SVG
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 Canvas 或 SVG
- en: You have already seen some benefits and some challenges to overcome when working
    with either of the two rendering methods. This section is supposed to summarize
    the most important differences. As such, it should give you a good understanding
    of what to use in which circumstance. Note, that I am juxtaposing SVG and Canvas
    rather than HTML and SVG with Canvas. It seems appropriate to focus on SVG as
    it is D3's main building block due to its visualization advantages. However, the
    same logic applies to the equally retained HTML.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这两种渲染方法中的任何一种时，你已经看到了一些好处和一些需要克服的挑战。本节旨在总结最重要的差异。因此，它应该能让你了解在何种情况下使用什么。请注意，我是在比较
    SVG 和 Canvas，而不是 HTML 和 SVG 与 Canvas。由于 SVG 在可视化方面的优势，将其作为 D3 的主要构建块来关注似乎是合适的。然而，同样的逻辑也适用于同样保留的
    HTML。
- en: Reasons to choose SVG
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 SVG 的原因
- en: 'Let''s first look at the SVG benefits:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 SVG 的好处：
- en: SVG is a vector-based graphics system. It allows resolution independent drawings
    you can scale without affecting quality.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG 是一种基于矢量的图形系统。它允许无分辨率依赖的绘制，你可以进行缩放而不会影响质量。
- en: You can easily access elements in the DOM to move, change, or add interactivity.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松访问 DOM 中的元素来移动、更改或添加交互性。
- en: You can style with CSS.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 CSS 进行样式设置。
- en: D3 works closely with the DOM, allowing for concise operations such as element
    selection and styling in a single pass and declarative animations with SVG.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3 与 DOM 密切合作，允许进行简洁的操作，如单次遍历中的元素选择和样式设置，以及使用 SVG 的声明性动画。
- en: SVG is accessible to screen-readers and SEO bots out of the box. Canvas requires
    fallback text or a sub-DOM to provide some level of accessibility.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG 默认对屏幕阅读器和 SEO 机器人是可访问的。Canvas 需要回退文本或子 DOM 以提供一定程度的可访问性。
- en: Reasons to choose Canvas
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 Canvas 的原因
- en: 'While SVG might be easier to handle, Canvas has advantages when it comes to showing
    and animating more elements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SVG 可能更容易处理，但在显示和动画更多元素时，Canvas 具有优势：
- en: SVG allows you to draw roughly 10,000 elements and animate 1,000 or so elements.
    With Canvas you can animate around 10,000 points. Why? First of all, Canvas is
    lower level and has fewer abstraction layers to keep and manage in memory. Secondly,
    browsers (like most monitors) mostly support a frame rate of 60 frames per second,
    meaning the screen is updated 60 times per second. This leaves *1000 / 60 = 16.67* milliseconds
    to finish all necessary rendering and housekeeping activities. As human brains
    are fooled into perceiving fluid animation at a mere 16 frames per second, the
    maximum time for rendering a frame is *1000 / 16 = 62.5* milliseconds — but you
    should strive for a shorter time. For SVG these activities include DOM parsing,
    render tree production, layout and screen painting, to name the most important.
    The path between Canvas changes and image is shorter. The browser turns the context
    instructions into an array of pixel values before painting it to the canvas.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SVG 允许你绘制大约 10,000 个元素并动画化大约 1,000 个元素。使用 Canvas，你可以动画化大约 10,000 个点。为什么？首先，Canvas
    是一个更低级的系统，内存中需要保持和管理的抽象层更少。其次，浏览器（如大多数显示器）主要支持每秒 60 帧的帧率，这意味着屏幕每秒更新 60 次。这留下了
    *1000 / 60 = 16.67* 毫秒来完成所有必要的渲染和清理活动。由于人类大脑被欺骗以在每秒 16 帧的速率感知流畅的动画，渲染一帧的最大时间是
    *1000 / 16 = 62.5* 毫秒——但你应该努力缩短这个时间。对于 SVG，这些活动包括 DOM 解析、渲染树生成、布局和屏幕绘制，仅举最重要的例子。Canvas
    和图像之间的路径更短。浏览器在将其绘制到画布上之前，将上下文指令转换为一个像素值的数组。
- en: If you need more elements to render or animate, accessing the alternative WebGL
    context is as easy as defining `canvas.getContext(‘webgl')`. WebGL allows you
    to animate 100k elements and more. While WebGL code is close to GPU programming
    and hence not for the faint-hearted, abstraction libraries like `Three.js`, `Pixi.js`, or `regl` make
    it more accessible.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要渲染或动画更多元素，访问替代的 WebGL 上下文就像定义 `canvas.getContext('webgl')` 一样简单。WebGL 允许你动画化
    10k 个元素甚至更多。虽然 WebGL 代码接近 GPU 编程，因此不适合胆小的人，但像 `Three.js`、`Pixi.js` 或 `regl` 这样的抽象库使其更容易访问。
- en: Check out Peter Beshai's excellent tutorial on animating 100,000 points with
    WebGl and regl at [https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html](https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看彼得·贝沙伊（Peter Beshai）关于使用 WebGl 和 regl 动画 100,000 个点的出色教程，[https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html](https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html)。
- en: 'Canvas is a **rasterized** graphics system. This just means the image consists
    of a *raster* (we could also say a *matrix*) of pixels. As a result, scaling can
    lead to blur, but in turn it''s simple to download your canvas as an image. A
    further problem are high **Dots Per Inch** (**DPI**) or retina screens, that can
    make Canvas blur. You can use the following setup to support retina displays on
    Canvas:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas 是一个 **光栅化** 的图形系统。这仅仅意味着图像由一个 *光栅*（我们也可以说是一个 *矩阵*）的像素组成。因此，缩放可能会导致模糊，但反过来，将你的
    Canvas 作为图像下载是简单的。另一个问题是高 **每英寸点数**（**DPI**）或视网膜屏幕，这可能会使 Canvas 模糊。你可以使用以下设置来支持
    Canvas 上的视网膜显示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Considering this, it seems a wise choice to stick to SVG for as long as possible
    and pull Canvas out of the hat when many elements need to be drawn or moved around.
    You might want to keep things simple until they can't be. One not-so-simple case
    could be the animation of a great many points. Let's look at an example that demonstrates
    the performance benefits Canvas has by building an element-heavy, animated application
    first with SVG and then with Canvas.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，似乎尽可能长时间坚持使用 SVG 是明智的选择，当需要绘制或移动许多元素时再拿出 Canvas。你可能想要保持简单，直到不能再简化为止。一个不那么简单的情况可能是大量点的动画。让我们通过首先使用
    SVG 然后使用 Canvas 构建一个元素密集型、动画化的应用程序来演示 Canvas 的性能优势。
- en: Visualizing flight paths with Canvas and D3
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Canvas 和 D3 可视化飞行路径
- en: Data can come with a great many number of individual data points. Maps especially
    can be the playground for large datasets. While it might be tempting to visualize
    features of a dataset as individual elements, in explanatory data visualization
    especially it often makes sense to aggregate data to bring across a single point
    well. While Canvas allows you to show and animate many points, it is power you
    might want to use responsibly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以包含大量单独的数据点。地图尤其可以成为大型数据集的游乐场。虽然将数据集的特征可视化为一组单独的元素可能很有吸引力，但在解释性数据可视化中，通常有道理将数据聚合起来，以便更好地传达一个观点。虽然
    Canvas 允许你显示和动画化许多点，但你可能希望负责任地使用这种能力。
- en: Having said that, it can often be mesmerizing to watch dynamic data unfold as
    well as bringing across a specific point. Combining user engagement with concise
    learnings is of course a great plus you should leverage if possible. Considering
    map data, there are a great many examples of dynamic visualizations with numerous
    animated elements, such as natural elements like winds or ocean currents, cultural
    elements like spreading ideas or inventions, as well technical elements like cars,
    ships, or airplanes. In this section, we will jump on the latter and visualize
    flight paths.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，观察动态数据展开以及传达特定观点往往令人着迷。结合用户参与和简洁的学习内容当然是一个很好的加分项，如果可能的话应该加以利用。考虑到地图数据，有许多动态可视化示例，包含众多动画元素，例如自然元素如风或洋流，文化元素如思想的传播或发明，以及技术元素如汽车、船只或飞机。在本节中，我们将关注后者，并可视化飞行路径。
- en: Our aim will be two-fold. Firstly, we want to build a map visualization with
    many animated elements – not just for the sake of showing many elements, but the
    detail we show should facilitate the understanding of the visual. Secondly, we
    want to compare the performance between SVG and Canvas. We have described it theoretically
    in a previous section, but let's get practical now.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标将是双重的。首先，我们希望构建一个包含许多动画元素的地图可视化——不仅仅是为了展示许多元素，但我们展示的细节应该有助于理解视觉效果。其次，我们希望比较SVG和Canvas的性能。我们已经在之前的章节中从理论上进行了描述，但现在让我们来实践一下。
- en: 'Here''s what we will build:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建以下内容：
- en: '![](img/15f41f3a-8672-433a-88c4-8a0c805a3659.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15f41f3a-8672-433a-88c4-8a0c805a3659.png)'
- en: 1,000 flight paths visualized. Each red dot is an animated plane (promise!)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 1,000条飞行路径可视化。每个红色圆点都是一个动画飞机（保证！）
- en: 'There are three main element categories we will draw: *the world, airports*
    (the white dots, consciously kept in the background as they are of only supporting
    importance), and the *planes* (the red dots). Representing real planes, our red
    dots are animated along their very own flight path flying from their origin to
    their destination. Here''s an image showing the paths our planes follow:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制三个主要元素类别：*世界、机场*（白色圆点，有意识地保持在背景中，因为它们只有辅助作用），以及*飞机*（红色圆点）。代表真实飞机的红色圆点将沿着它们自己的飞行路径动画化，从起点飞往目的地。以下是展示飞机飞行路径的图片：
- en: '![](img/6df407f2-f612-4734-adc7-16dc5c59dc86.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6df407f2-f612-4734-adc7-16dc5c59dc86.png)'
- en: 100 flights showing the route paths and their respective planes
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显示100条航线的路径及其相应的飞机
- en: The source data for this visual includes over 65,000 worldwide routes flying
    to and from just over 7,000 airports. We won't be able to animate all these routes,
    not even with Canvas. The aim of our visualization will rather be to show as many
    as we can to convey an immediate visual understanding of active versus less active
    flight regions as well as oft-used versus lesser-used routes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此视觉效果的源数据包括超过65,000条全球航线，飞往和来自超过7,000个机场。我们无法动画化所有这些航线，即使是使用Canvas也无法实现。我们的可视化目标将是尽可能多地展示，以传达对活跃与不活跃飞行区域以及常用与较少使用的航线的直观理解。
- en: 'At the bottom of the visual we will show a row of buttons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉效果的底部，我们将展示一排按钮：
- en: '![](img/c602cbc1-4402-4fb7-a5b0-0d0e0bf040af.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c602cbc1-4402-4fb7-a5b0-0d0e0bf040af.png)'
- en: Buttons to kick off the animation
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 启动动画的按钮
- en: These buttons will allow the user to set the number of flights to be displayed
    at once. Importantly, this will not be real time or replayed time. We won't bring
    in any flight schedules, showing flights at the time of day/date they depart or
    arrive, we will show all flights at the same time! Firstly, this supports the
    visualization aims described previously and secondly, it will help test performance
    because as many elements as possible are being animated at the same time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮将允许用户设置一次显示的航班数量。重要的是，这不会是实时或重放的。我们不会引入任何航班时刻表，显示航班在当天/日期出发或到达的时间，我们将同时显示所有航班！首先，这支持之前描述的可视化目标，其次，它将有助于测试性能，因为尽可能多的元素将在同一时间被动画化。
- en: 'To test browser performance, we shall add a small information box from `stats.js`
    at the top left of our app. Once dropped into your code, this nifty info tool
    displays page performance measures on your page, of which we will be mainly interested
    in **frames per second** (**FPS**). You will see it soon in action, but this is
    how it looks magnified indicating 60 frames per second:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试浏览器性能，我们将在应用程序的左上角添加一个来自`stats.js`的小信息框。一旦将其放入你的代码中，这个巧妙的工具就会在你的页面上显示页面性能指标，其中我们将主要对**每秒帧数**（**FPS**）感兴趣。你很快就会看到它的实际效果，但这是放大后的样子，表示每秒60帧：
- en: '![](img/e03b7b04-6e56-407e-b2cd-8536647e006d.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e03b7b04-6e56-407e-b2cd-8536647e006d.png)'
- en: The data
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据
- en: According to the three element categories we want to represent, we need three
    data sources to build the visual. The map data, data about airport locations,
    as well as flight data, showing origins and destinations for each flight. We will
    call this the **route data**. Both datasets come from [openflights.org](https://openflights.org/)
    which offers a tool you can use to map flights as well as databases for flights
    worldwide including routes and airport location data. This is exactly what we're
    after.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们想要表示的三个元素类别，我们需要三个数据源来构建可视化。这些数据源包括地图数据、机场位置数据以及每架航班的起点和终点数据。我们将称之为**路线数据**。这两个数据集都来自[openflights.org](https://openflights.org/)，它提供了一个工具，你可以用它来绘制航班图，以及包括路线和机场位置数据在内的全球航班数据库。这正是我们所追求的。
- en: 'After light cleaning and minor modifications, the first 10 entries of the route
    data and the airport location data with 100 flights look as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行简单的清洁和少量修改后，包含100个航班的路线数据和机场位置数据的前10条记录如下：
- en: '![](img/09edba9a-51fb-4a11-a87f-a4a9421e33a5.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09edba9a-51fb-4a11-a87f-a4a9421e33a5.png)'
- en: The route and the airport data
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 路线数据和机场数据
- en: All variable names are self-explanatory. Note that the first variable in the
    airport data, *i**ata**,* represents the official three-letter airport code from
    the **International Air Transport Association** (**IATA**). Also note that we
    had to remove some flights per dataset as not every airport location was available,
    which in fact leads to a lower number (less than 2-3%) of flights than the buttons
    suggest.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量名都是自解释的。请注意，机场数据中的第一个变量 *i**ata**，代表**国际航空运输协会**（**IATA**）的官方三位字母机场代码。此外，请注意，我们必须根据数据集删除一些航班，因为并非每个机场位置都可用，这实际上导致航班数量（少于2-3%）低于按钮所暗示的数量。
- en: Building the flight path map in SVG
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SVG中构建飞行路径图
- en: Our focus in this chapter will be on mapping with Canvas as well as on a benchmark
    of Canvas against SVG animation. In order to spend our time and effort wisely,
    I have pre-built an SVG map we can use as a benchmark, leaving us the rest of
    the chapter to focus on how to build the Canvas flight path app. The chapter is
    called *Mapping with **Canvas** and D3* after all...
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注使用Canvas进行映射，以及Canvas动画的基准测试。为了明智地利用我们的时间和精力，我已经预先构建了一个SVG地图，我们可以将其用作基准，这样我们就可以将本章的其余部分专注于如何构建Canvas飞行路径应用程序。毕竟，章节的标题是*使用**Canvas**和D3进行映射*...
- en: 'Nonetheless, let''s have a quick look at the steps we would take to build this
    app with SVG. There are roughly eight logical steps to follow:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们快速看一下构建此应用程序所需的步骤。大致有八个逻辑步骤需要遵循：
- en: You set up the map with a container SVG, as well as the projection and the path
    generator for the map
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用容器SVG、投影和地图路径生成器设置地图
- en: You load the map data and draw the map
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你加载地图数据并绘制地图
- en: You listen to button events and load in the appropriate dataset depending on
    the button pressed
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你监听按钮事件，并根据按下的按钮加载适当的数据集
- en: You draw the airports
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你绘制机场
- en: You calculate each plane’s origin and destination position as well as compute
    a path from origin to destination
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你计算每架飞机的起点和终点位置，并计算从起点到终点的路径
- en: You sample points along each plane’s path and store them in an array (we’ll
    call them *way points*)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你沿着每架飞机的路径采样点并将它们存储在数组中（我们将它们称为*航点*）
- en: Using D3, you transition each plane along its path
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用D3，你让每架飞机沿着其路径过渡
- en: Once each plane has reached its destination, you let the transition start again
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当每架飞机到达目的地后，你让过渡再次开始
- en: Now that we have conjured up our SVG flight path visual, let's see how many
    planes we can set off without any problems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创造出了SVG飞行路径可视化，让我们看看我们能够启动多少架飞机而不会出现任何问题。
- en: Measuring the performance
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量性能
- en: 'So here it is – let''s make some planes fly. We should start modestly and try
    with 100 routes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧——让一些飞机飞起来。我们应该从简单做起，尝试100条路线：
- en: '![](img/3a6bcd3b-ff61-4ea7-9fde-77ffc0c51fab.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a6bcd3b-ff61-4ea7-9fde-77ffc0c51fab.png)'
- en: SVG visualization of 100 flight paths at 60 FPS
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 60 FPS 下 100 条飞行路径的 SVG 可视化
- en: 'See the frame rate in the top-left corner? It''s a bit small but we''re still
    very happy with it! Displaying 60 frames per second is perfect. 1,000 flights
    will give us up to 40 frames per seconds. This is a drop, but the animation remains
    smooth. However, even at 1,000 flights we can’t really see any major clusters
    of flight activity. So, let’s try 5,000 flights at the same time:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 看看左上角的帧率吗？它有点小，但我们仍然非常满意！每秒显示 60 帧是完美的。1,000 架航班将给我们带来高达 40 帧每秒。这是一个下降，但动画仍然流畅。然而，即使在
    1,000 架航班的情况下，我们也看不到任何主要的航班活动集群。所以，让我们尝试同时显示 5,000 架航班：
- en: '![](img/e2e784cf-5c22-4ced-b89e-9770c8f440fc.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2e784cf-5c22-4ced-b89e-9770c8f440fc.png)'
- en: SVG visualization of 5,000 flight paths at 6 FPS
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 6 FPS 下 5,000 条飞行路径的 SVG 可视化
- en: Our performance crashed to 6 FPS. While this static image brings us closer to
    our visualization aim of identifying regions of high flight traffic, it's no fun
    to view the janking animation. Canvas to the rescue.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的性能下降到 6 FPS。虽然这个静态图像让我们更接近我们的可视化目标，即识别高航班交通区域，但观看这种抖动的动画并不有趣。Canvas 来拯救。
- en: View this step in the browser at: [https://larsvers.github.io/learning-d3-mapping-9-1](https://larsvers.github.io/learning-d3-mapping-9-1). Code
    example [09_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_01.html).
    I recommend to use a recent version of Chrome to view and work on the examples
    of this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-9-1](https://larsvers.github.io/learning-d3-mapping-9-1)。代码示例[09_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_01.html)。我建议使用最新版本的
    Chrome 来查看和操作本章的示例。
- en: At the conclusion of each step you will find two links in an info box close
    to the the relevant image. The first link brings you to a working implementation
    of this step that you can view in the browser. The second *code example* link
    brings you to the full code. If you're reading the print version, you can find
    all code examples at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping) in
    their relevant chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤结束时，您将在靠近相关图像的信息框中找到两个链接。第一个链接将带您到浏览器中可以查看的此步骤的工作实现。第二个**代码示例**链接将带您到完整的代码。如果您正在阅读印刷版，您可以在[https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)的相关章节中找到所有代码示例。
- en: Building the flight path map in Canvas
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Canvas 中构建飞行路径地图
- en: Let's start with an overview of our Canvas application before we take it apart.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将应用拆解之前，让我们先概述一下我们的 Canvas 应用。
- en: 'It''s best to quickly get the HTML out of the way as it couldn''t be much simpler.
    We have a `div` for the canvas at hand as well as our buttons:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最好快速处理 HTML，因为它不可能更简单。我们手头有一个用于画布的 `div` 以及我们的按钮：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that each button gets the same class selector as well as a `data-flights`
    attribute to pass on the number of flights each button represents. You will use
    this in a moment to load the right dataset!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个按钮都获得相同的类选择器以及一个 `data-flights` 属性来传递每个按钮代表的航班数量。您将稍后使用此属性来加载正确的数据集！
- en: 'Now let''s look at the steps we take in the JavaScript to build this app in
    Canvas and see what changes to the flow we described previously for the SVG app.
    I have **highlighted** the parts we change for the Canvas flow and have removed
    the SVG parts (in brackets):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看在 Canvas 中构建此应用的步骤，并查看我们对之前描述的 SVG 应用流程所做的更改。我已经**突出显示**了 Canvas 流程中更改的部分，并删除了
    SVG 部分（括号内）：
- en: You set up the **Canvas and the context** (instead of a container SVG), as well
    as the projection and the path generator for the map
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您设置**画布和上下文**（而不是容器 SVG），以及地图的投影和路径生成器
- en: You load the map data and draw the map
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您加载地图数据并绘制地图
- en: You listen to button events and load in the appropriate dataset depending on
    the button pressed
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您监听按钮事件并根据按下的按钮加载适当的数据集
- en: You draw the airports **and the world**, as they are on the same Canvas and
    a redraw is cheap
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您绘制机场**和世界地图**，因为它们位于同一个 Canvas 上，重绘成本很低
- en: You calculate each plane’s origin and destination position as well as compute
    a path from origin to destination
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您计算每架飞机的起点和终点位置，并计算从起点到终点的路径
- en: You sample *way points* along each plane’s path and store them in an array
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在每个飞机的路径上采样**航路点**并将它们存储在数组中
- en: '**You set off the game loop **(instead of using D3 transitions)**:**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您启动游戏循环**（而不是使用D3过渡）：'
- en: clear the Canvas
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除Canvas
- en: update the position
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新位置
- en: draw the planes
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制飞机
- en: In the SVG example we restart a transition, once each plane has reached its
    destination. In our Canvas app this is part of the **update step in the game loop**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SVG示例中，我们一旦每架飞机到达目的地，就重新启动一个过渡。在我们的Canvas应用程序中，这是游戏循环中的**更新步骤**的一部分。
- en: Setting up the map
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置地图
- en: 'First, we set up a few global variables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置了一些全局变量：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`width` and `height` speak for themselves. Countries will hold the GeoJSON
    data to draw the globe, which needs to be reached from various function scopes.
    Hence, it''s easier to define it as a global variable in this small app. `airportMap`
    will allow us to join the airport with the routes data by the three-letter IATA
    code. `requestID` will be filled by our loop function `requestAnimationFrom()`
    and used to cancel the current loop. We shall get to this in no time.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`和`height`不言而喻。国家将持有GeoJSON数据来绘制地球，这需要从各种函数作用域中访问。因此，在这个小型应用程序中将其定义为全局变量更容易。`airportMap`将允许我们通过三位字母IATA代码将机场与路线数据连接起来。`requestID`将被我们的循环函数`requestAnimationFrom()`填充，并用于取消当前循环。我们很快就会了解到这一点。'
- en: 'We then set up the two contexts: a context for the world and a context for
    the planes. This little extra work at the beginning makes our life much easier
    later. If we drew the world and the planes on the same context, we would have
    to update both the world and the planes every time a plane flies a short distance.
    Keeping the world on a separate canvas means we only have to draw the world once
    and can leave that image/context untouched:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置两个上下文：一个用于世界的上下文和一个用于飞机的上下文。这种在开始时的小额外工作使我们的生活后来容易得多。如果我们把世界和飞机画在同一个上下文中，每次飞机飞行的距离很短时，我们就必须更新世界和飞机。将世界保持在单独的画布上意味着我们只需要绘制一次世界，并且可以保持该图像/上下文不变：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We use absolute CSS positioning for the canvases to stack them perfectly on
    top of each other:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用绝对CSS定位来堆叠画布，使其完美地堆叠在一起：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we set up the `projection`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置`投影`：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Please note that instead of playing with `.scale()` and `.translate()` to center
    and fit your projection, you can use the D3 convenience methods  `.fitExtent()` or `.fitSize()`.
    You pass them your viz dimensions and the GeoJSON object you want to project and
    it calculates the best scale and translation for you.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用D3方便的方法`.fitExtent()`或`.fitSize()`而不是使用`.scale()`和`.translate()`来居中和调整您的投影。您将viz维度和您想要投影的GeoJSON对象传递给它们，它们会为您计算最佳比例和转换。
- en: Also notice that we don't use the omnipresent *Mercator* projection but the *Robinson* projection
    for our world map. It has the advantage of drawing the world in a slightly more
    realistic way in terms of country size proportions. The *Robinson *and many more
    non-standard projections can be found in the additional *d3-geo-projection module*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们不是使用无处不在的**墨卡托**投影，而是使用**罗宾逊**投影来绘制我们的世界地图。它在国家大小比例方面以稍微更真实的方式绘制世界。**罗宾逊**和其他许多非标准投影可以在额外的**d3-geo-projection模块**中找到。
- en: 'Now we need a path generator. In fact, you will need to build two path generators:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个路径生成器。实际上，你需要构建两个路径生成器：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`pathSVG` will be used to generate the flight path in memory. We want to do
    that in SVG as it comes with handy methods to calculate its length and sample
    points from it. `pathCanvas` will be used to draw our `geo` data to the screen.
    Note that we add `d3.geoPath()`''s `.context()` method and pass it our `contextWorld`.
    If we pass a Canvas context to this `.context()` method, the path generator will
    return a Canvas path for the passed context. If it''s not specified it will return
    an SVG path string. You can think of it as a switch button to tell D3 which renderer
    to use.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathSVG`将用于在内存中生成飞行路径。我们希望使用SVG来完成，因为它提供了方便的方法来计算其长度和从中提取样本点。`pathCanvas`将用于将我们的`geo`数据绘制到屏幕上。注意，我们添加了`d3.geoPath()`的`.context()`方法，并将其传递给我们的`contextWorld`。如果我们向这个`.context()`方法传递一个Canvas上下文，路径生成器将返回一个针对该上下文的Canvas路径。如果没有指定，它将返回一个SVG路径字符串。你可以将其视为一个切换按钮，告诉D3使用哪个渲染器。'
- en: Drawing the map and listening for user input
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制地图并监听用户输入
- en: 'As with the SVG process, we start by loading the data in:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与SVG过程一样，我们首先加载数据：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then do a bit of housekeeping and move the buttons in the `div#controls`
    below the canvases. You recode the TopoJSON to GeoJSON features and save the data
    as a global variable before you draw the map:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们做一些清理工作，并将按钮移动到 `div#controls` 下方画布下面。你在绘制地图之前，将 TopoJSON 重新编码为 GeoJSON
    功能，并将数据保存为全局变量：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Thanks to D3's versatile path generator, this is all it needs to draw the world.
    Easy!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 D3 的多功能路径生成器，绘制世界地图只需要这些。很简单！
- en: Back in our asynchronous `d3.json()` data load function, you'll handle the button
    events next. Remember, nothing has happened yet, but as soon as the user hits
    a button, the animation should kick off.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的异步 `d3.json()` 数据加载函数中，接下来你将处理按钮事件。记住，目前还没有发生任何事，但一旦用户点击按钮，动画就应该开始。
- en: 'You attach a mouse-down listener to all buttons:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你将鼠标按下监听器附加到所有按钮上：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Proceed with writing the handler:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写处理程序：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The button colors are handled in the first two lines. The next line will stop
    the current loop. We haven't even got a loop yet, so let's get back to this as
    soon as we have.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮颜色在前两行处理。下一行将停止当前循环。我们甚至还没有循环，所以一旦我们有循环，我们就会回到这里。
- en: Finally, we retrieve the number of flights the button represents and load the
    respective route and airport location data from the server. That's it for the
    `d3.json()` callback, as the `ready()` function will take over as soon as the
    data is loaded.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检索按钮代表的航班数量，并从服务器加载相应的航线和机场位置数据。这就是 `d3.json()` 回调的全部内容，因为一旦数据加载，`ready()`
    函数就会接管。
- en: Preparing and drawing with Canvas
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备和绘制 Canvas
- en: 'With Canvas, we want to achieve three things in the `ready()` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ready()` 函数中，我们想要在 Canvas 上实现三件事：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Drawing the background scene
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制背景场景
- en: 'Before we draw the airports, we manipulate the airport locations data. We create
    an array holding one GeoJSON point `geometry` object per airport:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制机场之前，我们操纵机场位置数据。我们创建一个数组，每个机场包含一个 GeoJSON 点 `geometry` 对象：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then we fill the global `airportMap` variable with a map we produce with `d3.map()`.
    `d3.map()` is a utility function that takes an array of objects to produce key-value
    pairs we can access with its own `map.get()` method. We won't use the map immediately
    but will get to it in a moment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `d3.map()` 函数生成一个地图，并将其填充到全局变量 `airportMap` 中。`d3.map()` 是一个实用函数，它接受一个对象数组，生成我们可以通过其
    `map.get()` 方法访问的键值对。我们不会立即使用这个地图，但稍后我们会用到它。
- en: 'Every time we call the `ready()` function, that is every time the user presses
    a new button, we will redraw airports and the world. Both are drawn on the same
    canvas. If we want to change one thing on a canvas, we need to change everything
    on a canvas. There are ways to only update regions with clip-paths but with complex
    animations of multiple elements, this can become a mess real quick. So we erase
    and rebuild:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用 `ready()` 函数，也就是每次用户按下新按钮时，我们都会重新绘制机场和世界。两者都绘制在同一个画布上。如果我们想在画布上更改一项内容，我们需要更改画布上的所有内容。有方法只更新具有
    clip-paths 的区域，但在多个元素的复杂动画中，这可能会很快变得混乱。因此，我们擦除并重建：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note, we''re on the first canvas we''ve drawn – accessible via `contextWorld.`
    We''ve seen `drawMap()` a few paragraphs ago, `drawAirports()` is even simpler
    and speaks for itself:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在绘制第一个画布 - 通过 `contextWorld` 访问。我们之前看到过 `drawMap()` 函数，`drawAirports()`
    函数甚至更简单，不言自明：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's it. This background scene will be drawn with every button press updating
    the airports shown.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这个背景场景将在每次按钮点击时更新显示的机场。
- en: Defining the planes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义飞机
- en: 'Next, we build the fundament for our animation. Essentially, we want an array
    of points on each plane''s route. We will call them **way points** and here''s
    how they will look for the flight path **Frankfurt to Atlanta** as an array and
    as points on the path:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的动画建立基础。本质上，我们想要每个飞机航线上的一系列点。我们将它们称为**航路点**，以下是飞行路径**法兰克福到亚特兰大**的航路点作为数组和路径上的点：
- en: '![](img/b4039708-d1d0-461c-848b-dfc51e19590f.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4039708-d1d0-461c-848b-dfc51e19590f.png)'
- en: Way points in an array (showing the first 10 of 733) and on the map (an illustration,
    not exact)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 航路点在数组中（显示前10个733个）和在地图上（一个示意图，不是精确的）
- en: 'The **way points** are the core ingredient, the fuel for our animation. When
    we animate the first frame, we will:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**航路点**是动画的核心成分，是我们的动画燃料。当我们动画第一帧时，我们将：'
- en: Clear the plane's own canvas `contextPlane`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除飞机自己的画布 `contextPlane`。
- en: Pull out the very first way point for each plane.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取每个飞机的第一个航路点。
- en: Draw that plane in this position.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个位置绘制那架飞机。
- en: When we draw the second frame we do the same, but in *step 2* pull out the second
    way point. For the third frame, we shall pull out the third way point, and so
    on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制第二帧时，我们做同样的事情，但在 *步骤 2* 中提取第二个 `wayPoint`。对于第三帧，我们将提取第三个 `wayPoint`，依此类推。
- en: We don't want to hold up the browser with complex calculations in between each
    frame, so we shall calculate all positions for all planes before we animate. Note,
    this is not always possible, positions might be dependent on user input or arbitrary
    charges in your force-directed graph or the like. However, whatever you can pre-calculate,
    you should.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望浏览器在每一帧之间因为复杂的计算而停滞，所以我们将在动画之前计算所有飞机的位置。注意，这并不总是可能的，位置可能取决于用户输入或你的力导向图中的任意电荷等因素。然而，无论你能预先计算什么，都应该这样做。
- en: Calculating the plane's positions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算飞机的位置
- en: 'How do we get to the `wayPoints` array? Conceptually, we''ve said it all already.
    We now express it in code. First, you need to create an array for all planes,
    depending on the route data the respective button press has loaded in:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到 `wayPoints` 数组？从概念上讲，我们已经说过了。我们现在用代码表达它。首先，你需要创建一个数组来存储所有飞机，这取决于相应按钮点击加载的路线数据：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a simple array of elements representing the three-letter origin and
    the destination IATA airport codes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的元素数组，代表三位字母的起点和目的地 IATA 机场代码。
- en: 'Next, you iterate through this array of start and end points to calculate the
    `wayPoints`. You will create an object called `planes` holding the data as well
    as two helper functions to calculate the data. But before this, have a look at
    the simple algorithm to produce the planes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你遍历这个起点和终点数组来计算 `wayPoints`。你将创建一个名为 `planes` 的对象来存储数据，以及两个辅助函数来计算数据。但在那之前，让我们看看生成飞机的简单算法：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Conceptually, you produce a plane for each route. Then you get this plane's
    route path and store it within the plane. Next, you sample the path for a number
    of *x*, *y* coordinates – our `wayPoints` – and also store it in the `plane`.
    Lastly, you add the `plane` with all the information you need in the `planes.items`
    array. That's all the calculation magic in an overview. As soon as that's done,
    you can animate the points.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，你为每条路线生成一架飞机。然后你获取这架飞机的路线路径并将其存储在飞机中。接下来，你采样路径的多个 *x*，*y* 坐标 – 我们的 `wayPoints`
    – 并也将它们存储在 `plane` 中。最后，你将包含所有所需信息的 `plane` 添加到 `planes.items` 数组中。这就是概述中的所有计算魔法。一旦完成，你就可以动画化这些点。
- en: 'Now, let''s have a brief look at the `planes` object. Note the plural! This
    is different to the `plane` object we build for each route. It is the home of
    all our `plane` objects. `planes.items` will keep all `plane` objects, `planes.getPlane()`
    will produce them, `planes.getPath()` will create the route''s path, and `planes.getWayPoints()`
    will sample our way points from the path:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要地看看 `planes` 对象。注意复数形式！这与我们为每条路线构建的 `plane` 对象不同。它是所有 `plane` 对象的家。`planes.items`
    将保存所有 `plane` 对象，`planes.getPlane()` 将生成它们，`planes.getPath()` 将创建路线的路径，而 `planes.getWayPoints()`
    将从路径中采样我们的 `wayPoints`：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s look at what each `planes` function does. There are three simple steps:
    first, we build the plane, then we draw each plane''s path, and finally we sample
    points from that path we can iterate through to make the plane move:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个 `planes` 函数的作用。这里有三个简单的步骤：首先，我们构建飞机，然后绘制每架飞机的路径，最后从该路径中采样点，我们可以迭代这些点来使飞机移动：
- en: '**Manufacturing a plane**:the `getPlane()` function takes the `planeRoute`
    – the three-letter airport codes for origin and destination – and uses it to initialize
    the plane''s position:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**制造飞机**：`getPlane()` 函数接受 `planeRoute` – 起点和目的地的三位字母机场代码 – 并用它来初始化飞机的位置：'
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It returns an object holding the `startX` and `startY` positions it retrieves
    from the `airportMap` lookup you created earlier. It also has `x` and `y` coordinates
    representing the current position of the plane. For the first frame this is the
    same as `startX` and `startY.` It also holds an as yet empty object for the `route`
    path and the `wayPoints` we calculate next. Lastly, it has a `currentIndex` keeping
    track of the way point the plane is at when we change its position (this will
    become clearer very soon).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个对象，包含从你之前创建的 `airportMap` 查找中检索到的 `startX` 和 `startY` 位置。它还有 `x` 和 `y`
    坐标，代表飞机的当前位置。对于第一帧，这和 `startX` 和 `startY` 相同。它还包含一个尚未填写的对象，用于 `route` 路径和我们在下一步计算的
    `wayPoints`。最后，它有一个 `currentIndex`，用于跟踪我们在改变飞机位置时飞机所在的 `wayPoint`（这很快就会变得清楚）。
- en: '**Drawing each plane''s path**:plane initialized. Now, let''s get the path.
    Remember that we created two path generators during setup? One was a Canvas path
    to draw worlds, the airport, and plane circles. The other one – `pathSVG` – was
    for creating the route as an SVG path. Why would you want to do that? Because
    SVG paths have the great `.getTotalLength()` and `.getPointAtLength()` methods
    that make it easy to sample points from that path. Here''s how to use D3 to create
    the path:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘制每架飞机的路径**：飞机初始化。现在，让我们获取路径。记得我们在设置期间创建了两个路径生成器吗？一个是用于绘制世界、机场和平面圆的Canvas路径。另一个是`pathSVG`，用于创建作为SVG路径的路线。你为什么要这样做呢？因为SVG路径有很好的`.getTotalLength()`和`.getPointAtLength()`方法，这使得从该路径中采样点变得容易。以下是使用D3创建路径的方法：'
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You won't create the path in the DOM, but only in memory and save it in the
    `pathElement` variable. As it's an SVG and not an HTML element, you need to specify
    the SVG namespace which you can do with D3's `.namespaces.svg` utility function.
    Then you create the path before returning the raw element rather than the D3 selection
    as `route.node()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会在DOM中创建路径，而是在内存中创建并保存到`pathElement`变量中。由于它是一个SVG而不是HTML元素，你需要指定SVG命名空间，这可以通过D3的`.namespaces.svg`实用函数来完成。然后你在返回原始元素而不是D3选择`route.node()`之前创建路径。
- en: '**Retrieving the way points**:all set to calculate the way points. `getWayPoints()`
    takes the plane which by now has its path stored in the `plane.route` property.
    We use the path sampling functions we just praised on its path and return an array
    holding all way points for this specific plane''s route path:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检索航点**：所有设置都已就绪以计算航点。`getWayPoints()`接受一个飞机，此时飞机的路径已存储在`plane.route`属性中。我们使用我们刚刚赞扬的路径采样函数来处理其路径，并返回一个包含该特定飞机路线路径所有航点的数组：'
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, you create an empty array called `arr` which will hold all your way points.
    Then, you produce an integer saved in the `points` variable. This integer will
    represent the number of points we want to sample from the path. You get the total
    length of the path, which is represented by the number of pixels the path will
    take up. This, you multiply by `2.5`. This very factor is important and controls
    how many points will be sampled and hence how fast or slow the animation will
    be. The higher the number, the more points it will sample and the slower the animation
    will appear. If you choose a low number or even a fraction such as *0.1*, few
    points will be sampled and the animation will appear faster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个名为`arr`的空数组，它将保存所有航点。然后，你生成一个保存在`points`变量中的整数。这个整数将代表我们从路径中想要采样的点的数量。你获取路径的总长度，这由路径将占据的像素数表示。这个值乘以`2.5`。这个因子非常重要，它控制了将采样多少点以及动画的快慢。数字越高，采样的点越多，动画看起来越慢。如果你选择一个低数字甚至是一个分数，如*0.1*，采样的点会很少，动画看起来会更快。
- en: You use `d3.range(points).forEach()` to retrieve the coordinates returned as
    so-called `DOMPoints` by `.getPointAtLength()` at each point of the path. Then
    you push each of them into the array and voila, you have your way points.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`d3.range(points).forEach()`来检索在每个路径点由`.getPointAtLength()`返回的所谓`DOMPoints`坐标。然后你将它们中的每一个推入数组，然后就是你的航点。
- en: 'Congratulations. You have just built a plane. In fact, you have built a plane
    and its route and all the points you need to make it jump to so that a viewer
    would think it flies. This is how it looks inside:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你。你刚刚构建了一架飞机。实际上，你构建了一架飞机及其路线以及所有需要使其跳跃的点，这样观众就会认为它在飞行。这就是它内部的样子：
- en: '![](img/ca50163d-84e0-461b-babd-943c3e5fe0f0.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca50163d-84e0-461b-babd-943c3e5fe0f0.png)'
- en: The plane flying from Frankfurt to Atlanta
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从法兰克福飞往亚特兰大的飞机
- en: Animating the plane
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞机动画
- en: 'The rest is simple. You just need to apply the game loop to the canvas. We''ve
    already encountered this a few times; you create a function called `animate()`
    and let it run in a continuous loop:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的很简单。你只需要将游戏循环应用到画布上。我们已经遇到过几次这种情况；你创建一个名为`animate()`的函数，并让它在一个连续的循环中运行：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note, that we added the used functions to the planes object as well, to keep
    all plane-related function code together.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还把使用的函数添加到了飞机对象中，以保持所有与飞机相关的函数代码在一起。
- en: First, we clear the canvas. `planes.clearPlanes()` literally just clears the
    context we pass to it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们清除画布。`planes.clearPlanes()`实际上只是清除我们传递给它的上下文。
- en: 'Then we iterate through the `planes.items` array holding all planes and update
    each plane with `planes.updatePlane()`. We pass it the respective plane and it
    either moves the `x` and `y` coordinates to the start if the plane has reached
    its destination or it moves them to the next way point coordinate:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历包含所有飞机的`planes.items`数组，并使用`planes.updatePlane()`更新每个飞机。我们传递相应的飞机，如果飞机已到达目的地，则将其`x`和`y`坐标移动到起点，或者将其移动到下一个航点的坐标：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The use of `currentIndex` should become clearer here. It keeps track of where
    each plane is on its path as well as moving the plane forward by one way point
    on each update.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`currentIndex`的使用应该变得更加清晰。它跟踪每个飞机在其路径上的位置，并在每次更新时将飞机向前移动一个航点。
- en: 'Finally, we draw the plane (this is where we realize we haven''t built an actual
    plane but a `tomato` colored circle):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绘制了平面（这时我们意识到我们并没有真正建造一个飞机，而是一个**番茄色**的圆圈）：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, you kick it off with `requestAnimationFrame()`. You can use `setInterval()`
    but you should use `requestAnimationFrame()` instead. It will allow the browser
    to choose the best time to trigger its callback before the next repaint. This
    is much more economical compared to the brute force `setInterval()`. It also has
    the additional benefit of interrupting the loop when the browser tab the app runs
    on is not in focus. Note also, that we save the `requestID` of each loop. You
    might remember that we use this unique ID to cancel the current loop with `cancelAnimationFrame(requestID)`
    when the user presses a button to set off a new loop.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用`requestAnimationFrame()`来启动它。你可以使用`setInterval()`，但你应该使用`requestAnimationFrame()`。它将允许浏览器在下次重绘之前选择最佳时间来触发其回调。这比强制的`setInterval()`更经济。它还有额外的优点，即当应用程序运行的浏览器标签页不在焦点时，可以中断循环。注意，我们还保存了每个循环的`requestID`。你可能记得，当用户按下按钮启动新循环时，我们使用这个唯一的ID通过`cancelAnimationFrame(requestID)`取消当前循环。
- en: Done. Well done.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。做得好。
- en: Measuring the performance
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测量
- en: 'So far so good. But does it work? And if it works, does it work better than
    the SVG example? Let''s recall that the SVG flight path visual gave us a whopping
    60 FPS for 100 animated circles and a meager 6 FPS for some 5,000 animated circles.
    Let''s start with 100 circles and focus on the `stats.js` measure in the top-left
    corner:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但是它工作吗？如果它工作，它比SVG示例工作得更好吗？让我们回忆一下，SVG飞行路径可视化为我们提供了100个动画圆的60 FPS和大约5,000个动画圆的6
    FPS。让我们从100个圆开始，关注左上角的`stats.js`度量：
- en: '![](img/d1367c00-7bfd-4a2b-b49f-a90f3d1a74d7.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1367c00-7bfd-4a2b-b49f-a90f3d1a74d7.png)'
- en: Canvas visualization of 100 flight paths at 60 FPS
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 60 FPS的100条飞行路径的Canvas可视化
- en: View this step in the browser at: [https://larsvers.github.io/learning-d3-mapping-9-2a](https://larsvers.github.io/learning-d3-mapping-9-2a).
    Code example [09_02a.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02a.html).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-9-2a](https://larsvers.github.io/learning-d3-mapping-9-2a)。代码示例[09_02a.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02a.html)。
- en: 'We expected 60 FPS. Let''s go to 1,000 flights:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望60 FPS。让我们增加到1,000架航班：
- en: '![](img/2e04a0e3-eac8-4a50-a4ec-62b7ea6f2203.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e04a0e3-eac8-4a50-a4ec-62b7ea6f2203.png)'
- en: Canvas visualization of 1,000 flight paths at 60 FPS
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 60 FPS的1,000条飞行路径的Canvas可视化
- en: Again, 60 FPS! 5,000 planes?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，60 FPS！5,000架飞机？
- en: '![](img/a914d46d-9c9a-4d7c-9062-1c4b4f0f8c22.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a914d46d-9c9a-4d7c-9062-1c4b4f0f8c22.png)'
- en: Canvas visualization of 5,000 flight paths at 45 FPS
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 45 FPS的5,000条飞行路径的Canvas可视化
- en: 'It''s going down, but still at 45 FPS keeping the animation fluid. Let''s look
    at 10,000 flights:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在下降，但仍然保持在45 FPS，保持动画流畅。让我们看看10,000架航班：
- en: '![](img/8fccd0c7-df9c-4e14-a37b-810eaae2305d.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fccd0c7-df9c-4e14-a37b-810eaae2305d.png)'
- en: Canvas visualization of 10,000 flight paths at 23 FPS
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 23 FPS的10,000条飞行路径的Canvas可视化
- en: We still see a frame rate similar to what you see when watching a movie with
    23 FPS. However, let's try and squeeze out a bit more.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然看到与观看23 FPS电影时相似的帧率。然而，让我们尝试挤出更多一些。
- en: Optimizing performance
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化
- en: Remember that we've used two canvases for this visual, one canvas to draw the
    static background scene with the map and the airports and one canvas for the dynamic
    flight animation. We did this because it kept drawing concerns separate.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们为这个可视化使用了两个Canvas，一个Canvas用于绘制带有地图和机场的静态背景场景，另一个Canvas用于动态飞行动画。我们这样做是因为它保持了绘制关注点的分离。
- en: Another reason for using an additional canvas is increased performance. We can
    use one canvas as an **in-memory buffer** to pre-render elements and just copy
    its contents onto the main visible canvas. This saves render costs as drawing
    on a visible canvas is less performant than drawing on a non-visible canvas to
    then copy over the image to the main canvas. Performance further rejoices as the
    context's `drawImage()` method we will use to copy over the image from the buffer
    to the display canvas, is hardware accelerated (meaning it uses the parallel processing
    powers of the GPU) by default.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用额外画布的另一个原因是提高了性能。我们可以使用一个画布作为 **内存缓冲区** 来预渲染元素，然后将其内容复制到主可见画布上。这节省了渲染成本，因为绘制在可见画布上比绘制在不可见画布上然后复制图像到主画布要低效。性能进一步得到提升，因为我们将要使用的上下文的
    `drawImage()` 方法默认是硬件加速的（这意味着它使用 GPU 的并行处理能力）。
- en: For our little app, the animated elements are the plane circles. Instead of
    drawing them with the `drawPlane()` function for each update, we can first create
    a single image of a circle on a small buffer canvas and then use `drawImage()`
    to port it over to the `canvasPlane.`
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的小程序，动画元素是飞机圆圈。我们不必在每次更新时使用 `drawPlane()` 函数来绘制它们，而是可以先在小型缓冲画布上创建一个圆圈的单一图像，然后使用
    `drawImage()` 将其传输到 `canvasPlane`。
- en: 'We create a single plane image in global scope:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在全局范围内创建了一个单独的飞机图像：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We create our buffer canvas called `planeImg` in thin air, set its `width` and
    `height` to `2` (double the plane's desired radius of `1`), and retrieve its context.
    We'll draw a `tomato` colored circle on it before we return it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在空中创建了一个名为 `planeImg` 的缓冲画布，将其 `width` 和 `height` 设置为 `2`（是平面期望半径 `1` 的两倍），并获取其上下文。在返回之前，我们将在其上绘制一个
    `tomato` 颜色的圆圈。
- en: 'We call this function once when initializing the `planes` object and store
    it as an image in the `planes` object:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在初始化 `planes` 对象时调用此函数一次，并将其作为图像存储在 `planes` 对象中：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we just have to remove our `drawPlane()` function we used to draw
    the circle on every update. Instead, we add a new function called `drawPlaneImage()`
    to the `planes` object that uses `drawImage()` to add our plane icon (the circle)
    to the context we determine:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需移除我们用来在每次更新时绘制圆圈的 `drawPlane()` 函数。相反，我们向 `planes` 对象添加一个名为 `drawPlaneImage()`
    的新函数，该函数使用 `drawImage()` 将我们的飞机图标（圆圈）添加到我们确定的上下文中：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, we don''t call `drawImage()` in the `animate()` function, but `drawPlaneImage()`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `animate()` 函数中不调用 `drawImage()`，而是调用 `drawPlaneImage()`：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Continuing with measuring performance
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续测量性能
- en: 'Now let''s check the frame rate for animating 10,000 points:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查动画 10,000 个点的帧率：
- en: '![](img/aff3f428-0751-4728-842b-44d1d7b9bc84.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aff3f428-0751-4728-842b-44d1d7b9bc84.png)'
- en: Canvas visualization of 10,000 flight paths at 36 instead of 23 FPS
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 36 FPS 而不是 23 FPS 下，10,000 条飞行路径的画布可视化
- en: 'View complete app at: [https://larsvers.github.io/learning-d3-mapping-9-2b](https://larsvers.github.io/learning-d3-mapping-9-2b).
    Code example: [09_02b.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02b.html).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 查看完整应用程序：[https://larsvers.github.io/learning-d3-mapping-9-2b](https://larsvers.github.io/learning-d3-mapping-9-2b)。代码示例：[09_02b.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02b.html)。
- en: That's great, boosting performance by about +57% compared to not using the powers
    of `drawImage()`. It's not shown here, but 5,000 points were animated at 60 FPS
    instead of 45 FPS. Yay.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了，与不使用 `drawImage()` 的能力相比，性能提升了约 +57%。这里没有显示，但 5,000 个点以 60 FPS 而不是 45 FPS
    动画。耶。
- en: Moving on, 15,000 flights fly with 24 FPS and 20,000 with up to 18 FPS. This
    is still just beyond the 16 FPS generally considered the lowest possible frame
    rate for fooling the brain into believing a fluid animation. Even 25,000 planes
    still move with around 14 frames per second conveying a mild jank, while 30,000
    flights stutter still only modestly at 12 FPS.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，15,000 架飞机以 24 FPS 飞行，20,000 架飞机以高达 18 FPS 飞行。这仍然略高于通常认为的最低可能帧率 16 FPS，以欺骗大脑相信流畅的动画。即使
    25,000 架飞机仍然以大约每秒 14 帧的速度移动，表现出轻微的卡顿，而 30,000 架飞机在 12 FPS 下仍然只有轻微的卡顿。
- en: '![](img/0e1e2049-a745-45f5-a39b-dc83b29464cc.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e1e2049-a745-45f5-a39b-dc83b29464cc.png)'
- en: Canvas visualization of 30,000 flight paths at 12 FPS
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 12 FPS 下，30,000 条飞行路径的画布可视化
- en: While performance can vary with different browsers, CPU’s and GPU’s the jump
    from SVG to Canvas is significant!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然性能会因不同的浏览器、CPU 和 GPU 而异，但从 SVG 跳转到 Canvas 的提升是显著的！
- en: With Canvas we have achieved our narrative mission to visualize regions of heavy
    flight activity. All of Europe seems to be in the air, as well as the east and
    west of the US and the east of China. Other continents show a line of increased
    air-activity along their costs. You might be surprised by the band of planes moving
    down through Thailand and Indonesia, although this is a densely-populated area.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Canvas，我们实现了我们的叙事任务，即可视化高飞行活动区域。整个欧洲似乎都在空中，以及美国的东海岸和西海岸以及中国的东部。其他大陆在其海岸线上显示出增加的航空活动线。你可能会对沿着泰国和印度尼西亚移动的飞机带感到惊讶，尽管这是一个人口密集的地区。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you have learned how to build a flight path visualization
    in SVG and in Canvas, bringing together much of what you have learned before.
    You have seen how it requires a different mental model to program animations with
    Canvas, probably best summarized by the game loop: process your data, clear the
    drawing, re-draw the animation. You have used D3 to set up the visualizations,
    but you have also seen that due to the different coding concept, Canvas might
    require you to step away a little from D3 core functionality like transitions.
    However, all that paid off by witnessing the power of Canvas when it comes to
    animation. Instead of being able to fluidly animate 1,000 points we managed to
    animate 15,000 points safely and 20,000 points still gracefully with optimized
    Canvas techniques.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 SVG 和 Canvas 构建飞行路径可视化，将之前学到的许多知识整合在一起。你看到了使用 Canvas 编程动画需要不同的思维模式，这最好通过游戏循环来概括：处理数据，清除绘图，重新绘制动画。你使用了
    D3 来设置可视化，但也看到了由于不同的编码概念，Canvas 可能需要你稍微远离 D3 的核心功能，如过渡效果。然而，所有这些努力都得到了回报，因为我们见证了
    Canvas 在动画方面的强大功能。我们不仅能够流畅地动画化 1,000 个点，还通过优化的 Canvas 技巧安全地动画化了 15,000 个点，并且优雅地动画化了
    20,000 个点。
- en: 'After having seen the benefits of Canvas, let''s now find a workaround for
    one of its caveats: interactivity!'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到了 Canvas 的好处之后，现在让我们找到一个解决其缺点之一的方案：交互性！
