- en: Chapter 10. Game On
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。游戏开始
- en: A quick browse through any of the online app stores quickly shows that the largest
    segment of the mobile applications market belongs to gaming. While most programmers
    would not think of JavaScript when it comes to developing games, it is actually
    well suited for a wide variety of games, including turn-based strategy games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览任何在线应用商店都会迅速显示，移动应用程序市场最大的部分属于游戏。虽然大多数程序员在开发游戏时不会想到 JavaScript，但实际上它非常适合各种游戏，包括回合制策略游戏。
- en: 'These games require only limited animation and can easily be built using the
    Sencha Touch Framework and the Sencha.io platform for communication. For turn-based
    strategy games, we only need to do a few basic things such as:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些游戏只需要有限的动画，并且可以很容易地使用 Sencha Touch 框架和 Sencha.io 平台进行通信。对于回合制策略游戏，我们只需要做几件基本的事情，例如：
- en: Build a game board
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建游戏棋盘
- en: Build the individual pieces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建单个棋子
- en: Handle moves
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理移动
- en: Handle the outcomes when one piece attacks another
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理一个棋子攻击另一个棋子的结果
- en: Handle communication of the moves between players at the end of a turn
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理玩家在回合结束时移动的通信
- en: Define the end of the game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义游戏的结束
- en: While this might seem a trivial style of game, it covers everything from tic-tac-toe
    to chess, poker, Go, Risk, and the incredibly complex tabletop strategy games
    of the pre-Internet era, such as Axis and Allies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种游戏风格可能看起来很微不足道，但它涵盖了从井字棋到国际象棋、扑克、围棋、风险以及互联网时代之前的复杂桌面策略游戏（如轴心国与同盟国）的一切。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: If you really want an idea of how complex some of these games can get, take
    a look at [http://boardgamegeek.com/](http://boardgamegeek.com/) and check out
    the strategy section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想了解这些游戏有多复杂，请查看 [http://boardgamegeek.com/](http://boardgamegeek.com/)
    并查看策略部分。
- en: Since we don't have an entire book to dedicate to this single topic, we are
    going to start with a relatively simple game of checkers. We will also explore
    some of the possible ways to take this simple game and build on it to create more
    complex games.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有一本整本书来专门讨论这个单一主题，我们将从一个相对简单的跳棋游戏开始。我们还将探讨一些将这个简单游戏扩展并创建更复杂游戏的可能方法。
- en: Building the basic board
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基本棋盘
- en: With any type of turn-based strategy game, it all starts with the board. The
    board determines where the pieces are placed and where they are allowed to move.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何类型的回合制策略游戏中，一切始于棋盘。棋盘决定了棋子放置的位置以及它们可以移动的位置。
- en: A board for checkers or chess consists of an 8 by 8 grid of squares. The squares
    alternate in color between light and dark (typically red and black for a dedicated
    checkers board).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 跳棋或国际象棋的棋盘由一个 8x8 的方格网格组成。方格在浅色和深色（通常为跳棋棋盘的红色和黑色）之间交替。
- en: Additionally, only the dark squares can be used by the pieces in checkers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，只有深色方格可以被跳棋的棋子使用。
- en: You could use a number of different Sencha Touch components to create such a
    board, but for these purposes a DataView is probably the most appropriate. A DataView
    will allow us to tap and select the piece we want to move as well as the place
    we want to move it to. These selection methods are already built into the DataView.
    We can also apply styles based on these selections to let the user know which
    moves are valid.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用许多不同的 Sencha Touch 组件来创建这样的棋盘，但出于这些目的，一个 DataView 可能是最合适的选择。DataView 将允许我们点击并选择我们想要移动的棋子以及我们想要将其移动到的位置。这些选择方法已经内置在
    DataView 中。我们还可以根据这些选择应用样式，让用户知道哪些移动是有效的。
- en: Creating the square model
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建方格模型
- en: 'Our DataView will be fed by a store with a model we call `Square`. It looks
    like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DataView 将由一个我们称为 `Square` 的模型提供数据。它看起来像这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This model carries five key pieces of information:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型包含五个关键信息：
- en: '`squareID` tells us exactly where the square is located on our board.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`squareID` 告诉我们方格在我们棋盘上的确切位置。'
- en: The value for `occupiedBy` tells us if the square is currently occupied by a
    red piece, a black piece, or if it is unoccupied (`none`).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`occupiedBy` 的值告诉我们方格目前是否被红色棋子、黑色棋子占据，或者是否为空（`none`）。'
- en: '`pieceType` will tell us if we are dealing with a regular piece or a king.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pieceType` 将告诉我们我们是在处理普通棋子还是国王。'
- en: The `decoration` setting will allow us to indicate the current movement path
    for the pieces and if a particular piece has been jumped.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decoration` 设置将允许我们指示棋子的当前移动路径以及是否有特定的棋子被跳过。'
- en: The `background` setting controls the background color of the piece. We will
    use this to set a style in our xTemplate for the DataView.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background` 设置控制棋子的背景颜色。我们将使用它来为 DataView 设置样式。'
- en: 'Our initial load in of data would look something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始加载数据看起来可能像这样：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would continue on to give us eight rows of eight squares per row. Squares
    are designated A through H and rows are numbered 1 through 8\. This data will
    also lay out our initial pieces in the standard layout for the start of a checkers
    game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将继续，给我们每行八个方格的八行。方格用A到H表示，行用1到8编号。这些数据还将按照国际跳棋游戏开始的标准布局排列初始棋子。
- en: You will also notice that when we alternate the backgrounds, we keep the last
    item of the row and the first item of the next row as the same color (`H1` and
    `A2` are both `dark`). This gives us our checkerboard pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到，当我们交替背景时，我们保持行的最后一个项目和下一行的第一个项目颜色相同（`H1`和`A2`都是`dark`）。这给了我们我们的棋盘图案。
- en: '![Creating the square model](img/8901OS_10_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![创建方格模型](img/8901OS_10_01.jpg)'
- en: 'The actual board image itself is a single background image. We have arranged
    our DataView to fit over the board and align with the individual squares. This
    will let us place elements on any square we choose using CSS. The `dataview` code
    is included as one of the items in our `view/Main.js` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的棋盘图像本身是一个单独的背景图像。我们已经安排了我们的DataView覆盖棋盘并与单个方格对齐。这将使我们能够使用CSS将元素放置在我们选择的任何方格上。`dataview`代码作为我们`view/Main.js`文件中的一个项目包含在内：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This DataView has a `cls` value of `board` so we can set the background image
    to the big checkerboard image in our `resources/css/app.css` file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个DataView有一个`cls`值为`board`，因此我们可以将背景图像设置为我们的`resources/css/app.css`文件中的大棋盘图像。
- en: Exploring itemTpl
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索`itemTpl`
- en: 'We also make extensive use of classes in the `itemTpl` config. Let''s take
    a look at the template line by line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`itemTpl`配置中广泛使用了类。让我们逐行查看模板：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first line sets up a `div` element with a `class` value of `gameSquare`.
    Each `gameSquare` is set in the `app.css` file to:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行设置了一个`div`元素，其`class`值为`gameSquare`。每个`gameSquare`在`app.css`文件中设置为：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This sets the individual items in our DataView to line up with our game board.
    By setting `position: relative`, we can also position items absolutely within
    `gameSquare`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '这将我们的DataView中的单个项目设置为与游戏板对齐。通过设置`position: relative`，我们还可以在`gameSquare`内绝对定位项目。'
- en: 'We also add a class for `{background}`. This value will be pulled from our
    data store and it will be either light or dark. We add this class so we can change
    the font color for our dark tiles to white. In the CSS, this looks like:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`{background}`类。这个值将从我们的数据存储中提取，它将是浅色或深色。我们添加这个类，以便我们可以将深色方格的字体颜色更改为白色。在CSS中，这看起来像：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next class we set is `decoration`. The `decoration` class will be used
    to show arrows for movement and a negation symbol when a piece will be jumped
    as part of a move as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的下一个类是`decoration`。`decoration`类将用于显示移动时的箭头和当棋子作为移动的一部分将被跳过时的否定符号，如下面的截图所示：
- en: '![Exploring itemTpl](img/8901OS_10_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![探索itemTpl](img/8901OS_10_02.jpg)'
- en: These images can be inserted into a style using the `before` CSS selector. This
    selector will insert content before our `div` element. In this case, we will insert
    a green arrow to indicate the direction the piece is moving.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像可以使用`before` CSS选择器插入到样式表中。这个选择器将在我们的`div`元素之前插入内容。在这种情况下，我们将插入一个绿色箭头以指示棋子移动的方向。
- en: 'For example, a piece moving up and to the left will have its `decoration` value
    set to `up_left` and the following style is applied in our `app.css` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个向上向左移动的棋子将它的`decoration`值设置为`up_left`，并在我们的`app.css`文件中应用以下样式：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By using `position: absolute`, we can set the `top` and `left` position of
    our image to any value we like including a negative number. The negative number
    places it up and to the left of the actual square (overlapping the square to the
    upper-left corner). The high `z-index` value insures that the image appears on
    top of the other images and text.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '通过使用`position: absolute`，我们可以将图像的`top`和`left`位置设置为任何我们喜欢的值，包括负数。负数将其放置在实际方格的上方和左侧（覆盖左上角的方格）。高`z-index`值确保图像出现在其他图像和文本之上。'
- en: We have similar CSS styles created for `.up_right`, `.down_left`, and `.down_right`.
    This gives us indicators for four diagonal directions of movement.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`.up_right`、`.down_left`和`.down_right`创建了类似的CSS样式。这为我们提供了四个对角方向移动的指示器。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of our images have been saved in the `resources/images` directory. If you
    change the location of the images, you will need to adjust the CSS file to match
    your setup.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的图片都保存在`resources/images`目录下。如果你更改图片的位置，你需要调整CSS文件以匹配你的设置。
- en: 'We also have a decoration class called `removed`. This class uses the CSS selector
    `after` to insert content after the `div` element and display our negation symbol
    over a piece that will be jumped during the current move. The CSS looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为`removed`的装饰类。这个类使用CSS选择器`after`在`div`元素之后插入内容，并在当前移动过程中将被跳过的棋子上的否定符号显示出来。CSS看起来像这样：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is similar to our styles for our arrows, except we need this symbol to show
    up over the top of our piece. We set its `top` and `left` attribute to `0` and
    because the image is the same size as our square, it floats over the top of the
    image of our piece. The higher z-index assures that it is the top element.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它类似于我们箭头的样式，但我们需要这个符号显示在棋子上方。我们将它的`top`和`left`属性设置为`0`，因为图像与我们的方格大小相同，它浮在棋子图像的上方。更高的z-index确保它是顶层元素。
- en: 'The next line of `itemTpl` is what controls the piece that occupies the square:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemTpl`的下一行控制占据方格的棋子：'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use a `tpl if` statement here to check and see if the square is occupied
    and if so, by what kind of piece. We use two of our data values to determine this
    value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`tpl if`语句来检查方格是否被占据，以及如果被占据，是由哪种类型的棋子占据。我们使用我们两个数据值来确定这个值。
- en: The first is `occupiedBy`, which can be `red`, `black`, or `none`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`occupiedBy`，可以是`red`、`black`或`none`。
- en: The second is `pieceType`, which can be `regular`, `king`, or `none`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`pieceType`，可以是`regular`、`king`或`none`。
- en: If both data values are set to `none`, we do not place a piece in the square.
    If we have a piece in the square, we use the combination of `occupiedBy` and `pieceType`
    to determine our image.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个数据值都设置为`none`，则我们不在方格中放置棋子。如果我们已经在方格中放置了棋子，我们使用`occupiedBy`和`pieceType`的组合来确定我们的图像。
- en: '![Exploring itemTpl](img/8901OS_10_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![探索itemTpl](img/8901OS_10_03.jpg)'
- en: These CSS values along with the individual squares from our DataView allow us
    to set the appearance of every square on the board by using the values stores
    in our data store.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些CSS值以及我们的DataView中的单个方格允许我们通过使用数据存储中存储的值来设置棋盘上每个方格的外观。
- en: Our individual moves can be created using the `select` event in our DataView.
    By setting the `mode` attribute to `MULTI`, the user can tap the piece they want
    to move and then the square they wish to move to. They can continue to tap squares
    if they are in a position to jump multiple pieces. We can also use the DataView's
    built-in `x-item-selected` class to highlight the squares the user has tapped.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用DataView中的`select`事件创建单个移动。通过将`mode`属性设置为`MULTI`，用户可以点击他们想要移动的棋子，然后点击他们想要移动到的方格。如果他们处于可以跳过多个棋子的位置，他们可以继续点击方格。我们还可以使用DataView内置的`x-item-selected`类来突出显示用户点击的方格。
- en: 'We just add the highlighted styles to our stylesheet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将高亮样式添加到我们的样式表中：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This gives us a green border to match our arrows and changes the text color
    as well. We also set a slightly different text color in our dark squares for readability.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个与箭头匹配的绿色边框，并更改了文本颜色。我们还在我们的深色方格中设置了一个稍微不同的文本颜色以提高可读性。
- en: Now that we have all of our different display possibilities mapped out, we need
    to set up the logic for the game.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有不同的显示可能性绘制出来，我们需要设置游戏的逻辑。
- en: Creating the game controller
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏控制器
- en: 'The game controller is where the logic for our game will go. Here we will follow
    the basic rules for checkers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏控制器是我们游戏逻辑所在的地方。在这里，我们将遵循跳棋的基本规则：
- en: Pieces are initially arranged on the opposite sides of the board in three rows,
    only on the black squares
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先在棋盘的相对两侧的三行中排列棋子，只位于黑色方格上
- en: Pieces can move diagonally
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋子可以斜着移动
- en: Pieces can only move to an empty square
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋子只能移动到空方格
- en: Regular pieces can only move forward
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通棋子只能向前移动
- en: Pieces can only move one square, unless jumping over an adjacent piece
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋子只能移动一个方格，除非跳过一个相邻的棋子
- en: Pieces can only jump one piece at a time
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋子一次只能跳过一个棋子
- en: Jumped pieces are removed from the board
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被跳过的棋子从棋盘上移除
- en: King pieces can move forward and backwards
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 皇后棋子可以向前和向后移动
- en: A regular piece that reaches the opposite side of the board is changed to a
    king piece, ending their current turn
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一枚到达棋盘另一侧的普通棋子被改变为皇后棋子，结束它们的当前回合
- en: The game is finished when all the pieces from one side have been jumped and
    removed
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一方的所有棋子都被跳过并移除后，游戏结束
- en: Our controller will check each move to see if it follows these rules and remove
    the pieces that have been jumped. For the purposes of this chapter, we will only
    be creating a local game. This is one in which two players would play by passing
    back and forth a single device. However, this game could easily be modified to
    allow for networked play using Sencha.io or an external API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器将检查每一步移动是否符合这些规则，并移除被跳过的棋子。为了本章的目的，我们只创建一个本地游戏。这是一种两个玩家通过互相传递一个单一设备来进行的游戏。然而，这个游戏可以很容易地修改为允许使用
    Sencha.io 或外部 API 进行网络游戏。
- en: Before we dive into the code for the controller, we need to add some things
    to our main view. We need a way for each user to start and finish a turn. We will
    also need a way to show a previous turn so that a user can see what occurred during
    the last move.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究控制器代码之前，我们需要在我们的主视图中添加一些东西。我们需要一种方式让每个用户开始和结束一轮。我们还需要一种方式来显示上一轮，以便用户可以看到在上一个移动中发生了什么。
- en: 'To do this, we will add a toolbar with two buttons to the bottom of our main
    view:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在主视图的底部添加一个带有两个按钮的工具栏：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will expand the functionality of these two buttons in our controller, so
    that they will also allow us to finish a turn or clear a currently selected move
    if we change our mind before finishing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在控制器中扩展这两个按钮的功能，以便它们还可以允许我们在完成之前改变主意时完成一轮或清除当前选定的移动。
- en: Now let's see how this all fits together in the controller.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看所有这些在控制器中是如何组合在一起的。
- en: 'As always, we start out by setting up our controller with the `control` and
    `refs` sections:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先通过设置 `control` 和 `refs` 部分来设置我们的控制器：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We create references for our board and our two buttons. In the `control` section,
    we add `select` and `deselect` functions for our board, and `tap` functions for
    our two buttons. The `mainBtn` function will start a turn and execute the finished
    move. The `altBtn` function will show the previous turn or clear the current set
    of moves. We will swap the text and functionality appropriately as part of the
    `tap` functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的棋盘和两个按钮创建引用。在 `control` 部分，我们为棋盘添加 `select` 和 `deselect` 函数，并为两个按钮添加 `tap`
    函数。`mainBtn` 函数将开始一轮并执行完成的移动。`altBtn` 函数将显示上一轮或清除当前选定的移动。我们将适当交换 `tap` 函数中的文本和功能。
- en: 'In order to track the turns, we are going to add two custom variables to our
    controller. These go down below our `refs` section (inside the `config` section):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪回合，我们将在控制器中添加两个自定义变量。这些变量位于我们的 `refs` 部分下方（在 `config` 部分内部）：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `previousTurn` variable will store red or black for `player`, `piece` (piece
    that was moved), `moves` (moves that were made—as an array), and `removedPieces`
    (pieces removed—as an array). This will let us highlight the squares from the
    previous turn when the user clicks on the **Show Previous Turn** button.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`previousTurn` 变量将存储 `player`（玩家）、`piece`（移动的棋子）、`moves`（移动的步骤——作为一个数组）和 `removedPieces`（移除的棋子——作为一个数组）。这将允许我们在用户点击
    **显示上一轮** 按钮时突出显示上一轮的方格。'
- en: 'The `currentTurn` variable stores the same information as `previousTurn`, but
    it also adds `Boolean` data for:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentTurn` 变量存储与 `previousTurn` 相同的信息，但它还添加了 `Boolean` 数据用于：'
- en: '`endOfTurn`: Has the user confirmed and completed the current move?'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endOfTurn`: 用户是否确认并完成了当前移动？'
- en: '`hasJumped`: Has the user jumped a piece as part of their turn?'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasJumped`: 用户是否在他们的回合中跳过一个棋子？'
- en: '`started`: Has the user pressed the **Start Turn** button?'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`started`: 用户是否按下了 **开始回合** 按钮？'
- en: '`kingable`: Has the user reached the opposite end of the board as part of the
    current move?'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kingable`: 用户是否在当前移动中到达了棋盘的对角端？'
- en: We also set the value for player to `black` by default, as black traditionally
    moves first in checkers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将玩家的默认值设置为 `black`，因为在跳棋中黑色传统上先移动。
- en: By declaring these `previousTurn` and `currentTurn` variables as part of `config`,
    we automatically create getters and setters for both. This means we can do things
    like `this.getPreviousTurn()` and `this.setCurrentTurn()` inside any of our controller
    functions. We will be using these functions extensively throughout the controller.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些 `previousTurn` 和 `currentTurn` 变量作为 `config` 的一部分声明，我们自动为两者创建了获取器和设置器。这意味着我们可以在任何控制器函数中执行类似
    `this.getPreviousTurn()` 和 `this.setCurrentTurn()` 的操作。我们将在控制器中广泛使用这些函数。
- en: Understanding basic controller functions
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解基本控制器功能
- en: Another thing that we will be using extensively in this controller is the concept
    of **subordinate functions** . These are functions that are called by other functions.
    While it might seem counter intuitive at first, splitting larger functions apart
    into smaller sub functions makes the logic easier to follow.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器中，我们还将大量使用**从属函数**的概念。这些是由其他函数调用的函数。虽然一开始可能感觉有些反直觉，但将较大的函数拆分成较小的子函数可以使逻辑更容易理解。
- en: This is especially true in the case of game logic, where the rules for the game
    can quickly spiral into a series of incomprehensible "if…then" statements. By
    splitting the logic into smaller functions, the logic is much easier to check.
    You can simply use `console.log()` to output the value you start with and the
    value you finish with in each of the smaller functions. This makes it much easier
    to tell which pieces are functioning as expected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这在游戏逻辑的情况下尤其如此，因为游戏规则可以迅速演变成一系列难以理解的“如果…那么”语句。通过将逻辑拆分成更小的函数，逻辑检查变得更加容易。你可以简单地使用`console.log()`来输出每个较小函数开始和结束时的值。这使得判断哪些棋子按预期工作变得容易得多。
- en: 'For this application, we have some smaller functions that help us with our
    game logic. We won''t go into great detail about these smaller functions but they
    can be found in the `controller/Game.js` file. These functions include:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，我们有一些较小的函数帮助我们处理游戏逻辑。我们不会详细介绍这些较小的函数，但它们可以在`controller/Game.js`文件中找到。这些函数包括：
- en: '`nextLetter` and `previousLetter`: Given a letter and a distance, these two
    functions return the next or previous letter in the sequence. For example, `nextLetter(''c'',
    2)` would return `e` when called. These will help us determine positioning on
    the board.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nextLetter`和`previousLetter`：给定一个字母和距离，这两个函数会返回序列中的下一个或前一个字母。例如，调用`nextLetter(''c'',
    2)`会返回`e`。这些将帮助我们确定棋盘上的位置。'
- en: '`getIntermediateSquare`: Given a *from location* and a *to location*, this
    function will return the square located between the two squares. This is used
    when a piece is jumped, so we can determine if a move is valid and apply the correct
    decorations to the square (arrows and negation symbol for jumped pieces).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getIntermediateSquare`：给定一个**起始位置**和一个**目标位置**，这个函数将返回位于两个方格之间的方格。当棋子跳过时使用此功能，这样我们可以确定移动是否有效，并正确地应用装饰到方格上（箭头和跳过的棋子的否定符号）。'
- en: '`isKingable`: Given the location the piece is moving to, is it eligible to
    be kinged?'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isKingable`: 给定棋子移动到的位置，它是否有资格成为国王？'
- en: '`clearTurn`: Clears out any old data from the current term and deselects any
    selected squares in the DataView.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearTurn`：清除当前术语中的任何旧数据，并在DataView中选择任何选中方格。'
- en: '`clearDecorations`: Clears any decorations from the data store (clearing this
    data also removes it from the display).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearDecorations`：清除数据存储中的任何装饰（清除这些数据也会将其从显示中移除）。'
- en: Aside from these smaller functions, the main logic for the board is handled
    in the `select` event. This event needs to check and see if we have a valid move,
    and then add the appropriate decorations to the board. These decorations will
    show the selected piece, the direction of the move, and any affected squares or
    pieces.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些较小的函数之外，棋盘的主要逻辑由`select`事件处理。这个事件需要检查是否有有效的移动，然后向棋盘添加适当的装饰。这些装饰将显示选中的棋子、移动的方向以及任何受影响的方格或棋子。
- en: The game board logic
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏棋盘逻辑
- en: 'The game logic will function as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏逻辑将按以下方式工作：
- en: A player clicks on the **Start Turn** button.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家点击**开始回合**按钮。
- en: The game responds with an alert telling the player it is black's or red's turn.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏会通过一个警告框告诉玩家现在是黑方或红方的回合。
- en: The player taps a piece.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家点击一个棋子。
- en: The game checks that a valid piece was tapped and stores the information in
    the `currentMove` variable.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏会检查是否点击了有效的棋子，并将信息存储在`currentMove`变量中。
- en: The player taps a destination square.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家点击目标方格。
- en: The game checks if the destination is valid and stores the information in the
    `currentMove` variable.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏会检查目标位置是否有效，并将信息存储在`currentMove`变量中。
- en: The player can then tap **Finish** **Turn!** to complete the turn or tap additional
    squares if jumping multiple pieces (finally tapping **Finish** **Turn!** when
    all moves for the turn are complete).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家可以点击**完成回合**以完成回合，或者点击更多方格以跳过多个棋子（最后点击**完成回合**以完成所有回合的移动）。
- en: Once the player taps **Finish Turn!**, the system removes any jumped pieces,
    removes all decorations for the move, and stores the move in the `previousMove`
    variable.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦玩家点击**Finish Turn!**，系统将移除任何跳过的棋子，移除所有关于这次走法的装饰，并将走法存储在`previousMove`变量中。
- en: We will begin our trip through the game logic at the most logical place, the
    function that fires when the user clicks on the **Start Turn** button.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从游戏逻辑中最合理的地方开始我们的旅程，即当用户点击**Start Turn**按钮时触发的函数。
- en: Starting a turn
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始回合
- en: 'Our **Start Turn** button actually has two functions that it handles, starting
    and finishing the turn. This means that we will switch functionality based on
    the current status (text) of the button. In the controller, this button is referred
    to as `mainBtn` and the tap function looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**Start Turn**按钮实际上处理了两个功能，即开始和结束回合。这意味着我们将根据按钮的当前状态（文本）切换功能。在控制器中，这个按钮被称为`mainBtn`，点击函数看起来像这样：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We start by grabbing our `currentTurn` variable using `this.getCurrentTurn()`.
    If the game has just started, the turn belongs to black. The rest of our values
    will be empty or false at this point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用`this.getCurrentTurn()`来获取我们的`currentTurn`变量。如果游戏刚刚开始，回合属于黑方。此时，我们其他的所有值都将为空或为假。
- en: We then check to see what the text value of the button is, so that we can determine
    what to do next. If the text is `Start Turn`, we need to change the text of the
    button to `Finish Turn!`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后检查按钮的文本值，以便我们可以确定下一步要做什么。如果文本是`Start Turn`，我们需要将按钮的文本更改为`Finish Turn!`。
- en: Our other button (`altBtn`) also changes its text based on the status of the
    current turn. If we are starting a new turn, `altBtn` will be set to `Clear Move`.
    This will allow the player to clear the move if they change their mind before
    finishing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的其他按钮（`altBtn`）也会根据当前回合的状态改变其文本。如果我们正在开始一个新的回合，`altBtn`将被设置为`Clear Move`。这将允许玩家在完成之前改变主意时清除走法。
- en: Next, we update our `turn` value for `started` to `true`. This lets us know
    that the current move has begun. We use the function called `clearTurn()` to clear
    out any old turn data and remove any previous selections from the board. We then
    inform the current player that it is their turn.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`turn`的`started`值更新为`true`。这让我们知道当前走法已经开始。我们使用名为`clearTurn()`的函数清除任何旧的回合数据并从棋盘上移除任何先前的选择。然后我们通知当前玩家现在是他们的回合。
- en: If the text of the button is set to `Finish Turn!`, the button will commit the
    selected move(s) for the current turn using another sub function called `commitTurn()`.
    We then change the current player, clear out the turn data, and reset the text
    for our two buttons. We'll come back to finishing a turn a bit later, but first
    we need to see what happens once the turn begins.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮的文本设置为`Finish Turn!`，按钮将使用另一个名为`commitTurn()`的子函数提交当前回合所选的走法。然后我们更改当前玩家，清除回合数据，并重置两个按钮的文本。我们稍后会回到结束回合的话题，但首先我们需要看看回合开始后会发生什么。
- en: Checking the turn
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查回合
- en: Once the turn has started, the user taps on the DataView to move a piece. We
    then need to make sure that each selection they make is valid. We do this by listening
    to the DataView's `select` event with a function called `doSelect()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回合开始，用户会点击DataView来移动棋子。然后我们需要确保他们所做的每个选择都是有效的。我们通过使用名为`doSelect()`的函数监听DataView的`select`事件来实现这一点。
- en: 'The first thing we want to make sure of is that the user has selected a valid
    piece, so the first thing we do is get the current turn:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要确保用户已经选择了一个有效的棋子，所以我们首先获取当前回合：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we have a few moves we know are illegal, in which case we can return
    false to prevent the player from selecting this moves:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一些已知的非法走法，在这种情况下，我们可以返回false来防止玩家选择这些走法：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This prevents the user from moving before the turn starts or after it has ended.
    We also don''t want the user to select any or the light squares on the board:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了用户在回合开始之前或结束之后移动。我们也不希望用户选择棋盘上的任何或亮色的方格：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the obvious illegal moves out of the way, we start checking for allowed
    moves, starting with this one:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在将明显的非法走法排除之后，我们开始检查允许的走法，从这一步开始：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This checks that we are at the beginning of a turn (`turn.moves.length == 0`)
    and the player has not clicked one of his or her opponent's pieces. If so, we
    return false to prevent the selection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查我们是否处于回合的开始（`turn.moves.length == 0`）以及玩家是否没有点击他或她的对手的棋子。如果是这样，我们返回false来防止选择。
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we are at the beginning of a move and the user has clicked the correct piece,
    we add the record onto the beginning of our `moves` array.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在移动的开始处，并且用户点击了正确的棋子，我们将记录添加到我们的`moves`数组的开始处。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We store `moves` in reverse order so that the first move in the list is the
    last move made. This is because it makes it much easier to grab the first element
    in the array (which will always be `turns.moves[0]`), than it is to count the
    array elements to grab the one on the end of the array.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相反的顺序存储`moves`，这样列表中的第一个移动就是最后一步移动。这是因为从数组中获取第一个元素（始终是`turns.moves[0]`）比计算数组元素以获取数组末尾的元素要容易得多。
- en: We then set the current turn with our new information and return true, so that
    the selection event fires and the square the piece is in highlights.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用新的信息设置当前回合并返回true，这样选择事件就会触发，并且棋子所在的方格会高亮显示。
- en: 'If this is not the first move (`turn.moves.length` is greater than zero), it
    means the user has previously selected a piece and is now selecting a square for
    the piece to move into. If this is the case, we move on to the next `else` statement,
    which checks to see if the move is legal under our game rules:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不是第一次移动（`turn.moves.length`大于零），这意味着用户之前已经选择了一个棋子，现在正在选择一个方格来移动棋子。如果是这种情况，我们继续到下一个`else`语句，该语句检查在游戏规则下移动是否合法：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the move is legal, we also check `isKingable()` to see if the player has
    reached the opposite side of the board. If the move is legal, we set the turn
    appropriately and add the arrows for the move using the `decorateCurrentTurn()`
    function. We will take a closer look at how the `decorateCurrentTurn()` function
    works a little later, but first we want to cover the logic behind the `isLegalMove()`
    function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移动是合法的，我们还会检查`isKingable()`以查看玩家是否到达了棋盘的另一侧。如果移动是合法的，我们将适当地设置回合并使用`decorateCurrentTurn()`函数添加移动的箭头。我们稍后会更详细地了解`decorateCurrentTurn()`函数的工作原理，但首先我们想要介绍`isLegalMove()`函数背后的逻辑。
- en: Checking if a move is legal
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查一个移动是否合法
- en: The `isLegalMove()` function is called when the user has selected a valid piece
    and is attempting to move it to a new square. The move isn't actually committed
    in this function, we are just checking to see if the square the player taps is
    a valid move. If it is, we allow the DataView's `select` event to fire by returning
    true.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择了一个有效的棋子并尝试将其移动到新的方格时，会调用`isLegalMove()`函数。在这个函数中，移动实际上并没有被提交，我们只是检查玩家点击的方格是否是一个有效的移动。如果是，我们通过返回true允许DataView的`select`事件触发。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for this application includes extensive console logs inside
    this function. These will print out information to the console in Safari or Chrome
    and should help when trying to follow the logic inside this function. Try clicking
    on valid and invalid moves while looking at the console to see which pieces of
    the function are responding, and how the move is validated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的源代码在此函数中包含大量的控制台日志。这些日志将在Safari或Chrome中打印到控制台，并有助于跟踪此函数中的逻辑。尝试在查看控制台的同时点击有效和无效的移动，以查看哪些函数部分正在响应，以及如何验证移动。
- en: 'To make this determination, we follow the basic rules for checkers and examine
    the move with the following criteria:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出这个判断，我们遵循跳棋的基本规则，并使用以下标准检查移动：
- en: The destination square cannot be occupied
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标方格不能被占据
- en: The move must be in the correct direction (regular pieces can only move forward)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动必须在正确的方向上（普通棋子只能向前移动）
- en: The move can be one square away from the current position
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动可以距离当前位置一个方格
- en: The move can be two squares away from the current position, *if* there is an
    opponent's piece in between the two squares
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动可以距离当前位置两个方格，*前提是两个方格之间有一个对手的棋子
- en: Since this is a rather large function, we will cover it in several parts, starting
    with the overall skeleton and filling in the details as we go.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相当大的函数，我们将分几个部分来介绍，从整体框架开始，然后逐步填充细节。
- en: 'We start our function by passing it values for our `from` and `to` locations
    for the move. We then grab the current turn and set some variables for later use:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始我们的函数，通过传递`from`和`to`位置的值来移动。然后我们获取当前回合并设置一些后续使用的变量：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing we check is if the destination square is occupied using `to.get('occupiedBy')`.
    If the square is clear this variable should be `none` and if it is occupied, it
    will be either `red` or `black`. If we get back `red` or `black`, we immediately
    return false which will exit our `isLegalMove()` function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查目标方格是否被占用，使用`to.get('occupiedBy')`。如果方格是空的，这个变量应该是`none`，如果它被占用，它将是`red`或`black`。如果我们得到`red`或`black`，我们立即返回false，这将退出我们的`isLegalMove()`函数。
- en: Next, we use the `split` function to take our values for `to` and `from`, and
    split them into an array. Since we `split` on `''`, it assigns the letter (A-H)
    to the first element of the array (`fromID[0]` and `toID[0]`) and assigns the
    number (1-8) to the second element of the array (`fromID[1]` and `toID[1]`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`split`函数来获取`to`和`from`的值，并将它们拆分成一个数组。由于我们在`''`上拆分，它将字母（A-H）分配给数组的第一个元素（`fromID[0]`和`toID[0]`），并将数字（1-8）分配给数组的第二个元素（`fromID[1]`和`toID[1]`）。
- en: We then use `Math.abs` to give us the distance between the two number values.
    `abs` is an absolute value, which ensures that we get back a positive number even
    if `fromID[1]` is greater than `toID[1]`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`Math.abs`来给出两个数值之间的距离。`abs`是绝对值，这确保了我们即使`fromID[1]`大于`toID[1]`也能得到一个正数。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that this distance is the row distance and not the actual
    number of squares between the start and the end of the move.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这个距离是行距离，而不是移动开始和结束之间的实际方格数。
- en: Next, we need to make sure our distance is one row (no jumping) or two rows
    (jumping). If it's neither, we return false and do not allow the move. These two
    sections are currently empty, so let's fill them out with some code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们的距离是一行（不跳跃）或两行（跳跃）。如果不是这两者之一，我们返回false，不允许移动。这两个部分目前是空的，所以让我们用一些代码来填充它们。
- en: 'As it turns out, these two options also have a few possibilities we need to
    account for. We will start off with a possible move of one row:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这两个选项也有一些我们需要考虑的可能性。我们将从一个可能的单行移动开始：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This checks our distance of one row and it also makes sure that the user does
    not jump a piece and then attempt to move a single row afterwards as part of the
    same move.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查了我们的一行距离，并确保用户不会跳跃一个棋子，然后作为同一移动的一部分尝试移动一行。
- en: 'Inside of this `if` statement, we need to check three possibilities:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`if`语句内部，我们需要检查三种可能性：
- en: Is the piece a king?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这件棋子是王吗？
- en: Is the piece red?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这件棋子是红色吗？
- en: Is the piece black?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这件棋子是黑色吗？
- en: 'These criteria determine which direction the piece can move and allow us to
    check if the move is valid. For the king we check the following condition:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标准决定了棋子可以移动的方向，并允许我们检查移动是否有效。对于王，我们检查以下条件：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here we use our `nextLetter()` and `previousLetter()` functions as part of
    a check to see if the move is on the diagonal:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`nextLetter()`和`previousLetter()`函数作为检查移动是否在斜线上的部分：
- en: '![Checking if a move is legal](img/8901OS_10_04.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![检查移动是否合法](img/8901OS_10_04.jpg)'
- en: In the example above, a king located in the **2** row of the board can move
    to either the **1** row or the **3** row, in the **D** or **F** column. Since
    our previous `doSelect()` function already checked to make sure we did not select
    a light background, we know that these are all valid moves. This is true for a
    king of either color.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，位于棋盘**2**行的王可以移动到**1**行或**3**行，在**D**或**F**列。由于我们之前的`doSelect()`函数已经检查确保我们没有选择浅色背景，我们知道这些都是有效的移动。这对任何颜色的王都适用。
- en: We then call `setEndOfTurn()` and return true to fire the select function and
    select the square.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`setEndOfTurn()`并返回true以触发选择函数并选择方格。
- en: 'For regular red and black pieces, we need to make sure the move is in the correct
    direction. For red, this looks like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规的红色和黑色棋子，我们需要确保移动的方向是正确的。对于红色棋子，这看起来是这样的：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since our rows are numbered 1 - 8 from top to bottom and red moves from bottom
    to top, we need to make sure that the row number we are coming from is less than
    the row number we are going to (`toID[1] < fromID[1]`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的行是从上到下编号为1-8，红色从下往上移动，我们需要确保我们来的行号小于我们要去的行号（`toID[1] < fromID[1]`）。
- en: '![Checking if a move is legal](img/8901OS_10_05.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![检查移动是否合法](img/8901OS_10_05.jpg)'
- en: We also need to make sure we are going to the next or previous letter before
    calling `setEndOfTurn()` and returning true to select the square in the DataView.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保在调用`setEndOfTurn()`并返回true以选择DataView中的方格之前，我们将前往下一个或上一个字母。
- en: 'For the black pieces, we will be moving from top to bottom, so we need to make
    sure our destination row is greater than our starting row. This will close out
    our `if` statement for distances of one row (no jumping):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于黑色棋子，我们将从上到下移动，所以我们需要确保目标行大于起始行。这将关闭我们关于单行距离（无跳跃）的`if`语句：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As before, this checks our row letters to make sure we only move to the adjacent
    rows, calls `setEndOfTurn()` and returns true to select the square:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，这也检查我们的行字母，以确保我们只移动到相邻的行，调用`setEndOfTurn()`并返回true来选择方格：
- en: '![Checking if a move is legal](img/8901OS_10_06.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![检查移动是否合法](img/8901OS_10_06.jpg)'
- en: Now that we have our single row moves accounted for, we need to take a look
    at what happens when we try to move a distance of two rows.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经记录了单行移动，我们需要看看当我们尝试移动两行距离时会发生什么。
- en: 'From the user''s perspective, they will select a piece by tapping on it, and
    then select an empty square with an opponent''s piece in between the two squares.
    If additional jumps are available, the play will tap those squares as well before
    clicking on the **Finish Move** button:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的视角来看，他们将通过点击选择一个棋子，然后选择一个空方格，其中有一个对手的棋子位于两个方格之间。如果还有其他跳跃可用，玩家在点击**完成移动**按钮之前也会点击这些方格：
- en: '![Checking if a move is legal](img/8901OS_10_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![检查移动是否合法](img/8901OS_10_07.jpg)'
- en: In this example, the player would tap the red king piece and then tap the three
    squares (shown here with check marks) before clicking on the **Finish Move** button.
    Let's take a look at how the code checks for this move.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，玩家会点击红色的国王棋子，然后点击三个方格（此处用勾号表示），最后点击**完成移动**按钮。让我们看看代码是如何检查这个移动的。
- en: 'This is where we fill out the second `if` statement inside of our `isValidMove()`
    function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们填充`isValidMove()`函数内部的第二个`if`语句的地方：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will check our row distance and grab the square located between the `from`
    and `to` locations using a `getIntermediateSquare()` function. In the preceding
    example, the move from **D5** to **B3** would grab **C4** as the intermediate
    square.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查我们的行距离，并使用`getIntermediateSquare()`函数获取位于`from`和`to`位置之间的正方形。在先前的例子中，从**D5**移动到**B3**会抓取**C4**作为中间正方形。
- en: Much like before, we will also need to check and see if the piece is black,
    red, or a king so we can make sure the jump is in the correct direction. However,
    there are a few new wrinkles to allow for.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们还需要检查棋子是黑色、红色还是国王，以确保跳跃方向正确。然而，还有一些新的细节需要考虑。
- en: First, we have to make sure that there is an opposing piece in between the `from`
    and `to` locations. Second, we need to allow for multiple jumps.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须确保在`from`和`to`位置之间有一个对手的棋子。其次，我们需要允许多次跳跃。
- en: If you remember back at the top of our controller, we had two variables for
    `currentTurn` and `previousTurn`. Inside of these were empty arrays for `moves`
    and `removedPieces`. We will use these arrays to store the multiple jumps.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得在控制器的顶部，我们有两个变量`currentTurn`和`previousTurn`。在这些变量内部，我们有空数组`moves`和`removedPieces`。我们将使用这些数组来存储多次跳跃。
- en: 'For the king pieces, we open up a new `if` statement, right below where we
    grabbed the intermediate square:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于国王棋子，我们在抓取中间方格的下方打开一个新的`if`语句：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once we know that we have a `King` piece, we don't need to check for the direction
    of the jump, we just need to make sure that the `intermediate` piece is the opposite
    color from the piece that is moving (our `occupiedBy` piece). Once we have determined
    this is a valid king jump, we use `unshift` to add the move onto the beginning
    of our array of moves.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道我们有一个`King`棋子，我们不需要检查跳跃方向，我们只需要确保`intermediate`棋子与移动的棋子（我们的`occupiedBy`棋子）颜色相反。一旦我们确定这是一个有效的国王跳跃，我们使用`unshift`将移动添加到我们的移动数组开头。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember we need to add things to the beginning of the `moves` array, so we
    can quickly access the most recent of these moves later on by using `moves[0]`
    in our other functions. This is necessary for placing the arrow decorations correctly
    (as we will see later on). It is less critical for our `removedPieces` array,
    which places the negation symbol directly over the piece. So for `removedPieces`,
    we use the `push()` function instead.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们需要将东西添加到`moves`数组的开头，这样我们就可以通过在其他函数中使用`moves[0]`来快速访问这些移动中的最新移动。这对于放置箭头装饰（我们稍后将看到）是必要的。对于放置否定符号直接在棋子上的`removedPieces`数组来说，这不太重要。因此，对于`removedPieces`，我们使用`push()`函数。
- en: We also add the `intermediate` location to our `removedPieces` array and set
    `hasJumped` to `true`. This lets us know that there are potentially more moves
    to be executed. Finally, we use `setCurrentTurn()` to record the location the
    user selected and return true to select the square in the DataView.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `intermediate` 位置添加到我们的 `removedPieces` 数组中，并将 `hasJumped` 设置为 `true`。这让我们知道可能还有更多需要执行的移动。最后，我们使用
    `setCurrentTurn()` 记录用户选择的位置，并返回 `true` 以在 DataView 中选择该方格。
- en: 'For moving a red piece, we run a check to see if the piece is jumping forward
    by checking to make sure that `toID[1] < fromID[1]`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动红色棋子，我们运行一个检查，以确保棋子是向前跳跃的，这需要确保 `toID[1] < fromID[1]`：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We also check to see if the piece that was jumped is black. The rest of the
    code follows the same pattern as the code for the king jump.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查被跳过的棋子是否是黑色的。其余的代码遵循国王跳跃代码相同的模式。
- en: 'We add the same basic code block to check the jump for a black piece:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加相同的代码块来检查黑色棋子的跳跃：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, we check our direction using `toID[1] > fromID[1]`, and check our intermediate
    square for a red piece. The rest of the code follows the same pattern as the code
    for both the red and the king jumps.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用 `toID[1] > fromID[1]` 来检查我们的方向，并检查中间方格是否有红色棋子。其余的代码遵循红色和国王跳跃代码相同的模式。
- en: At the bottom of our `isValidMove()` function, after all the `if` statements,
    we close out the function with `return false`. This covers us when the user does
    something totally outside of our set of `if…then` rules.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `isValidMove()` 函数的底部，在所有 `if` 语句之后，我们使用 `return false` 结束函数。这涵盖了当用户做了完全超出我们
    `if…then` 规则范围的事情时的情况。
- en: Once we have determined if the move is valid, we need to add the correct classes
    to our game board to let the user know they have chosen a valid move, and what
    will happen when the move is finished.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定移动是否有效，我们需要向我们的游戏棋盘添加正确的类，以便用户知道他们选择了一个有效的移动，以及移动完成后会发生什么。
- en: Decorating the move
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰移动
- en: Once the user has started a turn and clicked on a square, there needs to be
    some indication that a valid move was selected. This happens as part of the `doSelect()`
    function and it happens in two different ways.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户开始一个回合并点击一个方格，就需要有一些指示来表明已选择了一个有效的移动。这作为 `doSelect()` 函数的一部分发生，并且以两种不同的方式发生。
- en: The first way is that when we validate the selected move, we return either `true`
    or `false`. When we return `true`, that DataView fires the `select` event and
    the selected square is highlighted (this is the default behavior for a DataView).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方式是，当我们验证所选移动时，我们返回 `true` 或 `false`。当我们返回 `true` 时，DataView 触发 `select`
    事件，所选方格被高亮显示（这是 DataView 的默认行为）。
- en: When we return `false`, we actually prevent the `select` event from firing and
    the square is not highlighted.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们返回 `false` 时，实际上阻止了 `select` 事件的发生，该方格不会被高亮显示。
- en: As we mentioned earlier in the chapter, the highlight color is controlled with
    CSS styles and a class of `x-item-selected`. This class is automatically applied
    to any selected item in a DataView. We can use a similar methodology to add additional
    CSS decorations to our squares, which will give the user a better idea of what
    is happening in the game.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章前面提到的，高亮颜色由 CSS 样式和 `x-item-selected` 类控制。这个类会自动应用到 DataView 中的任何所选项。我们可以使用类似的方法为我们的方格添加额外的
    CSS 装饰，这将使用户更好地了解游戏中的情况。
- en: This happens in the `decorateCurrentTurn()` function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在 `decorateCurrentTurn()` 函数中。
- en: 'Earlier in the chapter we talked about our decoration classes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面我们讨论了我们的装饰类：
- en: '`up_left`: This suggests an arrow in the upper-left corner'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up_left`: 这表示一个指向左上角的箭头'
- en: '`up_right`: This suggests an arrow in the upper-right corner'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up_right`: 这表示一个指向右上角的箭头'
- en: '`down_left`: This suggests an arrow in the lower-left corner'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down_left`: 这表示一个指向左下角的箭头'
- en: '`down_right`: This suggests an arrow in the lower-right corner'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down_right`: 这表示一个指向右下角的箭头'
- en: '`removed`: This suggests a negation center in the middle of the square'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removed`: 这表示方格中间的否定中心'
- en: 'On the game board, they look like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏棋盘上，它们看起来是这样的：
- en: '![Decorating the move](img/8901OS_10_08.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![装饰移动](img/8901OS_10_08.jpg)'
- en: The `decorateTurn()` function will loop through our array of moves for a turn
    and apply the correct styles.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorateTurn()` 函数将遍历一个回合的移动数组并应用正确的样式。'
- en: 'We start by getting the `fromID` and `toID` values for the move and splitting
    it into an array with two elements: a number and a letter. Then we compare them
    to create a class name that corresponds to one of our four arrows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取移动的 `fromID` 和 `toID` 值，并将它们拆分为一个包含两个元素的数组：一个数字和一个字母。然后我们比较它们以创建一个与我们的四个箭头之一对应的类名：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For example, let''s assume we have a piece moving from **E4** to **D3**. If
    we split these values and check them in the preceding code, we would see that:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个棋子从 **E4** 移动到 **D3**。如果我们拆分这些值并在前面的代码中检查它们，我们会看到：
- en: 4 < 3 is false and we would set the value of `cls` to `up`
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 < 3 是错误的，我们会将 `cls` 的值设置为 `up`
- en: D < C is also false and we would add the text `_left` to our `cls` value
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D < C 也是错误的，我们会将文本 `_left` 添加到我们的 `cls` 值中
- en: This leaves us with a class of `up_left` applied to our square, and an arrow
    in the upper-left corner.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的方格应用了 `up_left` 类，并在左上角有一个箭头。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Comparing greater than / less than for text values in JavaScript compares the
    ASCII values for the letters. This is fine if you are comparing single letters,
    all with the same case, but it can become problematic in many cases. For example,
    "Z" < "a" is actually true in JavaScript, because all uppercase letters have a
    lower ASCII value than lowercase letters. In this case we are comparing a single
    uppercase letter to another single uppercase letter, which works just fine.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，比较文本值的大于/小于比较字母的 ASCII 值。如果你比较的是相同大小写的单个字母，这是可以的，但在许多情况下可能会出现问题。例如，"Z"
    < "a" 在 JavaScript 中实际上是正确的，因为所有大写字母的 ASCII 值都低于小写字母。在这种情况下，我们正在比较单个大写字母和另一个单个大写字母，这可以正常工作。
- en: Once we have set our arrow to indicate the direction using `from.set('decoration',
    cls);`, we need to account for any pieces to be removed. We handle this by looping
    through our `removedPieces` array that is part of our `turn` variable. We add
    `'removed'` to the class for all of the pieces in this array. The space in front
    of the string means that it will be added as an additional class on the square.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `from.set('decoration', cls);` 设置了箭头来指示方向，我们需要考虑任何要移除的棋子。我们通过遍历我们的 `turn`
    变量的一部分 `removedPieces` 数组来处理这个问题。我们为这个数组中的所有棋子添加 `'removed'` 到类中。字符串前面的空格意味着它将作为额外的类添加到方格上。
- en: This means the CSS class would be something like `"up_left removed"`, if the
    turn jumps over a piece that is up and to the left of its current location. Both
    styles would be applied to the square, giving it an upper-left arrow and a negation
    symbol.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 CSS 类将类似于 `"up_left removed"`，如果回合跳过一个位于当前位置上方和左方的棋子。这两种样式都会应用于该方格，给它一个上左箭头和一个否定符号。
- en: Once we have applied our styles for each move, we call `this.getBoard().refresh();`
    to refresh the board and make everything show up.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为每个移动应用了我们的样式，我们就调用 `this.getBoard().refresh();` 来刷新棋盘并显示所有内容。
- en: 'The beauty of creating a separate function for `decorateTurn()` is that we
    can use it to decorate the previous turn as well as the current one:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `decorateTurn()` 创建一个单独函数的美丽之处在于，我们可以用它来装饰上一个回合以及当前的回合：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function runs a check to see if we have a previous turn. If we do, we just
    pass it along to our decorate turn function and let it handle showing the appropriate
    decorations. If you were feeling particularly ambitious, you could store all the
    turns and replay every one of them by looping through and passing each turnoff
    to the `decorateTurn()` function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会检查我们是否有上一个回合。如果有，我们就将它传递给我们的装饰回合函数，让它处理显示适当的装饰。如果你特别雄心勃勃，你可以存储所有的回合并通过循环将每个回合传递给
    `decorateTurn()` 函数来重新播放每一个。
- en: However, before we get too ambitious, let's take a look at how we clear a move
    and its decorations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们过于雄心勃勃之前，让我们看看我们是如何清除移动及其装饰的。
- en: Clearing the move
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除移动
- en: 'When we clear a move, we need to accomplish two main things: clear the data
    out of our `currentTurn` variable and clear the decoration values out of our store.
    We split this into two separate functions to make things easier to update and
    maintain. The first function handles resetting the values for our `currentTurn`
    variable and then deselects everything on the board:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们清除一个移动时，我们需要完成两个主要任务：清除 `currentTurn` 变量中的数据，并清除存储中的装饰值。我们将此分为两个单独的函数，以便更容易更新和维护。第一个函数处理重置
    `currentTurn` 变量的值，然后在棋盘上取消选择所有内容：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The second function clears all of the decorations from the store. You might
    remember from previously in the chapter, the decorations are the arrows that indicate
    movement and the negation symbols used to designate a jumped piece. These are
    all applied as CSS styles to the squares in our DataView. When we clear the value
    for decoration on each square in the store, the DataView will automatically remove
    the arrows and symbols from the display.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数清除存储中的所有装饰。您可能还记得在本章之前，装饰是指示移动的箭头和用来指定跳过的棋子的否定符号。这些都是作为CSS样式应用到我们的DataView中的方块上。当我们清除存储中每个方块上的装饰值时，DataView将自动从显示中移除箭头和符号。
- en: Going beyond the finished game
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越完成的游戏
- en: Playing through the finished game can lead to some interesting ideas for modifications
    and improvements.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 玩过完成的游戏可以带来一些修改和改进的有趣想法。
- en: '![Going beyond the finished game](img/8901OS_10_09.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![超越完成的游戏](img/8901OS_10_09.jpg)'
- en: The squares could easily be adapted to the traditional hex grid used in most
    tabletop role-playing games.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方块可以很容易地适应大多数桌面角色扮演游戏中使用的传统六边形网格。
- en: '![Going beyond the finished game](img/8901OS_10_10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![超越完成的游戏](img/8901OS_10_10.jpg)'
- en: 'Even with a hex layout, the basic logic flow for the game still remains the
    same:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是六边形布局，游戏的基本逻辑流程仍然保持不变：
- en: The user selects a piece and we check if it is a valid selection
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户选择一个棋子，我们检查这个选择是否有效
- en: The user selects a destination and we check if the destination is valid
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户选择一个目的地，我们检查这个目的地是否有效
- en: If it is a valid move we provide visual feedback through CSS to tell the user
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这是一个有效的移动，我们通过CSS提供视觉反馈来告诉用户
- en: We determine the result of the move and remove or modify pieces as appropriate
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确定移动的结果，并适当地移除或修改棋子
- en: We check to see if the game has ended and if not, we repeat the process for
    the next player
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查游戏是否结束，如果没有，我们为下一位玩家重复这个过程
- en: The validation is also still a matter of math and some basic `if…then` logic.
    Granted, this logic can become much more complex, but the basic rules and game
    flow will remain the same.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 验证仍然是数学和一些基本的`if…then`逻辑的问题。诚然，这种逻辑可以变得更加复杂，但基本的规则和游戏流程将保持不变。
- en: Additionally, CSS transitions could be used to add a more visual appeal to the
    game play. A number of options can be found in the documentation at [http://docs.sencha.com/touch/2-0/#!/api/Ext.Anim](http://docs.sencha.com/touch/2-0/#!/api/Ext.Anim).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用CSS过渡来为游戏玩法添加更多的视觉吸引力。在[http://docs.sencha.com/touch/2-0/#!/api/Ext.Anim](http://docs.sencha.com/touch/2-0/#!/api/Ext.Anim)的文档中可以找到许多选项。
- en: These variations allow you to take a simple game model and truly make it your
    own.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化允许您将一个简单的游戏模型真正变成自己的。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter we covered the creation of a basic game of checkers:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了国际象棋基本游戏的创建：
- en: We built the basic game board
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建了基本的游戏板
- en: Explored the CSS and HTML structure to create our layout
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索了CSS和HTML结构以创建我们的布局
- en: We built the basic game controller and covered the game board logic
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建了基本的游戏控制器并覆盖了游戏板逻辑
- en: We showed you how to start, validate, decorate, and clear the moves on the board
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向您展示了如何开始、验证、装饰和清除板上的移动
- en: We also talked about some options for expanding the game and making it your
    own original idea
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还讨论了一些扩展游戏并使其成为您自己原创想法的选项
