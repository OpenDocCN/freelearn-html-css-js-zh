- en: Chapter 10. Building a Concurrent Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 构建并发应用程序
- en: We've now covered all the major areas that JavaScript has to offer in terms
    of concurrency. We've seen the browser and how the JavaScript interpreter fits
    into this environment. We've looked at the few language mechanisms that assist
    with writing concurrent code, and we've learned how to write concurrent JavaScript
    in the back-end. In this chapter, we're going to try and put this all together
    by building a simple chat application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了JavaScript在并发方面提供的主要领域。我们看到了浏览器以及JavaScript解释器如何适应这个环境。我们研究了帮助编写并发代码的少量语言机制，并学习了如何在后端编写并发JavaScript。在本章中，我们将通过构建一个简单的聊天应用程序来尝试将这些内容综合起来。
- en: It's worth noting upfront that this isn't a basic rehash of individual topics
    covered in earlier chapters, which would serve no real purpose. Instead, we're
    going to focus more on the concurrency decisions that we have to make during the
    initial implementation of the app, adapting earlier ideas learned in this book
    wherever appropriate. It's the design of concurrency semantics we put to use in
    our code that matters much more so than the actual mechanism that's used to do
    so.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这并不是对前面章节中涵盖的各个主题的基本重复，这没有任何实际意义。相反，我们将更多地关注在应用程序初始实施过程中必须做出的并发决策，并在适当的地方调整本书中学习到的早期想法。我们代码中使用的并发语义的设计比实际使用的机制更为重要。
- en: We'll start with a brief foray into the pre-implementation activities. Then,
    we'll look at the more detailed requirements of the application that we're building.
    Finally, we'll walk through the actual implementation, which is divided into two
    parts, the front-end and back-end.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实施前的简要探索开始。然后，我们将查看我们构建的应用程序更详细的需求。最后，我们将通过实际实施过程，这个过程分为前端和后端两部分。
- en: Getting started
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Looking at examples with code snippets is a good avenue for introducing a given
    topic. This is more or less what we've done so far throughout this book while
    going through concurrency in JavaScript. In the first chapter, we introduced a
    few concurrency principles. We should parallelize our code to take advantage of
    concurrent hardware. We should synchronize concurrent actions unobtrusively. We
    should conserve the CPU and memory by deferring computations and allocations wherever
    possible. Throughout the chapters, we've seen how these principles apply to different
    areas of JavaScript concurrency. They're also applicable in the first stages of
    development when we don't have an application or we're trying to fix an application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看带有代码片段的示例来介绍一个特定主题是一个很好的途径。这正是我们在本书中处理JavaScript并发时所做的大部分工作。在第一章中，我们介绍了一些并发原则。我们应该并行化我们的代码以利用并发硬件。我们应该无干扰地同步并发操作。我们应该通过尽可能推迟计算和分配来节省CPU和内存。在整个章节中，我们看到了这些原则如何应用于JavaScript并发的不同领域。它们也适用于开发初期，当我们没有应用程序或试图修复应用程序时。
- en: We'll start this section with another look at the idea that concurrency is the
    default mode. When concurrency is the default, everything is concurrent. We'll
    go over again, why this is such an important system trait. Then, we'll look at
    whether or not the same principles apply to applications that already exist. Lastly,
    we'll look at the types of applications we might be building, and how they influence
    our approach to concurrency.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个观点开始，即并发是默认模式。当并发是默认的，一切都是并发的。我们将再次探讨为什么这是一个如此重要的系统特性。然后，我们将看看这些原则是否适用于已经存在的应用程序。最后，我们将探讨我们可能构建的应用程序类型，以及它们如何影响我们对并发的处理方式。
- en: Concurrency first
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发优先
- en: As we're well aware by now, concurrency is difficult. No matter how we dress
    it up or how solid our abstractions are, it's simply counter-intuitive to how
    our brains work. This sounds impossible, doesn't it? This definitely isn't the
    case. As with any difficult problem, the right approach is almost always a variation
    of divide and conquer. In the case of JavaScript concurrency, we want to divide
    the problem into no more than a few really small, easy-to-solve problems. An easy
    way to do this is to heavily scrutinize potential concurrency issues before we
    actually sit down to write any code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，并发是困难的。无论我们如何粉饰它或我们的抽象多么稳固，它都与我们大脑的工作方式背道而驰。这听起来不可能，不是吗？这绝对不是事实。与任何困难问题一样，正确的做法几乎总是分而治之的变体。在JavaScript并发的情况下，我们希望将问题分解为不超过几个真正小、易于解决的问题。一个简单的方法是在我们真正坐下来编写任何代码之前，仔细审查潜在的并发问题。
- en: For example, let's say we work under the assumption that we're likely to encounter
    concurrency issues frequently, all throughout our code. This would mean that we'd
    have to spend a lot of time doing upfront concurrency design. Things like generators
    and promises make sense from the early stages of development, and they get us
    closer to our end goal. But other ideas, like functional programming, map/reduce,
    and web workers solve larger concurrency problems. Does this mean that we want
    to spend a lot of design time on issues like these that we have yet to actually
    experience in our application?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们基于这样的假设：我们很可能会在代码的各个阶段频繁遇到并发问题。这意味着我们可能需要花费大量时间进行前期并发设计。像生成器和承诺这样的概念在开发的早期阶段是有意义的，并且让我们更接近最终目标。但其他想法，如函数式编程、map/reduce和Web
    Workers，可以解决更大的并发问题。这难道意味着我们想在尚未真正在我们的应用程序中遇到的问题上花费大量设计时间吗？
- en: The other approach is to spend less time on upfront concurrency design. This
    is not to say that we ignore concurrency; that would defeat the whole premise
    of this book. Rather, we work under the assumptions that we don't yet have any
    concurrency issues, but there's a strong possibility that we will have them later
    on. Put differently, we continue to write code that's concurrent by default, without
    investing in solutions to concurrency problems that don't exist yet. The principles
    we've used throughout this book, again, help us solve the important problems first.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是减少在前期并发设计上的时间投入。这并不是说我们可以忽视并发；那样做会违背本书的整个前提。相反，我们基于这样的假设：我们目前还没有任何并发问题，但将来很可能会有。换一种说法，我们继续编写默认并发的代码，而不投资于尚未存在的并发问题解决方案。本书中一直使用的原则，再次帮助我们首先解决重要问题。
- en: For instance, we want to parallelize our code where we can get the most out
    of multiple CPUs on the system. Thinking about this principle forces the question—do
    we really care about leveraging eight CPUs for something that's easily handled
    by one? With little effort, we can build our application in such a way that we
    don't end up paralyzing ourselves by bikeshedding on concurrency issues that aren't
    real. Think about how to facilitate concurrency in the early stages in development.
    Think, how does this implementation make future concurrency issues difficult to
    deal with, and what's a better approach? Later in the chapter, our demo application
    will aim to implement code in this fashion.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们希望在可能的情况下并行化我们的代码，以便充分利用系统上的多个CPU。思考这个原则迫使提出问题——我们真的关心利用八个CPU来处理一个一个CPU就能轻松处理的事情吗？只需一点努力，我们就可以以这种方式构建我们的应用程序，这样我们就不会因为对不真实的并发问题进行无谓的争论而使自己瘫痪。想想如何在开发的早期阶段促进并发。想想，这种实现如何使未来的并发问题难以处理，什么是一个更好的方法？在本章的后面部分，我们的演示应用程序将致力于以这种方式实现代码。
- en: Retrofitting concurrency
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发改造
- en: Given that it's ill-advised to spend much time upfront thinking about concurrency
    issues, how do we go about fixing these issues once they happen? In some circumstances,
    the issues can be serious problems that render the interface unusable. For example,
    if we try to process a large amount of data, we could crash the browser tab by
    trying to allocate too much memory, or the UI could simply freeze. These are tough
    problems that require immediate attention, and they often don't come with the
    luxury of time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 既然在前期过多思考并发问题是不明智的，那么一旦这些问题发生，我们该如何着手解决它们呢？在某些情况下，这些问题可能是严重的问题，以至于使接口无法使用。例如，如果我们尝试处理大量数据，我们可能会通过尝试分配过多的内存来使浏览器标签崩溃，或者UI可能会简单地冻结。这些都是需要立即关注的问题，而且通常没有时间上的奢侈。
- en: The other circumstance that we're likely to find ourselves in is less-critical
    cases, where a concurrent implementation could objectively improve the user experience,
    but the application isn't going to fail if we don't fix it right away. For example,
    let's say that our application makes three API calls on the initial page load.
    Each call waits for the previous call to complete. But, it turns out that there's
    no actual dependency between the calls; they don't require response data from
    each other. Fixing these calls so that they all happen in parallel is relatively
    low-risk and improves the load time, possibly by more than a second.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到的另一种情况是，在不太关键的情况下，并发实现可以从客观上改善用户体验，但如果我们不立即修复它，应用程序也不会失败。例如，假设我们的应用程序在初始页面加载时进行了三次API调用。每次调用都等待前一个调用完成。但，实际上这些调用之间没有实际的依赖关系；它们不需要从彼此那里获取响应数据。将这些调用修复为并行执行相对风险较低，并且可以提高加载时间，可能超过一秒。
- en: The ultimate deciding factor on how easy or difficult these changes are to retrofit
    into our application depends on how the application was written. As mentioned
    in the preceding section, we don't want to spend a lot of time thinking about
    concurrency problems that don't exist. Instead, our initial focus should be on
    facilitating concurrency by default. So, when these circumstances arise, and we
    need to implement a concurrent solution that solves a tangible problem, it's not
    so difficult. We're already thinking concurrently because that's the way the code
    was written.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改如何容易或困难地重构到我们的应用程序中，最终取决于应用程序的编写方式。正如前文所述，我们不想花太多时间去思考那些不存在的并发问题。相反，我们的初始重点应该是默认促进并发。因此，当这些情况出现，我们需要实现一个解决实际问题的并发解决方案时，这并不困难。因为我们已经是在以代码编写的方式思考并发了。
- en: We're just as likely to find ourselves fixing an application that paid no mind
    to concurrency. These are trickier to handle when trying to fix issues that call
    for a concurrent solution. We'll often find that we need to refactor a lot of
    code just to fix something basic. This gets tough when we're under-the-gun time-wise,
    but generally-speaking, this can be a good thing. If a legacy application starts
    getting refactored for better concurrency facilitation one piece at a time, then
    we're better off. This just makes the next concurrency issue easier to fix, and
    it promotes a good style of coding—concurrency by default.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可能会遇到一个没有考虑并发性的应用程序。在尝试修复需要并发解决方案的问题时，这些情况处理起来会更复杂。我们经常会发现，我们只需要对大量代码进行重构才能修复一些基本问题。当我们在时间紧迫的情况下，这会变得很困难，但一般来说，这可以是一件好事。如果一个遗留应用程序开始逐个重构以更好地促进并发，那么我们会更好。这仅仅使得下一个并发问题更容易解决，并且促进了良好的编码风格——默认并发。
- en: Application types
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序类型
- en: One thing you can and should pay close attention to during the initial phases
    of implementation is the type of application that we're building. There's no generic
    approach to writing code that facilitates concurrency. The reason for this is
    that every application is concurrent in its own unique way. There's obviously
    some overlap between concurrency scenarios, but in general, it's a good bet that
    our application is going to require its own special treatment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施初期阶段，我们需要密切关注的是我们正在构建的应用程序类型。没有通用的编写代码以促进并发的途径。这是因为每个应用程序都以自己独特的方式并发。显然，并发场景之间存在一些重叠，但一般来说，我们可以肯定我们的应用程序将需要自己的特殊处理。
- en: For example, does it make sense to devote a lot of time and effort to designing
    abstractions around web workers? It wouldn't make sense to think about making
    API responses promised values if our application hardly makes any web requests
    at all. Finally, do we really want to think about inter-process communication
    design in our Node components if we don't have a high request/connectivity rate?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，花大量时间和精力去设计围绕Web Workers的抽象是否合理？如果我们应用程序几乎不做任何Web请求，去考虑实现API响应的承诺值就没有意义。最后，如果我们没有高请求/连接率，我们真的想要在我们的Node组件中考虑进程间通信的设计吗？
- en: The trick isn't to ignore these lower-priority items, because as soon as we
    ignore some dimension of concurrency in our application, next week is when everything
    changes, and we'll be completely unprepared to handle the situation. Instead of
    completely ignoring these dimensions of our application in a concurrency context,
    we need to optimize for the common case. The most effective way to do this is
    to profoundly think about the nature of our application. By doing this, we can
    easily spot the best candidate problems to work on in our code as far as concurrency
    is concerned.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧不是忽略这些低优先级的项目，因为一旦我们忽略了应用程序中并发的一些维度，下周一切都会改变，我们将完全无法准备应对这种情况。相反，我们不应该在并发环境中完全忽略这些应用程序维度，我们需要针对常见情况进行优化。最有效的方法是深入思考我们应用程序的本质。通过这样做，我们可以轻松地找到在并发方面我们代码中要解决的最佳候选问题。
- en: Requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: Now it's time to turn our attention to actually building a concurrent application.
    In this section, we'll go through a brief overview of the chat application that
    we're going to build, starting with the overall goal of the application. Then,
    we'll break down the other requirements into the "API" and the "UI". We'll drive
    into some code momentarily, don't worry.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的注意力转向实际构建一个并发应用程序了。在本节中，我们将简要概述我们将要构建的聊天应用程序，从应用程序的总体目标开始。然后，我们将其他要求分解为“API”和“UI”。我们很快就会进入一些代码，请放心。
- en: The overall goal
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总体目标
- en: First things first, why yet another chat application? Well, for two reasons;
    first, it's not a real application, and we're not building it for the sake of
    reinventing the wheel; we're building it to learn about concurrent JavaScript
    in the context of an application. Second, a chat application has a lot of moving
    parts that help you demonstrate some of the concurrency mechanisms that you've
    learned about in this book. That being said, it will be a very simply chat application—we
    only have so much space in a chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么还要另一个聊天应用程序？好吧，有两个原因；首先，它不是一个真正的应用程序，我们不是为了重新发明轮子而构建它；我们是为了在应用程序的背景下学习并发JavaScript而构建它。其次，聊天应用程序有很多动态部分，可以帮助你展示你在本书中学到的某些并发机制。话虽如此，这将是一个非常简单的聊天应用程序——我们在一章中只有这么多的空间。
- en: The chat concept that we'll implement is the same as with most other familiar
    chat applications out there. There's the chat itself, labeled with a topic, and
    there are the users and messages within. We'll implement these and not much else.
    Even the UI itself will be a stripped-down version of a typical chat window. Again,
    this is an effort to keep the code samples down to what's pertinent in a concurrency
    context.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的聊天概念与大多数其他熟悉的聊天应用程序相同。有聊天本身，带有主题标签，还有用户和消息。我们将实现这些，而不会做太多其他的事情。甚至UI本身也将是一个典型的聊天窗口的简化版本。再次强调，这是为了将代码示例保持在并发环境中的相关内容。
- en: To further simplify things, we won't actually persist the chats to disk; we'll
    just hold everything in memory. This way, we can keep our focus on other concurrency
    issues in the app, and it's easy to run without setting up storage or dealing
    with disk space. We'll also skip on the other common features of chats, such as
    typing notifications, emoji, etc. They're just not relevant to what we're trying
    to learn here. Even with all these functions removed, we'll see how involved concurrency
    design and implementation can get; larger projects are all the more challenging.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步简化事情，我们实际上不会将聊天持久化到磁盘；我们只是在内存中保留一切。这样，我们可以将注意力集中在应用程序中的其他并发问题上，而且很容易运行而无需设置存储或处理磁盘空间。我们还将跳过聊天的一些其他常见功能，如打字通知、表情符号等。它们与我们试图学习的内容无关。即使移除了所有这些功能，我们也会看到并发设计和实现可以变得多么复杂；更大的项目更具挑战性。
- en: Finally, instead of using authentication, this chat app will serve more of a
    transient usage scenario, where users want to throw up a quick chat that doesn't
    require registration. So, the chat creator will create a chat, and this creates
    a unique URL that can be shared with participants.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，而不是使用身份验证，这个聊天应用程序将更多地服务于短暂的用途场景，其中用户想要快速创建一个不需要注册的聊天。因此，聊天创建者将创建一个聊天，这将创建一个可以与参与者共享的唯一URL。
- en: The API
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API
- en: The API for our chat app will be implemented using a simple Node HTTP server.
    It doesn't use any web frameworks, only a couple small libraries. There's no reason
    for this other than the application is simple enough that using a framework doesn't
    enhance the examples in this chapter in any way. In the real world, by all means,
    use a Node web framework that simplifies your code—the lessons from this book—including
    this chapter—are still applicable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用API将使用简单的Node HTTP服务器实现。它不使用任何Web框架，只使用几个小型库。这样做没有其他原因，只是因为应用程序足够简单，使用框架不会以任何方式增强本章的示例。在现实世界中，无论如何，请使用简化你代码的Node
    Web框架——本书的教训——包括本章——仍然适用。
- en: 'The responses will be JSON strings of our chat data. Only the most basic API
    endpoints that are fundamental to the application will be implemented. Here''s
    what we need in terms of API endpoints:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将是我们的聊天数据的JSON字符串。只有对应用程序基本功能至关重要的最基本API端点将被实现。以下是API端点所需的内容：
- en: Create a new chat
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的聊天
- en: Join an existing chat
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加入现有聊天
- en: Post a new message to an existing chat
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有聊天中发布一条新消息
- en: Fetch an existing chat
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取现有聊天
- en: Pretty simple, right? It's deceptively simple. Since there are no filtering
    capabilities, this needs to be handled in the front-end. This is on purpose; an
    API that's missing features is common, and a concurrent solution in the front-end
    is the likely outcome. We'll revisit this topic again when we start building the
    UI.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？这看似简单。由于没有过滤功能，这需要在前端处理。这是故意的；缺少功能的API很常见，前端的一个并发解决方案可能是结果。当我们开始构建UI时，我们将再次讨论这个话题。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The NodeJS code implemented for this sample application also includes handlers
    for serving static files. This is really a convenience measure more than a reflection
    on what should be happening in production. It's more important that you be able
    to easily run this application and play around with it, than replicate how static
    files are served in a production environment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为此示例应用程序实现的NodeJS代码还包括用于提供静态文件的处理器。这实际上更多的是一种便利措施，而不是反映生产环境中应该发生的事情。你能够轻松运行此应用程序并与之互动比复制生产环境中静态文件的服务方式更重要。
- en: The UI
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'The user interface of our chat application will consist of a single HTML file
    and some accompanying JavaScript code. There are three pages within the HTML document—just
    simple `div` elements, and they are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用的用户界面将仅由一个HTML文件和一些辅助的JavaScript代码组成。HTML文档中包含三个页面——只是简单的`div`元素，具体如下：
- en: '**Create chat**: user provides a topic and their name.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建聊天**：用户提供主题和他们的名字。'
- en: '**Join chat**: user provides their name and is redirected to the chat.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加入聊天**：用户提供他们的名字并被重定向到聊天。'
- en: '**View chat**: user can view chat messages and send new messages.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看聊天**：用户可以查看聊天消息并发送新消息。'
- en: The role of these pages is fairly self-explanatory. The most complex page is
    view chat, and even this isn't too bad. It displays a list of all messages sent
    from any participant, including ourselves, along with the list of users. We'll
    have to implement a polling mechanism to keep the content of this page synchronized
    with chat data. Style-wise, we're not doing much beyond some very basic layout
    and font adjustments.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些页面的作用相当直观。最复杂的页面是查看聊天，但这并不太难。它显示来自任何参与者的所有消息列表，包括我们自己，以及用户列表。我们将必须实现一个轮询机制，以保持此页面的内容与聊天数据同步。在样式方面，我们不会做太多，只是做一些非常基本的布局和字体调整。
- en: Lastly, since users are likely to join chats frequently, they're transient and
    ad-hoc in nature. After all, it'd be nice if we didn't always have to enter our
    user name every time we create or join a chat. We'll add functionality that keeps
    the name of the user in browser local storage.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于用户可能会频繁加入聊天，它们是短暂的、临时的。毕竟，如果我们每次创建或加入聊天时都不必总是输入我们的用户名，那就太好了。我们将添加一个功能，以保持用户名在浏览器本地存储中。
- en: Alright, time to write some code, ready?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是时候写一些代码了，准备好了吗？
- en: Building the API
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API
- en: We'll begin the implementation with the NodeJS back-end. This is where we'll
    build the necessary API endpoints. We don't necessarily have to start with building
    the back-end first. In fact, a lot of the time, the UI design drives the API design.
    Different development shops have different approaches; we're doing the back-end
    first for no particular reason.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从NodeJS后端开始实施。这是我们构建必要API端点的地方。我们并不一定必须首先构建后端。实际上，很多时候，UI设计驱动API设计。不同的开发机构有不同的方法；我们之所以首先做后端，没有特别的原因。
- en: We'll start by implementing the basic HTTP serving and request routing mechanisms.
    Then, we'll look at using coroutines as handler functions. We'll wrap up the section
    with a look at how each of our handler functions are implemented.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现基本的 HTTP 服务和请求路由机制。然后，我们将探讨使用协程作为处理函数。我们将通过查看每个处理函数的实现来结束本节。
- en: The HTTP server and routing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 服务器和路由
- en: We're not going to use anything more than the core `http` Node module for handling
    HTTP requests. In a real application, where we're more likely to use a web framework
    that takes care of a lot of boilerplate code for us, we would probably have a
    router component at our disposal. Our requirements are very similar to what we'd
    find in these routers, so we'll just roll our own here for the sake of simplicity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用比核心的 `http` 节点模块更多的东西来处理 HTTP 请求。在实际应用中，我们更有可能使用一个负责为我们处理大量模板代码的 Web 框架，那么我们可能会有一个可用的路由组件。我们的需求与这些路由器中找到的需求非常相似，所以为了简单起见，我们在这里自己实现。
- en: 'We''ll use the `commander` library for parsing command line options but this
    is actually not so straightforward to do. The library is tiny and introducing
    it early on in our project just means it''s easier to add new configuration options
    to our server. Let''s look at a diagram that shows how our main program fits into
    the environment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `commander` 库来解析命令行选项，但这实际上并不那么简单。这个库很小，在我们项目的早期引入它只是为了更容易地添加新的配置选项到我们的服务器。让我们看看一个图表，展示我们的主程序如何适应环境：
- en: '![The HTTP server and routing](img/B05133_10_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP 服务器和路由](img/B05133_10_01.jpg)'
- en: 'The job of our main module is to launch the HTTP server and set up a handler
    function that does the routing. The routes themselves are a static mapping of
    regular expression to handler function. As we can see, the handler functions are
    stored in a separate module. So let''s take a look at our main program now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主模块的职责是启动 HTTP 服务器并设置一个处理路由的处理函数。路由本身是正则表达式到处理函数的静态映射。正如我们所见，处理函数存储在单独的模块中。那么现在让我们看看我们的主程序：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the extent of our handler routing mechanism. We have all our routes
    defined in the `routes` variable, and as our application changes over time, this
    is where the route changes happen. We can also see that getting options from the
    command line using `commander` is pretty straightforward. Adding new options here
    is easy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的处理路由机制的范围。我们所有的路由都定义在 `routes` 变量中，随着我们的应用程序随时间变化，这里的路由变化也会发生。我们还可以看到，使用
    `commander` 从命令行获取选项相当简单。在这里添加新选项也很容易。
- en: The request handler function that we've given to our HTTP server will probably
    never need to change, because it doesn't actually fulfill any requests. All it
    does is iterate over the routes until the route regular expression matches the
    request URL. When this happens, the request is handed off to the handler function.
    So, let's turn our attention to the actual handler implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 HTTP 服务器提供的请求处理函数可能永远不会需要改变，因为它实际上并不满足任何请求。它所做的只是遍历路由，直到路由正则表达式与请求 URL 匹配。当这种情况发生时，请求被传递给处理函数。所以，让我们把注意力转向实际的处理函数实现。
- en: Co-routines as handlers
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程作为处理函数
- en: As we saw in earlier chapters of this book, it doesn't take much to introduce
    callback hell in our front-end JavaScript code. This is where promises come in
    handy, because they allow us to encapsulate nasty synchronization semantics. The
    result is clean and readable code in our components, where we try to implement
    product features. Do we have the same problem with Node HTTP request handlers?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的前几章中看到的，在我们的前端 JavaScript 代码中引入回调地狱并不需要太多。这正是承诺派上用场的地方，因为它们允许我们封装讨厌的同步语义。结果是，在我们的组件中，我们尝试实现产品功能时，代码既干净又易于阅读。我们是否在
    Node HTTP 请求处理函数中也遇到了同样的问题？
- en: In simpler handlers, no, we don't face this challenge. All we have to do is
    look at the request, figure out what to do about it, do it, and then update the
    response before sending it. In more complex scenarios, we have to do all kinds
    of asynchronous activities within our request handler before we're able to respond.
    In other words, callback hell is inevitable if we're not careful. For example,
    our handler might reach out to other web services for some data, it could issue
    a database query, or it could write to disk. In all these cases, we need to execute
    callbacks when the asynchronous action completes; otherwise, we'd never finish
    our responses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在更简单的处理程序中，不，我们不会面临这个挑战。我们只需要查看请求，弄清楚如何处理它，然后执行它，并在发送响应之前更新响应。在更复杂的场景中，在我们能够响应之前，我们必须在请求处理程序中进行各种异步活动。换句话说，如果我们不小心，回调地狱是不可避免的。例如，我们的处理程序可能需要从其他网络服务获取一些数据，它可能执行数据库查询，或者它可能写入磁盘。在这些所有情况下，我们需要在异步操作完成时执行回调；否则，我们永远不会完成我们的响应。
- en: 'In [Chapter 9](ch09.html "Chapter 9. Advanced NodeJS Concurrency"), *Advanced
    NodeJS Concurrency*, we looked at implementing coroutines in Node using the `Co`
    library. What if we could do something similar with our request handler functions?
    That is, make them coroutines instead of plain callable functions. The ultimate
    goal would be to produce something that looks like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html "第9章。高级NodeJS并发")，“高级NodeJS并发”中，我们探讨了使用`Co`库在Node中实现协程。如果我们能在我们的请求处理程序函数中做类似的事情会怎么样？也就是说，让它们成为协程而不是普通的可调用函数。最终目标将是产生以下类似的东西：
- en: '![Co-routines as handlers](img/B05133_10_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![作为处理程序的协程](img/B05133_10_02.jpg)'
- en: 'Here, we can see that the values we get from these services behave as simple
    variables in our code. They don''t have to be services; however, they could be
    any asynchronous action. For example, our chat application needs to parse form
    data that''s posted from the UI. It''s going to use the `formidable` library to
    do this, which is an asynchronous action. The parsed form fields are passed to
    a callback function. Let''s wrap this action in a promise, and see what it looks
    like:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们从这些服务中获得的价值在我们的代码中表现为简单的变量。它们不必是服务；然而，它们可以是任何异步操作。例如，我们的聊天应用程序需要解析从UI发布的表单数据。它将使用`formidable`库来完成这项工作，这是一个异步操作。解析后的表单字段被传递给回调函数。让我们将这个操作包裹在一个承诺中，看看它是什么样子：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we want form fields, we have a promise to work with, which is good. But
    now, we need to use the function in the context of a coroutine. Let's walk through
    each of our request handlers, and see how to use the `formFields()` function to
    treat the promised value as a synchronous value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要表单字段时，我们有一个承诺要与之合作，这是好的。但现在，我们需要在协程的上下文中使用该函数。让我们逐一查看我们的请求处理程序，看看如何使用`formFields()`函数将承诺值作为同步值处理。
- en: The create chat handler
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建聊天处理程序
- en: 'The create chat handler is responsible for creating a new chat. It expects
    a topic and a user. It''s going to use the `formFields()` function to parse the
    form data that''s posted to this handler. After it stores the new chat in the
    global `chat` object (remember, this application stores everything in memory),
    the handler responds with the chat data as a JSON string. Let''s take a look at
    the handler code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建聊天处理程序负责创建一个新的聊天。它期望一个主题和一个用户。它将使用`formFields()`函数来解析发送到这个处理程序的表单数据。在它将新的聊天存储在全局`chat`对象中（记住，这个应用程序将所有内容存储在内存中）之后，处理程序以JSON字符串的形式响应聊天数据。让我们看看处理程序代码：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that the `createChat()` function is exported from this module, because
    it's used by our router in the main application module. We can also see that the
    handler function is a generator, and it's wrapped with `co.wrap()`. This is because
    we want it to be a coroutine instead of a regular function. The call to `formFields()`
    illustrates the ideas that we covered in the previous section. Notice that we
    yield the promise, and we get the resolved value in return. The function blocks
    while this is happening, and this is of key importance because it's how we're
    able to keep our code clean and free of excessive callbacks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`createChat()`函数从这个模块导出，因为它被我们的路由器在主应用程序模块中使用。我们还可以看到处理程序函数是一个生成器，并且它被`co.wrap()`包裹。这是因为我们希望它成为一个协程而不是一个普通函数。对`formFields()`的调用说明了我们在上一节中讨论的思想。注意，我们生成了承诺，并返回了解决后的值。函数在发生时阻塞，这非常重要，因为这正是我们能够保持我们的代码干净且没有过多的回调的原因。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a few utility functions used by each of our handlers. These functions
    aren't covered here in the interest of page space. However, they're in the code
    that ships with this book, and they're documented in the comments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的手册程序使用了一些实用函数。出于页面空间的考虑，这里没有涵盖这些函数。然而，它们包含在这本书的代码中，并在注释中进行了说明。
- en: The join chat handler
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入聊天处理程序
- en: 'The join chat chandler is how a user is able to join a chat created by another
    user. The user first needs the URL of the chat shared with them. Then, they can
    provide their name and post to this endpoint, which has the chat ID encoded as
    part of the URL. The job of this handler is to push the new user onto the users
    array of the chat. Let''s take a look at handler code now:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 加入聊天处理程序是用户能够加入其他用户创建的聊天的方式。用户首先需要与他们共享的聊天URL。然后，他们可以提供他们的名字，并将消息发送到这个端点，该端点的聊天ID作为URL的一部分编码。这个处理程序的工作是将新的用户推送到聊天的用户数组中。现在让我们看看处理程序代码：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can probably notice many similarities between this handler and the create
    chat handler. We check for the correct HTTP method, return a JSON response, and
    wrap the handler function as a coroutine so that we can parse the form in a way
    that completely avoids callback functions. The main difference is that we update
    an existing chat, instead of creating a new one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能注意到这个处理程序和创建聊天处理程序之间有很多相似之处。我们检查正确的HTTP方法，返回JSON响应，并将处理程序函数包装为协程，这样我们就可以以完全避免回调函数的方式解析表单。主要区别在于我们更新现有的聊天，而不是创建一个新的。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code where we push the new `user` object to the `users` array would be considered
    storing the chat. In a real application, this would mean writing the data to disk
    somehow —likely a call to a database library. This would mean making an asynchronous
    request. Luckily, we can follow the same technique used with our form parsing—have
    it return a promise and leverage the coroutine that's already in place.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的`user`对象推送到`users`数组的代码会被认为是存储聊天。在实际应用中，这意味着以某种方式将数据写入磁盘——很可能是调用数据库库。这意味着需要发起异步请求。幸运的是，我们可以遵循与我们的表单解析相同的技巧——让它返回一个承诺，并利用已经存在的协程。
- en: The load chat handler
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载聊天处理程序
- en: 'The job of the load chat handler is exactly what it sounds like—load the given
    chat using an ID found in the URL and respond with the JSON string of this chat.
    Here''s the code to do this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 加载聊天处理程序的工作正好符合其名称——使用在URL中找到的ID加载指定的聊天，并以该聊天的JSON字符串响应。以下是执行此操作的代码：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's no `co.wrap()` call for this function, nor a generator. This is because
    it's not needed. It's not that it's harmful to have this function be a generator
    that's wrapped as a coroutine, it's just wasteful.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数没有`co.wrap()`调用，也没有生成器。这是因为不需要。并不是说这个函数作为生成器被包装为协程是有害的，只是浪费。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is actually an example of us, the developers, making a conscious decision
    to avoid concurrency where it isn't justified. This might change down the road
    with this handler, and if it does, we'll have work to do. However, the trade-off
    is the fact that we now have less code, and it runs faster. It's beneficial to
    others who read it as it doesn't look like an asynchronous function, and it shouldn't
    be treated as such.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我们，即开发者，有意识地决定避免在不合理的地方使用并发的一个例子。将来这个处理程序可能会有所改变，如果确实如此，我们就会有工作要做。然而，权衡的结果是我们现在有更少的代码，运行速度更快。这对阅读它的人来说是有益的，因为它看起来不像一个异步函数，而且它也不应该被当作这样的函数来对待。
- en: The send message handler.
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息处理程序。
- en: 'The last major API endpoint that we need to implement is send message. This
    is how any user in a given chat is able to post a message that''s available for
    all other chat participants to consume. This is similar to the join chat handler,
    except we''re pushing a new message object onto the messages array. Let''s take
    a look at the handler code; this pattern should start to look familiar by now:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个主要API端点是发送消息。这是任何给定聊天中的用户能够发布一条消息，其他所有聊天参与者都可以消费的方式。这与加入聊天处理程序类似，除了我们将新的消息对象推送到消息数组。让我们看看处理程序代码；现在这个模式应该开始变得熟悉了：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The same idea applies when joining a chat. Modifying the chat object is likely
    an asynchronous action in a real application, and now, our coroutine handler pattern
    is all set up for us to make this change when the time is right. That's the key
    with these coroutine handlers, making it easy to add new asynchronous actions
    to handlers instead of overwhelmingly difficult.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当加入聊天时，同样的想法适用。在真实应用中，修改聊天对象可能是一个异步操作，而现在，我们的协程处理程序模式已经为我们准备好了，以便在适当的时候进行这个更改。这就是这些协程处理程序的关键，使得向处理程序添加新的异步操作变得容易，而不是非常困难。
- en: Static handlers
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态处理程序
- en: 'The last group of handlers that make up our chat application are the static
    content handlers. These have the job of serving static files from the file system
    to the browser, such as the `index.html` document and our JavaScript source. Typically,
    this is handled outside of the node application, but we''ll include them here
    because there are times where it''s just easier to go batteries included:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 构成我们聊天应用最后一批处理程序的最后一组是静态内容处理程序。它们的工作是从文件系统向浏览器提供静态文件，例如`index.html`文档和我们的JavaScript源文件。通常，这是在node应用之外处理的，但我们将包括它们，因为在某些时候，直接使用现成的电池包会更简单：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Building the UI
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: We now have an API to target; it's time to start building the user interface
    for our chat. We'll start by thinking about talking to the API that we've just
    built, then implementing that piece. Next, we'll build the actual HTML we need
    to render the three pages used by this application. From here, we'll move onto
    perhaps the most challenging part of the front end—building the DOM event handlers
    and manipulators. Finally, we'll see if we can enhance the responsiveness of the
    application by throwing a web worker into the mix.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个API要针对；是时候开始构建我们聊天应用的用户界面了。我们将从思考如何与刚刚构建的API通信开始，然后实现这一部分。接下来，我们将构建实际需要的HTML来渲染这个应用使用的三个页面。从这里，我们将转向前端可能最具挑战性的部分——构建DOM事件处理程序和操作器。最后，我们将看看是否可以通过添加一个Web
    Worker来提高应用响应性。
- en: Talking to the API
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与API通信
- en: The API communication paths in our UI are inherently concurrent—they send and
    receive data over a network connection. Therefore, it's in the best interest of
    our application architecture that we take time to hide the synchronization mechanisms
    from the rest of the system as best as we can. To communicate with our API, we'll
    use instances of the `XMLHttpRequest` class. However, as we've seen in earlier
    chapters of this book, this class can lead us toward callback hell.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们UI中的API通信路径本质上是并发的——它们通过网络连接发送和接收数据。因此，为了我们应用架构的最佳利益，我们最好花时间将同步机制从整个系统中尽可能隐藏起来。为了与我们的API通信，我们将使用`XMLHttpRequest`类的实例。然而，正如我们在本书的前几章中看到的，这个类可能会引导我们走向回调地狱。
- en: 'The solution, as we know, is to use a promise to support a consistent interface
    to all our API data. This doesn''t mean we need to abstract the `XMLHttpRequest`
    class over and over again. We create a simple utility function that handles the
    concurrency encapsulation for us, and then we create several smaller functions
    that are specific to a corresponding API endpoint. Here''s a diagram that illustrates
    the idea:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，解决方案是使用一个承诺来支持对所有API数据的统一接口。这并不意味着我们需要反复抽象`XMLHttpRequest`类。我们创建了一个简单的实用函数，它为我们处理并发封装，然后我们创建了几个针对相应API端点的特定小函数。下面是一个说明这个想法的图示：
- en: '![Talking to the API](img/B05133_10_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![与API通信](img/B05133_10_03.jpg)'
- en: 'This approach to talking with asynchronous API endpoints scales well, because
    adding new capabilities involves simply adding a small function. All the synchronization
    semantics are encapsulated within one `api()` function. Let''s take a look at
    the code now:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与异步API端点通信的这种方法具有良好的可扩展性，因为添加新功能只需要添加一个小函数。所有的同步语义都被封装在一个`api()`函数中。现在让我们看看代码：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function is pretty easy to use and supports all our API usage scenarios.
    The smaller API functions that we'll implement shortly can simply return the promise
    that's returned by this `api()` function. There's no need to do anything fancier
    than this.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常容易使用，支持我们所有的API使用场景。我们很快将要实现的较小的API函数可以简单地返回这个`api()`函数返回的承诺。没有必要比这更复杂。
- en: However, there is another thing we'll want to consider here. If we recall from
    the requirements of this application, the API doesn't have any filtering capabilities.
    This is a problem for the UI because we're not going to re-render the entire chat
    object. Messages can be posted frequently, and if we re-render a lot of messages,
    there's a good chance that the screen will flicker as we render the DOM elements.
    So, we obviously need to filter the chat messages and users in the browser; but
    where should this happen?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里还有另一件事我们需要考虑。如果我们回顾这个应用的要求，API 没有任何过滤功能。这对 UI 来说是个问题，因为我们不会重新渲染整个聊天对象。消息可以频繁发布，如果我们重新渲染大量消息，屏幕在渲染
    DOM 元素时可能会出现闪烁。因此，我们显然需要在浏览器中过滤聊天消息和用户；但这件事应该在何处发生？
- en: 'Let''s think about this in the context of concurrency. Say we decide to perform
    the filtering in a component that directly manipulates the DOM. This is good in
    a sense because it means that we can have several independent components using
    the same data yet filtering it differently. It''s also difficult to make any kind
    of adjustments for concurrency when the data transformations are this close to
    the DOM. For example, our application doesn''t need flexibility. There''s only
    one component that renders filtered data. But, it might benefit from concurrency.
    The following diagram illustrates another approach, where the API functionality
    that we implement performs the filtering:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在并发的背景下思考这个问题。假设我们决定在一个直接操作 DOM 的组件中执行过滤。这在某种程度上是好的，因为它意味着我们可以有多个独立组件使用相同的数据，但以不同的方式过滤。当数据转换与
    DOM 非常接近时，调整并发的任何类型都很难。例如，我们的应用程序不需要灵活性。只有一个组件渲染过滤后的数据。但是，它可能从并发中受益。以下图表说明了另一种方法，其中我们实现的
    API 功能执行过滤：
- en: '![Talking to the API](img/B05133_10_04.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![与 API 交流](img/B05133_10_04.jpg)'
- en: 'With this approach, the API functions are isolated enough from the DOM. We
    can introduce concurrency later on if we want. Let''s look at some specific API
    functions now in addition to a filtering mechanism we can attach to the given
    API calls as needed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，API 函数与 DOM 的隔离程度足够高。如果我们愿意，我们可以在稍后引入并发。现在，让我们看看一些具体的 API 函数，以及我们可以根据需要附加到给定
    API 调用的过滤机制：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `filterChat()` function is straightforward enough. It just modifies the
    given `chat` object to include only new users and messages. New messages are those
    that have a timestamp greater than the `timestamp` variable used here. After the
    filtering is done, `timestamp` is updated based on the chat's `timestamp` property.
    This could be the same value if nothing has changed, but if something has changed,
    this value is updated so that duplicate values aren't returned.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterChat()` 函数足够简单。它只是修改给定的 `chat` 对象，只包含新用户和消息。新消息是指那些时间戳大于这里使用的 `timestamp`
    变量的消息。过滤完成后，`timestamp` 会根据聊天的 `timestamp` 属性更新。如果没有变化，这个值可能保持不变，但如果有所变化，这个值会更新，以确保不会返回重复的值。'
- en: We can see that in our specific API functions, the `filterChat()` function is
    passed to the promise as a resolver. So we do retain a level of flexibility here.
    For example, if a different component needs to filter the chat differently, we
    can introduce a new function that uses the same approach, and add a different
    promise resolver function that filters accordingly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在我们的特定 API 函数中，`filterChat()` 函数被传递给承诺作为解析器。因此，我们在这里仍然保持了一定的灵活性。例如，如果不同的组件需要以不同的方式过滤聊天，我们可以引入一个新的函数，使用相同的方法，并添加一个不同的承诺解析器函数，以相应地进行过滤。
- en: Implementing the HTML
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现HTML
- en: Our UI needs some HTML in order to render. The chat application is simple enough
    to get away with just a single HTML page. We can organize the DOM structure into
    three `div` elements, each of which represents our page. The elements on each
    page are simple in themselves, because there aren't many moving parts at this
    stage in development. Our first priority is functionality—building features that
    work. At the same time, we should be thinking about concurrency design. These
    items are definitely more pertinent to building a resilient architecture than
    thinking about, say, widgets and virtual DOM rendering libraries. These are important
    considerations, but they're also easier to work around than a faulty concurrency
    design.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的UI需要一些HTML才能渲染。聊天应用程序足够简单，只需要一个HTML页面。我们可以将DOM结构组织成三个`div`元素，每个元素代表我们的页面。每个页面的元素本身很简单，因为在这个开发阶段没有多少动态部分。我们的首要任务是功能性——构建功能正常的功能。同时，我们应该考虑并发设计。这些项目肯定比考虑，比如说，小部件和虚拟DOM渲染库更相关。这些是重要的考虑因素，但它们也比处理有缺陷的并发设计更容易解决。
- en: 'Let''s take a look at the HTML source used with our UI. There are a few CSS
    styles defined for these elements. However, they''re trivial and aren''t covered
    here. For example, the hide class is used to toggle the visibility of a given
    page. By default, everything is hidden. It''s up to our event handlers to handle
    the display of these elements—we''ll cover these next:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与我们的UI一起使用的HTML源。为这些元素定义了一些CSS样式。然而，它们是微不足道的，这里没有涵盖。例如，隐藏类用于切换给定页面的可见性。默认情况下，一切都被隐藏。处理这些元素的显示是我们的事件处理器的责任——我们将在下一部分介绍这些：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: DOM events and manipulation
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM事件和操作
- en: 'We now have some API communication mechanisms and DOM elements in place. Let''s
    turn our attention to the event handlers of our application, and how they interact
    with the DOM. The most involved DOM manipulation activity for us to tackle is
    drawing the chat. That is, displaying messages and users participating in the
    chat. Let''s start here. We''ll implement a `drawChat()` function because it''s
    likely going to be used in more than one place:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经建立了一些API通信机制和DOM元素。让我们将注意力转向我们应用程序的事件处理器，以及它们如何与DOM交互。我们需要解决的最复杂的DOM操作活动是绘制聊天。也就是说，显示参与聊天的消息和用户。让我们从这里开始。我们将实现一个`drawChat()`函数，因为它可能将在多个地方使用：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are two important things to note about the `drawChat()` function. First,
    there's no chat filtering done here. It assumes that any message and user are
    new, and it simply appends them to the DOM. Second, we actually return the chat
    object after we've rendered the DOM. This may seem unnecessary at first, but we're
    actually going to use this function as a promise resolver. This means that if
    we want to add more resolvers to the `then()` chain, we have to pass the data
    along by returning it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`drawChat()`函数有两个重要的事项需要注意。首先，这里没有进行聊天过滤。它假设任何消息和用户都是新的，并且简单地将其追加到DOM中。其次，我们在渲染DOM之后实际上返回了聊天对象。一开始这可能看起来是不必要的，但我们实际上打算将这个函数用作承诺解析器。这意味着如果我们想在`then()`链中添加更多的解析器，我们必须通过返回它来传递数据。
- en: 'Let''s take a look at the load event to highlight the previous point. After
    the chat has been rendered, we need to perform some more work. To do this, we
    can just chain the next function with another `then()` call:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看加载事件来强调前面的观点。在聊天渲染后，我们需要做一些额外的工作。为此，我们可以简单地通过另一个`then()`调用链来链下下一个函数：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This handler is called when the page first loads, and it first needs to check
    if there''s a chat to load based on the current URL. If there is, then we make
    an API call to load the chat using `drawChat()` as the resolver. But, we also
    need to perform some additional functionality, and this is added to the next `then()`
    resolver in the chain. It''s job is to make sure the user is actually part of
    the chat, and for this, it needs the chat we just loaded from the API, which is
    passed along from `drawChat()`. After we make further API calls to add the user
    to the chat, if necessary, we start the polling mechanism. This is how we keep
    the UI up-to-date with new messages and new users joining the chat:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面首次加载时，此处理器会被调用，首先需要根据当前URL检查是否有聊天要加载。如果有，我们就通过使用`drawChat()`作为解析器来调用API加载聊天。但是，我们还需要执行一些额外的功能，并且这些功能被添加到链中的下一个`then()`解析器中。它的任务是确保用户实际上是聊天的一部分，为此，它需要我们从API加载的聊天，这是通过`drawChat()`传递的。在必要时，我们进行进一步的API调用以将用户添加到聊天中后，我们开始轮询机制。这就是我们如何保持UI与新的消息和加入聊天的用户保持同步的方式：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may have noticed that we're using strange call almost like a web worker—`api.postMessage()`.
    This is because it is a web worker, and this is what we'll cover next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们使用了一种奇怪的调用方式，几乎就像一个Web Worker——`api.postMessage()`。这是因为它是一个Web Worker，这就是我们接下来要讨论的内容。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the interest of space, we're leaving out three other DOM event handlers related
    to creating chats, joining chats, and sending messages. There's nothing different
    about them in terms of concurrency compared to the load handler that we just covered.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们省略了与创建聊天、加入聊天和发送消息相关的其他三个DOM事件处理器。与刚刚介绍过的加载处理器相比，它们在并发方面没有不同。
- en: Adding an API worker
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加API工作线程
- en: Earlier, when we were implementing the API communication functions, we decided
    that having filtering components coupled with the API rather than the DOM made
    more sense from a concurrency perspective. It's now time to benefit from this
    decision and encapsulate our API code within a web worker. The main reason we
    want to do this is because the `filterChat()` function has the potential to lock
    up responsiveness. In other words, for larger chats, this would take longer to
    complete, and text inputs would stop responding to user input. For instance, there's
    no reason to prevent a user from sending a message while we try to render the
    updated list of messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期实现API通信函数时，我们决定从并发角度来看，将过滤组件与API而不是DOM耦合更有意义。现在是时候从这个决定中受益，并将我们的API代码封装在Web
    Worker中。我们想要这样做的主要原因是`filterChat()`函数有可能锁定响应性。换句话说，对于较大的聊天，这需要更长的时间来完成，文本输入将停止响应用户输入。例如，在我们尝试渲染更新后的消息列表时，没有理由阻止用户发送消息。
- en: 'First, we need to extend the worker API to have `postMessage()` return a promise.
    This is just as we did in [Chapter 7](ch07.html "Chapter 7. Abstracting Concurrency"),
    *Abstracting Concurrency*. Take a look at the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要扩展工作线程API，使`postMessage()`返回一个承诺。这与我们在[第7章](ch07.html "第7章。抽象并发")中做的相同，即*抽象并发*。看看下面的代码：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's one minor detail that we didn't cover in [Chapter 7](ch07.html "Chapter 7. Abstracting
    Concurrency"), *Abstracting Concurrency*, with this technique of rejecting promises.
    For example, if the API call for some reason fails, we have to make sure that
    the promise in the main thread that's waiting on the worker is rejected; otherwise,
    strange bugs will start popping up.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。抽象并发")中，我们没有涵盖使用拒绝承诺的这种技术的一个细节。例如，如果API调用由于某种原因失败，我们必须确保主线程中等待工作线程的承诺被拒绝；否则，会出现奇怪的错误。
- en: 'Now, we need to make an addition to our `ui-api.js` module, where all our API
    functions are defined to accommodate for the fact that it''s running inside a
    web worker. We just need to add the following event handler:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的`ui-api.js`模块中添加一个附加项，其中定义了所有API函数，以适应它在Web Worker中运行的事实。我们只需要添加以下事件处理器：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `message` event handler is how we're able to communicate with the main
    thread. The `action` property is how we're able to determine which API endpoint
    to call. So now, whenever we perform any expensive filtering on our chat messages,
    it's in a separate thread.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`message`事件处理器是我们与主线程通信的方式。`action`属性是我们确定要调用哪个API端点的方法。因此，现在，每当我们在聊天消息上执行任何昂贵的过滤操作时，它都在一个单独的线程中。
- en: Another consequence of introducing this worker is that it encapsulates the API
    functionality into a cohesive whole. The API web worker component can now be thought
    of as a smaller application within the larger UI as a whole.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 引入这个工作线程的另一个后果是，它将API功能封装成一个统一的整体。现在，可以将API网络工作线程组件视为整个UI中更小的一个应用程序。
- en: Additions and improvements
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加和改进
- en: And that's the extent of coverage we'll have on the development of our chat
    application. We didn't walk through every bit of code, but this is why the code
    is made available as a companion to this book to look through it in it's entirety.
    The focus of the preceding sections has been through the lens of writing concurrent
    JavaScript code. We didn't utilize every last example from the chapters before
    this one, which would defeat the whole purpose of concurrency to fix issues that
    lead to a suboptimal user experience.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在我们的聊天应用程序开发上进行的全部覆盖。我们没有逐行分析代码，但这就是为什么代码作为本书的配套资料提供，以便可以查看其全部内容。前几节的内容是通过编写并发JavaScript代码的视角来进行的。我们没有利用这一章之前的所有例子，这会违背并发解决导致用户体验不佳的问题的整个目的。
- en: The focus of the chat application example was the facilitation of concurrency.
    This means making it possible to implement concurrent code when there's a need
    to do so as opposed to the implementing concurrent code for the sake of it. The
    latter doesn't make our application any better than it is right now, nor does
    it leave us in a better position to fix concurrency issues that happen later on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天应用示例的重点是促进并发。这意味着在需要实现并发代码时才实现并发代码，而不是为了实现并发代码而实现并发代码。后者不会使我们的应用比现在更好，也不会使我们处于更好的位置来解决以后出现的并发问题。
- en: We'll wrap up the chapter with a few areas that might be worth considering for
    our chat application. You, the reader, are encouraged to work with the chat application
    code and see if any of these points that follow are applicable. How would you
    go about supporting them? Do we need to alter our design? The point is that concurrency
    design in our JavaScript applications isn't a one-time occurrence, it's an ever
    evolving design task that changes alongside our application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章结束于一些可能值得考虑的聊天应用领域。鼓励读者，也就是你，与聊天应用代码一起工作，看看以下哪些点适用。你将如何支持它们？我们需要改变我们的设计吗？重点是，在我们的JavaScript应用中的并发设计不是一次性的，而是一个不断发展的设计任务，它随着我们的应用而变化。
- en: Clustering the API
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群API
- en: In [Chapter 9](ch09.html "Chapter 9. Advanced NodeJS Concurrency"), *Advanced
    NodeJS Concurrency*, you were introduced to the cluster module in NodeJS. This
    transparently scales the request handling ability of our HTTP servers. This module
    works by forking the node process into several child processes. Since they're
    each they're own process, they have their own even loop. Furthermore, there's
    no additional communication synchronization code required.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html "第9章。高级NodeJS并发")《高级NodeJS并发》中，你被介绍了NodeJS中的cluster模块。这个模块可以透明地扩展我们HTTP服务器的请求处理能力。该模块通过将node进程分叉成几个子进程来实现。由于它们各自是独立的进程，它们各自有自己的事件循环。此外，不需要额外的通信同步代码。
- en: It wouldn't take much effort on our behalf to add in these clustering capabilities
    to our `app.js` module. But here's the question—at what point do we decide that
    clustering is worthwhile? Do we wait until we actually have performance issues,
    or we just have it turned on automatically? These are the things that are difficult
    to know in advance. The reality is that it depends on how CPU-intensive our request
    handlers get. And these changes usually come about as a result of new features
    being added to the software.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`app.js`模块中添加这些集群功能并不需要我们付出太多努力。但问题是——我们何时决定集群是有价值的？我们是等到实际出现性能问题，还是自动将其打开？这些事情很难提前知道。现实是，这取决于我们的请求处理程序有多大的CPU密集度。这些变化通常是由于软件中添加了新功能而引起的。
- en: Will our chat app ever need clustering? Perhaps, someday. But there's really
    no work being performed by the handlers. This can always change. Maybe we could
    go ahead and implement the clustering capabilities, but also add an option that
    let's us turn it off.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用是否需要集群？也许，将来某天会需要。但处理程序实际上并没有进行任何工作。这可能会改变。也许我们可以继续实现集群功能，同时添加一个选项，让我们可以选择关闭它。
- en: Cleaning up chats
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理聊天记录
- en: Our chat application doesn't have any persistent storage; it holds all the chat
    data in memory. This is fine for our particular use case, because it's meant for
    users that want to spin up a transient chat so that they can share a link with
    people and not have to go through a registration process. The problem here is
    that long after the chat is no longer being used, its data still occupies memory.
    Eventually, this will be fatal to our Node process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用没有持久存储；它将所有聊天数据保存在内存中。这对于我们的特定用例来说是可以的，因为它是为那些想要启动临时聊天以便与他人分享链接而不必经历注册过程的用户而设计的。问题在于，在聊天不再被使用很长时间后，其数据仍然占用内存。最终，这将对我们的Node进程造成致命打击。
- en: What if we decided to implement a cleanup service, whose job would be to periodically
    iterate over the chat data and chats that hadn't been modified in a given amount
    of time would be deleted? This would keep only active chats in memory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定实现一个清理服务，其任务是在给定时间内定期遍历聊天数据和未修改的聊天记录，那么这些聊天记录将被删除？这将只保留内存中的活跃聊天。
- en: Asynchronous entry points
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步入口点
- en: We made the early decision to use coroutines for most of our request handlers.
    The only asynchronous action used by these handlers is the form parsing behavior.
    However, the likelihood of this remaining the only asynchronous action in any
    given handler is small. Especially as our application grows, we're going to start
    depending on more core NodeJS functionality, which means we're going to want to
    wrap in promises more asynchronous callback-style code. We'll probably start depending
    on external services too either our own or third-party software.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们早期就决定在大多数请求处理器中使用协程。这些处理器使用的唯一异步操作是表单解析行为。然而，任何给定处理器中只保留这一唯一异步操作的可能性很小。特别是随着我们应用的增长，我们将开始依赖更多的核心NodeJS功能，这意味着我们将想要将更多异步回调风格的代码包装在承诺中。我们可能也会开始依赖外部服务，无论是我们自己的还是第三方软件。
- en: Can we take our asynchronous architecture a step further and provide entry points
    into these handlers for those that wish to extend the system? For example, if
    the request is a create chat request, send requests to any before create chat
    extensions that have been provided. Something like this is quite the undertaking
    and is error prone. But for larger systems that have many moving parts, all of
    them being asynchronous, it's best to look at standardizing on asynchronous entry
    points into the system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将我们的异步架构再向前迈进一步，并为希望扩展系统的用户提供进入这些处理器的入口点？例如，如果请求是创建聊天请求，向任何提供的创建聊天扩展发送请求。这样的任务相当艰巨，且容易出错。但对于具有许多移动部件的大型系统，其中所有部件都是异步的，最好是在系统中标准化异步入口点。
- en: Who's typing?
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁在输入？
- en: Something we left out of our chat application is the typing state for a given
    user. This is the mechanism that informs all other members of the chat that a
    particular user is typing a message and is present on just about every modern
    chat system.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在聊天应用中遗漏了一个功能，那就是特定用户的输入状态。这是通知所有其他聊天成员特定用户正在输入消息并存在于几乎每个现代聊天系统中的机制。
- en: What would it take for us to implement such a feature, given our current design?
    Is the polling mechanism enough to deal with such a constantly-changing state?
    Would the data model have to change much, and would such a change bring about
    problems with our request handlers?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的设计下，要实现这样的功能需要什么？轮询机制是否足以处理这种不断变化的状态？数据模型是否需要做出很大改变，这样的改变会不会给我们的请求处理器带来问题？
- en: Leaving chats
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离开聊天
- en: Another feature missing from our chat application is removing users that are
    no longer participating in the chat. For example, does it really make sense for
    other chat participants to see users in the chat that aren't really there? Would
    listening to a unload event and implementing a new leave chat API endpoint suffice,
    or is there a lot more to it than this?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聊天应用中缺失的一个功能是移除不再参与聊天的用户。例如，其他聊天参与者看到聊天中实际上并不存在的用户，这真的有意义吗？仅仅监听卸载事件并实现一个新的离开聊天API端点是否足够，还是还有更多需要考虑的地方？
- en: Polling timeouts
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮询超时
- en: The chat application that we've just built does little to no error handling.
    One case in particular that's worth fixing is killing the polling mechanism when
    it times out. By this, we're talking about preventing the client from repeating
    failed request attempts. Let's say the server is down, or the handler is simply
    failing because of a bug introduced; do we want the poller to just spin indefinitely?
    We don't want it to do this, and there's probably something that can be done about
    it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建的聊天应用几乎没有进行错误处理。特别值得修复的一个案例是在轮询超时时终止轮询机制。通过这种方式，我们是在谈论防止客户端重复失败的请求尝试。假设服务器宕机，或者处理器因为引入的bug而简单地失败；我们希望轮询器无限期地空转吗？我们不想让它这样做，而且可能有一些事情可以解决它。
- en: For example, we would need to cancel the interval that's set up when the polling
    starts with the call to `setInterval()`. Likewise, we would need a means to track
    the number of successive failed attempts, so we would know when to shut it off.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要在轮询开始时通过调用`setInterval()`取消设置的间隔。同样，我们需要一种方法来跟踪连续失败的尝试次数，这样我们就会知道何时关闭它。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Hopefully, this walk-through of a silly chat application has given you a new
    appreciation of what's involved with designing concurrent JavaScript applications
    end-to-end. This book started off with a high-level overview of what concurrency
    is, especially in the context of a JavaScript application, because it is different
    from other programming language environments. Then, we introduced some guiding
    principles to help us along the way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这次对愚蠢的聊天应用程序的介绍，让你对设计端到端并发JavaScript应用程序所涉及的内容有了新的认识。这本书一开始就提供了一个关于并发是什么的高层次概述，特别是在JavaScript应用程序的背景下，因为这与其他编程语言环境不同。然后，我们介绍了一些指导原则，以帮助我们在这个过程中前进。
- en: The chapters where we took a disciplined look at the various language and environment
    concurrency mechanisms are really just a means to an end. The ultimate end game
    for us—the JavaScript programmers and architects—is an application that's free
    of concurrency issues. This is a broad statement, but at the end of the day, many
    issues that we face in our web applications are a direct result of inadequate
    concurrency design.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对各种语言和环境并发机制进行了有纪律的审视的章节，实际上只是达到目的的一种手段。对我们这些JavaScript程序员和架构师来说，最终的目标是一个没有并发问题的应用程序。这是一个宽泛的陈述，但最终，我们在Web应用程序中面临的大多数问题都是由于并发设计不足的直接结果。
- en: So use these principles. Use the awesome concurrency features available in JavaScript.
    Combine these two things to make great applications that exceed the expectations
    of our users. When we write code that's concurrent by default, many JavaScript
    programming challenges simply vanish.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请使用这些原则。使用JavaScript中可用的出色的并发功能。将这两者结合起来，制作出超出用户期望的出色应用程序。当我们编写默认并发的代码时，许多JavaScript编程挑战就会消失。
