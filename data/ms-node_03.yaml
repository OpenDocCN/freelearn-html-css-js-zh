- en: Streaming Data Across Nodes and Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在节点和客户端之间流式传输数据
- en: '"A jug fills drop by drop."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “壶口滴水成河。”
- en: – Buddha
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 佛陀'
- en: We now have a clearer picture of how the evented, I/O-focused design ethic of
    Node is reflected across its various module APIs, delivering a consistent and
    predictable environment for development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在更清楚地了解了Node的事件驱动、I/O集中的设计理念如何在其各种模块API中体现，为开发提供了一致和可预测的环境。
- en: In this chapter, we will discover how data, pulled from files or other sources,
    can be read, written, and manipulated just as easily using Node. Ultimately, we
    will learn how to use Node to develop networked servers with rapid I/O interfaces
    that support highly concurrent applications, sharing real-time data across thousands
    of clients, simultaneously.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现如何使用Node从文件或其他来源中提取数据，然后使用Node进行读取、写入和操作，就像使用Node一样容易。最终，我们将学习如何使用Node开发具有快速I/O接口的网络服务器，支持高并发应用程序，同时在成千上万的客户端之间共享实时数据。
- en: Why use streams?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用流？
- en: Presented with a fancy new language feature, design pattern, or software module,
    a novice developer may begin using it because it is new and fancy. An experienced
    developer, on the other hand, might ask, *why is this required?*
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 面对一个新的语言特性、设计模式或软件模块，一个新手开发者可能会开始使用它，因为它是新的和花哨的。另一方面，一个有经验的开发者可能会问，*为什么需要这个？*
- en: 'Streams are required because files are big. A few simple examples can demonstrate
    their necessity. To begin, let''s say we want to copy a file. In Node, a naive
    implementation looks like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文件很大，所以需要流。一些简单的例子可以证明它们的必要性。首先，假设我们想要复制一个文件。在Node中，一个天真的实现看起来像这样：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's very straightforward.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。
- en: The call to `readFileSync()` blocks while Node copies the contents of `source.bin`,
    a file in the same folder as the script, into memory, returning a `ByteBuffer`
    here named `block`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`readFileSync()`时，Node会将`source.bin`的内容（一个与脚本相同文件夹中的文件）复制到内存中，返回一个名为`block`的`ByteBuffer`。
- en: Once we have `block`, we can check and print out its size. Then, the code hands
    `block` to `writeFileSync`, which copies the memory block to the contents of a
    newly made or overwritten file, `destination.bin`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`block`，我们可以检查并打印出它的大小。然后，代码将`block`交给`writeFileSync`，它将内存块复制到一个新创建或覆盖的文件`destination.bin`的内容中。
- en: 'This code assumes the following things:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码假设以下事情：
- en: It's OK to block the event loop (it's not!)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞事件循环是可以的（不是！）
- en: We can read the whole file into memory (we can't!)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将整个文件读入内存（我们不能！）
- en: As you will recall from the previous chapter, Node processes one event after
    another, a single event at a time. Good asynchronous design allows a Node program
    to appear to be doing all sorts of things simultaneously, both to connected software
    systems and human users alike, while simultaneously offering developers in the
    code a straightforward presentation of logic that's easy to reason about and resistant
    to bugs. This is true, especially when compared to multithreaded code that might
    be written to solve the same task. Your team may have even turned to Node to make
    an improved replacement to such a classically multithreaded system. Also, good
    asynchronous design never blocks the event loop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中所记得的，Node会一个接一个地处理事件，一次处理一个事件。良好的异步设计使得Node程序看起来好像同时做了各种事情，既对连接的软件系统又对人类用户来说，同时还为代码中的开发者提供了一个易于理解和抵抗错误的逻辑呈现。这一点尤为真实，尤其是与可能编写来解决相同任务的多线程代码相比。你的团队甚至可能已经转向Node，以制作一个改进的替代品来解决这样一个经典的多线程系统。此外，良好的异步设计永远不会阻塞事件循环。
- en: Blocking the event loop is bad because Node can't do anything else, while your
    one blocking line of code is blocking. The example prior, written as a rudimentary
    script that copies a file from one place to another, might work just fine. It
    would block the terminal of the user while Node copies the file. The file might
    be small enough that there's little time to wait. If not, you could open another
    shell prompt while you're waiting. In this way, it's really no different from
    familiar commands like `cp` or `curl`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞事件循环是不好的，因为Node无法做其他事情，而你的一个阻塞代码行正在阻塞。前面的例子，作为一个简单的脚本，从一个地方复制文件到另一个地方，可能运行得很好。它会在Node复制文件时阻塞用户的终端。文件可能很小，等待的时间很短。如果不是，你可以在等待时打开另一个shell提示符。这样，它与`cp`或`curl`等熟悉的命令并没有什么不同。
- en: From the computer's perspective, this is quite inefficient, however. Each file
    copy shouldn't require its own operating system process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从计算机的角度来看，这是相当低效的。每个文件复制不应该需要自己的操作系统进程。
- en: Additionally, incorporating the previous code into a larger Node project could
    destabilize the system as a whole.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将之前的代码合并到一个更大的Node项目中可能会使整个系统不稳定。
- en: Your server-side Node app might be simultaneously letting three users log in,
    while sending large files to another two. If that app executes the previous code
    as well, two downloads will stick, and three browser throbbers will spin.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务器端Node应用程序可能同时让三个用户登录，同时向另外两个用户发送大文件。如果该应用程序执行之前的代码，两个下载将会停滞，三个浏览器会一直旋转。
- en: 'So, let''s try to fix this, one step at a time:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们一步一步地来修复这个问题：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At least now we're not using Node methods that have *Sync* in their titles.
    The event loop can breathe freely again.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 至少现在我们不再使用在它们标题中带有*Sync*的Node方法。事件循环可以再次自由呼吸。
- en: 'But still:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但是：
- en: How about big files? (Big explosions)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大文件怎么办？（大爆炸）
- en: That's quite a pyramid you've got there (of doom)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你那里有一个相当大的金字塔（厄运）
- en: 'Try the code prior with a 2 GB (2.0 x 2^30, or 2,147,483,648 byte) source file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用一个2GB（2.0 x 2^30，或2,147,483,648字节）的源文件来运行之前的代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you're watching a video on YouTube at 1080p, 2 GB will last you about an
    hour. The previous `RangeError` happens because `2,147,483,647` is `1111111111111111111111111111111`
    in binary, the largest 32-bit signed binary integer. Node uses that type internally
    to size and address the contents of a `ByteBuffer`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在YouTube上以1080p观看视频，2GB的流量大约可以让你看一个小时。之前的`RangeError`发生是因为`2,147,483,647`在二进制中是`1111111111111111111111111111111`，是最大的32位有符号二进制整数。Node在内部使用这种类型来调整和寻址`ByteBuffer`的内容。
- en: 'What happens if you hand our poor example? Smaller, but still very large, files
    are less deterministic. When it works, it does because Node successfully gets
    the required amount of memory from the operating system. The memory footprint
    of the Node process grows by the file size during the copy operation. Mice may
    turn to hourglasses, and fans may noisily spin up. Would promises help?:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你交给我们可怜的例子会发生什么？更小，但仍然非常大的文件是不确定的。当它工作时，是因为Node成功地从操作系统获取了所需的内存。在复制操作期间，Node进程的内存占用量会随着文件大小而增加。鼠标可能会变成沙漏，风扇可能会嘈杂地旋转起来。承诺会有所帮助吗？：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: No, essentially. We've flattened the pyramid, but the size limitation and memory
    issues remain in force.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不，本质上不是。我们已经扁平化了金字塔，但大小限制和内存问题仍然存在。
- en: What we really need is some code that is both asynchronous, and also *piece
    by piece*, grabbing a little part of the source file, shuttling it over to the
    destination file for writing, and repeating that cycle until we're done, like
    a bucket brigade from antique fire fighting.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是一些既是异步的，又是*逐步的*代码，从源文件中获取一小部分，将其传送到目标文件进行写入，并重复该循环，直到完成，就像古老的灭火队一样。
- en: '![](img/0e4e9db3-d056-41d5-a94f-5edb81573357.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e4e9db3-d056-41d5-a94f-5edb81573357.jpeg)'
- en: Such a design would let the event loop breathe freely the entire time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的设计会让事件循环在整个时间内自由呼吸。
- en: 'This is exactly what streams are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是流的作用：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In practice, scaled network applications are typically spread across many instances,
    requiring that the processing of data streams be distributed across many processes
    and servers. Here, a streaming file is simply a stream of data partitioned into
    slices, where each slice can be viewed independently irrespective of the availability
    of others. You can write to a data stream, or listen on a data stream, free to
    dynamically allocate bytes, to ignore bytes, to reroute bytes. Streams of data
    can be chunked, many processes can share chunk handling, chunks can be transformed
    and reinserted, and data flows can be precisely emitted and creatively managed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，规模化的网络应用通常分布在许多实例中，需要将数据流的处理分布到许多进程和服务器中。在这里，流文件只是一个数据流，被分成片段，每个片段可以独立查看，而不受其他片段的可用性的影响。你可以写入数据流，或者监听数据流，自由动态分配字节，忽略字节，重新路由字节。数据流可以被分块，许多进程可以共享块处理，块可以被转换和重新插入，数据流可以被精确发射和创造性地管理。
- en: Recalling our discussion on modern software and the Rule of Modularity, we can
    see how streams facilitate the creation of independent share-nothing processes
    that do one task well, and in combination, can compose a predictable architecture
    whose complexity does not preclude an accurate appraisal of its behavior. If the
    interfaces to data are uncontroversial, the data map can be accurately modeled,
    independent of considerations about data volume or routing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在现代软件和模块化规则上的讨论，我们可以看到流如何促进独立的共享无事务的进程的创建，这些进程各自完成一项任务，并且组合起来可以构成一个可预测的架构，其复杂性不会妨碍对其行为的准确评估。如果数据接口是无争议的，那么数据映射可以准确建模，而不考虑数据量或路由的考虑。
- en: Managing I/O in Node involves managing data events bound to data streams. A
    Node Stream object is an instance of `EventEmitter`. This abstract interface is
    implemented in numerous Node modules and objects, as we saw in the previous chapter.
    Let's begin by understanding Node's Stream module, then move on to a discussion
    of how network I/O in Node is handled via various Stream implementations; in particular,
    the HTTP module.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中管理I/O涉及管理绑定到数据流的数据事件。Node Stream对象是`EventEmitter`的一个实例。这个抽象接口在许多Node模块和对象中实现，正如我们在上一章中看到的那样。让我们首先了解Node的Stream模块，然后讨论Node中如何通过各种流实现处理网络I/O；特别是HTTP模块。
- en: Exploring streams
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索流
- en: 'According to Bjarne Stoustrup in his book, *The C++ Programming Language*,
    (third edition):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Bjarne Stoustrup在他的书《C++程序设计语言》（第三版）中的说法：
- en: '"Designing and implementing a general input/output facility for a programming
    language is notoriously difficult... An I/O facility should be easy, convenient,
    and safe to use; efficient and flexible; and, above all, complete."'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “为编程语言设计和实现通用的输入/输出设施是非常困难的... I/O设施应该易于使用、方便、安全；高效、灵活；最重要的是完整。”
- en: It shouldn't surprise anyone that a design team, focused on providing efficient
    and easy I/O, has delivered such a facility through Node. Through a symmetrical
    and simple interface, which handles data buffers and stream events so that the
    implementer does not have to, Node's Stream module is the preferred way to manage
    asynchronous data streams for both internal modules, and the module's developers
    will create.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让人不惊讶的是，一个专注于提供高效和简单I/O的设计团队，通过Node提供了这样一个设施。通过一个对称和简单的接口，处理数据缓冲区和流事件，使实现者不必关心，Node的Stream模块是管理内部模块和模块开发人员异步数据流的首选方式。
- en: 'A stream in Node is simply a sequence of bytes. At any time, a stream contains
    a buffer of bytes, and this buffer has a zero or greater length:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中，流只是一系列字节。在任何时候，流都包含一个字节缓冲区，这个缓冲区的长度为零或更大：
- en: '![](img/2723e2fe-cae1-4f74-ba59-fa5f464f0c2c.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2723e2fe-cae1-4f74-ba59-fa5f464f0c2c.jpg)'
- en: As each character in a stream is well-defined, and because every type of digital
    data can be expressed in bytes, any part of a stream can be redirected, or *piped*,
    to any other stream, different chunks of the stream can be sent to different handlers,
    and so on. In this way, stream input and output interfaces are both flexible and
    predictable, and can be easily coupled.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 流中的每个字符都是明确定义的，因为每种类型的数字数据都可以用字节表示，流的任何部分都可以重定向或*管道*到任何其他流，流的不同块可以发送到不同的处理程序，等等。这样，流输入和输出接口既灵活又可预测，并且可以轻松耦合。
- en: 'Node also offers a second type of streams: object streams. Instead of chunks
    of memory flowing through the stream, an object stream shuttles JavaScript objects.
    Byte streams pass around serialized data like streaming media, while object streams
    are the right choice for parsed, structured data like JSON records.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Node还提供了第二种类型的流：对象流。对象流不是通过流动内存块，而是通过JavaScript对象传输。字节流传输序列化数据，如流媒体，而对象流适用于解析的结构化数据，如JSON记录。
- en: Digital streams are well described using the analogy of fluids, where individual
    bytes (drops of water) are being pushed through a pipe. In Node, streams are objects
    representing data flows that can be written to and read from asynchronously.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数字流可以用流体的类比来描述，其中个别字节（水滴）被推送通过管道。在Node中，流是表示可以异步写入和读取的数据流的对象。
- en: The Node philosophy is a non-blocking flow, I/O is handled via streams, and
    so the design of the Stream API naturally duplicates this general philosophy.
    In fact, there is no other way of interacting with streams except in an asynchronous,
    evented manner—Node prevents developers, by design, from blocking I/O.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Node的哲学是非阻塞流，I/O通过流处理，因此Stream API的设计自然地复制了这一一般哲学。事实上，除了以异步、事件方式与流交互外，没有其他方式——Node通过设计阻止开发人员阻塞I/O。
- en: 'Five distinct base classes are exposed via the abstract Stream interface: **Readable**,
    **Writable**, **Duplex**, **Transform**, and **PassThrough**. Each base class
    inherits from `EventEmitter`, which we know of as an interface to which event
    listeners and emitters can be bound.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过抽象流接口暴露了五个不同的基类：**Readable**，**Writable**，**Duplex**，**Transform**和**PassThrough**。每个基类都继承自`EventEmitter`，我们知道它是一个可以绑定事件监听器和发射器的接口。
- en: As we will learn, and here will emphasize, the Stream interface is an abstract
    interface. An abstract interface functions as a kind of blueprint or definition,
    describing the features that must be built into each constructed instance of a
    Stream object. For example, a Readable stream implementation is required to implement
    a `public read` method which delegates to the interface's `internal _read` method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要学习的，并且在这里强调的，流接口是一个抽象接口。抽象接口充当一种蓝图或定义，描述了必须构建到每个构造的流对象实例中的特性。例如，可读流实现需要实现一个`public
    read`方法，该方法委托给接口的`internal _read`方法。
- en: 'In general, all stream implementations should follow these guidelines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，所有流实现都应遵循以下准则：
- en: As long as data exists to send, write to a stream until that operation returns
    `false`, at which point the implementation should wait for a drain event, indicating
    that the buffered stream data has emptied.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要存在要发送的数据，就向流写入，直到该操作返回`false`，此时实现应等待`drain`事件，表示缓冲的流数据已经清空。
- en: Continue to call read until a `null` value is received, at which point wait
    for a readable event prior to resuming reads.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续调用读取，直到收到`null`值，此时等待可读事件再恢复读取。
- en: Several Node I/O modules are implemented as streams. Network sockets, file readers
    and writers, `stdin` and `stdout`, zlib, and so on are all streams. Similarly,
    when implementing a readable data source, or data reader, one should implement
    that interface as a Stream interface.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个Node I/O模块都是以流的形式实现的。网络套接字、文件读取器和写入器、`stdin`和`stdout`、zlib等都是流。同样，当实现可读数据源或数据读取器时，应该将该接口实现为流接口。
- en: It is important to note that over the history of Node, the Stream interface
    changed in some fundamental ways. The Node team has done its best to implement
    compatible interfaces, so that (most) older programs will continue to function
    without modification. In this chapter, we will not spend any time discussing the
    specific features of this older API, focusing on the current design. The reader
    is encouraged to consult Node's online documentation for information on migrating
    older programs. As often happens, there are modules that *wrap* streams with convenient,
    reliable interfaces. A good one is: [https://github.com/rvagg/through2.](https://github.com/rvagg/through2)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在Node的历史上，Stream接口在某些根本性方面发生了变化。Node团队已尽最大努力实现兼容的接口，以便（大多数）旧程序可以继续正常运行而无需修改。在本章中，我们不会花时间讨论旧API的具体特性，而是专注于当前的设计。鼓励读者查阅Node的在线文档，了解迁移旧程序的信息。通常情况下，有一些模块会用方便、可靠的接口*包装*流。一个很好的例子是：[https://github.com/rvagg/through2.](https://github.com/rvagg/through2)
- en: Implementing readable streams
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现可读流
- en: Streams producing data that another process may have an interest in are normally
    implemented using a `Readable` stream. A `Readable` stream saves the implementer
    all the work of managing the read queue, handling the emitting of data events,
    and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 产生数据的流，另一个进程可能感兴趣的，通常使用“Readable”流来实现。“Readable”流保存了实现者管理读取队列、处理数据事件的发射等所有工作。
- en: 'To create a `Readable` stream, use this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个“Readable”流，请使用以下方法：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As previously mentioned, `Readable` is exposed as a base class, which can be
    initialized through three options:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，“Readable”作为一个基类暴露出来，可以通过三种选项进行初始化：
- en: '`encoding`: Decode buffers into the specified encoding, defaulting to UTF-8.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding`：将缓冲区解码为指定的编码，默认为UTF-8。'
- en: '`highWaterMark`: Number of bytes to keep in the internal buffer before ceasing
    to read from the data source. The default is 16 KB.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`highWaterMark`：在停止从数据源读取之前，保留在内部缓冲区中的字节数。默认为16 KB。'
- en: '`objectMode`: Tell the stream to behave as a stream of objects instead of a
    stream of bytes, such as a stream of JSON objects instead of the bytes in a file.
    Default `false`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectMode`：告诉流以对象流而不是字节流的方式运行，例如以JSON对象流而不是文件中的字节流。默认为`false`。'
- en: 'In the following example, we create a mock `Feed` object whose instances will
    inherit the `Readable` stream interface. Our implementation need only implement
    the abstract `_read` method of `Readable`, which will push data to a consumer
    until there is nothing more to push, at which point it triggers the `Readable`
    stream to emit an `end` event by pushing a `null` value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们创建一个模拟的`Feed`对象，其实例将继承`Readable`流接口。我们的实现只需要实现`Readable`的抽象`_read`方法，该方法将向消费者推送数据，直到没有更多数据可以推送为止，然后通过推送`null`值来触发`Readable`流发出一个`end`事件：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have an implementation, a consumer might want to instantiate the
    stream and listen for stream events. Two key events are `readable` and `end`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个实现，消费者可能希望实例化流并监听流事件。两个关键事件是`readable`和`end`。
- en: The `readable` event is emitted as long as data is being pushed to the stream.
    It alerts the consumer to check for new data via the `read` method of `Readable`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 只要数据被推送到流中，`readable`事件就会被触发。它会提醒消费者通过`Readable`的`read`方法检查新数据。
- en: Note again how the `Readable` implementation must provide a `private _read`
    method that services the `public read` method exposed to the consumer API.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，`Readable`实现必须提供一个`private _read`方法，为消费者API公开的`public read`方法提供服务。
- en: The `end` event will be emitted whenever a `null` value is passed to the `push`
    method of our `Readable` implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向`Readable`实现的`push`方法传递`null`值时，`end`事件将被触发。
- en: 'Here, we see a consumer using these methods to display new stream data, providing
    a notification when the stream has stopped sending data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个消费者使用这些方法来显示新的流数据，并在流停止发送数据时提供通知：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, we can implement a stream of objects through the use of the `objectMode`
    option:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过使用`objectMode`选项来实现对象流：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Having been placed in objectMode, each chunk pushed is expected to be an object.
    The reader for this stream can then work on the assumption that each `read()`
    event will produce a single object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置为objectMode后，每个推送的块都预期是一个对象。因此，该流的读取器可以假定每个`read()`事件将产生一个单独的对象：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we see that each read event is receiving an object, rather than a buffer
    or string.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到每个读取事件都接收一个对象，而不是缓冲区或字符串。
- en: 'Finally, the `read` method of a `Readable` stream can be passed a single argument,
    indicating the number of bytes to be read from the stream''s internal buffer.
    For example, if it was desired that a file should be read one byte at a time,
    one might implement a consumer using a routine similar to this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Readable`流的`read`方法可以传递一个参数，指示从流的内部缓冲区中读取的字节数。例如，如果希望逐字节读取文件，可以使用类似于以下的例程来实现消费者：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that we''re pushing the entirety of news into the stream, and terminating
    with null. The stream is primed with the entire string of bytes. Now the consumer:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将整个新闻推送到流中，并以null终止。流已经准备好了整个字节字符串。现在消费者：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, it should be clear that the `Readable` stream's buffer was filled with
    a number of bytes all at once, but was read from discretely.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应该清楚的是`Readable`流的缓冲区一次性填满了许多字节，但是却是离散地读取。
- en: Pushing and pulling
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送和拉取
- en: We have seen how a `Readable` implementation will use `push` to populate the
    stream buffer for reading. When designing these implementations, it is important
    to consider how volume is managed, at either end of the stream. Pushing more data
    into a stream than can be read can lead to complications around exceeding available
    space (memory). At the consumer end, it is important to maintain awareness of
    termination events, and how to deal with pauses in the data stream.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`Readable`实现将使用`push`方法来填充用于读取的流缓冲区。在设计这些实现时，重要的是考虑如何管理流的两端的数据量。向流中推送更多数据可能会导致超出可用空间（内存）的复杂情况。在消费者端，重要的是要保持对终止事件的意识，以及如何处理数据流中的暂停。
- en: We might compare the behavior of data streams running through a network with
    that of water running through a hose.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将通过网络传输的数据流的行为与水流经过软管进行比较。
- en: As with water through a hose, if a greater volume of data is being pushed into
    the read stream than can be efficiently drained out of the stream at the consumer
    end through `read`, a great deal of back pressure builds, causing a data backlog
    to begin accumulating in the stream object's buffer. Because we are dealing with
    strict mathematical limitations, `read` simply cannot be compelled to release
    this pressure by reading more quickly—there may be a hard limit on available memory
    space, or other limitations. As such, memory usage can grow dangerously high,
    buffers can overflow, and so forth.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与水流经过软管一样，如果向读取流中推送的数据量大于消费者端通过`read`方法有效排出的数据量，就会产生大量背压，导致数据在流对象的缓冲区中开始积累。由于我们正在处理严格的数学限制，`read`方法根本无法通过更快地读取来释放这种压力——可用内存空间可能存在硬性限制，或者其他限制。因此，内存使用可能会危险地增加，缓冲区可能会溢出，等等。
- en: A stream implementation should therefore be aware of, and respond to, the response
    from a `push` operation. If the operation returns `false`  , this indicates that
    the implementation should cease reading from its source (and cease pushing) until
    the next `_read` request is made.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，流实现应该意识到并响应`push`操作的响应。如果操作返回`false`，这表明实现应该停止从其源读取（并停止推送），直到下一个`_read`请求被发出。
- en: In conjunction with the above, if there is no more data to push but more is
    expected in the future, the implementation should `push` an empty string `("")`,
    which adds no data to the queue but does ensure a future `readable` event.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述内容相结合，如果没有更多数据可以推送，但将来预期会有更多数据，实现应该`push`一个空字符串`("")`，这不会向队列中添加任何数据，但确保将来会触发一个`readable`事件。
- en: While the most common treatment of a stream buffer is to `push` to it (queuing
    data in a line), there are occasions where you might want to place data on the
    front of the buffer (jumping the line). Node provides an `unshift` operation for
    these cases, whose behavior is identical to push, outside of the aforementioned
    difference in buffer placement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然流缓冲区最常见的处理方式是向其`push`（将数据排队），但有时您可能希望将数据放在缓冲区的前面（跳过队列）。对于这些情况，Node提供了一个`unshift`操作，其行为与`push`相同，除了在缓冲区放置数据的差异之外。
- en: Writable streams
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可写流
- en: A `Writable` stream is responsible for accepting some value (a stream of bytes,
    a string) and writing that data to a destination. Streaming data into a file container
    is a common use case.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writable`流负责接受某个值（一系列字节，一个字符串）并将数据写入目标。将数据流入文件容器是一个常见的用例。'
- en: 'To create a `Writable` stream:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Writable`流：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Writable` streams constructor can be instantiated with two options:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writable`流构造函数可以用两个选项实例化：'
- en: '`highWaterMark`: The maximum number of bytes the stream''s buffer will accept
    prior to returning `false` on writes. Default is 16 KB.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`highWaterMark`：在写入时流缓冲区将接受的最大字节数。默认值为16 KB。'
- en: '`decodeStrings`: Whether to convert strings into buffers before writing. Default
    is `true`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decodeStrings`：是否在写入之前将字符串转换为缓冲区。默认为`true`。'
- en: As with `Readable` streams, custom `Writable` stream implementations must implement
    a `_write` handler, which will be passed the arguments sent to the `write` method
    of instances.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Readable`流一样，自定义的`Writable`流实现必须实现`_write`处理程序，该处理程序将接收发送给实例的`write`方法的参数。
- en: 'One should think of a `Writable` stream as a data target, such as for a file
    you are uploading. Conceptually, this is not unlike the implementation of push
    in a `Readable` stream, where one pushes data until the data source is exhausted,
    passing `null` to terminate reading. For example, here, we write 32 "A" characters
    to a stream, which will log them:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将`Writable`流视为一个数据目标，比如你正在上传的文件。在概念上，这与`Readable`流中`push`的实现类似，其中一个推送数据直到数据源耗尽，并传递`null`来终止读取。例如，在这里，我们向流写入了32个“A”字符，它将把它们记录下来：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are two key things to note here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个关键点需要注意。
- en: First, our `_write` implementation fires the `callback` function immediately
    after writing a callback that is always present, regardless of whether the instance
    `write` method is passed a `callback` directly. This call is important for indicating
    the status of the write attempt, whether a failure (error) or a success.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的`_write`实现在写入回调后立即触发`callback`函数，这个回调函数始终存在，无论实例的`write`方法是否直接传递了`callback`。这个调用对于指示写入尝试的状态（失败或成功）非常重要。
- en: Second, the call to write returned `true`. This indicates that the internal
    buffer of the `Writable` implementation has been emptied after executing the requested
    write. What if we sent a very large amount of data, enough to exceed the default
    size of the internal buffer?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，调用write返回了`true`。这表明在执行请求的写操作后，`Writable`实现的内部缓冲区已经被清空。如果我们发送了大量数据，足以超过内部缓冲区的默认大小，会怎么样呢？
- en: 'Modifying the previous example, the following would return `false`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 修改前面的例子，以下将返回`false`：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The reason this `write` returns `false` is that it has reached the `highWaterMark`
    option—default value of 16 KB (16 * 1,024). If we changed this value to `16383`,
    `write` would again return `true` (or one could simply increase its value).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`返回`false`的原因是它已经达到了`highWaterMark`选项的默认值16 KB（16 * 1,024）。如果我们将这个值改为`16383`，`write`将再次返回`true`（或者可以简单地增加它的值）。'
- en: 'What should you do when `write` returns `false`? You should certainly not continue
    to send data! Returning to our metaphor of water in a hose: when the stream is
    full, one should wait for it to drain prior to sending more data. Node''s Stream
    implementation will emit a `drain` event whenever it is safe to write again. When
    `write` returns `false` , listen for the `drain` event before sending more data.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当`write`返回`false`时，你应该怎么做？你肯定不应该继续发送数据！回到我们水管的比喻：当流满时，应该等待它排空后再发送更多数据。Node的流实现会在安全写入时发出`drain`事件。当`write`返回`false`时，在发送更多数据之前监听`drain`事件。
- en: 'Putting together what we have learned, let''s create a `Writable` stream with
    a `highWaterMark` value of 10 bytes. We''ll then set up a simulation where we
    push the a string of data to `stdout` larger than the `highWaterMark` some number
    of times. We catch buffer overflows and wait for the drain event to fire prior
    to sending more data:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 综合我们所学到的知识，让我们创建一个`highWaterMark`值为10字节的`Writable`流。然后设置一个模拟，我们将推送一个大于`highWaterMark`的数据字符串到`stdout`，然后等待缓冲区溢出并在发送更多数据之前等待`drain`事件触发：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each time we right we check if the stream write action returned false, and if
    so we wait for the next drain event before running our `write` method again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每次写入时，我们都会检查流写入操作是否返回false，如果是，我们会在再次运行我们的`write`方法之前等待下一个`drain`事件。
- en: You should be careful to implement proper stream management, respecting the
    "warnings" emitted by write events, and properly waiting for the drain event to
    occur prior to sending more data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该小心实现正确的流管理，尊重写事件发出的“警告”，并在发送更多数据之前正确等待`drain`事件的发生。
- en: The fluid data in a `Readable` stream can be easily redirected to a `Writable`
    stream. For example, the following code will take any data sent by a terminal
    (`stdin` is a `Readable` stream) and echo it back to the destination `Writable`
    stream (`stdout`): `process.stdin.pipe(process.stdout)`. Whenever a `Writable`
    stream is passed to a `Readable` stream's pipe method, a **pipe** event will fire.
    Similarly, when a `Writable` stream is removed as a destination for a `Readable`
    stream, the **unpipe** event fires. To remove a `pipe`, use the following: `unpipe(destination
    stream)`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Readable` 流中的流体数据可以很容易地重定向到 `Writable` 流。例如，以下代码将接收终端发送的任何数据（`stdin` 是一个 `Readable`
    流）并将其回显到目标 `Writable` 流（`stdout`）：`process.stdin.pipe(process.stdout)`。当将 `Writable`
    流传递给 `Readable` 流的 pipe 方法时，将触发 **pipe** 事件。类似地，当将 `Writable` 流从 `Readable` 流的目标中移除时，将触发
    **unpipe** 事件。要移除 `pipe`，使用以下方法：`unpipe(destination stream)`'
- en: Duplex streams
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双工流
- en: 'A **duplex stream** is both readable and writeable. For instance, a TCP server
    created in Node exposes a socket that can be both read from, and written to:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**双工流** 既可读又可写。例如，在 Node 中创建的 TCP 服务器公开了一个既可读又可写的套接字：'
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When executed, this code will create a TCP server that can be connected to
    via Telnet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，此代码将创建一个可以通过 Telnet 连接的 TCP 服务器：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Start the server in one terminal window, open a separate terminal, and connect
    to the server via telnet. Upon connection, the connecting terminal will print
    out `Go ahead and type something!`—writing to the socket. Any text entered in
    the connecting terminal (after hitting **ENTER**) will be echoed to the `stdout`
    of the terminal running the TCP server (reading from the socket), creating a sort
    of chat application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端窗口中启动服务器，打开一个单独的终端，并通过 telnet 连接到服务器。连接后，连接的终端将打印出 `Go ahead and type something!`
    ——写入套接字。在连接的终端中输入任何文本（按下 **ENTER** 后）将被回显到运行 TCP 服务器的终端的 `stdout`（从套接字读取），创建一种聊天应用程序。
- en: This implementation of a bidirectional (duplex) communication protocol demonstrates
    clearly how independent processes can form the nodes of a complex and responsive
    application, whether communicating across a network or within the scope of a single
    process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种双向（双工）通信协议的实现清楚地展示了独立进程如何形成复杂和响应灵敏的应用程序的节点，无论是在网络上通信还是在单个进程范围内通信。
- en: The options sent when constructing a `Duplex` instance merge those sent to `Readable`
    and `Writable` streams, with no additional parameters. Indeed, this stream type
    simply assumes both roles, and the rules for interacting with it follow the rules
    for the interactive mode being used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 构造 `Duplex` 实例时发送的选项将合并发送到 `Readable` 和 `Writable` 流的选项，没有额外的参数。实际上，这种流类型简单地承担了两种角色，并且与其交互的规则遵循所使用的交互模式的规则。
- en: As a `Duplex` stream assumes both read and write roles, any implementation is
    required to implement both `­_write` and `_read` methods, again following the
    standard implementation details given for the relevant stream type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duplex` 流假定了读和写两种角色，任何实现都需要实现 `­_write` 和 `_read` 方法，再次遵循相关流类型的标准实现细节。'
- en: Transforming streams
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换流
- en: On occasion, stream data needs to be processed, often in cases where one is
    writing some sort of binary protocol or other *on the fly* data transformation.
    A `Transform` stream is designed for this purpose, functioning as a `Duplex` stream
    that sits between a `Readable` stream and a `Writable` stream.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要处理流数据，通常在写入某种二进制协议或其他 *即时* 数据转换的情况下。`Transform` 流就是为此目的而设计的，它作为一个位于 `Readable`
    流和 `Writable` 流之间的 `Duplex` 流。
- en: A `Transform` stream is initialized using the same options used to initialize
    a typical `Duplex` stream, where `Transform` differs from a normal `Duplex` stream
    is in its requirement that the custom implementation merely provides a `_transform`
    method, excluding the `_write` and `_read` method requirement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与初始化典型 `Duplex` 流相同的选项初始化 `Transform` 流，`Transform` 与普通的 `Duplex` 流的不同之处在于其要求自定义实现仅提供
    `_transform` 方法，而不需要 `_write` 和 `_read` 方法。
- en: 'The `_transform` method will receive three arguments, first the sent buffer,
    an optional encoding argument, and finally a callback which `_transform` is expected
    to call when the transformation is complete:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`_transform` 方法将接收三个参数，首先是发送的缓冲区，然后是一个可选的编码参数，最后是一个回调函数，`_transform` 期望在转换完成时调用。'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s imagine a program that helps to convert **ASCII (American Standard Code
    for Information Interchange)** codes into ASCII characters, receiving input from
    `stdin`. You type in an ASCII code, and the program responds with the alphanumeric
    character corresponding to that code. Here we can simply pipe our input to a `Transform`
    stream, then pipe its output back to `stdout`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个程序，它可以将 **ASCII（美国信息交换标准代码）** 代码转换为 ASCII 字符，从 `stdin` 接收输入。您输入一个 ASCII
    代码，程序将以对应该代码的字母数字字符作出响应。在这里，我们可以简单地将输入传输到 `Transform` 流，然后将其输出传输回 `stdout`：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Interacting with this program might produce an output resembling the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与此程序交互可能会产生类似以下的输出：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A more involved example of a transform stream will be demonstrated in the example
    that ends this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，将演示一个更复杂的转换流示例。
- en: Using PassThrough streams
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PassThrough 流
- en: This sort of stream is a trivial implementation of a `Transform` stream, which
    simply passes received input bytes through to an output stream. This is useful
    if one doesn't require any transformation of the input data, and simply wants
    to easily pipe a `Readable` stream to a `Writable` stream.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流是 `Transform` 流的一个简单实现，它只是将接收到的输入字节传递到输出流。如果不需要对输入数据进行任何转换，只是想要轻松地将 `Readable`
    流传输到 `Writable` 流，这是很有用的。
- en: '`PassThrough` streams have benefits similar to JavaScript''s anonymous functions,
    making it easy to assert minimal functionality without too much fuss. For example,
    it is not necessary to implement an abstract base class, as one does with for
    the `_read` method of a `Readable` stream. Consider the following use of a `PassThrough`
    stream as an event spy:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassThrough`流具有类似于JavaScript的匿名函数的好处，使得可以轻松地断言最小的功能而不需要太多的麻烦。例如，不需要实现一个抽象基类，就像对`Readable`流的`_read`方法所做的那样。考虑以下使用`PassThrough`流作为事件间谍的用法：'
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Normally a Transform or Duplex stream is what you want (where you can set up
    a proper implementation of `_read` and `_write`), but in certain scenarios, such
    as tests, it can be useful to place "watchers" on a stream.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Transform或Duplex流是你想要的（在这里你可以设置`_read`和`_write`的正确实现），但在某些情况下，比如测试中，可以将“观察者”放在流上是有用的。
- en: Creating an HTTP server
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个HTTP服务器
- en: 'HTTP is a stateless data transfer protocol built upon a request/response model:
    clients make requests to servers, which then return a response. As facilitating
    this sort of rapid-pattern network communication is the sort of I/O Node was designed
    to excel at, Node gained early widespread attention as a toolkit for creating
    servers—though it can certainly be used to do much, much more. Throughout this
    book, we will be creating many implementations of HTTP servers, as well as other
    protocol servers, and will be discussing best practices in more depth, contextualized
    within specific business cases. It is expected that you have already had some
    experience doing the same. For both of these reasons, we will quickly move through
    a general overview into some more specialized uses.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是建立在请求/响应模型之上的无状态数据传输协议：客户端向服务器发出请求，服务器然后返回响应。由于促进这种快速模式的网络通信是Node设计的出色之处，Node作为一个用于创建服务器的工具包获得了早期广泛的关注，尽管它当然也可以用于做更多的事情。在本书中，我们将创建许多HTTP服务器的实现，以及其他协议服务器，并将在更深入的上下文中讨论最佳实践，这些上下文是特定的业务案例。预期你已经有一些类似的经验。出于这两个原因，我们将快速地从一般概述中进入一些更专业的用途。
- en: 'At its simplest, an HTTP server responds to connection attempts, and manages
    data as it arrives and as it is sent along. A Node server is typically created
    using the `createServer` method of the `http` module:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，HTTP服务器会响应连接尝试，并在数据到达和发送时进行管理。通常使用`http`模块的`createServer`方法创建一个Node服务器：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The object returned by `http.createServer` is an instance of `http.Server`,
    which extends `EventEmitter`, broadcasting network events as they occur, such
    as a client connection or request. The code prior is a common way to write Node
    servers. However, it is worth pointing out that directly instantiating the `http.Server`
    class is sometimes a useful way to distinguish distinct server/client interactions.
    We will use that format for the following examples.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.createServer`返回的对象是`http.Server`的一个实例，它扩展了`EventEmitter`，在网络事件发生时广播，比如客户端连接或请求。前面的代码是编写Node服务器的常见方式。然而，值得指出的是，直接实例化`http.Server`类有时是区分不同服务器/客户端交互的一种有用方式。我们将在接下来的示例中使用这种格式。'
- en: 'Here, we create a basic server that simply reports when a connection is made,
    and when it is terminated:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个基本的服务器，它只是在连接建立时报告，并在连接终止时报告：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When building multiuser systems, especially authenticated multiuser systems,
    this point in the server-client transaction is an excellent place for client validation
    and tracking code, including setting or reading of cookies and other session variables,
    or the broadcasting of a client arrival event to other clients working together
    in a concurrent real-time application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建多用户系统时，特别是经过身份验证的多用户系统，服务器-客户端事务的这一点是客户端验证和跟踪代码的绝佳位置，包括设置或读取cookie和其他会话变量，或向在并发实时应用程序中共同工作的其他客户端广播客户端到达事件。
- en: 'By adding a listener for requests, we arrive at the more common request/response
    pattern, handled as a `Readable` stream. When a client POSTs some data, we can
    catch that data like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个请求的监听器，我们可以得到更常见的请求/响应模式，作为一个`Readable`流进行处理。当客户端POST一些数据时，我们可以像下面这样捕获这些数据：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Try sending some data to this server using **curl**:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用**curl**向这个服务器发送一些数据：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By using connection events, we can nicely separate our connection handling code,
    grouping it into clearly defined functional domains correctly described as executing
    in response to particular events. In the example above we saw how to set a timer
    that kicks server connections after two seconds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用连接事件，我们可以很好地将我们的连接处理代码分开，将其分组到清晰定义的功能域中，正确地描述为响应特定事件执行的功能域。在上面的示例中，我们看到了如何设置一个定时器，在两秒后启动服务器连接。
- en: If one simply wants to set the number of milliseconds of inactivity before a
    socket is presumed to have timed out, simply use `server.timeout = (Integer)num_milliseconds`.
    To disable socket timeouts, pass a value of `0` (zero).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是想设置在套接字被假定超时之前的不活动毫秒数，只需使用`server.timeout = (Integer)num_milliseconds`。要禁用套接字超时，请传递一个值`0`（零）。
- en: Let's now take a look at how Node's HTTP module can be used to enter into more
    interesting network interactions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Node的HTTP模块如何用于进入更有趣的网络交互。
- en: Making HTTP requests
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出HTTP请求
- en: It is often necessary for a network application to make external HTTP calls.
    HTTP servers are also often called upon to perform HTTP services for clients making
    requests. Node provides an easy interface for making external HTTP calls.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序通常需要进行外部HTTP调用。HTTP服务器也经常被要求为向其发出请求的客户端执行HTTP服务。Node提供了一个简单的接口来进行外部HTTP调用。
- en: 'For example, the following code will fetch the HTML front page of `www.example.org`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将获取`www.example.org`的HTML首页：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, we are working with a `Readable` stream, which can be written
    to a file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们正在使用一个`Readable`流，可以写入文件。
- en: A popular Node module for managing HTTP requests is Mikeal Roger's request: [https://github.com/request/request](https://github.com/request/request)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 管理HTTP请求的一个流行的Node模块是Mikeal Roger的request：[https://github.com/request/request](https://github.com/request/request)
- en: 'Because it is common to use `HTTP.request` in order to `GET` external pages,
    Node offers a shortcut:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因为通常使用`HTTP.request`来`GET`外部页面，Node提供了一个快捷方式：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's now look at some more advanced implementations of HTTP servers, where
    we perform general network services for clients.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些更高级的HTTP服务器实现，其中我们为客户端执行一般的网络服务。
- en: Proxying and tunneling
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和隧道
- en: Sometimes, it is useful to provide a means for one server to function as a proxy,
    or broker, for other servers. This would allow one server to distribute a load
    to other servers, for example. Another use would be to provide access to a secured
    server to users who are unable to connect to that server directly. It is also
    common to have one server answering for more than one URL—using a proxy, that
    one server can forward requests to the right recipient.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为一个服务器提供作为代理或经纪人的功能对其他服务器很有用。这将允许一个服务器将负载分发给其他服务器，例如。另一个用途是为无法直接连接到该服务器的用户提供对安全服务器的访问。一个服务器为多个URL提供答复是很常见的——使用代理，一个服务器可以将请求转发给正确的接收者。
- en: 'Because Node has a consistent streams interface throughout its network interfaces,
    we can build a simple HTTP proxy in just a few lines of code. For example, the
    following program will set up an HTTP server on port `8080` which will respond
    to any request by fetching the front page of a website and piping that page back
    to the client:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node在其网络接口中具有一致的流接口，我们可以用几行代码构建一个简单的HTTP代理。例如，以下程序将在端口`8080`上设置一个HTTP服务器，该服务器将通过获取网站的首页并将该页面传送回客户端来响应任何请求：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Go ahead and start this server, and connect to it. Once this server receives
    the client socket, it is free to push content from any readable stream back to
    the client, and here, the result of `GET` of `www.example.org` is streamed. One
    can easily see how an external content server managing a caching layer for your
    application might become a proxy endpoint, for example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 继续启动这个服务器，并连接到它。一旦这个服务器接收到客户端套接字，它就可以自由地从任何可读流中向客户端推送内容，这里，`www.example.org`的`GET`结果被流式传输。一个外部内容服务器管理应用程序的缓存层可能成为代理端点的例子。
- en: Using similar ideas, we can create a tunneling service, using Node's native
    `CONNECT` support. Tunneling involves using a proxy server as an intermediary
    to communicate with a remote server on behalf of a client. Once our proxy server
    connects to a remote server, it is able to pass messages back and forth between
    that server and a client. This is advantageous when a direct connection between
    a client and a remote server is not possible, or not desired.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的想法，我们可以使用Node的原生`CONNECT`支持创建一个隧道服务。隧道涉及使用代理服务器作为客户端的中间人与远程服务器进行通信。一旦我们的代理服务器连接到远程服务器，它就能在该服务器和客户端之间来回传递消息。当客户端和远程服务器之间无法直接建立连接或不希望建立连接时，这是有利的。
- en: 'First, we''ll set up a proxy server responding to `HTTP` `CONNECT` requests,
    then make a `CONNECT` request to that server. The proxy receives our client''s
    `Request` object, the client''s socket itself, and the head (the first packet)
    of the tunneling stream:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置一个代理服务器来响应`HTTP` `CONNECT`请求，然后向该服务器发出`CONNECT`请求。代理接收我们客户端的`Request`对象，客户端的套接字本身，以及隧道流的头部（第一个数据包）：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once we make a request to our local tunneling server running on port 8080 it
    will set up a remote socket connection to our destination and maintain this "bridge"
    between the remote socket and the (local) client socket. The remote connection
    of course only sees our tunneling server, and in this way clients can connect
    in a sense anonymously to remote services (which isn't always a shady practice!).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们向运行在端口8080上的本地隧道服务器发出请求，它将建立与目的地的远程套接字连接，并保持这个远程套接字和（本地）客户端套接字之间的“桥梁”。远程连接当然只看到我们的隧道服务器，这样客户端可以以某种匿名的方式连接到远程服务（这并不总是一种不正当的做法！）。
- en: HTTPS, TLS (SSL), and securing your server
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS、TLS（SSL）和保护您的服务器
- en: The security of web applications has become a significant discussion topic in
    recent years. Traditional applications normally benefited from the well-tested
    and mature security models designed into the major servers and application stacks
    underpinning major deployments. For one reason or another, web applications were
    allowed to venture into the experimental world of client-side business logic and
    open web services shielded by a diaphanous curtain.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的安全性近年来已成为一个重要的讨论话题。传统应用程序通常受益于主要部署基础的主要服务器和应用程序堆栈中设计成熟的安全模型。出于某种原因，Web应用程序被允许进入客户端业务逻辑的实验世界，并由一层薄薄的帷幕保护着开放的Web服务。
- en: As Node is regularly deployed as a web server, it is imperative that the community
    begins to accept responsibility for securing these servers. HTTPS is a secure
    transmission protocol—essentially encrypted HTTP formed by layering the HTTP protocol
    on top of the SSL/TLS protocol.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node经常部署为Web服务器，社区有责任开始确保这些服务器的安全。HTTPS是一种安全的传输协议——本质上是通过在SSL/TLS协议之上叠加HTTP协议而形成的加密HTTP。
- en: Creating a self-signed certificate for development
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为开发创建自签名证书
- en: In order to support SSL connections, a server will need a properly signed certificate.
    While developing, it is much easier to simply create a self-signed certificate,
    which will allow you to use Node's HTTPS module.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持SSL连接，服务器将需要一个正确签名的证书。在开发过程中，简单创建一个自签名证书会更容易，这将允许您使用Node的HTTPS模块。
- en: 'These are the steps needed to create a certificate for development. The certificate
    we create won''t demonstrate identity, as a certificate from a third party does,
    but it is all we need to use the encryption of HTTPS. From a terminal:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建开发证书所需的步骤。我们创建的证书不会展示身份，就像第三方的证书那样，但这是我们使用HTTPS加密所需要的。从终端：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These keys may now be used to develop HTTPS servers. The contents of these
    files need simply be passed along as options to a Node server:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些密钥现在可以用于开发HTTPS服务器。这些文件的内容只需作为选项传递给Node服务器即可：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Free low-assurance SSL certificates are available from [http://www.startssl.com/](http://www.startssl.com/)
    for cases where self-signed certificates are not ideal during development. Additionally, [https://www.letsencrypt.org](https://www.letsencrypt.org)
    has started an exciting initiative toward providing free certificates for all
    (and a safer web).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，可以从[http://www.startssl.com/](http://www.startssl.com/)获得免费的低保障SSL证书，这是自签名证书不理想的情况。此外，[https://www.letsencrypt.org](https://www.letsencrypt.org)已经开始了一个激动人心的倡议，为所有人提供免费证书（更安全的网络）。
- en: Installing a real SSL certificate
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装真正的SSL证书
- en: In order to move a secure application out of a development environment and into
    an internet-exposed environment, a real certificate will need to be purchased.
    The prices of these certificates has been dropping year by year, and it should
    be easy to find reasonably priced providers of certificates with a high-enough
    level of security. Some providers even offer free person-use certificates.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将安全应用程序从开发环境移出并放入暴露在互联网环境中，需要购买真正的证书。这些证书的价格一年比一年都在下降，应该很容易找到价格合理且安全级别足够高的证书提供商。一些提供商甚至提供免费的个人使用证书。
- en: 'Setting up a professional cert simply requires changing the HTTPS options we
    introduced previously. Different providers will have different processes and filenames.
    Typically, you will need to download or otherwise receive from your provider a
    `private` `.key` file, your signed domain certificate `.crt` file, and a bundle
    describing certificate chains:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设置专业证书只需要更改我们之前介绍的HTTPS选项。不同的提供商将有不同的流程和文件名。通常，您需要从提供商那里下载或以其他方式接收`private`
    `.key`文件，已签名的域证书`.crt`文件，以及描述证书链的捆绑文件：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is important to note that the `ca` parameter must be sent as an *array*,
    even if the bundle of certificates has been concatenated into one file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`ca`参数必须作为*数组*发送，即使证书的捆绑已经连接成一个文件。
- en: The request object
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求对象
- en: 'HTTP request and response messages are similar, consisting of the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求和响应消息是相似的，包括以下内容：
- en: A status line, which for a request would resemble GET/`index.html` HTTP/1.1,
    and for a response would resemble HTTP/1.1 200 OK
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态行，对于请求来说，类似于GET/`index.html` HTTP/1.1，对于响应来说，类似于HTTP/1.1 200 OK
- en: 'Zero or more headers, which in a request might include `Accept-Charset`: `UTF-8
    or From: user@server.com`, and in responses might resemble `Content-Type: text/html
    and Content-Length: 1024`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '零个或多个头部，对于请求可能包括`Accept-Charset`: `UTF-8或From: user@server.com`，对于响应可能类似于`Content-Type:
    text/html和Content-Length: 1024`'
- en: A message body, which for a response might be an HTML page, and for a `POST`
    request might be some form data
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息正文，对于响应可能是一个HTML页面，对于`POST`请求可能是一些表单数据
- en: We've seen how HTTP server interfaces in Node are expected to expose a request
    handler, and how this handler will be passed some form of a request and response
    object, each of which implement a readable or writable stream.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Node中HTTP服务器接口预期暴露一个请求处理程序，以及这个处理程序将被传递一些形式的请求和响应对象，每个对象都实现了可读或可写流。
- en: We will cover the handling of `POST` data and `Header` data in more depth later
    in this chapter. Before we do, let's go over how to parse out some of the more
    straightforward information contained in a request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更深入地讨论`POST`数据和`Header`数据的处理。在此之前，让我们先了解如何解析请求中包含的一些更直接的信息。
- en: The URL module
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL模块
- en: 'Whenever a request is made to an HTTP server, the request object will contain
    URL property, identifying the targeted resource. This is accessible via `request.url`.
    Node''s URL module is used to decompose a typical URL string into its constituent
    parts. Consider the following figure:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每当向HTTP服务器发出请求时，请求对象将包含URL属性，标识目标资源。这可以通过`request.url`访问。Node的URL模块用于将典型的URL字符串分解为其组成部分。请参考以下图示：
- en: '![](img/27aa88e6-d9b5-48b5-bdd3-9e3ce3cdd794.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27aa88e6-d9b5-48b5-bdd3-9e3ce3cdd794.png)'
- en: 'We see how the `url.parse` method decomposes strings, and the meaning of each
    segment should be clear. It might also be clear that the `query` field would be
    more useful if it was itself parsed into key/value pairs. This is accomplished
    by passing `true` as the second argument of to the `parse` method, which would
    change the query field value given above into a more useful key/value map:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`url.parse`方法是如何分解字符串的，每个部分的含义应该是清楚的。也许很明显，如果`query`字段本身被解析为键/值对会更有用。这可以通过将`true`作为`parse`方法的第二个参数来实现，这将把上面给出的查询字段值更改为更有用的键/值映射：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is especially useful when parsing GET requests. There is one final argument
    for `url.parse` that relates to the difference between these two URLs:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这在解析GET请求时特别有用。`url.parse`还有一个与这两个URL之间的差异有关的最后一个参数：
- en: '`http://www.example.org`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://www.example.org`'
- en: '`//www.example.org`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//www.example.org`'
- en: 'The second URL here is an example of a (relatively unknown) design feature
    of the HTTP protocol: the protocol-relative URL (technically, a **network-path
    reference**), as opposed to the more common absolute URL.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二个URL是HTTP协议的一个（相对较少知道的）设计特性的一个例子：协议相对URL（技术上是**网络路径引用**），而不是更常见的绝对URL。
- en: 'To learn more about how network-path references are used to smooth resource
    protocol resolution, visit: [http://tools.ietf.org/html/rfc3986#section-4.2](http://tools.ietf.org/html/rfc3986#section-4.2).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于如何使用网络路径引用来平滑资源协议解析的信息，请访问：[http://tools.ietf.org/html/rfc3986#section-4.2](http://tools.ietf.org/html/rfc3986#section-4.2)。
- en: 'The issue under discussion is this: `url.parse` will treat a string beginning
    with slashes as indicating a path, not a host. For example, `url.parse("//www.example.org")`
    will set the following values in the host and path fields:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正在讨论的问题是：`url.parse`将以斜杠开头的字符串视为路径，而不是主机。例如，`url.parse("//www.example.org")`将在主机和路径字段中设置以下值：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What we actually want is the reverse:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上想要的是相反的：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To resolve this issue, pass `true` as the third argument to `url.parse`, which
    indicates to the method that slashes denote a host, not a path:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，将`true`作为`url.parse`的第三个参数传递，这表明斜杠表示主机，而不是路径：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is also the case that a developer will want to create an URL, such as when
    making requests via `http.request`. The segments of said URL may be spread across
    various data structures and variables, and will need to be assembled. You accomplish this
    by passing an object like the one returned from `url.parse` to the method `url.format`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能开发人员想要创建一个URL，比如通过`http.request`进行请求时。所述URL的各个部分可能分布在各种数据结构和变量中，并且需要被组装。您可以通过将从`url.parse`返回的对象传递给`url.format`方法来实现这一点。
- en: 'The following code will create the URL string `http://www.example.org`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将创建URL字符串`http://www.example.org`：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Similarly, you may also use the `url.resolve` method to generate URL strings
    in the common scenario of requiring the concatenating of a base URL and a path:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您还可以使用`url.resolve`方法来生成URL字符串，以满足需要连接基本URL和路径的常见情况：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The Querystring module
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Querystring模块
- en: As we saw with the `URL` module, query strings often need to be parsed into
    a map of key/value pairs. The `Querystring` module will either decompose an existing
    query string into its parts, or assemble a query string from a map of key/value
    pairs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`URL`模块中看到的，查询字符串通常需要被解析为键/值对的映射。`Querystring`模块将分解现有的查询字符串为其部分，或者从键/值对的映射中组装查询字符串。
- en: 'For example, `querystring.parse("foo=bar&bingo=bango")` will return:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`querystring.parse("foo=bar&bingo=bango")`将返回：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If our query strings are not formatted using the normal `"&"` separator and
    `"="` assignment character, the `Querystring` module offers customizable parsing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的查询字符串没有使用正常的`"&"`分隔符和`"="`赋值字符格式化，`Querystring`模块提供了可定制的解析。
- en: 'The second argument to `Querystring` can be a custom separator string, and
    the third, a custom assignment string. For example, the following will return
    the same mapping as given previously on a query string with custom formatting:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Querystring`的第二个参数可以是自定义的分隔符字符串，第三个参数可以是自定义的赋值字符串。例如，以下将返回与先前给出的具有自定义格式的查询字符串相同的映射：'
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can compose a query string using the `Querystring.stringify` method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Querystring.stringify`方法组成查询字符串：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As with parse, `stringify` also accepts custom separator and assignment arguments:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与解析一样，`stringify`还接受自定义的分隔符和赋值参数：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Query strings are commonly associated with `GET` requests, seen following the
    `?` character. As we saw previously, in these cases, automatic parsing of these
    strings using the `url` module is the most straightforward solution. However,
    strings formatted in such a manner also show up when we're handling `POST` data,
    and in these cases, the `Querystring` module is of real use. We'll discuss this
    usage shortly, but first, something about HTTP headers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串通常与`GET`请求相关联，在`?`字符后面看到。正如我们之前看到的，在这些情况下，使用`url`模块自动解析这些字符串是最直接的解决方案。然而，以这种方式格式化的字符串也会在处理`POST`数据时出现，在这些情况下，`Querystring`模块是真正有用的。我们将很快讨论这种用法，但首先，关于HTTP头部的一些内容。
- en: Working with headers
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理头
- en: Each HTTP request made to a Node server will likely contain useful header information,
    and clients normally expect to receive similar package information from a server.
    Node provides straightforward interfaces for reading and writing headers. We'll
    briefly go over those simple interfaces, clarifying some details. Finally, we'll
    discuss how more advanced header usage might be implemented in Node, studying
    some common network responsibilities a Node server will likely need to accommodate.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 向Node服务器发出的每个HTTP请求可能包含有用的头信息，客户端通常希望从服务器接收类似的包信息。Node提供了简单的接口来读取和写入头信息。我们将简要介绍这些简单的接口，澄清一些细节。最后，我们将讨论如何在Node中实现更高级的头使用，研究Node服务器可能需要适应的一些常见网络责任。
- en: 'A typical request header will look something like the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的请求头将如下所示：
- en: '![](img/b618caa1-547a-47f7-b781-5baaab74e9b1.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b618caa1-547a-47f7-b781-5baaab74e9b1.png)'
- en: Headers are simple key/value pairs. Request keys are always lowercased. You
    may use any case format when setting response keys.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 头是简单的键/值对。请求键始终小写。在设置响应键时，可以使用任何大小写格式。
- en: Reading headers is straightforward. Read header information by examining the
    `request.header` object, which is a 1:1 mapping of the header's key/value pairs.
    To fetch the *accept* header from the previous example, simply read `request.headers.accept`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 读取头很简单。通过检查`request.header`对象来读取头信息，这是头键/值对的一对一映射。要从前面的示例中获取*accept*头，只需读取`request.headers.accept`。
- en: The number of incoming headers can be limited by setting the `maxHeadersCount`
    property of your HTTP server.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置HTTP服务器的`maxHeadersCount`属性，可以限制传入头的数量。
- en: If it is preferred that headers are read programmatically, Node provides the
    `response.getHeader` method, accepting the header key as its first argument.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望以编程方式读取头，Node提供了`response.getHeader`方法，接受头键作为其第一个参数。
- en: 'While request headers are simple key/value pairs, when writing headers, we
    need a more expressive interface. As a response typically must send a status code,
    Node provides a straightforward way to prepare a response status line and header
    group in one command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当写入头时，请求头是简单的键/值对，我们需要更具表现力的接口。由于响应通常必须发送状态码，Node提供了一种简单的方法来准备响应状态行和头组的一条命令：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To set headers individually, you can use `response.setHeader`, passing two
    arguments: the header key, followed by the header value.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独设置头，可以使用`response.setHeader`，传递两个参数：头键，然后是头值。
- en: 'To set multiple headers with the same name, you may pass an array to `response.setHeader`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用相同名称设置多个头，可以将数组传递给`response.setHeader`。
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Occasionally, it may be necessary to remove a response header after that header
    has been *queued*. This is accomplished using `response.removeHeader`, passing
    the header name to be removed as an argument.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在*排队*后可能需要删除响应头。这可以通过使用`response.removeHeader`来实现，将要删除的头名称作为参数传递。
- en: Headers must be written prior to writing a response. It is an error to write
    a header after a response has been sent.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在写入响应之前写入头。在发送响应后写入头是错误的。
- en: Using cookies
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cookies
- en: The HTTP protocol is stateless. Any given request has no information on previous
    requests. For a server, this meant that determining if two requests originated
    from the same browser was not possible. Cookies were invented to solve this problem.
    Cookies are primarily used to share state between clients (usually a browser)
    and a server, existing as small text files stored in browsers.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议是无状态的。任何给定的请求都没有关于先前请求的信息。对于服务器来说，这意味着确定两个请求是否来自同一个浏览器是不可能的。为了解决这个问题，发明了cookie。cookie主要用于在客户端（通常是浏览器）和服务器之间共享状态，存在于浏览器中的小型文本文件。
- en: Cookies are insecure. Cookie information flows between a server and a client
    in plain text. There is any number of tamper points in between. Browsers allow
    easy access to them, for example. This is a good idea, as nobody wants information
    on their browser or local machine to be hidden from them, beyond their control.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie是不安全的。Cookie信息在服务器和客户端之间以纯文本形式流动。中间存在任意数量的篡改点。例如，浏览器允许轻松访问它们。这是一个好主意，因为没有人希望他们的浏览器或本地机器上的信息被隐藏，超出他们的控制。
- en: Nevertheless, cookies are also used rather extensively to maintain state information,
    or pointers to state information, particularly in the case of user sessions or
    other authentication scenarios.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，cookie也被广泛用于维护状态信息，或者维护状态信息的指针，特别是在用户会话或其他身份验证方案的情况下。
- en: It is assumed that you are familiar with how cookies function in general. Here,
    we will discuss how cookies are fetched, parsed, and set by a Node HTTP server.
    We will use the example of a server that echoes back the value of a sent cookie.
    If no cookie exists, the server will create that cookie and instruct the client
    to ask for it again.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您对cookie的一般功能很熟悉。在这里，我们将讨论Node HTTP服务器如何获取、解析和设置cookie。我们将使用一个回显发送cookie值的服务器的示例。如果没有cookie存在，服务器将创建该cookie，并指示客户端再次请求它。
- en: 'Consider the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, we create a server that checks request headers for cookies:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个检查请求头中的cookie的服务器：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that cookies are stored as the `cookie` attribute of `request.headers`.
    If no cookies exist for this domain, we will need to create one, giving it the
    name `session` and a value of `123456`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，cookie存储为`request.headers`的`cookie`属性。如果该域不存在cookie，我们将需要创建一个，给它命名为`session`，值为`123456`：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we have set this cookie for the first time, the client is instructed to
    make another request to this same server, using a 302 Found redirect, instructing
    the client to call our server location again. As there is now a cookie set for
    this domain, the subsequent request will contain our cookie, which we handle next:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们第一次设置了这个cookie，客户端被指示再次向同一服务器发出请求，使用302 Found重定向，指示客户端再次调用我们的服务器位置。由于现在为该域设置了一个cookie，随后的请求将包含我们的cookie，我们将处理它：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now if you visit `localhost:8080` you should see something like this displayed:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你访问`localhost:8080`，你应该看到类似于这样的显示：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Understanding content types
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内容类型
- en: A client will often pass along a request header indicating the expected response
    **MIME** (**Multi-purpose Internet Mail Extension**) type. Clients will also indicate
    the MIME type of a request body. Servers will similarly provide header information
    about the MIME type of a response body. The MIME type for HTML is text/html, for
    example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通常会传递一个请求头，指示预期的响应MIME（多用途互联网邮件扩展）类型。客户端还会指示请求体的MIME类型。服务器将类似地提供有关响应体的MIME类型的头信息。例如，HTML的MIME类型是text/html。
- en: 'As we have seen, it is the responsibility of an HTTP response to set headers
    describing the entity it contains. Similarly, a `GET` request will normally indicate
    the resource type, the MIME type, it expects as a response. Such a request header
    might look like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，HTTP响应有责任设置描述其包含的实体的头。同样，`GET`请求通常会指示资源类型，MIME类型，它期望作为响应。这样的请求头可能看起来像这样：
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It is the responsibility of a server receiving such instructions to prepare
    a body entity conforming to the sent MIME type, and if it is able to do so, it
    should return a similar response header:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接收这样的指令的服务器有责任准备一个符合发送的MIME类型的实体主体，如果能够这样做，它应该返回类似的响应头：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Because requests also identify the specific resource desired (such as `/files/index.html`),
    the server must ensure that the requested resource it is streaming back to the
    client is in fact of the correct MIME type. While it may seem obvious that a resource
    identified by the extension `html` is in fact of the MIME type text/html, this
    is not at all certain—a filesystem does nothing to prevent an image file from
    being given an `html` extension. Parsing extensions is an imperfect method of
    determining file type. We need to do more.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因为请求还标识了所需的特定资源（例如`/files/index.html`），服务器必须确保返回给客户端的请求资源实际上是正确的MIME类型。虽然看起来很明显，由扩展名`html`标识的资源实际上是MIME类型text/html，但这并不确定——文件系统不会阻止将图像文件命名为`html`扩展名。解析扩展名是一种不完美的确定文件类型的方法。我们需要做更多的工作。
- en: 'The UNIX `file` program is able to determine the MIME type of a system file.
    For example, one might determine the MIME type of a file without an extension
    (for example, `resource`) by running this command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX的`file`程序能够确定系统文件的MIME类型。例如，可以通过运行以下命令来确定没有扩展名的文件（例如`resource`）的MIME类型：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We pass arguments instructing `file` to output the MIME type of resource, and
    that the output should be brief (only the MIME type, and no other information).
    This command might return something like `text/plain; charset=us-ascii`. Here,
    we have a tool to solve our problem.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递参数指示`file`输出资源的MIME类型，并且输出应该是简要的（只有MIME类型，没有其他信息）。这个命令可能返回类似于`text/plain;
    charset=us-ascii`的内容。在这里，我们有一个解决问题的工具。
- en: 'For more information about the file utility consult, go to: [http://man7.org/linux/man-pages/man1/file.1.html](http://man7.org/linux/man-pages/man1/file.1.html)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有关文件实用程序的更多信息，请参阅：[http://man7.org/linux/man-pages/man1/file.1.html](http://man7.org/linux/man-pages/man1/file.1.html)
- en: 'Recalling that Node is able to spawn child processes, we have a solution to
    our problem of accurately determining the MIME type of system files. We can use
    the Node command `exec` method of Node''s `child_process` module in order to determine
    the MIME type of a file, like so:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Node能够生成子进程，我们有一个解决方案来准确确定系统文件的MIME类型的问题。我们可以使用Node的`child_process`模块的Node命令`exec`方法来确定文件的MIME类型，就像这样：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This technique is also useful when validating a file streamed in from an external
    location. Following the axiom "never trust the client", it is always a good idea
    to check whether the `Content-type` header of a file posted to a Node server matches
    the actual MIME type of the received file as it exists on the local filesystem.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在从外部位置流入的文件进行验证时也很有用。遵循“永远不要相信客户端”的原则，检查文件发布到Node服务器的`Content-type`头是否与本地文件系统中存在的接收文件的实际MIME类型匹配，这总是一个好主意。
- en: Handling favicon requests
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理favicon请求
- en: When visiting a URL via a browser, you will often notice a little icon in the
    browser tab or in the browser's address bar. This icon is an image named `favicon.ico`,
    and it is fetched on each request. As such, an HTTP GET request normally combines
    two requests—one for the favicon, and another for the requested resource.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过浏览器访问URL时，通常会注意到浏览器标签中或浏览器地址栏中有一个小图标。这个图标是一个名为`favicon.ico`的图像，它在每个请求中都会被获取。因此，一个HTTP
    GET请求通常会结合两个请求——一个用于获取favicon，另一个用于获取请求的资源。
- en: 'Node developers are often surprised by this doubled request. Any implementation
    of an HTTP server must deal with favicon requests. To do so, the server must check
    the request type and handle it accordingly. The following example demonstrates
    one method of doing so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Node开发人员经常对这种重复的请求感到惊讶。任何一个HTTP服务器的实现都必须处理favicon请求。为此，服务器必须检查请求类型并相应地处理它。以下示例演示了一种这样做的方法：
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This code will simply send an empty image stream for the favicon. If there is
    a favicon to send, you would simply push that data through the response stream,
    as we've discussed previously.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将简单地发送一个空的图像流用于favicon。如果有一个要发送的favicon，你可以简单地通过响应流推送这些数据，就像我们之前讨论过的那样。
- en: Handling POST data
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理POST数据
- en: One of the most common `REST` methods used in network applications is POST.
    According to the `REST` specification, a `POST` is not idempotent, as opposed
    to most of the other well-known methods (`GET`, `PUT`, `DELETE`, and so on) that
    are. This is mentioned in order to point out that the handling of `POST` data
    will very often have a consequential effect on an application's state, and should
    therefore be handled with care.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中使用的最常见的`REST`方法之一是POST。根据`REST`规范，`POST`不是幂等的，与大多数其他众所周知的方法（`GET`、`PUT`、`DELETE`等）相反。这是为了指出`POST`数据的处理往往会对应用程序的状态产生重大影响，因此应该小心处理。
- en: We will now discuss the handling of the most common type of `POST` data, that
    which is submitted via forms. The more complex type of `POST`—multipart uploads—will
    be discussed in [Chapter 4](886e76b5-09f3-4ab0-bb0e-191b2c40c299.xhtml), *Using
    Node to Access the Filesystem*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论处理最常见类型的通过表单提交的`POST`数据。更复杂的`POST`类型——多部分上传——将在[第4章](886e76b5-09f3-4ab0-bb0e-191b2c40c299.xhtml)中讨论，*使用Node访问文件系统*。
- en: 'Let''s create a server which will return a form to clients, and echo back any
    data that client submits with that form. We will need to first check the request
    `URL`, determining if this is a form request or a form submission, returning `HTML`
    for a form in the first case, and parsing submitted data in the second:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个服务器，该服务器将向客户端返回一个表单，并回显客户端使用该表单提交的任何数据。我们需要首先检查请求的`URL`，确定这是一个表单请求还是表单提交，在第一种情况下返回表单的`HTML`，在第二种情况下解析提交的数据：
- en: '[PRE55]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that the form we respond with has a single field named `sometext`. This
    form should POST data in the form `sometext=entered_text` to the path `/submit`.
    To catch this data, add the following conditional:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们响应的表单只有一个名为`sometext`的字段。这个表单应该以`sometext=entered_text`的形式将数据POST到路径`/submit`。为了捕获这些数据，添加以下条件：
- en: '[PRE56]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Once our `POST` stream ends we parse the body using `Querystring.parse`, giving
    us a key/value map from which we can pluck the value of the form element with
    name `sometext`, and respond to the client that we have received their data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的`POST`流结束，我们使用`Querystring.parse`解析主体，从中得到一个键/值映射，我们可以从中取出名称为`sometext`的表单元素的值，并向客户端响应我们已经收到他们的数据。
- en: Creating and streaming images with Node
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node创建和流式传输图像
- en: Having gone over the main strategies for initiating and diverting streams of
    data, let's practice the theory by creating a service to stream (aptly named)
    **PNG** (**Portable Network Graphics**) images to a client. This will not be a
    simple file server, however. The goal is to create PNG data streams by piping
    the output stream of an **ImageMagick** convert operation executing in a separate
    process into the response stream of an HTTP connection, where the converter is
    translating another stream of **SVG** (**Scalable Vector Graphics**) data generated
    within a virtualized **DOM** (**Document Object Model**), existing in the Node
    runtime. Let's get started.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 经过对启动和转移数据流的主要策略的讨论，让我们通过创建一个服务来流式传输（恰当地命名为）**PNG**（**可移植网络图形**）图像来实践这个理论。然而，这不会是一个简单的文件服务器。目标是通过将在单独的进程中执行的**ImageMagick**转换操作的输出流管道传输到HTTP连接的响应流中来创建PNG数据流，其中转换器正在将Node运行时中存在的虚拟**DOM**（**文档对象模型**）中生成的另一个**SVG**（**可缩放矢量图形**）数据流进行转换。让我们开始吧。
- en: The full code for this example can be found in your code bundle.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码可以在你的代码包中找到。
- en: Our goal is to use Node to generate pie charts dynamically on a server based
    on client requests. A client will specify some data values, and a PNG representing
    that data in a pie will be generated. We are going to use the **D3.js** library,
    which provides a Javascript API for creating data visualizations, and the **jsdom**
    NPM package, which allows us to create a virtual DOM within a Node process. Additionally
    we'll use **ImageMagick** to transform a **SVG (Scalable Vector Graphics)** representation
    into a **PNG (Portable Network Graphics) **representation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使用Node根据客户端请求动态生成饼图。客户端将指定一些数据值，然后将生成表示该数据的PNG。我们将使用**D3.js**库，该库提供了用于创建数据可视化的Javascript
    API，以及**jsdom** NPM包，该包允许我们在Node进程中创建虚拟DOM。此外，我们将使用**ImageMagick**将**SVG（可缩放矢量图形）**表示转换为**PNG（便携式网络图形）**表示。
- en: Visit [https://github.com/tmpvar/jsdom](https://github.com/tmpvar/jsdom) to
    learn about how **jsdom** works, and [https://d3js.org/](https://d3js.org/) to
    learn about using D3 to generate SVG.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://github.com/tmpvar/jsdom](https://github.com/tmpvar/jsdom)了解**jsdom**的工作原理，访问[https://d3js.org/](https://d3js.org/)了解如何使用D3生成SVG。
- en: Additionally, the PNG we create will be written to a file. If future requests
    pass the same query arguments to our service, we will then be able to rapidly
    pipe the existing rendering immediately, without the overhead of regenerating
    it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们创建的PNG将被写入文件。如果未来的请求将相同的查询参数传递给我们的服务，我们将能够立即传送现有的渲染结果，而无需重新生成。
- en: 'A pie graph represents a range of percentages whose sum fills the total area
    of a circle, visualized as slices. Our service will draw such a graph based on
    the values a client sends. In our system, the client is required to send values
    adding up to 1, such as .5, .3, .2\. Our server, when it receives a request, will
    therefore need to fetch query parameters as well as create a unique key that maps
    to future requests with the same query parameters:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图代表一系列百分比，其总和填满圆的总面积，以切片形式可视化。我们的服务将根据客户端发送的值绘制这样的图表。在我们的系统中，客户端需要发送总和为1的值，例如.5，.3，.2。因此，当服务器收到请求时，需要获取查询参数，并创建一个将来与相同查询参数映射的唯一键：
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we see the URL module in action, pulling out our data values. As well,
    we create a key on these values by first sorting the values, then joining them
    into a string we will use as the filename for our cached pie graph. We sort values
    for this reason: the same graph is achieved by sending .5 .3 .2 and .3 .5 .2\.
    By sorting and joining, these both become the filename .2 .3 .5.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到URL模块正在起作用，提取我们的数据值。此外，我们通过首先对值进行排序，然后将它们连接成一个字符串来创建一个键，我们将使用它作为缓存的饼图的文件名。我们对值进行排序的原因是：通过发送.5
    .3 .2和.3 .5 .2可以得到相同的图表。通过排序和连接，这两者都变成了文件名.2 .3 .5。
- en: In a production application, more work would need to be done to ensure that
    the query is well formed, is mathematically correct, and so on. In our example,
    we assume proper values are being sent.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产应用程序中，需要做更多工作来确保查询格式正确，数学上正确等。在我们的示例中，我们假设正在发送正确的值。
- en: Creating, caching, and sending a PNG representation
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、缓存和发送PNG表示
- en: To start, install ImageMagick: [http://www.imagemagick.org/script/download.php](http://www.imagemagick.org/script/download.php).
    We will spawn a Node process to interface with the installed binary, below.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装ImageMagick：[http://www.imagemagick.org/script/download.php](http://www.imagemagick.org/script/download.php)。我们将生成一个Node进程来与安装的二进制文件进行交互，如下所示。
- en: 'Before we build the graph dynamically, assume that there already exists an
    SVG definition stored on variable `svg`, which will contain a string similar to
    this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态构建图表之前，假设已经存在一个存储在变量`svg`中的SVG定义，它将包含类似于这样的字符串：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To convert that SVG to a PNG we would spawn a child process running the ImageMagick
    convert program, and stream our SVG data to the `stdin` of that process, which
    will output a PNG. In the example that follows we continue this idea to stream
    the generated PNG to the client.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要将SVG转换为PNG，我们将生成一个子进程来运行ImageMagick转换程序，并将我们的SVG数据流式传输到该进程的`stdin`，该进程将输出一个PNG。在接下来的示例中，我们将继续这个想法，将生成的PNG流式传输到客户端。
- en: We'll skip the server boilerplate -- suffice it to say that the server will
    be running on 8080 and will a client calling with some data to graph. What's important
    is how we generate and stream the pie chart back.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过服务器样板代码 -- 只需说明服务器将在8080端口运行，并且将有一个客户端调用一些数据来生成图表。重要的是我们如何生成和流式传输饼图。
- en: 'The client will send some querystring arguments indicating the `values` for
    this graph (such as 4,5,8, the relative size of the slices). What the server will
    do is generate a "virtual DOM" using the jsdom module, into which the D3 graphics
    library is inserted, as well as some javascript (`pie.js` in your code bundle)
    to take the values we have received and draw an SVG pie chart using D3, all within
    this server-side virtual DOM. We then grab that generated SVG code and convert
    it to a PNG using ImageMagick. In order to allow caching we store this PNG using
    a string filename formed from the cache values as a cacheKey, and while writing
    we pipe the streaming PNG back to the client:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将发送一些查询字符串参数，指示此图表的`values`（例如4,5,8，切片的相对大小）。服务器将使用jsdom模块生成一个“虚拟DOM”，其中插入了D3图形库，以及一些javascript（在您的代码包中的`pie.js`），以便获取我们收到的值并使用D3绘制SVG饼图，所有这些都在服务器端虚拟DOM中完成。然后，我们获取生成的SVG代码，并使用ImageMagick将其转换为PNG。为了允许缓存，我们使用缓存值形成一个字符串文件名作为cacheKey存储这个PNG，并在写入时将流式传输的PNG返回给客户端：
- en: '[PRE59]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Recalling our discussion on streams, what is happening here should be clear.
    We generate a DOM (`window`) with jsdom, run the `insertPie` function to generate
    the SVG, and then spawn two streams: one to write the cache file, and one to the
    ImageMagick process. Using a `TransformStream`  (both readable and writable) we
    implement its abstract `_transform` method to expect input from `stdout` of our
    ImageMagick stream, write that data to the local filesystem, and then re-push
    the data back into the stream, which is piped forward onto the response stream.
    We can now achieve the desired stream chaining:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们关于流的讨论，这里发生的事情应该是清楚的。我们使用jsdom生成一个DOM（`window`），运行`insertPie`函数生成SVG，然后生成两个流：一个用于写入缓存文件，一个用于ImageMagick进程。使用`TransformStream`（可读和可写）我们实现了其抽象的`_transform`方法，以期望从ImageMagick流的`stdout`输入数据，将该数据写入本地文件系统，然后重新将数据推回流中，然后将其传送到响应流。我们现在可以实现所需的流链接：
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The client receives a pie graph, and a copy is written on the local file cache.
    In cases where the requested pie chart has already been rendered it can be directly
    streamed from a filesystem:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端接收到一个饼图，并且一个副本被写入到本地文件缓存中。在请求的饼图已经被渲染的情况下，它可以直接从文件系统中进行流式传输。
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you start the server and paste the following into your browser:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启动服务器并将以下内容粘贴到浏览器中：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should see a pie chart displayed:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个饼图显示出来：
- en: '![](img/53cbc2e5-db0f-4769-8b62-ea7fddcc0431.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53cbc2e5-db0f-4769-8b62-ea7fddcc0431.png)'
- en: While somewhat artificial, hopefully this shows how chains of different processes
    can be connected via streams, avoiding any intermediate storage in memory, which
    can be especially useful when passing data through and out of a highly trafficked
    network server.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些不自然，但希望这能展示不同进程链如何通过流连接，避免在内存中存储任何中间数据，特别是在通过高流量网络服务器传递数据时尤其有用。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we have learned, Node's designers have succeeded in creating a simple, predictable,
    and convenient solution to the challenging design problem of enabling efficient
    I/O between disparate sources and targets, while keeping code easy to manage.
    Its abstract Stream interface facilitates the instantiation of consistent readable
    and writable interfaces, and the extension of this interface into HTTP requests
    and responses, the filesystem, child processes, and other data channels makes
    stream programming with Node a pleasant experience.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所了解的，Node的设计者成功地创建了一个简单、可预测且方便的解决方案，解决了在不同来源和目标之间实现高效I/O的挑战性设计问题，同时保持了易于管理的代码。它的抽象流接口促进了一致的可读和可写接口的实例化，以及将这个接口扩展到HTTP请求和响应、文件系统、子进程和其他数据通道，使得使用Node进行流编程成为一种愉快的体验。
- en: Now that we've learned how to set up HTTP servers to handle streams of data
    arriving from many simultaneously connected clients, and how to feed those clients
    buffets of buffered streams, we can begin to engage more deeply with the task
    of building enterprise-grade concurrent real-time systems with Node.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何设置HTTP服务器来处理从许多同时连接的客户端接收的数据流，以及如何向这些客户端提供缓冲流的数据，我们可以开始更深入地参与使用Node构建企业级并发实时系统的任务。
