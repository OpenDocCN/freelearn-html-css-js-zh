- en: 2\. Declaration Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 声明文件
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter gets you started with declaration files in TypeScript. You will
    learn how to work with declaration files, including how to build your own declaration
    files from scratch, and then work with types in external libraries. By the end
    of this chapter, you will be able to create declaration files from scratch, implement
    common development patterns for creating declaration files, and produce type checking
    when working with third-party NPM code libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你开始使用 TypeScript 的声明文件。你将学习如何使用声明文件，包括如何从头开始构建自己的声明文件，然后在外部库中使用类型。到本章结束时，你将能够从头开始创建声明文件，实现创建声明文件的常见开发模式，并在与第三方
    NPM 代码库合作时进行类型检查。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you will learn about TypeScript declaration files. Declaration
    files give you the ability to give TypeScript more information about how a function
    or class is structured.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 TypeScript 声明文件。声明文件使 TypeScript 能够获取有关函数或类结构的更多信息。
- en: Why is it important to understand how declaration files work? Technically, declaration
    files speak directly to the core motivations for why TypeScript is becoming so
    popular. One of the common rationales for using TypeScript is because it guides
    developers through the application process. Let's walk through a real-world example
    as a case study.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么理解声明文件的工作原理很重要？从技术上讲，声明文件直接针对 TypeScript 变得如此流行的核心动机。使用 TypeScript 的一个常见理由是它指导开发者通过应用程序的过程。让我们通过一个真实世界的案例研究来探讨这个问题。
- en: In pure JavaScript, if we start working with a code library that we've never
    used before that formats dates, such as **Moment JS**, we would have to start
    by looking through the documentation in order to know what type of data we can
    pass to the Moment JS functions. When working with a new library, it is tedious
    work to figure out requirements, such as how many function arguments are required
    for each function and what data type each argument needs to be.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯 JavaScript 中，如果我们开始使用一个我们之前从未使用过的日期格式化代码库，例如 **Moment JS**，我们首先需要查阅文档以了解我们可以传递给
    Moment JS 函数的数据类型。当与一个新库合作时，确定需求，例如每个函数需要多少个函数参数以及每个参数需要的数据类型，是一项繁琐的工作。
- en: With the declaration files, however, TypeScript informs the text editor of the
    requirements for every function that a library has. So, instead of having to rely
    solely on documentation and Google searches, the text editor itself informs the
    developer how to work with each function. For example, the text editor, with the
    help of TypeScript, would inform us that the Moment JS format function takes in
    zero to one arguments, and the optional argument needs to be a string. And declaration
    files make all of this possible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用声明文件时，TypeScript 会通知文本编辑器库中每个函数的要求。因此，我们不必仅仅依赖文档和 Google 搜索，文本编辑器本身就会告诉开发者如何使用每个函数。例如，借助
    TypeScript 的帮助，文本编辑器会告诉我们 Moment JS 格式函数接受零到一 个参数，并且可选参数需要是一个字符串。声明文件使得这一切成为可能。
- en: Declaration Files
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明文件
- en: 'Anytime we''re asked to write additional boilerplate code, our first question
    is: why is it important to do this? With that in mind, before we walk through
    creating and managing declaration files, let''s first analyze the role of declaration
    files in the development process.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们被要求编写额外的样板代码时，我们的第一个问题是：为什么这样做很重要？考虑到这一点，在我们开始创建和管理声明文件之前，让我们首先分析声明文件在开发过程中的作用。
- en: The entire reason why we use TypeScript in the first place is to give our applications
    a specified structure based on types. Declaration files extend this functionality
    by allowing us to define the shape of our programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初使用 TypeScript 的全部原因是为了给我们的应用程序提供一个基于类型的指定结构。声明文件通过允许我们定义程序的形状来扩展这一功能。
- en: In this section, we will walk through two ways to work with declaration files.
    The first approach will be to create our own declaration files from scratch. This
    is a great place to start since it provides insight into how the declaration process
    works. In the second part, we will see how we can integrate types into third-party
    NPM libraries.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两种处理声明文件的方法。第一种方法是从头开始创建我们的声明文件。这是一个很好的起点，因为它提供了对声明过程如何工作的洞察。在第二部分，我们将看到如何将类型集成到第三方
    NPM 库中。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Declaration files are not a new concept in the programming world. The same principle
    has been used for decades in older programming languages such as Java, C, and
    C++.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 声明文件在编程世界中不是一个新概念。相同的原理已经在上个世纪的编程语言，如 Java、C 和 C++ 中使用了数十年。
- en: 'Before we get into this chapter''s example project, let''s look at the core
    elements that comprise a declaration file in TypeScript. Consider the following
    code, which assigns a string value to a variable:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本章的示例项目之前，让我们看看构成 TypeScript 声明文件的核心元素。考虑以下代码，它将一个字符串值赋给一个变量：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code in TypeScript will generate a compiler warning that says
    `Cannot find name ''firstName''`, which can be seen in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 TypeScript 代码将生成一个编译警告，指出 `Cannot find name 'firstName'`，这在以下截图中可以看到：
- en: '![Figure 2.1: Compiler error when TypeScript cannot find a variable declaration'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1：TypeScript 无法找到变量声明时的编译错误]'
- en: '](img/B14508_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_02_01.jpg]'
- en: 'Figure 2.1: Compiler error when TypeScript cannot find a variable declaration'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：TypeScript 无法找到变量声明时的编译错误
- en: 'This error is shown because whenever we attempt to assign a value to a variable,
    TypeScript looks for where a variable name is defined. We can fix this by utilizing
    the `declare` keyword. The following code will correct the error that we encountered
    in the previous case:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误显示，因为每次我们尝试给变量赋值时，TypeScript 都会寻找变量名定义的位置。我们可以通过使用 `declare` 关键字来修复这个问题。以下代码将纠正我们在上一个案例中遇到的错误：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see in the following screenshot, the compiler warning disappeared
    with the use of the `declare` keyword:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，使用 `declare` 关键字后，编译警告消失了：
- en: '![Figure 2.2: Example of a variable being defined in TypeScript'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.2：TypeScript 中定义变量的示例]'
- en: '](img/B14508_02_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_02_02.jpg]'
- en: 'Figure 2.2: Example of a variable being defined in TypeScript'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：TypeScript 中定义变量的示例
- en: 'Now, that may not seem like a big deal, because we could accomplish the same
    goal by simply defining a `let` variable, such as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能看起来不是什么大问题，因为我们可以通过简单地定义一个 `let` 变量，例如以下内容，来达到相同的目的：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code would not generate an error when viewed in the Visual Studio
    Code editor.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 编辑器中查看上述代码时，不会生成错误。
- en: So, what is the point of using `declare`? As we build out complex modules, the
    declare process allows us to describe the complete shape of our modules in a way
    that cannot be done by simply defining a variable. Now that you know the role
    of declaration files along with the basic syntax, let's walk through the full
    workflow of creating a declaration file from scratch in the following exercise.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用 `declare` 的目的是什么？随着我们构建复杂的模块，声明过程允许我们以无法通过简单地定义一个变量的方式来描述我们模块的完整结构。现在你已经了解了声明文件的作用以及基本语法，让我们在接下来的练习中从头开始创建一个声明文件。
- en: 'Exercise 2.01: Creating a Declaration File from Scratch'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.01：从头创建声明文件
- en: In this exercise, we'll create a declaration file from scratch. We'll declare
    file conventions, import, and then use declared files. Consider that you are developing
    a web app that requires users to register themselves with credentials such as
    email, user roles, and passwords. The data types of these credentials will be
    stated in the declaration file that we'll be creating. A user won't be allowed
    to log in if they fail to enter the correct credentials.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从头开始创建一个声明文件。我们将声明文件约定、导入，然后使用已声明的文件。假设你正在开发一个需要用户使用电子邮件、用户角色和密码等凭证注册自己的网络应用程序。这些凭证的数据类型将在我们创建的声明文件中声明。如果用户未能输入正确的凭证，则不允许用户登录。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/bBzat](https://packt.link/bBzat).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在以下位置找到：[https://packt.link/bBzat](https://packt.link/bBzat)。
- en: 'Perform the following steps to implement this exercise:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此练习：
- en: Open the Visual Studio Code editor.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code 编辑器。
- en: Create a new directory and then create a file named `user.ts`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录，然后创建一个名为 `user.ts` 的文件。
- en: 'Start the TypeScript compiler and have it watch for changes to the file with
    the following terminal compile command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 TypeScript 编译器，并使用以下终端编译命令监视文件的变化：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows how the command appears inside the terminal:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了命令在终端中的外观：
- en: '![Figure 2.3: Running the TypeScript compiler with the watch flag'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.3：使用 watch 标志运行 TypeScript 编译器]'
- en: '](img/B14508_02_03.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14508_02_03.jpg]'
- en: 'Figure 2.3: Running the TypeScript compiler with the watch flag'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.3：使用watch标志运行TypeScript编译器
- en: It's fine to leave this file empty for now. We'll start building out our implementation
    shortly. Now let's create our declaration file.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前可以留这个文件为空。我们很快就会开始构建我们的实现。现在让我们创建我们的声明文件。
- en: Create a directory called `types/` at the root of our program and then create
    a file inside it called `AuthTypes.d.ts`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们程序的根目录下创建一个名为`types/`的目录，然后在其中创建一个名为`AuthTypes.d.ts`的文件。
- en: 'Our project''s directory should now look like this:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的项目目录现在应该看起来像这样：
- en: '![Figure 2.4: AuthTypes file structure'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.4：AuthTypes文件结构'
- en: '](img/B14508_02_04.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_02_04.jpg)'
- en: 'Figure 2.4: AuthTypes file structure'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.4：AuthTypes文件结构
- en: Note
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Traditionally, declaration files are kept in their own directory called `types/`
    and are then imported by the modules that they are defining. It's also the standard
    convention to use the file extension of `.d.ts` instead of `.ts` for your declaration
    files.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传统上，声明文件被保存在一个名为`types/`的单独目录中，然后由它们定义的模块导入。使用`.d.ts`文件扩展名而不是`.ts`作为声明文件的扩展名也是标准约定。
- en: 'Within the new declaration file, define the shape of our `AuthTypes` module.
    Use the `declare` keyword at the top of the file. This tells TypeScript that we
    are about to describe how the `AuthTypes` module should be structured:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的声明文件中，定义我们的`AuthTypes`模块的形状。在文件顶部使用`declare`关键字。这告诉TypeScript我们即将描述`AuthTypes`模块应该如何结构化：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, another bit of syntax that might be different than what
    you''re used to writing is that we wrap the module name in quotation marks. When
    we implement the program, you''ll see that if we remove the quotation marks, we
    won''t be able to import the module. Inside the module, we can place any number
    of exports that we want the module to have. One of the most important concepts
    to keep in mind is that declaration files do not have any implementation code;
    they simply describe the types and structure for the elements used in the module.
    The following screenshot gives a visual representation of the code:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，可能有一段语法与您习惯的写法不同，那就是我们将模块名用引号括起来。当我们实现程序时，您会看到如果我们去掉引号，我们就无法导入模块。在模块内部，我们可以放置任何数量的导出，我们希望模块拥有的。需要记住的一个重要概念是，声明文件不包含任何实现代码；它们只是描述了模块中使用的元素的类型和结构。以下截图给出了代码的视觉表示：
- en: '![Figure 2.5: AuthTypes interface'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.5：AuthTypes接口'
- en: '](img/B14508_02_05.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_02_05.jpg)'
- en: 'Figure 2.5: AuthTypes interface'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.5：AuthTypes接口
- en: The compiler messages suggest that the import should happen successfully as
    there have not been any errors up to this point.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编译器消息表明导入应该成功，因为到目前为止没有出现任何错误。
- en: 'In this step, we''re exporting a user interface that defines two data points:
    email and roles. As far as the data types are concerned, the `email` attribute
    needs to be a string, and `roles` needs to be an array filled with strings. Such
    type definitions will ensure that anyone using this module will be informed immediately
    if they attempt to use the incorrect data structure.'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，我们导出一个用户界面，它定义了两个数据点：电子邮件和角色。就数据类型而言，`email`属性需要是一个字符串，而`roles`需要是一个填充字符串的数组。这样的类型定义将确保任何使用此模块的人如果尝试使用不正确的数据结构，会立即得到通知。
- en: Now that we have defined the `AuthTypes` module, we need to import it into our
    TypeScript file so that we can use it. We're going to use the reference import
    process to bring the file into our program.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`AuthTypes`模块，我们需要将其导入到我们的TypeScript文件中，以便我们可以使用它。我们将使用引用导入过程将文件引入我们的程序中。
- en: 'Go to the `user.ts` file and add the following two lines of code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`user.ts`文件，并添加以下两行代码：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code in the editor will look something like this:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑器中的代码看起来可能像这样：
- en: '![Figure 2.6: Importing a declaration file'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.6：导入声明文件'
- en: '](img/B14508_02_06.jpg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_02_06.jpg)'
- en: 'Figure 2.6: Importing a declaration file'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.6：导入声明文件
- en: The first line in the preceding code will make `AuthTypes.d.ts` available to
    our program, and the second line imports the module itself. Obviously, you can
    use any variable name for the import statement that you prefer. In this code,
    we're importing the `AuthTypes` module and storing it in the `auth` keyword.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码中的第一行将使`AuthTypes.d.ts`对我们的程序可用，第二行导入模块本身。显然，您可以为导入语句使用您喜欢的任何变量名。在这段代码中，我们导入`AuthTypes`模块并将其存储在`auth`关键字中。
- en: With our module imported, we can now start building the implementation for our
    program. We'll start out by defining a variable and assigning it to our user interface
    type that we defined in the declaration files.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入我们的模块后，我们现在可以开始构建程序的实现了。我们将从定义一个变量并将其分配给我们在声明文件中定义的用户界面类型开始。
- en: 'Add the following code to the `user.ts` file:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `user.ts` 文件中：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The updated code of `user.ts` file will look something like this:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`user.ts` 文件的更新代码将看起来像这样：'
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we've done here is quite impressive. We've essentially created our own
    type/interface in a separate file, imported it, and told the TypeScript compiler
    that our new variable is going to be of the `User` type.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里所做的是相当令人印象深刻的。我们实际上在单独的文件中创建了自己的类型/接口，导入它，并告诉 TypeScript 编译器我们的新变量将是 `User`
    类型。
- en: 'Add the actual values of `email` and `roles` for the `jon` variable with the
    help of the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码，通过添加以下代码帮助 `jon` 变量的 `email` 和 `roles` 实际值：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the required shape in place, the program compiles properly, and you can
    perform any tasks that you need to do.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在放置了必需的形状后，程序可以正确编译，你可以执行任何你需要做的任务。
- en: 'Create another `User` and see how we can work with optional attributes. Add
    the following code to add details of the user `alice`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个 `User` 并看看我们如何处理可选属性。将以下代码添加到添加用户 `alice` 的详细信息：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's imagine that we sometimes keep track of how a user found our application.
    Not all users will have this attribute though, so we'll need to make it optional
    without breaking the other user accounts. You can mark an attribute as optional
    by adding a question mark before the colon.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们有时会跟踪用户是如何找到我们的应用的。并不是所有用户都会有这个属性，所以我们需要在不破坏其他用户账户的情况下将其设置为可选。你可以通过在冒号前添加问号来标记一个属性为可选。
- en: 'Add a `source` attribute to the declaration file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明文件中添加 `source` 属性：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Update our `alice` user with a `source` value of `facebook`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `source` 值 `facebook` 更新我们的 `alice` 用户：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that the `jon` variable still works perfectly fine, even without the
    `source` value. This helps us to build flexible interfaces for our programs that
    define both optional and required data points.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，即使没有 `source` 值，`jon` 变量仍然工作得很好。这有助于我们为程序构建灵活的接口，这些接口定义了可选和必需的数据点。
- en: 'Open the terminal and run the following command to generate a JavaScript file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行以下命令以生成 JavaScript 文件：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s now look at the generated `user.js` file, which can be seen in the following screenshot:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们看看生成的 `user.js` 文件，如下面的截图所示：
- en: '![Figure 2.7: Declaration file rules not added to the generated JavaScript
    code'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7：未添加到生成的 JavaScript 代码中的声明文件规则](img/B14508_02_07.jpg)'
- en: '](img/B14508_02_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7：未添加到生成的 JavaScript 代码中的声明文件规则](img/B14508_02_07.jpg)'
- en: 'Figure 2.7: Declaration file rules not added to the generated JavaScript code'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：未添加到生成的 JavaScript 代码中的声明文件规则
- en: 'Well, that''s interesting. There is literally not a single mention of the declaration
    file in the generated JavaScript code. This brings up a very important piece of
    knowledge to know when it comes to declaration files and TypeScript in general:
    declaration files are used solely for the benefit of the developer and are only
    utilized by the IDE.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很有趣。在生成的 JavaScript 代码中，实际上没有提到声明文件。这让我们知道，当涉及到声明文件和 TypeScript 时，这是一个非常重要的知识点：声明文件仅用于开发者的利益，并且仅由
    IDE 利用。
- en: Declaration files are completely bypassed when it comes to what is rendered
    in the program. And with this in mind, hopefully the goal of declaration files
    is becoming clearer. The better your declaration files are, the easier it will
    be for the IDE to understand your program and for yourself and other developers
    to work with your code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到程序中渲染的内容时，声明文件完全被绕过。考虑到这一点，希望声明文件的目标变得更加清晰。你的声明文件越好，IDE 理解你的程序以及你自己和其他开发者与你代码合作就会越容易。
- en: Exceptions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'Let''s see what happens when we don''t follow the rules of our interface. Remember
    in the previous exercise that our interface required two data elements (`email`
    and `roles`) and that they need to be of the `string` and `Array<string>` types.
    So, watch what happens when we don''t implement the proper data type with the
    following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们不遵循接口规则时会发生什么。记住在之前的练习中，我们的接口需要两个数据元素（`email` 和 `roles`），并且它们需要是 `string`
    和 `Array<string>` 类型。所以，看看当我们不使用以下代码实现适当的数据类型时会发生什么：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will generate the following compiler error, as shown in the following
    screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下编译器错误，如下面的截图所示：
- en: '![Figure 2.8: TypeScript showing the required data types for an object'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8：TypeScript显示对象的必需数据类型]'
- en: '](img/B14508_02_08.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_02_08.jpg]'
- en: 'Figure 2.8: TypeScript showing the required data types for an object'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：TypeScript显示对象的必需数据类型
- en: That is incredibly helpful. Imagine that you are working with a library that
    you've never used before. If you were using vanilla JavaScript, this implementation
    would silently fail and would force you to dig through the library's source code
    to see what structure it required.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有帮助。想象一下，你正在使用一个之前从未使用过的库。如果你使用的是纯JavaScript，这个实现将静默失败，并迫使你挖掘库的源代码以查看它需要什么结构。
- en: 'This compiler error makes sense, and in a real-life application, such as a
    `AuthTypes` with the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编译器错误是有意义的，在现实生活中的应用中，例如以下代码的`AuthTypes`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see that the compiler will move the error message up to the `jon` variable
    name. If you hover over it, or look at the terminal output, you''ll see the error
    shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到编译器会将错误信息移动到`jon`变量名。如果你悬停在它上面，或者查看终端输出，你将看到以下屏幕截图中的错误：
- en: '![Figure 2.9: TypeScript showing the required attributes for an object'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9：TypeScript显示对象的必需属性]'
- en: '](img/B14508_02_09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_02_09.jpg]'
- en: 'Figure 2.9: TypeScript showing the required attributes for an object'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：TypeScript显示对象的必需属性
- en: This is an incredibly useful functionality. If you're new to development, this
    may not seem like a very big deal. However, this type of information is the exact
    reason why TypeScript continues to grow in popularity. Error messages such as
    this instantly provide the information that we need in order to fix the bug and
    work with the program. In the preceding screenshot, the message is telling us
    that the program won't compile as we are missing a required value, namely, `roles`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其有用的功能。如果你是新手开发者，这可能看起来不是什么大问题。然而，这种类型的信息正是TypeScript继续受到欢迎的精确原因。像这样的错误信息立即提供了我们需要的信息，以便修复错误并处理程序。在前面的屏幕截图中，信息告诉我们程序无法编译，因为我们缺少一个必需的值，即`roles`。
- en: Now that we have built out our own declaration file from scratch, it's time
    to move on and see how declaration files are utilized by other libraries.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从头开始构建了自己的声明文件，是时候继续前进，看看其他库是如何利用声明文件的。
- en: Third-Party Code Libraries
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方代码库
- en: Depending on the types of applications that you build, you may never need to
    build your own declaration files. However, if you're using TypeScript and working
    with third-party modules, you will need to understand how declaration files work
    because you will then be able to work seamlessly with external libraries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你构建的应用程序类型，你可能永远不需要构建自己的声明文件。然而，如果你使用TypeScript并与第三方模块一起工作，你需要了解声明文件是如何工作的，因为这样你就可以无缝地与外部库一起工作。
- en: DefinitelyTyped
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DefinitelyTyped
- en: Let's jump back in time for a moment. When TypeScript was originally developed,
    there was quite a bit of excitement around the idea of integrating types into
    JavaScript applications. However, developers began to get frustrated, because
    even though they were building their programs with types, every time that they
    imported an external library, such as lodash, they were forced to write code with
    no type signatures and little to no IDE guidance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时回到过去。当TypeScript最初开发时，将类型集成到JavaScript应用程序中的想法引起了极大的兴奋。然而，开发者开始感到沮丧，因为他们虽然用类型构建程序，但每次他们导入外部库，如lodash，他们都被迫编写没有类型签名和几乎没有任何IDE指导的代码。
- en: Essentially, this meant that each time we were to call a function from an external
    library, we didn't have a high level of assurance that we were working with it
    properly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着每次我们调用外部库中的函数时，我们都没有很高的信心认为我们正在正确地使用它。
- en: Thankfully, the open source community had the answer, and the DefinitelyTyped
    library was created. DefinitelyTyped is a very large repository that contains
    literally thousands of declaration files for JavaScript code libraries. This means
    that libraries such as `react`, `lodash`, and pretty much every other popular
    library has a full set of declaration files that we can use in our TypeScript
    programs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，开源社区已经有了答案，并创建了DefinitelyTyped库。DefinitelyTyped是一个非常大的仓库，包含成千上万的JavaScript代码库的声明文件。这意味着像`react`、`lodash`以及几乎所有其他流行的库都有完整的声明文件，我们可以在TypeScript程序中使用。
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on DefinitelyTyped, visit [https://definitelytyped.org](https://definitelytyped.org).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于DefinitelyTyped的信息，请访问[https://definitelytyped.org](https://definitelytyped.org)。
- en: Analyzing an External Declaration File
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析外部声明文件
- en: 'Before we learn how to import and use types with external libraries, let''s
    peek into what they look like:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何导入和使用外部库中的类型之前，让我们先看看它们的样子：
- en: '![Figure 2.10: Example of how DefinitelyTyped uses declaration files'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10：DefinitelyTyped使用声明文件的示例](img/B14508_02_10.jpg)'
- en: '](img/B14508_02_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_02_10.jpg](img/B14508_02_10.jpg)'
- en: 'Figure 2.10: Example of how DefinitelyTyped uses declaration files'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：DefinitelyTyped使用声明文件的示例
- en: In the preceding screenshot, if you look at the `lodash` declaration file for
    the array data structure, you'll see that a single declaration file is over 2,000
    lines long. That can be a little intimidating to look at, so let's try to simplify
    it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，如果你查看数组数据结构的`lodash`声明文件，你会看到单个声明文件超过2,000行长。这可能会让人有些畏惧，所以让我们试着简化它。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`lodash` is a utility library that provides functionality for working with
    objects, strings, arrays, and suchlike. The `lodash` library''s declaration file
    for the array data structure, as shown in the preceding screenshot, can be found
    here: [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/lodash/common/array.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/lodash/common/array.d.ts).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`lodash`是一个提供与对象、字符串、数组等一起工作的功能的实用库。如前所述的屏幕截图所示，`lodash`库的数组数据结构声明文件可以在这里找到：[https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/lodash/common/array.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/lodash/common/array.d.ts)。'
- en: You'll be pleased to know that the elements in the preceding declaration file
    are exactly what we built out in *Exercise 1.01:* *Creating a Declaration File
    from Scratch*. It starts by declaring a `module` instance, and from that point,
    it lists out interfaces for each of the elements that utilize the array data structure.
    In fact, if you dissect the code, you'll see that `lodash` provides three interfaces
    for each of the functions in the library. You don't have to know what these do;
    however, it is helpful to realize that you can provide as many interfaces as needed
    when you're building your own code libraries.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会很高兴地知道，前面声明文件中的元素与我们*练习1.01*中构建的完全一样：*从头开始创建声明文件*。它从声明一个`module`实例开始，然后从这个点开始，列出使用数组数据结构的每个元素的接口。实际上，如果你剖析代码，你会看到`lodash`为库中的每个函数提供了三个接口。你不必知道这些接口的作用；然而，当你构建自己的代码库时，意识到你可以提供所需数量的接口是有帮助的。
- en: 'Let''s now look at the interface for the `last` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`last`函数的接口：
- en: '![Figure 2.11: How lodash implements interfaces'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11：lodash实现接口的方式](img/B14508_02_11.jpg)'
- en: '](img/B14508_02_11.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_02_11.jpg](img/B14508_02_11.jpg)'
- en: 'Figure 2.11: How lodash implements interfaces'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：lodash实现接口的方式
- en: This is a good function to look at, because we'll use it when we get to the
    example for this section. You can see that the majority of the interface is actually
    a comment. If you've never seen this syntax before, it is using JSDoc syntax.
    This is very helpful, because IDEs such as Visual Studio Code will pull the comment,
    parameters, and return type directly into the IntelliSense interface. This means
    that when we start typing the `last` function when working with `lodash`, the
    IDE will automatically pull in the comment data so we can easily read how to use
    the function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的函数来查看，因为当我们到达本节的示例时，我们会使用它。你可以看到接口的大部分实际上是一个注释。如果你以前从未见过这种语法，它使用的是JSDoc语法。这非常有帮助，因为像Visual
    Studio Code这样的IDE会直接将注释、参数和返回类型拉入IntelliSense界面。这意味着当我们开始使用`lodash`工作时输入`last`函数时，IDE会自动拉入注释数据，这样我们就可以轻松地阅读如何使用该函数。
- en: After that, the declaration is pretty basic. It simply describes the shape of
    the last function, specifically, that it takes a list of values as the argument
    and then returns either `T` or `undefined`. Don't worry about all the references
    to `T`; you'll learn about what this represents in *Chapter 8*, *Generics*. For
    now, just know that it means that it is returning a value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，这个声明相当基础。它只是简单地描述了最后一个函数的形状，具体来说，它接受一个值列表作为参数，然后返回`T`或`undefined`。不用担心所有关于`T`的引用；你将在第8章*泛型*中了解到它代表什么。现在，只需知道这意味着它正在返回一个值。
- en: Following the same pattern from when we created the declaration file from scratch,
    in the next section, let's create a new TypeScript project and walk through a
    practical example of why types are needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们从头创建声明文件的相同模式，在下一节中，让我们创建一个新的 TypeScript 项目，并通过一个实际例子来了解为什么需要类型。
- en: 'Exercise 2.02: Creating Types with External Libraries'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.02：使用外部库创建类型
- en: In this exercise, we'll install types and integrate our types with external
    libraries. We will also be exploring a scenario wherein we'll check how the function
    behaves when the wrong type of parameter is passed to it. You'll need to start
    with an empty directory for this exercise.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将安装类型并将我们的类型与外部库集成。我们还将探索一个场景，其中我们将检查当传递给函数的错误类型参数时函数的行为。为此练习，您需要从一个空目录开始。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/k7Wbt](https://packt.link/k7Wbt).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在此处找到：[https://packt.link/k7Wbt](https://packt.link/k7Wbt)。
- en: 'Perform the following steps to implement this exercise:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此练习：
- en: Open the Visual Studio Code editor.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code 编辑器。
- en: 'Create an empty directory on your computer and run the following command to
    create a new NPM project:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的计算机上创建一个空目录，并运行以下命令以创建一个新的 NPM 项目：
- en: '[PRE15]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code will generate a `package.json` file.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码将生成一个 `package.json` 文件。
- en: 'To install the Lodash library, open the terminal and type the following command:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装 Lodash 库，打开终端并输入以下命令：
- en: '[PRE16]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding command installs the Lodash library. The `package.json` file
    should now look something like this, with `lodash` installed in the dependencies list:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的命令安装了 Lodash 库。`package.json` 文件现在应该看起来像这样，其中 `lodash` 已安装到依赖列表中：
- en: '![Figure 2.12: The generated package.json file'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.12: The generated package.json file](img/B14508_02_12.jpg)'
- en: '](img/B14508_02_12.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14508_02_12.jpg](img/B14508_02_12.jpg)'
- en: 'Figure 2.12: The generated package.json file'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.12：生成的 package.json 文件
- en: 'Create a file in that directory named `lodash_examples.ts`, start the TypeScript
    compiler, and have it watch for changes. Inside of the new `.ts` file, add the
    following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该目录中创建一个名为 `lodash_examples.ts` 的文件，启动 TypeScript 编译器，并让它监视更改。在新的 `.ts` 文件中，添加以下代码：
- en: '[PRE17]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the preceding program in the terminal by writing the following commands:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行前面的程序，输入以下命令：
- en: '[PRE18]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The console generates an output of `3`, as you can see in the following screenshot:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制台生成了 `3` 的输出，如下面的截图所示：
- en: '![Figure 2.13: Running the generated lodash_example.js program'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.13: Running the generated lodash_example.js program](img/B14508_02_13.jpg)'
- en: '](img/B14508_02_13.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14508_02_13.jpg](img/B14508_02_13.jpg)'
- en: 'Figure 2.13: Running the generated lodash_example.js program'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.13：运行生成的 lodash_example.js 程序
- en: 'Create another variable named `number` and assign it the value `10`. We''ll
    then pass this number as an argument to the Lodash library''s `_.last()` function.
    Write the following code to do this:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `number` 的变量，并将其赋值为 `10`。然后我们将这个数字作为参数传递给 Lodash 库的 `_.last()` 函数。编写以下代码来完成此操作：
- en: '[PRE19]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since we've looked at the declaration file, we know that the last function expects
    an array or some type of list. However, for now, let's pretend that we don't have
    that information, and this is the first time that we're working with the Lodash library.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们已经查看过声明文件，我们知道最后一个函数期望一个数组或某种类型的列表。然而，现在让我们假装我们没有这个信息，这是我们第一次使用 Lodash 库。
- en: Note
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The Lodash library's `last` function also works with strings because it views
    the string of characters like a collection of characters. For example, `_.last("hey")`
    will return `"y"` since it's the last character in the string.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: The Lodash 库的 `last` 函数也可以与字符串一起使用，因为它将字符串中的字符视为字符集合。例如，`_.last("hey")` 将返回
    `"y"`，因为它是字符串中的最后一个字符。
- en: 'Run the preceding program in the terminal by writing the following commands:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行前面的程序，输入以下命令：
- en: '[PRE20]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following output is generated when the preceding commands are executed:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行前面的命令时，将生成以下输出：
- en: '![Figure 2.14: What happens when the wrong argument is passed to the last function'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 2.14: What happens when the wrong argument is passed to the last function](img/B14508_02_14.jpg)'
- en: '](img/B14508_02_14.jpg)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14508_02_14.jpg](img/B14508_02_14.jpg)'
- en: 'Figure 2.14: What happens when the wrong argument is passed to the last function'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.14：将错误的参数传递给最后一个函数时会发生什么
- en: In such a small program, this may seem like a trivial issue. However, in a large
    system, getting an undefined value while expecting an actual value can be time-consuming,
    as we have to spend more time on debugging.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在如此小的程序中，这似乎是一个微不足道的问题。然而，在一个大系统中，当我们期望一个实际值时却得到了一个未定义的值，可能会很耗时，因为我们需要花费更多的时间进行调试。
- en: 'In order to fix this issue, let''s leverage the DefinitelyTyped repository
    and bring in the `lodash` types. If you hover over the `import` statement at the
    top of the file, you''ll even see the following warning and recommendation, as
    shown in the following screenshot:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们利用 DefinitelyTyped 仓库并引入 `lodash` 类型。如果你将鼠标悬停在文件顶部的 `import` 语句上，你甚至还会看到以下警告和建议，如下面的截图所示：
- en: '![Figure 2.15: TypeScript recommending to install Lodash types from DefinitelyTyped'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.15：TypeScript 推荐从 DefinitelyTyped 安装 Lodash 类型'
- en: '](img/B14508_02_15.jpg)'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_02_15.jpg)'
- en: 'Figure 2.15: TypeScript recommending to install Lodash types from DefinitelyTyped'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.15：TypeScript 推荐从 DefinitelyTyped 安装 Lodash 类型
- en: That's quite helpful. The warning itself is showing us how we can install the
    types for the library.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这非常有帮助。警告本身就告诉我们如何安装库的类型。
- en: 'Follow the recommendation and run the following command in the terminal to
    install `lodash` types:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照建议，在终端中运行以下命令来安装 `lodash` 类型：
- en: '[PRE21]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Any time that you see an `install` command that starts with `@types/`, that
    means that NPM is going to pull from the DefinitelyTyped repository.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次你看到以 `@types/` 开头的 `install` 命令时，这意味着 NPM 将从 DefinitelyTyped 仓库中提取。
- en: 'If you run that command, the warning in the `import` statement should go away
    automatically. But even more importantly, you should now see that the IDE is now
    complaining about the line of code where we''re trying to pass a number to the
    `last` function. If you hover over the word `number`, you should see the error
    shown in the following screenshot:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你运行该命令，`import` 语句中的警告应该会自动消失。但更重要的是，你现在应该看到 IDE 正在抱怨我们尝试将数字传递给 `last` 函数的那一行代码。如果你将鼠标悬停在单词
    `number` 上，你应该会看到以下截图所示的错误：
- en: '![Figure 2.16: IntelliSense revealing the correct type to use with the last
    function'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.16：IntelliSense 显示与最后一个函数一起使用的正确类型'
- en: '](img/B14508_02_16.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_02_16.jpg)'
- en: 'Figure 2.16: IntelliSense revealing the correct type to use with the last function'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：IntelliSense 显示与最后一个函数一起使用的正确类型
- en: From the preceding screenshot, it is clear that the `last` function won't take
    any argument of the `number` type. It accepts either an array or a list as an
    argument. So, let's imagine that we're building a real-world application, and
    we try to use the `last` function. If we were using vanilla JavaScript, we wouldn't
    realize our error until we, or even a user, encountered the error while running
    the program. However, by leveraging TypeScript and DefinitelyTyped, the program
    won't even compile if we attempt to use a function in the incorrect manner.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图可以看出，`last` 函数不会接受任何 `number` 类型的参数。它接受一个数组或列表作为参数。因此，让我们想象我们正在构建一个现实世界的应用程序，并尝试使用
    `last` 函数。如果我们使用原生 JavaScript，我们可能直到我们或甚至用户在运行程序时遇到错误才会意识到我们的错误。然而，通过利用 TypeScript
    和 DefinitelyTyped，如果我们尝试以错误的方式使用函数，程序甚至无法编译。
- en: Development Workflow with DefinitelyTyped
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 DefinitelyTyped 的发展流程
- en: Now that you've seen how to install and work with types, we will walk through
    a full development workflow so that you can observe the benefits of working with
    types. Without the integration of types into external libraries, we are forced
    to either have prior knowledge of the library or dig through the documentation
    to discover the proper usage.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何安装和使用类型，我们将通过一个完整的发展流程来展示，这样你就可以观察到使用类型的优势。如果没有将类型集成到外部库中，我们就必须具备对该库的先验知识，或者翻阅文档以发现正确的用法。
- en: However, with types, we're going to see how much more streamlined the process
    is when it comes to working with libraries such as `lodash`. Let's solve an exercise
    in the next section to get a proper understanding of this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有了类型，我们将看到在处理像 `lodash` 这样的库时，过程会多么流畅。让我们在下一节解决一个练习，以便更好地理解这一点。
- en: 'Exercise 2.03: Creating a Baseball Lineup Card Application'
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：创建棒球阵容卡应用程序
- en: 'In this exercise, we''ll create a baseball lineup application, wherein we have
    an array of player names that we''ll be retrieving from an API, and then we have
    a constant variable in the application called `lineupOrder`. Our lineup card application
    needs to pair the names from the API with `lineupOrder`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个棒球阵容应用程序，其中我们有一个从 API 获取的球员名字数组，然后我们在应用程序中有一个名为 `lineupOrder`
    的常量变量。我们的阵容卡应用程序需要将 API 中的名字与 `lineupOrder` 配对：
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/01spI](https://packt.link/01spI).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下链接找到：[https://packt.link/01spI](https://packt.link/01spI)。
- en: Open the Visual Studio Code editor.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code 编辑器。
- en: 'Create a file named `lodash_newexamples.ts` and add the following code, wherein
    we have an array variable, `playerNames`, and a list, `lineupOrder`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `lodash_newexamples.ts` 的文件，并添加以下代码，其中我们有一个数组变量 `playerNames` 和一个列表 `lineupOrder`：
- en: '[PRE22]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a perfect situation for using the `zip` function from the Lodash library.
    Let''s imagine that we''ve heard about the `zip` function, but aren''t quite aware
    of how to use it yet. Start by writing the following code in the same file:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这正是使用 Lodash 库中的 `zip` 函数的完美情况。让我们假设我们已经听说过 `zip` 函数，但还不完全清楚如何使用它。首先，在同一个文件中编写以下代码：
- en: '[PRE23]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you''ve typed the preceding code, place the cursor in between the parentheses.
    You''ll get some guidance on how to use the function straight from DefinitelyTyped,
    as shown in the following screenshot:![Figure 2.17: IntelliSense guidance on how
    to use the zip function in lodash'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入前面的代码后，将光标放在括号之间。你将直接从 DefinitelyTyped 获得有关如何使用该函数的指导，如下面的截图所示：![图 2.17：IntelliSense
    在 lodash 中使用 zip 函数的指导]
- en: '](img/B14508_02_17.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14508_02_17.jpg]'
- en: 'Figure 2.17: IntelliSense guidance on how to use the zip function in lodash'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.17：IntelliSense 在 lodash 中使用 zip 函数的指导
- en: Note
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: From the preceding screenshot, we can see that the `zip` function takes two
    arguments. Both arguments need to be `ArrayLike`, which means they need to function
    as a type of collection. Also, the function groups the elements together and returns
    the grouped collection. Thus, without having to dig through the `lodash` documentation,
    we were able to leverage the type definition as we were building the program.
    It gives us the guidance we need while working with the function.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从前面的截图，我们可以看到 `zip` 函数接受两个参数。两个参数都需要是 `ArrayLike`，这意味着它们需要作为某种集合的功能。此外，该函数将元素分组并返回分组集合。因此，无需查阅
    `lodash` 文档，我们就能在构建程序时利用类型定义。它为我们提供了在处理函数时所需的指导。
- en: Let's now test it out. We know that the `zip` function takes in two arrays.
    So, let's provide it with the `playerNames` and `lineupOrder` arrays.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们来测试一下。我们知道 `zip` 函数接受两个数组。所以，让我们提供 `playerNames` 和 `lineupOrder` 数组。
- en: 'Add the following code to provide the `zip` function with two arrays, `playerNames`
    and `lineupOrder`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向文件中添加以下代码，为 `zip` 函数提供两个数组 `playerNames` 和 `lineupOrder`：
- en: '[PRE24]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you run the preceding code, you''ll see that the `zip` function does exactly
    what it said it would do. It groups the elements and returns the exact data structure
    that we needed. The rendered lineup card would look something like that shown
    in the following screenshot:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果运行前面的代码，你会看到 `zip` 函数确实做了它所说的。它将元素分组并返回我们需要的确切数据结构。渲染的阵容卡看起来可能像以下截图所示：
- en: '![Figure 2.18: Running the zip function properly from lodash'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.18：从 lodash 正确运行 zip 函数]'
- en: '](img/B14508_02_18.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_02_18.jpg]'
- en: 'Figure 2.18: Running the zip function properly from lodash'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18：从 lodash 正确运行 zip 函数
- en: In completing this process, you can see how DefinitelyTyped allows you to extend
    types directly into third-party libraries so that you can get type guidance in
    your programs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此过程时，你可以看到 DefinitelyTyped 如何允许你直接扩展第三方库中的类型，以便你可以在程序中获得类型指导。
- en: 'Activity 2.01: Building a Heat Map Declaration File'
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 2.01：构建热图声明文件
- en: In this activity, you will build a TypeScript application named `heat map log
    system` for tracking baseball pitch data and ensuring data integrity. You will
    utilize a TypeScript declaration file to build the type system for the program.
    From that point, you will import the Lodash library and will add type checking
    to the program by implementing type definitions from DefinitelyTyped.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你将构建一个名为 `heat map log system` 的 TypeScript 应用程序，用于跟踪棒球投球数据并确保数据完整性。你将利用
    TypeScript 声明文件来构建程序的类型系统。从那时起，你将导入 Lodash 库，并通过实现来自 DefinitelyTyped 的类型定义来向程序添加类型检查。
- en: 'The steps are as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: 'Visit the following GitHub repository and download the activity project containing
    the specs and configuration elements: https://packt.link/vnj1R.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问以下 GitHub 仓库并下载包含规范和配置元素的 activity 项目：https://packt.link/vnj1R。
- en: Create a file called `heat_map_data.ts`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `heat_map_data.ts` 的文件。
- en: Run the TypeScript compiler on the file and watch for changes.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件上运行 TypeScript 编译器并观察更改。
- en: Create a declaration file and define a module called `HeatMapTypes` and export
    the interface named `Pitcher`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个声明文件并定义一个名为 `HeatMapTypes` 的模块，并导出名为 `Pitcher` 的接口。
- en: 'Define three attributes for the `Pitcher` module: `batterHotZones`, `pitcherHotZones`,
    and `coordinateMap`.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Pitcher` 模块定义三个属性：`batterHotZones`、`pitcherHotZones` 和 `coordinateMap`。
- en: The data structures should be the same for all three attributes, `Array<Array<number>>`,
    but `coordinateMap` should be optional.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有三个属性的数据结构应该相同，即 `Array<Array<number>>`，但 `coordinateMap` 应该是可选的。
- en: Then, import the declaration files into the `heat_map_data.ts` file. Then, create
    and export a `let` variable called `data` and assign it to the `Pitcher` type.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将声明文件导入到 `heat_map_data.ts` 文件中。接着，创建并导出一个名为 `data` 的 `let` 变量，并将其分配给 `Pitcher`
    类型。
- en: Add values that adhere to the declaration rules, ensuring that one of the nested
    arrays is identical in the `batterHotZones` and `pitcherHotZones` attributes.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加符合声明规则的数据，确保嵌套数组中的一个与 `batterHotZones` 和 `pitcherHotZones` 属性中的一个是相同的。
- en: Create a new function called `findMatch` that takes in both the `batterHotZones`
    and `pitcherHotZones` arrays and utilize the `lodash` function, `intersectionWith`,
    to return the identical nested array. You will need to import the Lodash library,
    which was installed when you initially ran `npm install`. Finally, store the value
    of `findMatch` in the `coordinateMap` attribute that was defined in the declaration
    file.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `findMatch` 的新函数，该函数接受 `batterHotZones` 和 `pitcherHotZones` 数组，并使用 `lodash`
    函数 `intersectionWith` 返回相同的嵌套数组。您需要导入在最初运行 `npm install` 时安装的 Lodash 库。最后，将 `findMatch`
    的值存储在声明文件中定义的 `coordinateMap` 属性中。
- en: 'The expected output of this activity will be a nested array that looks similar
    to this:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的预期输出将是一个类似以下的嵌套数组：
- en: '[PRE25]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor391).
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor391)找到。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've walked through how to utilize declaration files in TypeScript.
    We've analyzed how declaration files can assist the IDE in guiding how programs
    should be structured. We've seen examples of structuring the declaration files.
    Importing declaration files into TypeScript files assists in the development life
    cycle. We learned to assign objects to custom types that were defined in the declaration
    files. It injects typed guidance into the IDE's IntelliSense process. We also
    learned about DefinitelyTyped and how it can be leveraged to layer on types for
    third-party libraries and work with them like typed programs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何在 TypeScript 中使用声明文件。我们分析了声明文件如何帮助 IDE 指导程序的结构。我们看到了结构化声明文件的示例。将声明文件导入
    TypeScript 文件有助于开发周期。我们学习了如何将对象分配给在声明文件中定义的自定义类型。它将类型指导注入到 IDE 的 IntelliSense
    过程中。我们还了解了 DefinitelyTyped 以及如何利用它为第三方库添加类型，并像有类型的程序一样与之协作。
- en: With all this knowledge of declaration files, in the next chapter, we'll be
    taking a deep dive into working with functions in TypeScript. We'll be defining
    a function using types, building a suite of functions in a module, building a
    class of functions to perform a specific task, and exploring unit testing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了所有关于声明文件的知识后，在下一章中，我们将深入探讨在 TypeScript 中使用函数。我们将使用类型定义一个函数，在一个模块中构建一系列函数，构建一个执行特定任务的函数类，并探索单元测试。
