- en: Chapter 2. Basic Components That Make Up a Three.js Scene
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。构成 Three.js 场景的基本组件
- en: 'In the previous chapter, you learned the basics of Three.js. We showed a couple
    of examples, and you created your first complete Three.js scene. In this chapter,
    we''ll dive a bit deeper into Three.js and explain the basic components that make
    up a Three.js scene. In this chapter, you''ll explore the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了 Three.js 的基础知识。我们展示了一些示例，并且你创建了你的第一个完整的 Three.js 场景。在这一章中，我们将更深入地探讨
    Three.js，并解释构成 Three.js 场景的基本组件。在本章中，你将探索以下主题：
- en: The components that are used in a Three.js scene
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Three.js 场景中使用的组件
- en: What you can do with the `THREE.Scene` object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `THREE.Scene` 对象做什么
- en: How geometries and meshes are related
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何体和网格之间的关系
- en: The difference between the orthographic and perspective cameras
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正交相机和透视相机的区别
- en: We start with looking at how you can create a scene and add objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看如何创建场景并添加对象。
- en: Creating a scene
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景
- en: 'In the previous chapter, you created `THREE.Scene`, so you already know the
    basics of Three.js. We saw that for a scene to show anything, we need three types
    of components:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建了 `THREE.Scene`，因此你已经了解了 Three.js 的基础知识。我们看到了要使场景显示内容，我们需要三种类型的组件：
- en: '| Component | Description |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Camera | This determines what is rendered on the screen. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 相机 | 这决定了屏幕上渲染的内容。 |'
- en: '| Lights | These have an effect on how materials are shown and used when creating
    shadow effects (discussed in detail in [Chapter 3](ch03.html "Chapter 3. Working
    with the Different Light Sources Available in Three.js"), *Working with the Different
    Light Sources Available in Three.js*). |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 灯光 | 这些对创建阴影效果时材料的表现和使用有影响（在[第 3 章](ch03.html "第 3 章。在 Three.js 中使用不同的光源")中详细讨论）。
    |'
- en: '| Objects | These are the main objects that are rendered from the perspective
    of the camera: cubes, spheres, and the like. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 这些是从相机视角渲染的主要对象：立方体、球体等。 |'
- en: '`THREE.Scene` serves as the container for all these different objects. This
    object itself doesn''t have that many options and functions.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Scene` 是所有这些不同对象的容器。这个对象本身并没有很多选项和功能。'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`THREE.Scene` is a structure that is sometimes also called a scene graph. A
    scene graph is a structure that can hold all necessary information of a graphical
    scene. In Three.js, this means that `THREE.Scene` contains all the objects, lights,
    and other objects necessary for rendering. What is interesting to note is that
    a scene graph, as the name implies, isn''t just an array of objects; a scene graph
    consists of a set of nodes in a tree structure. Each object you can add to the
    scene in Three.js, and even `THREE.Scene` itself, extends from a base object named
    `THREE.Object3D`. A `THREE.Object3D` object can also have its own children, which
    you can use to create a tree of objects that Three.js will interpret and render.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Scene` 是一种有时也称为场景图的构造。场景图是一种可以包含图形场景所有必要信息的结构。在 Three.js 中，这意味着 `THREE.Scene`
    包含了所有必要的对象、灯光和其他渲染所需的对象。值得注意的是，场景图，正如其名称所暗示的，不仅仅是一个对象的数组；场景图由树结构中的一组节点组成。你可以将任何对象添加到
    Three.js 场景中，甚至 `THREE.Scene` 本身，都扩展自一个名为 `THREE.Object3D` 的基本对象。一个 `THREE.Object3D`
    对象也可以有自己的子对象，你可以使用这些子对象创建一个对象树，Three.js 将解释并渲染这些对象。 '
- en: Basic functionality of a scene
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景的基本功能
- en: 'The best way to explore the functionality of a scene is by looking at an example.
    In the source code for this chapter, you can find the `01-basic-scene.html` example.
    I''ll use this example to explain the various functions and options a scene has.
    When we open this example in the browser, the output will look somewhat like what''s
    shown in the next screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 探索场景功能的最有效方法是查看一个示例。在本章的源代码中，你可以找到 `01-basic-scene.html` 示例。我将使用这个示例来解释场景具有的各种功能和选项。当我们在这个示例中打开浏览器时，输出将类似于下一张截图所示：
- en: '![Basic functionality of a scene](img/2215OS_02_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![场景的基本功能](img/2215OS_02_01.jpg)'
- en: 'This looks pretty much like the examples we saw in the previous chapter. Even
    though the scene looks pretty empty, it already contains a couple of objects.
    Looking at the following source, we can see that we used the `scene.add(object)`
    function from the `THREE.Scene` object to add `THREE.Mesh` (the ground plane you
    see), `THREE.SpotLight`, and `THREE.AmbientLight`. The `THREE.Camera` object is
    added automatically by Three.js when you render the scene, but it is good practice
    to add it to the scene manually, especially when you''re working with multiple
    cameras. Take a look at the following source code for this scene:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来几乎就像我们在上一章中看到的示例。尽管场景看起来相当空旷，但它已经包含了一些对象。查看以下源代码，我们可以看到我们使用了`THREE.Scene`对象的`scene.add(object)`函数来添加`THREE.Mesh`（你所看到的地面平面）、`THREE.SpotLight`和`THREE.AmbientLight`。`THREE.Camera`对象在渲染场景时由Three.js自动添加，但手动将其添加到场景中是一种良好的实践，尤其是在你使用多个相机时。查看以下源代码以了解此场景：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before we look deeper into the `THREE.Scene` object, I''ll first explain what
    you can do in the demo, and after that, we''ll look at some code. Open the `01-basic-scene.html`
    example in your browser and look at the controls in the upper-right corner, as
    you can see in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨`THREE.Scene`对象之前，我先解释一下在演示中你可以做什么，然后我们将查看一些代码。在你的浏览器中打开`01-basic-scene.html`示例，并查看右上角的控件，就像你在以下截图中所看到的那样：
- en: '![Basic functionality of a scene](img/2215OS_02_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![场景的基本功能](img/2215OS_02_02.jpg)'
- en: 'With these controls, you can add a cube to the scene, remove the cube that
    was last added to the scene, and show all the current objects that the scene contains
    in the console of your browser. The last entry in the controls section shows the
    current number of objects in the scene. What you''ll probably notice when you
    start up the scene is that there are already four objects in the scene. These
    are the ground plane, the ambient light, and the spotlight, as well as the camera
    we mentioned earlier. We''ll look at each of the functions in the control section
    and start with the easiest one, `addCube`, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些控件，你可以向场景中添加一个立方体，删除最后添加到场景中的立方体，并在浏览器控制台中显示场景中包含的所有当前对象。控件部分的最后一项显示了场景中的当前对象数量。当你启动场景时，你可能会注意到场景中已经有四个对象。这些是地面平面、环境光、聚光灯以及我们之前提到的相机。我们将查看控件部分中的每个函数，并从最简单的`addCube`函数开始，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This piece of code should already be pretty easy to read by now. Not many new
    concepts are introduced here. When you hit the **addCube** button, a new `THREE.BoxGeometry`
    object is created whose width, height, and depth are set to a random value between
    1 and 3\. Besides a random size, the cube also gets a random color and a random
    position.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这段代码应该已经很容易阅读了。这里没有引入很多新概念。当你点击**addCube**按钮时，会创建一个新的`THREE.BoxGeometry`对象，其宽、高和深度设置为1到3之间的随机值。除了随机大小外，立方体还获得一个随机颜色和一个随机位置。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A new element that we introduce here is that we also give the cube a name using
    its `name` attribute. Its name is set to `cube-`, appended with the number of
    objects currently in the scene (`scene.children.length`). A name is very useful
    for debugging purposes but can also be used to directly access an object from
    your scene. If you use the `THREE.Scene.getObjectByName(name)` function, you can
    directly retrieve a specific object and, for instance, change its location without
    having to make the JavaScript object a global variable. You might wonder what
    the last line does. The `numberOfObjects` variable is used by our control GUI
    to list the number of objects in the scene. So, whenever we add or remove an object,
    we set this variable to the updated count.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们引入的一个新元素是，我们还可以使用其`name`属性给立方体命名。其名称设置为`cube-`，后面附加当前场景中对象的数量（`scene.children.length`）。名称对于调试非常有用，也可以用来直接从你的场景中访问对象。如果你使用`THREE.Scene.getObjectByName(name)`函数，你可以直接检索一个特定的对象，例如，改变其位置，而不必将JavaScript对象设置为全局变量。你可能想知道最后一行做了什么。`numberOfObjects`变量被我们的控制GUI用于列出场景中的对象数量。因此，每当我们添加或删除对象时，我们将此变量设置为更新后的计数。
- en: 'The next function we can call from the control GUI is `removeCube`. As the
    name implies, clicking on the **removeCube** button removes the last added cube
    from the scene. In code, it looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从控制GUI中调用的下一个函数是`removeCube`。正如其名所示，点击**removeCube**按钮会从场景中删除最后添加的立方体。在代码中，它看起来像这样：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To add an object to the scene, we use the `add` function. To remove an object
    from the scene, we use, not very surprisingly, the `remove` function. Since Three.js
    stores its children as a list (new ones are added at the end), we can use the
    `children` property, which contains an array of all the objects in the scene,
    from the `THREE.Scene` object to get the last object that was added. We also need
    to check whether that object is a `THREE.Mesh` object to avoid removing the camera
    and the lights. After we've removed the object, we once again update the GUI property,
    `numberOfObjects`, that holds the number of objects in the scene.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个对象添加到场景中，我们使用`add`函数。要从一个场景中移除一个对象，我们使用，不出所料，`remove`函数。由于Three.js将其子对象存储为列表（新添加的放在末尾），我们可以使用`children`属性，它包含场景中所有对象的数组，从`THREE.Scene`对象中获取最后添加的对象。我们还需要检查该对象是否是`THREE.Mesh`对象，以避免移除相机和灯光。在移除对象后，我们再次更新GUI属性`numberOfObjects`，该属性持有场景中对象的数量。
- en: 'The final button on our GUI is labeled **outputObjects**. You probably already
    clicked on this and nothing seemed to happen. This button prints out all the objects
    that are currently in our scene to the web browser console, as shown in the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们GUI上的最后一个按钮被标记为**outputObjects**。你可能已经点击了这个按钮，但似乎没有发生任何事情。这个按钮将当前场景中的所有对象打印到网络浏览器控制台，如下面的截图所示：
- en: '![Basic functionality of a scene](img/2215OS_02_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![场景的基本功能](img/2215OS_02_03.jpg)'
- en: 'The code to output information to the console log makes use of the built-in
    `console` object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将信息输出到控制台的代码使用了内置的`console`对象：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is great for debugging purposes, and especially when you name your objects,
    it''s very useful to find issues and problems with a specific object in your scene.
    For instance, the properties of `cube-17` look like this (if you already know
    the name beforehand, you could also use `console.log(scene.getObjectByName("cube-17")`
    to output only that single object):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调试目的非常有用，尤其是在你命名了你的对象时，查找场景中特定对象的错误和问题非常有用。例如，`cube-17`的属性看起来像这样（如果你事先已经知道了名称，你也可以使用`console.log(scene.getObjectByName("cube-17")`来输出仅该单个对象）：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Until now, we''ve seen the following scene-related functionality:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了以下场景相关功能：
- en: '`THREE.Scene.Add`: This adds an object to the scene'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene.Add`：这个函数将一个对象添加到场景中'
- en: '`THREE.Scene.Remove`: This removes an object from the scene'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene.Remove`：这个函数从场景中移除一个对象'
- en: '`THREE.Scene.children`: This gets a list of all the children in the scene'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene.children`：这个函数获取场景中所有子对象的列表'
- en: '`THREE.Scene.getObjectByName`: This gets a specific object, by name, from the
    scene'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene.getObjectByName`：这个函数通过名称从场景中获取一个特定的对象'
- en: These are the most important scene-related functions, and most often, you won't
    need any more than this. There are, however, a couple of helper functions that
    could come in handy, and I'd like to show them based on the code that handles
    the cube rotation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最重要的场景相关函数，而且通常你不需要比这更多的功能。然而，有几个辅助函数可能会很有用，我想根据处理立方体旋转的代码来展示它们。
- en: 'As you saw in the previous chapter, we used a *render loop* to render the scene.
    Let''s look at that loop for this example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，我们使用了一个*渲染循环*来渲染场景。让我们看看这个循环在这个例子中的样子：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we see the `THREE.Scene.traverse()` function being used. We can pass a
    function to the `traverse()` function that will be called for each child of the
    scene. If a child itself has children, remember that a `THREE.Scene` object can
    contain a tree of objects. The `traverse()` function will also be called for all
    the children of that object. You traverse through the complete scene graph.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到正在使用`THREE.Scene.traverse()`函数。我们可以向`traverse()`函数传递一个函数，该函数将为场景的每个子对象调用。如果一个子对象本身有子对象，请记住，一个`THREE.Scene`对象可以包含一个对象树。`traverse()`函数也将为该对象的全部子对象调用。你将遍历整个场景图。
- en: We use the `render()` function to update the rotation for each of the cubes
    (note that we explicitly ignore the ground plane). We could also have done this
    by iterating ourselves over the `children` property array using a `for` loop since
    we've only added objects to `THREE.Scene` and haven't created a nested structure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`render()`函数来更新每个立方体的旋转（注意我们明确忽略了地面平面）。我们也可以通过使用`for`循环遍历`children`属性数组来自行完成这项工作，因为我们只向`THREE.Scene`添加了对象，并没有创建嵌套结构。
- en: 'Before we dive into the details of `THREE.Mesh` and `THREE.Geometry`, I''d
    like to show two interesting properties that you can set on the `THREE.Scene`
    object: `fog` and `overrideMaterial`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨`THREE.Mesh`和`THREE.Geometry`的细节之前，我想展示两个你可以设置在`THREE.Scene`对象上的有趣属性：`fog`和`overrideMaterial`。
- en: Adding fog to the scene
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加雾气
- en: 'The **fog** property lets you add a fog effect to the complete scene; the farther
    off an object is, the more it will be hidden from sight, as shown in the following
    screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**fog**属性允许你为整个场景添加雾效；对象离得越远，就越会被视线遮挡，如下面的截图所示：'
- en: '![Adding fog to the scene](img/2215OS_02_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加雾气](img/2215OS_02_04.jpg)'
- en: 'Enabling fog is really easy in Three.js. Just add the following line of code
    after you''ve defined your scene:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中启用雾气非常简单。只需在你定义场景后添加以下代码行即可：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we define a white fog (`0xffffff`). The preceding two properties can
    be used to tune how the mist appears. The `0.015` value sets the `near` property,
    and the `100` value sets the `far` property. With these properties, you can determine
    where the mist starts and how fast it gets denser. With the `THREE.Fog` object,
    the fog increases linearly. There is also a different way to set the mist for
    the scene; for this, use the following definition:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一种白色雾气（`0xffffff`）。前两个属性可以用来调整雾气的外观。`0.015`值设置了`near`属性，而`100`值设置了`far`属性。使用这些属性，你可以确定雾气开始的位置以及它变浓的速度。使用`THREE.Fog`对象，雾气是线性增加的。还有另一种为场景设置雾气的方法；为此，请使用以下定义：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, we don't specify `near` and `far`, but just the color (`0xffffff`)
    and the mist's density (`0.01`). It's best to experiment a bit with these properties
    to get the effect you want. Note that with `THREE.FogExp2`, the fog doesn't increase
    linearly but grows exponentially denser with the distance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们没有指定`near`和`far`，只是颜色（`0xffffff`）和雾的密度（`0.01`）。最好对这些属性进行一些实验，以获得你想要的效果。注意，使用`THREE.FogExp2`，雾不是线性增加，而是随着距离的增加而指数级地变得更浓。
- en: Using the overrideMaterial property
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用overrideMaterial属性
- en: The last property we discuss for the scene is **overrideMaterial**. When you
    use this property, all the objects in the scene will use the material that is
    set to the `overrideMaterial` property and ignore the material that is set on
    the object itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论场景的最后一个属性是**overrideMaterial**。当你使用这个属性时，场景中的所有对象都将使用设置到`overrideMaterial`属性的材质，并忽略对象本身设置的材质。
- en: 'Use it like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon using the `overrideMaterial` property as shown in the preceding code,
    the scene will be rendered as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，使用`overrideMaterial`属性后，场景将渲染成以下截图所示：
- en: '![Using the overrideMaterial property](img/2215OS_02_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用overrideMaterial属性](img/2215OS_02_05.jpg)'
- en: In the preceding figure, you can see that all the cubes are rendered using the
    same material and the same color. In this example, we used a `THREE.MeshLambertMaterial`
    object as the material. With this material type, we can create non-shiny-looking
    objects that respond to the lights that are present in the scene. In [Chapter
    4](ch04.html "Chapter 4. Working with Three.js Materials"), *Working with Three.js
    Materials*, you'll learn more about this material.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图中，你可以看到所有立方体都使用了相同的材质和颜色。在这个例子中，我们使用了一个`THREE.MeshLambertMaterial`对象作为材质。使用这种材质类型，我们可以创建看起来不反光的物体，这些物体会对场景中存在的灯光做出反应。在[第4章](ch04.html
    "第4章。使用Three.js材质")中，*使用Three.js材质*，你将了解更多关于这种材质的信息。
- en: 'In this section, we looked at the first of the core concepts of Three.js: `THREE.Scene`.
    The most important thing to remember about the scene is that it is basically a
    container for all the objects, lights, and cameras you want to use when rendering.
    The following table summarizes the most important functions and attributes of
    the `THREE.Scene` object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Three.js的核心概念之一：`THREE.Scene`。关于场景，最重要的是记住它基本上是一个容器，用于存放你希望在渲染时使用的所有对象、灯光和相机。以下表格总结了`THREE.Scene`对象最重要的函数和属性：
- en: '| Function/Property | Description |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 函数/属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add(object)` | This is used to add an object to the scene. You can also
    use this function, as we''ll see later on, to create groups of objects. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `add(object)` | 用于将对象添加到场景中。你还可以使用此功能，如我们稍后将要看到的，来创建对象组。|'
- en: '| `children` | This returns a list of all the objects that have been added
    to the scene, including the camera and lights. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `children` | 返回场景中添加的所有对象的列表，包括相机和灯光。|'
- en: '| `getObjectByName(name, recursive)` | When you create an object, you can give
    it a distinct name. The scene object has a function that you can use to directly
    return an object with a specific name. If you set the recursive argument to `true`,
    Three.js will also search through the complete tree of objects to find the object
    with the specified name. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `getObjectByName(name, recursive)` | 当你创建一个对象时，你可以给它一个独特的名称。场景对象有一个函数，你可以使用它来直接返回具有特定名称的对象。如果你将递归参数设置为`true`，Three.js也会搜索完整的对象树以找到具有指定名称的对象。
    |'
- en: '| `remove(object)` | If you have a reference to an object in the scene, you
    can also remove it from the scene using this function. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `remove(object)` | 如果你有一个场景中对象的引用，你也可以使用此函数将其从场景中删除。 |'
- en: '| `traverse(function)` | The children property returns a list of all the children
    in the scene. With the traverse function, we can also access these children. With
    traverse, all the children are passed in to the supplied function one by one.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `traverse(function)` | 子属性返回场景中所有子对象的列表。使用遍历函数，我们也可以访问这些子对象。使用遍历，所有子对象将逐个传递给提供的函数。
    |'
- en: '| `fog` | This property allows you to set the fog for the scene. The fog will
    render a haze that hides faraway objects. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 这个属性允许你为场景设置雾。雾将渲染出一种雾气，隐藏远处的对象。 |'
- en: '| `overrideMaterial` | With this property, you can force all the objects in
    the scene to use the same material. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `overrideMaterial` | 使用这个属性，你可以强制场景中的所有对象使用相同的材质。 |'
- en: In the next section, we'll take a closer look at the objects that you can add
    to the scene.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更仔细地查看你可以添加到场景中的对象。
- en: Geometries and meshes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何体和网格
- en: 'In each of the examples until now, you''ve seen geometries and meshes being
    used. For instance, to add a sphere to the scene, we did the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在到目前为止的每个示例中，你都看到了几何体和网格的使用。例如，要向场景中添加一个球体，我们做了以下操作：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We defined the shape of the object and its geometry (`THREE.SphereGeometry`),
    we defined what this object looks like (`THREE.MeshBasicMaterial`) and its material,
    and we combined these two in a mesh (`THREE.Mesh`) that can be added to a scene.
    In this section, we'll take a closer look at what a geometry is and what a mesh
    is. We'll start with the geometry.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了对象的形状及其几何体（`THREE.SphereGeometry`），我们定义了对象的外观（`THREE.MeshBasicMaterial`）及其材质，并将这两个结合在一个网格（`THREE.Mesh`）中，可以添加到场景中。在本节中，我们将更仔细地看看几何体是什么，网格是什么。我们将从几何体开始。
- en: The properties and functions of a geometry
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何体的属性和函数
- en: 'Three.js comes with a large set of geometries out of the box that you can use
    in your 3D scene. Just add a material, create a mesh, and you''re pretty much
    done. The following screenshot, from example `04-geometries`, shows a couple of
    the standard geometries available in Three.js:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js自带了一套大量的几何体，你可以在你的3D场景中使用。只需添加一个材质，创建一个网格，你基本上就完成了。以下是从示例`04-geometries`中的截图，展示了Three.js中可用的几个标准几何体：
- en: '![The properties and functions of a geometry](img/2215OS_02_06.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![几何体的属性和函数](img/2215OS_02_06.jpg)'
- en: In [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, and [Chapter 6](ch06.html "Chapter 6. Advanced Geometries
    and Binary Operations"), *Advanced Geometries and Binary Operations*, we'll explore
    all the basic and advanced geometries that Three.js has to offer. For now, we'll
    look in greater detail at what a geometry actually is.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。学习与几何体一起工作") *学习与几何体一起工作* 和 [第6章](ch06.html "第6章。高级几何体和二进制操作")
    *高级几何体和二进制操作* 中，我们将探讨Three.js提供的所有基本和高级几何体。现在，我们将更详细地看看几何体实际上是什么。
- en: 'A geometry in Three.js, and in most other 3D libraries, is basically a collection
    of points in a 3D space, also called vertices, and a number of faces connecting
    those points together. Take, for example, a cube:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中，以及在大多数其他3D库中，几何体基本上是三维空间中点的集合，也称为顶点，以及连接这些点的多个面。以一个立方体为例：
- en: A cube has eight corners. Each of these corners can be defined as an *x*, *y*,
    and *z* coordinate. So each cube has eight points in a 3D space. In Three.js,
    these points are called vertices, and a single one is called a vertex.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个立方体有八个角。每个角都可以定义为*x*、*y*和*z*坐标。因此，每个立方体在三维空间中有八个点。在Three.js中，这些点被称为顶点，单个点称为顶点。
- en: A cube has six sides, with a vertex at each corner. In Three.js, a face always
    consists of three vertices that make a triangle. So, in the case of a cube, each
    side consists of two triangles to make the complete side.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立方体有六个面，每个角都有一个顶点。在Three.js中，一个面总是由三个顶点组成的三角形。因此，在立方体的例子中，每个面由两个三角形组成，以形成一个完整的面。
- en: 'When you use one of the geometries provided by Three.js, you don''t have to
    define all the vertices and faces yourself. For a cube, you only need to define
    the width, height, and depth. Three.js uses that information and creates a geometry
    with eight vertices at the correct position and the correct number of faces (12
    in the case of a cube). Even though you''d normally use the geometries provided
    by Three.js or generate them automatically, you can still create geometries completely
    by hand using vertices and faces. This is shown in the following lines of code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Three.js提供的几何体时，你不需要自己定义所有的顶点和面。对于一个立方体，你只需要定义宽度、高度和深度。Three.js使用这些信息并创建一个具有八个顶点且位置正确的几何体，立方体的情况下是12个面。即使你通常使用Three.js提供的几何体或自动生成它们，你仍然可以使用顶点和面完全手动创建几何体。这在下述代码行中展示：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code shows how to create a simple cube. We define the points that make
    up this cube in the `vertices` array. These points are connected to create triangular
    faces and are stored in the `faces` array. For instance, `new THREE.Face3(0,2,1)`
    creates a triangular face using the points `0`, `2`, and `1` from the `vertices`
    array. Note that you have to take care of the sequence of the vertices used to
    create `THREE.Face`. The order in which they are defined determines whether Three.js
    thinks it is a front-facing face (a face facing the camera) or a back-facing face.
    If you create the faces, you should use a clockwise sequence for front-facing
    faces and a counterclockwise sequence if you want to create a back-facing face.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何创建一个简单的立方体。我们在这个`vertices`数组中定义了组成这个立方体的点。这些点通过创建三角形面连接起来，并存储在`faces`数组中。例如，`new
    THREE.Face3(0,2,1)`就是使用`vertices`数组中的点`0`、`2`和`1`创建一个三角形面。请注意，你必须注意用于创建`THREE.Face`的顶点顺序。它们定义的顺序决定了Three.js是否认为这是一个正面面（面向摄像机的面）还是背面面。如果你创建面，你应该为正面面使用顺时针顺序，如果你想创建背面面，则使用逆时针顺序。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this example, we used a `THREE.Face3` element to define the six sides of
    the cube, with two triangles for each face. In previous versions of Three.js,
    you could also use a quad instead of a triangle. A quad uses four vertices instead
    of three to define the face. Whether using quads or triangles is better is a heated
    debate raging in the 3D modeling world. Basically though, using quads is often
    preferred during modeling since they can be more easily enhanced and smoothed
    than triangles. For render and game engines though, working with triangles is
    often easier since every shape can be rendered very efficiently as a triangle.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`THREE.Face3`元素来定义立方体的六个面，每个面使用两个三角形。在Three.js的早期版本中，你也可以使用四边形而不是三角形。四边形使用四个顶点而不是三个来定义面。使用四边形或三角形哪个更好，在3D建模界是一个热烈的争论。不过，基本上，在建模过程中，使用四边形通常更受欢迎，因为它们比三角形更容易增强和光滑。然而，对于渲染和游戏引擎来说，处理三角形通常更容易，因为每个形状都可以非常高效地作为一个三角形渲染。
- en: Using these vertices and faces, we can now create a new instance of `THREE.Geometry`
    and assign the vertices to the `vertices` attribute and the faces to the `faces`
    attribute. The last step that we need to take is call `computeFaceNormals()` on
    the geometry we created. When we call this function, Three.js determines the *normal*
    vector for each of the faces. This is the information Three.js uses to determine
    how to color the faces based on the various lights in the scene.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些顶点和面，我们现在可以创建一个新的`THREE.Geometry`实例，并将顶点分配给`vertices`属性，将面分配给`faces`属性。我们需要采取的最后一步是在我们创建的几何体上调用`computeFaceNormals()`函数。当我们调用这个函数时，Three.js会确定每个面的*法线*向量。这是Three.js用来根据场景中的各种灯光来确定如何着色面的信息。
- en: 'With this geometry, we can now create a mesh just as we saw earlier. I''ve
    created an example that you can use to play around with the position of the vertices,
    and which also shows the individual faces. In example `05-custom-geometry`, you
    can change the position of all the vertices of a cube and see how the faces react.
    This is shown in the following screenshot (should the control GUI be in the way,
    you can hide it by pressing *H*):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种几何体，我们现在可以创建一个网格，就像我们之前看到的那样。我创建了一个示例，您可以使用它来调整顶点的位置，并且它还显示了单个面。在示例 `05-custom-geometry`
    中，您可以改变立方体的所有顶点的位置，并查看面是如何反应的。这在上面的屏幕截图中显示（如果控制GUI挡住了视线，您可以通过按 *H* 隐藏它）：
- en: '![The properties and functions of a geometry](img/2215OS_02_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![几何体的属性和功能](img/2215OS_02_07.jpg)'
- en: 'This example, which uses the same setup as all our other examples, has a render
    loop. Whenever you change one of the properties in the drop-down control box,
    the cube is rendered based on the changed position of one of the vertices. This
    isn''t something that works out of the box. For performance reasons, Three.js
    assumes that the geometry of a mesh won''t change during its lifetime. For most
    geometries and use cases, this is a very valid assumption. To get our example
    to work, however, we need to make sure the following is added to the code in the
    render loop:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与我们的所有其他示例使用相同的设置，有一个渲染循环。每次您在下拉控制框中更改一个属性时，立方体都会根据顶点的一个变化位置进行渲染。这不是一件现成就能做到的事情。出于性能考虑，Three.js
    假设网格的几何体在其生命周期内不会改变。对于大多数几何体和用例，这是一个非常有效的假设。然而，为了让我们的示例工作，我们需要确保以下内容添加到渲染循环中的代码中：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first line, we point the vertices of the mesh you see on screen to an
    array of updated vertices. We don't need to reconfigure the faces since they are
    still connected to the same points as they were before. After we've set the updated
    vertices, we need to tell the geometry that the vertices need to be updated. We
    do this by setting the `verticesNeedUpdate` property of the geometry to `true`.
    Finally, we do a recalculation of the faces to update the complete model using
    the `computeFaceNormals` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将屏幕上看到的网格顶点指向一个更新的顶点数组。我们不需要重新配置面，因为它们仍然连接到与之前相同的位置。在设置更新后的顶点之后，我们需要告诉几何体顶点需要更新。我们通过将几何体的
    `verticesNeedUpdate` 属性设置为 `true` 来做到这一点。最后，我们使用 `computeFaceNormals` 函数重新计算面，以使用更新的顶点更新整个模型。
- en: 'The last geometry functionality we''ll look at is the `clone()` function. We
    mentioned that the geometry defines the form and shape of an object, and combined
    with a material, we create an object that can be added to the scene to be rendered
    by Three.js. With the `clone()` function, as the name implies, we can make a copy
    of the geometry, and for instance, use it to create a different mesh with a different
    material. In the same example, `05-custom-geometry`, you can see a **clone** button
    at the top of the control GUI, as can be seen in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一种几何体功能是 `clone()` 函数。我们提到几何体定义了物体的形状和形式，结合材料，我们可以创建一个可以被Three.js渲染的场景中的对象。正如其名所示，我们可以复制几何体，例如，使用它来创建具有不同材料的不同网格。在相同的示例
    `05-custom-geometry` 中，您可以在控制GUI的顶部看到一个 **clone** 按钮，如下面的屏幕截图所示：
- en: '![The properties and functions of a geometry](img/2215OS_02_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![几何体的属性和功能](img/2215OS_02_08.jpg)'
- en: 'If you click on this button, a clone (a copy) will be made of the geometry
    as it currently is, a new object is created with a different material, and it
    is added to the scene. The code for this is rather simple but is made a bit more
    complex because of the materials I used. Let''s take a step back and first look
    at how the green material for the cube was created, as shown in the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击此按钮，将根据当前的几何体创建一个副本（一个复制），创建一个新的具有不同材料的新对象，并将其添加到场景中。这个代码相当简单，但由于我使用的材料，它变得稍微复杂一些。让我们退一步，首先看看立方体的绿色材料是如何创建的，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, I didn't use a single material, but I used an array of two materials.
    The reason is that besides showing a transparent green cube, I also wanted to
    show you the wireframe since that shows up very clearly where the vertices and
    faces are located.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我没有使用单一材料，而是使用了两材料的阵列。原因是除了展示一个透明的绿色立方体之外，我还想向您展示线框，因为线框可以非常清晰地显示出顶点和面的位置。
- en: 'Three.js, of course, supports using multiple materials when creating a mesh.
    You can use the `SceneUtils.createMultiMaterialObject` function for this, as shown
    in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Three.js在创建网格时支持使用多个材质。你可以使用`SceneUtils.createMultiMaterialObject`函数来做这件事，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What Three.js does in this function is that it doesn''t create one `THREE.Mesh`
    object, but it creates one for each material you specified and puts these meshes
    in a group (a `THREE.Object3D` object). This group can be used in the same manner
    as you''ve used the scene object. You can add meshes, get objects by name, and
    so on. For instance, to make sure all the children of the group cast shadows,
    you do the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，Three.js所做的不是创建一个`THREE.Mesh`对象，而是为每种指定的材质创建一个，并将这些网格放入一个组（一个`THREE.Object3D`对象）。这个组可以像使用场景对象一样使用。你可以添加网格，通过名称获取对象，等等。例如，为了确保组中的所有子对象都能投射阴影，你可以这样做：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s get back to the `clone()` function we were discussing:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们之前讨论的`clone()`函数：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This piece of JavaScript is called when the **clone** button is clicked on.
    Here, we clone the geometry of the first child of our cube. Remember, the mesh
    variable contains two children; it contains two meshes, one for each material
    we specified. Based on this cloned geometry, we create a new mesh, aptly named
    `mesh2`. We move this new mesh using translate functions (more on this in [Chapter
    5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning to Work
    with Geometries*), remove the previous clone (if present), and add the clone to
    the scene.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段JavaScript代码在点击**克隆**按钮时被调用。在这里，我们克隆了立方体第一个子元素的几何形状。记住，mesh变量包含两个子元素；它包含两个网格，一个对应于我们指定的每种材质。基于这个克隆的几何形状，我们创建了一个新的网格，命名为`mesh2`。我们使用平移函数（更多内容请参阅[第5章](ch05.html
    "第5章。学习与几何形状一起工作")，*学习与几何形状一起工作*）移动这个新网格，移除之前的克隆（如果存在），并将克隆添加到场景中。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In the previous section, we used `createMultiMaterialObject` from the `THREE.SceneUtils`
    object to add a wireframe to the geometry we created. Three.js also provides an
    alternative way of adding a wireframe using `THREE.WireFrameHelper`. To use this
    helper, first instantiate the helper like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了`THREE.SceneUtils`对象的`createMultiMaterialObject`来为创建的几何形状添加线框。Three.js还提供了一个使用`THREE.WireFrameHelper`添加线框的替代方法。要使用这个辅助对象，首先以这种方式实例化它：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You provide the mesh you want to show the wireframe for and the color of the
    wireframe. Three.js will now create a helper object that you can add to the scene,
    `scene.add(helper)`. Since this helper internally is just a `THREE.Line` object,
    you can style how the wireframe appears. For instance, to set the width of the
    wireframe lines, use `helper.material.linewidth = 2;`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供你想要显示线框的网格以及线框的颜色。Three.js现在将创建一个辅助对象，你可以将其添加到场景中，`scene.add(helper)`。由于这个辅助对象内部只是一个`THREE.Line`对象，你可以设置线框的样式。例如，要设置线框线的宽度，使用`helper.material.linewidth
    = 2;`。
- en: That's enough on geometries for now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于几何形状的内容就讲到这里。
- en: Functions and attributes for meshes
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格的函数和属性
- en: 'We''ve already learned that to create a mesh, we need a geometry and one or
    more materials. Once we have a mesh, we add it to the scene and it''s rendered.
    There are a couple of properties that you can use to change where and how this
    mesh appears on the scene. In this first example, we''ll look at the following
    set of properties and functions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，要创建网格，我们需要一个几何形状和一个或多个材质。一旦我们有了网格，我们将其添加到场景中，它就会被渲染。有一些属性可以用来改变网格在场景中的位置和显示方式。在这个第一个例子中，我们将查看以下属性和函数集：
- en: '| Function/Property | Description |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 函数/属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `position` | This determines the position of this object relative to the
    position of its parent. Most often, the parent of an object is a `THREE.Scene`
    object or a `THREE.Object3D` object. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这决定了该对象相对于其父对象的位置。通常，对象的父对象是`THREE.Scene`对象或`THREE.Object3D`对象。
    |'
- en: '| `rotation` | With this property, you can set the rotation of an object around
    any of its axes. Three.js also provides specific functions for rotations around
    an axis: `rotateX()`, `rotateY()`, and `rotateZ()`. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `rotation` | 使用这个属性，你可以设置对象围绕其任意轴的旋转。Three.js还提供了围绕轴旋转的特定函数：`rotateX()`、`rotateY()`和`rotateZ()`。
    |'
- en: '| `scale` | This property allows you to scale the object around its *x*, *y*,
    and *z* axes. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `scale` | 这个属性允许你围绕对象的*x*、*y*和*z*轴进行缩放。 |'
- en: '| `translateX(amount)` | This property moves the object the specified amount
    over the *x* axis. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `translateX(amount)` | 这个属性将对象在*x*轴上移动指定的距离。 |'
- en: '| `translateY(amount)` | This property moves the object the specified amount
    over the *y* axis. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `translateY(amount)` | 此属性将对象沿 *y* 轴移动指定的量。 |'
- en: '| `translateZ(amount)` | This property moves the object the specified amount
    over the *z* axis.For the translate functions, you could also use the `translateOnAxis(axis,
    distance)` function, which allows you to translate the mesh a distance along a
    specific axis. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `translateZ(amount)` | 此属性将对象沿 *z* 轴移动指定的量。对于平移函数，你也可以使用 `translateOnAxis(axis,
    distance)` 函数，它允许你沿着特定轴平移网格一段距离。 |'
- en: '| `visible` | If you set this property to `false`, `THREE.Mesh` won''t be rendered
    by Three.js. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 如果将此属性设置为 `false`，`THREE.Mesh` 将不会被 Three.js 渲染。 |'
- en: 'As always, we have an example ready for you that will allow you to play around
    with these properties. If you open up `06-mesh-properties.html` in your browser,
    you get a drop-down menu where you can alter all these properties and directly
    see the result, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们为你准备了一个示例，让你可以玩转这些属性。如果你在浏览器中打开 `06-mesh-properties.html`，你会看到一个下拉菜单，你可以更改所有这些属性并直接看到结果，如下面的截图所示：
- en: '![Functions and attributes for meshes](img/2215OS_02_09.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](img/2215OS_02_09.jpg)'
- en: 'Let me walk you through them, and I''ll start with the position property. We''ve
    already seen this property a couple of times, so let''s quickly address this.
    With this property, you set the *x*, *y*, and *z* coordinates of the object. This
    position is relative to its parent object, which is normally the scene you add
    the object to, but could also be a `THREE.Object3D` object or another `THREE.Mesh`
    object. We''ll get back to this in [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*, when we look at
    grouping objects. We can set an object''s position property in three different
    ways. We can set each coordinate directly:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我带你了解它们，我会从位置属性开始。我们已经看到这个属性几次了，所以让我们快速解决这个问题。使用这个属性，你可以设置对象的 *x*、*y* 和 *z*
    坐标。这个位置相对于其父对象，通常是添加对象的场景，但也可能是 `THREE.Object3D` 对象或另一个 `THREE.Mesh` 对象。当我们查看分组对象时，我们将在
    [第 5 章](ch05.html "第 5 章。学习与几何体一起工作")，*学习与几何体一起工作* 中回到这一点。我们可以以三种不同的方式设置对象的位置属性。我们可以直接设置每个坐标：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, we can also set all of them at once, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以一次性设置所有这些属性，如下所示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is also a third option. The `position` property is a `THREE.Vector3`
    object. That means, we can also do the following to set this object:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个第三种选择。`position` 属性是一个 `THREE.Vector3` 对象。这意味着，我们也可以这样做来设置此对象：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I want to make a quick sidestep before looking at the other properties of this
    mesh. I mentioned that this position is set relative to the position of its parent.
    In the previous section on `THREE.Geometry`, we used `THREE.SceneUtils.createMultiMaterialObject`
    to create a multi-material object. I explained that this doesn't really return
    a single mesh but a group that contains a mesh based on the same geometry for
    each material; in our case, it's a group that contains two meshes. If we change
    the position of one of these meshes that is created, you can clearly see that
    it really is two distinct `THREE.Mesh` objects. However, if we now move the group
    around, the offset will remain the same, as shown in the following screenshot.
    In [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, we look deeper into parent-child relations and how grouping
    affects transformation, such as scaling, rotation, and translation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看此网格的其他属性之前，我想快速跳过一点。我提到这个位置是相对于其父位置设置的。在上一节关于 `THREE.Geometry` 的内容中，我们使用了
    `THREE.SceneUtils.createMultiMaterialObject` 来创建一个多材质对象。我解释说，这实际上并不返回一个单独的网格，而是一个包含基于每个材质相同几何形状的网格的组；在我们的例子中，它是一个包含两个网格的组。如果我们改变这些创建的网格之一的位置，你可以清楚地看到它确实是两个不同的
    `THREE.Mesh` 对象。然而，如果我们现在移动这个组，偏移量将保持不变，如下面的截图所示。在 [第 5 章](ch05.html "第 5 章。学习与几何体一起工作")，*学习与几何体一起工作*
    中，我们将更深入地探讨父子关系以及分组如何影响变换，例如缩放、旋转和平移。
- en: '![Functions and attributes for meshes](img/2215OS_02_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](img/2215OS_02_10.jpg)'
- en: 'OK, next on the list is the `rotation` property. You''ve already seen this
    property being used a couple of times in this chapter and the previous chapter.
    With this property, you set the rotation of the object around one of its axes.
    You can set this value in the same manner as we did the position. A complete rotation,
    as you might remember from math class, is *2 x π*. You can configure this in Three.js
    in a couple of different ways:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来列表中的下一个是`rotation`属性。你已经在本章和上一章中看到这个属性被使用了几次。使用这个属性，你可以设置物体围绕其一个轴的旋转。你可以以与我们设置位置相同的方式设置这个值。一个完整的旋转，你可能还记得从数学课上学到的，是*2
    x π*。你可以在Three.js中以几种不同的方式配置它：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you want to use degrees (from 0 to 360) instead, we''ll have to convert
    those to radians. This can be easily done like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用度数（从0到360），我们必须将这些转换为弧度。这可以很容易地这样做：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can play around with this property using the `06-mesh-properties.html` example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`06-mesh-properties.html`示例来玩转这个属性。
- en: 'The next property on our list is one we haven''t talked about: `scale`. The
    name pretty much sums up what you can do with this property. You can scale the
    object along a specific axis. If you set the scale to values smaller than one,
    the object will shrink, as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个属性是我们还没有讨论过的：`scale`。这个名字几乎概括了你可以用这个属性做什么。你可以沿着特定的轴缩放对象。如果你将缩放设置为小于一的值，物体将缩小，如下面的截图所示：
- en: '![Functions and attributes for meshes](img/2215OS_02_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](img/2215OS_02_11.jpg)'
- en: 'When you use values larger than one, the object will become larger, as shown
    in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用大于一的值时，物体将变得更大，如下面的截图所示：
- en: '![Functions and attributes for meshes](img/2215OS_02_12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](img/2215OS_02_12.jpg)'
- en: 'The next part of the mesh that we''ll look at in this chapter is the **translate**
    functionality. With translate, you can also change the position of an object,
    but instead of defining the absolute position where you want the object to be,
    you define where the object should move to, relative to its current position.
    For instance, we have a sphere that is added to a scene, and its position has
    been set to `(1,2,3)`. Next, we translate the object along its *x* axis: `translateX(4)`.
    Its position will now be `(5,2,3)`. If we want to restore the object to its original
    position, we do this: `translateX(-4)`. In the `06-mesh-properties.html` example,
    there is a menu tab called **translate**. From there, you can experiment with
    this functionality. Just set the translate values for *x*, *y*, and *z* and hit
    the **translate** button. You''ll see the object being moved to a new position
    based on these three values.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的网格的下一部分功能是**平移**。使用平移功能，你还可以改变物体的位置，但不是定义物体想要到达的绝对位置，而是定义物体相对于当前位置应该移动到的地方。例如，我们有一个添加到场景中的球体，其位置已设置为`(1,2,3)`。接下来，我们沿着物体的*x*轴进行平移：`translateX(4)`。它的位置现在将是`(5,2,3)`。如果我们想将物体恢复到原始位置，我们这样做：`translateX(-4)`。在`06-mesh-properties.html`示例中，有一个名为**平移**的菜单标签。从那里，你可以尝试这个功能。只需设置*x*、*y*和*z*的平移值，然后点击**平移**按钮。你会看到物体根据这三个值移动到新的位置。
- en: 'The last property you can use from the menu in the top-right corner is the
    **visible** property. If you click on the **visible** menu item, you''ll see that
    the cube becomes invisible, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从右上角的菜单中使用的最后一个属性是**可见**属性。如果你点击**可见**菜单项，你会看到立方体变得不可见，如下所示：
- en: '![Functions and attributes for meshes](img/2215OS_02_13.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![网格的函数和属性](img/2215OS_02_13.jpg)'
- en: When you click on it another time, the cube becomes visible again. For more
    information on meshes, geometries, and what you can do with these objects, look
    at [Chapter 5](ch05.html "Chapter 5. Learning to Work with Geometries"), *Learning
    to Work with Geometries*, and [Chapter 7](ch07.html "Chapter 7. Particles, Sprites,
    and the Point Cloud"), *Particles, Sprites, and the Point Cloud*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次点击它时，立方体再次变得可见。有关网格、几何体以及你可以用这些对象做什么的更多信息，请参阅[第5章](ch05.html "第5章。学习与几何体一起工作")，*学习与几何体一起工作*，以及[第7章](ch07.html
    "第7章。粒子、精灵和点云")，*粒子、精灵和点云*。
- en: Different cameras for different uses
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的用途需要不同的相机
- en: 'There are two different camera types in Three.js: the orthographic camera and
    the perspective camera. In [Chapter 3](ch03.html "Chapter 3. Working with the
    Different Light Sources Available in Three.js"), *Working with the Different Light
    Sources Available in Three.js*, we''ll have a much more detailed look at how to
    work with these cameras, so in this chapter, I''ll stick to the basics. The best
    way to explain the differences between these cameras is by looking at a couple
    of examples.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中有两种不同的摄像机类型：正交摄像机和透视摄像机。在[第 3 章](ch03.html "第 3 章。在 Three.js 中使用不同的光源")《在
    Three.js 中使用不同的光源》中，我们将更详细地探讨如何使用这些摄像机，因此在本章中，我将专注于基础知识。解释这两种摄像机之间差异的最佳方式是通过查看几个示例。
- en: Orthographic camera versus perspective camera
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正交摄像机与透视摄像机
- en: 'In the examples for this chapter, you can find a demo called `07-both-cameras.html`.
    When you open this example, you''ll see something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，你可以找到一个名为 `07-both-cameras.html` 的演示。当你打开这个示例时，你会看到如下内容：
- en: '![Orthographic camera versus perspective camera](img/2215OS_02_14.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![正交摄像机与透视摄像机](img/2215OS_02_14.jpg)'
- en: This is called a perspective view and is the most natural view. As you can see
    from this figure, the farther away the cubes are from the camera, the smaller
    they are rendered.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为透视视图，是最自然的视图。正如你可以从这张图中看到的，立方体离摄像机越远，渲染得越小。
- en: 'If we change the camera to the other type supported by Three.js, the orthographic
    camera, you''ll see the following view of the same scene:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将摄像机切换到 Three.js 支持的另一种类型——正交摄像机，你将看到相同场景的以下视图：
- en: '![Orthographic camera versus perspective camera](img/2215OS_02_15.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![正交摄像机与透视摄像机](img/2215OS_02_15.jpg)'
- en: With the orthographic camera, all the cubes are rendered the same size; the
    distance between an object and the camera doesn't matter. This is often used in
    2D games such as *SimCity 4* and old versions of *Civilization*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正交摄像机时，所有立方体都以相同的大小渲染；物体与摄像机之间的距离并不重要。这通常用于像 *SimCity 4* 和旧版本的 *Civilization*
    这样的 2D 游戏。
- en: '![Orthographic camera versus perspective camera](img/2215OS_02_16.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![正交摄像机与透视摄像机](img/2215OS_02_16.jpg)'
- en: 'In our examples, we''ll use the perspective camera the most since it best resembles
    the real world. Switching cameras is really very easy. The following piece of
    code is called whenever you hit the switch camera button on the `07-both-cameras`
    example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将最常使用透视摄像机，因为它最接近现实世界。切换摄像机非常简单。以下代码块在点击 `07-both-cameras` 示例中的切换摄像机按钮时被调用：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this table, you can see that there is a difference in the way we create
    the camera. Let''s look at `THREE.PerspectiveCamera` first. This camera takes
    the following arguments:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格中，你可以看到我们在创建摄像机的方式上存在差异。让我们首先看看 `THREE.PerspectiveCamera`。这个摄像机接受以下参数：
- en: '| Argument | Description |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fov` | **FOV** stands for **Field Of View**. This is the part of the scene
    that can be seen from the position of the camera. Humans, for instance, have an
    almost 180-degree FOV, while some birds might even have a complete 360-degree
    FOV.But since a normal computer screen doesn''t completely fill our vision, normally
    a smaller value is chosen. Most often, for games, a FOV between 60 and 90 degrees
    is chosen.*Good default: 50* |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `fov` | **FOV** 代表 **视场**。这是从摄像机位置可以看到的场景部分。例如，人类几乎有 180 度的视场，而一些鸟类的视场甚至可能达到完整的
    360 度。但由于普通计算机屏幕并不能完全填满我们的视野，通常会选择较小的值。对于游戏来说，通常选择 60 到 90 度之间的 FOV。*好的默认值：50*
    |'
- en: '| `aspect` | This is the aspect ratio between the horizontal and vertical sizes
    of the area where we''re to render the output. In our case, since we use the entire
    window, we just use that ratio. The aspect ratio determines the difference between
    the horizontal FOV and the vertical FOV, as you can see in the following image.*Good
    default: window.innerWidth / window.innerHeight* |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `aspect` | 这是我们将要渲染输出的区域水平尺寸和垂直尺寸之间的宽高比。在我们的例子中，因为我们使用整个窗口，所以我们只使用那个比例。宽高比决定了水平视场和垂直视场之间的差异，正如你可以在以下图像中看到。*好的默认值：window.innerWidth
    / window.innerHeight* |'
- en: '| `near` | The `near` property defines from how close to the camera Three.js
    should render the scene. Normally, we set this to a very small value to directly
    render everything from the position of the camera.*Good default: 0.1* |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `near` | `near` 属性定义了 Three.js 应该从多近的距离渲染场景。通常，我们将这个值设置得非常小，以便直接从摄像机的位置渲染一切。*好的默认值：0.1*
    |'
- en: '| `far` | The `far` property defines how far the camera can see from the position
    of the camera. If we set this too low, a part of our scene might not be rendered,
    and if we set it too high, in some cases, it might affect the rendering performance.*Good
    default: 1000* |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `far` | `far`属性定义了相机从相机位置可以看到多远。如果我们设置得太低，场景的一部分可能不会被渲染，如果我们设置得太高，在某些情况下可能会影响渲染性能。*好的默认值：1000*
    |'
- en: '| `zoom` | The `zoom` property allows you to zoom in and out of the scene.
    When you use a number lower than `1`, you zoom out of the scene, and if you use
    a number higher than `1`, you zoom in. Note that if you specify a negative value,
    the scene will be rendered upside down.*Good default value: 1* |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `zoom` | `zoom`属性允许你放大或缩小场景。当你使用小于`1`的数字时，你会缩小场景，如果你使用大于`1`的数字，你会放大。请注意，如果你指定一个负值，场景将被渲染为颠倒的。*好的默认值：1*
    |'
- en: 'The following image gives a good overview of how these properties work together
    to determine what you see:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像给出了这些属性如何共同工作以确定你所看到的内容的概述：
- en: '![Orthographic camera versus perspective camera](img/2215OS_02_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![正交相机与透视相机对比](img/2215OS_02_17.jpg)'
- en: The `fov` property of the camera determines the horizontal FOV. Based on the
    `aspect` property, the vertical FOV is determined. The `near` property is used
    to determine the position of the near plane, and the `far` property determines
    the position of the far plane. The area between the near plane and the far plane
    will be rendered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的`fov`属性决定了水平FOV。基于`aspect`属性，垂直FOV被确定。`near`属性用于确定近平面的位置，而`far`属性确定远平面的位置。近平面和远平面之间的区域将被渲染。
- en: 'To configure the orthographic camera, we need to use other properties. The
    orthographic projection isn''t interested either in the aspect ratio to use or
    with what FOV we look at the scene since all the objects are rendered at the same
    size. What you do when you define an orthographic camera is define the cuboid
    area that needs to be rendered. The properties for the orthographic camera reflect
    this, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置正交相机，我们需要使用其他属性。正交投影对使用的纵横比或观察场景的FOV不感兴趣，因为所有对象都以相同的大小渲染。当你定义一个正交相机时，你实际上是在定义需要渲染的立方体区域。正交相机的属性反映了这一点，如下所示：
- en: '| Argument | Description |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `left` | This is described in the Three.js documentation as *Camera frustum
    left plane*. You should see this as what is the left-hand border of what will
    be rendered. If you set this value to `-100`, you won''t see any objects that
    are farther to the left-hand side. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `left` | 在Three.js文档中，这被描述为**相机视锥体左平面**。你应该将其视为将要渲染的左侧边界。如果你将此值设置为`-100`，你将看不到任何位于左侧更远处的对象。|'
- en: '| `right` | The `right` property works in a way similar to the `left` property,
    but this time, to the other side of the screen. Anything farther to the right
    won''t be rendered. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `right` | `right`属性的工作方式与`left`属性类似，但这次是屏幕的另一侧。任何位于右侧更远处的对象都不会被渲染。|'
- en: '| `top` | This is the top position to be rendered. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `top` | 这是将要渲染的顶部位置。|'
- en: '| `bottom` | This is the bottom position to be rendered. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `bottom` | 这是将要渲染的底部位置。|'
- en: '| `near` | From this point, based on the position of the camera, the scene
    will be rendered. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `near` | 从这个点开始，根据相机的位置，场景将被渲染。|'
- en: '| `far` | To this point, based on the position of the camera, the scene will
    be rendered. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `far` | 到这个点，根据相机的位置，场景将被渲染。|'
- en: '| `zoom` | This allows you to zoom in and out of the scene. When you use a
    number lower than `1`, you''ll zoom out of the scene; if you use a number higher
    than `1`, you''ll zoom in. Note that if you specify a negative value, the scene
    will be rendered upside down. The default value is `1`. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `zoom` | 这允许你放大或缩小场景。当你使用小于`1`的数字时，你会缩小场景；如果你使用大于`1`的数字，你会放大。请注意，如果你指定一个负值，场景将被渲染为颠倒的。默认值是`1`。|'
- en: 'All these properties can be summarized in the following figure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性可以总结如下图所示：
- en: '![Orthographic camera versus perspective camera](img/2215OS_02_18.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![正交相机与透视相机对比](img/2215OS_02_18.jpg)'
- en: Looking at specific points
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察特定点
- en: 'Until now, you''ve seen how to create a camera and what the various arguments
    mean. In the previous chapter, you also saw that you need to position your camera
    somewhere in the scene, and that the view from that camera is rendered. Normally,
    the camera is pointed to the center of the scene: position (0,0,0). We can, however,
    easily change what the camera is looking at, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何创建摄像机以及各种参数的含义。在前一章中，你也看到了你需要将摄像机放置在场景中的某个位置，并且从该摄像机看到的视图会被渲染。通常，摄像机指向场景的中心：位置（0,0,0）。然而，我们可以很容易地改变摄像机观察的点，如下所示：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I''ve added an example where the camera moves, and the point it is looking
    at is marked with a red dot, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个示例，其中摄像机在移动，它正在观察的点用红点标记，如下所示：
- en: '![Looking at specific points](img/2215OS_02_19.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![观察特定点](img/2215OS_02_19.jpg)'
- en: If you open the `08-cameras-lookat` example, you'll see the scene moving from
    left to right. The scene isn't really moving. The camera is looking at different
    points (see the red dot in the center), which gives the effect that the scene
    is moving from left to right. In this example, you can also switch cameras to
    the orthographic one. There, you see that changing the point the camera looks
    at has pretty much the same effect as with `THREE.PerspectiveCamera`. The interesting
    part to notice, though, is that with `THREE.OrthographicCamera`, you can clearly
    see that the sizes of all the cubes stay the same regardless of where the camera
    is looking.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`08-cameras-lookat`示例，你会看到场景从左向右移动。实际上场景并没有移动。摄像机正在观察不同的点（见中心的红点），这给人一种场景从左向右移动的错觉。在这个例子中，你还可以切换到正交摄像机。在那里，你会发现改变摄像机观察的点几乎与`THREE.PerspectiveCamera`有相同的效果。然而，值得注意的是，使用`THREE.OrthographicCamera`，你可以清楚地看到，无论摄像机看向哪里，所有立方体的尺寸都保持不变。
- en: '![Looking at specific points](img/2215OS_02_20.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![观察特定点](img/2215OS_02_20.jpg)'
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'When you use the `lookAt` function, you point the camera at a specific position.
    You can also use this to make the camera follow an object around the scene. Since
    every `THREE.Mesh` object has a position that is a `THREE.Vector3` object, you
    can use the `lookAt` function to point to a specific mesh in the scene. All you
    need to do is this: `camera.lookAt(mesh.position)`. If you call this in the render
    loop, you''ll make the camera follow an object as it moves through the scene.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`lookAt`函数时，你将摄像机指向一个特定位置。你也可以使用这个函数使摄像机围绕场景中的物体移动。由于每个`THREE.Mesh`对象都有一个位置，它是一个`THREE.Vector3`对象，你可以使用`lookAt`函数指向场景中的特定网格。你只需要做的是：`camera.lookAt(mesh.position)`。如果你在渲染循环中调用这个函数，摄像机就会随着物体在场景中的移动而移动。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We discussed a lot of items in this second introduction chapter. We showed all
    the functions and properties of `THREE.Scene` and explained how you can use these
    properties to configure your main scene. We also showed you how you can create
    geometries. You can either create them from scratch using a `THREE.Geometry` object
    or use any of the built-in geometries Three.js provides. Finally, we showed you
    how you can configure the two cameras Three.js provides. `THREE.PerspectiveCamera`
    renders a scene using a real-world perspective, and `THREE.OrthographicCamera`
    provides a fake 3D effect also often seen in games. We've also introduced how
    geometries work in Three.js. You can now easily create your own geometries.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二部分的介绍章节中，我们讨论了许多项目。我们展示了`THREE.Scene`的所有函数和属性，并解释了如何使用这些属性来配置你的主场景。我们还展示了如何创建几何体。你可以从头开始使用`THREE.Geometry`对象创建它们，或者使用Three.js提供的任何内置几何体。最后，我们展示了如何配置Three.js提供的两个摄像机。`THREE.PerspectiveCamera`使用现实世界的透视渲染场景，而`THREE.OrthographicCamera`提供了一种在游戏中也经常看到的假3D效果。我们还介绍了在Three.js中几何体是如何工作的。你现在可以轻松地创建自己的几何体。
- en: In the next chapter, we'll look at the various light sources that are available
    in Three.js. You'll learn how the various light sources behave, how to create
    and configure them, and how they affect specific materials.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Three.js中可用的各种光源。你将了解各种光源的行为，如何创建和配置它们，以及它们如何影响特定材料。
