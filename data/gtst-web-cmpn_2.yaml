- en: Web Components Life Cycle Callback Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 组件生命周期回调方法
- en: In the last chapter, we talked about how to create a Web Component using vanilla
    JavaScript and HTML5\. We discussed the specifications that are created in order
    to achieve the concept of Web Components. In this chapter, we will talk about
    life cycle events and the callback methods associated with them. A life cycle
    event is an event that occurs during the life cycle of a Web Component. This chapter
    deals with these events and how to access them with the help of callback methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何使用纯 JavaScript 和 HTML5 创建 Web 组件。我们讨论了创建 Web 组件概念所需的规范。在本章中，我们将讨论生命周期事件及其相关的回调方法。生命周期事件是在
    Web 组件的生命周期中发生的事件。本章将处理这些事件以及如何通过回调方法访问它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Overview of life cycle callback methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期回调方法的概述
- en: Life cycle callback methods currently available in Web Components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 组件中当前可用的生命周期回调方法
- en: Overview of life cycle callback methods
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期回调方法的概述
- en: Life cycle events are events that are triggered inside a web component when
    it reaches a certain stage of execution. These stages reflect the overall process
    of creating a web component and can be controlled with the help of life cycle
    callback methods. Life cycle callback methods are hooks or interfaces that get
    called back whenever a Web Component goes through these life cycle events.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期事件是在 Web 组件达到执行某个阶段时在组件内部触发的事件。这些阶段反映了创建 Web 组件的整体过程，并且可以通过生命周期回调方法来控制。生命周期回调方法是当
    Web 组件经过这些生命周期事件时被调用的钩子或接口。
- en: Let me explain this with the help of an example. Suppose you have a shoe that
    you would like to wear. There may be certain events associated with the life cycle
    of this shoe. Let's say you want to wear it. You put your foot in and tie the
    lace. This triggers an event called `lacesTied()`. Now, you as a user who is wearing
    this shoe may choose to act on it. You can write a conditional block to check
    whether `lacesTiedStrength > 100` or whether `shoeSize < requiredShoeSize`. It
    depends on what you want to do. Similarly, there are life cycle callback methods
    associated with a Web Component that help the user capture certain execution states
    and write code effectively.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我用一个例子来解释这一点。假设你有一双你想穿的鞋。这双鞋的生命周期可能有一些相关的事件。比如说，你想穿上它。你把脚伸进去，系上鞋带。这会触发一个名为
    `lacesTied()` 的事件。现在，作为穿着这双鞋的用户，你可以选择对其做出反应。你可以编写一个条件块来检查 `lacesTiedStrength >
    100` 或 `shoeSize < requiredShoeSize`。这取决于你想做什么。同样，与 Web 组件相关联的生命周期回调方法可以帮助用户捕捉到某些执行状态，并有效地编写代码。
- en: Types of life cycle callback methods
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期回调方法的类型
- en: 'There are four life cycle callbacks available to Web Components as of now.
    These are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 Web 组件有四个生命周期回调可用。具体如下：
- en: '`connectedCallback()`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connectedCallback()`'
- en: '`disconnectedCallback()`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnectedCallback()`'
- en: '`adoptedCallback()`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adoptedCallback()`'
- en: '`attributeChangedCallback()`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributeChangedCallback()`'
- en: Let's discuss them in detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论它们。
- en: connectedCallback()
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`connectedCallback()`'
- en: This interface/callback gets invoked every time a copy of a Web Component gets
    added to the DOM. This is very useful when it comes to initializing events associated
    with the DOM inside the component, or state management (see [Chapter 5](0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml), *Managing
    States and Props*), or anything that needs any sort of initialization or pre-checks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口/回调函数会在每次将一个 Web 组件的副本添加到 DOM 中时被调用。当需要在组件内部初始化与 DOM 相关的事件或状态管理（见[第 5 章](0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml)，*管理状态和属性*），或需要进行任何类型的初始化或预检查时，这非常有用。
- en: Let's take a look at an example. In [Chapter 1](a40f739f-c213-4862-a256-a7e76eff4370.xhtml),
    *Web Components Essentials and Specifications*, we talked about a `<student-attendance-table>`
    component, where the Web Component makes a fetch call to the file `student.json`, in
    order to retrieve the attendance data and then display that data in the form of
    a table.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。在[第 1 章](a40f739f-c213-4862-a256-a7e76eff4370.xhtml)，*Web 组件基础和规范*中，我们讨论了一个
    `<student-attendance-table>` 组件，其中 Web 组件会向 `student.json` 文件发起 fetch 调用，以检索出勤数据，然后以表格的形式显示这些数据。
- en: The correct way to write that Web Component would be to add a `connectedCallback()`
    method to the definition of the `StudentAttendenceTable` class and then make the
    fetch call inside this callback.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正确编写该 Web 组件的方法是在 `StudentAttendenceTable` 类的定义中添加一个 `connectedCallback()` 方法，然后在回调函数内部进行获取调用。
- en: 'This is what our code would look like:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的代码会看起来像这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the code, we are now making a call to fetch the student list
    inside the `connectedCallback()` method. This makes sure that the code gets executed,
    once the Web Component is attached to the web page.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在代码中所见，我们现在在 `connectedCallback()` 方法中调用获取学生列表。这确保了代码在 Web 组件附加到网页后执行。
- en: 'Another example of a place where using the `connectedCallback` is helpful is
    event handling. Let''s say we have a Web Component that shows a custom button.
    And the purpose of this button is to show some text right next to it stating the
    number of times the button was clicked. If we try to use it without `connectedCallback`,
    it would look something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `connectedCallback` 有帮助的另一个例子是事件处理。假设我们有一个显示自定义按钮的 Web 组件。这个按钮的目的是在它旁边显示一些文本，说明按钮被点击的次数。如果我们尝试在不使用
    `connectedCallback` 的情况下使用它，它看起来可能就像这样：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The associated HTML would look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的 HTML 会看起来像这样：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how an event listener is bound to the DOM in the `connectedCallback()`
    method. We will be talking about event listeners in detail in the [Chapter 5](0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml), *Managing
    States and Props*, but for now; we can use the code as an example. The preceding
    code makes sure that we bind a click event to the button only after the DOM is
    available on the page. This prevents us from creating event-related bugs, which
    I am sure has happened to every one of us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在 `connectedCallback()` 方法中绑定了一个事件监听器。我们将在第 5 章 [0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml]，*管理状态和属性*
    中详细讨论事件监听器，但现在；我们可以用代码作为例子。前面的代码确保只有在 DOM 可用后，才将点击事件绑定到按钮上。这可以防止我们创建与事件相关的错误，我相信这肯定发生在我们每个人身上。
- en: disconnectedCallback()
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: disconnectedCallback()
- en: Just like there are certain operations that need to be performed when a Web
    Component is added to the DOM, there are certain operations that need to be performed
    after the component is removed from the DOM. The most common example of this scenario
    is, again, event handlers. Event handlers consume memory, and, when the DOM associated
    with them is removed, the event handler is still on the page, listening to events,
    still consuming memory. The callback, `disconnectedCallback()`, gives Web Components
    a way to write code that can handle these scenarios.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在将 Web 组件添加到 DOM 时需要执行某些操作一样，在组件从 DOM 中移除后也需要执行某些操作。这种情况最常见的例子又是事件处理器。事件处理器消耗内存，当与它们关联的
    DOM 被移除时，事件处理器仍然在页面上监听事件，仍然消耗内存。回调函数 `disconnectedCallback()` 为 Web 组件提供了一种编写代码来处理这些情况的方法。
- en: 'Let''s take a look at the `<custom-button>` element and how we can use `disconnectedCallback()`
    to remove the attached event:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `<custom-button>` 元素，以及我们如何使用 `disconnectedCallback()` 来移除附加的事件：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you look at the `disconnectedCallback()` method, we have a `console.log`
    statement and the code to remove the event. When you are running this Web Component
    on a page, you can manually remove the component and see that `disconnectedCallback()`
    gets called automatically. I prefer going to the dev console and typing the following code
    to see it happen:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `disconnectedCallback()` 方法，我们会看到一个 `console.log` 语句和移除事件的代码。当你在一个页面上运行这个
    Web 组件时，你可以手动移除组件，并看到 `disconnectedCallback()` 会自动被调用。我更喜欢去开发者控制台，输入以下代码来观察这个过程：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will remove the first instance of `<custom-button>` from the page, thus
    triggering the `disconnectedCallback()` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从页面上移除第一个 `<custom-button>` 实例，从而触发 `disconnectedCallback()` 方法。
- en: Removing an event handler is only one of the uses. There can be *any* number
    of use cases that need to be performed before removing the Web Component from
    the DOM.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 移除事件处理器只是其中一种用途。在从 DOM 中移除 Web 组件之前，可能需要执行任何数量的用例。
- en: adoptedCallback()
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: adoptedCallback()
- en: This callback gets triggered when the Web Component is moved from one parent
    to another.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Web 组件从一个父元素移动到另一个父元素时，这个回调会被触发。
- en: 'Just like we had `connectedCallback` and `disconnectedCallback`, we can write
    `adoptedCallback` in the following way:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们有 `connectedCallback` 和 `disconnectedCallback` 一样，我们可以这样编写 `adoptedCallback`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: attributeChangedCallback()
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: attributeChangedCallback()
- en: Since all the custom elements act and behave like any other HTML element, they
    also have the ability to have attributes inside them. We will be discussing attributes
    in the coming chapter, but, for now, let's assume we have a custom element named
    `<my-name>`, whose purpose is to display the text Hello, my name is John Doe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有自定义元素都像任何其他 HTML 元素一样行动和表现，它们也有能力在其内部拥有属性。我们将在下一章讨论属性，但现在，让我们假设我们有一个名为 `<my-name>`
    的自定义元素，其目的是显示文本“Hello, my name is John Doe”。
- en: 'So, the definition of this Web Component would become something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个 Web 组件的定义可能如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s say we want to have a different name. And for every different name,
    we will need to have a different definition of the custom element, making a totally
    different Web Component. In order to fix this problem, we can use attributes.
    We can pass the name in an attribute inside the HTML tag of this element, making
    it look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要一个不同的名称。对于每个不同的名称，我们都需要为自定义元素定义一个不同的定义，从而创建一个完全不同的 Web 组件。为了解决这个问题，我们可以使用属性。我们可以在该元素的
    HTML 标签内的属性中传递名称，使其看起来像这样：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But, in order to make a Web Component use the attributes provided, we will
    first ask it to observe certain attributes, which we can provide in an array like
    this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了使 Web 组件使用提供的属性，我们首先要求它观察某些属性，我们可以像这样提供一个数组：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are just going to observe `fullname`. You can add more as per your
    requirement. We will be diving into attributes in the coming chapters.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将要观察 `fullname`。你可以根据需求添加更多。我们将在接下来的章节中深入探讨属性。
- en: 'Once we have started observing these attributes, we can then use the `attributeChangedCallback()`
    to make necessary changes to custom elements as per the requirement. I am simply
    updating the name in the following callback:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始观察这些属性，我们就可以使用 `attributeChangedCallback()` 方法根据需求对自定义元素进行必要的更改。我只是在下面的回调中更新了名称：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, `attributeChangedCallback()` takes in three parameters: `name`,
    which is the name of the attribute changed, and `oldValue` and `newValue`, which
    are the values before and after the change, respectively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`attributeChangedCallback()` 接收三个参数：`name`，即更改的属性的名称，以及 `oldValue` 和 `newValue`，分别是更改前后的值。
- en: In the preceding code, we are simply checking whether the name of the attribute
    is `fullname` and updating the text to say the updated name.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是检查属性的名称是否为 `fullname`，并将文本更新为更新的名称。
- en: 'The full component code looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的组件代码如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `index.html` file associated with it becomes as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与其相关的 `index.html` 文件如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we are not doing anything different than what we have done in
    the previous sections.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们并没有在前面章节中做任何不同的事情。
- en: Summary
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about what life cycle callback methods are and what
    purpose they serve. We talked about `connectedCallback()`, `disconnectedCallback()`,
    `adoptedCallback()`, and `attributeChangedCallback()`. We looked into various
    examples of how to use these callbacks and their practical uses.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了生命周期回调方法是什么以及它们的作用。我们讨论了 `connectedCallback()`、`disconnectedCallback()`、`adoptedCallback()`
    和 `attributeChangedCallback()`。我们探讨了如何使用这些回调及其实际用途的多种示例。
- en: In the next chapter, we will look into styling our Web Components with the help
    of CSS, and then we will talk about the gold standard checklist and its purpose.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用 CSS 来美化我们的 Web 组件，然后我们将讨论黄金标准清单及其目的。
