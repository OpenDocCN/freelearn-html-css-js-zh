- en: Chapter 3. Working with Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：与模型一起工作
- en: JavaScript models are an essential part of client-side data management. In stateful
    JavaScript applications, local or remote data is stored in models and the model
    provides a number of functions to work with this data such as conversions, validations,
    data persistence, and so on. Backbone models are no different than these and provide
    similar functionalities such as set/get data, validate, save to or fetch from
    the server, delete an attribute, and sync with the server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript模型是客户端数据管理的重要组成部分。在具有状态的状态JavaScript应用程序中，本地或远程数据存储在模型中，并且模型提供了一系列函数来处理这些数据，例如转换、验证、数据持久化等。Backbone模型与这些模型没有区别，并提供类似的功能，例如设置/获取数据、验证、保存到或从服务器获取、删除属性以及与服务器同步。
- en: 'In this chapter, we will discuss some basic problems with models that Backbone
    developers usually face, and will then propose some possible solutions to them.
    Also, we will cover a few interesting plugins and extensions for models that will
    help reduce boilerplate in your code. The main points to be covered are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论Backbone开发者通常遇到的一些模型基本问题，并提出一些可能的解决方案。此外，我们还将介绍一些有趣的模型插件和扩展，这些插件可以帮助减少代码中的样板代码。以下是需要涵盖的主要点：
- en: '**Basic usage of models**: Learn the basics of Backbone models, such as important
    methods, properties, and data operations.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型的基本用法**：学习Backbone模型的基础知识，例如重要方法、属性和数据操作。'
- en: '**Validating the data**: We will see how basic data validations are done with
    Backbone models. Also, we will analyze an important plugin, `Backbone.Validation`
    that helps us reduce lots of boilerplate validation code.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证数据**：我们将看到如何使用Backbone模型执行基本数据验证。此外，我们还将分析一个重要的插件`Backbone.Validation`，它可以帮助我们减少大量的样板验证代码。'
- en: '**Serializing models**: The data sent to the server or received from the server
    can be of different format than the format the model expects it to be. In this
    section, we will see how overriding the `parse`() and `toJSON()` methods help
    the model directly communicate with the server.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化模型**：发送到服务器或从服务器接收的数据格式可能与模型期望的格式不同。在本节中，我们将看到如何通过重写`parse()`和`toJSON()`方法来帮助模型直接与服务器通信。'
- en: '**Understanding relational data model**: We will read an analysis of nested
    models and collections with the help of the Backbone relational plugin.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解关系型数据模型**：我们将借助Backbone关系插件来阅读嵌套模型和集合的分析。'
- en: Basic usage of models
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型的基本用法
- en: 'Models are one of the most important components of Backbone. Starting from
    storing data, they provide a lot of functionality, including logic around the
    data, validations, data interactions, and so on. A model can be defined by extending
    the `Backbone.Model` class, shown as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是Backbone最重要的组件之一。从存储数据开始，它们提供了很多功能，包括数据逻辑、验证、数据交互等。一个模型可以通过扩展`Backbone.Model`类来定义，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A model consists of an `attributes` property that stores the data within it.
    You can get the model data using a `get()` method and set the data in `attributes`
    by using the `set()` method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 模型由一个`attributes`属性组成，该属性存储其内部的数据。你可以使用`get()`方法获取模型数据，并通过使用`set()`方法在`attributes`中设置数据：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `toJSON()` method of a model returns a copy of the model attributes as
    a JSON object. Note that the output has `age` now set to the new value. Whenever
    you change any attribute via the `set()` method, a `change` event gets fired on
    the model:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的`toJSON()`方法返回一个JSON对象，其中包含模型属性的副本。注意，输出现在将`age`设置为新的值。每次通过`set()`方法更改任何属性时，都会在模型上触发一个`change`事件：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `change` event for each changed attribute also gets fired:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个更改的属性都会触发`change`事件：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is quite beneficial when you want to update your views partially, because
    both the `change` and `change:age` events get fired in this case. You can listen
    only to a particular attribute change and act accordingly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想部分更新视图时，这非常有用，因为在这种情况下会触发`change`和`change:age`事件。你可以只监听特定属性的变化并相应地采取行动。
- en: Using the defaults property
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用默认属性
- en: 'In some cases, you may want your model to have a set of default values until
    new data is added to it. Backbone provides a `defaults` property where you can
    specify the initial data, as shown in the following code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望你的模型在添加新数据之前具有一组默认值。Backbone提供了一个`defaults`属性，你可以在这里指定初始数据，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When added for every instance of the model, any unspecified attribute will automatically
    be set to the default value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当为模型的每个实例添加时，任何未指定的属性将自动设置为默认值。
- en: Avoiding object references in the defaults property
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免在 `defaults` 属性中使用对象引用
- en: 'Make sure that you never use any object or array directly in the `defaults`
    property. This is because the objects are shared by reference in JavaScript, and
    if added into `defaults`, the objects will get shared among all the instances
    of the model. An example follows to explain the case:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您永远不要在 `defaults` 属性中直接使用任何对象或数组。这是因为 JavaScript 中的对象是通过引用共享的，如果添加到 `defaults`
    中，这些对象将在模型的各个实例之间共享。以下是一个示例来解释这种情况：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will see that the `hobbies` array now becomes a shared property between
    both the instances of the model. This is not a desired case and you should always
    avoid putting objects as default attributes. The solution to this problem can
    be achieved by using a function for the `defaults` property instead of an object:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到 `hobbies` 数组现在成为模型两个实例之间的共享属性。这不是一个期望的情况，您应该始终避免将对象作为默认属性。可以通过使用函数而不是对象来为
    `defaults` 属性解决问题：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function will get executed every time a model instance is created, and
    thus will always send a new object for `defaults`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会在每次创建模型实例时执行，因此总是会为 `defaults` 发送一个新的对象。
- en: Data interaction with the server
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与服务器进行数据交互
- en: The Backbone model has made data operations with the server quite easy by providing
    a set of interesting methods such as `fetch()`, `save()`, `sync()`, and `destroy()`.
    Let's look into each of these methods one by one. We will use the same user model
    as we did earlier.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 模型通过提供一系列有趣的方法，如 `fetch()`、`save()`、`sync()` 和 `destroy()`，使得与服务器进行数据操作变得非常简单。让我们逐一查看这些方法。我们将使用之前相同的用户模型。
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a model
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个模型
- en: 'In general, if you set new values to the model and call the `save()` method
    on it, your server should create a new model in the database. Next time onwards,
    the model will carry this `id` attribute and calling the `save()` method again
    should only update the model and not create a new one:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您将新值设置到模型中并对其调用 `save()` 方法，您的服务器应该在数据库中创建一个新的模型。从下一次开始，模型将携带这个 `id` 属性，再次调用
    `save()` 方法应该只更新模型而不是创建一个新的模型：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As no `id` attribute is present there yet, a POST request is sent to the `/users`
    URL and the server sends a response with the new ID.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前还没有 `id` 属性，因此发送一个 POST 请求到 `/users` URL，服务器会发送一个包含新 ID 的响应。
- en: Updating a model
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新一个模型
- en: 'Updating a model is also similar. If there is an `id` attribute present, the
    same `save()` method sends a PUT request to the server with new attributes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 更新一个模型的过程也类似。如果存在 `id` 属性，相同的 `save()` 方法会向服务器发送一个带有新属性的 PUT 请求：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Fetching a model
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取一个模型
- en: 'If the `id` attribute is present, the `fetch()` method of the model sends a
    GET request to retrieve and populate the model:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在 `id` 属性，模型的 `fetch()` 方法会发送一个 GET 请求以检索并填充模型：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Deleting a model
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除一个模型
- en: 'Use the `destroy()` method to delete a model. This method sends a DELETE request
    to the server with the model ID:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `destroy()` 方法删除一个模型。此方法向服务器发送一个带有模型 ID 的 DELETE 请求：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Validating the data
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证数据
- en: 'In Backbone, validation is taken care of by the `model.validate()` method.
    By default, the `Backbone.Model` class doesn''t have a `validate()` method on
    its own. However, the developers are encouraged to add a `validate()` method that
    gets called by the model every time an attribute is saved or set with `validate:
    true` passed. A copy of the attributes is sent to the `validate()` method with
    all the changed values. Let''s look at a simple data validation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Backbone 中，验证由 `model.validate()` 方法处理。默认情况下，`Backbone.Model` 类本身没有 `validate()`
    方法。然而，开发者被鼓励添加一个 `validate()` 方法，该方法在每次使用 `validate: true` 传递时被模型调用。所有更改的值都会发送到
    `validate()` 方法的一个属性副本。让我们看看一个简单的数据验证示例：'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we created a model with the two attributes `name` and `email`, added a
    `validate()` method to test the values of these attributes, and defined a view
    that will handle the validation errors, if any.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个具有两个属性 `name` 和 `email` 的模型，添加了一个 `validate()` 方法来测试这些属性的值，并定义了一个视图来处理可能出现的验证错误。
- en: 'As we are setting both the values in a single `set()` method, the `validate()`
    method will be called only once. However, it will return an error as soon as it
    finds an invalid attribute. What if we want to display all the errors together
    on our form? In that case, we must return an array or an object with all the error
    messages as shown in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是在单个 `set()` 方法中设置两个值，所以 `validate()` 方法只会被调用一次。然而，一旦它发现一个无效属性，它就会返回一个错误。如果我们想在表单上一起显示所有错误怎么办？在这种情况下，我们必须返回一个包含所有错误信息的数组或对象，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we will receive an object with all the errors. This is useful while you
    need to show data individually even when they are set one by one. For example,
    this will be handy while we want to validate a field on blur event.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将接收到一个包含所有错误的对象。当你需要单独显示数据，即使它们一个接一个地设置时，这很有用。例如，当我们在 blur 事件上验证字段时，这将非常有用。
- en: Using the Backbone.Validation plugin
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Backbone.Validation 插件
- en: So, we just saw a simple implementation of data validation. However, when there
    are lots of form fields with multiple validation criteria, the `validate()` method
    becomes too large with several nested if-else conditions. Creating the complete
    validation logic from scratch may make it more complicated and time-consuming.
    Fortunately, there is a wonderful plugin called `Backbone.Validation` ([http://thedersen.com/projects/backbone-validation/](http://thedersen.com/projects/backbone-validation/)),
    which makes things a lot easier by providing multiple built-in validation methods
    and simplifying the validation binding with views. Let's reimplement the previous
    validation with this plugin.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚看到了数据验证的简单实现。然而，当有大量具有多个验证标准的表单字段时，`validate()` 方法会变得很大，包含多个嵌套的 if-else
    条件。从头开始创建完整的验证逻辑可能会使其更加复杂和耗时。幸运的是，有一个叫做 `Backbone.Validation` 的出色插件（[http://thedersen.com/projects/backbone-validation/](http://thedersen.com/projects/backbone-validation/))，它通过提供多个内置验证方法和简化与视图的验证绑定，使事情变得容易得多。让我们使用这个插件重新实现之前的验证。
- en: Configuring validation rules
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置验证规则
- en: 'There are a number of built-in validators, such as `required`, `maxLength`,
    `minLength`, `max`, `min`, `length`, and `pattern`. They are used as shown in
    the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多内置验证器，例如 `required`、`maxLength`、`minLength`、`max`、`min`、`length` 和 `pattern`。它们的使用方法如下所示：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are some existing validation patterns such as e-mail, number, and URL.
    Alternatively, you can use a regular expression as a pattern. Similarly, you may
    need to define the complete validation functionality for an attribute rather than
    just a regular expression. In that case, you can add custom method validators
    to an attribute. Check the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些现有的验证模式，如电子邮件、数字和 URL。或者，你可以使用正则表达式作为模式。同样，你可能需要为属性定义完整的验证功能，而不仅仅是正则表达式。在这种情况下，你可以向属性添加自定义方法验证器。查看以下示例：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can add the custom method to an attribute directly as a function or you
    can add the method name as a string, just like we did here. Every attribute can
    have one error message for each validation rule, or it can have a single one for
    all its validation rules. For example, in the following code, we provide separate
    messages for the `required` and `format` validations of `email`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接将自定义方法添加到属性中作为一个函数，或者你可以将方法名作为字符串添加，就像我们在这里做的那样。每个属性可以为每个验证规则有一个错误消息，或者它可以为所有验证规则有一个单一的错误消息。例如，在以下代码中，我们为
    `email` 的 `required` 和 `format` 验证提供了单独的消息：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Prevalidating a model with the preValidate() method
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 preValidate() 方法预先验证模型
- en: 'This plugin provides another important functionality to prevalidate an attribute
    of the model without touching the model itself, shown as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件还提供了另一个重要的功能，即在不接触模型本身的情况下预先验证模型的属性，如下所示：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, the attribute will be validated against the set of validators assigned to
    it, and the return value will be an error message if validation fails.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该属性将与其分配的验证器集进行验证，如果验证失败，返回值将是一个错误信息。
- en: The `Backbone.Validation` plugin is very effective if your application needs
    several form validations. It removes a lot of boilerplate from your code base
    and provides a simple yet robust validation mechanism.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要多个表单验证，`Backbone.Validation` 插件非常有效。它从你的代码库中移除了许多样板代码，并提供了一个简单而健壮的验证机制。
- en: Serializing models
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化模型
- en: 'So far, the model data we used in our examples in the previous chapters are
    all simple data objects with attributes. However, there might be a case where
    the server is sending a different data format and you need to extract the essential
    part from it and apply it to the related model. For example, consider the following
    data:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在前几章的示例中使用的模型数据都是简单的具有属性的数据对象。然而，可能存在服务器发送不同数据格式的情况，你需要从中提取关键部分并将其应用于相关模型。例如，考虑以下数据：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead of sending the preceding data, the server returns the following data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代替发送前面的数据，服务器返回以下数据：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This data cannot be applied directly to a model with the attributes `name`
    and `email`. If we call the `fetch()` method on the model now, it will just add
    another attribute named `user` to the model. The method that can help us overcome
    this issue is called `parse()`. By default, this method just passes the server
    response and the model applies whatever it receives from the `parse()` method.
    Here is how it is defined in `Backbone.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这份数据不能直接应用于具有 `name` 和 `email` 属性的模型。如果我们现在对模型调用 `fetch()` 方法，它将只是向模型添加另一个名为
    `user` 的属性。可以帮助我们克服这个问题的方法称为 `parse()`。默认情况下，这个方法只是传递服务器响应，模型应用从 `parse()` 方法接收到的任何内容。这是在
    `Backbone.js` 中如何定义的：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, we can override the `parse()` method to modify the raw server response
    and send back only the attribute `hash`. For this case, an object with the `name`
    and `email` attributes should be returned from the `parse()` method, as shown
    in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以覆盖 `parse()` 方法来修改原始服务器响应，并只发送属性 `hash`。对于这种情况，`parse()` 方法应返回一个具有 `name`
    和 `email` 属性的对象，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the `server.json` file consists of the newly formatted data. In the `parse()`
    method, we are parsing the response and returning data that the Backbone model
    can accept.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`server.json` 文件包含新格式化的数据。在 `parse()` 方法中，我们正在解析响应并返回 Backbone 模型可以接受的数据。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that the `fetch()` method will not clear your model, but will extend
    the attributes only. So if in our case, the server sends only an e-mail in the
    response, the previous e-mail will get updated, but the name will still be what
    it was.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`fetch()` 方法不会清除你的模型，但只会扩展属性。所以，在我们的例子中，如果服务器只发送一个电子邮件作为响应，之前的电子邮件将被更新，但名称仍然保持不变。
- en: 'Similar to fetching data from the server, sending data to it can also face
    the same problem, that is, the server may expect the exact format in which it
    sends data to the model. Now, if we call the `save()` method on the model, it
    will send the data in the following format:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与从服务器获取数据类似，向服务器发送数据也可能遇到相同的问题，即服务器可能期望它发送给模型的确切格式。现在，如果我们对模型调用 `save()` 方法，它将以以下格式发送数据：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, if the server expects the data in the same format as it is sending now,
    we need to override the `toJSON()` method, which is pretty straightforward. In
    the following code, we create a new object with the `user` property and return
    that object from the `toJSON()` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果服务器期望的数据格式与现在发送的格式相同，我们需要覆盖 `toJSON()` 方法，这相当简单。在下面的代码中，我们创建了一个具有 `user`
    属性的新对象，并从 `toJSON()` 方法返回该对象：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The request will be sent to the server with the following data, which is exactly
    what we were looking for:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将以以下数据发送到服务器，这正是我们所寻找的：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, this process has a downside. In most cases, we use the `toJSON()`
    method to get the model attributes hash directly. As we are overriding this method
    here, the data returned will differ from the expected data. So, you need to decide
    whether you will follow this approach to serialize the model or implement server-side
    interaction separately. If you go for this process, remember to apply the model
    data accordingly in your views when using the `toJSON()` method. Or alternatively,
    you can clone the `model.attributes` property to get the `hash` attribute:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个过程有一个缺点。在大多数情况下，我们使用 `toJSON()` 方法直接获取模型属性哈希。由于我们在这里覆盖了这个方法，返回的数据将与预期数据不同。因此，你需要决定你是否将采用这种方法来序列化模型或单独实现服务器端交互。如果你选择这个过程，记得在使用
    `toJSON()` 方法时相应地应用模型数据。或者，你也可以克隆 `model.attributes` 属性以获取 `hash` 属性：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is better not to use the `model.attributes` property directly. Manipulating
    the `hash` attribute directly can potentially cause some unexpected consequences,
    as the object will be passed by reference.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不直接使用 `model.attributes` 属性。直接操作 `hash` 属性可能会引起一些意外的后果，因为对象将通过引用传递。
- en: Understanding the relational data model
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解关系型数据模型
- en: All the examples we have gone through so far have used simple models to represent
    data. However, in any nontrivial application, the data structure is much more
    complex, and the relationships among entities are multi-relational. For any medium-
    or large-level application, there will be lots of one-to-one, one-to-many, and
    many-to-one relations. Keeping these relations synced with the server often becomes
    a tedious job, especially while saving or fetching data with multiple requests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所讨论的所有示例都使用了简单的模型来表示数据。然而，在任何非平凡的应用中，数据结构都要复杂得多，实体之间的关系是多重关系的。对于任何中等或大型应用，都存在大量的一对一、一对多和多对一关系。保持这些关系与服务器同步通常变得是一项繁琐的工作，尤其是在使用多个请求保存或检索数据时。
- en: 'While researching for this book, I found that most Backbone developers, at
    some point of their learning phase, have faced issues with nested models and collections.
    Fortunately, there is a great plugin known as Backbone-relational ([http://backbonerelational.org/](http://backbonerelational.org/)),
    developed by Paul Uithol, which minimizes the Backbone model hand-holding by syncing
    the model and all its related models with a single `save()` or `fetch()` method.
    It provides some great features that include the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究这本书的过程中，我发现大多数 Backbone 开发者在学习阶段某个时候都遇到过嵌套模型和集合的问题。幸运的是，有一个名为 Backbone-relational
    的优秀插件（[http://backbonerelational.org/](http://backbonerelational.org/)），由 Paul
    Uithol 开发，通过使用单个 `save()` 或 `fetch()` 方法同步模型及其所有相关模型，最小化了 Backbone 模型手动管理。它提供了一些很棒的特性，包括以下内容：
- en: Bidirectional relations that notify related models of changes through events
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向关系，通过事件通知相关模型的变化
- en: Control over how relations are serialized
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制关系序列化的方式
- en: Automatic conversion of nested objects in a model's attributes into model instances
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型属性中的嵌套对象自动转换为模型实例
- en: Easy retrieval of a set of related models
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松检索一组相关模型
- en: Determining the type of `HasMany` collections
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定 `HasMany` 集合的类型
- en: 'We will look into a simple example with company-employee relationship to explain
    the concept of the Backbone-relational plugin:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个简单的公司-员工关系示例来解释 Backbone-relational 插件的原理：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here we created a company-employees one-to-many relationship. In the company
    model configuration, you need to define the relation type that is used to create
    a `Backbone.Relation` instance at first. The `type` relation property can be `Backbone.HasMany`,
    `Backbone.HasOne`, or a direct reference to a particular relation instance. You
    also need to specify the attribute of the company model that holds all the employee
    models. Once the basic configuration is done, we will define the `Employee` model
    and `Employees` collection. Let''s test the relationship with some dummy data
    now:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个公司-员工的一对多关系。在公司模型配置中，你需要定义用于创建 `Backbone.Relation` 实例的关系类型。`type`
    关系属性可以是 `Backbone.HasMany`、`Backbone.HasOne` 或对特定关系实例的直接引用。你还需要指定公司模型中包含所有员工模型的属性。一旦完成基本配置，我们将定义
    `Employee` 模型和 `Employees` 集合。现在让我们用一些虚拟数据来测试这个关系：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We've now created a fully-managed relation. When you add or remove models from
    `innofied.employees` or update `employee.worksIn`, the other side of the relation
    automatically gets updated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个完全管理的关联。当你从 `innofied.employees` 中添加或删除模型或更新 `employee.worksIn` 时，关系的另一侧会自动更新。
- en: The previous mentioned code is just an elementary example of the Backbone-relational
    model. Once you go through their complete documentation, you will find that the
    plugin provides many features that can enhance application development process
    to a great extent.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的代码只是 Backbone-relational 模型的基本示例。一旦你阅读了他们的完整文档，你会发现该插件提供了许多可以极大地增强应用开发过程的特性。
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed some basic problems around Backbone models that lots
    of developers face, and described how we can approach these issues in our projects.
    We learned about basic data validation as well as getting all the error messages
    together from our validate method. Also, we saw how using the Backbone validation
    plugin can reduce our efforts when performing data validation by providing lots
    of inbuilt features.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了围绕 Backbone 模型的一些基本问题，以及我们如何在项目中解决这些问题。我们学习了基本的数据验证，以及如何从我们的 validate 方法中收集所有错误消息。此外，我们还看到了如何使用
    Backbone 验证插件通过提供许多内置特性来减少数据验证时的努力。
- en: If the data sent from the server has a different format from what a model expects,
    we now know how to override the `parse()` method to overcome this issue. Similarly,
    we override the `toJSON()` method to change the format of data that will be passed
    to the server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器发送的数据格式与模型期望的不同，我们现在知道如何覆盖`parse()`方法来解决这个问题。同样，我们也覆盖了`toJSON()`方法来改变将传递给服务器的数据格式。
- en: For most nontrivial applications, a nested model relationship is an essential
    requirement, and the Backbone-relational plugin can provide a ready-made solution
    for that. The plugin is widely accepted by the Backbone community and a lot of
    projects are currently using it successfully.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数非平凡应用，嵌套模型关系是一个基本要求，Backbone-relational插件可以为此提供一个现成的解决方案。该插件被Backbone社区广泛接受，并且许多项目目前正在成功使用它。
- en: There are some important topics to cover when working with models, such as collections,
    events, and sync. We are going to cover each of these points separately in the
    following chapters. The events and sync functionality is discussed in detail in
    [Chapter 6](ch06.html "Chapter 6. Working with Events, Sync, and Storage"), *Working
    with Events, Sync, and Storage*. In the next chapter, we will discuss the different
    functionalities of Backbone collections, basic and multiple sorting, filtering
    mechanisms, and collections with multiple model types.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模型时，有一些重要的话题需要讨论，例如集合、事件和同步。我们将在接下来的章节中分别详细讨论这些点。事件和同步功能在[第6章](ch06.html
    "第6章。处理事件、同步和存储")*处理事件、同步和存储*中进行了详细讨论。在下一章中，我们将讨论Backbone集合的不同功能，基本和多种排序，过滤机制，以及具有多种模型类型的集合。
