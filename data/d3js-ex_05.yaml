- en: Chapter 5. Using Data and Scales
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用数据和尺度
- en: In [Chapter 4](ch04.html "Chapter 4. Creating a Bar Graph"), *Creating a Bar
    Graph*, you learned how to create a bar graph that was based upon a sequence of
    integers that were statically coded within the application. Although the resulting
    graph looks quite nice, there are several issues with the way the data is provided
    and rendered.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。创建条形图")中，*创建条形图*，你学习了如何创建基于在应用程序中静态编码的整数序列的条形图。尽管生成的图表看起来相当不错，但在数据提供和渲染的方式上存在几个问题。
- en: One of the issues is that the data is hard-coded within the application. Almost
    invariably, we are going to load the data from an external source. D3.js provides
    a rich set of functionalities for loading data from sources over the web, and
    which is represented in different formats. In this chapter, you will learn to
    use D3.js for loading data from the web in JSON, CSV, and TSV formats.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是数据是硬编码在应用程序中的。几乎无一例外，我们将从外部源加载数据。D3.js提供了一套丰富的功能，可以从网络上的不同格式的源加载数据。在本章中，你将学习如何使用D3.js从网络以JSON、CSV和TSV格式加载数据。
- en: A second issue with the data in the example given in the previous chapter was
    that it was simply an array of integers. Data will often be represented as collections
    of objects with multiple properties, many of which we do not need for our visualization.
    They are also often represented as strings instead of numeric values. In this
    chapter, you will learn how to select just the data that you want and to convert
    it to the desired data type.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章给出的示例中，数据存在第二个问题是它只是一个整数的数组。数据通常会被表示为具有多个属性的对象集合，其中许多属性我们不需要用于我们的可视化。它们也经常被表示为字符串而不是数值。在本章中，你将学习如何选择你想要的数据并将其转换为所需的数据类型。
- en: Yet another issue in our previous bar graph was that we assumed that the values
    represented in the data had a direct mapping to the pixels in the visualization.
    This is normally not the case, and we need to scale the data into the size of
    our rendering in the browser. This can be easily accomplished using scales, which
    we already examined relative to axes, and now we will apply them to data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的条形图中，还有一个问题是假设数据中表示的值与可视化中的像素有直接映射。这通常不是情况，我们需要将数据缩放到浏览器中渲染的大小。这可以通过使用尺度轻松实现，我们已经相对于坐标轴进行了考察，现在我们将它们应用于数据。
- en: One last issue in the previous example was that our code for calculating the
    size and positions of the bars was performed manually. Bar graphs are common enough
    in D3.js applications, and there are built-in functions that can do this for us
    automatically. We will examine using these to simplify our code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，最后一个问题是我们的代码是手动计算条的大小和位置的。条形图在D3.js应用程序中很常见，并且有内置的函数可以自动为我们完成这项工作。我们将考察如何使用这些函数来简化我们的代码。
- en: 'So let''s jump in. In this chapter, we will specifically cover the following
    topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧。在本章中，我们将具体涵盖以下主题：
- en: Loading data in JSON, TSV, or CSV formats from the Web
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络加载JSON、TSV或CSV格式的数据
- en: Extracting fields from objects using the `.map()` function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.map()`函数从对象中提取字段
- en: Converting string values into their representative numeric data types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串值转换为它们的代表数值数据类型
- en: Using linear scales for transforming continuous values
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线性尺度转换连续值
- en: Using ordinal scales for mapping discrete data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用序数尺度映射离散数据
- en: Using bands for calculating the size and position of our bars
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带区计算条的大小和位置
- en: Applying what we've learned to date for creating a rich bar graph using real
    data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们迄今为止学到的知识应用于创建使用真实数据的丰富条形图
- en: Data
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据
- en: Data is the core of creating a data visualization. Almost every visual item
    created in D3 will need to be bound to a piece of data. This data can come from
    a number of sources. It can be explicitly coded in the visualization, loaded from
    an external source, or result from manipulation or calculation from other data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是创建数据可视化的核心。在D3中创建的几乎每个视觉元素都需要绑定到一些数据上。这些数据可以来自多个来源。它可以明确地编码在可视化中，从外部源加载，或者由其他数据的操作或计算结果而来。
- en: Most data used to create a D3.js visualization is either obtained from a file
    or a web service or URL. This data is often in one of many formats such as JSON,
    XML, **CSV** (**Comma Separated Values**), and **TSV** (**Tab Separated Values**).
    We will need to convert the data in these formats into JavaScript objects, and
    D3.js provides us with convenient functions for doing this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建 D3.js 可视化的数据大多是从文件、网络服务或 URL 获取的。这些数据通常以 JSON、XML、**CSV**（逗号分隔值）和 **TSV**（制表符分隔值）等多种格式之一存在。我们需要将这些格式的数据转换为
    JavaScript 对象，而 D3.js 提供了方便的函数来完成这项工作。
- en: Loading data with D3.js
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 D3.js 加载数据
- en: 'D3.js provides a number of helper functions to load data from outside the browser
    as well as to simultaneously convert it into JavaScript objects. Probably, the
    most common data formats that you may come across and which we will cover are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 提供了多个辅助函数，可以从浏览器外部加载数据，并将其同时转换为 JavaScript 对象。你可能遇到的最常见的几种数据格式，我们也将涉及，包括：
- en: JSON
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: TSV
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TSV
- en: CSV
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that I have omitted XML from the list in our examples.
    D3.js does have functions to load XML, but unlike with JSON, TSV and CSV, the
    results of the load are not converted automatically into JavaScript objects, and
    require additional manipulation using the JavaScript XML/DOM facilities. XML will
    be considered out of scope for this text as most of the scenarios you will currently
    come across will be handled with these three formats, if not solely by JSON, which
    has become almost the ubiquitous data format for the Web.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在我们的示例中，我排除了 XML。D3.js 确实有加载 XML 的函数，但与 JSON、TSV 和 CSV 不同，加载的结果不会自动转换为
    JavaScript 对象，需要使用 JavaScript XML/DOM 功能进行额外的操作。由于大多数你目前会遇到的情况都将由这三种格式处理，如果不仅仅是
    JSON，而 JSON 已经成为网络几乎无处不在的数据格式，因此 XML 将不在此文本的范围内。
- en: To demonstrate working with all these formats of data, we will examine a dataset
    that I have put together and placed in a GitHub that represents the viewership
    of the episodes of Season 5 of AMC's *The Walking Dead*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示处理所有这些数据格式，我们将检查一个数据集，我将其整理并放置在 GitHub 上，该数据集代表了 AMC 电视剧《行尸走肉》第五季的观众收视率。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This GitHub was built manually using data on [https://en.wikipedia.org/wiki/The_Walking_Dead_(season_5)](https://en.wikipedia.org/wiki/The_Walking_Dead_(season_5)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 GitHub 是手动使用 [https://en.wikipedia.org/wiki/The_Walking_Dead_(season_5)](https://en.wikipedia.org/wiki/The_Walking_Dead_(season_5))
    上的数据构建的。
- en: Loading JSON data
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载 JSON 数据
- en: Data in the **JavaScript Object Notation** (**JSON**) format is convenient for
    conversion into JavaScript objects. It is a very flexible format which supports
    named properties as well as hierarchical data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法**（**JSON**）格式的数据便于转换为 JavaScript 对象。它是一个非常灵活的格式，支持命名属性以及层次化数据。'
- en: The JSON data for this example is stored in GitHub and is available at [https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的 JSON 数据存储在 GitHub 上，可在 [https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json)
    找到。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The URL is a little unwieldy. You can go directly to the gist with all three
    versions of this data at [https://goo.gl/OfD1hc](https://goo.gl/OfD1hc).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: URL 稍显复杂。你可以直接访问包含此数据三个版本的 gist [https://goo.gl/OfD1hc](https://goo.gl/OfD1hc)。
- en: 'Clicking on the link will display the data in the browser. This file contains
    an array of JavaScript objects, each of which has six properties and represents
    an individual episode of the program. The first two objects are the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接将在浏览器中显示数据。此文件包含一个 JavaScript 对象数组，每个对象都有六个属性，代表该节目的单个剧集。前两个对象如下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This data can be loaded into our D3.js application using the `d3.json()` function.
    This function, like many others in D3.js, performs asynchronously. It takes two
    parameters: the URL of the data to load, and a callback function that is called
    when the data has been loaded.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `d3.json()` 函数将此数据加载到我们的 D3.js 应用程序中。这个函数，像 D3.js 中的许多其他函数一样，是异步执行的。它接受两个参数：要加载的数据的
    URL，以及当数据加载完成时被调用的回调函数。
- en: The following example demonstrates loading this data and displaying the first
    item in the array.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了加载数据并显示数组中的第一个项目。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.1): [http://goo.gl/Qe63wH](http://goo.gl/Qe63wH)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.1): [http://goo.gl/Qe63wH](http://goo.gl/Qe63wH)'
- en: 'The main portion of the code that loads the data is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据的主要代码如下：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There is no visible output from this example, but the output is written to
    the JavaScript console:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例没有可见的输出，但输出被写入 JavaScript 控制台：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the loading of data in D3.js is performed asynchronously. The output
    from the `console.log()` call shows that the data is loaded asynchronously and
    is executed first. Later, when the data is loaded, we see the output from the
    second call to `console.log()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，D3.js 中的数据加载是异步进行的。`console.log()` 调用的输出显示数据是异步加载的，并且首先执行。稍后，当数据加载完成后，我们会在第二次调用
    `console.log()` 中看到输出。
- en: The callback function itself has two parameters. The first is a reference to
    an object representing an error if one occurs. In such a case, this variable will
    be non-null and contain details. Non-null means the data was loaded, and is represented
    by the data variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数本身有两个参数。第一个是一个表示错误的对象的引用。在这种情况下，该变量将非空并包含详细信息。非空表示数据已加载，并由数据变量表示。
- en: Loading TSV data
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载 TSV 数据
- en: TSV is a type of data that you will come across if you do enough D3.js programming.
    In a TSV file, the values are separated by tab characters. Generally, the first
    line of the file is a tab-separated sequence of names for each of the values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TSV 是你在进行足够的 D3.js 编程时会遇到的一种数据类型。在 TSV 文件中，值由制表符分隔。通常，文件的第一个行是每个值的名称的制表符分隔序列。
- en: TSV files have the benefit of being less verbose than JSON files, and are often
    generated automatically by many systems that are not JavaScript based.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: TSV 文件比 JSON 文件更简洁，并且通常由许多非 JavaScript 基础的系统自动生成。
- en: The episode data in the TSV format is available at [https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.tsv](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.tsv).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: TSV 格式的剧集数据可在以下链接找到：[https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.tsv](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.tsv).
- en: 'Clicking on the link, you will see the following in your browser:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接，你将在浏览器中看到以下内容：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can load the data from this file using `d3.tsv()`. The following contains
    the code for the example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `d3.tsv()` 从此文件加载数据。以下包含示例代码：
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.2): [http://goo.gl/nlq8jy](http://goo.gl/nlq8jy)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.2): [http://goo.gl/nlq8jy](http://goo.gl/nlq8jy)'
- en: The code is identical to the JSON example except for the URL and the call to
    `d3.json()`. The output in the console is, however, different.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与 JSON 示例相同，只是 URL 和 `d3.json()` 调用不同。然而，控制台输出却是不同的。
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the properties **Episode**, **Season**, **SeriesNumber**, and **USViewers**
    are now of type string instead of integer. TSV files do not have a means of implying
    the type like JSON does, so everything defaults to string. These will often need
    to be converted to another type, and we will examine that in the next section
    on mapping and data conversion.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性 **Episode**、**Season**、**SeriesNumber** 和 **USViewers** 现在是字符串类型，而不是整数类型。TSV
    文件没有像 JSON 那样暗示类型的手段，所以所有内容默认为字符串。这些通常需要转换为其他类型，我们将在下一节关于映射和数据转换中探讨这一点。
- en: Loading CSV data
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载 CSV 数据
- en: CSV is a format similar to TSV except that instead of tab characters delimiting
    the fields, a comma is used. CSV is a fairly common format, common as output from
    spreadsheet applications, which is used for creating data to be consumed by other
    applications in many organizations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 格式与 TSV 类似，但字段分隔符不是制表符，而是逗号。CSV 是一种相当常见的格式，类似于电子表格应用程序的输出，常用于创建许多组织中其他应用程序消费的数据。
- en: The CSV version of the data is available at [https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.csv](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.csv).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的 CSV 版本可在以下链接找到：[https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.csv](https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.csv).
- en: 'Opening the link, you will see the following in your browser:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开链接，你将在浏览器中看到以下内容：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The example for demonstrating the loading of the preceding data using `d3.csv()`
    is available at the following link:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `d3.csv()` 加载前面数据的示例可在以下链接找到：
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.3): [http://goo.gl/JUX9CA](http://goo.gl/JUX9CA)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.3): [http://goo.gl/JUX9CA](http://goo.gl/JUX9CA)'
- en: The result is identical to that of the TSV example in that all the fields are
    loaded as strings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与 TSV 示例中的结果相同，即所有字段都作为字符串加载。
- en: Mapping fields and converting strings to numbers
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射字段和将字符串转换为数字
- en: We are going to use this data (in its CSV source) to render a bar graph that
    shows us the comparison of the viewership levels for each episode. If we are to
    use these fields as-is for creating the bar graph, those values will be interpreted
    incorrectly as their types are strings instead of numbers, and our resulting graph
    will be incorrect.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些数据（其 CSV 源）来渲染一个条形图，显示每个集的观众量比较。如果我们直接使用这些字段创建条形图，这些值将被错误地解释为字符串类型而不是数字，我们的结果图将是不正确的。
- en: Additionally, for the purpose of creating a bar chart showing viewership, we
    don't need the properties and can omit the `Season`, `SeriesNumber`, and `FirstAirDate`
    fields. It's not a real issue with this dataset, but sometimes, the data can have
    hundreds of columns and billions of rows, so it will be more efficient to extract
    only the necessary properties to help save memory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了创建一个显示观众量的条形图，我们不需要这些属性，可以省略 `Season`、`SeriesNumber` 和 `FirstAirDate` 字段。在这个数据集中这不是真正的问题，但有时数据可以有数百列和数十亿行，因此提取仅必要的属性以帮助节省内存将更加高效。
- en: These can be accomplished in a naive manner using a `for` loop, copying the
    desired fields into a new JavaScript object, and using one of the parse functions
    to convert the data. D3.js gives us a better way, a functional way, to perform
    this task.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过简单的 `for` 循环完成，将所需的字段复制到一个新的 JavaScript 对象中，并使用其中一个解析函数转换数据。D3.js 给我们提供了一个更好的方法，一种函数式的方法，来执行这个任务。
- en: D3.js provides us with the a .`map()` function that can be used on an array,
    which will apply a function to each of the array's items. This function returns
    a JavaScript object, and D3.js collects all these objects and returns them in
    an array. This gives us a simple way of selecting just the properties that we
    want and to convert the data, all in a single statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 为我们提供了一个 `.map()` 函数，可以在数组上使用，它将对数组的每个项目应用一个函数。这个函数返回一个 JavaScript 对象，D3.js
    收集所有这些对象并将它们作为一个数组返回。这为我们提供了一种简单的方法，只需一个语句就可以选择我们想要的属性并转换数据。
- en: 'To demonstrate this in action, open the example given at the following link:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示这一点，请打开以下链接提供的示例：
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.4): [http://goo.gl/ex2e8C](http://goo.gl/ex2e8C)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.4): [http://goo.gl/ex2e8C](http://goo.gl/ex2e8C)'
- en: 'The important portion of the code is the call to `data.map()`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的重要部分是 `data.map()` 的调用：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function that is passed to the `.map()` returns a new JavaScript object
    for each item in the array data. This new object consists of only the three specified
    properties. These objects are all collected by `.map()` and stored in the `mappedAndConverted`
    variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `.map()` 的函数为数据数组中的每个项目返回一个新的 JavaScript 对象。这个新对象仅包含三个指定的属性。这些对象都被 `.map()`
    收集并存储在 `mappedAndConverted` 变量中。
- en: 'The following code shows the first two objects in the new array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了新数组中的前两个对象：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that `Episode` and `USViewers` are now numeric values. This is accomplished
    by applying the unary `+` operator, which will convert a string to its appropriate
    numeric type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Episode` 和 `USViewers` 现在是数值。这是通过应用一元 `+` 运算符实现的，它将字符串转换为适当的数值类型。
- en: Scales
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规模
- en: Scales are functions provided by D3.js that map a set of values to another set
    of values. The input set of values is referred to as the domain, and the output
    is the range. The basic reason for the existence of scales is to prevent us from
    coding loops, and doing a lot of math to make these conversions happen. This is
    a very useful thing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 规模是 D3.js 提供的函数，用于将一组值映射到另一组值。输入值集被称为域，输出是范围。规模存在的基本原因是防止我们编写循环，并做大量的数学运算来实现这些转换。这是一件非常有用的事情。
- en: 'There are three general categories of scales: quantitative, ordinal, and time-scale.
    Within each category of scale, D3.js provides a number of concrete implementations
    that exist for accomplishing a specific type of mapping data useful for data visualization.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 规模通常分为三类：定量、序数和时间尺度。在每个尺度的类别中，D3.js 提供了一系列具体的实现，用于完成特定类型的数据映射，这些数据映射对于数据可视化非常有用。
- en: Covering examples of every type of scale would consume more space than is available
    in this book, and at the same time become tedious to read. We will examine several
    common scales that are used—kind of the 80/20 rule, where the few we cover here
    will be used most of the time you use scales.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖每种类型的刻度示例将占用比本书可用的空间更多，同时也会变得难以阅读。我们将考察几个常用的刻度，这有点像80/20规则，在这里我们涵盖的少数几个刻度将是你使用刻度时最常用的。
- en: Linear scales
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性刻度
- en: Linear scales are a type of quantitative scale that are arguably the most commonly
    used ones. The mapping performed is linear in that the output range is calculated
    using a linear function of the input domain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 线性刻度是一种定量刻度，可以说是最常用的刻度之一。所执行的映射是线性的，即输出范围是通过输入域的线性函数计算得出的。
- en: A good example of using a linear scale is the scenario with our *The Walking
    Dead* viewership data. We need to draw bars from this data; but if we use the
    code that we used earlier in the book, our bars will be extremely tall since that
    code has a one to one mapping between the value and the pixels.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性刻度的良好例子是我们*行尸走肉*观众的收视率数据。我们需要从这个数据中绘制条形图；但如果我们使用书中之前使用过的代码，我们的条形图将会非常高，因为那个代码在值和像素之间有一个一对一的映射。
- en: 'Let''s assume that our area for the bars on the graph has a height of 400 pixels.
    We would like to map the lowest viewership value to a bar that is 100 pixels tall,
    and map the largest viewership value to 400\. The following example performs this
    task:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设图表上条形图区域的高度为400像素。我们希望将最低收视率值映射到100像素高的条形图，并将最高收视率值映射到400像素。以下示例执行此任务：
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.5): [http://goo.gl/dgg0zf](http://goo.gl/dgg0zf)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.5): [http://goo.gl/dgg0zf](http://goo.gl/dgg0zf)'
- en: 'The code starts, as with the CSV example, by loading that data and mapping/converting
    it. The next task is to determine the minimum and maximum viewership values:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码开始，就像CSV示例一样，首先加载数据并映射/转换它。下一个任务是确定最小和最大收视率值：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we define several variables representing the minimum and maximum height
    that we would like for the bars:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义几个变量来表示我们希望条形图的最小和最大高度：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The scale is then created as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 刻度随后创建如下：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now use the `yScale` object as though it is a function. The following
    will log the results of scaling the minimum and maximum viewership values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将`yScale`对象当作一个函数来使用。以下代码将记录缩放最小和最大收视率值的结果：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Examining the console output, we can see that the scaling resulted in the expected
    values:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 检查控制台输出，我们可以看到缩放产生了预期的值：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ordinal scales
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序数刻度
- en: Ordinal scales are, in a way, similar to dictionary objects. The values in the
    domain and range are discrete. There must be an entry in the range for every unique
    input value, and that value must have a mapping to a single value in the range.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 序数刻度在某种程度上类似于字典对象。域和范围中的值是离散的。对于每个唯一的输入值，必须在范围中有一个条目，并且该值必须映射到范围中的单个值。
- en: There are several common uses for ordinal scales, and we will examine four common
    uses that we will use throughout the remainder of this book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种常见的序数刻度用法，我们将考察本书剩余部分中我们将使用的四种常见用法。
- en: Mapping color strings to codes
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将颜色字符串映射到代码
- en: Open the following link for an example of an ordinal scale. This example does
    not use the data from *The Walking Dead*, and simply demonstrates the mapping
    of string literals representing primary colors into the corresponding color codes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 打开以下链接查看序数刻度的示例。此示例不使用*行尸走肉*的数据，而是简单地演示了将表示基本颜色的字符串字面量映射到相应的颜色代码。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.6): [http://goo.gl/DezcUN](http://goo.gl/DezcUN)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.6): [http://goo.gl/DezcUN](http://goo.gl/DezcUN)'
- en: 'The scale is created as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 刻度创建如下：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now pass any of the range values to the `colorScale`, as demonstrated
    with the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将任何范围值传递给`colorScale`，如下所示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Examining the console output, we can see the results of this mapping as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 检查控制台输出，我们可以看到映射的结果如下：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Mapping integers to color scales
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将整数映射到颜色刻度
- en: D3.js comes with several special built-in scales that are referred to as **categorical**
    scales. It sounds like a fancy term, but they are simply mappings of a set of
    integers to unique colors (unique within that scale).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js附带了一些称为**分类**刻度的特殊内置刻度。听起来像是一个复杂的术语，但它们只是将一组整数映射到唯一的颜色（在该刻度内唯一）。
- en: These are useful when you have a set of sequential 0-based integer keys in your
    data, and you want to use a unique color for each, but you do not want to manually
    create all the mappings (like we did for the three strings in the previous example).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一组基于0的整数键的数据集，并且你想为每个键使用独特的颜色，但你不想手动创建所有映射（就像我们在上一个示例中为三个字符串所做的那样）时，这些很有用。
- en: 'Open the following link for an example of using a 10 color categorical scale:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 打开以下链接，查看使用10种颜色分类尺度的示例：
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.7): [http://goo.gl/RSW9Qa](http://goo.gl/RSW9Qa)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.7): [http://goo.gl/RSW9Qa](http://goo.gl/RSW9Qa)'
- en: The preceding example renders 10 adjacent rectangles, each with a unique color
    from a `category10()` color scale. You will see this in your browser when executing
    this example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例生成了10个相邻的矩形，每个矩形都从`category10()`颜色尺度中获取一个独特的颜色。当你执行这个示例时，你将在浏览器中看到这一点。
- en: '![Mapping integers to color scales](img/B04230_05_02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![将整数映射到颜色尺度](img/B04230_05_02.jpg)'
- en: The example starts by creating an array of 10 integers from 0 to 9.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例首先创建一个包含从0到9的10个整数的数组。
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The scale is created next:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建尺度：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can bind the integers to the rectangles, and set the fill for each by
    passing the value to the `colorScale` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将整数绑定到矩形上，并通过传递值到`colorScale`函数来设置每个矩形的填充：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: D3.js provides four sets of categorical color scales that can be used depending
    upon your scenario. You can take a look at them on the D3.js documentation page
    at [https://github.com/mbostock/d3/wiki/Ordinal-Scales](https://github.com/mbostock/d3/wiki/Ordinal-Scales).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js提供了四组分类颜色尺度，可以根据你的场景使用。你可以在D3.js文档页面上查看它们，网址为[https://github.com/mbostock/d3/wiki/Ordinal-Scales](https://github.com/mbostock/d3/wiki/Ordinal-Scales)。
- en: The ordinal scale using rangeBands
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用范围带的序数尺度
- en: In [Chapter 4](ch04.html "Chapter 4. Creating a Bar Graph"), *Creating a Bar
    Graph*, when we drew the graph we calculated the positions of the bars based upon
    a fixed bar size and padding. This is actually a very inflexible means of accomplishing
    this task. D3.js gives us a special scale that we can use, given the domain values
    and essentially a width, that will tell us the start and end values for each bar
    such that all the bars fit perfectly within the range!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。创建条形图")中，*创建条形图*，当我们绘制图表时，我们根据固定的条形大小和填充计算条形的位置。这实际上是一种非常不灵活的完成任务的方式。D3.js为我们提供了一个特殊的尺度，我们可以使用它，给定域值和基本宽度，这将告诉我们每个条形的起始和结束值，使得所有条形都能完美地位于范围内！
- en: 'Let''s take a look using this special scale with the following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下示例中的特殊尺度来看看：
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.8): [http://goo.gl/OG3g7S](http://goo.gl/OG3g7S)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.8): [http://goo.gl/OG3g7S](http://goo.gl/OG3g7S)'
- en: 'This example creates a simple ordinal scale specifying the range using the
    `.rangeBands()` function instead of `.range()`. The entire code of the example
    is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建了一个简单的序数尺度，使用`.rangeBands()`函数指定范围，而不是`.range()`。示例的整个代码如下：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `.range()` function will return an array with values representing the extents
    of an equal number of evenly-spaced divisions of the range specified to `.rangeBands()`.
    In this case, the width of the range is `100`, and there are three items specified
    in the domain; hence, the result is the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`.range()`函数将返回一个数组，其中的值表示`.rangeBands()`指定的范围的等间距划分的数量的范围。在这种情况下，范围的宽度是`100`，域中指定了三个项目；因此，结果是以下内容：'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Technically, this result is the values that represent the start of each band.
    The width of each band can be found using the `.rangeBand()` function, in this
    case returning the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，这个结果是表示每个带起始值的值。每个带的宽度可以通过`.rangeBand()`函数找到，在这种情况下返回以下内容：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This width may seem simplistic. Why have this function if we can just calculate
    the difference between two adjacent values in the result of `.range()`? To demonstrate,
    let's look at a slight modification of this example, available at the following
    link.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宽度可能看起来很简单。如果我们可以直接计算`.range()`结果中两个相邻值之间的差异，为什么还要有这个函数？为了演示，让我们看看这个示例的轻微修改，链接如下。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.9): [http://goo.gl/JPsuqh](http://goo.gl/JPsuqh)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.9): [http://goo.gl/JPsuqh](http://goo.gl/JPsuqh)'
- en: 'This makes one modification to the call to `.rangeBands()`, adding an additional
    parameter that specifies the padding that should exist between the bars:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这对`.rangeBands()`的调用进行了一次修改，添加了一个额外的参数，指定了条形之间应该存在的填充：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output differs slightly due to the addition of padding between the bands:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在带之间添加了填充，输出略有不同：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The width of each band is now 29.03, with a padding of 3.23 between bands (including
    on the outside of the two outer bands).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个带的宽度现在是 29.03，带之间的填充为 3.23（包括两个外带的外侧）。
- en: The value for padding is a value between 0.0 (the default, and which results
    in a padding of 0) and 1.0, resulting in bands of width 0.0\. A value of 0.5 makes
    the padding the same width as each band.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 填充的值是一个介于 0.0（默认值，结果为 0 填充）和 1.0 之间的值，结果为宽度为 0.0 的带。0.5 的值使填充的宽度与每个带相同。
- en: Visualizing The Walking Dead viewership
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化《行尸走肉》观众人数
- en: 'Now we pull everything from the chapter together to render a bar graph of the
    viewership across all the episodes of *The Walking Dead*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将本章的所有内容结合起来，以渲染《行尸走肉》所有剧集的观众人数条形图：
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'bl.ock (5.10): [http://goo.gl/T8d6OU](http://goo.gl/T8d6OU)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'bl.ock (5.10): [http://goo.gl/T8d6OU](http://goo.gl/T8d6OU)'
- en: 'The output of the preceding example is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例的输出如下：
- en: '![Visualizing The Walking Dead viewership](img/B04230_05_01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![可视化《行尸走肉》观众人数](img/B04230_05_01.jpg)'
- en: 'Now let''s step through how this is created. After loading the data from the
    JSON file, the first thing that is performed is the extraction of the `USViewership`
    values and the determining of the maximum value:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐步了解这是如何创建的。在从 JSON 文件加载数据后，首先执行的操作是提取 `USViewership` 值并确定最大值：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then various variables, which represent various metrics for the graph, and
    the main SVG element are created:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建了各种变量，它们代表图表的各种度量指标，以及主要的 SVG 元素：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The container for holding the bars is created next:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于容纳条形的容器：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we create an ordinal scale for the bars using `.rangeBands()`. We will
    use this to calculate the bar position and padding:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `.rangeBands()` 创建一个用于条形的序数刻度尺。我们将使用它来计算条形的位置和填充：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We also require a scale to calculate the height of each bar:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个刻度尺来计算每个条形的高度：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following function is used by the selection that creates the bars to position
    each of them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的函数用于创建条形的选取，以定位每个条形：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we create the groups for the content of each bar:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为每个条形的内容创建组：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next we append the rectangle for the bar:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加条形的矩形：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And then add a label to the bar to show the exact viewership value:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在条形上添加一个标签以显示确切的观众人数值：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The bars are now complete, so we move on to creating both the axes. We start
    with the left axis:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 条形现在已完成，因此我们继续创建两个轴。我们首先从左侧轴开始：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And now create a bottom axis which displays the titles:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个底部轴，显示标题：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following function is reusable code for styling the axes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的函数是用于样式化轴的可重用代码：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to load data from the web and use it as the
    basis for a bar graph. We started with loading data in the JSON, CSV, and TSV
    formats. You learned how to use the `.map()` function to extract just the values
    that you desire from this data, and examined the issues and solutions needed for
    converting string values into numeric values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何从网络加载数据并将其用作条形图的基础。我们从加载 JSON、CSV 和 TSV 格式的数据开始。你学习了如何使用 `.map()`
    函数从这些数据中提取你需要的值，并探讨了将字符串值转换为数值值所需的问题和解决方案。
- en: Next we covered scales in some more detail, and looked at several examples of
    the ways to use scales for mapping data from one range of values to another as
    well as to map discrete values such as color names to color codes. We covered
    categorical scales, a means of mapping integer values into predefined color maps,
    and a concept that we will use frequently in our examples. Our examination of
    scales ended with a demonstration of using `.rangeBands()`, and how it can help
    us size and place bars within a predefined area.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更详细地介绍了刻度尺，并探讨了如何使用刻度尺将数据从一个值域映射到另一个值域，以及如何将离散值，如颜色名称映射到颜色代码。我们介绍了分类刻度尺，这是一种将整数值映射到预定义颜色图的方法，以及我们将在示例中经常使用的一个概念。我们对刻度尺的考察以使用
    `.rangeBands()` 的演示结束，并展示了它如何帮助我们确定预定义区域内条形的大小和位置。
- en: We closed the chapter by combining all of these concepts together into, what
    is up to this point, our best example of generating a bar chart. This demonstrated
    loading the data, using multiple scales for both data and axes, and using `.rangeBands()`
    to determine the placement of the bars, as well as using not only a vertical but
    also a horizontal axis.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将这些概念结合起来，形成了到目前为止我们生成条形图的最佳示例来结束本章。这展示了加载数据、使用数据轴和轴的多个刻度尺，以及使用 `.rangeBands()`
    确定条形位置，以及不仅使用垂直轴还使用水平轴。
- en: In the next chapter, we will branch out of bar graphs into another type of data
    visualization—scatter (and bubble) plots.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从条形图扩展到另一种数据可视化类型——散点图（和气泡图）。
