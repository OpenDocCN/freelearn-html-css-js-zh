- en: '*Chapter 8*: Environments emulation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：环境模拟'
- en: I had the good luck of using the internet before it became popular. I was a
    teenager when *Windows 95 Plus* was launched to the market. Most people might
    remember *Windows 95 Plus* because it came with some cool themes and even the
    *Space Cadet Pinball* game. But this version of Windows brought a new software
    application whose name is still around these days, with haters and lovers. *Windows
    95 Plus* came with *Internet Explorer 1.0 (IE 1.0)*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我很幸运在互联网变得流行之前就开始使用它了。当*Windows 95 Plus*上市时，我还是个青少年。大多数人可能记得*Windows 95 Plus*是因为它附带了一些酷炫的主题，甚至还有*太空飞行员弹球机*游戏。但这个版本的Windows带来了一款新的软件应用，这个名字至今仍被人们所熟知，有人喜欢有人讨厌。*Windows
    95 Plus*附带的是*Internet Explorer 1.0 (IE 1.0)*。
- en: My first internet connection was a free phone number that a local newspaper
    shared with its readers. I was able to convince my dad to get me a modem. The
    speed was 36.6 kbps. Today my speed test goes to 150 Mbps download and 30 Mbps
    upload, over 4,000 times faster than the speed I got as a teen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一次互联网连接是一个当地报纸与读者共享的免费电话号码。我设法说服我爸爸给我买了一个调制解调器。速度是36.6 kbps。今天我的速度测试下载速度达到150
    Mbps，上传速度达到30 Mbps，比我在青少年时期得到的速度快了超过4,000倍。
- en: I don't remember very well the specs of my computer. But I do remember using
    a 15'' 800x600 monitor, and then upgrading to a 17'' 1,024x768\. LED? No way!
    What's that? There were some bulky, eye-burning CRT monitors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太记得我电脑的具体配置了。但我记得我使用过15英寸800x600分辨率的显示器，然后升级到了17英寸1,024x768分辨率。LED显示器？不可能！那是什么？当时有一些体积庞大、刺眼的CRT显示器。
- en: SEO? Google? Nobody knew those words back then. I remember that my favorite
    search engine was *AltaVista*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SEO？Google？当时没有人知道这些词。我记得我最喜欢的搜索引擎是*AltaVista*。
- en: Why am I telling you all this? Because back then, the internet experience was
    consistent. It was slow, very slow, ugly, very ugly, and limited, very limited.
    But it was the same for everybody. If you were a developer back then, you knew
    that you had to develop a website for IE 1.0 to be displayed on an 800x600 screen
    and that your page would take over a minute to download. But you wouldn't have
    thought about all that. You would be happy creating your page with *Microsoft
    FrontPage*, pushing that to some server, and letting the world know about your
    site.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么要告诉你这些？因为那时候，互联网体验是一致的。它很慢，非常慢，很丑，非常丑，而且有限，非常有限。但这对每个人来说都是一样的。如果你当时是开发者，你知道你必须为IE
    1.0开发一个网站，以便在800x600的屏幕上显示，而且你的页面需要超过一分钟才能下载。但你不会考虑那么多。你会很高兴地用*Microsoft FrontPage*创建你的页面，将其推送到某个服务器，并让全世界都知道你的网站。
- en: But now things are different. The ecosystem is more diverse than ever, and we
    need to be prepared to test all the different scenarios that we could come across.
    At the end of the day, it is our job to honor all our customers and try to understand
    their environments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在情况不同了。生态系统比以往任何时候都更加多样化，我们需要准备好测试我们可能遇到的所有不同场景。最终，我们的工作是尊重所有客户，并努力了解他们的环境。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding the browser's market share
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解浏览器市场份额
- en: Emulating mobile devices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟移动设备
- en: Emulating network conditions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟网络条件
- en: Emulating localization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟本地化
- en: Other emulations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他模拟
- en: By the end of this chapter, you will be able to get into your users' shoes and
    emulate how they experience your sites.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够站在用户的角度，模拟他们体验你的网站的方式。
- en: Let's get started.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will find all the code of this chapter on the GitHub repository ([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))
    under the `Chapter8` directory. Remember to run `npm install` on that directory,
    and then go to the `Chapter8/vuejs-firebase-shopping-cart` directory and run `npm
    install` again.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库([https://github.com/PacktPublishing/UI-Testing-with-Puppeteer](https://github.com/PacktPublishing/UI-Testing-with-Puppeteer))的`Chapter8`目录下找到本章的所有代码。请记住在那个目录下运行`npm
    install`，然后进入`Chapter8/vuejs-firebase-shopping-cart`目录再次运行`npm install`。
- en: Understanding the browser's market share
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解浏览器市场份额
- en: Before getting into all the emulation features Puppeteer provides, I would like
    to discuss how the browser's market share looks these days. I believe that will
    give you a clear picture of the importance of testing and emulating different
    scenarios.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨Puppeteer提供的所有模拟功能之前，我想讨论一下现在浏览器市场份额的分布情况。我相信这将清楚地展示测试和模拟不同场景的重要性。
- en: The browser's popularity over the years
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器多年来的流行度
- en: 'We have lived through lots of changes over the past 25 years. Browsers have
    been dramatically adopted and discarded. Let''s take a look at this table made
    by Nick Routley in his post *Internet Browser Market Share (1996–2019)* ([https://www.visualcapitalist.com/internet-browser-market-share/](https://www.visualcapitalist.com/internet-browser-market-share/)):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的25年里，我们经历了许多变化。浏览器被大量采用和废弃。让我们看看Nick Routley在他的帖子《互联网浏览器市场份额（1996–2019）》中制作的这张表格（[https://www.visualcapitalist.com/internet-browser-market-share/](https://www.visualcapitalist.com/internet-browser-market-share/))）：
- en: '![](img/Table_8.1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_8.1.jpg)'
- en: Although I used *Netscape Navigator*, I wasn't there at its peak back in 1995\.
    But I remember the days when the only browser that mattered was *Internet Explorer*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我使用了*Netscape Navigator*，但我并没有在1995年的顶峰时期在那里。但我记得只有*Internet Explorer*才是当时唯一重要的浏览器的日子。
- en: The community was living through browser fatigue back in 2008, when *Google
    Chrome* was launched, causing a massive number of users to move to *Google Chrome*
    and *Firefox*, which had a peak in 2010.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，当*Google Chrome*推出时，社区正经历着浏览器疲劳，这导致大量用户转向*Google Chrome*和*Firefox*，这两个浏览器在2010年达到了峰值。
- en: 'If you didn''t play the video on Nick''s post, don''t miss that. I took a screenshot
    from the moment that the video gets to 2013 Q1:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看Nick帖子上的视频，不要错过。我从视频到达2013年Q1的时刻截了一张图：
- en: '![Market share in 2013'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![2013年的市场份额'
- en: '](img/Figure_8.01_B16113.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.01_B16113.jpg)'
- en: Market share in 2013
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年的市场份额
- en: That was a challenging year for developers. You had four different browser engines
    behaving differently, processing CSS styles differently, having different JavaScript
    features. It was a mess. But I think that was a healthy web, with no clear market
    owner.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那年对开发者来说是一个挑战。你有了四种不同的浏览器引擎，它们的行为不同，处理CSS样式的方式不同，拥有不同的JavaScript功能。那是一团糟。但我认为那是一个健康的网络，没有明确的市场主导者。
- en: Browsers' popularity in 2020
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2020年浏览器的流行度
- en: 'According to *StatCounter* ([https://gs.statcounter.com/](https://gs.statcounter.com/)),
    the picture is very different these days:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*StatCounter* ([https://gs.statcounter.com/](https://gs.statcounter.com/))，现在的形势非常不同：
- en: '![Browser market share in December 2020 according to StatCounter'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![2020年12月浏览器市场份额根据StatCounter'
- en: '](img/Figure_8.02_B16113.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B16113.jpg)'
- en: Browser market share in December 2020 according to StatCounter
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据StatCounter，2020年12月的浏览器市场份额
- en: Many people call *Google Chrome* the **new** Internet Explorer. The Chrome predominance
    gets even more important when you consider that *Edge* and *Opera* use the Chromium
    engine. When a browser gets to these levels of market share, it is good for developers,
    but it's not good for the web.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人称*Google Chrome*为**新**的Internet Explorer。当你考虑到*Edge*和*Opera*使用Chromium引擎时，Chrome的主导地位变得更加重要。当一个浏览器的市场份额达到这些水平时，这对开发者来说是个好事，但对网络来说却不是。
- en: What if we take a look at operative systems?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看操作系统呢？
- en: Operative Systems market share
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统市场份额
- en: 'Operative systems play an essential part in how browsers work. They are responsible
    for providing the fonts and interacting with the hardware, among other things.
    Most browsers are cross-platform, but although they try to give the same experience
    across operative systems, they don''t always work in the same way. That''s why
    it''s so important to know how the operative system market share looks:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统在浏览器的工作中扮演着至关重要的角色。它们负责提供字体并与硬件交互，以及其他事情。大多数浏览器都是跨平台的，尽管它们试图在操作系统之间提供相同的使用体验，但它们并不总是以相同的方式工作。这就是为什么了解操作系统市场份额的分布如此重要的原因：
- en: '![Operative system market share in December 2020 according to StatCounter'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![根据StatCounter，2020年12月的操作系统市场份额'
- en: '](img/Figure_8.03_B16113.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.03_B16113.jpg)'
- en: Operative system market share in December 2020 according to StatCounter
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据StatCounter，2020年12月的操作系统市场份额
- en: I honestly found this surprising. Almost 55% of internet consumption is on mobile,
    and over 39% is on Android. These values should make us re-think how we develop
    and test our sites.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的觉得这很令人惊讶。几乎55%的互联网消费是在移动设备上，超过39%是在Android上。这些值应该让我们重新思考我们开发和测试网站的方式。
- en: The last thing we can take a look at is screen resolutions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以最后看看屏幕分辨率。
- en: Screen resolution distribution
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕分辨率分布
- en: 'Screen resolution is another important piece when we try to understand the
    whole web ecosystem. In [*Chapter 3*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Navigating through a website*, we talked about how developers can change a page
    layout based on the screen resolution. Let''s see how the screen resolution is
    distributed according to **StatCounter**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕分辨率是我们试图理解整个网络生态系统时另一个重要的因素。在[*第3章*](B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050)“浏览网站”，我们讨论了开发者如何根据屏幕分辨率更改页面布局。让我们看看根据**StatCounter**的屏幕分辨率是如何分布的：
- en: '![Screen resolution market share in December 2020 according to StatCounter'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![2020年12月根据StatCounter的屏幕分辨率市场份额'
- en: '](img/Figure_8.04_B16113.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.04_B16113.jpg)'
- en: Screen resolution market share in December 2020 according to StatCounter
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 2020年12月根据StatCounter的屏幕分辨率市场份额
- en: The distribution of screen resolutions is crazy. There is not only a wide variety
    of resolutions, but we also have "**Other**" with 41%. We are far from that 800x600
    standard.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕分辨率的分布非常疯狂。不仅有各种各样的分辨率，我们还有一个占41%的“**其他**”。我们远远没有达到800x600的标准。
- en: The message I want to leave you with is that the internet ecosystem is more
    diverse than ever. The world where everything was just IE, 800x600, over a dial-up
    connection is long gone. Although there is one predominant browser, we have many
    possible scenarios, mobile devices, and screen resolutions, and we haven't talked
    about network speeds. We have Wi-Fi, 4G, 3G, or GPRS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我想留给你的信息是，互联网生态系统比以往任何时候都更加多样化。那个所有东西都是IE、800x600、通过拨号连接的世界已经一去不复返了。尽管有一个主导的浏览器，但我们有许多可能的场景、移动设备和屏幕分辨率，我们还没有讨论网络速度。我们有Wi-Fi、4G、3G或GPRS。
- en: We sometimes make the error of thinking that all users have a crazy-fast internet
    and 27'' 4K displays, and we are unable to understand why they feel frustrated
    with our site.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会犯错误，认为所有用户都有疯狂快速的互联网和27'' 4K显示器，我们无法理解他们为什么对我们网站感到沮丧。
- en: Do you know your users? Do you know whether they use your site on the street
    on their phones? Do you want your site to be used worldwide? Do you know that
    there are countries where they write right to left or where they don't have 4G
    coverage?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解你的用户吗？你知道他们是否在街上用手机访问你的网站吗？你希望你的网站被全球使用吗？你知道有些国家是从右到左书写的，或者那里没有4G覆盖吗？
- en: It's time to get into mobile users' shoes. Let's see how we can emulate mobile
    devices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候换位思考移动用户了。让我们看看我们如何模拟移动设备。
- en: Emulating mobile devices
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟移动设备
- en: 'The first type of emulation I want to cover is mobile emulation. In this section,
    we will cover the three elements that Puppeteer can emulate: The viewport, the
    touchscreen, and the user agent. We have to keep in mind that it is a browser
    trying to **emulate** a mobile device. Puppeteer and Chromium won''t be able to
    emulate any hardware limitations or any other specific features that certain mobile
    phones offer. There is no real device behind the curtains; it''s just a browser
    trying to show you how a website would look on that device''s screen.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我要介绍的第一种模拟类型是移动模拟。在本节中，我们将介绍Puppeteer可以模拟的三个元素：视口、触摸屏和用户代理。我们必须记住，这是一个试图**模拟**移动设备的浏览器。Puppeteer和Chromium无法模拟任何硬件限制或某些手机提供的任何其他特定功能。幕后没有真正的设备；它只是一个试图向您展示该设备屏幕上网站外观的浏览器。
- en: As I mentioned previously, **55% of the internet traffic comes from mobile devices**.
    Most of the diversity we saw in the previous section is in the mobile world.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，**55%的互联网流量来自移动设备**。我们之前章节中看到的大部分多样性都在移动世界。
- en: 'Let''s take a look at some of the browser distribution in the mobile world:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看移动世界的一些浏览器分布情况：
- en: '![Browser market share in mobile devices according to StatCounter'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![根据StatCounter的移动设备浏览器市场份额'
- en: '](img/Figure_8.05_B16113.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.05_B16113.jpg)'
- en: Browser market share in mobile devices according to StatCounter
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据StatCounter的移动设备浏览器市场份额
- en: The mobile market is mostly divided between *Chrome* and *Safari*. One thing
    you should know is that in *iOS*, the only available browser engine is *WebKit*/*Safari*.
    You have browsers such as *Chrome*, *Edge*, or *Firefox* available in *iOS*, but
    they cannot ship their own browser engine. They have to use *WebKit*. The only
    thing they can provide are features over that engine. The main feature you will
    see in those browsers is the synchronization between the desktop and the mobile
    browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 移动市场主要被*Chrome*和*Safari*分割。你应该知道的是，在*iOS*中，唯一可用的浏览器引擎是*WebKit*/*Safari*。在*iOS*中，你可以使用*Chrome*、*Edge*或*Firefox*等浏览器，但它们不能提供自己的浏览器引擎。它们必须使用*WebKit*。他们唯一能提供的是在该引擎之上的功能。你会在那些浏览器中看到的主要功能是桌面和移动浏览器之间的同步。
- en: 'Let''s take a look at screen resolutions on mobile devices:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看移动设备上的屏幕分辨率：
- en: '![](img/Figure_8.06_B16113.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_8.06_B16113.jpg)'
- en: Screen resolutions on mobile devices according to StatCounter
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据StatCounter，移动设备上的屏幕分辨率
- en: You need 10 screen resolutions to reach 50% of the market share, compared with
    only three resolutions on desktop, 1,920x1,080, 1,366x768, and 1,536x864\. The
    screen resolutions in the mobile world are highly diverse. Another thing that
    should call your attention in that chart is the resolutions that are pretty low.
    Who buys a phone with a 360x640 resolution? No one. We will find out in the next
    section who those 360x480 users really are.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要10种屏幕分辨率才能达到50%的市场份额，而在桌面上的分辨率只有三种，分别是1,920x1,080、1,366x768和1,536x864。在移动世界中，屏幕分辨率高度多样化。在那个图表中，你应该注意到的另一件事是那些相当低的分辨率。谁会买一个分辨率为360x640的手机？没有人。我们将在下一节中找出那些360x480用户到底是谁。
- en: So, it's time to talk about the elements that Puppeteer considers to emulate
    a mobile device.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候讨论Puppeteer在模拟移动设备时考虑的元素了。
- en: The Viewport
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视口
- en: We've talked a lot about the viewport in this book. It's time to give a clear
    definition of the viewport.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经讨论了很多关于视口的内容。现在是时候给出视口的明确定义了。
- en: 'I like to explain the viewport by explaining what it''s not. The viewport is
    not the screen resolution. It''s not the size of the browser''s window. And lastly,
    it''s not the size of the page. The viewport is the rectangular portion of the
    screen the browser uses to render a page. From the user''s point of view, the
    viewport is the part of the page you can see:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢通过解释它不是什么来解释视口。视口不是屏幕分辨率。它不是浏览器窗口的大小。最后，它也不是页面的大小。视口是浏览器用来渲染页面的屏幕的矩形部分。从用户的角度来看，视口是你可以看到的页面部分：
- en: '![The viewport'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![视口'
- en: '](img/Figure_8.07_B16113.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B16113.jpg)'
- en: The viewport
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 视口
- en: I love the preceding visualization, not because I made it, but because it clearly
    shows the difference between the viewport and the screen size. The page can be
    huge. It can be way longer than what you can see. Even more, if you are a social
    media user, you would also know that pages can have an "infinite" height because
    sites such as *Facebook* and *Twitter* load new content when you are close to
    reaching the end of the page. Although it's not as common, a page could also be
    wider than the viewport. There was a wave of horizontal-scrolling pages when *Windows
    8* was launched. The Microsoft *Azure* portal still shows its content using a
    horizontal layout.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢前面的可视化，不是因为我自己做了它，而是因为它清楚地显示了视口和屏幕尺寸之间的差异。页面可以非常大。它可以比你能看到的长得多。更重要的是，如果你是社交媒体用户，你也会知道页面可以有“无限”的高度，因为像*Facebook*和*Twitter*这样的网站会在你接近页面底部时加载新内容。尽管这种情况不常见，页面也可能比视口宽。当*Windows
    8*发布时，曾经有一股水平滚动页面的潮流。Microsoft *Azure*门户仍然使用水平布局来显示其内容。
- en: The second element to take into consideration when you try to emulate a device
    screen is the pixel ratio.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试模拟设备屏幕时，需要考虑的第二个元素是像素比。
- en: Pixel ratio
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素比
- en: What if I told you that the Samsung Galaxy S20, with a screen resolution of
    1,440x3,200, has a viewport of 360x800?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，三星Galaxy S20，屏幕分辨率为1,440x3,200，其视口为360x800？
- en: 'No, that''s not a typo, nor an error. That''s the browser''s viewport on that
    beautiful mobile phone. How''s that possible? Let''s see how a web page would
    be displayed on a Samsung S20 without a pixel ratio set:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这并不是一个打字错误，也不是一个错误。这是那个美丽手机上的浏览器视口。这是怎么可能的？让我们看看在没有设置像素比率的Samsung S20上网页会如何显示：
- en: '![Galaxy S20 without a pixel ratio'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![没有像素比率的Galaxy S20'
- en: '](img/Figure_8.08_B16113.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.08_B16113.jpg)'
- en: Galaxy S20 without a pixel ratio
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 没有像素比率的Galaxy S20
- en: 'Imagine if the browser honored the real resolution of the screen. That would
    be impossible to read, so you need to scale the resolution. You need to tell the
    browser to use a ratio to zoom the page and make it more usable. In the case of
    the Samsung Galaxy S20, the pixel ratio is 4, taking the viewport to 360x800,
    which is simple math (1,440/4) x (3,200/4). If we navigate the page using a pixel
    ratio of 4, we will see something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果浏览器尊重屏幕的真实分辨率。这将难以阅读，因此你需要缩放分辨率。你需要告诉浏览器使用一个比例来缩放页面，使其更易于使用。在三星Galaxy
    S20的情况下，像素比率为4，将视口设置为360x800，这是一个简单的数学计算（1,440/4）x（3,200/4）。如果我们使用像素比率4来导航页面，我们会看到类似这样的内容：
- en: '![Galaxy S20 with the right pixel ratio'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![携带正确像素比率的Galaxy S20'
- en: '](img/Figure_8.09_B16113.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.09_B16113.jpg)'
- en: Galaxy S20 with the right pixel ratio
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 携带正确像素比率的Galaxy S20
- en: Now we have an S20 with a huge resolution, but pages are rendered in a way that
    we can read them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个具有巨大分辨率的S20，但页面渲染的方式使我们能够阅读它们。
- en: If you're wondering how I've been emulating different devices, it's tool time!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道我是如何模拟不同设备的，现在是时候使用工具了！
- en: 'If you open the developer tools (I hope that by now I don''t have to tell you
    how to do that), you will find that there is a button called **Toggle device emulation**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开了开发者工具（我希望到现在你不需要我再告诉你如何操作），你会找到一个名为**切换设备模拟**的按钮：
- en: '![Toggle device emulation option'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![切换设备模拟选项'
- en: '](img/Figure_8.10_B16113.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B16113.jpg)'
- en: Toggle device emulation option
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 切换设备模拟选项
- en: If you click on that button, you will activate the device emulation mode. From
    there, you will be able to pick any device to emulate, or create new ones. You
    will also be able to change the zoom. Notice that this zoom won't affect the viewport;
    it's just to zoom the emulator. Finally, you will have the option to emulate different
    network speeds. We will talk about that in the *Emulating network conditions*
    section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击那个按钮，你将激活设备模拟模式。从那里，你将能够选择任何设备进行模拟，或者创建新的设备。你还可以更改缩放。请注意，这个缩放不会影响视口；它只是用于缩放模拟器。最后，你将有一个选项来模拟不同的网络速度。我们将在*模拟网络条件*部分讨论这一点。
- en: The next element that Puppeteer takes into consideration is the touchscreen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer考虑的下一个元素是触摸屏。
- en: The touchscreen
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸屏
- en: 'If the device has a touchscreen, the browser will give developers an extra
    set of tools, **touch events** ([https://www.hardkoded.com/ui-testing-with-puppeteer/touchevents](https://www.hardkoded.com/ui-testing-with-puppeteer/touchevents)).
    Single taps will be processed as click events. But the browser offers the chance
    of processing multi-touch interactions. Let''s see how Chromium shows the touchscreen
    emulation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备有触摸屏，浏览器将为开发者提供一套额外的工具，**触摸事件** ([https://www.hardkoded.com/ui-testing-with-puppeteer/touchevents](https://www.hardkoded.com/ui-testing-with-puppeteer/touchevents))。单次点击将被处理为点击事件。但浏览器提供了处理多指交互的机会。让我们看看Chromium如何显示触摸屏模拟：
- en: '![Touch emulation'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![触摸模拟'
- en: '](img/Figure_8.11_B16113.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.11_B16113.jpg)'
- en: Touch emulation
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸模拟
- en: If you use the device emulation, you will see that Chromium will emulate taps
    with a black circle.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用设备模拟，你会看到Chromium会使用黑色圆圈来模拟点击。
- en: 'That takes us to the last thing that Puppeteer uses to emulate devices: the
    user agent.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了Puppeteer用来模拟设备使用的最后一件事：用户代理。
- en: The user agent
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户代理
- en: The user agent is one of those terrible decisions made on the web that are hard
    to eradicate. The user agent is a string (text) sent to the server on every request
    that identifies the browser/application, the operative system, the vendor, and
    its version.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理是网络中难以根除的糟糕决策之一。用户代理是一个字符串（文本），在每次请求中发送到服务器，用于标识浏览器/应用程序、操作系统、供应商及其版本。
- en: 'According to MDN ([https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent](https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent)),
    the format should be something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 MDN ([https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent](https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent))，格式应该是这样的：
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you open DevTools in Chrome and type `navigator.userAgent`, you will get
    something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开Chrome中的DevTools并输入`navigator.userAgent`，你会得到类似这样的内容：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only clear thing here is that I'm on a Mac, using an Intel processor, and
    the operating system version is `11_0_1`. It's also true that I'm on `Chrome/87.0.4280.88`.
    The rest are patches after patches, so the user doesn't get a "Your browser is
    not compatible" message. So, if the server checks for Mozilla, the user agent
    will match, but it's not Mozilla. Could you tell me what *KHTML, like Gecko* is?
    As you can see, the user agent system is broken.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里唯一明确的是，我正在使用 Mac，搭载英特尔处理器，操作系统版本为 `11_0_1`。同样真实的是，我正在使用 `Chrome/87.0.4280.88`。其余的都是补丁之后的补丁，所以用户不会收到“您的浏览器不兼容”的消息。因此，如果服务器检查
    Mozilla，用户代理将匹配，但它不是 Mozilla。你能告诉我 *KHTML, like Gecko* 是什么吗？正如你所见，用户代理系统已经损坏了。
- en: 'Many developers would use the user agent to determine which device is on the
    other side. Let''s take, for instance, the user agent on an iPad:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者会使用用户代理来确定另一端是哪种设备。以 iPad 上的用户代理为例：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If a developer wants to check whether the user is on an iPad, they can check
    whether the user agent contains the word **iPad**. But what if they want to check
    whether the user is using Safari? If they look for the word **Safari**, it will
    work on iPad, but, if you look at Chrome's user agent, it also has the word Safari,
    so we would think that Chromium is Safari. User agents are a mess.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者想检查用户是否在使用 iPad，他们可以检查用户代理是否包含单词 **iPad**。但如果他们想检查用户是否使用 Safari 呢？如果他们寻找单词
    **Safari**，在 iPad 上会起作用，但如果你查看 Chrome 的用户代理，它也有 Safari 这个词，所以我们可能会认为 Chromium
    是 Safari。用户代理是一团糟。
- en: If Puppeteer wants to emulate devices correctly, it needs to change the User-Agent
    in two places. First, it needs to change the User-Agent request header ([https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent](https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent))
    sent to the server. And second, as developers can also access the User-Agent from
    their JavaScript code using the `navigator.userAgent` property, the browser needs
    to change the value of that property as well. With these changes, both the server
    and the client will get a User-Agent that a real device would send.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Puppeteer 想要正确地模拟设备，它需要在两个地方更改 User-Agent。首先，它需要更改发送到服务器的 User-Agent 请求头（[https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent](https://www.hardkoded.com/ui-testing-with-puppeteer/userAgent)）。其次，因为开发者也可以通过
    `navigator.userAgent` 属性从他们的 JavaScript 代码中访问 User-Agent，浏览器需要更改该属性的值。通过这些更改，服务器和客户端都将获得一个真实设备会发送的用户代理。
- en: Now it's time to see how we apply all this in our Puppeteer code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们如何在我们的 Puppeteer 代码中应用所有这些了。
- en: Emulating mobile devices with Puppeteer
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Puppeteer 模拟移动设备
- en: 'You toggle the emulation mode by calling `page.emulate(options)`. I honestly
    think that the name `options` is wrong there. Compared with the other options
    we have seen in this book, this `options` argument is mandatory. The object will
    contain all the required data Puppeteer needs to emulate a device:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `page.emulate(options)` 来切换模拟模式。我真心认为那里的名字 `options` 是错误的。与其他我们在本书中看到的选项相比，这个
    `options` 参数是必需的。该对象将包含 Puppeteer 模拟设备所需的所有必要数据：
- en: '`viewport` is the first property, and it includes the definition of the viewport
    and a little bit more:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewport` 是第一个属性，它包括视口的定义和一些其他内容：'
- en: a) `width`, representing the viewport width.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `width`，表示视口宽度。
- en: b) `height`, representing the viewport height.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `height`，表示视口高度。
- en: c) `deviceScaleFactor`, which is the pixel ratio we talked about before.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) `deviceScaleFactor`，这是我们之前讨论过的像素比。
- en: d) `isMobile` is a Boolean property that will make the browser consider the
    meta viewport tag. You can read more about this on the MDN site ([https://www.hardkoded.com/ui-testing-with-puppeteer/viewportMetaTag](https://www.hardkoded.com/ui-testing-with-puppeteer/viewportMetaTag)).
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) `isMobile` 是一个布尔属性，将使浏览器考虑元视口标签。你可以在 MDN 网站上了解更多信息（[https://www.hardkoded.com/ui-testing-with-puppeteer/viewportMetaTag](https://www.hardkoded.com/ui-testing-with-puppeteer/viewportMetaTag)）。
- en: e) `hasTouch` is a Boolean that will enable touch support.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e) `hasTouch` 是一个布尔值，将启用触摸支持。
- en: f) `isLandscape` is a Boolean that will emulate a device in landscape mode.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: f) `isLandscape` 是一个布尔值，将模拟横向模式的设备。
- en: The `userAgent` property will allow us to change the user agent on the request
    header and JavaScript, as we saw in the previous section.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userAgent` 属性将允许我们在请求头和 JavaScript 中更改用户代理，正如我们在上一节中看到的。'
- en: 'I have some good news and some bad news for you. Good news first. The `puppeteer`
    class has a property called `devices`. It''s a dictionary containing over 70 devices.
    We could do something like this in our code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一些好消息和一些坏消息要告诉你。先说好消息。`puppeteer`类有一个名为`devices`的属性。它是一个包含70多个设备的字典。我们可以在代码中这样做：
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s the good news. The bad news is that you have to go to the source code
    for you to know the available list of devices: [https://www.hardkoded.com/ui-testing-with-puppeteer/DeviceDescriptors](https://www.hardkoded.com/ui-testing-with-puppeteer/DeviceDescriptors).
    That''s not ideal. The other option would be grabbing any Puppeteer code you have
    and printing the keys of the `devices` object:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是好消息。坏消息是，你必须查看源代码才能知道可用的设备列表：[https://www.hardkoded.com/ui-testing-with-puppeteer/DeviceDescriptors](https://www.hardkoded.com/ui-testing-with-puppeteer/DeviceDescriptors)。这并不理想。另一种选择是获取你拥有的任何Puppeteer代码，并打印`devices`对象的键：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you do that, you will get all the devices included in Puppeteer. The other
    bad news is that the list of devices is not as up to date as you might expect.
    But I think it makes sense. First, because we get new devices every month, and
    keeping that list updated would be a tough job. And second, the website you want
    to automate shouldn't need to be tested on every single device. I think you should
    be able to have good test coverage using the provided devices.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你将获得Puppeteer中包含的所有设备。另一个坏消息是，设备列表并没有像你预期的那样及时更新。但我认为这是有道理的。首先，因为每个月我们都会得到新的设备，保持该列表更新将是一项艰巨的任务。其次，你想要自动化的网站不需要在每台设备上测试。我认为你应该能够使用提供的设备获得良好的测试覆盖率。
- en: If you do need to test a specific device, you could browse the spec on the web
    and manually pass a device setting. *yesviz.com* (https://yesviz.com/devices.php)
    has a nice list of devices' viewports. You can find a list of user agents at *DeviceAtlas*
    (https://deviceatlas.com/blog/list-of-user-agent-strings).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要测试特定的设备，你可以在网上浏览规格，并手动传递设备设置。*yesviz.com*（https://yesviz.com/devices.php）有一个设备视口的良好列表。你可以在*DeviceAtlas*（https://deviceatlas.com/blog/list-of-user-agent-strings）找到用户代理列表。
- en: 'If we want to emulate an iPhone 12 device, which is not on the devices list,
    we can do something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想模拟一个不在设备列表中的iPhone 12设备，我们可以这样做：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At the time of writing this book, I wasn't able to find the user agent sent
    by an iPhone 12, so I'm using the one from the iPhone XR. But if you are using
    this as a test tool, it would be a matter of asking your development team which
    values they are checking so you can then test the different user agents used by
    the team.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，我找不到iPhone 12发送的用户代理，所以我使用了iPhone XR的。但如果你将此用作测试工具，这将是询问你的开发团队他们正在检查哪些值的问题，这样你就可以测试团队使用的不同用户代理。
- en: That takes us on to the next questions. How do we apply all these new concepts?
    How should we test mobile emulation?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了下一个问题。我们如何应用所有这些新概念？我们应该如何测试移动模拟？
- en: Testing mobile UX
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试移动用户体验
- en: 'First, you need to check for **behavior changes**. Good developers make a great
    effort to give the best experience based on the device they infer you are using.
    Let''s see how the [www.packtpub.com](http://www.packtpub.com) website looks on
    mobile:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要检查**行为变化**。优秀的开发者会竭尽全力，根据他们推断你正在使用的设备，为你提供最佳体验。让我们看看[www.packtpub.com](http://www.packtpub.com)网站在移动设备上的样子：
- en: '![The packtpub site on an iPhone X'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![The packtpub site on an iPhone X](The_packtpub_site_on_an_iPhone_X.jpg)'
- en: '](img/Figure_8.12_B16113.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.12_B16113.jpg](img/Figure_8.12_B16113.jpg)'
- en: The packtpub site on an iPhone X
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone X上的packtpub网站
- en: As we can see, the experience changes completely. The top menu is changed to
    a hamburger menu, and now you need to click on the magnifying glass to search
    for a book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，体验完全改变。顶部菜单变成了汉堡菜单，现在你需要点击放大镜来搜索书籍。
- en: If you care about UI regressions, you will need to identify the different **layout
    changes**. Grids could become lists, and sections might be removed entirely to
    simplify the UI, fit the content on the screen, and make the user experience much
    nicer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关心UI回归，你需要识别不同的**布局变化**。网格可能变成列表，部分内容可能被完全删除以简化UI，适应屏幕内容，并使用户体验更加出色。
- en: You might be thinking, "OK, but how do I test all that? Which devices should
    I test, all of them?". In order to know which devices to test, we need to know
    a little bit about **breakpoints**. No, not debugging breakings, **media query
    breakpoints**. Media query breakpoints are points that a developer can use to
    apply a different set of CSS styles based on the viewport width or height.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“好吧，但我该如何测试所有这些？我应该测试哪些设备，全部吗？”为了知道应该测试哪些设备，我们需要了解一点关于**断点**的知识。不，不是调试断点，**媒体查询断点**。媒体查询断点是开发者可以使用它来根据视口宽度或高度应用不同CSS样式的地方。
- en: 'Do you remember how when we talked about generating PDF files, we mentioned
    that developers could use `@media print` to determine the style used to print
    a page? Well, `@media print` is not the only option we have there. We can also
    do stuff such as this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们讨论生成PDF文件时提到，开发者可以使用`@media print`来确定打印页面所使用的样式吗？嗯，`@media print`并不是我们唯一的选择。我们还可以做类似这样的事情：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example is taken from the *w3schools* site ([https://www.hardkoded.com/ui-testing-with-puppeteer/breakpoints](https://www.hardkoded.com/ui-testing-with-puppeteer/breakpoints)).
    We can see that developers can set specific styles depending on the width of the
    viewport. Functionally speaking, these days, we talk about five types of device
    categories:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是从*w3schools*网站（[https://www.hardkoded.com/ui-testing-with-puppeteer/breakpoints](https://www.hardkoded.com/ui-testing-with-puppeteer/breakpoints)）上取的。我们可以看到，开发者可以根据视口的宽度设置特定的样式。从功能上讲，如今我们谈论五种类型的设备类别：
- en: Mobile phones in portrait (up to 600 px)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竖向模式的移动电话（最多600 px）
- en: Tablets in portrait (up to 900 px)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纵向模式的平板电脑（最多900 px）
- en: Tablets in landscape (up to 1,200 px)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横向模式的平板电脑（最多1,200 px）
- en: Desktops (up to 1,800 px)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面（最多1,800 px）
- en: Big desktops (bigger than 1,800 px)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型桌面（大于1,800 px）
- en: These numbers are relative, and you should team up with the development team
    and see which breakpoints they are using, and you should try to test edge scenarios
    using those breakpoints.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字是相对的，你应该与开发团队合作，了解他们使用的断点，并尝试使用这些断点测试边缘情况。
- en: 'So maybe once you have met with the development team, you find that, based
    on the breakpoints they use, you should test the following devices:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，也许你与开发团队会面后，你会发现，根据他们使用的断点，你应该测试以下设备：
- en: iPhone 6
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPhone 6
- en: iPad
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPad
- en: iPad Landscape
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纵向模式的iPad
- en: A desktop with a viewport of 1,280x1,080
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个视口为1,280x1,080的桌面
- en: 'We could improve our UI regression tests and test those devices:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改进我们的UI回归测试，并测试这些设备：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, I grabbed the same code from the previous chapter, but I wrapped it in
    a `for` loop that will iterate through the four devices we picked. We will assume
    that an empty string will be the default. If we get a device in the loop, we call
    the `emulate` function. If not, we set the **viewport** we had before.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我抓取了前一章的相同代码，但将其包裹在一个`for`循环中，该循环将遍历我们选择的四个设备。我们将假设空字符串是默认值。如果我们得到循环中的设备，我们调用`emulate`函数。如果没有，我们设置我们之前的**视口**。
- en: Lastly, if you want to emulate user taps, you can replace calls to the `click`
    function with a call to the `tap` function. The `tap` function works just like
    the `click` function, but instead of using mouse emulation, it will use touchscreen
    emulation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想模拟用户点击，你可以将`click`函数的调用替换为`tap`函数的调用。`tap`函数的工作方式与`click`函数类似，但它将使用触摸屏模拟而不是鼠标模拟。
- en: Now we have UI regression tests for mobile devices.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了针对移动设备的UI回归测试。
- en: Tip
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Device emulation is not only for UI testing. Web developers can benefit from
    this feature to check how a page looks on different devices. In the same way that
    we coded this test, you can create a small script that can loop through many devices,
    navigate a page, and take screenshots. Then you can check whether something is
    broken or not.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 设备模拟不仅用于UI测试。Web开发者可以利用这个功能来检查页面在不同设备上的外观。就像我们编写这个测试一样，你可以创建一个小脚本，它可以遍历许多设备，导航页面，并截图。然后你可以检查是否有东西出错了。
- en: 'If you want to test a page''s behavior on mobile devices, it won''t be much
    different from the different Puppeteer tests we''ve been writing. You could create
    a new test file for mobile and add your tests there. You could create a `homepage.iPhone.tests.js`,
    and do something like this in the `beforeEach` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要测试页面的移动设备行为，它将与我们之前编写的不同Puppeteer测试没有太大区别。你可以为移动设备创建一个新的测试文件，并将测试添加到那里。你可以创建一个`homepage.iPhone.tests.js`文件，并在`beforeEach`函数中做如下操作：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The only thing new there is the call to the `emulate` function. From there,
    it is up to you to evaluate which tests you want to write for iPhone and which
    tests you don't. For instance, you might want to test layout changes, but tests
    such as prices or stock checks should be the same no matter the device.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里唯一的新事物是对 `emulate` 函数的调用。从那里，就取决于您来评估您想要为iPhone编写的哪些测试，以及哪些测试不需要。例如，您可能想要测试布局变化，但像价格或库存检查这样的测试无论在什么设备上都应该保持一致。
- en: In this section, we learned how to emulate different viewports, user agents,
    and touch devices. But there is more. Let's move on to bandwidth emulation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何模拟不同的视口、用户代理和触摸设备。但还有更多。让我们继续到带宽模拟。
- en: Emulating network conditions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟网络条件
- en: 'Networking is a challenging topic in computer science. If you tell a network
    engineer that Chromium emulates a 4G network, they will ask you to show them how
    it can emulate radio tower and weather conditions. Chromium does not pretend to
    emulate a network but a network condition. Chromium limits the scope to three
    variables that affect web development: Download speed, Upload speed, and Latency.
    That''s it.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是计算机科学中的一个具有挑战性的主题。如果您告诉一个网络工程师Chromium模拟了4G网络，他们会要求您向他们展示它如何模拟无线电塔和天气条件。Chromium并不假装模拟网络，而是模拟网络条件。Chromium将范围限制在影响Web开发的三个变量：下载速度、上传速度和延迟。仅此而已。
- en: 'Emulating network conditions is something that you can now do on Chromium.
    You can open the developer tools and go to the **Network** tab, and you will find
    a drop-down list called throttling with the **Online** option selected by default,
    as in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在Chromium上执行模拟网络条件。您可以打开开发者工具并转到**网络**选项卡，您将找到一个名为**限制**的下拉列表，默认选中**在线**选项，如下面的截图所示：
- en: '![Emulating network conditions on Chromium'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![在Chromium上模拟网络条件'
- en: '](img/Figure_8.13_B16113.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.13_B16113.jpg)'
- en: Emulating network conditions on Chromium
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chromium上模拟网络条件
- en: 'If you click on that drop-down list, you will find three other options: **Fast
    3G**, **Slow 3G**, and **Offline**. Another cool feature is that you will be able
    to add custom profiles. There you will be asked about three variables we mentioned
    before, download, upload, and latency, and additionally, to provide a name so
    you can identify your new profile.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击那个下拉列表，您将找到三个其他选项：**快速3G**、**慢速3G**和**离线**。另一个酷炫的功能是您将能够添加自定义配置文件。在那里，您将被询问我们之前提到的三个变量：下载、上传和延迟，以及提供一个名称，以便您能够识别您的新配置文件。
- en: Emulating different network conditions is not something you want to add to every
    UI test. We want our tests to be as fast as possible. But it's a great tool to
    perform tests on demand. For instance, say one user of your e-commerce site reports
    that they're unable to finish the checkout process when they're using 4G. The
    company doesn't want to leave mobile users out, so they improve the site to work
    better on 4G. Now we have to write a test to ensure that the page will work on
    4G.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟不同的网络条件并不是您想要添加到每个UI测试中的东西。我们希望我们的测试尽可能快。但它是一个很好的工具，可以按需执行测试。例如，假设您的电子商务网站的一个用户报告说，当他们使用4G时无法完成结账流程。公司不希望让移动用户感到被排除在外，因此他们改进了网站以更好地在4G上运行。现在我们必须编写一个测试来确保页面将在4G上工作。
- en: 'You can emulate different network conditions by calling `page.networkConditions(networkConditions)`,
    where `networkConditions` is an object with the following properties:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用 `page.networkConditions(networkConditions)` 来模拟不同的网络条件，其中 `networkConditions`
    是一个具有以下属性的对象：
- en: '`download`: Download speed (bytes/sec). -1 disables download throttling.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`download`: 下载速度（字节/秒）。-1 禁用下载限制。'
- en: '`upload`: Upload speed (bytes/sec). -1 disables upload throttling.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload`: 上传速度（字节/秒）。-1 禁用上传限制。'
- en: '`latency`: Minimum latency from the request sent to response headers received
    (ms).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`latency`: 从发送请求到接收到响应头部的最小延迟（毫秒）。'
- en: 'The `puppeteer` object has a property called `networkConditions` that provides
    two network settings: `''Slow 3G''` and `''Fast 3G''`. This is how you can use
    them according to the official documentation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppeteer` 对象有一个名为 `networkConditions` 的属性，它提供了两个网络设置：`''Slow 3G''` 和 `''Fast
    3G''`。这是您如何根据官方文档使用它们的示例：'
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But we are not limited to the two options Puppeteer provides. We can create
    our own settings, or find examples on GitHub. For instance, The *porchmark* project
    ([https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark](https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark))
    has a great list. The project is under the MIT license so we can use it freely.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们并不局限于 Puppeteer 提供的两个选项。我们可以创建自己的设置，或者在 GitHub 上找到示例。例如，*porchmark* 项目 ([https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark](https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark))
    有一个很棒的列表。该项目采用 MIT 许可证，因此我们可以自由使用它。
- en: 'These are some values we can get from that project, and then use them in our
    own code to emulate different network conditions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从那个项目中获取一些值，然后在我们自己的代码中使用它们来模拟不同的网络条件：
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are more in that repository. You can see the full list here: [https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark-presets](https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark-presets).
    If you want to incorporate that file, you will need to rename the `downloadThroughput`
    property to `download` and `uploadThroughput` to `upload`, and remove the `offline`
    property. You will also find the `networkPresets.js` file in the project of this
    chapter with all the replacements already made.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个仓库中还有更多。你可以在这里看到完整的列表：[https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark-presets](https://www.hardkoded.com/ui-testing-with-puppeteer/porchmark-presets)。如果你想合并那个文件，你需要将
    `downloadThroughput` 属性重命名为 `download`，将 `uploadThroughput` 重命名为 `upload`，并删除
    `offline` 属性。你还会在这个章节的项目中找到 `networkPresets.js` 文件，其中已经完成了所有替换。
- en: 'We could test our login on a "Good 3G" network with all this information. We
    can go to our `login.tests.js` file and add this test:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用所有这些信息在我们的 “Good 3G” 网络上测试我们的登录。我们可以去我们的 `login.tests.js` 文件并添加这个测试：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the same test as `emulateNetworkConditions` function. If we don''t
    want to use a `NetworkPresets` file, we could hardcode our network condition.
    Let''s see how we can call `page.emulateNetworkConditions` using our own settings:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `emulateNetworkConditions` 函数的测试是相同的。如果我们不想使用 `NetworkPresets` 文件，我们可以硬编码我们的网络条件。让我们看看我们如何使用自己的设置调用
    `page.emulateNetworkConditions`：
- en: '[PRE12]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The end result will be the same. You can also have a fixed preset and add it
    to our existing `config.js` file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将是相同的。你还可以有一个固定的预设，并将其添加到我们现有的 `config.js` 文件中。
- en: We already covered a lot of ground in this chapter. In this section, we learned
    how to emulate different network conditions. We also learned how to execute methods
    from the DevTools protocol that are not exposed in the Puppeteer API. Now it's
    time to learn about localization.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经覆盖了很多内容。在本节中，我们学习了如何模拟不同的网络条件。我们还学习了如何执行 DevTools 协议中的方法，这些方法在 Puppeteer
    API 中没有暴露。现在是时候学习本地化了。
- en: Emulating localization
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟本地化
- en: I love this topic. Maybe because English is not my mother tongue, so I have
    seen and felt the pain when a site fails to honor other cultures.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这个话题。也许是因为英语不是我的母语，所以我看到并感受到了当一个网站未能尊重其他文化时的痛苦。
- en: There are many debates about what localization is, what internationalization
    is, and the difference between them. While I bet there will be debate over whether
    I should treat both as a whole or not, we will treat both as a whole.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本地化是什么，国际化是什么，以及它们之间的区别，有很多争论。虽然我敢打赌，关于我是否应该将两者视为整体会有争论，但我们将把它们视为整体。
- en: 'When we talk about localization, we''re saying that a website should honor
    its audience:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论本地化时，我们是在说一个网站应该尊重其受众：
- en: It should honor their language.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该尊重他们的语言。
- en: It should honor their culture, such as how they read numbers, sort information,
    and read the content.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该尊重他们的文化，例如他们如何阅读数字，如何排序信息，以及如何阅读内容。
- en: It should honor their beliefs. For example, Green/Good Red/Bad might not apply
    in every culture.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该尊重他们的信仰。例如，绿色/好 红色/坏 在每个文化中可能都不适用。
- en: Localization is a feature.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化是一个特性。
- en: Ideally, every site on the web should consider localization. But localization
    can be quite a costly feature to implement. There is a high chance that your company
    is not Google or Amazon and you cannot afford to localize your site for every
    culture, so you need to know your audience.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，网络上的每个网站都应该考虑本地化。但本地化可能是一个相当昂贵的特性来实现。有很大可能性，你的公司不是 Google 或 Amazon，你无法为每种文化本地化你的网站，所以你需要了解你的受众。
- en: 'You might be thinking: "I''m just a QA analyst. Should I care about that?".
    Let me tell you this: You should be the number-one person in the company defending
    and honoring your customers'' culture.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：“我只是个 QA 分析师。我应该关心这个吗？”让我告诉你：你应该成为公司中捍卫和尊重客户文化的第一人。
- en: Let me share a few real-life examples of having a clear scope of your audience.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我分享一些关于明确受众范围的真实生活例子。
- en: I have found many times that buying local train tickets in Europe can be hard.
    They are only in the local language, or the English version of the site is extremely
    poor. The scope is evident. This site is for local people. If you are a tourist,
    go to *Rail Europe*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现很多次，在欧洲购买当地火车票可能会有困难。它们只使用当地语言，或者网站的英文版本非常糟糕。范围显而易见。这个网站是为当地人准备的。如果你是游客，就去*欧洲铁路*。
- en: One colleague from the United States wanted to buy a flight ticket on a Chilean
    website. He went to that site and found a flight at $186.992\. He thought the
    flight price was 186 dollars and 992 cents. In fact, it was one hundred and eighty-six
    thousand, nine hundred and ninety-two Chilean pesos. The site didn't consider
    the way that my friend reads numbers. He wasn't part of the site's audience.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个来自美国的同事想在智利网站上购买机票。他去了那个网站，发现票价为186.992美元。他认为机票价格是186美元和992美分。实际上，那是十八万六千九百九十二智利比索。该网站没有考虑到我的朋友读数字的方式。他不是该网站受众的一部分。
- en: On the bright side, if you go to [www.google.com](http://www.google.com), you
    will always get the site in your preferred language. The world is their audience.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一方面来看，如果你去[www.google.com](http://www.google.com)，你总是会得到你偏好的语言的网站。全世界都是他们的受众。
- en: 'If I go to [www.kayak.com](http://www.kayak.com), I will get prices in my local
    currency, because I''m part of their audience. This is the full list of countries
    you will find on Kayak''s website:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我访问[www.kayak.com](http://www.kayak.com)，我会得到以我本地货币的价格，因为我属于他们的受众。这是你将在Kayak网站上找到的完整国家列表：
- en: '![Kayak''s audience'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![Kayak的受众'
- en: '](img/Figure_8.14_B16113.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.14_B16113.jpg)'
- en: Kayak's audience
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Kayak的受众
- en: This might look like just a list of countries in Kayak. But that's, in fact,
    the definition of their audience.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是在Kayak上的一串国家列表。但实际上，这是他们受众的定义。
- en: If you don't know your site's audience, ask for it, and defend it in your tests.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道你网站的受众，就要求它，并在你的测试中捍卫它。
- en: Before getting into the code, there is one more thing you need to know regarding
    localization. There is no one way to implement it, and Puppeteer won't cover every
    scenario. But, let's take a look at the things we will be able to do with Puppeteer.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，还有一件关于本地化的事情你需要知道。没有一种方法可以实施它，Puppeteer也不会涵盖每个场景。但是，让我们看看我们能够用Puppeteer做什么。
- en: Emulating geolocation
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟地理位置
- en: With Puppeteer, we will be able to change the geolocation used by pages using
    the Geolocation API ([https://www.hardkoded.com/ui-testing-with-puppeteer/geolocalization](https://www.hardkoded.com/ui-testing-with-puppeteer/geolocalization)).
    I chose those words carefully. You won't be able to emulate geolocation completely.
    Most sites use IP-based geolocation. That means that when a site gets a request
    from your device, it will grab the IP, and it will infer your country based on
    an IP-to-country table they have on their server. In other words, you won't be
    able to change the country on *Netflix.com*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppeteer，我们将能够通过Geolocation API（[https://www.hardkoded.com/ui-testing-with-puppeteer/geolocalization](https://www.hardkoded.com/ui-testing-with-puppeteer/geolocalization)）更改页面使用的地理位置。我仔细选择了这些词。你将无法完全模拟地理位置。大多数网站使用基于IP的地理位置。这意味着当网站从你的设备收到请求时，它会抓取IP，并根据他们服务器上的IP到国家表推断出你的国家。换句话说，你无法在*Netflix.com*上更改国家。
- en: So, what can we emulate? You will be able to emulate client-side geolocation,
    such as [maps.google.com](http://maps.google.com) or even the [google.com](http://google.com)
    search itself.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能效仿什么呢？你将能够模拟客户端地理位置，比如[maps.google.com](http://maps.google.com)或者甚至是[google.com](http://google.com)的搜索本身。
- en: 'Let''s say we want to make Google tell us where to eat, but in Paris. We can
    do something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让谷歌告诉我们在哪里吃饭，但是在巴黎。我们可以这样做：
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s go through this code. You can find this script in the `wheretoeat.js`
    file. We already know what `puppeteer.launch` and `browser.newPage` do. The third
    line has something new: `browser.defaultBrowserContext`. OK, that''s new for us,
    but that''s not a big deal. It will give us the context of the new page we got
    in the previous line.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码。你可以在这个`wheretoeat.js`文件中找到这个脚本。我们已经知道`puppeteer.launch`和`browser.newPage`的作用。第三行有一些新内容：`browser.defaultBrowserContext`。好吧，这对我们来说是个新词，但不是什么大问题。它将给我们之前一行获得的新页面的上下文。
- en: 'The next line does have something interesting: `context.overridePermissions`.
    This function allows us to bypass many permission checks that Chromium performs.
    If you open Google for the first time and you search for "where to eat," you will
    get something like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行确实有一些有趣的内容：`context.overridePermissions`。这个函数允许我们绕过 Chromium 执行的许多权限检查。如果你第一次打开
    Google 并搜索“在哪里吃饭”，你将得到类似以下的内容：
- en: '![Geolocation permission request'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![地理位置权限请求'
- en: '](img/Figure_8.15_B16113.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.15_B16113.jpg)'
- en: Geolocation permission request
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 地理位置权限请求
- en: 'That window is not something you can click on with Puppeteer. As we can''t
    click on that, Puppeteer provides `context.overridePermissions` to tell the browser
    which permissions we want to grant automatically. The signature is quite simple:
    `browserContext.overridePermissions(origin, permissions)`, where `origin` is the
    page (the URL) we want to grant permission, and `permissions` is an array of strings
    accepting one of the following values:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 那个窗口不是你可以用 Puppeteer 点击的。由于我们无法点击它，Puppeteer 提供了 `context.overridePermissions`
    来告诉浏览器我们想要自动授予哪些权限。签名相当简单：`browserContext.overridePermissions(origin, permissions)`，其中
    `origin` 是我们想要授予权限的页面（URL），而 `permissions` 是一个字符串数组，可以接受以下值之一：
- en: geolocation
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: geolocation
- en: midi
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: midi
- en: midi-sysex
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: midi-sysex
- en: notifications
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: notifications
- en: push
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: push
- en: camera
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: camera
- en: microphone
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microphone
- en: background-sync
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: background-sync
- en: ambient-light-sensor
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境光传感器
- en: accelerometer
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: accelerometer
- en: gyroscope
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gyroscope
- en: magnetometer
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: magnetometer
- en: accessibility-events
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: accessibility-events
- en: clipboard-read
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: clipboard-read
- en: clipboard-write
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: clipboard-write
- en: payment-handler
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: payment-handler
- en: You don't need to remember all these values; just come to this list when you
    get a permission request, and you need to know which value to use.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要记住所有这些值；只需在你收到权限请求时查看此列表，并知道要使用哪个值。
- en: 'The next line is a fun one: `await page.setGeolocation({latitude: 48.8578349,
    longitude: 2.3249841})`. This function is also fairly straightforward. It only
    expects an object with three properties: `latitude`, which is a number between
    -90 and 90; `longitude`, which is a number between -180 and 180; and `accuracy`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '下一行是一个有趣的内容：`await page.setGeolocation({latitude: 48.8578349, longitude: 2.3249841})`。这个函数也非常简单。它只期望一个包含三个属性的对象：`latitude`，这是一个介于
    -90 和 90 之间的数字；`longitude`，这是一个介于 -180 和 180 之间的数字；以及 `accuracy`。'
- en: Pro tip
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 高级技巧
- en: If you want to know the coordinates of a place, you can go to Google Maps ([https://www.google.com/maps](https://www.google.com/maps))
    and search for a place. The resulting URL will give you the coordinates. For instance,
    if you search for Paris, the URL should be https://www.google.com/maps/search/Paris/@48.8590448,2.3257917,14.49z;
    `48.8590448` will be the latitude, and `2.3257917` the longitude.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道一个地方的坐标，你可以去 Google 地图 ([https://www.google.com/maps](https://www.google.com/maps))
    并搜索一个地方。生成的 URL 将给出坐标。例如，如果你搜索巴黎，URL 应该是 https://www.google.com/maps/search/Paris/@48.8590448,2.3257917,14.49z；`48.8590448`
    将是纬度，`2.3257917` 是经度。
- en: 'After setting the geolocation, we can navigate to Google, type **where to eat**,
    and the result will be where to eat in Paris:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置地理位置后，我们可以导航到 Google，输入**在哪里吃饭**，结果将是巴黎的吃饭地点：
- en: '![Where to eat in Paris'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![在巴黎哪里吃饭'
- en: '](img/Figure_8.16_B16113.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.16_B16113.jpg)'
- en: Where to eat in Paris
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在巴黎哪里吃饭
- en: Puppeteer allows us to emulate not only a location but also a time zone. Let's
    see how we can travel around the globe with Puppeteer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 允许我们模拟不仅是一个位置，还是一个时区。让我们看看我们如何使用 Puppeteer 环游全球。
- en: Emulating time zones
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟时区
- en: Finding a use case for time zone emulation is not easy, but there are a few.
    You can emulate time zones to test an application in some specific time zone,
    even if you are not there. This will be helpful when we talk about scraping in
    the next chapter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个时区模拟的使用案例并不容易，但有一些。你可以模拟时区来测试某个特定时区的应用程序，即使你不在那里。在下一章讨论抓取时，这将很有帮助。
- en: One check that can be interesting is testing that your application saves data
    correctly, no matter the time zone.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的检查是测试你的应用程序是否正确保存数据，无论时区如何。
- en: 'The function to emulate time zones is pretty straightforward: `page.emulateTimezone(timezoneId)`,
    where `timezoneId` is an ICU''s time zone. Chromium also has a list of ICU time
    zones in its source code. You can find it using the following link: [https://www.hardkoded.com/ui-testing-with-puppeteer/metazones](https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟时区的功能相当直接：`page.emulateTimezone(timezoneId)`，其中`timezoneId`是ICU时区。Chromium在其源代码中也有一个ICU时区列表。你可以通过以下链接找到它：[https://www.hardkoded.com/ui-testing-with-puppeteer/metazones](https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt)。
- en: 'If you want to test this feature, you can try changing your time zone and going
    to a site that shows your current date. You can follow this script in the `timezones.js`
    file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试这个功能，你可以尝试更改你的时区，并访问一个显示你当前日期的网站。你可以在`timezones.js`文件中遵循以下脚本：
- en: '[PRE14]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There we set the time zone to "Europe/London," and go to [https://www.unixtimestamp.com/](https://www.unixtimestamp.com/),
    which shows dates and times in different formats. Not a fancy feature, but it
    might be useful someday.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将时区设置为"Europe/London"，然后访问[https://www.unixtimestamp.com/](https://www.unixtimestamp.com/)，它以不同的格式显示日期和时间。这不是一个花哨的功能，但将来可能会有用。
- en: The last thing we want to cover on this localization topic is language.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本本地化主题上要讨论的最后一件事是语言。
- en: Emulating languages
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟语言
- en: Delivering the website in the user's language is the first thing developers
    cover when implementing localization. But there's one problem in our ecosystem.
    Let's cover the four common ways developers implement localization.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现本地化时，开发者首先考虑的是将网站以用户的语言提供。但我们的生态系统中有一个问题。让我们来谈谈开发者实现本地化的四种常见方法。
- en: You will see sites that will show you the content **based on your IP**. If it
    detects your IP is from Spain, it'll show you content in Spanish. If it detects
    you're in France, it'll show you the site in French. What if you live in a country
    with five official languages? It just picks one. As we mentioned when we talked
    about geolocation, we won't be able to emulate IP-based language change.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一些网站会根据你的IP地址显示内容。如果它检测到你的IP来自西班牙，它会显示西班牙语内容。如果你在法国，它会显示法语网站。如果你生活在一个有五种官方语言的国家怎么办？它只会选择一种。正如我们在讨论地理位置时提到的，我们无法模拟基于IP地址的语言更改。
- en: Developers could also deliver **domain-based** solutions. If you go to [www.amazon.es](http://www.amazon.es),
    you will see the content in Spanish. If you go to [www.amazon.fr](http://www.amazon.fr),
    you will see content in French. This will be easy to test. You just need to create
    a language domain map and use it in your tests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者还可以提供**基于域**的解决方案。如果你访问[www.amazon.es](http://www.amazon.es)，你会看到西班牙语内容。如果你访问[www.amazon.fr](http://www.amazon.fr)，你会看到法语内容。这将很容易测试。你只需要创建一个语言域映射并在测试中使用它。
- en: Third, developers might offer a **preference-based** solution. If you go to
    [www.amazon.com](http://www.amazon.com), you'll get the content in English, but
    it will show you a drop-down list somewhere to change your language. This one
    will also be easy to test. You could have one user per language in your test database,
    and then use them to test the website in different languages.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，开发者可能会提供一个**基于偏好的**解决方案。如果你访问[www.amazon.com](http://www.amazon.com)，你会看到英文内容，但会在某个地方看到一个下拉列表来更改你的语言。这个方案也容易测试。你可以在测试数据库中为每种语言设置一个用户，然后使用他们来测试网站在不同语言下的表现。
- en: 'The last option I will cover here, although maybe there are more, is the one
    I believe is the proper way of inferring the user language: by reading the **Accept-Language
    header** value. According to MDN (https://www.hardkoded.com/ui-testing-with-puppeteer/Accept-Language),
    "*the Accept-Language request HTTP header advertises which languages the client
    is able to understand, and which locale variant is preferred. (By languages, we
    mean natural languages, such as English, and not programming languages.) Using
    content negotiation, the server then selects one of the proposals, uses it and
    informs the client of its choice with the Content-Language response header*."'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我要在这里讨论的最后一种选项，尽管可能还有更多，但我认为这是推断用户语言的正确方式：通过读取**Accept-Language头信息**的值。根据MDN
    (https://www.hardkoded.com/ui-testing-with-puppeteer/Accept-Language)，"*Accept-Language请求HTTP头信息告知服务器客户端能够理解的语言以及首选的locale变体。（我们所说的语言是指自然语言，如英语，而不是编程语言。）然后服务器通过内容协商选择一个提议，使用它，并通过Content-Language响应头通知客户端其选择*。”
- en: The browser tells the server which languages you prefer. When you navigate to
    a page, and on every subsequent request after that, the browser adds the **Accept-Language**
    header so that the server can act accordingly.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器告诉服务器您更喜欢哪种语言。当您导航到一个页面，以及之后的每次请求，浏览器都会添加**Accept-Language**头，以便服务器可以相应地操作。
- en: 'When you install a Browser, it will have a default list of languages, based
    on the download option you chose or the language of your Operative System. But
    you can then go to the preferences page and change that list of languages. If
    you go to your browser''s preferences, you should be able to find a **Languages**
    section. You should be able to see something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装一个浏览器时，它将有一个默认的语言列表，基于您选择的下载选项或操作系统的语言。但您可以去偏好设置页面更改那个语言列表。如果您进入浏览器的偏好设置，您应该能够找到一个**语言**部分。您应该能够看到类似以下内容：
- en: '![](img/Figure_8.17_B16113.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_8.17_B16113.jpg)'
- en: Language settings in Microsoft Edge
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Edge的语言设置
- en: 'There, I have three languages: English (United States), English, and Spanish.
    All those three are set in the Accept-Language header. Sadly for us, according
    to Paul Reinheimer (https://twitter.com/preinheimer), only 7.2% of the top 10,000
    sites supported Accept-Language in 2017 (https://wonderproxy.com/blog/accept-language/).
    That means that despite having the tools to infer the language based on the user''s
    preference, most sites won''t use it. I hope that changes over time. How can we
    test languages using the Accept-Language header? It''s not that hard:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，我有三种语言：英语（美国）、英语和西班牙语。所有这三种语言都设置在`Accept-Language`头中。遗憾的是，根据Paul Reinheimer（https://twitter.com/preinheimer）的说法，2017年顶级10,000个网站中只有7.2%支持`Accept-Language`（https://wonderproxy.com/blog/accept-language/）。这意味着尽管我们有根据用户偏好推断语言的工具，但大多数网站都不会使用它。我希望随着时间的推移，这种情况会有所改变。我们如何使用`Accept-Language`头测试语言？这并不难：
- en: '[PRE15]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a way you can get Google's website in French. We will talk more about
    `page.setExtraHTTPHeaders` in the next chapter. But what you need to know is that
    you will be able to change the Accept-Language header the server gets.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种您可以在法语中访问谷歌网站的方法。我们将在下一章中更多地讨论`page.setExtraHTTPHeaders`。但您需要知道的是，您将能够更改服务器收到的`Accept-Language`头。
- en: I think we have now seen the most relevant emulation features that Puppeteer
    offers. But I don't want you to miss anything. Let me briefly show you a few more
    emulation tools.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们现在已经看到了Puppeteer提供的最相关的模拟功能。但我不想让您错过任何东西。让我简要地展示您一些更多的模拟工具。
- en: Other emulations
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他模拟
- en: To wrap up this chapter, I want to share three extra emulation functions with
    you.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章，我想与您分享三个额外的模拟功能。
- en: 'The first one is related to **accessibility**. Localization and accessibility
    are two human topics. They talk about integration, about not leaving anyone out,
    not even from the web. I believe that your website could leave certain cultures
    out (read these words in context, please). You could say, "I don''t plan to sell
    my products to this country, so I don''t need to translate my site to X." As we
    said, localization could be expensive. But we do have to design sites to be inclusive.
    I think that in the same way we enforce shopping malls to have ramps for wheelchairs,
    we should enforce websites to be accessible. I could write lots of pages about
    this, but that''s not the purpose of this book. But I encourage you to read about
    inclusive design on Microsoft''s site: [https://www.microsoft.com/design/inclusive/](https://www.microsoft.com/design/inclusive/).
    I will leave you with this quote from that site:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个与**无障碍性**相关。本地化和无障碍性是两个与人类相关的话题。它们谈论的是整合，关于不让任何人掉队，甚至不包括网络。我相信您的网站可能会排除某些文化（请根据上下文阅读这些话）。您可能会说：“我不打算向这个国家销售我的产品，所以我不需要将我的网站翻译成X。”正如我们所说的，本地化可能会很昂贵。但我们确实需要设计网站以实现包容性。我认为，就像我们强制购物中心为轮椅提供斜坡一样，我们也应该强制网站实现无障碍。我可以写很多关于这个话题的页面，但这不是本书的目的。但我鼓励您在微软的网站上阅读关于包容性设计的内容：[https://www.microsoft.com/design/inclusive/](https://www.microsoft.com/design/inclusive/)。我将用该网站上的这句话作为结束语：
- en: Exclusion happens when we solve problems using our own biases.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 排除发生在我们使用自己的偏见解决问题时。
- en: I'm taking the time to write these paragraphs in a UI testing book because I
    believe that Quality Assurance is the last line of defense for defending and including
    all users of the web.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我花时间写这些段落在一个UI测试书中，因为我相信质量保证是保护并包括所有网络用户的最后一道防线。
- en: 'Puppeteer won''t cover every accessibility check you should do, but it will
    help you emulate different vision deficiencies. You can call the `page.emulateVisionDeficiency(type)`
    function to emulate the following vision deficiencies: **achromatopsia** (total
    color blindness), **deuteranopia** (green color blindness), **protanopia** (red
    color blindness), **tritanopia** (blue-yellow color blindness), and **blurredVision**,
    to check blurred vision. Let''s see how we can use this new function:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 不会涵盖您应该做的每一个可访问性检查，但它将帮助您模拟不同的视觉缺陷。您可以通过调用 `page.emulateVisionDeficiency(type)`
    函数来模拟以下视觉缺陷：**achromatopsia**（全色盲）、**deuteranopia**（绿色盲）、**protanopia**（红色盲）、**tritanopia**（蓝黄色盲）和
    **blurredVision**，以检查模糊视觉。让我们看看我们如何使用这个新功能：
- en: '[PRE16]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you run this check, you will get this result:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行这个检查，您将得到以下结果：
- en: '![Packtpub under blurred vision emulation'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![Packtpub 在模糊视觉模拟下'
- en: '](img/Figure_8.18_B16113.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B16113.jpg)'
- en: Packtpub under blurred vision emulation
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Packtpub 在模糊视觉模拟下
- en: You could write checks such as this and share them in a dashboard, so both the
    design and the development team can see how accessible the site is for people
    with visual impairments.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写这样的检查，并在仪表板上共享它们，这样设计和开发团队都可以看到网站对视力障碍人士的易用性。
- en: 'The next emulation I want to share with you is about emulating media features.
    The function is `page.emulateMediaFeatures(features)`. It accepts an array of
    **name/value** features you want to change. These are the two features that Puppeteer
    supports:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我接下来要分享的下一个模拟是关于模拟媒体功能。函数是 `page.emulateMediaFeatures(features)`。它接受一个您想要更改的
    **name/value** 特性数组。这是 Puppeteer 支持的两个特性：
- en: '`prefers-colors-scheme`, which will help you toggle between `dark` and `light`
    mode'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefers-colors-scheme`，这将帮助您在 `dark` 和 `light` 模式之间切换'
- en: '`prefers-reduced-motion`, which will reduce CSS animations with the `reduce`
    option or `no-preference`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefers-reduced-motion`，这将使用 `reduce` 选项或 `no-preference` 减少CSS动画'
- en: 'This might not have been a popular feature a few years ago. But now, many sites
    are jumping onto the dark mode hype. This is how you can test dark mode:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能几年前不是一个流行的功能。但现在，许多网站都在追逐暗黑模式的潮流。这是您如何测试暗黑模式的方法：
- en: '[PRE17]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we can simply navigate to a page and emulate `prefers-color-scheme`
    with the value `dark`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以简单地导航到一个页面，并模拟 `prefers-color-scheme` 的值为 `dark`。
- en: 'The last emulation I want to share in this chapter is media type emulation.
    We talked about media types when we talked about PDF generation. We have two media
    types: **screen** and **print**. This is an excellent feature if you need to test
    how a page would be printed. You could use it to test the receipt page, which
    might be printed by the user.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我想分享的最后一种模拟是媒体类型模拟。我们在讨论PDF生成时谈到了媒体类型。我们有两种媒体类型：**screen** 和 **print**。如果您需要测试页面打印效果，这是一个非常出色的功能。您可以使用它来测试可能会被用户打印的收据页面。
- en: 'The function is `page.emulateMediaType(type)`, and the type is a string that
    can be `screen` or `print`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 `page.emulateMediaType(type)`，其中类型是一个字符串，可以是 `screen` 或 `print`：
- en: '[PRE18]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we go to the Puppeteer repo and check how it would look if we were about
    to print the page.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们前往 Puppeteer 仓库，看看如果我们即将打印页面，它会是什么样子。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was another chapter full of content. I hope you enjoyed it as much as I
    enjoyed writing it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个内容丰富的章节。我希望您喜欢它，就像我喜欢写它一样。
- en: We started the chapter by talking about the internet ecosystem. We talked about
    how the world is moving toward mobile experiences. This is an excellent time to
    reach out to the person in charge of analytics in your company and see whether
    the charts we saw in this chapter represent your website's users.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以讨论互联网生态系统开始本章。我们讨论了世界如何向移动体验转变。这是一个很好的时机，去联系您公司负责分析的人，看看本章中我们看到的数据图表是否代表了您的网站用户。
- en: Then we moved on to mobile emulation. There, we learn about the viewport, the
    pixel ratio, a fundamental concept in mobile resolution, touchscreen emulation,
    and the user agent.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向移动模拟。在那里，我们学习了视口、像素比、移动分辨率的基本概念，触摸屏模拟和用户代理。
- en: We also learned how to emulate different network conditions. We will see in
    [*Chapter 10*](B16113_10_Final_SK_ePub.xhtml#_idTextAnchor167), *Evaluating and
    Improving the Performance of a Website*, how critical speed is in the mobile experience.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何模拟不同的网络条件。我们将在 [*第10章*](B16113_10_Final_SK_ePub.xhtml#_idTextAnchor167)
    中看到，*评估和改进网站性能*，速度在移动体验中的重要性。
- en: At the end of this chapter, we covered localization emulation. We learned how
    to emulate geolocation, time zones, and languages.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们讨论了本地化模拟。我们学习了如何模拟地理位置、时区和语言。
- en: I didn't want to leave any emulation out of this chapter. That's why we also
    learned about other available emulations. We covered accessibility, dark mode,
    and media type emulation. Testing dark mode will become more important with all
    the dark mode hype we live in these days.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想在本章中遗漏任何模拟内容。这就是为什么我们还学习了其他可用的模拟。我们涵盖了可访问性、暗黑模式和媒体类型模拟。在当前这个充满暗黑模式炒作的时代，测试暗黑模式将变得更加重要。
- en: The next chapter will be about Scraping. We will demystify the concept of scraping
    and learn some new techniques so that you can use Puppeteer not only for testing
    but also for other fun stuff.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍爬取（Scraping）。我们将揭开爬取概念的神秘面纱，并学习一些新技巧，这样你就可以不仅用 Puppeteer 进行测试，还能用于其他有趣的事情。
