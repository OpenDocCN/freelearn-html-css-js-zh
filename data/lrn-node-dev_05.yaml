- en: Basics of Asynchronous Programming in Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js中异步编程的基础知识
- en: 'If you''ve read any article about Node, you''d have probably come across four
    terms: asynchronous, non-blocking, event-based, and single-threaded. All of those
    are accurate terms to describe Node; the problem is it usually stops there, and
    it''s really abstract. The topic of asynchronous programming in Node.js has been
    divided into three chapters. The goal in these upcoming three chapters is to make
    asynchronous programming super practical by putting all these terms to use in
    our weather application. That''s the project we''re going to be building in these
    chapters.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过任何关于Node的文章，你可能会遇到四个术语：异步、非阻塞、事件驱动和单线程。所有这些都是描述Node的准确术语；问题是通常就到此为止，而且这些术语非常抽象。Node.js中的异步编程主题已经分为三章。在接下来的三章中，我们的目标是通过在我们的天气应用程序中使用所有这些术语，使异步编程变得非常实用。这是我们将在这些章节中构建的项目。
- en: This chapter is all about the basics of asynchronous programming. We'll look
    into the basic concepts, terms, and technology related to async programming. We'll
    look into making requests to Geolocation APIs. We'll need to make asynchronous
    HTTP requests. Let's dive in, looking at the very basics of async programming
    in Node.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节主要讲解异步编程的基础知识。我们将深入了解与异步编程相关的基本概念、术语和技术。我们将学习如何向地理位置API发出请求。我们需要进行异步HTTP请求。让我们深入了解Node中异步编程的基础知识。
- en: 'Specifically, we''ll look into the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将研究以下主题：
- en: The basic concept of asynchronous program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步程序的基本概念
- en: Call stack and event loop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用栈和事件循环
- en: Callback functions and APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数和API
- en: HTTPS requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS请求
- en: The basic concept of asynchronous program
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步程序的基本概念
- en: In this section, we're going to create our first asynchronous non-blocking program.
    This means our app will continue to run while it waits for something else to happen.
    In this section, we'll look at a basic example; however, in the chapter, we'll
    be building out a weather app that communicates with third-party APIs, such as
    the Google API and a weather API. We'll need to use asynchronous code to fetch
    data from these sources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建我们的第一个异步非阻塞程序。这意味着我们的应用程序将在等待其他事件发生时继续运行。在本节中，我们将看一个基本的例子；然而，在本章中，我们将构建一个与第三方API（如Google
    API和天气API）通信的天气应用程序。我们需要使用异步代码从这些来源获取数据。
- en: 'For this, all we need to do is make a new folder on the desktop for this chapter.
    I''ll navigate onto my desktop and use `mkdir` to make a new directory, and I''ll
    call this one `weather-app`. All I need to do is navigate into the weather app:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们只需要在桌面上创建一个新的文件夹。我会进入我的桌面并使用`mkdir`创建一个新目录，我会将其命名为`weather-app`。然后我只需要进入weather
    app：
- en: '![](img/04b2a143-975a-478c-8e13-e45f3c7b0cc7.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04b2a143-975a-478c-8e13-e45f3c7b0cc7.png)'
- en: Now, I'll use the `clear` command to clear the Terminal output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将使用`clear`命令清除终端输出。
- en: 'Now, we can open up that new `weather app` directory inside of Atom:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在Atom中打开`weather app`目录：
- en: '![](img/ac8857e7-30de-4a55-9e5c-67806357a18c.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac8857e7-30de-4a55-9e5c-67806357a18c.png)'
- en: This is the directory we'll use throughout this entire chapter. In this section,
    we'll not be building out the weather app just yet, we'll just play around with
    the async features. So inside `weather-app` we'll make the `playground` folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在整个章节中将使用的目录。在本节中，我们不会立即构建天气应用程序，而是先尝试一下异步特性。所以在`weather-app`中，我们将创建`playground`文件夹。
- en: 'This code is not going to be a part of the weather app, but it will be really
    useful when it comes to creating the weather app in the later sections. Now inside
    `playground`, we can make the file for this section. We''ll name it `async-basics.js`
    as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不会成为天气应用程序的一部分，但在后面创建天气应用程序时，它将非常有用。现在在`playground`中，我们可以创建这一节的文件。我们将其命名为`async-basics.js`，如下所示：
- en: '![](img/96badf4f-66db-407f-8eeb-17b0fcd09f0b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96badf4f-66db-407f-8eeb-17b0fcd09f0b.png)'
- en: Illustrating the async programming model
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明异步编程模型
- en: 'To illustrate how the asynchronous programming model works, we''ll get started
    with a simple example using `console.log`. Let''s get started by adding a couple
    of `console.log` statements in a synchronous way. We''ll create one `console.log`
    statement at the beginning of the app that will say `Starting app`, and we will
    add a second one to the end, and the second one will print `Finishing up`, as
    shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明异步编程模型的工作原理，我们将从一个简单的例子开始，使用`console.log`。让我们通过以同步的方式添加一些`console.log`语句来开始。我们将在应用程序的开头创建一个`console.log`语句，显示`Starting
    app`，然后在结尾添加第二个`console.log`语句，显示`Finishing up`，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now these are always going to run synchronously. No matter how many times you
    run the program, `Starting app` is always going to show up before `Finishing up`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些语句将始终同步运行。无论你运行程序多少次，`Starting app`都会在`Finishing up`之前显示。
- en: 'In order to add some asynchronous code, we''ll take a look at a function that
    Node provides called `setTimeout`. The `setTimeout` function is a great method
    for illustrating the basics of non-blocking programming. It takes two arguments:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加一些异步代码，我们将看一下Node提供的一个名为`setTimeout`的函数。`setTimeout`函数是一个很好的方法，可以说明非阻塞编程的基础知识。它接受两个参数：
- en: The first one is a function. This will be referred to as callback function,
    and it will get fired after a certain amount of time.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是一个函数。这将被称为回调函数，并且会在一定时间后触发。
- en: The second argument is a number, which tells the number of milliseconds you
    want to wait. So if you want to wait for one second, you would pass in a thousand
    milliseconds.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个数字，它告诉你想要等待的毫秒数。所以如果你想等待一秒，你需要传入一千毫秒。
- en: 'Let''s call `setTimeout`, passing in an arrow function (`=>`) as our first
    argument. This will be callback function. It will get fired right away; that is,
    it will get fired after the timeout is up, after our two seconds. And then we
    can set up our second argument which is the delay, `2000` milliseconds, which
    equals those two seconds:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用`setTimeout`，将箭头函数(`=>`)作为第一个参数。这将是回调函数。它将立即触发；也就是说，在超时结束后，两秒后触发。然后我们可以设置我们的第二个参数，即延迟`2000`毫秒，等于这两秒：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the arrow function (`=>`), all we''ll do is use a `console.log` statement
    so that we can figure out exactly when our function fires, because the statement
    will print to the screen. We''ll add `console.log` and then inside callback to
    get the job done, as shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数(`=>`)中，我们将使用`console.log`语句，以便我们可以确定我们的函数何时触发，因为该语句将打印到屏幕上。我们将添加`console.log`，然后在回调函数内完成工作，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this in place, we''re actually ready to run our very first async program,
    and I''ll not use `nodemon` to execute it. I''ll run this file from the Terminal
    using the basic Node command; `node playground` and the file inside the `playground`
    folder which is `async-basic.js`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '有了这个，我们实际上已经准备好运行我们的第一个异步程序了，我将不使用`nodemon`来执行它。我将使用基本的Node命令从终端运行这个文件；`node
    playground`和`playground`文件夹中的文件`async-basic.js`： '
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now pay close attention to exactly what happens when we hit e*nter*. We''ll
    see two messages show up right away, then two seconds later our final message,
    `Inside of callback`, prints to the screen:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要特别注意当我们按下回车键时发生了什么。我们会立即看到两条消息显示出来，然后两秒后我们的最终消息`Inside of callback`打印到屏幕上：
- en: '![](img/510326df-2908-422e-b443-97b9c45037b7.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/510326df-2908-422e-b443-97b9c45037b7.png)'
- en: 'The sequence in which these messages are shown is: first we got `Starting app`;
    almost immediately after this, `Finishing up` prints to the screen and finally
    (two seconds later), `Inside of callback` was printed as shown in the previous
    code. Inside the file, this is not the order in which we wrote the code, but it
    is the order the code executes in.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息显示的顺序是：首先我们得到`Starting app`；几乎立即，`Finishing up`打印到屏幕上，最后（两秒后），`Inside of
    callback`如前面的代码所示。在文件内部，这不是我们编写代码的顺序，但这是代码执行的顺序。
- en: The `Starting app` statement prints to the screen as we expect. Next, we call
    `setTimeout`, but we're not actually telling it to wait two seconds. We're registering
    a callback that will get fired in two seconds. This will be an asynchronous callback,
    which means that Node can do other things while these two seconds are happening.
    In this case, the other thing it moves down to the `Finishing up` message. Now
    since we did register this callback by using `setTimeout`, it will fire at some
    point in time, and two seconds later we do see `Inside of callback` printing to
    the screen.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Starting app`语句按我们的预期打印到屏幕上。接下来，我们调用`setTimeout`，但实际上我们并没有告诉它等待两秒。我们正在注册一个回调，将在两秒后触发。这将是一个异步回调，这意味着在这两秒内Node可以做其他事情。在这种情况下，它会继续执行`Finishing
    up`消息。现在，由于我们使用`setTimeout`注册了这个回调，它将在某个时间点触发，两秒后我们确实看到`Inside of callback`打印到屏幕上。'
- en: By using non-blocking I/O, we're able to wait, in this case two seconds, without
    preventing the rest of the program from executing. If this was blocking I/O, we
    would have to wait two seconds for this code to fire, then the `Finishing up`
    message would print to the screen, and obviously that would not be ideal.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用非阻塞I/O，我们能够等待，这种情况下是两秒，而不会阻止程序的其余部分执行。如果这是阻塞I/O，我们将不得不等待两秒钟才能触发此代码，然后`Finishing
    up`消息将打印到屏幕上，显然这是不理想的。
- en: Now this is a pretty contrived example, we will not exactly use `setTimeout`
    in our real-world apps to create unnecessary arbitrary delays, but the principles
    are the same. For example, when we fetch data from the Google API we'll need to
    wait about 100 to 200 milliseconds for that data to come back, and we don't want
    the rest of the program to just be idle, it will continue. We'll register a callback,
    and that callback will get fired once the data comes back from the Google servers.
    The same principles applies even though what's actually happening is quite different.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个相当牵强的例子，我们不会在我们的真实应用程序中使用`setTimeout`来创建不必要的任意延迟，但原则是相同的。例如，当我们从Google
    API获取数据时，我们需要等待大约100到200毫秒才能收到数据，我们不希望程序的其余部分只是空闲，它将继续执行。我们将注册一个回调，一旦数据从Google服务器返回，该回调将被触发。即使实际发生的事情完全不同，但相同的原则也适用。
- en: 'Now, we want to write another `setTimeout` right here. We want to register
    a `setTimeout` function that prints a message; something like `Second setTimeout
    works`. This will be inside the callback, and we want to register a delay of `0`
    milliseconds, no delay at all. Let''s fill out the async basics `setTimeout`.
    I''ll call `setTimeout` with my arrow function (`=>`), passing in a delay of `0`
    milliseconds, as shown in the following code. Inside the arrow function (`=>`),
    I''ll use `console.log` so I can see exactly when this function executes, and
    I''ll use `Second setTimeout` as the text:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想在这里写另一个`setTimeout`。我们想要注册一个`setTimeout`函数，打印一条消息; 类似`Second setTimeout
    works`。这将在回调函数内部，我们想要注册一个延迟`0`毫秒，没有延迟。让我们填写async基础`setTimeout`。我将使用箭头函数(`=>`)调用`setTimeout`，传入`0`毫秒的延迟，如下面的代码所示。在箭头函数(`=>`)中，我将使用`console.log`，以便我可以看到这个函数何时执行，我将使用`Second
    setTimeout`作为文本：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have this in place, we can run the program from the Terminal, and
    it''s really important to pay attention to the order in which the statements print.
    Let''s run the program:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好从终端运行程序了，非常重要的是要注意语句打印的顺序。让我们运行程序：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Right away we get three statements and then at the very end, two seconds later,
    we get our final statement:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 立即我们得到三个语句，然后在最后，两秒后，我们得到我们的最终语句：
- en: '![](img/23b9c478-6bd3-439f-a4a1-3a0eed3ad0dd.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23b9c478-6bd3-439f-a4a1-3a0eed3ad0dd.png)'
- en: We start with `Starting app`, which makes sense, it's at the top. Then we get
    `Finishing up`. After `Finishing up` we get `Second setTimeout`, which seems weird,
    because we clearly told Node we want to run this function after `0` milliseconds,
    which should run it right away. But in our example, `Second setTimeout` printed
    after `Finishing up`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Starting app`开始，这是有道理的，它在顶部。然后我们得到`Finishing up`。在`Finishing up`之后，我们得到`Second
    setTimeout`，这似乎很奇怪，因为我们明确告诉Node我们希望在`0`毫秒后运行这个函数，这应该立即运行它。但在我们的示例中，`Second setTimeout`在`Finishing
    up`之后打印出来。
- en: Finally, `Inside of callback` printed to the screen. This behavior is completely
    expected. This is exactly how Node.js is supposed to operate, and it will become
    a lot clearer after the next section, where we'll go through this example exactly,
    showing you what happens behind the scenes. We'll get started with a more basic
    example showing you how the call stack works, we'll talk all about that in the
    next section, and then we'll go on to a more complex example that has some asynchronous
    events attached to it. We'll discuss the reason why `Second setTimeout` comes
    up after the `Finishing up` message after the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Inside of callback`打印到屏幕上。这种行为完全是预期的。这正是Node.js应该运行的方式，而在下一节中，我们将通过这个例子来详细展示幕后发生了什么。我们将从一个更基本的示例开始，向你展示调用堆栈的工作方式，我们将在下一节中详细讨论这一点，然后我们将继续进行一个更复杂的示例，其中附加了一些异步事件。我们将讨论为什么`Second
    setTimeout`在`Finishing up`消息之后出现。
- en: Call stack and event loop
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用堆栈和事件循环
- en: In the last section, we ended up creating our very first asynchronous application,
    but unfortunately we ended up asking more questions than we got answers. We don't
    exactly know how async programming works even though we've used it. Our goal for
    this section is to understand why the program runs the way it does.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们最终创建了我们的第一个异步应用程序，但不幸的是，我们提出了更多问题，而不是得到了答案。尽管我们使用了异步编程，但我们并不确切知道它是如何工作的。我们本节的目标是理解程序运行的方式。
- en: For example, why does the two-second delay in the following code not prevent
    the rest of the app from running, and why does a `0` second delay cause the function
    to be executed after `Finishing up` prints to the screen?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为什么以下代码中的两秒延迟不会阻止应用程序的其余部分运行，为什么`0`秒延迟会导致函数在`Finishing up`打印到屏幕后执行？
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These are all questions we'll answer in this section. This section will take
    you behind the scenes into what happens in V8 and Node when an async program runs.
    Now let's dive right into how the async program runs. We'll start with some basic
    synchronous examples and then move on to figuring out exactly what happens in
    the async program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们将在本节中回答的问题。本节将带你深入了解异步程序运行时V8和Node中发生的事情。现在让我们直接深入了解异步程序的运行方式。我们将从一些基本的同步示例开始，然后继续找出异步程序中究竟发生了什么。
- en: A synchronous program example
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步程序示例
- en: 'The following is example number one. On the left-hand side we have the code,
    a basic synchronous example, and on the right-hand side we have everything that
    happens behind the scenes, the Call Stack, our Node APIs, the Callback Queue,
    and the Event Loop:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例一。在左侧是代码，一个基本的同步示例，右侧是发生在幕后的一切，调用堆栈、我们的Node API、回调队列和事件循环：
- en: '![](img/9462dc2e-caf3-45d0-ac4e-b9dc70e780b2.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9462dc2e-caf3-45d0-ac4e-b9dc70e780b2.jpg)'
- en: Now if you've ever read an article or watched any video lesson on how Node works,
    you've most likely heard about one or more of these terms. In this section, we'll
    be exploring how they all fit together to create a real-world, working Node application.
    Now for our first synchronous example, all we need to worry about is the Call
    Stack. The Call Stack is part of a V8, and for our synchronous example it's the
    only thing that's going to run. We're not using any Node APIs and we're not doing
    any asynchronous programming.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你曾经阅读过有关Node工作原理的文章或观看过任何视频课程，你很可能听说过这些术语中的一个或多个。在本节中，我们将探讨它们如何共同组成一个真实的、可工作的Node应用程序。现在，对于我们的第一个同步示例，我们只需要担心调用堆栈。调用堆栈是V8的一部分，对于我们的同步示例，它是唯一要运行的东西。我们不使用任何Node
    API，也不进行任何异步编程。
- en: The call stack
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用堆栈
- en: 'The Call Stack is a really simple data structure that keeps track of program
    execution inside of a V8\. It keeps track of the functions currently executing
    and the statements that are fired. The Call Stack is a really simple data structure
    that can do two things:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 调用堆栈是一个非常简单的数据结构，用于跟踪V8内部的程序执行。它跟踪当前正在执行的函数和已触发的语句。调用堆栈是一个非常简单的数据结构，可以做两件事：
- en: You can add something on top of it
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在顶部添加一些东西
- en: You can remove the top item
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以移除顶部的项目
- en: This means if there's an item at the bottom of the data structure and there's
    an item above it, you can't remove the bottom item, you have to remove the top
    item. If there's already two items and you want to add something on to it, it
    has to go on because that's how the Call Stack works.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果数据结构的底部有一个项目，上面有一个项目，你不能移除底部的项目，你必须移除顶部的项目。如果已经有两个项目，你想要添加一个项目，它必须放在上面，因为这就是调用堆栈的工作方式。
- en: 'Think about it like a can of Pringles or a thing of tennis balls: if there''s
    already an item in there and you drop one in, the item you just dropped will not
    be the bottom item, it''s going to be the top item. Also, you can''t remove the
    bottom tennis ball from a can of tennis balls, you have to remove the one on top
    first. That''s exactly how the Call Stack works.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下它就像一罐薯片或一罐网球：如果里面已经有一个项目，你再放一个进去，你刚刚放进去的项目不会成为底部项目，它将成为顶部项目。此外，你不能从一罐网球中移除底部的网球，你必须先移除顶部的网球。这正是调用堆栈的工作方式。
- en: Running the synchronous program
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行同步程序
- en: Now when we start executing the program shown in the following screenshot, the
    first thing that will happen is Node will run the main function. The main function
    is the wrapper function we saw over in nodemon (refer to, *Installing the nodemon
    module* section in [Chapter 2](9e56dc82-3ad8-4376-81b7-27ba482bd4e2.xhtml), *Node
    Fundamentals Part-1*) that gets wrapped around all of our files when we run them
    through Node. In this case, by telling V8 to run the main function we are starting
    the program.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们开始执行下面截图中显示的程序时，首先会发生的事情是Node将运行main函数。main函数是我们在nodemon中看到的包装函数（参见[第2章](9e56dc82-3ad8-4376-81b7-27ba482bd4e2.xhtml)中的*安装nodemon模块*部分，*Node基础知识第1部分*），当我们通过Node运行所有文件时，它会包装在所有文件周围。在这种情况下，通过告诉V8运行main函数，我们开始了程序。
- en: 'As shown in the following screenshot, the first thing we do in the program
    is create a variable `x`, setting it equal to `1`, and that''s the first statement
    that''s going to run:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的截图所示，我们在程序中的第一件事是创建一个变量`x`，将其设置为`1`，这是将要运行的第一个语句：
- en: '![](img/70060c29-23bb-4f89-b2fa-cfc7b5d7cd0f.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70060c29-23bb-4f89-b2fa-cfc7b5d7cd0f.jpg)'
- en: 'Notice it comes in on top of main. Now this statement is going to run, creating
    the variable. Once it''s done, we can remove it from the Call Stack and move on
    to the next statement, where we make the variable `y`, which gets set equal to
    `x`, which is `1` plus `9`. That means `y` is going to be equal to `10`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它出现在main的上面。现在这个语句将运行，创建变量。一旦完成，我们可以将其从调用堆栈中移除，并继续下一个语句，其中我们将变量`y`设置为`x`，`x`是`1`加`9`。这意味着`y`将等于`10`：
- en: '![](img/19d054e3-7f09-4d91-8de5-fef056d46fcb.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19d054e3-7f09-4d91-8de5-fef056d46fcb.jpg)'
- en: 'As shown in the previous screenshot, we do that and move on to the next line.
    The next line is our `console.log` statement. The `console.log` statement will
    print `y` is `10` to the screen. We use template strings to inject the `y` variable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们这样做并继续下一行。下一行是我们的`console.log`语句。`console.log`语句将在屏幕上打印`y`是`10`。我们使用模板字符串来注入`y`变量：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run this line it gets popped on to the Call Stack, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这行时，它被弹出到调用堆栈上，如下所示：
- en: '![](img/306ebfce-aff9-4024-a01e-0bbed6a0d391.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/306ebfce-aff9-4024-a01e-0bbed6a0d391.jpg)'
- en: Once the statement is done, it gets removed. At this point, we've executed all
    the statements inside our program and the program is almost ready to be complete.
    The main function is still running but since the function ends, it implicitly
    returns, and when it returns, we remove main from the Call Stack and the program
    is finished. At this point, our Node process is closed. Now this is a really basic
    example of using the Call Stack. We went into the main function, and we moved
    line by line through the program.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦语句完成，它就会被移除。此时，我们已经执行了程序中的所有语句，程序几乎完成了。主函数仍在运行，但由于函数结束，它会隐式返回，当它返回时，我们将main从调用堆栈中移除，程序就完成了。此时，我们的Node进程已关闭。现在这是使用调用堆栈的一个非常基本的例子。我们进入了main函数，然后逐行通过程序。
- en: A complex synchronous program example
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个复杂的同步程序示例
- en: 'Let''s go over a slightly more complex example, our second example. As shown
    in the following code, we start off by defining an `add` function. The `add` function
    takes arguments `a` and `b`, adds them together storing that in a variable called
    `total`, and returns `total`. Next, we add up `3` and `8`, which is `11`, storing
    it in the `res` variable. Then, we print out the response using the `console.log`
    statement, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个稍微复杂一点的例子，我们的第二个例子。如下面的代码所示，我们首先定义一个`add`函数。`add`函数接受参数`a`和`b`，将它们相加并将结果存储在一个名为`total`的变量中，然后返回`total`。接下来，我们将`3`和`8`相加，得到`11`，将其存储在`res`变量中。然后，我们使用`console.log`语句打印出响应，如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That''s it, nothing synchronous is happening. Once again we just need the Call
    Stack. The first thing that happens is we execute the main function; this starts
    the program we have here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，没有发生任何同步的事情。再次强调，我们只需要调用堆栈。发生的第一件事是我们执行main函数；这启动了我们这里的程序：
- en: '![](img/6ec5b5ab-7d5e-462c-a768-7e8e0ea744ad.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ec5b5ab-7d5e-462c-a768-7e8e0ea744ad.jpg)'
- en: 'Then we run the first statement where we define the `add` variable. We''re
    not actually executing the function, we''re simply defining it here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行第一个语句，其中我们定义`add`变量。我们实际上并没有执行函数，我们只是在这里定义它：
- en: '![](img/63ff443b-843d-4f82-b65a-9a1c92420682.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63ff443b-843d-4f82-b65a-9a1c92420682.jpg)'
- en: 'In the preceding image, the `add()` variable gets added on to the Call Stack,
    and we define `add`. The next line, line `7`, is where we call the `add` variable
    storing the return value on the response variable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，`add()`变量被添加到调用堆栈上，并且我们定义了`add`。下一行，第7行，是我们调用`add`变量，将返回值存储在response变量中：
- en: '![](img/dc68ead6-954e-4a52-96b6-2a28c73d04b1.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc68ead6-954e-4a52-96b6-2a28c73d04b1.jpg)'
- en: When you call a function, it gets added on top of the Call Stack. When you return
    from a function, it gets removed from the Call Stack.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数时，它会被添加到调用堆栈的顶部。当你从一个函数返回时，它会从调用堆栈中移除。
- en: 'In this example, we''ll call a function. So we''re going to add `add()` on
    to the Call Stack, and we''ll start executing that function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将调用一个函数。所以我们将`add()`添加到调用堆栈上，并开始执行该函数：
- en: '![](img/014ad652-75db-4d3b-a2f4-261afbacce6a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/014ad652-75db-4d3b-a2f4-261afbacce6a.png)'
- en: 'As we know, when we add main we start executing main and, when we add `add()`
    we start executing add. The first line inside `add` sets the `total` variable
    equal to `a + b`, which would be `11`. We then return from the function using
    the `return total` statement. That''s the next statement, and when this runs,
    `add` gets removed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，当我们添加main时，我们开始执行main，当我们添加`add()`时，我们开始执行add。`add`内的第一行将`total`变量设置为`a
    + b`，即`11`。然后我们使用`return total`语句从函数中返回。这是下一个语句，当这个语句运行时，`add`被移除：
- en: '![](img/6194fada-6e7e-45a8-b471-18aa71102281.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6194fada-6e7e-45a8-b471-18aa71102281.png)'
- en: 'So when `return total` finishes, `add()` gets removed, then we move on to the
    final line in the program, our `console.log` statement, where we print `11` to
    the screen:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`return total`完成时，`add()`被移除，然后我们继续执行程序中的最后一行，我们的`console.log`语句，其中我们将`11`打印到屏幕上：
- en: '![](img/b78be88d-6449-4055-8f3c-051c24e50d8a.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b78be88d-6449-4055-8f3c-051c24e50d8a.png)'
- en: The `console.log` statement will run, print `11` to the screen and finish the
    execution, and now we're at the end of the main function, which gets removed from
    the stack when we implicitly return. This is the second example of a program running
    through the V8 Call Stack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log`语句将运行，将`11`打印到屏幕上并完成执行，现在我们已经到达主函数的末尾，在隐式返回时从调用栈中移除。这是程序通过V8调用栈运行的第二个示例。'
- en: An async program example
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步程序示例
- en: 'So far we haven''t used Node APIs, the Callback Queue, or the Event Loop. The
    next example will use all four (Call Stack, the Node APIs, the Callback Queue,
    and the Event Loop). As shown on the left-hand side of the following screenshot,
    we have our async example, exactly the same as we wrote it in the last section:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有使用Node APIs、回调队列或事件循环。下一个示例将使用所有四个（调用栈、Node APIs、回调队列和事件循环）。如下面截图左侧所示，我们有一个异步示例，与上一节中写的完全相同：
- en: '![](img/e43204f3-ed6a-49d5-a851-f00f726b4741.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e43204f3-ed6a-49d5-a851-f00f726b4741.png)'
- en: 'In this example, we will be using the Call Stack, the Node APIs, the Callback
    Queue, and the Event Loop. All four of these are going to come into play for our
    asynchronous program. Now things are going to start off as you might expect. The
    first thing that happens is we run the main function by adding it on to the Call
    Stack. This tells a V8 to kick off the code we have on the left side in the previous
    screenshot, shown here again:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用调用栈、Node APIs、回调队列和事件循环。所有这四个都将在我们的异步程序中发挥作用。现在事情将开始如你所期望的那样。首先发生的是我们将主函数添加到调用栈中运行。这告诉V8启动我们在上一截图左侧的代码，再次显示如下：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first statement in this code is really simple, a `console.log` statement
    that prints `Starting app` to the screen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的第一个语句非常简单，是一个`console.log`语句，将`Starting app`打印到屏幕上：
- en: '![](img/2d83849c-ded9-4fde-86a4-9d8840f0ba69.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d83849c-ded9-4fde-86a4-9d8840f0ba69.png)'
- en: 'This statement runs right away and we move on to the second statement. The
    second statement is where things start to get interesting, this is a call to `setTimeout`,
    which is indeed a Node API. It''s not available inside a V8, it''s something that
    Node gives us access to:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句会立即运行，然后我们继续执行第二个语句。第二个语句是开始变得有趣的地方，这是对`setTimeout`的调用，它确实是一个Node API。它在V8内部不可用，这是Node给我们提供的：
- en: '![](img/7b6ac225-620b-4319-ad4a-5c77643b586a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b6ac225-620b-4319-ad4a-5c77643b586a.png)'
- en: The Node API in async programming
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程中的Node API
- en: 'When we call the `setTimeout (2 sec)` function, we''re actually registering
    the event callback pair in the Node APIs. The event is simply to wait two seconds,
    and the callback is the function we provided, the first argument. When we call
    `setTimeout`, it gets registered right in the Node APIs as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`setTimeout (2 sec)`函数时，实际上是在Node APIs中注册事件回调对。事件就是等待两秒，回调函数是我们提供的函数，也就是第一个参数。当我们调用`setTimeout`时，它会像下面这样在Node
    APIs中注册：
- en: '![](img/60a18658-2f1b-4eb0-bb20-6ce701ece9f2.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60a18658-2f1b-4eb0-bb20-6ce701ece9f2.jpg)'
- en: 'Now this statement will finish up, the Call Stack will move on, and the `setTimeout`
    will start counting down. Just because the `setTimeout` is counting down, it doesn''t
    mean the Call Stack can''t continue to do its job. The Call Stack can only run
    one thing at a time, but we can have events waiting to get processed even when
    the Call Stack is executing. Now the next statement that runs is the other call
    to `setTimeout`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个语句将结束，调用栈将继续执行，`setTimeout`将开始倒计时。`setTimeout`正在倒计时，并不意味着调用栈不能继续执行它的工作。调用栈一次只能运行一件事情，但即使调用栈在执行，我们也可以有事件等待处理。现在运行的下一个语句是另一个对`setTimeout`的调用：
- en: '![](img/e7d396b0-ba1e-4070-b54c-6f456ba39ad6.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7d396b0-ba1e-4070-b54c-6f456ba39ad6.png)'
- en: 'In this, we register a `setTimeout` callback function with a delay of `0` milliseconds,
    and the exact same thing happens. It''s a Node API and it''s going to get registered
    as shown in the following screenshot. This essentially says that after zero seconds,
    you can execute this callback:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注册了一个延迟为`0`毫秒的`setTimeout`回调函数，发生了完全相同的事情。这是一个Node API，将如下截图所示注册：
- en: '![](img/110b8bc0-920b-4467-9024-0bb618a6985c.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/110b8bc0-920b-4467-9024-0bb618a6985c.jpg)'
- en: The `setTimeout (0 sec)` statement gets registered and the Call Stack removes
    that statement.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout (0 sec)`语句被注册，调用栈移除该语句。'
- en: The callback queue in async programming
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程中的回调队列
- en: 'At this point let''s assume that `setTimeout`, the one that has a zero second
    delay, finishes. When it finishes, it''s not going to get executed right away;
    it''s going to take that callback and move it down into the Callback Queue, as
    shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，让我们假设`setTimeout`，那个零秒延迟的函数，已经完成。当它完成时，它不会立即被执行；它会把回调函数移动到回调队列中，如下所示：
- en: '![](img/74fbf540-71b8-499a-a7cf-2da14ed034de.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74fbf540-71b8-499a-a7cf-2da14ed034de.jpg)'
- en: The Callback Queue is all the callback functions that are ready to get fired.
    In the previous screenshot, we move the function from Node API into the Callback
    Queue. Now the Callback Queue is where our callback functions will wait; they
    need to wait for the Call Stack to be empty.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 回调队列是所有准备好被触发的回调函数。在前面的截图中，我们将函数从Node API移动到回调队列中。现在回调队列是我们的回调函数将等待的地方；它们需要等待调用栈为空。
- en: When the Call Stack is empty we can run the first function. There's another
    function after it. We'll have to wait for that first function to run before the
    second one does, and this is where the Event Loop comes into play.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用栈为空时，我们可以运行第一个函数。在它之后还有另一个函数。在第一个函数运行之前，我们必须等待第二个函数运行，这就是事件循环发挥作用的地方。
- en: The event loop
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: The Event Loop takes a look at the Call Stack. If the Call Stack is not empty,
    it doesn't do anything because it can't, there is nothing it can do you can only
    run one thing at a time. If the Call Stack is empty, the Event Loop says great
    let's see if there's anything to run. In our case, there is a callback function,
    but because we don't have an empty Call Stack, the Event Loop can't run it. So
    let's move on with the example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环查看调用堆栈。如果调用堆栈不为空，则不执行任何操作，因为它无法执行任何操作，一次只能运行一件事。如果调用堆栈为空，事件循环会说好的，让我们看看是否有任何要运行的东西。在我们的情况下，有一个回调函数，但是因为我们没有空的调用堆栈，事件循环无法运行它。所以让我们继续示例。
- en: Running the async code
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行异步代码
- en: 'The next thing that happens in our program is we run our `console.log` statement,
    which prints `Finishing up` to the screen. This is the second message that shows
    up in the Terminal:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序中的下一件事是运行我们的`console.log`语句，将`Finishing up`打印到屏幕上。这是在终端中显示的第二条消息：
- en: '![](img/6b591f34-12a2-410f-b7d2-3911a9d3f9d3.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b591f34-12a2-410f-b7d2-3911a9d3f9d3.png)'
- en: This statement runs, our main function is complete, and it gets removed from
    the Call Stack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句运行，我们的主函数完成，并从调用堆栈中移除。
- en: 'At this point, the Event Loop says hey I see that we have nothing in the call
    stack and we do have something in the Callback Queue, so let''s run that callback
    function. It will take the callback and move it into the Call Stack; this means
    the function is executing:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，事件循环说，嘿，我看到我们的调用堆栈中没有任何内容，而回调队列中有内容，所以让我们运行那个回调函数。它将获取回调并将其移动到调用堆栈中；这意味着函数正在执行：
- en: '![](img/7ee2ab4f-d118-48c1-bf7f-aecc519e88c5.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ee2ab4f-d118-48c1-bf7f-aecc519e88c5.png)'
- en: It will run the first line which is sitting on line `8`, `console.log`, printing
    `Second setTimeout` to the screen. This is why `Second setTimeout` shows up after
    `Finishing up` in our previous section examples, because we can't run our callback
    until the Call Stack is complete. Since `Finishing up` is part of the main function,
    it will always run before `Second setTimeout`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它将运行第一行，该行位于第`8`行，`console.log`，将`Second setTimeout`打印到屏幕上。这就是为什么在我们之前的部分示例中，`Second
    setTimeout`在`Finishing up`之后出现的原因，因为在调用堆栈完成之前，我们无法运行回调。由于`Finishing up`是主函数的一部分，它将始终在`Second
    setTimeout`之前运行。
- en: 'After our `Second setTimeout` statement finishes, the function is going to
    implicitly return and callback will get removed from the Call Stack:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Second setTimeout`语句完成后，函数将隐式返回，并且回调将从调用堆栈中移除：
- en: '![](img/0e185b6b-e029-4292-91f9-cf15147fe72c.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e185b6b-e029-4292-91f9-cf15147fe72c.png)'
- en: 'At this point, there''s nothing in the Call Stack and nothing in the Callback
    Queue, but there is still something in our Node APIs, we still have an event listener
    registered. So the Node process is not yet completed. Two seconds later, the `setTimeout(2
    sec)` event is going to fire, and it''s going to take that callback function and
    move it into the Callback Queue. It gets removed from the Node APIs and it gets
    added to the Callback Queue:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，调用堆栈中没有任何内容，回调队列中也没有任何内容，但是我们的Node API中仍然有内容，我们仍然注册了一个事件监听器。因此，Node进程尚未完成。两秒后，`setTimeout(2
    sec)`事件将触发，并将回调函数移动到回调队列中。它将从Node API中移除，并添加到回调队列中：
- en: '![](img/b50be7e7-2306-42f7-8a85-d2b2b31d6a67.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b50be7e7-2306-42f7-8a85-d2b2b31d6a67.jpg)'
- en: 'At this point, the Event Loop will take a look at the Call Stack and see it''s
    empty. Then it will take a quick look at the Callback Queue and see there is indeed
    something to run. What will it do? It will take that callback, add it on to the
    Call Stack, and start the process of executing it. This means that we''ll run
    our one statement inside callback. After that''s finished, the callback function
    implicitly returns and our program is complete:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，事件循环将查看调用堆栈，并看到它是空的。然后它会快速查看回调队列，并确实有要运行的内容。它会怎么做？它将获取该回调，将其添加到调用堆栈中，并开始执行该过程。这意味着我们将运行回调中的一个语句。完成后，回调函数将隐式返回，程序完成：
- en: '![](img/e2aea224-9be5-4a15-b9ef-7d950c526818.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2aea224-9be5-4a15-b9ef-7d950c526818.png)'
- en: This is exactly how our program ran. This illustrates how we're able to register
    our events using Node APIs, and why when we use a `setTimeout` of zero the code
    doesn't run right away. It needs to go through the Node APIs and through the Callback
    Queue before it can ever execute on the Call Stack.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们的程序运行的方式。这说明了我们如何能够使用Node API注册我们的事件，以及为什么当我们使用`setTimeout`为零时，代码不会立即运行。它需要通过Node
    API和回调队列才能在调用堆栈上执行。
- en: Now as I mentioned in the beginning of this section, the Call Stack, the Node
    APIs, the Callback Queue, and the Event Loop are pretty confusing topics. A big
    reason why they're confusing is because we never actually directly interact with
    them; they're happening behind the scenes. We're not calling the Callback Queue,
    we're not firing an Event Loop method to make these things work. This means we're
    not aware they exist until someone explains them. These are topics that are really
    hard to grasp the first time around. By writing real asynchronous code it's going
    to become a lot clearer how it works.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我在本节开头提到的，调用堆栈、Node API、回调队列和事件循环是非常令人困惑的话题。它们令人困惑的一个重要原因是因为我们实际上从未直接与它们交互；它们是在幕后发生的。我们没有调用回调队列，我们没有触发事件循环方法来使这些事情工作。这意味着在有人解释之前，我们不知道它们的存在。这些是非常难以理解的话题。通过编写真正的异步代码，它将变得更加清晰。
- en: Now that we got a little bit of an idea about how our code executes behind the
    scenes, we'll move on with the rest of the chapter and start creating a weather
    app that interacts with third-party APIs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对代码在幕后执行的一些想法，我们将继续本章的其余部分，并开始创建一个与第三方API交互的天气应用程序。
- en: Callback functions and APIs
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数和API
- en: In this section, we'll take an in-depth look at callback functions, and use
    them to fetch some data from a Google Geolocation API. That's going to be the
    API that takes an address and returns the latitude and longitude coordinates,
    and this is going to be great for the weather app. This is because the weather
    API we use requires those coordinates and it returns the real-time weather data,
    such as the temperature, five-day forecast, wind speed, humidity, and other pieces
    of weather information.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究回调函数，并使用它们从Google地理位置API中获取一些数据。这将是一个接受地址并返回纬度和经度坐标的API，这对于天气应用来说非常重要。这是因为我们使用的天气API需要这些坐标，并返回实时天气数据，如温度、五天预报、风速、湿度和其他天气信息。
- en: The callback function
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数
- en: 'Before we get started making the HTTPS request, let''s talk about callback
    functions, and we have already used them. Refer to the following code (we used
    it in the previous section):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行HTTPS请求之前，让我们谈谈回调函数，我们已经使用过它们。参考以下代码（我们在上一节中使用过）：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `setTimeout` function we used a `callback` function. In general,
    a `callback` function is defined as a function that gets passed as an argument
    to another function and is executed after some event happens. Now this is a general
    definition, there is no strict definition in JavaScript, but it does satisfy the
    function in this case:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setTimeout`函数内部，我们使用了一个`callback`函数。一般来说，`callback`函数被定义为作为参数传递给另一个函数并在某些事件发生后执行的函数。现在这是一个一般性的定义，在JavaScript中没有严格的定义，但在这种情况下它确实满足函数的要求：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we have a function and we pass it as an argument to another function, `setTimeout`,
    and it does get executed after some event—two-second pass. Now the event could
    be other things, it could be a database query finishes, it could be an HTTP request
    comes back. In those cases, you will want a callback function, like the one in
    our case, to do something with that data. In the case of `setTimeout`, we don't
    get any data back because we're not requesting any; we're just creating an arbitrary
    delay.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个函数，并将其作为参数传递给另一个函数，`setTimeout`，并在某个事件——两秒后执行。现在事件可能是其他事情，它可能是数据库查询完成，它可能是HTTP请求返回。在这些情况下，你将需要一个回调函数，就像我们的情况一样，对数据进行一些操作。在`setTimeout`的情况下，我们不会得到任何数据，因为我们没有请求任何数据；我们只是创建了一个任意的延迟。
- en: Creating the callback function
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建回调函数
- en: 'Now before we actually make an HTTP request to Google, let''s create a callback
    function example inside our `playground` folder. Let''s make a new file called
    `callbacks.js`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们实际向Google发出HTTP请求之前，让我们在`playground`文件夹中创建一个回调函数示例。让我们创建一个名为`callbacks.js`的新文件：
- en: '![](img/13d07457-a4b6-4ac5-a217-c8f4465160f4.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13d07457-a4b6-4ac5-a217-c8f4465160f4.png)'
- en: Inside the file, we'll create a contrived example of what a callback function
    would look like behind the scenes. We'll be making real examples throughout the
    book and use many functions that require callbacks. But for this chapter, we'll
    start with a simple example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件内，我们将创建一个虚构的示例，展示回调函数在幕后的样子。我们将在整本书中创建真实的示例，并使用许多需要回调的函数。但在本章中，我们将从一个简单的示例开始。
- en: 'To get started, let''s make a variable called `getUser`. This will be the function
    we''ll define that will show us exactly what happens behind the scenes when we
    pass a callback to another function. The `getUser` callback will be something
    that simulates what it would look like to fetch a user from a database or some
    sort of web API. It will be a function, so we''ll set it as such using arrow function
    (`=>`):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，让我们创建一个名为`getUser`的变量。这将是我们定义的函数，当我们将回调传递给另一个函数时，它将向我们展示幕后发生的事情。`getUser`回调将是一些模拟从数据库或某种Web
    API中获取用户的样子。它将是一个函数，所以我们将使用箭头函数（`=>`）来设置它：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The arrow function (`=>`) is going to take some arguments. The first argument
    it will take is the `id`, which will be some sort of a unique number that represents
    each user. I might have an `id` of `54`, you might have an `id` of `2000`; either
    way we''re going to need the `id` to find a user. Next up we''ll get a callback
    function, which is what we will call later with the data, with that user object:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数（`=>`）将接受一些参数。它将接受的第一个参数是`id`，它将是一个代表每个用户的唯一数字。我可能有一个`id`是`54`，你可能有一个`id`是`2000`；无论如何，我们都需要`id`来找到一个用户。接下来我们将得到一个回调函数，这是我们稍后将用数据调用的函数，用那个用户对象：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is exactly what happens when you pass a function to `setTimeout`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是当你将一个函数传递给`setTimeout`时发生的情况。
- en: 'The `setTimeout` function definition looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout`函数的定义如下：'
- en: '`var getUser = (callback, delay) => {`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`var getUser = (callback, delay) => {`'
- en: '`};`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`};`'
- en: It has a callback and a delay. You take the callback, and after a certain amount
    of time passes, you call it. In our case, though, we'll switch the order with
    an `id` first and the callback second.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个回调和一个延迟。你拿到回调，然后在一定的时间后调用它。在我们的情况下，我们将交换顺序，先是`id`，然后是回调。
- en: 'Now we can call this function before actually filling it out. We''ll call `getUser`,
    just like we did with `setTimeout` in the previous code example. I''ll call `getUser`,
    passing in those two arguments. The first one will be some `id`; since we''re
    faking it for now it doesn''t really matter, and I''ll go with `31`. The second
    argument will be the function that we want to run when the user data comes back,
    and this is really important. As shown, we''ll define that function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在实际填写之前调用这个函数。我们将调用`getUser`，就像我们在上一个代码示例中使用`setTimeout`一样。我将调用`getUser`，传入这两个参数。第一个将是一些`id`；因为我们现在是假的，所以并不重要，我会选择`31`。第二个参数将是当用户数据返回时我们想要运行的函数，这一点非常重要。如下所示，我们将定义该函数：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now the callback alone isn''t really useful; being able to run this function
    after the user data comes back only works if we actually get the user data, and
    that''s what we''ll expect here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在单独的回调并不是真正有用的；只有在我们实际获取用户数据后才能运行这个函数，这就是我们在这里期望的：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll expect that the `user` objects, things like `id`, `name`, `email`, `password`,
    or whatever, comes back as an argument to the callback function. Then inside the
    arrow function (`=>`), we can actually do something with that data, for example,
    we could show it on a web app, respond to an API request, or in our case we can
    simply print it to the console, `console.log(user)`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望`user`对象，诸如`id`、`name`、`email`、`password`等，作为回调函数的参数返回。然后在箭头函数(`=>`)中，我们实际上可以对这些数据做一些操作，例如，在Web应用程序中显示它，响应API请求，或者在我们的情况下，我们可以简单地将其打印到控制台上，`console.log(user)`：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have the call in place, let's fill out the `getUser` function to
    work like we have it defined.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调用了，让我们填写`getUser`函数，使其像我们定义的那样工作。
- en: 'The first thing I''ll do is create a dummy object that''s going to be the `user`
    object. In the future, this is going to come from database queries, but for now
    we''ll just create a variable `user` setting it equal to some object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我要做的第一件事是创建一个虚拟对象，它将成为`user`对象。将来，这将来自数据库查询，但现在我们将创建一个名为`user`的变量，并将其设置为某个对象：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s set an `id` property equal to whatever `id` the user passes in, and
    we''ll set a `name` property equal to some name. I''ll use `Vikram`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`id`属性设置为用户传入的`id`，并将`name`属性设置为某个名称。我会使用`Vikram`：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have our `user` object, what we want to do is call the callback,
    passing it as an argument. We''ll then be able to actually run, `getUser(31, (user)`
    function, printing the `user` to the screen. In order to do this, we would call
    the callback function like any other function, simply referencing it by name and
    adding our parentheses like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`user`对象，我们想要做的是调用回调，将其作为参数传递。然后我们将能够实际运行`getUser(31, (user)`函数，将`user`打印到屏幕上。为了做到这一点，我们将像调用任何其他函数一样调用回调函数，只需通过名称引用它并添加括号，就像这样：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now if we call the function like this, we''re not passing any data from `getUser`
    back to the callback. In this case, we''re expecting a `user` to get passed back,
    which is why we are going to specify `user` as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们这样调用函数，我们不会从`getUser`传递任何数据回到回调函数。在这种情况下，我们期望传回一个`user`，这就是为什么我们要像这样指定`user`：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now the naming isn''t important, I happen to call it `user`, but I could easily
    call this `userObject` and `userObject` as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在命名并不重要，我碰巧称之为`user`，但我可以很容易地称之为`userObject`和`userObject`如下所示：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All that matters is the arguments, position. In this case, we call the first
    argument `userObject` and the first argument pass back is indeed that `userObject`.
    With this in place we can now run our example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是参数的位置。在这种情况下，我们将第一个参数称为`userObject`，并且第一个参数传回的确实是`userObject`。有了这个，我们现在可以运行我们的例子。
- en: Running the callback function
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行回调函数
- en: 'In the Terminal, we''ll run the callback function using `node`, which is in
    the `playground` folder, and we call the file `callbacks.js`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们将使用`node`运行回调函数，它在`playground`文件夹中，我们调用文件`callbacks.js`：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we run the file, right away our data prints to the screen:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行文件时，我们的数据立即打印到屏幕上：
- en: '![](img/376f22d6-d06e-41ce-9522-2f56296d9fb6.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/376f22d6-d06e-41ce-9522-2f56296d9fb6.png)'
- en: We've created a callback function using synchronous programming. Now as I mentioned,
    this is still a contrived example because there is no need for a callback in this
    case. We could simply return the user object, but in that case, we wouldn't be
    using a callback, and the whole point here is to explore what happens behind the
    scenes and how we actually call the function that gets passed in as an argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用同步编程创建了一个回调函数。现在正如我提到的，这仍然是一个人为的例子，因为在这种情况下不需要回调。我们可以简单地返回用户对象，但在这种情况下，我们不会使用回调，这里的重点是探索幕后发生的事情以及我们如何实际调用作为参数传入的函数。
- en: Simulating delay using setTimeout
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`setTimeout`模拟延迟
- en: 'Now, we can also simulate a delay using `setTimeout`, so let''s do that. In
    our code, just before the `callback (user)` statement, we''ll use `setTimeout`
    just like we did before in the previous section. We''ll pass an arrow function
    (`=>`) in as the first argument, and set a delay of 3 seconds using `3000` milliseconds:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还可以使用`setTimeout`来模拟延迟，所以让我们这样做。在我们的代码中，在`callback (user)`语句之前，我们将像在上一节中一样使用`setTimeout`。我们将传入一个箭头函数(`=>`)作为第一个参数，并使用`3000`毫秒设置3秒的延迟：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now I can take my callback call, delete it from line 10, and add it inside
    of the callback function, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以取出我的回调调用，从第10行删除它，并将其添加到回调函数中，如下所示：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we'll not be responding to the `getUser` request until three seconds have
    passed. Now this will be more or less similar to what happens when we create real-world
    examples of callbacks, we pass in a callback, some sort of delay happens whether
    we're requesting from a database or from an HTTP endpoint, and then the callback
    gets fired.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在三秒钟后，我们将不会响应`getUser`请求。现在这将更多或多少类似于我们创建回调的真实例子时发生的情况，我们传入一个回调，无论是从数据库请求还是从HTTP端点请求，都会发生某种延迟，然后回调被触发。
- en: 'If I save `callbacks.js` and rerun the code from the Terminal, you''ll see
    we wait those three seconds, which is the simulated delay, and then the `user`
    object prints to the screen:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我保存`callbacks.js`并从终端重新运行代码，你会看到我们等待了三秒钟，这是模拟的延迟，然后`user`对象打印到屏幕上：
- en: '![](img/a1425890-0edd-436d-9b0a-725045975d3c.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1425890-0edd-436d-9b0a-725045975d3c.png)'
- en: This is exactly the principle that we need to understand in order to start working
    with callbacks, and that is exactly what we'll start doing in this section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要理解的原则，以便开始使用回调，并且这正是我们将在本节中开始做的事情。
- en: Making request to Geolocation API
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向地理位置API发出请求
- en: The requests that we'll be making to that Geolocation API can actually be simulated
    over in the browser before we ever make the request in Node, and that's exactly
    what we want to do to get started. So follow along for the URL, [https://maps.googleapis.com/maps/api/geocode/json](https://maps.googleapis.com/maps/api/geocode/json).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要向Geolocation API发出的请求实际上可以在浏览器中模拟，然后再在Node中发出请求，这正是我们想要做的。所以跟着URL一起进行，[https://maps.googleapis.com/maps/api/geocode/json](https://maps.googleapis.com/maps/api/geocode/json)。
- en: 'Now this is the actual endpoint URL, but we do have to specify the address
    for which we want the geocode. We''ll do that using query strings, which will
    be provided right after the question mark. Then, we can set up a set of key value
    pairs and we can add multiples using the ampersand in the URL, for example: [https://maps.googleapis.com/maps/api/geocode/json?key=value&keytwo=valuetwo](https://maps.googleapis.com/maps/api/geocode/json?key=value&keytwo=valuetwo).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是实际的终端URL，但是我们必须指定我们想要地理编码的地址。我们将使用查询字符串来做到这一点，这将在问号后面提供。然后，我们可以设置一组键值对，并且可以使用URL中的和号添加多个，例如：[https://maps.googleapis.com/maps/api/geocode/json?key=value&keytwo=valuetwo](https://maps.googleapis.com/maps/api/geocode/json?key=value&keytwo=valuetwo)。
- en: In our case, all we need is one query string address, [https://maps.googleapis.com/maps/api/geocode/json?address](https://maps.googleapis.com/maps/api/geocode/json?address),
    and for the address query string we'll set it equal to an address. In order to
    fill out that query address, I'll start typing `1301 lombard street philadelphia`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们只需要一个查询字符串地址，[https://maps.googleapis.com/maps/api/geocode/json?address](https://maps.googleapis.com/maps/api/geocode/json?address)，对于地址查询字符串，我们将把它设置为一个地址。为了填写查询地址，我将开始输入`1301
    lombard street philadelphia`。
- en: 'Notice that we are using spaces in the URL. This is just to illustrate a point:
    we can use spaces in the browser because it''s going to automatically convert
    those spaces to something else. However, inside Node we''ll have to take care
    of that ourselves, and we''ll talk about that a little later in the section. For
    now if we leave the spaces in, hit e*nter*, and we can see they automatically
    get converted for us:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在URL中使用了空格。这只是为了说明一个观点：我们可以在浏览器中使用空格，因为它会自动将这些空格转换为其他内容。然而，在Node中，我们将不得不自己处理这个问题，我们稍后会在本节中讨论这个问题。现在，如果我们保留这些空格，按下回车键，我们可以看到它们自动为我们转换：
- en: '![](img/8c3c2305-5da7-4618-9a47-2bcaad4f493e.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c3c2305-5da7-4618-9a47-2bcaad4f493e.png)'
- en: 'Space characters get converted to `%20`, which is the encoded version of a
    space. In this page, we have all of the data that comes back:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 空格字符被转换为`%20`，这是空格的编码版本。在这个页面上，我们有所有返回的数据：
- en: '![](img/c9b78df0-de39-482f-9373-1abf4b76cb54.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9b78df0-de39-482f-9373-1abf4b76cb54.png)'
- en: Now we'll use an extension called JSONView, which is available for Chrome and
    Firefox.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用一个名为JSONView的扩展，它适用于Chrome和Firefox。
- en: I highly recommend installing JSONView, as we should see a much nicer version
    of our JSON data. It lets us minimize and expand various properties, and it makes
    it super easy to navigate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议安装JSONView，因为我们应该看到我们的JSON数据的更好版本。它让我们可以最小化和展开各种属性，并且使得导航变得非常容易。
- en: Now as shown in the preceding screenshot, the data on this page has exactly
    what we need. We have an address_components property, we don't need that. Next,
    we have a formatted address which is really nice, it includes the state, the zip
    code, and the country, which we didn't even provide in the address query.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，这个页面上的数据正是我们需要的。我们有一个address_components属性，我们不需要它。接下来，我们有一个格式化的地址，这真的很好，它包括了州、邮政编码和国家，这些我们甚至没有在地址查询中提供。
- en: 'Then, we have what we really came for: in geometry, we have location, and this
    includes the latitude and longitude data.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到了我们真正想要的东西：在几何学中，我们有位置，这包括纬度和经度数据。
- en: Using Google Maps API data in our code
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的代码中使用Google Maps API数据
- en: Now, what we got back from the Google Maps API request is nothing more than
    some JSON data, which means we can take that JSON data, convert it to a JavaScript
    object, and start accessing these properties in our code. To do this, we'll use
    a third-party module that lets us make these HTTP requests inside of our app;
    this one is called request.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从Google Maps API请求中得到的只是一些JSON数据，这意味着我们可以将这些JSON数据转换为JavaScript对象，并在我们的代码中开始访问这些属性。为了做到这一点，我们将使用一个第三方模块，让我们在我们的应用程序中进行这些HTTP请求；这个模块叫做请求。
- en: 'We can visit it by going to [https://www.npmjs.com/package/request](https://www.npmjs.com/package/request).
    When we visit this page, we''ll see all the documentation and all the different
    ways we can use the request package to make our HTTP requests. For now, though,
    we''ll stick to some basic examples. On the request documentation page, on the
    right-hand side, we can see this is a super popular package and it has seven hundred
    thousand downloads in the last day:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问[https://www.npmjs.com/package/request](https://www.npmjs.com/package/request)来访问它。当我们访问这个页面时，我们将看到所有的文档和我们可以使用请求软件包进行HTTP请求的所有不同方式。不过，现在我们将坚持一些基本的例子。在请求文档页面的右侧，我们可以看到这是一个非常受欢迎的软件包，在过去的一天里有七十万次下载：
- en: '![](img/d6b8a05a-c1ca-4ded-b928-9b9c0f4eb9cd.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6b8a05a-c1ca-4ded-b928-9b9c0f4eb9cd.png)'
- en: In order to get started we're going to install the package inside our project,
    and we'll make a request to this URL.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将在我们的项目中安装该软件包，并向该URL发出请求。
- en: Installing the request package
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装请求软件包
- en: 'To install the package, we''ll go to the Terminal and install the module using
    `npm init`, to create the `package.json` file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装该软件包，我们将转到终端并使用`npm init`来安装模块，以创建`package.json`文件：
- en: '![](img/9a57438c-a172-4d10-aa76-d8246f6307ea.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a57438c-a172-4d10-aa76-d8246f6307ea.png)'
- en: 'We''ll run this command and use e*nter* to use the defaults for every single
    option:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行这个命令，并使用回车键使用每个选项的默认值：
- en: '![](img/79dcf48c-a7f7-41e0-bc08-3de90317979c.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79dcf48c-a7f7-41e0-bc08-3de90317979c.png)'
- en: At the end, we'll type `yes` and hit e*nter* again.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将输入`yes`并再次按下回车键。
- en: 'Now that we have our `package.json` file we can use `npm install`, followed
    by the module name, request, and I will specify a version. You can always find
    the latest version of modules on the npm page. The latest version at the time
    of writing is `2.73.0`, so we''ll add that, `@2.73.0`. Then we can specify the
    save flag because we do want to save this module in our `package.json` file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`package.json`文件，我们可以使用`npm install`，然后是模块名称，request，我会指定一个版本。您可以在npm页面上找到模块的最新版本。撰写时的最新版本是`2.73.0`，所以我们将添加`@2.73.0`。然后我们可以指定保存标志，因为我们确实希望将此模块保存在我们的`package.json`文件中：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It will be critical for running the weather application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于运行天气应用程序至关重要。
- en: Using request as a function
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将请求用作函数
- en: Now that we have the request module installed, we can start using it. Inside
    Atom we'll wrap up the section by making a request to that URL, in a new file
    in the root of the project called `app.js`. This will be the starting point for
    the weather application. The weather app will be the last command-line app we
    create. In the future we'll be making the backend for web apps as well as real-time
    apps using Socket.IO. But to illustrate asynchronous programming, a command-line
    app is the nicest way to go.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了请求模块，我们可以开始使用它。在Atom中，我们将通过在项目的根目录中创建一个名为`app.js`的新文件，向该URL发出请求，来结束本节。这将是天气应用程序的起点。天气应用程序将是我们创建的最后一个命令行应用程序。将来，我们将为Web应用程序以及使用Socket.IO创建实时应用程序的后端。但是为了说明异步编程，命令行应用程序是最好的方式。
- en: 'Now, we have our app file, and we can get started by loading in `request` just
    like we did with our other npm modules. We''ll make a constant variable, call
    it `request`, and set it equal to `require(request)`, as shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了我们的应用文件，我们可以开始加载`request`，就像我们加载其他npm模块一样。我们将创建一个常量变量，称之为`request`，并将其设置为`require(request)`，如下所示：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now what we need to do is make a `request`. In order to do this, we''ll have
    to call the `request` function. Let''s call it, and this function takes two arguments:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的是发出一个`request`。为了做到这一点，我们将不得不调用`request`函数。让我们调用它，这个函数需要两个参数：
- en: The first argument will be an options object where we can configure all sorts
    of information
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数将是一个选项对象，我们可以在其中配置各种信息
- en: The second one will be a callback function, which will be called once the data
    comes back from the HTTP endpoint
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个将是一个回调函数，一旦数据从HTTP端点返回，就会被调用
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In our case, it''s going to get called once the JSON data, the data from the
    Google Maps API, comes back into the Node application. We can add the arguments
    that are going to get passed back from `request`. Now, these are arguments that
    are outlined in the `request` documentation, I''m not making up the names for
    these:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，一旦JSON数据，即来自Google Maps API的数据，返回到Node应用程序中，它就会被调用。我们可以添加从`request`返回的参数。现在，这些是在`request`文档中概述的参数，我并没有为这些参数编写名称：
- en: '![](img/10684375-fffa-435f-ba8c-94f30382a37f.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10684375-fffa-435f-ba8c-94f30382a37f.png)'
- en: In the documentation, you can see they call it **error**, **response**, and
    **body**. That's exactly what well call ours. So, inside Atom, we can add `error`,
    `response`, and `body`, just like the docs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中，您可以看到他们称之为**error**，**response**和**body**。这正是我们将要调用的。因此，在Atom中，我们可以添加`error`，`response`和`body`，就像文档中一样。
- en: 'Now we can fill out that options object, which is where we are going to specify
    the things unique to our `request`. In this case, one of the unique things is
    the URL. The URL specifies exactly what you want to request, and in our case,
    we have that in the browser. Let''s copy the URL exactly as it appears, pasting
    it inside of the string for the URL property:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以填写选项对象，这是我们将要指定的与我们的`request`相关的唯一事物。在这种情况下，其中一个唯一的事物是URL。URL准确地指定了您要请求的内容，在我们的情况下，我们在浏览器中有这个。让我们粘贴URL，就像它出现的那样，将其粘贴到URL属性的字符串中：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have the URL property in place, we can add a comma at the very
    end and hit e*nter*. Because we will specify one more property, we''ll set `json`
    equal to `true`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了URL属性，我们可以在最后加上一个逗号，然后按下回车键。因为我们将指定另一个属性，我们将把`json`设置为`true`：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This tells `request` that the data coming back is going to be JSON data, and
    it should go ahead, take that JSON string, and convert it to an object for us.
    That lets us skip a step, it's a really useful option.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`request`返回的数据将是JSON数据，它应该继续，获取JSON字符串，并将其转换为对象。这让我们跳过了一步，这是一个非常有用的选项。
- en: 'With this in place, we can now do something in the callback. In the future
    we''ll be taking this longitude and latitude and fetching weather. For now, we''ll
    simply print the `body` to the screen by using `console.log`. We''ll pass the
    body argument into `console.log`, as shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以在回调中做一些事情。将来，我们将使用这个经度和纬度来获取天气。现在，我们将简单地通过使用`console.log`将`body`打印到屏幕上。我们将把`body`参数传递给`console.log`，如下所示：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have our very first HTTP request set up, and we have a callback
    that's going to fire when the data comes back, we can run it from the Terminal.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的第一个HTTP请求，并且有一个回调函数，当数据返回时将会触发，我们可以从终端运行它。
- en: Running the request
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行请求
- en: 'To run the request, we''ll use `node` and run the `app.js` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行请求，我们将使用`node`并运行`app.js`文件：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we do this, the file will start executing and there will be a really short
    delay before the body prints to the screen:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，文件将开始执行，并且在数据打印到屏幕之前会有一个非常短的延迟：
- en: '![](img/b60c8eb8-7f66-4289-9dfa-019b6045ba86.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b60c8eb8-7f66-4289-9dfa-019b6045ba86.png)'
- en: What we get back is exactly what we saw in the browser. Some of the properties,
    such as `address_components`, show object in this case because we're printing
    it to the screen. But those properties do indeed exist; we'll talk about how to
    get them later in the chapter. For now, though, we do have our `formatted_address`
    as shown in the preceding screenshot, the `geometry` object, the `place_id`, and
    `types`. This is what we'll be using to fetch the longitude and latitude, and
    later to fetch the weather data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的正是我们在浏览器中看到的。一些属性，比如`address_components`，在这种情况下显示为对象，因为我们将其打印到屏幕上。但这些属性确实存在；我们将在本章后面讨论如何获取它们。不过，我们现在有我们的`formatted_address`，如前面的屏幕截图所示，`geometry`对象，`place_id`和`types`。这是我们将用来获取经度和纬度，并稍后获取天气数据的内容。
- en: Now that we have this in place, we are done. We have the first step of the process
    complete. We've made a request to the Google Geolocation API, and we're getting
    the data back. We'll continue creating the weather app in the next section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一步。我们已经向Google地理位置API发出了请求，并且正在收到数据。我们将在下一节继续创建天气应用程序。
- en: Pretty printing objects
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漂亮地打印对象
- en: Before we continue learning about HTTP and what exactly is inside of `error`,
    `response`, and `body`, let's take a quick moment to talk about how we can pretty
    print an object to the screen. As we saw in the last subsection, when we ran our
    app with `node app.js`, the body prints to the screen.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续学习HTTP和`error`、`response`和`body`中确切的内容之前，让我们花一点时间来谈谈如何漂亮地打印一个对象到屏幕上。正如我们在上一小节中看到的，当我们用`node
    app.js`运行我们的应用程序时，body会打印到屏幕上。
- en: 'But since there is a lot of objects nested inside of each other, JavaScript
    starts clipping them:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于有很多嵌套在一起的对象，JavaScript开始裁剪它们：
- en: '![](img/1bddd246-d407-41f7-9df9-9f03dc10223f.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bddd246-d407-41f7-9df9-9f03dc10223f.png)'
- en: As shown in the preceding screenshot, it tells us an object is in the `results`,
    but we don't get to see exactly what the properties are. This takes place for
    `address_components`, `geometry`, and `types`. Obviously this is not useful; what
    we want to do is see exactly what's in the object.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，它告诉我们一个对象在`results`中，但我们无法看到确切的属性是什么。这发生在`address_components`、`geometry`和`types`中。显然这是没有用的；我们想要做的是确切地看到对象中的内容。
- en: Using the body argument
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用body参数
- en: 'To explore all of the properties, we''re going to look at a way to pretty print
    our objects. This is going to require a really simple function call, a function
    we''ve actually already used, `JSON.stringify`. This is the function that takes
    your JavaScript objects, which `body` is, remember we used the `json: true` statement
    to tell `request` to take the JSON and convert it into an object. In the `console.log`,
    statement we''ll take that object, pass `body` in, and provide the arguments as
    shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '为了探索所有属性，我们将看一种漂亮地打印我们的对象的方法。这将需要一个非常简单的函数调用，一个我们实际上已经使用过的函数，`JSON.stringify`。这是一个将你的JavaScript对象（`body`）转换为字符串的函数，记住我们使用`json:
    true`语句告诉`request`将JSON转换为对象。在`console.log`语句中，我们将取得该对象，传入`body`，并提供如下参数：'
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, this is how we''ve usually used `JSON.stringify`, in the past we provided
    just one argument, the object we want to `stringify`, in this case we''re going
    to provide a couple of other arguments. The next argument is used to filter out
    properties. We don''t want to use that, it''s usually useless, so we''re going
    to leave it as undefined as of now:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这就是我们通常使用`JSON.stringify`的方式，在过去我们只提供了一个参数，即我们想要`stringify`的对象，在这种情况下，我们将提供另外一些参数。下一个参数用于过滤属性。我们不想使用它，通常是无用的，所以我们暂时将其留空：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The reason we need to provide it, is because the third argument is the thing
    we want. The third argument will format the JSON, and we''ll specify exactly how
    many spaces we want to use per indentation. We could go with `2` or `4` depending
    on your preference. In this case, we''ll pick `2`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供它的原因是，第三个参数是我们想要的东西。第三个参数将格式化JSON，并且我们将指定每个缩进使用多少空格。我们可以选择`2`或`4`，取决于你的偏好。在这种情况下，我们将选择`2`：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ll save the file and rerun it from the Terminal. When we `stringify` our
    JSON and print it to the screen, as we''ll see when we rerun the app, we get the
    entire object showing up. None of the properties are clipped off, we can see the
    entire address_components array, everything shows up no matter how complex it
    is:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存文件并从终端重新运行它。当我们`stringify`我们的JSON并将其打印到屏幕上时，当我们重新运行应用程序时，我们将看到整个对象显示出来。没有任何属性被裁剪，无论它有多复杂，我们都可以看到整个`address_components`数组，所有内容都显示出来：
- en: '![](img/c7d02d6e-293b-4a01-9646-7ae9ad08770a.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7d02d6e-293b-4a01-9646-7ae9ad08770a.png)'
- en: 'Next, we have our geometry object, this is where our latitude and longitude
    are stored, and you can see them as shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的几何对象，这是我们的纬度和经度存储的地方，你可以在这里看到它们的显示：
- en: '![](img/1a5555bb-a957-4db1-97ff-65a218a78d98.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a5555bb-a957-4db1-97ff-65a218a78d98.png)'
- en: 'Then below that, we have our `types`, which was cut off before, even though
    it was an array with one item, which is a string:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在下面，我们有我们的`types`，之前被截断了，尽管它是一个包含一个字符串的数组：
- en: '![](img/ea97b02b-f35f-46cd-b775-1772187d7037.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea97b02b-f35f-46cd-b775-1772187d7037.png)'
- en: Now that we know how to pretty print our objects, it will be a lot easier to
    scan data inside of the console—none of our properties will get clipped, and it's
    formatted in a way that makes the data a lot more readable. In the next section,
    we'll start diving into HTTP and all of the arguments in our callback.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何漂亮地打印我们的对象，扫描控制台内部的数据将会更容易——我们的属性不会被裁剪，它的格式使得数据更易读。在下一节中，我们将开始深入研究HTTP和回调中的所有参数。
- en: Making up of the HTTPS requests
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组成HTTPS请求
- en: 'The goal in the previous section was not to understand how HTTP works, or what
    exactly the arguments, `error`, `response`, and `body` are the goal was to come
    up with a real-world example of a callback, as opposed to the contrived examples
    that we''ve been using so far with `setTimeout`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们的目标不是理解HTTP的工作原理，或者确切的参数`error`、`response`和`body`的含义，目标是提供一个回调的真实示例，而不是我们迄今为止使用`setTimeout`的人为示例：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding case, we had a real callback that got fired once the HTTP request
    came back from the Google servers. We were able to print the `body`, and we saw
    exactly what we had in the website. In this section, we'll dive into these arguments,
    so let's kick things off by taking a look at the `body` argument. This is the
    third argument that `request` passes to the callback.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的案例中，我们有一个真正的回调，一旦HTTP请求从谷歌服务器返回，就会被触发。我们能够打印`body`，并且我们看到了网站上的确切内容。在本节中，我们将深入研究这些参数，让我们首先来看一下`body`参数。这是`request`传递给回调函数的第三个参数。
- en: Now the `body` is not something unique to the `request` module (`body` is part
    of HTTP, which stands for the **Hypertext Transfer Protocol**). When you make
    a request to a website, the data that comes back is the body of the request. We've
    actually used the body about a million times in our life. Every single time we
    request a URL in the browser, what we get rendered inside the screen is the body.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`body`不是`request`模块的独有内容（`body`是HTTP的一部分，代表**超文本传输协议**）。当您向网站发出请求时，返回的数据就是请求的`body`。我们实际上在生活中已经无数次使用了`body`。每当我们在浏览器中请求URL时，屏幕上呈现的内容就是`body`。
- en: In the case of [https://www.npmjs.com](https://www.npmjs.com), the body that
    comes back is an HTML web page that the browser knows how to render. The body
    could also be some JSON information, which is the case in our Google API request.
    Either way, the body is the core data that comes back from the server. In our
    case, the body stores all of the location information we need, and we'll be using
    that information to pull out the formatted address, the latitude, and the longitude
    in this section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://www.npmjs.com](https://www.npmjs.com)的情况下，返回的`body`是浏览器知道如何渲染的HTML网页。`body`也可以是一些JSON信息，这是我们谷歌API请求的情况。无论哪种情况，`body`都是从服务器返回的核心数据。在我们的情况下，`body`存储了我们需要的所有位置信息，我们将使用这些信息来提取本节中的格式化地址、纬度和经度。
- en: The response object
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应对象
- en: 'Before we dive into the body, let''s discuss about the `response` object. We
    can look at the `response` object by printing it to the screen. Let''s swap out
    body in the `console.log` statement for `response` in the code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论`body`之前，让我们先讨论一下`response`对象。我们可以通过将其打印到屏幕上来查看`response`对象。让我们在代码中将`console.log`语句中的`body`替换为`response`：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then save the file and rerun things inside of the Terminal by running the `node
    app.js` command. We''ll get that little delay while we wait for the request to
    come back, and then we get a really complex object:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后保存文件，并通过运行`node app.js`命令在终端内重新运行。我们将等待请求返回时出现一点延迟，然后我们会得到一个非常复杂的对象：
- en: '![](img/60be856d-a1a4-4bd8-8fd5-f3885a7dc9c4.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60be856d-a1a4-4bd8-8fd5-f3885a7dc9c4.png)'
- en: In the preceding screenshot, we can see the first thing we have in the `response`
    object is a status code. The status code is something that comes back from an
    HTTP request; it's a part of the response and tells you exactly how the request
    went.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到`response`对象中的第一件事是状态码。状态码是从HTTP请求返回的东西；它是响应的一部分，告诉您请求的情况如何。
- en: In this case, `200` means everything went great, and you're probably familiar
    with some status codes, like 404 which means the page was not found, or 500 which
    means the server crashed. There are other body codes we'll be using throughout
    the book.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`200`表示一切都很顺利，你可能熟悉一些状态码，比如404表示页面未找到，或者500表示服务器崩溃。在本书中，我们将使用其他的body代码。
- en: We'll be making our very own HTTP API, so you'll become intimately familiar
    with how to set and use status codes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的HTTP API，因此您将熟悉如何设置和使用状态码。
- en: In this section, all we care about is that the status code is `200`, which means
    things went well. Next up in the `response` object, we actually have the `body`
    repeated because it is part of the `response`. Since it's the most useful piece
    of information that comes back, the request module developers chose to make it
    the third argument, although you could access it using `response.body` as you
    can clearly see in this case. Here, we have all of the information we've already
    looked at, address components, formatted address geometry, so on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只关心状态码是`200`，这表示事情进行得很顺利。在`response`对象中，接下来我们实际上有`body`重复，因为它是`response`的一部分。由于它是从服务器返回的最有用的信息，请求模块的开发人员选择将其作为第三个参数，尽管你可以像在这种情况下清楚地看到的那样，使用`response.body`来访问它。在这里，我们已经查看了所有的信息，地址组件、格式化地址几何等等。
- en: 'Next to the body argument, we have something called `headers`, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`body`参数旁边，我们有一个叫做`headers`的东西，如下所示：
- en: '![](img/285426a4-9865-41b7-8cb4-8a61cbbf808d.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/285426a4-9865-41b7-8cb4-8a61cbbf808d.png)'
- en: Now, `headers` are part of the HTTP protocol, they are key-value pairs as you
    can see in the preceding screenshot, where the key and the value are both strings.
    They can be sent in the request, from the Node server to the Google API server,
    and in the response from the Google API server back to the Node server.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`headers`是HTTP协议的一部分，它们是键值对，就像你在前面的截图中看到的那样，键和值都是字符串。它们可以在请求中从Node服务器发送到谷歌API服务器，也可以在谷歌API服务器的响应中发送回Node服务器。
- en: Headers are great, there's a lot of built-in ones like `content-type`. The `content-type`
    is HTML for a website, and in our case, it's `application/json`. We'll talk about
    headers more in the later chapters. Most of these headers are not important to
    our application, and most we're never ever going to use. When we go on and create
    our own API later in the book, we'll be setting our own headers, so we'll be intimately
    familiar with how these headers work. For now, we can ignore them completely,
    all I want you to know is that these headers you see are set by Google, they're
    headers that come back from their servers.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 标头很棒，有很多内置的标头，比如`content-type`。`content-type`是网站的HTML，在我们的案例中是`application/json`。我们将在后面的章节中更多地讨论标头。这些标头中大多数对我们的应用程序不重要，大多数我们永远不会使用。当我们在本书后面创建自己的API时，我们将设置自己的标头，所以我们将非常熟悉这些标头的工作方式。现在，我们可以完全忽略它们，我只想让你知道的是，你看到的这些标头是由Google设置的，它们是从他们的服务器返回的标头。
- en: 'Next to the headers we have the request object, which stores some information
    about the request that was made:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在标头旁边，我们有请求对象，它存储了关于所做请求的一些信息：
- en: '![](img/8b7078fe-8c57-45f5-ba3e-5a2803c86959.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b7078fe-8c57-45f5-ba3e-5a2803c86959.png)'
- en: As shown in the preceding screenshot, you can see the protocol HTTPS, the host,
    the `maps.googleapis.com` website, and other things such as the address parameters,
    the entire URL, and everything else about the request, which is stored in this
    part.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，您可以看到协议HTTPS，主机，`maps.googleapis.com`网站，以及其他一些内容，比如地址参数，整个URL，以及存储在这部分的请求的其他内容。
- en: 'Next, we also have our own headers. These are headers that were sent from Node
    to the Google API:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还有我们自己的标头。这些是从Node发送到Google API的标头。
- en: '![](img/55dfdbb1-e595-4fde-a400-570c02a49890.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55dfdbb1-e595-4fde-a400-570c02a49890.png)'
- en: 'This header got set when we added `json: true` to options object in our code.
    We told request we want JSON back and request went on to tell Google, *Hey, we
    want to accept some JSON data back, so if you can work with that format send it
    back!* And that''s exactly what Google did.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们在代码中的选项对象中添加`json: true`时，这个标头就被设置了。我们告诉请求我们想要JSON返回，请求继续告诉Google，“嘿，我们想要接受一些JSON数据，所以如果你能用这种格式发送回来就行了！”这正是Google所做的。'
- en: This is the `response` object, which stores information about the `response`
    and about the request. While we'll not be using most of the things inside the
    `response` argument, it is important to know they exist. So if you ever need to
    access them, you know where they live. We'll use some of this information throughout
    the book, but as I mentioned earlier, most of it is not necessary.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`response`对象，它存储了关于`response`和请求的信息。虽然我们不会使用`response`参数中的大多数内容，但知道它们存在是很重要的。所以如果你需要访问它们，你知道它们在哪里。我们将在整本书中使用一些这些信息，但正如我之前提到的，大部分都是不必要的。
- en: For the most part, we're going to be accessing the body argument. One thing
    we will use is the status. In our case it was `200`. This will be important when
    we're making sure that the request was fulfilled successfully. If we can't fetch
    the location or if we get an error in the status code, we do not want to go on
    to try to fetch the weather because obviously we don't have the latitude and longitude
    information.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们将访问body参数。我们将使用的一个东西是状态。在我们的案例中是`200`。当我们确保请求成功完成时，这将是重要的。如果我们无法获取位置或者如果我们在状态码中得到错误，我们就不想继续尝试获取天气，因为显然我们没有纬度和经度信息。
- en: The error argument
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误参数
- en: For now, we can move on to the final thing which is error. As I just mentioned,
    the status code can reveal that an error occurred, but this is going to be an
    error on the Google servers. Maybe the Google servers have a syntax error and
    their program is crashing, maybe the data that you sent is invalid, for example,
    you sent an address that doesn't exist. These errors are going to become evident
    via the status code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续进行最后的错误处理。正如我刚才提到的，状态码可以显示出现了错误，但这将是在Google服务器上的错误。也许Google服务器有语法错误，他们的程序崩溃了，也许你发送的数据是无效的，例如，你发送了一个不存在的地址。这些错误将通过状态码变得明显。
- en: 'What the error argument contains is errors related to the process of making
    that HTTP request. For example, maybe the domain is wrong: if I delete `s` and
    the dot with `go` in the URL, in our code, I get a URL that most likely doesn''t
    exist:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 错误参数包含的是与进行HTTP请求的过程相关的错误。例如，也许域名是错误的：如果我在URL中删除`s`和点，用`go`替换，那么在我们的代码中，我得到的URL很可能是不存在的：
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, I'll get an error in the error object because Node cannot make
    the HTTP request, it can't even connect it to the server. I could also get an
    error if the machine I'm making the request from does not have access to the internet.
    It's going to try to reach out to the Google servers, it's going to fail, and
    we're going to get an error.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我会在错误对象中得到一个错误，因为Node无法进行HTTP请求，甚至无法将其连接到服务器。如果我发出请求的机器没有互联网访问权限，也会出现错误。它将尝试连接到Google服务器，但会失败，我们将会得到一个错误。
- en: 'Now, we can check out the error object by deleting those pieces of text from
    the URL and making a request. In this case, I''ll swap out response for `error`,
    as shown here:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过从URL中删除这些文本并发出请求来检查错误对象。在这种情况下，我将把response换成`error`，如下所示：
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, inside the Terminal, let''s rerun the application by running the `node
    app.js` command, and we can see exactly what we get back:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在终端中，让我们通过运行`node app.js`命令重新运行应用程序，我们可以看到我们得到了什么：
- en: '![](img/8d245a95-3e14-43ce-a952-406ef0d38ddc.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d245a95-3e14-43ce-a952-406ef0d38ddc.png)'
- en: When we make the bad request, we get our error object printing to the screen,
    and the thing we really care about is the error code. In this case we have the
    `ENOTFOUND` error. This means that our local machine could not connect to the
    host provided. In this case `mapogleapis.com`, it doesn't exist so we'll get an
    error right here.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发出错误请求时，我们的错误对象会打印到屏幕上，我们真正关心的是错误代码。在这种情况下，我们有`ENOTFOUND`错误。这意味着我们的本地机器无法连接到提供的主机。在这种情况下，`mapogleapis.com`不存在，所以我们会在这里得到一个错误。
- en: These are going to be the system errors, things such as your program not being
    able to connect to the internet or the domain not being found. This is also going
    to be really important when it comes to creating some error handling for our application
    there is a chance that the user's machine won't be connected to the internet.
    We're going to want to make sure to take the appropriate action and we'll do that
    depending on what is inside the error object.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将是系统错误，例如您的程序无法连接到互联网或找不到域名。当我们为应用程序创建一些错误处理时，这也将非常重要，因为有可能用户的机器无法连接到互联网。我们将要确保根据错误对象中的内容采取适当的行动。
- en: 'If we can fix the URL, setting it back to [maps.googleapis.com](https://developers.google.com/maps/),
    and make the exact same request by using the up arrow key and the *enter* key,
    the request error object it''s going to be empty, and you can see null print to
    the screen:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以修复URL，将其设置回[maps.googleapis.com](https://developers.google.com/maps/)，然后使用上箭头键和*enter*键进行完全相同的请求，请求错误对象将为空，并且您可以看到null打印到屏幕上：
- en: '![](img/2a0914db-1015-4b3c-8ca1-0469123b5f9b.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a0914db-1015-4b3c-8ca1-0469123b5f9b.png)'
- en: In this case, everything went great, there was no error, and it was able to
    successfully fetch the data, which it should be able to because we have a valid
    URL. That is a quick rundown of the body, the `response`, and the error argument.
    We will use them in more detail as we add error handling.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一切都很顺利，没有错误，并且它能够成功获取数据，这应该是可以的，因为我们有一个有效的URL。这是对body、`response`和错误参数的快速概述。随着我们添加错误处理，我们将更详细地使用它们。
- en: Printing data from the body object
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从body对象中打印数据
- en: Now, we'll print some data from the body to the screen. Let's get started by
    printing the formatted address, and then we will be responsible for printing both
    the latitude and the longitude.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从body中将一些数据打印到屏幕上。让我们从打印格式化地址开始，然后我们将负责打印纬度和经度。
- en: Printing the formatted address
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印格式化地址
- en: 'We''ll start with figure out where the formatted address is. For this, we''ll
    go to the browser and use JSONView. At the bottom of the browser page, you can
    see that little blue bar shows up when we highlight over items, and it changes
    as we switch items. For formatted address, for example, we access the `results`
    property, results is an array. In the case of most addresses, you''ll only get
    one result:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先找出格式化地址在哪里。为此，我们将转到浏览器并使用JSONView。在浏览器页面底部，当我们在项目上高亮显示时，可以看到一个小蓝条出现，并且随着我们切换项目而改变。例如，对于格式化地址，我们访问`results`属性，results是一个数组。在大多数地址的情况下，您只会得到一个结果：
- en: '![](img/b87f0474-ed72-4227-874f-d769284acb61.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b87f0474-ed72-4227-874f-d769284acb61.png)'
- en: We'll use the first result every time, so we have the index of `0`, then it's
    the `.formatted_address` property. This bottom line is exactly what we need to
    type inside of our Node code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次都会使用第一个结果，所以我们有索引`0`，然后是`.formatted_address`属性。这最后一行正是我们需要在Node代码中输入的内容。
- en: 'Inside Atom, in our code, we''ll delete the `console.log` statement, and replace
    it with a new `console.log` statement. We''ll use template strings to add some
    nice formatting to this. We''ll add `Address` with a colon and a space, then I''ll
    inject the address using the dollar sign and the curly braces. We''ll access the
    body, results, and the first item in the results array followed by formatted address,
    as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，在我们的代码中，我们将删除`console.log`语句，并将其替换为一个新的`console.log`语句。我们将使用模板字符串为此添加一些漂亮的格式。我们将添加`Address`后跟一个冒号和一个空格，然后我将使用美元符号和大括号注入地址。我们将访问body、results和results数组中的第一项，然后是formatted
    address，如下所示：
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this in place, I can now add a semicolon at the end and save the file.
    Next, we''ll rerun the application inside of the Terminal, and this time around
    we get our address printing to the screen, as shown here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我现在可以在末尾加上一个分号并保存文件。接下来，我们将在终端中重新运行应用程序，这一次我们将在屏幕上打印出我们的地址，如下所示：
- en: '![](img/88e40c01-c715-4a9d-8ce6-ea184038e29d.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88e40c01-c715-4a9d-8ce6-ea184038e29d.png)'
- en: Now that we have the address printing to the screen, what we would like to print
    both the latitude and the longitude next.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在屏幕上打印出地址，接下来我们想打印出纬度和经度。
- en: Printing latitude and longitude
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印纬度和经度
- en: In order to get started, inside Atom, we'll add another `console.log` line right
    next to the `console.log` we added for formatted address. We'll use template strings
    again to add some nice formatting. Let's print the latitude first.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，在Atom中，我们将在我们为格式化地址添加的`console.log`旁边添加另一行`console.log`。我们将再次使用模板字符串添加一些漂亮的格式。让我们首先打印纬度。
- en: 'For this, we''ll add latitude followed by a colon. Then we can inject our variable
    using the dollar sign with the curly braces. Then, the variable we want is on
    the body. Just like the formatted address, it''s also in the first results item;
    results at the index of zero. Next, we''ll be going into geometry. From geometry,
    we''ll grab the location property, the latitude, `.lat`, as shown here:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将添加纬度后跟一个冒号。然后，我们可以使用带有大括号的美元符号注入我们的变量。然后，我们想要的变量在body中。就像格式化地址一样，它也在第一个results项中；在索引为零的results中。接下来，我们将进入geometry。从geometry中，我们将获取位置属性，即纬度`.lat`，如下所示：
- en: '[PRE40]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have this in place, we''ll do the exact same thing for longitude.
    We''ll add another `console.log` statement in the next line of the code. We''ll
    use template strings once again, typing longitude first. After that, we''ll put
    a colon and then inject the value. In this case, the value is on the body; it''s
    in that same results item, the first one. We''ll go into geometry location again.
    Instead of `.lat`, we''ll access `.lng`. Then we can add a semicolon at the end
    and save the file. This will look something like the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了，我们将对经度做同样的操作。我们将在代码的下一行添加另一个`console.log`语句。我们将再次使用模板字符串，首先输入经度。之后，我们会加上一个冒号，然后注入数值。在这种情况下，数值在body中；它在相同的results项中，第一个。我们将再次进入geometry位置。我们将访问`.lng`而不是`.lat`。然后我们可以在末尾加上一个分号并保存文件。这将看起来像下面这样：
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we''ll test it from the Terminal. We''ll rerun the previous command, and
    as shown in the following screenshot, you can see we have the latitude, `39.94`,
    and the longitude, `-75.16` printing to the screen:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从终端进行测试。我们将重新运行先前的命令，并且如下截图所示，您可以看到我们的纬度为`39.94`，经度为`-75.16`打印到屏幕上：
- en: '![](img/ecf9866f-0d5c-413c-86a2-5962c33fbda4.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecf9866f-0d5c-413c-86a2-5962c33fbda4.png)'
- en: And these are the exact same values we have inside the Chrome browser, `39.94`,
    `-75.16`. With this in place, we've now successfully pulled off the data we need
    to make that request to the weather API.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 而这些值在Chrome浏览器中也是完全相同的，`39.94`，`-75.16`。有了这个，我们现在成功地获取了我们需要向天气API发出请求的数据。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have gone through a basic example of asynchronous programming.
    Next, we talked about what happens behind the scenes when you run asynchronous
    code. We got a really good idea about how your program runs and what tools and
    tricks are happening behind the scenes to make it run the way it does. We through
    a few examples that illustrate how the Call Stack, Node APIs, the Callback Queue,
    and the Event Loop work.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了异步编程的基本示例。接下来，我们讨论了在运行异步代码时发生了什么。我们对程序的运行方式以及在幕后发生的工具和技巧有了一个很好的了解。我们通过几个示例说明了调用堆栈、Node
    API、回调队列和事件循环的工作原理。
- en: Then, we learned how to use the request module to make an HTTP request for some
    information, the URL we requested was a Google Maps Geocoding URL, and we passed
    in the address we want the latitude and the longitude for. Then we used a callback
    function that got fired once that data came back.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何使用请求模块来发出HTTP请求以获取一些信息，我们请求的URL是Google Maps地理编码URL，并且我们传入了我们想要获取纬度和经度的地址。然后我们使用了一个回调函数，一旦数据返回，就会触发该函数。
- en: At the end of the section *Callback functions and APIs*, we looked into a quick
    tip on how we can format objects when we want to print them to the console. Last,
    we looked into what makes up the HTTPS request.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在*回调函数和API*部分的结尾，我们研究了一个关于如何在想要将对象打印到控制台时如何格式化对象的快速提示。最后，我们研究了HTTPS请求的组成部分。
- en: In the next chapter, we'll add some error handling to this callback because
    that's going to be really important for our HTTP requests. There's a chance that
    things will go wrong, and when they do, we'll want to handle that error by printing
    a nice error message to the screen.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为这个回调函数添加一些错误处理，因为这对于我们的HTTP请求非常重要。有可能出现问题，当出现问题时，我们希望通过将错误消息打印到屏幕上来处理该错误。
