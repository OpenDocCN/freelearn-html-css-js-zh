- en: Storing Our Data in MongoDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 MongoDB 中存储我们的数据
- en: All the applications that you use on a daily basis store their information in
    databases. Databases allow you to provide the best experience to your users. Just
    imagine how hard it might be for your users without a database. For example, imagine
    you have bought a new iPhone and need to have all your contacts from your Instagram
    account added to your new phone. If databases did not exist, you would need to
    copy all of your contact information and add it locally to your new device. This
    may sound ridiculous, but this is how a world without databases might be.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天使用的所有应用程序都将它们的信息存储在数据库中。数据库允许你为用户提供最佳体验。想象一下，如果没有数据库，你的用户可能会遇到多么困难。例如，想象你购买了一部新的
    iPhone，需要将你的 Instagram 账户中的所有联系人添加到你的新手机上。如果没有数据库，你需要复制所有联系人信息并将其本地添加到新设备上。这听起来可能很荒谬，但这就是没有数据库的世界可能的样子。
- en: It is important to learn how to create applications that are able to connect
    and store information into a database. So, now you will learn how to use MongoDB
    as your NoSQL database and how to integrate our backend with it using one of the
    most popular libraries called Mongoose.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何创建能够连接到数据库并存储信息的应用程序非常重要。因此，现在你将学习如何使用 MongoDB 作为你的 NoSQL 数据库，以及如何使用名为 Mongoose.js
    的最受欢迎的库之一将我们的后端与之集成。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: NoSQL databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL 数据库
- en: Introducing MongoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 MongoDB
- en: MongooseJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongooseJS
- en: Integrating our API with MongoDB
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的 API 与 MongoDB 集成
- en: NoSQL databases
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL 数据库
- en: 'Big companies around the globe are using NoSQL Databases to provide the velocity
    that the users expect when using their applications; companies such as Facebook,
    Amazon, and Google all use them. However, why are these databases so special?
    To answer this question, let''s see what is the difference between SQL and NoSQL
    databases:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 全球的大公司都在使用 NoSQL 数据库来提供用户在使用应用程序时期望的速度；例如，Facebook、Amazon 和 Google 都在使用它们。然而，为什么这些数据库如此特别？为了回答这个问题，让我们看看
    SQL 和 NoSQL 数据库之间的区别：
- en: '| **SQL databases** | **NoSQL databases** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **SQL 数据库** | **NoSQL 数据库** |'
- en: '| Table-based and hard structured | Not table-based |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 基于表格和硬结构化 | 不基于表格 |'
- en: '| Encourage normalization | Encourage denormalization |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 鼓励规范化 | 鼓励非规范化 |'
- en: '| Require a schema | Are schema-less |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 需要模式 | 无模式 |'
- en: '| Fast | Superfast |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 快速 | 超快速 |'
- en: '| Scalability is difficult to achieve | Scalability is extremely easy to achieve
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性难以实现 | 可扩展性极其容易实现 |'
- en: Of course, there are more differences and benefits, but talking about all the
    advantages and the science behind them is beyond the scope of this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多差异和好处，但讨论所有优点及其背后的科学超出了本书的范围。
- en: It is important to know that there are different types of NoSQL databases to
    solve different types of challenges. Let's learn about them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，有不同类型的 NoSQL 数据库来解决不同类型的挑战。让我们来了解一下它们。
- en: Document databases
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档数据库
- en: 'This is one of the most popular databases, thanks to MongoDB and CouchDB. This
    type of database stores the information in a JSON-based document. As this is a
    key-value store, you can save complex objects that contain arrays, nested documents,
    and other different data types. For example, you can save the following *person*
    in the JSON document:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最受欢迎的数据库之一，归功于 MongoDB 和 CouchDB。这种类型的数据库以 JSON 格式存储信息。由于这是一个键值存储，你可以保存包含数组、嵌套文档和其他不同数据类型的复杂对象。例如，你可以在
    JSON 文档中保存以下 *人*：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, you don't need to store the addresses in a different document
    (or a table in SQL databases); you can perfectly store them in the same document
    (or a table in SQL databases).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你不需要在不同的文档（或 SQL 数据库中的表）中存储地址；你可以在同一个文档（或 SQL 数据库中的表）中完美地存储它们。
- en: Introducing MongoDB
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MongoDB
- en: As stated on its official website, MongoDB is an open source document database
    with the scalability and flexibility that you want and the querying and indexing
    that you need.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其官方网站所述，MongoDB 是一个开源的文档数据库，它具有你想要的可扩展性和灵活性，以及你需要的查询和索引。
- en: MongoDB uses collections to persist a set of JSON documents, and the schema
    for the documents can change over time without affecting the other documents stored
    in the collection. The schema-less feature is great when you are working on applications
    that have different kind of roles and users. A user might utilize some fields,
    while other users might require some other fields but without the need to fill
    the unused fields with null values. Instead, fields that are not required are
    not persisted in the JSON document.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 使用集合来持久化一组 JSON 文档，文档的模式可能会随时间变化，而不会影响集合中存储的其他文档。当您在处理具有不同角色和用户的复杂应用程序时，无模式特性非常出色。一个用户可能会使用一些字段，而其他用户可能需要一些其他字段，但不需要用
    null 值填充未使用的字段。相反，不需要的字段不会持久化到 JSON 文档中。
- en: Installing MongoDB
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 MongoDB
- en: You can learn how to install MongoDB on its official site at [https://www.mongodb.com](https://www.mongodb.com).
    We strongly recommend you to use Docker for your development environment instead
    of installing MongoDB on your local machine. So, let's see how you can install
    MongoDB using Docker containers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其官方网站 [https://www.mongodb.com](https://www.mongodb.com) 上学习如何安装 MongoDB。我们强烈建议您在开发环境中使用
    Docker 而不是在本地机器上安装 MongoDB。那么，让我们看看如何使用 Docker 容器安装 MongoDB。
- en: 'First, you will need to download Docker from its official site, [https://www.docker.com](https://www.docker.com).
    Once the download is completed, go ahead and install it. If you are working on
    MacOS or Windows, Docker will also install another tool called **Kitematic**.
    When the installation is done, look for mongo in the Containers section. Then,
    hit CREATE. Take a look at the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要从其官方网站下载 Docker，[https://www.docker.com](https://www.docker.com)。下载完成后，继续安装。如果您在
    MacOS 或 Windows 上工作，Docker 还会安装另一个名为 **Kitematic** 的工具。安装完成后，在容器部分查找 mongo。然后，点击创建。看看下面的截图：
- en: '![](img/7c999c7a-6285-41ed-866a-d4a4a7b593cc.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c999c7a-6285-41ed-866a-d4a4a7b593cc.png)'
- en: 'The tool will download the image and once it is done, it will run the MongoDB
    container and provide us the host and port where MongoDB is running, as illustrated:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 工具将下载镜像，一旦完成，它将运行 MongoDB 容器，并为我们提供 MongoDB 运行的宿主机和端口，如图所示：
- en: '![](img/d3aa4e49-68c3-415c-bdf9-f67934799bc3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3aa4e49-68c3-415c-bdf9-f67934799bc3.png)'
- en: 'For users who are using Linux, execute the following command to create a MongoDB
    container:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 Linux 的用户，执行以下命令以创建 MongoDB 容器：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous command will start a new container and exposes its internal port
    `27017` and will share a directory called `data` from your host to the container.
    By doing this, we can persist the container information into our host file system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将启动一个新的容器，并暴露其内部端口 `27017`，并将您的宿主机的 `data` 目录共享到容器中。通过这样做，我们可以将容器信息持久化到我们的宿主机文件系统中。
- en: Once we have our MongoDB database running on top of Docker, we need to practice
    a little bit with MongoDB.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的 MongoDB 数据库在 Docker 上运行，我们需要在 MongoDB 上进行一些实践。
- en: CRUD operations
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD 操作
- en: Before we integrate our API with MongoDB, it is important to learn how to interact
    with MongoDB directly. So, let's learn how to perform the basic CRUD operations
    using the MongoDB command-line tool. To do this, we will need to access the MongoDB
    container Terminal, but it is extremely easy using Kitematic. In the container's
    toolbar, click on the exec options. This will launch a Terminal window connected
    to the MongoDB container Terminal.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 API 集成到 MongoDB 之前，了解如何直接与 MongoDB 交互非常重要。因此，让我们学习如何使用 MongoDB 命令行工具执行基本的
    CRUD 操作。为此，我们需要访问 MongoDB 容器的终端，但使用 Kitematic 非常简单。在容器的工具栏中，点击 exec 选项。这将启动一个连接到
    MongoDB 容器终端的终端窗口。
- en: 'When it is launched, type `mongo` to get into the MongoDB CLI. Take a look
    at the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当它启动时，输入 `mongo` 以进入 MongoDB CLI。看看下面的截图：
- en: '![](img/a79c1485-e01e-4ef5-a775-46e001de3ee1.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a79c1485-e01e-4ef5-a775-46e001de3ee1.png)'
- en: 'For users who are using Linux. You can get into the container by running the
    following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 Linux 的用户。您可以通过运行以下命令进入容器：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Cool! Now we are ready to play with MongoDB.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们可以开始使用 MongoDB 了。
- en: Creating a document
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文档
- en: 'To insert a document, first we specify the `collection` name and pass the JSON
    document by calling the `insert` method as the following syntax:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入文档，首先我们指定 `collection` 名称，并通过调用 `insert` 方法传递 JSON 文档，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s insert the first team to our `teams` collection:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向 `teams` 集合插入第一个团队：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The three dots at the beginning of the lines refer to new lines or the *Enter*
    key.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 行首的三个点代表新行或*Enter*键。
- en: If the insertion was executed correctly, you should receive the `writeResult`
    response that contains the number of documents inserted into its `nInserted` property.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入执行正确，你应该会收到包含其`nInserted`属性中插入的文档数量的`writeResult`响应。
- en: Retrieving documents
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索文档
- en: 'To retrieve the list of documents, we use the `find` method. For example, run
    the following query to retrieve the full list of teams:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索文档列表，我们使用`find`方法。例如，运行以下查询以检索完整的球队列表：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, a new `_id` property has been added automatically. This property
    is known as the primary key of the JSON document. This is an autogenerated value,
    so you will have a different value when you run the command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个新`_id`属性已被自动添加。这个属性被称为JSON文档的主键。这是一个自动生成的值，所以当你运行命令时，你将有一个不同的值。
- en: 'The teams'' collection over time will have more than just a single team. So,
    how could we retrieve a single team from the collection? Do you remember the `{}`
    JSON object we passed to the `find` method? This JSON object is used to query
    the collection. So, if we want to retrieve the `Peru` team, we have to execute
    the following query:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，球队的集合将不仅仅只有一个球队。那么，我们如何从集合中检索一个单独的球队呢？你还记得我们传递给`find`方法的`{}` JSON对象吗？这个JSON对象用于查询集合。所以，如果我们想检索`Peru`队，我们必须执行以下查询：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that we can pass any field used in the JSON document. For example, you
    can use `name`, `ranking`, `captain`, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以传递JSON文档中使用的任何字段。例如，你可以使用`name`、`ranking`、`captain`等等。
- en: Updating documents
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新文档
- en: 'To update a document, we use the `updateOne` or `updateMany` methods. For example,
    let''s update the `ranking` property of the `Peru` team. Execute the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新文档，我们使用`updateOne`或`updateMany`方法。例如，让我们更新`Peru`队的`排名`属性。执行以下代码：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The syntax looks a little weird, but it is not. The first question you might
    have is why do we need `$set`? We need `$set` to specify the fields that we are
    interested to update. Otherwise, you will replace the document. Consider this
    example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 语法看起来有点奇怪，但并不是。你可能的第一个问题是为什么我们需要`$set`？我们需要`$set`来指定我们想要更新的字段。否则，你会替换整个文档。考虑以下示例：
- en: 'First, let''s list our teams'' collection to see the first update reflected:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们列出我们的球队集合，以查看第一次更新的反映：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, yes, the `ranking` field has been updated to `1`. Now let''s try to update
    this document without the `$set` operator:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，是的，`排名`字段已更新为`1`。现在让我们尝试不使用`$set`运算符来更新此文档：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that an error is thrown and no changes have been made. That is helpful
    for us because we are using the `updateOne` method, but there is another method
    called `update`, which will give us headaches if we don''t use it properly. For
    example, run the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，会抛出一个错误，并且没有进行任何更改。这对我们很有帮助，因为我们正在使用`updateOne`方法，但还有一个名为`update`的方法，如果我们不正确使用它，会给我们带来麻烦。例如，运行以下代码：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this moment, when you note that you forgot the `$set` operator, you have
    lost your team''s data. Try to find the `Peru` team:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，当你意识到你忘记了`$set`运算符时，你已经失去了你队的资料。尝试找到`Peru`队：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: No results are shown. Now a tear might be rolling down your cheek. Funny, right?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 没有显示结果。现在可能有一滴眼泪从你的脸颊滑落。有趣，对吧？
- en: Be careful when you are updating or deleting documents. A production error of
    this type can cost you the post.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新或删除文档时要小心。这种类型的生产错误可能会让你失去职位。
- en: Deleting documents
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文档
- en: 'Lastly, to delete a document, we use the `deleteOne` or `deleteMany` methods.
    For example, again insert the `Peru` team and run the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要删除文档，我们使用`deleteOne`或`deleteMany`方法。例如，再次插入`Peru`队并运行以下代码：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Cool! Now we are in a good shape to learn about Mongoose and how to integrate
    our API with MongoDB. Keep reading!!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们处于良好的状态，可以学习Mongoose以及如何将我们的API与MongoDB集成。继续阅读！！
- en: We recommend that you use a GUI tool to explore your MongoDB data. We use **Robo
    3T** or Robomongo. You can download it from its official page at [https://robomongo.org](https://robomongo.org).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用GUI工具来探索您的MongoDB数据。我们使用**Robo 3T**或Robomongo。您可以从其官方网站[https://robomongo.org](https://robomongo.org)下载。
- en: MongooseJS
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongooseJS
- en: Mongoose.js is one of the most popular NPM modules to integrate a Node.js application
    with a MongoDB database. It provides an easy way to model our application data
    and comes along with different built-in features to validate, cast, and query
    our database, avoiding boilerplate code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose.js 是最受欢迎的 NPM 模块之一，用于将 Node.js 应用程序与 MongoDB 数据库集成。它提供了一种简单的方式来建模我们的应用程序数据，并附带不同的内置功能来验证、转换和查询我们的数据库，避免样板代码。
- en: 'We will use our MongoDB container that we installed in the previous section.
    The two pieces of information that we need are the host and port where MongoDB
    is running. That information is shown in the Kitematic tool in the `Home/IP &
    Ports/Access URL` section. For example, in my case, these are `localhost` and
    `32768`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在上一节中安装的 MongoDB 容器。我们需要的信息是 MongoDB 运行的主机和端口。这些信息在 Kitematic 工具的 `Home/IP
    & Ports/Access URL` 部分显示。例如，在我的情况下，这些是 `localhost` 和 `32768`：
- en: '![](img/edf8840c-9f0a-4ac1-974c-77ed971705ee.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/edf8840c-9f0a-4ac1-974c-77ed971705ee.png)'
- en: Installing Mongoose
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Mongoose
- en: 'To install Mongoose, we will use NPM. So, in your Terminal, navigate to the
    `wc-backend` project and run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Mongoose，我们将使用 NPM。因此，在你的终端中，导航到 `wc-backend` 项目并运行以下命令：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the installation is done, we need to get into the `src` folder and create
    a new folder called `config`*.* In the `config` folder, now create a new file
    called `mongoose-connection.js`*:*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要进入 `src` 文件夹并创建一个名为 `config` 的新文件夹。在 `config` 文件夹中，现在创建一个名为 `mongoose-connection.js`
    的新文件：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have Mongoose installed and we have created our configuration file,
    it is time to write some code to establish the connection to MongoDB.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Mongoose 并创建了配置文件，是时候编写一些代码来建立与 MongoDB 的连接了。
- en: Configuring Mongoose
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Mongoose
- en: 'This is where the best part starts. So, we will need to create a connection
    to the *database*; to do this, open the `mongoose-connection.js` file and apply
    the following changes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最精彩的部分开始的地方。因此，我们需要创建一个到 *数据库* 的连接；为此，打开 `mongoose-connection.js` 文件并应用以下更改：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, we import the Mongoose module and host it into the `mongoose` constant.
    Then, we call the `connect` function and pass the connection URL using the *host*
    and *port* that points to our MongoDB docker container. Lastly, we tell mongoose
    that our database name will be `wcDb`. If the connection was successful, the `connected`
    event will be called and the `connection is ready` message should be printed.
    Let''s test things out; execute the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 Mongoose 模块并将其托管到 `mongoose` 常量中。然后，我们调用 `connect` 函数并传递连接 URL，使用 *主机*
    和 *端口* 指向我们的 MongoDB docker 容器。最后，我们告诉 mongoose 我们的数据库名称将是 `wcDb`。如果连接成功，将调用 `connected`
    事件，并打印出 `connection is ready` 消息。让我们来测试一下；执行以下命令：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Cool! Our Node.js module is able to establish a successful connection with MongoDB
    using Mongoose. Now we will need to define schemas, models, and collections. Keep
    reading!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的 Node.js 模块能够使用 Mongoose 成功地与 MongoDB 建立连接。现在我们需要定义模式、模型和集合。继续阅读！
- en: Defining schemas
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模式
- en: 'To store information in our database we need to create a model, this model
    is created based on a initial schema definition. This schema definition contains
    the attributes and datatypes of the information we want to store. Let''s define
    the schema for our collections of teams. In the same `mongoose-connection.js`
    file, add the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的数据库中存储信息，我们需要创建一个模型，这个模型是基于初始模式定义创建的。这个模式定义包含了我们想要存储的信息的属性和数据类型。让我们为我们的团队集合定义模式。在同一个
    `mongoose-connection.js` 文件中，添加以下代码：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, defining schemas is straightforward. We use the `mongoose.Schema`
    object and define the fields we want for our schema as a JSON object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，定义模式很简单。我们使用 `mongoose.Schema` 对象，并将我们想要为模式定义的字段作为 JSON 对象定义。
- en: Data types
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'As in other database engines, the fields should be defined with a data type.
    The following are all valid types:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其他数据库引擎，字段应该使用数据类型定义。以下都是有效的类型：
- en: '`String`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字符串`'
- en: '`Date`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`日期`'
- en: '`Number`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数字`'
- en: '`Boolean`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`布尔值`'
- en: '`Array`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数组`'
- en: '`ObjectId`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectId`'
- en: '`Buffer`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`缓冲区`'
- en: '`Mixed`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`混合`'
- en: Perhaps, you are familiar will almost all the data types listed. The `Mixed`
    data type basically allows you to define a field whose value can be of any data
    type. Personally, we don't recommend the use of this data type because maintaining
    a `Mixed` field can become hard, and you may want to write boilerplate code to
    use it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你对列出的几乎所有数据类型都很熟悉。`Mixed`数据类型基本上允许你定义一个字段，其值可以是任何数据类型。个人来说，我们不推荐使用这种数据类型，因为维护一个`Mixed`字段可能会变得困难，你可能需要编写样板代码来使用它。
- en: Validation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: Mongoose comes with several built-in validators. Some validators are present
    in all data types and some are exclusive for a data type. For example, a `String`
    field will have the `min` and `max` validators but a `Boolean` type will not.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose自带几个内置验证器。一些验证器存在于所有数据类型中，而一些则仅针对特定数据类型。例如，`String`字段将具有`min`和`max`验证器，但`Boolean`类型则没有。
- en: 'Let''s add some validations to our `Team` schema. Open the `mongoose-connection.js`
    file and apply the following changes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Team`模式中添加一些验证。打开`mongoose-connection.js`文件并应用以下更改：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, our schema looks more professional and will help us validate the data before
    it is persisted in MongoDB. Most of the validators are self-explanatory. As you
    might have noticed, when you want to apply validators, the syntax to declare a
    field changes a little bit; in this case, a JavaScript object should be passed
    to define the data type and validators. To find more information about validators,
    visit [http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的模式看起来更专业，这将帮助我们验证在MongoDB中持久化之前的数据。大多数验证器都是自解释的。正如你可能已经注意到的，当你想要应用验证器时，声明字段的语法会略有变化；在这种情况下，应该传递一个JavaScript对象来定义数据类型和验证器。要了解更多关于验证器的信息，请访问[http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html)。
- en: Creating models
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Now that we have our schema, it is time to tell Mongoose that we want to use
    that Schema to create new objects in order to send them to MongoDB. To do this,
    we need to create a model by passing the schema already defined. Open the `mongoose-connection.js`
    file and add the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的模式，是时候告诉Mongoose我们想要使用该模式来创建新对象，以便将它们发送到MongoDB。为此，我们需要通过传递已定义的模式来创建一个模型。打开`mongoose-connection.js`文件并添加以下代码：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Believe it or not, we just need this line to interface our schema to MongoDB.
    In this line, we tell Mongoose that we want to call our collection as `team`.
    The result of calling `mongoose.model` will be an object that is the model; we
    will use this object to create new instances. The `Team` object also contains
    built-in CRUD methods, so we will use them to create CRUD operations to the database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们只需要这一行代码就能将我们的模式与MongoDB接口。在这一行中，我们告诉Mongoose我们想要将我们的集合称为`team`。调用`mongoose.model`的结果将是一个对象，它是模型；我们将使用这个对象来创建新的实例。`Team`对象还包含内置的CRUD方法，因此我们将使用它们来创建对数据库的CRUD操作。
- en: 'To test things out, let''s create the `Peru` team and save it in our database.
    In the same file, add the following changes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一下，让我们创建`Peru`团队并将其保存在我们的数据库中。在同一文件中，添加以下更改：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First, we create the `peruTeam` object using the `Team` model instance we created
    earlier. Each new instance contains built-in functions. The `save` built-in function
    is called to save the `peruTeam` in the database. A callback is defined to process
    the result of the operation. If everything goes right, a message showing the new
    generated ID will be shown. So, execute the following command to test things out:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用之前创建的`Team`模型实例创建`peruTeam`对象。每个新实例都包含内置函数。调用内置的`save`函数将`peruTeam`保存在数据库中。定义了一个回调来处理操作的结果。如果一切顺利，将显示一个显示新生成ID的消息。因此，执行以下命令来测试一下：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Cool! Now we are ready to start the integration between our database module
    and our RESTful API. Keep reading!!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们准备好开始将我们的数据库模块和RESTful API进行集成。继续阅读吧！！
- en: Integrating our API with MongoDB
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的API与MongoDB集成
- en: 'Here we are! It''s time to implement our Teams Rest controller. To do this,
    we will start decoupling the Team model that has all the logic to communicate
    with the MongoDB database. Once the Team model is refactored, we will start implementing
    the code in the Team Rest Controller to implement the CRUD operations to do the
    following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里就完成了！现在是时候实现我们的Teams Rest控制器了。为此，我们将开始解耦具有与MongoDB数据库通信逻辑的所有逻辑的Team模型。一旦Team模型重构完成，我们将在Team
    Rest控制器中开始实现代码以实现以下CRUD操作：
- en: List all the teams
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有团队
- en: Create new teams
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的团队
- en: Update the existing teams
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有团队
- en: Delete teams
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除团队
- en: Let's get our hands dirty!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手解决吧！
- en: Decoupling the Team Model
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦团队模型
- en: 'We have created a `models` folder in the root project directory. In this folder,
    we will create all the models for our application. Start creating the `team.js`
    file in the `src`/`models` folders:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在根项目目录中创建了一个 `models` 文件夹。在这个文件夹中，我们将创建我们应用程序的所有模型。开始在 `src`/`models` 文件夹中创建
    `team.js` 文件：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remember that we use the `touch` command to create a new file. Then, open this
    file, and from the `src/config/mongoose-connection.js` file, cut the following
    lines and copy them into the `src/models/team.js` file, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们使用 `touch` 命令创建一个新文件。然后，打开这个文件，并从 `src/config/mongoose-connection.js` 文件中剪切以下行并将它们复制到
    `src/models/team.js` 文件中，如下所示：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We just need to isolate the `TeamSchema` definition, and we are exporting the
    model created by mongoose to be accessed later by the Rest Controller. Be sure
    that your `src/config/mongoose-connection` file looks like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要隔离 `TeamSchema` 定义，然后我们将导出 mongoose 创建的模型，以便稍后由 Rest 控制器访问。确保你的 `src/config/mongoose-connection`
    文件看起来如下：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Cool! So far, so good. Now it is time to implement our Rest Controller.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！到目前为止，一切顺利。现在是时候实现我们的 Rest 控制器了。
- en: Implementing the Rest Controller
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Rest 控制器
- en: Isolating the business logic is always a good practice; for that reason, we
    won't be calling the model directly from the Rest Controller.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离业务逻辑始终是一个好的实践；因此，我们不会直接从 Rest 控制器调用模型。
- en: Connecting the app
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接应用
- en: 'Let''s start by calling the `mongoose-connection` module to open a connection
    to MongoDB. Open the `server.js` file and apply the following changes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先调用 `mongoose-connection` 模块来打开与 MongoDB 的连接。打开 `server.js` 文件并应用以下更改：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That's all we need to establish a new connection. The `mongoose-connection`
    file contains the logic to open a connection to MongoDB, so we don't need to type
    more code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们建立新连接所需的所有内容。`mongoose-connection` 文件包含打开 MongoDB 连接的逻辑，所以我们不需要编写更多代码。
- en: Creating a new team
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的团队
- en: 'To create a new team, we need to call the model''s built-in methods provided
    by Mongoose. The `save` function is used to create and update the fields for any
    model. So, first we will start importing the `Team` model into the `src/routes/teams-api.js`
    file, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的团队，我们需要调用由 Mongoose 提供的模型内置方法。`save` 函数用于创建和更新任何模型的字段。因此，我们首先将开始将 `Team`
    模型导入到 `src/routes/teams-api.js` 文件中，如下所示：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have imported the module with the `require` function and stored
    it into the `Team` constant, we can use it to create a new team. Let''s modify
    the `POST HTTP` method of the Rest Controller:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用 `require` 函数导入了模块并将其存储在 `Team` 常量中，我们可以用它来创建一个新的团队。让我们修改 Rest 控制器的
    `POST HTTP` 方法：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first change to note is the `next` param into the function. This param is
    used to throw an error to express in case Mongoose is not able to create a new
    team. Then, we create a new team, passing the `body` param from the `req` object
    and calling the `save` function. The `save` function returns a `Promise` that
    is just an asynchronous call, which, when finished successfully, will return the
    information of the new team saved into the `then` method. Once we have the data,
    we send the information as a `JSON` type to the client.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的第一个更改是函数中的 `next` 参数。此参数用于在 Mongoose 无法创建新团队时向 express 抛出错误。然后，我们创建一个新的团队，通过
    `req` 对象的 `body` 参数调用 `save` 函数。`save` 函数返回一个 `Promise`，它只是一个异步调用，当成功完成时，将在 `then`
    方法中返回新保存到 `Team` 的信息。一旦我们有了数据，我们就以 `JSON` 类型将信息发送给客户端。
- en: 'Let''s test things out. First, we need to get the server up by executing `node
    server.js` and then we will use cURL to test this endpoint. Open your Terminal
    and run the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下。首先，我们需要通过执行 `node server.js` 来启动服务器，然后我们将使用 cURL 来测试这个端点。打开你的终端并运行以下命令：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If everything went right, you should see the JSON object responding with the
    autogenerated `_id` attribute. Let''s see what happens if we run it again:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到响应包含自动生成的 `_id` 属性的 JSON 对象。让我们看看再次运行它会发生什么：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we receive an ugly error that says we are falling in a duplication key
    error. Why is this happening? Let''s get answers from the model schema that we
    defined earlier. Open the `src/models/team.js` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们收到一个丑陋的错误，说我们遇到了重复键错误。为什么会这样？让我们从我们之前定义的模型模式中找到答案。打开 `src/models/team.js`
    文件：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Hot dog! You have the answer. The error we are facing, is because we defined
    the `name` property as `unique:true`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 热狗！你找到了答案。我们遇到的问题是因为我们定义了 `name` 属性为 `unique:true`。
- en: 'We will need to fix something in the message. We expect a JSON response from
    the REST API, so let''s configure a global exception handler in our backend to
    send the error as a JSON object instead of an ugly and incomprehensible HTML page.
    Open the `server.js` file and apply the following change:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在消息中修复一些内容。我们期望从REST API接收JSON响应，所以让我们在我们的后端配置一个全局异常处理器，将错误作为JSON对象发送，而不是一个丑陋且难以理解的HTML页面。打开`server.js`文件并应用以下更改：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We defined a global middleware, which is a function that expects four params:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个全局中间件，它是一个期望四个参数的函数：
- en: '`err`: Contains null if no error is thrown; otherwise, it''s an instance of
    error or another value'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err`: 如果没有抛出错误，则包含`null`；否则，它是一个错误实例或另一个值'
- en: '`req`: The source request sent by the client'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req`: 客户端发送的源请求'
- en: '`res`: The response property'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res`: 响应属性'
- en: '`next`: The reference to the next action that Express.js will call'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`: Express.js将调用的下一个操作的引用'
- en: 'As is expected, all the errors return an HTTP status different than `200`.
    Until we define the correct status of the other CRUD operations, let''s leave
    it with `status(500)` by default. Now, let''s run it again and see what happens:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，所有错误都会返回一个不同于`200`的HTTP状态。在我们定义其他CRUD操作的正确状态之前，让我们默认使用`status(500)`。现在，让我们再次运行它并看看会发生什么：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we receive a JSON object with a single `error` attribute. Cool!
    Let's continue and learn how to retrieve the full list of teams.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们接收了一个包含单个`error`属性的JSON对象。太棒了！让我们继续学习如何检索完整的团队列表。
- en: Listing the teams
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出团队
- en: 'To retrieve the full list of teams, we will make use of the GET HTTP method.
    Let''s start by cleaning up our code a little bit. Until now, we have been using
    an array of teams; we won''t need it anymore, so let''s remove it. In `src/routes/teams-api.js`,
    apply the following changes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索完整的团队列表，我们将使用GET HTTP方法。让我们先稍微清理一下我们的代码。到目前为止，我们一直在使用一个团队数组；我们不再需要它了，所以让我们将其删除。在`src/routes/teams-api.js`中，应用以下更改：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we have our code cleaned, add the following change to implement the
    logic to retrieve the full list of teams:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清理了代码，添加以下更改以实现检索完整团队列表的逻辑：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First, we call the `find` method to return a `Promise` as the `save` function
    used to create new teams. As it is a `Promise`, we will receive the data returned
    from the database into the **`then`** function and if something goes wrong, it
    will return an error in the `catch` function. Let''s test it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`find`方法以返回一个`Promise`，作为创建新团队时使用的`save`函数。由于它是一个`Promise`，我们将从数据库返回的数据接收进**`then`**函数，如果出现问题，它将在`catch`函数中返回一个错误。让我们测试它：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Awesome! Now we are able to retrieve the list of teams using the `api` we just
    implemented. Let's continue!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们能够使用我们刚刚实现的`api`检索团队列表。让我们继续！
- en: Finding a single team
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找一个单个团队
- en: 'To find a single team, we will make use of the `findById` built-in method,
    and we will pass a valid ID to it. So, apply the following changes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找单个团队，我们将使用`findById`内置方法，并将一个有效的ID传递给它。因此，应用以下更改：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, we extract the ID from the `req.params` object. Note that we are not
    using the `/teams` route. Instead, we are using the `/teams/:id` route. It means
    that Express.js will inject the `id` attribute as an element of the `params` object.
    Then, we call the `findById` method and send the response to the client. Let''s
    test it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`req.params`对象中提取ID。请注意，我们不是使用`/teams`路由。相反，我们使用的是`/teams/:id`路由。这意味着Express.js将把`id`属性作为`params`对象中的一个元素注入。然后，我们调用`findById`方法并将响应发送给客户端。让我们测试它：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Cool! It is working. Note that we are using an existing ID—`5a662fbf728726072c6298fc`.
    This value will be different for you. To get a valid value, just call the `/teams`
    endpoint to list all your teams, and copy and replace it with the value in the
    `_id` attribute.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！它正在工作。请注意，我们正在使用一个现有的ID——`5a662fbf728726072c6298fc`。这个值对您来说将是不同的。要获取一个有效的值，只需调用`/teams`端点以列出所有您的团队，然后复制并替换`_id`属性中的值。
- en: 'Now, what would happen if we pass an invalid ID? Let''s test it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们传递一个无效的ID会发生什么？让我们测试它：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A `null` value is retrieved now. According to our API Documentation, we have
    to return the `HTTP 404` status to represent a Not found response. So, to do this,
    we need to validate the result from the `findById` method and raise an error if
    we receive a null as a response. Go ahead and apply the following changes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检索到一个`null`值。根据我们的API文档，我们必须返回`HTTP 404`状态来表示未找到响应。因此，为了做到这一点，我们需要验证`findById`方法的结果，并在收到null响应时引发错误。请继续并应用以下更改：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now with this implementation, if we receive a `null`, we will raise an error
    that will be handled by our global error handler, which will send a JSON object
    with the error message. Let''s test it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个实现中，如果我们收到一个`null`，我们将引发一个错误，这个错误将由我们的全局错误处理器处理，它会发送一个包含错误信息的JSON对象。让我们测试一下：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Lastly, we need to modify our error handler to change the HTTP status code
    to `404`. In the `server.js` file, apply the following change:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改我们的错误处理器，将HTTP状态码更改为`404`。在`server.js`文件中，应用以下更改：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'First, we declare the `STATUS` variable and assign `500` as its default value.
    Then, we apply a regular expression validation to check whether the message contains
    the `not found` string. If so, `STATUS` is changed to `404`. So, let''s test it
    again, adding the `-v` flag in the `curl` command to see the HTTP status:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个`STATUS`变量并将其默认值设置为`500`。然后，我们应用正则表达式验证来检查消息是否包含`not found`字符串。如果是这样，`STATUS`将更改为`404`。所以，让我们再次测试它，在`curl`命令中添加`-v`标志来查看HTTP状态：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That's it! Now with this, we are ready to learn how to update a `team`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，我们准备好学习如何更新一个`team`了。
- en: Updating teams
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新团队
- en: 'To update our `teams`, first we will need to look for an existing team in our
    database using the `ID` provided in the path. If a team is found, we apply the
    changes to the `team` object. So, let''s start adding the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新我们的`teams`，首先我们需要使用路径中提供的`ID`在我们的数据库中查找现有的团队。如果找到一个团队，我们将对`team`对象应用更改。所以，让我们开始添加以下代码：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, we extract the `id` passed in the endpoint. Then, we call the `findById`
    method to look for an existing team. If a valid team is found, we will have a
    `team` object as a parameter. Otherwise, an error will be thrown.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从端点中提取传递的`id`。然后，我们调用`findById`方法来查找现有的团队。如果找到一个有效的团队，我们将有一个作为参数的`team`对象。否则，将抛出一个错误。
- en: 'As you can see, there are more lines of code to add to our logic. Now it''s
    time to extract the values from the `req.body` object and modify the `team` found:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要向我们的逻辑中添加更多的代码行。现在，是时候从`req.body`对象中提取值并修改找到的`team`了：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have created a `teamBody` variable to host the `req.body` data. Then, we
    change the values into the `team` object. We are using the `||` operator; this
    operator will assign `teamBody.code` if this value is sent in the body object.
    Otherwise, it will assign the same value to the `team` object. With this, we are
    able to change the values only if they are sent.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`teamBody`变量来存储`req.body`数据。然后，我们将这些值转换为`team`对象。我们使用`||`运算符；如果这个值在请求体中发送，这个运算符将分配`teamBody.code`。否则，它将分配给`team`对象相同的值。通过这种方式，我们只能在值被发送时更改这些值。
- en: 'Now, to save it to the database, we will call the save method as we did when
    we coded the logic to create a new `Team`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将其保存到数据库中，我们将调用保存方法，就像我们编写创建新`Team`的逻辑时做的那样：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Cool! Now we have implemented the logic to update our `Team` entities. Let''s
    test things out. Execute the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经实现了更新我们的`Team`实体的逻辑。让我们测试一下。执行以下命令：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Excellent! Now we are able to update `Team` entities. However, have you noticed
    that our code is a little difficult to organize? We are using multiple `Promise`
    entities to find and save a product. What will happen if we need to perform more
    asynchronous operations? Sooner or later, we will end up having code that contains
    a lot of `then` instructions that might be difficult to maintain and understand.
    However, don't worry! The async/await comes to save the day! Keep reading.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 极好！现在我们能够更新`Team`实体。然而，你有没有注意到我们的代码有点难以组织？我们正在使用多个`Promise`实体来查找和保存一个产品。如果我们需要执行更多的异步操作会发生什么？迟早，我们会有很多`then`指令的代码，这可能很难维护和理解。但是，别担心！async/await来拯救这一天！继续阅读。
- en: The async/await instruction
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async/await指令
- en: The async and await are two instructions that come to save our life from the
    `Promise` chaos. This will allows us to write asynchronous code using asynchronous
    syntax. Let's organize our code to see how this works!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: async和await是两个指令，它们可以帮助我们从`Promise`混乱中拯救我们的生命。这将允许我们使用异步语法编写异步代码。让我们组织我们的代码，看看它是如何工作的！
- en: 'First, we will need to create a new function for the update process, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为更新过程创建一个新的函数，如下所示：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first thing to note in the preceding code is the `async` keyword. This keyword
    will wrap the returning result into a `Promise` and will allow us to use the `await`
    keyword. You cannot use `await` keyword in a non-async function. The `await` keyword
    will wait for the asynchronous call `Team.findById(id)` to end and will return
    the result. The same happens when we call the `team.save()` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先要注意的是`async`关键字。这个关键字会将返回的结果包装成一个`Promise`，并允许我们使用`await`关键字。你无法在非异步函数中使用`await`关键字。`await`关键字将等待异步调用`Team.findById(id)`结束，并返回结果。当我们调用`team.save()`方法时，也会发生同样的事情。
- en: Using async-await helps us avoid the `Promise` chaos. It provides us with an
    execution flow that might look like an asynchronous execution.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用async-await帮助我们避免`Promise`混乱。它为我们提供了一个可能看起来像异步执行的执行流程。
- en: 'Once we have defined the `updateTeam` async function, we need to modify our
    `PUT` endpoint to call this new function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`updateTeam`异步函数，我们需要修改我们的`PUT`端点来调用这个新函数：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We said that `async` will wrap the result into a `Promise`, so to use the result,
    we will need to use the `then` and `catch` methods to process the returning `Promise`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过`async`会将结果包装成一个`Promise`，因此要使用这个结果，我们需要使用`then`和`catch`方法来处理返回的`Promise`。
- en: That's it! Now we are ready to learn how to delete an existing object.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们准备好学习如何删除现有的对象了。
- en: Deleting teams
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除团队
- en: 'Deleting a team is extremely easy. To do this, we will call the remove built-in
    method of the `Team` model. Add the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个团队非常简单。为此，我们将调用`Team`模型的内置`remove`方法。添加以下代码：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s test things out. Execute the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下。执行以下命令：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is a bit different now; we received a JSON object with two params:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出略有不同；我们收到了一个包含两个参数的JSON对象：
- en: '`n`: The number of documents removed'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`：被删除的文档数量'
- en: '`ok`: `1` if the operations were successful or `0` if not'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok`：如果操作成功则为`1`，如果不成功则为`0`'
- en: Awesome! Now we have our Rest API to manage our teams ready, but there is a
    key missing piece in our API that we did not take care of, and that is security.
    We will make our API secure by adding an authentication and authorization layer
    in subsequent chapters. Keep reading!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们有了管理团队的Rest API，但我们的API中缺少一个关键部分，那就是安全性。我们将在后续章节中添加认证和授权层来使我们的API更安全。继续阅读！
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned what a database is and the difference between SQL
    and NoSQL databases. Also, we implemented the API to manage teams that is able
    to persist the information into a MongoDB database.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了什么是数据库以及SQL数据库和NoSQL数据库之间的区别。我们还实现了将信息持久化到MongoDB数据库中的管理团队的API。
- en: You also learned about async/await, and we were able to code a more easy-to-read
    and maintainable asynchronous logic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了关于async/await的内容，我们能够编写更易于阅读和维护的异步逻辑。
- en: In the next chapter, we will explore advanced features of Aurelia to integrate
    our REST API with our Aurelia web application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Aurelia的高级功能，以将我们的REST API集成到我们的Aurelia Web应用程序中。
