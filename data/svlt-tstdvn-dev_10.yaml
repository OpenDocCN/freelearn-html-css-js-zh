- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Test-Driving API Endpoints
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动 API 端点
- en: SvelteKit makes creating API endpoints a breeze. This chapter looks at how you
    can use tests to drive and prove your API endpoints.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SvelteKit 使得创建 API 端点变得轻而易举。本章将探讨如何使用测试来驱动和证明你的 API 端点。
- en: In the preceding chapter, you saw how we could push business logic out of SvelteKit
    and into plain JavaScript. We can make use of the extracted `birthdayRepository`
    object in the new API endpoints. We will now add endpoints for creating, updating,
    and getting birthdays using the `addNew`, `replace`, and `getAll` functions from
    the repository.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到了我们如何将业务逻辑从 SvelteKit 推送到纯 JavaScript。我们可以利用提取的 `birthdayRepository`
    对象在新 API 端点中使用。现在我们将添加用于创建、更新和获取生日的端点，使用存储库中的 `addNew`、`replace` 和 `getAll` 函数。
- en: '*Figure 10**.1* shows how our system design is shaping up. The endpoints we’ll
    create in this chapter are very lightweight, thanks to the fully specified `birthdayRepository`
    object:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.1* 展示了我们的系统设计是如何形成的。在本章中我们将创建的端点非常轻量级，这得益于完全指定的 `birthdayRepository`
    对象：'
- en: '![Figure 10.1 – SvelteKit components flowing into the inner system](img/Figure_10.1_B19611.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – SvelteKit 组件流入内部系统](img/Figure_10.1_B19611.jpg)'
- en: Figure 10.1 – SvelteKit components flowing into the inner system
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – SvelteKit 组件流入内部系统
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下关键主题：
- en: Creating a service test with Playwright
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Playwright 创建服务测试
- en: Adding an API endpoint for retrieving data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用于检索数据的 API 端点
- en: Adding an API endpoint for saving data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用于保存数据的 API 端点
- en: Adding an API endpoint for updating data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用于更新数据的 API 端点
- en: By the end of the chapter, you’ll have learned how to implement API endpoints
    using test-driven development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何使用测试驱动开发来实现 API 端点。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，链接为 [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter10/Start)。
- en: Creating a service test with Playwright
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Playwright 创建服务测试
- en: You’ve already seen how Playwright can be used to create end-to-end tests that
    drive the application through the web browser interface. It can also be used to
    drive the API endpoints directly, and that’s what you’ll learn to do in this section.
    The benefit of writing up-front Playwright API tests is that we can very carefully
    plan out how our API will look.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用 Playwright 创建端到端测试，通过网页浏览器界面驱动应用程序。它也可以直接驱动 API 端点，这正是本节你要学习的内容。编写前置
    Playwright API 测试的好处是我们可以非常仔细地规划我们的 API 将如何呈现。
- en: 'We’ll write just a single test named `creating and reading a birthday`. It
    will do two things: first, create a request to `POST` `/api/birthdays` that will
    create a birthday. Then we’ll call `GET` `/api/birthdays` and check that the previously
    created birthday is returned in the response:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为 `creating and reading a birthday` 的单个测试。它将做两件事：首先，创建一个向 `/api/birthdays`
    发送 `POST` 请求的请求，以创建一个生日。然后我们将调用 `GET` `/api/birthdays` 并检查之前创建的生日是否在响应中返回：
- en: 'Create a new file named `tests/api/birthdays.test.js` with the following content,
    which is the first half of that test:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `tests/api/birthdays.test.js` 的新文件，内容如下，这是测试的一半：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code snippet uses the test’s request parameter. It has a `request.post`
    method that we invoke to make the API request. The `data` prop is the JSON object
    we want to send across. Playwright takes care of converting that into an HTTP
    request and response. The request looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段使用了测试的请求参数。它有一个 `request.post` 方法，我们调用它来发送 API 请求。`data` 属性是我们想要发送的 JSON
    对象。Playwright 会负责将其转换为 HTTP 请求和响应。请求看起来是这样的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The returned object, which we call `newBirthday`, has an `ok` method that we
    call to figure out whether the endpoint returned a `200` response.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象，我们称之为 `newBirthday`，有一个 `ok` 方法，我们调用它来确定端点是否返回了 `200` 响应。
- en: Mixing assertions into test actions
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将断言混合到测试操作中
- en: In previous chapters, all our tests have been structured in the *Arrange-Act-Assert*
    format. When it comes to Playwright tests, it’s okay to occasionally have repeated
    cycles of *Act*-*Assert*, ending up with something like *Arrange-Act-Assert-Act-Assert…*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们所有的测试都按照 *安排-行动-断言* 的格式进行结构化。当涉及到 Playwright 测试时，偶尔会有重复的 *行动-断言* 循环，最终可能变成
    *安排-行动-断言-行动-断言…* 的样子。
- en: I wouldn’t do that in my unit tests, but in end-to-end and service tests, it
    can sometimes make sense because they help the tests play out **user scenarios**.
    The tests follow the steps that a typical user would take. The assertions sprinkled
    throughout the test serve as checkpoints to check whether the test is on the right
    path.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在我的单元测试中这样做，但在端到端和服务测试中，有时这样做是有意义的，因为它们有助于测试模拟 **用户场景**。测试遵循典型用户会采取的步骤。测试中散布的断言充当检查点，以检查测试是否在正确的路径上。
- en: 'Next, complete the test with a call to the GET `/api/birthdays` endpoint. Of
    interest here is the use of `expect.anything()` to say *I expect an ID back, but
    I don’t care what* *it is*:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过调用 `/api/birthdays` 端点的 `GET` 请求来完成测试。这里值得注意的是，使用 `expect.anything()`
    来表示 *我期望返回一个 ID，但我并不关心它是什么*：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That completes the test; go ahead and run the test and check that it currently
    fails (since the endpoint doesn’t exist yet).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了测试；请运行测试并检查它目前是否失败（因为端点尚不存在）。
- en: Avoiding data clashes in Playwright tests
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在 Playwright 测试中数据冲突
- en: The preceding example used the name `Nyx` in the test example. This name hasn’t
    been used before, but if you had used one of the previous names, such as `Hercules`
    or `Athena`, you would have seen other tests fail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子在测试示例中使用了 `Nyx` 这个名字。这个名字之前没有被使用过，但如果你使用了之前的名字之一，比如 `Hercules` 或 `Athena`，你可能会看到其他测试失败。
- en: The current Playwright test suite does not clear the test database between individual
    test runs. Here, we solved the issue by ensuring that each of our tests uses independent
    pieces of data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 Playwright 测试套件在单个测试运行之间不会清除测试数据库。在这里，我们通过确保我们的每个测试都使用独立的数据来解决此问题。
- en: An alternative approach would be to always clean down the database before each
    test or test suite, similar to how the Vitest unit tests are written.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在每次测试或测试套件之前始终清理数据库，类似于 Vitest 单元测试的编写方式。
- en: 'There’s an advantage to the first approach, however: you can point Playwright
    to deployed environments that are already primed with data that you don’t control
    and still expect the tests to pass.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第一种方法有一个优点：你可以将 Playwright 指向已经用你无法控制的数据预置的已部署环境，并仍然期望测试通过。
- en: 'Add a second test for updating a birthday using the `PUT` HTTP verb. The request
    will look like this:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个测试，使用 `PUT` HTTP 动词更新生日。请求看起来像这样：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Start with the first half of the test, given as follows. Notice how this pulls
    out the returned `id` field so that we can use it in the second half of the test:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下给出的测试的第一部分开始。注意，这是如何提取返回的 `id` 字段，以便我们可以在测试的第二部分中使用它：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then add the second half of the test, which performs the `PUT` request using
    `id` and checks the result:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加测试的第二部分，它使用 `id` 执行 `PUT` 请求并检查结果：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This last expectation doesn’t make use of `expect.anything`. Instead, it checks
    that `id` remains the same.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的期望并没有使用 `expect.anything`。相反，它检查 `id` 是否保持不变。
- en: That completes the two Playwright tests, covering the three new endpoints. In
    the next section, we’ll use the `GET` request to retrieve all the birthdays from
    the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了两个 Playwright 测试，涵盖了三个新的端点。在下一节中，我们将使用 `GET` 请求从系统中检索所有生日。
- en: Adding an API endpoint for retrieving data
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用于检索数据的 API 端点
- en: 'Now we get on to the fun bit: introducing new functionality for the API. In
    a SvelteKit application, a `GET` request is very directly specified by creating
    a function named `GET` inside of a route.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入有趣的部分：介绍 API 的新功能。在 SvelteKit 应用程序中，一个 `GET` 请求可以通过在路由内部创建一个名为 `GET` 的函数来非常直接地指定。
- en: Although we won’t use it for our endpoint, this function has a `params` argument
    that contains the `route` parameter. You’ll see this later in the chapter when
    we implement the `PUT` request in the *Adding an API endpoint for updating* *data*
    section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会在我们的端点中使用它，但这个函数有一个包含 `route` 参数的 `params` 参数。你将在本章后面实现 `PUT` 请求的 *添加用于更新数据的
    API 端点* 部分时看到这一点。
- en: Valid responses from the endpoint must be proper response objects. We can use
    SvelteKit’s JSON helper to define a valid JSON response. Error responses are handled
    by throwing an exception that is built by calling SvelteKit’s error helper. We’ll
    use both of these now.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 来自端点的有效响应必须是正确的响应对象。我们可以使用 SvelteKit 的 JSON 辅助工具来定义有效的 JSON 响应。错误响应通过抛出一个由调用
    SvelteKit 的错误辅助工具构建的异常来处理。我们现在将使用这两个工具。
- en: The json helper in Node versions below 18
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 版本低于 18 的版本中，json 辅助工具
- en: Calls to the `json` function may fail with a `Response is not defined` error.
    If you see this error when implementing the following tests, you can install the
    **node-fetch** package ([https://github.com/node-fetch/node-fetch](https://github.com/node-fetch/node-fetch))
    and ensure it loads as part of your Vitest setup files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`json`函数可能会失败，并出现`Response is not defined`错误。如果您在实现以下测试时遇到此错误，您可以安装**node-fetch**包（[https://github.com/node-fetch/node-fetch](https://github.com/node-fetch/node-fetch)），并确保它作为您的Vitest设置文件的一部分加载。
- en: 'Let’s start by defining a new test suite:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个新的测试套件：
- en: 'Create a new test file, `src/routes/api/birthdays/server.test.js`, that begins
    with the following `import` statements. The `birthdayRepository` module is imported
    so that the repository can be populated before calling the `GET` function:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的测试文件，`src/routes/api/birthdays/server.test.js`，它以以下`import`语句开始。导入`birthdayRepository`模块，以便在调用`GET`函数之前填充存储库：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next define the following helper method, `bodyOfResponse`, which we’ll use
    in the first test to pull out data from the HTTP response. This can go just below
    the imports:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来定义以下辅助方法，`bodyOfResponse`，我们将在第一个测试中使用它来从HTTP响应中提取数据。这可以放在导入下面：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, create a new `describe` block with the following test. It creates two
    birthdays and checks that they are returned:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的`describe`块，包含以下测试。它创建两个生日，并检查它们是否被返回：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Testing array responses
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数组响应
- en: I find that when I’m testing array objects, it’s always best to use two (and
    sometimes three) items in the list rather than just one. That way, it’s clear
    that the test is operating on lists of items, not just single items.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，在测试数组对象时，使用列表中的两个（有时是三个）项目而不是只有一个项目总是最好的。这样，可以清楚地看出测试是在操作项目列表，而不仅仅是单个项目。
- en: 'To make that test pass, create a new file named `src/routes/api/birthdays/+server.js`
    with the following content. The implementation works like this: it passes the
    request right through to the store using the `getAll` function and then wraps
    the response with a call to SvelteKit’s `json` function:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使该测试通过，创建一个名为`src/routes/api/birthdays/+server.js`的新文件，并包含以下内容。实现方式如下：它直接使用`getAll`函数将请求传递到存储库，然后通过调用SvelteKit的`json`函数包装响应：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That completes the `GET` request. Next, we’ll work on the `POST` and `PUT` requests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`GET`请求。接下来，我们将处理`POST`和`PUT`请求。
- en: Adding an API endpoint for saving data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用于保存数据的API端点
- en: In this section, we’ll start by adding the `POST` request handler function for
    saving data and then continue with the `PUT` function, in its own route file,
    for updating data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先添加用于保存数据的`POST`请求处理函数，然后继续在它自己的路由文件中添加`PUT`函数，用于更新数据。
- en: 'Let’s begin with a test helper:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一个测试辅助函数开始：
- en: 'Create a new file, `src/factories/request.js`, with the following content.
    This will be used by both the `POST` and `PUT` functions to read the data of the
    request. SvelteKit will pass a `Request` argument. The only bit of this we need
    to provide is the `json` method, as shown here:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`src/factories/request.js`，包含以下内容。这将由`POST`和`PUT`函数共同使用，以读取请求的数据。SvelteKit将传递一个`Request`参数。我们只需要提供这个参数的`json`方法，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Providing minimal versions of collaborating objects
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提供协作对象的最低版本
- en: SvelteKit passes the `Request` objects into our request handler functions. But
    for our unit tests we don’t need fully formed `Request` objects, we just need
    an object that implements the parts of the interface that we use. Our application
    code doesn’t use anything but the `json` method for reading the request body in
    JSON format, so that’s the only method we need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SvelteKit将`Request`对象传递到我们的请求处理函数中。但对我们来说，单元测试不需要完整的`Request`对象，我们只需要一个实现我们使用的接口部分的简单对象。我们的应用程序代码除了用于以JSON格式读取请求体之外，不使用任何其他方法，因此我们只需要这个方法。
- en: 'Now move to `src/api/birthdays/server.test.js` and add an `import` statement
    for the `createRequest` method. Also, update the `+server.js` import to include
    the `POST` request handler function:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`src/api/birthdays/server.test.js`，并添加一个`import`语句用于`createRequest`方法。同时，更新`+server.js`的导入以包括`POST`请求处理函数：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, add a new `describe` block for the `POST` function, just below the `describe`
    block for the `GET` function, and include this one test:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`GET`函数的`describe`块下方添加一个新的`describe`块，并包含以下测试：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To make that pass, first update the import in `src/api/birthdays/+server.js`
    to include the `addNew` function:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使该测试通过，首先更新`src/api/birthdays/+server.js`中的导入以包括`addNew`函数：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Continue by adding a definition for `POST`, as shown in the following code
    block. After this change, your test should pass:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续添加对 `POST` 的定义，如下面的代码块所示。在此更改后，你的测试应该通过：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have data saved into the repository, it’s time to check the HTTP
    response. We want any API caller to receive the same data back. The following
    test makes use of the `toContain` matcher rather than `toEqual`. That’s because
    we already know that the response will contain an `id` field that isn’t relevant
    to this test:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将数据保存到仓库中，是时候检查 HTTP 响应了。我们希望任何 API 调用者都能收到相同的数据。以下测试使用了 `toContain` 匹配器而不是
    `toEqual`。这是因为我们已经知道响应将包含一个与本次测试无关的 `id` 字段：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Testing the presence of an id field
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 id 字段的存在
- en: Why is the `id` field not included in the expectation of this test? Because
    it has a different lifecycle from the other data. This test verifies that the
    user-provided information is stored. But the `id` field is auto-generated, so
    it belongs to a separate test. I’ve omitted it here because it’s already tested
    in both the repository and the Playwright API test, but you may feel more comfortable
    including the test.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `id` 字段没有被包含在本次测试的期望中？因为它与其他数据有不同的生命周期。这个测试验证了用户提供的信息已被存储。但 `id` 字段是自动生成的，因此它属于另一个测试。我在这里省略了它，因为它已经在仓库和
    Playwright API 测试中测试过了，但你可能觉得包括这个测试会更舒服。
- en: 'To make the test pass, add a `return` value to the function that uses the `json`
    function import:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，向函数中添加一个使用 `json` 函数导入的 `return` 值：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The final test for the `POST` request handler is to check that the function
    throws an exception if the data is invalid. Throwing errors can complicate tests:
    here, the test uses a call to `expect.hasAssertions` to ensure that Vitest will
    fail the test if the call does *not* raise an error:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POST` 请求处理函数的最终测试是检查如果数据无效，函数是否会抛出异常。抛出错误可能会使测试复杂化：在这里，测试使用对 `expect.hasAssertions`
    的调用确保如果调用 *不* 抛出错误，Vitest 将失败测试：'
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Try running this test now: you’ll see the `expected any number of assertions,
    but got none` failure. That is courtesy of the `hasAssertions` statement at the
    top of the test.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行这个测试：你会看到 `expected any number of assertions, but got none` 的失败。这是测试顶部
    `hasAssertions` 语句的功劳。
- en: Understanding the hasAssertions helper
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 hasAssertions 辅助函数
- en: 'Try deleting the `expect.hasAssertions` line from the test. You will notice
    that the test already passes. That’s because the expectations were never met.
    This is the point of the `hasAssertions` call: it is useful in tests that rely
    on having expectations within `catch` blocks that won’t be called until you implement
    the exception-throwing behavior in your application code.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从测试中删除 `expect.hasAssertions` 行。你会注意到测试已经通过了。这是因为期望从未被满足。这就是 `hasAssertions`
    调用的目的：它在依赖于在 `catch` 块中有期望的测试中很有用，这些期望直到你在应用程序代码中实现抛出异常的行为才会被调用。
- en: 'To make that pass, first update the `import` statement in `src/api/birthdays/+server.js`
    to include the `error` helper:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，首先更新 `src/api/birthdays/+server.js` 中的 `import` 语句以包含 `error` 辅助函数：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then update the `POST` function to re-package any errors from the repository
    into an `error` object that’s then thrown:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后更新 `POST` 函数，将仓库中的任何错误重新打包成一个 `error` 对象，然后抛出：
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That completes the `POST` request handler for inserting new birthdays; the next
    section completes the chapter with the addition of the `PUT` request handler for
    updating existing birthdays.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了插入新生日信息的 `POST` 请求处理函数；下一节通过添加更新现有生日的 `PUT` 请求处理函数来完成本章。
- en: Adding an API endpoint for updating data
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用于更新数据的 API 端点
- en: The final piece of the puzzle is to add a `PUT` request handler function for
    dealing with updates. Similar to the `POST` function, we must provide the request
    body using the `createRequest` helper.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加一个用于处理更新的 `PUT` 请求处理函数。类似于 `POST` 函数，我们必须使用 `createRequest` 辅助函数提供请求体。
- en: 'The form of our `PUT` request means that `id` is passed as a parameter in the
    URL, like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `PUT` 请求的形式意味着 `id` 作为参数传递到 URL 中，如下所示：
- en: 'Here’s a reminder of how the URL must be passed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个关于如何传递 URL 的提醒：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To make SvelteKit register the `abc123` value as a parameter, we need to create
    a new route directory at `src/routes/api/birthday/[id]`. SvelteKit will then know
    that `abc123` matches the `[id]` bit of the directory path. The directory itself
    will then contain the `+server.js` file and its tests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 SvelteKit 将 `abc123` 值注册为参数，我们需要在 `src/routes/api/birthday/[id]` 创建一个新的路由目录。SvelteKit
    将知道 `abc123` 匹配目录路径中的 `[id]` 部分。该目录本身将包含 `+server.js` 文件及其测试。
- en: 'Let’s start with the tests:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试开始：
- en: 'Create a new file named `src/routes/api/birthday/[id]/server.test.js` and add
    the following imports. This has everything we’ve used previously for the `GET`
    and `POST` functions, together with an import for the `PUT` function:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`src/routes/api/birthday/[id]/server.test.js`的新文件，并添加以下导入。这包括了之前用于`GET`和`POST`函数的所有内容，以及`PUT`函数的导入：
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then create this new `describe` block. It contains a `beforeEach` block that
    not only clears the repository but inserts a new item, ready for editing:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建这个新的`describe`块。它包含一个`beforeEach`块，不仅清除仓库，还插入一个新项目，以便编辑：
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we get to the first test, add the following helper:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们到达第一个测试之前，添加以下辅助函数：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now add the first test, as shown here. It mimics SvelteKit’s call semantics
    by passing a new `params` object into the handler:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加第一个测试，如下所示。它通过向处理程序传递一个新的`params`对象来模仿SvelteKit的调用语义：
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make that pass, create a new file named `src/routes/api/birthday/[id]/+server.js`
    with the following content. This should immediately make the test pass:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，创建一个名为`src/routes/api/birthday/[id]/+server.js`的新文件，并包含以下内容。这应该会立即使测试通过：
- en: '[PRE25]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For the next test, we’ll begin by repeating a helper from the `GET` tests.
    Add the `bodyOfResponse` function, as shown here:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们将从重复`GET`测试中的一个辅助函数开始。添加`bodyOfResponse`函数，如下所示：
- en: '[PRE26]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, add the next test, which uses this function to check the response:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加下一个测试，该测试使用此函数来检查响应：
- en: '[PRE27]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To make that pass, start by adding the import for `json` in the application
    code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，首先在应用程序代码中添加对`json`的导入：
- en: '[PRE28]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, update the `PUT` function to return the result of the repository action,
    just as we did with the `POST` request handler function:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新`PUT`函数以返回仓库操作的结果，就像我们处理`POST`请求处理函数一样：
- en: '[PRE29]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The final test repeats the mechanics of the final `POST` test, checking what
    happens if the data is invalid:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个测试重复了最后一个`POST`测试的机制，检查数据无效时会发生什么：
- en: '[PRE30]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To make that pass, start by updating the `import` statement in the application
    code to include the `error` function:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，首先更新应用程序代码中的`import`语句以包含`error`函数：
- en: '[PRE31]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, include the guard clause in the `PUT` function, as shown here:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`PUT`函数中包含守卫子句，如下所示：
- en: '[PRE32]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That’s it. If you run both the Vitest and Playwright tests now, you should find
    they all pass.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如果你现在运行Vitest和Playwright测试，你应该会发现它们都通过了。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has shown how to make quick work of API endpoints. Playwright tests
    can be used to specify how an API should behave, and the unit tests can be used
    to drive the design and ensure that we end up with minimal implementation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何快速处理API端点。Playwright测试可以用来指定API应该如何表现，单元测试可以用来驱动设计并确保我们最终得到最小化的实现。
- en: 'The next chapter completes the API story arc: we will update the form actions
    to use the new API endpoints rather than going directly to the repository.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章完成了API故事弧：我们将更新表单操作以使用新的API端点，而不是直接访问仓库。
