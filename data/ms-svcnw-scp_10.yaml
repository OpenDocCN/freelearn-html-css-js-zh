- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: In this chapter, we will be looking at best practices when scripting in ServiceNow.
    Best practices are important when scripting to make the most use of resources
    and present the best user experience. We will explore best practices in general
    scripting, server-side and client-side code, and debugging. We will also delve
    into best practices involving logs, queues, and system performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在 ServiceNow 中脚本编写时的最佳实践。在脚本编写时，最佳实践非常重要，以便充分利用资源并提供最佳的用户体验。我们将探讨一般脚本、服务器端和客户端代码以及调试的最佳实践。我们还将深入研究涉及日志、队列和系统性能的最佳实践。
- en: 'The following topics will be looked at in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨以下主题：
- en: Coding best practices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码最佳实践
- en: Business rule best practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务规则最佳实践
- en: Client script best practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端脚本最佳实践
- en: Debugging tools best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试工具最佳实践
- en: Logs and queues best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和队列最佳实践
- en: System performance best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统性能最佳实践
- en: Coding best practices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码最佳实践
- en: When scripting, there are many ways to achieve the same goal, but keeping code
    efficient can make it much easier to maintain and work on in the future. Using
    a few system resources is usually encouraged too, as this decreases loading times
    and the load on the data center in the cloud.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本编写时，有许多方法可以实现相同的目标，但保持代码高效可以使未来的维护和工作变得更加容易。通常也鼓励使用少量系统资源，因为这可以减少加载时间和云数据中心上的负载。
- en: You will often find that older instances suffer from poor performance because
    best practices were not adhered to during development. I have been part of minor
    projects simply to make code more efficient before, and because these are often
    associated with slow loading times, it can be a great improvement for the user
    base.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现，较旧的实例由于在开发过程中没有遵守最佳实践而性能不佳。我之前曾参与过一些小项目，仅仅是为了使代码更高效，因为这些项目通常与缓慢的加载时间相关，因此对用户基础来说可能是一个巨大的改进。
- en: In this section, we will look at how to make sure your script adhers to best
    practices and how to avoid common mistakes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何确保你的脚本遵守最佳实践以及如何避免常见的错误。
- en: 'First, one type of scripting that is quite common is nested `if` statements.
    This is an `if` statement after an `if` statement and is often used to catch several
    potential values for the same variable. We can see a server-side example of what
    this looks like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一种相当常见的脚本类型是嵌套的 `if` 语句。这是一个在另一个 `if` 语句之后的 `if` 语句，通常用于捕获同一变量的几个潜在值。我们可以看到一个服务器端示例，看看它是什么样子：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also see what this looks like in a script field in *Figure 10.1*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 *图 10.1* 中的脚本字段中看到它的样子：
- en: '![](img/9b0da519-1776-4e5e-932e-333a32ed5b1e.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b0da519-1776-4e5e-932e-333a32ed5b1e.png)'
- en: 'Figure 10.1: Nested if statement script example'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：嵌套 if 语句脚本示例
- en: 'Instead of using these nested if statements, it is better to use a `switch`
    statement. We can see how the previous script can be a more efficient `switch`
    statement instead:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用嵌套的 if 语句相比，使用 `switch` 语句更好。我们可以看到之前的脚本可以是一个更高效的 `switch` 语句：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `switch` statement is easier to read as well for developers who may need
    to maintain the ServiceNow instance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能需要维护 ServiceNow 实例的开发者来说，`switch` 语句也更容易阅读。
- en: 'We can see the `switch` statement inside a script field in *Figure 10.2*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *图 10.2* 中看到脚本字段内的 `switch` 语句：
- en: '![](img/5ac4131c-bdb6-4b33-8530-32cdc872631f.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ac4131c-bdb6-4b33-8530-32cdc872631f.png)'
- en: 'Figure 10.2: Switch statement script example'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：开关语句脚本示例
- en: Ensure that you use a break at the end of each case to ensure that the `switch`
    statement works correctly, as sometimes this can be omitted by mistake.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在每个 case 的末尾使用 break，以确保 `switch` 语句正确工作，因为有时可能会不小心省略。
- en: Business rule best practices
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务规则最佳实践
- en: Business rule best practices are, to a large extent, about running business
    rules at the correct time. As we have already discovered, a business rule can
    be run at different times based on when the form is saved or the action is taken
    to the record.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 业务规则最佳实践在很大程度上是关于在正确的时间运行业务规则。正如我们已经发现的，业务规则可以在表单保存或对记录执行操作的不同时间运行。
- en: This means that it is important to make sure that a business rule that is created
    is running in the most efficient way. Using business rules correctly, we can avoid
    problems such as updating the same record twice and running script when it is
    not required.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着确保创建的业务规则以最有效的方式运行非常重要。正确使用业务规则，我们可以避免诸如更新同一记录两次和在不必要的时候运行脚本等问题。
- en: 'We''ll start with looking at the check boxes on a business rule, as shown in *Figure
    10.3*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看业务规则上的复选框开始，如图*图10.3*所示：
- en: '![](img/3fdd372f-ae82-46c1-be9d-400360e4aaf9.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fdd372f-ae82-46c1-be9d-400360e4aaf9.png)'
- en: 'Figure 10.3: Business rule check boxes'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：业务规则复选框
- en: Insert and Update are the most frequently used, and they are often used together.
    However, it is a best practice to ensure that you make your business rule only
    run when necessary. Do not tick both boxes just to cover all possibilities; if
    your business rule is not needed when a record is inserted or updated then leave
    that tick box unchecked.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: “插入”和“更新”是最常用的，它们经常一起使用。然而，确保您的业务规则仅在必要时运行是最佳实践。不要只是为了覆盖所有可能性而同时勾选两个框；如果业务规则在记录插入或更新时不需要，则不要勾选该复选框。
- en: Usually, Delete and Query are selected individually, as these operations do
    not tend to align themselves with any other operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，单独选择“删除”和“查询”，因为这些操作通常不会与其他操作对齐。
- en: As business rules run on the server side, a good practice in business rule script
    also applies to other areas of ServiceNow where server-side scripting is used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于业务规则在服务器端运行，因此业务规则脚本中的良好做法也适用于ServiceNow的其他使用服务器端脚本的区域。
- en: The When field is the next field we will look at. This is an important field
    to get right, and avoid bad practices by doing so. There are four options here;
    let's have a look at each.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “当”字段是我们接下来要查看的字段。这是一个重要的字段，正确设置它可以帮助避免不良做法。这里有四个选项；让我们逐一看看。
- en: Before
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 之前
- en: Running a business rule before a record is saved is a great way to change values
    before the save action takes place. The before option should be selected when
    making changes to the record being saved. This means that if you are changing
    values using current, then before is most likely the best option.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录保存之前运行业务规则是改变保存操作之前值的好方法。当对正在保存的记录进行更改时，应选择“之前”选项。这意味着如果您正在使用“current”来更改值，那么“之前”可能是最佳选项。
- en: Remember that when running a script in a before business rule, the record has
    not been saved yet. This means that you only need to set the values in the current
    record as the record will be saved afterward. This also means that you need to
    ensure that you avoid using `current.update()` as this will end up saving the
    record twice.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在“之前”业务规则中运行脚本时，记录尚未保存。这意味着您只需要设置当前记录中的值，因为记录将在之后保存。这也意味着您需要确保避免使用`current.update()`，因为这会导致记录被保存两次。
- en: After
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 之后
- en: If the business rule is run with the after option selected, the script runs
    immediately after the record is saved. We should use the after option if we are
    updating values not on the current record we are saving, but want the script to
    be run immediately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行业务规则时选择了“之后”选项，脚本将在记录保存后立即运行。如果我们正在更新当前保存的记录之外的值，但希望脚本立即运行，则应使用“之后”选项。
- en: This option is useful to update records associated with the record being saved,
    for example, to change tasks when updating a change. This is also a good option
    if we are scripting any sort of approval changes for the record being saved, as
    these will be displayed on the record after it is reloaded, after being saved.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项适用于更新与正在保存的记录相关的记录，例如，在更新更改时更改任务。如果我们正在为正在保存的记录编写任何类型的审批更改脚本，这也是一个好的选项，因为这些更改将在记录重新加载后、保存后显示在记录上。
- en: If we are looking to update the current record, then it is better to use the
    before option. If you are thinking of using `current.update()` in your script,
    then think about using the before option instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更新当前记录，那么使用“之前”选项会更好。如果您在脚本中考虑使用`current.update()`，那么考虑使用“之前”选项代替。
- en: Async
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步
- en: The async option will send the script to the system scheduler, and it will be
    run shortly after the record is saved. This option is good for when the script
    you have written does not need to be run immediately after the record is saved.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: “异步”选项会将脚本发送到系统调度器，并在记录保存后不久运行。当您编写的脚本不需要在记录保存后立即运行时，此选项是很好的选择。
- en: Good uses for the async option are for sending messages between integrations
    and sending tasks to the ECC queue. Remember that the async option can have a
    more significant delay if the ServiceNow instance-scheduled job queue is long,
    so be mindful of the average wait time for your instance when setting an async
    business rule. If you would like a more instant running of your script, consider
    the after option.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 异步选项的良好用途包括在集成之间发送消息和将任务发送到ECC队列。请记住，如果ServiceNow实例计划作业队列很长，异步选项可能会有更大的延迟，因此在设置异步业务规则时，请注意您实例的平均等待时间。如果您希望脚本立即运行，请考虑使用after选项。
- en: Display
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示
- en: A display business rule runs when a record is loaded before any client-side
    scripts are run. This type of business rule is useful for providing values to
    the client side so that there is no need to call the server from a client script.
    We can avoid AJAX calls using this type of business rule.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录在运行任何客户端脚本之前被加载时，显示业务规则会运行。这种类型的业务规则对于向客户端提供值非常有用，这样就不需要从客户端脚本调用服务器。我们可以使用这种类型的业务规则来避免AJAX调用。
- en: Display business rules were not always available in ServiceNow, so you may find
    instances where using them in old instances can reduce server calls in client
    scripts and therefore reduce record-loading times.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 显示业务规则在ServiceNow中并不总是可用，因此你可能会发现，在旧实例中使用它们可以减少客户端脚本中的服务器调用，从而减少记录加载时间。
- en: If you are considering using an AJAX call in an onLoad client script, then you
    should instead, where possible, use a display business rule to fetch the server-side
    values you require and set them in a scratchpad for client-side scripts to use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑在onLoad客户端脚本中使用AJAX调用，那么在可能的情况下，你应该使用显示业务规则来获取所需的服务器端值，并将它们设置在草稿本中供客户端脚本使用。
- en: Client script best practices
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端脚本最佳实践
- en: As we have seen, client scripts run on the client side and so only have access
    to data that has been sent to the client from the server. The main goal we have
    when writing client-side scripts is to minimize the amount of script we write
    and the calls to the server we make.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，客户端脚本在客户端运行，因此只能访问从服务器发送到客户端的数据。当我们编写客户端脚本时，我们的主要目标是尽量减少我们编写的脚本数量和对服务器的调用次数。
- en: The reason we keep client scripting to a minimum is that these scripts run in
    front of the user and therefore directly effect loading times. We want to keep
    loading times to a minimum and, therefore, client scripting to a minimum also.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将客户端脚本保持到最小量的原因是因为这些脚本在用户面前运行，因此会直接影响加载时间。我们希望将加载时间保持在最低，因此客户端脚本也应该保持在最低。
- en: When writing a new client script, it is worth considering whether the script
    could be run on the server side instead, and if so, then this is usually considered
    a best practice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一个新的客户端脚本时，考虑脚本是否可以在服务器端运行是有价值的，如果是这样，那么这通常被认为是最佳实践。
- en: 'Let''s have a look at one of the most common bad practices in client scripting.
    Take the following script, for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看客户端脚本中最常见的坏做法之一。以下是一个示例脚本： '
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This script is calling the server side to get the details about the current
    caller for an incident, and whether that caller is active now in the system. This
    is a bad practice as we can already tell whether this user is active before we
    load the record, rather than loading it, then going back to the database again,
    increasing load times.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本正在调用服务器以获取有关当前事件调用者的详细信息，以及该调用者是否现在在系统中活跃。这是一个不好的做法，因为我们可以在加载记录之前就已经知道这个用户是否活跃，而不是加载记录后再次回到数据库，这会增加加载时间。
- en: 'We can see what this code would look like in the following client script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下客户端脚本中看到这段代码的示例：
- en: '![](img/84110aec-6a8c-4713-beb8-416985f4c191.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84110aec-6a8c-4713-beb8-416985f4c191.png)'
- en: 'Figure 10.4: Client script showing bad practise by making an unnecessary server
    call'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：客户端脚本展示了不必要的服务器调用的不良做法
- en: To keep this functionality, but improve the code, we can use a display business
    rule. By doing this, we bring the data we want from the server before we get to
    the client using a scratchpad.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持这一功能，同时改进代码，我们可以使用一个显示业务规则。通过这样做，我们在将数据从服务器传输到客户端之前，使用草稿本来获取我们想要的数据。
- en: 'First, we create the display business rule with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用以下代码创建显示业务规则：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code sets the active field value to the `caller_active` scratchpad so that
    it can be used by the client code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将活动字段值设置为`caller_active`草稿本，以便它可以被客户端代码使用。
- en: 'Let''s see what this looks like as a display business rule:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这作为一个显示业务规则的样子：
- en: '![](img/33caf409-5655-4b44-96f7-e387f1389de3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33caf409-5655-4b44-96f7-e387f1389de3.png)'
- en: 'Figure 10.5: Display business rule setting a scratchpad variable'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：显示业务规则设置刮板变量
- en: In our business rule, we would set the When field on the When to run tab to
    be displayed so that this rule runs as the form is loaded. For our example, we
    have set the incident form as the table to run this business rule on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的业务规则中，我们会将“何时运行”选项卡上的“何时”字段设置为显示，以便这个规则在表单加载时运行。在我们的例子中，我们将事件表单设置为运行此业务规则的表。
- en: 'Now, we have the display business rule set up, so we just need to amend our
    client script:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了显示业务规则，所以我们只需要修改我们的客户端脚本：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the earlier code, we set the field message text using the scratchpad value
    we set in the display business rule. This now means that we are not making a round
    trip to the server for this detail anymore as it is sent initially.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期代码中，我们使用在显示业务规则中设置的刮板值来设置字段消息文本。这意味着我们不再需要为这个细节进行服务器往返，因为它最初就被发送了。
- en: 'Let''s see what this will look like in a defined client script:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在定义的客户端脚本中这会是什么样子：
- en: '![](img/6b113e83-e523-48c3-9e8c-066bbff49ac5.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b113e83-e523-48c3-9e8c-066bbff49ac5.png)'
- en: 'Figure 10.6: Client script setting a field message based on a scratchpad value'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：客户端脚本根据刮板值设置字段消息
- en: In our example, we are using the script when the incident form loads. This will
    show the active state of the caller currently selected on the incident form. We
    would also want to bear in mind changing this value if the caller changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用脚本在事件表单加载时。这将显示在事件表单上当前选定的调用者的活动状态。我们还想注意，如果调用者发生变化，这个值可能会改变。
- en: Using this method, we can display any of the other caller attributes as well,
    including helpful fields like phone number or email address to contact a caller
    about progress on an incident. We could also display the line manager and use
    dot walking to display some of the manager's information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们还可以显示其他调用者属性，包括如电话号码或电子邮件地址等有助于联系调用者了解事件进展的辅助字段。我们还可以显示线路经理，并使用点遍历来显示一些经理的信息。
- en: 'Here, we can see what the output would look like for our example for a caller
    on the incident form:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的示例中事件表单上调用者的输出会是什么样子：
- en: '![](img/e88c6d9c-bd36-49a4-8928-ada8e91557ce.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e88c6d9c-bd36-49a4-8928-ada8e91557ce.png)'
- en: 'Figure 10.7: Incident form showing a custom field message for the Caller field'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：事件表单显示调用者字段的自定义字段消息
- en: We have opened one of the baseline incidents that is present in ServiceNow,
    and we can see that the current caller is active in ServiceNow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打开了一个存在于ServiceNow中的基线事件，我们可以看到当前调用者在ServiceNow中是活跃的。
- en: It is highly recommended to review the client scripts in your ServiceNow instance
    to ensure that no unnecessary server calls are made by them. Remember to use display
    business rules where possible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 高度推荐审查你的ServiceNow实例中的客户端脚本，以确保它们没有进行不必要的服务器调用。记住尽可能使用显示业务规则。
- en: Debugging tools best practices
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试工具的最佳实践
- en: As we have discovered in previous chapters, there are many ways to debug in
    ServiceNow. Each developer will have their own favorite methods, and also, there
    are better ways to debug different scenarios.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所发现的，在ServiceNow中有很多调试方法。每个开发者都会有他们自己的首选方法，而且，也有更好的方法来调试不同的场景。
- en: Logging
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: One of my favorite ways of debugging is using logging techniques such as `gs.log`.
    In earlier chapters, we saw that these logs can be added to a script, and when
    the script runs, we see these logs in the system log for the ServiceNow instance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的调试方法之一是使用日志技术，例如`gs.log`。在早期章节中，我们看到了这些日志可以被添加到脚本中，当脚本运行时，我们可以在ServiceNow实例的系统日志中看到这些日志。
- en: However, we must ensure that this debugging is never seen in a production instance.
    It is a good practice to check each script that you write to ensure that no debugging
    is left in the final version. It can be a good idea to check the system log before
    your newly created script is executed and then again once you have finished. If
    there are any logging messages that are sent, then these should be removed before
    the new functionality is sent to a production instance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须确保这种调试永远不会在生产实例中可见。检查你编写的每个脚本以确保没有调试代码留在最终版本中是一个好习惯。在执行新创建的脚本之前检查系统日志，完成后再检查一次是个好主意。如果有任何日志消息被发送，那么在将新功能发送到生产实例之前应该删除这些消息。
- en: It is also important to make sure that you make your logging messages relevant
    to the functionality you are trying to achieve. This is especially important if
    you aim to leave in some logging functionality for your new code. Building some
    logging functionality can be helpful in a larger application or customization.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的日志消息与您试图实现的功能相关也很重要。如果您打算在新的代码中保留一些日志功能，这一点尤为重要。在更大的应用程序或定制中构建一些日志功能可能会有所帮助。
- en: 'Consider, for example, the following code and logging:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码和日志：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example will create a log when the value of the caller has been successfully
    put into the caller variable, but it does not offer much information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将在调用者的值成功放入调用者变量时创建日志，但它没有提供太多信息。
- en: 'We can see the log this creates here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里创建的日志：
- en: '![](img/1af01dba-3064-4ceb-ab33-82a1126d309a.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1af01dba-3064-4ceb-ab33-82a1126d309a.png)'
- en: 'Figure 10.8: Sample basic log'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：基本日志示例
- en: 'To improve our log, let''s look at another example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的日志，让我们看看另一个例子：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This second example is better because we now have some information about what
    is happening at this point in the code, and where the code was successful.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子更好，因为我们现在有了关于代码此点发生的事情以及代码成功的地方的一些信息。
- en: 'The output of this log looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此日志的输出看起来像这样：
- en: '![](img/8cf92da7-bd2e-4149-ad80-cdd63246976d.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cf92da7-bd2e-4149-ad80-cdd63246976d.png)'
- en: 'Figure 10.9: Sample improved log'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9：改进后的日志示例
- en: We can still improve this further though by adding more information at this
    point.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还可以通过在此处添加更多信息来进一步改进它。
- en: 'Let''s look at a further example on logging in this way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步看看这种方式的日志记录示例：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Looking at the example, we now have added code in our logging to log the value
    of the caller field, as well as the details of what has occurred in the script.
    This will log the `sys_id` of the user in the system log, so we can check the
    value of the caller variable is correct at this point in the code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个例子，我们现在在我们的日志中添加了代码来记录调用者字段的值，以及脚本中发生的情况的详细信息。这将记录系统日志中的用户`sys_id`，这样我们就可以检查调用者变量在此代码点的值是否正确。
- en: 'We can see this improved log in the following figure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图中看到这个改进后的日志：
- en: '![](img/6b5b4b7c-9459-4dfc-ab5d-d5c3a9ff4498.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b5b4b7c-9459-4dfc-ab5d-d5c3a9ff4498.png)'
- en: 'Figure 10.10: Sample log with data added'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10：添加数据后的日志示例
- en: 'Now, we will look at one final example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看一个最终的例子：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this final example, we are now logging the display value to the log, so
    we can see the actual name of the user rather than just the `sys_id` of the user.
    This makes the result clearer for a developer reading through the log statements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终示例中，我们现在将显示值记录到日志中，这样我们就可以看到用户的实际名称，而不仅仅是用户的`sys_id`。这使得阅读日志语句的开发者看到的结果更清晰。
- en: 'Let''s look at how the final example looks in the system log:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最终示例在系统日志中的样子：
- en: '![](img/e8dba677-3bae-4ccc-ba7b-c43c818ecc20.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8dba677-3bae-4ccc-ba7b-c43c818ecc20.png)'
- en: Figure 10.11:  Sample log with useful data included
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11：包含有用数据的日志示例
- en: We have seen how it is easy to add logging to ServiceNow script, but it is best
    practice to ensure that the logs you create would be helpful to developers other
    than yourself.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何轻松地将日志添加到 ServiceNow 脚本中，但最佳实践是确保您创建的日志对其他开发者也有帮助。
- en: Session debug
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话调试
- en: Session debug can be a powerful tool, but it can also create an overload of
    logs making debugging a long and arduous process. When using session debugging,
    it is important to think about the type of logs you need to debug the situation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 会话调试可以是一个强大的工具，但它也可能创建过多的日志，使调试变得漫长而艰巨。在使用会话调试时，重要的是要考虑您需要调试情况所需的日志类型。
- en: While it can seem easiest to simply enable all session debugging, it is best
    to enable the areas you are interested in only. This ensures there are less logs
    to go through and means you can access the information that you are interested
    in faster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单地启用所有会话调试可能看起来最简单，但最好只启用您感兴趣的区域。这确保了日志数量更少，意味着您可以更快地访问您感兴趣的信息。
- en: In general, I do not find session debug to be used by many developers except
    for scopes and security rules. This is because other methods are preferred for
    the other debugging options session debugging provides.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我发现除了作用域和安全规则之外，很少有开发者使用会话调试。这是因为其他方法更受其他调试选项会话调试的青睐。
- en: Logs and queues best practices
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志和队列的最佳实践
- en: Logs and queues are an important part of a ServiceNow instance. Logs are used
    throughout ServiceNow to record events occurring in an instance. These are used
    in debugging, as we have seen, and these logs should be well-defined when included.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 日志和队列是ServiceNow实例的重要组成部分。日志在ServiceNow中用于记录实例中发生的事件。这些日志在调试中使用，正如我们所见，当包含这些日志时，它们应该被很好地定义。
- en: Queues are seen in ServiceNow in a number of areas, from the ECC queue to the
    system scheduler. These queues build up jobs or actions to be performed when the
    time is right.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 队列在ServiceNow的多个区域中可见，从ECC队列到系统调度器。这些队列在适当的时间构建要执行的作业或操作。
- en: When using logs and queues, it is important to make logs clear and only create
    jobs or event in queues where necessary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用日志和队列时，重要的是使日志清晰，并且只在必要时在队列中创建作业或事件。
- en: Logs
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: Logs need to be created with clear information given for each log, and to be
    sent to the right logging location to ensure that the information can be easily
    read. We covered some logging techniques in the debugging section or how to write
    good logs, but we also need to make sure that we send logs to the correct log
    itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 需要为每个日志创建清晰的详细信息，并将其发送到正确的日志位置，以确保信息可以轻松读取。我们在调试部分介绍了某些日志技术或如何编写良好的日志，但我们还需要确保将日志发送到正确的日志本身。
- en: When using `gs.log`, we can specify a source to send the logs to. If no source
    is specified, then *** Script will be the default source used. This will show
    the log in the Script Log Statements module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`gs.log`时，我们可以指定一个发送日志的源。如果没有指定源，则默认使用***脚本作为源。这将在脚本日志语句模块中显示日志。
- en: 'Here, we can see a sample log with the *** Script source displayed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个示例日志，其中显示了***脚本源：
- en: '![](img/118bac73-6537-4fab-af5b-bc38a969c51b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/118bac73-6537-4fab-af5b-bc38a969c51b.png)'
- en: 'Figure 10.12: Sample script log'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：示例脚本日志
- en: If you are creating a larger piece of functionality or a custom application,
    it is advised that you create your own logging source. By adding your own source,
    you can keep all of your logging separate and easy to maintain. It is also often
    the case that a developer will create a module as part of their new application
    to be directed to logs with the custom source of the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个较大的功能块或自定义应用程序，建议你创建自己的日志源。通过添加自己的源，你可以保持所有日志的独立性和易于维护。通常情况下，开发者会创建一个模块作为他们新应用程序的一部分，以便将日志定向到具有应用程序自定义源的日志。
- en: Queues
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: There are many queues in ServiceNow that you can send jobs and events to. Queuing
    up a task or event allows them to be combined together and processed in a batch
    rather than individually.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在ServiceNow中，你可以将作业和事件发送到许多队列。将任务或事件排队可以允许它们组合在一起批量处理，而不是单独处理。
- en: Each queue will be processed after a given time, and the timing that each queue
    is processed is often set in the system properties. Changing the frequency that
    a queue is processed will mean that tasks or events are dealt with quicker, but
    it will have a draining effect on system resources. It is always important to
    carefully consider this when setting queue processing times at a different value
    to the defaults that are provided in the baseline system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个队列将在给定时间后进行处理，每个队列的处理时间通常在系统属性中设置。改变队列的处理频率意味着任务或事件将更快地被处理，但会对系统资源产生消耗效应。在将队列处理时间设置为与基线系统提供的默认值不同的值时，始终需要仔细考虑这一点。
- en: Now, let's take a look at some of the most important queues in a ServiceNow
    instance and the best practice for each queue type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看ServiceNow实例中一些最重要的队列以及每种队列类型的最佳实践。
- en: Event queue
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件队列
- en: The event queue triggers events that are then picked up by notifications and
    script actions. Triggering an event does not use many system resources, so volume
    is not usually a problem. There are many events that are provided and triggered
    in the baseline system, so this queue will always contain activity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 事件队列触发事件，然后由通知和脚本操作捕获。触发事件不会使用很多系统资源，因此通常不会成为问题。基线系统中提供了许多事件，因此此队列将始终包含活动。
- en: The more important aspect of setting up scripts to send events to the event
    queue is making sure that the event is well-defined and only fires when it is
    supposed to.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 设置脚本以将事件发送到事件队列的重要方面是确保事件被很好地定义，并且仅在需要时触发。
- en: Well-explained events are much easier to use for other developers, so try to
    demonstrate what the event is triggered by in the name of the event itself, and
    certainly in the definition.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 事件解释得很好的事件对其他开发者来说更容易使用，因此尽量在事件名称本身以及定义中演示事件是由什么触发的。
- en: 'We can see a sample event log here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到示例事件日志：
- en: '![](img/27c3e01e-f7b1-42b5-95a5-c7a97ad60ffb.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27c3e01e-f7b1-42b5-95a5-c7a97ad60ffb.png)'
- en: 'Figure 10.13: Event log sample'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13：事件日志示例
- en: In an event log, we can see when events were processed, and the processing duration
    of events. It is worth considering the impact of events taking a long time to
    process and, if necessary, investigate why this is the case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件日志中，我们可以看到事件的处理时间以及事件的处理持续时间。考虑事件处理时间过长的影响，并在必要时调查原因，这是值得考虑的。
- en: In our example, we can see some regular events in the log including a successful
    login and established session, as well as a heartbeat event and text indexing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以在日志中看到一些常规事件，包括成功的登录和建立的会话，以及心跳事件和文本索引。
- en: When creating an event, ensure that you test edge-case scenarios so that the
    definition of the event truly reflects when it will fire.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建事件时，确保测试边缘情况，以确保事件的定义真正反映了它何时会触发。
- en: When sending an event to the event queue for the more distant future, be careful
    that the event will not be lost as part of table rotation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当将事件发送到更远未来的事件队列时，请注意事件不会在表轮换过程中丢失。
- en: System scheduler
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调度器
- en: One of the most common ways that you can add a job to the system scheduler is
    to use an async business rule. Once an async business rule is triggered, it sends
    a job to the scheduler queue to run the script contained within it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将作业添加到系统调度器中最常见的方法之一是使用异步业务规则。一旦异步业务规则被触发，它就会将作业发送到调度器队列以运行其中包含的脚本。
- en: It is also possible to add your own jobs to the system scheduler. It is best
    to only do this where necessary, as too many jobs in the scheduler can be a detriment
    to instance performance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将您自己的作业添加到系统调度器中。最好只在必要时这样做，因为调度器中的作业过多可能会损害实例性能。
- en: ECC queue
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECC 队列
- en: The ECC queue is where input and output messages from MID servers are held.
    This is usually for integrations between instances and other systems. Here, we
    can send jobs using scripts for the MID servers to perform. There is normally
    not a lot of scripted messages to the ECC queue as it normally triggers an integration
    in one line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ECC 队列是存放来自 MID 服务器输入和输出消息的地方。这通常是为了实例和其他系统之间的集成。在这里，我们可以使用脚本向 MID 服务器发送作业。通常不会向
    ECC 队列发送很多脚本消息，因为它通常会在一行中触发一次集成。
- en: 'The ECC Queue is accessed from the application navigator by navigating to ECC
    | Queue. We can see this module here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到 ECC | 队列，可以从应用程序导航器访问 ECC 队列。我们可以在这里看到此模块：
- en: '![](img/7fecccce-53ba-4615-a4da-1d56a8f7e2b3.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fecccce-53ba-4615-a4da-1d56a8f7e2b3.png)'
- en: Figure 10.14:  ECC queue module
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14：ECC 队列模块
- en: The queue will often contain heartbeat probes sent out to MID servers to check
    that they are responding. This is done every 5 minutes, and if a response is received,
    the MID server is marked as up, and if no response is received, the MID server
    is marked as down.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 队列通常会包含发送到 MID 服务器以检查它们是否响应的心跳探测。这是每 5 分钟进行一次，如果收到响应，则将 MID 服务器标记为在线，如果没有收到响应，则将
    MID 服务器标记为离线。
- en: When sending jobs to the ECC queue, just make sure that each job is relevant
    and do not send more jobs than are necessary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当向 ECC 队列发送作业时，只需确保每个作业都是相关的，并且不要发送比必要的更多的作业。
- en: System performance best practices
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统性能最佳实践
- en: There are a number of attributes that make up the perceived performance of an
    instance. These can be greatly effected by badly coded scripts or a large number
    of them that are not required.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多属性构成了实例的感知性能。这些可能会受到糟糕编写的脚本或大量不必要的脚本的影响。
- en: One of the most common ways scripting can cause perceived performance delays
    is when an excess of client scripts are used when a form opens. This causes a
    big delay in browser rendering and parsing, which is very apparent to the user.
    As we have mentioned before, a best practice in this scenario is to limit the
    amount of client scripts created only to those essential, and to ensure that server
    calls are kept to a minimum.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可能导致感知性能延迟的最常见方式之一是在表单打开时使用过多的客户端脚本。这会导致浏览器渲染和解析的延迟很大，用户可以非常明显地感觉到。正如我们之前提到的，在这种情况下的一种最佳实践是将创建的客户端脚本数量限制在仅必要的那些，并确保服务器调用保持在最低限度。
- en: If information is needed for an `onLoad` client script, then consider a display
    business rule instead of calling the server from a client script.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要`onLoad`客户端脚本的信息，那么考虑使用显示业务规则而不是从客户端脚本调用服务器。
- en: Using this method, we can obtain the information we need from the server from
    the display business rule before displaying a form. Then, we run client-side code
    in a client script that will be able to use the information we provided from the
    display business rule.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以在显示表单之前从显示业务规则中获取所需的服务器信息。然后，我们在客户端脚本中运行客户端代码，该代码将能够使用我们从显示业务规则中提供的信息。
- en: It is possible to clear the cache of an instance by navigating to your instance
    name and suffixing it with `/cache.do`. This clears the cache for you and can
    help when you want to ensure that your new script is being run, and cached data
    is not being used.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到您的实例名称并在其后附加`/cache.do`，可以清除实例的缓存。这会为您清除缓存，并在您想要确保新脚本正在运行且缓存数据未被使用时有所帮助。
- en: We can see the screen a user is shown when navigating to the page that clears
    the cache, here in *Figure 10.15*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到用户在导航到清除缓存页面时看到的屏幕，如图10.15所示。
- en: '![](img/61ee7e84-2e2a-410b-879b-9aa670c02095.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61ee7e84-2e2a-410b-879b-9aa670c02095.png)'
- en: 'Figure 10.15: Information provided on cache clearance'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：缓存清除提供的信息
- en: Clearing the cache for an instance, however, can cause performance degradation,
    so it is important to know when to do this. On non-production instances, this
    should not be a problem, as the performance decrease should not dramatically affect
    other developers. For a production instance though, this should be avoided during
    business hours where possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，清除实例的缓存可能会导致性能下降，因此了解何时进行此操作很重要。在非生产实例上，这通常不会成为问题，因为性能下降不应显著影响其他开发者。但对于生产实例，在可能的情况下应避免在办公时间内进行。
- en: When considering system performance, it is also worth checking the performance
    of the instance being used. This can be done using the ServiceNow performance
    home page that ServiceNow provides.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑系统性能时，还值得检查正在使用的实例的性能。这可以通过ServiceNow提供的性能主页来完成。
- en: 'Let''s have a look at some of the graphs that this home page provides:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个主页提供的某些图表：
- en: '![](img/e95682fd-8e0e-4e32-a6f7-0a8ec2702828.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e95682fd-8e0e-4e32-a6f7-0a8ec2702828.png)'
- en: 'Figure 10.16: System overview graphs sample'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：系统概述图表示例
- en: In the previously shown graphs, we can see an overview, transaction, response
    time, and active session graph. These can be helpful in finding out the current
    load on the instance and whether the response times are providing a good level
    of service.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前展示的图表中，我们可以看到概述、交易、响应时间和活跃会话图表。这些图表有助于了解实例当前的负载情况以及响应时间是否提供了良好的服务水平。
- en: The ServiceNow performance home page also displays many other graphs than the
    ones shown, which you can use. I tend to find the response times the most useful
    of the ones provided, but each graph can have its uses.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceNow性能主页还显示了比展示的更多的图表，您可以使用它们。我倾向于认为提供的响应时间是最有用的，但每个图表都有其用途。
- en: By keeping an eye on instance performance, you can be proactive in resolving
    potential system performance issues.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关注实例性能，您可以主动解决潜在的系统性能问题。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at best practices in ServiceNow. We looked at some
    of the best ways to use scripting in ServiceNow, and some bad practices to avoid.
    Our best practices included the areas of coding, business rules, and client scripts,
    as well as debugging, logs, queues, and system performance. We saw how these best
    practices work together to build a streamlined ServiceNow instance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了ServiceNow的最佳实践。我们探讨了在ServiceNow中使用脚本的一些最佳方法，以及一些应避免的坏习惯。我们的最佳实践包括编码、业务规则和客户端脚本领域，以及调试、日志、队列和系统性能。我们看到了这些最佳实践是如何协同工作以构建一个精简的ServiceNow实例的。
- en: In the next chapter, we will look at using update sets. Update sets are a big
    part of moving functionality between instances of ServiceNow, and are widely used.
    We will look at when and how to use update sets and how they work in relation
    to scope. We discover how to move update sets between instances and the pitfalls
    to avoid when doing so. Finally, we take a look at best practices with update
    sets, so you can make the most of the ServiceNow application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用更新集。更新集是ServiceNow实例之间移动功能的重要组成部分，并且被广泛使用。我们将讨论何时以及如何使用更新集，以及它们与范围的关系。我们将发现如何在不同实例之间移动更新集，以及在此过程中应避免的陷阱。最后，我们将探讨使用更新集的最佳实践，以便您能够最大限度地利用ServiceNow应用程序。
