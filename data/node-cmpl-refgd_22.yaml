- en: State
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: Now that we have created our microservice base layout on different frameworks,
    it's time to read our code more carefully and see if everything looks good. It's
    easy to just keep writing code and stop thinking about what we're doing, but later
    on, when we do stop for a while, we'll be wasting time deleting repeated code
    and reorganizing our service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在不同的框架上创建了我们的微服务基础布局，是时候更仔细地阅读我们的代码，看看一切是否看起来都很好了。只是继续编写代码而停止思考我们在做什么是很容易的，但后来当我们停下来的时候，我们会浪费时间删除重复的代码和重新组织我们的服务。
- en: 'It''s always better to think before we code. This is something you''ll learn
    with time, to value the time you dedicate to plan your service or think about
    a new feature. It''s never a good idea to just start coding. In theory, your **Service**
    should be inside a **Security** layer, with a good and stable connection to **State**:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编码之前总是先思考更好。这是随着时间的推移你会学到的东西，那就是重视你用来规划服务或思考新功能的时间。直接开始编码从来不是一个好主意。理论上，你的**服务**应该位于**安全**层内部，与**状态**有良好且稳定的连接：
- en: '![](img/0fafb30f-c4b5-4361-a42c-fc1ca74f7259.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fafb30f-c4b5-4361-a42c-fc1ca74f7259.png)'
- en: State
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: Think of state as a person's memory. Usually, a service has state, which means
    it has memory of actions and information it's serving. The idea is that our service
    will run indefinitely, but sometimes we're forced to restart it or even stop it
    for some time because of maintenance or an upgrade.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态视为一个人的记忆。通常，一个服务具有状态，这意味着它有它所提供的行为和信息记忆。我们的服务将无限期运行的设想是，但有时我们被迫重新启动它，甚至因为维护或升级而停止它一段时间。
- en: 'Ideally, a service should resume without losing state, giving its users the
    perception that it never stopped. This is achieved by doing one of two things:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，一个服务应该在不丢失状态的情况下恢复，给用户一种它从未停止的印象。这是通过做以下两件事之一来实现的：
- en: Having state stored in a persistent storage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态存储在持久存储中
- en: Saving state in a persistent storage before stopping and loading that state
    after restarting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在停止之前将状态保存在持久存储中，并在重启后加载该状态
- en: The first option will make your service a bit slower (nothing is faster than
    state in system memory) but should give you a more consistent state across restarts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择会使你的服务稍微慢一些（没有比系统内存中的状态更快的东西），但应该在你重启时提供更一致的状态。
- en: The second option is trickier, because sometimes our service might stop abruptly
    and be unable to save that state, but for those use cases, you may not care about
    the state. It's up to you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择更复杂，因为有时我们的服务可能会突然停止，无法保存该状态，但对于这些用例，你可能并不关心状态。这取决于你。
- en: There are a lot of options to store state; it will depend on what you want to
    store. For a microservice, you should avoid the filesystem so as to make your
    service more compatible with multiple operating systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 存储状态有很多选择；这取决于你想要存储什么。对于一个微服务，你应该避免文件系统，以便使你的服务与多个操作系统更兼容。
- en: Storing state
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储状态
- en: 'Depending on your service, you can store state using:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的服务，你可以使用以下方式存储状态：
- en: A **relational database management system** (**RDBMS**), such as MySQL or PostgreSQL
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系型数据库管理系统**（**RDBMS**），例如MySQL或PostgreSQL'
- en: A **non-relational database management system**, or NoSQL, such as MongoDB or
    RethinkDB
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非关系型数据库管理系统**，或NoSQL，例如MongoDB或RethinkDB'
- en: An **in-memory database** (**IMDB**), such as Redis or Memcached
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存数据库**（**IMDB**），例如Redis或Memcached'
- en: The first option is still the most commonly used one. You'll rely on stable
    and more than proven database systems that run in multiple systems and that you
    can find on any cloud service where you might want to deploy your microservice.
    Apart from the maturity of most solutions, a relational database, if properly
    set up, should give you consistency.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择仍然是使用最广泛的一种。你将依赖于稳定且经过充分证明的数据库系统，这些系统在多个系统中运行，并且你可以在任何你想要部署微服务的云服务中找到。除了大多数解决方案的成熟度之外，如果设置得当，关系数据库应该给你一致性。
- en: The second option is more recent compared to the first one. Usually, there are
    no fixed tables as in RDBMS, and you normally work with collections of documents
    that are just common JSON structures. It's more agile as there are usually no
    restrictions, and each document might have a different structure. The more agile,
    the less consistent.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一种选择相比，第二种选择更近。通常，没有像RDBMS那样的固定表，你通常与文档集合一起工作，这些文档只是常见的JSON结构。由于通常没有限制，并且每个文档可能具有不同的结构，因此它更灵活。越灵活，一致性越低。
- en: All three options, depending on the specific system you choose, support replication,
    which should enable fault tolerance and improve speed in geographically spaced
    instances.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择的特定系统，所有三种选项都支持复制，这应该能够实现容错并提高地理上分散的实例的速度。
- en: Let's try each of the three options using one of the suggested systems. Let's
    begin with the relational database, and use MySQL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用建议的系统之一来使用这三种选项中的每一个。让我们从关系型数据库开始，并使用 MySQL。
- en: MySQL
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL
- en: Installing MySQL is very simple. Just head to the official website and follow
    the instructions. You'll usually be asked for a password for the root user, which
    you can use later on to manage the server settings and user accounts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 MySQL 非常简单。只需访问官方网站并按照说明操作。您通常会被要求为 root 用户设置密码，您以后可以使用它来管理服务器设置和用户账户。
- en: There are some options to connect to a MySQL server using Node.js, but the best
    tools are the `mysql` and `mysql2` modules. They both serve the required purpose,
    and neither is the next version of the other, they're just a bit different in
    design and supported features.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node.js 连接到 MySQL 服务器有一些选项，但最好的工具是 `mysql` 和 `mysql2` 模块。它们都满足所需的功能，并且都不是对方的下一个版本，它们只是在设计和支持的功能上略有不同。
- en: 'First, let''s add the dependency to our service. On the terminal, go to our
    service folder and type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将依赖项添加到我们的服务中。在终端中，进入我们的服务文件夹并输入：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now include our dependency and configure a connection to the database.
    To avoid having the credentials in our code, we can create a separate file and
    put settings there that we may change in the future, and that shouldn't belong
    in the code. We can take advantage of Node.js being able to include JSON files,
    and just write our settings in JSON.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以包含我们的依赖项并配置数据库连接。为了避免在代码中包含凭证，我们可以创建一个单独的文件，并将设置放在那里，我们可以在将来更改这些设置，而且这些设置不应该包含在代码中。我们可以利用
    Node.js 能够包含 JSON 文件的能力，并直接将设置写入 JSON。
- en: 'Create a file called `settings.json`, and add the following content:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `settings.json` 的文件，并添加以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We defined a setting called `db` that has a database URI, which is a handy way
    of defining our database access and credentials using an address similar to any
    website address. Our database uses `mysql`; it's at `localhost` (using the default
    port), which can be accessed using the username `root` and the password `test`,
    and our database name is called `imagini`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `db` 的设置，它有一个数据库 URI，这是一种方便的方法，使用类似于任何网站地址的地址来定义我们的数据库访问和凭证。我们的数据库使用
    `mysql`；它在 `localhost`（使用默认端口），可以通过用户名 `root` 和密码 `test` 访问，我们的数据库名称为 `imagini`。
- en: 'We can now include the module and settings, and create the connection:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以包含模块和设置，并创建连接：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This module only connects to the database when you make a query. This means
    the service would start and you wouldn''t know whether your connection settings
    are correct until you make the first query. We don''t want to figure out we can''t
    connect to the database only when the service is used later on, so let''s force
    a connection and check if the server is running and accepts our connection:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块仅在您进行查询时连接到数据库。这意味着服务将启动，您直到进行第一次查询之前都不会知道您的连接设置是否正确。我们不希望在服务稍后使用时才发现无法连接到数据库，所以让我们强制连接并检查服务器是否正在运行并接受我们的连接：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This way, if anything is wrong with the database, the service won''t start
    and will throw an exception, which will notify you to check what''s wrong. Here''s
    an example of a possible error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果数据库有任何问题，服务将无法启动并抛出异常，这会通知你检查哪里出了问题。以下是一个可能的错误示例：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This indicates you probably typed the password incorrectly, or the user doesn't
    match, or even the hostname or database may be wrong. Ensuring you connect to
    the database before setting up the service means your service won't be exposed
    to the public without a proper state.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你可能输入了错误的密码，或者用户不匹配，甚至主机名或数据库名可能错误。在设置服务之前确保您连接到数据库意味着您的服务在没有适当状态的情况下不会被公开。
- en: 'Our microservice has a very simple state, so to speak. Our state is the images
    previously uploaded. Instead of using the filesystem, we can now use the database
    and create a table to store them all:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 说到我们的微服务，它的状态非常简单。我们的状态是之前上传的图片。我们不仅可以使用文件系统，现在还可以使用数据库并创建一个表来存储它们：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can issue this query every time the service starts because it will create
    the images table only if it doesn't exist already. If we don't change its structure,
    it's fine to always do this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在服务每次启动时执行此查询，因为它只会在表不存在时创建图像表。如果我们不更改其结构，总是这样做是可以的。
- en: You can see we're creating a table with a unique identification number (`id`),
    a creation date (`date_created`), a date to know when our image has been used(`date_used`),
    the `name` of the image, the `size` of it in bytes, and the image `data`. The
    size is a little redundant here as we could just check the data length, but bear
    with me, this is just an example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们正在创建一个具有唯一识别号（`id`）、创建日期（`date_created`）、知道我们的图像何时被使用的日期（`date_used`）、图像的`name`、以字节为单位的图像`size`和图像`data`的表。大小在这里有点多余，因为我们可以直接检查数据长度，但请耐心，这只是一个例子。
- en: We also defined our name as a unique key, meaning it has an index for quickly
    finding images by name, and also ensures our name does not repeat and that no
    one can overwrite an image (without removing it first).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也将我们的名称定义为一个唯一的键，这意味着它有一个索引，可以快速通过名称查找图像，同时也确保我们的名称不会重复，并且没有人可以覆盖一个图像（除非先删除它）。
- en: 'Having the images stored this way on a database table gives you several advantages,
    such as regarding:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像以这种方式存储在数据库表中，给你带来几个优势，例如：
- en: How many images you have
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有多少张图像
- en: The size of every image and the total size
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每张图像的大小和总大小
- en: When the images were created and last used
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的创建时间和最后使用时间
- en: It also enables you to improve your service; for example, you can delete images
    that are not used for longer than a specific time period. You can also make this
    dependent on the image sizes. Later, you can add authentication (mandatory or
    not) and have user-specific rules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使你能够改进你的服务；例如，你可以删除长时间未使用的图像。你还可以根据图像大小来设置这个条件。稍后，你可以添加认证（强制或非强制）并设置用户特定的规则。
- en: It's also easy to back up and replicate the state to another site. There are
    plenty of tools for backing up databases, and you can have another MySQL server
    acting as a slave to this one and have your images replicated in real time to
    another geographical location.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很容易备份并将状态复制到另一个站点。有许多用于备份数据库的工具，你可以拥有另一个充当从属服务器的MySQL服务器，并将你的图像实时复制到另一个地理位置。
- en: Let's change our service from the previous chapter to use our table instead
    of the previously used folder on our filesystem.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的服务从上一章改为使用我们的表，而不是之前在文件系统上使用的文件夹。
- en: 'We can remove our  `fs` module dependency (don''t remove the path dependency
    for now):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除我们的`fs`模块依赖（现在不要移除路径依赖）：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our `app.param` is completely different. We now validate the `image` against
    our `image` table. If it doesn''t find it, it returns code `404`. If it does find
    it, it stores the `image` information in `req.image`. We can now change our `image`
    upload to store the `image` on our table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`app.param`完全不同。我们现在验证`image`是否与我们的`image`表匹配。如果没有找到，它返回代码`404`。如果找到了，它将`image`信息存储在`req.image`中。我们现在可以将我们的`image`上传改为将`image`存储在我们的表中：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Uploading images no longer use the filesystem and instead creates a new row
    on our table. We don''t need to specify the `id` as it''s automatic. Our creation
    date is also automatic as it defaults to the current timestamp. Our use date defaults
    to `NULL`, which means we haven''t used the `image` yet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上传图像不再使用文件系统，而是在我们的表中创建一个新的行。我们不需要指定`id`，因为它会自动生成。我们的创建日期也是自动的，默认为当前时间戳。我们的使用日期默认为`NULL`，这意味着我们还没有使用过`image`：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our `image` check method now gets extremely simple as it relies on the previous
    `app.param` to check whether the `image` exists, so, if we get to this point,
    we already know the image exists (it's on `req.image`), so we just need to return
    the code `200`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`image`检查方法现在变得极其简单，因为它依赖于之前的`app.param`来检查图像是否存在，所以，如果我们到达这个点，我们已经知道图像存在（它在`req.image`上），所以我们只需要返回代码`200`。
- en: 'Before updating our image `fetch` method, let''s try our service. If you start
    it on the console, you can immediately open any MySQL administration tool and
    check our database. I''m using Sequel Pro for macOS. Although there''s a Pro in
    the name, it''s free software and it''s damn good:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新我们的图像`fetch`方法之前，让我们尝试我们的服务。如果你在控制台启动它，你可以立即打开任何MySQL管理工具并检查我们的数据库。我使用的是Sequel
    Pro for macOS。尽管名字中有Pro，但它是一款免费软件，而且非常好用：
- en: '![](img/65b81b98-1531-4dfd-9cc2-1987f3662fcc.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65b81b98-1531-4dfd-9cc2-1987f3662fcc.png)'
- en: 'Our table was created, and you can check it has all the properties and indexes
    we defined. Let''s now upload an `image` once again:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表已创建，你可以检查它是否具有我们定义的所有属性和索引。现在让我们再次上传一个`image`：
- en: '![](img/51f3e97d-d8ed-4e1f-9d58-0fb7277a8c99.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51f3e97d-d8ed-4e1f-9d58-0fb7277a8c99.png)'
- en: 'As before, it returns a JSON response with a success status and the size of
    the `image`. If you look at Sequel again, on the content separator, you''ll see
    our images data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，它返回一个包含成功状态和`image`大小的JSON响应。如果你再次查看Sequel，在内容分隔符上，你会看到我们的图片数据：
- en: '![](img/8abacb08-a0fd-4724-9b17-2280b0cd71ab.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8abacb08-a0fd-4724-9b17-2280b0cd71ab.png)'
- en: 'Let''s try and upload the `image` again. Previously, our service would just
    overwrite it. Now, because of our unique index, it should deny an `INSERT` with
    the same name:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试上传`image`。之前，我们的服务会直接覆盖它。现在，由于我们的唯一索引，它应该拒绝具有相同名称的`INSERT`操作：
- en: '![](img/44849b11-4ec0-40e4-92cb-d6604f5515cc.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44849b11-4ec0-40e4-92cb-d6604f5515cc.png)'
- en: Great! The `ER_DUP_ENTRY` is the MySQL code for duplicate insertion. We can
    rely on that and deny overwriting images.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！`ER_DUP_ENTRY`是MySQL的重复插入代码。我们可以依赖它并拒绝覆盖图片。
- en: 'We can also check whether our `image` exists using the `check` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`check`方法来检查我们的`image`是否存在：
- en: '![](img/b2f9f4a5-884f-444e-b8ae-2de6bcf310ba.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2f9f4a5-884f-444e-b8ae-2de6bcf310ba.png)'
- en: 'If we use another name, we''ll get a code `404`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用另一个名称，我们会得到一个代码`404`：
- en: '![](img/c33c9c5a-0af8-4b77-b65b-08cdd3acd9b6.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c33c9c5a-0af8-4b77-b65b-08cdd3acd9b6.png)'
- en: 'It looks like everything is working great. Let''s now change our final method,
    the `image` manipulation one. This method is almost the same; we just don''t have
    to read the `image` file, as it''s already available:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都很顺利。现在让我们改变我们的最终方法，即`image`操作方法。这个方法几乎一样；我们只是不需要读取`image`文件，因为它已经可用：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see how we used the path dependency to get the extension of the `image`
    name. The rest is the same. We just add an update to our image every time we request
    this method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们如何使用路径依赖来获取`image`名称的扩展名。其余的都是一样的。我们只是在每次请求此方法时更新我们的`image`。
- en: 'We can use a web browser to test our method and see our previously uploaded
    image:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用网络浏览器来测试我们的方法并查看我们之前上传的图片：
- en: '![](img/88605934-5962-4af5-b5fb-821ef77a428d.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88605934-5962-4af5-b5fb-821ef77a428d.png)'
- en: 'Everything should just work as before because we haven''t changed our image
    manipulation dependency, so blurring and the other actions should work as expected:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都应该和之前一样正常工作，因为我们没有更改我们的图像处理依赖项，所以模糊和其他操作应该按预期工作：
- en: '![](img/6cd78552-7907-4854-b1fc-27fd4eb936a4.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cd78552-7907-4854-b1fc-27fd4eb936a4.png)'
- en: 'We can now improve our service and add a method we didn''t expose before: deleting
    an `image`. To do that, we can use the `DELETE` verb from HTTP and just remove
    the `image` from our table:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以改进我们的服务并添加一个我们之前没有公开的方法：删除`image`。为此，我们可以使用HTTP的`DELETE`动词并从我们的表中删除`image`：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We just have to check whether the query resulted in an error. If so, we respond
    with a code `500` (internal server error). If not, we respond with the usual code
    `200`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要检查查询是否导致错误。如果是这样，我们以代码`500`（内部服务器错误）响应。如果不是，我们以通常的代码`200`响应。
- en: 'Let''s restart our microservice and try to delete our `image`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新启动我们的微服务并尝试删除我们的`image`：
- en: '![](img/f332e424-4eb1-4153-9c9e-0807469373fe.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f332e424-4eb1-4153-9c9e-0807469373fe.png)'
- en: 'It looks like it worked; it responded with a code `200`. If we try to open
    our image in the web browser, we should see something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它工作了；它以代码`200`响应。如果我们尝试在网页浏览器中打开我们的图片，我们应该看到类似这样的内容：
- en: '![](img/eced36f5-8a89-4228-ad2f-779c7b69b60a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eced36f5-8a89-4228-ad2f-779c7b69b60a.png)'
- en: 'On Sequel, the table should now be empty too:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sequel中，表现在也应该为空：
- en: '![](img/480a78b6-72cc-4286-bb0e-719f3fea3f71.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/480a78b6-72cc-4286-bb0e-719f3fea3f71.png)'
- en: We now have a functional microservice with a state that persists across restarts,
    as we intended. You can now deploy to any cloud service with no dependency on
    the filesystem, just a database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个具有跨重启持久状态的实用微服务，正如我们预期的。你现在可以部署到任何云服务，无需依赖文件系统，只需数据库即可。
- en: You could easily change MySQL to another database or use an **o****bject relational ****mapping**
    (**ORM**) module to enable you to change database server without changing your
    code. An ORM is a library that allows you to use a common interface to access
    different types of databases. Usually, this kind of abstraction involves not using
    SQL at all and reducing your interaction with the databases to simpler queries
    (to allow for interoperability between database servers).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地将MySQL更改为另一个数据库，或者使用**对象关系映射**（**ORM**）模块来使你能够在不更改代码的情况下更改数据库服务器。ORM是一个库，它允许你使用一个通用接口来访问不同类型的数据库。通常，这种抽象涉及根本不使用SQL，并将你与数据库的交互简化为更简单的查询（以允许数据库服务器之间的互操作性）。
- en: Let's take this opportunity to go a little further and add a few methods that
    got simplified by this migration to the database. Let's create a method that exposes
    statistics about our database, and let's remove old images.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们抓住这个机会，更进一步，添加一些由于这次迁移而被简化的数据库中的方法。让我们创建一个公开数据库统计信息的方法，并删除旧图像。
- en: 'Our first statistics method should just return a JSON structure with some useful
    information. Let''s expose the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种统计方法应该只返回一个包含一些有用信息的JSON结构。让我们公开以下内容：
- en: The total number of images
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的总数
- en: The total size of the images
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的总大小
- en: How long our service is running
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的服务运行了多久
- en: When the last time was that we uploaded an image
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上次我们上传图像的时间
- en: 'Here''s an example of how our statistics method could look:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个我们的统计方法可能看起来像的例子：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Restart the service, and let''s try it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务，让我们试试：
- en: '![](img/277cd1a8-085e-410c-b712-0e6d1f58d1f2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/277cd1a8-085e-410c-b712-0e6d1f58d1f2.png)'
- en: As we can see, we have no images as we just removed our image previously. There's
    no size because we have no images. There's also no used date, and the service
    uptime is 5 seconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们没有图像，因为我们刚刚删除了我们的图像。没有大小，因为我们没有图像。也没有使用日期，服务运行时间为5秒。
- en: 'If we upload our previous image, we will get different results, something like
    the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们上传之前的图像，我们将得到不同的结果，就像以下截图所示：
- en: '![](img/ac4b4b76-7cad-4ba4-b35e-40b11c7ca310.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac4b4b76-7cad-4ba4-b35e-40b11c7ca310.png)'
- en: Now, for our second task, deleting old images, we need to check our database
    periodically. We'll use an interval timer and just run a `DELETE` query. The intervals
    mentioned in the following query are just an example; you can write the conditions
    you want.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们的第二个任务，删除旧图像，我们需要定期检查我们的数据库。我们将使用间隔计时器并运行一个`DELETE`查询。以下查询中提到的间隔只是一个例子；你可以编写你想要的条件。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This query deletes `images` that were not used in the past month (but were used
    before) or images that were not used in the past week (and never used before).
    This means that images uploaded need to be used at least once or they will get
    removed quickly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询删除了在过去一个月内未使用（但之前使用过）的`images`或在过去一周内未使用（且从未使用过）的图像。这意味着上传的图像至少需要使用一次，否则它们将很快被删除。
- en: You can think of a different strategy, or use no strategy and delete manually
    if you want. Now that we've seen MySQL, let's move on and look at another kind
    of database server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想一个不同的策略，或者如果你愿意，不使用策略并手动删除。现在我们已经看到了MySQL，让我们继续看看另一种类型的数据库服务器。
- en: Adding code coverage
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加代码覆盖率
- en: Now that our test suite is working and has one test, let's introduce code coverage.
    Adding this from the beginning of development is very easy and will help us focus
    on parts of the code that need to be tested, especially some use cases that involve
    specific conditions (such as `if-then-else` statements in our code). Having it
    all set up from the start of development is easy. On the other hand, if you have
    a fully working code and want to add tests and coverage, it will be harder and
    will take quite some time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个正在工作的测试套件和一个测试，让我们引入代码覆盖率。从开发初期开始添加这个功能非常容易，并将帮助我们关注需要测试的代码部分，特别是涉及特定条件的一些用例（例如我们代码中的`if-then-else`语句）。从开发初期开始设置它很容易。另一方面，如果你有一个完全工作的代码，并想添加测试和覆盖率，这将更困难，并且需要相当长的时间。
- en: 'To add code coverage, we''ll introduce another module. We''ll install it globally
    to be able to run the tests with it directly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加代码覆盖率，我们将引入另一个模块。我们将全局安装它，以便能够直接使用它运行测试：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now run our tests with the following instrumentation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下仪器运行我们的测试：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This should run our tests with the instrumentation installed. In the end, you'll
    get a nice console report.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会运行我们的测试，同时安装了仪器。最后，你将得到一个漂亮的控制台报告。
- en: '![](img/99619f27-c68e-49d6-8b6a-a3ad0178c91a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99619f27-c68e-49d6-8b6a-a3ad0178c91a.png)'
- en: The coverage results are stored inside in a `.nyc_output` folder. This enables
    you to look at the last test results without running tests again. This is useful
    if your test suite is big and takes some time to finish.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率结果存储在`.nyc_output`文件夹中。这使得你可以在不再次运行测试的情况下查看最后的测试结果。如果你的测试套件很大且需要一些时间才能完成，这很有用。
- en: 'To see the results, you just run `nyc report`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，只需运行`nyc report`：
- en: '![](img/bd9cb784-7cdb-4a9f-8136-5c8c2e133c2a.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd9cb784-7cdb-4a9f-8136-5c8c2e133c2a.png)'
- en: 'The result is a console report. There are several other styles of reports.
    One particularly useful one is the `html` report. Let''s generate it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个控制台报告。还有几种其他类型的报告。其中一个特别有用的是`html`报告。让我们生成它：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should now have a `coverage` folder with an `index.html` file. Open that
    in your browser, and you should see something like the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有一个包含`index.html`文件的`coverage`文件夹。在浏览器中打开它，你应该会看到以下截图：
- en: '![](img/90266f17-41c9-456b-ae43-f238f88d56bb.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90266f17-41c9-456b-ae43-f238f88d56bb.png)'
- en: We only have one file that represents our microservice. If we had more, they
    would be listed hierarchically. There are global average statistics for every
    file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个文件代表我们的微服务。如果有更多，它们将按层次列出。每个文件都有全局平均统计数据。
- en: 'There are three important groups of columns:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有三组重要的列：
- en: '**Statements**: Which represent code statements (conditions, assignments, assertions,
    calls, and so on)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句**：代表代码语句（条件、赋值、断言、调用等）'
- en: '**Branches**: Which represent possible code control workflows, such as if-then-else
    or switch-case statement possibilities'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支**：代表可能的代码控制工作流程，例如if-then-else或switch-case语句的可能性'
- en: '**Functions**: Which represent our actual code functions and callbacks'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：代表我们的实际代码函数和回调'
- en: 'You can click in our file, look at the specific details of it and, more specifically,
    see the code and information line by line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们的文件上点击，查看其具体细节，更具体地说，可以逐行查看代码和信息：
- en: '![](img/9331f44e-72e3-4ca6-ab78-8be70c2f63e8.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9331f44e-72e3-4ca6-ab78-8be70c2f63e8.png)'
- en: To the right of every line number, you see a gray area and, in this case, you
    see `2x` in some of the lines. This is the execution count for that line. The
    execution has passed by that line twice. This is actually not that important,
    unless you're looking for bits of code that get largely executed and you want
    to do some kind of optimization.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行数字的右侧，你看到一个灰色区域，在这种情况下，你会在一些行中看到`2x`。这是该行的执行次数。该行被执行了两次。这实际上并不重要，除非你在寻找大量执行的代码片段并想进行某种优化。
- en: 'You can also see that *line 12* has two changes. First, there''s a pinkish
    background in the back of `throw err`. That means that statement never got executed,
    which is normal for now as we always successfully connected to the database. The
    mark before the `if` statement means that the condition never got executed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到第12行有两个变化。首先，在`throw err`后面有一个粉红色的背景。这意味着该语句从未被执行，这在目前是正常的，因为我们总是成功连接到数据库。`if`语句前的标记表示该条件从未被执行：
- en: '![](img/0945b756-7b35-43c7-ae99-dd753f2e554f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0945b756-7b35-43c7-ae99-dd753f2e554f.png)'
- en: If you scroll a few lines down, we'll see more lines with marks. For example,
    we can see our image upload method got almost completely covered. The only statement
    missing is the error handling.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向下滚动几行，我们会看到更多带有标记的行。例如，我们可以看到我们的图片上传方法几乎被完全覆盖。唯一缺失的是错误处理。
- en: As we delete our test image before running the tests, our image deletion method
    is also covered. Again, the only missing branch is if the database returns an
    error to our `DELETE` query.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在运行测试之前删除了测试图像，我们的图像删除方法也得到了覆盖。再次强调，唯一缺失的分支是如果数据库返回错误到我们的`DELETE`查询。
- en: 'Before going any further with the image upload, let''s add another `integration`
    test file called `image-parameter.js`, and add some tests to increase our coverage:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步处理图片上传之前，让我们添加另一个名为`image-parameter.js`的`integration`测试文件，并添加一些测试来提高我们的覆盖率：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s run our test suite and see how it goes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试套件并看看结果如何：
- en: '![](img/44cfd9bd-5ed2-43df-9b75-925c62c0c5da.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44cfd9bd-5ed2-43df-9b75-925c62c0c5da.png)'
- en: 'Refresh the HTML report page and look at our parameter method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新HTML报告页面，查看我们的参数方法：
- en: '![](img/feb5c546-faf8-48dd-9033-b7d921f98985.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/feb5c546-faf8-48dd-9033-b7d921f98985.png)'
- en: 'As you can see, we now cover the following condition:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在覆盖了以下条件：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following condition:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下条件：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now have full coverage on this method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对这个方法有了全面的覆盖。
- en: There are other coverage lines that are harder to test, such as timers (you
    can see one on *line 28*), `catch` statements, or external errors coming from
    databases or other storage sources. There are ways of mocking those events, and
    we'll cover them later on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他一些更难测试的覆盖行，例如计时器（你可以在*第28行*看到一个），`catch`语句，或者来自数据库或其他存储源的外部错误。有方法来模拟这些事件，我们稍后会讨论。
- en: RethinkDB
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RethinkDB
- en: 'Let''s see the differences for a non-relational database using RethinkDB. If
    you don''t have it, just install it by following the official documentation ([https://www.rethinkdb.com/docs/](https://www.rethinkdb.com/docs/)).
    Let''s just start the server:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用RethinkDB的非关系型数据库的差异。如果你没有它，只需按照官方文档（[https://www.rethinkdb.com/docs/](https://www.rethinkdb.com/docs/)）进行安装。让我们先启动服务器：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will start the server, which comes with a very nice administration console
    on port `8080`. You can open it in the web browser:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动服务器，它附带一个非常好的管理控制台，端口为`8080`。你可以在网页浏览器中打开它：
- en: '![](img/8a25af14-fa51-4597-9eff-d47bcde127d9.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a25af14-fa51-4597-9eff-d47bcde127d9.png)'
- en: 'Go to the Tables section on top to see the databases:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前往顶部的“表”部分查看数据库：
- en: '![](img/b2a5cad5-13fc-40b5-9aa5-c36694406605.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2a5cad5-13fc-40b5-9aa5-c36694406605.png)'
- en: 'Create a database called `imagini` using the Add Database button. You should
    now have our database ready. You need nothing else here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“添加数据库”按钮创建一个名为`imagini`的数据库。现在你应该已经有了我们的数据库准备就绪。这里你不需要其他任何东西：
- en: '![](img/5be39ecd-34f7-42c4-8266-fbad8ad61e0b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5be39ecd-34f7-42c4-8266-fbad8ad61e0b.png)'
- en: 'To use our new database, we need to install the `rethinkdb` dependency. You
    can remove the MySQL dependency:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们新的数据库，我们需要安装`rethinkdb`依赖项。你可以移除MySQL依赖项：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s change our `settings` file. This module doesn''t accept a connection
    string, so we''ll use a JSON structure:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改变我们的`settings`文件。这个模块不接受连接字符串，所以我们将使用JSON结构：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To include our dependency, we just need to include the module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含我们的依赖项，我们只需要包含这个模块：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, use this to connect to our server:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用这个来连接到我们的服务器：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After connecting, we can create our table as we did before. This time, we don''t
    need to specify any structure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，我们可以像之前一样创建我们的表。这次，我们不需要指定任何结构：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `rethinkdb` object is the one we'll use to manipulate our table, and the
    `db` object is a connection object used to reference the connection and to indicate
    where to run our manipulations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`rethinkdb`对象是我们用来操作我们的表的，而`db`对象是一个连接对象，用于引用连接并指示在哪里运行我们的操作。'
- en: 'If you restart our service just like this, you''ll see a new table on our previously
    created database:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像这样重启我们的服务，你会在之前创建的数据库中看到一个新表：
- en: '![](img/976d103d-a00f-4bc1-b830-ada32e107310.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/976d103d-a00f-4bc1-b830-ada32e107310.png)'
- en: 'If you restart our service again, you''ll get an error trying to create the
    table that already exists. We need to check whether it already exists, and only
    issue the command if not:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次重启我们的服务，尝试创建已经存在的表时会出错。我们需要检查它是否已经存在，并且只有在不存在的情况下才发出命令：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Moving on, our upload method should be changed slightly to something like the
    following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的上传方法应该稍微改变一下，如下所示：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you restart the server just like this, you should be able to upload an `image`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像这样重启服务器，你应该能够上传一个`image`：
- en: '![](img/5591f6a1-af2d-414b-9d22-9b5defb7c872.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5591f6a1-af2d-414b-9d22-9b5defb7c872.png)'
- en: 'We receive the same response, just like with MySQL. We can go to the Data Explorer
    section in the administration console and get our record to see whether it''s
    there:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到相同的响应，就像MySQL一样。我们可以进入管理控制台中的数据探索器部分，获取我们的记录以查看它是否在那里：
- en: '![](img/b05c2929-88d4-46bb-aa48-61055e014f06.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b05c2929-88d4-46bb-aa48-61055e014f06.png)'
- en: Looks good. Notice our record ID is not a number, it's a **Universally Unique
    Identifier** (**UUID**). This is because RethinkDB has support for sharding (our
    table is sharded by default if there was more than one server) and it's easier
    to shard unique identifiers than an incremental number.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。注意我们的记录ID不是一个数字，它是一个**通用唯一标识符**（**UUID**）。这是因为RethinkDB支持分片（如果有多于一个服务器，我们的表默认是分片的）并且相对于递增数字，分片唯一标识符更容易。
- en: 'Moving on to our Express parameter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的Express参数：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this change, we can now restart our service and see whether our `image`
    exists:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，我们现在可以重启我们的服务并查看我们的`image`是否存在：
- en: '![](img/cf087587-648d-4091-aa9f-e0d9a8a15fd7.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf087587-648d-4091-aa9f-e0d9a8a15fd7.png)'
- en: 'We need to change the download just a little bit. We need to remove the previous
    query to update our usage date and replace it with a new one:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要稍微改变一下下载方式。我们需要删除之前的查询以更新我们的使用日期，并用一个新的查询替换它：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now download our image using the web browser:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用网络浏览器下载我们的图片：
- en: '![](img/454e1973-472e-414f-af6e-2b0abbb621ea.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/454e1973-472e-414f-af6e-2b0abbb621ea.png)'
- en: 'Next, we need to update our image removal method. It''s as easy as our upload:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的图片删除方法。它就像我们的上传一样简单：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time, we used the image unique ID to remove it. If we try again using
    the `curl` command, we''ll receive a code `200`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用了图片的唯一 ID 来删除它。如果我们再次使用 `curl` 命令尝试，我们会收到一个代码 `200`：
- en: '![](img/e8c95a69-2e76-4e9d-b83f-7990119543e7.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8c95a69-2e76-4e9d-b83f-7990119543e7.png)'
- en: 'If we try to get the first record of our table, we''ll see there''s nothing
    there:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试获取我们表的第一条记录，我们会看到那里什么也没有：
- en: '![](img/600662dc-1ded-4417-a286-899f773f6fc1.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/600662dc-1ded-4417-a286-899f773f6fc1.png)'
- en: 'Finally, there are our two extra features that we added after introducing MySQL:
    the statistics and removing old unused images.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们引入 MySQL 后添加的两个额外功能：统计和删除旧的不用图片。
- en: 'Our statistics method is not so simple as running an SQL query with aggregations.
    We must calculate each of our statistics:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的统计方法并不像运行带有聚合的 SQL 查询那样简单。我们必须计算我们每个统计量：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We should have a similar result to before:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到与之前相似的结果：
- en: '![](img/81ddd5ab-115d-42c0-867b-95a7319a2555.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81ddd5ab-115d-42c0-867b-95a7319a2555.png)'
- en: 'Removing old images is more or less easy; we just need to filter the images
    we want to remove, and then remove them:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 删除旧图片相对容易；我们只需要过滤掉我们想要删除的图片，然后删除它们：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I simplified the previous strategy and am just removing `images` older than 1
    month (30 days, times 86,400 seconds a day, times 1,000 milliseconds).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我简化了之前的策略，只是删除了1个月（30天，每天86,400秒，每天1,000毫秒）之前的 `images`。
- en: Redis
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis
- en: In-memory databases are different from the previous two types, as they're usually
    not structured, which means you have no tables. What you have is normally lists
    of some kind that you can look up and manipulate, or simple hash tables.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 内存数据库与前面两种类型不同，因为它们通常不是结构化的，这意味着你没有任何表。你通常有一些可以查找和操作的类型列表，或者简单的哈希表。
- en: 'Taking advantage of the Redis instance we installed previously for Hydra, let''s
    see another drawback, or actually feature, of this kind of database. Let''s connect
    to our Redis instance and make the following sequence of instructions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们之前为 Hydra 安装的 Redis 实例，让我们看看这种数据库的另一个缺点，或者实际上是特性。让我们连接到我们的 Redis 实例并执行以下指令序列：
- en: '![](img/2b204f94-7078-4020-9b1d-bf1f62f402cc.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b204f94-7078-4020-9b1d-bf1f62f402cc.png)'
- en: 'What we did here was to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是：
- en: Connect to the Redis service using `redis-cli`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `redis-cli` 连接到 Redis 服务。
- en: Get the content of the counter, which is nil (nothing), because we haven't defined
    it yet.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取计数器的内容，它是 nil（无），因为我们还没有定义它。
- en: Increment the counter, which is now automatically defined and set to `1`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加计数器，现在是自动定义并设置为 `1`。
- en: Increment the counter again, which is now `2`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次增加计数器，现在是 `2`。
- en: Get the content of the counter, which is of course `2`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取计数器的内容，当然是 `2`。
- en: Shut down the Redis service.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 Redis 服务。
- en: Start the Redis service.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Redis 服务。
- en: Connect to the Redis service again.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次连接到 Redis 服务。
- en: Get the content of the counter, which is nil (nothing).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取计数器的内容，它是 nil（无）。
- en: Where's our counter? Well, this is an in-memory database, so everything is gone
    when we shut down the Redis service. This is the design of almost all kinds of
    in-memory databases.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计数器在哪里？嗯，这是一个内存数据库，所以当我们关闭 Redis 服务时，一切都会消失。这是几乎所有内存数据库的设计。
- en: They're designed to be fast and in-memory. Their purpose is normally to cache
    data that is expensive to get, such as some complex calculations, or extensive
    to download, and we want that to be available faster (in-memory).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被设计成快速和内存中的。它们的目的通常是缓存那些获取成本高昂的数据，比如一些复杂的计算，或者下载量大的数据，我们希望它们能够更快地可用（内存中）。
- en: I wasn't completely fair with Redis as it actually allows your data to be saved
    between service restarts. So, let's see how far we can go in using it to save
    our microservice state.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 Redis 并不完全公平，因为它实际上允许你的数据在服务重启之间被保存。所以，让我们看看我们可以用它来保存我们的微服务状态有多远。
- en: 'As before, let''s uninstall `rethinkdb` and install the `redis` module:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们卸载 `rethinkdb` 并安装 `redis` 模块：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's ignore our `settings.json` file (you can remove it if you prefer) and
    assume Redis will be on our local machine.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们忽略我们的`settings.json`文件（如果你喜欢，你可以将其删除）并假设Redis将运行在我们的本地机器上。
- en: 'First, we need to include the `redis` module and create a `Client` instance:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要包含`redis`模块并创建一个`Client`实例：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then need to wait until it connects:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要等待它连接：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are a couple of ways we can use Redis to store our data. To make it simple,
    as we don't have tables, let's use hashes to store our images. Each image will
    have a different hash, and the name of the hash will be the name of the image.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Redis存储我们的数据的方式有很多种。为了简单起见，因为我们没有表，让我们使用散列来存储我们的图像。每个图像将有一个不同的散列，散列的名称将是图像的名称。
- en: As there are no tables in this kind of database, our initialization code can
    just be removed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种类型的数据库中没有表，我们的初始化代码可以简单地删除。
- en: 'Next, let''s change our upload method to store data on Redis. As I mentioned,
    let''s store it in a hash with the name of the `image`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更改我们的上传方法，以便在Redis上存储数据。正如我提到的，让我们将其存储在以`image`命名的散列中：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `hmset` command lets us set multiple fields of a hash, in our case, `size`
    and `data`. Notice we''re storing our image content in `base64` encoding, otherwise
    we''ll lose data. If we restart our service and try to upload our test `image`,
    it should work fine:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`hmset`命令允许我们设置散列的多个字段，在我们的例子中，是`size`和`data`。注意我们以`base64`编码存储我们的图像内容，否则我们会丢失数据。如果我们重启我们的服务并尝试上传我们的测试`image`，它应该可以正常工作：'
- en: '![](img/69d28e98-498a-4a5f-8dca-9532bb9027e6.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69d28e98-498a-4a5f-8dca-9532bb9027e6.png)'
- en: 'We can then use `redis-cli` and see whether our image is there. Well, we''re
    checking to see whether our hash has the field size and matches our image size:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`redis-cli`查看我们的图像是否在那里。嗯，我们正在检查散列是否具有字段大小并且与我们的图像大小匹配：
- en: '![](img/3112df7b-958f-4b55-97c6-d3623d694963.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3112df7b-958f-4b55-97c6-d3623d694963.png)'
- en: 'Great! We can now change our Express parameter to look for the `image` hash:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们可以更改我们的Express参数，以查找`image`散列：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our `image` check method should work now. And, for our download method to work,
    we just need to change the image loading to decode our previous `base64` encoding:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`image`检查方法现在应该可以工作。而且，为了我们的下载方法能够工作，我们只需要将图像加载更改为解码我们之前的`base64`编码：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our images are now being served from Redis. As a bonus, we''re adding/updating
    a `date_used` field in our `image` hash to indicate when it was last used:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正从Redis中提供图像。作为额外的好处，我们在`image`散列中添加/更新了一个`date_used`字段，以指示它最后一次被使用的时间：
- en: '![](img/c617c24a-e4df-4878-a442-2ce3ff909f1b.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c617c24a-e4df-4878-a442-2ce3ff909f1b.png)'
- en: 'Removing our `image` is as simple as removing our hash:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 删除我们的`image`就像删除我们的散列一样简单：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then try to remove our `test` image:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试删除我们的`test`图像：
- en: '![](img/3557032f-1cf1-42f1-9943-00c31ef5fd66.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3557032f-1cf1-42f1-9943-00c31ef5fd66.png)'
- en: 'Using `redis-cli` to check whether the hash exists, we see that it''s gone:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`redis-cli`检查散列是否存在，我们看到它已经消失了：
- en: '![](img/716dfce9-3eaa-405a-ac5f-91f5bdd7424a.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/716dfce9-3eaa-405a-ac5f-91f5bdd7424a.png)'
- en: The only two features missing are the statistics and removing old images.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的只有两个功能：统计信息和删除旧图像。
- en: For the statistics, that could be hard as we're using generic hash tables and
    we can't be sure how many hash tables are defined, and if all or any have image
    data. We would have to scan all hash tables, which is complex for large sets.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统计信息，这可能很困难，因为我们使用的是通用的散列表，我们无法确定定义了多少个散列表，以及是否所有或任何散列表都有图像数据。我们可能需要扫描所有散列表，这对于大型集合来说很复杂。
- en: To remove old images, the problem is the same as there's no way of looking for
    hash tables with a specific condition, such as a field value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除旧图像，问题与查找具有特定条件（如字段值）的散列表的方式相同。
- en: There are still other paths available to tackle this problem. For example, we
    could have another hash table with just our image names and use dates. But, the
    complexity would increase, and the integrity could be at risk as we're splitting
    information through different hash tables with no certainty of making **Atomicity**,
    **Consistency**, **Isolation**, and **Durability** (**ACID**) operations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有其他路径可以解决这个问题。例如，我们可以有一个包含我们图像名称的另一个散列表，并使用日期。但是，复杂性会增加，而且由于我们通过不同的散列表分割信息而没有确保**原子性**、**一致性**、**隔离性**和**持久性**（**ACID**）操作，完整性可能会受到风险。
- en: Conclusion
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: As we've seen, there are plenty of options to store our microservice state.
    Depending on the type of information we're manipulating, there are databases better-prepared
    to handle our data.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，有许多选项可以存储我们的微服务状态。根据我们操作的信息类型，有一些数据库更适合处理我们的数据。
- en: 'It all depends on a few different questions we should ask ourselves:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都取决于我们应该问自己的一些不同的问题：
- en: Is our data integrity important?
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的数据完整性重要吗？
- en: Is our data structure complex?
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的数据结构复杂吗？
- en: How and what type of information do we need to acquire?
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要获取哪些类型的信息？
- en: If our data integrity is important or the data structure is complex, do not
    use in-memory databases. Depending on the complexity, see if you need a non-relational
    database, or whether you can go with a relational database that can handle more
    complex manipulation and data aggregation operations, which will help you to achieve
    the last point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据完整性很重要或数据结构复杂，不要使用内存数据库。根据复杂度，看看你是否需要一个非关系型数据库，或者是否可以使用能够处理更复杂操作和数据聚合的关系型数据库，这将有助于你实现最后一个要点。
- en: Security
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: One good practice is to write code iteratively, testing every time we make a
    new small feature or improvement, and always write code thinking of all the features
    we envision for our service.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是迭代性地编写代码，每次我们添加一个新的小功能或改进时都进行测试，并且始终编写考虑到我们为服务设想的所有功能的代码。
- en: Thinking about the service roadmap allows you to prepare the service for future
    improvements, reducing the amount of code wasted or replaced later on.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑服务的路线图可以帮助你为未来的改进做好准备，减少以后浪费或替换的代码量。
- en: 'For instance, in terms of security:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在安全方面：
- en: Is our service secure? Is it prepared for some types of malicious attacks?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的服务是否安全？它是否为某些类型的恶意攻击做好了准备？
- en: Is our service private? Should it have some kind of authentication or authorization
    mechanism?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的服务是否私密？它是否应该有一些认证或授权机制？
- en: Luckily, our frameworks allow our code to be composed and allow us to add layers
    of security later. For example, using Express or Hydra, we can add a precedent
    routing function that will run before any of our service methods, allowing us
    to enforce, for example, authentication.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的框架允许我们的代码进行组合，并允许我们后来添加安全层。例如，使用Express或Hydra，我们可以添加一个先导路由功能，该功能将在我们的服务方法之前运行，使我们能够强制执行，例如，认证。
- en: 'Looking at our service, since it exposes its methods using HTTP, there are
    a couple of improvements we can add to it, for example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的服务，因为它使用HTTP公开其方法，我们可以对其进行一些改进，例如：
- en: '**Authentication**: Forcing anyone that uses it to identify themselves. Or,
    just the upload and removal methods. It''s up to you. There could also be user
    accounts, and each user would see their respective list of images.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：强制任何使用它的人进行身份验证。或者，仅对上传和删除方法进行强制。这取决于你。也可能有用户账户，每个用户都会看到他们各自的图片列表。'
- en: '**Authorization**: Restricting, for example, what networks could access the
    service, independently of having a valid authentication or not.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：限制例如哪些网络可以访问服务，无论是否有有效的认证。'
- en: '**Confidentiality**: Giving your users protection against prying eyes over
    the network traffic.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：保护用户免受网络流量中窥探者的侵害。'
- en: '**Availability**: Restricting the maximum usage frequency of the service, per
    client, to ensure a single client cannot block your entire service.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：限制每个客户端对服务的最大使用频率，以确保单个客户端不会阻塞你的整个服务。'
- en: To introduce these improvements, you may add an authentication module such as
    the Passport module, and use a certificate to give your users a more secure HTTPS
    experience.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入这些改进，你可以添加一个认证模块，例如Passport模块，并使用证书为用户提供更安全的HTTPS体验。
- en: 'Other types of insecurity come directly from your code and don''t improve by
    adding a certificate or forcing authentication. I''m referring to:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的不安全性直接来自你的代码，并且通过添加证书或强制认证并不能得到改善。我指的是：
- en: Bugs, programming logic flaws, and use cases not properly tested, which can
    lead to minor or serious problems
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷、编程逻辑错误以及未正确测试的使用案例，可能导致小或严重的问题。
- en: Dependency bugs, which you might not be aware of but can still ruin your service
    and may force you to look for alternative dependencies, which is never a pleasant
    task
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖性错误，你可能没有意识到，但仍然可能破坏你的服务，并可能迫使你寻找替代依赖项，这从来都不是一项愉快的任务。
- en: To minimize these events, you should always keep evolving your test suite, adding
    use cases as they show up, ensuring a new bug that is solved does not reappear
    later. Regarding dependency bugs, you can subscribe to the Node Security Project
    and even integrate it with your code to always know when one of your dependencies
    is a risk.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化这些事件，你应该始终不断进化你的测试套件，随着用例的出现添加它们，确保解决的新问题不会在以后再次出现。关于依赖性问题，你可以订阅Node Security
    Project，甚至将其集成到你的代码中，以便始终知道你的依赖项中是否有任何一个是风险的。
- en: 'If there were source code commandments, the next four would surely be on the
    list:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有源代码戒律，接下来的四条肯定会在列表上：
- en: Keep the code simple. If the code is getting complex, stop, look back, and split
    the code into simpler parts.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持代码简单。如果代码变得复杂，就停下来，回顾一下，并将代码拆分成更简单的部分。
- en: Validate external input, whether it's the user or another service. Never trust
    data from the outside.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证外部输入，无论是用户还是另一个服务。永远不要相信来自外部的数据。
- en: Deny by default and not the opposite, checking whether someone has access to
    a resource and denying anyone that is not.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认拒绝而不是相反，检查某人是否有权访问资源，并拒绝任何无权访问的人。
- en: Add test cases from the beginning of the project.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从项目开始时就添加测试用例。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The state is part of any service, and state is built upon data. For a more cloud-native
    experience, a service cannot depend on a traditional filesystem and needs to use
    other kinds of storage structures to store data. Databases are a natural progress,
    and there are some types of databases to choose from, depending on how important
    and complex our data is.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是任何服务的一部分，状态建立在数据之上。为了获得更云原生（cloud-native）的体验，服务不能依赖于传统的文件系统，而需要使用其他类型的存储结构来存储数据。数据库是一个自然的发展，根据我们的数据的重要性和复杂性，我们可以选择一些数据库类型。
- en: Assuming our state is securely stored in a database service of some kind, it's
    also important to ensure our data cannot be corrupted using our service. There
    can be security flaws and bugs in our service that may put our data at risk, so
    it's important to write simple code, validate input, and think about security
    in general when planning the service roadmap.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的状态已安全存储在某些类型的数据库服务中，确保我们的数据不能通过我们的服务被破坏也同样重要。我们的服务中可能存在安全漏洞和错误，可能会使我们的数据处于风险之中，因此，在规划服务路线图时，编写简单的代码、验证输入和考虑安全性是很重要的。
- en: To progress our service, let's introduce something we haven't done yet, and
    should, which is a proper test suite. In the next chapter, we'll see some good
    options and create a test suite, establishing whether anything needs to change
    in order to make our service as secure as possible.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推进我们的服务，让我们引入我们尚未做但应该做的事情，那就是一个合适的测试套件。在下一章中，我们将看到一些好的选择，并创建一个测试套件，确定是否需要改变以使我们的服务尽可能安全。
