- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Handling HTTP Requests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求
- en: The foundation of server-side web development is the ability to receive HTTP
    requests from clients and generate responses. In this chapter, I introduce the
    Node.js API for creating HTTP servers and explain how it can be used to receive
    and respond to requests. *Table 5.1* puts the Node.js HTTP API in context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端 Web 开发的基础是能够从客户端接收 HTTP 请求并生成响应。在本章中，我介绍了用于创建 HTTP 服务器的 Node.js API，并解释了如何使用它来接收和响应请求。*表
    5.1* 将 Node.js HTTP API 放置在上下文中。
- en: 'Table 5.1: Putting the Node.js API in context'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：将 Node.js API 放置在上下文中
- en: '| Question | Answer |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What is it? | The `http` and `https` modules contain the functions and classes
    required to create HTTP and HTTPS servers, receive requests, and generate responses.
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 它是什么？ | `http` 和 `https` 模块包含创建 HTTP 和 HTTPS 服务器、接收请求和生成响应所需的函数和类。 |'
- en: '| Why is it useful? | Receiving and responding to HTTP requests is the core
    feature of server-side web application development. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它有用？ | 接收和响应 HTTP 请求是服务器端 Web 应用程序开发的核心功能。 |'
- en: '| How is it used? | Servers are created with the `createServer` function, which
    emits events when requests are received. Callback functions are invoked to handle
    the request and generate a response. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 如何使用它？ | 使用 `createServer` 函数创建服务器，当收到请求时，会触发事件。回调函数被调用以处理请求并生成响应。 |'
- en: '| Are there any pitfalls or limitations? | Handler functions can become complex
    and mix the statements that match requests with the statements that generate responses.
    Third-party packages, such as the Express package introduced in this chapter,
    build on the Node.js API to streamline request handling. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 有没有陷阱或限制？ | 处理函数可能会变得复杂，并将匹配请求的语句与生成响应的语句混合。本章中介绍的 Express 包等第三方包建立在 Node.js
    API 之上，以简化请求处理。 |'
- en: '| Are there any alternatives? | No. The Node.js HTTP and HTTPS APIs are integral
    to server-side web application development. Third-party packages can make the
    API easier to use but are built on the same features. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 没有。Node.js 的 HTTP 和 HTTPS API 是服务器端 Web 应用程序开发的核心。第三方包可以使 API
    更易于使用，但它们建立在相同的功能之上。 |'
- en: '*Table 5.2* summarizes the chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 5.2* 总结了本章内容。'
- en: 'Table 5.2: Chapter summary'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2：本章总结
- en: '| Problem | Solution | Listing |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Listing for HTTP requests | Use the `createServer` function to create a `Server`
    object and use the `listen` method to start listening for requests. | *4* |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 请求列表 | 使用 `createServer` 函数创建 `Server` 对象，并使用 `listen` 方法开始监听请求。 | *4*
    |'
- en: '| Inspect an HTTP request | Use the features provided by the `IncomingRequest`
    class. | *5* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 检查 HTTP 请求 | 使用 `IncomingRequest` 类提供的功能。 | *5* |'
- en: '| Parse a request URL | Use the `URL` class in the `url` module. | *6* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 解析请求 URL | 使用 `url` 模块中的 `URL` 类。 | *6* |'
- en: '| Create an HTTP response | Use the features provided by the `ServerResponse`
    class. | *7* |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 创建 HTTP 响应 | 使用 `ServerResponse` 类提供的功能。 | *7* |'
- en: '| Listen for HTTPS requests | Use the features provided by the `https` module.
    | *8, 9* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 监听 HTTPS 请求 | 使用 `https` 模块提供的功能。 | *8, 9* |'
- en: '| Detect HTTPS requests | Check the value of the `socket.encrypted` property
    on the `IncomingRequest` object. | *10* |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 检测 HTTPS 请求 | 检查 `IncomingRequest` 对象上的 `socket.encrypted` 属性的值。 | *10* |'
- en: '| Redirect insecure requests | Send a 302 header to the HTTPS port. | *11,
    12* |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 重定向不安全的请求 | 向 HTTPS 端口发送 302 标头。 | *11, 12* |'
- en: '| Simplify request processing | Use a third-party router and enhanced request
    and response classes. | *13-19* |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 简化请求处理 | 使用第三方路由和增强的请求和响应类。 | *13-19* |'
- en: Preparing for this chapter
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: In this chapter, I continue to use the `webapp` project created in *Chapter
    4*. To prepare for this chapter, replace the contents of the `handler.ts` file
    in the `src` folder with the code shown in *Listing 5.1*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将继续使用在 *第 4 章* 中创建的 `webapp` 项目。为了准备本章，请将 `src` 文件夹中 `handler.ts` 文件的全部内容替换为
    *列表 5.1* 中显示的代码。
- en: '**Tip**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* to get help if you have problems running the examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)
    下载本章的示例项目——以及本书中所有其他章节的示例项目。如果您在运行示例时遇到问题，请参阅 *第 1 章* 获取帮助。
- en: 'Listing 5.1: Replacing the contents of the handler.ts file in the src folder'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1：替换 src 文件夹中 handler.ts 文件的内容
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Replace the contents of the `server.ts` file in the `src` folder with the code
    shown in *Listing 5.2*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `src` 文件夹中的 `server.ts` 文件的内容替换为 *列表 5.2* 中显示的代码。
- en: 'Listing 5.2: Replacing the contents of the server.ts file in the src folder'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2：替换 src 文件夹中 server.ts 文件的内容
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the command shown in *Listing 5.3* in the `webapp` folder to start the watcher
    that compiles TypeScript files and executes the JavaScript that is produced.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `webapp` 文件夹中运行 *列表 5.3* 中显示的命令以启动编译 TypeScript 文件并执行生成的 JavaScript 的监视器。
- en: 'Listing 5.3: Starting the project'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3：启动项目
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `server.ts` file in the `src` folder will be compiled to produce a pure
    JavaScript file named `server.js` in the `dist` folder. The JavaScript code will
    be executed by the Node.js runtime, which will start listening for HTTP requests.
    Open a web browser and request `http://localhost:5000` and you will see the response
    shown in *Figure 5.1*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 文件夹中的 `server.ts` 文件将被编译，生成一个位于 `dist` 文件夹中的纯 JavaScript 文件，名为 `server.js`。JavaScript
    代码将由 Node.js 运行时执行，它将开始监听 HTTP 请求。打开一个网页浏览器，请求 `http://localhost:5000`，你将看到 *图
    5.1* 中显示的响应。'
- en: '![](img/B21959_05_01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_05_01.png)'
- en: 'Figure 5.1: Running the example project'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：运行示例项目
- en: Listening for HTTP requests
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听 HTTP 请求
- en: In *Chapter 4*, I created a simple web server so that I could demonstrate the
    way that JavaScript code is executed. In doing so, I skipped over the details
    of how the code worked, but now it is time to go back and dig into the details.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章* 中，我创建了一个简单的 Web 服务器，以便演示 JavaScript 代码的执行方式。在这样做的时候，我跳过了代码工作原理的细节，但现在该回到细节中去探究了。
- en: The `createServer` function in the `http` module is used to create `Server`
    objects that can be used to listen for and process HTTP requests. The `Server`
    object requires configuration before it starts listening for requests and the
    most useful methods and properties defined by the `Server` class are described
    in *Table 5.3*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` 模块中的 `createServer` 函数用于创建 `Server` 对象，这些对象可以用来监听和处理 HTTP 请求。在开始监听请求之前，`Server`
    对象需要配置，而 `Server` 类定义的最有用方法和属性在 *表 5.3* 中进行了描述。'
- en: 'Table 5.3: Useful server methods and properties'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.3：有用的服务器方法和属性
- en: '| Name | Description |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| This method starts listening for requests on a specified port. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 此方法在指定的端口上开始监听请求。 |'
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| This method stops listening for requests. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 此方法停止监听请求。 |'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| This property gets or sets the request timeout period, which can also be
    used using the configuration object passed to the `createServer` function. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 此属性获取或设置请求超时时间，也可以使用传递给 `createServer` 函数的配置对象来使用。 |'
- en: Once the `Server` object has been configured, it emits events that denote important
    changes in state. The most useful events are described in *Table 5.4*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 `Server` 对象，它就会发出表示状态重要变化的的事件。最有用的事件在 *表 5.4* 中进行了描述。
- en: 'Table 5.4: Useful server events'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.4：有用的服务器事件
- en: '| Name | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| This event is triggered when the server starts listening for requests. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 当服务器开始监听请求时，将触发此事件。 |'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| This event is triggered when a new request is received. The callback function
    that handles this event is invoked with arguments that represent the HTTP request
    and response. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 当接收到新的请求时，将触发此事件。处理此事件的回调函数将使用表示 HTTP 请求和响应的参数调用。 |'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| This event is triggered when there is a network error. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 当发生网络错误时，将触发此事件。 |'
- en: The use of events to invoke callback functions is typical of the JavaScript
    code execution model described in *Chapter 4*. The `request` event will be triggered
    each time an HTTP request is received, and the JavaScript execution model means
    that only one HTTP request will be handled at a time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件来调用回调函数是 *第 4 章* 中描述的 JavaScript 代码执行模型的典型特征。每当收到 HTTP 请求时，都会触发 `request`
    事件，而 JavaScript 执行模型意味着一次只能处理一个 HTTP 请求。
- en: The Node.js API often allows event handlers to be specified through other methods.
    The `createServer` function used to create a `Server` object accepts an optional
    function argument that is registered as a handler for the `request` event, and
    the `Server.listen` method accepts an optional function argument that is used
    to handle the `listening` event.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js API 通常允许通过其他方法指定事件处理器。用于创建 `Server` 对象的 `createServer` 函数接受一个可选的函数参数，该参数被注册为
    `request` 事件的处理器，而 `Server.listen` 方法接受一个可选的函数参数，用于处理 `listening` 事件。
- en: These convenience features can be used to combine the statements that create
    and configure the HTTP server with the callback functions that handle the events,
    as shown in *Listing 5.4*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些便利功能可以用来组合创建和配置 HTTP 服务器的语句与处理事件的回调函数，如 *列表 5.4* 所示。
- en: 'Listing 5.4: Using the event convenience features in the server.ts file in
    the src folder'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4：在 src 文件夹中的 server.ts 文件中使用服务器的事件便利功能
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code has the same effect as *Listing 5.2* but is more concise and easier
    to read.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码与 *列表 5.2* 有相同的效果，但更简洁、更易于阅读。
- en: Understanding the Server configuration object
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解服务器配置对象
- en: The arguments for the `createServer` function are a configuration object and
    a request-handling function. The configuration object is used to change the way
    that requests are received, and the most useful settings are described in *Table
    5.5*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer` 函数的参数是一个配置对象和一个请求处理函数。配置对象用于更改接收请求的方式，其中最有用的设置在 *表 5.5* 中描述。'
- en: 'Table 5.5: Useful createServer configuration object settings'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.5：有用的 `createServer` 配置对象设置
- en: '| Name | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `IncomingMessage` | This property specifies the class used to represent requests.
    The default is the `IncomingMessage` class, defined in the `http` module. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `IncomingMessage` | 此属性指定用于表示请求的类。默认是 `IncomingMessage` 类，在 `http` 模块中定义。|'
- en: '| `ServerResponse` | This property specifies the class used to represent responses.
    The default is the `ServerResponse` class, defined in the `http` module. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `ServerResponse` | 此属性指定用于表示响应的类。默认是 `ServerResponse` 类，在 `http` 模块中定义。|'
- en: '| `requestTimeout` | This property specifies the amount of time, in milliseconds,
    allowed for a client to send requests, after which the request times out. The
    default value is 300,000 milliseconds. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `requestTimeout` | 此属性指定客户端发送请求允许的时间量（以毫秒为单位），在此之后请求超时。默认值为 300,000 毫秒。|'
- en: 'The configuration object can be omitted if the default values are required.
    The handler function is invoked when an HTTP request has been received and its
    parameters are objects whose types are those specified by the `IncomingMessage`
    and `ServerResponse` properties, or the default types if the configuration hasn’t
    been changed. The code in *Listing 5.4* omits the configuration object, which
    means that the default types will be used to represent the HTTP request and response
    when the handler function for the request event is invoked, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要默认值，则可以省略配置对象。当接收到 HTTP 请求并调用处理函数时，处理函数的参数是对象，其类型由 `IncomingMessage` 和 `ServerResponse`
    属性指定，或者如果配置未更改，则使用默认类型。*列表 5.4* 中的代码与 *列表 5.2* 有相同的效果，但更简洁、更易于阅读。
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Later examples in this chapter demonstrate using different types, but the default
    representations of the HTTP request and response provide all the features needed
    to process HTTP, as explained in the following sections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面的示例展示了使用不同类型，但 HTTP 请求和响应的默认表示提供了处理 HTTP 所需的所有功能，如以下各节所述。
- en: Understanding HTTP requests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 HTTP 请求
- en: 'Node.js represents HTTP requests using the `IncomingMessage` class, which is
    defined in the `http` module. The four main building blocks of an HTTP request
    are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 使用 `IncomingMessage` 类表示 HTTP 请求，该类在 `http` 模块中定义。HTTP 请求的四个主要构建块是：
- en: The HTTP method, which describes the operation the client wants to perform.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 方法，它描述了客户端想要执行的操作。
- en: The URL, which identifies the resource the request should be applied to.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL，它标识请求应该应用到的资源。
- en: The headers, which provide additional information about the request and the
    capabilities of the client.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部，它提供了有关请求和客户端能力的附加信息。
- en: The request body, which provides the data required for the requested operation.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求体，它提供了请求操作所需的数据。
- en: The `IncomingMessage` class provides access to all of these building blocks,
    allowing them to be inspected so the server can generate a suitable response.
    *Table 5.6* lists the properties provided for the first three request building
    blocks, and I explain how to deal with the request body in *Chapter 6*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`IncomingMessage` 类提供了对这些构建块的访问权限，允许检查它们，以便服务器可以生成适当的响应。*表 5.6* 列出了为前三个请求构建块提供的属性，我在
    *第 6 章* 中解释了如何处理请求体。'
- en: 'Table 5.6: Useful IncomingMessage properties'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.6：有用的 `IncomingMessage` 属性
- en: '| Name | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `headers` | This property returns an `IncomingHttpHeaders` object, which
    defines properties for common headers and can also be used as a key/value object
    that maps the names of the headers in the request to the header values. The headers
    are normalized, as described below. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `headers` | 此属性返回一个`IncomingHttpHeaders`对象，它定义了常见头的属性，也可以用作将请求中头的名称映射到头值的键/值对象。头信息已按以下描述规范化。|'
- en: '| `headersDistinct` | This property returns a key/value object that maps the
    names of the headers in the request to the header values. The values are normalized,
    as described below this table. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `headersDistinct` | 此属性返回一个将请求中头的名称映射到头值的键/值对象。值已按以下表格描述规范化。|'
- en: '| `httpVersion` | This property returns a `string` value containing the version
    of HTTP used in the request. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `httpVersion` | 此属性返回一个包含请求中使用的HTTP版本的`string`值。|'
- en: '| `method` | This property returns a `string` value containing the HTTP method
    specified by the request. This value may be `undefined.` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `method` | 此属性返回一个包含请求中指定的HTTP方法的`string`值。此值可能为`undefined`。|'
- en: '| `url` | This property returns a `string` value containing the request URL.
    This value may be `undefined`. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `url` | 此属性返回一个包含请求URL的`string`值。此值可能为`undefined`。|'
- en: '| `socket` | This property returns an object that represents the network socket
    used to receive the connection, which is useful when detecting HTTPS requests,
    as demonstrated in the *Detecting HTTPS requests* section. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `socket` | 此属性返回一个表示用于接收连接的网络套接字的对象，这在检测HTTPS请求时很有用，如*检测HTTPS请求*部分所示。|'
- en: HTTP headers can be difficult to work with and the `headers` and `headersDistinct`
    properties normalize headers so that they are easier to use. Some HTTP headers
    should only appear once in a request, so Node.js removes duplicate values. Other
    headers can have multiple values, and these are concatenated into a single `string`
    value by the `headers` property and into an array of strings by the `headersDistinct`
    property. The exception is the `set-cookie` header, which is always presented
    as a `string` array. (I describe how cookies are used in detail in *Part 2*.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头可能难以处理，`headers`和`headersDistinct`属性规范化了头信息，使其更容易使用。某些HTTP头只应在请求中出现一次，因此Node.js会移除重复的值。其他头可以有多个值，这些值通过`headers`属性连接成一个单一的`string`值，并通过`headersDistinct`属性转换成一个字符串数组。例外的是`set-cookie`头，它始终以`string`数组的形式呈现。（我在*第2部分*中详细描述了cookie的使用。）
- en: '**Tip**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: The `IncomingRequest` class also defines the `rawHeaders` property, which provides
    access to the headers as they were received, with no normalization. This property
    can be useful if you need to perform custom normalization, but the `headers` and
    `headersDistinct` properties are more useful for mainstream development projects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`IncomingRequest`类还定义了`rawHeaders`属性，它提供了以未规范化形式访问头信息的方式。如果需要执行自定义规范化，此属性可能很有用，但`headers`和`headersDistinct`属性对于主流开发项目更有用。'
- en: As a rule of thumb, the `headers` property is more useful for displaying or
    logging headers, while the `headersDistinct` property is more useful when using
    headers to decide what kind of response to produce. *Listing 5.5* updates the
    example to log the details of the request to the Node.js console.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`headers`属性在显示或记录头信息时更有用，而`headersDistinct`属性在用头信息决定要生成哪种响应时更有用。*列表5.5*更新了示例，以记录请求的详细信息到Node.js控制台。
- en: 'Listing 5.5: Logging request details in the handler.ts file in the src folder'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5：在src文件夹中的handler.ts文件中记录请求详细信息
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example writes out the HTTP method, the request URL, and three headers:
    the `host` header, which specifies the hostname and port to which the request
    was sent; the `accept` header, which specifies the formats the client is willing
    to accept in the response; and the `user-agent` header, which identifies the client.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例输出了HTTP方法、请求URL和三个头信息：指定请求发送到的主机名和端口的`host`头；指定客户端愿意在响应中接受的格式的`accept`头；以及标识客户端的`user-agent`头。
- en: 'I used the `headers` property in *Listing 5.5*, which allows me to access headers
    using properties that correspond to the header name, like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*列表5.5*中使用了`headers`属性，这使我能够使用与头名称对应的属性来访问头信息，如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Not all HTTP header names can be used as JavaScript property names, and there
    is no property for the `user-agent` header because JavaScript property names cannot
    contain hyphens. Instead, I have to access the `user-agent` header by specifying
    the property name as a string, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有 HTTP 头名称都可以用作 JavaScript 属性名称，并且没有 `user-agent` 头的属性，因为 JavaScript 属性名称不能包含连字符。因此，我必须通过指定属性名称为字符串来访问
    `user-agent` 头，如下所示：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use a browser to request `http://localhost:5000` and you will see output similar
    to the following, although you may see different values for the headers (and I
    have elided the header values for brevity):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `http://localhost:5000`，你将看到类似以下内容的输出，尽管你可能看到不同的头部值（并且为了简洁起见，我省略了头部值）：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This output shows two requests because browsers will often request `/favicon.ico`,
    which is used as the icon for the tab. You may not see the `favicon.ico` request
    if you recently used your browser for the examples in the previous chapter, where
    a `404 Not Found` response was produced. You can clear your browser’s cache if
    you want to see both requests, but it isn’t important for the examples that follow.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了两个请求，因为浏览器通常会请求 `/favicon.ico`，这是用作标签页图标的。如果你最近使用了浏览器中的前一章中的示例，其中生成了 `404
    Not Found` 响应，你可能看不到 `favicon.ico` 请求。如果你想看到两个请求，你可以清除浏览器的缓存，但这对于后续的示例并不重要。
- en: Parsing URLs
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 URL
- en: Node.js provides the `URL` class in the `url` module to parse URLs into their
    parts, making it easier to inspect URLs to make decisions about what kind of response
    will be sent. URLs are parsed by creating a new `URL` object and reading the properties
    described in *Table 5.7*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 在 `url` 模块中提供了 `URL` 类，用于将 URL 解析为其各个部分，这使得检查 URL 并做出关于将发送何种响应的决定变得更容易。通过创建一个新的
    `URL` 对象并读取 *表 5.7* 中描述的属性来解析 URL。
- en: 'Table 5.7: Useful URL properties'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.7：有用的 URL 属性
- en: '| Name | Description |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `hostname` | This property returns a `string` containing the URL hostname
    component. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `hostname` | 此属性返回一个包含 URL 主机名组件的 `string`。|'
- en: '| `pathname` | This property returns a `string` containing the URL pathname
    component. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `pathname` | 此属性返回一个包含 URL 路径组件的 `string`。|'
- en: '| `port` | This property returns a `string` containing the URL port component.
    The value will be an empty string if the request has been made to the default
    port for the URL’s protocol (such as port `80` for unsecured HTTP requests). |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `port` | 此属性返回一个包含 URL 端口组件的 `string`。如果请求已发送到 URL 协议的默认端口（例如，对于未加密的 HTTP
    请求，端口为 `80`），则该值将为空字符串。|'
- en: '| `protocol` | This property returns a `string` containing the URL protocol
    component. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `protocol` | 此属性返回一个包含 URL 协议组件的 `string`。|'
- en: '| `search` | This property returns a `string` containing the entire query portion
    of the URL. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `search` | 此属性返回一个包含 URL 整个查询部分的 `string`。|'
- en: '| `searchParams` | This property returns a `URLSeachParams` object that provides
    key/value access to the query portion of the URL. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `searchParams` | 此属性返回一个 `URLSeachParams` 对象，它提供了对 URL 查询部分的键/值访问。|'
- en: '*Listing 5.6* creates a new URL object to parse the request URL.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5.6* 创建一个新的 URL 对象以解析请求 URL。'
- en: 'Listing 5.6: Parsing a URL in the handler.ts file in the src folder'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6：在 src 文件夹中的 handler.ts 文件中解析 URL
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Creating a `URL` object to parse a URL requires a little work. The `IncomingMessage.url`
    property returns a relative URL, which the `URL` class constructor will accept
    as an argument, but only if the base part of the URL (the protocol, hostname,
    and port) is specified as a second argument. The hostname and port can be obtained
    from the `host` request header, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于解析 URL 的 `URL` 对象需要一点工作。`IncomingMessage.url` 属性返回一个相对 URL，`URL` 类构造函数将接受它作为参数，但前提是必须将
    URL 的基础部分（协议、主机名和端口）作为第二个参数指定。主机名和端口可以从 `host` 请求头中获取，如下所示：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The missing piece is the protocol. The example only accepts regular unsecured
    HTTP requests so I can specify `http` as the protocol, safe in the knowledge that
    it will be correct. I will demonstrate how to determine the protocol properly
    when I demonstrate the use of HTTPS later in the chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的部分是协议。示例仅接受常规未加密的 HTTP 请求，因此我可以指定 `http` 作为协议，有信心它是正确的。我将在本章后面演示如何在使用 HTTPS
    时正确确定协议。
- en: The properties described in *Table 5.7* can be used to inspect the individual
    parts of the URL once the `URL` object has been created, and the example writes
    out the `protocol`, `hostname`, `port`, and `pathname` values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `URL` 对象之后，可以使用 *表 5.7* 中描述的属性来检查 URL 的各个部分，示例中写出了 `protocol`、`hostname`、`port`
    和 `pathname` 的值。
- en: 'The `URL` class parses the query section of the URL and presents it as a set
    of key/value pairs and these are also written out. Use a browser to request the
    following URL: `http://localhost:5000/myrequest?first=Bob&last=Smith`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`URL`类解析URL的查询部分，并将其呈现为键/值对集合，这些也会被写出。使用浏览器请求以下URL：`http://localhost:5000/myrequest?first=Bob&last=Smith`'
- en: 'This URL has a path and a query, and you will see output similar to the following
    when the URL is parsed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此URL有一个路径和一个查询，当解析此URL时，你会看到类似以下输出：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output shows that the browser has sent a second request, for `/favicon.ico`,
    in addition to the URL that was explicitly requested.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，除了显式请求的URL外，浏览器还发送了一个第二个请求，即对`/favicon.ico`的请求。
- en: Understanding HTTP responses
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTTP响应
- en: The purpose of inspecting an HTTP request is to determine what kind of response
    is required. Responses are produced using the features provided by the `ServerResponse`
    class, the most useful of which are described in *Table 5.8*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 检查HTTP请求的目的是确定所需的响应类型。响应是通过`ServerResponse`类提供的功能生成的，其中最有用的功能在*表5.8*中描述。
- en: 'Table 5.8: Useful ServerResponse members'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.8：有用的ServerResponse成员
- en: '| Name | Description |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `sendDate` | This `boolean` property determines whether Node.js automatically
    generates the `Date` header and adds it to the response. The default is `true`.
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `sendDate` | 此`boolean`属性确定Node.js是否自动生成`Date`头并将其添加到响应中。默认值为`true`。 |'
- en: '| `setHeader(name, value)` | This method sets a response header using the specified
    name and value. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `setHeader(name, value)` | 此方法使用指定的名称和值设置响应头。 |'
- en: '| `statusCode` | This `number` property is used to set the response status
    code. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `statusCode` | 此`number`属性用于设置响应状态码。 |'
- en: '| `statusMessage` | This `string` property is used to set the response status
    message. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `statusMessage` | 此`string`属性用于设置响应状态消息。 |'
- en: '| `writeHead(code, msg, headers)` | This method is used to set the status code
    and, optionally, the status message and response headers. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `writeHead(code, msg, headers)` | 此方法用于设置状态码，可选地设置状态消息和响应头。 |'
- en: '| `write(data)` | This method writes data to the response body, which is expressed
    as a `string` or a `Buffer`. This method accepts optional arguments that specify
    the encoding for the data and a callback function that is invoked when the operation
    is complete. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `write(data)` | 此方法将数据写入响应体，数据以`string`或`Buffer`形式表示。此方法接受可选参数，指定数据的编码以及一个在操作完成后被调用的回调函数。
    |'
- en: '| `end()` | This method tells Node.js that the response is complete and can
    be sent to the client. The method can be invoked with an optional `data` argument,
    which will be added to the response body, an encoding for the data, and a callback
    function that will be invoked when the response has been sent. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `end()` | 此方法通知Node.js响应已完整，可以发送给客户端。此方法可以带有一个可选的`data`参数，该参数将被添加到响应体中，一个用于数据的编码，以及一个回调函数，当响应发送完毕时将被调用。
    |'
- en: The basic approach to generating a response is to set the status code and status
    message, define any headers that will help the client process the response, write
    the data for the body – if there is one – and then send the response to the client.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 生成响应的基本方法是设置状态码和状态消息，定义任何有助于客户端处理响应的头部，写入体数据（如果有的话），然后向客户端发送响应。
- en: '*Listing 5.7* inspects the requests that are received to determine how the
    features provided by the `ServerResponse` class are used to create a response.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5.7* 检查接收到的请求，以确定如何使用`ServerResponse`类提供的功能来创建响应。'
- en: 'Listing 5.7: Generating HTTP responses in the handler.ts file in the src folder'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7：在src文件夹中的handler.ts文件中生成HTTP响应
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example generates three different responses. For requests that don’t specify
    the HTTP GET method or request `/favicon.ico`, the status code is set to 404,
    which tells the browser the requested resource doesn’t exist, the human-readable
    status message is set to `Not Found`, and the `end` method is called to complete
    the request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例生成了三个不同的响应。对于未指定HTTP GET方法或请求`/favicon.ico`的请求，状态码被设置为404，这告诉浏览器请求的资源不存在，可读的状态消息被设置为`Not
    Found`，然后调用`end`方法来完成请求。
- en: For all other requests, the status code is set to 200, indicating a successful
    response and the status message is set to `OK`. The query component of the request
    URL is checked to see if there is a `keyword` parameter and, if there is, the
    value is included in the response body.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他请求，状态码设置为200，表示成功响应，状态消息设置为`OK`。检查请求URL的查询部分以查看是否存在`keyword`参数，如果存在，则将其值包含在响应体中。
- en: Notice that I use the `return` keyword after calling the `end` method. This
    is not a requirement, but it is an error to set headers or write data after the
    `end` method has been called, and explicitly returning from the function avoids
    this problem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在调用`end`方法后使用了`return`关键字。这不是必需的，但在调用`end`方法之后设置标题或写入数据是一个错误，并且明确地从函数返回可以避免这个问题。
- en: Use a browser to request `http://localhost:5000/favicon.ico`, `http://localhost:5000?keyword=World`,
    and `http://localhost:5000` and you will see the responses shown in *Figure 5.2*.
    (The browser usually requests the `favicon.ico` file behind the scenes, but requesting
    it explicitly makes it easier to see the `HTTP 404` response.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求`http://localhost:5000/favicon.ico`、`http://localhost:5000?keyword=World`和`http://localhost:5000`，您将看到*图5.2*中显示的响应。（浏览器通常在幕后请求`favicon.ico`文件，但明确请求它可以使查看`HTTP
    404`响应更容易。）
- en: '![](img/B21959_05_02.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_05_02.png)'
- en: 'Figure 5.2: Generating HTTP responses'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：生成HTTP响应
- en: Supporting HTTPS requests
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持HTTPS请求
- en: Most web applications use HTTPS, where HTTP requests are sent over an encrypted
    network connection using the TLS/SSL protocol. Using HTTPS ensures that the request
    and response cannot be inspected as they traverse public networks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用程序使用HTTPS，其中HTTP请求通过加密的网络连接使用TLS/SSL协议发送。使用HTTPS确保请求和响应在穿越公共网络时不会被检查。
- en: Supporting SSL requires a certificate that establishes the identity of the server
    and is used as the basis for the encryption that secures HTTPS requests. For this
    chapter, I am going to use a self-signed certificate, which is sufficient for
    development and testing, but should not be used for deployment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 支持SSL需要一个证书来确立服务器的身份，并用作加密HTTPS请求的基础。对于本章，我将使用自签名证书，这对于开发和测试是足够的，但不应用于部署。
- en: '**Note**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: See [https://letsencrypt.org](https://letsencrypt.org) if you want a certificate
    for deployment. The Let’s Encrypt service is supported by a non-profit organization
    and offers free certificates suitable for use with HTTPS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要用于部署的证书，请参阅[https://letsencrypt.org](https://letsencrypt.org)。Let’s Encrypt服务由一个非营利组织支持，并提供适合与HTTPS一起使用的免费证书。
- en: Creating the self-signed certificate
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自签名证书
- en: The easiest way to create a self-signed certificate is to use the OpenSSL package,
    which is an open-source toolkit for security-related tasks. The OpenSSL project
    can be found at [https://www.openssl.org](https://www.openssl.org) and OpenSSL
    is part of many popular Linux distributions. A list of binaries and installers,
    including installers for Windows, can be found at [https://wiki.openssl.org/index.php/binaries](https://wiki.openssl.org/index.php/binaries).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自签名证书最简单的方法是使用OpenSSL包，这是一个用于安全相关任务的开源工具包。OpenSSL项目可以在[https://www.openssl.org](https://www.openssl.org)找到，OpenSSL是许多流行Linux发行版的一部分。可以在[https://wiki.openssl.org/index.php/binaries](https://wiki.openssl.org/index.php/binaries)找到二进制文件和安装程序的列表，包括Windows的安装程序。
- en: Alternatively, the Git client includes OpenSSL in the `usr/bin` folder (`C:\Program
    Files\Git\usr\bin` on Windows), which can be used to create self-signed certificates
    without needing to install the OpenSSL package.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，Git客户端在`usr/bin`文件夹中包含OpenSSL（在Windows上是`C:\Program Files\Git\usr\bin`），可以用来创建自签名证书，而无需安装OpenSSL包。
- en: Ensure that the OpenSSL executable is in your command prompt path and run the
    command shown in *Listing 5.8* in the `webapp` folder, entering the entire command
    on one line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 确保OpenSSL可执行文件在您的命令提示符路径中，并在`webapp`文件夹中运行*列表5.8*中显示的命令，将整个命令在一行中输入。
- en: 'Listing 5.8: Generating a self-signed certificate'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8：生成自签名证书
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command prompts for the details that will be included in the certificate.
    Press the *Enter* key to select the default value for each option:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会提示输入将包含在证书中的详细信息。按*Enter*键选择每个选项的默认值：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The details don’t matter because the certificate will be used only for development.
    When the command completes, there will be two new files in the `webapp` folder:
    the `cert.pem` file (which contains the self-signed certificate) and the `key.pem`
    file (which contains the private key for the certificate).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 详细内容不重要，因为证书仅用于开发。当命令完成后，`webapp` 文件夹中将出现两个新文件：包含自签名证书的 `cert.pem` 文件和包含证书私钥的
    `key.pem` 文件。
- en: Handling HTTPS requests
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 HTTPS 请求
- en: The next step is to use the API provided by Node.js to receive HTTPS requests,
    as shown in *Listing 5.9*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 Node.js 提供的 API 接收 HTTPS 请求，如 *列表 5.9* 所示。
- en: 'Listing 5.9: Handling HTTPS requests in the server.ts file in the src folder'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9：在 src 文件夹的 server.ts 文件中处理 HTTPS 请求
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The process for receiving HTTPS requests is similar to regular HTTP, to the
    extent that the function for creating an HTTPS server is named `createServer`,
    which is the same name used for HTTP. To use both versions of the `createServer`
    function in the same code file, I have used an alias in the `import` statement,
    like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接收 HTTPS 请求的过程与常规 HTTP 类似，到函数创建 HTTPS 服务器时命名为 `createServer`，这与 HTTP 使用的名称相同。为了在同一个代码文件中使用两个版本的
    `createServer` 函数，我在 `import` 语句中使用了别名，如下所示：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This statement imports the `createServer` function from the `https` module and
    the `as` keyword is used to assign a name that doesn’t conflict with other imports.
    In this case, the name I have chosen is `createHttpsServer`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句从 `https` 模块导入 `createServer` 函数，并使用 `as` 关键字分配一个不会与其他导入冲突的名称。在这种情况下，我选择的名称是
    `createHttpsServer`。
- en: 'A configuration object is required to specify the certificate files that were
    created in the previous section with properties named `key` and `cert`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个配置对象来指定上一节中创建的证书文件，其属性名为 `key` 和 `cert`：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `key` and `cert` properties can be assigned `string` or `Buffer` values.
    I use the `readFileSync` functions from the `fs` module to read the contents of
    the `key.pem` and `cert.pem` files, which produces `Buffer` values that contain
    byte arrays.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`key` 和 `cert` 属性可以分配 `string` 或 `Buffer` 值。我使用 `fs` 模块的 `readFileSync` 函数读取
    `key.pem` 和 `cert.pem` 文件的内容，这会产生包含字节数组的 `Buffer` 值。'
- en: '**Understanding synchronous file reads**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解同步文件读取**'
- en: 'In *Chapter 4*, I explained that it can make sense to use blocking operations
    when you know that there is no other work to be performed by the main thread.
    In this case, I need to read the contents of the `key.pem` and `cert.pem` files
    as part of the application startup. There is little benefit to using a callback
    or a promise because I need the contents of those files to configure Node.js to
    listen for HTTPS requests and using non-blocking operations produces code like
    this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章* 中，我解释了当知道主线程没有其他工作要做时，使用阻塞操作是有意义的。在这种情况下，我需要读取 `key.pem` 和 `cert.pem`
    文件的内容作为应用程序启动的一部分。使用回调或承诺的好处很少，因为我需要这些文件的内容来配置 Node.js 以监听 HTTPS 请求，并且使用非阻塞操作会产生如下代码：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code shows you *can* read the files using the non-blocking `readFile` function,
    but the nested callbacks are harder to make sense of. Promises don’t help either
    because the `await` keyword can only be used within functions, which means the
    `then` syntax demonstrated in *Chapter 4* must be used.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了 *可以* 使用非阻塞的 `readFile` 函数读取文件，但嵌套回调更难理解。承诺也没有帮助，因为 `await` 关键字只能在函数内部使用，这意味着必须使用
    *第 4 章* 中展示的 `then` 语法。
- en: It is important to avoid blocking the main thread in almost every situation,
    but there are a few occasions when it doesn’t matter, and non-blocking features
    are less useful.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，避免阻塞主线程都很重要，但有一些情况下这并不重要，并且非阻塞特性不太有用。
- en: 'There are many configuration options available, described at [https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener](https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener),
    but the `key` and `cert` options are enough to get started. The configuration
    object is passed to the `createServer` function, which I have aliased as `createHttpsServer`
    in this example, and the `listen` method is called on the result to start listening
    for HTTPS requests:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多配置选项可用，描述在 [https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener](https://nodejs.org/dist/latest-v20.x/docs/api/https.html#httpscreateserveroptions-requestlistener)，但
    `key` 和 `cert` 选项足以开始。配置对象传递给 `createServer` 函数，在这个例子中，我将其别名为 `createHttpsServer`，并在结果上调用
    `listen` 方法以开始监听 HTTPS 请求：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Open a web browser and request `https://localhost:5500`, which will send an
    HTTPS request to the port on which Node.js has been configured to listen. Browsers
    will display warnings for self-signed certificates, and you will typically have
    to confirm you want to proceed, as shown in *Figure 5.3*, which shows the warning
    presented by Chrome.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并请求 `https://localhost:5500`，这将向 Node.js 配置为监听的端口发送 HTTPS 请求。浏览器将显示自签名证书的警告，你通常需要确认你想要继续，如
    *图 5.3* 所示，该图显示了 Chrome 提出的警告。
- en: '![](img/B21959_05_03.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_05_03.png)'
- en: 'Figure 5.3: Accepting a self-signed certificate'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：接受自签名证书
- en: Node.js is still listening for regular HTTP requests on port `5000`, which you
    can confirm by requesting `http://localhost:5000`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 仍然在端口 `5000` 上监听常规 HTTP 请求，你可以通过请求 `http://localhost:5000` 来确认。
- en: Detecting HTTPS requests
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测 HTTPS 请求
- en: The Node.js API uses the `IncomingMessage` and `ServerResponse` classes for
    both HTTP and HTTPS requests, which means that the same handler function can be
    used for both request types. However, it can be useful to know which kind of request
    is being processed so that different responses can be generated, as shown in *Listing
    5.10*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js API 使用 `IncomingMessage` 和 `ServerResponse` 类来处理 HTTP 和 HTTPS 请求，这意味着相同的处理函数可以用于两种请求类型。然而，了解正在处理哪种类型的请求可能很有用，以便可以生成不同的响应，如
    *列表 5.10* 所示。
- en: 'Listing 5.10: Detecting HTTPS requests in the handler.ts file in the src folder'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10：在 src 文件夹中的 handler.ts 文件中检测 HTTPS 请求
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `socket` property defined by the `IncomingMessage` class will return an
    instance of the `TLSSocket` class for secure requests and this class defines an
    `encrypted` property that always returns `true`. Checking if this property exists
    allows HTTPS and HTTP connections to be identified so that different responses
    can be produced.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `IncomingMessage` 类定义的 `socket` 属性将为安全请求返回 `TLSSocket` 类的实例，该类定义了一个 `encrypted`
    属性，它始终返回 `true`。检查此属性的存在允许识别 HTTPS 和 HTTP 连接，以便可以生成不同的响应。
- en: '**Note**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: A common deployment pattern for Node.js is to use a proxy that receives HTTPS
    requests from clients and fans them out to Node.js servers using plain HTTP. In
    this situation, you can usually check the `X-Forwarded-Proto` request header,
    which proxies use to pass on details of the encryption used by the client. See
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto)
    for details.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的常见部署模式是使用一个代理，该代理从客户端接收 HTTPS 请求，并使用纯 HTTP 将其分发到 Node.js 服务器。在这种情况下，你通常可以检查
    `X-Forwarded-Proto` 请求头部，代理使用它来传递客户端使用的加密细节。有关详细信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto)。
- en: Use a browser to request `http://localhost:5000` and `https://localhost:5500`
    and you will see the responses shown in *Figure 5.4*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `http://localhost:5000` 和 `https://localhost:5500`，你将看到 *图 5.4* 中显示的响应。
- en: '![](img/B21959_05_04.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_05_04.png)'
- en: 'Figure 5.4: Identifying HTTPS requests'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：识别 HTTPS 请求
- en: Redirecting insecure requests
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向不安全请求
- en: HTTPS has become the preferred way to offer web functionality and it is common
    practice to respond to regular HTTP requests with a response that directs the
    client to use HTTPS instead, as shown in *Listing 5.11*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 已成为提供网络功能的首选方式，并且通常的做法是对常规 HTTP 请求做出响应，指示客户端使用 HTTPS，如 *列表 5.11* 所示。
- en: 'Listing 5.11: Redirecting HTTP requests in the handler.ts file in the src folder'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11：在 src 文件夹中的 handler.ts 文件中重定向 HTTP 请求
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The new handler uses the `writeHead` method to set the status code to `302`,
    which denotes a redirection, and sets the `Location` header, which specifies the
    URL the browser should request instead. *Listing 5.12* applies the new handler
    so that it is used to generate responses for all HTTP requests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 新的处理程序使用 `writeHead` 方法将状态码设置为 `302`，这表示重定向，并设置 `Location` 头部，该头部指定浏览器应请求的 URL。*列表
    5.12* 应用了新的处理程序，使其用于生成所有 HTTP 请求的响应。
- en: 'Listing 5.12: Applying a handler in the server.ts file in the src folder'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12：在 src 文件夹中的 server.ts 文件中应用处理程序
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you use the browser to request `http://localhost:5000`, the response sent
    by the new handler will cause the browser to request `https://localhost:5500`.
    If you examine the network connections made by the browser in the *F12* developer
    tools window, you will see the redirection response and the subsequent HTTPS request,
    as shown in *Figure 5.5*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用浏览器请求 `http://localhost:5000`，新处理器发送的响应将导致浏览器请求 `https://localhost:5500`。如果你在
    *F12* 开发者工具窗口中检查浏览器建立的网络连接，你会看到重定向响应和随后的 HTTPS 请求，如图 *5.5* 所示。
- en: '**Using HTTP Strict Transport Security (HSTS)**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 HTTP 严格传输安全 (HSTS)**'
- en: Redirecting HTTP requests to an HTTPS URL means that the initial communication
    between the client and server is unencrypted, which presents the potential for
    the HTTP request to be hijacked by a man-in-the-middle attack that redirects clients
    to a malicious URL instead. The **HTTP Strict Transport Security** (**HSTS**)
    header can be used to tell browsers not to only use HTTPS requests for a domain.
    See [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)
    for details.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTTP 请求重定向到 HTTPS URL 意味着客户端和服务器之间的初始通信是不加密的，这可能导致 HTTP 请求被中间人攻击者劫持，将客户端重定向到恶意
    URL。可以使用 **HTTP 严格传输安全** (**HSTS**) 标头来告诉浏览器不仅为该域名使用 HTTPS 请求。有关详细信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)。
- en: '![](img/B21959_05_05.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21959_05_05](img/B21959_05_05.png)'
- en: 'Figure 5.5: Redirecting HTTP requests'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：重定向 HTTP 请求
- en: '**Understanding HTTP/2**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解 HTTP/2**'
- en: All the examples in this chapter use HTTP/1.1, which tends to be the default
    for Node.js web application development.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都使用 HTTP/1.1，这通常是 Node.js 网络应用程序开发的默认选项。
- en: HTTP/2 is an update to the HTTP protocol that is intended to improve performance.
    HTTP/2 uses a single network connection to interleave multiple requests from the
    client, sends headers in a compact binary format, and allows the server to “push”
    content to the client before it is requested. Node.js provides support for HTTP/2
    in the `http2` module and even includes a compatibility API that uses the approach
    shown in this chapter to handle HTTP/1.1 and HTTP/2 requests with the same code.
    (See [https://nodejs.org/dist/latest-v20.x/docs/api/http2.html](https://nodejs.org/dist/latest-v20.x/docs/api/http2.html)
    for details.)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 是对 HTTP 协议的更新，旨在提高性能。HTTP/2 使用单个网络连接来交错多个客户端请求，以紧凑的二进制格式发送标头，并允许服务器在请求之前“推送”内容到客户端。Node.js
    在 `http2` 模块中提供了对 HTTP/2 的支持，甚至包括一个兼容性 API，该 API 使用本章中所示的方法以相同的代码处理 HTTP/1.1 和
    HTTP/2 请求。（有关详细信息，请参阅 [https://nodejs.org/dist/latest-v20.x/docs/api/http2.html](https://nodejs.org/dist/latest-v20.x/docs/api/http2.html)）。
- en: But HTTP/2 isn’t an automatic choice for Node.js projects, even though it is
    more efficient. That’s because HTTP/2 benefits applications that have a large
    volume of requests, and applications of that size use a proxy to receive requests
    and fan them out to multiple Node.js servers. The proxy receives HTTP/2 requests
    from clients but communicates with Node.js using HTTP/1.1 requests because the
    HTTP/2 features don’t have much impact inside the data center. You can see an
    example of this type of deployment in *Part 3* of this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但 HTTP/2 并不是 Node.js 项目的自动选择，尽管它更高效。这是因为 HTTP/2 适用于请求量大的应用程序，而此类规模的应用程序使用代理来接收请求并将它们分发到多个
    Node.js 服务器。代理从客户端接收 HTTP/2 请求，但使用 HTTP/1.1 请求与 Node.js 通信，因为 HTTP/2 功能在数据中心内部影响不大。你可以在本书的
    *第 3 部分* 中看到一个此类部署的示例。
- en: For applications that don’t use a proxy, the volume of requests is small enough
    that the efficiencies of HTTP/2 don’t justify the additional complexity that HTTP/2
    adds to development, such as requiring encryption for all requests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用代理的应用程序，请求量足够小，以至于 HTTP/2 的效率不足以证明其给开发带来的额外复杂性，例如要求所有请求加密。
- en: Most Node.js applications still use HTTP/1.1 and you can see this reflected
    in the way that open-source packages for Node.js, such as the Express package
    I use in the next section, remain hugely popular even though they don’t support
    HTTP/2.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Node.js 应用程序仍然使用 HTTP/1.1，你可以在下一节中使用的 Express 包等 Node.js 的开源包中看到这一点，尽管它们不支持
    HTTP/2，但仍然非常受欢迎。
- en: Using third-party enhancements
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方增强功能
- en: The API that Node.js provides for HTTP and HTTPS is comprehensive but can produce
    verbose code that is difficult to read and maintain. One of the joys of JavaScript
    development is the huge range of open-source packages that are available and there
    are many packages that are built on the Node.js API to simplify request handling.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 为 HTTP 和 HTTPS 提供的 API 功能全面，但可能会生成难以阅读和维护的冗长代码。JavaScript 开发的乐趣之一是可用的开源包种类繁多，有许多包是基于
    Node.js API 构建的，用于简化请求处理。
- en: The most popular of these packages is Express. Run the commands shown in *Listing
    5.13* in the `webapp` folder to install the Express package and the TypeScript
    types for Express in the example project.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包中最受欢迎的是 Express。在 `webapp` 文件夹中运行 *列表 5.13* 中显示的命令，以安装 Express 包和示例项目中 Express
    的 TypeScript 类型。
- en: '**Tip**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Don’t worry if you don’t like the way that Express works because there are plenty
    of other packages available that do similar things. A quick web search for Express
    alternatives will give you several options to consider. Bear in mind when choosing
    a package that, as I noted in *Chapter 2*, not all JavaScript packages receive
    long-term support from their creators, and it is worth considering how widely
    a package has been adopted before using it in a project.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢 Express 的工作方式，请不要担心，因为还有许多其他包可供选择。快速在网上搜索 Express 的替代品将为您提供几个可考虑的选项。在选择包时，请记住，正如我在
    *第二章* 中提到的，并非所有 JavaScript 包都从其创建者那里获得长期支持，在使用项目之前考虑包的采用范围是值得的。
- en: 'Listing 5.13: Installing the Express package'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13：安装 Express 包
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Express has many features, which are described in detail at [https://expressjs.com](https://expressjs.com),
    but the two that are most useful are the request router and the enhanced request/response
    types, both of which are described in the sections that follow.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Express 有许多功能，详情请参阅 [https://expressjs.com](https://expressjs.com)，但其中最有用的是请求路由器和增强的请求/响应类型，这两者都在接下来的章节中进行了描述。
- en: Using the Express router
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Express 路由器
- en: Request handler functions that use the Node.js API mix the statements that inspect
    requests with the code that generates responses. A new branch of code is required
    every time a new URL is supported by the application, as shown in *Listing 5.14*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node.js API 的请求处理函数将检查请求的语句与生成响应的代码混合在一起。每当应用程序支持新的 URL 时，都需要一个新的代码分支，如 *列表
    5.14* 所示。
- en: 'Listing 5.14: Supporting a new URL in the handler.ts file in the src folder'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14：在 src 文件夹中的 handler.ts 文件中支持新的 URL
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each new addition makes the code more complex and increases the chances of a
    coding error that either doesn’t match the right requests or generates the wrong
    response.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每次新增都会使代码更加复杂，并增加编码错误的几率，这些错误可能无法匹配正确的请求或生成错误的响应。
- en: The Express *router* solves this problem by separating request matching from
    generating responses. The first step towards using the Express router is to refactor
    the existing request handler code into separate functions that generate responses
    without the statements that inspect requests, as shown in *Listing 5.15*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Express *路由器* 通过将请求匹配与生成响应分离来解决此问题。使用 Express 路由器的第一步是将现有的请求处理代码重构为独立的函数，这些函数生成响应而不包含检查请求的语句，如
    *列表 5.15* 所示。
- en: 'Listing 5.15: Refactoring in the handler.ts file in the src folder'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15：在 src 文件夹中的 handler.ts 文件中进行重构
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The responses are generated in the same way as earlier examples, but each response
    is created by a separate handler function, without the code that matches requests.
    The next step is to use the Express router to match requests and select one of
    the handlers from *Listing 5.15* to produce a result, as shown in *Listing 5.16*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的生成方式与之前的示例相同，但每个响应都是由一个独立的处理函数创建的，没有匹配请求的代码。下一步是使用 Express 路由器来匹配请求并从 *列表
    5.15* 中选择一个处理函数来生成结果，如 *列表 5.16* 所示。
- en: 'Listing 5.16: Using the Express router in the server.ts file in the src folder'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16：在 src 文件夹中的 server.ts 文件中使用 Express 路由器
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `Express` package contains a default export, which is a function named
    `express`, and this is why the new `import` statement looks different:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Express` 包包含一个默认导出，即名为 `express` 的函数，这就是为什么新的 `import` 语句看起来不同的原因：'
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `express` function is invoked to create an `Express` object, which provides
    methods for mapping requests to handler functions. *Table 5.9* describes the most
    useful methods, most of which incorporate the HTTP method into the matching process.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `express` 函数以创建一个 `Express` 对象，该对象提供了将请求映射到处理函数的方法。*表 5.9* 描述了最有用的方法，其中大多数方法都结合了
    HTTP 方法到匹配过程中。
- en: 'Table 5.9: Useful Express methods'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.9：有用的 Express 方法
- en: '| Name | Description |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| This method routes HTTP GET requests that match the path to the specified
    handler function. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 此方法将匹配路径的 HTTP GET 请求路由到指定的处理函数。 |'
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| This method routes HTTP POST requests that match the path to the specified
    handler function. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 此方法将匹配路径的 HTTP POST 请求路由到指定的处理函数。 |'
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| This method routes HTTP PUT requests that match the path to the specified
    handler function. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 此方法将匹配路径的 HTTP PUT 请求路由到指定的处理函数。 |'
- en: '|'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| This method routes HTTP DELETE requests that match the path to the specified
    handler function. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 此方法将匹配路径的 HTTP DELETE 请求路由到指定的处理函数。 |'
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| This method routes all requests that match the path to the specified handler
    function. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 此方法将所有匹配路径的请求路由到指定的处理函数。 |'
- en: '|'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| This method adds a middleware component, which is able to inspect and intercept
    all requests. Later chapters contain examples that use middleware. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 此方法添加了一个中间件组件，该组件能够检查和拦截所有请求。后续章节将包含使用中间件的示例。 |'
- en: 'I am only interested in GET requests in this chapter, and so I used the `get`
    method to specify URL paths and the functions that will generate responses:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中只对 GET 请求感兴趣，因此我使用了 `get` 方法来指定 URL 路径和将生成响应的函数：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These statements are *routes*, and the URLs are specified as patterns that
    allow wildcards, such as the `*` character in this route:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句是 *路由*，URL 被指定为允许通配符的模式，例如此路由中的 `*` 字符：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This matches any GET request and routes it to the `defaultHandler` function.
    Express matches requests to routes in the order in which they are defined, and
    so this is a catch-all route that will be applied if requests are not matched
    by the other routes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配任何 GET 请求并将其路由到 `defaultHandler` 函数。Express 按照定义的顺序匹配请求到路由，因此这是一个通配符路由，如果请求未匹配其他路由，则将应用此路由。
- en: 'In addition to the methods described in *Table 5.9*, the `Express` object is
    also a handler function that can be used with the Node.js `createServer` functions
    defined in the `http` and `https` modules:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 *表 5.9* 中描述的方法之外，`Express` 对象也是一个可以与 `http` 和 `https` 模块中定义的 Node.js `createServer`
    函数一起使用的处理函数：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Express processes all the HTTP requests that Node.js receives and routes them
    to the appropriate handler.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Express 处理 Node.js 收到的所有 HTTP 请求并将它们路由到适当的处理函数。
- en: Using the request and response enhancements
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用请求和响应增强功能
- en: In addition to routing, Express provides enhancements to the `IncomingRequest`
    and `ServerResponse` objects that are passed to handler functions. The object
    that represents the HTTP request is named `Request` and it extends the `IncomingRequest`
    type. The most useful `Request` enhancements are described in *Table 5.10*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路由之外，Express 还为传递给处理函数的 `IncomingRequest` 和 `ServerResponse` 对象提供了增强功能。代表
    HTTP 请求的对象命名为 `Request`，它扩展了 `IncomingRequest` 类型。最有用的 `Request` 增强功能在 *表 5.10*
    中描述。
- en: 'Table 5.10: Useful Express request enhancements'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.10：有用的 Express 请求增强功能
- en: '| Name | Description |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `hostname` | This property provides convenient access to the value of the
    `hostname` header. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `hostname` | 此属性提供了对 `hostname` 标头值的便捷访问。 |'
- en: '| `params` | This property provides access to the route parameters, which are
    described in the *Using Express route parameters* section of this chapter. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `params` | 此属性提供了对路由参数的访问，这些参数在本章的 *使用 Express 路由参数* 部分中描述。 |'
- en: '| `path` | This property returns the path component of the request URL. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `path` | 此属性返回请求 URL 的路径部分。 |'
- en: '| `protocol` | This property returns the protocol used to make the request,
    which will be either `http` or `https`. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `protocol` | 此属性返回用于发出请求的协议，它将是 `http` 或 `https`。 |'
- en: '| `query` | This property returns an object whose properties correspond to
    the query string parameters. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `query` | 此属性返回一个对象，其属性对应于查询字符串参数。 |'
- en: '| `secure` | This property returns `true` if the request has been made using
    HTTPS. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `secure` | 如果请求是使用 HTTPS 发出的，则此属性返回 `true`。 |'
- en: '| `body` | This property is assigned the parsed contents of the request body,
    as demonstrated in *Chapter 6*. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `body` | 此属性被分配了请求体的解析内容，如 *第 6 章* 中所示。 |'
- en: The object that Express uses to represent the HTTP response is named `Response`
    and it extends the `ServerResponse` type. The most useful basic `Response` enhancements
    are described in *Table 5.11*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Express用来表示HTTP响应的对象命名为`Response`，它扩展了`ServerResponse`类型。最有用的基本`Response`增强功能在*表5.11*中描述。
- en: 'Table 5.11: Useful basic Express response enhancements'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.11：有用的基本Express响应增强
- en: '| Name | Description |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| `redirect(code, path)``redirect(path)` | This method sends a redirection
    response. The `code` argument is used to set the response status code and message.
    The `path` argument is used to set the value of the `Location` header. If the
    `code` argument is omitted, then a temporary redirection, with status code `302`,
    is sent. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `redirect(code, path)``redirect(path)` | 此方法发送重定向响应。`code`参数用于设置响应状态码和消息。`path`参数用于设置`Location`头的值。如果省略`code`参数，则发送临时重定向，状态码为`302`。
    |'
- en: '| `send(data)` | This method is used to send a response to the server. The
    status code is set to `200`. This method sets response headers to describe the
    content, including the `Content-Length` and `Content-Type` headers. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `send(data)` | 此方法用于向服务器发送响应。状态码设置为`200`。此方法设置响应头以描述内容，包括`Content-Length`和`Content-Type`头。
    |'
- en: '| `sendStatus(code)` | This method is used to send a status code response and
    will automatically set the status message for well-known status codes, so that
    a status code of `200` will lead to the **OK** message being used, for example.
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `sendStatus(code)` | 此方法用于发送状态码响应，并将自动设置已知状态码的状态消息，例如，状态码`200`将导致使用**OK**消息。
    |'
- en: Other Express enhancements relate to features described in later chapters, but
    the basic additions described in *Table 5.10* and *Table 5.11* are enough to simplify
    the way that responses are generated by the example application, as shown in *Listing
    5.17*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其他Express增强功能与后续章节中描述的功能相关，但*表5.10*和*表5.11*中描述的基本添加足以简化示例应用程序生成响应的方式，如*列表5.17*所示。
- en: 'Listing 5.17: Using the Express enhancements in the handler.ts file in the
    src folder'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.17：在src文件夹中的handler.ts文件中使用Express增强功能
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Express automatically parses the request URL and makes its parts accessible
    through the `Response` properties described in *Table 5.10*, which means I don’t
    have to parse the URL explicitly. The convenient `secure` property means that
    I can remove the `isHttps` function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Express自动解析请求URL，并通过*表5.10*中描述的`Response`属性使URL的各个部分可访问，这意味着我不必显式解析URL。方便的`secure`属性意味着我可以移除`isHttps`函数。
- en: The `Response` methods described in *Table 5.11* reduce the number of statements
    required to produce responses. The `send` method, for example, takes care of setting
    the response status code, sets some useful headers, and calls the `end` method
    to tell Node.js that the response is complete.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*表5.11*中描述的`Response`方法减少了生成响应所需的语句数量。例如，`send`方法负责设置响应状态码，设置一些有用的头信息，并调用`end`方法通知Node.js响应已完成。'
- en: If you request `https://localhost:5500/newurl` and `https://localhost:5500?keyword=Express`,
    you will see the responses shown in *Figure 5.6*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您请求`https://localhost:5500/newurl`和`https://localhost:5500?keyword=Express`，您将看到*图5.6*中显示的响应。
- en: '**Note**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Your browser may use a different font to display these responses, which happens
    because the `Response` methods used to generate responses in *Listing 5.17* set
    the `Content-Type` header in the response to `text/html`. This header was not
    set in previous examples, and it alters the way that most browsers display the
    content.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器可能使用不同的字体来显示这些响应，这是因为*列表5.17*中用于生成响应的`Response`方法在响应中设置了`Content-Type`头为`text/html`。此头在之前的示例中没有设置，并且它改变了大多数浏览器显示内容的方式。
- en: '![](img/B21959_05_06.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_05_06.png)'
- en: 'Figure 5.6: Generating responses using Express'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：使用Express生成响应
- en: Using Express route parameters
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Express路由参数
- en: It is important to understand that Express doesn’t do anything magical and its
    features are built on those provided by Node.js described earlier in the chapter.
    The value of Express is that it makes the Node.js API easier to consume, with
    the result that the code is easier to understand and maintain.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解Express并没有做什么神奇的事情，它的功能建立在章节中较早描述的Node.js提供的基础上。Express的价值在于它使Node.js
    API更容易使用，结果是代码更容易理解和维护。
- en: One especially useful feature that Express provides is specifying *route parameters*,
    which extract values from URL paths when matching requests and make them easily
    accessible through the `Response.params` property, as shown in *Listing 5.18*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Express 提供的一个特别有用的功能是指定 *路由参数*，当匹配请求时从 URL 路径中提取值，并通过 `Response.params` 属性使它们易于访问，如
    *列表 5.18* 所示。
- en: 'Listing 5.18: Using route parameters in the server.ts file in the src folder'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.18：在 src 文件夹中的 server.ts 文件中使用路由参数
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The modified route matches requests when the path begins with `/newurl`. The
    second segment in the URL path is assigned to a route parameter named `message`.
    The parameter is denoted by the colon (the `:` character). For the URL path `/newurl/London`,
    for example, the `message` parameter will be assigned the value `London`. The
    question mark (the `?` character) denotes this is an optional parameter, which
    means the route will match requests even if there is no second URL segment.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的路由在路径以 `/newurl` 开头时匹配请求。URL 路径的第二部分被分配给名为 `message` 的路由参数。参数由冒号（`:` 字符）表示。例如，对于
    URL 路径 `/newurl/London`，`message` 参数将被分配值 `London`。问号（`?` 字符）表示这是一个可选参数，这意味着即使没有第二个
    URL 段，路由也会匹配请求。
- en: Route parameters are an effective way to increase the range of URLs that a route
    can match. *Listing 5.19* uses the `Response.params` property to get the value
    of the `message` parameter and incorporate it into the response.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 路由参数是增加路由可以匹配的 URL 范围的有效方法。*列表 5.19* 使用 `Response.params` 属性获取 `message` 参数的值并将其纳入响应中。
- en: 'Listing 5.19: Consuming a route parameter in the handler.ts file in the src
    folder'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.19：在 src 文件夹中的 handler.ts 文件中消耗路由参数
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Use a browser to request `https://localhost:5500/newurl/London` and you will
    see the response shown in *Figure 5.7*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `https://localhost:5500/newurl/London`，你将看到 *图 5.7* 中显示的响应。
- en: '![](img/B21959_05_07.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_05_07.png)'
- en: 'Figure 5.7: Using a route parameter'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：使用路由参数
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, I described the API features that Node.js provides for receiving
    HTTP requests and producing responses, which is the backbone of server-side web
    application development:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了 Node.js 提供的用于接收 HTTP 请求和生成响应的 API 功能，这是服务器端 Web 应用程序开发的基础：
- en: The Node.js API provides support for receiving HTTP and HTTPS requests.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js API 提供了接收 HTTP 和 HTTPS 请求的支持。
- en: Node.js emits events when requests are received and invokes callback functions
    to handle those requests.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收到请求时，Node.js 会发出事件并调用回调函数来处理这些请求。
- en: Some additional work, such as parsing URLs, is generally required when using
    the Node.js API.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 Node.js API 时，通常需要执行一些额外的工作，例如解析 URL。
- en: Third-party packages, such as Express, build on the Node.js APIs to streamline
    request processing and simplify the code that generates responses.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方包，例如 Express，基于 Node.js API 来简化请求处理并简化生成响应的代码。
- en: In the next chapter, I describe the features Node.js provides for reading and
    writing data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将描述 Node.js 提供的用于读取和写入数据的功能。
