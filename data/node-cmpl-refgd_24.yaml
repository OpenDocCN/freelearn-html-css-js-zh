- en: Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: In the previous chapter, we successfully deployed our service to a cloud provider
    without having to fundamentally change our code. We used a database to store our
    data, and the only thing we needed to do was to point to the new location.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们成功地将我们的服务部署到云提供商，而无需对代码进行根本性的更改。我们使用数据库来存储我们的数据，我们唯一需要做的就是指向新的位置。
- en: It's common, during the specification and development process, to have challenging
    problems with one or more ways of solving them. The ways, or paths, you choose
    throughout the development are called design patterns, as they're part of your
    design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范和开发过程中，遇到具有一种或多种解决方法的有挑战性的问题是常见的。你在开发过程中选择的方法或路径被称为设计模式，因为它们是你设计的一部分。
- en: Some design patterns are more common than others. Some are well-known, others,
    not so much. Some are good design patterns and you should follow them. Others
    are bad because of the disadvantages they bring in the short or long term.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设计模式比其他模式更常见。一些是众所周知的，而另一些则不那么为人所知。一些是好的设计模式，你应该遵循它们。其他则因为它们在短期或长期带来的缺点而不好。
- en: In this chapter, we're going to take a look at the importance of choosing good
    patterns; we will look at some common architectural patterns and review the continuous
    integration we followed through the entire book until we successfully deployed
    to the cloud.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨选择良好模式的重要性；我们将查看一些常见的架构模式，并回顾我们整本书中遵循的持续集成，直到我们成功地将服务部署到云端。
- en: Choosing patterns
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择模式
- en: Patterns are not libraries or classes, they're concepts, reusable solutions
    to common programming problems, tested and optimized for specific use cases. As
    they're just concepts to solve specific problems, they have to be implemented
    in every language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 模式不是库或类，它们是概念，是针对常见编程问题的可重用解决方案，针对特定用例进行了测试和优化。由于它们只是解决特定问题的概念，因此必须在每种语言中实现。
- en: Every pattern has its advantages and disadvantages, and choosing a wrong pattern
    for a problem can cause you a big headache.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模式都有其优点和缺点，为问题选择错误模式可能会给你带来很大的麻烦。
- en: Patterns can speed up the development process because they provide well-tested
    and well-proven development paradigms. Reusing patterns helps prevent issues and
    improves code readability between developers that are familiar with the patterns.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以加快开发过程，因为它们提供了经过良好测试和验证的开发范例。重用模式有助于防止问题，并提高熟悉模式的开发者之间的代码可读性。
- en: Patterns have major importance in high-performance applications. Sometimes,
    in order to achieve some flexibility, patterns introduce a new level of indirection
    in the code, which may reduce performance. You should choose when to introduce
    a pattern or when that introduction will hurt the performance metric you're targeting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模式在高性能应用程序中具有重大意义。有时，为了获得一些灵活性，模式会在代码中引入一个新的间接层次，这可能会降低性能。你应该选择何时引入模式，或者何时引入模式会损害你正在追求的性能指标。
- en: 'Knowing good patterns is essential for avoiding the opposite: anti-patterns.
    An anti-pattern is something that looks good in the beginning but later on turns
    out to look like the worst decision you ever made. Anti-patterns are not specific
    patterns but are more like common errors, seen by the majority as strategies you
    shouldn''t use. Some of the most common and frequent anti-patterns seen out there
    are:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 了解良好的模式对于避免相反的情况：反模式至关重要。反模式是开始看起来不错，但后来却变成你做出的最糟糕决定的某种东西。反模式不是特定的模式，而更像是一些常见的错误，大多数人认为你不应该使用的策略。最常见和最频繁出现的反模式包括：
- en: '**Repeating yourself**: Don''t repeat excessive parts of the code. Lean back,
    look at the big picture and refactor it. Some developers tend to look at this
    refactoring as a complexity of the application, but it can actually turn your
    application simpler. If you think you won''t be able to understand the simplicity
    of your refactoring, don''t forget to add a couple of introductory comments to
    the code.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复自己**：不要重复过多的代码部分。退后一步，看看大局，然后重构它。一些开发者倾向于将这种重构视为应用程序的复杂性，但实际上它可以使你的应用程序更简单。如果你认为你无法理解重构的简单性，不要忘记在代码中添加一些介绍性注释。'
- en: '**Golden hammer or silver bullet**: Don''t think your favorite language or
    framework is universally applicable. Most of the languages can actually do practically
    anything, at least the mature ones, and with a huge community. That doesn''t mean
    a language performs some tasks well. If your goal is performance, try to have
    a couple of hammers in your belt.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金锤或银弹**：不要认为你最喜欢的语言或框架是普遍适用的。大多数语言实际上可以做到任何事情，至少是成熟的那些，以及庞大的社区。这并不意味着语言在执行某些任务时表现良好。如果你的目标是性能，尝试在腰间带上几把锤子。'
- en: '**Coding by exception**: Don''t add new code to handle new cases as they appear.
    By new cases, I don''t mean new features; I mean behavior your code was not expecting.
    For example, when you''re making a file upload feature of some kind, remember
    an error might happen during transfer, the file can be empty, have weird content,
    be huge, and so on.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常编程**：不要在出现新情况时添加新代码来处理。这里的新情况，我说的不是新功能；我说的是代码没有预料到的行为。例如，当你制作某种类型的文件上传功能时，记住在传输过程中可能会发生错误，文件可能为空，内容奇怪，非常大，等等。'
- en: '**Programming by accident**: Don''t program by trial and error until you succeed.
    This is something you should really avoid. Programming by accident can sometimes
    make your code work in some cases (by accident) and produce erroneous behaviors
    in others.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偶然编程**：不要通过试错直到成功来编程。这真的是你应该避免的事情。偶然编程有时可能会使你的代码在某些情况下（偶然）工作，而在其他情况下产生错误的行为。'
- en: Architectural patterns
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构模式
- en: When developing microservices and, more specifically, an ecosystem of microservices,
    some patterns become very obvious, and you'll use them without knowing. Just looking
    at the architectural patterns, here are some that you might find interesting.
    Perhaps you have already used them before.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发微服务，尤其是微服务生态系统时，一些模式变得非常明显，你会在不知不觉中使用它们。仅从架构模式来看，这里有一些你可能觉得有趣的模式。也许你之前已经使用过它们了。
- en: Front Controller
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端控制器
- en: 'The **Front Controller** pattern is when all requests go for a single point
    in your architecture, called the handler, which then processes and dispatches
    the requests to other handlers. This is the pattern used by, for example, load
    balancers and reverses proxies:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**前端控制器**模式是指所有请求都指向你的架构中的一个单一点，称为处理器，然后它处理并调度请求到其他处理器。例如，负载均衡器和反向代理使用这种模式：'
- en: '![](img/9d6b169f-e015-4e4b-a9fb-6f19784bcdb9.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d6b169f-e015-4e4b-a9fb-6f19784bcdb9.png)'
- en: It's useful to scale horizontally, especially when the **Front Controller**
    is just routing requests, so it can handle a lot more requests than each separate
    controller, which need, some time to actually process each request.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 横向扩展很有用，尤其是在**前端控制器**只是路由请求时，这样它可以处理比每个单独控制器更多的请求，而每个控制器需要一些时间来实际处理每个请求。
- en: This pattern is also very useful in helping other services not having to know
    where the controllers are and choosing the one with the lowest load that should
    handle the request faster.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在帮助其他服务不必知道控制器在哪里，并选择负载最低、应该更快处理请求的控制器方面也非常有用。
- en: Layered
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层
- en: 'The layered pattern is common in filesystems and operative systems (and virtual
    machines for that matter). This pattern consists of creating different layers
    that go from the raw data through to the data seen by a user:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 分层模式在文件系统、操作系统（以及虚拟机）中很常见。这种模式包括创建不同的层，从原始数据到用户看到的数据：
- en: '![](img/b9108de4-0f45-4c97-b35e-1a5fae26a05f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9108de4-0f45-4c97-b35e-1a5fae26a05f.png)'
- en: 'The idea is to separate the complexity of the different layers, each one not
    having to know how the others do their tasks:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将不同层的复杂性分开，每一层都不必知道其他层是如何执行它们的任务：
- en: Handling the data structures and storing them in a fast and secure way
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据结构并以快速和安全的方式存储它们
- en: Manipulating the data structures and adding business logic to them
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数据结构并向它们添加业务逻辑
- en: Handling user requests and showing the data in a localised format
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户请求并以本地化格式显示数据
- en: Service Locator
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务定位器
- en: 'The **Service Locator** pattern is actually an anti-pattern. It''s not considered
    a good practice because it adds much more complexity to an ecosystem. The pattern
    consists of a central registry, called a **Service Locator**, where services register
    their abilities, and other services can consult the registry and know where the
    services they need are located:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务定位器**模式实际上是一种反模式。它不被认为是良好的实践，因为它会给生态系统增加更多的复杂性。该模式由一个中央注册表组成，称为**服务定位器**，服务在这里注册它们的能力，其他服务可以咨询注册表，了解它们所需的服务位于何处：'
- en: '![](img/8726196c-a92f-4b0c-a0f2-aed006649424.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8726196c-a92f-4b0c-a0f2-aed006649424.png)'
- en: The **Service Locator** is similar to the Front Controller, but with added complexity,
    as you need to contact the Service Locator and the service you need, instead of
    just making a simple request to a Front Controller.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务定位器**与前端控制器类似，但增加了复杂性，因为你需要联系服务定位器和所需的服务，而不仅仅是向前端控制器发出简单请求。'
- en: Observer
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: 'The Observer pattern is used every day in Node.js. It consists of a **Subject**,
    which maintains a list of dependents, called Observers, which get notified of
    any state change happening on the **Subject**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式在Node.js中每天都会被使用。它由一个**主题**组成，该主题维护一个依赖者列表，称为观察者，它们会收到**主题**上发生的任何状态变化的通知：
- en: '![](img/0035ea4e-a748-478e-81cc-246dfedcf072.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0035ea4e-a748-478e-81cc-246dfedcf072.png)'
- en: You can see this happening every time in your web browser when some code (**Observer**)
    attaches an event listener to an object or interface element (**Subject**).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的网页浏览器中看到这种情况，每次某些代码（**观察者**）将事件监听器附加到对象或界面元素（**主题**）上时。
- en: Publish-Subscribe
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布-订阅
- en: 'Another very similar pattern is the Publish-Subscribe pattern, usually abbreviated
    as **Pub-Sub**. This pattern is almost exactly the same as the previous one. You
    have Subscribers that, as the name implies, subscribe to a specific event, or
    topic, or whatever you want to call it, and then you have Publishers that emit
    those events or send information to those topics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常相似的模式是发布-订阅模式，通常缩写为**Pub-Sub**。这个模式几乎与上一个模式完全相同。你有订阅者，正如其名所示，订阅特定的事件、主题或你想要称之为什么的东西，然后你有发布者，它们会发出这些事件或向这些主题发送信息：
- en: '![](img/d76f8596-5cfc-4d66-97ae-7bf57f0051ae.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d76f8596-5cfc-4d66-97ae-7bf57f0051ae.png)'
- en: The difference to the previous pattern may look very thin but is actually very
    important. The **Pub-Sub** pattern involves a third-party service and, unlike
    the Observer pattern, the Publishers have no knowledge of the Subscribers. This
    removes the need to handle and directly notify the Subscribers, thereby simplifying
    your code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前模式的区别可能看起来非常微小，但实际上非常重要。**发布-订阅**模式涉及第三方服务，与观察者模式不同，发布者对订阅者没有任何了解。这消除了处理和直接通知订阅者的需求，从而简化了你的代码。
- en: This pattern is quite useful for microservice communication. It involves a third
    party that abstracts the state change notification. Also, Publishers and Subscribers
    have no knowledge of each other.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对于微服务通信非常有用。它涉及一个第三方，该第三方抽象化了状态变化的通知。此外，发布者和订阅者对彼此没有任何了解。
- en: Using patterns
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模式
- en: Choosing good design patterns is essentially choosing best practices. Not all
    design patterns fit every purpose, but for many scenarios, they'll make your life
    easier. Perhaps you may not notice any difference in the beginning, but you should
    in the long-term.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 选择好的设计模式本质上是在选择最佳实践。并非所有设计模式都适合每一个目的，但许多情况下，它们会使你的生活变得更轻松。也许一开始你可能不会注意到任何区别，但从长远来看，你应该会注意到。
- en: Good design patterns also have indirect advantages. You'll find more documentation
    and examples online, as well as a broader set of options to choose from, for example,
    when using the Publish-Subscribe pattern, where you'll find many types of implementations
    to integrate with your services.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的设计模式也有间接的优势。你会在网上找到更多的文档和示例，以及更广泛的选择范围，例如，在使用发布-订阅模式时，你将找到许多类型的实现，可以与你的服务集成。
- en: Choosing the pattern that fits your needs also involves planning and knowing
    what you need and what you'll need in the future. Think of the edge cases and
    see if the pattern is capable of handling them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适合你需求的设计模式也涉及到规划和了解你现在需要什么以及将来你需要什么。考虑边缘情况，看看模式是否能够处理它们。
- en: Planning your microservice
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划你的微服务
- en: Developing a microservice may look like a simple task. As the name implies,
    it is a micro service. But that is not necessarily true, as sometimes we tend
    to complexify something that should be simple.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 开发微服务可能看起来像是一项简单的任务。正如其名所示，它是一个微服务。但这也并不一定正确，因为有时我们倾向于将本应简单的事情复杂化。
- en: This does not mean a service should be simple, it can be quite complex. What
    should be simple is the goal and the properties of the service. There shouldn't
    be any doubt regarding what it does and what it shouldn't do.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着服务应该是简单的，它可以相当复杂。应该简单的是服务的目标和属性。关于它做什么以及它不应该做什么，不应该有任何疑问。
- en: 'Before writing any line of code, you should start by knowing a couple of what
    I call characteristics of the service, such as:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何一行代码之前，你应该先了解一些我称之为服务特征的几个方面，例如：
- en: What is it for? What tasks will it do?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是用来做什么的？它将执行哪些任务？
- en: What other services will use it? What protocol will it speak?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他服务将如何使用它？它将使用什么协议？
- en: Will it replace another service? Will it cover the same tasks?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会取代另一个服务吗？它会覆盖相同的任务吗？
- en: This can be summed in one word—purpose. If you don't clearly define its purpose
    and just start developing tasks it can handle, you'll end up having a mixed service
    that deviates from the main goal of a microservice.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用一个词来概括——目的。如果你没有明确定义它的目的，只是开始开发它能够处理的任务，你最终会得到一个混合服务，这与微服务的主要目标相偏离。
- en: After having a proper purpose, you can then choose the best pattern and plan
    the individual tasks. The first task will probably take longer to develop, as
    you're creating the base layout for the service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确目的之后，你可以选择最佳的模式并规划个别任务。第一个任务可能需要更长的时间来开发，因为你正在为服务创建基础布局。
- en: Don't forget to add tests, coverage, and documentation as soon as possible.
    I know this is something most developers tend to ignore, but it will bite you
    later. It's easier to add a simple test for a first simple task. Code coverage
    is easier at this point. Adding documentation should also be easier if you're
    planning the individual tasks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记尽快添加测试、覆盖率和文档。我知道这可能是大多数开发者倾向于忽略的事情，但将来它会给你带来麻烦。对于第一个简单的任务，添加一个简单的测试会更简单。在这个阶段，代码覆盖率也会更容易。如果你在规划个别任务，添加文档也应该更容易。
- en: 'After having your first task, with a proper test, you should set your first
    deploy. This will end your first development cycle and bring you back to planning.
    If you keep this loop going, with small tasks, you''ll develop faster, and deploy
    faster:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成第一个任务并进行了适当的测试后，你应该设置你的第一次部署。这将结束你的第一个开发周期，并带你回到规划阶段。如果你保持这个循环，通过小任务，你会更快地开发和部署：
- en: '![](img/f8b06c25-bf65-4bf1-be50-7ba83cd2977f.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8b06c25-bf65-4bf1-be50-7ba83cd2977f.png)'
- en: This type of simple loop with small tasks will allow you to do what is called
    **continuous integration** and **continuous deployment**, where you're able to
    develop and deploy to a testing cluster. The change can be automatically tested
    and deployed if everything passes the tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的小任务简单循环将允许你进行所谓的**持续集成**和**持续部署**，其中你能够开发并部署到测试集群。如果一切通过测试，更改可以自动测试和部署。
- en: Obstacles when developing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发中的障碍
- en: As we saw previously, a microservice architecture has many advantages, such
    as splitting code into smaller isolated projects, where it becomes easier to develop
    or even delegate responsibility.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，微服务架构有许多优点，例如将代码拆分为更小的孤立项目，这使得开发或甚至委派责任变得更加容易。
- en: These advantages come at a cost, which is the build of a more complex system
    or application. Because of how microservices are supposed to work, an information
    barrier is intrinsic. A microservice responsible for a type of information should
    be the only one manipulating it, forcing any other service to communicate with
    it to have access to information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势是有代价的，那就是构建一个更复杂的系统或应用程序。由于微服务应该如何工作，信息屏障是固有的。负责某种信息的微服务应该是唯一一个操作它的服务，迫使任何其他服务与之通信才能访问信息。
- en: This gives you a finer control over the information because you know the service
    responsible for it, and you can force service or user authentication, with authorization
    or even rate-access limits. But, this means that a complex application will tend
    to penalize the network as there will be significant inter-service messaging.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你对信息有更精细的控制，因为你知道负责它的服务，你可以强制服务或用户身份验证，包括授权甚至速率访问限制。但是，这意味着一个复杂的应用程序往往会惩罚网络，因为会有大量的服务间消息传递。
- en: Inter-service messaging means network traffic and latency. If the services are
    not on the same local network, this will eventually create noticeable latency.
    Adding some kind of cache service to accelerate access will also add more complexity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的消息传递意味着网络流量和延迟。如果服务不在同一个本地网络中，这最终会创建明显的延迟。添加某种缓存服务以加速访问也会增加更多复杂性。
- en: Although testing and development for each microservice should be easier than
    a monolith application, looking at the microservice test frameworks all together,
    and having two or more services test together, is more complicated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个微服务的测试和开发应该比单体应用程序更容易，但整体来看微服务测试框架，并且有两个或更多服务一起测试，会更加复杂。
- en: Finally, avoid something called a nanoservice. This is considered an anti-pattern,
    and it's when you exaggerate on fine-graining your architecture and create overly 
    small services, complexifying your development to the extreme.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，避免一种被称为纳米服务的东西。这被认为是一种反模式，就是你过度细化你的架构，创建了过于小的服务，将你的开发复杂化到了极致。
- en: Find a good balance between the number of microservices and what each will do.
    Think of them as a person that will handle a specific task. Is the task too simple
    to have one person allocated to do just that? Shouldn't the person have a broader
    set of tasks from the same context?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的数量和每个微服务将执行的任务之间找到一个良好的平衡。把它们想象成一个将处理特定任务的人。这个任务是否过于简单以至于只需要一个人来做？这个人不应该有来自同一上下文的更广泛的任务集吗？
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Today's applications have space for microservices. Applications are no longer
    monolith and left the traditional computer architecture long ago. Users constantly
    demand integrations and interoperability between applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的应用程序有空间容纳微服务。应用程序不再是单体架构，并且早已离开了传统的计算机架构。用户不断要求应用程序之间的集成和互操作性。
- en: Microservices help developers to reduce the complexity of applications by separating
    different contexts, such as frontend, backend, mobile, or a simple API. They're
    a concept, or a pattern, that, when used well, can give you great power, and split
    complexity and responsibility.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过分离不同的上下文，如前端、后端、移动或简单的API，帮助开发者降低应用程序的复杂性。它们是一个概念，或者是一个模式，当使用得当，可以给你带来巨大的力量，并分割复杂性和责任。
- en: But, microservices are more than that. Microservices help you scale horizontally
    by just replicating the services you need and not a complete monolith application,
    saving resources and, ultimately, money.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，微服务不仅仅是这样。微服务通过仅复制所需的服务而不是完整的单体应用程序来帮助你水平扩展，节省资源，最终节省金钱。
- en: There's a lot to explore out there; we have just scratched the surface. There
    are plenty of cloud providers and tools for you to experiment with and choose
    what fits you best. Remember, practice makes perfect, so head to your work desk,
    and good luck!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 外面有太多可以探索的东西；我们只是刚刚触及了表面。有大量的云提供商和工具供你实验和选择最适合你的。记住，熟能生巧，所以回到你的工作桌前，祝你好运！
