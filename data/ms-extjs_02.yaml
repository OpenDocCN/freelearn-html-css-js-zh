- en: Chapter 2. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 入门
- en: In this book, we are going to dive into the Sencha Ext JS 5 world and explore
    real-world examples. We will also build a complete application from scratch, from
    the wireframe phase until the deployment in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将深入探索 Sencha Ext JS 5 世界，并研究现实世界的示例。我们还将从头开始构建一个完整的应用程序，从线框阶段直到在生产环境中的部署。
- en: 'Throughout this book, we are going to develop an application to manage a *DVD
    rental store*. In this chapter, we will introduce the application and describe
    its capabilities. You will also learn how to organize the files of the application,
    which is going to be built throughout the chapters of this book. This chapter
    will also present the mockup (wireframe) of the application and how to start organizing
    the screens (which is a very important step and some developers forget to do it).
    In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将开发一个用于管理 *DVD 租赁店* 的应用程序。在本章中，我们将介绍该应用程序及其功能。你还将学习如何组织应用程序的文件，这些文件将在本书的章节中构建。本章还将展示应用程序的草图（线框）以及如何开始组织屏幕（这是一个非常重要的步骤，一些开发者会忘记做）。在本章中，我们将涵盖以下内容：
- en: Preparing the development environment by installing the required software
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过安装所需的软件来准备开发环境
- en: Presenting the application and its capabilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示应用程序及其功能
- en: Creating mockups/wireframes of each screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个屏幕创建草图/线框
- en: Creating the structure of the app using Sencha Cmd
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sencha Cmd 创建应用程序的结构
- en: Creating the loading page (splash screen)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建加载页面（启动画面）
- en: Preparing the development environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: The application that we are going to develop has a very simple architecture.
    We are going to use Ext JS 5 on the frontend, which is going to communicate with
    a server-side module using Ajax/JSON, which will then communicate with a database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发的应用程序具有一个非常简单的架构。我们将在前端使用 Ext JS 5，它将通过 Ajax/JSON 与后端模块通信，然后该模块将与数据库通信。
- en: 'The following diagram encapsulates the preceding paragraph:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概括了前面的段落：
- en: '![Preparing the development environment](img/0457OT_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![准备开发环境](img/0457OT_02_01.jpg)'
- en: The server-side module will be developed using PHP. You need not worry if you
    don't know PHP. We are going to use very basic code (no frameworks), and we are
    going to focus on the programming logic that needs to be implemented on the server
    side. This way, you can apply the same logic using any other programming language,
    such as Java, ASP.NET, Ruby, Python, or any other (that supports the exchange
    of data in JSON or XML format as this is the communication format used by Ext
    JS). For the database, we will use MySQL. We will also use the Sakila sample schema
    ([http://dev.mysql.com/doc/sakila/en/](http://dev.mysql.com/doc/sakila/en/)),
    a free MySQL sample database, which is perfect to demonstrate how to work with
    **Create, Read, Update, and Delete/Destroy** (**CRUD**) operations on a database
    table and also use more complex operations, such as views and stored procedures
    (we will learn how to handle all this information with Ext JS).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 后端模块将使用 PHP 开发。如果你不知道 PHP，无需担心。我们将使用非常基础的代码（无框架），并将重点放在需要在服务器端实现的编程逻辑上。这样，你可以使用任何其他编程语言，如
    Java、ASP.NET、Ruby、Python 或任何其他（支持以 JSON 或 XML 格式交换数据，因为这是 Ext JS 使用的通信格式）来应用相同的逻辑。对于数据库，我们将使用
    MySQL。我们还将使用 Sakila 示例模式([http://dev.mysql.com/doc/sakila/en/](http://dev.mysql.com/doc/sakila/en/))，这是一个免费的
    MySQL 示例数据库，非常适合演示如何在数据库表中执行 **创建、读取、更新和删除/销毁**（**CRUD**）操作，以及使用更复杂的操作，如视图和存储过程（我们将学习如何使用
    Ext JS 处理所有这些信息）。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are a Java developer, you can find some sample code on how to integrate
    Java with Ext JS at [http://goo.gl/rv76E2](http://goo.gl/rv76E2) and [http://goo.gl/nNIRuQ](http://goo.gl/nNIRuQ).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 Java 开发者，你可以在[http://goo.gl/rv76E2](http://goo.gl/rv76E2)和[http://goo.gl/nNIRuQ](http://goo.gl/nNIRuQ)找到一些如何将
    Java 与 Ext JS 集成的示例代码。
- en: Also, we will need to have Sencha Cmd installed (we have already installed Sencha
    Cmd during [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"), *Sencha
    Ext JS Overview*). However, we still need to execute some extra steps to have
    it configured. Once configured, we will be able to create the application structure,
    customize the theme, and also make the production build. Sencha Cmd requires having
    Ruby compatible with versions 1.8 or 1.9 (version 2.x will not work). We also
    need to have Apache Ant installed (and because Apache Ant is built with Java,
    we also need to have Java installed and configured in our computer).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要安装Sencha Cmd（我们已经在[第1章](ch01.html "第1章. Sencha Ext JS概述")中安装了Sencha
    Cmd，*Sencha Ext JS概述*）。然而，我们仍然需要执行一些额外的步骤来配置它。一旦配置完成，我们就能创建应用程序结构，定制主题，并制作生产版本。Sencha
    Cmd需要Ruby与1.8或1.9版本兼容（2.x版本将无法使用）。我们还需要安装Apache Ant（由于Apache Ant是用Java构建的，因此我们还需要在计算机上安装和配置Java）。
- en: After we have finished implementing the application, we will customize the theme,
    and because of this, we will need to install Ruby (1.8 or 1.9) and the Sass and
    Compass gems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成应用程序的实现后，我们将定制主题，因此我们需要安装Ruby（1.8或1.9）以及Sass和Compass宝石。
- en: To deploy the application, we need a web server. If you do not have any web
    server installed on your computer yet, do not worry. In this book, we will use
    Xampp as the default web server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署应用程序，我们需要一个Web服务器。如果您尚未在计算机上安装任何Web服务器，请不要担心。在这本书中，我们将使用Xampp作为默认的Web服务器。
- en: We will also need a browser to run our application in. The recommended ones
    are Firefox (with Firebug) or Google Chrome.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个浏览器来运行我们的应用程序。推荐使用Firefox（带Firebug）或Google Chrome。
- en: 'If you do not have any of the software or technologies mentioned previously
    installed on your computer, don''t worry. To summarize all the tools and software
    we need to have installed prior to starting the fun, here is a list with the links
    where you can download them and find installation instructions (all items are
    available for Windows, Linux, and Mac OS):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前提到的任何软件或技术尚未安装在您的计算机上，请不要担心。为了总结在开始有趣的工作之前我们需要安装的所有工具和软件，以下是一个包含下载链接和安装说明的列表（所有项目均适用于Windows、Linux和Mac
    OS）：
- en: 'A browser with a debugger tool:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有调试工具的浏览器：
- en: 'Firefox with Firebug: [https://www.mozilla.org/firefox/](https://www.mozilla.org/firefox/)
    and [http://getfirebug.com/](http://getfirebug.com/)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Firebug的Firefox：[https://www.mozilla.org/firefox/](https://www.mozilla.org/firefox/)
    和 [http://getfirebug.com/](http://getfirebug.com/)
- en: 'Google Chrome: [www.google.com/chrome](http://www.google.com/chrome)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Chrome：[www.google.com/chrome](http://www.google.com/chrome)
- en: 'Web server:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器：
- en: 'Xampp: [http://www.apachefriends.org/en/xampp.html](http://www.apachefriends.org/en/xampp.html)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xampp：[http://www.apachefriends.org/en/xampp.html](http://www.apachefriends.org/en/xampp.html)
- en: 'Database:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库：
- en: 'MySQL: [http://dev.mysql.com/downloads/mysql/](http://dev.mysql.com/downloads/mysql/)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL：[http://dev.mysql.com/downloads/mysql/](http://dev.mysql.com/downloads/mysql/)
- en: 'MySQL Workbench: [http://dev.mysql.com/downloads/tools/workbench/](http://dev.mysql.com/downloads/tools/workbench/)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL Workbench：[http://dev.mysql.com/downloads/tools/workbench/](http://dev.mysql.com/downloads/tools/workbench/)
- en: 'MySQL Sakila sample database: [http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html)
    and [http://dev.mysql.com/doc/sakila/en/index.html](http://dev.mysql.com/doc/sakila/en/index.html)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL Sakila示例数据库：[http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html)
    和 [http://dev.mysql.com/doc/sakila/en/index.html](http://dev.mysql.com/doc/sakila/en/index.html)
- en: 'Sencha Command required tools:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sencha Command所需工具：
- en: 'Ruby: [http://www.ruby-lang.org/en/downloads/](http://www.ruby-lang.org/en/downloads/)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby：[http://www.ruby-lang.org/en/downloads/](http://www.ruby-lang.org/en/downloads/)
- en: 'Sass: [http://sass-lang.com/](http://sass-lang.com/)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass：[http://sass-lang.com/](http://sass-lang.com/)
- en: 'Compass: [http://compass-style.org/](http://compass-style.org/)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 罗盘：[http://compass-style.org/](http://compass-style.org/)
- en: 'Java JDK (Java 7 or later): [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java JDK（Java 7或更高版本）：[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)
- en: 'Java environment variables: [http://docs.oracle.com/javase/tutorial/essential/environment/paths.html](http://docs.oracle.com/javase/tutorial/essential/environment/paths.html)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java环境变量：[http://docs.oracle.com/javase/tutorial/essential/environment/paths.html](http://docs.oracle.com/javase/tutorial/essential/environment/paths.html)
- en: 'Apache Ant: [http://ant.apache.org/bindownload.cgi](http://ant.apache.org/bindownload.cgi)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Ant：[http://ant.apache.org/bindownload.cgi](http://ant.apache.org/bindownload.cgi)
- en: Of course, we also need Ext JS SDK and Sencha Cmd, which we downloaded and installed
    in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"), *Sencha Ext JS
    Overview*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要Ext JS SDK和Sencha Cmd，这些我们在[第1章](ch01.html "第1章. Sencha Ext JS 概述")中下载并安装了，*Sencha
    Ext JS 概述*。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To help you configure the required development environment in order to be able
    to create the application from this book, here is a video that demonstrates it
    step by step (step by step done for Windows environment—the Linux and Mac OS setup
    is very similar): [http://youtu.be/B43bEnFBRRc](http://youtu.be/B43bEnFBRRc).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你配置所需的开发环境，以便能够从本书创建应用程序，这里有一个逐步演示的视频（逐步完成Windows环境——Linux和Mac OS的设置非常相似）：[http://youtu.be/B43bEnFBRRc](http://youtu.be/B43bEnFBRRc)。
- en: Presenting the application and its capabilities
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示应用程序及其功能
- en: The application we are going to develop throughout this book is very common
    to other web systems you are probably used to implementing. We will implement
    a DVD Rental Store management application (that is why the use of the Sakila sample
    database). Some of the features of the application are the security management
    (able to manage users and their permissions within the application), which manage
    actors, films, inventory, and rental information.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中开发的应用程序与其他你可能习惯实现的其他Web系统非常相似。我们将实现一个DVD租赁店管理应用程序（这就是为什么使用Sakila示例数据库）。应用程序的一些功能包括安全管理（能够在应用程序中管理用户及其权限）、管理演员、电影、库存和租赁信息。
- en: Ext JS will help you to achieve your goal. It provides beautiful components,
    a complete architecture, the possibility to reuse components (and decreases our
    work), and a very complete data package (that makes it easier to make connections
    to the server side and send and retrieve information).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS将帮助你实现目标。它提供了美观的组件、完整的架构、组件重用的可能性（减少了我们的工作量），以及一个非常完整的数据包（使得连接到服务器端和发送、检索信息变得更容易）。
- en: We will divide the application into modules, and each module will be responsible
    for some features of the application. In each chapter of this book, we will implement
    one of the modules.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把应用程序分成模块，每个模块将负责应用程序的一些功能。在这本书的每一章中，我们将实现一个模块。
- en: 'The application is composed of:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序由以下部分组成：
- en: A splash screen (so the user does not need to see a blank screen while the application
    is still launching)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动屏幕（这样在应用程序仍在启动时，用户就不需要看到空白屏幕）
- en: A main screen
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主屏幕
- en: A login screen
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录屏幕
- en: User administration screen
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理屏幕
- en: MySQL tables management (for categories, and combobox values—static data)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL表管理（用于类别和组合框值——静态数据）
- en: Content management control
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容管理控制
- en: For each of the modules and screens mentioned in the preceding list, we will
    create mockups, so we can plan how the application will work. Here, you will learn
    more about each one of them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面列表中提到的每个模块和屏幕，我们将创建原型，这样我们就可以规划应用程序的工作方式。在这里，你将了解它们中的每一个。
- en: The splash screen
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动屏幕
- en: 'Our application will have a splash screen, so the user does not need to see
    a blank page while the application is still loading the required files and classes
    prior to its initialization. Here''s a screenshot that illustrates a splash screen
    aptly:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有一个启动屏幕，这样在应用程序还在加载初始化之前所需的文件和类时，用户就不需要看到空白页面。以下是一个展示启动屏幕的截图：
- en: '![The splash screen](img/0457OT_02_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![启动屏幕](img/0457OT_02_02.jpg)'
- en: We will cover the implementation of this screen later in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面介绍这个屏幕的实现。
- en: The login screen
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录屏幕
- en: 'After the application is fully loaded, the first screen the user will see is
    the login screen. The user will be able to enter the **User Name** and **Password**.
    There is also a multilingual combobox, where the user can choose the language
    of the system (multilingual capability). Then, we have the **Cancel** and **Submit**
    buttons, as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序完全加载后，用户将看到的第一个屏幕是登录屏幕。用户将能够输入**用户名**和**密码**。还有一个多语言组合框，用户可以选择系统的语言（多语言功能）。然后，我们有**取消**和**提交**按钮，如下面的截图所示：
- en: '![The login screen](img/0457OT_02_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![登录屏幕](img/0457OT_02_03.jpg)'
- en: The **Cancel** button resets the **Login** form and the **Submit** button will
    trigger an event that will create an Ajax request and send the user credentials
    to the server for authentication. If the user is successfully authenticated, then
    we display the main screen; otherwise, we display an error message.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**取消**按钮将重置**登录**表单，而**提交**按钮将触发一个事件，该事件将创建一个Ajax请求并将用户凭据发送到服务器进行认证。如果用户认证成功，则显示主屏幕；否则，显示错误消息。'
- en: We will cover the implementation of the login screen in [Chapter 3](ch03.html
    "Chapter 3. The Login Page"), *The Login Page*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 [3 章](ch03.html "第3章。登录页面")，*登录页面* 中介绍登录屏幕的实现。
- en: The main screen
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主屏幕
- en: 'The general idea of the application is to have a main screen that will be organized
    using border layout. Border Layout is divided into five regions: north, south,
    east, west, and center, of which all but the east region are demonstrated in the
    following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的一般思路是使用边框布局来组织主屏幕。边框布局分为五个区域：北、南、东、西和中心，其中除了东区域外，以下图中都进行了演示：
- en: '![The main screen](img/0457OT_02_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![主屏幕](img/0457OT_02_04.jpg)'
- en: In the **Center Region**, we will have a tab panel, and each tab represents
    a screen of the application (each screen will have its own layout)—only the first
    tab can not be closed (**Home**) tab. In the **North Region** we will have a header
    with the name of the application (**DVD Rental Store Manager**), the multilingual
    combobox (if the user wants to change the current language of the application)
    and a **Logout** button. In the **South Region**, we will have the footer with
    a copyright message (or it can be the name of the company or developer that implemented
    the project). And in the **West Region**, we will have a dynamic menu (we will
    implement user control management). The menu will be dynamic and will be rendered
    based on the permissions that the user has in the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在**中心区域**，我们将有一个标签面板，每个标签代表应用程序的一个屏幕（每个屏幕将有自己的布局）——只有第一个标签不能关闭（**主页**标签）。在**北区域**，我们将有一个包含应用程序名称（**DVD租赁店管理器**）、多语言组合框（如果用户想要更改应用程序的当前语言）和**注销**按钮的页眉。在**南区域**，我们将有一个包含版权信息的页脚（或者它可以是实施项目的公司或开发者的名称）。在**西区域**，我们将有一个动态菜单（我们将实现用户控制管理）。菜单将是动态的，并将根据用户在应用程序中的权限进行渲染。
- en: 'The main screen will look somewhat like the following mockup:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 主屏幕将看起来大致如下所示：
- en: '![The main screen](img/0457OT_02_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![主屏幕](img/0457OT_02_05.jpg)'
- en: We will cover the implementation of the main screen and the multilingual and
    logout capabilities in [Chapter 4](ch04.html "Chapter 4. The Logout and Multilingual
    Capabilities"), *The Logout and Multilingual Capabilities*. And in [Chapter 5](ch05.html
    "Chapter 5. Advanced Dynamic Menu"), *Advanced Dynamic Menu*, we will cover how
    to generate a dynamic menu.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 [4 章](ch04.html "第4章。注销和多语言功能")，*注销和多语言功能* 中介绍主屏幕的实现以及多语言和注销功能。在第 [5 章](ch05.html
    "第5章。高级动态菜单")，*高级动态菜单* 中，我们将介绍如何生成动态菜单。
- en: User administration
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户管理
- en: 'In the user control management, the user will have access to create new users
    and new groups and assign new roles to users. The user will be able to control
    the system permissions (which user can see which modules in the system). This
    is how the **Create/Edit User** page looks:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户控制管理中，用户将能够创建新用户和新组，并为用户分配新角色。用户将能够控制系统权限（哪些用户可以看到系统中的哪些模块）。这是**创建/编辑用户**页面的样子：
- en: '![User administration](img/0457OT_02_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![用户管理](img/0457OT_02_06.jpg)'
- en: We will cover the implementation of user administration in [Chapter 6](ch06.html
    "Chapter 6. User Management"), *User Management*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 [6 章](ch06.html "第6章。用户管理")，*用户管理* 中介绍用户管理的实现。
- en: MySQL table management
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL表管理
- en: 'Every system has information that is considered static data, such as film categories,
    film language, combobox options, and so on. For these tables, we need to provide
    all CRUD options and also filter options. The screens from this module will be
    very similar to the **Edit Table Data** option from **MySQL Workbench**., as shown
    in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都有被认为是静态数据的信息，例如电影类别、电影语言、组合框选项等。对于这些表，我们需要提供所有CRUD选项和过滤选项。此模块的屏幕将非常类似于**MySQL
    Workbench**中的**编辑表数据**选项，如下面的截图所示：
- en: '![MySQL table management](img/0457OT_02_07.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![MySQL表管理](img/0457OT_02_07.jpg)'
- en: 'The user will be able to edit the data in the rows of the grid, similar to
    what can be done in MS Excel. Once the user is done making the changes, they can
    click on the **Save Changes** button to save all modified data to the server and
    database. The following is how the **Browser Window** view looks:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将能够编辑网格中的行数据，类似于在 MS Excel 中可以执行的操作。一旦用户完成更改，他们可以点击**保存更改**按钮，将所有修改后的数据保存到服务器和数据库中。以下是如何查看**浏览器窗口**视图：
- en: '![MySQL table management](img/0457OT_02_08.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![MySQL 表管理](img/0457OT_02_08.jpg)'
- en: We will cover the implementation of this module in [Chapter 7](ch07.html "Chapter 7. Static
    Data Management"), *Static Data Management*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 7 章[静态数据管理](ch07.html "第 7 章。静态数据管理")中介绍这个模块的实现，*静态数据管理*。
- en: Content management control
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容管理控制
- en: In this module, the user will be able to see and edit the core information from
    the system. As most of the database tables we will be handling in this module
    have a relationship with other tables, the editing of the information will be
    more complex, involving the master-detail relationship. Usually, we will present
    the information to the user in a data grid (a list or a table), and the addition
    of the information will be made in such a form that it will be displayed inside
    a pop-up window.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本模块中，用户将能够查看和编辑系统中的核心信息。由于我们将在本模块中处理的数据库表中的大多数都与其他表有关联，因此信息的编辑将更加复杂，涉及主从关系。通常，我们将信息以数据网格（列表或表格）的形式呈现给用户，信息的添加将以弹出窗口内显示的形式进行。
- en: 'It is also very important to remember that most of the screens from a module
    will have similar capabilities, and since we are going to build an application
    with a lot of screens, it is important to design the system to be able to reuse
    as much code as possible, making the system easy to maintain and easy to add new
    features and capabilities to. The following screen depicts the capabilities we
    have discussed in this section:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还非常重要的一点是要记住，大多数模块的屏幕将具有类似的功能，并且由于我们将构建一个包含许多屏幕的应用程序，因此设计系统以便尽可能多地重用代码，使系统易于维护并易于添加新功能和能力是非常重要的。以下屏幕展示了本节中讨论的功能：
- en: '![Content management control](img/0457OT_02_09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![内容管理控制](img/0457OT_02_09.jpg)'
- en: 'When clicking on **Add** or **Edit**, a new pop-up window will open to edit
    the information, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**添加**或**编辑**时，将打开一个新弹出窗口来编辑信息，如下所示：
- en: '![Content management control](img/0457OT_02_10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![内容管理控制](img/0457OT_02_10.jpg)'
- en: We will cover the implementation of this module in [Chapter 8](ch08.html "Chapter 8. Content
    Management"), *Content Management*, and [Chapter 9](ch09.html "Chapter 9. Adding
    Extra Capabilities"), *Adding Extra Capabilities*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 8 章[内容管理](ch08.html "第 8 章。内容管理")和第 9 章[添加额外功能](ch09.html "第 9 章。添加额外功能")中介绍这个模块的实现，*添加额外功能*。
- en: Charts
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表
- en: 'In the charts module, we will create a chart in Ext JS. For the same chart
    information, the user will be able to generate different types of charts. The
    user will also be able to export the chart to an image, SVG, or PDF, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表模块中，我们将使用 Ext JS 创建图表。对于相同的图表信息，用户将能够生成不同类型的图表。用户还可以将图表导出为图像、SVG 或 PDF，如下所示：
- en: '![Charts](img/0457OT_02_11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/0457OT_02_11.jpg)'
- en: We will cover the implementation of this module in [Chapter 9](ch09.html "Chapter 9. Adding
    Extra Capabilities"), *Adding Extra Capabilities*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 9 章[添加额外功能](ch09.html "第 9 章。添加额外功能")中介绍这个模块的实现，*添加额外功能*。
- en: Creating the application with Sencha Cmd
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sencha Cmd 创建应用程序
- en: Let's get started and get our hands on the code. The first thing we are going
    to do is create the application using the MVC structure. Sencha Command (referred
    to as Sencha Cmd from now on) provides the capability of creating the application
    structure automatically for us. Utilizing Sencha Cmd is helpful not only because
    it creates the structure according to the MVC architecture for our application,
    but also because it provides all the files we need later on when going live with
    the software and to customize its theme—we'll learn more about this in a later
    chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始动手编写代码。我们将要做的第一件事是使用 MVC 结构创建应用程序。从现在起，我们将称之为 Sencha 命令（Sencha Cmd），它为我们提供了自动创建应用程序结构的功能。利用
    Sencha Cmd 不仅因为它为我们根据 MVC 架构创建应用程序结构，而且还因为它提供了我们在软件上线和定制主题时需要的所有文件——我们将在后面的章节中了解更多关于这一点。
- en: A quick word about MVC
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单谈谈 MVC
- en: '**MVC** stands for **Model-View-Controller**. It is a software architecture
    pattern that separates the representation of the information from the user''s
    interaction with it. The Model represents the application data, the View represents
    the output of the representation of the data (form, grid, chart), and the Controller
    mediates the input, converting it into commands for the Model or View.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC**代表**模型-视图-控制器**。它是一种软件架构模式，将信息的表示与用户的交互分离。模型表示应用程序数据，视图表示数据的表示输出（表单、网格、图表），控制器协调输入，将其转换为模型或视图的命令。'
- en: Ext JS supports MVC**,** which is a Model-View-Controller pattern (as one of
    the architecture options, it also provides a **Model-View-View-Model** (**MVVM**),
    which we will discuss later). The Model is a representation of the data we want
    to manipulate in our application, a representation of a table from the database.
    The View is all the components and screens we create to manage the information
    of a Model. As Ext JS is event-driven, all the View instances fire events when
    the user interacts with them, the Controller can be configured to listen to events
    raised from the View, and the developer can implement custom handlers to respond
    to these events. The Controller can also redirect the command to the Model (or
    Store) or the View. And the Store in Ext JS is very similar to the **Data Access
    Object** (**DAO**) pattern used on server-side technologies (with more capabilities
    such as sorting and filtering, introduced in [Chapter 1](ch01.html "Chapter 1. Sencha
    Ext JS Overview"), *Sencha Ext JS Overview*).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 支持MVC**模式**，这是一种模型-视图-控制器模式（作为架构选项之一，它还提供了**模型-视图-视图模型**（MVVM），我们将在后面讨论）。模型是我们想要在应用程序中操作的数据的表示，是数据库中表的表示。视图是我们创建的所有组件和屏幕，用于管理模型的信息。由于Ext
    JS是事件驱动的，所有视图实例在用户与之交互时都会触发事件，控制器可以配置为监听从视图引发的事件，开发者可以实施自定义处理程序来响应这些事件。控制器还可以将命令重定向到模型（或存储）或视图。在Ext
    JS中，存储与在服务器端技术中使用的**数据访问对象**（DAO）模式非常相似（在[第1章](ch01.html "第1章. Sencha Ext JS 概述"
    "Sencha Ext JS Overview"）中介绍了更多功能，如排序和过滤）。
- en: 'For a quick example, let''s say we have **WidgetA**, which is a GridPanel that
    displays all the records from a table. This table is represented by **ModelA**.
    **StoreA** is responsible for retrieving the information (collection of **ModelA**
    from the server). When the user clicks on a record from **WidgetA**, a window
    will be opened (called **WidgetB**) displaying information from a table (represented
    by **ModelB**). And of course, **StoreB** will be responsible for retrieving the
    collection of **ModelB** from server. In this case, we will have **ControllerA**
    to capture the `itemclick` event from **WidgetA**, do all the required logic to
    display **WidgetB**, and load all the **ModelB** information. If we try to put
    this into a quick reference diagram, it would be something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速示例，假设我们有一个**WidgetA**，它是一个GridPanel，用于显示表中的所有记录。这个表由**ModelA**表示。**StoreA**负责从服务器检索信息（**ModelA**的集合）。当用户点击**WidgetA**中的记录时，将打开一个窗口（称为**WidgetB**），显示表中的信息（由**ModelB**表示）。当然，**StoreB**将负责从服务器检索**ModelB**的集合。在这种情况下，我们将有**ControllerA**来捕获**WidgetA**的`itemclick`事件，执行所有必要的逻辑以显示**WidgetB**，并加载所有**ModelB**信息。如果我们尝试将其放入快速参考图中，它可能看起来像这样：
- en: '![A quick word about MVC](img/0457OT_02_12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![关于MVC的简要说明](img/0457OT_02_12.jpg)'
- en: Creating the application
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: We are going to create the application inside the `htdocs` folder of our Xampp
    directory. Our application will be named `masteringextjs`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Xampp目录的`htdocs`文件夹中创建应用程序。我们的应用程序将命名为`masteringextjs`。
- en: 'Before we start, let''s take a look how the `htdocs` folder looks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们看看`htdocs`文件夹的样貌：
- en: '![Creating the application](img/0457OT_02_13.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序](img/0457OT_02_13.jpg)'
- en: We still have the original Xampp files in there, and the Ext JS 5 SDK folder,
    along with the Ext JS 5 documentation folder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有原始的Xampp文件，以及Ext JS 5 SDK文件夹和Ext JS 5文档文件夹。
- en: The next step is to use Sencha Cmd to create the application for us. To do so,
    we need to open the terminal application that comes with the operating system
    we 're using. For Linux and Mac OS users, this would be the terminal application.
    For Windows users, it's the Command Prompt application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用Sencha Cmd为我们创建应用程序。为此，我们需要打开操作系统附带的终端应用程序。对于Linux和Mac OS用户，这将是一个终端应用程序。对于Windows用户，它是命令提示符应用程序。
- en: 'Here are the steps that we are going to execute:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要执行的步骤：
- en: First, we need to change the current directory to the Ext JS directory (`htdocs/ext-5.0.0`
    in this case).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将当前目录更改为 Ext JS 目录（在本例中为 `htdocs/ext-5.0.0`）。
- en: 'Then, we will use the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下命令：
- en: '[PRE0]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `sencha generate app` command will create the `masteringextjs` directory
    inside the `htdocs` folder with the necessary file structure required by the MVC
    architecture as used by ExtJS. `Packt` is the name of the namespace of our application,
    which means that every class we create is going to start with `Packt`, for example,
    `Packt.model.Actor`, `Pack.view.Login`, and so on. And the last argument passed
    to the command is the directory where the application will be created. In this
    case, it is inside a folder named `masteringextjs`, which is located inside the
    `htdocs` folder.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`sencha generate app` 命令将在 `htdocs` 文件夹内创建 `masteringextjs` 目录，并包含 ExtJS 所需的
    MVC 架构所需的必要文件结构。`Packt` 是我们应用程序的命名空间名称，这意味着我们创建的每个类都将以 `Packt` 开头，例如，`Packt.model.Actor`，`Pack.view.Login`
    等。命令传递的最后一个参数是应用程序将被创建的目录。在这种情况下，它位于 `htdocs` 文件夹内的 `masteringextjs` 文件夹中。'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Namespaces are used for scoping variables and classes so that they are not global,
    defining deeply their nested structures. Sencha has a good article about namespaces
    at [http://goo.gl/2iLxcn](http://goo.gl/2iLxcn).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间用于变量和类的范围，以确保它们不是全局的，并深入定义它们的嵌套结构。Sencha 在 [http://goo.gl/2iLxcn](http://goo.gl/2iLxcn)
    有关于命名空间的好文章。
- en: 'After the command finishes its execution, we will have something like what
    is shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行完成后，我们将得到以下截图所示的内容：
- en: '![Creating the application](img/0457OT_02_14.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序](img/0457OT_02_14.jpg)'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code presented in this book was written with Ext JS 5.0 (so you will
    see the screenshots with version 5.0) and upgraded to 5.1 once it was released.
    So once you download its source code, it will be compatible with version 5.1\.
    Upgrading the source code from 5.0 to 5.1 does not have any impact.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的源代码是用 Ext JS 5.0 编写的（因此您将看到带有 5.0 版本的截图），并在发布后升级到 5.1。因此，一旦您下载其源代码，它将与 5.1
    版本兼容。从 5.0 升级到 5.1 的源代码没有任何影响。
- en: 'But why do we need to create a project structure like this one? The following
    is the structure used by Ext JS applications:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们需要创建这样的项目结构呢？以下是由 Ext JS 应用程序使用的结构：
- en: '![Creating the application](img/0457OT_02_15.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![创建应用程序](img/0457OT_02_15.jpg)'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the `Sencha generate app` command, please consult
    [http://docs.sencha.com/cmd/5.x/extjs/cmd_app.html](http://docs.sencha.com/cmd/5.x/extjs/cmd_app.html).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Sencha generate app` 命令的更多信息，请参阅 [http://docs.sencha.com/cmd/5.x/extjs/cmd_app.html](http://docs.sencha.com/cmd/5.x/extjs/cmd_app.html)。
- en: Let's see what each folder does.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个文件夹的作用。
- en: 'First we have the `app` folder. This is where we will create all the code for
    our application. Inside the `app` folder, we can find the following folders as
    well: `controller`, `model`, `store`, and `view`. We can also find the `Application.js`
    file. Let''s have a detailed look at them. In the `model` folder, we will create
    all files that represent a Model, which is an Ext JS class that represents a set
    of fields, which means that an object that our application manages (actor, country,
    film, and so on). It is similar to a class on the server side with only the attributes
    of the class plus the getter and setter methods used to represent a table from
    the database.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `app` 文件夹。这是我们创建应用程序所有代码的地方。在 `app` 文件夹内，我们还可以找到以下文件夹：`controller`，`model`，`store`
    和 `view`。我们还可以找到 `Application.js` 文件。让我们详细了解一下它们。在 `model` 文件夹中，我们将创建所有代表 Model
    的文件，Model 是一个 Ext JS 类，它代表一组字段，这意味着它是我们应用程序管理的对象（演员、国家、电影等）。它与服务器端上的类类似，只是具有类的属性以及用于表示数据库表的
    getter 和 setter 方法。
- en: On the `store` folder, we will create all the `Store` classes, which are caches
    of collections of Model instances. The `store` folder also has capabilities similar
    to DAO**—**classes used on server-side languages to perform CRUD operations on
    the database. As Ext JS does not communicate directly with databases, the `Store`
    classes are used to communicate with the server side or a local storage—used with
    a Proxy. Proxies are used by Store or Model instances to handle the loading and
    saving of Model data, and it is the place where we are going to configure how
    we want to communicate with the server (using Ajax and using JSON or XML, formatting
    the data so that the client and the backend understand each other).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`store`文件夹中，我们将创建所有的`Store`类，这些类是模型实例集合的缓存。`store`文件夹也具有类似于DAO**—**在服务器端语言中用于在数据库上执行CRUD操作的类的功能。由于Ext
    JS不直接与数据库通信，因此使用`Store`类与服务器端或本地存储（使用Proxy）进行通信。Proxies由Store或Model实例用于处理Model数据的加载和保存，这是我们配置如何与服务器通信（使用Ajax和使用JSON或XML格式化数据，以便客户端和后端能够相互理解）的地方。
- en: On the `view` folder, we will create all `view` classes, also known as the **User
    Interface Components** (**UI Components**), such as grids, trees, menus, forms,
    windows, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`view`文件夹中，我们将创建所有的`view`类，也称为**用户界面组件**（**UI组件**），例如网格、树、菜单、表单、窗口等。
- en: And finally, in the `controller` folder, we can create classes that will handle
    the events fired by the components (events fired because of the life cycle of
    the component or because of some *interaction* of the user with a component).
    We always need to remember that Ext JS is *event-driven*, and on the `Controller`
    classes, we will control these events and update any Model, View, or Store (if
    required). Some examples of events fired would be a click or mouseover of a button,
    an `itemclick` event of a row of a grid, and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`controller`文件夹中，我们可以创建处理由组件（由于组件的生命周期或用户与组件的某些*交互*）触发的事件的类。我们始终需要记住Ext
    JS是*事件驱动的*，在`Controller`类中，我们将控制这些事件并更新任何Model、View或Store（如果需要）。触发的一些事件示例包括按钮的点击或鼠标悬停，网格行的`itemclick`事件等。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also have `ViewController` classes inside the `view` folder. This is
    applied when we use the MVVM pattern, which we will discuss more in detail in
    the next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`view`文件夹内创建`ViewController`类。这在我们使用MVVM模式时适用，我们将在下一章中更详细地讨论这一点。
- en: The MVC `app` folder structure has been created. Now, we will copy the Ext JS
    SDK (`extjs` folder) into the `masteringExtjs` folder, and we will also create
    a file named `app.js`. We will edit this file later in this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: MVC的`app`文件夹结构已经创建。现在，我们将把Ext JS SDK（`extjs`文件夹）复制到`masteringExtjs`文件夹中，我们还将创建一个名为`app.js`的文件。我们将在本章后面编辑此文件。
- en: We also have the `Application.js` file. This is the entry point of our application.
    We'll come back to this later on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`Application.js`文件。这是我们的应用程序的入口点。我们稍后会回到这个话题。
- en: 'The `masteringextjs` directory contains a few more files:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`masteringextjs`目录包含一些额外的文件：'
- en: '`app.js`: This file inherits the code from the `Application.js` file. It is
    the point of entry of the application. This is the file that is called by Ext
    JS to initialize the application. We should avoid changing this file `app.json`:
    this is a configuration file for the application. In this file, we can add extra
    CSS and JS files, which should be loaded with the application, such as charts
    and locale-specific configurations. We will make some changes in this file throughout
    the book.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.js`：此文件从`Application.js`文件继承代码。这是应用程序的入口点。这是由Ext JS调用来初始化应用程序的文件。我们应该避免更改此文件`app.json`：这是应用程序的配置文件。在此文件中，我们可以添加额外的CSS和JS文件，这些文件应与应用程序一起加载，例如图表和特定地区的配置。我们将在本书中对此文件进行一些更改。'
- en: '`bootstrap.css`, `bootstrap.json`, and `bootstrap.js`: Created by Sencha Cmd,
    these files *should not be edited*. The CSS file contains the import of the theme
    used by the application (which is the so-called **Neptune theme** by default).
    After we make a build, the content of these files is updated with CSS definitions,
    and the JavaScript files will contain dependencies that need to be loaded prior
    to execution, custom `xtypes`, and other class system features.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap.css`、`bootstrap.json`和`bootstrap.js`：由Sencha Cmd创建，这些文件*不应该被编辑*。CSS文件包含了应用程序使用的主题的导入（默认情况下是所谓的**Neptune主题**）。在构建完成后，这些文件的内容会更新为CSS定义，JavaScript文件将包含在执行前需要加载的依赖项、自定义`xtypes`和其他类系统功能。'
- en: '`build.xml`: Sencha Cmd uses Apache Ant ([http://ant.apache.org/](http://ant.apache.org/)),
    which is a Java tool used to build Java projects. Ant uses a configuration file
    named `build.xml`, which contains all the required configurations and commands
    to build a project. Sencha Cmd uses Ant as the engine to build an Ext JS application
    on the background (while we simply need to use a command). This is the reason
    why we need to have the Java SDK installed to use some of the Sencha Cmd features.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.xml`：Sencha Cmd使用Apache Ant（[http://ant.apache.org/](http://ant.apache.org/)），这是一个用于构建Java项目的Java工具。Ant使用一个名为`build.xml`的配置文件，其中包含所有必需的配置和命令来构建项目。Sencha
    Cmd使用Ant作为后台构建Ext JS应用程序的引擎（而我们需要简单地使用命令）。这就是为什么我们需要安装Java SDK来使用一些Sencha Cmd功能的原因。'
- en: '`index.html`: This is the index file of our project. This is the file that
    will be rendered by the browser when we execute our application. Inside this file,
    we will find the import of the `bootstrap.js` file. We should avoid making changes
    in this file as well because when we build the application, Sencha Cmd will generate
    a new `index.html` file in the `build` folder, discarding all the changes we might
    have made to the `index.html` file. If we need to include a JS or CSS file, we
    should define this within the `app.json` file.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`：这是我们项目的索引文件。这是当执行我们的应用程序时浏览器将渲染的文件。在这个文件中，我们将找到`bootstrap.js`文件的导入。我们应该避免在这个文件中做任何更改，因为当我们构建应用程序时，Sencha
    Cmd将在`build`文件夹中生成一个新的`index.html`文件，丢弃我们对`index.html`文件所做的所有更改。如果我们需要包含一个JS或CSS文件，我们应该在`app.json`文件中定义这个文件。'
- en: '`ext`: Inside this folder, we can find all the Ext JS framework files (`ext-all`,
    `ext-all-debug`, and `ext-dev`), its source code, and also the `packages` folder,
    containing the locale definitions for our application and theme-related packages,
    among others.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ext`：在这个文件夹中，我们可以找到所有Ext JS框架文件（`ext-all`、`ext-all-debug`和`ext-dev`），其源代码，以及包含我们的应用程序和主题相关包的`packages`文件夹等。'
- en: '`overrides`: When we create the application, this folder is empty. We can add
    any class overrides and customizations we will need for our project.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`覆盖`：当我们创建应用程序时，这个文件夹是空的。我们可以添加我们项目需要的任何类覆盖和自定义。'
- en: '`packages`: Inside this folder, we can create our own packages. A package can
    be a new theme, for example. Its concept is similar to *gems* in Ruby or custom
    APIs in Java and .NET (for example, to use Apache Ant in a Java project, we need
    to include the Apache Ant `jar` file).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`包`：在这个文件夹中，我们可以创建自己的包。一个包可以是一个新的主题，例如。其概念类似于Ruby中的*gem*或Java和.NET中的自定义API（例如，在Java项目中使用Apache
    Ant，我们需要包含Apache Ant的`jar`文件）。'
- en: '`resources`: Inside this folder, we will place all the images of our application.
    We can also place other CSS files and font files.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资源`：在这个文件夹中，我们将放置我们应用程序的所有图片。我们也可以放置其他CSS文件和字体文件。'
- en: '`sass`: Inside this folder, we can find some Sass files used to create themes.
    Any custom CSS for our application will be created inside this folder.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sass`：在这个文件夹中，我们可以找到一些用于创建主题的Sass文件。我们应用程序的任何自定义CSS都将创建在这个文件夹中。'
- en: Let's gain firsthand knowledge now! We will now explore some of the concepts
    described previously during the development of our application to understand them
    better.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们获取第一手知识吧！我们将现在探索之前在开发我们的应用程序过程中描述的一些概念，以便更好地理解它们。
- en: Looking out for changes with the watch command
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用watch命令查看更改
- en: Sencha Cmd has another command that is very useful while developing Ext JS applications.
    It is the `watch` command. We will use this command all the time while developing
    the application in this book.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd还有一个在开发Ext JS应用程序时非常有用的命令，那就是`watch`命令。在本书开发应用程序的过程中，我们将一直使用这个命令。
- en: 'Let''s execute this command and see what it does. First, we need to change
    the directory to the `masteringextjs` folder (which is our application folder
    generated with Sencha Cmd). Then, we can execute the `sencha app watch` command.
    The following screenshot exemplifies the output of this command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行这个命令并看看它会做什么。首先，我们需要将目录更改为`masteringextjs`文件夹（这是我们使用Sencha Cmd生成的应用程序文件夹）。然后，我们可以执行`sencha
    app watch`命令。以下截图展示了这个命令的输出：
- en: '![Looking out for changes with the watch command](img/0457OT_02_16.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![使用watch命令查看更改](img/0457OT_02_16.jpg)'
- en: This command looks for any changes made inside the Ext JS application folder.
    If we create a new file or change any file, this command will know that a change
    has been made and will make an application build.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会查找Ext JS应用程序文件夹内部的所有更改。如果我们创建了一个新文件或更改了任何文件，这个命令就会知道已经进行了更改，并将生成一个应用程序构建。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can minimize the terminal application and let the command be executed in
    the background. If we close the terminal, the command will no longer be alive,
    and we have to execute it again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以最小化终端应用程序，让命令在后台执行。如果我们关闭终端，命令将不再活跃，我们必须再次执行它。
- en: 'It is also going to start a web server at `http://locahost:1841`, where we
    can access our application as demonstrated in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将启动一个位于 `http://locahost:1841` 的网络服务器，我们可以像以下截图所示那样访问我们的应用程序：
- en: '![Looking out for changes with the watch command](img/0457OT_02_17.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用 watch 命令查看更改](img/0457OT_02_17.jpg)'
- en: So this is how an application created with Sencha Cmd looks. Sencha Cmd also
    creates some files inside the `app` folder that we can change according to our
    needs. We will go through the files in the next chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是使用 Sencha Cmd 创建的应用程序的外观。Sencha Cmd 还在 `app` 文件夹内部创建了一些文件，我们可以根据需要更改它们。我们将在下一章中介绍这些文件。
- en: 'We can also execute the application from the Xampp `localhost` URL by accessing
    `http://localhost/masteringextjs`, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过访问 `http://localhost/masteringextjs` 来从 Xampp 的 `localhost` URL 执行应用程序，如下所示：
- en: '![Looking out for changes with the watch command](img/0457OT_02_18.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![使用 watch 命令查看更改](img/0457OT_02_18.jpg)'
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The output from `http://localhost/masteringextjs` is exactly the same as accessing
    `http://locahost:1841`. You can use any of them. But be aware that `http://locahost:1841`
    will be alive only when we use the `sencha app watch` command. As we will use
    PHP and apply some other configurations, we will use `http://localhost/masteringextjs`
    throughout the book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `http://localhost/masteringextjs` 的输出与通过 `http://locahost:1841` 访问的输出完全相同。您可以使用任何一个。但请注意，`http://locahost:1841`
    只在我们使用 `sencha app watch` 命令时才会活跃。由于我们将使用 PHP 并应用一些其他配置，我们将全书使用 `http://localhost/masteringextjs`。
- en: Applying the first changes in our app
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的应用程序中应用第一次更改
- en: We know that Sencha Cmd has created some files for us, but we do not want that
    screen to be the first one the user will see. We want the user to see the login
    screen and then go the main screen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 Sencha Cmd 为我们创建了一些文件，但我们不希望那个屏幕是用户首先看到的。我们希望用户先看到登录屏幕，然后进入主屏幕。
- en: 'To make it happen, we need to make some changes inside the `app.js` file. If
    we open the file, we will see the following content:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要在 `app.js` 文件中进行一些更改。如果我们打开文件，我们会看到以下内容：
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are going to change the preceding code that was highlighted to the following
    code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改前面高亮的代码，改为以下代码：
- en: '[PRE2]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the only change we will make in this file, because we should avoid changing
    it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个文件中进行的唯一更改就是，我们应该避免更改它。
- en: What this line does is create the `Packt.view.main.Main` component automatically
    after the application is initialized, but we do not want that happening. We want
    to display the splash screen first and then the login screen. That is why we are
    asking the application not to auto-render the viewport.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码的作用是在应用程序初始化后自动创建 `Packt.view.main.Main` 组件，但我们不希望这样。我们希望首先显示启动屏幕，然后是登录屏幕。这就是为什么我们要求应用程序不要自动渲染视口。
- en: Note that the terminal where we have the `sencha app watch` command running
    will output a few lines, which means the application will be refreshed and the
    development build updated. This will happen every time we make a change and save
    it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，运行 `sencha app watch` 命令的终端将输出几行，这意味着应用程序将被刷新，开发构建更新。每次我们进行更改并保存时，都会发生这种情况。
- en: If we refresh the browser, we should see an empty page. This means we can start
    the development of our DVD Rental Store application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新浏览器，我们应该看到一个空页面。这意味着我们可以开始开发我们的 DVD 租赁店应用程序。
- en: Understanding the Application.js file
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Application.js 文件
- en: 'If we open the `app/Application.js` file, this is how it looks:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开 `app/Application.js` 文件，它看起来是这样的：
- en: '[PRE3]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `app.js` file inherits all the behavior of the application from the `Application.js`
    file. This file is used as the entry point of the app.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js` 文件从 `Application.js` 文件继承了应用程序的所有行为。此文件用作应用程序的入口点。'
- en: On the first line of the preceding code, we have the `Ext.application` declaration
    (`#1`). This means that our application will have a single page ([http://en.wikipedia.org/wiki/Single-page_application](http://en.wikipedia.org/wiki/Single-page_application)),
    and the parent container of the app will be the viewport. The viewport is a specialized
    container representing the viewable application area that is rendered inside the
    `<body>` tag of the HTML page (`<body></body>`).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的第一行，我们有 `Ext.application` 的声明（`#1`）。这意味着我们的应用程序将有一个单页应用（[http://en.wikipedia.org/wiki/Single-page_application](http://en.wikipedia.org/wiki/Single-page_application)），并且应用程序的父容器将是视口。视口是一个特殊的容器，代表在
    HTML 页面的 `<body>` 标签内渲染的可视应用程序区域（`<body></body>`）。
- en: Inside the `Ext.application`, we can also declare `views` (`#3`), `controllers`
    (`#4`), and `stores` (`#5`) used by the application. We will add this information
    in this file as we create new classes for our project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Ext.application` 内部，我们还可以声明应用程序使用的 `views`（`#3`）、`controllers`（`#4`）和 `stores`（`#5`）。随着我们为项目创建新的类，我们将在该文件中添加这些信息。
- en: We need to declare the `name` attribute of the application, which will be the
    namespace (`#2`) of the application. In this case, Sencha Cmd used the namespace
    we used in the `sencha generate app` command.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要声明应用程序的 `name` 属性，这将作为应用程序的命名空间（`#2`）。在这种情况下，Sencha Cmd 使用了我们在 `sencha generate
    app` 命令中使用的命名空间。
- en: We can also create a `launch` function inside `Ext.application` (`#6`). This
    function will be called after all the application's controllers are initialized,
    and this means that the application is completely loaded. So this function is
    a good place to instantiate our main view, which in our case will be the login
    screen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `Ext.application` 内部创建一个 `launch` 函数（`#6`）。这个函数将在所有应用程序的控制器初始化之后被调用，这意味着应用程序已经完全加载。因此，这个函数是实例化我们的主视图的好地方，在我们的例子中，这将是我们登录屏幕。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Do we need to use `Ext.onReady` when using `Ext.application`?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用 `Ext.application` 时是否需要使用 `Ext.onReady`？
- en: The answer is no. We only need to use one of the options. According to the Ext
    JS API documentation, `Ext.application` *loads Ext.app.Application class and starts
    it up with given configuration after the page is ready* and `Ext.onReady` *adds
    a new listener to be executed when all required scripts are fully loaded*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。我们只需要使用其中一个选项。根据 Ext JS API 文档，`Ext.application` *在页面准备就绪后加载 Ext.app.Application
    类，并使用给定的配置启动它*，而 `Ext.onReady` *添加一个新监听器，在所有必需的脚本完全加载时执行*。
- en: 'If we take a look at the source code for `Ext.application`, we have:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `Ext.application` 的源代码，我们有：
- en: '[PRE4]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that `Ext.application` is already calling `Ext.onReady`, so we do
    not need to do it twice.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `Ext.application` 已经调用了 `Ext.onReady`，所以我们不需要重复调用它。
- en: Hence, use `Ext.onReady` when you have a few components to be displayed, which
    are not in the MVC architecture (similar to the jQuery `$(document).ready()` function),
    and use `Ext.application` when you are developing an Ext JS MVC application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您有一些要显示的组件，而这些组件不在 MVC 架构中（类似于 jQuery 的 `$(document).ready()` 函数）时，请使用 `Ext.onReady`；当您正在开发
    Ext JS MVC 应用程序时，请使用 `Ext.application`。
- en: 'The following diagram exemplifies all the high-level steps performed during
    the Ext JS application startup. Once the steps are executed, the application is
    completely loaded:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 Ext JS 应用程序启动期间执行的所有高级步骤。一旦执行了这些步骤，应用程序就完全加载了：
- en: '![Understanding the Application.js file](img/0457OT_02_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Application.js 文件](img/0457OT_02_19.jpg)'
- en: Now that we know how an Ext JS application is initialized, we can start building
    our app.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了 Ext JS 应用程序的初始化方式，我们就可以开始构建我们的应用程序了。
- en: Creating the loading page
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建加载页面
- en: When working with large Ext JS applications, it is normal to have a short delay
    when loading the application. This happens because Ext JS is loading all the required
    classes to have the application up and running, and meanwhile, all the users see
    is a blank screen, which can be annoying for them. A very common solution to this
    problem is to have a loading page, also known as a splash screen.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当与大型 Ext JS 应用程序一起工作时，在加载应用程序时出现短暂的延迟是正常的。这是因为 Ext JS 正在加载所有必需的类，以便使应用程序运行，同时，所有用户看到的是一个空白的屏幕，这可能会对他们造成烦恼。解决这个问题的非常常见的解决方案是有一个加载页面，也称为启动屏幕。
- en: 'So let''s add a splash screen to our application that looks like what is shown
    in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在我们的应用程序中添加一个类似于以下截图所示的启动屏幕：
- en: '![Creating the loading page](img/0457OT_02_20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![创建加载页面](img/0457OT_02_20.jpg)'
- en: First, we need to understand how this splash screen will work. After the user
    loads the application, the splash screen will be displayed. The application will
    show the splash screen while it loads all the required classes and code so that
    the application can be used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解这个启动屏幕是如何工作的。在用户加载应用程序后，启动屏幕将被显示。应用程序将在加载所有必需的类和代码的同时显示启动屏幕，以便应用程序可以被使用。
- en: 'We already know that the application calls the `launch` function when it is
    ready to be used. So we know that we will need to remove the splash screen on
    the `launch` method. The question now is: where inside `Ext.application` can we
    call the splash screen? The answer is inside the `init` function. The `init` function
    is called when the application boots, so it gives some time to all required code
    to be loaded, and after that, the `launch` function is called.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道当应用程序准备好使用时，它会调用`launch`函数。所以我们知道我们需要在`launch`方法中移除启动屏幕。现在的问题是：在`Ext.application`的哪个位置可以调用启动屏幕？答案是`init`函数内部。`init`函数在应用程序启动时被调用，这给了所有必需的代码加载一些时间，然后调用`launch`函数。
- en: Now that we know how the splash screen will work, let's implement it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了启动屏幕是如何工作的，让我们来实现它。
- en: 'Inside `Ext.application`, we will implement a function called `init` after
    the `launch` function declaration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Ext.application`内部，我们在`launch`函数声明之后实现一个名为`init`的函数：
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we need to do is to apply a `mask` method (`#2`) into the HTML body of the
    application (`Ext.getBody()`). That is why we are calling the `mask` method passing
    the loading message (`Loading Application`) and applying a CSS style that will
    be a loading `GIF` file, and it is already part of the Ext JS CSS (`splashscreen`).
    The `mask` method will return an `Ext.dom.Element` class, which we will need to
    manipulate later (remove the `mask` method from the HTML body), and for this reason,
    we need to keep a reference to this `Ext.dom.Element` class, and we will store
    this reference as a variable part of `Ext.application` (`me.splashscreen`). The
    `me` variable is a reference to `this` (`#1`), which makes a reference to `Ext.application`
    itself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是将一个`mask`方法（`#2`）应用到应用程序的HTML主体中（`Ext.getBody()`）。这就是为什么我们调用`mask`方法，传递加载信息（`Loading
    Application`），并应用一个CSS样式，这将是一个加载的`GIF`文件，它已经是Ext JS CSS的一部分（`splashscreen`）。`mask`方法将返回一个`Ext.dom.Element`类，我们稍后需要对其进行操作（从HTML主体中移除`mask`方法），因此我们需要保留对这个`Ext.dom.Element`类的引用，并将这个引用作为`Ext.application`的一部分存储为变量（`me.splashscreen`）。`me`变量是对`this`（`#1`）的引用，它指向`Ext.application`本身。
- en: 'With the code of the `init` method only, we will have a loading screen as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用`init`方法的代码，我们将有一个如下所示的加载屏幕：
- en: '![Creating the loading page](img/0457OT_02_21.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![创建加载页面](img/0457OT_02_21.jpg)'
- en: If this is all you need, that is OK. But let's go a little bit further and customize
    the loading screen, adding a logo image so that it can look like the first image
    of this topic, which is our final output.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说足够了，那就没问题。但让我们更进一步，定制加载屏幕，添加一个标志图像，使其看起来像这个主题的第一张图片，这是我们最终的输出。
- en: To add the image to our splash screen, we need to create a CSS style. We could
    create a CSS file and then include it in our `index.html` file, but we will follow
    the best practices and create a `Sass` file inside the `sass` folder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片添加到我们的启动屏幕中，我们需要创建一个CSS样式。我们可以创建一个CSS文件并将其包含在我们的`index.html`文件中，但我们将遵循最佳实践，在`sass`文件夹内创建一个`Sass`文件。
- en: Ext JS has a better way to deal with custom CSS styles. When we are done implementing
    our application, we want to customize the theme, and we want to make a production
    build. The production build contains only the essential Ext JS SDK source code,
    which is required to execute the application, along with our application source
    code. This code will be obfuscated and optimized so that the user can download
    a file with minimal size. The production build will do the same with the CSS file
    as well; it will optimize and add only the required CSS from Ext JS components
    that are needed to execute the application. As of course, we want any custom CSS
    that we create to be optimized as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 有一种更好的方式来处理自定义CSS样式。当我们完成应用程序的实现后，我们想要定制主题，并想要创建一个生产构建。生产构建只包含执行应用程序所需的Ext
    JS SDK源代码，以及我们的应用程序源代码。此代码将被混淆和优化，以便用户可以下载一个最小尺寸的文件。生产构建也会对CSS文件做同样的事情；它将优化并添加执行应用程序所需的Ext
    JS组件的CSS。当然，我们希望我们创建的任何自定义CSS也得到优化。
- en: To do so, we are going to create our custom CSS inside the `sass/etc` folder
    using Sass ([http://sass-lang.com/](http://sass-lang.com/)). So let's go ahead
    and create a file named `all.scss` inside the `sass/etc` folder.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将在 `sass/etc` 文件夹中使用 Sass 创建自定义 CSS（[http://sass-lang.com/](http://sass-lang.com/))。因此，让我们在
    `sass/etc` 文件夹中创建一个名为 `all.scss` 的文件。
- en: Inside the resources, we will also create an `images/app` folder with the Packt
    logo image (you can copy the Packt logo image from this book's source code).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源内部，我们还将创建一个包含 Packt 标志图像的 `images/app` 文件夹（你可以从本书的源代码中复制 Packt 标志图像）。
- en: 'This is how our application structure will look after creating these files:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些文件后，我们的应用程序结构将如下所示：
- en: '![Creating the loading page](img/0457OT_02_22.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![创建加载页面](img/0457OT_02_22.jpg)'
- en: 'And the `all.scss` file will look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `all.scss` 文件将看起来像这样：
- en: '[PRE6]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is plain CSS code, except for lines `#1`, `#2`, and `#3`, which is Sass code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段纯 CSS 代码，除了行 `#1`、`#2` 和 `#3`，这是 Sass 代码。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not familiar with Sass, it is a new way of writing CSS code. Sass
    uses the **don't repeat yourself** (**DRY**) principle, which means that you can
    use variables and nested syntax (as the one we used in `#1`) and import other
    Sass files (allowing you to create modular CSS), among other features. The Ext
    JS engine theme uses Sass and Compass (a Sass framework). Sass is an alternative
    to Less. To learn more about Sass, please visit [http://sass-lang.com/](http://sass-lang.com/).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 Sass，它是一种编写 CSS 代码的新方法。Sass 使用 **不要重复自己**（**DRY**）原则，这意味着你可以使用变量和嵌套语法（如我们在
    `#1` 中使用的）以及导入其他 Sass 文件（允许你创建模块化 CSS），以及其他功能。Ext JS 引擎主题使用 Sass 和 Compass（一个
    Sass 框架）。Sass 是 Less 的替代品。要了解更多关于 Sass 的信息，请访问 [http://sass-lang.com/](http://sass-lang.com/)。
- en: 'Lines `#1`, `#2`, and `#3` would be the same thing as:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 行 `#1`、`#2` 和 `#3` 将与以下内容相同：
- en: '[PRE7]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is the CSS code generated after compiling the Sass file.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是在编译 Sass 文件后生成的 CSS 代码。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When Sencha Cmd makes a build, the code from our `all.scss` file will be added
    to the single CSS file generated for our application, which contains the Ext JS
    CSS code and our code as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Sencha Cmd 进行构建时，我们的 `all.scss` 文件中的代码将被添加到为我们的应用程序生成的单个 CSS 文件中，该文件包含 Ext
    JS CSS 代码以及我们的代码。
- en: Now, let's go back to the `Application.js` file and continue to add some code
    to the `init` function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `Application.js` 文件，并继续向 `init` 函数中添加一些代码。
- en: 'We add the following code after the code we already have:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在已有的代码之后添加以下代码：
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will add a new CSS style to the loading `<div>` tag. Note that the following
    styles from `app.css` will be applied: `.x-mask.splashscreen` and `.x-mask-msg.splashscreen
    div`. This will make the background white instead of gray, and it is also going
    to change the font of the "`Loading application`" message.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向加载 `<div>` 标签添加一个新的 CSS 样式。请注意，以下来自 `app.css` 的样式将被应用：`.x-mask.splashscreen`
    和 `.x-mask-msg.splashscreen div`。这将使背景变为白色而不是灰色，并且它还将改变 “`加载应用程序`” 消息的字体。
- en: 'This is how the generated HTML will look:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 HTML 将如下所示：
- en: '![Creating the loading page](img/0457OT_02_23.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![创建加载页面](img/0457OT_02_23.jpg)'
- en: 'Now, we will add the following code in the `init` function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `init` 函数中添加以下代码：
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code will search for the first `<div>` tag that contains the `.x-mask-msg`
    class (`Ext.query('.x-mask-msg')[0]`) and will add a new `<div>` tag as a child
    with the class `x-splash-icon` that will be responsible for adding the logo image
    above the loading message.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将搜索包含 `.x-mask-msg` 类的第一个 `<div>` 标签（`Ext.query('.x-mask-msg')[0]`），并将一个新的
    `<div>` 标签作为子标签添加，其类为 `x-splash-icon`，它将负责在加载消息上方添加标志图像。
- en: 'And this is how the generated HTML will look:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 HTML 将如下所示：
- en: '![Creating the loading page](img/0457OT_02_24.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![创建加载页面](img/0457OT_02_24.jpg)'
- en: After we execute the preceding code, we will have the output shown in the screenshot
    at the beginning of this topic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，我们将得到本主题开头截图所示的输出。
- en: Now we have the splash screen being displayed. We need to work on the `launch`
    function to remove the splash screen after all the code the application needs
    is loaded; otherwise, the loading message will be there indefinitely!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经显示了启动屏幕。我们需要在所有应用程序需要的代码加载完毕后，在 `launch` 函数中移除启动屏幕；否则，加载信息将无限期地显示在那里！
- en: 'To remove the splash screen, the only code we need to add to the `launch` function
    is the following, which is about removing the mask from the HTML body:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除启动屏幕，我们只需要在 `launch` 函数中添加以下代码，该代码涉及从 HTML 身体中移除遮罩：
- en: '[PRE10]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, removing the mask abruptly is not nice because the user cannot even
    see the loading message. Instead of only removing the mask, let''s give the user
    2 seconds to see the loading message after the application is ready:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，突然移除遮罩并不好，因为用户甚至看不到加载信息。在应用程序准备就绪后，除了移除遮罩，我们还可以给用户2秒钟的时间来查看加载信息：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To do so, we use the `DelayedTask` class (`#1`), which is a class that provides
    the chance of a function to be executed after the given timeout in milliseconds
    (`#3`). So, in the case of the following task, we remove the mask from the HTML
    body (`#2`) after 2 seconds of timeout (2,000 milliseconds).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们使用`DelayedTask`类（`#1`），这是一个在给定毫秒数（`#3`）超时后执行函数的机会的类。因此，在以下任务的情况下，我们在2秒（2,000毫秒）的超时后从HTML主体中移除遮罩（`#2`）。
- en: 'If we test the output right now, it works, but it is still not nice for the
    user. It would be even better if we could add an animation to the masking. So,
    we will add a fade out animation (which animates the opacity of an element—from
    opaque to transparent), and after the animation, we will remove the masking (inside
    the `Ext.util.DelayedTask` function). The following code is a demonstration of
    the explanation provided in this paragraph:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在测试输出，它工作得很好，但对于用户来说仍然不好。如果我们能添加一个遮罩动画会更好。所以，我们将添加一个淡出动画（它动画元素的透明度——从不透明到透明），动画之后，我们将移除遮罩（在`Ext.util.DelayedTask`函数内部）。以下代码是本段提供的解释的演示：
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After we execute this code, notice that the loading message is still being displayed.
    We need to analyze the generated HTML to find out why.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，请注意加载信息仍在显示。我们需要分析生成的HTML以找出原因。
- en: 'Before we call the `fadeOut` function, this is the HTML of the loading message:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`fadeOut`函数之前，这是加载信息的HTML：
- en: '![Creating the loading page](img/0457OT_02_25.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![创建加载页面](img/0457OT_02_25.jpg)'
- en: 'After we call the `fadeout` function, the HTML will be the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`fadeout`函数之后，HTML将是以下内容：
- en: '![Creating the loading page](img/0457OT_02_26.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![创建加载页面](img/0457OT_02_26.jpg)'
- en: 'Only the first `<div>` tag with the `splashscreen` class was faded out. We
    need to also fade out the `<div>` tag with the `x-mask-msg splashscreen` class,
    which contains the logo and the loading message. To do so, we can use the next
    method, which will get the next sibling of the `splashscreen` node, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 只有具有`splashscreen`类的第一个`<div>`标签被淡出。我们还需要淡出包含标志和加载信息的具有`x-mask-msg splashscreen`类的`<div>`标签。为此，我们可以使用以下方法，该方法将获取`splashscreen`节点的下一个兄弟节点，如下所示：
- en: '[PRE13]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will be a pleasant animation that is shown to the user. Also note
    that the `splashscreen` `<div>` tag was removed from the generated HTML, which
    is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个用户可以看到的愉快动画。同时请注意，`splashscreen` `<div>`标签已从生成的HTML中删除，如下所示：
- en: '![Creating the loading page](img/0457OT_02_27.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![创建加载页面](img/0457OT_02_27.jpg)'
- en: 'The complete code for the `launch` function will be the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch`函数的完整代码如下：'
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: To make our splash screen even nicer, we will listen (`#1`) to the `afteranimate`
    event (`#2`) of the `fadeOut` method so that we can display the initial component
    of our application. We will show a login screen that we will implement in the
    next chapter. For now, we will add a console message (`#3`) just to know where
    we need to call the initial component. In Internet Explorer, `console.log` will
    not work; instead, you can use `window.console.log`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的启动屏幕更加美观，我们将监听（`#1`）`fadeOut`方法的`afteranimate`事件（`#2`），以便我们可以显示我们应用程序的初始组件。我们将展示一个将在下一章实现的登录屏幕。现在，我们将添加一个控制台消息（`#3`），以便知道我们需要在哪里调用初始组件。在Internet
    Explorer中，`console.log`将不起作用；相反，您可以使用`window.console.log`。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that all the code we used to display the loading message mask and remove
    it is part of the `Ext.dom.Element` class. This class encapsulates a **Document
    Object Model** (**DOM**) element, where we can manage it using the class's methods.
    This class is a part of the `Ext Core` library, which is a part of the foundation
    of the Ext JS framework.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们用来显示加载信息遮罩并移除它的所有代码都是`Ext.dom.Element`类的一部分。这个类封装了一个**文档对象模型**（**DOM**）元素，我们可以使用类的方法来管理它。这个类是`Ext
    Core`库的一部分，它是Ext JS框架的基础之一。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the application we will implement throughout the
    chapters of this book in a lot of depth. We also covered all the requirements
    to create the development environment for this application. You learned how to
    create the initial structure of an Ext JS MVC application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了本书各章节中将实现的应用程序。我们还涵盖了创建此应用程序的开发环境所需的所有要求。你学习了如何创建Ext JS MVC应用程序的初始结构。
- en: You also learned, through examples, how to create a splash screen (also known
    as the loading screen), manipulating the DOM using the `Ext.dom.Element` class.
    You learned the steps how to start up an Ext JS application and also learned the
    difference between the `init` and `launch` methods from `Ext.application`. We
    left `Application.js` ready to display its first screen, which will be a login
    screen, and which you will learn how to implement in the next chapter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你还通过示例学习了如何创建启动屏幕（也称为加载屏幕），使用`Ext.dom.Element`类操作DOM。你学习了启动Ext JS应用程序的步骤，以及从`Ext.application`中学习`init`和`launch`方法之间的区别。我们让`Application.js`准备好显示其第一个屏幕，这将是一个登录屏幕，你将在下一章中学习如何实现它。
