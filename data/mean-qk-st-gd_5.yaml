- en: Managing State with Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux管理状态
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下的配方：
- en: Defining actions and action creators
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义动作和动作创建者
- en: Defining reducer functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义减速器函数
- en: Creating a Redux store
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Redux存储
- en: Binding action creators to the dispatch method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动作创建者绑定到分派方法
- en: Splitting and combining reducers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分和组合减速器
- en: Writing Redux store enhancers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Redux存储增强器
- en: Time traveling with Redux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redux进行时间旅行
- en: Understanding Redux middleware
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Redux中间件
- en: Dealing with asynchronous data flow
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步数据流
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have an IDE, Visual Studio Code, Node.js and MongoDB.
    You will also need to install Git, in order use the Git repository of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个IDE、Visual Studio Code、Node.js和MongoDB。您还需要安装Git，以便使用本书的Git存储库。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码是如何运行的：
- en: '[https://goo.gl/mU9AjR](https://goo.gl/mU9AjR)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/mU9AjR](https://goo.gl/mU9AjR)'
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Redux is a predictable state container for JavaScript applications. It allows
    developers to manage the state of their applications with ease. With Redux, the
    state is immutable. Thus, it is possible to go back and forth to the next or previous
    state of your application. Redux is bound to three core principles:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是JavaScript应用程序的可预测状态容器。它允许开发人员轻松管理其应用程序的状态。使用Redux，状态是不可变的。因此，可以在应用程序的下一个或上一个状态之间来回切换。Redux遵循三个核心原则：
- en: '**Single source of truth**: All the state of your application must be stored
    in a single object tree within one single store'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一的真相来源**：应用程序的所有状态必须存储在一个单一存储中的单个对象树中'
- en: '**State is read-only**: You must not mutate the state tree. Only by dispatching
    an action can the state tree change'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态是只读的**：您不能改变状态树。只有通过分派动作，状态树才能改变'
- en: '**Changes are made with pure functions**: These are called reducers, which
    are functions that accept the previous state and an action and compute a new state.
    Reducers must never mutate the previous state but rather always return a new one'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用纯函数进行更改**：这些被称为减速器的函数接受先前的状态和一个动作，并计算一个新的状态。减速器绝不能改变先前的状态，而是始终返回一个新的状态'
- en: 'Reducers work in a very similar way to how the `Array.prototype.reduce` function
    does. The `reduce` method executes a function for every item in an array against
    an accumulator to reduce it to a single value. For example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 减速器的工作方式与`Array.prototype.reduce`函数非常相似。`reduce`方法对数组中的每个项目执行一个函数，以将其减少为单个值。例如：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The resulting value in variable `c` while reducing `a` and `b` against the
    `accumulator`, is `15` and the initial value is `0`. The reducer function here
    is:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`累加器`进行`a`和`b`的减速时，得到的值是`15`，初始值为`0`。这里的减速器函数是：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Redux reducers are written in a similar way and they are the most important
    concept of Redux. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Redux减速器的编写方式类似，它们是Redux的最重要概念。例如：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this chapter, we will focus on learning how to manage simple and complex
    state trees with Redux. You will learn as well how to deal with asynchronous data
    flows.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于学习如何使用Redux管理简单和复杂的状态树。您还将学习如何处理异步数据流。
- en: Defining actions and action creators
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义动作和动作创建者
- en: Reducers accept an `action` object that describes the action that is going to
    be performed and decides how to transform the state based on this `action` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 减速器接受描述将执行的动作的`action`对象，并根据此`action`对象决定如何转换状态。
- en: 'Actions are just plain objects and they have only one required property that
    needs to be present, the action-type. For instance:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 动作只是普通对象，它们只有一个必需的属性，需要存在，即动作类型。例如：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also provide additional properties as well. For instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以提供额外的属性。例如：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Actions creators are just functions that return actions, for instance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建者只是返回动作的函数，例如：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will see how these simple Redux concepts can be applied
    with `Array.prototype.reduce` to decide how data should be accumulated or reduced.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将看到如何使用`Array.prototype.reduce`来应用这些简单的Redux概念，以决定如何累积或减少数据。
- en: We won't need the Redux library yet for this purpose.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不需要Redux库来实现这个目的。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Build a small JavaScript application that will increase or decreased a counter
    based on the action provided.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个小型的JavaScript应用程序，根据提供的动作来增加或减少计数器。
- en: Create a new file named `counter.js`
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`counter.js`的新文件
- en: 'Define action-types as constants:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动作类型定义为常量：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define two action creators for generating two kinds of actions to `increment`
    and `decrement` the counter:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个动作创建者，用于生成`增加`和`减少`计数器的两种动作：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Initialize the initial accumulator to `0`, then reduce it by passing several
    actions. The reducer function will decide which kind of action to perform based
    on the action type:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将初始累加器初始化为`0`，然后通过传递多个动作来减少它。减速器函数将根据动作类型决定执行哪种动作：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Log the resulting value:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录结果值：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the file
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Open a terminal and run:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Outputs: `8`'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出：`8`
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first action type that the reducer encounters is `increment(10)` which will
    increment the accumulator by `10`. Because the initial value of the accumulator
    is `0`, the next current value will be `10`
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减速器遇到的第一个动作类型是`increment(10)`，它将使累加器增加`10`。因为累加器的初始值是`0`，下一个当前值将是`10`
- en: The second action type tells the reducer function to decrement the accumulator
    by `5`. Thus, the accumulator's value will be `5`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个动作类型告诉减速器函数将累加器减少`5`。因此，累加器的值将是`5`。
- en: The last action type tells the reducer function to increment the accumulator
    by `3`. As a result, the accumulator's value will be `8`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个动作类型告诉减速器函数将累加器增加`3`。结果，累加器的值将是`8`。
- en: Defining reducer functions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义减速器函数
- en: 'Redux reducers are pure functions. That means, they have no side-effects. Given
    the same arguments, the reducer must always generate the same shape of state.
    Take for example the following reducer function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Redux减速器是纯函数。这意味着它们没有副作用。给定相同的参数，减速器必须始终生成相同形状的状态。例如，以下减速器函数：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we execute this function providing the same arguments, the result will always
    be the same:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此函数并提供相同的参数，结果将始终相同：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, take into account that even though the returned values have the same
    shape, these are two different objects. For instance, comparing the above:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，即使返回的值具有相同的形状，这些是两个不同的对象。例如，比较上面的：
- en: '`console.log(a === b)` returns false.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(a === b)`返回false。'
- en: 'Impure reducer functions prevent your application state from being predictable
    and make difficult to reproduce the same state. For instance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 不纯的减速器函数会导致您的应用程序状态不可预测，并且难以重现相同的状态。例如：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we execute this function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此函数：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, after executing the function for a second time after 2 seconds,
    we get a different result. To make it pure, you can consider re-writing the previously
    impure reducer as:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在2秒后第二次执行函数后，我们得到了不同的结果。为了使其纯净，您可以考虑将先前的不纯减速器重写为：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, you can safely pass a time property inside your action to set the time:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以安全地在您的动作中传递一个时间属性来设置时间：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach makes your state predictable and the state is easy to reproduce.
    For instance, you could re-create a scenario of how your application will act
    if you pass the `time` property for any time in morning or afternoon.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使您的状态可预测，并且状态易于重现。例如，您可以重新创建一个场景，了解如果您为早上或下午的任何时间传递`time`属性，您的应用程序将如何运行。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Now that you understand the concept of how reducers work, in this recipe, you
    will build a small application that will act differently according to the state
    change.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了减速器的工作原理，本教程中，您将构建一个根据状态更改而表现不同的小型应用程序。
- en: For this purpose, you won't need to install or use the Redux library yet.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您不需要安装或使用Redux库。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Build an application that will remind you what kind of meal you should get
    according to your local time. Manage all the state of our application in a single
    object tree. Also provide a way to simulate what the application will display
    if it''s `00:00a.m` or `12:00p.m`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个应用程序，根据您的本地时间提醒您应该吃什么样的餐点。在一个单一的对象树中管理我们应用程序的所有状态。还提供一种模拟应用程序将在“00:00a.m”或“12:00p.m”时显示的方法：
- en: Create a new file named `meal-time.html`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`meal-time.html`的新文件。
- en: 'Add the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inside the script tag add the code defined in the next steps, starting on step
    4.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签中添加下一步中定义的代码，从第4步开始。
- en: 'Define a variable `state` that will contain all the state tree and later the
    next state:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个变量`state`，它将包含所有状态树和稍后的下一个状态：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a reference to the HTML elements that we will use to display data or
    add event listeners:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个引用HTML元素的引用，我们将用它来显示数据或添加事件监听器：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define two action types:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两种动作类型：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define an action creator for setting the kind of meal the user should have:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户应该有的餐点定义一个动作创建者：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define an action creator for setting the time:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个动作创建者，用于设置时间：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define a reducer function that will compute a new state when an action is dispatched:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个减速器函数，当动作被分发时计算新的状态：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a function that we will call when the state changes, so we can update our
    view:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个我们在状态改变时将调用的函数，以便更新我们的视图：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define a dispatch function that will generate a new state tree by passing the
    current state and an action to the reducer. Then, it will call the `onChangeState`
    function to notify your application that the state has changed:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个分发函数，通过将当前状态和动作传递给减速器来生成新的状态树。然后，它将调用`onChangeState`函数来通知您的应用程序状态已经改变：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add an event listener for the button that will emulate that the time is `00:00a.m`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加一个事件监听器，模拟时间为“00:00a.m”：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add an event listener for the button that will emulate that the time is `12:00p.m`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加一个事件监听器，模拟时间为“12:00p.m”：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the script is running, dispatch an action with the current time for the
    view to update:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本运行后，分发一个带有当前时间的动作，以便更新视图：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Save the file.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Let's test it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'To see your previous work in action:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 查看您之前的工作成果：
- en: Open the `meal-time.html` file in your web browser. You can do so by double-clicking
    on the file, or right-clicking on the file and choosing Open with....
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开`meal-time.html`文件。您可以通过双击文件或右键单击文件并选择“使用...”来执行此操作。
- en: You should be able to see your current local time and a message stating what
    kind of meal you should have. For instance, if your local time is `20:42:35 GMT+0800
    (CST)`, you should see `Dinner time!`
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够看到您当前的本地时间和一条消息，说明您应该有什么样的餐点。例如，如果您的本地时间是“20:42:35 GMT+0800 (CST)”，您应该看到“晚餐时间！”
- en: Click on the button `"Let's pretend is 00:00:00"` to see what your application
    would display if the time was `00:00a.m`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮“让我们假装是00:00:00”来查看如果时间是“00:00a.m”，您的应用程序将显示什么。
- en: The same way, click on the button `"Let's pretend is 12:00:00"` to see what
    your application would display if the time was `12:00p.m`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，点击按钮“让我们假装是12:00:00”来查看如果时间是“12:00p.m”，您的应用程序将显示什么。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can summarize our application like the following to understand how it works:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结我们的应用程序如下，以了解它的工作原理：
- en: Action types `SET_MEAL` and `SET_TIME` were defined.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作类型`SET_MEAL`和`SET_TIME`已被定义。
- en: 'Two action creators were defined:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了两个动作创建者：
- en: '`setMeal` which generates an action with the `SET_MEAL` action type and a `kindOfMeal`
    property with the provided argument'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setMeal`生成一个带有`SET_MEAL`动作类型和`kindOfMeal`属性的动作'
- en: '`setTime` which generates an action with the `SET_TIME` action type and a `time`
    property with the provided argument'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setTime`生成一个带有`SET_TIME`操作类型和提供的参数的`time`属性的操作'
- en: 'A reducer function was defined:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了一个reducer函数：
- en: For the action type `SET_MEAL`, computes a new state with a new `kindOfMeal`
    property
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于操作类型`SET_MEAL`，计算一个新的状态，具有一个新的`kindOfMeal`属性
- en: For the action type `SET_TIME`, computes a new state with a new `time` property
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于操作类型`SET_TIME`，计算一个新的状态，具有一个新的`time`属性
- en: We defined a function that will get called when the state tree changes. Inside
    the function, we updated the view according to the new state.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个函数，当状态树发生变化时将被调用。在函数内部，我们根据新状态更新了视图。
- en: A `dispatch` function was defined that calls the reducer function providing
    the previous state and an action object to generate a new state.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了一个`dispatch`函数，它调用reducer函数，提供先前的状态和一个操作对象以生成一个新的状态。
- en: Creating a Redux store
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Redux存储
- en: In the previous recipes, we have seen how to define reducers and actions. We
    have also seen how to create a dispatch function to dispatch actions for the reducers
    to update the state. The store is an object that provides a small API to put all
    of that together.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的教程中，我们已经看到了如何定义reducers和actions。我们还看到了如何创建一个dispatch函数来分派操作，以便reducers更新状态。存储是一个提供了一个小API的对象，将所有这些放在一起。
- en: 'The redux module exposes the `createStore` method which we can use to create
    a store. It has the following signature:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: redux模块公开了`createStore`方法，我们可以使用它来创建一个存储。它具有以下签名：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The two last arguments are optional. For example, creating a store with a single
    reducer could look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个参数是可选的。例如，创建一个只有一个reducer的store可能如下所示：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling `createStore` will expose four methods:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`createStore`将公开四种方法：
- en: '`store.dispatch(action)`: Where action is an object that contains at least
    one property named `type` that specifies the action type'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.dispatch(action)`:其中action是一个包含至少一个名为`type`的属性的对象，指定操作类型'
- en: '`store.getState()`: Returns the whole state tree'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.getState()`:返回整个状态树'
- en: '`store.subscribe(listener)`: Where listener is a callback function that will
    get triggered whenever the state tree changes. Several listeners can be subscribed'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.subscribe(listener)`:其中listener是一个回调函数，每当状态树发生变化时都会触发。可以订阅多个监听器'
- en: '`store.replaceReducer(reducer)`: Replaces the current Reducer function with
    a new one'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.replaceReducer(reducer)`:用新的reducer函数替换当前的Reducer函数'
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will re-build the application that you built in the previous
    recipe. However, this time you will use Redux. Before you start, create a new
    `package.json` file with the following content:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将重新构建您在上一个教程中构建的应用程序。但是，这一次您将使用Redux。在开始之前，创建一个新的`package.json`文件，内容如下：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行来安装依赖项：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, build a small ExpressJS server application whose sole purpose will be
    to serve an HTML file and the Redux module:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一个小的ExpressJS服务器应用程序，其唯一目的是提供HTML文件和Redux模块：
- en: Create a new file named `meal-time-server.js`
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`meal-time-server.js`的新文件
- en: 'Include the ExpressJS and `path` module and initialize a new ExpressJS Application:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括ExpressJS和`path`模块，并初始化一个新的ExpressJS应用程序：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Serve the Redux library on `/lib` path. Make sure that the path points to the
    `node_modules` folder:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/lib`路径上提供Redux库。确保路径指向`node_modules`文件夹：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Serve the client application on the root path `/`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根路径`/`上提供客户端应用程序：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listen for new connections on port `1337`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口`1337`上监听新的连接：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save the file
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Now, build the client application using Redux following the next steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤使用Redux构建客户端应用程序：
- en: Create a new file named `meal-time-client.html`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`meal-time-client.html`的新文件。
- en: 'Add the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Inside the script tag, add the code for the next steps, starting from step 4.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签内，从第4步开始添加下一步的代码。
- en: 'Extract the `createStore` method from the Redux library:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Redux库中提取`createStore`方法：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define the initial state of your application:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义应用程序的初始状态：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Keep a reference of the HTML DOM elements that will be used to display the
    state or interact with the application:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留将用于显示状态或与应用程序交互的HTML DOM元素的引用：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define two action types:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两种操作类型：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define two action creators:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个操作创建者：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the reducer that will transform the state when `SET_TIME` and/or `SET_TIME`
    action types are dispatched:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将在分派`SET_TIME`和/或`SET_TIME`操作类型时转换状态的reducer：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a new Redux Store:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Redux存储：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Subscribe a callback function to the changes of the store. Whenever the store
    changes this callback will be triggered and it will update the view according
    to the changes in the store:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个回调函数以更改存储。每当存储更改时，此回调将被触发，并且它将根据存储中的更改更新视图：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add an event listener for the `click` event for our button that will dispatch
    the `SET_TIME` action type to set the time to `00:00:00`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的按钮添加一个`click`事件的事件监听器，将分派`SET_TIME`操作类型以将时间设置为`00:00:00`：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add an event listener for the `click` event for our button that will dispatch
    the `SET_TIME` action type to set the time to `12:00:00`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的按钮添加一个`click`事件的事件监听器，将分派`SET_TIME`操作类型以将时间设置为`12:00:00`：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the application is first started, dispatch an action to set the time to
    the current local time:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序首次启动时，分派一个操作以将时间设置为当前本地时间：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Save the file
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: Let's test it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'To see the previous work in action:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以前的工作成果：
- en: 'Open a new terminal and run:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In your web browser, visit:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中，访问：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You should be able to see your current local time and a message stating what
    kind of meal you should have. For instance, if your local time is `20:42:35 GMT+0800
    (CST)`, you should see `Dinner time!`
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够看到您当前的本地时间和一条消息，说明您应该吃什么样的饭。例如，如果您的本地时间是`20:42:35 GMT+0800 (CST)`，您应该看到`晚餐时间！`
- en: Click on the button `"Let's pretend is 00:00:00"` to see what your application
    would display if the time was `00:00a.m`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击按钮`“假设现在是00:00:00”`，查看如果时间是`00:00a.m`，您的应用程序会显示什么。
- en: The same way, click on the `"Let's pretend is 12:00:00"` button to see what
    your application would display if the time was `12:00p.m`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，点击“假装是12:00:00”按钮，看看如果时间是12:00p.m，你的应用程序会显示什么。
- en: There's more
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'You can use the ES6 spread operator instead of `Object.assign` to merge your
    previous state with the next one, for instance, we re-wrote the reducer function
    of the previous recipe:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用ES6扩展运算符来合并你的先前状态和下一个状态，例如，我们重写了前面食谱的减速器函数：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We rewrote it as the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它重写为以下形式：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This could make the code more readable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使代码更易读。
- en: Binding action creators to the dispatch method
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将动作创建者绑定到`dispatch`方法
- en: 'Actions creators are just functions that generate action objects which can
    later be used to dispatch actions using the `dispatch` method. Take for example
    the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建者只是生成动作对象的函数，稍后可以使用`dispatch`方法来分派动作。例如，看下面的代码：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Later, somewhere in your application, you can dispatch these actions using
    the `dispatch` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在应用程序的其他地方，你可以使用`dispatch`方法来分派这些动作：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, as you can see, calling the `dispatch` method every time seems like
    a repeated and unnecessary step. You could simply wrap the action creators around
    the `dispatch` function itself like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所看到的，每次调用`dispatch`方法似乎是一个重复和不必要的步骤。你可以简单地将动作创建者包装在`dispatch`函数周围，就像这样：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Even though this seems like a good solution, there is a problem. It means,
    you would need to create the store first, then define your action creators binding
    them to the `dispatch` method. In addition, it would be difficult to maintain
    the action creators in a separate file since they depend on the `dispatch` method
    to be present. There is a solution provided by the Redux module, a helper method
    called `bindActionCreators` which accepts two arguments. The first argument is
    an object with keys, which represent the name of an action creator, and values,
    which represent a function that returns an action. The second argument is expected
    to be the `dispatch` function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这似乎是一个很好的解决方案，但存在一个问题。这意味着，你需要先创建存储，然后定义你的动作创建者，将它们绑定到`dispatch`方法。此外，由于它们依赖于`dispatch`方法的存在，很难将动作创建者维护在一个单独的文件中。Redux模块提供了一个解决方案，一个名为`bindActionCreators`的辅助方法，它接受两个参数。第一个参数是一个具有键的对象，这些键代表一个动作创建者的名称，值代表一个返回动作的函数。第二个参数预期是`dispatch`函数：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This helper method will map all the action creators to the dispatch method.
    For instance, we could re-write the previous example as the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助方法将所有的动作创建者映射到`dispatch`方法。例如，我们可以将前面的例子重写为以下形式：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, later somewhere in your application, you can call these methods without
    wrapping them around the `dispatch` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在应用程序的其他地方，你可以调用这些方法，而不需要将它们包装在`dispatch`方法周围：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see, our bound action creators look more like regular functions
    now. In fact, by destructuring the `actions` object, you can use only the methods
    you need. For instance:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的绑定动作创建者现在看起来更像普通函数。事实上，通过解构`actions`对象，你可以只使用你需要的方法。例如：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, you can call them like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以这样调用它们：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'In this recipe, you will build a simple To-do application and you will use
    the concepts that you just have learned about binding action creators. First,
    create a new `package.json` file with the following content:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将构建一个简单的待办事项应用程序，并使用你刚刚学到的关于绑定动作创建者的概念。首先，创建一个包含以下内容的新的`package.json`文件：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行来安装依赖项：
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: To build your To-do application, for the purpose of this recipe, define only
    one action creator and use `bindActionCreators` to bind it to the `dispatch` method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建你的待办事项应用程序，在这个食谱的目的，只定义一个动作创建者，并使用`bindActionCreators`将它绑定到`dispatch`方法。
- en: 'First, build a small ExpressJS application that will serve the HTML file containing
    the To-do client application which we will build after:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一个小的ExpressJS应用程序，它将提供包含待办事项客户端应用程序的HTML文件，我们将在之后构建：
- en: Create a new file named `bind-server.js`
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`bind-server.js`的新文件
- en: 'Add the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Save the file
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Next, build the To-do application in an HTML file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在HTML文件中构建待办事项应用程序：
- en: Create a new file named `bind-index.html`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`bind-index.html`的新文件。
- en: 'Add the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Inside the script tag, add the code in the following steps, starting from step
    4.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标记内，从第4步开始，按照以下步骤添加代码。
- en: 'Keep a reference to the HTML DOM element that will be used in the application:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留一个将在应用程序中使用的HTML DOM元素的引用：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Define the initial state of your application:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的应用程序的初始状态：
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define an action type:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个动作类型：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define an action creator:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个动作创建者：
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define a reducer function that will add a new item to the list whenever the
    `ADD_ITEM` action type is dispatched. The state will keep only 5 items:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个减速器函数，每当分派`ADD_ITEM`动作类型时，将一个新项目添加到列表中。状态将只保留5个项目：
- en: '[PRE69]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a store and bind the `dispatch` function to the action creator:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个存储，并将`dispatch`函数绑定到动作创建者：
- en: '[PRE70]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Subscribe to the store and whenever the state changes add a new item to the
    list. If an item was already defined, we will re-use it instead of creating a
    new one:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅存储，每当状态改变时向列表中添加一个新项目。如果已经定义了一个项目，我们将重复使用它，而不是创建一个新项目：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add an event listener to the form for the `submit` event. This way, we can
    get the input value and dispatch an action:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为表单添加一个`submit`事件的事件侦听器。这样，我们就可以获取输入值并分派一个动作：
- en: '[PRE72]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Save the file.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Let's test it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下…
- en: 'To see the previous work in action:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前的工作成果：
- en: 'Open a new Terminal and run:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In your browser, visit:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问：
- en: '[PRE74]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Type something in the input box and press Enter. A new item should appear in
    the list.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入框中输入一些内容，然后按Enter。列表中应该会出现一个新项目。
- en: Try to add more than five items to the list. The last one displayed will be
    removed and only five items are kept on the view.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试向列表中添加超过五个项目。显示的最后一个将被移除，视图上只保留五个项目。
- en: Splitting and combining reducers
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割和组合reducer
- en: As your application grows, you probably wouldn't want to write all the logic
    for how the state of your application needs to be transformed in a simple reducer
    function. What you would probably want is to write smaller reducers that specialize
    in managing independent parts of the state.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，你可能不希望在一个简单的reducer函数中编写应用程序状态的转换逻辑。你可能希望编写更小的reducer，专门管理状态的独立部分。
- en: 'Take for example the following reducer function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，以下是一个reducer函数：
- en: '[PRE75]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You have two properties that manage the state of two different parts of an
    application. One manages the state of a Todo, list while the other manages the
    Chat messages. You could split this reducer into two reducer functions, where
    each manages one slice of the state, for instance:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个属性来管理应用程序的两个不同部分的状态。一个管理待办事项列表的状态，另一个管理聊天消息的状态。你可以将这个reducer分割成两个reducer函数，每个函数管理状态的一个片段，例如：
- en: '[PRE76]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'However, because `createStore` method accepts only one reducer as the first
    argument, you would need to combine them into a single reducer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为`createStore`方法只接受一个reducer作为第一个参数，你需要将它们合并成一个单一的reducer：
- en: '[PRE77]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this way, we are able to split our reducers into smaller reducers that specialize
    in managing only one slice of the state, and later combine them together into
    a single reducer function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们能够将reducer分割成更小的reducer，专门管理状态的一个片段，然后将它们合并成一个单一的reducer函数。
- en: 'Redux provides a helper method named `combineReducers` that allows you to combine
    reducers in a similar way to what we just did but without having to repeat a lot
    of code; for instance, we could rewrite the previous way of combining reducers
    like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Redux提供了一个名为`combineReducers`的辅助方法，允许你以类似的方式组合reducer，但不需要重复大量的代码；例如，我们可以像这样重新编写组合reducer的先前方式：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `combineReducers` method is a *higher-order reducer* function. It accepts
    an object mapping specifies keys to a certain slice of the state managed by a
    specific `reducer` function and returns a new reducer function. If you run the
    following code, for instance:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineReducers`方法是一个*高阶reducer*函数。它接受一个对象映射，指定键到特定`reducer`函数管理的状态片段，并返回一个新的reducer函数。例如，如果你运行以下代码：'
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You will see that the generated shape of the state looks like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到生成的状态形状如下：
- en: '[PRE80]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can try as well if our combined reducers are working and managing only the
    part of the state assigned to them. For instance:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以尝试一下，看看我们组合的reducer是否工作，并且只管理分配给它们的状态部分。例如：
- en: '[PRE81]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output should display the generated state as the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该显示生成的状态如下：
- en: '[PRE82]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This shows that each reducer is managing only the slice of the state assigned
    to them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明每个reducer只管理分配给它们的状态片段。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will recreate the To-do application as in the pervious
    recipe. However, you will add other functionalities such as remove and toggle
    a To-do item. You will define other state of your application that will be managed
    by separate reducer functions. First, create a new `package.json` file with the
    following content:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，你将重新创建待办事项应用程序，就像在之前的教程中一样。但是，你将添加其他功能，比如删除和切换待办事项。你将定义应用程序的其他状态，这些状态将由单独的reducer函数管理。首先，创建一个新的`package.json`文件，内容如下：
- en: '[PRE83]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE84]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, build a small ExpressJS server application that will serve the client
    application and the Redux library installed in `node_modules`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一个小的ExpressJS服务器应用程序，它将为客户端应用程序提供服务，并安装在`node_modules`中的Redux库：
- en: Create a new file named `todo-time.js`
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`todo-time.js`的新文件
- en: 'Add the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE85]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Save the file
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Next, build the To-do client application. Also include a separate reducer to
    manage state for the current local time and a random lucky number generator:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建待办事项客户端应用程序。还包括一个单独的reducer来管理当前本地时间的状态和一个随机幸运数字生成器：
- en: Create a new file named `todo-time.html`
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`todo-time.html`的新文件
- en: 'Add the following HTML code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下HTML代码：
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Inside the script tag add the JavaScript code following the next steps, starting
    from step 4
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在script标签内添加以下JavaScript代码，按照下面的步骤开始
- en: 'Keep a reference of the HTML elements that we will use to display data or interact
    with the application:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留我们将用来显示数据或与应用程序交互的HTML元素的引用：
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Get the `createStore` method and helper methods from the Redux library:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Redux库中获取`createStore`方法和辅助方法：
- en: '[PRE88]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Set action types:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置action类型：
- en: '[PRE89]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Define action creators:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义action creators：
- en: '[PRE90]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Define a reducer function to manage the slice of state that keeps the time:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个reducer函数来管理状态的一个片段，保存时间：
- en: '[PRE91]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Define a reducer function to manage the slice of state that keeps a lucky number
    that will be generated every time the user loads your application:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个reducer函数来管理状态的一个片段，保存每次用户加载应用程序时生成的幸运数字：
- en: '[PRE92]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Define a reducer function to manage the slice of state that keeps an array
    of To-do items:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个reducer函数来管理状态的一个片段，保存待办事项的数组：
- en: '[PRE93]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Combine all reducers into a single one:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有的reducer合并成一个单一的reducer：
- en: '[PRE94]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create a store:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个store：
- en: '[PRE95]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Bind all actions creators to the `dispatch` method of the store:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有的action creators绑定到store的`dispatch`方法上：
- en: '[PRE96]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Subscribe a listener to the store that will update the HTML element, that will
    hold the time, whenever the state changes:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个监听器到store，当状态改变时更新包含时间的HTML元素：
- en: '[PRE97]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Subscribe a listener to the store that will update the HTML element, that will
    display a lucky number, whenever the state changes:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个监听器到store，当状态改变时更新包含幸运数字的HTML元素：
- en: '[PRE98]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Subscribe a listener to the store that will update the HTML element that will
    display the list of To-do items, whenever the state changes. Set the attribute
    `draggable` for the `li` HTML elements to allow the user to drag and drop the
    items on the view:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个监听器到store，当状态改变时更新包含待办事项列表的HTML元素。为`li` HTML元素设置`draggable`属性，允许用户在视图上拖放项目：
- en: '[PRE99]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Add an event listener for the `click` event on the list HTML element that will
    toggle a To-do item''s `completed` property whenever the item is clicked:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表HTML元素上添加一个`click`事件的事件监听器，以在点击项目时切换待办事项的`completed`属性：
- en: '[PRE100]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Add an event listener for the `drag` event on the list HTML element that will
    remove a To-do Item when this one is dragged outside of the list:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表HTML元素上添加一个`drag`事件的事件监听器，当拖动项目到列表之外时，将移除一个待办事项：
- en: '[PRE101]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Add an event listener for the `submit` event on the form that contains an input
    HTML element that will dispatch a new action to add a new To-do item:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含输入HTML元素的表单上添加一个`submit`事件的事件监听器，以分派一个新动作来添加一个新的待办事项：
- en: '[PRE102]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When the page loads for the first time, dispatch an action to set a lucky number
    and define a function that will get triggered every second to update the current
    time in the state of the application:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面首次加载时，分发一个动作来设置一个幸运数字，并定义一个每秒触发的函数，以更新应用程序状态中的当前时间：
- en: '[PRE103]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Save the file
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: Let's test it...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'To see the previous work in action:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前的工作成果：
- en: 'Open a new Terminal and run:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE104]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In your browser, visit:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，访问：
- en: '[PRE105]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Introduce something in the input box and press enter. A new item should appear
    in the list.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入框中输入内容并按回车。列表中应该会出现一个新项目。
- en: Click on one of the items that you have added to mark it as completed.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击其中一个您添加的项目，标记为已完成。
- en: Click once again on one of the items marked as completed to mark it as not completed.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击其中一个标记为已完成的项目，将其标记为未完成。
- en: Click and drag one of the items outside of the list to remove it from the To-do
    list.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动其中一个项目到列表之外，以将其从待办事项列表中移除。
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Three reducer functions were defined to independently manage each slice of
    the state that has the following shape:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了三个reducer函数，分别独立管理具有以下结构的状态切片：
- en: '[PRE106]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We used the `combineReducers` helper method from the Redux library to combine
    those three reducers into a single one
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了Redux库中的`combineReducers`辅助方法，将这三个reducer组合成一个单一的reducer
- en: Then, a store was created providing the combined reducer function
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建了一个存储，提供了组合的reducer函数
- en: For convenience, we subscribed three listener functions that get triggered whenever
    the state changes to update the HTML elements used to display the data from the
    state
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为方便起见，我们订阅了三个监听函数，每当状态发生变化时，这些函数就会被触发，以更新用于显示状态数据的HTML元素
- en: 'We also defined three event listeners: one to detect when a user submits a
    form that contains an input HTML element to add a new To-do item, another to detect
    when the user clicks on a To-do item displayed on the screen to toggle its state
    from not completed to completed or vice versa, and finally one event listener
    to detect when the user drags an element from the list to dispatch an action to
    remove it from the list of To-do items'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了三个事件监听器：一个用于检测用户提交包含输入HTML元素的表单以添加新的待办事项，另一个用于检测用户点击屏幕上显示的待办事项以切换其状态，最后一个事件监听器用于检测用户拖动列表中的元素以分派一个动作将其从待办事项列表中移除
- en: Writing Redux store enhancers
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Redux存储增强器
- en: 'A Redux store enhancer is a higher-order function that takes a store creator
    function and returns a new enhanced store creator function. The `createStore`
    method is a store creator which has the following signature:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Redux存储增强器是一个高阶函数，它接受一个存储创建函数，并返回一个新的增强存储创建函数。`createStore`方法是一个存储创建函数，具有以下签名：
- en: '[PRE107]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'While a store enhancer function has the following signature:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 而存储增强器函数具有以下签名：
- en: '[PRE108]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: It may look a bit difficult to understand now, but you don't really have to
    worry if you don't get it at first because you will probably never need to write
    a store enhancer. The purpose of this recipe was simply to help you to understand
    their purpose in a very simple way.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能看起来有点难以理解，但如果一开始不理解也不必担心，因为您可能永远不需要编写存储增强器。这个示例的目的只是帮助您以非常简单的方式理解它们的目的。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will create a store enhancer to expand the functionality
    of Redux by allowing the definition of reducer functions in a `Map` JavaScript
    native object. First, create a new `package.json` file with the following content:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将创建一个存储增强器，以扩展Redux的功能，允许在`Map`JavaScript原生对象中定义reducer函数。首先，创建一个新的`package.json`文件，内容如下：
- en: '[PRE109]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE110]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Remember that `createStore` accepts a single reducer function as the first
    argument. We write a store enhancer to allow the `createStore` method to accept
    a `Map` object containing key-value pairs, where key is the property or slice
    of state that will be managed, and value is a `reducer` function. Then, define
    two reducer functions using a `Map` object to handle two slices of the state,
    one for a counter and the other for setting the current time:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`createStore`接受一个单一的reducer函数作为第一个参数。我们编写了一个存储增强器，允许`createStore`方法接受一个包含键值对的`Map`对象，其中键是将要管理的状态属性或切片，值是一个`reducer`函数。然后，使用`Map`对象定义了两个reducer函数来处理状态的两个切片，一个用于计数，另一个用于设置当前时间：
- en: Create a new file named `map-store.js`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`map-store.js`的新文件。
- en: 'Include the Redux library:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括Redux库：
- en: '[PRE111]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Define a store enhancer function that will allow the `createStore` method to
    accept a `Map` object as an argument. It will go through each key-value pair of
    the `Map` and add it to an object which will then be used to combine the reducers
    using the `combineReducers` method:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个存储增强函数，允许`createStore`方法接受一个`Map`对象作为参数。它将遍历`Map`的每个键值对，并将其添加到一个对象中，然后使用`combineReducers`方法来组合这些reducer：
- en: '[PRE112]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Define actions types:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义动作类型：
- en: '[PRE113]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Define actions creators:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义动作创建者：
- en: '[PRE114]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Define a `map` constant that will contain an instance of `Map`:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`map`常量，其中包含一个`Map`的实例：
- en: '[PRE115]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Add a new reducer function to the `map` object with a key `counter`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`map`对象添加一个新的reducer函数，使用`counter`作为键：
- en: '[PRE116]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Add another reducer function to the `map` object with a key `time`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`map`对象添加另一个reducer函数，使用`time`作为键：
- en: '[PRE117]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Create a new store providing the `map` as the first argument and the **store
    enhancer** as the second argument to extend the functionality of the `createStore`
    method:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的存储，将`map`作为第一个参数，并将**存储增强器**作为第二个参数，以扩展`createStore`方法的功能：
- en: '[PRE118]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Bind the previously defined actions creators to the `dispatch` method of the
    store:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将先前定义的动作创建者绑定到存储的`dispatch`方法：
- en: '[PRE119]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To test the code in NodeJS, use the `setInterval` global method to repeatedly
    call a function every second. It will first dispatch an action to set the current
    time, then, based on the criteria, it will decide if to increment or decrement
    the counter. After, pretty print in the terminal the current value of the store:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 NodeJS 中测试代码，使用`setInterval`全局方法来每秒重复调用一个函数。它将首先分派一个动作来设置当前时间，然后根据条件决定是增加还是减少计数器。之后，在终端中漂亮地打印出存储的当前值：
- en: '[PRE120]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Save the file.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'Open a new Terminal and run:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE121]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The current state would be displayed every second having this shape:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前状态将每秒显示一次，具有以下形式：
- en: '[PRE122]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: How it works...
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The enhancer composes the store creator into a new one. For instance, the following
    line:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 增强器将存储创建者组合成一个新的存储创建者。例如，以下行：
- en: '[PRE123]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Could be written as:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写成：
- en: '[PRE124]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Which actually, in a way, wraps the original `createStore` method into another
    `createStore` method.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这在某种程度上将原始的`createStore`方法包装到另一个`createStore`方法中。
- en: 'Composition can be explained as a set of functions that are called accepting
    the result argument of the previous function. For instance:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 组合可以解释为一组函数，这些函数被调用并接受前一个函数的结果参数。例如：
- en: '[PRE125]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This composes functions `f`, `g`, and `h` from right to left into a single
    function `c`. That means, we could write the previous line of code also like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这将函数`f`、`g`和`h`从右到左组合成一个单一的函数`c`。这意味着，我们也可以像这样写前一行代码：
- en: '[PRE126]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Here `_createStore` is the result of composing `createStore` and your store
    enhancer function.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`_createStore`是将`createStore`和您的存储增强器函数组合的结果。
- en: Time traveling with Redux
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux 进行时间旅行
- en: 'Even though, you may probably never need to write store enhancers, there is
    one special that you may find very useful for debugging your Redux powered applications
    to time travel through the state of your application. You can enable time traveling
    on your application by simple installing **Redux DevTools Extension** (for Chrome
    and Firefox): [https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension).'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可能永远不需要编写存储增强器，但有一种特殊的存储增强器可能对调试您的 Redux 动力应用程序非常有用，它可以通过应用程序的状态进行时间旅行。您可以通过简单安装**Redux
    DevTools 扩展**（适用于 Chrome 和 Firefox）来启用应用程序的时间旅行：[https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension)。
- en: Getting ready
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will see an example of how to take advanced of this feature
    and analyze how the state of your application has changed over the time that was
    running on the browser. First, create a new `package.json` file with the following
    content:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到一个示例，演示如何利用这个功能，并分析应用程序的状态在浏览器上运行的时间内如何发生变化。首先，创建一个新的`package.json`文件，内容如下：
- en: '[PRE127]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行来安装依赖项：
- en: '[PRE128]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Make sure to have installed the Redux DevTools Extension in your web browser.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在您的网络浏览器中安装了 Redux DevTools 扩展。
- en: How to do it...
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Build a counter application that will randomly increment or decrement the initial
    specified counter 10 times when the application is run on the browser. However,
    because it happens fast, the user won't be able to notice that the state has actually
    changed 10 times since the application started. We will use the Redux DevTools
    Extension to navigate and analyze how the state has changed over time.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个计数器应用程序，当应用程序在浏览器上运行时，它将随机增加或减少初始指定的计数器10次。然而，由于它发生得很快，用户将无法注意到自应用程序启动以来状态实际上已经改变了10次。我们将使用
    Redux DevTools 扩展来浏览和分析状态随时间如何改变。
- en: 'First, build a small ExpressJS server application that will serve the client
    application and the Redux library installed in `node_modules`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一个小的 ExpressJS 服务器应用程序，该应用程序将为客户端应用程序提供服务，并安装在`node_modules`中的 Redux 库：
- en: Create a new file named `time-travel.js`
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`time-travel.js`的新文件
- en: 'Add the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE129]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Save the file
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Next, build your counter, Redux powered application, with time travel capabilities:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用时间旅行功能构建您的计数器，Redux 动力应用程序：
- en: Create a new file named `time-travel.html`
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`time-travel.html`的新文件
- en: 'Add the following HTML code:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 HTML 代码：
- en: '[PRE130]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Inside the script tag add the JavaScript code that follows the next steps, starting
    from step 4
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签中添加以下 JavaScript 代码，按照以下步骤开始，从第4步开始
- en: 'Keep a reference to the `span` HTML element that will display the current value
    of the counter whenever the state changes:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留一个引用到`span` HTML 元素，每当状态改变时将显示计数器的当前值：
- en: '[PRE131]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Get the `createStore` method and `bindActionCreators` method from the Redux
    library:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Redux 库中获取`createStore`方法和`bindActionCreators`方法：
- en: '[PRE132]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Define two action types:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两种动作类型：
- en: '[PRE133]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Define two action creators:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个动作创建者：
- en: '[PRE134]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Define a reducer function that will transform the state according to the given
    action type:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 reducer 函数，根据给定的动作类型转换状态：
- en: '[PRE135]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Create a new store providing a store enhancer function that will be available
    on the `window` object when the Redux DevTools extension is installed:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的存储，提供一个存储增强器函数，当安装 Redux DevTools 扩展时，它将在`window`对象上可用：
- en: '[PRE136]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Bind the action creators to the `dispatch` method of the store:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动作创建者绑定到存储的`dispatch`方法：
- en: '[PRE137]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Subscribe a listener function to the store that will update the `span` HTML
    element whenever the state changes:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个监听函数到存储，每当状态改变时将更新`span` HTML 元素：
- en: '[PRE138]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Let''s create a `for` loop that will update increment or decrement the counter
    randomly 10 times when the application is run:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`for`循环，当应用程序运行时，它会随机更新增加或减少计数器10次：
- en: '[PRE139]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Save the file
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: Let's test it...
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'To see the previous work in action:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前的工作效果：
- en: 'Open a new Terminal and run:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE140]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'In your Browser, visit:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中访问：
- en: '[PRE141]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Open Developer Tools of your Browser and look for the Redux tab. You should
    see a tab like this:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器的开发者工具，并查找Redux选项卡。您应该看到一个类似这样的选项卡：
- en: '![](img/d6635f01-f201-44b1-91ba-76ee735152da.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6635f01-f201-44b1-91ba-76ee735152da.png)'
- en: Redux DevTools – Tab Window
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools – Tab Window
- en: 'The slider allows you to move from the last state to the very first state of
    your application. Try moving the slider to a different position:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滑块允许您从应用程序的最后状态移动到最初状态。尝试将滑块移动到不同的位置：
- en: '![](img/64146aed-2c98-42af-bfef-96fa08b2d098.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64146aed-2c98-42af-bfef-96fa08b2d098.png)'
- en: Redux DevTools – Moving Slider
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools – Moving Slider
- en: While moving the slider, you would be able to see in your browser the counters
    initial value and how it changed those ten times in the for loop
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移动滑块时，您可以在浏览器中看到计数器的初始值以及在for循环中如何改变这些值十次
- en: There's more
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: '**Redux DevTools** has some features that you will probably find amazing and
    helpful for debugging and managing the state of your application. In fact, if
    you followed the previous recipes, I suggest you go back to the projects we wrote
    and enable this enhancer and try to experiment with Redux DevTools.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redux DevTools**具有一些功能，您可能会发现令人惊讶和有助于调试和管理应用程序状态。实际上，如果您遵循了之前的示例，我建议您返回我们编写的项目，并启用此增强器，尝试使用Redux
    DevTools进行实验。'
- en: 'One of many features of Redux DevTools is the Log monitor, which displays in
    chronological order which action was dispatched and the resulting value of transforming
    the state:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools的众多功能之一是Log监视器，它按时间顺序显示分派的动作以及转换状态的结果值：
- en: '![](img/c1d3b8a0-3d7d-4f30-80a0-1c660b506e43.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d3b8a0-3d7d-4f30-80a0-1c660b506e43.png)'
- en: Redux DevTools – Log Monitor
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools – Log Monitor
- en: Understanding Redux middleware
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Redux中间件
- en: Probably the easiest and best way of extending the Redux functionality is by
    using middleware.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单和最好的扩展Redux功能的方法是使用中间件。
- en: 'There is a store enhancer function that comes in the Redux library named `applyMiddleware`
    and allows you define one or multiple middleware functions. The way middleware
    works in Redux is simple, it allows you to wrap the `dispatch` method of the store
    to extend its functionality. The same way as store enhancer functions, middleware
    is composable and has the following signature:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Redux库中有一个名为`applyMiddleware`的store增强函数，允许您定义一个或多个中间件函数。Redux中的中间件工作方式很简单，它允许您包装store的`dispatch`方法以扩展其功能。与store增强函数一样，中间件是可组合的，并具有以下签名：
- en: '[PRE142]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Here, `API` is an object containing the `dispatch` and `getState` methods from
    the store, destructuring the `API`, the signature looks like this:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`API`是一个包含来自store的`dispatch`和`getState`方法的对象，解构`API`，签名如下：
- en: '[PRE143]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Let''s analyze how it works:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析它是如何工作的：
- en: 'The `applyMiddleware` function receives one or more middleware functions as
    arguments. For example:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`applyMiddleware`函数接收一个或多个中间件函数作为参数。例如：'
- en: '[PRE144]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Each middleware function is kept internally as an `Array`. Then, internally
    using the `Array.prototype.map` method, the array maps each middleware function
    by calling itself providing the middleware `API` object which contains the `dispatch`
    and `getState` methods of the store. Similar to this:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个中间件函数在内部都被保留为一个`Array`。然后，在内部使用`Array.prototype.map`方法，数组通过调用自身提供store的`dispatch`和`getState`方法的中间件`API`对象来映射每个中间件函数。类似于这样：
- en: '[PRE145]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Then, by composing all the middleware functions, it computes a new value for
    the `dispatch` method providing the `next` argument. In the very first middleware
    that is executed, the `next` argument refers to the original `dispatch` method
    before any middleware was applied. For instance, if applying three middleware
    functions, the new computed dispatch method''s signature would be:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过组合所有中间件函数，使用`next`参数计算`dispatch`方法的新值。在执行的第一个中间件中，`next`参数指的是在应用任何中间件之前的原始`dispatch`方法。例如，如果应用了三个中间件函数，新计算的dispatch方法的签名将是：
- en: '[PRE146]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Which means that a middleware function can interrupt the chain and prevent a
    certain action from being dispatched if the `next(action)` method is not called
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着中间件函数可以中断链，并且如果未调用`next(action)`方法，则可以阻止某个动作的分派
- en: The dispatch method from the middleware `API` object, allows you to call the
    dispatch method of the store with the previously applied middleware. That means,
    if you are not careful while using this method, you may create an infinite loop
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件`API`对象的dispatch方法允许您调用store的dispatch方法，并应用之前应用的中间件。这意味着，如果在使用此方法时不小心，可能会创建一个无限循环
- en: Understanding how it works internally may not be so simple at first, but I assure
    you that you will get it soon.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 最初可能不那么简单地理解其内部工作方式，但我向你保证，你很快就会理解。
- en: Getting ready
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will write a middleware function that will warn the user
    when dispatching an action type that has not been defined. First, create a new
    `package.json` file with the following content:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将编写一个中间件函数，当分派未定义的动作类型时，它将警告用户。首先，创建一个包含以下内容的新的`package.json`文件：
- en: '[PRE147]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE148]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: How to do it...
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Redux doesn''t warn you or display errors when an action type, that was never
    defined within your reducers, is used. Build a NodeJS application that will use
    Redux to manage its state. Focus on writing a middleware function that will check
    that the dispatched actions types are defined or else throw an error:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当在reducers中从未定义过的action类型被使用时，Redux不会警告你或显示错误。构建一个NodeJS应用程序，该应用程序将使用Redux来管理其状态。专注于编写一个中间件函数，该函数将检查分派的动作类型是否已定义，否则会抛出错误：
- en: Create a new file named `type-check-redux.js`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`type-check-redux.js`的新文件。
- en: 'Include the Redux library:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括Redux库：
- en: '[PRE149]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Define an object containing the allowed action types:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含允许的动作类型的对象：
- en: '[PRE150]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Create a dummy reducer function that returns its original state whichever action
    type is called. We don''t need it for the purpose of this recipe:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个虚拟的reducer函数，无论调用哪种动作类型，它都会返回其原始状态。我们不需要它来实现这个示例的目的：
- en: '[PRE151]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Define a middleware function that will intercept every action that is being
    dispatched and check whether the action type exists in the `TYPE` object. If the
    action exists allow the action to be dispatched, or otherwise, throw an error
    and inform the user that an invalid action type was dispatched. Additionally,
    let''s provide the user, as part of the error message, information about which
    valid types are allowed:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个中间件函数，该函数将拦截正在分派的每个操作，并检查操作类型是否存在于`TYPE`对象中。如果操作存在，则允许分派操作，否则，抛出错误并通知用户分派了无效的操作类型。另外，让我们在错误消息的一部分中提供用户有关允许的有效类型的信息：
- en: '[PRE152]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Create a store and apply the defined middleware function:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个存储并应用定义的中间件函数：
- en: '[PRE153]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Dispatch two action types. The first action type is valid, and it exists in
    the `TYPE` object. However, the second one is an action type that was never defined:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分派两种操作类型。第一个操作类型是有效的，并且存在于`TYPE`对象中。但是，第二个是一个从未定义的操作类型：
- en: '[PRE154]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Save the file.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Let's test it...
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'First, open a new Terminal and run:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端并运行：
- en: '[PRE155]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The Terminal output should display an error similar to this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 终端输出应显示类似于此的错误：
- en: '[PRE156]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'In this example, the stack trace tells us that the error happened on line `18`,
    which points to our middleware function. However, the next one points to line
    `33`, `store.dispatch({ type: ''MISTAKE'' })`, which is a good thing because it
    can help you track exactly where certain actions are dispatched that were never
    defined.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，堆栈跟踪告诉我们错误发生在第`18`行，指向我们的中间件函数。但是，下一个指向第`33`行，`store.dispatch({ type:
    ''MISTAKE'' })`，这是一个好事，因为它可以帮助您准确跟踪分派了从未定义的某些操作的位置。'
- en: How it works...
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It's pretty simple, the middleware function checks the action type, of the action
    being dispatched, to see if it exists as a property of the `TYPE` object constant.
    If it exists, then the middleware passes control to the next middleware in the
    chain. However, in our case, there is no next middleware, so the control is passed
    to the original dispatch method of the store that will apply the reducer and transform
    the state. On the other side, if the action type was not defined, the middleware
    function interrupts the middleware chain by not calling the `next` function and
    by throwing an error.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，中间件函数检查被分派的操作的操作类型，以查看它是否存在作为`TYPE`对象常量的属性。如果存在，则中间件将控制传递给链中的下一个中间件。但是，在我们的情况下，没有下一个中间件，因此控制权被传递给存储的原始分派方法，该方法将应用减速器并转换状态。另一方面，如果未定义操作类型，则中间件函数通过不调用`next`函数并抛出错误来中断中间件链。
- en: Dealing with asynchronous data flow
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步数据流
- en: By default, Redux doesn't handle asynchronous data flow. There are several libraries
    out there that can help you with these tasks. However, for the purpose of this
    chapter, we will build our own implementation using middleware functions to give
    the `dispatch` method the ability to dispatch and handle asynchronous data flow.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Redux不处理异步数据流。有几个库可以帮助您完成这些任务。但是，为了本章的目的，我们将使用中间件函数构建我们自己的实现，以使`dispatch`方法能够分派和处理异步数据流。
- en: Getting ready
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will build an ExpressJS application with a very small API
    to test your application when making HTTP requests and dealing with asynchronous
    data flow and errors. First, create a new `package.json` file with the following
    content:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将构建一个ExpressJS应用程序，其中包含一个非常小的API，用于测试应用程序在进行HTTP请求和处理异步数据流和错误时的情况。首先，创建一个新的`package.json`文件，内容如下：
- en: '[PRE157]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Then install the dependencies by opening a Terminal and running:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过打开终端并运行来安装依赖项：
- en: '[PRE158]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: How to do it...
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Build a simple RESTful API server that will have two endpoints or answer to
    paths `/time` and `/date` when a GET request is made. However, on `/date` path,
    we will pretend that there is an internal error and make the request fail in order
    to see how to handle errors in asynchronous requests as well:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个简单的RESTful API服务器，当进行GET请求时，将有两个端点或回答路径`/time`和`/date`。但是，在`/date`路径上，我们将假装存在内部错误，并使请求失败，以查看如何处理异步请求中的错误：
- en: Create a new file named `api-server.js`
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`api-server.js`的新文件
- en: 'Include the ExpressJS library and initialize a new ExpressJS application:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括ExpressJS库并初始化一个新的ExpressJS应用程序：
- en: '[PRE159]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'For `/time` path, simulates a delay of `2s` before sending a response:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`/time`路径，在发送响应之前模拟延迟`2s`：
- en: '[PRE160]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'For `/date` path, simulates a delay of `2s` before sending a failed response:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`/date`路径，在发送失败响应之前模拟延迟`2s`：
- en: '[PRE161]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Listen on port `1337` for new connections
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听端口`1337`以获取新连接
- en: '[PRE162]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Save the file
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'As for the client, build a NodeJS application using Redux that will dispatch
    synchronous and asynchronous actions. Write a middleware function to allow the
    dispatch method to handle asynchronous actions:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 至于客户端，使用Redux构建一个NodeJS应用程序，该应用程序将分派同步和异步操作。编写一个中间件函数，以使分派方法能够处理异步操作：
- en: Create a new file named `async-redux.js`
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`async-redux.js`的新文件
- en: 'Include the `node-fetch` and Redux libraries:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括`node-fetch`和Redux库：
- en: '[PRE163]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Define three kinds of status. Each status represents the state of an asynchronous
    operation:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三种状态。每种状态表示异步操作的状态：
- en: '[PRE164]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Define two action types:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两种操作类型：
- en: '[PRE165]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Define action creators. Notice that the value property is an asynchronous function
    in the first two action creators. Your, later defined, middleware function will
    be responsible for making Redux understand these actions:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义操作创建者。请注意，前两个操作创建者中的值属性是一个异步函数。稍后定义的中间件函数将负责使Redux理解这些操作：
- en: '[PRE166]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Define a common function for setting values from an action object that will
    be used in your reducer:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个通用函数，用于从操作对象中设置值，该函数将在您的减速器中使用：
- en: '[PRE167]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Define the initial state of your application:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义应用程序的初始状态：
- en: '[PRE168]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Define a reducer function. Notice that it is only one reducer that handles
    two slices of the state, the `time` and the `date`:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个减速器函数。请注意，它只有一个减速器，处理状态的两个部分，即`time`和`date`：
- en: '[PRE169]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Define a middleware function that will check whether a dispatched action type
    has a function as the `value` property. If that is so, assume that the `value`
    property is an async function. First, we dispatch an action to set the status
    as `PENDING`. Then, when the async function is resolved, we dispatch another action
    to set the status as `RESOLVED` or in case of an error as `REJECTED`:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个中间件函数，用于检查分发的动作类型是否具有`value`属性作为函数。如果是这样，假设`value`属性是一个异步函数。首先，我们分发一个动作来将状态设置为`PENDING`。然后，当异步函数解决时，我们分发另一个动作来将状态设置为`RESOLVED`，或者在出现错误时设置为`REJECTED`。
- en: '[PRE170]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Create a new store and apply your defined middleware function to extend the
    functionality of the `dispatch` method:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的存储器，并应用你定义的中间件函数来扩展`dispatch`方法的功能：
- en: '[PRE171]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Bind action creators to the `dispatch` method of the store:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动作创建器绑定到存储器的`dispatch`方法上：
- en: '[PRE172]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Subscribe a function listener to the store and display in terminal the state
    tree, as a JSON string, every time there is a change in the state:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个函数监听器到存储器，并在每次状态发生变化时在终端显示状态树，以JSON字符串的形式。
- en: '[PRE173]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Dispatch a synchronous action to set the time:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发一个同步动作来设置时间：
- en: '[PRE174]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Dispatch an asynchronous action to fetch and set the time:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发一个异步动作来获取并设置时间：
- en: '[PRE175]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Dispatch another asynchronous action to fetch and try to set the date. Remember
    that this operation is supposed to fail and it''s intentional:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发另一个异步动作来获取并尝试设置日期。请记住，这个操作应该失败，这是故意的。
- en: '[PRE176]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Save the file.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Let's test it...
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'To see your previous work in action:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前的工作成果：
- en: 'Open a new terminal and run:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE177]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Without closing the previously running NodeJS process, open another Terminal
    and run:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不关闭先前运行的NodeJS进程的情况下，打开另一个终端并运行：
- en: '[PRE178]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: How it works...
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理是这样的...
- en: Every time there is a change in the state, the subscribed listener function
    will pretty print in the terminal the current state tree
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当状态发生变化时，订阅的监听函数将在终端中漂亮地打印出当前状态树。
- en: 'The first dispatched action is synchronous. It will cause the time slice of
    the state tree to be updated like this, for example:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个分发的动作是同步的。它将导致状态树的时间片段被更新，例如像这样：
- en: '[PRE179]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The second action being dispatched is asynchronous. Internally, two actions
    are dispatched to reflect the state of the asynchronous operation, one when the
    async function is still in execution, and another when the async function was
    fulfilled:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个被分发的动作是异步的。在内部，会分发两个动作来反映异步操作的状态，一个是在异步函数仍在执行时，另一个是在异步函数被执行完成时。
- en: '[PRE180]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The third action being dispatched is also asynchronous. Internally, it also
    causes two actions to be dispatched to reflect the state of the async operation:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个被分发的动作也是异步的。在内部，它也会导致分发两个动作来反映异步操作的状态。
- en: '[PRE181]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Take into account that because the operations are asynchronous, the output displayed
    in the terminal may not always be in the same order
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，由于操作是异步的，终端显示的输出可能不总是按照相同的顺序进行。
- en: Notice that the first async operation is fulfilled and the status marked as
    `RESOLVED` while the second async operation is fulfilled and its status marked
    as `REJECTED`
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，第一个异步操作被执行完成，并且状态标记为`RESOLVED`，而第二个异步操作被执行完成，并且其状态标记为`REJECTED`。
- en: The statuses `PENDING`, `RESOLVED`, and `REJECTED` reflect the three statuses
    that a JavaScript Promise can be, and they are not obligatory names, simply easy
    to remember
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态`PENDING`，`RESOLVED`和`REJECTED`反映了JavaScript Promise可能具有的三种状态，并且它们不是强制性的名称，只是易于记忆。
- en: There's more...
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you don''t want to write your own middleware functions or store enhancers
    to deal with asynchronous operations, you can opt to use one of the many libraries
    for Redux that exist out there. Two of the most use or popular ones are these:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想编写自己的中间件函数或存储增强器来处理异步操作，你可以选择使用Redux的许多现有库之一。其中两个最常用或最受欢迎的是这些：
- en: Redux Thunk—[https://github.com/gaearon/redux-thunk](https://github.com/gaearon/redux-thunk)
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Thunk—[https://github.com/gaearon/redux-thunk](https://github.com/gaearon/redux-thunk)
- en: Redux Saga—[https://github.com/redux-saga/redux-saga](https://github.com/redux-saga/redux-saga)
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Saga—[https://github.com/redux-saga/redux-saga](https://github.com/redux-saga/redux-saga)
