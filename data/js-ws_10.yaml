- en: 10\. Accessing External Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 访问外部资源
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to describe AJAX, REST, JSON, and
    HTTP to APIs; perform service calls using a library such as jQuery and native
    XMLHttpRequest and be familiar with the pros and cons of each approach; use an
    external API to retrieve data using JavaScript; use some jQuery functionality
    for the UI and events; and identify cross-domain-capable APIs and use cross-domain
    requests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够描述 AJAX、REST、JSON 和 HTTP 到 API 的内容；使用 jQuery 或原生 XMLHttpRequest 等库执行服务调用，并熟悉每种方法的优缺点；使用
    JavaScript 通过外部 API 获取数据；使用一些 jQuery 功能进行 UI 和事件处理；并识别支持跨域的 API 并使用跨域请求。
- en: In this chapter, we will cover various approaches to using AJAX to obtain data,
    primarily from RESTful services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用 AJAX 获取数据的不同方法，主要是从 RESTful 服务中获取。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned about Node.js, which runs on the server-side.
    This chapter will cover the other side of services – you will learn how to call
    them from the client-side. There's a good chance that services being accessed
    are, in fact, implemented in Node.js, but it is common for them to run on other
    platforms as well, such as Java, C#, and Python.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了 Node.js，它运行在服务器端。本章将涵盖服务的另一面——您将学习如何从客户端调用它们。被访问的服务实际上可能是用 Node.js
    实现的，但它们通常也运行在其他平台上，如 Java、C# 和 Python。
- en: Web pages are static and of limited use without fresh data. Web services are
    a set of technologies that provide standards for your web page to communicate
    with other servers and sites to exchange data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 没有新鲜数据的网页是静态的，用途有限。网络服务是一套技术，为您的网页提供与其他服务器和站点通信的标准，以交换数据。
- en: To enable services implemented in different languages to communicate with each
    other, they need to have common rules regarding how the requests and responses
    being exchanged should look and be structured. For this reason, there are a number
    of different standards and approaches to web services out there that define the
    format of data being exchanged. The most popular combination used for websites
    today is **REST** with **JSON**, which stands for **Representational State Transfer**
    with **JavaScript Object Notation**. This chapter will describe in detail all
    you need to know in order to call REST services to provide data for your web pages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用不同语言实现的服务能够相互通信，它们需要有一套共同的规则，关于交换的请求和响应应该如何看起来以及如何结构化。因此，存在许多不同的标准和网络服务方法，它们定义了交换数据格式。目前用于网站的最流行组合是
    **REST** 与 **JSON**，它代表 **Representational State Transfer** 与 **JavaScript Object
    Notation**。本章将详细描述您需要了解的所有内容，以便调用 REST 服务为您的网页提供数据。
- en: Before web services came about, web servers needed to gather all required data
    on the server-side before rendering the final HTML they would serve. To get a
    fresh update, the entire page had to be redrawn. The user experience of the pages
    was constantly affected, especially if the data involved complex calculations
    or queries, as the user would need to wait until redrawing was complete and didn't
    have the ability to use any other functionality on the page in the meantime.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络服务出现之前，网络服务器需要在服务器端收集所有必要的数据，然后渲染最终要提供的 HTML。为了获取新鲜更新，整个页面必须重新绘制。页面用户体验始终受到影响，特别是如果涉及复杂计算或查询，因为用户需要等待重新绘制完成，在此期间无法使用页面上的任何其他功能。
- en: For example, think of a page that displays stock quotes or email messages. In
    the old days, you would have to reload or refresh the whole page in the browser
    to see whether there were any updates to the stock quotes or whether you had any
    new mail. Web services and dynamic HTML changed this, as it is now common for
    pages to only update portions at a time without needing to reload and redraw the
    entire page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个显示股票报价或电子邮件信息的页面。在以前，您必须在浏览器中重新加载或刷新整个页面，才能查看股票报价是否有更新，或者是否有新邮件。网络服务和动态
    HTML 改变了这一点，因为现在页面通常只更新部分内容，而不需要重新加载和重新绘制整个页面。
- en: Note that many web services use a different technology, known as **SOAP**, which
    stands for **Simple Object Access Protocol** with an **XML** (**eXtensible Markup
    Language**) format. There are some emerging standards as well that are gaining
    traction, such as Google's protocol buffers. While each of these technologies
    has its advantages and disadvantages and use cases where they are appropriate,
    we will only focus on REST and JSON in this book as they are the most widespread
    methods in use today.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，许多网络服务使用一种称为**SOAP**的不同技术，它代表**简单对象访问协议**，具有**XML**（可扩展标记语言）格式。还有一些新兴的标准也在获得关注，例如谷歌的协议缓冲区。虽然每种技术都有其优点和缺点以及适用的用例，但本书中我们将只关注REST和JSON，因为它们是目前使用最广泛的方法。
- en: JSON
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: As you have been using JavaScript up until now in this book, you should feel
    right at home with the syntax of JSON, as it is derived from JavaScript and closely
    resembles object structures you have already learned in previous chapters. JSON,
    usually pronounced like the name Jason, is lightweight, easy for humans to read
    and write, and easy for machines to parse and work with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您在本书中一直使用JavaScript，因此您应该对JSON的语法感到非常熟悉，因为它是从JavaScript派生出来的，并且与您在前面章节中学到的对象结构非常相似。JSON，通常发音像名字Jason，轻量级，易于人类阅读和编写，也易于机器解析和处理。
- en: 'There are two main data structures used in JSON:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JSON中使用了两种主要的数据结构：
- en: A collection of key-value pairs enclosed in curly-braces `{ }`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用花括号`{ }`括起来的键值对集合
- en: A list of values enclosed in square brackets `[ ]`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用方括号`[ ]`括起来的值列表
- en: 'Here''s a sample JSON object that shows different structures and value types:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例JSON对象，展示了不同的结构和值类型：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each key-value pair has the key wrapped in double quotation marks, as in `"key"`,
    and a colon is placed between the key and the value. For example, the following
    would be incorrect, as the key does not have double quotation marks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键值对中，键被双引号包围，例如`"key"`，键和值之间放置一个冒号。例如，以下是不正确的，因为键没有双引号：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Keys must be unique within each object, can be any valid string, and allow space
    characters (though it is not always the best idea to use spaces in keys, as programming
    is sometimes easier if other characters, such as underscores, are used instead).
    Each key-value pair is separated by a comma.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 键必须在每个对象内是唯一的，可以是任何有效的字符串，并允许空格字符（尽管在键中使用空格并不总是最好的主意，因为如果使用其他字符，如下划线，编程可能更容易）。每个键值对通过逗号分隔。
- en: 'The values can be one of the following types:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以是以下类型之一：
- en: '`"twitter_username": "@LeoDiCaprio"` in the preceding example. String values
    are enclosed in double-quotes.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在前面的示例中`"twitter_username": "@LeoDiCaprio"`。字符串值用双引号括起来。'
- en: '`"year": 1997` in the preceding example. Sign (+ or -) and decimal fractions
    are also permitted. Numbers are not enclosed in double-quotes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在前面的示例中`"year": 1997`。符号（+或-）和小数也是允许的。数字不需要用双引号括起来。'
- en: '`"active": true` in the preceding example (Boolean values are not enclosed
    in double-quotes).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在前面的示例中`"active": true`（布尔值不需要用双引号括起来）。'
- en: '**Nested array**: This is a value that is itself an array of strings. Each
    of the strings is enclosed in double-quotes and separated by a comma. (An array
    is used here to allow any number of costars to be specified). Have a look at the
    example block:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套数组**：这是一个自身是字符串数组的值。每个字符串都用双引号括起来，并通过逗号分隔。（在这里使用数组是为了允许指定任意数量的联袂演员）。看看下面的示例块：'
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`famous_movies` list. Each element in the array is a nested object that contains
    fields related to a movie, including `title, director, costars`, and `year`. The
    nested objects in the array are separated by a comma.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`famous_movies`列表。数组中的每个元素都是一个包含与电影相关的字段（包括`title, director, costars`和`year`）的嵌套对象。数组中的嵌套对象通过逗号分隔。'
- en: '`"eye_color": null` in the preceding code snippet. `Null` can be used to indicate
    an unknown or inapplicable value. `Null` is indicated with no quotes.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在前面的代码片段中`"eye_color": null`。`null`可以用来表示未知或不适用的值。`null`表示时不加引号。'
- en: Note
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: There is some debate on how to best represent such scenarios, with many opinions
    being that if a value is unknown, the field should not appear at all rather than
    assigning a value of `null`. We can leave this debate aside for the purposes of
    this book.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于如何最好地表示此类场景存在一些争议，许多人认为如果某个值未知，则字段根本不应出现，而不是分配一个`null`值。为了本书的目的，我们可以暂时将这个争议放在一边。
- en: Whitespace (spaces, tabs, and carriage returns) is generally ignored in JSON
    (except in strings) and can be used liberally to increase readability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 空白（空格、制表符和换行符）在JSON中通常被忽略（除了字符串之外），并且可以自由使用以提高可读性。
- en: 'There are some important limitations with JSON syntax as well:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JSON语法也有一些重要的限制：
- en: Values must be one of the types previously specified, and cannot have more complex
    expressions, calculations, or function calls.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值必须是之前指定的类型之一，并且不能有更复杂的表达式、计算或函数调用。
- en: Comments are not permitted.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许注释。
- en: REST
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST
- en: An **Application Programming Interface** (**API**) defines the formats and rules
    of how programs talk to each other. REST is a software architectural style that
    has become the de facto standard for most web services used by websites today.
    In this book, rather than getting bogged down with the academic theory behind
    REST, we'll focus on the practical aspects of how to invoke and use RESTful services
    from the client-side.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）定义了程序之间交流的格式和规则。REST是一种软件架构风格，已成为今天大多数网站使用的网络服务的既定标准。在这本书中，我们不会陷入REST背后的学术理论，而是将重点放在客户端如何调用和使用RESTful服务的实际方面。'
- en: What Is HTTP?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是HTTP？
- en: In order to understand REST, it is important to touch a bit on the underlying
    technology of the World Wide Web and how resources are identified and communicated.
    Very briefly, **HyperText Transfer Protocol** (**HTTP**) defines what actions
    web browsers and servers should take in response to various commands.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解REST，了解万维网的基础技术以及资源是如何被标识和通信的非常重要。简要来说，**超文本传输协议**（**HTTP**）定义了浏览器和服务器在响应各种命令时应采取的操作。
- en: 'Resources such as HTML pages, images, documents, or video files are identified
    by using a **Uniform Resource Locator** (**URL**). URLs have the following parts:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**统一资源定位符**（**URL**）通过使用HTML页面、图像、文档或视频文件等资源进行标识。URL具有以下部分：
- en: '![Figure 10.1: Parts of a URL'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：URL的组成部分'
- en: '](img/C14377_10_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片C14377_10_01.jpg](img/C14377_10_01.jpg)'
- en: 'Figure 10.1: Parts of a URL'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：URL的组成部分
- en: '`http` (insecure) or `https` (for secure communication).'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http`（不安全）或`https`（用于安全通信）。'
- en: '**Host Name**: Specifies the location of the IP address or domain name.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主机名**：指定IP地址或域名的位置。'
- en: '`80` is assumed by default for `http` (`443` for `https`).'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`http`假设为`80`（`https`为`443`）。
- en: '**Path**: To a file or location on the webserver.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路径**：指向网络服务器上的文件或位置。'
- en: '`?`). The parameter name is separated from the value by an equals sign (`=`).
    Multiple parameters can also be present, usually separated by an ampersand (`&`).'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数名称与值之间由等号（`=`）分隔。也可以存在多个参数，通常由和号（`&`）分隔。
- en: Most REST APIs favor URLs that combine identifiers with other elements of the
    URL rather than using parameters in the query string, for example, a URL such
    as `http://myserver.com/user/1234`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数REST API倾向于使用结合标识符和其他URL元素的URL，而不是在查询字符串中使用参数，例如，一个如`http://myserver.com/user/1234`的URL。
- en: The preceding URL code is often preferred over `http://myserver.com/user?user_id=1234`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的URL代码通常比`http://myserver.com/user?user_id=1234`更受欢迎。
- en: But this latter style is still perfectly valid and definitely considered RESTful!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种后端风格仍然完全有效，并且绝对被认为是RESTful的！
- en: 'On a basic level, REST utilizes HTTP verbs to perform actions with data or
    resources: `GET` is used to retrieve a resource, `PUT` is used to update a resource,
    `POST` is used to create a new resource, and `DELETE` is used to remove data.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，REST通过使用HTTP动词来对数据进行操作或资源：`GET`用于检索资源，`PUT`用于更新资源，`POST`用于创建新资源，而`DELETE`用于删除数据。
- en: 'HTTP requests frequently require different values to be passed through headers
    as well. The HTTP header format contains name-value pairs separated by a colon.
    For example, to indicate that you desire the data in your HTTP response to be
    in JSON format, it is often necessary to provide the following header:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求通常还需要通过头部传递不同的值。HTTP头部格式包含由冒号分隔的名称-值对。例如，为了表明你希望你的HTTP响应中的数据以JSON格式提供，通常需要提供以下头部：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: TheSportsDB
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TheSportsDB
- en: There are many websites and services that provide data of various types through
    APIs. TheSportsDB ([https://www.thesportsdb.com](https://www.thesportsdb.com))
    is one such site that provides sports-related data through its simple JSON REST
    API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多网站和服务通过API提供各种类型的数据。TheSportsDB（[https://www.thesportsdb.com](https://www.thesportsdb.com)）就是这样一个网站，它通过其简单的JSON
    REST API提供体育相关数据。
- en: 'TheSportsDB is a community database of sports data and artwork that covers
    hundreds of professional and non-professional sports, such as soccer, basketball,
    baseball, tennis, cricket, and motorsport. It provides live scores, logos, rosters,
    stats, schedules, and much more:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: TheSportsDB是一个涵盖数百种专业和非专业体育（如足球、篮球、棒球、网球、板球和赛车）的体育数据和艺术作品的社区数据库。它提供实时比分、标志、阵容、统计数据、赛程等更多信息：
- en: '![Figure 10.2: Home page and logo of TheSportsDB'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2：TheSportsDB的首页和标志'
- en: '](img/C14377_10_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_10_02.jpg)'
- en: 'Figure 10.2: Home page and logo of TheSportsDB'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：TheSportsDB的首页和标志
- en: Many APIs require users to obtain an API key in order to use their services.
    The good news is access to TheSportsDB API is free with a test API key, `1`, for
    educational purposes or smaller applications. (Commercial applications and larger
    users are encouraged to sign up if the API will be used frequently. Donations
    are also accepted, though are not required, through Patreon.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 许多API要求用户获取API密钥才能使用其服务。好消息是，通过测试API密钥 `1`，TheSportsDB API对教育目的或较小应用是免费的。（如果API将被频繁使用，鼓励商业应用和大型用户注册。通过Patreon的捐赠也是接受的，尽管不是必需的。）
- en: '![Figure 10.3: Sample page showing how the data from various API calls is'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：示例页面，展示如何将来自各种API调用的数据组合起来展示球队信息]'
- en: combined to present team info
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结合起来展示球队信息
- en: '](img/C14377_10_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_10_03.jpg)'
- en: 'Figure 10.3: Sample page showing how the data from various API calls are combined
    to present team info'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：示例页面，展示如何将来自各种API调用的数据组合起来展示球队信息
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The full API is documented at https://packt.live/2NuwMtd.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的API文档位于 https://packt.live/2NuwMtd。
- en: 'Exercise 10.01: Using a REST API to Make Calls'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.01：使用REST API进行调用
- en: To get a good feel for this REST API and how it works before learning how to
    invoke it programmatically, we are going to make some calls right in our web browser.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何以编程方式调用它之前，为了更好地了解这个REST API及其工作原理，我们将在我们的网页浏览器中直接进行一些调用。
- en: Calls to TheSportsDB API have `https://www.thesportsdb.com/api/v1/json/{APIKEY}/resource_path`
    as the base form. Since we are using the free test API key, substitute `{APIKEY}`
    with the value of `1`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: TheSportsDB API的调用形式为 `https://www.thesportsdb.com/api/v1/json/{APIKEY}/resource_path`。由于我们使用的是免费测试API密钥，将
    `{APIKEY}` 替换为 `1` 的值。
- en: 'The following is a summary of the API calls we will be using in the exercises.
    A string of `XXXX`''s indicate where an appropriate identifier or value should
    be substituted:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在练习中使用的API调用的摘要。一串 `XXXX` 表示应替换为适当的标识符或值的适当位置：
- en: '`https://www.thesportsdb.com/api/v1/json/1/all_leagues.php`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/all_leagues.php`'
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_teams.php?id=XXXX`, where
    `XXXX` is a value of `idLeague` from the list of leagues'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_teams.php?id=XXXX`，其中
    `XXXX` 是来自联赛列表的 `idLeague` 的值'
- en: '`https://www.thesportsdb.com/api/v1/json/1/eventslast.php?id=XXXX`, where `XXXX`
    is a value of `idTeam` from the list of teams'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/eventslast.php?id=XXXX`，其中 `XXXX`
    是来自球队列表的 `idTeam` 的值'
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookupteam.php?id=XXXX`, where,
    again, `XXXX` is a value of `idTeam` from the list of teams'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/lookupteam.php?id=XXXX`，其中，再次，`XXXX`
    是来自球队列表的 `idTeam` 的值'
- en: 'The following are other useful methods the API provides (but will not be specifically
    covered here):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些API提供的其他有用方法（但在此处不会具体介绍）：
- en: '`https://www.thesportsdb.com/api/v1/json/1/searchteams.php?t=XXXX`, where `XXXX`
    is a search string'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/searchteams.php?t=XXXX`，其中 `XXXX`
    是搜索字符串'
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_players.php?id=XXXX`,
    where `XXXX` is a value of `idTeam` from the list of teams'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_players.php?id=XXXX`，其中
    `XXXX` 是来自球队列表的 `idTeam` 的值'
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookupplayer.php?id=XXXX`, where
    `XXXX` is a value of `idPlayer` from the list of players'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/lookupplayer.php?id=XXXX`，其中 `XXXX`
    是来自球员列表的 `idPlayer` 的值'
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookuphonors.php?id= XXXX`, where
    `XXXX` is a value of `idPlayer` from the list of players'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/lookuphonors.php?id= XXXX`，其中 `XXXX`
    是来自球员列表的 `idPlayer` 的值'
- en: '`https://www.thesportsdb.com/api/v1/json/1/eventsnext.php?id= XXXX`, where
    `XXXX` is a value of `idTeam` from the list of teams'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/eventsnext.php?id= XXXX`，其中 `XXXX`
    是来自球队列表的 `idTeam` 的值'
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookupevent.php?id=XXXX`, where
    `XXXX` is an `idEvent` from the list of events'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/lookupevent.php?id=XXXX`，其中 `XXXX`
    是来自活动列表的 `idEvent` 的值'
- en: '`https://www.thesportsdb.com/api/v1/json/1/eventsnextleague.php?id=XXXX`, where
    `XXXX` is a value of `idLeague` from the list of leagues'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/eventsnextleague.php?id=XXXX`，其中`XXXX`是从联赛列表中获取的`idLeague`的值'
- en: '`https://www.thesportsdb.com/api/v1/json/1/eventsday.php?d=2019-10-10`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/eventsday.php?d=2019-10-10`'
- en: In order to obtain useful data regarding our favorite sports team, it is necessary
    to first look up the ID for that team. The easiest way to do this is by obtaining
    a list of all available leagues, finding the ID we are interested in, then doing
    another call with this ID.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取有关我们最喜欢的运动队的有用数据，首先需要查找该队的ID。最简单的方法是获取所有可用联赛的列表，找到我们感兴趣的ID，然后使用此ID进行另一个调用。
- en: '`TheSportsDB` provides the following service call to obtain our list of all
    available leagues. The following instructions are for Google Chrome, but any major
    browser supports similar functionality:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`TheSportsDB`提供了以下服务调用以获取所有可用联赛的列表。以下说明适用于Google Chrome，但任何主要浏览器都支持类似的功能：'
- en: Launch a new instance of the browser.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动浏览器的新实例。
- en: Press the *F12* key to launch the debugger (or select `More Tools` | `Developer
    Tools` from the menu).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*F12*键以启动调试器（或从菜单中选择`更多工具` | `开发者工具`）。
- en: 'Select the `Network` tab and make sure the circle icon is red (to indicate
    that network traffic is being logged). Your screen should now look similar to
    this:![Figure 10.4: Network tab in the debugger of Chrome Developer Tools'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`网络`选项卡，并确保圆圈图标为红色（表示正在记录网络流量）。此时你的屏幕应该看起来类似于以下这样：![图10.4：Chrome开发者工具中的网络选项卡
- en: '](img/C14377_10_04.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_10_04.jpg)'
- en: 'Figure 10.4: Network tab in the debugger of Chrome Developer Tools'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.4：Chrome开发者工具中的网络选项卡
- en: 'Type `https://www.thesportsdb.com/api/v1/json/1/all_leagues.php` as the URL
    into the address bar and press *Enter*. Your screen should now look similar to
    this:![Figure 10.5: Raw JSON response with league data'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`https://www.thesportsdb.com/api/v1/json/1/all_leagues.php`作为URL输入地址栏并按*Enter*。此时你的屏幕应该看起来类似于以下这样：![图10.5：包含联赛数据的原始JSON响应
- en: '](img/C14377_10_05.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_10_05.jpg)'
- en: 'Figure 10.5: Raw JSON response with league data'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.5：包含联赛数据的原始JSON响应
- en: Notice the JSON response in the main window lists all the league data, but it
    is unformatted and not very user-friendly. Luckily, the debugger provides a nicer
    way of viewing the data in a collapsible tree. In the `Network` tab, select the
    line with `all_leagues.php` and select the `Preview` tab.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意主窗口中的JSON响应列出了所有联赛数据，但它未格式化且不太友好。幸运的是，调试器提供了一个更友好的方式来以可折叠树的形式查看数据。在`网络`选项卡中，选择带有`all_leagues.php`的行，并选择`预览`选项卡。
- en: You should see the first line of JSON data in your `Preview` window. Place your
    mouse over this line and right-click the mouse button to open the context menu.
    From the context menu, select `Expand recursively`. You will now see a lot more
    data, like the screenshot that follows. Note that you may need to select `Expand
    recursively` two or three times to get the data to fully expand.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在`预览`窗口中看到第一行JSON数据。将鼠标悬停在此行上，然后右键单击鼠标按钮以打开上下文菜单。从上下文菜单中选择`递归展开`。现在你会看到更多数据，如以下截图所示。请注意，你可能需要选择`递归展开`两次或三次才能使数据完全展开。
- en: 'Let''s find the data for the league we are interested in. Press *Ctrl* + *F*
    and type `NBA` to find the entry for the National Basketball Association. Your
    screen should now look similar to this:![Figure 10.6: Expanded and formatted JSON'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们找到我们感兴趣的联赛的数据。按*Ctrl* + *F*并输入`NBA`以找到国家篮球协会的条目。此时你的屏幕应该看起来类似于以下这样：![图10.6：展开并格式化的JSON
- en: '](img/C14377_10_06.jpg)'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_10_06.jpg)'
- en: 'Figure 10.6: Expanded and formatted JSON'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.6：展开并格式化的JSON
- en: 'Focusing on the entry for our league, the full JSON for the entry looks like
    this (formatted for clarity):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专注于我们联赛的条目，该条目的完整JSON格式如下（为了清晰起见进行了格式化）：
- en: '[PRE4]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This entry only has a few key-value pairs, but with the `idLeague` key, we now
    know that the league ID of `4387` represents the NBA in this API. This ID can
    now be used for another service call to obtain further details regarding the NBA.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此条目只有几个键值对，但有了`idLeague`键，我们现在知道API中的联赛ID `4387`代表NBA。现在可以使用此ID进行另一个服务调用，以获取有关NBA的更多详细信息。
- en: 'Following a similar process to the one previously described, enter the following
    as the URL:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前描述的类似过程，将以下内容作为URL输入：
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_teams.php?id=4387`'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_teams.php?id=4387`'
- en: Notice the `id` parameter placed at the end of the URL, for which we plugged
    in the ID of `4387` that we found in the previous steps.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意URL末尾放置的`id`参数，我们在这里插入了之前步骤中找到的`4387` ID。
- en: Once you have expanded the result set, search for the word `Knicks`. This time,
    you will need to search through several of the matches until you find the correct
    one, as the word `Knicks` appears in several irrelevant entries as part of long
    descriptions. Also, there will be many more key-value pairs available in the resulting
    entry compared to last time, but we will only focus on some of them.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你扩展了结果集，搜索单词`Knicks`。这次，你需要搜索多个匹配项，直到找到正确的一个，因为单词`Knicks`作为长描述的一部分出现在多个无关条目中。此外，与上次相比，结果条目中将有更多的键值对，但我们将只关注其中的一些。
- en: 'The relevant JSON looks something like this, with many of the fields removed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的JSON看起来像这样，其中许多字段已被删除：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we see the team ID and name in the `idTeam` and `strTeam` keys, followed
    by other fields related to team history, stadium info, and website and social
    media URLs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`idTeam`和`strTeam`键中的团队ID和名称，后面跟着与团队历史、球场信息和网站及社交媒体URL相关的其他字段。
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, there are links to various available images for the team badge, jersey,
    logo, and banner, which we can use to display on our site if we wish. We will
    be making use of these values in the upcoming exercises.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一些链接到各种可用的团队徽章、球衣、标志和横幅图片，我们可以根据需要将这些图片显示在我们的网站上。我们将在接下来的练习中使用这些值。
- en: HTTP Headers
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP头部
- en: 'While we have the network monitor open, it would be a good time to take note
    of some other useful information. Click on the `Headers` tab, and you will see
    all the HTTP request headers, response headers, and some other details that were
    involved in the interaction, similar to this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开网络监视器时，这是一个记录一些其他有用信息的好时机。点击`头部`标签，你会看到所有HTTP请求头部、响应头部以及一些涉及交互的其他细节，类似于以下内容：
- en: '![Figure 10.7: HTTP Headers'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7：HTTP头部'
- en: '](img/C14377_10_07.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_10_07.jpg)'
- en: 'Figure 10.7: HTTP Headers'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：HTTP头部
- en: 'The following are of particular note:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容特别值得关注：
- en: '`Request Method: GET`: URLs entered into the address line of a browser are
    `GET` by default.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`请求方法：GET`：输入到浏览器地址栏的URL默认为`GET`。'
- en: '`Status Code: 200`: This indicates the interaction was successful. There are
    several status codes, and the following are some of the most common ones. The
    later status codes, with a number of `400` or greater, indicate various error
    conditions that occurred:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态码：200`：这表示交互成功。有几个状态码，以下是一些最常见的。后续状态码，编号为`400`或更大，表示发生了各种错误条件：'
- en: '![Figure 10.8: Status code and their meanings'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8：状态码及其含义](img/C14377_10_07.jpg)'
- en: '](img/C14377_10_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_10_08.jpg)'
- en: 'Figure 10.8: Status code and their meanings'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：状态码及其含义
- en: '`content-type: application/json; charset=utf-8`: This indicates to the caller
    that the response is in JSON format in UTF-8 encoding.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content-type: application/json; charset=utf-8`：这表示响应以UTF-8编码的JSON格式。'
- en: '`Remote Address: 104.18.46.13:443`: This indicates the IP address and port
    of the remote server that processed the request.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`远程地址：104.18.46.13:443`：这表示处理请求的远程服务器的IP地址和端口号。'
- en: '`access-control-allow-origin: *`: This is a header that enables cross-site
    requests. More on this in a later section.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access-control-allow-origin: *`：这是一个允许跨站请求的头部。关于这一点，将在后面的章节中详细介绍。'
- en: '`accept: text/html,application/xhtml+xml,application/xml;…`: This header advises
    the server what formats the caller would accept for the response. This requires
    a bit of explanation in our case. TheSportsDB is designed to be a JSON-only API,
    so even though JSON is not indicated in the list of accepted formats the browser
    sent, the response is still in JSON. (This is not the case for other APIs that
    may support multiple formats such as HTML, XML, or JSON. So, this header would
    be used for the caller to indicate which format they desire.)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accept: text/html,application/xhtml+xml,application/xml;…`：此头部通知服务器调用者希望接受哪些格式的响应。在我们的情况下，需要一些解释。TheSportsDB被设计为仅支持JSON格式的API，因此即使浏览器发送的接受格式列表中没有指示JSON，响应仍然是JSON格式。（对于可能支持多种格式（如HTML、XML或JSON）的其他API来说，情况并非如此。因此，此头部将用于调用者表明他们希望使用哪种格式。）'
- en: 'There are other available HTTP headers that were not part of this request but
    deserve to be mentioned. To briefly summarize some of the most common headers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的HTTP头部虽然不是本次请求的一部分，但值得提及。简要总结一些最常见的头部：
- en: '`Authorization`: Many resources are protected and require credentials to access
    them, such as with a user/password combination or a token. This header is used
    to send the credentials in various formats.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authorization`：许多资源受到保护，需要凭证才能访问，例如使用用户/密码组合或令牌。此头信息用于以各种格式发送凭证。'
- en: '`Cache-Control`: Static resources or data that is not expected to change in
    the near future can be cached by the browser or client, so the resource is not
    fetched unnecessarily if requested again. This response header indicates whether
    caching is allowed. Some of the most common values are `no-cache` and `max-age=<seconds>`,
    which indicate whether the object can be cached and for how long, respectively.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cache-Control`：静态资源或预计在不久的将来不会改变的数据可以被浏览器或客户端缓存，因此如果再次请求，则不需要不必要地获取资源。此响应头指示是否允许缓存。一些最常见的值是`no-cache`和`max-age=<seconds>`，分别表示对象是否可以缓存以及可以缓存多长时间。'
- en: '`Last-Modified`: This response header indicates when the object was last modified.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Last-Modified`：此响应头指示对象最后修改的时间。'
- en: '`Keep-Alive`: Controls how long a persistent connection should stay open. A
    persistent connection is a special type that is used when multiple requests are
    made with the same connection, making it unnecessary to close and re-establish
    connections.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Keep-Alive`：控制持久连接应保持多长时间开放。持久连接是一种特殊类型，用于在同一个连接上发出多个请求时使用，这使得无需关闭和重新建立连接成为可能。'
- en: '`Cookie`/`Set-Cookie`: A cookie is a small piece of data sent by a website
    to save state or track user authentication, devices, and activity. The next time
    the browser or client makes a request to the server, the previously sent cookie
    value is included.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cookie`/`Set-Cookie`：Cookie是由网站发送的小数据块，用于保存状态或跟踪用户身份验证、设备和活动。当浏览器或客户端下次向服务器发出请求时，之前发送的cookie值将被包含在内。'
- en: In this section, we introduced the basics of HTTP, JSON, and REST web services.
    We learned about the parts of a URL, HTTP status codes, HTTP headers, and how
    to use the browser debugger to invoke REST services and glean the data we need.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了HTTP、JSON和REST Web服务的基础知识。我们学习了URL的组成部分、HTTP状态码、HTTP头信息，以及如何使用浏览器调试器调用REST服务并获取所需的数据。
- en: In the next topic, we will introduce AJAX and how to invoke services with JavaScript
    code using the jQuery library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将介绍AJAX以及如何使用jQuery库通过JavaScript代码调用服务。
- en: AJAX
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX
- en: AJAX stands for Asynchronous JavaScript and XML and is an umbrella term for
    a set of technologies to communicate with servers and other sites in various formats,
    including JSON and XML.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: AJAX代表异步JavaScript和XML，是一个总称，用于描述一系列用于以各种格式（包括JSON和XML）与服务器和其他站点通信的技术。
- en: Most JavaScript is synchronous, which means there is only a single thread of
    execution, and only one operation can be executed at a time. If browsers were
    truly synchronous, websites would be a drag to use, as only one resource would
    be able to load at a time. Imagine if the images on websites only drew one at
    a time after loading! Sometimes, requests can take a long time, such as to do
    a calculation or a complex database query. You wouldn't want your site to become
    non-responsive while a request is processing!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript是同步的，这意味着只有一个执行线程，一次只能执行一个操作。如果浏览器真正是同步的，那么网站将难以使用，因为一次只能加载一个资源。想象一下，如果网站上的图片在加载后只绘制一个！有时，请求可能需要很长时间，例如进行计算或复杂的数据库查询。你肯定不希望你的网站在请求处理时变得无响应！
- en: Luckily, service calls were designed to allow multiple calls to occur asynchronously.
    Also, in between requests being made and a response is received, the main thread
    of execution can continue to execute and potentially issue more service calls.
    This is the *"A"* in *AJAX*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，服务调用被设计为允许异步发生多个调用。此外，在发出请求并收到响应之间，主执行线程可以继续执行，并可能发出更多的服务调用。这是AJAX中的“*A*”。
- en: JavaScript has developed several techniques and approaches to accomplish synchronicity,
    and the most straightforward and widespread is by using callbacks. This chapter
    will use callbacks, but other techniques, such as promises, will be explored in
    *Chapter 15, Asynchronous Tasks*
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经开发出多种技术和方法来实现同步，其中最直接和最广泛使用的是回调函数。本章将使用回调函数，但其他技术，如Promise，将在第15章“异步任务”中探讨。
- en: JavaScript has a means of natively performing service calls via an object called
    `XMLHttpRequest`. Normally, there is a preference to use native functionality
    that is built-in to JavaScript, but in my opinion, `XMLHttpRequest` is too low-level
    and difficult to use most of the time. This is a use case where utilizing a library
    makes more sense and really simplifies your code. (However, we will also cover
    `XMLHttpRequest` later in this chapter.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript通过一个名为 `XMLHttpRequest` 的对象提供了一种原生的执行服务调用的方式。通常，人们倾向于使用JavaScript内置的本地功能，但在我看来，`XMLHttpRequest`
    太底层且难以使用。这是一个利用库会更有意义且真正简化代码的场景。（然而，我们将在本章后面也介绍 `XMLHttpRequest`。）
- en: There are several libraries available that make REST calls, and we'll start
    with exploring jQuery's `ajax()` and `getJSON()` calls.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个库可用于执行REST调用，我们将从探索jQuery的 `ajax()` 和 `getJSON()` 调用开始。
- en: jQuery
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery
- en: 'jQuery is one of the most popular JavaScript libraries out there. It is lightweight
    and greatly simplifies programming JavaScript for many functions related to websites.
    These include:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是目前最受欢迎的JavaScript库之一。它轻量级，极大地简化了与网站相关的许多JavaScript编程任务。这些包括：
- en: HTML/DOM manipulation
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML/DOM操作
- en: CSS styling helpers
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS样式辅助工具
- en: HTML event handling
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML事件处理
- en: AJAX service call helpers and much more
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX服务调用辅助工具以及更多
- en: '![Figure 10.9: Home page of the jQuery project'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9：jQuery项目的首页]'
- en: '](img/C14377_10_09.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_10_09.jpg)'
- en: 'Figure 10.9: Home page of the jQuery project'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：jQuery项目的首页
- en: For HTML/DOM and CSS manipulation, jQuery syntax typically follows a pattern
    of *selecting* HTML elements and calling methods to perform *actions* on the elements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTML/DOM和CSS操作，jQuery语法通常遵循选择HTML元素并调用方法在元素上执行操作的模式。
- en: 'The basic syntax is `$(selector).action()`, where:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基本语法是 `$(selector).action()`，其中：
- en: The `$` sign defines/accesses jQuery.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` 符号定义/访问jQuery。'
- en: '`(selector)` locates HTML elements.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(selector)` 用于定位HTML元素。'
- en: '`action()` denotes the jQuery action to be performed on the elements.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action()` 表示要在元素上执行的jQuery操作。'
- en: 'Selectors start with the dollar sign and parentheses: `$()`. They follow a
    very similar syntax to selecting elements in CSS code. The most basic case for
    using a selector is an element by HTML ID, for which you prefix the ID with a
    pound sign (`#`). For example, if you start with the following HTML:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器以美元符号和括号开始：`$()`。它们的语法与在CSS代码中选择元素非常相似。使用选择器的最基本案例是通过HTML ID选择元素，其中ID前缀为井号（`#`）。例如，如果你从以下HTML开始：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `$("#test_div"").hide()` code would cause the `<div>` with an ID of `test_div`
    to be hidden from view. Multiple actions can also be performed in a chained fashion
    on the same elements. For example, `$("#test_div"").html(""Hello World"").show()`
    would assign the text `Hello World` as the body of the `<div>` and cause it to
    reappear.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`$("#test_div"").hide()` 这段代码会使ID为 `test_div` 的 `<div>` 元素从视图中隐藏。也可以在同一个元素上以链式方式执行多个操作。例如，`$("#test_div"").html(""Hello
    World"").show()` 会将文本 `Hello World` 赋予 `<div>` 的主体，并使其重新出现。'
- en: 'The following are common methods provided by jQuery for UI purposes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由jQuery提供的常见UI方法：
- en: '![Figure 10.10: Common jQuery Methods for UI purpose'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10：用于UI目的的常见jQuery方法]'
- en: '](img/C14377_10_10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_10_10.jpg)'
- en: 'Figure 10.10: Common jQuery Methods for UI purpose'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：用于UI目的的常见jQuery方法
- en: 'jQuery can also be used to define functions to handle events on HTML elements;
    for example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery还可以用来定义处理HTML元素事件的函数；例如：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code would cause an alert with the message `Button Clicked` to
    appear if the button was clicked. Also note that a class selector was used in
    this case, not one to select by ID as was used previously. Class selectors start
    with a period (`.`) and result in selecting all elements in the document that
    have that class in its list of classes (in this case, only one element).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会在按钮被点击时显示一个包含消息 `Button Clicked` 的警告。此外，请注意，在这个例子中使用了类选择器，而不是之前使用的ID选择器。类选择器以点（`.`）开头，并选择文档中具有该类名的所有元素（在这个例子中，只有一个元素）。
- en: It is also possible to select multiple elements by type, attributes, values,
    and much more.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过类型、属性、值等多种方式选择多个元素。
- en: 'The following are common methods provided by jQuery for event handlers:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由jQuery提供的常见事件处理方法：
- en: '![Figure 10.11: Common jQuery methods for event handlers'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11：用于事件处理的常见jQuery方法]'
- en: '](img/C14377_10_11.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_10_11.jpg)'
- en: 'Figure 10.11: Common jQuery methods for event handlers'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：用于事件处理的常见jQuery方法
- en: Finally, jQuery offers a complete suite of helpers to perform AJAX service calls.
    These will be introduced in the next exercise.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，jQuery 提供了一套完整的辅助工具来执行 AJAX 服务调用。这些将在下一个练习中介绍。
- en: The previous paragraphs were only a brief introduction to jQuery, but there
    are many good tutorials and resources available to learn about it in more depth.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的段落只是对 jQuery 的简要介绍，但有许多优秀的教程和资源可以帮助你更深入地了解它。
- en: 'Exercise 10.02: Using AJAX and the jQuery ajax() Method to Invoke a Service'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.02：使用 AJAX 和 jQuery 的 ajax() 方法调用服务
- en: Now that we understand the mechanics of HTTP and REST, we are ready to write
    some code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 HTTP 和 REST 的机制，我们可以开始编写一些代码了。
- en: jQuery has very nice methods available that greatly simplify AJAX interactions.
    In this exercise, we will first use the `$.ajax()` method to make a TheSportsDB
    service call to find out how our favorite team scored in its last game. We will
    use the team ID obtained in the previous section as a parameter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 提供了非常方便的方法，可以极大地简化 AJAX 交互。在这个练习中，我们将首先使用 `$.ajax()` 方法调用 TheSportsDB
    服务以找出我们最喜欢的球队在上一场比赛中的得分。我们将使用上一节中获得的团队 ID 作为参数。
- en: First, we enter the HTML code. Open a text editor or IDE and create a new file
    (`exercise2.html`).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们输入 HTML 代码。打开文本编辑器或 IDE 并创建一个新文件（`exercise2.html`）。
- en: Add the `<html>` tag and the `<head>` element, which simply includes the JavaScript
    files for the jQuery library and our JavaScript source file, which will be shown
    shortly using the file `exercise2.html:`
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `<html>` 标签和 `<head>` 元素，这些元素简单地包含了 jQuery 库的 JavaScript 文件以及我们即将展示的 JavaScript
    源文件，该文件将使用 `exercise2.html` 文件展示：
- en: '[PRE9]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, add the `<body>` tag. The `<table>` contains the HTML tags to display
    the last game data:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `<body>` 标签。`<table>` 包含用于显示最后一场比赛数据的 HTML 标签：
- en: '[PRE10]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use a table to aid the layout. The table is initially specified with a style
    of `display: none` since the data is incomplete when the page is loaded, and we
    don''t want it to be shown yet. We will make it visible only once the service
    call returns and provides us with the data.'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们使用表格来辅助布局。表格最初指定为 `display: none` 样式，因为页面加载时数据不完整，我们不想立即显示它。我们将在服务调用返回并提供数据后使其可见。'
- en: 'Fill in the table rows and columns until the end of the HTML:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充表格的行和列，直到 HTML 的结尾：
- en: '[PRE11]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Most of the table columns are given IDs such as `away_team` and `away_score`
    so they can be referenced later to fill in the data once available. This also
    allows us to treat each value separately and define different styling for each
    if we desire.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表的大部分列都赋予了 ID，例如 `away_team` 和 `away_score`，这样就可以在数据可用时引用它们来填充数据。这也允许我们分别处理每个值，并在需要时为每个值定义不同的样式。
- en: Finally, we get to the actual JavaScript code. Save the first file as `exercise2.html`
    and create a new file in the text editor or IDE.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们到达实际的 JavaScript 代码。将第一个文件保存为 `exercise2.html` 并在文本编辑器或 IDE 中创建一个新文件。
- en: 'Enter the first line of the file `exercise2.js`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `exercise2.js` 文件的第一行：
- en: '[PRE12]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All jQuery functions begin with the dollar sign, `$`, as a shortcut, followed
    by a dot and the function name. The `$(document).ready()` function is called once
    the page is fully loaded. It's important to use this function here, since this
    JavaScript file was included in the document via a `<script>` tag in the `<head>`
    section of the HTML before the `<body>` tag. This code could potentially be loaded
    and executed before the full body of the HTML is parsed and processed. If we did
    not enclose our logic in a `$(document).ready()` function, there is potential
    for errors if an HTML element is referenced that hasn't been loaded yet.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有 jQuery 函数都以美元符号 `$` 开头，作为快捷方式，后面跟着一个点和函数名。`$(document).ready()` 函数在页面完全加载后调用。在这里使用这个函数很重要，因为此
    JavaScript 文件是通过 HTML `<head>` 部分中的 `<script>` 标签在 `<body>` 标签之前包含到文档中的。如果我们的逻辑没有包含在
    `$(document).ready()` 函数中，如果引用了尚未加载的 HTML 元素，则可能会出现错误。
- en: 'Start the `$.ajax()` call as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式开始 `$.ajax()` 调用：
- en: '[PRE13]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `$.ajax()` call includes a listing of various settings. The `method` setting
    indicates that the type of call we desire is `GET`. (In truth, it is not really
    necessary to specify the `method` setting as `GET` is the default value if it
    is not present. But sometimes it is more beneficial to be more explicit.)
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$.ajax()` 调用包含了一系列设置。`method` 设置指示我们想要的调用类型是 `GET`。实际上，如果不指定 `method` 设置，`GET`
    是默认值，因此通常没有必要指定。但有时更明确地指定可能更有益。'
- en: 'We next enter the `dataType` setting:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们输入 `dataType` 设置：
- en: '[PRE14]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This specifies that we expect the call response to be in JSON format, and to
    return the JSON parsed to a JavaScript object. This also causes a request header
    similar to `Accept: application/json` to be sent.'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这指定了我们期望调用响应以JSON格式返回，并将JSON解析为JavaScript对象。这也导致发送了一个类似于`Accept: application/json`的请求头。'
- en: 'Type the `url` setting next, which indicates the URL for our call:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来输入`url`设置，它指示我们调用的URL：
- en: '[PRE15]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next is the `data` setting:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`data`设置：
- en: '[PRE16]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `data` setting indicates the parameters that should be sent in the request.
    Since this is a `GET`, under the hood, jQuery will add the parameter key-value
    pairs to the URL query string, resulting in `?id=134862` in this case. We could
    have added this value to the URL ourselves if we wanted but specifying parameters
    in the `data` setting allows the parameters to be separate from the URL itself.
    Another reason is so that the library will handle any URL encoding needed for
    more complex values.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`data`设置指示请求中应发送的参数。由于这是一个`GET`请求，在底层，jQuery将参数键值对添加到URL查询字符串中，在本例中导致`?id=134862`。如果我们想自己添加这个值到URL中，我们可以这样做，但在`data`设置中指定参数允许参数与URL本身分开。另一个原因是让库处理任何复杂值所需的URL编码。'
- en: 'Next, begin the `success` function, which is a callback function called by
    jQuery once the service call returns with a response. By this point, jQuery will
    have processed the response and parsed the JSON into a JavaScript object:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，开始`success`函数，这是一个由jQuery在服务调用返回响应时调用的回调函数。到这时，jQuery将已处理响应并将JSON解析为JavaScript对象：
- en: '[PRE17]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This `eventslast.php` service call returns the last five events for the team,
    ordered by latest date first, in the `data.results[]` array. However, for our
    purposes, we only require the latest game. There is a quirk in the API we need
    to account for: if the game is currently in progress, the event will be present
    in the array, but the score may not have a value yet. For our page, we''d prefer
    to only show games that actually have a score. Enter the following code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`eventslast.php`服务调用返回该队的最后五个事件，按最新日期排序，位于`data.results[]`数组中。然而，就我们的目的而言，我们只需要最新的比赛。API中有一个我们需要注意的怪癖：如果比赛正在进行中，事件将存在于数组中，但得分可能还没有值。对于我们的页面，我们更愿意只显示实际有得分的比赛。输入以下代码：
- en: '[PRE18]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We use the `data.results.find()` function to iterate through the array and
    locate the first element with a score. Specifically, we look for the first event
    for which the `intAwayScore` and `intHomeScore` values are non-null. We will next
    set various table cell data with the following code:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`data.results.find()`函数遍历数组并定位具有得分的第一个元素。具体来说，我们寻找`intAwayScore`和`intHomeScore`值非空的第一个事件。接下来，我们将使用以下代码设置各种表格单元格数据：
- en: '[PRE19]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These lines set the table cell corresponding to the ID to the specified value.
    HTML elements can be selected by ID in jQuery by placing a pound (`#`) character
    before the ID. So, for example, `$("#game_date")` would result in `<td>` with
    the `game_date` ID being selected, and method calls that come afterward will apply
    to that element. Finally, the `html()` call would result in the value being assigned
    to that table cell.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些行将对应于ID的表格单元格设置为指定的值。在jQuery中，可以通过在ID前放置一个井号（`#`）字符来通过ID选择HTML元素。例如，`$("#game_date")`将选择具有`game_date`
    ID的`<td>`元素，随后调用的方法将应用于该元素。最后，`html()`调用将导致值被分配给该表格单元格。
- en: 'Once all the data is assigned in the table, we are finally ready to show the
    table to the user. Enter the following final code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有数据都分配到表格中，我们最终准备好向用户显示表格。输入以下最终代码：
- en: '[PRE20]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'jQuery has a `show()` function, which results in the `display: none` style
    being made visible. So, `$("#game_table").show()` would select the table represented
    by the `game_table` ID and cause it to show.'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'jQuery有一个`show()`函数，它将`display: none`样式变为可见。因此，`$("#game_table").show()`将选择由`game_table`
    ID表示的表格并使其显示。'
- en: Save the file as `exercise2.js`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为`exercise2.js`。
- en: 'Load the `exercise2.html` file into a browser. The output should look something
    like the following screenshot:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`exercise2.html`文件加载到浏览器中。输出应类似于以下截图：
- en: '![Figure 10.12: Result of exercise 10.02'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12：练习10.02的结果'
- en: '](img/C14377_10_12.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_10_12.jpg)'
- en: 'Figure 10.12: Result of exercise 10.02'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：练习10.02的结果
- en: Note there is no styling yet (but that will be added in the next exercise).
    We can see the results of the favourite team scored using the `$.ajax()` method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意目前还没有样式（但将在下一个练习中添加）。我们可以看到使用`$.ajax()`方法得分的最喜欢的球队的结果。
- en: In this section, we introduced AJAX and the jQuery `ajax()` method to invoke
    a service. We also introduced the basic jQuery functions to add dynamic content
    to HTML elements and show/hide them as needed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了AJAX和jQuery的`ajax()`方法来调用服务。我们还介绍了基本的jQuery函数，用于向HTML元素添加动态内容，并在需要时显示/隐藏它们。
- en: In the next topic, we will go further and use the results of one service as
    an input to another service call. We will also invoke multiple services asynchronously.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将进一步使用一个服务的输出作为另一个服务调用的输入。我们还将异步调用多个服务。
- en: 'Exercise 10.03: More AJAX and Some CSS Styling'
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.03：更多AJAX和CSS样式
- en: 'The previous exercise was a good starting point, but now we''d like to build
    on it to do the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的练习是一个很好的起点，但现在我们想在此基础上做以下事情：
- en: Use the results obtained from the first service call to show additional items
    related to the game and teams, such as team logos.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第一个服务调用获得的结果来显示与比赛和球队相关的附加项目，例如球队标志。
- en: Make the site more visually appealing by adding CSS styling.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加CSS样式使网站更具视觉吸引力。
- en: 'We''ll enhance the code in these steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下步骤中增强代码：
- en: Open a text editor or IDE and create a new file.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文本编辑器或IDE并创建一个新的文件。
- en: 'First, add the `<html>` tag and the `<head>` element. It is almost the same
    code as in *Exercise 10.02: Using AJAX and the jQuery ajax() Method to Invoke
    a Service*, but with the addition of a stylesheet using the file `exercise3.html`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加`<html>`标签和`<head>`元素。这几乎与*练习10.02：使用AJAX和jQuery的ajax()方法调用服务*中的代码相同，但增加了使用文件`exercise3.html`的样式表：
- en: '[PRE21]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, add `<body>`. In `<table>`, the first `<tr>` row is the same as *Exercise
    10.02: Using AJAX and the jQuery ajax() Method to Invoke a Service*:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`<body>`。在`<table>`中，第一个`<tr>`行与*练习10.02：使用AJAX和jQuery的ajax()方法调用服务*相同：
- en: '[PRE22]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the next table row. This is new code and has two `<img>` elements that
    contain the team''s banner images. Also, notice that these images have also been
    marked with `class="team_banner"`, as we will define CSS styles for them later:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加下一个表格行。这是新代码，包含两个包含球队横幅图片的`<img>`元素。注意，这些图片也已标记为`class="team_banner"`，因为我们将在稍后定义它们的CSS样式：
- en: '[PRE23]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last row and the remainder of the HTML is the same as the last exercise
    as well, as are the slots where the home and away scores will be displayed:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的行和剩余的HTML代码与上一个练习相同，同样也包括显示主队和客队得分的槽位：
- en: '[PRE24]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Save the file and create a new one for the JavaScript code. Copy the initial
    code from the previous exercise:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并为JavaScript代码创建一个新的文件。复制上一个练习中的初始代码：
- en: '[PRE25]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A cool feature would be to apply special styling to the winning score, or to
    both scores in the event of a tie. We do this by assigning a dynamic style to
    the appropriate score element with the following code. Firstly, add the Boolean
    expressions to determine whether the home team had the winning score or there
    was a tie:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个酷炫的功能是对获胜得分应用特殊样式，或者在平局的情况下对两个得分都应用样式。我们通过以下代码将动态样式分配给适当的得分元素。首先，添加布尔表达式以确定主队是否有获胜得分或是否有平局：
- en: '[PRE26]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the home score is greater than the away score, then `homewinner` will equal
    `true`. Notice you need to call `parseInt()` to convert the data values to integers
    before performing the comparison, as the service returns the scores as string
    types.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果主队得分高于客队得分，则`homewinner`将等于`true`。注意，在执行比较之前，你需要调用`parseInt()`将数据值转换为整数，因为服务以字符串类型返回得分。
- en: '[PRE27]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice the expression with the conditional ternary operator. This shortcut
    has the same effect as the following code:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意使用条件三元运算符的表达式。这个快捷方式与以下代码具有相同的效果：
- en: '[PRE28]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'This can actually be improved a bit further if we wish. jQuery has a function
    called `toggleClass()` for this specific use case where a class should be added
    conditionally. This code can be rewritten as follows:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们愿意，这实际上可以进一步改进。jQuery有一个名为`toggleClass()`的函数，用于此特定用例，其中应条件性地添加一个类。此代码可以重写如下：
- en: '`$("#home_score").html(homeScore)`'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$("#home_score").html(homeScore)`'
- en: '`.toggleClass("winning_score", homeWinner || tie);`'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.toggleClass("winning_score", homeWinner || tie);`'
- en: The `toggleClass()` method takes two parameters. The first parameter is the
    name of the class that will be conditionally added (or removed). The second parameter
    is the Boolean value or expression itself.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`toggleClass()`方法接受两个参数。第一个参数是要条件添加（或删除）的类的名称。第二个参数是布尔值或表达式本身。'
- en: 'Next, we add the code to get the team''s banner images:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加获取球队横幅图片的代码：
- en: '[PRE29]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `lastGame.idHomeTeam` and `lastGame.idAwayTeam` fields contain the IDs of
    the home and away teams of the most recent game. Using these IDs, we are going
    to call the `getTeamImage()` function, which will load the banner image for each
    of the teams, passing in the HTML IDs of the images as well. (This function will
    be defined soon.)
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`lastGame.idHomeTeam` 和 `lastGame.idAwayTeam` 字段包含最近一场比赛的本地和客场球队的 ID。使用这些 ID，我们将调用
    `getTeamImage()` 函数，该函数将为每个球队加载横幅图像，同时也会传入图像的 HTML ID。（此函数将很快定义。）'
- en: 'Type in the remainder of the function, which is the same as in the last exercise,
    to actually show the table:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入函数的其余部分，与上一个练习中的相同，以实际显示表格：
- en: '[PRE30]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we come to the `getTeamImage()` function:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们来到了 `getTeamImage()` 函数：
- en: '[PRE31]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the exercise is complete, the final result should look something like
    the following screenshot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦练习完成，最终结果应该类似于以下截图：
- en: '![Figure 10.13: Final result of exercise'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.13：练习的最终结果'
- en: '](img/C14377_10_13.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片链接](img/C14377_10_13.jpg)'
- en: 'Figure 10.13: Final result of exercise'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13：练习的最终结果
- en: 'There are a number of items to notice here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的点：
- en: 'We used `$.getJSON()` instead of `$.ajax()` this time. The `$.getJSON()` function
    is a shortcut that can be used for requests that are `JSON GET`. Using this shortcut,
    `dataType="json"` is assumed by default. There is no need to specify the URL,
    data parameters, and `success` function as separate settings, as the signature
    of the function is the following, with the brackets indicating that the last two
    parameters are optional: `$.getJSON( url [, data ] [, success ] )`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们这次使用了 `$.getJSON()` 而不是 `$.ajax()`。`$.getJSON()` 函数是一个用于 `JSON GET` 请求的快捷方式，默认情况下假定
    `dataType="json"`。不需要单独指定 URL、数据参数和 `success` 函数作为设置，因为函数的签名如下，方括号表示最后两个参数是可选的：`$.getJSON(
    url [, data ] [, success ] )`。
- en: '`imageId` is passed in to represent the ID of the HTML image element that will
    be set. We will use jQuery to select this image element and call `attr("src",
    value)`, which is jQuery''s utility method to set the `src` field of the `<img>`
    HTML element (similar to `<img src="img/…."/>`). We will set this `src` with the
    value returned by the service call in the `teamData.strTeamBanner` element. Setting
    the `src` field will trigger the browser to load the corresponding image dynamically.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imageId` 被传递进来，以表示将要设置的 HTML 图像元素的 ID。我们将使用 jQuery 选择此图像元素并调用 `attr("src",
    value)`，这是 jQuery 的实用方法，用于设置 `<img>` HTML 元素的 `src` 字段（类似于 `<img src="img/…."/>`）。我们将使用服务调用返回的
    `teamData.strTeamBanner` 元素中的值来设置此 `src`。设置 `src` 字段将触发浏览器动态加载相应的图像。'
- en: '`$.getJSON()` is an asynchronous call, which means that after the request is
    made, the browser will not wait for the response and execution will continue even
    while the service call is in progress (and execute the `success` callback when
    the response is received). The implication of this is that the calls to `getTeamImage()`
    will effectively issue two simultaneous service calls and not lock the browser
    while the requests are in flight.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$.getJSON()` 是一个异步调用，这意味着在请求发出后，浏览器不会等待响应，即使在服务调用进行中，执行也会继续（并在收到响应时执行 `success`
    回调）。这意味着对 `getTeamImage()` 的调用将实际上发出两个同时的服务调用，并且在请求进行时不会锁定浏览器。'
- en: CSS
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS
- en: We will now briefly cover the CSS and styling that was added to the page in
    the preceding exercise to make it visually appealing. As this is not really a
    book on CSS, we will only give a brief overview. (There are many excellent books
    and resources available that cover CSS in depth.)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将简要介绍在前一个练习中添加到页面中的 CSS 和样式，以使其更具视觉吸引力。由于这并不是一本关于 CSS 的书，我们只会提供一个简要概述。（有许多优秀的书籍和资源可以深入介绍
    CSS。）
- en: 'The stylesheet is included in the head element with the following tag:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表通过以下标签包含在 head 元素中：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The contents of the CSS file follow here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 文件的內容如下：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `#game_table` selector indicates that all styles in this block will apply
    to the HTML element with an ID of `game_table`.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#game_table` 选择器表示此块中的所有样式都将应用于具有 `game_table` ID 的 HTML 元素。'
- en: Places a border around the table to make it appear more contained.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表格周围放置边框，使其看起来更紧凑。
- en: We move the `display:none` style (to prevent display until the data is loaded)
    into the stylesheet itself, to keep the HTML code less cluttered of styling code.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `display:none` 样式（用于防止在数据加载前显示）移动到样式表中本身，以使 HTML 代码更简洁，避免过多的样式代码。
- en: The `#game_table td` selector indicates that the styles in the block will apply
    to all `<td>` elements that appear within the table with an ID of `game_table`.
    Here, we are saying that all text in table rows should be aligned to the right.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#game_table td` 选择器表示该块中的样式将应用于具有 ID 为 `game_table` 的表格中出现的所有 `<td>` 元素。在这里，我们表示表格中的所有文本都应该右对齐。'
- en: A comma in the selector allows you to select multiple elements. Here, we are
    indicating that scores should have a larger, 24-pixel font.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器中的逗号允许您选择多个元素。在这里，我们表示分数应该有更大的、24 像素的字体。
- en: Selectors that begin with a dot (such as `.team_banner` here) are a different
    type of selector. This is a `class` selector, which would apply to all HTML elements
    that have `class="team_banner"` specified.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以点开头的选择器（如这里的 `.team_banner`）是另一种选择器。这是一个 `class` 选择器，它将应用于所有指定 `class="team_banner"`
    的 HTML 元素。
- en: The banner images from the server are quite large, but we only want a scaled-down
    image of 275 x 50 pixels.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器上的横幅图像相当大，但我们只想得到一个缩小到 275 x 50 像素的图像。
- en: A distinctive style that indicates the winning score in green and bold.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种独特的样式，用绿色和粗体表示获胜的分数。
- en: In the last section, we explored different types of responses from services
    (JSON and images) and how to use jQuery to display them using the helpers for
    dynamic DOM manipulation. We also saw how to use CSS to add colors, fonts, and
    other styles to make our screen more visually appealing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们探讨了服务（JSON 和图像）的不同类型响应以及如何使用 jQuery 通过动态 DOM 操作助手来显示它们。我们还看到了如何使用 CSS
    添加颜色、字体和其他样式，使我们的屏幕更具视觉吸引力。
- en: Other Libraries and XMLHttpRequest
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他库和 XMLHttpRequest
- en: This section explores other approaches to AJAX with JavaScript. The approach
    to making REST calls using jQuery and callbacks is just one of many different
    options available and was presented first as it's the most straightforward and
    easy-to-understand option for novice users. This is not to say the approach is
    not powerful though. And it is really all that is needed in many cases. Remember
    that jQuery offers other functionality you may want to use in your application
    as well.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了其他使用 JavaScript 的 AJAX 方法。使用 jQuery 和回调进行 REST 调用的方法只是许多不同选项之一，并且最初作为对新手用户最直接、最容易理解的选择而提出。但这并不意味着这种方法不强大。实际上，在许多情况下，这已经足够了。记住，jQuery
    还提供了您可能在应用程序中想要使用的其他功能。
- en: Axios and the Fetch API
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Axios 和 Fetch API
- en: At this point in the book, we'd like to mention two other popular choices that
    may be appropriate to be used in your projects, Axios and the Fetch API. These
    use advanced concepts such as promises, so they will not be covered here but will
    be covered in *Chapter 15, Asynchronous Tasks* of the advanced module. (Note that
    even jQuery itself offers variations on the AJAX methods that return promises
    instead of using callbacks, but this usage is not in the scope of this chapter
    either.)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们想提到两个可能适合在您的项目中使用的其他流行选择，Axios 和 Fetch API。它们使用诸如承诺等高级概念，因此这里不会涉及，但将在高级模块的
    *第 15 章，异步任务* 中介绍。（请注意，即使是 jQuery 本身也提供了返回承诺而不是使用回调的 AJAX 方法的变体，但这种用法也不在本章的范围内。）
- en: But for now, we'll compare jQuery with the native `XMLHttpRequest` JavaScript
    object in the next section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们将在下一节中将 jQuery 与原生的 `XMLHttpRequest` JavaScript 对象进行比较。
- en: 'For Comparison: XMLHttpRequest and jQuery'
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对比：XMLHttpRequest 和 jQuery
- en: '`XMLHttpRequest` is a low-level class built into JavaScript to handle service
    calls. Despite having XML in its name, `XMLHttpRequest` can actually be used for
    other protocols as well, including JSON and HTML.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 是 JavaScript 中内置的低级类，用于处理服务调用。尽管其名称中有 XML，但 `XMLHttpRequest`
    实际上也可以用于其他协议，包括 JSON 和 HTML。'
- en: 'The following is equivalent code to *Exercise 10.02: Using AJAX and the jQuery
    ajax() Method to Invoke a Service* so you can compare how code using `XMLHttpRequest`
    looks in comparison to that of jQuery (`xml_http_request_example.js`):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与*练习 10.02：使用 AJAX 和 jQuery ajax() 方法调用服务*等效的代码，以便您可以比较使用 `XMLHttpRequest`
    的代码与 jQuery (`xml_http_request_example.js`) 的代码之间的差异：
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: HTML part is the same as above in *exercise 10.02* in file `exercise2.html`,
    but omit the jQuery lib in `<head>` and change the `js` script `src` file to `xml_http_request_example.js`
    rather than `exercise2.js`
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 部分与文件 `exercise2.html` 中的 *练习 10.02* 相同，但省略 `<head>` 中的 jQuery 库，并将 `js`
    脚本 `src` 文件更改为 `xml_http_request_example.js` 而不是 `exercise2.js`
- en: '[PRE34]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s examine the preceding example in detail:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查前面的示例：
- en: '[PRE35]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When using `XMLHttpRequest`, we need to append query parameters ourselves to
    the end of the URL. Here, it is straightforward to do so, since the value is just
    a simple number, but more complex values will require HTTP encoding by calling
    `encodeURI()`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`XMLHttpRequest`时，我们需要自己将查询参数附加到URL的末尾。在这里，这样做很简单，因为值只是一个简单的数字，但更复杂的值将需要通过调用`encodeURI()`进行HTTP编码：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We instantiate the `XMLHttpRequest` object and call the open method, specifying
    the method (`GET`, `POST`, and so on) and the URL:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化`XMLHttpRequest`对象并调用`open`方法，指定方法（`GET`、`POST`等）和URL：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This low-level API doesn''t take care of setting headers like jQuery did:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个低级API不像jQuery那样处理设置头部：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is the callback function that will be called when there is a ready state
    change. There are a number of states the request can have, so we need to check
    the current state, as in the following line:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当就绪状态发生变化时将被调用的回调函数。请求可以有多个状态，因此我们需要检查当前状态，如下面的行所示：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Unlike the jQuery implementation, there is no `success()` function that gets
    called. We have to check the `readyState` and `status` code explicitly.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与jQuery实现不同，没有`success()`函数被调用。我们必须显式地检查`readyState`和`status`代码。
- en: 'A `readyState` of `4` indicates the request finished and the response is ready.
    Possible states are:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`readyState`为`4`表示请求已完成且响应就绪。可能的状态有：'
- en: '`0`: Request not initialized'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`: 请求未初始化'
- en: '`1`: Server connection established'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`: 建立服务器连接'
- en: '`2`: Request received'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`: 接收请求'
- en: '`3`: Processing request'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`: 处理请求'
- en: '`4`: Request finished, and response is ready'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`: 请求完成，响应就绪'
- en: 'A `status` of `200` indicates `OK`. See the *HTTP Headers* section for a list
    of the most common HTTP status codes:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`状态`为`200`表示`OK`。请参阅*HTTP头部*部分，了解最常见的HTTP状态代码列表：'
- en: '[PRE40]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Unlike with jQuery, we need to parse the JSON text ourselves by calling `JSON.parse()`
    from the response field:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与jQuery不同，我们需要通过从响应字段调用`JSON.parse()`来自己解析JSON文本：
- en: '[PRE41]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `document.getElementById()` function is the native way to select DOM elements
    in JavaScript by ID (equivalent to jQuery''s `$("#game_date")` function). You
    would set the text for the element by setting the `innerHTML` field directly (rather
    than calling an `html()` function as in jQuery):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.getElementById()`函数是JavaScript中通过ID选择DOM元素的本地方式（相当于jQuery的`$("#game_date")`函数）。你会通过直接设置`innerHTML`字段来设置元素的文本（而不是像jQuery那样调用`html()`函数）：'
- en: '[PRE42]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Setting `style.display` is the native way to make a hidden element visible
    again, equivalent to jQuery''s `show()` method (though obviously not as simple):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`style.display`是使隐藏元素再次可见的本地方式，相当于jQuery的`show()`方法（尽管显然不那么简单）：
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The request does not actually get sent until the `send()` method is actually
    invoked, so it is important we do not forget to call it. (Unlike jQuery, where
    the request is automatically sent.)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请求实际上只有在`send()`方法被实际调用时才会发送，因此我们很重要的一点是不要忘记调用它。（与jQuery不同，jQuery会自动发送请求。）
- en: Using jQuery and XMLHttpRequest for POST Requests
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery和XMLHttpRequest进行POST请求
- en: 'Using `$.ajax()` for `POST` requests with regular parameters is much the same
    as for `GET`, apart from specifying `method="POST"`. However, a `POST` request
    has an additional capability – sending the request data in `JSON` format rather
    than the default `''application/x-www-form-urlencoded''` content type. If you
    wish to do so, the `contentType` setting should be set to `''application/json''`
    and the data object should be wrapped in `JSON.stringify()`. Here''s an example:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$.ajax()`进行带有常规参数的`POST`请求与`GET`请求非常相似，除了指定`method="POST"`。然而，`POST`请求有一个额外的功能——以`JSON`格式发送请求数据，而不是默认的`'application/x-www-form-urlencoded'`内容类型。如果你希望这样做，应将`contentType`设置设置为`'application/json'`，并将数据对象包装在`JSON.stringify()`中。以下是一个示例：
- en: '[PRE44]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Like `$.getJSON()`, jQuery also provides a shortcut for `POST` requests, called
    `$.post()`. It has one additional parameter, though, to indicate the data type
    of the response. Here''s an example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 与`$.getJSON()`类似，jQuery还提供了一个用于`POST`请求的快捷方式，称为`$.post()`。不过，它有一个额外的参数，用于指示响应的数据类型。以下是一个示例：
- en: '[PRE45]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For `XMLHttpRequest`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`XMLHttpRequest`：
- en: If you are just sending standard parameters, use `setRequestHeader("Content-Type",
    "application/x-www-form-urlencoded")` and send the encoded parameters when calling
    `send()`. (You may need to also call `encodeURI()` if your data is complex.)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只是发送标准参数，使用`setRequestHeader("Content-Type", "application/x-www-form-urlencoded")`并在调用`send()`时发送编码后的参数。（如果你的数据复杂，你可能还需要调用`encodeURI()`。）
- en: If you are sending your input as JSON, use `setRequestHeader("Content-type",
    "application/json")` and send the data wrapped in `JSON.stringify()` when calling
    `send()`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你以JSON格式发送输入，请在调用`send()`时使用`setRequestHeader("Content-type", "application/json")`，并将数据包裹在`JSON.stringify()`中发送。
- en: For either method, one caveat is that the return code from the service will
    frequently be `201 (Created)` rather than `200 (OK)`, so you want to make sure
    your code looks out for the correct return code.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何一种方法，一个需要注意的问题是，服务返回的代码通常会频繁地是`201 (Created)`而不是`200 (OK)`，所以你想要确保你的代码检查到正确的返回代码。
- en: 'Here''s an example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE46]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Cross-Domain Requests
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨域请求
- en: When selecting or implementing a REST API, there is an important rule to be
    aware of that can impact whether the API can be used for your site. Browsers have
    a security feature known as the **Same Origin Policy**. This policy only allows
    scripts running on a site to access data from URLs on the same site with no specific
    restrictions but prevents scripts from accessing data that is hosted on a different
    domain. The reason for this policy is to prevent different types of attacks unscrupulous
    people can make by exploiting browser security weaknesses to steal your data or
    invoke malicious service calls.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择或实现REST API时，有一个重要的规则需要注意，这可能会影响API是否适用于你的网站。浏览器有一个称为**同源策略**的安全功能。此策略仅允许在站点上运行的脚本访问同一站点上的URL数据，没有具体限制，但阻止脚本访问托管在不同域上的数据。此策略的原因是为了防止不道德的人通过利用浏览器安全漏洞来窃取你的数据或调用恶意服务调用而进行的各种攻击。
- en: 'For instance, if your page is hosted at [https://www.mygreatsite.com/foo.html](https://www.mygreatsite.com/foo.html),
    you would be able to access data or call the service with a URL such as [https://www.mygreatsite.com/my_data.json](https://www.mygreatsite.com/my_data.json).
    However, if the domain differs, even just in a different subdomain such as [https://www.foobar.mygreatsite.com/my_data.json](https://www.foobar.mygreatsite.com/my_data.json),
    the browser would respond with an error such as the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的页面托管在[https://www.mygreatsite.com/foo.html](https://www.mygreatsite.com/foo.html)，你将能够通过类似[https://www.mygreatsite.com/my_data.json](https://www.mygreatsite.com/my_data.json)的URL访问数据或调用服务。然而，如果域名不同，即使是不同的子域名，如[https://www.foobar.mygreatsite.com/my_data.json](https://www.foobar.mygreatsite.com/my_data.json)，浏览器将返回如下错误：
- en: '[PRE47]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Luckily, there are a few ways around this restriction that APIs can implement.
    The details of the implementation of these workarounds are on the server side
    and are not in the scope of this chapter. But it is sufficient to know that APIs
    can be designed in a way that makes them data available across sites. So, when
    selecting APIs to use for your project, you'll need to investigate whether it
    is cross-domain capable. (The API we used in the earlier exercise, TheSportsDB,
    is such a site.)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几种方法可以绕过这种限制，API可以实现。这些解决方案的具体实现细节在服务器端，并不在本章的讨论范围内。但重要的是要知道，API可以设计成跨站点的数据可用。因此，在选择用于项目的API时，你需要调查它是否支持跨域。（我们在前面的练习中使用的TheSportsDB就是一个这样的网站。）
- en: CORS Header
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CORS头信息
- en: 'If you are really curious, the main technique that allows cross-site requests
    is by the service sending something called a **CORS** header, which stands for
    **Cross-Origin Resource Sharing**. If the API wants to make its service available
    from any domain, the server can send the following response header when serving
    the response:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的好奇，允许跨站请求的主要技术是通过服务发送一个称为**CORS**的头信息，它代表**跨源资源共享**。如果API希望使其服务对任何域名都可用，服务器在响应时可以发送以下响应头：
- en: '[PRE48]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `*` value indicates "any origin," but the server could also be more restrictive
    in what sites have access to as per its desire. This is only a very brief description
    of a larger subject. There are some other techniques to achieve cross-domain requests,
    such as using JSONP, `postMessage()` between frames, or local server-side proxies,
    but we will not detail them here.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`值表示“任何来源”，但服务器也可以根据其意愿对可以访问的网站进行更严格的限制。这只是一个对更大主题的简要描述。还有一些其他技术可以实现跨域请求，例如使用JSONP、帧之间的`postMessage()`或本地服务器端代理，但这里不会详细说明。'
- en: 'Activity 10.01: Implement REST Service Calls Using Various Techniques'
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十点零一：使用各种技术实现REST服务调用
- en: 'So far, we have only coded for HTTP `GET` requests. Let''s get some practice
    using `POST`. The API we have been using in the previous exercises, TheSportsDB,
    only contains GET requests, making it unsuitable for testing other HTTP methods.
    Luckily, there are several dummy REST APIs out there made specifically for testing
    and prototyping that can be used for our purposes. We will use one such free API
    called **REQ | RES** (at [https://reqres.in/](https://packt.live/37aWtH4)):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只为HTTP `GET`请求编写了代码。让我们练习使用`POST`。我们在之前的练习中使用的API，TheSportsDB，只包含GET请求，这使得它不适合测试其他HTTP方法。幸运的是，有几个专门为测试和原型设计、用于我们目的的虚拟REST
    API。我们将使用一个名为**REQ | RES**（在[https://reqres.in/](https://packt.live/37aWtH4)）的免费API：
- en: '![Figure 10.14: Home page of REQ|RES'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.14：REQ|RES首页'
- en: '](img/C14377_10_14.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_10_14.jpg)'
- en: 'Figure 10.14: Home page of REQ|RES'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：REQ|RES首页
- en: The API supplies a POST method at [https://reqres.in/api/users](https://reqres.in/api/users)
    for which you supply a JSON object with any fields you wish. You include the object
    as the data of your service call, and the service responds with the same object
    but with additional `id` and `createdAt` fields.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 该API在[https://reqres.in/api/users](https://reqres.in/api/users)提供了一个POST方法，你可以提供任何字段的JSON对象。你将对象作为服务调用的数据，服务响应时会返回相同的对象，但会额外包含`id`和`createdAt`字段。
- en: 'For instance, if you have the following data:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有以下数据：
- en: '![Figure 10.15: Request and Response example'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15：请求和响应示例'
- en: '](img/C14377_10_15.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_10_15.jpg)'
- en: 'Figure 10.15: Request and Response example'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：请求和响应示例
- en: Your task is to implement the code for this service call using the `$.ajax()`
    method followed by the `$.post()` method, and finally execute it using the `XMLHttpRequest`
    method. Then, print out the `id` and `createdAt` fields returned to the console.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是使用`$.ajax()`方法，然后是`$.post()`方法实现这个服务调用，并最终使用`XMLHttpRequest`方法执行它。然后，将返回的`id`和`createdAt`字段打印到控制台。
- en: Keep in mind that the **REQ | RES** API is really just a dummy service for testing
    and does not actually persist any data, so don't expect to be able to retrieve
    the data you sent later.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**REQ | RES** API实际上只是一个用于测试的虚拟服务，它不会实际持久化任何数据，所以不要期望能够检索你稍后发送的数据。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的整体步骤如下：
- en: 'Use `$.ajax()` with `method: ''post''` and `dataType: ''json''`.'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用`$.ajax()`，设置`method: ''post''`和`dataType: ''json''`。'
- en: Enclose your data fields in an object, `{}`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的数据字段放在一个对象`{}`中。
- en: Create a `success` function to output the expected values.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`success`函数以输出预期的值。
- en: Now, use `$.post()`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`$.post()`。
- en: Enclose your data fields in an object, `{}`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的数据字段放在一个对象`{}`中。
- en: Create a `success` function to output the expected values.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`success`函数以输出预期的值。
- en: As the last parameter to `$.post()`, use the `'json'` value to indicate the
    expected JSON return type.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为`$.post()`的最后一个参数，使用`'json'`值来指示预期的JSON返回类型。
- en: Finally, create a new `XMLHttpRequest` object.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的`XMLHttpRequest`对象。
- en: Call `open('POST')`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`open('POST')`。
- en: Set the `Content-type` and `Accept` request headers to the appropriate values.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Content-type`和`Accept`请求头设置为适当的值。
- en: Create a function for `onreadystatechange` that checks for a status code of
    `201 (Created)` and parses the JSON data with `JSON.parse()`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于`onreadystatechange`的函数，该函数检查状态码为`201 (Created)`，并使用`JSON.parse()`解析JSON数据。
- en: Call `JSON.stringify()` on the input data to convert it to JSON format.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对输入数据调用`JSON.stringify()`以将其转换为JSON格式。
- en: Send the JSON data when calling `send()`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`send()`时发送JSON数据。
- en: 'The code should result in something like the following in the JavaScript console
    in Google Chrome:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该在Google Chrome的JavaScript控制台中产生如下结果：
- en: '![Figure 10.16: JavaScript Console output'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.16：JavaScript控制台输出'
- en: '](img/C14377_10_16.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_10_16.jpg)'
- en: 'Figure 10.16: JavaScript Console output'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：JavaScript控制台输出
- en: Note
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 742.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第742页找到。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the last section, we explored the native `XMLHttpRequest` object and how
    it differs from other libraries for making service calls. In summary, as you can
    see, compared to jQuery, the native approach is a lot more verbose, difficult
    to work with, and low-level for most use cases. Unless you have a specific need
    where more control is required, I do not recommend its use.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们探讨了原生的`XMLHttpRequest`对象以及它与制作服务调用其他库的不同之处。总的来说，正如你所看到的，与jQuery相比，原生方法在大多数情况下更为冗长、难以操作且级别较低。除非你有特定的需要更多控制的需求，否则我不建议使用它。
- en: In the next chapter, we will describe regular expressions, which are commonly
    used to match patterns in a concise, flexible, and efficient manner. We will also
    explore best practices for writing clean and understandable code, which is critical
    if you want your code to be easily maintainable and live for a long time.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述正则表达式，它们通常被用来以简洁、灵活和高效的方式匹配模式。我们还将探讨编写清晰易懂代码的最佳实践，这对于你希望代码易于维护并长期存活至关重要。
