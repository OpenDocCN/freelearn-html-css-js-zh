- en: Chapter 4. Making Things Move
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 制作动态效果
- en: A pretty picture is just the beginning! The hallmark of taking full advantage
    of the medium is making visualizations that adapt to new situations. Visualizations
    that let the user explore our data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅漂亮的图片只是开始！充分利用这种媒介的标志是制作能够适应新情况的视觉化。让用户能够探索我们的数据。
- en: In this chapter, we'll animate our pictures with the powerful transitions module
    of d3.js, and will look at some strategies for interacting with the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 d3.js 强大的转换模块来动画化我们的图片，并探讨一些与用户交互的策略。
- en: Animating with transitions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用转换进行动画
- en: So far attributes have been applied instantly, which is great for rendering
    an image, but what if we want to highlight something with a simple animation?
    Perhaps we just want a smoother transition from nothing to "Hey, graph!" while
    loading external data?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，属性都是即时应用的，这对于渲染图像来说很棒，但如果我们想通过简单的动画突出显示某些内容呢？也许我们只想在加载数据时从无到“嘿，图表！”有一个更平滑的过渡？
- en: That's where transitions come in. Transitions use the familiar principle of
    changing a selection's attributes, except that changes are applied over time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是转换的作用。转换使用熟悉的改变选择属性的原则，但变化是随时间应用的。
- en: 'To slowly turn a rectangle red, we''d use the following line of code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要慢慢将矩形变成红色，我们会使用以下代码行：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We start a new transition with `.transition()` and then define the final state
    of each animated attribute. By default, every transition takes 250 milliseconds;
    you can change the timing with `.duration()`. New transitions are executed on
    all properties simultaneously unless you set a delay using `.delay()`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `.transition()` 开始一个新的转换，然后定义每个动画属性的最终状态。默认情况下，每个转换需要 250 毫秒；你可以使用 `.duration()`
    来更改时间。除非你使用 `.delay()` 设置延迟，否则新转换将同时执行所有属性。
- en: Delays are handy when we want to make transitions happen in sequence. Without
    a delay, they are all executed at the same time, depending on an internal timer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要按顺序使转换发生时，延迟很有用。如果没有延迟，它们将同时执行，取决于内部计时器。
- en: For single objects, nested transitions are much simpler than carefully calibrated
    delays.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个对象，嵌套转换比精心校准的延迟简单得多。
- en: Take our rectangle example and write something like this in your Chrome console.
    If you haven't already, you'll need to actually add a rectangle to the page for
    this to work. Such is life.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的矩形为例，在 Chrome 控制台中写下类似的内容。如果你还没有这样做，你需要实际将一个矩形添加到页面上才能使这生效。生活就是这样。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running this code, you'll see the rectangle become red as it moves right by
    a hundred pixels, then moves downwards by the same distance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你会看到矩形向右移动一百像素后变成红色，然后向下移动相同的距离。
- en: 'Capturing animations in screenshots is tough, but say this is your initial
    state:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕截图中捕获动画很困难，但假设这是你的初始状态：
- en: '![Animating with transitions](img/0007OS_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![使用转换进行动画](img/0007OS_04_01.jpg)'
- en: 'The final state would look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最终状态看起来会是这样：
- en: '![Animating with transitions](img/0007OS_04_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![使用转换进行动画](img/0007OS_04_02.jpg)'
- en: We do realize these are just two squares on a white background, but believe
    me, the red square is a hundred pixels below and to the right of the black square.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实意识到这些只是白色背景上的两个正方形，但请相信我，红色正方形在黑色正方形下方和右侧一百像素处。
- en: 'If you want to do something before a transition begins, or want to listen for
    it to end, you can use `.each()` with the appropriate event type like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在转换开始之前做某事，或者想监听它何时结束，你可以使用 `.each()` 并提供适当的事件类型，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is handy for making instant changes before or after a transition. Just
    keep in mind that transitions run independently and you cannot rely on transitions
    outside the current callback being in this state or that.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这在在转换之前或之后进行即时更改时很有用。但请记住，转换是独立运行的，你不能依赖于当前回调之外的转换处于这种状态或那种状态。
- en: Interpolators
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值器
- en: To calculate values between the initial and final states of a transition, d3.js
    uses interpolators—functions mapping the `[0,1]` domain to the target range (color,
    number, or string). Under the hood, scales are based on these same interpolators.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一个转换的初始状态和最终状态之间的值，d3.js 使用插值器——这些函数将 `[0,1]` 的域映射到目标范围（颜色、数字或字符串）。在底层，比例尺基于这些相同的插值器。
- en: D3's built-in interpolators can interpolate between almost any two arbitrary
    values, most often between numbers or colors, but also between strings. This sounds
    odd at first, but it's actually pretty useful.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: D3 的内置插值器可以在几乎任何两个任意值之间进行插值，最常见的是在数字或颜色之间，也可以在字符串之间。一开始这听起来很奇怪，但实际上非常实用。
- en: To let d3.js pick the right interpolator for the job, we just write `d3.interpolate(a,
    b)` and the `interpolation` function is chosen depending on the type of `b`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 d3.js 选择适合工作的正确插值器，我们只需编写 `d3.interpolate(a, b)`，然后根据 `b` 的类型选择 `interpolation`
    函数。
- en: If `b` is a number, `a` will be coerced into a number and `.interpolateNumber()`
    will be used. You should avoid interpolating to or from a zero value because values
    will eventually be transformed into a string for the actual attribute and very
    small numbers might turn into scientific notation. CSS and HTML don't quite understand
    `1e-7` (the digit 1 with seven zeroes in front), so the smallest number you can
    safely use is `1e-6`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `b` 是一个数字，`a` 将会被强制转换为数字，并使用 `.interpolateNumber()` 方法。你应该避免将值插值到或从零值，因为最终值会被转换为字符串属性，非常小的数字可能会变成科学记数法。CSS
    和 HTML 并不完全理解 `1e-7`（前面有七个零的数字1），所以你可以安全使用的最小数字是 `1e-6`。
- en: If `b` is a string, d3.js checks whether it's a CSS color, in which case it
    is transformed to a proper color, just like the ones in [Chapter 2](ch02.html
    "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*.
    `a` is transformed into a color as well, and then d3.js uses `.interpolateRgb()`
    or a more appropriate interpolator for your color space.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `b` 是一个字符串，d3.js 会检查它是否是 CSS 颜色，如果是，它会被转换为一个合适的颜色，就像 [第 2 章](ch02.html "第
    2 章。DOM、SVG 和 CSS 简介") *DOM、SVG 和 CSS 简介* 中的那些一样。`a` 也会被转换成颜色，然后 d3.js 使用 `.interpolateRgb()`
    或更适合你的颜色空间的插值器。
- en: Something even more amazing happens when the string is not a color. d3.js can
    handle that too! When it encounters a string, d3.js will parse it for numbers,
    then use `.interpolateNumber()` on each numerical piece of the string. This is
    useful for interpolating mixed style definitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串不是颜色时，还会发生更令人惊奇的事情。d3.js 也能处理这种情况！当它遇到字符串时，d3.js 会解析它以获取数字，然后对字符串中的每个数值部分使用
    `.interpolateNumber()`。这对于插值混合样式定义非常有用。
- en: 'For instance, to transition a font definition, you might do something like
    this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要过渡字体定义，你可能做如下操作：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We used `.styleTween()` to manually define a transition. It is most useful when
    we want to define the starting value of a transition without relying on the current
    state. The first argument defines which style attribute to transition and the
    second is the interpolator.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `.styleTween()` 来手动定义过渡。当不想依赖于当前状态来定义过渡的起始值时，这非常有用。第一个参数定义了要过渡的样式属性，第二个参数是插值器。
- en: You can use `.tween()` to do this for attributes other than style.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `.tween()` 方法来对除了样式以外的属性进行插值。
- en: Every numerical part of the string was interpolated between the starting and
    ending values, and the string parts changed to their final state immediately.
    An interesting application of this is interpolating path definitions—you can make
    shapes change in time. How cool is that?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的每个数值部分都在起始值和结束值之间进行插值，而字符串部分则立即变为最终状态。这个应用的有趣之处在于插值路径定义——你可以使形状随时间变化。这有多酷？
- en: Keep in mind that only strings with the same number and location of control
    points (numbers in the string) can be interpolated. You can't use interpolators
    for everything. Creating a custom interpolator is as simple as defining a function
    that takes a single `t` parameter and returns the start value for `t = 0` and
    end value for `t = 1` and blends values for anything in between.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只有具有相同数量和位置的控点（字符串中的数字）的字符串才能进行插值。你不能对一切使用插值器。创建一个自定义插值器就像定义一个只接受单个 `t`
    参数并返回 `t = 0` 的起始值和 `t = 1` 的结束值，并在两者之间混合值的函数一样简单。
- en: 'For example, the following code shows the `interpolateNumber` function of d3.js:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码显示了 d3.js 的 `interpolateNumber` 函数：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's as simple as that!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！
- en: You can even interpolate whole arrays and objects, which work like compound
    interpolators of multiple values. We'll use those soon.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以插值整个数组和对象，它们就像多个值复合插值器。我们很快就会使用它们。
- en: Easing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓动
- en: Easing tweaks the behavior of interpolators by controlling the `t` argument.
    We use this to make our animations feel more natural, to add some bounce elasticity,
    and so on. Mostly we use easing to avoid the artificial feel of linear animation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缓动通过控制 `t` 参数来调整插值器的行为。我们使用它来使动画感觉更自然，添加一些弹跳弹性，等等。我们主要使用缓动来避免线性动画的人工感。
- en: Let's make a quick comparison of the easing functions provided by d3.js and
    see what they do.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速比较 d3.js 提供的缓动函数，看看它们的作用。
- en: Don't forget the drawing area! I once spent an hour debugging a graph before
    realizing there was no `svg` element.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记绘图区域！我曾经花了一个小时调试一个图表，直到意识到没有`svg`元素。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we need an array of easing functions and a scale for placing them along
    the vertical axis.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个缓动函数数组和一个用于在垂直轴上放置它们的缩放比例。
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You'll notice that `poly`, `elastic`, and `back` take arguments; since these
    are just strings, we'll have to manually change them into real arguments later.
    The `poly` easing function is just a polynomial, so `poly(2)` is equal to `quad`
    and `poly(3)` is equal to `cubic`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`poly`、`elastic`和`back`需要参数；由于这些只是字符串，我们稍后必须手动将它们更改为实际参数。`poly`缓动函数只是一个多项式，所以`poly(2)`等于`quad`，`poly(3)`等于`cubic`。
- en: The `elastic` easing function simulates an elastic and the two arguments control
    tension. I suggest playing with the values to get the effect you want.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`elastic`缓动函数模拟弹性，两个参数控制张力。我建议尝试调整这些值以获得你想要的效果。'
- en: The `back` easing function is supposed to simulate backing into a parking space.
    The argument controls how much overshoot there's going to be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`back`缓动函数旨在模拟倒车进入停车位。参数控制将有多少超调。'
- en: 'The nonsense at the end (`cubic-in`, `cubic-out`, and so on) is a list of the
    easing functions we create ourselves by combining the following modifiers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后面的无意义内容（`cubic-in`、`cubic-out`等）是我们通过组合以下修饰符自己创建的缓动函数列表：
- en: '`-in`: It does nothing'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-in`：它什么都不做'
- en: '-`out`: It reverses the easing direction'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-out`：它反转缓动方向'
- en: '-`in-out`: It copies and mirrors the easing function from `[0, 0.5]` and `[0.5,
    1]`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-in-out`：它从`[0, 0.5]`和`[0.5, 1]`复制并镜像缓动函数'
- en: '`-out-in`: It copies and mirrors the easing function from `[1, 0.5]` and `[0.5,
    0]`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-out-in`：它从`[1, 0.5]`和`[0.5, 0]`复制并镜像缓动函数'
- en: 'You can add these to any easing function, so play around. Time to render a
    circle flying towards the right for every function in the list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些添加到任何缓动函数中，所以可以随意尝试。现在是时候渲染一个向右飞行的圆圈，为列表中的每个函数：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We loop over the list with an iterator that creates a new circle and uses the
    `y()` scale for vertical placement and `y.rangeBand()` for circle size. This way,
    we can add or remove examples easily. Transitions will start with a delay of just
    under half a second to give us a chance to see what's going on. A duration of
    `1500` milliseconds and a final position of `400` should give enough time and
    space to see the easing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个迭代器遍历列表，创建一个新的圆圈，并使用`y()`缩放进行垂直定位，使用`y.rangeBand()`进行圆圈大小。这样，我们可以轻松地添加或删除示例。过渡将延迟不到半秒开始，这样我们可以有机会看到正在发生的事情。持续时间为`1500`毫秒，最终位置为`400`应该有足够的时间和空间来观察缓动效果。
- en: 'We define the easing at the end of this function, before the `});` bit:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个函数的末尾定义缓动，在`});`之前：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code checks for parentheses in the `ease` string, parses out the easing
    function and its arguments, and feeds them to `transition.ease()`. Without parentheses,
    `ease` is just the easing type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查`ease`字符串中的括号，解析出缓动函数及其参数，并将它们传递给`transition.ease()`。如果没有括号，`ease`只是缓动类型。
- en: 'Let''s add some text so we can tell the examples apart:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些文本，这样我们就可以区分示例：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The visualization is a cacophony of dots:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是一堆点的嘈杂组合：
- en: '![Easing](img/0007OS_04_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Easing](img/0007OS_04_03.jpg)'
- en: The screenshot doesn't quite showcase the animation, so you should really try
    this one in the browser. Or you can take a look at the easing curves at [http://easings.net/](http://easings.net/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 截图并不能很好地展示动画，所以你真的应该在浏览器中尝试这个。或者你可以查看[http://easings.net/](http://easings.net/)上的缓动曲线。
- en: Timers
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时器
- en: To schedule transitions, d3.js uses timers. Even an immediate transition will
    start after a delay of 17 ms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安排过渡，d3.js使用计时器。即使是立即过渡，也会在延迟17毫秒后开始。
- en: Far from keeping timers all to itself, d3.js lets us use timers so that we can
    take animation beyond the two-keyframe model of transition. For those of us who
    aren't animators, keyframes define the start or end of a smooth transition.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js不仅将计时器留给自己，还允许我们使用计时器，这样我们就可以将动画扩展到过渡的两个关键帧模型之外。对于我们这些不是动画师的人来说，关键帧定义了平滑过渡的开始或结束。
- en: To create a timer, we use `d3.timer()`. It takes a function, a delay, and a
    starting mark. After the set delay (in milliseconds) from the mark, the function
    will be executed repeatedly until it returns `true`. The mark should be a date
    converted into milliseconds since Unix epoch (`Date.getTime()` will do), or you
    can let d3.js use `Date.now()` by default.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个计时器，我们使用 `d3.timer()`。它需要一个函数、一个延迟和一个起始标记。从标记开始设置延迟（以毫秒为单位）后，该函数将重复执行，直到它返回
    `true`。标记应该是一个自 Unix 纪元以来的日期转换为毫秒（`Date.getTime()` 可以做到），或者你可以让 d3.js 默认使用 `Date.now()`。
- en: Let's animate the drawing of a parametric function to work just like the Spirograph
    toy you might have had as a kid.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动画化一个参数函数的绘制，使其看起来就像你小时候可能玩过的斯皮罗图玩具。
- en: We'll create a timer, let it run for a few seconds, and use the millisecond
    mark as the parameter for a parametric function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个计时器，让它运行几秒钟，并使用毫秒标记作为参数函数的参数。
- en: 'First we need a drawing area:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个绘图区域：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I found a good function in Wikipedia's article on parametric equations at [http://en.wikipedia.org/wiki/Parametric_equations](http://en.wikipedia.org/wiki/Parametric_equations).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我在维基百科关于参数方程的文章中找到一个很好的函数，链接为 [http://en.wikipedia.org/wiki/Parametric_equations](http://en.wikipedia.org/wiki/Parametric_equations)。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function will return a mathematical position based on the parameter going
    from zero up. You can tweak the Spirograph by changing the `a`, `b`, `c`, and
    `d` variables—examples in the same Wikipedia article.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将根据参数从零向上的变化返回一个数学位置。你可以通过改变 `a`、`b`、`c` 和 `d` 变量来调整斯皮罗图——同一维基百科文章中的示例。
- en: 'This function returns positions between `-2` and `2`, so we need some scales
    to make it visible on the screen:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回介于 `-2` 和 `2` 之间的位置，因此我们需要一些刻度来使其在屏幕上可见：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`t_scale` will translate time into parameters for the function; `x` and `y`
    will calculate the final position on the image.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`t_scale` 将时间转换为函数的参数；`x` 和 `y` 将计算图像上的最终位置。'
- en: Now we need to define `brush` to fly around and pretend it's drawing and a variable
    to hold the `previous` position so that we can draw straight lines.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义 `brush` 来四处移动并假装它在绘制，以及一个变量来保存 `previous` 位置，这样我们就可以绘制直线。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to define an animation `step` function that moves the brush and
    draws a line between the previous and current points:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个动画 `step` 函数，该函数移动刷子并在前一个和当前点之间绘制线条：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first condition stops the timer when the current value of the `time` parameter
    is beyond the domain of `t_scale`. Then, we use `t_scale()` to translate the time
    into our parameter and get a new position for the brush.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件在 `time` 参数的当前值超出 `t_scale` 的定义域时停止计时器。然后，我们使用 `t_scale()` 将时间转换为我们的参数，并为刷子获取一个新的位置。
- en: Then, we move the brush—there is no transition because *we* are performing the
    transition—and draw a new steelblue line between the previous and current position
    (`pos`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们移动刷子——因为没有过渡，因为我们正在执行过渡——并在前一个和当前位置 (`pos`) 之间绘制一条新的钢蓝色线条。
- en: We conclude by setting a new value for the previous position.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置新的 `previous` 位置来得出结论。
- en: 'All that''s left now is creating a timer:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下创建一个计时器：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's it. Half a second after a page refresh, the code will begin drawing a
    beautiful shape and finish 25 seconds later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。页面刷新后半秒，代码将开始绘制一个美丽的形状，并在25秒后完成。
- en: 'Starting out, it looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，它看起来像这样：
- en: '![Timers](img/0007OS_04_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![计时器](img/0007OS_04_04.jpg)'
- en: Getting the whole picture takes a while, so this probably isn't the best way
    to draw Spirographs. Since we're using time as a parameter, a smoother curve (more
    points) takes more time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 获得整个图像需要一段时间，所以这可能不是绘制斯皮罗图的最好方法。由于我们使用时间作为参数，更平滑的曲线（更多点）需要更多时间。
- en: Another problem is that lagging computers or slower machines will affect the
    final outcome of the animation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是有延迟的计算机或较慢的机器会影响动画的最终结果。
- en: A reader wrote a version without these problems and put the code on Github at
    [https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js](https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一位读者编写了一个没有这些问题的版本，并将代码放在了 Github 上，链接为 [https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js](https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js)。
- en: '![Timers](img/0007OS_04_05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![计时器](img/0007OS_04_05.jpg)'
- en: But both versions of the code will eventually come up with a beautiful flower.
    When I wrote this code, I spent an hour just marveling at the drawing process
    and tweaking the parameters to see what happens.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但两种代码版本最终都会得到一个美丽的花朵。当我编写这段代码时，我花了整整一个小时惊叹于绘制过程并调整参数以查看会发生什么。
- en: Interacting with the user
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与用户交互
- en: Great visualizations don't just stop at pretty pictures and animations! They
    give users the power to play with data and figure things out on their own. That's
    what we'll look into next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的可视化不仅仅停留在漂亮的图片和动画上！它们赋予用户操作数据和自行解决问题的能力。这正是我们接下来要探讨的。
- en: You don't know it yet, but you already know how to let users interact with visualizations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还不知道，但你已经知道如何让用户与可视化进行交互。
- en: Basic interaction
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本交互
- en: Much like with other UI libraries, the principle for interaction is simple—attach
    an event listener to an element and do something when it's triggered. We add and
    remove listeners to and from selections with the `.on()` method, an event type
    (for instance, `click`), and a listener function that is executed when the event
    is triggered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他UI库类似，交互的原则很简单——将事件监听器附加到元素上，并在触发时执行某些操作。我们使用`.on()`方法、事件类型（例如，`click`）和当事件被触发时执行的监听器函数，向和从选择中添加和删除监听器。
- en: We can set a capture flag, which ensures our listener is called first and all
    other listeners wait for our listener to finish. Events bubbling up from children
    elements will not trigger our listener.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个捕获标志，确保我们的监听器首先被调用，其他所有监听器都等待我们的监听器完成。从子元素冒泡上来的事件不会触发我们的监听器。
- en: You can rely on the fact there will only ever be a single listener for a particular
    event on an element because old listeners for the same event are removed when
    new ones are added. This is very useful for avoiding unpredictable behavior.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以依赖这样一个事实：一个元素上特定事件的监听器始终只有一个，因为当添加新监听器时，会移除相同事件的旧监听器。这对于避免不可预测的行为非常有用。
- en: Just like other functions acting on element selections, event listeners get
    the current datum and index and set the `this` context to the DOM element. The
    global `d3.event` will let you access the actual event object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他对元素选择执行操作的函数一样，事件监听器会获取当前数据项和索引，并将 `this` 上下文设置为 DOM 元素。全局的 `d3.event` 将允许你访问实际的事件对象。
- en: Let's play around with these principles and a simple visualization using mouse
    clicks and finger touches. Yes, d3.js has some support for touch devices, but
    it doesn't always work perfectly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过鼠标点击和手指触摸来玩转这些原则和简单的可视化。是的，d3.js 对触摸设备有一些支持，但并不总是完美。
- en: 'As always, begin with a drawing area:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，从一个绘图区域开始：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we create a function that will emulate ripples in a pond using three
    circles; you might need some imagination:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个函数，将使用三个圆模拟池塘中的涟漪；你可能需要一些想象力：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `radiate` function creates three circles centered around a position, defined
    by a two-element array—[x, y]. A transition will grow the circles, reduce their
    opacity, and in the end, remove them. We used `.delay` to ensure the circles don't
    overlap, which creates the rippling illusion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`radiate` 函数在由一个包含两个元素的数组定义的位置（[x, y]）周围创建三个圆。过渡效果会使圆变大，降低它们的透明度，最后移除它们。我们使用了
    `.delay` 来确保圆不会重叠，从而产生涟漪的错觉。'
- en: 'Now for the fun part:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候享受乐趣了：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We used `.on()` once for each type of event we want to make ripples for—the
    familiar `click` event first and then the possibly less familiar `touchstart`.
    The `touchstart` event is triggered when a finger touches the screen; think of
    it as the `mousedown` event of touch. Other useful touch events are `touchmove`,
    `touchend`, `touchcancel`, and `tap`. Mozilla's documentation explains touch events
    in more detail at [https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为想要产生涟漪的每种事件类型使用 `.on()` 一次——首先是熟悉的 `click` 事件，然后是可能不太熟悉的 `touchstart`。当手指触摸屏幕时，会触发
    `touchstart` 事件；将其视为触摸的 `mousedown` 事件。其他有用的触摸事件包括 `touchmove`、`touchend`、`touchcancel`
    和 `tap`。Mozilla 的文档在 [https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events)
    中更详细地解释了触摸事件。
- en: The `click` listener uses `d3.mouse()` to get the cursor's position relative
    to the container element, and the `touchstart` listener maps through a list of
    all touches. In theory, this will draw several ripples if you smoosh your whole
    hand on the screen, but I was unable to get this working on any of my devices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`click` 监听器使用 `d3.mouse()` 获取相对于容器元素的游标位置，而 `touchstart` 监听器通过所有触摸的列表进行映射。理论上，如果你将整个手压在屏幕上，这将绘制几个涟漪，但我无法在我的任何设备上实现这一点。'
- en: 'Make the ripples pretty with some styling:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些样式使涟漪变得漂亮：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Clicking around makes ripples!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 点击周围会产生涟漪！
- en: '![Basic interaction](img/0007OS_04_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![基本交互](img/0007OS_04_06.jpg)'
- en: Behaviors
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为
- en: Sometimes, you want more than to just let the user click around like a madman;
    you want drag-and-drop and zoom-in and zoom-out stuff!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你想要的不仅仅是让用户像疯子一样点击；你想要拖放、缩放和缩放功能！
- en: You can make all this with just click events, but I heartily recommend d3's
    behaviors module. It makes complex behaviors as simple as calling the right function
    on some elements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击事件完成所有这些，但我强烈推荐使用 d3 的行为模块。它使得复杂的行为变得像在元素上调用正确函数一样简单。
- en: Currently, d3.js supports only `drag` and `zoom`, but I am hopeful that more
    are on the way. The main benefit of behaviors is that they automatically create
    relevant event listeners and let you work at a higher level of abstraction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，d3.js 只支持 `drag` 和 `zoom`，但我希望更多功能即将到来。行为的主要好处是它们自动创建相关的事件监听器，并允许你在更高的抽象级别上工作。
- en: Drag
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Drag
- en: I can't think of a better dragging demonstration than animating with the parallax
    illusion. The illusion works by having several keyframes rendered in vertical
    slices and dragging a screen over them to create an animated thingamabob.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我想不出比用视差错觉动画更好的拖动演示了。错觉是通过在垂直切片中渲染几个关键帧来实现的，通过拖动屏幕覆盖它们来创建一个动画效果。
- en: Drawing the lines by hand would be tedious, so we're using an image *Marco Kuiper*
    created in Photoshop. I asked on Twitter and he said we can use the image, if
    we check out his other work at [marcofolio.net](http://marcofolio.net).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 手动绘制线条会很麻烦，所以我们使用了一个由 *Marco Kuiper* 在 Photoshop 中创建的图像。我在推特上询问了他，他说如果我们查看他在
    [marcofolio.net](http://marcofolio.net) 的其他作品，我们可以使用这张图片。
- en: '![Drag](img/0007OS_04_07.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Drag](img/0007OS_04_07.jpg)'
- en: You can also get the image in the examples repository at [https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png](https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在示例仓库中找到这张图片：[https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png](https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png).
- en: 'We need somewhere to put the parallax:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个地方来放置视差效果：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll use SVG''s native support for embedding bitmaps to insert `parallax_base.png`
    into the page:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 SVG 的原生位图嵌入支持来将 `parallax_base.png` 插入页面：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `image` element's magic stems from its `xlink:href` attribute. It understands
    links and even lets us embed images to create self-contained SVGs. To use that,
    you would prepend an image MIME type to a base64 encoded representation of the
    image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`image` 元素的魔力源于其 `xlink:href` 属性。它理解链接，甚至允许我们嵌入图像以创建自包含的 SVG。要使用它，你需要在图像的 base64
    编码表示之前添加一个图像 MIME 类型。'
- en: For instance, the following line is the smallest embedded version of a spacer
    GIF. Don't worry if you don't know what a spacer GIF is; they were useful up to
    about 2005.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下行是最小的嵌入版 spacer GIF。如果你不知道什么是 spacer GIF，不用担心；它们在 2005 年左右之前很有用。
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Anyway, now that we have the animation base, we need a screen that can be dragged.
    It''s going to be a bunch of carefully calibrated vertical lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，现在我们有了动画的基础，我们需要一个可以拖动的屏幕。它将是一系列精心校准的垂直线条：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We'll base the screen off an array of numbers (`lines`). Since line thickness
    and density are very important, we divide `screen_width` by `6`—five pixels for
    a line and one for spacing. Make sure the value of `screen_width` is a multiple
    of 6; otherwise anti-aliasing ruins the effect.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于数字数组（`lines`）来构建屏幕。由于线条的粗细和密度非常重要，我们将 `screen_width` 除以 `6`——五像素用于线条，一像素用于间距。确保
    `screen_width` 的值是 6 的倍数；否则抗锯齿会破坏效果。
- en: 'The `x` scale will help us place the lines evenly:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 标度将帮助我们均匀地放置线条：'
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's nothing particularly interesting here, just stuff you already know.
    The code goes through the array and draws a new vertical line for each entry.
    We made absolutely certain there won't be any anti-aliasing by setting `shape-rendering`
    to `crispEdges`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别有趣的东西，只是你已经知道的东西。代码遍历数组，并为每个条目绘制一条新的垂直线。我们确保通过将 `shape-rendering` 设置为
    `crispEdges` 来避免任何抗锯齿。
- en: 'Time to define and activate a dragging behavior for our group of lines:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候定义并激活我们线条组的拖动行为：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We created the behavior with `d3.behavior.drag()`, defined a `.origin()` accessor,
    and specified what happens on drag. The behavior automatically translates touch
    and mouse events to the higher-level drag event. How cool is that!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `d3.behavior.drag()` 创建了行为，定义了 `.origin()` 访问器，并指定了拖动时发生的事情。该行为自动将触摸和鼠标事件转换为更高层次的拖动事件。这有多酷！
- en: We need to give the behavior an origin so it knows how to calculate positions
    relatively; otherwise, the current position is always set to the mouse cursor
    and objects jump around. It's terrible. `Object` is the identity function for
    elements and assumes a datum with *x* and *y* coordinates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要给行为一个原点，这样它就知道如何计算相对位置；否则，当前位置总是设置为鼠标光标，对象会四处跳跃。这太糟糕了。"Object" 是元素的恒等函数，并假设具有
    *x* 和 *y* 坐标的 `datum`。
- en: The heavy lifting happens inside the `drag` listener. We get the screen's new
    position from `d3.event.x`, move the screen there, and update the attached `.datum()`
    method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重的劳动发生在 `drag` 监听器内部。我们从 `d3.event.x` 获取屏幕的新位置，将其移动到那里，并更新附加的 `.datum()` 方法。
- en: 'All that''s left to do is to call `drag` and make sure to set the attached
    datum to the current position:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是调用 `drag` 并确保将附加的 `datum` 设置为当前位置：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The item looks solid now! Try dragging the screen at different speeds.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目看起来很坚固了！尝试以不同的速度拖动屏幕。
- en: '![Drag](img/0007OS_04_08.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![拖动](img/0007OS_04_08.jpg)'
- en: The parallax effect doesn't work very well on a retina display because the base
    image gets resized and our screen loses calibration.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在视网膜显示屏上，视差效果并不很好，因为基础图像会被重新调整大小，我们的屏幕失去了校准。
- en: Zoom
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放
- en: Despite the name, the zoom behavior lets you do more than just zoom—you can
    also pan! Like the drag behavior, zoom automatically handles both mouse and touch
    events and then triggers the higher-level zoom event. Yes, this means pinch-to-zoom
    works! That's pretty awesome if you ask me.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字叫缩放行为，但它不仅能缩放，还能平移！就像拖动行为一样，缩放自动处理鼠标和触摸事件，然后触发高级缩放事件。如果你问我，这真的很酷！
- en: Remember that map from [Chapter 3](ch03.html "Chapter 3. Making Data Useful"),
    *Making Data Useful*? The one with airports on a world map? That one.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记得[第3章](ch03.html "第3章。使数据有用")，*使数据有用*中的那个地图吗？那个在世界地图上有机场的地图？就是那个。
- en: Let's commit a crime against computational efficiency and make it zoom and pan.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们犯一个计算效率上的错误，让它可以缩放和拖动。
- en: I am warning you this will be very rudimentary and painfully slow. This is not
    how you'd make a real explorable map, just an example to let us play with zooming.
    In real life you should use tiling, progressive detailing, and other tricks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我要警告你，这将会非常基础且痛苦缓慢。这并不是制作一个真正的可探索地图的方法，而只是一个让我们可以尝试缩放的例子。在现实生活中，你应该使用瓦片、渐进式细节和其他技巧。
- en: To make this a bit more bearable, you should disable water and urban areas.
    Comment out `add_to_map` calls for rivers, lakes, and oceans roughly on lines
    30, 36, and 42 in the JavaScript code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程稍微容易忍受一些，你应该禁用水域和城市区域。在JavaScript代码的大约第30、36和42行处注释掉 `add_to_map` 对河流、湖泊和海洋的调用。
- en: 'Your map becomes much simpler:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你的地图变得简单多了：
- en: '![Zoom](img/0007OS_04_09.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![缩放](img/0007OS_04_09.jpg)'
- en: The biggest effect comes from removing large areas, so if you remove land as
    well, the map will be surprisingly performant but quite useless.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的效果来自于移除大面积区域，所以如果你也移除了陆地，地图将会有惊人的性能，但相当无用。
- en: 'Jump to the end of `draw_airlines` and add a call to `zoomable`; we''ll define
    this next:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到 `draw_airlines` 的末尾，并添加对 `zoomable` 的调用；我们将在下一部分定义它：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`zoomable` needs `airports`, `R_scale`, and `routes` data to resize the circles
    when zooming:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`zoomable` 需要 `airports`、`R_scale` 和 `routes` 数据来在缩放时调整圆的大小：'
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We defined a zoom behavior with `d3.behavior.zoom()` and immediately called
    it on the whole image.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `d3.behavior.zoom()` 定义了一个缩放行为，并立即在整个图像上调用它。
- en: We set the current `.translate()` vector and `.scale()` to whatever the projection
    was using. The zoom event will call our `onzoom` function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前的 `.translate()` 向量和 `.scale()` 设置为投影所使用的值。缩放事件将调用我们的 `onzoom` 函数。
- en: 'Let''s define it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一下：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First we told our projection the new translation vector is in `d3.event.translate`.
    The translation vector will pan the map with a transformation, just like in [Chapter
    2](ch02.html "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG,
    and CSS*. `d3.event.scale` is just a number the projection uses to scale itself,
    effectively zooming the map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉我们的投影新的平移向量是 `d3.event.translate`。平移向量将通过转换平移地图，就像在[第2章](ch02.html "第2章。DOM、SVG和CSS入门")，*DOM、SVG和CSS入门*中一样。`d3.event.scale`
    是投影用来缩放自身的数字，实际上就是缩放地图。
- en: Then, we recalculated all the paths with a new `d3.geo.path()` using the changed
    projection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用新的投影重新计算了所有路径的 `d3.geo.path()`。
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The same approach works for circles. Take the new info, select all the circles,
    and change their attributes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也适用于圆形。获取新的信息，选择所有的圆形，并更改它们的属性。
- en: The positioning function is exactly the same as in `draw_airlines` because geographic
    projections handle panning out of the box. Adjusting size takes a bit more work.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 定位函数与`draw_airlines`中的完全相同，因为地理投影处理了超出框的平移。调整大小需要更多的工作。
- en: After calculating a magnifier as a ratio between the current and default scale
    (`1200`), we use `R_scale` to get the circle's normal size and multiply it by
    the magnifier.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算放大镜作为当前和默认比例（`1200`）之间的比率后，我们使用`R_scale`获取圆的正常大小，并将其乘以放大镜。
- en: You can now explore the world!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以探索这个世界了！
- en: Have patience, though, it's slow. Redrawing everything on every move will do
    that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但是要有耐心，因为它很慢。每次移动都重新绘制一切会这样。
- en: For a more performant zoomable map, we'd have to use data with less detail when
    zoomed out, draw a sensible number of airports, and possibly avoid drawing parts
    of the map that fall out of the image anyway.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个更高效的可缩放地图，当缩小视图时，我们必须使用更少细节的数据，绘制一个合理的机场数量，并可能避免绘制图像之外的地图部分。
- en: '![Zoom](img/0007OS_04_10.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![缩放](img/0007OS_04_10.jpg)'
- en: Brushes
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画笔
- en: Similar to zoom and drag, brushes are a simple way to create complex behavior—they
    enable users to select a part of the canvas.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与缩放和拖动类似，画笔是一种创建复杂行为的简单方法——它们使用户能够选择画布的一部分。
- en: Strangely enough, they aren't considered a behavior, but fall under the `.svg`
    namespace, perhaps because they are mostly meant for visual effects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 很奇怪，它们不被视为一种行为，而是属于`.svg`命名空间，可能是因为它们主要用于视觉效果。
- en: To create a new brush, we'd call `d3.svg.brush()` and define its x and y scales
    using `.x()` and `.y()`. We can also define a bounding rectangle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的画笔，我们会调用`d3.svg.brush()`并使用`.x()`和`.y()`定义其x和y比例。我们还可以定义一个边界矩形。
- en: Time for an example!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候举一个例子了！
- en: 'We''re going to make a scatterplot of some random data and let the user select
    points. Begin with a drawing area and some data:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一些随机数据的散点图，并让用户选择点。从绘图区域和一些数据开始：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We used a built-in random generator to create numbers with a `normal` distribution
    centered around `.5` and a dispersion of `.11`. d3.js also gives us the `logNormal`
    and `irwinHall` distributions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置的随机生成器创建围绕`.5`中心且分散度为`.11`的`normal`分布的数字。d3.js还提供了`logNormal`和`irwinHall`分布。
- en: We now have an array of 800 random two-dimensional positions. To draw them,
    we'll use two scales to make the tiny range more visible, then place each datum
    on the page as a circle.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含800个随机二维位置的数组。为了绘制它们，我们将使用两个比例使小范围更明显，然后将每个数据点放置在页面上作为一个圆。
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I know we don''t usually add axes in this book, but scatterplots look ridiculous
    without them. Let''s add some:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我们在这本书中通常不会添加坐标轴，但如果没有它们，散点图看起来会很荒谬。让我们添加一些：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You should remember what's going on here from [Chapter 2](ch02.html "Chapter 2. A
    Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*, where we discussed
    axes at length.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记得这里发生的事情来自[第2章](ch02.html "第2章。DOM、SVG和CSS入门")，*DOM、SVG和CSS入门*，在那里我们详细讨论了坐标轴。
- en: 'Add some basic styling to the HTML:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为HTML添加一些基本样式：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And yay, scatterplot!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈，散点图！
- en: '![Brushes](img/0007OS_04_11.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![画笔](img/0007OS_04_11.jpg)'
- en: 'Now for the fun stuff:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候做一些有趣的事情了：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We made a new grouping element for the brush and called a freshly constructed
    `d3.svg.brush()` with both scales defined. The `"brush"` class will help with
    styling. Finally, we defined listeners for `brusthstart`, `brush`, and `brushend`
    events.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为画笔创建了一个新的分组元素，并使用已定义的两个比例调用了一个新构建的`d3.svg.brush()`。`"brush"`类将有助于样式。最后，我们为`brushstart`、`brush`和`brushend`事件定义了监听器。
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`brushstart` flicks the styling to `selecting`. We''ll use it to help the user
    distinguish between selected and unselected circles:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`brushstart`将样式切换到`selecting`。我们将使用它来帮助用户区分已选择和未选择的圆圈：'
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`brushmove` is where the real magic happens.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`brushmove`是真正魔法发生的地方。'
- en: First, we find the selection's boundaries using `d3.event.target.extent()`.
    `d3.event.target` returns the current brush and `.extent()` returns a set of two
    points—upper-left and bottom-right corner.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`d3.event.target.extent()`找到选择范围的边界。`d3.event.target`返回当前的画笔，而`.extent()`返回一组两个点——左上角和右下角。
- en: 'Then, we go through all the circles and turn the `selected` class on or off,
    depending on whether a circle''s position lies within the bounding box:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历所有圆圈，根据圆的位置是否在边界框内，打开或关闭`selected`类：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`brushend` just turns off the selecting state if the selection is empty.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择为空，`brushend`只是关闭选择状态。
- en: 'Our HTML needs some more styling definitions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HTML需要更多的样式定义：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We're changing the opacity of the circle fill (`fill-opacity)` rather than for
    the borders so that the circle edges always shine out at full opacity. Adding
    a CSS transition gives everything a smoother feel.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在改变圆形填充的透明度（`fill-opacity`），而不是边框的透明度，这样圆形的边缘总是以全透明度闪耀。添加CSS过渡使一切感觉更加平滑。
- en: In this case, we prefer CSS transitions over what d3.js can do, so we can limit
    JavaScript to changing element states. Brushes sometimes also have problems with
    d3.js transitions and change properties immediately.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们更喜欢CSS过渡而不是d3.js能做的，这样我们可以将JavaScript限制在改变元素状态上。刷子有时也会在d3.js过渡中遇到问题，并立即更改属性。
- en: 'When you select some elements, the image will look like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一些元素时，图像将看起来像这样：
- en: '![Brushes](img/0007OS_04_12.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![刷子](img/0007OS_04_12.jpg)'
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow, what a fun chapter!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，多么有趣的一章！
- en: You've made things jump around the page, almost killed your computer and patience
    with a zoomable map, and created a spinning thingy out of nothing but vertical
    lines.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你让事物在页面上跳跃，几乎用可缩放的地图杀死了你的电脑和耐心，并且仅用垂直线条就创造了一个旋转的东西。
- en: This is everything you need for visualizations users can play with. The rest
    is just experimentation and some ingenuity in piecing things together. Good luck!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是用户可以与之互动的视觉化所需的一切。其余的只是实验和一些巧妙地将事物组合在一起。祝你好运！
