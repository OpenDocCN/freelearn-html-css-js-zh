- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Framework Organization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架组织
- en: The existing JavaScript frameworks have many technical and structural similarities
    that are useful to learn as part of becoming experts in framework development.
    In this chapter, framework organization refers to the way of composing a set of
    abstractions and building blocks, thus creating a collection of usable interfaces
    that can be utilized in application code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的JavaScript框架在技术和结构上有很多相似之处，这些相似之处对于成为框架开发专家来说是很有用的学习内容。在本章中，框架组织指的是将一组抽象和构建块组合起来的方式，从而创建一个可用的接口集合，这些接口可以在应用程序代码中使用。
- en: 'We are going to learn about the following organizational topics that enable
    framework development and use:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习以下组织主题，这些主题有助于框架的开发和使用：
- en: Learning about abstractions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解抽象
- en: Building blocks of abstractions in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中抽象的构建块
- en: Framework building blocks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架构建块
- en: Differentiating modules, libraries, and frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分模块、库和框架
- en: Understanding the core building blocks and aspects of framework development
    will help us craft our own framework and have the domain knowledge to use other
    frameworks to their maximum potential. The expectations from the users or stakeholders
    of a software framework are to have clear instructions with familiar application
    concepts, reduced complexity, and a well-defined code base. Let us explore how
    framework organization can help us satisfy those expectations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 理解框架开发的核心理念和方面将帮助我们构建自己的框架，并拥有使用其他框架的最大潜能的领域知识。软件框架的用户或利益相关者的期望是拥有清晰的指导、熟悉的应用概念、降低复杂性和一个定义良好的代码库。让我们探讨框架组织如何帮助我们满足这些期望。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Similar to the previous chapter, we will be using the book’s repository as an
    extension to this chapter. You can find it at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    For the code from the repository, you can use any environment that supports a
    terminal and runs Node.js, such as Windows, macOS, and most varieties of Linux.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，我们将使用本书的仓库作为本章的扩展。您可以在 [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework)
    找到它。对于仓库中的代码，您可以使用任何支持终端并运行Node.js的环境，例如Windows、macOS和大多数Linux版本。
- en: This chapter includes examples from open source frameworks – to save space,
    the unimportant details are omitted with the `// ...` comment. You will need familiarity
    with reading JavaScript code, but don’t worry if you don’t understand the whole
    code block. As part of reading the code, be sure to follow the links next to those
    examples to see the full implementation with all the code details. The `chapter2/README.md`
    file lists the available code resources of the chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括开源框架的示例——为了节省空间，省略了不重要的细节，这些细节用 `// ...` 注释表示。您需要熟悉阅读JavaScript代码，但如果您不理解整个代码块也不要担心。在阅读代码的过程中，请确保跟随那些示例旁边的链接查看完整的实现，包括所有代码细节。`chapter2/README.md`
    文件列出了本章可用的代码资源。
- en: In this chapter, it is suggested to try out debugging to further our expertise
    in framework structures. The easiest way to explore that on your computer would
    be by downloading the latest version of Visual Studio Code from [code.visualstudio.com](http://code.visualstudio.com).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，建议尝试调试以进一步深化我们对框架结构的理解。在您的计算机上探索这一点的最简单方法是从 [code.visualstudio.com](http://code.visualstudio.com)
    下载最新版本的Visual Studio Code。
- en: Learning about abstractions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解抽象
- en: Let’s dive into the first aspect of framework organization – the fundamental
    concept of **abstractions**. One of the main conveniences of software development
    frameworks in web development or other fields is to provide developers with high-quality
    opinionated abstractions. This means taking a task that can span multiple lines
    of code, riddled with implementation gotchas, and creating a simple interface
    around it. It also means coming up with an intelligent way of structuring independent
    interfaces into a familiar, extensible pattern that is easily usable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入框架组织的第一个方面——**抽象**的基本概念。软件开发框架在Web开发或其他领域的主要便利之一是向开发者提供高质量的、有见地的抽象。这意味着将可以跨越多行代码的任务，其中充满了实现陷阱，围绕它创建一个简单的接口。这也意味着提出一种智能的方法，将独立的接口结构化成熟悉、可扩展的、易于使用的模式。
- en: This concept of abstracting away the complexity and generalization of objects
    helps us define the building blocks that could be used for multiple purposes in
    our frameworks. Each abstracted object can be initialized with a custom set of
    properties and be utilized in many shapes when needed. Having this benefit of
    simplification and generalization in frameworks is what allows developers to focus
    on the business logic of the programs. Precisely these abstraction concepts benefit
    developers by eliminating complexity, repetition, and the challenges of learning
    new systems. Through abstractions, developers do not have to use or even learn
    the low-level components of the systems they build for.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将复杂性和对象泛化的概念抽象化的做法，帮助我们定义可以在我们的框架中用于多种目的的构建块。每个抽象对象都可以使用自定义属性集进行初始化，并在需要时以多种形状使用。在框架中拥有这种简化和泛化的好处，使得开发者能够专注于程序的商务逻辑。正是这些抽象概念通过消除复杂性、重复以及学习新系统的挑战，为开发者带来了好处。通过抽象，开发者不必使用甚至学习他们构建的系统中的低级组件。
- en: Abstractions in computer science
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的抽象
- en: In general, the concept of abstractions, a simplified representation of some
    complex mechanism, is essential in software development. This concept is taught
    early in programming courses and can be implemented in the high-level and low-level
    interfaces of large and small programs. Software abstractions structure many parts
    of these programs and dictate the program’s control flow. Data types and structures
    that define how the data is represented can be considered abstractions on top
    of lower-level object entities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，抽象的概念，即某些复杂机制简化的表示，在软件开发中是至关重要的。这个概念在编程课程中很早就被教授，并且可以在大型和小型程序的高层和低层接口中实现。软件抽象结构了这些程序中的许多部分，并决定了程序的控制流程。定义数据如何表示的数据类型和结构可以被认为是建立在较低级对象实体之上的抽象。
- en: Some programming languages offer direct syntax to write abstract classes and
    interfaces. TypeScript offers this feature as part of its extensions to JavaScript.
    This allows developers to declare *abstract* classes, methods, and fields. You
    can find some excellent examples at [www.typescriptlang.org/docs/handbook/2/classes.html](http://www.typescriptlang.org/docs/handbook/2/classes.html)
    for further reading and prototyping.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言提供了直接语法来编写抽象类和接口。TypeScript 作为其扩展 JavaScript 的一部分提供了这一功能。这允许开发者声明 *抽象*
    类、方法和字段。你可以在 [www.typescriptlang.org/docs/handbook/2/classes.html](http://www.typescriptlang.org/docs/handbook/2/classes.html)
    找到一些优秀的示例，以供进一步阅读和原型设计。
- en: If we look at the process of developing websites with bare CSS, HTML, and JavaScript
    technologies, we can already spot many pre-defined abstractions to make that process
    more easily accessible and simplified. For instance, HTML, with its elements combined
    with attributes, can quickly define hyperlinks and embed media with just a few
    lines of marked-up tags. The styling of those elements with CSS is defined by
    a set of styling rules targeting particular element nodes. We can see examples
    of web API abstractions in the **Document Object Model API**, an abstraction on
    top of a complex tree of nested nodes defining a document structure. These frontend
    technologies provide a way for user interactions inside a web browser, which generalizes
    and removes the complexity of interacting with a web application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看使用纯 CSS、HTML 和 JavaScript 技术开发网站的过程，我们就可以发现许多预定义的抽象，使这个过程更容易访问和简化。例如，HTML
    通过其元素与属性的组合，只需几行标记标签就能快速定义超链接和嵌入媒体。这些元素的样式通过一组针对特定元素节点的样式规则来定义。我们可以在 **文档对象模型
    API** 中看到 Web API 抽象的例子，这是一个在复杂嵌套节点树之上的抽象，这些节点定义了文档结构。这些前端技术为用户在网页浏览器内的交互提供了一种方式，它泛化和简化了与
    Web 应用交互的复杂性。
- en: 'We can see a simplified pyramid of abstractions here, starting from application
    code that developers write on top and rules of basic logic at the lowest level:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到一个简化的抽象层次结构，从开发者编写在最顶层的应用代码开始，到最低层的基本逻辑规则：
- en: '![Figure 2.1: Abstraction pyramid from higher- to lower-level structures](img/Figure_2.1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：从高层到低层结构的抽象层次结构](img/Figure_2.1.jpg)'
- en: 'Figure 2.1: Abstraction pyramid from higher- to lower-level structures'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：从高层到低层结构的抽象层次结构
- en: This finally brings us to JavaScript, as a high-level programming language that
    already abstracts away complexity in many ways, such as memory management, interaction
    with the browser, and general object management. In fact, some abstractions that
    compile to JavaScript focus on abstracting away even the higher-level components.
    Toolkits such as GWT and programming languages such as Elm, C#, and Dart approach
    this higher-level abstraction process by compiling to CSS, HTML, and JavaScript.
    The language extensions for ECMAScript, such as TypeScript, hold closer to JavaScript
    in terms of syntax, abstract away the common pitfalls in how we write JavaScript
    programs, and improve the overall developer experience with the addition of a
    compilation step.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终带我们来到了JavaScript，作为一种高级编程语言，它已经在许多方面抽象掉了复杂性，例如内存管理、与浏览器的交互以及一般对象管理。事实上，一些编译为JavaScript的抽象甚至关注于抽象掉更高层次的组件。例如，GWT这样的工具包和Elm、C#、Dart这样的编程语言通过编译为CSS、HTML和JavaScript来实现这一更高层次的抽象过程。ECMAScript的语言扩展，如TypeScript，在语法上更接近JavaScript，抽象掉了我们在编写JavaScript程序时常见的陷阱，并通过添加编译步骤来提高整体开发者体验。
- en: In [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we looked at several frameworks
    that use TypeScript, rely on another framework, or both to create a framework
    of a higher abstraction level. For example, Nuxt.js is a Vue.js framework, and
    it relies on TypeScript. In such cases, frameworks require developers to use these
    language extensions and their own self-defined abstractions to build the applications.
    It is interesting to ponder how deep the levels of abstractions could be nested
    when we are developing for the web platform and within the JavaScript ecosystem.
    On the frontend, we have the web browser, which manages the network request/response
    networking, draws the layout, enables interactivity, and so much more. The backend
    application services are working on top of the process and operating system infrastructure
    within the cloud server instances. The levels of abstraction keep growing as we
    zoom out to electricity flowing through wires, which delivers the required bits
    for our application code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B19014_01.xhtml#_idTextAnchor015)中，我们探讨了几个使用TypeScript的框架，这些框架依赖于另一个框架，或者两者兼而有之，以创建更高抽象级别的框架。例如，Nuxt.js是一个Vue.js框架，它依赖于TypeScript。在这种情况下，框架要求开发者使用这些语言扩展和它们自己定义的抽象来构建应用程序。当我们为Web平台和JavaScript生态系统开发时，思考抽象层次可以嵌套多深是非常有趣的。在前端，我们有网络浏览器，它管理网络请求/响应网络，绘制布局，启用交互，等等。后端应用程序服务在云服务器实例中的进程和操作系统基础设施之上运行。当我们放大到电线中的电流，它为我们应用程序代码提供所需的比特时，抽象层次会不断增长。
- en: Now that we are more familiar with abstractions and why they are used, we shall
    examine the downsides of this core pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对抽象及其用途有了更多的了解，我们将探讨这种核心模式的缺点。
- en: Downsides of abstractions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象的缺点
- en: 'We have examined the benefits of abstractions, but there are some downsides
    to consider when utilizing or implementing abstractions. These factors are also
    true for frameworks and heavily affect framework development. Let’s discuss some
    of the ways abstractions can lead you down the wrong path:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了抽象的好处，但在利用或实现抽象时，也有一些缺点需要考虑。这些因素也适用于框架，并且对框架开发有重大影响。让我们讨论一下抽象可能导致走错路的一些方式：
- en: Abstractions may be incomplete – covering all the potential use cases of an
    underlying technology with an abstraction could be difficult. For instance, if
    you have a web application framework, this could usually be a case where a niche
    feature to output HTML in a certain way could not be supported. The niche requirements
    could include rendering different types of components, such as SVG animations
    or direct DOM manipulations. Frameworks offer escape hatches to avoid these issues,
    but there could be other cases where we have to rely on the knowledge of lower-level
    components, avoiding the defined abstractions. At the same time, an abstraction
    may falsely represent the low-level system, which could lead to confusion or false
    use of the underlying concepts. For instance, if a cryptographic library wrongly
    uses the primitives, even with the correct outcomes, it could potentially introduce
    bugs.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象可能是不完整的——使用抽象覆盖底层技术的所有潜在用例可能很困难。例如，如果你有一个Web应用程序框架，这通常可能是一个无法支持以特定方式输出HTML的利基功能的情况。利基需求可能包括渲染不同类型的组件，例如SVG动画或直接DOM操作。框架提供逃生口来避免这些问题，但可能还有其他情况，我们必须依赖底层组件的知识，避免使用定义的抽象。同时，一个抽象可能错误地表示底层系统，这可能导致混淆或对底层概念的错误使用。例如，如果加密库错误地使用了原语，即使结果正确，也可能引入潜在的错误。
- en: Abstractions introduce an extra layer of code between you and the lower-level
    system, possibly affecting performance. In the case of frontend development, this
    means more code to transfer over the wire – additional function calls and layers
    of indirection. In the backend scenarios, server instances use more process memory.
    The performance may also be affected by the framework’s choice of algorithms.
    These days, performance is taken seriously by framework authors and users, and
    regular comparisons and benchmarks help deal with these drawbacks.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象引入了介于你和底层系统之间的额外代码层，可能会影响性能。在前端开发的情况下，这意味着需要通过网络传输更多的代码——额外的函数调用和间接层。在后端场景中，服务器实例使用更多的进程内存。性能也可能受到框架选择算法的影响。如今，框架作者和用户都非常重视性能，定期的比较和基准测试有助于处理这些缺点。
- en: Some of the different framework abstractions may not provide the right interfaces
    or enough control for the users, which could limit the system’s potential. It
    could be as simple as not supporting all the underlying methods of the lower-level
    interface. This issue can also happen if a chosen abstraction is used for something
    other than what it was designed for. This can also be a problem if the framework
    was designed before a certain technology was introduced. For instance, with **WebAssembly**
    support in certain frameworks, loading the WASM modules is not possible in some
    cases due to loading limitations or has to be done with external components. Introducing
    and using WebAssembly in an already established project with a lacking framework
    would be an anti-pattern.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些不同的框架抽象可能不会提供正确的接口或足够的控制给用户，这可能会限制系统的潜力。这可能是简单地不支持底层接口的所有方法。如果选择的抽象被用于其设计目的之外的事情，也可能发生这个问题。如果框架是在引入某种技术之前设计的，这也可能成为问题。例如，在某些框架中支持**WebAssembly**时，由于加载限制或必须使用外部组件，在某些情况下无法加载WASM模块。在一个缺乏框架的现有项目中引入和使用WebAssembly将是一种反模式。
- en: Specifically, patterns and abstraction ideas change quickly in the JavaScript
    ecosystem. New tools and solutions come into existence that abstract how we manage
    frontend interactions and build backend services. This means, as project owners,
    we have to adjust either to the changing platform or our existing abstractions
    become outdated. This could lead to a lack of support for some functionalities
    or just general code breakage. In many circumstances, this happens when some web
    APIs change or evolve as the web platform introduces new features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，在JavaScript生态系统中，模式和抽象思想变化很快。新的工具和解决方案出现，抽象了我们对前端交互的管理和后端服务的构建。这意味着，作为项目负责人，我们必须调整到变化中的平台，或者我们的现有抽象变得过时。这可能导致某些功能支持不足或代码普遍损坏。在许多情况下，当某些Web
    API随着Web平台引入新功能而改变或发展时，这种情况就会发生。
- en: Another downside of abstractions is the scenario where a developer may know
    how to create applications with a certain framework but knows nothing about the
    internals of the underlying technology. The hidden-away complexity can lead to
    difficulty in troubleshooting problems and in tracking down errors in the core
    of the application. Not understanding the technology behind the scenes also limits
    the developer in their ability to optimize features and take advantage of advanced
    features.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象的另一个缺点是，开发者可能知道如何使用某个框架创建应用程序，但对底层技术的内部结构一无所知。隐藏的复杂性可能导致在调试问题和追踪应用程序核心错误时遇到困难。不了解幕后技术也限制了开发者优化功能和利用高级功能的能力。
- en: We may also face so-called *leaky abstractions*. This is where the attempt to
    conceal some system complexity fully is not successful. This usually results in
    the details of the underlying system being revealed to the users of the abstraction.
    This phenomenon can lead to more complexity in the code with its own problems.
    The problem becomes evident when developers have to dig into the implementation
    details of the low-level system and try their best to figure out how the abstraction
    maps to the underlying system.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可能面临所谓的“泄漏抽象”。这是指尝试完全隐藏某些系统复杂性的尝试并不成功。这通常会导致底层系统的细节暴露给抽象的使用者。这种现象可能导致代码更加复杂，并带来自己的问题。当开发者不得不深入研究底层系统的实现细节并尽力弄清楚抽象如何映射到底层系统时，问题变得明显。
- en: Highly opinionated abstractions, in frameworks and in general, may cause issues
    when introducing additional layers of sophistication by imposing specific design
    choices that the developer may disagree with but is unable to change. These can
    limit the reusability and flexibility of the application code. If we look at Next.js,
    it provides highly opinionated solutions for several of its features. For example,
    if you are planning to add API routes to build an API in the Next.js project,
    these must be mapped to an `/api/` endpoint. To learn more about that, check out
    [nextjs.org/docs/api-routes/introduction](http://nextjs.org/docs/api-routes/introduction).
    This is a simple example, but hopefully it illustrates this drawback well.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在框架和一般情况下的高度主观抽象可能会在引入更复杂的层级时引发问题，因为它们强加了一些开发者可能不同意但无法更改的具体设计选择。这些选择可能会限制应用程序代码的可重用性和灵活性。如果我们看看Next.js，它为其许多功能提供了高度主观的解决方案。例如，如果你计划在Next.js项目中添加API路由来构建API，这些路由必须映射到`/api/`端点。要了解更多信息，请查看[Next.js官方文档](http://nextjs.org/docs/api-routes/introduction)。这是一个简单的例子，但希望它能很好地说明这一缺点。
- en: No matter where you introduce the use of an abstraction, it does add an extra
    layer of complexity and indirectness to what we are trying to interface with.
    When we add abstractions through various means, this makes our projects dependent
    on them. This dependency may create certain complications. With an external abstraction,
    we have to accept the risks and trade-offs that come with using it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在哪里引入抽象的使用，它都会给我们要与之交互的事物增加一个额外的复杂性和间接性层级。当我们通过各种方式添加抽象时，这使得我们的项目依赖于它们。这种依赖可能会产生某些复杂性。使用外部抽象时，我们必须接受使用它所带来的风险和权衡。
- en: In the next section, we are going to look at the popular abstracted building
    blocks, which are often used in framework development and are exposed as public
    interfaces of frameworks. We will dive into the frontend browser APIs and the
    backend runtime modules to better understand what frameworks utilize to build
    their own abstractions. This is a useful exercise because it helps us figure out
    how these frameworks function and what techniques they use to combine different
    tools together. These exercises in tracing the framework organization are valuable
    to becoming a domain expert in frameworks and understanding the underlying technology
    behind them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨流行的抽象构建块，这些构建块通常用于框架开发，并作为框架的公共接口暴露出来。我们将深入研究前端浏览器API和后端运行时模块，以更好地理解框架利用什么来构建自己的抽象。这是一项有用的练习，因为它帮助我们了解这些框架的工作原理以及它们使用哪些技术将不同的工具组合在一起。这些追踪框架组织的练习对于成为框架领域的专家以及理解其背后的技术至关重要。
- en: Building blocks of abstractions in JavaScript
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中抽象的构建块
- en: In this section, we will discuss some detailed abstraction examples in JavaScript,
    as well as web APIs, and features that are used as the building blocks and foundational
    components of abstractions in frameworks. Framework and browser developers put
    a lot of thought and hard work into defining these abstractions, which allow developers
    to be really crafty, produce well-organized code, and build great products.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些JavaScript中的详细抽象示例，以及Web API和作为框架中抽象构建块和基础组件的功能。框架和浏览器开发者投入了大量思考和辛勤工作来定义这些抽象，这些抽象使开发者能够真正巧妙地编写代码，构建有组织的代码，并创建出色的产品。
- en: Frontend framework abstractions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端框架抽象
- en: 'With these three technologies – HTML, CSS, and JavaScript – that enable website
    development, we get plenty of building blocks that already abstract away the challenges
    of publishing something on the web. However, we do not get a particular, well-structured,
    opinionated way to build complex web application projects. This is where the frontend
    frameworks primarily fill the void that is lacking in the core technologies provided
    by the web. The frontend frameworks create abstractions in these two cases:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些三种技术——HTML、CSS和JavaScript——它们使网站开发成为可能，我们得到了许多构建块，这些构建块已经抽象化了在网络上发布内容的挑战。然而，我们并没有得到一种特定、结构良好、有见地的构建复杂Web应用程序项目的方法。这正是前端框架主要填补了由网络核心技术提供的空白。在前端框架中，这两种情况下创建了抽象：
- en: On top of existing web APIs, which are built into the web browser or a JavaScript
    runtime.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有的网络API之上，这些API内置在网页浏览器或JavaScript运行时中。
- en: When new abstractions are built from scratch based on the framework’s internals
    and opinionated definitions. The innovative and unique approach to these abstractions
    is what makes a particular framework desirable and liked among developers.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从头开始基于框架的内部结构和有见地的定义构建新的抽象时。这些抽象的创新和独特方法使得特定的框架在开发者中变得受欢迎和喜爱。
- en: 'The following web APIs provided by the browser engines are often abstracted
    by frontend frameworks:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器引擎提供的以下Web API通常被前端框架抽象化：
- en: '**Document Object Model** (**DOM**) – This allows manipulation of the web page’s
    structure. The DOM represents a tree where the nodes constrain the objects. The
    DOM API provides access and the ability to modify this logical tree. The user
    interface frameworks primarily need this to display the rendered views and handle
    DOM interactions and events. Even the frameworks that use a virtual DOM need to
    attach their structures to the real document to make it visible on the page.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）——这允许操作网页的结构。DOM表示一个树，其中的节点约束对象。DOM API提供了访问和修改这个逻辑树的能力。用户界面框架主要需要这个来显示渲染的视图和处理DOM交互和事件。即使是使用虚拟DOM的框架，也需要将它们的结构附加到真实文档上，以便在页面上可见。'
- en: '`document` property. The browser also provides complex APIs, such as the WebAssembly
    API, which lets applications include binary-code modules. The frameworks usually
    have a loader for these low-level modules as part of their loader workflow.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document`属性。浏览器还提供了复杂的API，例如WebAssembly API，它允许应用程序包含二进制代码模块。框架通常将这些底层模块的加载器作为其加载工作流程的一部分。'
- en: '`document.body.style.color = ''pink'';`. This object model also offers several
    method calls such as `getComputedStyle();` to fetch information about the object’s
    style.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.body.style.color = ''pink'';`。这个对象模型还提供了几个方法调用，如`getComputedStyle();`来获取有关对象样式的信息。'
- en: '**Network APIs** – These APIs have the ability to make asynchronous network
    requests using the Fetch API or the XMLHttpRequest API. Frameworks utilize these
    for basic networking operations, including structuring complex requests using
    GraphQL. The networking APIs also offer **WebSocket** functionality. These APIs
    provide full-duplex (data can be transmitted and received simultaneously) communications
    with less overhead than usual networking calls, enabling applications with real-time
    updates and communication. The WebSocket API is simple enough that it can be used
    directly in the applications or with the inclusion of an extension package for
    a particular framework. **Socket.io** builds on top of WebSocket APIs and offers
    a complete low-latency solution that can coexist with the framework code. Finally,
    **WebRTC** also fits into the category of networking APIs, and it enables the
    capturing and streaming of audio and video content in the browser. Similar to
    WebSockets, the WebRTC framework integration is usually included with an external
    library because it is quite a subtle feature.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络 API** – 这些 API 具有使用 Fetch API 或 XMLHttpRequest API 进行异步网络请求的能力。框架利用这些
    API 进行基本的网络操作，包括使用 GraphQL 结构复杂请求。网络 API 还提供了 **WebSocket** 功能。这些 API 提供了比常规网络调用更少的开销的全双工（数据可以同时发送和接收）通信，使得具有实时更新和通信的应用程序成为可能。WebSocket
    API 足够简单，可以直接在应用程序中使用或在特定框架中包含扩展包。**Socket.io** 建立在 WebSocket API 之上，提供了一个完整的低延迟解决方案，可以与框架代码共存。最后，**WebRTC**
    也属于网络 API 的范畴，它允许在浏览器中捕获和流式传输音频和视频内容。与 WebSocket 类似，WebRTC 框架集成通常包含在外部库中，因为它是一个非常微妙的特性。'
- en: '**Storage APIs** – These APIs have the ability to store data for web application
    and caching purposes. These APIs are often utilized to store data in the local
    and session storages. They also write to browser cookies and databases, such as
    **IndexedDB**. For instance, Angular applications can include a dependency that
    provides a cookie service and makes it easier to read and write cookie information.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储 API** – 这些 API 具有存储数据以供 Web 应用程序和缓存使用的能力。这些 API 通常用于在本地和会话存储中存储数据。它们还写入浏览器
    Cookie 和数据库，如 **IndexedDB**。例如，Angular 应用程序可以包含一个提供 Cookie 服务并使读取和写入 Cookie 信息更简单的依赖项。'
- en: '**Background services** – These include a slew of services that enable background
    synchronization of data, notifications, push messaging, and more. Web workers
    generally provide a way to run background-independent scripts and make use of
    multiple CPU cores.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台服务** – 这些包括一系列服务，可以启用数据的后台同步、通知、推送消息等。Web workers 通常提供了一种运行后台独立脚本并利用多个
    CPU 核心的方法。'
- en: '**Graphics APIs** – These APIs grant the ability to render high-performance
    3D and vector graphics. These include the **WebGL** APIs and **SVG** elements.
    The 3D graphics libraries utilize the *canvas* element for rendering and can utilize
    the graphics hardware. For applications built with Vue.js, there is an additional
    component library called VueGL that makes it easier to create WebGL-based components.
    In terms of SVG, JSX in React is able to directly parse SVG syntax, as long as
    the SVG properties are converted to the camel-case JavaScript syntax.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形 API** – 这些 API 允许渲染高性能的 3D 和矢量图形。这包括 **WebGL** API 和 **SVG** 元素。3D 图形库使用
    *canvas* 元素进行渲染，并可以利用图形硬件。对于使用 Vue.js 构建的应用程序，还有一个额外的组件库称为 VueGL，它使得创建基于 WebGL
    的组件更加容易。至于 SVG，React 中的 JSX 能够直接解析 SVG 语法，只要将 SVG 属性转换为 camel-case JavaScript
    语法即可。'
- en: A useful, in-depth list of web APIs that frameworks can potentially utilize
    can be found at [developer.mozilla.org/docs/Web/API](http://developer.mozilla.org/docs/Web/API).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [developer.mozilla.org/docs/Web/API](http://developer.mozilla.org/docs/Web/API)
    找到框架可能利用的有用、深入的 Web API 列表。
- en: Let’s now take a look at a real-world frontend example with Nuxt.js.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个使用 Nuxt.js 的真实世界前端示例。
- en: Real-world examples
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实世界的示例
- en: 'Nuxt.js uses Vue as a backbone for its frontend components. As shown in *Figure
    2**.2*, the Nuxt.js framework has the `NuxtLink` built-in component for creating
    links, which can be used in application code, and utilizes several modules from
    Vue, such as the `vue-router` and component-building functions such as `defineComponent`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt.js 使用 Vue 作为其前端组件的骨干。如图 *图 2.2* 所示，Nuxt.js 框架内置了 `NuxtLink` 组件用于创建链接，这些链接可以在应用代码中使用，并且利用了
    Vue 的几个模块，例如 `vue-router` 和组件构建功能，如 `defineComponent`：
- en: '![Figure 2.2: Nuxt.js and Vue framework abstraction](img/Figure_2.2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：Nuxt.js 和 Vue 框架抽象](img/Figure_2.2.jpg)'
- en: 'Figure 2.2: Nuxt.js and Vue framework abstraction'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：Nuxt.js和Vue框架抽象
- en: 'We can follow the usage of this abstraction (*Figure 2**.2*) in detail from
    an `example.vue` page in application code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从应用代码中的`example.vue`页面详细跟踪这个抽象的使用（*图2.2*）：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run this particular code example on your computer, navigate to the `chapter2/nuxt-js-application`
    directory and run `npm install && npm run dev`. Refer to the included `chapter2/README.md`
    documentation for additional details. Once the application is ready to run locally,
    you should see the URL that you can open in your browser in the terminal. Here’s
    an example of the successful output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的计算机上运行这个特定的代码示例，请导航到`chapter2/nuxt-js-application`目录并运行`npm install && npm
    run dev`。有关更多详细信息，请参阅包含的`chapter2/README.md`文档。一旦应用程序准备就绪，您应该在终端中看到可以打开的URL。以下是一个成功输出的示例：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The auto-import feature of the framework allows the direct use of the component
    to create the two links in the template file. This built-in component is defined
    in the source of the Nuxt framework at [github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts](http://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的自动导入功能允许直接在模板文件中使用组件创建两个链接。这个内置组件在Nuxt框架的源代码中定义，位于[github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts](http://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts)。
- en: 'Let us take a moment to understand the `nuxt-link` component code, following
    along with the source from the framework itself. The code behind this particular
    component extends the routing behavior from Vue.js. It defines the typed TypeScript
    interfaces, such as `NuxtLinkOptions` and `NuxtLinkProps`, to accept particular
    styling attributes and routing options. The `defineNuxtLink` function returns
    the component with the customized routing behavior. Helper functions, such as
    `checkPropConflicts` and `resolveTrailingSlashBehavior`, address specific routing
    use cases. The `setup()` function call uses the Vue 3 Composition API to enable
    reactive properties of the component and attach component lifecycle hooks to versions
    of `NuxtLink` in applications. More details on this API can be found in Vue.js’
    documentation – [vuejs.org/guide/extras/composition-api-faq.html](http://vuejs.org/guide/extras/composition-api-faq.html).
    The important parts are shown in a condensed form here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来理解`nuxt-link`组件代码，跟随框架本身的源代码。这个特定组件的代码扩展了Vue.js的路由行为。它定义了如`NuxtLinkOptions`和`NuxtLinkProps`这样的类型化TypeScript接口，以接受特定的样式属性和路由选项。`defineNuxtLink`函数返回具有定制路由行为的组件。如`checkPropConflicts`和`resolveTrailingSlashBehavior`这样的辅助函数处理特定的路由用例。`setup()`函数调用使用Vue
    3组合API来启用组件的响应式属性并将组件生命周期钩子附加到应用中的`NuxtLink`版本。更多关于这个API的细节可以在Vue.js的文档中找到 – [vuejs.org/guide/extras/composition-api-faq.html](http://vuejs.org/guide/extras/composition-api-faq.html)。这里以压缩形式展示了重要部分：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding component code, we see the final return statement of `defineComponent`.
    This generates the anchor `<a>` element that we ultimately see in the final source
    of the HTML structure in the web application. It is produced by the internal Vue.js
    function call:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的组件代码中，我们看到`defineComponent`的最终返回语句。这生成了我们在Web应用程序HTML结构最终源代码中看到的锚点`<a>`元素。它是由Vue.js内部函数调用生成的：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the `defineNuxtLink` function, it is also evident that it is possible to
    modify some parts of the component. For example, we can define a component with
    a custom name using the `componentName` parameter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从`defineNuxtLink`函数中也可以明显看出，可以修改组件的一些部分。例如，我们可以使用`componentName`参数定义一个具有自定义名称的组件。
- en: From [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we’ve seen that JavaScript
    has much to offer for full stack frameworks. In the next section, we are going
    to look at the APIs that we can utilize as part of the backend environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第一章*](B19014_01.xhtml#_idTextAnchor015)，我们已经看到JavaScript为全栈框架提供了很多。在下一节中，我们将探讨可以作为后端环境一部分利用的API。
- en: Backend runtime abstractions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端运行时抽象
- en: Although there are many frontend APIs to choose from, we are still bound by
    what the web browser supports. This is a lesser issue when we write backend services,
    as there are still many APIs that we can use, and we can even write our own extensions
    or integrate with external systems for custom use cases. Let’s take a look at
    important APIs that we can use as part of framework development.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有众多前端API可供选择，但我们仍然受限于网络浏览器支持的功能。当我们编写后端服务时，这是一个较小的问题，因为我们仍然可以使用许多API，我们甚至可以编写自己的扩展或与外部系统集成以用于定制用例。让我们看看可以作为框架开发一部分使用的重要API。
- en: 'In this section, we will look at both **Node.js** and **Deno**, as they are
    two runtimes that offer similar features. These runtimes need to handle server
    creation, file and process management, module packaging, and more. The following
    are some of the essential APIs that are used by the backend frameworks:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨**Node.js**和**Deno**，因为它们是提供类似功能的两个运行时。这些运行时需要处理服务器创建、文件和进程管理、模块打包等。以下是一些后端框架使用的必要API：
- en: '**Filesystem APIs** – This has the ability to read and write files and other
    file system entities. Frameworks use this heavily while storing data, loading
    existing files, and serving static content. These APIs also include file streaming
    and asynchronous features.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统API** – 这具有读取和写入文件以及其他文件系统实体的能力。框架在存储数据、加载现有文件和提供静态内容时，会大量使用这些API。这些API还包括文件流和异步功能。'
- en: '**Networking** – These are the APIs to start new server processes and accept
    requests. Includes handling of HTTP requests and other request formats.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络** – 这些是启动新的服务器进程和接受请求的API。包括处理HTTP请求和其他请求格式。'
- en: '**Modules and packaging** – These are the conventions of how modules and packages
    can be loaded.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块和打包** – 这些是模块和包可以加载的约定。'
- en: '**Operating system APIs** – These are the APIs to fetch information from the
    operating system that is running the process. This includes useful data about
    memory consumption and useful operating system directories.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统API** – 这些是从运行进程的操作系统获取信息的API。这包括有关内存消耗的有用数据和有用的操作系统目录。'
- en: '**Process handling** – These APIs allow for manipulating and gathering details
    of the currently running process. These also enable sub-process creation and handling
    of multi-process communication.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程处理** – 这些API允许操作和收集当前运行进程的详细信息。这些API还支持子进程创建和多进程通信的处理。'
- en: '**Native modules** – The native module APIs allow users to call out to libraries
    written in other native languages, such as C/C++, Rust, and others. In some cases,
    they use the **Foreign Function Interface** (**FFI**). WebAssembly is also part
    of this native module support.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生模块** – 原生模块API允许用户调用用其他原生语言编写的库，例如C/C++、Rust等。在某些情况下，它们使用**外部函数接口**（**FFI**）。WebAssembly也是原生模块支持的一部分。'
- en: '**Worker APIs** – Allows the spawning of additional worker threads to schedule
    heavy server work to happen outside of the main process. For instance, the Deno
    runtime supports the **Web Worker API** to provide these features, while Node.js
    uses its **Worker** **Threads** module.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作线程API** – 允许生成额外的工作线程，以便在主进程之外调度重负载服务器工作。例如，Deno运行时支持**Web Worker API**以提供这些功能，而Node.js使用其**工作线程**模块。'
- en: '**Console and debugging** – This set of internal APIs allows for recording
    process logs. The debugging APIs make developing and finding issues in the running
    code easier. Paired with an editor that supports debugging operations, it can
    pause the debugger when the framework request handler is processing a request.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台和调试** – 这组内部API允许记录进程日志。调试API使得开发和查找运行代码中的问题更加容易。与支持调试操作的编辑器配合使用，可以在框架请求处理器处理请求时暂停调试器。'
- en: These are some of the APIs that backend frameworks can use as the foundation
    for their projects. For instance, the hapi.js framework is able to combine some
    of these APIs to create its `Server`, `Route`, `Request`, and `Plugin` modules.
    For example, its `Core` ([hapi/lib/core.js](http://hapi/lib/core.js)) module makes
    use of the operating system, networking, and module-handling APIs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些后端框架可以作为项目基础使用的API。例如，hapi.js框架能够结合一些这些API来创建其`Server`、`Route`、`Request`和`Plugin`模块。例如，其`Core`（[hapi/lib/core.js](http://hapi/lib/core.js)）模块利用了操作系统、网络和模块处理API。
- en: Next, we can take a look at a detailed example of combinations of abstractions
    and runtime APIs in Nest.js, a framework that is familiar to us from [*Chapter
    1*](B19014_01.xhtml#_idTextAnchor015).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看看 Nest.js 中抽象和运行时 API 组合的详细示例，这是一个我们熟悉的框架，见 [*第 1 章*](B19014_01.xhtml#_idTextAnchor015)。
- en: Backend framework abstractions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端框架抽象
- en: The Nest.js framework supports the ability to provide any HTTP framework as
    long as there is an adapter defined to work with it. The existing adapters that
    are built right into Nest.js are `platform-express` and `platform-fastify`. The
    default behavior of the HTTP adapter abstraction is transparent to the developer
    as it uses the `express` module by default.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js 框架支持提供任何 HTTP 框架的能力，只要定义了与其一起工作的适配器。直接嵌入 Nest.js 的现有适配器是 `platform-express`
    和 `platform-fastify`。HTTP 适配器抽象的默认行为对开发者来说是透明的，因为它默认使用 `express` 模块。
- en: 'In *Figure 2**.3*, we can see the combination of all the components. The application
    code is powered by the framework that utilizes both the framework abstractions
    and the Node.js API:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 2**.3* 中，我们可以看到所有组件的组合。应用程序代码由利用框架抽象和 Node.js API 的框架提供支持：
- en: '![Figure 2.3: Nest.js framework abstractions](img/Figure_2.3.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3：Nest.js 框架抽象](img/Figure_2.3.jpg)'
- en: 'Figure 2.3: Nest.js framework abstractions'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：Nest.js 框架抽象
- en: 'As shown in *Figure 2**.3*, the `main.ts` entry point file in Nest.js starts
    the server and listens for incoming requests:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 2**.3* 所示，Nest.js 的 `main.ts` 入口文件启动服务器并监听传入的请求：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`express-adapter`, which extends from `AbstractHttpAdapter`, defines the set
    of methods required for the HTTP server, including the `.``listen` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`express-adapter`，它从 `AbstractHttpAdapter` 扩展而来，定义了 HTTP 服务器所需的方法集，包括 `.listen`
    方法：'
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The adapter code above utilizes the `express` framework and the internal `http`
    APIs. Ultimately, this results in a class that exposes a method to set up an HTTP
    server. Even though `express` provides the routing and HTTP helpers, it does not
    start the server by itself. Inside `express-adapter`, there is a direct call to
    Node.js APIs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的适配器代码利用了 `express` 框架和内部 `http` API。最终，它产生了一个公开设置 HTTP 服务器方法的类。尽管 `express`
    提供了路由和 HTTP 辅助函数，但它本身并不启动服务器。在 `express-adapter` 中，有一个直接调用 Node.js API：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The direct call in the preceding code block figures out the type of server to
    start, *HTTP* or *HTTPS*. It also accepts a variety of `httpOptions` values. This
    pattern is similar in other frameworks. For instance, in AdonisJS, the framework
    authors define the `HttpServer` class ([github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts](http://github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts))
    that creates an HTTP server and utilizes the `createHttpServer` utility function
    to call out to the runtime APIs of Node.js.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码块中的直接调用确定要启动的服务器类型，*HTTP* 或 *HTTPS*。它还接受各种 `httpOptions` 值。这种模式在其他框架中也很相似。例如，在
    AdonisJS 中，框架作者定义了 `HttpServer` 类 ([github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts](http://github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts))，该类创建
    HTTP 服务器并使用 `createHttpServer` 工具函数调用 Node.js 的运行时 API。
- en: As we dig in further to understand how existing frameworks are structured and
    how their abstractions work, it is important to have a way of traversing the code
    of these nested abstractions. In the next section, we will cover the technique
    of debugging, which can help us uncover the hidden interfaces within the frameworks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步了解现有框架的结构和它们的抽象如何工作的时候，有一种方法可以遍历这些嵌套抽象的代码是非常重要的。在下一节中，我们将介绍调试技术，这可以帮助我们揭示框架中的隐藏接口。
- en: About debugging
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于调试
- en: Debugging plays an important role in software development. It helps us identify
    and resolve issues quickly. As part of the framework learning process, it also
    helps us understand how these frameworks work internally. By stepping through
    the breakpoints of the program and digging deep into the call stack, we can understand
    the inner workings of the internal modules. It also helps us navigate through
    multiple levels of abstractions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调试在软件开发中扮演着重要的角色。它帮助我们快速识别和解决问题。作为框架学习过程的一部分，它还帮助我们了解这些框架的内部工作方式。通过逐步执行程序的断点并深入调用堆栈，我们可以理解内部模块的内部工作原理。它还帮助我们穿越多个抽象层次。
- en: 'Node.js’ debugger integration provides a way for us to debug our programs and
    frameworks. It is a good habit to try it out on your own to get a better understanding
    of how the framework functions. For example, to debug a Nest.js application, we
    can utilize the Visual Studio Code debugger:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的调试器集成为我们提供了调试程序和框架的方法。自己尝试一下是一个好习惯，这样你可以更好地了解框架的工作方式。例如，要调试Nest.js应用，我们可以利用Visual
    Studio Code调试器：
- en: Open up the `nest-js-application` project in the `framework-organization` directory
    of the book’s GitHub repository.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在书的GitHub仓库的`framework-organization`目录中打开`nest-js-application`项目。
- en: Run `npm install` to get the project’s dependencies.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`以获取项目的依赖项。
- en: Set a code execution breakpoint in the `app.service.ts` file of the application;
    refer to the screenshot in *Figure* *2**.5*. To set the breakpoint, hit the empty
    space to the left of the line number until you see a red dot. Once this red dot
    appears, that will be your breakpoint.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用的`app.service.ts`文件中设置代码执行断点；参考*图2.5*中的截图。要设置断点，点击行号左侧的空白区域，直到你看到一个红色圆点。一旦出现红色圆点，那将是你的断点。
- en: 'In Visual Studio Code, browse to the `package.json` file, and press the `scripts`
    section. See an example of this in *Figure 2**.4*:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，浏览到`package.json`文件，并按`scripts`部分。在*图2.4*中查看此示例：
- en: '![Figure 2.4: Debug button in package.json](img/Figure_2.4.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：package.json中的调试按钮](img/Figure_2.4.jpg)'
- en: 'Figure 2.4: Debug button in package.json'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：package.json中的调试按钮
- en: After pressing the `start:dev` option, which should start the application, observable
    in the `nest` command is not found, that means you need to install the dependencies
    for this project using `npm install`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按下`start:dev`选项后，这应该会启动应用，但在`nest`命令中找不到可观察项，这意味着你需要使用`npm install`安装此项目的依赖项。
- en: With the application running in debug mode and using the `start:dev` script,
    open the address at `http://127.0.0.1:3000` in your browser. This should now pause
    on the extract line of your breakpoint.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用以调试模式运行并使用`start:dev`脚本时，在浏览器中打开`http://127.0.0.1:3000`地址。现在应该会在你的断点提取行上暂停。
- en: 'If you hit a breakpoint properly in the editor, that means you successfully
    attached the debugger to the application. You can now use the call stack pane
    on the left (as shown in *Figure 2**.5*) to navigate around the running process
    and browse through the Nest.js modules:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地触发了编辑器中的断点，这意味着你成功地将调试器附加到了应用上。现在你可以使用左侧的调用堆栈窗格（如图2.5所示）在运行进程周围导航并浏览Nest.js模块：
- en: '![Figure 2.5: Debugging a Nest.js application](img/Figure_2.5.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：调试Nest.js应用](img/Figure_2.5.jpg)'
- en: 'Figure 2.5: Debugging a Nest.js application'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：调试Nest.js应用
- en: This technique is a quick way to get a view behind the scenes of a framework.
    It enables developers to quickly get a sense of how the framework functions and
    makes it easier to understand the nested abstractions. To get more from it, you
    can find an in-depth explanation of the Visual Studio Code debugger at [code.visualstudio.com/docs/editor/debugging](http://code.visualstudio.com/docs/editor/debugging).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是快速了解框架幕后视图的一种方法。它使开发者能够快速了解框架的工作方式，并使理解嵌套抽象变得更加容易。要从中获得更多，你可以在[code.visualstudio.com/docs/editor/debugging](http://code.visualstudio.com/docs/editor/debugging)找到Visual
    Studio Code调试器的深入解释。
- en: Framework building blocks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架构建块
- en: Just like most programming languages, JavaScript, and its extensions such as
    TypeScript, have the fundamental features of working with numbers, strings, Booleans,
    conditional logic statements, and much more. The more advanced features are built
    on top of those fundamentals. The frameworks utilize existing interfaces, such
    as events and modules. However, they also create their own build blocks, by defining
    interfaces to create components, routers, and others.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数编程语言一样，JavaScript及其扩展，如TypeScript，具有处理数字、字符串、布尔值、条件逻辑语句等基本功能。更高级的功能建立在这些基础之上。框架利用现有的接口，如事件和模块。然而，它们也通过定义接口来创建自己的构建块，以创建组件、路由等。
- en: In this section, we are going to examine both existing interfaces and custom
    ones. We are going to look at some of the common interfaces, which can be combined
    to make a framework. These are the abstracted entities that solve particular problems
    in application development and are beneficial to their users.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查现有的接口和自定义接口。我们将查看一些常见的接口，这些接口可以组合起来形成一个框架。这些是抽象实体，它们解决了应用开发中的特定问题，并且对用户有益。
- en: Events
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'Event binding and events are everywhere in JavaScript applications. They enable
    frontend user interfaces and interactivity through buttons, forms, pointer movement,
    keyboard keys, scrolling, and more. The concept of event binding is something
    that every framework handles with different syntax definitions as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定和事件在JavaScript应用程序中无处不在。它们通过按钮、表单、指针移动、键盘键、滚动等方式启用前端用户界面和交互性。事件绑定的概念是每个框架都通过不同的语法定义来处理的，如下所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Most of the time, the event handling is very similar to original DOM events,
    but with a modified syntax to fit the framework abstractions better. Frameworks
    further enable event handling by providing more complex event management components.
    For example, Angular has the concept of `HostListener` ([angular.io/api/core/HostListener](http://angular.io/api/core/HostListener))
    to register events within its components.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，事件处理与原始DOM事件非常相似，但语法经过修改以更好地适应框架抽象。框架通过提供更复杂的事件管理组件来进一步启用事件处理。例如，Angular有`HostListener`的概念（[angular.io/api/core/HostListener](http://angular.io/api/core/HostListener)），用于在其组件内注册事件。
- en: On the server side, Node.js is heavily event-based because of its asynchronous,
    event-driven architecture and the frameworks take advantage of that. For example,
    hapi.js maintains its own event emitter package called `@hapi/podium`, which allows
    the developers to register custom application events.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，Node.js由于其异步、事件驱动的架构而高度基于事件，框架利用了这一点。例如，hapi.js维护自己的事件发射器包，称为`@hapi/podium`，允许开发者注册自定义应用程序事件。
- en: 'Another example of the event handling pattern would be how the `change` and
    `navigation` events to report the latest values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理模式的另一个例子将是如何报告最新值的`change`和`navigation`事件：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The use of events is an important building block, which allows us to subscribe
    to user interaction and listen to the changes or progress of some operation. As
    we are set on developing our own framework, it needs to provide a way to interact
    with events and abstract certain complexities around them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的使用是一个重要的构建块，它允许我们订阅用户交互并监听某些操作的更改或进度。既然我们决定开发自己的框架，它需要提供一种与事件交互并抽象它们周围某些复杂性的方法。
- en: Components
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: Many frameworks provide an abstraction to create reusable components to organize
    the project. Depending on how the application is planned out, components can help
    split any type of application into reusable and independent pieces of code. These
    code parts can also be nested within each other. Depending on the required business
    logic, developers can define custom components, use the pre-built ones, or import
    a library of components that are designed for specific use. Once many components
    are nested and situated together, it is common to have some interaction between
    these objects. The components utilize data properties to render the information
    to the user from the current state, and in many cases, they need some properties
    from the parent components. For frameworks that use React or Vue, this means writing
    communication patterns that enable child-to-parent component communication and
    the other way around. This communication process can get complicated, which is
    why these frameworks use a unidirectional or a one-way data flow where the data
    updates flow from parent to child components. Instead of synchronizing the same
    state between nested components, it is advised to store the state in the most
    common ancestor component in the chain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 许多框架提供抽象来创建可重用组件以组织项目。根据应用程序的计划，组件可以帮助将任何类型的应用程序拆分为可重用和独立的代码片段。这些代码部分也可以相互嵌套。根据所需业务逻辑，开发者可以定义自定义组件、使用预构建的组件或导入为特定用途设计的组件库。一旦许多组件嵌套并放置在一起，这些对象之间通常会有一些交互。组件利用数据属性从当前状态向用户渲染信息，在许多情况下，它们需要从父组件中获取某些属性。对于使用React或Vue的框架，这意味着编写通信模式，以实现子组件到父组件以及相反方向的通信。这个过程可能会变得复杂，这就是为什么这些框架使用单向或单程数据流，其中数据更新从父组件流向子组件组件。与其在嵌套组件之间同步相同的状态，不如建议在链中最常见的祖先组件中存储状态。
- en: If we have a complex application, this means that we will probably end up with
    a lot of components, nested multiple levels deep. This is where **component composition**
    can help. Component composition is a pattern that allows for minimal code duplication,
    and performance improvements.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个复杂的应用程序，这意味着我们可能最终会有很多组件，嵌套多层。这就是 **组件组合** 可以帮助的地方。组件组合是一种允许最小化代码重复并提高性能的模式。
- en: 'In the following figure, we have an illustrative example of how composition
    can affect and reorganize a set of nested components within an application. The
    component organization pattern is very familiar to developers, so it would be
    a good choice to use or create a framework utilizing this pattern:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们有一个说明性的例子，说明了组合如何影响和重新组织应用程序内嵌套组件的集合。组件组织模式对开发者来说非常熟悉，因此使用或创建利用此模式的框架将是一个不错的选择：
- en: "![Figure \uFEFF2.6: Nested versus composed components](img/Figure_2.6.jpg)"
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6：嵌套与组合组件](img/Figure_2.6.jpg)'
- en: 'Figure 2.6: Nested versus composed components'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：嵌套与组合组件
- en: Lifecycle methods
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期方法
- en: Lifecycle methods or events are often managed by the framework, providing the
    ability to execute code at particular points. These methods can be used to execute
    custom logic at different stages of components and other parts of the system,
    which provides flexibility to the framework interfaces. These lifecycle methods
    can be used to attach or detach additional logging, utility functions, and more
    during the component execution. Lifecycle sequence, which means the order of how
    these events occur, must be well documented and described in the framework. This
    is done mostly due to the fact that the lifecycle methods can have a particular
    naming convention and have a complex runtime hierarchy.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期方法或事件通常由框架管理，提供在特定点执行代码的能力。这些方法可以用于在组件和其他系统的不同阶段执行自定义逻辑，这为框架接口提供了灵活性。这些生命周期方法可以在组件执行期间附加或分离额外的日志、实用函数等。生命周期序列，即这些事件发生的顺序，必须在框架中得到良好的文档和描述。这主要是因为生命周期方法可以遵循特定的命名约定，并且具有复杂的运行时层次结构。
- en: 'In Nest.js, the server framework provides lifecycle hooks to its module system.
    Some examples of that are `onApplicationBootstrap()`, which is called when all
    modules in the application have been initialized, and `onModuleInit()`, which
    is called when the dependencies of a module have been resolved. Using the TypeScript
    interfaces in Nest.js, we can inject code into the `onApplicationShutdown` lifecycle
    event as all connections to the server close down, which can be defined as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Nest.js 中，服务器框架为其模块系统提供了生命周期钩子。其中的例子包括 `onApplicationBootstrap()`，它在所有模块在应用程序中初始化时被调用，以及
    `onModuleInit()`，它在模块的依赖关系被解决时被调用。使用 Nest.js 中的 TypeScript 接口，我们可以在所有连接到服务器关闭时注入代码到
    `onApplicationShutdown` 生命周期事件中，这可以定义如下：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Vue.js, given that the framework deals with rendering components, the events
    available cover the whole lifetime of the component. For instance, it has `beforeCreate`,
    `created` events as the component initializes its state, and `beforeMount`, `mounted`
    events as the component gets mounted to the DOM tree. You can find a great lifecycle
    diagram of Vue.js at [vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram](http://vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中，由于框架处理组件的渲染，可用的事件涵盖了组件的整个生命周期。例如，它有 `beforeCreate`、`created` 事件，组件初始化其状态时触发，以及
    `beforeMount`、`mounted` 事件，组件被挂载到 DOM 树上时触发。你可以在 [vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram](http://vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram)
    找到 Vue.js 的一个很好的生命周期图。
- en: Router
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: Both frontend and backend frameworks usually require some form of a router that
    navigates to different parts of the application. The router mechanism on the frontend
    follows the navigational pattern of web pages, following the browser’s URL patterns.
    On the frontend, the router is essential to transition between states or navigate
    to internal or external pages. Besides providing the routing *tree* structure,
    the router is also responsible for interfaces that allow components to invoke
    the routing behaviors – we saw an example of this via `NuxtLink` in the *Real-world
    Examples* section of this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端框架通常都需要某种形式的路由器，以导航到应用程序的不同部分。前端的路由机制遵循网页的导航模式，遵循浏览器的URL模式。在前端，路由器对于在状态之间转换或导航到内部或外部页面至关重要。除了提供路由*树*结构外，路由器还负责提供接口，允许组件调用路由行为——我们通过本章“实际示例”部分的`NuxtLink`示例看到了这一点。
- en: 'The **react-router** ([reactrouter.com/main/start/overview](http://reactrouter.com/main/start/overview))
    project is a good example of everything you need from a router component. It makes
    it possible to simply define the routes within a component as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**react-router** ([reactrouter.com/main/start/overview](http://reactrouter.com/main/start/overview))项目是路由组件所需一切的良好示例。它使得在组件内简单地定义路由成为可能，如下所示：'
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The backend server frameworks use a server router to handle requests coming
    to API endpoints. Normally, the router interface takes different forms of endpoint
    URL structures and maps those into functions that process the route. Some good
    examples of an unopinionated router can be found in Express.js ([expressjs.com/guide/routing.html](http://expressjs.com/guide/routing.html)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务器框架使用服务器路由来处理发送到API端点的请求。通常，路由接口采用不同的端点URL结构形式，并将这些映射到处理路由的函数。在Express.js([expressjs.com/guide/routing.html](http://expressjs.com/guide/routing.html))中可以找到一些无意见的路由器的良好示例。
- en: 'From the following code example, we see the relationship between the endpoint
    path and the function that is able to process the request and a text response:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下代码示例中，我们看到端点路径与能够处理请求并返回文本响应的函数之间的关系：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we have seen examples
    of file-based routing, which further simplifies the routing mechanisms by just
    looking at the files in the application, and dynamically creating routes based
    on those files.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第一章*](B19014_01.xhtml#_idTextAnchor015)中，我们看到了基于文件的路由示例，这通过仅查看应用程序中的文件来进一步简化路由机制，并基于这些文件动态创建路由。
- en: Template engine
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板引擎
- en: Another essential building block is the template engine. This engine combines
    the static parts of a marked-up document with the data from the application. Templating
    makes it possible to render views with various forms of data. With frontend frameworks,
    this usually means rendering the nested component hierarchy. The template engine’s
    job is to enable data binding and to bind any specified events for the interactive
    components, such as buttons or input fields.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键构建块是模板引擎。这个引擎将标记文档的静态部分与来自应用程序的数据结合起来。模板使得能够以各种形式的数据渲染视图。使用前端框架，这通常意味着渲染嵌套的组件层次结构。模板引擎的任务是启用数据绑定，并将任何指定的交互式组件（如按钮或输入字段）的事件绑定。
- en: With a backend framework, templating engines render the whole page or, in some
    cases, partials, sending them over the wire to the client for initial static rendering.
    From [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we have seen frameworks,
    such as Next.js, that are able to render the frontend components on the server
    side and then attach any JavaScript behaviors to the readily rendered component.
    By default, in Next.js, the pages are pre-rendered to improve search engine optimization
    and performance in the browser client. Templating is a vital building block of
    a framework – this is how developers create the presentation layer and mark up
    the page structure.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后端框架，模板引擎渲染整个页面，或者在某些情况下渲染部分页面，通过网络发送到客户端进行初始静态渲染。从[*第一章*](B19014_01.xhtml#_idTextAnchor015)中，我们看到了像Next.js这样的框架，它能够在服务器端渲染前端组件，然后将任何JavaScript行为附加到已渲染的组件上。默认情况下，在Next.js中，页面是预先渲染的，以提高搜索引擎优化和浏览器客户端的性能。模板是框架的一个关键构建块——这是开发者创建表示层和标记页面结构的方式。
- en: Networking
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络连接
- en: 'Web frameworks commonly provide several components as networking abstractions.
    The ability to use a good networking interface can vastly improve the readability,
    performance, and error handling of the application. Here are some features that
    usually come as part of a good networking abstraction:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Web框架通常提供几个组件作为网络抽象。使用良好的网络接口可以极大地提高应用程序的可读性、性能和错误处理能力。以下是一些通常作为良好网络抽象一部分的功能：
- en: '**Session management** – This is the ability to manage sessions and provide
    easy access to session information. This is included as part of networking because
    frontend frameworks usually rely on the backend service to fetch and parse the
    session information.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话管理** – 这是指管理会话并提供对会话信息的便捷访问的能力。这作为网络的一部分被包括在内，因为前端框架通常依赖于后端服务来获取和解析会话信息。'
- en: '**Error handling** – This provides good interfaces to handle all types of possible
    errors that can happen during the process of making a request to an endpoint.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理** – 这提供了良好的接口来处理在向端点发出请求过程中可能发生的所有类型的错误。'
- en: '**Caching** – This is the mechanism that provides a caching layer to improve
    performance and avoid redundant queries if the data is already fresh enough.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存** – 这是提供缓存层以改善性能并避免在数据已经足够新鲜的情况下进行冗余查询的机制。'
- en: '**Security** – Often frameworks come with baked-in security features that follow
    the best practices. This includes examples such as XSS, CSRF protection, script
    injection prevention, and input validation.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性** – 通常，框架内置了遵循最佳实践的安全功能。这包括例如XSS、CSRF保护、脚本注入预防以及输入验证的示例。'
- en: '**Request and response management** – This improves the ability to make requests
    with the required parameters and parse the responses from external systems.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求和响应管理** – 这提高了使用所需参数发出请求并解析来自外部系统的响应的能力。'
- en: Most of these networking abstractions apply to both frontend and backend systems.
    In a full stack framework, a combination of these abstractions can vastly improve
    the workflow and the efficiency of the system that it is supporting.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些网络抽象都适用于前端和后端系统。在全栈框架中，这些抽象的组合可以极大地提高所支持系统的作业流程和效率。
- en: All these abstractions are implemented in JavaScript, TypeScript, or enabled
    by the runtime. Their implementation can be provided from within three categories
    of code structures – as a module, library, or built into a framework. In the next
    section, we are going to explore these categories of code organization.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '所有这些抽象都是在JavaScript、TypeScript中实现或由运行时启用的。它们的实现可以来自三类代码结构 – 作为模块、库或内置于框架中。在下一节中，我们将探讨这些代码组织类别。 '
- en: Differentiating modules, libraries, and frameworks
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分模块、库和框架
- en: While working on JavaScript applications, we rely on modules, libraries, and,
    of course, the larger frameworks. These structures can originate from internal
    and external sources, meaning they are either written by you or your team or are
    a dependency that is written by someone else. JavaScript, specifically, is in
    a unique position where modules, libraries, and even frameworks can be used on
    browser and server environments. For framework developers, it is important to
    know how to work with these JavaScript structures, because frameworks heavily
    rely on defining and using modules and libraries. These abstractions and structures
    allow for better code organization, which we will be discussing in the next subsections.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发JavaScript应用程序时，我们依赖于模块、库，当然还有更大的框架。这些结构可能来自内部和外部来源，这意味着它们要么是你或你的团队编写的，要么是其他人编写的依赖项。特别是JavaScript，它处于一个独特的位置，其中模块、库甚至框架都可以在浏览器和服务器环境中使用。对于框架开发者来说，了解如何与这些JavaScript结构协同工作非常重要，因为框架在很大程度上依赖于定义和使用模块和库。这些抽象和结构允许更好的代码组织，我们将在下一节中讨论这一点。
- en: Modules
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Developers create their own modules to separate the code into multiple files
    or logical blocks. In a similar manner, modules can be imported from external
    sources. The module encapsulation wraps a block of code, providing a way for it
    to export various data types through strings, functions, and other data types.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者创建自己的模块以将代码分割成多个文件或逻辑块。以类似的方式，模块也可以从外部来源导入。模块封装将代码块包裹起来，提供了一种通过字符串、函数和其他数据类型导出各种数据类型的方法。
- en: 'The history of how modules are defined and used in JavaScript is complicated;
    it ventures out to different module patterns and implementations. Even in modern
    projects, you will find inconsistent approaches to module management. Initially,
    there was no way to organize modules, so frontend JavaScript modules were wrapped
    in immediately invoked function expressions or objects. Using functions allows
    the hosting of all the values inside of it within a lexical scope. Here is a sample:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中模块的定义和使用历史相当复杂；它探索了不同的模块模式和实现。即使在现代项目中，你也会发现模块管理的不一致方法。最初，没有组织模块的方法，因此前端
    JavaScript 模块被封装在立即执行的函数表达式或对象中。使用函数可以在词法作用域内托管其内部的所有值。以下是一个示例：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It was evident that the language needed some kind of a modular pattern, and
    this is where **CommonJS** and AMD types of modules were introduced. Defining
    a CommonJS module is straightforward and can be seen in use in a lot of the Node.js
    frameworks:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种语言需要某种模块模式，这就是 **CommonJS** 和 AMD 类型模块被引入的地方。定义 CommonJS 模块很简单，可以在许多 Node.js
    框架中看到其使用情况：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For instance, hapi.js uses a similar CommonJS module pattern in most of its
    files, which can be found in the framework repository at [github.com/hapijs/hapi/tree/master/lib](http://github.com/hapijs/hapi/tree/master/lib)
    – a simple example from a list of its modules is `lib/compression.js` in the `lib`
    directory:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，hapi.js 在其大多数文件中使用了类似的 CommonJS 模块模式，这些模式可以在框架仓库 [github.com/hapijs/hapi/tree/master/lib](http://github.com/hapijs/hapi/tree/master/lib)
    中找到——其模块列表中的一个简单示例是 `lib/compression.js` 文件，位于 `lib` 目录下：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This module provides compression functions for many hapi.js use cases. With
    some of the code omitted, we see the `exports` keyword, which is used to make
    methods from this module available in other files.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块为许多 hapi.js 用例提供了压缩功能。省略了一些代码后，我们看到 `exports` 关键字，它被用来使此模块的方法在其他文件中可用。
- en: These days projects may have different types of JavaScript modules that are
    used as part of their workflow. The more standard ones you will see are CommonJS
    and `module.exports` keywords. The ESM system provides `import` and `export` keywords
    to manage the modules. To distinguish the module types, the `.cjs` and `.mjs`
    file extensions are used to be explicit about which module system is used. The
    normal `.js` extension can still be used, but then it is up to the module loading
    system to figure out how to load these files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，项目可能包含不同类型的 JavaScript 模块，这些模块作为其工作流程的一部分被使用。你将看到的更标准的类型是 CommonJS 和 `module.exports`
    关键字。ESM 系统提供了 `import` 和 `export` 关键字来管理模块。为了区分模块类型，`.cjs` 和 `.mjs` 文件扩展名被用来明确指出使用了哪个模块系统。正常的
    `.js` 扩展名仍然可以使用，但这时模块加载系统需要确定如何加载这些文件。
- en: 'Some examples of module types that you may see in the ecosystem are listed
    here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在生态系统中你可能看到的模块类型的一些示例列在这里：
- en: '**Universal Module Definition** (**UMD**) – This is the module definition that
    tries to support all possible module declarations'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用模块定义**（**UMD**）—— 这是尝试支持所有可能模块声明的模块定义'
- en: '`require()` and `define()` functions to manage the module'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require()` 和 `define()` 函数用于管理模块'
- en: '**Immediately Invoked Function Expression** (**IIFE**) – These are simplistic
    modules encapsulated by a function scope'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立即执行的函数表达式**（**IIFE**）—— 这些是由函数作用域封装的简单模块'
- en: The module systems are slowly getting better in JavaScript, but it is something
    to watch out for when using various modules in frameworks and choosing the right
    module system to use. The varying usage of modules can lead to issues with loading
    in specific environments or can lead to some features not working as intended.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统在 JavaScript 中正在逐渐变得更好，但在使用框架中的各种模块和选择合适的模块系统时，这是一件需要注意的事情。模块的不同使用可能导致特定环境中的加载问题，或者导致某些功能无法按预期工作。
- en: Libraries
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库
- en: Libraries are indispensable in software development nowadays; they play an important
    role in supporting web development projects of any size. The libraries consist
    of a collection of useful resources that implement certain specific functionality
    with a well-defined interface. The focus of libraries is to include the encapsulation
    of optimized features to solve certain problems. Most libraries try to focus on
    a specific set of problems that can help their stakeholders. JavaScript has an
    abundance of open source libraries that developers cannot live without in professional
    projects. They don’t dictate any specific opinionated control flow, but instead,
    let the developer make use of them when needed. In a similar fashion to frameworks,
    the technological availability of the JavaScript runtime allows some of the libraries
    to be used in both the browser and the backend environments.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的软件开发中，库是不可或缺的；它们在支持任何规模的网络开发项目中都发挥着重要作用。这些库由一组实现特定功能且接口定义良好的资源组成。库的焦点是包含封装的优化功能以解决某些问题。大多数库都试图专注于一组特定的问题，以帮助他们的利益相关者。JavaScript拥有丰富的开源库，开发者在专业项目中无法离开它们。它们不指定任何特定的意见控制流程，而是让开发者在他们需要时使用它们。与框架类似，JavaScript运行时的技术可用性允许一些库在浏览器和后端环境中使用。
- en: 'Libraries can serve as a core component used by a framework to solve certain
    technological challenges. There are many cases where we see frameworks building
    abstractions around the following libraries:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以作为框架用于解决某些技术挑战的核心组件。我们看到了许多框架围绕以下库构建抽象的例子：
- en: '**lodash** ([lodash.com](http://lodash.com)) – This library provides a large
    set of utility functions for common tasks'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lodash** ([lodash.com](http://lodash.com)) – 这个库提供了一组用于常见任务的实用函数'
- en: '**React** ([reactjs.org](http://reactjs.org)) – This is an extremely popular
    user interface component rendering library with state management that many of
    the frontend frameworks mentioned so far are based on'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React** ([reactjs.org](http://reactjs.org)) – 这是一个极其流行的用户界面组件渲染库，具有状态管理功能，许多前面提到的前端框架都是基于它构建的'
- en: '**Axios** ([axios-http.com](http://axios-http.com)) – This is a powerful HTTP
    client library for frontend and backend JavaScript projects'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Axios** ([axios-http.com](http://axios-http.com)) – 这是一个强大的前端和后端JavaScript项目的HTTP客户端库'
- en: '**Luxon** ([moment.github.io/luxon](http://moment.github.io/luxon)) – This
    is a library to manipulate date and time in JavaScript, the evolution of a popular
    library called moment.js'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Luxon** ([moment.github.io/luxon](http://moment.github.io/luxon)) – 这是一个用于在JavaScript中操作日期和时间的库，是流行的moment.js库的演变'
- en: '**jQuery** ([jquery.com](http://jquery.com)) – This is more than a decade old
    – a popular library that simplified DOM traversal and abstracted away cross-browser
    quirks for CSS, AJAX, and more'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jQuery** ([jquery.com](http://jquery.com)) – 这是一个超过十年的流行库，它简化了DOM遍历，并抽象了CSS、AJAX等跨浏览器的怪癖'
- en: '**Three.js** ([threejs.org](http://threejs.org)) – This is a JavaScript 3D
    library that abstracts away the complexities of WebGL and 3D graphics on the web'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Three.js** ([threejs.org](http://threejs.org)) – 这是一个JavaScript 3D库，它抽象了WebGL和Web上的3D图形的复杂性'
- en: It is a common pattern to build out additional tooling on top of existing libraries
    to enable applications of various types. For example, in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    we saw examples of frameworks building tooling and abstractions around React.
    If the project allows you to, it is usually a good idea to utilize a library or
    learn from existing implementations for a solved problem rather than rebuilding
    or rewriting the same code. In the next section, we are going to compare choosing
    a development workflow with a set of libraries in contrast with framework-driven
    workflows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有库的基础上构建额外的工具以支持各种类型的应用程序是一种常见的模式。例如，在[*第一章*](B19014_01.xhtml#_idTextAnchor015)中，我们看到了一些框架围绕React构建工具和抽象的例子。如果项目允许，通常利用库或从现有实现中学习已解决的问题，而不是重新构建或重写相同的代码，这是一个好主意。在下一节中，我们将比较选择一组库的开发工作流程与框架驱动的流程。
- en: Frameworks
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: From [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we already know what JavaScript
    frameworks do and the benefits they offer. It is also important to understand
    how much frameworks rely on libraries for their workflows and features, and the
    differences between them. Both libraries and frameworks manage control flow in
    the applications. This control flow is the order and structure of how the logic
    in the application flows. With a library workflow, the existing program will have
    its own control flow and as part of it the library functions are executed when
    required. This existing program precisely calls out to the reusable code in the
    library. This gives full control to the developer to structure the application
    as they see fit, allowing for more room to fine-tune the application behavior
    but missing the value and structures that could potentially be gained by using
    a framework.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第一章*](B19014_01.xhtml#_idTextAnchor015)，我们已经知道 JavaScript 框架的作用以及它们提供的优势。了解框架对其工作流程和功能的依赖程度，以及它们之间的差异也同样重要。库和框架都管理应用程序中的控制流。这种控制流是应用程序中逻辑流动的顺序和结构。使用库工作流程时，现有程序将有自己的控制流，作为其中的一部分，当需要时将执行库函数。现有程序精确地调用库中的可重用代码。这给了开发者完全的控制权，让他们能够根据需要结构化应用程序，从而为微调应用程序行为提供更多空间，但同时也错过了使用框架可能获得的潜在价值和结构。
- en: With a framework workflow, the framework dictates how the control flow should
    be structured. In this case, the developer works within the constraints of the
    framework and follows the often strict guidelines defined by someone else.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架工作流程时，框架决定了控制流应该如何结构化。在这种情况下，开发者需要在框架的限制内工作，并遵循由他人定义的通常严格的指南。
- en: A good comparison would be the React library versus a JavaScript framework such
    as Next.js that depends on the library. The library just consists of functions
    that execute certain tasks. React contains logic for rendering, creating components,
    and other methods. But it is Next.js – the framework – that defines the architecture
    for the application, using the library methods from within to enable its features.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的比较是 React 库与依赖于该库的 JavaScript 框架，如 Next.js。库仅由执行特定任务的函数组成。React 包含渲染、创建组件和其他方法的逻辑。但定义应用程序架构的是
    Next.js – 框架 – 它在内部使用库方法来启用其功能。
- en: Choosing the workflow of using the library within a framework makes it a powerful
    combination; this way, it is possible to gain the benefits of both of these tools.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架内使用库的工作流程选择使其成为一种强大的组合；这样，就有可能获得这两种工具的好处。
- en: Framework organization showcase
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 框架组织展示
- en: You can try out the framework organization examples from this chapter in the
    book repository. Access the examples by cloning the repository from [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    Then use your terminal to change directories into the `framework-organization`
    directory of the repository and run `npm install` followed by `npm start`. Follow
    the guidance in the terminal and keep an eye out for the `README.md` files in
    the directories for extra information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试本书库中的框架组织示例。通过从 [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework)
    克隆仓库来访问示例。然后使用您的终端将目录更改为仓库中的 `framework-organization` 目录，并运行 `npm install` 后跟
    `npm start`。遵循终端中的指导，并留意目录中的 `README.md` 文件以获取更多信息。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have looked at abstractions combined with clever API design, which together
    form the key to building successful frameworks. We have also expanded our knowledge
    of common framework interfaces that provide value to developers and make the application
    development process much more efficient and approachable. Understanding how modules,
    libraries, and frameworks are used helps us be better system architects. In addition,
    the ability to use the debugger to quickly explore how all these pieces come together
    in existing frameworks empowers us to be much more efficient developers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了抽象与巧妙的 API 设计的结合，这共同构成了构建成功框架的关键。我们还扩展了我们关于为开发者提供价值并使应用程序开发过程更加高效和易于接近的常见框架接口的知识。了解模块、库和框架的使用方法有助于我们成为更好的系统架构师。此外，使用调试器快速探索现有框架中所有这些组件如何组合在一起的能力，使我们能够成为更加高效的开发者。
- en: Now that we are more familiar with various organization patterns, we can dive
    deeper into the specific techniques that help us architect new systems. In the
    next chapter, we are going to look at the existing and common patterns that combine
    the building blocks that we have learned into a cohesive system.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对各种组织模式更加熟悉了，我们可以更深入地探讨那些帮助我们构建新系统的具体技术。在下一章中，我们将探讨现有的和常见的模式，这些模式将我们所学的基础构件组合成一个统一的系统。
