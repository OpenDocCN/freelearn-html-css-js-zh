- en: Chapter 5. Security and Traceability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 安全和可追溯性
- en: '**Security** is one of the biggest concerns in systems nowadays. The amount
    of information leaked from big companies is worrying, especially because 90% of
    the information leaks could be mended with very small actions by the software
    developers. Something similar happens with the logging of events and the traceability
    of errors. No one really pays too much attention until someone requests the logs
    that you don''t have in order to audit a failure. In this chapter, we will discuss
    how to manage security and logging so that our system is safe and traceable, with
    the help of the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全**是当今系统中最大的关注点之一。大公司泄露的信息量令人担忧，尤其是因为90%的信息泄露可以通过软件开发人员的一些小动作来修复。类似的情况也发生在事件日志记录和错误的可追溯性上。直到有人要求你没有的日志来审计故障时，没有人会真正关注这些。在本章中，我们将讨论如何管理安全和日志记录，以使我们的系统安全和可追溯，以下是一些帮助的主题：'
- en: '**Infrastructure logical security**: We will discuss how to secure our software
    infrastructure in order to provide the industry standard security layer in our
    communications.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础逻辑安全性**：我们将讨论如何保护我们的软件基础设施，以提供行业标准的通信安全层。'
- en: '**Application security**: We will introduce the common techniques to secure
    our applications. Practices such as output encoding or input validation are the
    industry standard and they could save us from a catastrophe.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用安全**：我们将介绍保护我们应用程序的常见技术。输出编码或输入验证等做法是行业标准，它们可以避免我们遭受灾难。'
- en: '**Traceability**: Being able to follow the requests around our system is a
    must in microservices architectures. We will leverage this task to Seneca and
    learn how to get the information from this fantastic framework.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可追溯性**：能够跟踪我们系统中的请求在微服务架构中是必不可少的。我们将利用Seneca来完成这项任务，并学习如何从这个出色的框架中获取信息。'
- en: '**Auditing**: Even though we put our best efforts in building a software, accidents
    happen. The ability to rebuild the sequence of calls and see exactly what happened
    is important. We will discuss how to enable our system in order to be able to
    recover the required information.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计**：即使我们尽了最大努力构建软件，事故仍然会发生。重建调用序列并准确查看发生了什么的能力是很重要的。我们将讨论如何启用我们的系统，以便能够恢复所需的信息。'
- en: Infrastructure logical security
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础逻辑安全性
- en: Infrastructure security is usually ignored by software engineers as it is completely
    different from their area of expertise. However, nowadays, and especially if your
    career is leaning towards DevOps, it is a subject that should not be ignored.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施安全通常被软件工程师忽视，因为它与他们的专业领域完全不同。然而，如今，特别是如果你的职业倾向于DevOps，这是一个不容忽视的主题。
- en: In this book, we are not going to go very deep into the infrastructure security
    more than few rules of thumb to keep your microservices safe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会深入探讨基础设施安全，只会提出一些保持微服务安全的经验法则。
- en: It is strongly recommended for the readers to read and learn about cryptography
    and all the implications around the usage of SSH, which is one of the main resources
    for keeping communications secure nowadays.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议读者阅读并了解密码学以及围绕SSH使用的所有影响，这是目前保持通信安全的主要资源之一。
- en: SSH – encrypting the communications
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSH - 加密通信
- en: In any organization, there is a strict list of people who can access certain
    services. In general, this authentication for these services is done via username
    and password, but it can also be done using a key to *verify the identity of the
    user*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何组织中，都有一份可以访问某些服务的严格名单。通常，这些服务的身份验证是通过用户名和密码进行的，但也可以使用密钥来*验证用户的身份*。
- en: No matter what authentication method is used, the communication should always
    be done over a secure channel such as **SSH**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用何种身份验证方法，通信都应始终通过安全通道进行，如**SSH**。
- en: '**SSH** stands for **Secure Shell** and it is a software used to access shells
    in remote machines, but it can also be a very helpful tool to create proxies and
    tunnels to access remote servers.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSH**代表**安全外壳**，它是一种用于访问远程机器中的外壳的软件，但它也可以是一个非常有用的工具，用于创建代理和隧道以访问远程服务器。'
- en: 'Let''s explain how it works using the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令来解释它是如何工作的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, I am using **Vagrant** to facilitate the building of virtual machines.
    Vagrant is a very popular tool to automate development environments and their
    website ([https://www.vagrantup.com/](https://www.vagrantup.com/)) consists of
    useful information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我使用**Vagrant**来简化虚拟机的构建。Vagrant是一个非常流行的工具，用于自动化开发环境，他们的网站（[https://www.vagrantup.com/](https://www.vagrantup.com/)）包含了有用的信息。
- en: In the first line, we execute the `ssh david@192.168.0.1` command. This command
    tries to open a terminal as the user `david` in the `192.168.0.1` host.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行中，我们执行`ssh david@192.168.0.1`命令。该命令尝试以`192.168.0.1`主机中的用户`david`身份打开终端。
- en: As it is the first time that this command is executed against the machine in
    the IP `192.168.0.1`, our computer will not trust the remote server.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是第一次针对IP为`192.168.0.1`的机器执行此命令，我们的计算机将不信任远程服务器。
- en: This is done by maintaining a file called `known_hosts`, under the `/home/david/.ssh/known_hosts`
    folder in this case (it will depend on the user).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过维护一个名为`known_hosts`的文件来完成的，在这种情况下是在`/home/david/.ssh/known_hosts`文件夹下（这将取决于用户）。
- en: 'This file is a list of hosts with the corresponding key. As you can see, the
    following two lines explain that the *host cannot be trusted* and present the
    fingerprint of the key held by the remote server in order to verify it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是一个带有相应密钥的主机列表。正如你所看到的，接下来的两行解释了*主机不能被信任*并呈现了远程服务器持有的密钥指纹以进行验证：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, the user is supposed to verify the identity of the server by
    checking the key. Once this is done, we can instruct SSH to connect to the server,
    which will result in the following log being printed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，用户应该通过检查密钥来验证服务器的身份。一旦完成此操作，我们可以指示SSH连接到服务器，这将导致打印以下日志：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if we check our `known_hosts` file, we can see that the key has been added
    to the list, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们检查我们的`known_hosts`文件，我们可以看到密钥已被添加到列表中，如下所示：
- en: '![SSH – encrypting the communications](img/B04889_05_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![SSH-加密通信](img/B04889_05_03.jpg)'
- en: This key stored in the `known_hosts` file is the public key of the remote server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`known_hosts`文件中的这个密钥是远程服务器的公钥。
- en: 'SSH uses a **cryptography algorithm** called **RSA**. This algorithm is built
    around the concept of **asymmetric cryptography**, which is shown in the following
    image:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SSH使用一种名为**RSA**的**密码算法**。这种算法是围绕**非对称加密**的概念构建的，如下图所示：
- en: '![SSH – encrypting the communications](img/B04889_05_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![SSH-加密通信](img/B04889_05_01.jpg)'
- en: 'The asymmetric cryptography relies on a set of keys: one public and one private.
    As the name states, the public key can be shared with everyone; whereas, the private
    key has to be kept secret.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密依赖于一组密钥：一个公钥和一个私钥。顾名思义，公钥可以与所有人共享；而私钥必须保密。
- en: The messages encrypted with the private key can only be decrypted with the public
    key and the other way around so that it is almost impossible (unless someone gets
    the other half of the key) to intercept and decrypt a message.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私钥加密的消息只能使用公钥解密，反之亦然，因此几乎不可能（除非有人获得了密钥的另一半）拦截和解密消息。
- en: At this point, our computer knows the public key of the server and we are in
    a position to start an encrypted session with the server. Once we get the terminal,
    all the commands and results of these commands will be encrypted and sent over
    the wire.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的计算机知道了服务器的公钥，我们可以开始与服务器建立加密会话。一旦我们进入终端，所有命令和命令的结果都将被加密并发送到网络上。
- en: This key can also be used to connect to a remote server without password. The
    only thing we need to do is generate an SSH key in our machine and install it
    in the server in a file called `authorized_keys` under the `.ssh` folder, where
    the `known_hosts` file is.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个密钥也可以用来在没有密码的情况下连接到远程服务器。我们需要做的唯一一件事就是在我们的机器上生成一个SSH密钥，并将其安装在服务器上的一个名为`authorized_keys`的文件中，该文件位于`.ssh`文件夹下，`known_hosts`文件所在的位置。
- en: When working with microservices, you can be remotely logged in to quite a few
    different machines so that this approach becomes more attractive. However, we
    need to be very careful about how we handle the private keys because if a user
    leaks that private key, our infrastructure could be compromised.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微服务时，您可以远程登录到许多不同的机器上，因此这种方法变得更加吸引人。但是，我们需要非常小心地处理私钥，因为如果用户泄漏了私钥，我们的基础设施可能会受到损害。
- en: Application security
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序安全性
- en: Application security is becoming more and more important. As the cloud is becoming
    the de-facto standard for infrastructure in large companies, we can't rely on
    the fact that the data is confined in a single data centre.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序安全性变得越来越重要。随着云成为大公司基础设施的事实标准，我们不能指望数据仅限于单个数据中心。
- en: Usually, when someone starts a new business, the main focus is to build the
    product from the functional point of view. Security is not the main focus and
    usually gets overlooked.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当有人开始新业务时，主要关注点是从功能角度构建产品。安全性不是主要关注点，通常被忽视。
- en: This is a very dangerous practice and we are going to amend that by letting
    the reader know the main security threats that could compromise our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常危险的做法，我们将通过让读者了解可能危害我们应用程序的主要安全威胁来加以修正。
- en: 'The main four big security points to develop applications in a secure manner
    are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应用程序的主要四个安全要点是：
- en: Injection
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入
- en: Cross-site scripting
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本
- en: Cross-site request forgery token protection
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站点请求伪造令牌保护
- en: Open redirects
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放式重定向
- en: At the end of this section, we will be able to identify the main vulnerabilities,
    but we won't be armored against a malicious attacker. In general, a software engineer
    should be up to date with the security as much as they are up to date with new
    technologies. No matter how good the product you build is, if it is not secure,
    someone will find out and take the advantage of it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，我们将能够识别主要的漏洞，但我们不会对恶意攻击者进行防护。一般来说，软件工程师应该尽可能跟上安全性，就像他们跟上新技术一样。无论你构建的产品有多好，如果它不安全，总会有人发现并利用它。
- en: Common threats – how to be up to date
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见威胁-如何跟上最新
- en: As we stated before, security is an ongoing subject in application development.
    No matter what type of software you are building, there will always be security
    implications around it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，安全性是应用程序开发中一个持续的主题。无论您正在构建什么类型的软件，总会有与之相关的安全性问题。
- en: The best way I've found during my professional career to be up to date with
    security around web development without being a full-time dedicated security engineer
    is to follow the **OWASP** project. **OWASP** stands for **Open Web Application
    Security Project** and they produce quite an interesting document (among others)
    on a yearly basis called OWASP Top 10.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我发现了一种不需要成为全职专门的安全工程师就能跟上网页开发安全的最佳方法，那就是遵循**OWASP**项目。**OWASP**代表**开放式Web应用程序安全项目**，他们每年都会发布一份相当有趣的文件（以及其他文件），名为OWASP十大。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OWASP Top 10 was first published in 2003 and its goal is to raise awareness
    in the development community about the most common threats in application development.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP十大于2003年首次发布，其目标是提高开发社区对应用程序开发中最常见威胁的意识。
- en: In the previous section, we identified the four main security issues that a
    software developer can face and all of them are mentioned in the following sections.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们确定了软件开发人员可能面临的四个主要安全问题，并且所有这些问题都在接下来的章节中提到。
- en: Injection
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入
- en: '**Injection** is, by far, the most dangerous attack that we could be exposed
    to. Specifically, a SQL injection is the most common form of injection that affects
    applications and it consists of an attacker forcing a SQL code in one of our application
    queries, leading to a different query that could compromise the data of our company.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注入**是迄今为止我们可能遭受的最危险的攻击。具体来说，SQL注入是影响应用程序的最常见的注入形式，它包括攻击者在我们的应用程序查询中强制执行SQL代码，导致不同的查询可能危及我们公司的数据。'
- en: There are other types of injections, but we are going to focus on SQL injection,
    as pretty much every application in the modern world uses a relational database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的注入，但我们将专注于SQL注入，因为现代世界中几乎每个应用程序都使用关系数据库。
- en: SQL injection consists of the injection or manipulation of SQL queries in our
    application through the input from non-validated sources, such as a web form or
    any other data source with arbitrary input of text.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入包括通过来自未经验证的来源的输入（如Web表单或任何其他具有任意文本输入的数据源）注入或操纵我们应用程序中的SQL查询。
- en: 'Let''s consider the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下例子：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Never store passwords in plain in the database. Always hash and salt them to
    avoid rainbow-table attacks. This is just an example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将密码以明文形式存储在数据库中。始终对其进行哈希和盐处理，以避免彩虹表攻击。这只是一个例子。
- en: 'This query will give us the user that corresponds to a given name and password.
    In order to build the query from the client''s input, we can consider doing something
    similar to the following code as a good idea:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将给我们提供与给定名称和密码相对应的用户。为了从客户端的输入构建查询，我们可以考虑做类似以下代码的事情是一个好主意：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At first sight, it looks like an easy program that accesses the database called
    `test_db` and issues a query to check whether there is a user that matches the
    username and password and renders it back to the client so that if we open the
    browser and try to browse to the `http://localhost:3000/login?username=david&password=mypassword`
    URL, the browser will render a JSON object with the result of the following query:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，它看起来像一个简单的程序，访问名为`test_db`的数据库，并发出一个查询，以检查是否有与用户名和密码匹配的用户，并将其返回给客户端，因此如果我们打开浏览器并尝试浏览到`http://localhost:3000/login?username=david&password=mypassword`
    URL，浏览器将呈现一个JSON对象，其中包含以下查询的结果：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nothing strange yet, but what happens if the customer tries to hack us?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还没有什么奇怪的，但是如果客户试图黑我们会发生什么？
- en: 'Take a look at the following input:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下输入：
- en: '`http://localhost:3000/login?username='' OR 1=1 --&password=mypassword`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:3000/login?username='' OR 1=1 --&password=mypassword`'
- en: 'As you can see, the query generated by it is the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它生成的查询是以下代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In SQL, the `--` character sequence is used to comment the rest of the line
    so that the effective query would be as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，`--`字符序列用于注释掉行的其余部分，因此有效的查询将如下所示：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This query returns the full list of users, and if our software is using the
    result of this query to resolve whether the user should be logged in or not, we
    are in some serious problems. We have just granted access to our system to someone
    who does not even know a valid username.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询返回用户的完整列表，如果我们的软件使用这个查询的结果来确定用户是否应该登录，那么我们就有一些严重的问题。我们刚刚授予了我们的系统对一个甚至不知道有效用户名的人的访问权限。
- en: This is one of the many examples on how SQL injection can affect us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SQL注入如何影响我们的众多例子之一。
- en: In this case, it is pretty obvious that we are concatenating untrusted data
    (coming from the user) into our query, but believe me, when the software gets
    more complicated, it is not always easy to identify.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，很明显我们正在将不受信任的数据（来自用户）连接到我们的查询中，但相信我，当软件变得更加复杂时，要识别这一点并不总是容易的。
- en: A way to avoid SQL injection is through the usage of prepared statements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 避免SQL注入的一种方法是使用预处理语句。
- en: Input validation
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入验证
- en: Applications interact with users mainly through forms. These forms usually contain
    free text input fields that could lead to an attack.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序主要通过表单与用户进行交互。这些表单通常包含自由文本输入字段，可能会导致攻击。
- en: The easiest way to prevent corrupted data from getting into our server is through
    input validation, which as the name suggests, consists of validating the input
    from the user to avoid the situation described earlier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 防止损坏数据进入我们服务器的最简单方法是通过输入验证，正如其名称所示，它包括验证用户的输入，以避免前面描述的情况。
- en: 'There are two types of input validation, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的输入验证，如下：
- en: White listing
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白名单
- en: Black listing
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑名单
- en: '**Black listing** is a dangerous technique. In majority of cases, trying to
    define what is incorrect in the input takes a lot more effort than simply defining
    what we expect.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑名单**是一种危险的技术。在大多数情况下，试图定义输入中的错误要比简单定义我们期望的要费力得多。'
- en: 'The recommended approach is (and will always be) to **white list** the data
    coming from the user, validating it through the use of a regular expression: we
    know how a phone number looks like, we also know how a username should look like,
    and so on.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的方法是（并且将始终是）从用户那里**白名单**数据，通过使用正则表达式进行验证：我们知道电话号码是什么样子的，我们也知道用户名应该是什么样子的，等等。
- en: 'Input validation is not always easy. If you have ever come across the validation
    of an e-mail, you will know what I am talking about: the regular expression to
    validate an e-mail is anything but simple.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证并不总是容易的。如果你曾经遇到过验证电子邮件的情况，你会知道我在说什么：验证电子邮件的正则表达式绝不简单。
- en: The fact that there is not an easy way to validate some data should not restrict
    us from doing it as the omission of input validation could lead to a serious security
    flaw.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不能轻易验证某些数据的事实不应该限制我们去做，因为忽略输入验证可能会导致严重的安全漏洞。
- en: Input validation is not the silver bullet for SQL injections, but it also helps
    with other security threats such as cross-site scripting.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证并不是SQL注入的万能药，但它也有助于解决其他安全威胁，比如跨站脚本攻击。
- en: 'In the query from the previous section, we do something quite dangerous: concatenate
    user input into our query.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的查询中，我们做了一些非常危险的事情：将用户输入连接到我们的查询中。
- en: 'One of the solutions could be to use some sort of escaping library that will
    sanitize the input from the user, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个解决方案可能是使用某种转义库来清理用户输入，如下所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, the `mysql` library used provides a suite of methods to escape
    strings. Let''s see how it works:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用的`mysql`库提供了一套方法来转义字符串。让我们看看它是如何工作的：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The small script from earlier escapes the string provided as `username` in the
    previous example, the result is `\' OR 1=1 --`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的小脚本转义了前面示例中作为`username`提供的字符串，结果是`\' OR 1=1 --`。
- en: As you can see, the `escape()` method has replaced the dangerous characters,
    sanitizing the input from the user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`escape()`方法已经替换了危险字符，清理了用户输入。
- en: Cross-site scripting
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: '**Cross-site scripting**, also known as **XSS**, is a security vulnerability
    that mainly affects web applications. It is one of the most common security issues
    and the implications can be huge for the customer as potentially, someone could
    steal the user identity with this attack.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本攻击**，也称为**XSS**，是主要影响Web应用程序的安全漏洞之一。这是最常见的安全问题之一，对客户的影响可能是巨大的，因为潜在地，有人可能会利用这种攻击窃取用户身份。'
- en: The attack is an injection code put into a third-party website that could steal
    data from the client's browser. There are a few ways of doing it, but by far,
    the most common is by unescaped input from the client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击是将注入代码放入第三方网站中，可以从客户端浏览器中窃取数据。有几种方法可以做到这一点，但到目前为止，最常见的方法是通过来自客户端的未转义输入。
- en: In few websites on the Internet, users can add comments containing arbitrary
    input. This arbitrary input can contain script tags that load a JavaScript from
    a remote server that can steal the session cookie (or other types of valuable
    information), letting the attacker replicate the user session on a remote machine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上的一些网站上，用户可以添加包含任意输入的评论。这种任意输入可能包含加载来自远程服务器的JavaScript的脚本标记，可以窃取会话cookie（或其他类型的有价值的信息），让攻击者在远程机器上复制用户会话。
- en: 'There are two main types of XSS attacks: **persistent** and **non-persistent**.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要类型的XSS攻击：**持久**和**非持久**。
- en: The **persistent** type of XSS consists of storing the XSS attack by crafting
    a particular string of text that resolves into the attack once it is displayed
    to the user in the website. This code could be injected via an arbitrary input
    text that is stored in the database (such as a comment in a forum).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久**类型的XSS包括通过制作特定的文本字符串来存储XSS攻击，一旦在网站上向用户显示时，该文本字符串就会解析为攻击。这段代码可以通过存储在数据库中的任意输入文本（例如论坛中的评论）来注入。'
- en: The **non-persistent** type of XSS is when the attack is inserted into a non-persistent
    part of the application due to bad data handling.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**非持久**类型的XSS是当攻击插入到应用程序的非持久部分中，由于处理不当的数据而发生。'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下的屏幕截图：
- en: '![Cross-site scripting](img/B04889_05_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![跨站脚本攻击](img/B04889_05_02.jpg)'
- en: 'As you can see, we have searched for a book (this book) in [http://www.amazon.co.uk/](http://www.amazon.co.uk/).
    It does not produce any output (as the book is not published yet), but it specifies
    that **Your search "microservices nodejs" did not match any products**, which
    is somehow using the input from the web browser as output. Even more, when I clicked
    on search, Amazon redirected me to the following URL:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在[http://www.amazon.co.uk/](http://www.amazon.co.uk/)中搜索了一本书（这本书）。它没有产生任何输出（因为这本书还没有出版），但它指定了**Your
    search "microservices nodejs" did not match any products**，这在某种程度上使用了来自Web浏览器的输入作为输出。更重要的是，当我点击搜索时，亚马逊将我重定向到以下URL：
- en: '[http://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=microservices+nodejs](http://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=microservices+nodejs)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=microservices+nodejs](http://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=microservices+nodejs)'
- en: We know Amazon is secure, but if it was sensible to XSS attacks, we could have
    modified the value of the `field-keywords` parameter to craft a request that injected
    a script tag in the content, leading to the attacker being able to steal the session
    cookie that could result in some serious problems for the website.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道亚马逊是安全的，但如果它对XSS攻击很敏感，我们可以修改`field-keywords`参数的值，以制作一个请求，该请求在内容中注入了一个脚本标记，导致攻击者能够窃取会话cookie，这可能会给网站带来严重的问题。
- en: Output encoding
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出编码
- en: A way to protect against this attack is output encoding. We have done it before,
    when we used `connection.escape()` in the *Input validation* section of this chapter.
    In fairness, we should be validating all the data entered from the user and encoding
    all the outputs that come from third parties. This includes the input entered
    by the user, as well as sources of information coming from outside of the system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 防范这种攻击的一种方法是输出编码。我们之前已经做过了，在本章的*输入验证*部分中使用了`connection.escape()`。公平地说，我们应该验证用户输入的所有数据，并对来自第三方的所有输出进行编码。这包括用户输入的输入，以及来自系统外部的信息来源。
- en: 'When narrowing the problem to web development, we have to be aware of the three
    different areas where output encoding is needed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当将问题缩小到Web开发时，我们必须意识到输出编码所需的三个不同领域：
- en: CSS
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS
- en: JavaScript
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: HTML
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML
- en: The most problematic two are JavaScript and HTML, where an attacker could easily
    steal information without too much effort.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最棘手的两种是JavaScript和HTML，攻击者可以很容易地窃取信息。
- en: Generally, no matter which framework we use for building our app, it always
    has functions to encode the output.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，无论我们使用哪个框架来构建我们的应用程序，它总是具有编码输出的功能。
- en: Cross-site request forgery
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: '**Cross-site request forgery** (**CSRF**) is the reverse of cross-site request
    scripting. In cross-site request scripting, the problem is in the client trusting
    the data coming from the server. With cross-site request forgery, the problem
    is that the server trusts the data coming from the client.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站点请求伪造**（**CSRF**）是跨站点请求脚本的反向。在跨站点请求脚本中，问题在于客户端信任来自服务器的数据。而在跨站点请求伪造中，问题在于服务器信任来自客户端的数据。'
- en: After stealing the session cookie, the attacker can not only steal information
    from the user, but can also modify the information of the account associated with
    the cookie.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 窃取会话cookie后，攻击者不仅可以窃取用户的信息，还可以修改与cookie关联的帐户的信息。
- en: This is done by posting the data to the server via HTTP requests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过通过HTTP请求将数据发布到服务器来完成的。
- en: 'HTTP classifies its requests in methods. A method is basically used to specify
    what is the operation to be carried by the request. The most interesting four
    methods are the following ones:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP将其请求分类为方法。方法基本上用于指定请求要执行的操作。最有趣的四种方法是以下几种：
- en: '`GET`: This gets the data from the server. It should not modify any persistent
    data.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：这从服务器获取数据。它不应修改任何持久数据。'
- en: '`POST`: This creates a resource in the server.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：这在服务器上创建资源。'
- en: '`PUT`: This updates a resource in the server.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这在服务器上更新资源。'
- en: '`DELETE`: This deletes a resource from the server.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：这从服务器中删除资源。'
- en: There are more methods (such as `PATCH` or `CONNECT`), but let's focus on these
    four. As you can see, three of these four methods modify data from the server,
    and a user with a valid session could potentially steal data, create payments,
    order goods, and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多方法（如`PATCH`或`CONNECT`），但让我们专注于这四种。正如你所看到的，这四种方法中的三种会修改服务器中的数据，而具有有效会话的用户可能会窃取数据，创建付款，订购商品等。
- en: A way to avoid the cross-site request forgery attack is by protecting the `POST`,
    `PUT` and `DELETE` endpoints with a cross-site request token.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 避免跨站点请求伪造攻击的一种方法是使用跨站点请求令牌保护`POST`，`PUT`和`DELETE`端点。
- en: 'Take a look at the following HTML form:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下HTML表单：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This form describes a perfectly valid situation: a user registering on our
    website; very simple, but still valid and flawed.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单描述了一个完全有效的情况：用户在我们的网站上注册；非常简单，但仍然有效且有缺陷。
- en: We are specifying a URL and the list of expected parameters so that an attacker
    can register hundreds or thousands of accounts within a span of minutes, with
    a small script that issues a `POST` request with the two parameters (`email` and
    `password`) in the body.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在指定一个URL和预期参数列表，以便攻击者可以在几分钟内注册数百或数千个帐户，使用一个小脚本发出带有两个参数（`email`和`password`）的`POST`请求。
- en: 'Now, look at the following form:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下以下表单：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see the difference: there is an extra hidden parameter called `csrftoken`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到区别：有一个额外的隐藏参数叫做`csrftoken`。
- en: This parameter is a random string that is generated every time a form is rendered
    so that we can add this extra parameter to every form.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该参数是一个随机字符串，每次呈现表单时都会生成，以便我们可以将此额外参数添加到每个表单中。
- en: Once the form is submitted, the `csrftoken` parameter is validated to only let
    go through the requests with a valid token and generate a new token to be rendered
    on the page again.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦表单提交，`csrftoken`参数将被验证，只允许具有有效令牌的请求通过，并生成一个新令牌再次呈现在页面上。
- en: Open redirects
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开放式重定向
- en: 'Sometimes, our application might need to redirect the user to a certain URL.
    For example, when hitting a private URL without a valid authentication, the user
    will usually be redirected to the login page:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的应用程序可能需要将用户重定向到某个特定的URL。例如，当访问私有URL而没有有效的身份验证时，用户通常会被重定向到登录页面：
- en: '`http://www.mysite.com/my-private-page`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://www.mysite.com/my-private-page`'
- en: 'This could result into a redirect to the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致重定向到以下内容：
- en: '`http://www.mysite.com/login?redirect=/my-private-page`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://www.mysite.com/login?redirect=/my-private-page`'
- en: This sounds legit. The user is sent to the login page, and once he provides
    a valid set of credentials, it is redirected to `/my-private-page`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来合理。用户被发送到登录页面，一旦提供有效的凭据集，就会被重定向到`/my-private-page`。
- en: What happens if someone tries to steal the account of our user?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人试图窃取我们用户的帐户会发生什么？
- en: 'Look at the following request:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下请求：
- en: '`http://www.mysite.com/login?redirect=http://myslte.com`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://www.mysite.com/login?redirect=http://myslte.com`'
- en: This is a crafted request that will redirect the user to `myslte.com` instead
    of `mysite.com` (note the `l` instead of `i`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个精心制作的请求，将用户重定向到`myslte.com`而不是`mysite.com`（注意`l`而不是`i`）。
- en: Someone could make `myslte.com` look like the login page of `mysite.com` and
    steal your user's password and username by distributing the preceding URL in the
    social media as the users will be redirected to a malicious page.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可以让`myslte.com`看起来像`mysite.com`的登录页面，并通过在社交媒体上分发前面的URL来窃取用户的密码和用户名，因为用户将被重定向到恶意页面。
- en: 'The solution for the preceding problem is quite simple: don''t redirect the
    user to untrusted third-party websites.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面问题的解决方案非常简单：不要将用户重定向到不受信任的第三方网站。
- en: Again, the best way of doing such task is white listing the target hosts for
    redirects. Basically, we don't let our software redirect our customers to unknown
    websites.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，执行此任务的最佳方法是为重定向的目标主机进行白名单处理。基本上，我们不让我们的软件将我们的客户重定向到未知的网站。
- en: Effective code reviews
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效的代码审查
- en: One of the most effective ways to reduce security flaws in our applications
    is through a systematic and informed code review process. The problem with code
    reviews is that they always end up being a dump area for opinions and personal
    preferences that usually not only won't improve the quality of the code, but will
    also lead to last minute changes that could expose vulnerabilities in our application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 减少我们应用程序中安全漏洞的最有效方法之一是通过系统化和知情的代码审查流程。代码审查的问题在于它们总是最终成为意见和个人偏好的倾倒区域，这些意见和偏好通常不仅不会提高代码的质量，而且还会导致最后一刻的更改，可能会暴露我们应用程序中的漏洞。
- en: A dedicated stage in the product development life cycle for a security code
    review helps to drastically reduce the amount of bugs delivered to production.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 产品开发生命周期中专门的安全代码审查阶段有助于大大减少交付到生产环境中的错误数量。
- en: The problem that the software engineers have is that their mind is trained to
    build things that work well, but they don't have the mindset to find defects,
    especially around the things that they build. This is why you should not be testing
    your own code (any further than the test carried on when developing), and even
    less, security testing your application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师面临的问题是，他们的思维被训练成构建良好运行的东西，但他们没有发现缺陷的思维，尤其是围绕他们构建的东西。这就是为什么您不应该测试自己的代码（除了在开发时进行的测试之外），甚至更少地测试应用程序的安全性。
- en: However, we usually work in teams and that enables us to review someone else's
    code, but we have to do it in an effective manner.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常是团队合作，这使我们能够审查别人的代码，但我们必须以有效的方式进行。
- en: Code reviews require as much brain power as needed to write software, especially
    if you are reviewing a complex code. You should never spend more than two hours
    reviewing the same functionality, otherwise important flaws will be missed and
    attention to detail will decrease to a worrying level.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查需要尽可能多的大脑力量，尤其是在审查复杂的代码时。您不应该花费超过两个小时审查相同的功能，否则会错过重要的缺陷，并且对细节的关注将降低到令人担忧的水平。
- en: This is not a big problem in microservices-based architectures as the functionality
    should be small enough to be read in a reasonable period of time, especially if
    you talked to the author about what he was trying to build.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这在基于微服务的架构中并不是一个大问题，因为功能应该足够小，可以在合理的时间内阅读，尤其是如果你和作者讨论过他试图构建什么。
- en: 'You should always follow a two phase review, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终遵循两阶段审查，如下所示：
- en: 'Review the code quickly to get the big picture: how it works, what technology
    it uses that you are not familiar with, does it do what it is supposed to do,
    and so on'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速审查代码以获得整体情况：它是如何工作的，它使用了你不熟悉的技术，它是否做了它应该做的事情，等等
- en: Review the code following a checklist of items to look for
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照检查清单审查代码
- en: This list of items has to be decided upfront and depends on the nature of the
    software that your company is building.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目清单必须事先决定，并取决于您的公司正在构建的软件的性质。
- en: 'Usually, the list of items to check around the code security concerns during
    a code review is quite big, but we can narrow it down to the following components:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在代码审查期间检查代码安全性方面的项目清单很长，但我们可以将其缩小到以下组件：
- en: Is all the input validated/encoded when applicable?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有输入在适用时都经过了验证/编码吗？
- en: Is all the output encoded, including logs?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有输出都进行了编码，包括日志吗？
- en: Do we protect endpoints with cross-site request forgery tokens?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否用跨站点请求伪造令牌保护端点？
- en: Are all the user credentials encrypted or hashed in the database?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用户凭据在数据库中都进行了加密或哈希处理吗？
- en: If we check this list, we will be able to identify the biggest issues around
    security in our apps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查这个清单，我们将能够确定我们应用程序中安全性方面的最大问题。
- en: Traceability
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可追溯性
- en: Traceability is extremely important in the modern information systems. It is
    a delicate matter in microservices that is gracefully solved in Seneca, making
    the requests easy to follow around our system so that we can audit the failure.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代信息系统中，可追溯性非常重要。这在微服务中是一个微妙的问题，在Seneca中得到了很好的解决，使得请求在我们的系统中易于跟踪，以便我们可以审计故障。
- en: Logging
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: Seneca is pretty good with the logging. There are so many options that can be
    configured in Seneca in order to get the required information about how everything
    is working (if it is working).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca在日志记录方面做得相当不错。在Seneca中有很多可以配置的选项，以便获取关于一切工作情况的所需信息（如果它正在工作）。
- en: 'Let''s see how logging works with a small application:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看日志记录如何在一个小应用程序中工作：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the simplest Seneca application that can be written. Let''s run it
    as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以编写的最简单的Seneca应用程序。让我们按照以下方式运行它：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the result of running the app with the default logging configuration.
    Aside from the `console.log()` method that we have used in the code, there is
    some internal information about Seneca being logged. Sometimes, you might want
    to only log what your application is producing so that you can debug the application
    without all the noise. In this case, just run the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用默认日志配置运行应用程序的结果。除了我们在代码中使用的`console.log()`方法之外，还有一些有关Seneca的内部信息被记录下来。有时，您可能只想记录您的应用程序产生的日志，以便您可以调试应用程序而不受到所有噪音的干扰。在这种情况下，只需运行以下命令：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, sometimes, there are weird behaviors in the system (or even a bug
    in the frameworks used) and you want to get all the information about what is
    happening. Seneca supports that as well, as shown in the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时系统中会出现奇怪的行为（甚至是使用的框架中的错误），你想获取关于发生了什么的所有信息。Seneca也支持这一点，如下命令所示：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding command will print an endless amount of information that might
    not be helpful.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将打印大量可能没有帮助的信息。
- en: 'In order to reduce the amount of logging produced by Seneca, there is a fine-grain
    control in what gets logged into the output. Let''s take a look at the following
    lines:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少Seneca产生的日志量，可以对输出的日志进行精细控制。让我们看看以下行：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'They are random lines from a log output on the preceding code example, but
    it will give us useful information: these entries are debug-level log lines for
    different actions (such as plugin, register, and act) on the Seneca framework.
    In order to filter them, Seneca provides a control over what levels or actions
    do we want to see. Consider the following for example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是前面代码示例的日志输出中的随机行，但它将为我们提供有用的信息：这些条目是Seneca框架上不同操作（如插件、注册和执行）的调试级别日志行。为了对它们进行过滤，Seneca提供了对我们想要查看的级别或操作的控制。例如考虑以下内容：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will only output the logs related to the `INFO` level:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅输出与“INFO”级别相关的日志：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also filter by action type, which is quite interesting. When you are
    working with microservices, knowing the chain of events that happened in a flow
    is one of the first things that you need to look into in order to audit a failure.
    With this control over the logging that Seneca gives us, it is as easy as executing
    the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按操作类型进行过滤，这是非常有趣的。当您使用微服务时，了解流程中发生的事件链是您需要首先查看的事情之一，以便审计失败。有了塞内卡给我们的日志记录控制，执行以下命令就像轻而易举的事情：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will produce the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Logging](img/B04889_05_04.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![日志记录](img/B04889_05_04.jpg)'
- en: As you can see, all the preceding lines correspond to the `act` type, and even
    more, if we follow the output of the command from top to bottom, we exactly know
    the sequence of events to which Seneca reacted and their order.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，所有前面的行都对应于“act”类型，而且，如果我们从上到下跟随命令的输出，我们确切地知道塞内卡对事件的反应及其顺序。
- en: Tracing requests
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追踪请求
- en: 'Tracing requests is also a very important activity, and sometimes, it is even
    a legal requirement, especially if you work in the world of finance. Again, Seneca
    is fantastic at tracing requests. For every call, Seneca generates a unique identifier.
    This identifier can be traced across all the paths to where the call is going
    to, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪请求也是非常重要的活动，有时甚至是法律要求，特别是如果你在金融领域工作。同样，塞内卡在追踪请求方面做得非常出色。对于每个调用，塞内卡生成一个唯一标识符。这个标识符可以在调用要去的所有路径上进行追踪，如下所示：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we are logging a dictionary that contains the transaction ID in Seneca
    to the terminal. So, if we execute it, we will get the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个包含塞内卡中的事务ID的字典记录到终端。因此，如果我们执行它，我们将得到以下输出：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can see how all the requests in Seneca are traced: the framework assigns
    an ID and it gets propagated across endpoints. In this case, all our endpoints
    are in the local machine, but if we distribute them in different machines, the
    ID will still be the same.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到塞内卡是如何追踪所有请求的：框架分配了一个ID，并且它在端点之间传播。在这种情况下，我们所有的端点都在本地机器上，但如果我们将它们分布在不同的机器上，ID仍将是相同的。
- en: With this unique ID, we will be able to reconstruct the journey of the customer
    data in our system, and ordering the requests with the associated timestamp, we
    can get an accurate picture of what the user was doing, how much time did every
    action take, what are the possible problems associated with delays, and so on.
    Usually, the logging combined with circuit breakers output information allows
    the engineers to solve issues within a very reduced time frame.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个唯一的ID，我们将能够重建客户数据在我们系统中的旅程，并且通过与相关时间戳的请求排序，我们可以准确地了解用户在做什么，每个动作需要多长时间，与延迟相关的可能问题等。通常，结合断路器输出信息的日志记录使工程师能够在非常短的时间内解决问题。
- en: Auditing
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计
- en: Up till now, we have been using `console.log()` to output the data into the
    logs. This is a bad practice. It breaks the format of the logs and throws the
    content to the standard output.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`console.log()`将数据输出到日志中。这是一个不好的做法。它会破坏日志的格式，并将内容抛到标准输出。
- en: 'Again, Seneca comes to the rescue:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，塞内卡来到了救援：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s see what Seneca produces as output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看塞内卡产生的输出：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we are now outputting the transaction ID using the logger. We
    have produced a `WARN` message instead of a simple console dump. From now on,
    we can use Seneca log filters to hide the output of our actions in order to focus
    on what we are trying to find.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们现在正在使用记录器输出事务ID。我们产生了一个`WARN`消息，而不是简单的控制台转储。从现在开始，我们可以使用塞内卡日志过滤器来隐藏我们操作的输出，以便专注于我们试图找到的内容。
- en: 'Seneca provides the following five levels of logging:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 塞内卡提供以下五个日志级别：
- en: '**DEBUG**: This is used to debug applications when you are developing them
    and also trace problems in production systems.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DEBUG**：这用于在开发应用程序时进行调试，也用于跟踪生产系统中的问题。'
- en: '**INFO**: This log level is used to produce important messages about events
    such as a transaction has started or completed.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INFO**：此日志级别用于生成关于事件的重要消息，例如交易已开始或已完成。'
- en: '**WARN**: This is the warning level. We use it when something bad happens in
    the system, but it is not critical, the user usually does not get affected; however,
    it is an indication that something is going in the wrong way.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WARN**：这是警告级别。当系统发生一些不好的事情时我们使用它，但它并不是关键的，用户通常不会受到影响；然而，这表明事情正在朝着错误的方向发展。'
- en: '**ERROR**: This is used to log errors. Generally, the user gets affected by
    it and it also interrupts the flow.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ERROR**：这用于记录错误。通常用户会受到影响，它也会中断流程。'
- en: '**FATAL**: This is the most catastrophic level. It is only used when a non-recoverable
    error has occurred and the system won''t be able to function normally.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FATAL**：这是最灾难性的级别。只有在发生不可恢复的错误并且系统无法正常运行时才会使用。'
- en: A way to produce logs in different levels is to use the associated functions.
    As we have seen earlier, we called `this.log.warn()` to log a warning. If we call
    the `this.log.fatal()` method, we will be logging a fatal error, and same with
    the other levels.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以不同级别生成日志的一种方法是使用相关函数。正如我们之前所看到的，我们调用了`this.log.warn()`来记录警告。如果我们调用`this.log.fatal()`方法，我们将记录一个致命错误，其他级别也是如此。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Try to adjust the logs in your application as a part of the development process
    or you will regret the lack of information when something bad occurs in production.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在应用程序开发过程中调整日志，否则当生产中发生问题时，您将后悔缺乏信息。
- en: In general, INFO, DEBUG, and WARN will be the most used log levels.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，INFO、DEBUG和WARN将是最常用的日志级别。
- en: HTTP codes
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP代码
- en: HTTP codes are often ignored, but they are a really important mechanism to standardize
    responses from remote servers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP代码经常被忽视，但它们是标准化远程服务器响应的一个非常重要的机制。
- en: 'When a program (or user) issues a request to a server, there are a few things
    that could happen, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序（或用户）向服务器发出请求时，可能会发生以下几种情况：
- en: It could be successful
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会成功
- en: It could fail validation
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会失败验证
- en: It could produce a server error
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会产生服务器错误
- en: As you can see, the possibilities are endless. The problem that we now have
    is that HTTP was created for the communication between machines. How do we handle
    the fact that machines will be reading these codes?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，可能性是无穷无尽的。我们现在面临的问题是，HTTP是为机器之间的通信而创建的。我们如何处理机器将阅读这些代码的事实？
- en: 'HTTP solved this problem in a very elegant way: every single request has to
    be resolved with an HTTP code and these codes have ranges that indicate the nature
    of the code.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP以非常优雅的方式解决了这个问题：每个请求都必须用HTTP代码解决，这些代码有指示代码性质的范围。
- en: 1xx – informational
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1xx – 信息性
- en: The codes in the 100-199 range are purely informational. The most interesting
    code in this range is the 102 code. This code is used to specify that an operation
    is happening in the background and might take some time to complete.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 100-199范围内的代码纯粹是信息性的。此范围内最有趣的代码是102代码。此代码用于指定后台正在进行的操作，可能需要一些时间才能完成。
- en: 2xx – success codes
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2xx – 成功代码
- en: Success codes are used to indicate a certain level of success in the HTTP request.
    It is the most common (and desired) codes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 成功代码用于指示HTTP请求的一定程度的成功。这是最常见（也是最期望的）代码。
- en: 'The most common codes in this range are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此范围内最常见的代码如下：
- en: '`200: Success`: This code indicates a full success. Nothing went wrong even
    remotely.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 200：成功：此代码表示完全成功。甚至远程都没有出现任何问题。
- en: '`201: Created`: This code is used mainly for REST APIs when the client requests
    to create a new entity in the server.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 201：已创建：当客户端请求在服务器中创建一个新实体时，主要使用此代码。
- en: '`203: Non-authoritative information`: This code is intended to be used when,
    while routing the request through a transforming proxy, the origin responds with
    a 200.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 203：非权威信息：此代码用于在通过转换代理路由请求时，源响应为200。
- en: '`204: No Content`: This is a successful code, but there is no content coming
    back from the server. Sometimes, APIs returns 200, even if there is no content.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 204：无内容：这是一个成功的代码，但是服务器没有返回任何内容。有时，API即使没有内容也会返回200。
- en: '`206: Partial Content`: This code is used for paginated responses. A header
    is sent, specifying a range (and an offset) that the client will accept. If the
    response is bigger than the range, the server will reply with 206, indicating
    that there is more data to follow.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 206：部分内容：此代码用于分页响应。发送一个标头，指定客户端将接受的范围（和偏移量）。如果响应大于范围，服务器将回复206，表示还有更多数据要跟随。
- en: 3xx – redirection
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3xx – 重定向
- en: The codes in the 300 to 399 range indicate that the client must take some additional
    actions to complete the request.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 300至399范围内的代码表示客户端必须采取一些额外的操作才能完成请求。
- en: 'The most common codes in this range are described as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此范围内最常见的代码描述如下：
- en: '`301: Moved permanently`: This status code is indicating that the resource
    that the client was trying to get has been moved permanently to another location.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 301：永久移动：此状态代码表示客户端试图获取的资源已永久移动到另一个位置。
- en: '`302: Found`: This code indicates that the user is required to perform a temporary
    redirect for some reason, but the browsers started implementing this code as `303
    See Other`. This lead to the introduction of the 303 and `307 Temporary redirect`
    codes to disambiguate the overlap of behavior.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 302：找到：此代码表示用户需要出于某种原因执行临时重定向，但浏览器开始实现此代码为`303 See Other`。这导致引入了303和`307临时重定向`代码以消除行为的重叠。
- en: '`308 Permanent Redirect`: This code, as the name indicates, is used to specify
    a permanent redirect for a resource. It could be confused with 301, but there
    is a small difference, the 308 code does not allow the HTTP method to change.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 308 永久重定向：此代码如其名称所示，用于指定资源的永久重定向。它可能会与301混淆，但有一个小差异，308代码不允许HTTP方法更改。
- en: 4xx – client errors
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4xx – 客户端错误
- en: The codes in the 400 to 499 range represent errors generated by the client.
    They indicate that there is a problem with the request. This range is particularly
    important as it is the way that HTTP servers have to indicate the clients that
    something is wrong with their request.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 400至499范围内的代码表示客户端生成的错误。它们表示请求存在问题。此范围尤为重要，因为这是HTTP服务器用来指示客户端请求存在问题的方式。
- en: 'The common codes in this range are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此范围内常见的代码如下：
- en: '`400 Bad Request`: This code indicates that the request from the user is syntactically
    incorrect. There could be parameters missing or some of the values didn''t pass
    validation.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 400 错误请求：此代码表示用户的请求在语法上不正确。可能缺少参数或某些值未通过验证。
- en: '`401 Unauthorized`: This code represents a lack of authentication of the client.
    Usually, a valid login will fix this problem.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 401 未经授权：此代码表示客户端缺乏身份验证。通常，有效的登录将解决此问题。
- en: '`403 Forbidden`: This is similar to 401, but in this case, it is indicating
    that the user does not have enough privileges.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 403 禁止：这与401类似，但在这种情况下，它表示用户权限不足。
- en: '`404 Not Found`: This means that the resource is not found in the server. This
    is the error that you get when you navigate to a page that does not exist.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404 未找到：这意味着服务器中未找到资源。当您导航到不存在的页面时，会出现此错误。
- en: 5xx – server errors
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5xx – 服务器错误
- en: This range indicates that there has been a processing error in the server. When
    a 5xx code is issued, it means that there was some sort of problem in the server
    and it cannot be fixed from the client.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此范围表示服务器中发生了处理错误。当发出5xx代码时，意味着服务器出现了某种问题，客户端无法修复。
- en: 'Some of the codes in this range are as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此范围内的一些代码如下：
- en: '`500 Internal Server Error`: This means that an error has occurred in the software
    in the server. There is no more information disclosed.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500 内部服务器错误：这意味着服务器中的软件发生了错误。没有更多信息披露。
- en: '`501 Not Implemented`: This error occurs when a client hits an endpoint that
    has not been implemented yet.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 501 未实现：当客户端命中尚未实现的端点时会发生此错误。
- en: '`503 Service unavailable`: This code is issued when the server is not available
    for some reason, either an excess of the load or the server is down.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`503服务不可用`：当服务器由于某种原因不可用时，将发出此代码，无论是负载过多还是服务器宕机。'
- en: Why HTTP codes matter in microservices
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么HTTP代码在微服务中很重要
- en: The popular saying *don't reinvent the wheel* is one of my favorite principles
    when building software. HTTP codes are a standard, so everybody understands the
    consequences of the different codes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的说法“不要重复造轮子”是我在构建软件时最喜欢的原则之一。HTTP代码是一个标准，所以每个人都了解不同代码的后果。
- en: When building microservices, you always need to keep in mind that your system
    will be interacting with proxies, caches, and other services that already speak
    HTTP so that they can react according to the response from the servers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务时，您始终需要牢记您的系统将与代理、缓存和其他已经使用HTTP的服务进行交互，以便它们可以根据来自服务器的响应做出反应。
- en: The best example of this is the circuit-breaker pattern. No matter how you implement
    it and what software you use, a circuit breaker has to understand that an HTTP
    request with 500 code is an error, so it can open the circuit accordingly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的例子是断路器模式。无论您如何实现它以及使用什么软件，断路器都必须了解500代码的HTTP请求是一个错误，因此它可以相应地打开断路器。
- en: In general, it is good practice to keep the codes of your application as accurate
    as possible as it will benefit your system in the long run.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，将应用程序的代码保持尽可能准确是一个良好的做法，因为这将使您的系统受益良多。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you have learned how to build secure software (and not only
    microservices), although it is a subject big enough to write a full book on it.
    The problem with security is that companies usually see investing in security
    as burning money, but that is far from reality. I am a big fan of the 80-20 rule:
    20% of time will give you 80% of features and the 20% of missing features will
    require 80% of the time.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何构建安全软件（不仅仅是微服务），尽管这是一个足够大的主题，可以写一本完整的书。安全性的问题在于，公司通常认为投资安全就是在烧钱，但这与现实相去甚远。我非常喜欢80-20法则：20%的时间将给您80%的功能，而缺失的20%功能将需要80%的时间。
- en: In security, we really should be aiming for 100% coverage; however, the 80%
    shown in this chapter will cover majority of the cases. Anyway, as I mentioned
    before, a software engineer should be up to date with security as a flaw in the
    security of an application is the easiest way to kill a company.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全方面，我们确实应该力争实现100%的覆盖率；然而，本章显示的80%将覆盖大多数情况。无论如何，正如我之前提到的，软件工程师应该随时了解安全性，因为应用程序安全性的缺陷是摧毁公司的最简单方式。
- en: We have also been talking about traceability and logging, one of the most ignored
    subjects in the modern software engineering that are becoming more and more important,
    especially if your software is built using a microservices approach.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还谈到了可追溯性和日志记录，这是现代软件工程中最被忽视的主题之一，尤其是如果您的软件是使用微服务方法构建的。
