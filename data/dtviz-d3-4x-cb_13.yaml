- en: Chapter 13. Test Drive Your Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。测试驱动你的可视化
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Getting Jasmine and setting up the test environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Jasmine 并设置测试环境
- en: Test driving your visualization - chart creation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动你的可视化 - 图表创建
- en: Test driving your visualization - SVG rendering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动你的可视化 - SVG 渲染
- en: Test driving your visualization - pixel-perfect bar rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动你的可视化 - 像素级完美的条形图渲染
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Whenever we program as a professional programmer it is always important to test
    the program we write in order to make sure it functions as designed and produces
    the expected outcome. D3 data visualization mainly consists of JavaScript programs
    hence just like any other program we write, data visualization needs to be tested
    to make sure it represents the underlying data accurately. Obviously, we can perform
    our validation through visual examination and manual testing, which is always
    a critical part of the process of building data visualization since visual observation
    gives us a chance to verify not only the correctness, but also the aesthetics,
    usability, and many other useful aspects. However, manual visual inspection can
    be quite subjective, therefore, in this chapter we will focus our effort on automated
    unit testing. Visualization well covered by unit tests can free the creator from
    the manual labor of verifying correctness by hand, additionally allowing the creator
    to focus more on the aesthetics, usability, and other important aspects where
    it is hard to automate with machine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们以专业程序员的身份进行编程时，测试我们所编写的程序总是非常重要的，以确保它按设计运行并产生预期的结果。D3 数据可视化主要是由 JavaScript
    程序组成的，因此就像我们编写的任何其他程序一样，数据可视化也需要进行测试，以确保它准确地表示底层数据。显然，我们可以通过视觉检查和手动测试来进行验证，这始终是构建数据可视化过程中的一个关键部分，因为视觉观察不仅给我们提供了验证正确性的机会，还可以验证美学、可用性以及许多其他有用的方面。然而，手动视觉检查可能相当主观，因此，在本章中，我们将专注于自动化单元测试。通过单元测试充分覆盖的可视化可以免除创作者手动验证正确性的劳动，同时允许创作者更多地关注美学、可用性以及其他难以自动化的重要方面。
- en: Introduction to unit testing
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试简介
- en: Unit testing is a method in which a smallest unit of the program is tested and
    verified by another program called the test case. The logic behind unit testing
    is that at unit level the program is typically simpler and more testable. If we
    can verify that every unit in the program is correct then putting these correct
    units together will give us a higher confidence in which the integrated program
    is also correct. Furthermore, since unit tests are typically cheap and fast to
    execute, a group of unit test cases can be quickly and frequently executed to
    provide feedback whether our program is performing correctly or not.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种方法，其中通过另一个称为测试用例的程序测试和验证程序的最小单元。单元测试背后的逻辑是，在单元级别，程序通常是更简单且更容易测试的。如果我们能够验证程序中的每个单元都是正确的，那么将这些正确的单元组合在一起将使我们更有信心，集成程序也是正确的。此外，由于单元测试通常成本低且执行速度快，一组单元测试用例可以快速频繁地执行，以提供反馈，告诉我们程序是否正在正确执行。
- en: Software testing is a complex topic and so far we have only scratched the surface;
    however, due to limited scope in this chapter, we will have to stop our introduction
    now and dive into developing unit tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是一个复杂的话题，到目前为止我们只是触及了皮毛；然而，由于本章范围有限，我们现在必须停止介绍并深入到单元测试的开发中。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on some of the important concepts in software testing
    please check out the following links: Unit test: [https://en.wikipedia.org/wiki/Unit_testing](https://en.wikipedia.org/wiki/Unit_testing)
    Test driven development: [https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development)
    Code coverage: [https://en.wikipedia.org/wiki/Code_coverage](https://en.wikipedia.org/wiki/Code_coverage)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件测试中的一些重要概念，请查看以下链接：单元测试：[https://zh.wikipedia.org/wiki/单元测试](https://zh.wikipedia.org/wiki/单元测试)
    测试驱动开发：[https://zh.wikipedia.org/wiki/测试驱动开发](https://zh.wikipedia.org/wiki/测试驱动开发)
    代码覆盖率：[https://zh.wikipedia.org/wiki/代码覆盖率](https://zh.wikipedia.org/wiki/代码覆盖率)
- en: Getting Jasmine and setting up the test environment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 Jasmine 并设置测试环境
- en: Before we start writing our unit test cases we need to set up an environment
    where our test cases can be executed to verify our implementation. In this recipe,
    we will show how this environment and necessary libraries can be set up for a
    visualization project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写单元测试用例之前，我们需要设置一个环境，以便我们的测试用例可以被执行以验证我们的实现。在这个食谱中，我们将展示如何为可视化项目设置此环境和必要的库。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Jasmine ([https://jasmine.github.io/](https://jasmine.github.io/) ) is a **Behavior-Driven
    Development** (**BDD**) framework for testing JavaScript code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine ([https://jasmine.github.io/](https://jasmine.github.io/)) 是一个用于测试 JavaScript
    代码的 **行为驱动开发**（**BDD**）框架。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: BDD is a software development technique that combines **Test Driven Development**
    (**TDD**) with domain driven design.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 是一种软件开发技术，它将 **测试驱动开发**（**TDD**）与领域驱动设计相结合。
- en: We chose Jasmine as our testing framework because of its popularity in JavaScript
    community as well as its nice BDD syntax. You can download the Jasmine library
    from, [https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 Jasmine 作为我们的测试框架，因为它在 JavaScript 社区中非常受欢迎，并且它的 BDD 语法很好。您可以从 [https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases)
    下载 Jasmine 库。
- en: 'Once downloaded you need to unzip it into the `lib` folder. Besides the `lib`
    folder we also need to create the `src` and `spec` folders for storing source
    files as well as test cases (in BDD terminology, test cases are called specification).
    See the following screenshot for the folder structure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，您需要将其解压缩到 `lib` 文件夹中。除了 `lib` 文件夹外，我们还需要创建 `src` 和 `spec` 文件夹来存储源文件以及测试用例（在
    BDD 术语中，测试用例被称为规范）。请参阅以下截图以了解文件夹结构：
- en: '![Getting ready](img/image_13_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/image_13_001.jpg)'
- en: Testing directory structure
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试目录结构
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now, we have Jasmine in our environment, next thing to do is to set up an HTML
    page that will include Jasmine library as well as our source code plus test cases
    so they can be executed to verify our program. This file is called `SpecRunner.html`
    in our setup which includes the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的环境中已经有了 Jasmine，接下来要做的事情是设置一个 HTML 页面，该页面将包括 Jasmine 库以及我们的源代码和测试用例，以便它们可以被执行以验证我们的程序。这个文件在我们的设置中被称为
    `SpecRunner.html`，它包含以下代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This code follows standard Jasmine spec runner structure and generates execution
    report directly into our HTML page. Now, you have a fully functional test environment
    set up for your visualization development. If you open the `SpecRunner.html` file
    with your browser you will see a blank page at this point; however, if you check
    out our code sample you will see the following report:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遵循标准的 Jasmine 规范运行器结构，并直接在我们的 HTML 页面上生成执行报告。现在，您已经为您的可视化开发设置了一个完全功能化的测试环境。如果您用浏览器打开
    `SpecRunner.html` 文件，您现在会看到一个空白页面；然而，如果您查看我们的代码示例，您将看到以下报告：
- en: '![How it works...](img/image_13_002.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/image_13_002.jpg)'
- en: Jasmine report
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 报告
- en: See also
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Jasmine**:[https://jasmine.github.io/](https://jasmine.github.io/)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine**：[https://jasmine.github.io/](https://jasmine.github.io/)'
- en: '**Jasmine 2.5 Reference Document**: [https://jasmine.github.io/2.5/introduction](https://jasmine.github.io/2.5/introduction)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine 2.5 参考文档**：[https://jasmine.github.io/2.5/introduction](https://jasmine.github.io/2.5/introduction)'
- en: '**Behavior Driven ****Development**:[https://en.wikipedia.org/wiki/Behavior-driven_development](https://en.wikipedia.org/wiki/Behavior-driven_development)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为驱动开发**：[https://en.wikipedia.org/wiki/Behavior-driven_development](https://en.wikipedia.org/wiki/Behavior-driven_development)'
- en: Test driving your visualization - chart creation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动您的可视化 - 图表创建
- en: 'With test environment ready, we can move on and develop a simple bar chart
    very similar to what we have done in the *Creating a bar chart* recipe in [Chapter
    8](ch08.html "Chapter 8. Chart Them Up"), *Chart Them Up*, though this time in
    a test-driven fashion. You can see how the bar chart looks if you open the `tdd-bar-chart.html`
    page:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境准备就绪后，我们可以继续开发一个简单的条形图，这与我们在第 8 章“Chart Them Up”中“创建条形图”食谱中所做的工作非常相似，不过这次是采用测试驱动的模式。您可以通过打开
    `tdd-bar-chart.html` 页面来查看条形图的外观：
- en: '![Test driving your visualization - chart creation](img/image_13_003_new.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![测试驱动您的可视化 - 图表创建](img/image_13_003_new.jpg)'
- en: Test driven bar chart
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动条形图
- en: By now we all know very well how to implement a bar chart using D3; however,
    building a bar chart is not the focus of this recipe. Instead, we want to show
    how we can build test cases every step of the way and verify automatically that
    our bar chart implementation is doing what it is supposed to do. The source code
    of this recipe was built using test driven development method; however, we will
    not show you every step in the TDD process due to limited scope in this book.
    Instead, we have grouped multiple steps into three larger sections with different
    focuses in this chapter and this recipe is the first step we take.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们所有人都非常清楚如何使用 D3 实现条形图；然而，构建条形图并不是这个菜谱的重点。相反，我们想展示我们如何一步一步地构建测试用例，并自动验证我们的条形图实现是否做了它应该做的事情。这个菜谱的源代码是使用测试驱动开发方法构建的；然而，由于本书的范围有限，我们不会展示
    TDD 过程中的每个步骤。相反，我们将多个步骤组合成三个更大的部分，每个部分都有不同的重点，这个菜谱是我们采取的第一步。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your text editor:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的文本编辑器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js)'
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js)'
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First step we need to take is to make sure our bar chart implementation exists
    and can receive the data. The starting point of our development could be arbitrary
    and we decide to drive from this simplest function to set up the skeleton for
    our object. Here is what the test case looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一步是确保我们的条形图实现存在并且可以接收数据。我们开发的起点可以是任意的，我们决定从这个最简单的函数开始，为我们的对象设置骨架。以下是测试用例的样子：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this first test case we used a few Jasmine constructs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个测试用例中，我们使用了几个 Jasmine 构造：
- en: '`describe`: This function defines a suite of test cases; within `describe`
    a sub-suite can be nested and test cases can be defined'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`：此函数定义了一组测试用例；在 `describe` 内可以嵌套子套件，并可以定义测试用例'
- en: '`it`: This function defines a test case'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it`：此函数定义了一个测试用例'
- en: '`beforeEach`: This function defines a pre-execution hook which will execute
    the given function before the execution of each test case'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach`：此函数定义了一个执行前钩子，它将在每个测试用例执行前执行给定的函数'
- en: '`afterEach`: This function defines a post-execution hook which will execute
    the given function after the execution of each test case'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach`：此函数定义了一个执行后钩子，它将在每个测试用例执行后执行给定的函数'
- en: '`expect`: This function defines an expectation in your test case which can
    then be chained with matchers (for example, `toBe` and `toBeEmpty`) to perform
    assertion in your test case'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`：此函数在您的测试用例中定义了一个期望，然后可以通过匹配器（例如，`toBe` 和 `toBeEmpty`）进行链式调用以在测试用例中执行断言'
- en: 'In our example we use the `beforeEach` hook to set up a `div` container for
    each test case and then remove `div` after execution in `afterEach` hook to improve
    the isolation between different test cases. The test case itself is almost trivial;
    it checks if the bar chart can take data and also return data attribute correctly.
    At this point if we run our `SpecRunner`, it will display a red message complaining
    there is no `BarChart` object, so let''s create our object and function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用 `beforeEach` 钩子为每个测试用例设置一个 `div` 容器，然后在 `afterEach` 钩子中删除 `div`
    以提高不同测试用例之间的隔离性。测试用例本身几乎是微不足道的；它检查条形图是否可以接收数据，并且也能正确返回数据属性。在这个时候，如果我们运行我们的 `SpecRunner`，它将显示一条红色的消息，抱怨没有
    `BarChart` 对象，所以让我们创建我们的对象和函数：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, if you run `SpecRunner.html` again it will give you a happy green message
    showing our only test case is passing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您再次运行 `SpecRunner.html`，它将显示一条愉快的绿色消息，表明我们的唯一测试用例已经通过。
- en: Test driving your visualization - SVG rendering
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动您的可视化 - SVG 渲染
- en: Now we have the basic skeleton of our bar chart object created, and we feel
    that we are
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了条形图对象的基本骨架，我们感觉我们已经
- en: ready to try to render something, so in this second iteration we will try to
    generate the `svg:svg` element.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 准备尝试渲染一些内容，因此在这个第二次迭代中，我们将尝试生成 `svg:svg` 元素。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your text editor:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的文本编辑器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js)'
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js)'
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Rendering the `svg:svg` element should not only simply add the `svg:svg` element
    to the HTML body, but also translate the width and height setting on our chart
    object to proper SVG attributes. Here is how we express our expectation in our
    test cases:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染`svg:svg`元素不仅应该简单地将`svg:svg`元素添加到HTML主体中，还应该将我们的图表对象的宽度和高度设置转换为适当的SVG属性。以下是我们在测试用例中如何表达我们的期望：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'At this point, all of these tests will fail since we don''t even have the render
    function; however, it clearly articulates that we expect the render function to
    generate the `svg:svg` element and setting the `width` and `height` attributes
    correctly. The second test case also makes sure that if the user does not provide
    the `height` and `width` attributes we will supply a set of default values. Here
    is how we will implement the render method to satisfy these expectations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些测试都将失败，因为我们甚至还没有渲染函数；然而，它清楚地说明了我们期望渲染函数生成`svg:svg`元素，并正确设置`width`和`height`属性。第二个测试用例还确保，如果用户没有提供`height`和`width`属性，我们将提供一组默认值。以下是我们将如何实现渲染方法以满足这些期望：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point our `SpecRunner.html` is once again all green and happy. However,
    it's still not doing much since all it does is generate an empty `svg:` `svg`
    element on the page and not even use the data at all.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`SpecRunner.html`再次全部显示为绿色和愉快。然而，它仍然没有做太多，因为它只是在页面上生成一个空的`svg:` `svg`元素，甚至没有使用任何数据。
- en: Test driving your visualization - pixel-perfect bar rendering
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动可视化 - 像素级精确的条形图渲染
- en: In this iteration we will finally generate the bars using the data we have.
    Through our test cases we will make sure all bars are not only rendered but rendered
    with pixel-perfect precision.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们将最终使用我们拥有的数据生成条形图。通过我们的测试用例，我们将确保所有条形图不仅被渲染，而且渲染得像素级精确。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your text editor:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的文本编辑器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/src/bar_chart.js)'
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter13/spec/bar_chart_spec.js)'
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s see how we test it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何测试它：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding test suite we describe our expectations of having the chart
    body `svg:g` element correctly transform and correct number of bars with appropriate
    attributes (`width`, `x`, `y`, `height`) set. The implementation is actually going
    to be shorter than our test case which is quite common in well tested implementation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试套件中，我们描述了对图表主体`svg:g`元素正确转换和正确数量的条形图以及适当属性（`width`、`x`、`y`、`height`）设置的期望。实际上，实现将比我们的测试用例短得多，这在经过良好测试的实现中很常见：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I think you are getting the picture and now you can repeat this cycle over and
    over to drive your implementation. D3 visualization is built on HTML with SVG
    and both are simple mark-up languages that can be verified easily. Well thought-out
    test suite can make sure your visualization is pixel-perfect even sub-pixel perfect.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经明白了，现在你可以一遍又一遍地重复这个周期来驱动你的实现。D3可视化建立在HTML和SVG之上，两者都是简单的标记语言，可以轻松验证。精心设计的测试套件可以确保你的可视化是像素级精确的，甚至是亚像素级精确的。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Test driven development**:[https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试驱动开发**：[https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development)'
