- en: Data Storage and Retrieval
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据存储和检索
- en: In the previous two chapters, we built a small and somewhat useful application
    for storing notes, and then made it work on mobile devices. While the application
    works reasonably well, it doesn't store those notes anywhere on a long-term basis,
    meaning the notes are lost when you stop the server and, if you run multiple instances
    of Notes, each instance has its own set of notes. The typical next step is to
    introduce a database tier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们构建了一个小型且有一定用途的应用程序来存储笔记，然后使其在移动设备上工作。虽然应用程序工作得相当好，但它并没有在任何长期基础上存储那些笔记，这意味着当你停止服务器时，笔记就会丢失，如果你运行多个笔记实例，每个实例都有自己的笔记集。典型的下一步是引入数据库层。
- en: In this chapter, we will look at database support in Node.js, so the user sees
    the same set of notes for any Notes instance accessed, and to reliably store notes
    for long-term retrieval.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Node.js中的数据库支持，这样用户在任何访问的笔记实例中都能看到相同的笔记集，并且能够可靠地存储笔记以供长期检索。
- en: 'We''ll start with the *Notes* application code used in the previous chapter.
    We started with a simple, in-memory data model using an array to store the notes,
    and then made it mobile friendly. In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一章中使用的*笔记*应用程序代码开始。我们从一个简单的、使用数组存储笔记的内存数据模型开始，然后使其适应移动设备。在本章中，我们将：
- en: Discover logging operational and debugging information
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现日志操作和调试信息
- en: Begin using the ES6 module format
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用ES6模块格式
- en: Implement data persistence for Notes objects using several database engines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个数据库引擎实现笔记对象的持久化
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: The first step is to duplicate the code from the previous chapter. For instance,
    if you were working in `chap06/notes`, duplicate that to be `chap07/notes`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是复制上一章中的代码。例如，如果你在`chap06/notes`中工作，将其复制到`chap07/notes`。
- en: Data storage and asynchronous code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据存储和异步代码
- en: By definition, external data storage systems require asynchronous code in the
    Node.js architecture. The access time to retrieve data from disk, from another
    process, or from a database, always takes sufficient time to require deferred
    execution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，外部数据存储系统在Node.js架构中需要异步代码。从磁盘、另一个进程或数据库中检索数据访问时间总是足够长，以至于需要延迟执行。
- en: The existing `Notes` data model is an in-memory data store. In theory, in-memory
    data access does not require asynchronous code and therefore, the existing model
    module could have used regular functions rather than `async` functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的`Notes`数据模型是一个内存数据存储。从理论上讲，内存数据访问不需要异步代码，因此，现有的模型模块可以使用常规函数而不是`async`函数。
- en: We knew that Notes must move to using databases, and would require an asynchronous
    API to access Notes data. For that reason, the existing Notes model API uses `async`
    functions so that in this chapter, we can persist Note data to databases.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道笔记必须迁移到使用数据库，并且需要异步API来访问笔记数据。因此，现有的笔记模型API使用`async`函数，这样我们就可以在本章中将笔记数据持久化到数据库中。
- en: Logging
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: 'Before we get into databases, we have to address one of the attributes of a
    high-quality software system: managing logged information, including normal system
    activity, system errors, and debugging information. Logs give us an insight into
    the behavior of the system. How much traffic is it getting? If it''s a website,
    which pages are people hitting the most? How many errors occur and of what kind?
    Do attacks occur? Are malformed requests being sent?'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入数据库之前，我们必须解决一个高质量软件系统的一个属性：管理日志信息，包括正常系统活动、系统错误和调试信息。日志使我们能够深入了解系统的行为。它获得了多少流量？如果是一个网站，人们最多访问哪些页面？发生了多少错误，以及错误的类型是什么？是否发生了攻击？是否发送了格式不正确的请求？
- en: Log management is also an issue. Log rotation means regularly moving the log
    file out of the way, to start with a fresh log file. You should process logged
    data to produce reports. A high priority on screening for security vulnerabilities
    is a must.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 日志管理也是一个问题。日志轮转意味着定期将日志文件移开，以便开始一个新的日志文件。你应该处理日志数据以生成报告。对安全漏洞的筛查必须具有高优先级。
- en: The Twelve Factor application model suggests simply sending logging information
    to the console, and then some other software system captures that output and directs
    it to a logging service. Following their advice can reduce system complexity by
    having fewer things that can break. In a later chapter, we'll use PM2 for that
    purpose.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 十二因素应用程序模型建议简单地将日志信息发送到控制台，然后其他软件系统捕获该输出并将其导向日志服务。遵循他们的建议可以通过减少可能出错的事物来降低系统复杂性。在后面的章节中，我们将使用
    PM2 来实现这个目的。
- en: Let's first complete a tour of information logging as it stands right now in
    Notes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先完成对笔记中当前信息日志的浏览。
- en: 'When we used the Express Generator to initially create the *Notes* application,
    it configured an activity logging system using `morgan`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Express Generator 最初创建 *Notes* 应用程序时，它配置了一个使用 `morgan` 的活动日志系统：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is what prints the requests on the Terminal window. Visit [https://github.com/expressjs/morgan](https://github.com/expressjs/morgan)
    for more information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在终端窗口中打印请求的内容。有关更多信息，请访问 [https://github.com/expressjs/morgan](https://github.com/expressjs/morgan)。
- en: Internally, Express uses the **Debug** package for debugging traces. You can
    turn these on using the `DEBUG` environment variable. We should try to use this
    package in our application code. For more information, visit [https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Express 使用 **Debug** 包进行调试跟踪。您可以使用 `DEBUG` 环境变量来开启这些功能。我们应该尽量在我们的应用程序代码中使用这个包。更多信息，请访问
    [https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug)。
- en: Finally, the application might generate uncaught exceptions. The `uncaughtException`
    error needs to be captured, logged, and dealt with appropriately.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序可能会生成未捕获的异常。需要捕获、记录并适当处理`uncaughtException`错误。
- en: Request logging with Morgan
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Morgan 进行请求日志记录
- en: 'The Morgan package has two general areas for configuration:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Morgan 包有两个主要的配置区域：
- en: Log format
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志格式
- en: Log location
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志位置
- en: As it stands, Notes uses the `dev` format, which is described as a concise status
    output meant for developers. This can be used to log web requests as a way to
    measure website activity and popularity. The Apache log format already has a large
    ecosystem of reporting tools and, sure enough, Morgan can produce log files in
    this format.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Notes 使用的是 `dev` 格式，它被描述为一种简洁的状态输出，旨在为开发者使用。这可以用来记录网络请求，作为衡量网站活动和受欢迎程度的一种方式。Apache
    日志格式已经拥有一个庞大的报告工具生态系统，而且确实，Morgan 可以生成这种格式的日志文件。
- en: 'To change the format, simply change this line in `app.js`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改格式，只需更改`app.js`中的这一行：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then run *Notes* as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式运行 *Notes*：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To revert to the previous logging output, simply do not set this environment
    variable. If you've looked at Apache access logs, this logging format will look
    familiar. The `::1` notation at the beginning of the line is IPV6 notation for
    the `localhost`, which you may be more familiar with as `127.0.0.1`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复到之前的日志输出，只需不设置此环境变量。如果您查看过 Apache 访问日志，这种日志格式看起来会熟悉。行首的 `::1` 表示法是 `localhost`
    的 IPV6 表示法，您可能更熟悉的是 `127.0.0.1`。
- en: We can declare victory on request logging and move on to debugging messages.
    However, let's look at logging this to a file directly. While it's possible to
    capture `stdout` through a separate process, Morgan is already installed in Notes
    and it does provide the capability to direct its output to a file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在请求日志记录上宣布胜利，然后转向调试消息。然而，让我们看看如何将日志直接记录到文件中。虽然可以通过一个单独的进程捕获 `stdout`，但 Morgan
    已经安装在 Notes 中，并且它确实提供了将输出直接导向文件的能力。
- en: 'The Morgan documentation suggests this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Morgan 文档建议如下：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But this has a problem; it's impossible to perform log rotation without killing
    and restarting the server. Instead, we'll use their `rotating-file-stream` package.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但这有一个问题；在不杀死和重新启动服务器的情况下，无法执行日志轮转。因此，我们将使用他们的 `rotating-file-stream` 包。
- en: 'First, install the package:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装该包：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we add this code to `app.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将此代码添加到`app.js`中：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we're using an environment variable, `REQUEST_LOG_FILE`, to control whether
    to send the log to `stdout` or to a file. The log can go into a directory, and
    the code will automatically create that directory if it doesn't exist. By using `rotating-file-stream` ([https://www.npmjs.com/package/rotating-file-stream](https://www.npmjs.com/package/rotating-file-stream)),
    we're guaranteed to have log file rotation with no extra systems required.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用环境变量 `REQUEST_LOG_FILE` 来控制是否将日志发送到 `stdout` 或文件。日志可以放入目录中，如果目录不存在，代码将自动创建该目录。通过使用
    `rotating-file-stream` ([https://www.npmjs.com/package/rotating-file-stream](https://www.npmjs.com/package/rotating-file-stream))，我们确保了日志文件轮转，无需额外的系统。
- en: The `fs-extra` module is being used because it adds Promise-based functions
    to the `fs` module ([https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra)).
    In this case, `fs.ensureDir` checks if the named directory structure exists and,
    if not, the directory path is created.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fs-extra` 模块是因为它向 `fs` 模块添加了基于 Promise 的函数 ([https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra))。在这种情况下，`fs.ensureDir`
    检查指定的目录结构是否存在，如果不存在，则创建目录路径。
- en: Debugging messages
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试信息
- en: 'You can generate quite a detailed trace of what Express does by running *Notes* this
    way:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式运行 *Notes*，你可以生成 Express 所做的详细跟踪：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is pretty useful if you want to debug Express. But, we can use this in our
    own code as well. It is similar to inserting `console.log` statements, but without
    having to remember to comment out the debugging code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调试 Express，这非常有用。但，我们也可以在我们的代码中使用它。这类似于插入 `console.log` 语句，但无需记住要注释掉调试代码。
- en: 'It is very simple to enable debugging in a module:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 启用模块中的调试非常简单：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Capturing stdout and stderr
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获 stdout 和 stderr
- en: Important messages can be printed to `process.stdout` or `process.stderr`, which
    can be lost if you don't capture that output. The Twelve Factor model suggests
    using a system facility to capture these output streams. With Notes, we'll use
    PM2 for that purpose, which we'll cover in [Chapter 10](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml),
    *Deploying Node.js Applications*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息可以打印到 `process.stdout` 或 `process.stderr`，如果未捕获该输出，则可能会丢失。十二要素模型建议使用系统功能来捕获这些输出流。在笔记中，我们将使用
    PM2 来实现这一目的，这将在第 [10 章](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml) “部署 Node.js
    应用程序” 中介绍。
- en: The `logbook` module ([https://github.com/jpillora/node-logbook](https://github.com/jpillora/node-logbook))
    offers some useful capabilities in term of not only capturing `process.stdout`
    and `process.stderr`, but sending that output to useful places.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`logbook` 模块 ([https://github.com/jpillora/node-logbook](https://github.com/jpillora/node-logbook))
    在捕获 `process.stdout` 和 `process.stderr` 方面提供了一些有用的功能，并且可以将输出发送到有用的位置。'
- en: Uncaught exceptions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未捕获的异常
- en: 'Uncaught exceptions is another area where important information can be lost.
    This is easy to fix in the *Notes* application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 未捕获的异常是另一个可能会丢失重要信息的地方。在 *Notes* 应用程序中修复这个问题很容易：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `debug` package has a convention we're following. For an application with
    several modules, all debugger objects should use the naming pattern `app-name:module-name`.
    In this case, we used `notes:error` that will be used for all error messages.
    We could also use `notes:memory-model` or `notes:mysql-model` for debugging different
    models.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug` 包有一个我们遵循的约定。对于具有多个模块的应用程序，所有调试对象都应该使用命名模式 `app-name:module-name`。在这种情况下，我们使用了
    `notes:error`，它将用于所有错误消息。我们也可以使用 `notes:memory-model` 或 `notes:mysql-model` 来调试不同的模型。'
- en: While we were setting up the handler for uncaught exceptions, it is also a good
    idea to add error logging into the error handlers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置未捕获异常的处理程序时，将错误记录添加到错误处理程序中也是一个好主意。
- en: Unhandled Promise rejections
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未处理的 Promise 拒绝
- en: Using Promise and `async` functions automatically channels errors in a useful
    direction.  Errors will cause a Promise to flip into a *rejected* state, which
    must eventually be handled in a `.catch` method.  Since we're all human, we're
    bound to forget to ensure that all code paths handle their rejected Promise's.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Promise 和 `async` 函数自动将错误引导到有用的方向。错误会导致 Promise 转换为 *拒绝* 状态，这最终必须在 `.catch`
    方法中处理。由于我们都是人类，我们难免会忘记确保所有代码路径都处理了它们的拒绝的 Promise。
- en: 'Currently, Node.js prints the following warning if it detects an unhandled
    Promise rejection:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果 Node.js 检测到未处理的 Promise 拒绝，它会打印以下警告：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The warning goes on to say that the default handler for unhandled Promise rejection
    has been deprecated and that such Promise rejections will crash the Node process
    rather than print this message. The built-in `process` module does emit an event
    in this case, so it''s easy enough to add a handler:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 警告继续说明，未处理的Promise拒绝的默认处理程序已被弃用，并且此类Promise拒绝将使Node进程崩溃而不是打印此消息。在这种情况下，内置的`process`模块确实会发出事件，因此添加处理程序很容易：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the minimum, we can print an error message such as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，我们可以打印如下错误消息：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the ES6 module format
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES6模块格式
- en: We wrote the *Notes* application using CommonJS modules, the traditional Node.js
    module format. While the application could continue using that format, the JavaScript
    community has chosen to switch to ES6 modules in both browser and Node.js code,
    and therefore it's important to switch ES6 modules so we can all get on board
    with a common module format. Let's rewrite the application using ES6 modules,
    and then write ES6 modules for anything new we add.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用CommonJS模块编写了*笔记*应用程序，这是传统的Node.js模块格式。虽然应用程序可以继续使用该格式，但JavaScript社区已经选择在浏览器和Node.js代码中切换到ES6模块，因此切换到ES6模块非常重要，这样我们就可以使用统一的模块格式。让我们使用ES6模块重写应用程序，然后为任何新添加的内容编写ES6模块。
- en: The changes required are large to replace `require` statements with `import`
    statements, and renaming files from `foo.js` to `foo.mjs`. Let's get started.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的更改很大，需要将`require`语句替换为`import`语句，并将文件从`foo.js`重命名为`foo.mjs`。让我们开始吧。
- en: Rewriting app.js as an ES6 module
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将app.js重写为ES6模块
- en: 'Let''s start with `app.js`, changing its name to `app.mjs`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`app.js`开始，将其名称更改为`app.mjs`：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Change the block of `require` statements at the top to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将顶部的`require`语句块更改为以下内容：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, at the bottom of the script, make this change:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在脚本的底部进行以下更改：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's talk a little about the workaround mentioned here. There were several
    global variables automatically injected by Node.js into CommonJS modules. Those
    variables are not supported by ES6 modules. The critical variable for *Notes*
    is `__dirname`, which is used in `app.mjs` in several places. The code change
    shown here includes a workaround based on a brand new JavaScript feature that
    is available starting in Node.js 10.x, the `import.meta.url` variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要谈谈这里提到的解决方案。Node.js自动注入到CommonJS模块中的有几个全局变量。这些变量不受ES6模块支持。对于*笔记*应用程序来说，关键的变量是`__dirname`，它在`app.mjs`中多处使用。这里显示的代码更改包括基于Node.js
    10.x开始可用的全新JavaScript功能的一个解决方案，即`import.meta.url`变量。
- en: The `import.meta` object is meant to inject useful information into an ES6 module.
    As the name implies, the `import.meta.url` variable contains the URL describing
    where the module was loaded from.  For Node.js, at this time, ES6 modules can
    only be loaded from a `file://` URL on the local filesystem. That means, if we
    extract the `pathname` of that URL, we can easily calculate the directory containing
    the module, as shown here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`import.meta`对象旨在将有用信息注入到ES6模块中。正如其名所示，`import.meta.url`变量包含描述模块从何处加载的URL。对于Node.js来说，目前，ES6模块只能从本地文件系统上的`file://`
    URL加载。这意味着，如果我们提取该URL的`pathname`，我们可以轻松计算出包含模块的目录，如下所示。'
- en: Why this solution? Why not use a pathname beginning with `./`?  The answer is
    that a `./` filename is evaluated relative to the process's current working directory.
    That directory is usually different from the directory containing the Node.js
    module being executed.  Therefore it is more than convenient that the Node.js
    team has added the `import.meta.url` feature.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择这个解决方案？为什么不使用以`./`开头的路径名？答案是，`./`文件名是相对于进程的当前工作目录进行评估的。这个目录通常与正在执行的Node.js模块所在的目录不同。因此，Node.js团队添加`import.meta.url`功能是非常方便的。
- en: 'The pattern followed in most cases is this change:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，遵循以下更改模式：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember that Node.js uses the same module lookup algorithm in both ES6 and
    CommonJS modules. A Node.js `require` statement is synchronous, meaning that by
    the time `require` finishes, it has executed the module and is returning its `module.exports`.
    By contrast, an ES6 module is asynchronous, meaning the module may not have finished
    loading, and you can import just the required bits of the module.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Node.js在ES6和CommonJS模块中都使用相同的模块查找算法。Node.js的`require`语句是同步的，这意味着在`require`完成时，它已经执行了模块并返回了其`module.exports`。相比之下，ES6模块是异步的，这意味着模块可能还没有完成加载，你可以只导入所需的模块部分。
- en: Most of the module imports shown here are for regular Node.js modules installed
    in the `node_modules` directory, most of which are CommonJS modules. The rule
    for using `import` with a CommonJS module is that the `module.exports` object
    is treated as if it were the default export. The `import` statement shown earlier
    name the default export (or the `module.exports` object) as shown in the `import`
    statement. For a CommonJS module imported this way, you then use it as you would
    in a CommonJS context, `moduleName.functionName()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的大多数模块导入是为了在 `node_modules` 目录中安装的常规 Node.js 模块，其中大多数是 CommonJS 模块。使用 `import`
    与 CommonJS 模块的规则是，`module.exports` 对象被处理为如果它是默认导出。前面显示的 `import` 语句将默认导出（或 `module.exports`
    对象）命名为 `import` 语句中所示。对于以这种方式导入的 CommonJS 模块，您将像在 CommonJS 上下文中一样使用它，即 `moduleName.functionName()`。
- en: 'The usage of the `debug` module is effectively the same, but is coded differently.
    In the CommonJS context, we''re told to use that module as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug` 模块的使用实际上是相同的，但编码方式不同。在 CommonJS 上下文中，我们被告知如下使用该模块：'
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In other words, the `module.exports` of this module is a function, which we
    immediately invoke. There isn't a syntax for ES6 modules to use the `debug` module
    in that fashion. Therefore, we had to break it apart as shown, and explicitly
    call that function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，该模块的 `module.exports` 是一个函数，我们立即调用它。ES6 模块没有使用 `debug` 模块的那种语法的语法。因此，我们必须像下面那样将其拆分，并显式调用该函数。
- en: The final point of discussion is the `import` of the two router modules. It
    was first attempted to have those modules export the `router` as the default value,
    but Express threw an error in that case. Instead, we'll rewrite these modules
    to export `router` as a named export and then use that named export as shown here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论的最后一个要点是两个路由模块的 `import`。最初尝试让这些模块将 `router` 作为默认值导出，但 Express 在那种情况下抛出了错误。因此，我们将重写这些模块，将
    `router` 作为命名导出，然后像下面这样使用它。
- en: Rewriting bin/www as an ES6 module
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 `bin/www` 重写为 ES6 模块
- en: Remember that `bin/www` is a script used to launch the application. It is written
    as a CommonJS script, but because `app.mjs` is now an ES6 module, `bin/www` also
    must be rewritten as an ES6 module. A CommonJS module cannot, at the time of writing,
    import an ES6 module.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `bin/www` 是一个用于启动应用程序的脚本。它被编写为一个 CommonJS 脚本，但由于 `app.mjs` 现在是一个 ES6 模块，因此
    `bin/www` 也必须被重写为 ES6 模块。在编写本文时，CommonJS 模块不能导入 ES6 模块。
- en: 'Change the filename:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件名：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, at the top, change the `require` statements to `import` statements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在顶部，将 `require` 语句更改为 `import` 语句：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've already discussed everything here except that `app.mjs` exports its `app`
    object as the default export. Therefore, we use it as shown here.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了这里的一切，除了 `app.mjs` 将其 `app` 对象作为默认导出。因此，我们像下面这样使用它。
- en: Rewriting models code as ES6 modules
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型代码重写为 ES6 模块
- en: 'The models directory contains two modules: `Note.js` defines the `Note` class,
    and `notes-memory.js` contains an in-memory data model. Both are easy to convert
    to ES6 modules.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模型目录包含两个模块：`Note.js` 定义了 `Note` 类，而 `notes-memory.js` 包含一个内存中的数据模型。这两个模块都很容易转换为
    ES6 模块。
- en: 'Change the filenames:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件名：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `Note.mjs`, simply make the following change:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Note.mjs` 中，只需进行以下更改：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This makes the `Note` class the default export.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 `Note` 类成为默认导出。
- en: 'Then, in `notes-memory.mjs`, make the following change:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `notes-memory.mjs` 中进行以下更改：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a straightforward transliteration of assigning functions to `module.exports`
    to using named exports.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对将函数分配给 `module.exports` 并使用命名导出的直接转写。
- en: By defining the `Note` class as the default export of the `Note.mjs` module,
    it `import`s nicely  into any module using that class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `Note` 类定义为 `Note.mjs` 模块的默认导出，它可以很好地导入使用该类的任何模块。
- en: Rewriting router modules as ES6 modules
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将路由模块重写为 ES6 模块
- en: The `routes` directory contains two router modules. As it stands, each router
    module creates a `router` object, adds route functions to that object, and then
    assigns it to the `module.exports` field. That suggests we should export the `router`
    as the default export, but as we said earlier, that didn't work out right. Instead,
    we'll export `router` as a named export.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes` 目录包含两个路由模块。目前，每个路由模块创建一个 `router` 对象，向该对象添加路由函数，然后将它分配给 `module.exports`
    字段。这表明我们应该将 `router` 作为默认导出，但如我们之前所说，这并没有成功。相反，我们将 `router` 作为命名导出。'
- en: 'Change the filenames:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件名：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, at the top of each, change the `require` statement block to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每个文件的顶部，将 `require` 语句块更改为以下内容：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It will be the same in both files. Then, at the bottom of each file, delete
    the line assigning `router` to `module.exports`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件将会一样。然后在每个文件的底部，删除将 `router` 赋值给 `module.exports` 的那行代码。
- en: Let's turn to `app.mjs` and change how the router modules are imported.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向 `app.mjs` 并更改导入路由模块的方式。
- en: 'Because `router` is a named export, by default you''d import the `router` object,
    in `app.mjs`, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `router` 是一个命名导出，默认情况下你会在 `app.mjs` 中如下导入 `router` 对象：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But then we''d have a conflict since both modules define a `router` object.
    Instead, we changed the name of this object using an `as` clause:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们会遇到冲突，因为这两个模块都定义了一个 `router` 对象。相反，我们使用 `as` 子句更改了这个对象的名称：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `router` object from each module is hence given a suitable name.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块的 `router` 对象因此被赋予了合适的名称。
- en: Storing notes in the filesystem
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件系统中存储笔记
- en: The filesystem is an often overlooked database engine. While filesystems don't
    have the sort of query features supported by database engines, they are a reliable
    place to store files. The notes schema is simple enough that the filesystem can
    easily serve as its data storage layer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是一个经常被忽视的数据库引擎。虽然文件系统没有数据库引擎支持的查询功能，但它们是存储文件的可靠位置。笔记模式足够简单，以至于文件系统可以轻松地作为其数据存储层。
- en: 'Let''s start by adding a function to `Note.mjs`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `Note.mjs` 添加一个函数开始：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`JSON` is a getter, which means it gets the value of the object. In this case,
    the `note.JSON` attribute/getter, no parentheses, will simply give us the JSON
    representation of the Note. We''ll use this later for writing to JSON files.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON` 是一个获取器，这意味着它获取对象的值。在这种情况下，`note.JSON` 属性/获取器，没有括号，将简单地给出 Note 的 JSON
    表示形式。我们将在写入 JSON 文件时使用这个。'
- en: '`fromJSON` is a static function, or factory method, to aid in constructing
    `Note` objects if we have a JSON string. The difference is that `JSON` is associated
    with an instance of the `Note` class, while `fromJSON` is associated with the
    class itself. The two can be used as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromJSON` 是一个静态函数，或者工厂方法，用于在拥有 JSON 字符串的情况下辅助构建 `Note` 对象。区别在于 `JSON` 与 `Note`
    类的实例相关联，而 `fromJSON` 与类本身相关联。它们可以如下使用：'
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s create a new module, `models/notes-fs.mjs`, to hold the filesystem
    model:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的模块，`models/notes-fs.mjs`，来保存文件系统模型：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `notesDir` function will be used throughout `notes-fs` to ensure that the
    directory exists. To make this simple, we're using the `fs-extra` module because
    it adds Promise-based functions to the `fs` module ([https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra)).
    In this case, `fs.ensureDir` verifies whether the named directory structure exists,
    and, if not, the directory path is created.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`notesDir` 函数将在 `notes-fs` 中被使用，以确保目录存在。为了简化这个过程，我们使用了 `fs-extra` 模块，因为它向 `fs`
    模块添加了基于 Promise 的函数（[https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra)）。在这种情况下，`fs.ensureDir`
    验证指定的目录结构是否存在，如果不存在，则创建目录路径。'
- en: The environment variable, `NOTES_FS_DIR`, configures a directory within which
    to store notes. We'll have one file per note and store the note as JSON. If no
    environment variable is specified, we'll fall back on using `notes-fs-data` as
    the directory name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量 `NOTES_FS_DIR` 配置了一个存储笔记的目录。我们将为每篇笔记创建一个文件，并将笔记存储为 JSON 格式。如果没有指定环境变量，我们将回退到使用
    `notes-fs-data` 作为目录名称。
- en: 'Because we''re adding another dependency:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要添加另一个依赖：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The filename for each data file is the `key` with `.json` appended. That gives
    one limitation that filenames cannot contain the `/` character, so we test for
    that using the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据文件的文件名是带有 `.json` 后缀的 `key`。这带来一个限制，即文件名不能包含 `/` 字符，因此我们使用以下代码进行测试：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As is the case with the `notes-memory` module, the `create` and `update` functions
    use the exact same code. The `notesDir` function is used to ensure that the directory
    exists, then we create a `Note` object, and then write the data to a file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `notes-memory` 模块一样，`create` 和 `update` 函数使用完全相同的代码。`notesDir` 函数用于确保目录存在，然后我们创建一个
    `Note` 对象，然后将数据写入文件。
- en: 'Notice how the code is very straightforward because of the `async` function.
    We aren''t checking for errors because they''ll be automatically caught by the
    `async` function and bubble out to our caller:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码因为使用了 `async` 函数而非常直接。我们不需要检查错误，因为它们将被 `async` 函数自动捕获并传递给我们的调用者：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using `readJSON`, read the file from the disk. It already generates the `Note`
    object, so all we have to do is return that object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `readJSON` 从磁盘读取文件。它已经生成了 `Note` 对象，所以我们只需返回该对象即可：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `fs.unlink` function deletes our file. Because this module uses the filesystem,
    deleting the file is all that''s necessary to delete the `note` object:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.unlink`函数删除我们的文件。因为这个模块使用文件系统，所以删除文件就是删除`note`对象所必需的：'
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The contract for `keylist` is to return a Promise that will resolve to an array
    of keys for existing note objects. Since they're stored as individual files in
    the `notesdir`, we have to read every file in that directory to retrieve its key.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`keylist`的合约是返回一个Promise，该Promise将解析为现有笔记对象的键数组。由于它们作为单独的文件存储在`notesdir`中，我们必须读取该目录中的每个文件来检索其键。'
- en: '`Array.map` constructs a new array from an existing array, namely the array
    of filenames returned by `fs.readdir`. Each entry in the constructed array is
    the `async` function, which reads the Note, returning the `key`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.map`从一个现有的数组（即由`fs.readdir`返回的文件名数组）构造一个新的数组。构造数组中的每个条目都是一个`async`函数，它读取笔记，返回`key`：'
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Counting the number of notes is simply a matter of counting the number of files in
    `notesdir`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 计算笔记的数量只是简单地计算`notesdir`中文件的数量。
- en: Dynamic import of ES6 modules
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6模块的动态导入
- en: Before we start modifying the router functions, we have to consider how to account
    for multiple models. We currently have two modules for our data model, `notes-memory`
    and `notes-fs`, and we'll be implementing several more by the end of this chapter.
    We will need a simple method to select between the model being used.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始修改路由函数之前，我们必须考虑如何处理多个模型。我们目前有两个数据模型模块，`notes-memory`和`notes-fs`，并且我们将在本章结束时实现更多。我们需要一个简单的方法来选择正在使用的模型。
- en: 'There are several possible ways to do this. For example, in a CommonJS module,
    it''s possible to do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可能的方法可以做到这一点。例如，在一个CommonJS模块中，可以这样做：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This lets us set an environment variable, `NOTES_MODEL`, to select the module
    to use for the data model.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以设置一个环境变量`NOTES_MODEL`来选择用于数据模型的模块。
- en: This approach does not work with the regular `import` statement, because the
    module name in an `import` statement cannot be such an expression.  The Dynamic
    Import feature now in Node.js does offer a mechanism similar to the snippet just
    shown.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不适用于常规的`import`语句，因为`import`语句中的模块名不能是这种表达式。现在Node.js中的动态导入功能确实提供了一个类似于刚才显示的片段的机制。
- en: 'Dynamic import is an `import()` function that returns a Promise that will resolve
    to the imported module. As a function-returning-a-Promise, `import()` won''t be
    useful as top-level code in the module. But, consider this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 动态导入是一个返回Promise的`import()`函数，该Promise将解析为导入的模块。作为一个返回Promise的函数，`import()`在模块的顶层代码中不会很有用。但是，考虑以下情况：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save that module in a file, `models/notes.mjs`. This module implements the same
    API as we'll use for all Notes model modules. The `model()` function is the key
    to dynamically selecting a notes model implementation based on an environment
    variable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将该模块保存在文件`models/notes.mjs`中。该模块实现了我们将用于所有笔记模型模块的相同API。`model()`函数是动态选择基于环境变量的笔记模型实现的关键。
- en: This is an `async` function and therefore its return value is a Promise. The
    value of that Promise is the selected module, as loaded by `import()`. Because
    `import()` returns a Promise, we use `await` to know whether it loaded correctly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`async`函数，因此它的返回值是一个Promise。该Promise的值是`import()`加载的所选模块。因为`import()`返回一个Promise，所以我们使用`await`来知道它是否正确加载。
- en: 'Every API method follows this pattern:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个API方法都遵循以下模式：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Because `model()` returns a Promise, it''s most succinct to use an `async`
    function and use `await` to resolve the Promise. Once the Promise is resolved,
    we simply call the `methodName` function and go about our business. Otherwise,
    those API method functions would be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`model()`返回一个Promise，所以最简洁的方法是使用一个`async`函数，并使用`await`来解析Promise。一旦Promise解析完成，我们只需调用`methodName`函数并继续我们的业务。否则，那些API方法函数将如下所示：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The two implementations are equivalent, and it's clear which is the more succinct.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种实现是等效的，并且很明显哪种更简洁。
- en: 'With all this `await`ing on Promise''s returned from `async` functions, it''s
    worth discussing the overhead. The worst case is on the first call to `model()`,
    because the selected notes model has not been loaded. The first time around, the
    call flow goes as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些对`async`函数返回的Promise的`await`等待中，讨论开销是值得的。最坏的情况是在第一次调用`model()`时，因为选定的笔记模型尚未加载。第一次调用时，调用流程如下：
- en: The API method calls `model()`, which calls `import()`, then `await`'s the module
    to finish loading
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API方法调用`model()`，然后调用`import()`，然后`await`模块以完成加载
- en: The API method `await`'s the Promise returned from `model()`, getting the module
    object, and it then calls the API function
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API方法`await`等待`model()`返回的Promise，获取模块对象，然后调用API函数
- en: The caller is also using `await` to receive the final result
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者也在使用`await`来接收最终结果
- en: The first time around, the time is dominated by waiting on `import()` to finish
    loading the module. On subsequent calls, the module has already been loaded and
    the first step is to simply form a resolved Promise containing the module. The
    API method can then quickly get on with delegating to the actual API method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行时，时间主要被`import()`加载模块的过程所占据。在后续调用中，模块已经被加载，第一步就是简单地形成一个包含模块的已解析的Promise。然后API方法可以快速地委托给实际的API方法。
- en: 'To use this, in `routes/index.mjs`, and in `routes/notes.mjs`, we make this
    change:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个功能，在`routes/index.mjs`和`routes/notes.mjs`中，我们进行以下更改：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Running the Notes application with filesystem storage
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件系统存储运行笔记应用程序
- en: 'In `package.json`, add this to the `scripts` section:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，在`scripts`部分添加以下内容：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you put these entries in `package.json`, make sure that you use correct
    JSON syntax. In particular, if you leave a comma at the end of the `scripts` section,
    it will fail to parse and npm will throw up an error message.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`package.json`中放入这些条目时，请确保使用正确的JSON语法。特别是，如果你在`scripts`部分的末尾留下逗号，它将无法解析，并且npm将抛出一个错误信息。
- en: 'With this code in place, we can now run the *Notes* application as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好这段代码后，我们现在可以按照以下方式运行*笔记*应用程序：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then we can use the application at `http://localhost:3000` as before. Because
    we did not change any template or CSS files, the application will look exactly
    as you left it at the end of Chapter 6, *Implementing the Mobile-First Paradigm*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在之前一样的方式使用`http://localhost:3000`上的应用程序。因为我们没有更改任何模板或CSS文件，所以应用程序将看起来与你在第6章*实现移动优先范式*结束时的样子完全一样。
- en: Because debugging is turned on for `notes:*`, we'll see a log of whatever the
    *Notes* application is doing. It's easy to turn this off simply by not setting
    the `DEBUG` variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`notes:*`的调试被打开，我们会看到*笔记*应用程序正在进行的日志。通过简单地不设置`DEBUG`变量，很容易关闭这个功能。
- en: 'You can now kill and restart the *Notes* application and see the exact same
    notes. You can also edit the notes at the command line using regular text editors
    such as `vi`. You can now start multiple servers on different ports and see exactly
    the same notes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以终止并重新启动*笔记*应用程序，并看到完全相同的笔记。你还可以使用常规文本编辑器，如`vi`在命令行中编辑笔记。你现在可以在不同的端口上启动多个服务器，并看到完全相同的笔记：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Then you start `server1` and `server2` in separate command windows as we did
    in [Chapter 5](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml), *Your First Express
    Application*. Then, visit the two servers in separate browser windows, and you
    will see that both browser windows show the same notes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你在单独的命令窗口中启动`server1`和`server2`，就像我们在第5章*你的第一个Express应用程序*中做的那样。然后，在单独的浏览器窗口中访问这两个服务器，你将看到两个浏览器窗口都显示了相同的笔记。
- en: The final check is to create a note where the key has a `/` character. Remember
    that the key is used to generate the filename where we store the note, and therefore
    the key cannot contain a `/` character. With the browser open, click on ADD Note
    and enter a note, ensuring that you use a `/` character in the `key` field. On
    clicking the Submit button, you'll see an error saying that this isn't allowed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的检查是创建一个键中包含`/`字符的笔记。记住，键用于生成存储笔记的文件名，因此键不能包含`/`字符。在浏览器打开的情况下，点击“添加笔记”并输入笔记，确保你在`key`字段中使用`/`字符。点击提交按钮时，你会看到一个错误信息，说明这是不允许的。
- en: Storing notes with the LevelUP data store
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LevelUP数据存储存储笔记
- en: 'To get started with actual databases, let''s look at an extremely lightweight, small-footprint
    database engine: **LevelUP**. This is a Node.js-friendly wrapper around the LevelDB
    engine developed by Google, which is normally used in web browsers for local data
    persistence. It is a non-indexed, NoSQL data store designed originally for use
    in browsers. The Node.js module, Level, uses the LevelDB API, and supports multiple
    backends, including `LevelDOWN`, which integrates the C++ LevelDB database into
    Node.js.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用实际的数据库，让我们看看一个非常轻量级、小体积的数据库引擎：**LevelUP**。这是一个围绕Google开发的LevelDB引擎的Node.js友好型包装器，通常用于在网页浏览器中进行本地数据持久化。它是一个非索引的NoSQL数据存储，最初是为在浏览器中使用而设计的。Node.js模块Level使用LevelDB
    API，并支持多个后端，包括`LevelDOWN`，它将C++ LevelDB数据库集成到Node.js中。
- en: Visit [https://www.npmjs.com/package/level](https://www.npmjs.com/package/level)
    for information on the module. The `level` package automatically sets up the `levelup`
    and `leveldown` packages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://www.npmjs.com/package/level](https://www.npmjs.com/package/level)
    获取有关模块的信息。`level` 包自动设置 `levelup` 和 `leveldown` 包。
- en: 'To install the database engine, run this command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装数据库引擎，请运行以下命令：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, start creating the `models/notes-level.mjs` module:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，开始创建 `models/notes-level.mjs` 模块：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `level` module gives us a `db` object through which to interact with the
    database. We're storing that object as a global within the module for ease of
    use. If the `db` object is set, we can just return it immediately. Otherwise,
    we open the database using `createIfMissing` to go ahead and create the database
    if needed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`level` 模块通过 `db` 对象为我们提供了一个与数据库交互的方式。我们为了方便使用，将此对象作为模块中的全局变量存储。如果 `db` 对象已设置，我们就可以立即返回它。否则，我们将使用
    `createIfMissing` 打开数据库，以便在需要时创建数据库。'
- en: 'The location of the database defaults to `notes.level` in the current directory.
    The environment variable `LEVELDB_LOCATION` can be set, as the name implies, to
    specify the database location:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的位置默认为当前目录中的 `notes.level`。可以通过设置环境变量 `LEVELDB_LOCATION`（顾名思义）来指定数据库位置：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Calling `db.put` either creates a new database entry, or replaces an existing
    one. Therefore, both `update` and `create` are set to be the same function. We
    convert the Note to JSON so it can be easily stored in the database:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `db.put` 要么创建一个新的数据库条目，要么替换现有的一个。因此，`update` 和 `create` 都被设置为相同的函数。我们将笔记转换为
    JSON，以便它可以轻松地存储在数据库中：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Reading a Note is easy: just call `db.get` and it retrieves the data, which
    must be decoded from the JSON representation.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 读取笔记很简单：只需调用 `db.get`，它将检索数据，该数据必须从 JSON 表示形式中解码。
- en: 'Notice that `db.get` and `db.put` did not take a callback function, and that
    we use `await` to get the results value. The functions exported by `level` can
    take a callback function, in which the callback will be invoked. Alternatively,
    if no callback function is provided, the `level` function will instead return
    a Promise for compatibility with `async` functions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`db.get` 和 `db.put` 没有使用回调函数，我们使用 `await` 来获取结果值。`level` 导出的函数可以接受回调函数，其中回调将被调用。如果没有提供回调函数，则
    `level` 函数将返回一个 Promise 以与 `async` 函数兼容：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `db.destroy` function deletes a record from the database:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.destroy` 函数从数据库中删除记录：'
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `createKeyStream` function uses an event-oriented interface similar to the
    Streams API. It will stream through every database entry, emitting events as it
    goes. A `data` event is emitted for every key in the database, while the `end`
    event is emitted at the end of the database, and the `error` event is emitted
    on errors. The effect is that there's no simple way to present this as a simple
    Promise. Instead, we invoke `createKeyStream`, let it run its course, collecting
    data as it goes. We have to wrap it inside a Promise object, and call resolve
    on the `end` event.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`createKeyStream` 函数使用类似于 Streams API 的事件驱动接口。它将流经每个数据库条目，在过程中发出事件。对于数据库中的每个键都会发出
    `data` 事件，在数据库结束时发出 `end` 事件，在出错时发出 `error` 事件。结果是，没有简单的方法来将其表示为一个简单的 Promise。相反，我们调用
    `createKeyStream`，让它运行，在运行过程中收集数据。我们必须将其包装在一个 Promise 对象中，并在 `end` 事件上调用 resolve。'
- en: 'Then we add this to `package.json` in the `scripts` section:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此内容添加到 `package.json` 的 `scripts` 部分：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, you can run the *Notes* application:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以运行 *Notes* 应用程序：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The printout in the console will be the same, and the application will also
    look the same. You can put it through its paces and see that everything works
    correctly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中的打印输出将与应用程序相同。您可以对其进行测试，以查看一切是否正常工作。
- en: Since `level` does not support simultaneous access to a database from multiple
    instances, you won't be able to use the multiple *Notes* application scenario.
    You will, however, be able to stop and restart the application at will without
    losing any notes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `level` 不支持多个实例同时访问数据库，您将无法使用多个 *Notes* 应用程序场景。然而，您将能够随意停止和重新启动应用程序而不会丢失任何笔记。
- en: Storing notes in SQL with SQLite3
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLite3 在 SQL 中存储笔记
- en: To get started with more normal databases, let's see how to use SQL from Node.js.
    First, we'll use SQLite3, a lightweight, simple-to-set-up database engine eminently
    suitable for many applications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用更常见的数据库，让我们看看如何在 Node.js 中使用 SQL。首先，我们将使用 SQLite3，这是一个轻量级、易于设置的数据库引擎，非常适合许多应用程序。
- en: To learn about that database engine, visit [http://www.sqlite.org/](http://www.sqlite.org/).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解该数据库引擎，请访问[http://www.sqlite.org/](http://www.sqlite.org/)。
- en: To learn about the Node.js module, visit [https://github.com/mapbox/node-sqlite3/wiki/API](https://github.com/mapbox/node-sqlite3/wiki/API)
    or [https://www.npmjs.com/package/sqlite3](https://www.npmjs.com/package/sqlite3).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Node.js模块，请访问[https://github.com/mapbox/node-sqlite3/wiki/API](https://github.com/mapbox/node-sqlite3/wiki/API)或[https://www.npmjs.com/package/sqlite3](https://www.npmjs.com/package/sqlite3)。
- en: The primary advantage of SQLite3 is that it doesn't require a server; it is
    a self-contained, no-set-up-required SQL database.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite3的主要优势是它不需要服务器；它是一个自包含的、无需设置的SQL数据库。
- en: 'The first step is to install the module:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装模块：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: SQLite3 database schema
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite3数据库模式
- en: 'Next, we need to make sure that our database is configured. We''re using this
    SQL table definition for the schema (save this as `models/schema-sqlite3.sql`):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们的数据库已配置。我们使用以下SQL表定义作为模式（将其保存为`models/schema-sqlite3.sql`）：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'How do we initialize this schema before writing some code? One way is to ensure
    that the `sqlite3` package is installed through your operating system package
    management system, such as using `apt-get` on Ubuntu/Debian, and MacPorts on macOS.
    Once it''s installed, you can run the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在编写代码之前初始化这个模式？一种方法是通过您的操作系统包管理系统确保安装了`sqlite3`包，例如在Ubuntu/Debian上使用`apt-get`，在macOS上使用MacPorts。一旦安装完成，您就可以运行以下命令：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: While we can do that, the Twelve Factor application model says we must automate
    any administrative processes in this way. To that end, we should instead write
    a little script to run an SQL operation on SQLite3 and use that to initialize
    the database.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以这样做，但十二要素应用程序模型表示我们必须以这种方式自动化任何管理过程。为此，我们应该编写一个小脚本，在SQLite3上运行SQL操作，并使用它来初始化数据库。
- en: 'Fortunately, the `sqlite3` command offers us a way to do this. Add the following
    to the `scripts` section of `package.json`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`sqlite3`命令为我们提供了这样做的方法。将以下内容添加到`package.json`的`scripts`部分：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the setup script:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行设置脚本：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We could have written a small Node.js script to do this, and it's easy to do
    so. However, by using the tools provided by the package, we have less code to
    maintain in our own project.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个小的Node.js脚本来完成这个任务，这样做也很容易。然而，通过使用包提供的工具，我们在自己的项目中需要维护的代码更少。
- en: SQLite3 model code
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite3模型代码
- en: Now, we can write code to use this database in the *Notes* application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写代码来在*笔记*应用程序中使用这个数据库。
- en: 'Create `models/notes-sqlite3.mjs` file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`models/notes-sqlite3.mjs`文件：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This serves the same purpose as the `connectDB` function in `notes-level.mjs`:
    to manage the database connection. If the database is not open, it''ll go ahead
    and do so, and even make sure that the database file is created (if it doesn''t
    exist). But if it is already open, it is immediately returned:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`notes-level.mjs`中的`connectDB`函数具有相同的目的：管理数据库连接。如果数据库没有打开，它会继续打开，并确保数据库文件被创建（如果不存在）。但如果数据库已经打开，它将立即返回：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: These are our `create` and `update` functions. As promised, we are now justified
    in defining the Notes model to have separate functions for `create` and `update`
    operations, because the SQL statement for each is different.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的`create`和`update`函数。正如承诺的那样，我们现在有理由定义笔记模型，使其具有`create`和`update`操作的单独函数，因为每个的SQL语句都不同。
- en: Calling `db.run` executes an SQL query, giving us the opportunity to insert
    parameters into the query string.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`db.run`执行SQL查询，给我们机会将参数插入到查询字符串中。
- en: The `sqlite3` module uses a parameter substitution paradigm that's common in SQL
    programming interfaces. The programmer puts the SQL query into a string, and then
    places a question mark in each place where the aim is to insert a value into the
    query string. Each question mark in the query string has to match a value in the
    array provided by the programmer. The module takes care of encoding the values
    correctly so that the query string is properly formatted, while preventing SQL
    injection attacks.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3`模块使用在SQL编程接口中常见的参数替换范式。程序员将SQL查询放入字符串中，然后在要插入值的地方放置一个问号。查询字符串中的每个问号都必须与程序员提供的数组中的值匹配。模块负责正确编码值，以确保查询字符串格式正确，同时防止SQL注入攻击。'
- en: 'The `db.run` function simply runs the SQL query it is given, and does not retrieve any
    data. Because the `sqlite3` module doesn''t produce any kind of Promise, we have
    to wrap function calls in a `Promise` object:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.run` 函数简单地运行它所给的 SQL 查询，并不检索任何数据。因为 `sqlite3` 模块不产生任何类型的 Promise，我们必须在函数调用中包裹一个
    `Promise` 对象：'
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To retrieve data using the `sqlite3` module, you use the `db.get`, `db.all`,
    or `db.each` functions. The `db.get` function used here returns only the first
    row of the result set. The `db.all` function returns all rows of the result set
    at once, which can be a problem for available memory if the result set is large.
    The `db.each` function retrieves one row at a time, while still allowing processing
    of the entire result set.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `sqlite3` 模块检索数据，你使用 `db.get`、`db.all` 或 `db.each` 函数。这里使用的 `db.get` 函数只返回结果集的第一行。`db.all`
    函数一次性返回结果集的所有行，如果结果集很大，这可能会成为内存问题。`db.each` 函数逐行检索，同时仍然允许处理整个结果集。
- en: For the *Notes* application, using `db.get` to retrieve a note is sufficient
    because there is only one note per `notekey`. Therefore, our `SELECT` query will
    return at most one row anyway. But what if your application will see multiple
    rows in the result set? We'll see what to do about that in a minute.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *笔记* 应用程序，使用 `db.get` 来检索笔记是足够的，因为每个 `notekey` 只有一个笔记。因此，我们的 `SELECT` 查询无论如何最多只返回一行。但如果你的应用程序会在结果集中看到多行呢？我们将在下一分钟看看如何处理这个问题。
- en: 'By the way, this `read` function has a bug in it. See if you can spot the error.
    We''ll read more about this in Chapter 11, *Unit Testing and Functional Testing*,
    when our testing efforts uncover the bug:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这个 `read` 函数中有一个错误。看看你是否能找到错误。我们将在第 11 章 *单元测试和功能测试* 中了解更多，当我们的测试工作揭示这个错误时：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To destroy a note, we simply execute the `DELETE FROM` statement:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除笔记，我们只需执行 `DELETE FROM` 语句：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `db.all` function retrieves all rows of the result set.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.all` 函数检索结果集的所有行。'
- en: 'The contract for this function is to return an array of note keys. The `rows`
    object is an array of results from the database that contains the data we are
    to return, but in a different format. Therefore, we use the `map` function to
    convert the array into the format required to fulfill the contract:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的合约是返回一个笔记键数组。`rows` 对象是从数据库中返回的结果数组，它包含我们要返回的数据，但格式不同。因此，我们使用 `map` 函数将数组转换为满足合约的格式：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can simply use SQL to count the number of notes for us. In this case, `db.get`
    returns a row with a single column, `count`, which is the value we want to return.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用 SQL 来为我们计算笔记的数量。在这种情况下，`db.get` 返回一个包含单个列 `count` 的行，这是我们想要返回的值。
- en: Running Notes with SQLite3
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLite3 运行 Notes
- en: 'Finally, we''re ready to run the *Notes* application with SQLite3\. Add the
    following code to the `scripts` section of `package.json`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好使用 SQLite3 运行 *笔记* 应用程序。将以下代码添加到 `package.json` 的 `scripts` 部分：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run the *Notes* application:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *笔记* 应用程序：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You can now browse the application at `http://localhost:3000`, and run it through
    its paces as before.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以浏览应用程序在 `http://localhost:3000`，并且像之前一样运行它。
- en: 'Because SQLite3 supports simultaneous access from multiple instances, you can
    run the multiserver example by adding this to the `scripts` section of `package.json`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 SQLite3 支持来自多个实例的并发访问，你可以通过将此添加到 `package.json` 的 `scripts` 部分来运行多服务器示例：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Then, run each of these in separate command Windows, as before.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像之前一样，在单独的命令窗口中运行这些命令。
- en: Because we still haven't made any changes to the View templates or CSS files, the
    application will look the same as before.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有对视图模板或 CSS 文件进行任何更改，应用程序看起来和之前一样。
- en: 'Of course, you can use the `sqlite` command, or other SQLite3 client applications,
    to inspect the database:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用 `sqlite` 命令，或其他 SQLite3 客户端应用程序来检查数据库：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Storing notes the ORM way with Sequelize
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sequelize 的 ORM 方法存储笔记
- en: There are several popular SQL database engines, such as PostgreSQL, MySQL ([https://www.npmjs.com/package/mysql](https://www.npmjs.com/package/mysql)),
    and MariaDB ([https://www.npmjs.com/package/mariasql](https://www.npmjs.com/package/mariasql)).
    Corresponding to each are Node.js client modules similar in nature to the `sqlite3`
    module that we just used. The programmer is close to the SQL, which can be good
    in the same way that driving a stick shift car is fun. But what if we want a higher-level
    view of the database so that we can think in terms of objects rather than rows
    of a database table? **Object Relation Mapping** (**ORM**) systems provide such
    a higher-level interface and even offer the ability to use the same data model
    with several databases.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种流行的 SQL 数据库引擎，例如 PostgreSQL、MySQL ([https://www.npmjs.com/package/mysql](https://www.npmjs.com/package/mysql))
    和 MariaDB ([https://www.npmjs.com/package/mariasql](https://www.npmjs.com/package/mariasql))。每个数据库引擎都对应着类似我们刚刚使用的
    `sqlite3` 模块的 Node.js 客户端模块。程序员可以接近 SQL，这就像驾驶手动挡汽车一样有趣。但如果我们想要一个更高层次的数据库视图，以便我们可以从对象的角度而不是数据库表中的行来思考呢？**对象关系映射**（**ORM**）系统提供了这样的高级接口，甚至可以提供使用相同数据模型与多个数据库的能力。
- en: The **Sequelize** module ([http://www.sequelizejs.com/](http://www.sequelizejs.com/))
    is Promise-based, offers strong, well-developed ORM features, and can connect
    with SQLite3, MySQL, PostgreSQL, MariaDB, and MSSQL. Because Sequelize is Promise-based,
    it will fit naturally with the Promise-based application code we're writing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sequelize** 模块 ([http://www.sequelizejs.com/](http://www.sequelizejs.com/))
    基于 Promise，提供了强大、成熟的 ORM 功能，并且可以连接到 SQLite3、MySQL、PostgreSQL、MariaDB 和 MSSQL。由于
    Sequelize 基于 Promise，它将自然地与我们所编写的基于 Promise 的应用程序代码兼容。'
- en: A prerequisite to most SQL database engines is having access to a database server.
    In the previous section, we skirted around that issue by using SQLite3, which
    requires no database server setup. While it's possible to install a database server
    on your laptop, we want to avoid the complexity of doing so, and will use Sequelize
    to manage an SQLite3 database. We'll also see that it's simply a matter of a configuration
    file to run the same Sequelize code against a hosted database such as MySQL. In [Chapter
    10](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml), *Deploying Node.js Applications*,
    we'll learn how to use Docker to easily set up any service, including database
    servers, on our laptop and deploy the exact same configuration to a live server. Most
    web hosting providers offer MySQL or PostgreSQL as part of the service.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 SQL 数据库引擎的一个先决条件是能够访问数据库服务器。在上一节中，我们通过使用 SQLite3 来绕过这个问题，因为 SQLite3 不需要设置数据库服务器。虽然可以在您的笔记本电脑上安装数据库服务器，但我们想避免这种复杂性，并使用
    Sequelize 来管理 SQLite3 数据库。我们还将看到，只需一个配置文件就可以运行相同的 Sequelize 代码，针对托管数据库，如 MySQL。在
    [第 10 章](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml)，*部署 Node.js 应用程序* 中，我们将学习如何使用
    Docker 在笔记本电脑上轻松设置任何服务，包括数据库服务器，并将相同的配置部署到实时服务器。大多数网络托管提供商将 MySQL 或 PostgreSQL
    作为服务的一部分提供。
- en: 'Before we start on the code, let''s install two modules:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们安装两个模块：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The first obviously installs the Sequelize package. The second, `js-yaml`, is
    installed so that we can implement a YAML-formatted file to store the Sequelize
    connection configuration. YAML is a human-readable *data serialization language*,
    which simply means YAML is an easy-to-use text file format to describe data objects.
    Perhaps the best place to learn about YAML is its Wikipedia page at [https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模块显然是安装 Sequelize 包。第二个模块 `js-yaml` 是为了我们可以实现一个 YAML 格式的文件来存储 Sequelize 连接配置。YAML
    是一种可读性强的 *数据序列化语言*，这意味着 YAML 是一种易于使用的文本文件格式，用于描述数据对象。也许了解 YAML 的最佳地方是它的维基百科页面
    [https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML)。
- en: Sequelize model for the Notes application
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes 应用程序的 Sequelize 模型
- en: 'Let''s create a new file, `models/notes-sequelize.mjs`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件，`models/notes-sequelize.mjs`：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The database connection is stored in the `sequlz` object, and is established
    by reading a configuration file (we'll go over this file later), and instantiating
    a Sequelize instance. The data model, `SQNote`, describes our object structure to
    Sequelize so that it can define corresponding database table(s). If `SQNote` is
    already defined, we simply return it, otherwise we define and return `SQNote`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接存储在 `sequlz` 对象中，通过读取配置文件（我们稍后会介绍这个文件）并实例化一个 Sequelize 实例来建立连接。数据模型 `SQNote`
    向 Sequelize 描述我们的对象结构，以便它可以定义相应的数据库表。如果 `SQNote` 已经定义，我们只需返回它，否则我们定义并返回 `SQNote`。
- en: The Sequelize connection parameters are stored in a YAML file we specify in
    the `SEQUELIZE_CONNECT` environment variable. The line `new Sequelize(..)` opens
    the database connection. The parameters obviously contain any needed database
    name, username, password, and other options required to connect with the database.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 连接参数存储在我们通过 `SEQUELIZE_CONNECT` 环境变量指定的 YAML 文件中。`new Sequelize(..)`
    这一行打开数据库连接。显然，参数包含任何需要的数据库名称、用户名、密码以及其他与数据库连接所需的选项。
- en: The line `sequlz.define` is where we define the database schema. Instead of
    defining the schema as the SQL command to create the database table, we're giving
    a high-level description of the fields and their characteristics. Sequelize maps
    the object attributes into columns in tables.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequlz.define` 这一行是我们定义数据库模式的地方。我们不是将模式定义为创建数据库表的 SQL 命令，而是提供了一个字段及其特性的高级描述。Sequelize
    将对象属性映射到表中的列。'
- en: We're telling Sequelize to call this schema Note, but we're using a `SQNote`
    variable to refer to that schema. That's because we already defined Note as a
    class to represent notes. To avoid a clash of names, we'll keep using the `Note`
    class, and use SQNote to interact with Sequelize about the notes stored in the
    database.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉 Sequelize 调用这个模式 Note，但我们使用 `SQNote` 变量来引用该模式。这是因为我们已将 Note 定义为一个表示笔记的类。为了避免名称冲突，我们将继续使用
    `Note` 类，并使用 SQNote 与数据库中存储的笔记交互。
- en: 'Online documentation can be found at the following locations:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下位置可以找到在线文档：
- en: Sequelize class: [http://docs.sequelizejs.com/en/latest/api/sequelize/](http://docs.sequelizejs.com/en/latest/api/sequelize/).
    [](http://docs.sequelizejs.com/en/latest/api/sequelize/) Defining models: [http://docs.sequelizejs.com/en/latest/api/model/](http://docs.sequelizejs.com/en/latest/api/model/).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize 类：[http://docs.sequelizejs.com/en/latest/api/sequelize/](http://docs.sequelizejs.com/en/latest/api/sequelize/)。
    [http://docs.sequelizejs.com/en/latest/api/sequelize/](http://docs.sequelizejs.com/en/latest/api/sequelize/)
    定义模型：[http://docs.sequelizejs.com/en/latest/api/model/](http://docs.sequelizejs.com/en/latest/api/model/)。
- en: 'Add these functions to `models/notes-sequelize.mjs`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些函数添加到 `models/notes-sequelize.mjs`：
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There are several ways to create a new object instance in Sequelize. The simplest is
    to call an object's `create` function (in this case, `SQNote.create`). That function
    collapses together two other functions, `build` (to create the object), and `save`
    (to write it to the database).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sequelize 中创建新的对象实例有几种方法。最简单的是调用一个对象的 `create` 函数（在这个例子中，`SQNote.create`）。这个函数将两个其他函数
    `build`（用于创建对象）和 `save`（用于将其写入数据库）合并在一起。
- en: Updating an object instance is a little different. First, we must retrieve its
    entry from the database using the `find` operation. The `find` operation is given
    an object specifying the query. Using `find`, we retrieve one instance, whereas
    the `findAll` operation retrieves all matching instances.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 更新对象实例略有不同。首先，我们必须使用 `find` 操作从数据库中检索其条目。`find` 操作提供了一个指定查询的对象。使用 `find`，我们检索一个实例，而
    `findAll` 操作检索所有匹配的实例。
- en: For documentation on Sequelize queries, visit [http://docs.sequelizejs.com/en/latest/docs/querying/](http://docs.sequelizejs.com/en/latest/docs/querying/).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Sequelize 查询的文档，请访问 [http://docs.sequelizejs.com/en/latest/docs/querying/](http://docs.sequelizejs.com/en/latest/docs/querying/)。
- en: Like most or all other Sequelize functions, `SQNote.find` returns a Promise.
    Therefore, inside an `async` function, we `await` the result of the operation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数或所有其他 Sequelize 函数一样，`SQNote.find` 返回一个 Promise。因此，在 `async` 函数内部，我们需要 `await`
    操作的结果。
- en: 'The update operation requires two steps, the first being to `find` the corresponding
    object to read it in from the database. Once the instance is found, we can update
    its values simply with the `updateAttributes` function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作需要两个步骤，第一步是使用 `find` 操作找到相应的对象以从数据库中读取它。一旦找到实例，我们就可以使用 `updateAttributes`
    函数简单地更新其值：
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: To read a note, we use the `find` operation again. There is the possibility
    of an empty result, and we have to throw an error to match.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 读取笔记时，我们再次使用 `find` 操作。可能存在空结果的可能性，我们必须抛出一个错误来匹配。
- en: 'The contract for this function is to return a `Note` object. That means taking
    the fields retrieved using Sequelize and using that to create a `Note` object:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的合约是返回一个 `Note` 对象。这意味着使用 Sequelize 获取的字段来创建一个 `Note` 对象：
- en: '[PRE70]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To destroy a note, we use the `find` operation to retrieve its instance, and
    then call its `destroy()` method:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁一个笔记，我们使用 `find` 操作检索其实例，然后调用其 `destroy()` 方法：
- en: '[PRE71]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Because the `keylist` function acts on all `Note` objects, we use the `findAll`
    operation. We query for the `notekey` attribute on all notes. We''re given an
    array of objects with a field named `notekey`, and we use the `.map` function
    to convert this into an array of the note keys:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`keylist`函数作用于所有`Note`对象，我们使用`findAll`操作。我们查询所有笔记上的`notekey`属性。我们得到了一个名为`notekey`的字段的对象数组，我们使用`.map`函数将其转换为笔记键的数组：
- en: '[PRE72]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: For the `count` function, we can just use the `count()` method to calculate
    the needed result.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`count`函数，我们可以直接使用`count()`方法来计算所需的结果。
- en: Configuring a Sequelize database connection
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Sequelize数据库连接
- en: Sequelize supports the same API on several SQL database engines. The database
    connection is initialized using parameters on the Sequelize constructor. The Twelve
    Factor Application model suggests that configuration data such as this should
    be kept outside the code and injected using environment variables or a similar
    mechanism. What we'll do is use a YAML-formatted file to store the connection
    parameters, specifying the filename with an environment variable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize在几个SQL数据库引擎上支持相同的API。数据库连接是通过Sequelize构造函数的参数初始化的。十二要素应用程序模型建议，此类配置数据应保存在代码外部，并使用环境变量或类似机制注入。我们将使用YAML格式的文件来存储连接参数，并通过环境变量指定文件名。
- en: The Sequelize library does not define any such file for storing connection parameters.
    But it's simple enough to develop such a file. Let's do so.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize库没有定义用于存储连接参数的此类文件。但开发这样的文件很简单。让我们这样做。
- en: 'The API for the Sequelize constructor is: `constructor(database: String, username:
    String, password: String, options: Object)`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'Sequelize构造函数的API是：`constructor(database: String, username: String, password:
    String, options: Object)`。'
- en: 'In the `connectDB` function, we wrote the constructor as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`connectDB`函数中，我们构造器编写如下：
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This file, named `models/sequelize-sqlite.yaml`, provides with us a simple
    mapping that looks like this for an SQLite3 database:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`models/sequelize-sqlite.yaml`的文件为我们提供了一个简单的映射，如下所示，用于SQLite3数据库：
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The YAML file is a direct mapping to the Sequelize constructor parameters. The `dbname`,
    `username`, and `password` fields in this file correspond directly to the connection
    credentials, and the `params` object gives additional parameters. There are many,
    many, possible attributes to use in the `params` field, and you can read about
    them in the Sequelize documentation at [http://docs.sequelizejs.com/manual/installation/usage.html](http://docs.sequelizejs.com/manual/installation/usage.html).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件是Sequelize构造函数参数的直接映射。此文件中的`dbname`、`username`和`password`字段直接对应于连接凭证，而`params`对象提供了额外的参数。`params`字段中有许多可能的属性可以使用，你可以在Sequelize文档中阅读有关它们的更多信息，请参阅[http://docs.sequelizejs.com/manual/installation/usage.html](http://docs.sequelizejs.com/manual/installation/usage.html)。
- en: The `dialect` field tells Sequelize what kind of database to use. For an SQLite
    database, the database filename is given in the `storage` field.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialect`字段告诉Sequelize使用哪种类型的数据库。对于SQLite数据库，数据库文件名在`storage`字段中给出。'
- en: Let's first use SQLite3, because no further setup is required. After that, we'll
    get adventurous and reconfigure our Sequelize module to use MySQL.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用SQLite3，因为不需要进一步设置。之后，我们将尝试使用MySQL重新配置我们的Sequelize模块。
- en: 'If you already have a different database server available, it''s simple to
    create a corresponding configuration file. For a plausible MySQL database on your
    laptop, create a new file, such as `models/sequelize-mysql.yaml`, containing something
    like the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个不同的数据库服务器可用，创建相应的配置文件很简单。对于笔记本电脑上的一个合理的MySQL数据库，创建一个新的文件，例如`models/sequelize-mysql.yaml`，包含以下代码：
- en: '[PRE75]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This is straightforward. The `username` and `password` must correspond to the
    database credentials, while `host` and `port` will specify where the database
    is hosted.  Set the database `dialect` and other connection information, and you're
    good to go.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。`username`（用户名）和`password`（密码）必须与数据库凭证相匹配，而`host`（主机）和`port`（端口）将指定数据库托管的位置。设置数据库`dialect`和其他连接信息，然后就可以开始了。
- en: 'To use MySQL, you will need to install the base MySQL driver so that Sequelize
    can use MySQL:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用MySQL，你需要安装基础MySQL驱动程序，这样Sequelize才能使用MySQL：
- en: '[PRE76]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Running with Sequelize against other databases it supports, such as PostgreSQL, is
    just as simple. Just create a configuration file, install the Node.js driver,
    and install/configure the database engine.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sequelize针对它支持的其它数据库，如PostgreSQL，同样简单。只需创建一个配置文件，安装Node.js驱动程序，并安装/配置数据库引擎。
- en: Running the Notes application with Sequelize
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sequelize运行Notes应用程序
- en: 'Now we can get ready to run the *Notes* application using Sequelize. We can
    run this against both SQLite3 and MySQL, but let''s start with SQLite. Add this
    entry to the `scripts` entry in `package.json`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以准备运行*Notes*应用程序使用Sequelize。我们可以针对SQLite3和MySQL运行它，但让我们从SQLite开始。将以下条目添加到`package.json`中的`scripts`条目：
- en: '[PRE77]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then run it as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下步骤运行它：
- en: '[PRE78]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As before, the application looks exactly the same because we've not changed
    the View templates or CSS files. Put it through its paces and everything should
    work.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序看起来完全一样，因为我们没有更改视图模板或CSS文件。对其进行测试，一切应该正常工作。
- en: 'With Sequelize, multiple *Notes* application instances is as simple as adding
    these lines to the `scripts` section of `package.json`, and then starting both
    instances as before:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sequelize，多个*Notes*应用程序实例就像在`package.json`的`scripts`部分添加这些行一样简单，然后像以前一样启动这两个实例：
- en: '[PRE79]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You will be able to start both instances, use separate browser windows to visit
    both instances, and see that they show the same set of notes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够启动这两个实例，使用不同的浏览器窗口访问这两个实例，并看到它们显示相同的笔记集合。
- en: 'To reiterate using the Sequelize-based model on a given database server:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在给定的数据库服务器上使用基于Sequelize的模式：
- en: Install and provision the database server instance, or else get the connection
    parameters for an already-provisioned database server.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装和配置数据库服务器实例，或者获取已配置数据库服务器的连接参数。
- en: Install the corresponding Node.js driver.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装相应的Node.js驱动程序。
- en: Write a YAML configuration file corresponding to the connection parameters.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个与连接参数相对应的YAML配置文件。
- en: Create new `scripts` entries in `package.json` to automate starting Notes against
    that database.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中创建新的`scripts`条目来自动化针对该数据库启动笔记。
- en: Storing notes in MongoDB
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MongoDB中存储笔记
- en: 'MongoDB is widely used with Node.js applications, a sign of which is the popular
    MEAN acronym: MongoDB (or MySQL), Express, Angular, and Node.js. MongoDB is one
    of the leading NoSQL databases. It is described as a *scalable, high-performance,
    open source, document-oriented database*. It uses JSON-style documents with no
    predefined, rigid schema and a large number of advanced features. You can visit
    their website for more information and documentation at [http://www.mongodb.org](http://www.mongodb.org).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在Node.js应用程序中得到了广泛的应用，其中一个标志是流行的MEAN缩写：MongoDB（或MySQL），Express，Angular和Node.js。MongoDB是领先的NoSQL数据库之一。它被描述为*可扩展的、高性能的、开源的、面向文档的数据库*。它使用JSON风格的文档，没有预定义的、刚性的模式，并具有大量高级功能。你可以访问他们的网站获取更多信息以及文档，网址为[http://www.mongodb.org](http://www.mongodb.org)。
- en: Documentation on the Node.js driver for MongoDB can be found at [https://www.npmjs.com/package/mongodb](https://www.npmjs.com/package/mongodb)
    and [http://mongodb.github.io/node-mongodb-native/](http://mongodb.github.io/node-mongodb-native/).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的Node.js驱动程序的文档可以在[https://www.npmjs.com/package/mongodb](https://www.npmjs.com/package/mongodb)和[http://mongodb.github.io/node-mongodb-native/](http://mongodb.github.io/node-mongodb-native/)找到。
- en: Mongoose is a popular ORM for MongoDB ([http://mongoosejs.com/](http://mongoosejs.com/)).
    In this section, we'll use the native MongoDB driver instead, but Mongoose is
    a worthy alternative.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose是MongoDB的一个流行ORM（对象关系映射）工具([http://mongoosejs.com/](http://mongoosejs.com/))。在本节中，我们将使用原生的MongoDB驱动程序，但Mongoose也是一个值得考虑的替代方案。
- en: You will need a running MongoDB instance. The `compose.io` ([https://www.compose.io/](https://www.compose.io/))
    and `ScaleGrid.io` ([https://scalegrid.io/](https://scalegrid.io/)) hosted service
    providers offer hosted MongoDB services. Nowadays, it is straightforward to host
    MongoDB as a Docker container as part of a system built of other Docker containers.
    We'll do this in Chapter 11, *Unit Testing and Functional Testing*.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个运行的MongoDB实例。`compose.io`([https://www.compose.io/](https://www.compose.io/))和`ScaleGrid.io`([https://scalegrid.io/](https://scalegrid.io/))托管服务提供商提供托管MongoDB服务。如今，将MongoDB作为Docker容器的一部分托管在由其他Docker容器构建的系统中的操作非常简单。我们将在第11章，*单元测试和功能测试*中这样做。
- en: It's possible to set up a temporary MongoDB instance for testing on, say, your
    laptop. It is available in all the operating system package management systems,
    and the MongoDB website has instructions ([https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/)).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能在笔记本电脑上设置一个临时的MongoDB实例进行测试。它在所有操作系统包管理系统中都可用，MongoDB网站有说明([https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/))。
- en: Once installed, it's not necessary to set up MongoDB as a background service.
    Instead, you can run a couple of simple commands to get a MongoDB instance running
    in the foreground of a command window, which you can kill and restart any time
    you like.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，就没有必要将MongoDB设置为后台服务。相反，你可以运行几个简单的命令，在命令窗口的前台运行MongoDB实例，你可以随时将其终止和重启。
- en: 'In one command window, run the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个命令窗口中，运行以下命令：
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In another command window, you can test it as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个命令窗口中，你可以按以下方式测试：
- en: '[PRE81]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This saves a *document* in the collection named `foo`. The second command finds
    all documents in `foo`, printing them out for you. The `_id` field is added by
    MongoDB and serves as a document identifier. This is useful for testing and debugging.
    For a real deployment, your MongoDB server must be properly installed on a server.
    See the MongoDB documentation for these instructions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在名为`foo`的集合中保存一个*文档*。第二个命令在`foo`中查找所有文档，并将它们打印出来供你使用。`_id`字段由MongoDB添加，作为文档标识符。这对于测试和调试很有用。对于实际部署，你的MongoDB服务器必须在服务器上正确安装。请参阅MongoDB文档以获取这些说明。
- en: MongoDB model for the Notes application
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Notes应用程序的MongoDB模型
- en: Now that you've proved you have a working MongoDB server, let's get to work.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经证明你有了一个工作的MongoDB服务器，让我们开始工作。
- en: 'Installing the Node.js driver is as simple as running the following command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js驱动程序就像运行以下命令一样简单：
- en: '[PRE82]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now create a new file, `models/notes-mongodb.mjs`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的文件，`models/notes-mongodb.mjs`：
- en: '[PRE83]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `MongoClient` class is used to connect with a MongoDB instance. The required
    URL, which will be specified through an environment variable, uses a straightforward
    format: `mongodb://localhost/`. The database name is specified via another environment
    variable.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MongoClient`类与MongoDB实例连接。所需的URL将通过环境变量指定，格式简单：`mongodb://localhost/`。数据库名称通过另一个环境变量指定。
- en: Documentation for the corresponding objects can be found at
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对应对象的文档可以在以下位置找到
- en: '[http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html](http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html)
    for MongoClient and [http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html](http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html) for Db'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html](http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html)
    用于MongoClient和 [http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html](http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html)
    用于Db'
- en: 'This creates the database client, and then opens the database connection. Both
    objects are returned from `connectDB` in an anonymous object. The general pattern
    for MongoDB operations is as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个数据库客户端，然后打开数据库连接。这两个对象都从`connectDB`以匿名对象的形式返回。MongoDB操作的一般模式如下：
- en: '[PRE84]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Therefore, our model methods require both `client` and `db` objects, because
    they will use both. Let''s see how that''s done:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的模型方法需要同时使用`client`和`db`对象，因为它们都会用到它们。让我们看看这是如何完成的：
- en: '[PRE85]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We retrieve `db` and `client` into individual variables using a destructuring
    assignment.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用解构赋值将`db`和`client`检索到单独的变量中。
- en: MongoDB stores all documents in collections. A *collection* is a group of related
    documents, and a collection is analogous to a table in a relational database.
    This means creating a new document or updating an existing one starts by constructing
    it as a JavaScript object, and then asking MongoDB to save that object to the
    database. MongoDB automatically encodes the object into its internal representation.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB将所有文档存储在集合中。一个*集合*是一组相关的文档，集合在关系数据库中类似于一个表。这意味着创建一个新的文档或更新现有的文档，首先将其构造为一个JavaScript对象，然后请求MongoDB将该对象保存到数据库中。MongoDB自动将该对象编码为其内部表示。
- en: The `db.collection` method gives us a `Collection` object with which we can
    manipulate the named collection. See its documentation at [http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.collection`方法为我们提供了一个`Collection`对象，我们可以用它来操作命名集合。请参阅其文档[http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html)。'
- en: As the method name implies, `insertOne` inserts one document into the collection.
    Likewise, the `updateOne` method first finds a document (in this case, by looking
    up the document with the matching `notekey` field), and then changes fields in
    the document as specified.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如方法名所示，`insertOne`将一个文档插入到集合中。同样，`updateOne`方法首先查找一个文档（在这种情况下，通过查找匹配的`notekey`字段），然后根据指定更改文档中的字段。
- en: You'll see that these methods return a Promise. The `mongodb` driver supports
    both callbacks and Promises. Many methods will invoke the callback function if
    one is provided, otherwise it returns a Promise that will deliver the results
    or errors. And, of course, since we're using `async` functions, the `await` keyword
    makes this so clean.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这些方法返回一个 Promise。`mongodb` 驱动支持回调和 Promise。许多方法如果提供了回调函数，将调用该函数，否则它返回一个将传递结果或错误的
    Promise。当然，由于我们正在使用 `async` 函数，`await` 关键字使得这个过程非常简洁。
- en: 'Further documentation can be found at the following links:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的文档可以在以下链接中找到：
- en: Insert: [https://docs.mongodb.org/getting-started/node/insert/](https://docs.mongodb.org/getting-started/node/insert/).
    [](https://docs.mongodb.org/getting-started/node/insert/) Update: [https://docs.mongodb.org/getting-started/node/update/](https://docs.mongodb.org/getting-started/node/update/).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 插入：[https://docs.mongodb.org/getting-started/node/insert/](https://docs.mongodb.org/getting-started/node/insert/).
    [更新：](https://docs.mongodb.org/getting-started/node/update/).
- en: 'Next, let''s look at reading a note from MongoDB:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何从 MongoDB 读取笔记：
- en: '[PRE86]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `mongodb` driver supports several variants of `find` operations. In this
    case, the *Notes* application ensures that there is exactly one document matching
    a given key. Therefore, we can use the `findOne` method. As the name implies,
    `findOne` will return the first matching document.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongodb` 驱动支持多种 `find` 操作的变体。在这种情况下，*笔记* 应用确保恰好有一个文档与给定的键匹配。因此，我们可以使用 `findOne`
    方法。正如其名所示，`findOne` 将返回第一个匹配的文档。'
- en: The argument to `findOne` is a query descriptor. This simple query looks for
    documents whose `notekey` field matches the requested `key`. An empty query will,
    of course, match all documents in the collection. You can match against other
    fields in a similar way, and the query descriptor can do much more. For documentation
    on queries, visit [https://docs.mongodb.org/getting-started/node/query/](https://docs.mongodb.org/getting-started/node/query/).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOne` 的参数是一个查询描述符。这个简单的查询寻找 `notekey` 字段与请求的 `key` 匹配的文档。当然，一个空查询将匹配集合中的所有文档。你可以以类似的方式匹配其他字段，并且查询描述符可以做更多的事情。有关查询的文档，请访问
    [https://docs.mongodb.org/getting-started/node/query/](https://docs.mongodb.org/getting-started/node/query/)。'
- en: The `insertOne` method we used earlier also took the same kind of query descriptor.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的 `insertOne` 方法也采用了相同的查询描述符。
- en: 'In order to satisfy the contract for this function, we create a `Note` object
    and then return it to the caller. Hence, we create a Note using the data retrieved from
    the database:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这个函数的合约，我们创建一个 `Note` 对象，并将其返回给调用者。因此，我们使用从数据库检索到的数据创建一个 Note：
- en: '[PRE87]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'One of the `find` variants is `findOneAndDelete`. As the name implies, it finds
    one document matching the query descriptor, and then deletes that document:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 变体之一是 `findOneAndDelete`。正如其名所示，它会找到与查询描述符匹配的一个文档，然后删除该文档：'
- en: '[PRE88]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, we're using the base `find` operation and giving it an empty query so
    that it matches every document. What we're to return is an array containing the
    `notekey` for every document.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用基本的 `find` 操作并给它一个空查询，以便匹配每个文档。我们要返回的是一个包含每个文档的 `notekey` 的数组。
- en: All of the `find` operations return a `Cursor` object. The documentation can
    be found at [http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 `find` 操作都会返回一个 `Cursor` 对象。文档可以在 [http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html)
    找到。
- en: The Cursor object is, as the name implies, a pointer into a result set from
    a query. It has a number of useful functions related to operating on a result
    set. For example, you can skip the first few items in the results, or limit the
    size of the result set, or perform the `filter` and `map` operations.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`Cursor` 对象是查询结果集的一个指针。它具有许多与操作结果集相关的有用函数。例如，你可以跳过结果集中的前几个项目，或者限制结果集的大小，或者执行
    `filter` 和 `map` 操作。
- en: The `Cursor.forEach` method takes two callback functions. The first is called
    on every element in the result set. In this case, we can use that to record just
    the `notekey` in an array. The second callback is called after all elements in
    the result set have been processed. We use this to indicate success or failure,
    and to return the `keyz` array.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cursor.forEach` 方法接受两个回调函数。第一个在结果集中的每个元素上调用。在这种情况下，我们可以用它将 `notekey` 记录在一个数组中。第二个回调在处理完结果集中的所有元素后调用。我们使用这个来指示成功或失败，并返回
    `keyz` 数组。'
- en: 'Because `forEach` uses this pattern, it does not have an option for supplying
    a Promise, and we have to create the Promise ourselves, as shown here:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`forEach`使用这种模式，所以它没有提供Promise的选项，我们必须自己创建Promise，如下所示：
- en: '[PRE89]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The `count` method takes a query descriptor and, as the name implies, counts
    the number of matching documents.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`方法接受一个查询描述符，正如其名称所暗示的，它计算匹配文档的数量。'
- en: Running the Notes application with MongoDB
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB运行笔记应用程序
- en: Now that we have our MongoDB model, we can get ready to run *Notes* with it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了MongoDB模型，我们可以准备好使用它来运行*笔记*。
- en: 'By now you know the drill; add this to the `scripts` section of `package.json`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经知道了这个步骤；将其添加到`package.json`的`scripts`部分：
- en: '[PRE90]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `MONGO_URL` environment variable is the URL to connect with your MongoDB
    database.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`MONGO_URL`环境变量是连接到你的MongoDB数据库的URL。'
- en: 'You can start the *Notes* application as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式启动*笔记*应用程序：
- en: '[PRE91]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can browse the application at `http://localhost:3000` and put it through
    its paces. You can kill and restart the application, and your notes will still
    be there.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`http://localhost:3000`上浏览应用程序，并对其进行测试。你可以终止并重新启动应用程序，你的笔记仍然会保留在那里。
- en: 'Add this to the `scripts` section of `package.json`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`package.json`的`scripts`部分：
- en: '[PRE92]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You will be able to start two instances of the *Notes* application, and see
    that both share the same set of notes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够启动两个*笔记*应用程序的实例，并看到它们共享同一组笔记。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through a real whirlwind of different database technologies.
    While we looked at the same seven functions over and over, it's useful to be exposed
    to the various data storage models and ways of getting things done. Even so, we
    only touched the surface of options for accessing databases and data storage engines from
    Node.js.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了一场关于不同数据库技术的真实旋风。虽然我们反复查看相同的七个功能，但接触各种数据存储模型和完成任务的方式是有用的。即便如此，我们也只是触及了从Node.js访问数据库和数据存储引擎选项的表面。
- en: By abstracting the model implementations correctly, we were able to easily switch
    data storage engines while not changing the rest of the application. We did skip
    around the issue of setting up database servers. As promised, we'll get to that
    in [Chapter 10,](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml) *Deploying Node.js
    Applications*, when we explore production deployment of Node.js applications.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通过正确抽象模型实现，我们能够在不改变应用程序其余部分的情况下轻松切换数据存储引擎。我们确实跳过了设置数据库服务器的问题。正如承诺的那样，当我们在第10章*部署Node.js应用程序*中探索Node.js应用程序的生产部署时，我们将讨论这个问题。
- en: By focusing the model code on the purpose of storing data, both the models and
    the application should be easier to test. The application can be tested with a
    mock data module that provides known predictable notes that can be checked predictably.
    We'll look at this in more depth in Chapter 11, *Unit Testing and Functional Testing*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将模型代码集中在存储数据的目的上，模型和应用程序都应该更容易进行测试。可以使用一个模拟数据模块来测试应用程序，该模块提供已知可预测的笔记，这些笔记可以可预测地进行检查。我们将在第11章*单元测试和功能测试*中更深入地探讨这一点。
- en: In the next chapter, we'll focus on authenticating our users using OAuth2.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于使用OAuth2对用户进行身份验证。
