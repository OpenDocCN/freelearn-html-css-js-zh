- en: Async/Await Project Setup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步/等待项目设置
- en: 'In this chapter, we''re going to go through the process of learning how async/await
    works, what exactly it is, and where it''s going to fit into what we know about
    Node already. **Async/await** is a feature that is not available in all versions
    of Node. You have to be using the 7.6 or greater. So if you are on V7, just make
    sure you are on 7.6 or greater. If we go over to [nodejs.org](https://nodejs.org/en/),
    you''re going to see that v9 is actually out, so we can go ahead and just upgrade
    to V9 right now:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习异步/等待的工作过程，它到底是什么，以及它将如何融入我们已经了解的Node知识中。**异步/等待**是一个不是在所有Node版本中都可用的功能。您必须使用7.6或更高版本。所以如果您使用的是V7，只需确保您使用的是7.6或更高版本。如果我们转到[nodejs.org](https://nodejs.org/en/)，您会看到v9实际上已经发布了，所以我们现在可以升级到V9：
- en: '![](img/8df4fd3d-1152-4b3c-bff2-725e9cb538bd.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8df4fd3d-1152-4b3c-bff2-725e9cb538bd.png)'
- en: It's perfectly fine if there's a newer version. You can go ahead and grab that
    as well, as long as it is 7.6 or up. So 6.10, it's not going to have the syntax
    that we're about to dive into.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更新版本也是完全可以的。只要是7.6或更高版本就可以。所以6.10不会有我们即将深入研究的语法。
- en: Using async/await features in promises
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步/等待功能在承诺中
- en: Now, before we actually use async/await, we're going to go ahead and run through
    an example that just uses promises. We're going to use techniques we already know
    to set up a little example project. Now, when people hear about async/await, they
    think that they need to forget everything they know about callbacks and promises,
    and that is not true. Async/await is not a third option; it is more like an enhancement
    for promises. We're going to go through an example using just regular old promises,
    things you already know how to do. Then we're going to see how async/await can
    enhance that code. So, to kick things off, we do need a place to put all of this.
    I'm going to make a brand new project on my Desktop, `async-await`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们实际使用异步/等待之前，我们将先通过一个只使用承诺的示例来运行。我们将使用我们已经知道的技术来设置一个小的示例项目。现在，当人们听说异步/等待时，他们认为他们需要忘记他们对回调和承诺的所有了解，这是不正确的。异步/等待不是第三个选择；它更像是承诺的增强。我们将通过一个例子来使用普通的承诺，这些是您已经知道如何做的事情。然后我们将看到异步/等待如何增强该代码。因此，为了开始，我们确实需要一个地方来放置所有这些。我将在我的桌面上创建一个全新的项目，`async-await`。
- en: 'We can crack that open in our editor and make sure to crack it open in your
    terminal as well. Now, the goal here is to just make a very simple project. We''re
    not going to need any Node modules for this one and we are just going to need
    a single file. This file can sit in the root of the project and we''ll just call
    it `app-promises.js`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的编辑器中打开它，并确保在您的终端中也打开它。现在，这里的目标是只做一个非常简单的项目。对于这个项目，我们不需要任何Node模块，我们只需要一个文件。这个文件可以放在项目的根目录，我们将把它命名为`app-promises.js`：
- en: '![](img/eebdc135-aed2-48bd-b38c-440efd8094cd.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eebdc135-aed2-48bd-b38c-440efd8094cd.png)'
- en: 'This is going to be the version of our application that just uses promises.
    Now, before we go any further, I do want to give you a quick idea as to what the
    chapter is going to look like. We''re going to go through three distinct things:
    first up, we are going to create a very contrived example and this is going to
    allow us to learn how to use async/await without a lot of overhead or baggage.
    So, we''re going to be creating constants, like `users`, which would just be an
    array of objects and constants, like `grades`; also an array of objects and this
    is going to be what a database would look like.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的应用程序的版本，只使用承诺。现在，在我们继续之前，我想给你一个快速的想法，关于这一章将会是什么样子。我们将经历三个不同的事情：首先，我们将创建一个非常牵强的例子，这将使我们学会如何在没有太多开销或负担的情况下使用异步/等待。因此，我们将创建常量，比如`users`，它只是一个对象数组和常量，比如`grades`；也是一个对象数组，这将是数据库的样子。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Obviously, there is nothing asynchronous about accessing some property from
    an array, so we're going to go ahead and create some new promises to turn a synchronous
    process into an asynchronous one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从数组中访问某个属性并没有任何异步性，因此我们将继续创建一些新的承诺，将同步过程转换为异步过程。
- en: Setting up the getUser project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置getUser项目
- en: So, the first project is not very real-world, but it is going to be a great
    way to learn the new syntax. Then we're going to move on to another little project
    where you're going to be required to make two actual API calls from some APIs
    I picked out. Those will be asynchronous and we'll use async/await there. To wrap
    things up, we're going to add a little bit of async/await code back into the todo
    API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个项目并不是非常现实，但它将是学习新语法的好方法。然后我们将继续进行另一个小项目，您将需要从我挑选出来的一些API中进行两个实际的API调用。这些将是异步的，我们将在那里使用异步/等待。最后，我们将把一点异步/等待代码添加回todo
    API中。
- en: 'So, to kick things off, we''re going to go through this very contrived example
    and we can start by creating a few users to work with. Each user object is going
    to have a few properties; we''ll start off with an `id`, just like they would
    have inside of a real database. I''m going to give this one an id of `1`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将通过这个非常牵强的例子开始，我们可以开始创建一些要处理的用户。每个用户对象将有一些属性；我们将从一个`id`开始，就像它们在真实数据库中一样。我将给这个一个id为`1`：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''ll also have a name, a string name for the user. I''m going to call the
    first one `Andrew` and then we''re going to move on to the final property, a `schoolId`,
    an ID that will change as the student switches from one school to another. We
    can just make up another id for this one. I''m going to go ahead and start at
    `101`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会有一个名字，一个用户的字符串名字。我要叫第一个`Andrew`，然后我们将继续到最后一个属性，一个`schoolId`，一个ID，当学生从一所学校转到另一所学校时会改变。我们可以为这个再编一个id。我将从`101`开始：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have user number `1` created'' let''s go ahead and clone him. I''m
    going to copy it, toss a comma and paste it, and we''ll create just one more user
    for this example. This one will have an `id` of `2`. We''ll change the name from
    `Andrew` over to something like `Jessica` and we''ll give her a `schoolId` of
    `999`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户编号为 `1`，让我们继续克隆他。我将复制它，加上逗号，然后粘贴，我们将为这个示例创建一个更多的用户。这个用户的 `id` 将是
    `2`。我们将把名字从 `Andrew` 改成类似 `Jessica` 的名字，然后给她一个 `schoolId` 为 `999`。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have some users in place, we''re going to create our first of three
    functions we''ll be building in this section. This one is called const `getUser`.
    It is going to take the `id` of the user, find that user, and return the user
    object:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些用户，我们将在这一部分中创建我们的第一个三个函数之一。这个函数叫做 `getUser`。它将获取用户的 `id`，找到该用户，并返回用户对象：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, if the `id` is `1`, we''re going to get this object:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果 `id` 是 `1`，我们将得到这个对象：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If it''s `2`, I''m going to get this object back:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是 `2`，我将得到这个对象：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If it's `3` or some other id that doesn't exist, I'm going to actually have
    an error thrown. So, this is going to return a promise of resolve if the `id`
    is a match with one of the users, or reject if it's not.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是 `3` 或其他不存在的 id，我将会抛出一个错误。所以，如果 `id` 与其中一个用户匹配，它将返回一个解析的 promise，否则将返回一个拒绝的
    promise。
- en: 'Now, as I mentioned, this is a contrived example, so we''re going to be creating
    new promises explicitly. I''m going to create a new promise, passing in that promise
    function which, as you remember, gets called with `resolve` and `reject`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我所提到的，这是一个人为的例子，所以我们将显式地创建新的 promises。我将创建一个新的 promise，传入那个 promise 函数，你记得，它会调用
    `resolve` 和 `reject`：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then we're going to go ahead and add a little bit of logic in the function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将在函数中添加一点逻辑。
- en: The array find method
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组的 find 方法
- en: 'The first thing we need to do is try to find a match and I''m going to use
    the array find method to get that done. We''ll create a `const user` to store
    the match, then we''ll set it equal to `users.find`, passing in our function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是尝试找到一个匹配项，我将使用数组的 find 方法来完成这个任务。我们将创建一个 `const user` 来存储匹配项，然后将其设置为
    `users.find`，传入我们的函数：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now this function gets called one time for every item in the array. It's an
    array of users so we can call the individual item `user`. If we return `true`,
    it is going to consider that a match. It'll stop and it'll set that object on
    a user. If we return `false`, it'll continue on through the array and, if none
    are matched, undefined will be the value for user. So, we're just going to return
    `user.id`, checking if it equals the `id` passed in.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个函数会被数组中的每个项目调用一次。这是一个用户数组，所以我们可以称单个项目为 `user`。如果我们返回 `true`，它将被视为匹配。它将停止并将该对象设置为用户。如果我们返回
    `false`，它将继续遍历数组，如果没有匹配，用户的值将是未定义的。所以，我们将返回 `user.id`，检查它是否等于传入的 `id`。
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we have a great candidate for the shorthand syntax here. We just have
    an arrow function that returns some value. It just provides the value and have
    it be implicitly returned:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在这里有一个很好的简写语法的候选者。我们只有一个返回某个值的箭头函数。它只提供值，并且会被隐式返回：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here we have the exact same functionality. Now, before we go ahead and use
    it, let''s go ahead and actually call `resolve` or `reject`. If there is a user,
    we''re going to do one thing; if there''s not a user, that''s fine, we''re just
    going to do something else. In the `else` statement, we''ll be calling `reject`
    and, in if statement, we''ll be calling `resolve`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有完全相同的功能。现在，在我们使用它之前，让我们调用 `resolve` 或 `reject`。如果有用户，我们将做一件事；如果没有用户，那没关系，我们将做其他事。在
    `else` 语句中，我们将调用 `reject`，在 `if` 语句中，我们将调用 `resolve`：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, `resolve` is just going to have the user passed in and, for `reject`, we
    can come up with an error message that helps the user figure out what went wrong.
    We can add `unable to find user with id of .`, then, we'll put the `id` next to
    it. Inside the template string, I'm going to reference `id`. This is the exact
    value that was passed in the `getUser` variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`resolve` 只是将用户传入，对于 `reject`，我们可以提供一个错误消息，帮助用户找出问题出在哪里。我们可以添加 `无法找到 id 为
    . 的用户`，然后，我们会把 `id` 放在旁边。在模板字符串中，我将引用 `id`。这是传入 `getUser` 变量的确切值。
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, before we go ahead and actually run this, let's just use `getUser` real
    quick. I'm going to call `getUser` with an `id` of `2`, which should return `Jessica`.
    I'll add on then and `catch`. Inside `catch`, we can `catch` that error. We're
    just going to get the error and log it out, `console.log(e)`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续运行之前，让我们快速使用 `getUser`。我将使用 `id` 为 `2` 调用 `getUser`，应该返回 `Jessica`。然后我会添加
    `then` 和 `catch`。在 `catch` 中，我们可以捕获错误。我们将获取错误并将其记录下来，`console.log(e)`。
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we can set up our `then` callback; inside `then`, we''re going to get
    access to the user and, for now, we''ll just log it out:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以设置我们的 `then` 回调；在 `then` 中，我们将获得对用户的访问，现在，我们将把它记录下来：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running the getUser object test
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 getUser 对象测试
- en: 'To actually run this, we''re going to head over into the Terminal and make
    sure we do get the expected results. I''m going to be using `nodemon` to get that
    done. If you just updated Node, it also updated `npm` and, at the end of the day,
    what that means is that you no longer have access to those global modules. You
    might need to rerun `npm install -g nodemon` before you can use the `nodemon`
    command. I''m going to use `nodemon` running the `app-promises.js` file and, right
    here, we have our output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际运行这个，我们将转到终端，确保我们得到预期的结果。我将使用 `nodemon` 来完成这个任务。如果你刚刚更新了 Node，它也更新了 `npm`，最终意味着你不再可以访问这些全局模块。你可能需要重新运行
    `npm install -g nodemon`，然后才能使用 `nodemon` 命令。我将使用 `nodemon` 运行 `app-promises.js`
    文件，然后，我们有了输出：
- en: '![](img/0e958782-4416-4d8d-9f6e-6853fcbc6698.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e958782-4416-4d8d-9f6e-6853fcbc6698.png)'
- en: 'We have Jessica printing with a `schoolId` of `999` and an `id` of `2`. That
    is because I passed `2` in `getUser` id:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出了 `schoolId` 为 `999`，`id` 为 `2` 的 Jessica。这是因为我在 `getUser` 中传入了 `2`：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If I switch this out for `1`, I should see `Andrew`. I do indeed see `Andrew`.
    Finally, let''s go ahead and pass in an ID that doesn''t exist like `21`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将这个替换为`1`，我应该看到`Andrew`。我确实看到了`Andrew`。最后，让我们传入一个不存在的ID，比如`21`：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Right here I do get the message: `unable to find user with id of 21`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我确实收到消息：`无法找到id为21的用户`：
- en: '![](img/48afe2da-d67b-4dce-b536-052629b8d18f.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48afe2da-d67b-4dce-b536-052629b8d18f.png)'
- en: So, this is the first of three projects that we're going to be building. Let's
    go ahead and knock out the other two real quick.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要构建的三个项目中的第一个。让我们快速完成其他两个。
- en: Setting up the getGrades project
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置getGrades项目
- en: 'This will set us up to actually explore the async/await syntax, using `const
    getGrades`. `getGrades` is going to be very similar to `getUsers` although. Instead
    of working with the users array, it is going to work with the grades array:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够实际探索async/await语法，使用`const getGrades`。`getGrades`将与`getUsers`非常相似。但是，它不会使用用户数组，而是使用成绩数组：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we don't have any grades set up, so let's go ahead and set some up.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们没有设置任何成绩，所以让我们继续设置一些。
- en: Creating grades for the getGrades project
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为getGrades项目创建成绩
- en: 'We''re going to go ahead and create a few grades. First up, let''s create a
    grade with an `id` of `1`. Now, this `1` is going to be attached to `Andrew`,
    so we''ll go ahead and use the `schoolId` to do that. The `schoolId`, in this
    case for `Andrew`, is `101`. Then, we''re going to put in the actual `grade`.
    In this case, I''ll go ahead and give myself an `86`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续创建一些成绩。首先，让我们创建一个id为`1`的成绩。现在，这个`1`将附加到`Andrew`，所以我们将使用`schoolId`来做到这一点。在这种情况下，对于`Andrew`，`schoolId`是`101`。然后，我们将输入实际的`grade`。在这种情况下，我将给自己一个`86`：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is grade `1`; let''s go ahead and create three more grades. I''m going
    to copy it, toss in a comma, and paste it two times. This one is going to have
    an id of `2`. We can associate this one with `Jessica`, so we''ll give her the
    `schoolId` value of `999`. She''s really smart so we''ll give her a `100`. Finally,
    id of `3`: we''ll leave this one associated with `Andrew` and, next, we''ll give
    him a grade of an `80`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第`1`个成绩；让我们继续创建三个成绩。我将复制它，放入一个逗号，并粘贴两次。这个将有一个id为`2`。我们可以将这个与`Jessica`关联起来，所以我们将给她`schoolId`值为`999`。她非常聪明，所以我们给她`100`。最后，id为`3`：我们将保留这个与`Andrew`相关联，接下来，我们将给他一个`80`的成绩：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, we have some grades in place and the goal is to return all of the grades
    for a particular student based off of their `schoolId`. If I pass in `101`, I
    would expect an array to come back with the object associated with Andrew. If
    I pass in `999`, I would expect an array to come back with the one associated
    with Jessica, and if I pass in a value like `55`, there are going to be no grades
    for that student, so we'll go ahead and return an empty array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经设置了一些成绩，目标是根据他们的`schoolId`返回特定学生的所有成绩。如果我传入`101`，我期望得到一个包含与Andrew相关的对象的数组。如果我传入`999`，我期望得到一个包含与Jessica相关的对象的数组，如果我传入像`55`这样的值，那么该学生将没有成绩，所以我们将返回一个空数组。
- en: Returning a new promise
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回一个新的promise
- en: 'Now, in the `getGrades` variable, we''re going to get the `schoolId` that we''re
    using to look things up with. Then we''re going to go ahead and return a new promise;
    this is all part of the contrived example, `resolve` and `reject` are our two
    arguments:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`getGrades`变量中，我们将得到我们用于查找的`schoolId`。然后我们将继续返回一个新的promise；这都是虚构的例子，`resolve`和`reject`是我们的两个参数：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then, right here, we're going to go ahead and `resolve` the filtered grades
    array, that is `grades.filter`. We're going to filter this one by passing an arrow
    function. It'll get called with the individual grade, not user, and then we'll
    go ahead and implicitly return something. If we return `true`, it'll be considered
    a match and that grade will be resolved. If we return `false`, that grade will
    be removed from the array that gets resolved. In this case, we want to keep the
    grade if the `grade.schoolId` equals the `schoolId` that the function was called
    with.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这里，我们将继续`resolve`筛选后的成绩数组，即`grades.filter`。我们将通过传递一个箭头函数来筛选这个数组。它将被调用与单个成绩，而不是用户，并且我们将继续隐式返回一些东西。如果我们返回`true`，它将被视为匹配，并且该成绩将被解析。如果我们返回`false`，那么该成绩将从被解析的数组中删除。在这种情况下，如果`grade.schoolId`等于函数调用时的`schoolId`，我们希望保留该成绩。
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this case, that is it for `getGrades`; we can go ahead and test it out.
    I''m going to call `getGrades` instead of `getUser`. I''m going to pass in a valid
    `schoolId` like `101` and, instead of user, we''ll have `grades`  and next:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这就是`getGrades`的全部内容；我们可以继续测试。我将调用`getGrades`而不是`getUser`。我将传入一个有效的`schoolId`，比如`101`，而不是用户，我们将有`grades`，接下来：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If I save this, what do we get? We get an array with two objects, as expected:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我保存这个，我们得到什么？我们得到一个包含两个对象的数组，正如预期的那样：
- en: '![](img/9e6a57eb-ba42-42c7-bdca-429a6839e282.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e6a57eb-ba42-42c7-bdca-429a6839e282.png)'
- en: 'We have all the grades for `Andrew`, `86` and `80`. I''m going to go ahead
    and pass in `999`; we get Jessica''s grades and, finally, we pass in `12`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`Andrew`的所有成绩，分别是`86`和`80`。我将继续传入`999`；我们得到Jessica的成绩，最后，我们传入`12`：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If I pass in `12`, we get an empty array, which is exactly what I was hoping
    for. Just one more function left, and then we'll be done with this section and
    we can move on to the next one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我传入`12`，我们得到一个空数组，这正是我希望的。只剩下一个函数了，然后我们就完成了这一部分，可以继续下一部分了。
- en: Setting up the getStatus project
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置getStatus项目
- en: 'This project is going to be called `const getStatus`. `getStatus` is going
    to be a function and it is going to take the `userId`, the `id` for the user whose
    status you''re trying to fetch. Now, the goal of this project is to just return
    a string along the lines. We''ll start off with their name, like `Andrew`, and
    then we''ll add a little bit of information; `Andrew has a`, in this case, I have
    an `83` average in the class (so I take `80`, I add on `86`, I divide it by `2`
    to generate that average). So, we want to resolve the following string from `getStatus`
    after we actually run through `getUser` and `getGrades`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将被称为`const getStatus`。`getStatus`将是一个函数，它将获取`userId`，即要获取其状态的用户的`id`。现在，这个项目的目标只是返回一条字符串。我们将从他们的名字开始，比如`Andrew`，然后我们将添加一些信息；`Andrew
    has a`，在这种情况下，我在课堂上有一个`83`的平均分（所以我拿`80`，我再加上`86`，然后除以`2`来生成这个平均分）。因此，我们希望在实际运行`getUser`和`getGrades`后，从`getStatus`中解析出以下字符串：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Resolving the getStatus string
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决`getStatus`字符串
- en: 'We''re going to go ahead and knock this out, and then we''ll be done. That
    means we''ll be calling `getStatus` with a `userId`. We''re going to get the status
    back and we are going to log the status out:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续完成这个，然后就完成了。这意味着我们将使用`userId`调用`getStatus`。我们将获取状态并将状态记录下来：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now to kick things off, what do we need to do? First up, we have to go ahead
    and `return` to keep the promise chain alive, because we attach the then and `catch`
    callbacks with the `getStatus` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始，我们需要做什么？首先，我们必须继续`return`以保持promise链的活动状态，因为我们使用`getStatus`函数附加了`then`和`catch`回调。
- en: 'Next up, we''ll be calling `getUser`. Before we can actually use `getGrades`,
    we have to take the `userId`, find the user object, and get their `schoolId`.
    We also want to make sure to have access to the name for the message, so we need
    two pieces of information off of that object: `getUser` and `userId`. We''ll add
    our `then` callback. In this callback, we''re going to get access to that user
    object and this contains some useful information. One of those pieces of information
    is going to allow us to actually call `getGrades`. I''m going to `return getGrades`,
    right here, and we''re going to pass in the student school ID, that''s `user.schoolId`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用`getUser`。在我们实际使用`getGrades`之前，我们必须获取`userId`，找到用户对象，并获取他们的`schoolId`。我们还想确保在消息中有姓名的访问权限，因此我们需要从该对象中获取两条信息：`getUser`和`userId`。我们将添加我们的`then`回调。在这个回调中，我们将获得对该用户对象的访问权限，其中包含一些有用的信息。其中一条信息将允许我们实际调用`getGrades`。我将在这里`return
    getGrades`，然后我们将传入学生的学校ID，即`user.schoolId`：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So now that we have `getGrades` called, we''ll have access to those grades
    next. The success callback for `getGrades` promise  will get the `grades` array.
    We can then go ahead and actually create an `average` variable, which we''ll do
    in a second, and then we can `return our string`. So, that is the goal for this
    function, but this is where we run into one of the first problems you most likely
    have seen when working with promises:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调用了`getGrades`，我们将接下来访问这些成绩。`getGrades` promise的成功回调将获得`grades`数组。然后我们可以继续创建一个`average`变量，我们将在下一步中完成，然后我们可以`return
    our string`。因此，这是这个函数的目标，但这是我们在使用promise时可能遇到的第一个问题之一：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have the `getStatus` promise chain; we have to have one promise called in
    order to actually start the other one and, at the end of the day, I want to do
    something with values from both. Well, we can't; we do not have access to user
    inside the second `then` function. It was created in another function, the first
    `then` callback, which is a pretty common problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`getStatus`的promise链；我们必须调用一个promise才能实际启动另一个promise，而且最终，我想对来自两者的值做一些处理。嗯，我们不能；我们无法在第二个`then`函数内访问用户。它是在另一个函数中创建的，即第一个`then`回调，这是一个相当常见的问题。
- en: So, how do we solve this? There are a few ways we could do that. Most of them
    are kind of ugly workarounds. Just below the `getStatus` variable, I could make
    a variable called `user` and I would set it equal to undefined at first.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何解决这个问题呢？我们可以有几种方法来解决。其中大多数都是有点丑陋的解决方法。就在`getStatus`变量下面，我可以创建一个名为`user`的变量，并首先将其设置为未定义。
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, in the first `then` callback, I will give it a value when this function
    runs. Now, I can''t have two variables with the same thing. If I try to type `user
    = user`, we''re going to run into some problems:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第一个`then`回调中，当此函数运行时，我将给它一个值。现在，我不能有两个具有相同内容的变量。如果我尝试输入`user = user`，我们将遇到一些问题：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is going to take the `user` value and set it equal to the user value in
    then callback. It''s not going to use the user variable at all. So we have to
    add another little workaround: `tempUser`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它将获取`user`的值并将其设置为`then`回调中的用户值。它根本不会使用用户变量。因此，我们必须添加另一个小的解决方法：`tempUser`。
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then we're going to go ahead and set `user = tempUser`, and this is going to
    technically work. We'll now have access to user variable and we can get some stuff
    done.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将继续设置`user = tempUser`，这在技术上可以工作。我们现在将可以访问用户变量并完成一些工作。
- en: Calculating the average
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算平均值
- en: 'So, we can calculate the average of our `average = 0` in the second `then`
    callback function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在第二个`then`回调函数中计算我们的`average = 0`的平均值：
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we''ve been using const throughout the course. We can actually switch
    our `var` over to `let`; `let` is the ES6 equivalent to `var`, so this is a variable
    whose value we can change:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个课程中，我们一直在使用const。我们实际上可以将我们的`var`改为`let`；`let`是ES6中`var`的等价物，因此这是一个其值可以更改的变量：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we''re going to start off with an average of `0` and move on to actually
    calculating a better average if there are `grades`: `grades.length`. If `grades.length`
    is greater than `0`, we''re going to go ahead and actually run a calculation.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从平均值`0`开始，然后继续计算更好的平均值，如果有`grades`：`grades.length`。如果`grades.length`大于`0`，我们将继续实际运行计算。
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we're going to use a few array methods here. First up, we're going to set
    average equal to some value. We're going to kick things off by taking our array
    of objects and getting it down to an array of numbers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要在这里使用一些数组方法。首先，我们将把平均值设置为某个值。我们将从对象数组开始，将其转换为数字数组。
- en: We'll do that using map; that's `grades.map`. Here, we're going to go ahead
    and get access to the individual grade and all we're going to do is implicitly
    return `grade.grade`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用map来做到这一点；就是`grades.map`。在这里，我们将继续访问单个grade，我们要做的就是隐式返回`grade.grade`。
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, we have the individual `grade` object and we're trying to access its `grade`
    property. At this point, we have an array of numbers. We need to turn those numbers
    into a sum and then we have to divide that by the length of the array. We'll be
    using `reduce` here, so we call `reduce` on an array of numbers. `reduce` works
    a little differently than some of the other array methods you might have seen
    in the past. This one takes two arguments, `a` and `b`;
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有单个`grade`对象，我们正在尝试访问它的`grade`属性。在这一点上，我们有一个数字数组。我们需要将这些数字转换为总和，然后我们必须将其除以数组的长度。我们将在这里使用`reduce`，所以我们在数字数组上调用`reduce`。`reduce`的工作方式与您过去可能见过的其他一些数组方法有些不同。这个方法接受两个参数，`a`和`b`；
- en: '[PRE35]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So, the first time it goes through, it''s going to take the first two grades
    and we''ll be able to do something with those grades. What do we want to do? We
    want to return `a + b`. Then it''s going to take that sum for the first two grades,
    it is going to call the reduce function again, putting that sum and putting the
    third grade. We''ll take `a + b` to get that value added on to the new `b` and
    then we''ll continue to generate that sum. Now, you can actually simplify that
    `a + b`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，第一次通过时，它将获取前两个成绩，我们将能够对这些成绩做些什么。我们想要做什么？我们想要返回`a + b`。然后它将获取前两个成绩的总和，然后再次调用reduce函数，将该总和和第三个成绩放在一起。我们将取`a
    + b`来获得添加到新`b`上的值，然后我们将继续生成该总和。现在，你实际上可以简化`a + b`：
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, this alone just gives us the sum so, in the case of `Andrew`, we haven't
    calculated the average `83`; we've just added up the two numbers. You also want
    to divide this by `grades.length`; that is what's going to give us the average.
    We can go ahead and test this out by printing the `average` variable, `console.log
    (average)`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这仅仅给我们提供了总和，所以在`Andrew`的情况下，我们还没有计算出平均值`83`；我们只是把这两个数字加起来了。你还想要除以`grades.length`；这将给我们平均值。我们可以通过打印`average`变量来测试这一点，`console.log(average)`。
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I'm going to save it. We have `getStatus` and we have `getStatus` for `1`. That
    is perfectly fine, we can continue to use that. In the terminal, we get `83` printing,
    which is the correct average.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我要保存它。我们有`getStatus`和`getStatus` for `1`。这完全没问题，我们可以继续使用。在终端中，我们得到`83`的打印，这是正确的平均值。
- en: '![](img/9ddf5dd1-a439-4778-9e86-517849b86da5.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ddf5dd1-a439-4778-9e86-517849b86da5.png)'
- en: If I go ahead and rerun it for user `2`, we get `100` printing. Everything is
    working really well; `undefined` is just coming up because we don't have anything
    returned so status equals `undefined`, which prints in the `console.log` statement.
    So, instead of just dumping average to the screen, let's go ahead and actually
    return our template string. This is the final thing we're going to do in this
    section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我继续为用户`2`重新运行，我们会得到`100`的打印。一切都运行得非常顺利；`undefined`只是出现，因为我们没有返回任何东西，所以状态等于`undefined`，这会在`console.log`语句中打印出来。所以，我们不仅仅把平均值倒出来，让我们实际返回我们的模板字符串。这是我们在本节中要做的最后一件事情。
- en: Returning the template string
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回模板字符串
- en: 'Just above the `console.log` statement for average, we''re going to follow
    this format starting off with the name, that is, `user.name`. Then we''re going
    to move on to the next part, has a, followed by their grade. That''s the `average`.
    We''ll toss the `%` after it in the class period:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在平均值的`console.log`语句上面，我们将按照这种格式开始，首先是名字，也就是`user.name`。然后我们将继续下一部分，有一个，后面跟着他们的成绩。那就是`average`。我们将在班级期间加上`%`：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we''re returning something, this value will be accessible to whoever
    calls `getStatus`. In this case, that happens right here. In the Terminal, we
    see `Jessica has 100% in the class` printing to the screen:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在返回一些东西，这个值将可以被调用`getStatus`的人访问。在这种情况下，就是这里。在终端中，我们看到`Jessica在班级中有100%`打印到屏幕上：
- en: '![](img/b34cd88f-5855-41dd-90f3-65856c3ec008.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b34cd88f-5855-41dd-90f3-65856c3ec008.png)'
- en: 'If I go on to `1`, we see `Andrew` has an `83` and, if I type in some other
    `id`, we can see `Unable to find user with the id of 123` printing. So, this is
    it for our contrived starter example. I know there wasn''t a heck of a lot of
    interesting stuff here, but I promise having an example to work with, it''s going
    to make understanding async/await so much easier. So, the goal in the next section
    is to take the code snippet and get it down to about three lines of code using
    this new syntax:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我继续到`1`，我们会看到`Andrew`有一个`83`，如果我输入其他的`id`，我们会看到打印`无法找到id为123的用户`。所以，这就是我们构造的起始示例。我知道这里没有太多有趣的东西，但我保证有一个示例可以让理解async/await变得更容易。所以，下一节的目标是使用这种新的语法将代码片段简化为大约三行代码：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's going to be three lines of code that are a whole lot easier to read and
    work with. It's going to look like synchronous code as opposed to callbacks and
    promise chains.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是三行代码，更容易阅读和处理。它看起来像同步代码，而不是回调和promise链。
- en: Async/await basics
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async/await基础知识
- en: 'In this section, you''re finally going to get to use the new async/await functionality.
    We''re going to create an alternative version of the `getStatus` function and
    call it `getStatusAlt`, so we can go ahead and actually define that: a const `getStatusAlt`. Now,
    it''s still going to be a function, so we''re going to start off by creating an
    arrow function (`=>`). We''re still going to take in an argument, so we''ll define
    that `userId`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你终于将要使用新的async/await功能。我们将创建`getStatus`函数的另一个版本并称之为`getStatusAlt`，所以我们可以继续并实际定义它：一个const
    `getStatusAlt`。现在，它仍然是一个函数，所以我们将开始创建一个箭头函数(`=>`)。我们仍然会接受一个参数，所以我们将定义`userId`：
- en: '[PRE40]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, though, we're going to switch things up. Instead of working through the
    old example, we're going to use the new async/await functionality. To explore
    this, let's temporarily comment out the `getStatus`-`then` and `catch` block code.
    We'll be recreating it with a call to `getStatusAlt` as opposed to a call to `getStatus`,
    but I do want to leave the old code in place so we can directly compare and contrast
    the differences.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要改变一下。不再使用旧的例子，我们将使用新的async/await功能。为了探索这一点，让我们暂时注释掉`getStatus`-`then`和`catch`块代码。我们将用`getStatusAlt`的调用来重新创建它，而不是用`getStatus`的调用，但我确实想留下旧代码，这样我们可以直接比较和对比差异。
- en: The new async/await functionality is going to allow us to write our old code
    in a way that looks like synchronous code, which means that we'll be able to avoid
    things like `then` callbacks, promise chaining, and workarounds. With async/await,
    we're going to able to avoid all of that stuff, creating a function that's just
    a whole lot easier to read, alter, work with, and test. Now, `getStatusAlt` is
    going to start off in a way that is super boring.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 新的async/await功能将允许我们以看起来像同步代码的方式编写旧代码，这意味着我们将能够避免像`then`回调、promise链和变通方法之类的东西。使用async/await，我们将能够避免所有这些东西，创建一个更容易阅读、修改、处理和测试的函数。现在，`getStatusAlt`将以一种非常无聊的方式开始。
- en: 'We''re going to return a string, `Mike`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将返回一个字符串，`Mike`：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the JavaScript `101` stuff. You would expect `Mike` to come back. If
    I use `consult.log`, his name should pop out through `getStatusAlt`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript的基础知识。你期望得到`Mike`。如果我使用`consult.log`，他的名字应该通过`getStatusAlt`弹出。
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s just go ahead and work through this, so we''re going to save the file,
    `nodemon` is going to restart, and there we go. We have `Mike` printing to the
    screen:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行这个，所以我们将保存文件，`nodemon`将重新启动，然后我们就可以了。我们在屏幕上打印出`Mike`：
- en: '![](img/a7eaf74b-6b0e-4ffe-9b31-76b5f717ace6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7eaf74b-6b0e-4ffe-9b31-76b5f717ace6.png)'
- en: That's exactly what we would expect. Now, with async/await, we actually mark
    our functions as special functions. I have a few functions here. We're going to
    be marking `return 'Mike'` as a special async function. So in the future, `async/await`
    are going to be two words `async` and `await`. These aren't just words, but actual
    keywords that we're going to be typing out.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的。现在，使用async/await，我们实际上将我们的函数标记为特殊函数。我这里有几个函数。我们将把`return 'Mike'`标记为一个特殊的async函数。所以在未来，`async/await`将是两个单词`async`和`await`。这不仅仅是单词，而是我们将要输入的实际关键字。
- en: Using the async function
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步函数
- en: 'The first one, `await`, will eventually get used inside of our `async` functions
    but, before we can ever use `await`, we have to mark that function as `async`,
    so we''re going to do that first. We''re going to explore it, then we''ll move
    on to `await`. In the `getStatusAlt` variable line, all we''re going to do is
    add `async` in front of our arguments list with a space:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`await`将最终在我们的`async`函数内部使用，但在我们能够使用`await`之前，我们必须将该函数标记为`async`，所以我们将首先这样做。我们将探索它，然后继续使用`await`。在`getStatusAlt`变量行中，我们要做的就是在参数列表前面加上`async`并加上一个空格：
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, this is actually going to change how the `console.log` works; to explore
    that, all we''re going to do is save the file and see what we get. Instead of
    getting the string `Mike` back, you can see we''re now getting a `Promise` back:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这实际上会改变`console.log`的工作方式；为了探索这一点，我们要做的就是保存文件并查看我们得到了什么。我们不再得到字符串`Mike`，你可以看到我们现在得到了一个`Promise`：
- en: '![](img/5ed5f2f8-73dd-49f2-b71f-cbd75509283e.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ed5f2f8-73dd-49f2-b71f-cbd75509283e.png)'
- en: 'We''re getting a promise back that resolves the string `Mike`, so this brings
    us to the first big difference between regular functions and `async` functions.
    Regular functions return strings and strings come back; `async` functions always
    return promises. If you return something from an `async` function, it''s actually
    returning a promise and it''s resolving the value. So this function is equivalent
    to the following code. You don''t have to write this out; this is just to get
    the idea. It is equivalent to creating a function that returns a new promise where
    that new promise gets `resolve` and `reject`, and it then calls resolve with `Mike`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个解析为字符串`Mike`的promise，这就是常规函数和`async`函数之间的第一个重大区别。常规函数返回字符串并返回字符串；`async`函数总是返回promise。如果你从`async`函数返回了某些东西，实际上它返回的是一个promise并且解析了这个值。所以这个函数等同于以下代码。你不必写出这个；这只是为了理解。它等同于创建一个返回新promise的函数，这个新promise得到`resolve`和`reject`，然后用`Mike`调用resolve：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These two are identical, they have the exact same functionality. We create a
    new promise, we resolve `Mike` or we use an `async` function that simply returns
    something.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者是相同的，它们具有完全相同的功能。我们创建一个新的promise，我们解析`Mike`或者使用一个简单返回某些东西的`async`函数。
- en: 'So, that is lesson one: when you have an `async` function, whatever you return
    is actually just going to get resolved, which means that we can switch up this
    usage.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是第一课：当你有一个`async`函数时，你返回的任何东西实际上都将被解析，这意味着我们可以改变这种用法。
- en: In place of `console.log` statement, I'm going to call `getStatusAlt`. This
    time we're getting a promise back and we know that, so we can just use the `then`
    callback. What are we going to get back? We're going to get back the return value
    as our resolved value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`console.log`语句的位置，我将调用`getStatusAlt`。这次我们得到一个promise，我们知道，所以我们可以使用`then`回调。我们将得到什么？我们将得到返回值作为我们的解决值。
- en: 'If I return to string, I''d get a string back; here a number, I''d get a number;
    a Boolean, an object, a function; whatever you explicitly return from this function
    is going to be available as if it was resolved, which means that I can create
    a name variable like a `console.log(name)`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我返回字符串，我会得到一个字符串；这里是一个数字，我会得到一个数字；一个布尔值，一个对象，一个函数；无论你从这个函数中明确返回什么，都将作为已解决的值可用，这意味着我可以创建一个名为`console.log(name)`的变量：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, what are we going to get back inside `nodemon`? We''re just going to get
    back `Mike` once again, the regular plain old string. Because we''ve added on
    a piece of promise-based chaining, we then get the name and we print it out, and
    here `Mike` prints once again:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`nodemon`中我们将得到什么？我们将再次得到`Mike`，普通的字符串。因为我们添加了一个基于promise的链条，然后我们得到名字并将其打印出来，这里`Mike`再次打印出来：
- en: '![](img/df24595e-51c1-4109-9dda-980a368ea47b.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df24595e-51c1-4109-9dda-980a368ea47b.png)'
- en: So, if returning a value is equivalent to resolving, how do we reject?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果返回一个值等同于解决，那么我们如何拒绝？
- en: Rejecting an error using the async function
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`async`函数拒绝错误
- en: 'If I want it to reject an error like (`''This is an error''`), how do I go
    about doing that with the new `async` feature? All we do is throw a new error
    using standard JavaScript techniques. Throw a new error with a message, (`''This
    is an error''`):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想要拒绝一个错误（`'This is an error'`），我该如何使用新的`async`功能来做到这一点？我们只需使用标准的JavaScript技术抛出一个新的错误。使用消息抛出一个新的错误（`'This
    is an error'`）：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is equivalent to using the `reject` argument in the new Promise. When
    you throw a new error from an `async` function, it is exactly the same as rejecting
    some value. So, in this case, we can go ahead and use that error by adding a `catch`,
    like we would if it was a regular old promise. We''re going to get the error back,
    and I''ll use `console.log` to print it to the screen, if it occurs:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在新的Promise中使用`reject`参数。当你从`async`函数中抛出一个新的错误时，它与拒绝某个值完全相同。因此，在这种情况下，我们可以继续使用该错误，通过添加`catch`，就像我们处理常规的promise一样。我们将得到错误，如果发生，我将使用`console.log`将其打印到屏幕上：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It''s always going to occur, because I throw it on line `1`. If I save the
    file, `nodemon` restarts and we get `Error: This is an error` printing to the
    screen:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '它总是会发生，因为我在第1行抛出了它。如果我保存文件，`nodemon`会重新启动，我们会得到`Error: This is an error`打印到屏幕上：'
- en: '![](img/c705b4a4-fef0-4bca-8159-8b51cc42380e.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c705b4a4-fef0-4bca-8159-8b51cc42380e.png)'
- en: So, those are the first two important things you need to know about `async`
    functions before we go any further and use await. Returning something is equivalent
    to resolving, and throwing an error is equivalent to rejecting; we always get
    a promise back.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在继续使用`await`之前，你需要了解的`async`函数的前两个重要事项。返回某些东西等同于解决，抛出错误等同于拒绝；我们总是得到一个promise。
- en: Using the await function
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`await`函数
- en: At this point, we have only used half of the feature. We've used the `async`
    part, which alone is not particularly useful. It gets really useful when we combine
    it with `await`, so let's go ahead and start taking a look at that.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了功能的一半。我们使用了`async`部分，单独使用并不特别有用。当我们将其与`await`结合使用时，它变得非常有用，所以让我们继续开始看一下。
- en: 'The `await` function is going to allow us to introduce the other functions
    back into play, `getGrades` and `getUser`. We''re just going to go ahead and use
    `await`, and then we''ll talk about exactly what''s happening. So, for the moment,
    bear with me and just type out this line: `const user =` and we''re going to set
    it equal to the `await` keyword. We''ll talk about this in just a second; we''re
    going to call `getUser` and we''re going to pass in the `userId`. So let''s start
    breaking this line down:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`函数将允许我们重新引入其他函数，`getGrades`和`getUser`。我们将继续使用`await`，然后我们将讨论确切发生了什么。所以，暂时跟我一起，只需输入这一行：`const
    user =`，然后我们将其设置为`await`关键字。我们将在接下来讨论这一点；我们将调用`getUser`并传入`userId`。所以让我们开始分解这一行：'
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've done this before; we're calling `getUser` with the `userId`. It returns
    a promise.  We're creating a new variable user and it's a constant; it's the `await`
    part that's new. So the `await` keyword, as I mentioned earlier, has to be used
    in an `async` function. We're meeting that criteria. We have an `async` function,
    which means we can use await inside it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前做过这个；我们使用`userId`调用`getUser`。它返回一个promise。我们创建一个新的变量user，它是一个常量；新的部分是`await`。所以`await`关键字，正如我之前提到的，必须在`async`函数中使用。我们满足了这个标准。我们有一个`async`函数，这意味着我们可以在其中使用`await`。
- en: We use `await` just before a promise, so here we get a promise back. So, we're
    awaiting for that promise to either `resolve` or `reject`. If that promise resolves,
    the result of this expression is going to be the resolved value, which means that
    resolved value will get stored in the user variable. If the promise rejects, it
    is going to be equivalent to throwing an error, which means no user variable will
    ever be created. The function will stop executing and we'll get that error inside
    `catch`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个promise之前使用`await`，所以这里我们得到一个promise。因此，我们正在等待该promise要么`resolve`要么`reject`。如果该promise被解决，这个表达式的结果将是解决的值，这意味着解决的值将被存储在用户变量中。如果promise被拒绝，它将等同于抛出一个错误，这意味着永远不会创建用户变量。函数将停止执行，我们将在`catch`中得到该错误。
- en: 'Let''s go ahead and actually play around with this. What I''m going to do is
    pass an `id` into `getStatusAlt`. Let''s go ahead and use `Jessica`; all we''re
    going to do is `console.log(user)` to the screen. We want to see what user equals.
    Now, `nodemon` is going to restart in the background and my `nodemon` got cleared
    before:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实际操作一下。我要把一个`id`传递给`getStatusAlt`。让我们使用`Jessica`；我们要做的就是将`user`打印到屏幕上。现在，`nodemon`将在后台重新启动，我的`nodemon`在之前被清除了：
- en: '![](img/d87d9af9-e821-468c-b768-3957d25d81d4.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d87d9af9-e821-468c-b768-3957d25d81d4.png)'
- en: Right here, we have our object with an `id` of `2`, the name of `Jessica`, and
    the school id of `999`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`id`为`2`的对象，名为`Jessica`，学校id为`999`。
- en: Now, without `await`, we would be getting a promise back; with `await`, we're
    able to actually get that value back, which is equivalent to what we did previously.
    It's equivalent to this stuff where we got access to the user and we did something
    with it but, using `async/await`, we're able to do this in a way that looks very
    synchronous.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，没有`await`，我们将得到一个promise；有了`await`，我们实际上能够得到那个值，这相当于我们之前所做的。这相当于我们获得了用户的访问权并对其进行了操作，但是，使用`async/await`，我们能够以看起来非常同步的方式做到这一点。
- en: 'Now, we can apply this exact same technique to getting the grades. Next to
    the `user` const, we''re going to make a const called `grades`. We want those
    grades back. What we don''t want to do is create stupid temporary variables, add
    complex chaining, and nesting. We just want to get the grades, so we''re going
    to await the following promise, to either `resolve` or `reject`. For the one that
    comes back from `getGrades`, we pass in a valid school id, `user.schoolId`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个确切的技术应用到获取成绩上。在`user`常量旁边，我们将创建一个名为`grades`的常量。我们想要那些成绩。我们不想创建愚蠢的临时变量，添加复杂的链接和嵌套。我们只想得到成绩，所以我们将等待以下promise，要么`resolve`要么`reject`。对于从`getGrades`返回的那个，我们传入一个有效的学校id，`user.schoolId`：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is going to return the `grades` array, for that user will be able to dump
    them to the screen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回该用户的`grades`数组，我们将能够将它们显示在屏幕上。
- en: 'So, in the Terminal, we are getting the object and the grades for `Jessica`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在终端中，我们正在获取`Jessica`的对象和成绩：
- en: '![](img/739f501c-8c70-46e8-8293-12942466abb9.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/739f501c-8c70-46e8-8293-12942466abb9.png)'
- en: 'She just has one grade, so we have an array with a single object inside it.
    We''re not getting back a promise; we''re getting back a regular old array. The
    same thing is true for `Andrew`; he''s going to have those two grades:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 她只有一个成绩，所以我们有一个包含单个对象的数组。我们得到的不是一个promise；我们得到的是一个普通的数组。对于`Andrew`也是一样；他将有这两个成绩：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'They''re all going to come back and, if I switch this up to an `id` that''s
    not valid, we''re going to get our error: `Unable to find user with an id of 123`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都会回来，如果我把这个切换到一个无效的`id`，我们会得到我们的错误：`无法找到id为123的用户`：
- en: '![](img/8fa2a59c-d746-4226-8300-43b89c28006d.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fa2a59c-d746-4226-8300-43b89c28006d.png)'
- en: 'That is because the `await` function rejects, which is equivalent to throwing
    an error. We saw that when we throw an error from an `async` function with access
    to it via `catch`. So, at this point, we have our user, we have our grades, and
    we''re ready to move on to the final step, which is the actual important stuff.
    So far, we''re just getting data out, took a few lines of code that required us
    to nest things. At this point, we can take the code snippet for average, exactly
    as it sits:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`await`函数会拒绝，这相当于抛出一个错误。我们看到当我们从具有访问权限的`async`函数中抛出错误时，可以通过`catch`访问它。所以，在这一点上，我们有了我们的用户，我们有了我们的成绩，我们准备继续进行最后一步，也就是真正重要的事情。到目前为止，我们只是获取数据，需要嵌套几行代码。在这一点上，我们可以采用平均值的代码片段，就像它所在的位置一样：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This code relies on a `user` variable, which we have, and a `grades` variable,
    again, we have it as well. We can take it and copy it in the `async` function
    like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码依赖于一个`user`变量，我们有，还有一个`grades`变量，同样，我们也有。我们可以把它复制到`async`函数中，像这样：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we set up our average variable. We calculate the average if there are
    grades and we return our status:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们设置了我们的平均变量。如果有成绩，我们计算平均值并返回我们的状态：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'At this point, we can use the status and we can print it using the `console.log`
    statement. Let''s change this back to a valid `id`, either `1` or `2`, some `id`
    that does exist. This time, when JavaScript runs through `getStatusAlt`, it is
    actually going to return the correct status: `Andrew has an 83 in the class` or `Jessica
    has a 100 in the class`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用状态，并使用`console.log`语句打印出来。让我们把它改回一个有效的`id`，要么是`1`要么是`2`，一些存在的`id`。这一次，当JavaScript运行`getStatusAlt`时，它实际上会返回正确的状态：`Andrew在课堂上得了83分`或`Jessica在课堂上得了100分`：
- en: '![](img/28df30c7-48ca-4b69-b59d-9acbf81ca8eb.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28df30c7-48ca-4b69-b59d-9acbf81ca8eb.png)'
- en: We were able to do all of this without a single callback, no chaining, no nesting,
    just regular old code that looks like synchronous code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够做到所有这一切，没有一个回调，没有链接，没有嵌套，只是看起来像同步代码的常规旧代码。
- en: This code is way more readable, maintainable, and understandable than what we
    have up above. Using `async`/`await`, we're going to be able to do just that.
    We're going to be able to write better, more concise promise-based code. Now,
    you'll notice that I'm not using `await` on the functions up above. There is no
    need to, because we don't need `async` inside them. One more important thing to
    note, there is no top-level `await`. You have to use `await` inside an `async`
    function so, in our case, all that means is that we do use a little chaining at
    the end, but when we are working with complex chains, we are able to use `async/await`
    to get the job done.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比我们上面的更可读，更易维护，更易理解。使用`async`/`await`，我们将能够做到这一点。我们将能够编写更好、更简洁的基于promise的代码。现在，你会注意到我在上面的函数中没有使用`await`。没有必要，因为我们不需要在其中使用`async`。还有一件重要的事情要注意，就是没有顶层的`await`。你必须在`async`函数中使用`await`，所以在我们的情况下，这意味着我们在最后使用了一点点链接，但是当我们处理复杂的链式结构时，我们可以使用`async/await`来完成工作。
- en: At this point, I don't expect you to be able to use `async`/`await` on your
    own. We're going to run through another example using real APIs that's going to
    give us a little more real-world experience. I'm excited to get to it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我不指望你能够自己使用`async`/`await`。我们将通过另一个使用真实API的例子来获得更多真实世界的经验。我很兴奋。
- en: A real-world example
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个真实世界的例子
- en: 'In this section, we''re going to move on from our contrived example and we''re
    going to look at an example using two real HTTP APIs. Before we do, it''s important
    to note that arrow functions (`=>`) aren''t the only functions that support `async`.
    I just happen to use an arrow function (`=>`). I could also use an ES5 function
    with the `function` keyword; this works as well:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从我们编造的例子中迈出，然后我们将看一个使用两个真实的HTTP API的例子。在此之前，重要的是要注意箭头函数(`=>`)并不是唯一支持`async`的函数。我碰巧使用了箭头函数(`=>`)。我也可以使用带有`function`关键字的ES5函数；这同样有效：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'I can save the file and I''m still going to get `Jessica has 100%` printing:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以保存文件，仍然会打印出`Jessica has 100%`：
- en: '![](img/b8ec5e0a-4379-481c-b740-d670caa0ac4d.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8ec5e0a-4379-481c-b740-d670caa0ac4d.png)'
- en: I could also `async` an ES6 object method, but I'm going to stick to an arrow
    function (`=>`) here. Now, we're going to leave this file in the dust and we're
    going to move on to a brand new file for our real-world example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以`async`一个ES6对象方法，但我会继续使用箭头函数(`=>`)。现在，我们将把这个文件抛在脑后，然后转到一个全新的文件来进行我们的真实世界的例子。
- en: Creating a currency-converter using the async/await function
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用async/await函数创建货币转换器
- en: This one is going to be called `currency-convert.js` and, as you can probably
    guess by the name, we're going to create a currency converter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件将被称为`currency-convert.js`，你可能已经猜到，我们将创建一个货币转换器。
- en: Essentially, this is just a function that takes three arguments. We're going
    to start off with the currency code for the currency we're starting with; in this
    case, let's say I have US dollars. Then there's the currency code we're trying
    to convert to; let's say I'm going up to Canada and I want to see how much my
    money is worth; and the amount we want to convert by.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这只是一个带有三个参数的函数。我们将从我们要开始的货币代码开始；在这种情况下，假设我有美元。然后是我们要转换的货币代码；假设我要去加拿大，想知道我的钱值多少；以及我们要转换的金额。
- en: 'So, this is essentially asking for the Canadian equivalent of `23 USD`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这本质上是在询问`23美元`的加拿大等值物：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''re going to be able to use any code we want and any value we want. Now,
    to actually get all that information, we are going to be using two APIs. We would
    essentially be saying `23 USD is worth28 CAD. You can spend these in the following
    countries`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够使用任何我们想要的代码和任何我们想要的值。现在，为了真正获得所有这些信息，我们将使用两个API。我们基本上会说`23美元相当于28加拿大元。你可以在以下国家使用这些`：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Then we'll go ahead and list out all of the countries that actually accept the
    Canadian dollar. Now, to actually get all this information, we will be using those
    two APIs and I do want to explore those over inside Chrome. Then, we'll install
    Axios, make the requests, and integrate all of that into the currency converter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将列出所有实际接受加拿大元的国家。现在，为了真正获得所有这些信息，我们将使用这两个API，并且我想在Chrome中探索它们。然后，我们将安装Axios，发出请求，并将所有这些集成到货币转换器中。
- en: Exploring APIs for currency exchange rate
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索货币汇率的API
- en: 'The first API we''re going to be using is at [fixer.io](http://fixer.io/):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第一个API在[fixer.io](http://fixer.io/)上：
- en: '![](img/a6c4836a-172c-4101-acd2-d02c93c36e95.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6c4836a-172c-4101-acd2-d02c93c36e95.png)'
- en: This one is going to give us current currency numbers, so we're going to be
    able to get those exchange rates. If we go over to their website, they have a
    great usage page. You can click the URLs; it's going to show you the exact data
    that would come back had you made an HTTP request.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们当前货币数字，所以我们将能够获得这些汇率。如果我们去他们的网站，他们有一个很好的使用页面。你可以点击URL；它会显示你如果发出了HTTP请求会得到的确切数据。
- en: 'This API and the other one we''re going to be using, they do not require authentication
    so we''re going to be able to integrate them without too much trouble. Here, we
    see the base currency is the Euro and we can see what a Euro is worth in other
    currencies. So €1 is currently worth 1.2411 USD or 1.5997 CAD:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API和我们将要使用的另一个API，它们不需要身份验证，所以我们将能够轻松地集成它们。在这里，我们看到基本货币是欧元，我们可以看到欧元在其他货币中的价值。因此，€1目前价值1.2411美元或1.5997加拿大元：
- en: '![](img/36b75cae-700a-47d5-a1c6-9654a68cf1f6.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36b75cae-700a-47d5-a1c6-9654a68cf1f6.png)'
- en: This is the first end point that we're going to be using and we're actually
    going to be using an alternative following. Here we can specify the base query
    parameter that is going to start us out at the currency of our choice. This is
    the currency that we're converting from and then we get the exchange rate.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要使用的第一个端点，我们实际上将使用一个替代方案。在这里，我们可以指定基本查询参数，这将使我们从我们选择的货币开始。这是我们要转换的货币，然后我们得到汇率。
- en: So, if I wanted to convert US dollars to Canadian dollars, I would get the base
    USD conversion chart. I would find this number and I would just multiply `23`
    by this number, or whatever value I was trying to convert. So this is API number
    one; let's go ahead and grab the URL, open it up in the browser and we're going
    to leave that up.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我想将美元转换为加拿大元，我将得到基本美元转换图表。我会找到这个数字，然后将`23`乘以这个数字，或者我想要转换的任何值。所以这是API编号一；让我们去获取URL，在浏览器中打开它，然后我们将保持它开着。
- en: 'The other API that we''re going to be using, you can find at [restcountries.eu](http://restcountries.eu/).
    This one contains some useful information about countries. If you go to the All
    example, we can get this URL:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的另一个API，你可以在[restcountries.eu](http://restcountries.eu/)找到。这个API包含一些有关国家的有用信息。如果你去All示例，我们可以得到这个URL：
- en: '![](img/13b625b3-896c-4479-a9d8-98162303e6f2.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13b625b3-896c-4479-a9d8-98162303e6f2.png)'
- en: 'We can crack it open in the browser and we can see the extensive list of countries
    and country data that the API returns, starting off with `Afghanistan`: various
    things about it, top-level domains, alternative spellings, `regions`, lat and
    long, `population`, a lot of really nice information:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器中打开它，然后我们可以看到API返回的国家和国家数据的详尽列表，从`阿富汗`开始：关于它的各种信息，顶级域，替代拼写，`地区`，纬度和经度，`人口`，很多非常好的信息：
- en: '![](img/a6ff62d0-642b-4be6-a7d5-81730f992e4c.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/a6ff62d0-642b-4be6-a7d5-81730f992e4c.png)
- en: 'It also includes those currency codes, so we''re actually going to be using
    a different endpoint. They support the Currency endpoint:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括那些货币代码，所以我们实际上将使用不同的端点。他们支持货币端点：
- en: '![](img/f2fe1c21-e741-4e4d-8592-89304582a399.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f2fe1c21-e741-4e4d-8592-89304582a399.png)
- en: 'This lets you find countries that use a specific currency, so let''s take this
    URL and crack it open in the browser. Here we''re using `cop`; let''s go ahead
    and swap that out for `usd`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这让您找到使用特定货币的国家，因此让我们使用此URL并在浏览器中打开它。这里我们使用`cop`；让我们继续将其替换为`usd`：
- en: '![](img/c2ec3da1-d9d6-455b-bdd2-9fc43b274cb6.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/c2ec3da1-d9d6-455b-bdd2-9fc43b274cb6.png)
- en: Now, there are multiple countries that use the United States dollar. We have
    `American Samoa`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有多个国家使用美元。我们有`美属萨摩亚`。
- en: 'Down below, if we scroll way, way, way down the list, we''re going to get other
    things; here we''ve got Zimbabwe, for example. Then, we have the United States
    of America - that''s an obvious one - Turks and Caicos Islands:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，如果我们向下滚动列表，我们将得到其他东西；例如，这里有津巴布韦。然后，我们有美利坚合众国-这是一个明显的例子-特克斯和凯科斯群岛：
- en: '![](img/c380bfce-b017-4b6e-8d8c-6fba9a14b850.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/c380bfce-b017-4b6e-8d8c-6fba9a14b850.png)
- en: 'So there are quite a few different places that use the US dollar. If we swap
    it out for `cad` - Canada; only one there:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有很多不同的地方使用美元。如果我们将其替换为`cad`-加拿大；只有一个：
- en: '![](img/3a9f94bb-8a3e-423e-8d08-d20afdf77a75.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/3a9f94bb-8a3e-423e-8d08-d20afdf77a75.png)
- en: So, using these two endpoints, we're going to be able to convert the currency
    and figure out, which countries support that currency. We're going to wire all
    of this up together, then I'm going to set you out on your own to actually use
    async/await to get that information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用这两个端点，我们将能够转换货币并找出哪些国家支持该货币。我们将把所有这些连接在一起，然后我将让您自己使用async/await来获取该信息。
- en: Taking advantage of axios inside our application
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中利用axios
- en: 'Let''s go ahead and kick things off over inside the Terminal by shutting things
    down, clearing the output, and installing the necessary dependencies. I''m going
    to run `npm init`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过关闭事物，清除输出并安装必要的依赖项来在终端内启动事物。我将运行`npm init`：
- en: '![](img/f7551dc3-cf00-4304-be21-38dc2e2b092d.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f7551dc3-cf00-4304-be21-38dc2e2b092d.png)
- en: 'We can just generate a quick `package.json` file using the defaults and they''ll
    use `npm install axios`. The current version of Axios is `0.18.1`, and we''ll
    toss on the `save` flag:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用默认值快速生成一个`package.json`文件，然后使用`npm install axios`。Axios的当前版本是`0.18.1`，我们将添加`save`标志：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It's going to make sure to say that as a dependency, and there we go. Everything
    is working, as expected. Now we can clear this output and we can actually take
    advantage of Axios inside our application. So, let's kick things off with the
    first one. We're going to go ahead and set up a function that makes the call to
    Fixer and gets the exchange rate.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 它将确保将其作为依赖项，并且一切都按预期工作。现在我们可以清除此输出，并且实际上可以在我们的应用程序中利用Axios。因此，让我们从第一个开始。我们将继续设置一个函数，该函数调用Fixer并获取汇率。
- en: The getExchangeRate function
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: getExchangeRate函数
- en: 'To do that, over inside Atom, we''re going to kick things off by creating a
    `const axios`; we''re going to `require axios`, and then we''re going to make
    `const` for one of our two functions. This is for the first endpoint `getExchangeRate`.
    Now, `getExchangeRate` is going to take two pieces of information: the `from`
    currency code and the `to` currency code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在Atom内部，我们将通过创建一个`const axios`来启动事物；我们将`require axios`，然后我们将为我们的两个函数之一创建`const`。这是第一个端点`getExchangeRate`。现在，`getExchangeRate`将获取两个信息：`from`货币代码和`to`货币代码：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is going to be a function. All we''re going to do is use `axios`. That''s
    `axios.get`, and we''re going to pass in that URL that I just copied from the
    browser:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个函数。我们将只使用`axios`。这是`axios.get`，然后我们将传入我刚从浏览器中复制的URL：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now we want to set the base equal to whatever currency we're coming from. So
    I can go ahead and use a template string, swapping out the static base value for
    a dynamic one, accessing `from` and `then` functions. We're going to use `then`
    real quick. We're going to use `then` here to just manipulate the value. This
    is going to return the promise from Axios with a bunch of information about the
    HTTP requests. The caller of `getExchangeRate` does not care about that. They
    shouldn't even know that an HTTP request was made. All they need back is a number,
    so that is exactly what we're going to give them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想将基础设置为我们来自的任何货币。因此，我可以使用模板字符串，将静态基本值替换为动态值，访问`from`和`then`函数。我们将快速使用`then`。我们将在这里使用`then`来操纵值。这将返回Axios的承诺，并提供有关HTTP请求的大量信息。`getExchangeRate`的调用者不关心这一点。他们甚至不应该知道已经发出了HTTP请求。他们需要的只是一个数字，这正是我们将给他们的。
- en: 'In the `then` callback, we''re going to have access to `response`, and on the
    `response` we''re going to be able to get that currency code. We''re going to
    `return response.data`. This gets us into the JSON object. Now, in here we have
    a `rates` object, which is key-value pairs, where the key is the currency, so
    we do want to access `rates` and we want to get the rate for whatever the `to`
    variable is:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`then`回调中，我们将可以访问`response`，并且在`response`上，我们将能够获取该货币代码。我们将`return response.data`。这将使我们进入JSON对象。现在，在这里我们有一个`rates`对象，其中包含键值对，其中键是货币，因此我们确实要访问`rates`并获取`to`变量的汇率：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'So, in this case, we would have USD to Canadian dollars. We would call this
    URL with `USD` and we would get this value back: `1.2889`. That is the exact value
    that we''re going to return. Let''s go ahead and test this out down below, `getExchangeRate`.
    I''m going to pass in `USD` to `CAD` (Canadian) dollars, `then` we''ll get our
    `rate` back and we can log it out, `console.log(rate)`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，我们将有美元兑加拿大元。我们将使用`USD`调用此URL，然后我们将得到这个值：`1.2889`。这正是我们要返回的确切值。让我们在下面测试一下，`getExchangeRate`。我将把`USD`传递给`CAD`（加拿大）元，然后我们将得到我们的`rate`并将其记录下来，`console.log(rate)`：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'I''m going to go ahead and save this. In the background, inside the Terminal,
    we can start up `nodemon` once again, and we''re going to run the `currency-convert`
    file. Right here, we get that value `1.2889` is the current currency exchange
    rate:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续保存这个。在后台，在终端中，我们可以再次启动`nodemon`，然后运行`currency-convert`文件。在这里，我们得到了值`1.2889`是当前的货币汇率：
- en: '![](img/3baa5fea-f353-4913-8903-d22186ac6841.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3baa5fea-f353-4913-8903-d22186ac6841.png)'
- en: 'I could put `EUR` in code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在代码中放入`EUR`：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'I could figure out what the Euro exchange rate is `0.80574`, so there we go:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以弄清楚欧元的汇率是`0.80574`，所以我们可以：
- en: '![](img/76ee4c08-faa0-425b-a58d-d08e4266ab0d.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76ee4c08-faa0-425b-a58d-d08e4266ab0d.png)'
- en: We got our first one all knocked out. Now, the other one that we're going to
    create real quick is going to be `getCountries`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了第一个。现在，我们要快速创建的另一个是`getCountries`。
- en: The getCountries function
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getCountries`函数'
- en: 'The `getCountries`  function is going to get a list of countries, just their
    names, and we''re going to get it by `currencyCode`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCountries`函数将获取一个国家列表，只包括它们的名称，并且我们将通过`currencyCode`来获取它：'
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This one, just like `getExchangeRate`, is also going to return a promise from
    `axios.get` and the URL we want to get lives over in the browser:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个，就像`getExchangeRate`一样，也将从`axios.get`返回一个promise，我们要获取的URL位于浏览器中：
- en: '![](img/f40d00e9-2900-41b0-b991-716d90bfd0a2.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f40d00e9-2900-41b0-b991-716d90bfd0a2.png)'
- en: 'So, right here we have our URL. We have the spot where we''re going to dump
    our `currencyCode`, so we can knock that out. It''s going to be a template string
    and we''re going to get rid of `CAD` and inject whatever the `currencyCode` argument
    is:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里有我们的URL。我们有一个地方可以将我们的`currencyCode`输出，所以我们可以完成这一步。它将是一个模板字符串，我们将去掉`CAD`并注入`currencyCode`参数：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, at this point, once again, we do want to do a little manipulation to the
    data, so I could go ahead and use `then`. In the `then` callback, I can go ahead
    and access the `response`. What I want to do with the `response` is I just want
    to loop over it. I want to figure out all the countries that support my currency
    and then I want to return an array:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，再次，我们确实想对数据进行一些操作，所以我可以继续使用`then`。在`then`回调中，我可以继续访问`response`。我想对`response`做的是，我只想循环遍历它。我想找出所有支持我的货币的国家，然后我想返回一个数组：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now you know that we're going to get all those countries back, right? So, for
    `cad` we have an array with the single object inside it. For `usd`, we have an
    array with multiple objects inside it, so we're going to take this array of objects
    and convert it to an array of string.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道我们将得到所有这些国家，对吧？因此，对于`cad`，我们有一个包含单个对象的数组。对于`usd`，我们有一个包含多个对象的数组，因此我们将把这个对象数组转换为一个字符串数组。
- en: 'We would start off with `American Samoa`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`美属萨摩亚`开始：
- en: '![](img/d9cd2b07-ef23-4441-8c3c-a2b3214be8c2.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9cd2b07-ef23-4441-8c3c-a2b3214be8c2.png)'
- en: 'To do that, we''re just going to use `map`. Back inside Atom, we can go ahead
    and knock this out really quickly by returning `response.data`, which is an array,
    which means it has access to that `map` method. We are then going to use `map`.
    Each individual item is going to be a `country`; each `country` has a `name` property,
    so we can return `country.name`, giving us an array of country names that support
    the `currency`. In this case, we can simplify that by implicitly returning `country.name`.
    Now, let''s go ahead and test that out right here; `getCountries`. We''re going
    to get `countries` back and we''re going to dump `countries` to the screen. We
    only provide a single argument:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用`map`。回到Atom中，我们可以通过返回`response.data`来快速完成这个任务，它是一个数组，这意味着它可以访问`map`方法。然后我们将使用`map`。每个单独的项目将是一个`country`；每个`country`都有一个`name`属性，所以我们可以返回`country.name`，给我们一个支持该`currency`的国家名称数组。在这种情况下，我们可以通过隐式返回`country.name`来简化这个过程。现在，让我们在这里测试一下；`getCountries`。我们将得到`countries`并将其输出到屏幕上。我们只提供一个参数：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'So, if we save this and check things out over in the Terminal, we should see
    exactly what comes back. Here we have a list of all of the countries that we can
    use that currency in, in this case, the US dollar:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们保存并在终端中检查，我们应该看到确切的返回内容。这里有一个我们可以在其中使用该货币的所有国家的列表，在这种情况下是美元：
- en: '![](img/34db21af-227a-4289-81b4-6a01be9772f9.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34db21af-227a-4289-81b4-6a01be9772f9.png)'
- en: 'We could go over to `EUR` to see which countries support that:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以去`EUR`看看哪些国家支持它：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we save the file, we're going to get that list back in just a moment.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存文件，我们将在片刻后得到那个列表。
- en: 'Here we have all the countries that support it, everything from `Belgium` all
    the way down to `Zimbabwe` and `Spain`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有所有支持它的国家，从`比利时`一直到`津巴布韦`和`西班牙`：
- en: '![](img/248390da-7b6c-42b7-bfd0-cfcda4a062e9.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/248390da-7b6c-42b7-bfd0-cfcda4a062e9.png)'
- en: 'All those countries are included. Next up, is CAD:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些国家都包括在内。接下来是CAD：
- en: '[PRE68]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You should just have that one, Canada, and it does indeed show up right there:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只有一个，加拿大，它确实显示在那里：
- en: '![](img/d6354192-c490-48bb-bf34-ee1388d7a068.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6354192-c490-48bb-bf34-ee1388d7a068.png)'
- en: So, at this point, we have all the data we need to actually get things done.
    So, together we're going to build the equivalent of this function over in our
    promises and you're going to be building out the `async` one.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此时我们已经有了实际完成任务所需的所有数据。因此，我们将一起在我们的promises中构建这个函数的等价物，而你将构建`async`的函数。
- en: 'Over here, let''s go ahead and get started: `const convertCurrency`. That is
    going to be the function we''ll be building. It''s the one that you''ll eventually
    make `async` but, for now, we''ll leave it as a regular arrow function (`=>`).
    We''re going to get the currency code that we''re converting `from` the one we''re
    converting `to`, and the amount we''re looking to convert.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，让我们开始吧：`const convertCurrency`。这将是我们要构建的函数。这是您最终将使`async`的函数，但是现在，我们将其保留为常规箭头函数（`=>`）。我们将获取我们要转换的货币代码`from`和`to`，以及我们要转换的金额。
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Inside here, we can kick things off by getting those countries. I''m going
    to `return getCountries`. I''m going to call that with the currency that we''re
    converting to, then we can tack on `then` and we are going to get the `countries`
    list back. Next up, we''re going to return a call to `getExchangeRates` - passing
    in `from` and `to`, and we''re going to get that back as a promise as well, which
    means we can tack on another `then` call. Here we''re going to get that rate:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过获取这些国家来开始。我将返回`getCountries`。我将用我们要转换的货币调用它，然后我们可以添加`then`，然后我们将得到`countries`列表。接下来，我们将返回一个调用`getExchangeRates`
    - 传入`from`和`to`，我们也将得到一个承诺，这意味着我们可以添加另一个`then`调用。在这里，我们将得到那个汇率：
- en: '[PRE70]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, inside the `then` callback, we can go ahead and actually calculate all
    the stuff we're going to calculate. In this case, we're going to generate that
    long string I was talking about.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`then`回调中，我们可以继续计算我们要计算的所有内容。在这种情况下，我们将生成我所说的那个长字符串。
- en: Let's first start off by creating a `const`; this const will be called `exchangedAmount`.
    All we're going to do is take the `amount` the user passed in and multiply it
    by the exchange `rate`; so, in this case, we would successfully convert US dollars
    from Canadian dollars. Now, down below, we can go ahead and start working on that
    string. We're going to `return` a template string and, inside here, we're going
    to do quite a few things.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个`const`；这个常量将被称为`exchangedAmount`。我们要做的就是取用户传入的`amount`并乘以汇率；所以，在这种情况下，我们成功地将美元从加拿大元转换过来。现在，在下面，我们可以开始处理那个字符串。我们将返回一个模板字符串，在这里，我们将做很多事情。
- en: 'So, first off, we''re going to start off with the `amount`. The `amount` in
    the currency you''re coming `from` is `worth`. Then we''re going to put the `amount`
    in the currency you''re going to, it''s `exchangedAmount`. Then we''ll toss in
    `to`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`amount`开始。`from`货币中的`amount`是`worth`。然后我们将把`amount`放在你要去的货币中，它是`exchangedAmount`。然后我们将加上`to`：
- en: '[PRE71]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'So, this is part one. We can actually go ahead and test this out before even
    moving on. Next, I''m going to switch the `getCountries` call over to a `convertCurrency`
    call. We''re going to go ahead and convert Canadian dollars over to US Dollars.
    Let''s go ahead and convert a hundred of those. Now we''re going to get the `status`
    back, as opposed to actually getting back the countries list:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一部分。我们实际上可以在继续之前测试一下。接下来，我要将`getCountries`调用切换到`convertCurrency`调用。我们将把加拿大元转换成美元。让我们转换一百个。现在我们将得到`status`，而不是实际得到国家列表：
- en: '[PRE72]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can go ahead and save currency-convert and see what happens over inside
    the Terminal. Over here, we get `100 CAD is worth 73.947 USD`, and this is a great
    first step:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存currency-convert并查看在终端中发生了什么。在这里，我们得到`100 CAD值73.947 USD`，这是一个很好的第一步。
- en: '![](img/a374ceff-7e82-4451-92c5-f13ebe93efef.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a374ceff-7e82-4451-92c5-f13ebe93efef.png)'
- en: 'Now, we''re also going to tack on that country''s list, which we do not have
    access to in this function. We can go through the same step we used last time.
    We''ll create `tempCountries`. Up above, we can make a new variable called countries
    and we''ll set countries equal to `tempCountries` like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还将添加那个国家列表，这在这个函数中我们无法访问。我们可以通过上次使用的相同步骤。我们将创建`tempCountries`。在上面，我们可以创建一个名为countries的新变量，并将countries设置为`tempCountries`，就像这样：
- en: '[PRE73]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now we'll be able to access those countries and do something with them. What
    are we going to do? We're just going to join them all together, separated by a
    comma, to create that nice list. That'll be the currency that we're talking about.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将能够访问这些国家并对它们进行操作。我们要做什么？我们只是将它们全部连接在一起，用逗号分隔，创建一个漂亮的列表。那将是我们谈论的货币。
- en: 'Then, we''ll add a colon and then we will interpolate the following. So, we''re
    going to take all those countries, we''re going to take that array, and we''re
    going to convert it over to a string using `join`. What do we want to put between
    all of them? We''re going to put a comma and a space, we''re going to create a
    comma separated list of countries that that currency can be used in:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个冒号，然后我们将插入以下内容。所以，我们将获取所有这些国家，我们将获取那个数组，然后我们将使用`join`将其转换为字符串。我们想在它们之间放什么？我们将放一个逗号和一个空格，我们将创建一个逗号分隔的国家列表，该货币可以在其中使用：
- en: '[PRE74]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we can go ahead and save currency- convert and see what happens over inside
    `nodemon` when things restart, `100 CAD is worth 73 USD. USD can be used in the
    following countries`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存currency-convert并查看在`nodemon`重新启动时发生了什么，`100 CAD值73 USD。USD可以在以下国家使用`：
- en: '![](img/9c0d7eb8-59cd-4525-ada1-17035f8265ce.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c0d7eb8-59cd-4525-ada1-17035f8265ce.png)'
- en: 'Then we have a list of all the countries we can use it in. Let''s go ahead
    and test out a different variation. Let''s go ahead and switch US dollars over
    to Canadian dollars:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个我们可以在其中使用的所有国家的列表。让我们继续测试一个不同的变体。让我们将美元换成加拿大元：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This time around, we''re going to get a different output as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将得到以下不同的输出：
- en: '![](img/6b2b831d-12f4-4ef7-a3d5-41b422e32711.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b2b831d-12f4-4ef7-a3d5-41b422e32711.png)'
- en: The Canadian dollar can be used in the following countries, in this case, just
    `Canada`. Everything is working as expected. The problem is we're using promise
    chaining in order to get everything done. We need to use the `async` function
    instead of that.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，加拿大元可以在以下国家使用，这种情况下只有`Canada`。一切都按预期运行。问题在于我们使用promise chaining来完成所有工作。我们需要使用`async`函数而不是那样。
- en: Creating convertCurrencyAlt as the async/await function
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建convertCurrencyAlt作为async/await函数
- en: 'We are going to convert this over to async/await, and you''re going to do that
    right here at the end of `convertCurrency` function. We''re going to use `Create
    convertCurrencyAlt as async function`. So, just like we did over inside of app-promises,
    you''re going to create an `async` function. Then you''re going to fetch both
    pieces of data using `await`: `Get countries and rate using await and our two
    functions`. So, you''re going to `await` both of these promises and then you''re
    going to store that value in some variable. You can create a country''s variable
    and a `rate` variable. Finally, you''ll be able to take these two lines and just
    tack those on at the end:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个转换成async/await，并且你将在`convertCurrency`函数的末尾完成这个过程。我们将使用`创建convertCurrencyAlt作为async函数`。所以，就像我们在app-promises中所做的那样，你将创建一个`async`函数。然后你将使用`await`获取两个数据片段：`使用await获取国家和汇率以及我们的两个函数`。所以，你将等待这两个promise，然后将该值存储在某个变量中。你可以创建一个国家变量和一个`rate`变量。最后，你将能够将这两行代码添加到最后：
- en: '[PRE76]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'That will calculate the `exchangedAmount` and it will return the correct information:
    `Calculate exchangedAmount` and `Return status string`. You have two statements
    to get the data, one to calculate the exchanged amount and the final one to actually
    print things out.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算`exchangedAmount`并返回正确的信息：`计算exchangedAmount`和`返回状态字符串`。你有两个语句来获取数据，一个用来计算交换金额，最后一个用来实际打印出来。
- en: 'We''re going to go ahead and kick things off by creating that `const convertCurrencyAlt`.
    This one is going to be an `async` function, so we have to mark it as such. We
    can then move on to our arguments list, which is exactly the same as the other
    one: `from`, `to`, and `amount`. Then we''re going to put the arrow and arrow
    function (`=>`), and we''re going to open and close our curly braces.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续创建`const convertCurrencyAlt`。这将是一个`async`函数，所以我们必须标记它。然后我们可以继续我们的参数列表，与另一个函数完全相同：`from`，`to`和`amount`。然后我们将放置箭头和箭头函数（`=>`），然后打开和关闭大括号。
- en: '[PRE77]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now we can move on to the first thing, which is getting the countries and getting
    the exchange rate. I''m going to start off with countries; `const countries` equals.
    We are going to `await` the promise that comes back from `getCountries`. What
    countries do we want to get? The ones where the `to` currency is able to be used.
    Then we''re going to move on down below to rate. So, `const rate`. In this case,
    we are also trying to `await` something; we''re trying to `await` the promise
    that comes back from `getExchangeRate`. We''re trying to get the exchange rate,
    right here, `from` and `to`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行第一步，即获取国家和获取汇率。我将从国家开始；`const countries`等于。我们将等待从`getCountries`返回的promise。我们想要获取哪些国家？那些可以使用`to`货币的国家。然后我们将继续获取汇率。所以，`const
    rate`。在这种情况下，我们也要尝试`await`一些东西；我们要等待从`getExchangeRate`返回的promise。我们要在这里获取汇率，`from`和`to`：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'So, at this point, we have all that data and we can move on to calculating
    the exchanged amount and returning the string. We already built that out, there''s
    no need to recreate it. We can just copy both of those lines, paste them down
    below, and there we go. Everything is done:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，此时，我们已经有了所有的数据，我们可以继续计算交换金额并返回字符串。我们已经构建好了，没有必要重新创建。我们可以复制这两行代码，粘贴到下面，然后就完成了。一切都完成了：
- en: '[PRE79]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now, down below, instead of calling `convertCurrency`, we're able to call `convertCurrencyAlt`,
    passing in the exact same arguments and getting back the status.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下面，我们可以调用`convertCurrencyAlt`，而不是调用`convertCurrency`，传入完全相同的参数并返回状态。
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The difference is that our function is using `async`; a whole lot more readable,
    much easier to work with. We''re going to go ahead and save currency-convert.
    That is going to run through the process of getting all of that data, converting
    it and then we''re going to go ahead and print the status. What do we get at the
    end of the day? Over here, we get the exact same thing as shown in output here:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于我们的函数使用`async`；更易读，更容易使用。我们将继续保存currency-convert。这将运行整个过程，获取所有数据，转换它，然后我们将打印状态。最终我们得到什么？在这里，我们得到与输出中显示的完全相同的东西：
- en: '![](img/f4080d79-100c-4234-8b4b-c895dc865f65.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4080d79-100c-4234-8b4b-c895dc865f65.png)'
- en: In the next section, we're going to talk about a few other places we can use
    `async` in this example, and we're also going to talk about how we can work with
    and handle errors.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论在这个示例中可以使用`async`的其他一些地方，并且我们还将讨论如何处理和处理错误。
- en: Handling errors and awaiting async function
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误和等待async函数
- en: We're going to kick this section off by converting both `getExchangeRate` and
    `getCountries` over to `async` functions. They're good candidates because we do
    have promises and we could just await those promises instead. Then we're going
    to talk about errors, how we can throw them and how we can customize errors that
    get thrown by other code. It's going to make it really useful and it'll make it
    a lot easier to actually use `async`/`await` in the real world where you do need
    to handle errors.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将`getExchangeRate`和`getCountries`转换为`async`函数。它们是很好的候选者，因为我们有promise，我们可以等待这些promise。然后我们将讨论错误，我们如何抛出错误以及如何自定义其他代码抛出的错误。这将使它非常有用，并且在实际需要处理错误的现实世界中，使用`async`/`await`会更容易。
- en: Converting getExchangeRate and getCountries into the async function
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将getExchangeRate和getCountries转换为async函数
- en: 'So the first thing we''re going to do is convert `getExchangeRate` and `getCountries`.
    The first step I''m going to take is to make this an `async` function, otherwise
    we can''t use `await`. Then we''re going to go ahead and set up a variable, a `const` response,
    and we are going to set this equal to `await`. Then we''re going to await the
    following promise, the one that comes back from `axios.get`. I''m going to copy
    it, paste it, toss a semicolon at the end, and the only thing left to do is to
    return the value. I''m going to take the `return` statement and move it right
    there, then we can remove all of the previous code we had:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要做的第一件事是转换`getExchangeRate`和`getCountries`。我要采取的第一步是将其转换为`async`函数，否则我们无法使用`await`。然后我们将继续设置一个变量，一个`const`
    response，并将其设置为`await`。然后我们将等待以下承诺，来自`axios.get`返回的承诺。我将复制它，粘贴它，末尾加上一个分号，唯一剩下的事情就是返回这个值。我将取出`return`语句，移动到那里，然后我们可以删除之前的所有代码：
- en: '[PRE81]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We now have the exact same functionality and it''s a little bit nicer. Now,
    the benefit isn''t as drastic as the benefit from going to `convertCurrency` to `convertCurrencyAlt`,
    but it is still indeed nice and I''d recommend using `async` anywhere you can.
    Now we need to convert `getCountries` using the exact same steps we just followed:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有完全相同的功能，而且更好一些。现在，好处并不像从`convertCurrency`到`convertCurrencyAlt`那样显著，但确实很好，我建议您尽可能使用`async`。现在我们需要使用刚刚遵循的相同步骤来转换`getCountries`：
- en: 'Mark `currencyCode` one as `async`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`currencyCode`标记为`async`：
- en: '[PRE82]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create that `response` variable and actually awaiting on the promise. We''re
    going to await the following promise:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`response`变量并实际等待承诺。我们将等待以下承诺：
- en: '[PRE83]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The last step is to just `return` the exact same thing. There we go:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步就是返回完全相同的东西。就是这样：
- en: '[PRE84]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now that we have both of these converted, we're just going to test our work
    by saving the file and, as long as we get the exact same output, we'll move on
    to talking about errors; how it could catch them, how we can throw them, and how,
    in general, we can improve the errors that show up in our application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这两个都转换了，我们只需通过保存文件来测试我们的工作，只要我们得到完全相同的输出，我们就会继续讨论错误；如何捕捉它们，如何抛出它们，以及一般来说，我们如何改进出现在我们应用程序中的错误。
- en: 'Alright, the new result just showed up:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，新的结果刚刚出现：
- en: '![](img/2f42f941-2149-465f-91e3-41459ffc071e.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f42f941-2149-465f-91e3-41459ffc071e.png)'
- en: It is identical to the other two, which means that we are good to go. Now, I'd
    like to shift the discussion over to errors.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他两个是相同的，这意味着我们可以继续进行。现在，我想把讨论转移到错误上。
- en: Error handling in the async function
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数中的错误处理
- en: What we're going to do is get the endpoints to trigger errors. We're going to
    look at how exactly we can handle those endpoints and how we can tweak them to
    be something that's a little more useful, because currently we're going to get
    back just a whole bunch of junk.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是让端点触发错误。我们将看看我们如何处理这些端点，以及如何调整它们成为更有用的东西，因为目前我们将得到一大堆垃圾。
- en: Printing an error to the screen
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将错误打印到屏幕上
- en: 'Step one is to actually print the error out to the screen so we can see what
    we''re working with. We''re going to `catch` the error and we''re going to print
    the error, `console.log(e)`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是实际上将错误打印到屏幕上，这样我们就可以看到我们正在处理的是什么。我们将`catch`错误，并打印错误，`console.log(e)`：
- en: '[PRE85]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now let's go ahead and start making some things fail. We're going to kick things
    off by making `getCountries` fail; that's the first call.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始让一些东西失败。我们将通过使`getCountries`失败来开始；那是第一个调用。
- en: 'Now, this one only uses `to`, so all we have to do to get that to fail is to
    send in a bad to `countryCode`. I''m going to use `MMM`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个只使用了`to`，所以我们要做的就是让它失败，发送一个错误的`countryCode`。我将使用`MMM`：
- en: '[PRE86]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Save the file and we''ll see what we get over inside the browser. Now what
    we''re going to get back is a whole bunch of junk:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，我们将看到在浏览器中得到什么。现在我们将得到一大堆垃圾：
- en: '![](img/91ec9cbc-23ec-4cf2-bcd0-c03c5bf778cd.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91ec9cbc-23ec-4cf2-bcd0-c03c5bf778cd.png)'
- en: What's coming back here is actually the `axios` response. This has the error
    information; it has things like that status code. You can see it was a 404\. We
    have a message saying not found. This is letting us know that `countryCode` we
    provided was not found by that endpoint. Now this is not particularly useful.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里返回的实际上是`axios`的响应。这里有错误信息；它有状态码之类的东西。你可以看到它是404。我们有一条消息说未找到。这让我们知道我们提供的`countryCode`没有被该端点找到。现在这并不特别有用。
- en: 'We want to come up with something that is a little more useful, like a message:
    `Unable to get countries that use MMM`. That''d be great. So, to do that, we''re
    going to tweak `getCountries`. We''re going to go ahead and use a regular old `try
    catch` block and set it up like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要得到一些更有用的东西，比如一条消息：`无法获取使用MMM的国家`。那将很好。所以，为了做到这一点，我们将调整`getCountries`。我们将继续使用一个普通的`try
    catch`块，并设置如下：
- en: '[PRE87]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If the code in the `try` block throws an error, the `catch` block will run,
    otherwise `catch` will never run. All we''re going to do is take `const response` and `return
    statement` code and move it inside of `try`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`try`块中的代码引发错误，`catch`块将运行，否则`catch`将永远不会运行。我们要做的就是取`const response`和`return
    statement`代码，并将其移动到`try`内部：
- en: '[PRE88]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'So, what we''re doing is saying anytime either of these lines throw an error,
    run the code in the `catch` block and provide the error. Now we know what the
    error is. It doesn''t contain much of anything, so what we''re going to do is
    just throw our own error; something that is human-readable: `throw new Error`.
    In this case, we''re going to stick with a template string and we''re going to
    go ahead and set it up: `Unable to get countries that use`. Then we''ll inject,
    right before the period, the `currencyCode`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的意思是，每当这两行中的任何一行引发错误时，运行`catch`块中的代码并提供错误。现在我们知道错误是什么。它并不包含太多东西，所以我们要做的就是抛出我们自己的错误；一些人类可读的东西：`throw
    new Error`。在这种情况下，我们将坚持使用模板字符串，并且我们将继续设置它：`无法获取使用的国家`。然后我们将在句号之前注入`currencyCode`：
- en: '[PRE89]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, if we go ahead and save the currency-convert application with a bad to `countryCode`,
    we're going to see `Unable to get countries that use MMM` as the error. We could
    access the message directly using `e.message`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用错误的`countryCode`保存currency-convert应用程序，我们将看到错误`无法获取使用MMM的国家`。我们可以直接使用`e.message`访问消息。
- en: '[PRE90]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: That'll improve the output even more. Now we just have a string. We could do
    anything we want with that string. It's very clear: `Unable to get the countries
    that use MMM`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这将进一步改善输出。现在我们只有一个字符串。我们可以对该字符串做任何我们想做的事情。非常清楚：`无法获取使用MMM的国家`。
- en: Error handling for the getExchangeRate function
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: getExchangeRate函数的错误处理
- en: Now, let's go ahead and look at the next one in our list, that is, the `getExchangeRate` function.
    There are actually two things that can go wrong here; the `axios` request can
    fail itself and we could also end up with a response that's valid, but the `to` status
    code is invalid. In that case, there would be no rate for it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看我们列表中的下一个，即`getExchangeRate`函数。这里实际上有两件事情可能出错；`axios`请求本身可能会失败，我们也可能得到一个有效的响应，但`to`状态码无效。在这种情况下，就不会有汇率。
- en: 'Now we can go ahead and actually simulate this by commenting out a few lines
    of code that''s going to allow us to test to `getExchangeRate` in isolation:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过注释掉一些代码行来实际模拟这一点，这将允许我们测试`getExchangeRate`的隔离：
- en: '[PRE91]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, if I go ahead and mess the `USD` with `QWE`, we can save the file and
    we are going to get another error request failed with status code 422:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我将`USD`弄乱成`QWE`，我们可以保存文件，然后会得到另一个错误请求失败，状态码为422：
- en: '![](img/53166ba5-3402-4671-beba-504da35aa544.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53166ba5-3402-4671-beba-504da35aa544.png)'
- en: 'What we''re going to do again is go through that exact same process. So, we''re
    going to wrap those two lines in a `try catch` block. Then, if `catch` runs, you''re
    going to throw a new error using the following format: `Unable to get exchange
    rate for USD and CAD`. This is going to be the `from` USD currency code to CAD
    currency code. We''re going to kick things off by setting up that `try catch` block.
    We are going to try to run the following code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是再次进行完全相同的过程。所以，我们将这两行代码放在`try catch`块中。然后，如果`catch`运行，你将使用以下格式抛出一个新的错误：`无法获取USD和CAD的汇率`。这将是从USD货币代码到CAD货币代码。我们将通过设置`try
    catch`块来启动这些事情。我们将尝试运行以下代码：
- en: '[PRE92]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If it runs that would be very nice but, if it doesn''t, we do want to handle
    that as well by throwing a new error. Inside the `catch` block, we are going to
    provide our message; it''ll just be a template string. Now, the message I want
    to provide is `Unable to get exchange rate for ${from} and ${to}`, followed by
    a period:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它运行将会非常好，但是如果没有，我们也希望通过抛出新的错误来处理。在`catch`块内，我们将提供我们的消息；它将只是一个模板字符串。现在，我想提供的消息是`无法获取${from}和${to}的汇率`，后面跟一个句号：
- en: '[PRE93]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now we can go ahead and save this and see what happens over inside the browser:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存这个并查看浏览器中发生了什么：
- en: '![](img/37665d81-2f4a-42f7-91a6-49cb6dc77311.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37665d81-2f4a-42f7-91a6-49cb6dc77311.png)'
- en: 'We get `Unable to get exchange rate for QWE and MMM`. Now currently that''s
    failing because `from` is invalid, but what if `from` is valid? What if we''re
    trying to go to `USD` to `MMM`? This time around we are actually going to get
    something different:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到`无法获取QWE和MMM的汇率`。现在目前失败是因为`from`无效，但是如果`from`有效呢？如果我们试图从`USD`到`MMM`？这一次我们将得到不同的东西：
- en: '![](img/639973a0-e857-4d02-b0f8-178c197411ce.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/639973a0-e857-4d02-b0f8-178c197411ce.png)'
- en: Here we just get `undefined`. It comes up because the `return` statement in `getExchangeRate` has `response.data.rates`. We
    have a valid `from countryCode` so valid data comes back, but the `to countryCode` does
    not exist, which is where undefined comes from.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们只得到`undefined`。这是因为`getExchangeRate`中的`return`语句有`response.data.rates`。我们有一个有效的`from
    countryCode`，所以返回有效数据，但`to countryCode`不存在，这就是undefined的来源。
- en: 'We can always go ahead and fix that by creating a variable `const rate`, and
    we''ll set it equal to `response.data.rates[to]`. Then, well, a little bit of `if` logic.
    If there is `rate`, we''re just going to go ahead and return it. If there''s no `rate`,
    we''re just going to go ahead and `throw` a new error, which will trigger the `catch` block,
    which will print the message to the screen:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个变量`const rate`来修复这个问题，并将其设置为`response.data.rates[to]`。然后，一点点的`if`逻辑。如果有`rate`，我们将继续返回它。如果没有`rate`，我们将继续`throw`一个新的错误，这将触发`catch`块，将消息打印到屏幕上：
- en: '[PRE94]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, if we save the code using these same codes, we get the message once again: `Unable
    to get the exchange rate for USD and MMM`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用相同的代码保存代码，我们再次收到消息：`无法获取USD和MMM的汇率`：
- en: '![](img/d0f4490f-2302-4e77-a61b-826dfe13753d.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0f4490f-2302-4e77-a61b-826dfe13753d.png)'
- en: Now this message is going to show up if `from` is invalid, if `to` is invalid,
    or if both are invalid.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`from`无效，如果`to`无效，或者两者都无效，这条消息将显示出来。
- en: 'With that in place, we now have some little error handling set up and we can
    bring back the rest of the lines from our application. If we run through the app
    using this bad data here, `Unable to get countries that use MMM` prints:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了一些小的错误处理，并且可以将应用程序的其余部分重新引入。如果我们使用这里的错误数据运行应用程序，将打印`无法获取使用MMM的国家`：
- en: '![](img/7e232781-0bbe-4eb2-a64f-d7fdca377911.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e232781-0bbe-4eb2-a64f-d7fdca377911.png)'
- en: 'Let''s switch it back over to valid country codes like `USD` and `CAD`. Let''s
    actually use the Euro, `EUR`, for a change and over inside the browser we should
    get valid values, since both of those country codes are indeed valid:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换回到有效的国家代码，比如`USD`和`CAD`。让我们实际上使用欧元`EUR`来进行一些改变，在浏览器中，我们应该得到有效的值，因为这两个国家代码确实是有效的：
- en: '![](img/19bc552f-7419-43a7-8400-37a54cd4ce27.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19bc552f-7419-43a7-8400-37a54cd4ce27.png)'
- en: Here we get the exchange rate, we get all of the countries that use the Euro,
    we aren't getting any of our error messages, which is fantastic. So by using regular
    techniques, things from way back in JavaScript, like `try`, `catch`, and `throw`
    new error, we're able to create a very nice setup using those `async` functions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了汇率，我们得到了所有使用欧元的国家，我们没有得到任何错误消息，这太棒了。因此，通过使用常规技术，例如JavaScript中的`try`、`catch`和`throw`新错误，我们能够使用这些`async`函数创建一个非常好的设置。
- en: 'That is it for this section, and that is it for our little currency-convert
    example. So, at this point, we''ve gone through two examples: we went through
    the app promises example, where we had a contrived set of data; we created a few
    functions and we got to explore the basics of `async`/`await`. Then we went through
    the currency- convert example, where we used two real APIs and we added a little
    more robust error handling. At the end of the day, they''ll both use the exact
    same `async` and `await` techniques. Hopefully, you''re starting to see how this
    can fit into our Node applications. In the next and final section, we''re actually
    going to use `async` and `await` to make some changes to the Node API.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节的全部内容，也是我们小小的货币转换示例的全部内容。因此，到目前为止，我们已经经历了两个示例：我们经历了应用承诺示例，其中我们有一组人为设置的数据；我们创建了一些函数，并且了解了`async`/`await`的基础知识。然后我们经历了货币转换示例，我们在其中使用了两个真实的API，并且增加了更健壮的错误处理。归根结底，它们都将使用完全相同的`async`和`await`技术。希望您开始看到这如何适用于我们的Node应用程序。在下一节，也是最后一节中，我们实际上将使用`async`和`await`对Node
    API进行一些更改。
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked into a new syntax `async`/`await`. We looked into
    project setup, basics of `async`/`await`, and a real-world example. We also looked
    into error handling using `async`/`await`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了一个新的语法`async`/`await`。我们研究了项目设置、`async`/`await`的基础知识和一个真实的示例。我们还研究了使用`async`/`await`进行错误处理。
