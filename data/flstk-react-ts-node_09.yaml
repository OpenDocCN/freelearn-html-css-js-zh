- en: '*Chapter 7*: Learning Redux and React Router'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：学习Redux和React Router'
- en: In this chapter, we'll learn about Redux and React Router. Redux is still the
    most common method of managing global state shared across a React application.
    Using Redux global state, we can reduce a great deal of boilerplate code and streamline
    the application. React Router is also the most popular framework for managing
    client-side URL routing. Client-side URL routing allows a SPA application to behave
    in ways that are familiar to users expecting a classic-style web application that
    indicates where they are in the app. Both of these technologies are necessary
    for building SPA applications that look and feel like standard web apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Redux和React Router。Redux仍然是管理React应用程序中共享的全局状态的最常见方法。使用Redux全局状态，我们可以减少大量样板代码并简化应用程序。React
    Router也是管理客户端URL路由的最流行框架。客户端URL路由允许SPA应用程序以用户期望的经典样式Web应用程序的方式行为。这两种技术对于构建外观和感觉像标准Web应用程序的SPA应用程序是必不可少的。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Learning about Redux state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Redux状态
- en: Learning about React Router
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习React Router
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should have a basic understanding of web development using React. We will
    once again be using Node and Visual Studio Code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对使用React进行Web开发有基本的了解。我们将再次使用Node和Visual Studio Code。
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap7` folder.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap7`文件夹中的代码。
- en: To set up this chapter's code folder, go to your `HandsOnTypescript` folder
    and create a new folder called `Chap7`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置本章的代码文件夹，请转到您的`HandsOnTypescript`文件夹并创建一个名为`Chap7`的新文件夹。
- en: Learning about Redux state
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Redux状态
- en: Redux is still the most popular enterprise-level framework for creating and
    managing global state in a React application (although we can use Redux in any
    JavaScript app, not just React). Many newer frameworks have been created, and
    some of them have gained their own considerable following; however, Redux is still
    the most commonly used. You may find that Redux is difficult to understand at
    first. However, once we do learn it, we'll see its many benefits and why it is
    so often the go-to framework for large, complex React applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Redux仍然是在React应用程序中创建和管理全局状态的最流行的企业级框架（尽管我们可以在任何JavaScript应用程序中使用Redux，而不仅仅是React）。许多新的框架已经被创建，其中一些已经获得了相当大的追随者；然而，Redux仍然是最常用的。您可能会发现一开始很难理解Redux。然而，一旦我们学会了它，我们将看到它的许多好处，以及为什么它经常成为大型复杂React应用程序的首选框架。
- en: We learned about React state in [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072),
    *Learning Single-Page Application Concepts and How React Enables Them*, and [*Chapter
    5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081), *React Development with Hooks*.
    So, to reiterate, state, or a component's data, is the main driver of all UI changes
    in React. This is the reason why the React framework has the word "react" in its
    name, because it is reacting to these state changes (this is also known as being
    reactive). So, when creating and managing state, we generally want to associate
    local state with the component or the component's root parent most of the time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072)中学习了React状态，*学习单页应用程序概念以及React如何实现它们*，以及[*第5章*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)，*使用Hooks进行React开发*。因此，再次强调，状态或组件的数据是React中所有UI更改的主要驱动程序。这就是为什么React框架的名称中有"react"一词的原因，因为它对这些状态变化做出反应（这也被称为响应式）。因此，在创建和管理状态时，我们通常希望大部分时间将本地状态与组件或组件的根父级关联起来。
- en: Component-based state can be limiting. There are cases where state is not specific
    to a component or even to a component hierarchy. State can sometimes be necessary
    for several components or other non-component services that make up an application.
    In addition to this, state in React is passed down only one way, from the parent
    down to children as props. It should not be done upstream. And this further constrains
    how state can be used in React. Redux therefore provides a mechanism not only
    to share state globally but also to allow injection and updating of state from
    any component as needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的状态可能有限。有些情况下，状态不仅适用于一个组件，甚至不适用于组件层次结构。状态有时可能对多个组件或构成应用程序的其他非组件服务是必要的。除此之外，在React中，状态只能单向传递，从父级向子级传递作为props。不应该向上游传递。这进一步限制了React中状态的使用。因此，Redux不仅提供了一种在全局共享状态的机制，还允许根据需要从任何组件注入和更新状态。
- en: Let's give an example to flesh this out a bit. In a typical enterprise-class
    application, we will always have authentication. And once a user is authenticated,
    we may receive certain data about the user – for example, the user's full name,
    user ID, email, and so on. It should not seem unreasonable to think that these
    data points may be used by a significant portion of the components within an application.
    It would be tedious and error-prone therefore to have each component call to get
    this data and then save it locally in their own state. Doing it this way would
    mean that there were multiple copies of the data and as it changed, some components
    may end up keeping older versions of the data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来详细说明一下。在典型的企业级应用程序中，我们总是会有身份验证。一旦用户经过身份验证，我们可能会收到关于用户的某些数据 - 例如，用户的全名、用户ID、电子邮件等。因此，认为这些数据点可能被应用程序中的大部分组件使用并不是不合理的。因此，让每个组件调用以获取这些数据，然后在它们自己的状态中保存它，这样做将是乏味且容易出错的。这样做意味着数据会有多个副本，并且随着数据的更改，一些组件可能会保留旧版本的数据。
- en: This sort of conflict can be the source of bugs. Therefore, it would be helpful
    to be able to maintain this data on the client in only one place and share it
    with whatever component needed it. This way, if this data ever did get updated,
    we could be assured that all components, no matter what section of the app they
    are in, would get the latest valid data. This is what Redux can do for our application.
    We can consider it a **single source of truth**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种冲突可能是bug的来源。因此，能够在客户端的一个地方维护这些数据并与需要它的任何组件共享将是有帮助的。这样，如果这些数据有更新，我们可以确保所有组件，无论在应用程序的哪个部分，都能获得最新的有效数据。这就是Redux可以为我们的应用程序做的事情。我们可以把它看作是**唯一的真相源**。
- en: Redux is a data storage service that maintains all the globally shared data
    in our React application. Redux provides not only the store itself, but also the
    base functions needed to add, remove, and share this data. One difference with
    React state, however, is that Redux state is not necessarily going to trigger
    UI updates. It certainly can if we desire to do so, but there is no explicit necessity
    for doing so. So, we should keep that in mind.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个数据存储服务，它在我们的React应用程序中维护所有全局共享的数据。Redux不仅提供存储本身，还提供了添加、删除和共享这些数据所需的基本功能。然而，与React状态的一个不同之处是，Redux状态不一定会触发UI更新。如果我们希望这样做，它当然可以，但并不一定需要这样做。因此，我们应该记住这一点。
- en: 'Let''s take a look at how to set up Redux:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何设置Redux：
- en: 'Create a new React project in the `Chap7` folder like this:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chap7`文件夹中创建一个新的React项目，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once our project is set up, open it and use your command line to `cd` into the
    `redux-sample` folder.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的项目设置好了，打开它并使用命令行`cd`到`redux-sample`文件夹。
- en: 'We will now install Redux, which is actually several different dependencies.
    First, run this command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将安装Redux，实际上是几个不同的依赖项。首先，运行这个命令：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command gives us the main dependencies, including the TypeScript types.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令给我们主要的依赖项，包括TypeScript类型。
- en: OK, now that we've done some basic setup, we need to understand a few more things
    about Redux before we continue. Redux uses a pair of concepts called reducers
    and actions. Let's see what each of these does.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经完成了一些基本设置，我们需要在继续之前了解一些关于Redux的更多内容。Redux使用了一对叫做reducers和actions的概念。让我们看看它们各自的作用。
- en: Reducers and actions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reducers和actions
- en: In Redux, there is only a single store for all data. So, all our global data
    will live inside of a single Redux object. Now, the issue with this design is
    that, since this is global state, different app features will require different
    types of data and the entirety of the data is not always relevant to all parts
    of the application. So, the Redux creators came up with a scheme that uses reducers
    to filter and split up the single store into separated chunks. So, if component
    A only needs a specific piece of data, it does not have to deal with the entire
    store.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux中，所有数据只有一个单一的存储。因此，我们所有的全局数据都将存在于一个Redux对象中。现在，这种设计的问题是，由于这是全局状态，不同的应用程序功能将需要不同类型的数据，而整个数据并不总是与应用程序的所有部分相关。因此，Redux的创建者提出了一种方案，使用reducers来过滤和拆分单一存储为分离的块。因此，如果组件A只需要特定的数据片段，它就不必处理整个存储。
- en: This design is a good way of separating data concerns. But the side effect of
    having such a design is that we need some way of updating the relevant portion
    of data without affecting any of the other pieces. This is what actions do. Actions
    are objects that provide the data for specific reducers only.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计是分离数据关注点的好方法。但这种设计的副作用是，我们需要一种更新相关数据部分而不影响其他部分的方法。这就是actions的作用。Actions是提供特定reducer数据的对象。
- en: 'Now that we have a high-level view of what reducers and actions are, let''s
    look at some examples in code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对reducers和actions有了一个高层次的了解，让我们在代码中看一些例子：
- en: Create a new folder called `store` under `src`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`下创建一个名为`store`的新文件夹。
- en: 'Then, create a file called `AppState.ts`. This file will store our aggregated
    reducer object called `rootReducer` of type `AppState`, which represents the global
    state. Insert this code into the file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`AppState.ts`的文件。这个文件将存储我们的聚合reducer对象`rootReducer`，类型为`AppState`，它代表了全局状态。将以下代码插入文件中：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`rootReducer` represents an aggregated object of all of our reducers. We don''t
    have any reducers yet, but we will add the actual reducers once our setup is complete.
    `combineReducers` takes each of our reducers and combines them into a single object.
    At the bottom, we are creating a TypeScript type based upon our `rootReducer`
    by using the `ReturnType utility type`, and then exporting the new type called
    `AppState`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`rootReducer`代表了我们所有reducer的聚合对象。我们还没有任何reducer，但是一旦我们的设置完成，我们将添加实际的reducer。`combineReducers`接受我们的每个reducer，并将它们组合成一个单一的对象。在底部，我们使用`ReturnType实用类型`基于我们的`rootReducer`创建了一个TypeScript类型，然后导出了新类型`AppState`。'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A utility type is simply a helper class that the TypeScript team created to
    give specific functionality. There are many different utility types and a list
    can be found here: [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实用类型只是TypeScript团队创建的一个帮助类，用于提供特定功能。有许多不同的实用类型，可以在这里找到列表：[https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)。
- en: 'Next, we create a file called `configureStore.ts`, which will contain our actual
    store object used by Redux and the app. This is what it should look like:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`configureStore.ts`的文件，其中包含了Redux和应用程序使用的实际存储对象。它应该是这样的：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, Redux's `createStore` method is used to build the actual store
    based upon our `AppState` object, `rootReducer`. `configureStore` is exported
    and used later to execute the creation of the store.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Redux的`createStore`方法用于基于我们的`AppState`对象`rootReducer`构建实际的存储。`configureStore`被导出并稍后用于执行存储的创建。
- en: 'Now, we must update our `index.tsx` file to call our `configureStore` method
    and initialize Redux for our app. Update `index.tsx` like this:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须更新我们的`index.tsx`文件，调用我们的`configureStore`方法并为我们的应用程序初始化Redux。像这样更新`index.tsx`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, we import `Provider` from `react-redux`. `Provider` is a React component
    that acts as a parent component to all other components and *provides* our store
    data. In addition, `Provider`, as shown, is receiving the initialized store by
    accepting the return value of the `configureStore` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`react-redux`中导入`Provider`。`Provider`是一个React组件，作为所有其他组件的父组件，并且*提供*我们的存储数据。此外，如所示，`Provider`接收了通过接受`configureStore`函数的返回值来初始化的存储：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This commented code is coming from the `create-react-app` project. It is included
    here for completeness. OK, so now we have a base-level setup of Redux. So, our
    example will continue by creating a call to get a user object. We will use the
    JSONPlaceholder API we learned about in [*Chapter 6*](B15508_06_Final_JC_ePub.xhtml#_idTextAnchor091),
    *Setting Up Our Project Using create-react-app and Testing with Jest*. After a
    successful login, it shares the user information by putting it into Redux as a
    reducer. Let''s do that now:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注释的代码来自`create-react-app`项目。这里包含它是为了完整性。好的，现在我们已经建立了Redux的基本设置。因此，我们的示例将继续通过创建一个调用来获取用户对象。我们将使用我们在[*第6章*](B15508_06_Final_JC_ePub.xhtml#_idTextAnchor091)中学到的JSONPlaceholder
    API，*使用create-react-app设置我们的项目并使用Jest进行测试*。成功登录后，它通过将用户信息放入Redux作为reducer来共享用户信息。现在让我们来做这个：
- en: 'Create a new file, `UserReducer.ts`, inside of the `store` folder, like this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UserReducer.ts`的新文件，放在`store`文件夹中，像这样：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first thing we do is create a constant for the action type called `USER_TYPE`.
    This is optional but helps us avoid issues such as typos:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`USER_TYPE`的action类型的常量。这是可选的，但有助于我们避免诸如拼写错误之类的问题：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we create a type representing our `User`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个表示我们的`User`的类型：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, by convention, an action has two members: type and payload. So, we create
    a `UserAction` type with those members in it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照惯例，一个action有两个成员：类型和有效负载。因此，我们创建了一个`UserAction`类型，其中包含这些成员：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And then, finally, we create our reducer called `UserReducer`. A reducer always
    takes the `state` and `action` parameters. Note, `state` is not the entire state,
    it is only the partial state relevant to some reducer. This reducer will know
    whether the passed-in `state` is its own based on the `action` type. Also notice
    that the original state is never mutated. This is extremely important. *Never*
    change the state directly. You should either return the state as is, which is
    done in `case` `default`, or return some other data. In this case, we return `action.payload`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后，我们创建了名为`UserReducer`的reducer。reducer始终接受`state`和`action`参数。请注意，`state`并不是整个状态，它只是与某个reducer相关的部分状态。这个reducer将根据`action`类型知道传入的`state`是否属于它自己。还要注意，原始状态永远不会被改变。这一点非常重要。绝对不要直接改变状态。你应该要么返回原状态，这在`case`
    `default`中完成，要么返回其他数据。在这种情况下，我们返回`action.payload`。
- en: 'So now, we have to go back into our `AppState.ts` file and add this new reducer.
    The file should now look like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须回到我们的`AppState.ts`文件中，添加这个新的reducer。文件现在应该是这样的：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s start using our new state. Update the `App.tsx` file like this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用我们的新状态。像这样更新`App.tsx`文件：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will take `userid` as a parameter and then, based upon that ID, we will get
    the associated user from the JSON Placeholder API. Now, in order to do this, we
    need to use some Redux-specific Hooks so we can add our found user to the Redux
    store.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以`userid`作为参数，然后根据该ID从JSON Placeholder API中获取关联的用户。为了做到这一点，我们需要使用一些Redux特定的Hooks，这样我们就可以将我们找到的用户添加到Redux存储中。
- en: 'Let''s update the `App` component in `App.tsx` like this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们像这样更新`App`组件中的`App.tsx`：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'const onChangeUserId = onChangeUserId handler, we make a call to the JSONPlaceholder
    API. Then we use the usersResponse response object to get the result from our
    network API. We then get our desired user by filtering with the user ID we got
    from our UI. Then we use dispatch to send our action to our reducer. Also notice
    onChangeUserId is now an async function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`onChangeUserId`处理程序，我们调用JSONPlaceholder API。然后我们使用`usersResponse`响应对象从我们的网络API中获取结果。然后我们通过筛选从UI中获取的用户ID来获取我们想要的用户。然后我们使用dispatch将我们的action发送给我们的reducer。还要注意`onChangeUserId`现在是一个异步函数：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This UI will take `userid` as an input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI将以`userid`作为输入。
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s create a child component that can display all of our user-related
    data:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个子组件，可以显示我们所有与用户相关的数据：
- en: 'Create a new component called `UserDisplay.tsx` and add this code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UserDisplay.tsx`的新组件，并添加这段代码：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s add the `UserDisplay` component to our `App` component:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`UserDisplay`组件添加到我们的`App`组件中：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: function App() {
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: function App() {
- en: const [userid, setUserid] = useState(0);
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: const [userid, setUserid] = useState(0);
- en: const dispatch = useDispatch();
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: const dispatch = useDispatch();
- en: 'const onChangeUserId = async (e:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'const onChangeUserId = async (e:'
- en: React.ChangeEvent<HTMLInputElement>) => {
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: React.ChangeEvent<HTMLInputElement>) => {
- en: const useridFromInput = e.target.value ?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: const useridFromInput = e.target.value ?
- en: 'Number(e.target.value) : 0;'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'Number(e.target.value) : 0;'
- en: console.log("userid", useridFromInput);
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: console.log("userid", useridFromInput);
- en: setUserid(useridFromInput);
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: setUserid(useridFromInput);
- en: const usersResponse = await
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: const usersResponse = await
- en: fetch('https://jsonplaceholder.typicode.com/      users');
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: fetch('https://jsonplaceholder.typicode.com/      users');
- en: if(usersResponse.ok) {
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: if(usersResponse.ok) {
- en: const users = await usersResponse.json();
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: const users = await usersResponse.json();
- en: 'const usr = users.find((userItem: any) => {'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'const usr = users.find((userItem: any) => {'
- en: return userItem && userItem.id ===         useridFromInput;
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: return userItem && userItem.id ===         useridFromInput;
- en: '});'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: dispatch({
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: dispatch({
- en: 'type: USER_TYPE,'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'type: USER_TYPE,'
- en: 'payload: {'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'payload: {'
- en: 'id: usr.id,'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'id: usr.id,'
- en: 'username: usr.username,'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'username: usr.username,'
- en: 'email: usr.email,'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'email: usr.email,'
- en: 'city: usr.address.city'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'city: usr.address.city'
- en: '}'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: return (
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: return (
- en: <React.Fragment>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <React.Fragment>
- en: <div className="App">
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <div className="App">
- en: <label>user id</label>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <label>用户ID</label>
- en: <input value={userid} onChange={onChangeUserId}           />
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <input value={userid} onChange={onChangeUserId}           />
- en: </div>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: </div>
- en: UserDisplay in the returned JSX UI so that our user information is displayed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的JSX UI中使用`UserDisplay`，这样我们的用户信息就会显示出来。
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now if you load the browser at `http://localhost:3000` and enter `1` in the
    input, you should see this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你在浏览器中加载`http://localhost:3000`并在输入框中输入`1`，你应该会看到这个：
- en: '![Figure 7.1 – User object from the Redux store'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - 来自Redux存储的用户对象'
- en: '](img/Figure_7.01_B15508.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B15508.jpg)'
- en: Figure 7.1 – User object from the Redux store
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 来自Redux存储的用户对象
- en: 'So, now that we''ve seen a sample of a simple Redux store use case, let''s
    take it a step further and show what will happen when we have multiple reducers
    in the same store:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经看到了一个简单Redux存储用例的示例，让我们进一步展示当我们在同一个存储中有多个reducer时会发生什么：
- en: 'Create a new file called `PostDisplay.tsx` and add the following code. This
    component will display posted comments from the JSON Placeholder API:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PostDisplay.tsx`的新文件，并添加以下代码。这个组件将显示来自JSON Placeholder API的发布评论：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Again, like our previous example, here, we set up which state data we want
    using `useSelector`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的示例一样，这里我们使用`useSelector`设置我们想要的状态数据：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, it looks very similar to `UserDisplay`, but it displays `post-r`elated
    information such as `title` and `body`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它看起来与`UserDisplay`非常相似，但它显示与`post`相关的信息，如`title`和`body`。
- en: 'Now, we update our Redux code to add our new reducer. First, add a new file
    inside of the `store` folder called `PostReducer.ts` and then add this code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们更新我们的Redux代码以添加我们的新reducer。首先，在`store`文件夹内添加一个名为`PostReducer.ts`的新文件，然后添加以下代码：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, this is very similar to `UserReducer`, but focused on posts instead of
    users.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这与`UserReducer`非常相似，但专注于帖子而不是用户。
- en: 'Next, we want to update the `AppState.tsx` file and add our new reducer to
    it. Add this code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要更新`AppState.tsx`文件，并将我们的新reducer添加到其中。添加以下代码：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'OK, so now we''ll update our `App` component and add code specifically for
    finding a specific post by ID from the JSON Placeholder API. Update `App` with
    this code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们将更新我们的`App`组件，并添加特定于从JSON Placeholder API中查找特定帖子的代码。使用以下代码更新`App`：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice we don't have a `dispatch` specific to any reducer. That's because dispatchers
    are just generic execution functions. The action will be routed to the appropriate
    reducer eventually.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有针对任何reducer特定的`dispatch`。这是因为分派程序只是通用执行函数。该操作最终将被路由到适当的reducer。
- en: '`onChangeUserId` has not changed but is shown here for completeness:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangeUserId`没有改变，但出于完整性，这里显示一下：'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`onChangePostId` is a new event handler for handling `post-r`elated data changes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChangePostId`是一个新的事件处理程序，用于处理与`post`相关的数据更改：'
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`OnChangePostId` dispatches a relevant `action` via the `dispatch` function.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnChangePostId`通过`dispatch`函数分派相关的`action`。'
- en: 'The UI has been slightly updated to handle the new `PostDisplay` component
    and separate it from the `UserDisplay` components:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: UI已经稍微更新以处理新的`PostDisplay`组件，并将其与`UserDisplay`组件分开：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Figure 7.2 – PostDisplay result'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – PostDisplay结果'
- en: '](img/Figure_7.02_B15508_New.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B15508_New.jpg)'
- en: Figure 7.2 – PostDisplay result
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – PostDisplay结果
- en: Notice that in the console, when updating the `postid` input, there is no log
    for `UserDisplay`. This shows that the Redux store is not directly attached to
    the React render pipeline and only the components associated with a particular
    state change will re-render. This is different behavior from React Context and
    can be a benefit to performance by reducing unwanted renders (we'll talk about
    Context in the next section).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在控制台中，当更新`postid`输入时，没有`UserDisplay`的日志。这表明Redux存储不直接连接到React渲染管道，只有与特定状态更改相关的组件才会重新渲染。这与React
    Context的行为不同，并且可以通过减少不需要的渲染来提高性能（我们将在下一节中讨论Context）。
- en: In this section, we learned about Redux, the most popular way of managing global
    state in React. In larger apps, we will use a global state manager frequently,
    as there is generally a lot of global data sharing happening. In our application,
    we will store information about our logged-in user and other data that will be
    shared across the app, so having this capability will be valuable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了Redux，这是在React中管理全局状态的最流行方式。在更大的应用程序中，我们经常会使用全局状态管理器，因为通常会发生大量的全局数据共享。在我们的应用程序中，我们将存储有关已登录用户和其他将在整个应用程序中共享的数据的信息，因此具有这种能力将是有价值的。
- en: React Context
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Context
- en: Context is a newer feature that came out a little before Hooks. Context is not
    a separate dependency but is built into React core. It allows similar functionality
    to Redux in that it allows state to be stored in a single source and then shared
    across components, without having to manually pass down props through the component
    hierarchy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Context是在Hooks之前推出的一个较新的功能。Context不是一个单独的依赖项，而是内置到React核心中的。它允许类似于Redux的功能，即允许状态存储在单一源中，然后在组件之间共享，而无需手动通过组件层次结构传递props。
- en: 'This capability is very efficient from a developer coding perspective because
    it eliminates the need to write a lot of boilerplate code to pass state down from
    a parent to its children. Here''s a visualization of a possible set of hierarchies
    in a larger React app:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发人员编码的角度来看，这种能力非常高效，因为它消除了从父级到其子级传递状态所需的大量样板代码。这是一个更大的React应用程序中可能的一组层次结构的可视化：
- en: '![Figure 7.3 – React component hierarchy'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – React组件层次结构'
- en: '](img/Figure_7.03_B15508.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B15508.jpg)'
- en: Figure 7.3 – React component hierarchy
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – React组件层次结构
- en: In this example diagram, we have a single parent component and it has several
    children, which it is using in its own JSX. Those children also have their own
    children, and so on. So, if we were to configure the passing of props all the
    way down for every component hierarchy, it would be quite a bit of code, especially
    knowing that some hierarchies involve passing functions that may call back to
    some arbitrary parent. Having these sorts of prop relationships also causes additional
    cognitive load for developers, as they need to think about data relationships
    and how data is being moved among the components.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例图中，我们有一个单一的父组件，它有几个子组件，它在自己的JSX中使用。这些子组件也有它们自己的子组件，依此类推。因此，如果我们要为每个组件层次结构配置传递props，那将是相当多的代码，特别是知道有些层次结涉及传递可能回调到某个任意父级的函数。这种类型的prop关系也会给开发人员带来额外的认知负担，因为他们需要考虑数据关系以及数据在组件之间的传递方式。
- en: Both React Context and Redux are good ways of avoiding this state-passing boilerplate
    code, when appropriate. And for smaller projects, the simplicity of Context works
    well. However, for larger projects, I recommend against using Context.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当适当时，React上下文和Redux都是避免这种状态传递样板代码的好方法。对于较小的项目，上下文的简单性效果很好。然而，对于较大的项目，我建议不要使用上下文。
- en: React Context can have multiple parent providers, meaning it is possible to
    have more than one root context. For larger apps, this can be confusing and adds
    more boilerplate code. Additionally, the mixing of global state providers can
    be confusing. If a team decides to use both Context and Redux, when do we use
    each one? And if we use both now, we must maintain two styles for global state
    management.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: React上下文可以有多个父提供者，这意味着可能有多个根上下文。对于更大的应用程序，这可能会令人困惑，并增加更多样板代码。此外，全局状态提供者的混合可能会令人困惑。如果团队决定同时使用Context和Redux，那么我们何时使用每一个？如果我们现在同时使用两者，那么我们必须维护两种全局状态管理样式。
- en: In addition, Context, unlike Redux, has no concept of reducers. Therefore, all
    users of Context will receive the entire set of state data, which is not a good
    practice in terms of the separation of concerns. Over time, it can become confusing
    as to what subset of the data a particular component should deal with.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与Redux不同，上下文没有reducers的概念。因此，上下文的所有用户将接收整个状态数据集，这在关注点分离方面不是一个好的实践。随着时间的推移，特定组件应处理哪个数据子集可能会变得令人困惑。
- en: 'One additional side effect of having all state data available to all component
    users is that, even if a component does not actually access the specific state
    member, any Context changes will trigger a re-render. For example, let''s say
    that the Context state looks like this `{ username, userage }` and our component
    only uses `username`. Even if `userage` alone changes, it triggers a re-render
    in that component. This is true even when `memo` is used (we covered `memo` in
    [*Chapter 5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081), *React Development
    with Hooks*). Let''s look at an example demonstrating this effect:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有状态数据对所有组件用户都可用的一个额外副作用是，即使组件实际上没有访问特定状态成员，任何上下文更改都会触发重新渲染。例如，假设上下文状态如下`{
    username, userage }`，而我们的组件只使用`username`。即使仅`userage`发生变化，它也会触发该组件的重新渲染。即使使用了`memo`（我们在[*第5章*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)中介绍了`memo`），这也是正确的。让我们看一个演示这种效果的例子：
- en: 'Remove `React.StrictMode` and `Provider` from `index.tsx` to avoid confusion.
    We''ll put this back later. Now, the `index.tsx` file should look like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`index.tsx`中删除`React.StrictMode`和`Provider`，以避免混淆。我们稍后会把它们放回去。现在，`index.tsx`文件应该是这样的：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, these comments are coming from `create-react-app` and are included here
    only for completeness:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这些注释来自`create-react-app`，仅出于完整性而包含在这里：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can also remove any unused imports to avoid triggering warning messages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: You can also remove any unused imports to avoid triggering warning messages.
- en: 'Now, create these two child components, where each one will use a unique member
    of our Context state. First, create the `UserAgeComp.tsx` component with this
    code in it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建这两个子组件，每个组件将使用我们上下文状态的一个唯一成员。首先，创建`UserAgeComp.tsx`组件，并添加以下代码：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code uses object destructuring to only use the `userage` member of `TestContext`
    by using the `useContext` Hook, which we will create later, and displays it only.
    Now, create the `UserNameComp.tsx` component with this code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用对象解构来仅使用`TestContext`的`userage`成员，通过使用稍后我们将创建的`useContext` Hook，并仅显示它。现在，创建`UserNameComp.tsx`组件，并添加以下代码：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we need to create a parent component that has Context in it. Create the
    `ContextTester.tsx` file and add this code into it:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个包含上下文的父组件。创建`ContextTester.tsx`文件，并添加以下代码：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we use `createContext` to create our `TestContext` object, which will
    hold our state:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`createContext`来创建我们的`TestContext`对象，它将保存我们的状态：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, if we click on `Update age` or `Update localstate`, you will see that the
    `console.log` statement in `UserNameComp` is never executed. That log statement
    was only executed one time when the page first loaded, which is what is supposed
    to happen since `UserNameComp` is using `memo` (`memo` only allows re-renders
    when props change). You should see only one set of logs in your **Console** tab
    (ignore the warnings, as we'll re-add our dependencies soon):![Figure 7.4 – Context
    render result
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们点击“更新年龄”或“更新本地状态”，你会发现`UserNameComp`中的`console.log`语句从未执行过。该日志语句仅在页面首次加载时执行了一次，这是应该发生的，因为`UserNameComp`使用了`memo`（`memo`只允许在props更改时重新渲染）。你应该在**控制台**选项卡中只看到一组日志（忽略警告，因为我们很快会重新添加我们的依赖项）：![图7.4
    - 上下文渲染结果
- en: '](img/Figure_7.04_B15508.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.04_B15508.jpg)'
- en: Figure 7.4 – Context render result
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 - 上下文渲染结果
- en: 'OK, so then now, let''s force `UserNameComp` to use the `username` from our
    `TestContext`. So now, `UserNameComp` should look like this:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在，让我们强制`UserNameComp`使用我们的`TestContext`中的`username`。所以现在，`UserNameComp`应该是这样的：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: const ContextTester = () => {
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: const ContextTester = () => {
- en: const [userage, setUserage] = useState(20);
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: const [userage, setUserage] = useState(20);
- en: const [localState, setLocalState] = useState(0);
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: const [localState, setLocalState] = useState(0);
- en: const onClickAge = () => {
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: const onClickAge = () => {
- en: setUserage(
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: setUserage(
- en: userage + 1
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: userage + 1
- en: );
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: const onClickLocalState = () => {
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: const onClickLocalState = () => {
- en: setLocalState(localState + 1);
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: setLocalState(localState + 1);
- en: '}'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return (<React.Fragment>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（<React.Fragment>
- en: <button onClick={onClickAge}>Update age</button>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <button onClick={onClickAge}>更新年龄</button>
- en: <username is hardcoded to "dave" and never changes. And as you can see, UserNameComp
    was moved into TestContext.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <username is hardcoded to "dave" and never changes. And as you can see, UserNameComp
    was moved into TestContext.
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if we run this code and then click on the buttons several times, we should
    see something like this:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这段代码，然后多次点击按钮，我们应该看到类似这样的结果：
- en: '![Figure 7.5 – Re-renders when using Context'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 - 使用上下文时的重新渲染'
- en: '](img/Figure_7.05_B15508.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.05_B15508.jpg)'
- en: Figure 7.5 – Re-renders when using Context
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 - 使用上下文时的重新渲染
- en: As you can see, our `UserNameComp` component keeps getting re-rendered, even
    when we only change the `localState` variable. Why is this happening? `TestContext`
    is a component just like any other React component. And it does not use `memo`.
    So, when the parent component, `ContextTester`, gets re-rendered, it also gets
    re-rendered, which has a knock-on effect for any of its children. This is why
    `UserNameComp` keeps getting re-rendered although it never uses the `userage`
    variable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的`UserNameComp`组件不断重新渲染，即使我们只改变了`localState`变量。为什么会发生这种情况？`TestContext`是一个像任何其他React组件一样的组件。它不使用`memo`。因此，当父组件`ContextTester`重新渲染时，它也会重新渲染，这对于它的任何子组件都会产生连锁效应。这就是为什么`UserNameComp`不断重新渲染，尽管它从不使用`userage`变量。
- en: So, as you can see, Context has some issues with its use, and it is my opinion
    that for large React applications, if you had to choose between the two, it would
    be better, albeit more complex, to use Redux.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，上下文在使用上有一些问题，我认为对于大型的React应用程序，如果你必须在这两者之间做出选择，使用Redux可能更好，尽管更复杂。
- en: In this section, we learned about Context basics. Context is relatively easy
    to learn and use. And for smaller projects, it works very well. However, due to
    its simple design, for more complex projects, a more sophisticated global state
    management system may be preferable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了有关上下文的基础知识。上下文相对来说很容易学习和使用。对于较小的项目，它非常有效。然而，由于其简单的设计，对于更复杂的项目，更复杂的全局状态管理系统可能更可取。
- en: Learning about React Router
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习React Router
- en: React Router is the most commonly used routing framework in React. It is relatively
    simple to learn and use. Routing, as we discovered in [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072),
    *Learning Single-Page Application Concepts and How React Enables Them*, is ubiquitous
    in web development. It is a feature expected by users of web apps, so learning
    how to use it for our React app is a requirement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: React Router是React中最常用的路由框架。它相对来说很简单学习和使用。路由，正如我们在[*第4章*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072)中发现的，*学习单页应用程序的概念以及React如何实现它们*，在Web开发中是无处不在的。这是Web应用程序用户所期望的功能，因此学习如何在我们的React应用程序中使用它是一个要求。
- en: 'Routes in React Router are simply React Router components that contain our
    own application components, and these components in turn represent our screens.
    In other words, a route in React Router is a logical representation of a virtual
    location (by virtual location, I mean a URL that is just a label and does not
    actually exist on any server). The "routers" in React Router act as parent components
    and our screen rendering components act as children. This is a bit difficult to
    understand by simply reading about it, so let''s create an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Router中，路由只是包含我们自己应用程序组件的React Router组件，而这些组件又代表我们的屏幕。换句话说，React Router中的路由是虚拟位置的逻辑表示（通过虚拟位置，我指的是一个仅仅是标签而不实际存在于任何服务器上的URL）。React
    Router中的“路由器”充当父组件，而我们的屏幕渲染组件充当子组件。仅仅通过阅读是有点难以理解的，所以让我们创建一个例子：
- en: 'Create a new React project under the `Chap7` folder in your terminal by calling
    this command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中调用这个命令，在`Chap7`文件夹下创建一个新的React项目：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once it has completed creating our project, `cd` into the new `try-react-outer`
    folder, then let''s add some packages:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦它完成了创建我们的项目，`cd`进入新的`try-react-outer`文件夹，然后让我们添加一些包：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s update our `index.tsx` file so that it includes the root React
    Router component in our app. Update `index.tsx` like this:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新我们的`index.tsx`文件，以便在我们的应用程序中包含根React Router组件。像这样更新`index.tsx`：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So now, since this tool is giving us routing, we must set up our individual
    routes. However, since routes ultimately are just containers for components that
    represent our screens, let''s create two of those screens first. Create a file
    called `ScreenA.tsx` and add this code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于这个工具为我们提供了路由，我们必须设置我们的个别路由。然而，由于路由最终只是代表我们屏幕的组件的容器，让我们首先创建两个屏幕。创建一个名为`ScreenA.tsx`的文件，并添加以下代码：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It's a simple component that displays **ScreenA** in the browser.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的组件，在浏览器中显示**ScreenA**。
- en: 'Now, create a file called `ScreenB.tsx` and add this code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`ScreenB.tsx`的文件，并添加以下代码：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Again, it is a simple component displaying **ScreenB** in the browser.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是一个简单的组件，在浏览器中显示**ScreenB**。
- en: 'Now, let''s give our routes a try. Open `App.tsx` and add this code into it:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们试试我们的路由。打开`App.tsx`并添加以下代码：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Figure 7.6 – Routed to ScreenA'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 - 路由到ScreenA'
- en: '](img/Figure_7.06_B15508.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.06_B15508.jpg)'
- en: Figure 7.6 – Routed to ScreenA
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - 路由到ScreenA
- en: 'But if we were to go to route `"/b"`, we should see **ScreenB** instead, like
    this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们要去到路由`"/b"`，我们应该看到**ScreenB**，就像这样：
- en: '![Figure 7.7 – Routed to ScreenB'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - 路由到ScreenB'
- en: '](img/Figure_7.07_B15508.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.07_B15508.jpg)'
- en: Figure 7.7 – Routed to ScreenB
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 路由到ScreenB
- en: So, as I stated at the beginning of the section, React Router routes are React
    components. This may seem weird as they have no visible UI. Nevertheless, they
    are parent components, except they render their children but have no UI of their
    own.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如我在本节开头所述，React Router路由是React组件。这可能看起来很奇怪，因为它们没有可见的UI。尽管如此，它们是父组件，除了渲染它们的子组件之外，它们自己没有UI。
- en: Now, we know that when our app first loads, it is the `index.tsx` file that
    runs before anything else. And this is also where the core React Router service
    lives. When this service encounters a URL, it looks through the set of routes
    defined in our `App.tsx` file and selects a matching route. Once the matching
    route is selected, that route's child component is rendered. So, for example,
    the route with `path="/b"` would render the `ScreenB` component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道当我们的应用程序首次加载时，首先运行的是`index.tsx`文件。这也是核心React Router服务所在的地方。当这个服务遇到一个URL时，它会查看我们的`App.tsx`文件中定义的路由集，并选择一个匹配的路由。一旦选择了匹配的路由，就会渲染该路由的子组件。因此，例如，具有`path="/b"`的路由将渲染`ScreenB`组件。
- en: Let's drill into the details of our routing code. If we look back at our routes,
    we should see that our first route has a property called `exact`. This tells React
    Router not to use regular expressions in determining a route match but instead
    to look for an exact match. Next, we see a property called `path`, which of course
    is supposed to be our URL path after the root domain. This path is by default
    a "contains" path, meaning that any URL that contains the same value as the `path`
    property will be accepted and the first matching route will be rendered, unless
    we included the `exact` property.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解我们的路由代码的细节。如果我们回顾一下我们的路由，我们应该看到我们的第一个路由有一个叫做`exact`的属性。这告诉React Router不要使用正则表达式来确定路由匹配，而是要寻找一个精确匹配。接下来，我们看到一个叫做`path`的属性，这当然是我们在根域之后的URL路径。这个路径默认是一个"包含"路径，意味着任何包含与`path`属性相同值的URL都将被接受，并且将呈现第一个匹配的路由，除非我们包含了`exact`属性。
- en: Now, you will also notice that we have a property called `component`, which
    of course refers to the child component that is to be rendered. And for simple
    scenarios, using this property works fine. But what if we need to pass some additional
    props to our component? React Router provides another property called `render`,
    which allows us to use what's called a **render property**.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你还会注意到我们有一个叫做`component`的属性，它当然是指要呈现的子组件。对于简单的场景，使用这个属性是可以的。但是如果我们需要向组件传递一些额外的props怎么办？React
    Router提供了另一个叫做`render`的属性，它允许我们使用所谓的**渲染属性**。
- en: 'A `render` property is a property that takes a function as its parameter. When
    the parent component does its rendering, it will call the `render` function internally.
    Let''s look at an example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`属性是一个以函数作为参数的属性。当父组件进行渲染时，它将在内部调用`render`函数。让我们看一个例子：'
- en: 'Create a new component called `ScreenC.tsx` and add this code in it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ScreenC.tsx`的新组件，并在其中添加以下代码：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `ScreenC` component is much like the other components. However, it also
    receives a prop called `message` and uses that as its display. Let's see how we
    pass this prop in via our `render` property of React Router.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScreenC`组件与其他组件非常相似。但是它还接收一个叫做`message`的prop，并将其用作显示。让我们看看如何通过React Router的`render`属性传递这个prop。'
- en: 'Now let''s update our `App` component and add this new component as a route:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们更新我们的`App`组件，并将这个新组件作为一个路由添加进去：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we add a new `Route` that uses the `render` property and pass it the
    `renderScreenC` function. If we go to the `"/c"` path, we see basically the same
    thing as the other screens, but with our message, **This is Screen C**:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个使用`render`属性的新的`Route`，并将其传递给`renderScreenC`函数。如果我们去`"/c"`路径，我们会看到基本上与其他屏幕相同的东西，但是有我们的消息，**这是屏幕C**：
- en: '![Figure 7.8 – Routed to ScreenC'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 - 路由到ScreenC'
- en: '](img/Figure_7.08_B15508.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.08_B15508.jpg)'
- en: Figure 7.8 – Routed to ScreenC
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - 路由到ScreenC
- en: But also, I've included a log of the props that are being passed into the component
    and we can see things such as `history`, `location`, and `match` members being
    included. You will recall our render function, `renderScreenC`, had a signature
    of `(props:any) => { … }`. That `props` parameter is being passed in by our `Route`
    component from the React Router service. We'll take a look at these routing properties
    later.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我还包含了一个传递给组件的props的日志，我们可以看到诸如`history`、`location`和`match`成员等内容。你会记得我们的渲染函数`renderScreenC`，它的签名是`(props:any)
    => { … }`。这个`props`参数是由React Router服务的`Route`组件传递进来的。我们稍后会看一下这些路由属性。
- en: 'So, now we know how to get better control of our screen component renders by
    using the `render` property, but a typical URL can also have parameters that pass
    data to the screen. Let''s look at how to do this with React Router:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们知道了如何通过使用`render`属性更好地控制我们的屏幕组件渲染，但是一个典型的URL也可以有传递数据到屏幕的参数。让我们看看如何在React
    Router中实现这一点：
- en: 'Let''s update our `Route` for `ScreenC` like this:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们像这样更新`ScreenC`的`Route`：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `userid` field is now a parameter on the URL.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`userid`字段现在是URL上的一个参数。'
- en: 'Now let''s update our `ScreenC` component to accept Route props and handle
    our new `userid` parameter field:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们更新我们的`ScreenC`组件，接受Route props并处理我们的新的`userid`参数字段：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Figure 7.9 – Routed to ScreenC with a parameter'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 - 带参数路由到ScreenC'
- en: '](img/Figure_7.09_B15508.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.09_B15508.jpg)'
- en: Figure 7.9 – Routed to ScreenC with a parameter
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 - 带参数路由到ScreenC
- en: As you can see, our `userid` parameter of value **1** is shown.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的`userid`参数的值为**1**。
- en: OK, so now we've used React Router more realistically, but there's another important
    characteristic to note about how React Router works. React Router acts basically
    like a stack of URLs. In other words, when a user visits the URLs of a site, they
    do so in a linear fashion. They go to A, then B, and maybe back to A, then C,
    and so on. And the result of this is that the browser history of a user can be
    saved as a stack, where you can go forward to a new URL or backward to a previously
    visited one. This characteristic of browser behavior is mostly maintained in React
    Router's `history` object.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们更实际地使用了React Router，但关于React Router的工作方式还有另一个重要特点需要注意。React Router基本上就像一个URL的堆栈。换句话说，当用户访问站点的URL时，他们是以线性方式进行的。他们先去A，然后去B，也许回到A，然后去C，依此类推。由此产生的结果是用户的浏览器历史可以保存为一个堆栈，用户可以前进到一个新的URL，或者后退到先前访问过的URL。这种浏览器行为特性在React
    Router的`history`对象中大多得到了维护。
- en: 'So, again, let''s update our code and take a look at some of the capabilities
    provided by the `history` object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次，让我们更新我们的代码，看看`history`对象提供的一些功能：
- en: 'Update the `ScreenC` component like this:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ScreenC`组件如下：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s use another function inside of the `history` object. Update `ScreenC`
    again, like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`history`对象内部使用另一个函数。再次更新`ScreenC`，像这样：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can see we have a button called `"/b"` route.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到我们有一个名为`"/b"`的路由按钮。
- en: 'One more thing to review: React Router recently added the Hooks capability.
    So, we no longer have to pass down route properties using a child''s props; we
    can just use Hooks. Here''s what it looks like (i''ve kept the non-Hooks as comments
    for your convenience):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一件事要回顾一下：React Router最近添加了Hooks功能。因此，我们不再需要通过子组件的props传递路由属性；我们可以直接使用Hooks。以下是它的样子（我已经将非Hooks部分作为注释保留给您）：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we have our new `useHistory` and `useParams` Hooks imports:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的新的`useHistory`和`useParams` Hooks导入：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we call our `useHistory` and `useParams` Hooks to get `history` and the
    `userid` URL parameter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用我们的`useHistory`和`useParams` Hooks来获取`history`和`userid` URL参数：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And here, we use the Hooks objects to display the same messages as before. It's
    quite easy and nice to use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Hooks对象来显示与之前相同的消息。使用起来非常简单和方便。
- en: There are of course more capabilities of the `history` object and React Router
    overall, but this is a good introduction to those capabilities and we will use
    more of these features as we begin to build our app in the coming chapters.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`history`对象和React Router整体还有更多功能，但这是对这些功能的一个很好的介绍，我们将在接下来的章节中开始构建我们的应用程序时使用更多这些特性。
- en: Routing is a vital part of web development. Routes help users know where they
    are in the application and can provide a sense of context. Routing also helps
    us as developers structure the logical sections of our application and group relevant
    items together. React Router allows us to do all these things by providing many
    programmatic features that allow us to build sophisticated routing into our applications.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是Web开发的重要部分。路由帮助用户了解他们在应用程序中的位置，并提供一种上下文的感觉。路由还帮助我们作为开发人员结构化应用程序的逻辑部分，并将相关项目组合在一起。React
    Router通过提供许多编程功能，使我们能够将复杂的路由集成到我们的应用程序中。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered some of the most important React-related frameworks. Redux
    is a sophisticated tool for managing global application state. React Router provides
    client-side URL management that looks and feels like classic-style web URLs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一些最重要的与React相关的框架。Redux是一个管理全局应用程序状态的复杂工具。React Router提供了类似经典Web URL的客户端URL管理。
- en: Working with high-quality technologies such as Redux and React Router will help
    us to write better code. And this in turn will help us give our users the best
    experience.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高质量的技术，如Redux和React Router，将帮助我们编写更好的代码。这反过来将帮助我们为用户提供最佳体验。
- en: We have reached the end of *Part 2*, which focused on client-side technologies.
    We will now begin learning about server-side technologies in *Part 3*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了重点放在客户端技术的*第二部分*的结尾。现在我们将开始学习*第三部分*的服务器端技术。
