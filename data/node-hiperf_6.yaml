- en: Chapter 6. Test, Benchmark, and Analyze
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。测试、基准测试和分析
- en: Testing your application is as important as its development. Testing is the
    process of analyzing your application modules and the application as a whole to
    see whether it behaves as you expect it. It allows your business to define use
    cases and check whether they're all accomplished.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的应用程序与其开发一样重要。测试是分析应用程序模块和整个应用程序的过程，以查看它是否表现如您所期望的。它允许您的业务定义用例并检查它们是否都得到满足。
- en: There are many testing techniques. One of the most famous is **Test-driven Development**
    (**TDD**). This technique consists of using the smallest development cycles possible.
    Between every cycle, tests are performed and new tests and uses cases are added
    before they're developed. This way, your application versions can be continuously
    tested and any faulty version can be quickly spotted. If you use a version control
    system, such as Git, it becomes very easy to find the culprit of the failing test
    and fix it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多测试技术。其中最著名的之一是**测试驱动开发**（**TDD**）。这种技术包括使用尽可能小的开发周期。在每个周期之间，进行测试并在开发之前添加新的测试和用例。这样，您的应用程序版本可以持续测试，并且可以快速发现任何有问题的版本。如果您使用版本控制系统，比如Git，那么很容易找到失败测试的罪魁祸首并加以修复。
- en: An important aspect of performing tests from the ground up is that you can keep
    adding use cases and test cases as you spot them. For example, if someone reports
    a bug and you create a specific use case for it, you can ensure that that bug
    doesn't appear again or that it will not be visible in the tests. In community-driven
    projects, it's very common to see this use case (a member spotting a bug and adding
    a test case for it). If you can replicate it, you can create a test case.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始执行测试的一个重要方面是，您可以在发现它们时不断添加用例和测试用例。例如，如果有人报告了一个错误，并且您为此创建了一个特定的用例，您可以确保该错误不会再次出现，或者它不会在测试中可见。在社区驱动的项目中，很常见看到这种用例（成员发现错误并为其添加测试用例）。如果您能复制它，您可以创建一个测试用例。
- en: Depending on your test platform, you can benchmark your application. Usually,
    test platforms have a default timeout per test as long as 1 or 2 seconds. You
    can reduce this value for features that you want to ensure perform well. You can
    also do the opposite by giving more time for longer use cases.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的测试平台，您可以对应用程序进行基准测试。通常，测试平台每个测试有一个默认的超时时间，长达1或2秒。您可以减少这个值以确保功能的性能。您也可以通过为更长的用例提供更多时间来做相反的操作。
- en: Platforms with this timeout feature allow you to have consistent tests. Remember
    to test in a common platform, such as a general working environment. Don't define
    test benchmarks for a superfast server and then expect them to pass in a computer
    that is 20 years old.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 具有此超时功能的平台可以让您进行一致的测试。记住在一个常见的平台上进行测试，比如一个通用的工作环境。不要为一个超快的服务器定义测试基准，然后期望它们在一个20年前的计算机上通过。
- en: Test fundamentals
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试基础
- en: Tests can be defined in a variety of ways. The most common approach is unit
    testing. This is a method by which parts of your application are individually
    checked to confirm that they comply with the specifications. This approach encourages
    your application parts to act as independent and replaceable black boxes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以以多种方式定义。最常见的方法是单元测试。这是一种方法，通过该方法可以逐个检查应用程序的部分，以确认它们是否符合规范。这种方法鼓励您的应用程序部分作为独立和可替换的黑匣子。
- en: You need real data to properly test your application. You also need unrealistic
    data. Both are crucial to confirm that it behaves as expected with both correct
    data and scrambled data. This ensures that a misguided or malicious user won't
    break your application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要真实的数据来正确测试您的应用程序。您还需要不切实际的数据。这两者对于确认它在正确数据和混乱数据下的行为是否符合预期都是至关重要的。这确保了误导或恶意用户不会破坏您的应用程序。
- en: You might be wondering what I mean by unrealistic data. Does your application
    handle text in date fields or numbers in checkboxes? What about missing data?
    You might think it does, but if you have more developers working on it, you may
    want to ensure that, somewhere in the future, it doesn't stop behaving correctly.
    The most common type of bug occurs in one place after making a change in a completely
    different place.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道我所说的不切实际的数据是什么意思。您的应用程序是否处理日期字段中的文本或复选框中的数字？缺少的数据呢？您可能认为它可以，但是如果有更多的开发人员在上面工作，您可能希望确保在将来的某个地方它不会停止正确地行为。最常见的错误类型是在一个地方进行更改后在完全不同的地方出现。
- en: The goal of unit testing should be to completely isolate each of your application's
    modules and to be able to test them independently. If a module needs other parts
    of the application to work properly, you can fake that data or mock that dependency,
    using Sinon ([http://sinonjs.org/](http://sinonjs.org/)) for example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的目标应该是完全隔离您应用程序的每个模块，并能够独立测试它们。如果一个模块需要应用程序的其他部分正常工作，您可以使用Sinon（例如[http://sinonjs.org/](http://sinonjs.org/)）来伪造数据或模拟依赖关系。
- en: 'Some of the benefits of testing are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试的好处如下：
- en: Bugs are found early in the development cycle. Since you can test your code
    every time you change it, bugs should be spotted earlier. The cost of fixing bugs
    earlier, sometimes even before going into production, greatly reduces overall
    costs.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发周期的早期发现错误。由于您可以在每次更改代码时测试代码，因此应该更早地发现错误。更早地修复错误的成本，有时甚至在投入生产之前，大大降低了总体成本。
- en: It forces developers to think about I/O data and errors, since application architects
    must think and properly describe every use case. Features and use cases are developed
    with one or more test cases in mind.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它迫使开发人员考虑I/O数据和错误，因为应用程序架构师必须考虑并正确描述每个用例。功能和用例是根据一个或多个测试用例开发的。
- en: It enables changing or refactoring modules while still ensuring that the expected
    behavior is kept intact because of the test cases.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使您能够更改或重构模块，同时确保预期行为保持不变，因为有了测试用例。
- en: It facilitates module integration tests, since each of the modules are tested
    and have an expected behavior.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于模块集成测试，因为每个模块都经过测试并具有预期行为。
- en: All of these benefits are achieved only if the tests are properly defined and
    your test covers the entire application (all functions and objects). With proper
    test coverage, you can also add specific use cases for new features or edge cases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在测试被正确定义并且您的测试覆盖了整个应用程序（所有功能和对象）时，才能实现所有这些好处。通过正确的测试覆盖，您还可以为新功能或边缘情况添加特定的用例。
- en: Separating tests for each module is quite difficult. For example, if one of
    your modules needs a database to work, your test case will require giving it database
    access. This is not good, since your unit test will actually be an integration
    test, and if it fails you won't be able to say whether the problem is with the
    module or with the database.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个模块分离测试是相当困难的。例如，如果您的模块之一需要数据库才能工作，那么您的测试用例将需要给予它数据库访问权限。这不好，因为您的单元测试实际上将是集成测试，如果失败，您将无法确定问题是模块还是数据库的问题。
- en: The test environment
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试环境
- en: It is also important to have a consistent test environment. More importantly,
    the environment should be the same or almost the same, as the production environment.
    This means the same application (of course), but also the same operating system
    version, the same database server version, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一致的测试环境也很重要。更重要的是，环境应该与生产环境相同或几乎相同。这意味着相同的应用程序（当然），但也是相同的操作系统版本、相同的数据库服务器版本等等。
- en: For example, for Node.js tests, ensure that your test environment has the same
    Node.js version. You can test with different versions, but the most important
    is the version used in production. The same applies to the operative system version,
    the database service version, dependencies' versions, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于Node.js测试，请确保您的测试环境具有相同的Node.js版本。您可以尝试不同的版本，但最重要的是在生产中使用的版本。相同的原则也适用于操作系统版本、数据库服务版本、依赖项版本等等。
- en: The Docker tool
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker工具
- en: Having the same environment might not be easy, but there's a solution for that—Linux
    containers. If you haven't tried Docker yet, you're missing the train. This solution
    is free and is a tool involving containers that makes them usable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有相同的环境可能不容易，但有解决方案——Linux容器。如果您还没有尝试过Docker，那您就错过了。这个解决方案是免费的，是一个涉及容器的工具，使它们可用。
- en: Its main difference compared to tools such as Vagrant is that it doesn't need
    a virtual machine to create an environment. Docker is similar to OpenVZ ([https://openvz.org/Main_Page](https://openvz.org/Main_Page)),
    but with a twist; you can create an environment (a container) and share it for
    others to use. If you like NPM, you will find this similar. You have versioning
    and dependencies, and the most used environments are already online for you to
    download and use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与Vagrant等工具相比的主要区别在于，它不需要虚拟机来创建环境。Docker类似于OpenVZ（[https://openvz.org/Main_Page](https://openvz.org/Main_Page)），但有一个区别；您可以创建一个环境（容器）并共享给其他人使用。如果您喜欢NPM，您会发现这很相似。您有版本和依赖关系，最常用的环境已经在线上供您下载和使用。
- en: You can create a test environment in a container and then distribute the container
    to other developers. This also applies to production. Your developers can get
    a snapshot of a production database and a complete production environment in their
    laptop. In this way, changes can be made and tested as if they were applied to
    production. This is better than trying in production and having to roll back.
    In this way, you'll roll back less often. This is the principle of continuous
    integration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在容器中创建一个测试环境，然后将容器分发给其他开发人员。这也适用于生产。您的开发人员可以在他们的笔记本电脑上获得生产数据库的快照和完整的生产环境。通过这种方式，可以进行更改和测试，就好像它们被应用于生产环境一样。这比在生产环境中尝试并不得不回滚要好。这样，您将更少地回滚。这是持续集成的原则。
- en: 'Let''s create a very simple environment for our Node.js application. Have Docker
    installed, open a terminal, and run this code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的Node.js应用程序创建一个非常简单的环境。安装Docker，打开终端，运行以下代码：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Remember that we want a specific version, and that''s why we''re forcing `0.12.4`
    in this case. I''m considering the operative system as unimportant, since our
    application won''t have external dependencies or node modules. This command will
    just download the image template, and it''s not creating any environment yet;
    we''ll do that in a moment. You''ll notice that it takes a few hundred megabytes.
    Don''t worry; that is possibly the only space you need, as your environments will
    almost always depend on this image. If you want to check out the downloaded image,
    run this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们想要一个特定的版本，这就是为什么在这种情况下我们强制使用`0.12.4`。我认为操作系统不重要，因为我们的应用程序不会有外部依赖项或节点模块。这个命令只会下载图像模板，还没有创建任何环境；我们马上就会做。您会注意到它需要几百兆字节。不用担心；这可能是您唯一需要的空间，因为您的环境几乎总是依赖于这个图像。如果您想查看已下载的图像，请运行以下命令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Well, there's a lot of space there, isn't there? If you look closely, you'll
    notice that there's only one image (the `IMAGE ID` is the same). What has happened
    is that `0.12.4` is actually the latest version by the time of writing this book,
    and the latest tag has also been assigned to our image. Furthermore, that version
    is the last version of `0.12`, and it's the last version of 0.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，那里有很多空间，不是吗？如果你仔细看，你会注意到只有一个图像（`IMAGE ID`是相同的）。发生的事情是，`0.12.4`实际上是写这本书时的最新版本，并且最新标签也已分配给我们的图像。此外，该版本是`0.12`的最后一个版本，也是0的最后一个版本。
- en: This means that we can use any of these tags to refer to our image, but we don't
    want that, as new versions might come up and our images would start being built
    with those new versions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用这些标签中的任何一个来引用我们的图像，但我们不希望这样，因为可能会出现新版本，我们的图像将开始使用这些新版本构建。
- en: 'We can see which containers are running, or were created before, and are not
    running anymore. We can see simply what is running, but I find it much more useful
    to see dead containers, as they potentially use unnecessary space. There are no
    containers now. We can simply test the image to see whether it works:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到哪些容器正在运行，或者之前创建过但不再运行。我们可以简单地看到正在运行的内容，但我发现看到死掉的容器更有用，因为它们可能使用了不必要的空间。现在没有容器了。我们可以简单地测试镜像以查看它是否工作：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We just ran a basic environment using our image, running `bash` in a `tty`
    (`-t`), in interactive mode (`-i`) as opposed to running in the background (`-d`).
    You can see that we have node and `npm` in the environment. If we look at which
    containers exist, we will see something similar to this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用我们的镜像在交互模式下运行了一个基本环境，使用了`tty`(`-t`)中的`bash`，而不是在后台运行(`-d`)。您可以看到我们的环境中有node和`npm`。如果我们查看存在的容器，我们会看到类似于这样的东西：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our container has unique identifier, `1a56bbeb3d36`, is using the `0` node
    image, and is running the `bash` command. Well, it is actually no longer running.
    You can remove it by running this line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的容器有唯一标识符`1a56bbeb3d36`，正在使用`0`节点镜像，并且正在运行`bash`命令。好吧，它实际上已经不再运行了。您可以通过运行这行来删除它：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Noticed the `Exited (0) ..` lines in the `ps` command? Yes, exit code from the
    command is accessible. If you exited `bash` with `exit` `123`, you will see it
    outside the container. This is great for launching a test command instead of `bash`
    and then just checking whether all the tests have passed based on the exit code.
    You can also record the output and, in the event of a failure, save it for analysis.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`ps`命令中的`Exited (0) ..`行吗？是的，命令的退出代码是可以访问的。如果您使用`exit` `123`退出`bash`，您将在容器外看到它。这对于启动测试命令而不是`bash`，然后仅根据退出代码检查所有测试是否通过非常有用。您还可以记录输出，并在失败时保存以供分析。
- en: The test tool
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试工具
- en: Now that we have a form of replicating the environment to test, we need a proper
    test tool—something you can use to define your use cases and test cases. There
    are many great tools and Node.js has specific tools for testing. Some of them
    are really great.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种复制环境进行测试的方法，我们需要一个合适的测试工具——您可以用它来定义您的用例和测试用例。有许多很棒的工具，Node.js有专门用于测试的工具。其中一些真的很棒。
- en: 'If you have nothing in mind, I would recommend trying mocha ([http://mochajs.org/](http://mochajs.org/)).
    It''s available for installation on NPM, and you should install it globally:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有头绪，我建议尝试一下mocha ([http://mochajs.org/](http://mochajs.org/))。它可以在NPM上安装，并且您应该全局安装它：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this way, you can use mocha in all your applications on your computer without
    having to install it over and over again, because it's actually a development/test
    dependency, not a real application dependency. Installing it globally will also
    install the `mocha` command in your path.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以在计算机上的所有应用程序中使用mocha，而无需一遍又一遍地安装它，因为它实际上是一个开发/测试依赖项，而不是一个真正的应用程序依赖项。全局安装它还将在您的路径中安装`mocha`命令。
- en: 'Let''s create a very simple module called `module`.js with a function that
    simply adds two numbers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单的名为`module`.js的模块，其中包含一个简单地添加两个数字的函数：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s create a test case. For this, we''ll create another file called
    `test.js`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个测试用例。为此，我们将创建另一个名为`test.js`的文件：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, this file loads our module (`m`) and asserts that `m.add` should
    add two numbers. To check it, we add a test case by checking whether the module
    returns `5` when we pass `2` and `3` to it. Now, open a terminal in the folder
    where you have these two files and just run `mocha` without any arguments, like
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个文件加载了我们的模块(`m`)，并断言`m.add`应该添加两个数字。为了检查它，我们通过检查模块在我们传递`2`和`3`时是否返回`5`来添加一个测试用例。现在，在您拥有这两个文件的文件夹中打开一个终端，并且只需运行`mocha`而不带任何参数，就像这样：
- en: '![The test tool](img/4183_06_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![测试工具](img/4183_06_01.jpg)'
- en: Nice, isn't it? There are other forms of output called **reporters**, such as
    the progress, list, or dot matrix. If you just want a simple output, try list
    or progress. If you want the details of every test, use the spec reporter. It's
    shown in the preceding screenshot.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，是吧？还有其他形式的输出称为**报告者**，例如进度、列表或点矩阵。如果您只想要简单的输出，尝试列表或进度。如果您想要每个测试的详细信息，请使用规范报告者。它显示在前面的截图中。
- en: 'Let''s add another test to our function. Change the test file to look like
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的函数添加另一个测试。将测试文件更改为如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run `mocha` again, your test case will cause the `test` suite to fail,
    as shown in this screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行`mocha`，您的测试用例将导致`test`套件失败，就像这个截图中显示的那样：
- en: '![The test tool](img/4183_06_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![测试工具](img/4183_06_02.jpg)'
- en: 'Let''s change our module to behave correctly, as we stated in our new test.
    You can change it however you want; I''ll just show an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改我们的模块以正确地行事，就像我们在新测试中所述的那样。您可以随意更改它；我只是举个例子：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Upon running again, our test should pass, as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行，我们的测试应该通过，就像下面的截图中显示的那样：
- en: '![The test tool](img/4183_06_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![测试工具](img/4183_06_03.jpg)'
- en: 'We can now test this in our environment instead of testing it directly. This
    ensures that our application works in a clean environment and is not passing because
    of something your local environment has. To do this, we can use our previous node
    image. Let''s create a simple test environment. To do this, we need to create
    a file called `Dockerfile` in our test folder:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的环境中测试这个，而不是直接测试它。这确保了我们的应用程序在一个干净的环境中工作，并且不是因为您的本地环境的某些原因而通过。为此，我们可以使用我们之前的node镜像。让我们创建一个简单的测试环境。为此，我们需要在我们的测试文件夹中创建一个名为`Dockerfile`的文件：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This describes our environment. What the file is describing is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了我们的环境。文件描述如下：
- en: Use node image version `0.12.4`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用node镜像版本`0.12.4`
- en: Install the `mocha` dependency
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装`mocha`依赖
- en: Create a linkable volume on `/opt/app`
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/opt/app`上创建可链接的卷
- en: 'Now, let''s build our environment and call it `env/test`. We''re actually creating
    a new image based on another image. Our linkable volume is a folder that we can
    specify when running our environment. In this way, you can use this very image
    for all your applications. To build our environment, we run this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建我们的环境并称之为`env/test`。我们实际上是在基于另一个镜像创建一个新的镜像。我们可以在运行环境时指定一个可链接的卷作为文件夹。这样，你可以为所有你的应用程序使用这个镜像。为了构建我们的环境，我们运行这个命令：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have an image that we can use. Let's try the image by running our tests
    with `mocha`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以使用的镜像。让我们通过使用`mocha`运行我们的测试来尝试这个镜像。
- en: '![The test tool](img/4183_06_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![测试工具](img/4183_06_04.jpg)'
- en: Check out the online documentation of Docker for details on the command line.
    We're running our image where the `/opt/app` (`-v`) volume is our current folder
    (with our Node.js files). Our test environment is run in interactive mode (`-it`),
    and the result image is discarded at the end (`--rm`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Docker的在线文档，了解命令行的详细信息。我们正在运行我们的镜像，其中`/opt/app`（-v）卷是我们当前的文件夹（包含我们的Node.js文件）。我们的测试环境以交互模式运行（-it），并且在最后丢弃结果镜像（--rm）。
- en: 'If you have a central code repository, it is good practice to test before committing
    to avoid common mistakes. It also avoids breaking changes. It''s common to make
    a change to fix or improve something and break something else. With an always-clean
    test environment, developers can ensure that the tests run correctly. This environment
    can be similar to the one in the following image:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个中央代码存储库，最好在提交之前进行测试，以避免常见错误。这也可以避免破坏性的变更。通常会出现修复或改进某些内容的变更，同时破坏其他内容的情况。有了始终干净的测试环境，开发人员可以确保测试正确运行。这个环境可以类似于下图中的环境：
- en: '![The test tool](img/4183_06_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![测试工具](img/4183_06_05.jpg)'
- en: Continuous integration
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: '**Continuous integration** (**CI**) is a practice wherein all the developers
    of an application continuously integrate their changes into a central repository.
    This is a practice used in **extreme programming** (**XP**). It introduces new
    features faster and helps avoid code conflicts by reducing code merge time.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）是一种实践，应用程序的所有开发人员不断将他们的更改集成到一个中央存储库中。这是极限编程（XP）中使用的一种实践。它可以更快地引入新功能，并通过减少代码合并时间来避免代码冲突。
- en: If the application has a good test suite, developers can test changes locally
    in a replicated production and test environments and just commit if they pass.
    These tests should not replace the tests done on the server. If the test suite
    executes fast, it could even be a guarantee for the commit to be merged, but this
    is usually not recommended, as some commits actually cannot pass. Usually, all
    the commits are accepted and only then are they tested. The test results should
    be public at least inside the developer's circle as a way of forcing them to take
    care of their commits, how they structure their code, and how they describe commits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序有一个良好的测试套件，开发人员可以在本地测试变更，模拟生产和测试环境，并且只有通过了测试才提交。这些测试不应该取代服务器上的测试。如果测试套件执行速度快，甚至可以作为提交合并的保证，但通常不建议这样做，因为有些提交实际上无法通过。通常，所有提交都会被接受，然后才会进行测试。测试结果应该至少在开发人员圈子内公开，作为一种强制他们注意他们的提交、代码结构和提交描述的方式。
- en: 'There are four best practices for CI:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CI有四个最佳实践：
- en: Have a code repository and use a revision control system
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个代码存储库并使用版本控制系统
- en: Every commit should be checked to guarantee that it passes all the tests
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次提交都应该经过检查，以确保它通过了所有的测试。
- en: Separate the test environment from production environment
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试环境与生产环境分开
- en: Automate deployment
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署
- en: One way of achieving this workflow is by using **git**. Since it allows you
    to define hooks for commits and merges, you can add a hook to the central repository
    to test every new commit. If the commit passes, it could be eligible to pass to
    production.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种工作流程的一种方法是使用git。因为它允许你为提交和合并定义钩子，你可以在中央存储库中添加一个钩子来测试每个新的提交。如果提交通过，它可能有资格通过到生产环境。
- en: 'One strategy can be to merge the latest commit that passed all the tests with
    production. This could be every time a commit passes or at specific times. For
    simple applications, this approach is acceptable. But if you have a big user base,
    it can really be risky. Ensure that your test base is really good, and at least
    look and read the commit change log. There are risks that you should know of,
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略是将最新通过所有测试的提交与生产环境合并。这可以是每次提交通过或在特定时间。对于简单的应用程序，这种方法是可以接受的。但如果你有一个庞大的用户群体，这可能会带来真正的风险。确保你的测试基础真的很好，并且至少查看和阅读提交的变更日志。有一些你应该知道的风险，如下：
- en: Your test base might not cover all of your code. This means that there are parts
    of your code that are not tested, which raises uncertainty about its behavior.
    In this case, you should try to cover as much of your code as possible.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的测试基础可能无法覆盖所有代码。这意味着你的代码中有一些部分没有经过测试，这会对其行为产生不确定性。在这种情况下，你应该尽可能覆盖你的代码。
- en: Your test base might not cover all of your use cases. If all of your use cases
    are not described in the tests, they will not be tested in your code. They could
    get handled correctly, but it's still uncertain. So, you should describe all of
    your use cases.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的测试基础可能无法覆盖所有用例。如果你的所有用例都没有在测试中描述，它们将不会在你的代码中进行测试。它们可能会被正确处理，但仍然存在不确定性。因此，你应该描述所有的用例。
- en: There are test cases which aren't easy to describe or even reproduce. You should
    make an effort to avoid these kinds of tests and ensure that you can completely
    rely on tests. Otherwise, you'll need someone to test the application changes
    before they go to production.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些测试用例很难描述甚至重现。你应该努力避免这些类型的测试，并确保你可以完全依赖测试。否则，你需要有人在应用程序变更上线之前进行测试。
- en: Also, it is important to be able to test the application against your production
    database, perhaps the latest backup or a database with replication that you can
    use without compromising the production environment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，能够针对生产数据库进行应用测试也很重要，也许是最新的备份或者具有复制的数据库，可以在不影响生产环境的情况下使用。
- en: Data size always influences your application's performance. If you're just testing
    your modules to check simple use cases, you're not testing the load, but you should.
    Sometimes, your production data can have relationships that you didn't except
    at first. You may think your code doesn't allow those relationships to appear,
    but you may be wrong.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数据大小总是影响你的应用程序的性能。如果你只是测试你的模块来检查简单的用例，你并没有测试负载，但你应该。有时，你的生产数据可能有你一开始没有预料到的关系。你可能认为你的代码不允许这些关系出现，但你可能是错的。
- en: Consider, for example, a hierarchical structure in which you define a parent
    for a certain element. Assume that this descendant can also be a parent of another
    element. What if a third-degree descendant is a parent of an ascendant? This creates
    a loop that you probably don't want but you have to handle. Even if your application
    doesn't allow this loop to appear at first, consider getting the code required
    to protect yourself against it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个层次结构，你为某个元素定义了一个父元素。假设这个后代也可以是另一个元素的父元素。如果一个第三代后代是一个祖先的父元素呢？这会创建一个循环，你可能不希望出现，但你必须处理。即使你的应用程序一开始不允许出现这种循环，也要考虑获取所需的代码来保护自己免受它的影响。
- en: Code coverage
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Having all of your code covered by tests is important to ensure that you're
    really testing everything, or at least everything that is coded. This is not an
    easy task. Conditions and loops in your code create a log of different cases and
    running paths, and some of your code might be triggered only in very specific
    situations. That situation needs to be tested somehow.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试覆盖所有代码对于确保你真正测试了所有东西，或者至少测试了所有编码的东西是很重要的。这并不是一件容易的事。你的代码中的条件和循环会创建许多不同的情况和运行路径，你的一些代码可能只在非常特定的情况下触发。这种情况需要以某种方式进行测试。
- en: Code coverage is a metric used to indicate how much of your code is covered
    by your test suite. A higher metric indicates that your application is more "test
    covered" and can usually be an indication of low bug probability. This metric
    is usually given in percentage values, and 50 percent coverage means that half
    of your code covered by the test suite.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一个指标，用来表示你的代码有多少被你的测试套件覆盖。更高的指标表示你的应用程序更“测试覆盖”，通常可以表示低错误概率。这个指标通常以百分比值给出，50%的覆盖率意味着你的代码有一半被测试套件覆盖。
- en: There are tools that can help you find this value, otherwise it would be impossible
    to calculate it. In a Node.js environment, what the tools usually do is creating
    a replica of your code, in which they change every significant line to get a way
    of counting the number of times the execution passed through that line. Significant
    lines are lines with real code, not comments or empty lines.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以帮助你找到这个值，否则将无法计算它。在Node.js环境中，这些工具通常做的是创建你的代码的副本，然后改变每一行有意义的代码，以便计算执行通过该行的次数。有意义的行是真正的代码行，而不是注释或空行。
- en: There are also online services for doing this. Depending on your application
    license or budget, you might prefer to prepare your test environment locally.
    This is usually not as simple as it might look. You have to create a way of instrumenting
    your code (this is best done on a copy) and running your tests while gathering
    the coverage metrics, and then generate a report.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 也有在线服务可以做到这一点。根据你的应用程序许可证或预算，你可能更喜欢在本地准备你的测试环境。这通常并不像看起来那么简单。你必须创建一种仪器化你的代码的方法（最好在副本上完成），并在收集覆盖度指标的同时运行你的测试，然后生成一个报告。
- en: 'There are several tools for Node.js that you can try. There''s no magic tool,
    and you should see what fits you and your application best. One possible tool
    is `istanbul`. Let''s try it out on our small test example. You''ll see that it''s
    a little tricky, and for a real application, you must automate this process. Let''s
    start by installing the dependencies:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种Node.js工具可以尝试。没有魔法工具，你应该看看哪个最适合你和你的应用程序。一个可能的工具是`istanbul`。让我们在我们的小测试示例上试一试。你会发现这有点棘手，对于一个真正的应用程序，你必须自动化这个过程。让我们从安装依赖开始：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `mocha-istanbul` dependency can be installed locally. The `istanbul` Node.js
    module should be global because it has a command for us to use. Now we can instrument
    our code. Let''s create an instrumented copy:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`mocha-istanbul`依赖项可以在本地安装。`istanbul` Node.js模块应该是全局的，因为它有一个我们可以使用的命令。现在我们可以仪器化我们的代码。让我们创建一个仪器化的副本：'
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now have to change our test suite to use our instrumented version:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须更改我们的测试套件以使用我们的仪器版本：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we just need to run our test suite using the `istanbul` reporter.
    To do this, run `mocha` with the `reporter` parameter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要使用`istanbul`报告者运行我们的测试套件。要做到这一点，使用`reporter`参数运行`mocha`：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Instead of showing a description of the tests, you''ll see a report showing
    how many lines and functions are instrumented in your code and covered by the
    test suite. Here''s an example of the output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不再显示测试的描述，而是显示一个报告，显示代码中有多少行和函数被测试套件覆盖。以下是一个输出的例子：
- en: '![Code coverage](img/4183_06_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![代码覆盖率](img/4183_06_06.jpg)'
- en: 'After this, you should have a folder called `html-report` with an `index.html`
    page inside. Open it in your browser to analyze your test coverage. You should
    see a page similar to the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你应该有一个名为`html-report`的文件夹，里面有一个`index.html`页面。在浏览器中打开它以分析你的测试覆盖率。你应该看到一个类似以下截图的页面：
- en: '![Code coverage](img/4183_06_07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![代码覆盖率](img/4183_06_07.jpg)'
- en: You'll see the `test` folder, and inside, you'll find our original module. Click
    on it and you'll see a coverage report. For each significant line (notice that
    the lines with closing brackets are ignored), you'll have a number associated.
    It corresponds to the number of times the execution passed that line while we
    we're testing. In our case, it's the **1** and **2** columns with a green background.
    It's easy to understand why, seeing that we have only two tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到`test`文件夹，里面有我们的原始模块。点击它，你会看到一个覆盖率报告。对于每一行代码（注意，带有闭合括号的行将被忽略），你会看到一个相关联的数字。这个数字对应着在测试过程中执行通过该行的次数。在我们的案例中，它是**1**和**2**列，带有绿色背景。很容易理解，因为我们只有两个测试。
- en: '![Code coverage](img/4183_06_08.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![代码覆盖率](img/4183_06_08.jpg)'
- en: Benchmark tests
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试
- en: 'Benchmarking is the process of running a set of tools or tests to measure specific
    performance metrics in order to compare them, either with other tools or with
    past tests. The most common benchmark tests for applications are related to two
    similar metrics: time (of an operation) and operations (over a period of time).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试是运行一组工具或测试来测量特定性能指标的过程，以便将它们与其他工具或过去的测试进行比较。应用程序最常见的基准测试与两个类似的指标有关：时间（操作的时间）和操作（一段时间内的操作次数）。
- en: To maintain your application's performance, you need to continuously benchmark
    it. One obvious approach is to use the test suite, where you add specific tests
    just for benchmarking purposes. After checking out the common use cases, you can
    have specific tests where you can ensure that certain operations continue to run
    for a specific target time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用程序的性能，你需要不断地进行基准测试。一个明显的方法是使用测试套件，你可以添加专门用于基准测试的特定测试。在检查常见用例之后，你可以有特定的测试，确保某些操作继续运行一段特定的时间。
- en: Take benchmarking seriously, but don't lose sleep over it! Most of the time,
    when you start your application development, you just don't have the statistics
    to compare with and you don't know what benchmark tests to define.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 认真对待基准测试，但不要为此失眠！大多数情况下，当你开始应用程序开发时，你没有统计数据可以进行比较，也不知道要定义哪些基准测试。
- en: Start by benchmarking simple listings, such as history lists, and ensure that
    they don't perform over the 100-millisecond mark. When creating a more complex
    interface, ensure that its rendering also performs well. People tend to stress
    out if they have to wait for more than half a second for a simple task, and more
    than one or two seconds for a more complex one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从基准测试简单的列表开始，比如历史列表，并确保它们不超过100毫秒。当创建一个更复杂的界面时，确保它的渲染也表现良好。如果人们不得不等待超过半秒钟来完成一个简单的任务，或者超过一两秒来完成一个更复杂的任务，他们往往会感到压力。
- en: These benchmarks are usually done using a copy of the production data, or a
    subset of it if it's too large, in order to ensure that you're benchmarking against
    a good amount of data and not a small set of data on a test environment like your
    personal laptop. You can also perform the test against the production data, but
    I won't recommend it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基准测试通常使用生产数据的副本，或者如果数据太大，则使用其子集，以确保你正在针对大量数据进行基准测试，而不是在测试环境中（比如你的个人笔记本电脑）上的一小组数据。你也可以对生产数据进行测试，但我不建议这样做。
- en: 'For example, using our previous test framework, `mocha` ensures that each test
    runs for less than two seconds. You can change this default timeout for specific
    tests. Let''s try it out with a new test file called `timeout.js`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用我们之前的测试框架，`mocha`确保每个测试运行时间不超过两秒。你可以为特定测试更改这个默认超时时间。让我们尝试一下，使用一个名为`timeout.js`的新测试文件：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''re creating an asynchronous test. This is because we referenced `done`
    in our test function to be called when the test ends. In this case, we''re not
    calling it specifically to force it to fail. Let''s try it, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个异步测试。这是因为我们在测试函数中引用了`done`，以便在测试结束时调用它。在这种情况下，我们没有明确调用它，以强制它失败。让我们试一下，如下所示：
- en: '![Benchmark tests](img/4183_06_09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![基准测试](img/4183_06_09.jpg)'
- en: It is good practice to use timeouts in specific tests where performance is important.
    The normal timeout may be fine for most common tests, but make sure that you analyze
    some specific tests and ensure that they perform within a certain period of time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能重要的特定测试中使用超时是一个好的做法。通常的超时对于大多数常见的测试可能是可以的，但确保你分析一些特定的测试，并确保它们在一定的时间范围内执行。
- en: That timeout can be a performance limit or just a mark to inform you when your
    application is becoming too complex or when your test data is becoming too big
    to be able to keep up that performance. That's when, based on the previous chapter,
    you need to take a look at your environment and analyze your next steps.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 超时可能是性能限制，或者只是一个标记，告诉你当你的应用程序变得太复杂或者测试数据变得太大以至于无法保持性能时。这时，基于前一章的内容，你需要审视你的环境并分析下一步的行动。
- en: 'Test suites such as mocha can also give you other interesting information that
    complements your tests and helps you get a better picture of the behavior of your
    application, such as:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像mocha这样的测试套件还可以为你提供其他有趣的信息，补充你的测试，并帮助你更好地了解应用程序的行为，比如：
- en: Report test durations, even for the tests that are not benchmark tests, this
    will allow you to first make your tests and look at the metrics, and then define
    a good timeout mark.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告测试持续时间，即使对于不是基准测试的测试，这将使你首先进行测试并查看指标，然后定义一个良好的超时标记。
- en: Present test reports. They can be used for quality assurance reports and can
    be saved for later analysis or comparison.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现测试报告。它们可以用于质量保证报告，并且可以保存以供以后分析或比较。
- en: 'Specifically for Node.js applications, `mocha` can provide you with:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于Node.js应用程序，`mocha`可以为你提供：
- en: Memory leak detection, by looking at global variables before and after the tests
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏检测，通过查看测试前后的全局变量
- en: Uncaught exception detection, indicating the test that caused it
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测未捕获的异常，指示引起异常的测试
- en: Seamless asynchronous support
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无缝的异步支持
- en: Node.js debugger support
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js调试器支持
- en: Browser support
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器支持
- en: Analyzing tests
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析测试
- en: Having a test suite is very important. The most important benefit is having
    your application fully tested, or at least as much tested as possible. Creating
    the initial test environment may be a challenge, but it pays off as you keep developing
    your application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个测试套件非常重要。最重要的好处是能够对应用程序进行全面测试，或者至少尽可能多地进行测试。创建初始测试环境可能是一个挑战，但随着应用程序的不断开发，它会得到回报。
- en: 'Performing proper tests ensures that you:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 进行适当的测试可以确保您：
- en: Don't reintroduce old bugs with new features. This can happen even without touching
    the source code and just by making a database change.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在引入新功能时重新引入旧的错误。即使不触及源代码，只是进行数据库更改，也可能发生这种情况。
- en: Can define use cases by defining test cases first (look at [https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development)).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过首先定义测试用例来定义用例（参见[https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development)）。
- en: Can make changes and easily check whether the application keeps behaving as
    expected.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以进行更改，并轻松检查应用程序是否保持预期的行为。
- en: Can check your test coverage and see how it has changed over time.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以检查测试覆盖率，并查看其随时间的变化。
- en: Can create specific tests for newly found bugs and ensure that they don't reappear.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以为新发现的错误创建特定的测试，并确保它们不会再次出现。
- en: Ensure that benchmark tests run under a specific metric.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保基准测试在特定指标下运行。
- en: Getting a proper test suite is similar to having a quality assurance person
    test your application every time you make a change. Moreover, your quality assurance
    person won't be as precise or as fast as your test suite.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个适当的测试套件就像每次进行更改时都有一个质量保证人员测试您的应用程序一样。此外，您的质量保证人员不会像您的测试套件那样精确或快速。
- en: If your application has more developers than just you, make sure that you enforce
    tests passing successfull and a test coverage of a high mark like 90 percent.
    If you automate your coverage tests, you can use the coverage metric as a condition
    to merge new features with production.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序不仅仅是您一个人在开发，确保您强制执行测试通过成功和高达90%的测试覆盖率。如果您自动化了覆盖率测试，您可以将覆盖率指标作为合并新功能与生产的条件。
- en: Make sure that your tests are public in the development group circle, allowing
    everyone to see the work of others. This motivates people to work better, as their
    reputation is public, at least inside the group.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的测试在开发组圈子中是公开的，让每个人都能看到其他人的工作。这激励人们更好地工作，因为他们的声誉是公开的，至少在团队内部是这样。
- en: When there are more people looking at tests, developers can share experiences
    and ask for help upon bumping into failing tests. This reduces the time taken
    to fix a problem and motivates developers to keep the test suite always going.
    It should be a constant goal—to keep the test history clean of failures.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当有更多的人关注测试时，开发人员可以分享经验，并在遇到测试失败时寻求帮助。这减少了解决问题所需的时间，并激励开发人员始终保持测试套件的运行。保持测试历史清除失败应该是一个不断的目标。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: A good, performant application is all about how well it performs. A complete
    test suite ensures that you also perform well in developing and can introduce
    changes fast—changes that can improve performance. The test suite should have
    specific tests for benchmark analysis, with demanding time restrictions. The developers
    should know about them and work hard to keep the tests passing without having
    to lift those restrictions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的、高性能的应用程序取决于其性能。完整的测试套件确保您在开发中也能表现良好，并且可以快速引入改变——这些改变可以提高性能。测试套件应该有专门的测试用于基准分析，具有严格的时间限制。开发人员应该了解这些测试，并努力保持测试通过，而不必解除这些限制。
- en: Use the test suite as a metric for production. Ensure that you merge new changes
    if your test suite covers your application source in at least 90 percent coverage
    and passes all the benchmark tests. Use a separate server for those tests, and
    don't mix tests with production. Keep your production server lean and fast, and
    change it only if you're sure it will keep that way.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试套件用作生产的度量标准。确保如果您的测试套件覆盖了应用程序源代码至少90%并通过了所有基准测试，那么您就可以合并新的更改。为这些测试使用单独的服务器，并且不要将测试与生产混合在一起。保持生产服务器精简和快速，并且只有在确定它将保持这种状态时才进行更改。
- en: In the next chapter, we'll look at bottlenecks—limits that degrade performance—and
    the situations in which you can't do anything about them. You must try hard to
    be ready for them and, if possible, try to attenuate their consequences. The network,
    the server, and the client are some of the factors that introduce bottlenecks.
    Some you can control and minimize, but others… you just have to be ready for them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看瓶颈——降低性能的限制，以及您无法对其做任何事情的情况。您必须努力为它们做好准备，并在可能的情况下尽量减轻其后果。网络、服务器和客户端是引入瓶颈的一些因素。有些你可以控制和最小化，但其他的……你只能为它们做好准备。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他使用都需要版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止，并违反适用法律。保留所有权利。
