- en: Chapter 2. The Ember.Object Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. Ember.Object 模型
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Working with classes and instances
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与类和实例一起工作
- en: Working with computed properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与计算属性一起工作
- en: Working with Ember observers in Ember.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ember.js 中使用 Ember 观察者
- en: Working with bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与绑定一起工作
- en: Using mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混合
- en: Using enumerables with arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组与可枚举一起
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Ember.Object** is the base class for almost every other Ember object. Routes,
    models, views, and components all inherit from Ember.Object. It''s used everywhere
    so it''s important to understand how it works and how it can be used in our application.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ember.Object** 是几乎所有其他 Ember 对象的基类。路由、模型、视图和组件都继承自 Ember.Object。它无处不在，因此了解它的工作方式和如何在我们的应用程序中使用它非常重要。'
- en: Standard JavaScript objects aren't used often in Ember. Ember's object model
    builds on JavaScript objects and adds important features such as observers, mixins,
    computed properties, and initializers. Many of these features are aligned to be
    in the new **ECMAScript** standard.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 JavaScript 对象在 Ember 中不常用。Ember 的对象模型建立在 JavaScript 对象之上，并添加了重要的功能，如观察者、混合、计算属性和初始化器。许多这些功能都与新的
    **ECMAScript** 标准保持一致。
- en: Working with classes and instances
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与类和实例一起工作
- en: Creating and extending classes is a major feature of the Ember object model.
    In this recipe, we'll take a look at how creating and extending objects works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和扩展类是 Ember 对象模型的主要功能之一。在本食谱中，我们将探讨创建和扩展对象的工作方式。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s begin by creating a very simple `Ember` class using `extend()`:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用 `extend()` 创建一个非常简单的 `Ember` 类：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This defines a new `Light` class with a property called `isOn`. `Light` inherits
    properties and behavior from the Ember object, such as initializers, mixins, and
    computed properties.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这定义了一个新的名为 `Light` 的类，它有一个名为 `isOn` 的属性。`Light` 类从 Ember 对象继承属性和行为，例如初始化器、混合和计算属性。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Ember Twiddle tip**'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Ember Twiddle 小贴士**'
- en: At any point of time, you might need to test out small snippets of the Ember
    code. An easy way to do this is to use a website called **Ember Twiddle**. From
    this website, you can create an Ember application and run it in the browser as
    if you were using the Ember CLI. You can even save and share it. It has similar
    tools such as JSFiddle but only for Ember. Check it out at [http://ember-twiddle.com](http://ember-twiddle.com).
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在任何时候，你可能需要测试 Ember 代码的小片段。一个简单的方法是使用一个名为 **Ember Twiddle** 的网站。从这个网站，你可以创建一个
    Ember 应用程序并在浏览器中运行它，就像使用 Ember CLI 一样。你甚至可以保存和分享它。它有类似 JSFiddle 的工具，但仅限于 Ember。在
    [http://ember-twiddle.com](http://ember-twiddle.com) 上查看。
- en: 'Once you have defined a class, you''ll need to be able to create an instance
    of it. You can do this using the `create()` method. We''ll go ahead and create
    an instance of `Light`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你定义了一个类，你需要能够创建它的一个实例。你可以使用 `create()` 方法来做这件事。我们将创建一个 `Light` 的实例：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Accessing properties within the bulb instance
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问灯泡实例内的属性
- en: 'We can access the properties of the `bulb` object using the `set` and `get`
    accessor methods. Let''s go ahead and get the `isOn` property of the `Light` class:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `set` 和 `get` 访问器方法访问 `bulb` 对象的属性。让我们先获取 `Light` 类的 `isOn` 属性：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code will get the `isOn` property from the `bulb` instance.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将从 `bulb` 实例获取 `isOn` 属性。
- en: 'To change the `isOn` property, we can use the `set` accessor method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更改 `isOn` 属性，我们可以使用 `set` 访问器方法：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `isOn` property will now be set to `true` instead of `false`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在 `isOn` 属性将被设置为 `true` 而不是 `false`。
- en: Initializing the Ember object
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化 Ember 对象
- en: The `init` method is invoked whenever a new instance is created. This is a great
    place to put in any code that you may need for the new instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 方法在创建新实例时被调用。这是一个放置任何可能需要为新实例编写的代码的好地方。'
- en: 'In our example, we''ll add an alert message that displays the default setting
    for the `isOn` property:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将添加一个警报消息，显示 `isOn` 属性的默认设置：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As soon as the `Light.create` line of code is executed, the instance will be
    created and **The isON property is defaulted to false** message will pop up on
    the screen.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行了 `Light.create` 这行代码，实例将被创建，并且屏幕上会弹出**“isON 属性默认为 false”**的消息。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Subclass**'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**子类**'
- en: Be aware that you can create subclasses of your objects in Ember. You can override
    methods and access the parent class using the `_super()` keyword method. This
    is done by creating a new object that uses the Ember `extend` method on the parent
    class.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可以在Ember中创建你对象的子类。你可以重写方法并使用`_super()`关键字方法访问父类。这是通过创建一个新的对象来完成的，该对象使用父类的Ember
    `extend`方法。
- en: Another important thing is if you're subclassing a framework class such as `Ember.Component`
    and you override the `init` method, you'll need to make sure that you call `this._super()`.
    If not, the component might not work properly.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个重要的事情是，如果你正在子类化一个框架类，例如`Ember.Component`，并且你重写了`init`方法，你需要确保调用`this._super()`。如果不这样做，组件可能无法正常工作。
- en: Reopening classes
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新打开类
- en: At any time, you can reopen a class and define new properties or methods in
    it. For this, use the `reopen` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，你都可以重新打开一个类并在其中定义新的属性或方法。为此，请使用`reopen`方法。
- en: 'In our previous example, we had an `isON` property. Let''s reopen the same
    class and add a `color` property:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们有一个`isON`属性。让我们重新打开同一个类并添加一个`color`属性：
- en: 'To add the `color` property, we need to use the `reopen()` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加`color`属性，我们需要使用`reopen()`方法：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If needed, you can add static methods or properties using `reopenClass`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，你可以使用`reopenClass`添加静态方法或属性：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can now access the static property `Light.wattage`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以访问静态属性`Light.wattage`。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous examples, we created an Ember object using `extend`. This tells
    Ember to create a new `Ember` class. The `extend` method uses inheritance in the
    Ember.js framework. The `Light` object inherits all the methods and bindings of
    the Ember object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`extend`创建了Ember对象。这告诉Ember创建一个新的`Ember`类。`extend`方法在Ember.js框架中使用继承。`Light`对象继承了Ember对象的所有方法和绑定。
- en: The `create` method also inherits from the Ember object class and returns a
    new instance of this class. The `bulb` object is a new instance of the Ember object
    that we created.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`方法也继承自Ember对象类，并返回该类的新实例。`bulb`对象是我们创建的Ember对象的新实例。'
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: To use the previous examples, we can create our own module and import it to
    our project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面的示例，我们可以创建自己的模块并将其导入到我们的项目中。
- en: 'To do this, create a new file in the `app` folder called `MyObject.js`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，在`app`文件夹中创建一个名为`MyObject.js`的新文件：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a module that we can now import to any file in our Ember application.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个我们可以现在导入到我们的Ember应用程序中任何文件的模块。
- en: 'In the `app` folder, edit the `app.js` file. You''ll need to add the following
    line at the top of the file:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹中，编辑`app.js`文件。你需要在文件顶部添加以下行：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the bottom, before the export, add this line:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导出之前，添加以下行：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will execute the `myObject` function that we created in the `myObject.js`
    file. After running `ember server`, you'll see the `isOn` property defaulted to
    a `false` popup message.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将执行我们在`myObject.js`文件中创建的`myObject`函数。在运行`ember server`之后，你会看到`isOn`属性默认显示为`false`的弹出消息。
- en: Working with computed properties
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算属性
- en: In this recipe, we'll take a look at computed properties and how they can be
    used to display data, even if that data changes as the application is running.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看计算属性以及它们如何用于显示数据，即使这些数据在应用程序运行时发生变化。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create a new Ember.Object and add a computed property to it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Ember.Object并给它添加一个计算属性：
- en: 'Let''s begin by creating a new `description` computed property. This property
    will reflect the status of the `isOn` and `color` properties:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的`description`计算属性。这个属性将反映`isOn`和`color`属性的状态：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now create a new `Light` object and get the computed property `description`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个新的`Light`对象并获取计算属性`description`：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding example creates a computed property that depends on the `isOn`
    and `color` properties. When the `description` function is called, it returns
    a string describing the state of the light.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的示例创建了一个依赖于`isOn`和`color`属性的计算属性。当调用`description`函数时，它返回一个描述灯的状态的字符串。
- en: Computed properties will observe changes and dynamically update whenever they
    occur.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算属性将观察变化，并在它们发生时动态更新。
- en: 'To see this in action, we can change the preceding example and set the `isOn`
    property to `false`. Use the following code to accomplish this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到这个功能的效果，我们可以修改前面的示例并将`isOn`属性设置为`false`。使用以下代码来完成此操作：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The description has been automatically updated and will now display `The yellow
    light is set to true`.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 描述已经自动更新，现在将显示`The yellow light is set to true`。
- en: Chaining the Light object
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接 Light 对象
- en: Ember provides you with a nice feature that allows computed properties to be
    present in other computed properties. In the previous example, we created a `description`
    property that outputted some basic information about the `Light` object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 提供了一个很好的功能，允许计算属性存在于其他计算属性中。在先前的例子中，我们创建了一个 `description` 属性，该属性输出了有关
    `Light` 对象的一些基本信息。
- en: 'Let''s add another property that gives a full description:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个属性，该属性提供完整的描述：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `fullDescription` function returns a string that concatenates the output
    from the description with a new string that displays `age`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fullDescription` 函数返回一个字符串，该字符串将描述的输出与显示 `age` 的新字符串连接起来：'
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, during the instantiation of the `Light` object, we set the
    `age` to `22`. We could have overwritten any property if necessary.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，在 `Light` 对象实例化期间，我们将 `age` 设置为 `22`。如果需要，我们可以覆盖任何属性。
- en: Alias
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名
- en: The `Ember.computed.alias` method allows us to create a property that is an
    alias for another property or object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.computed.alias` 方法允许我们创建一个属性，该属性是另一个属性或对象的别名。'
- en: 'Any call to `get` or `set` will behave as if the changes were made to the original
    property:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `get` 或 `set` 的任何调用都将表现得像是更改了原始属性：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `aliasDescription` alias will display the same text as `fullDescription`
    as it's just an alias of this object. If we made any changes to any properties
    in the `Light` object later, the alias would also observe these changes and be
    computed properly. We'll discuss more about this in the *Working with bindings*
    recipe.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aliasDescription` 别名将显示与 `fullDescription` 相同的文本，因为它只是这个对象的别名。如果我们稍后对 `Light`
    对象中的任何属性进行了更改，别名也会观察这些更改并正确计算。我们将在 *使用绑定* 的配方中进一步讨论这一点。'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Computed properties are built on top of the observer pattern. Whenever an observation
    shows a state change, it recomputes the output. If no changes occur, then the
    result is cached.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性建立在观察者模式之上。每当观察显示状态变化时，它都会重新计算输出。如果没有变化发生，则结果将被缓存。
- en: In other words, computed properties are functions that get updated whenever
    any of their dependent values change. You can use them in much the same way that
    you would use a static property. They are common and useful throughout Ember and
    its codebase.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，计算属性是当它们的依赖值中的任何一个发生变化时都会更新的函数。您可以使用它们的方式与您使用静态属性的方式几乎相同。它们在 Ember 及其代码库中很常见且很有用。
- en: Keep in mind that a computed property will only update if it is in a template
    or function that is being used. If the function or template is not being called,
    nothing will occur. This will help with performance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，计算属性只有在它位于模板或正在使用的函数中时才会更新。如果函数或模板没有被调用，则不会发生任何事情。这将有助于提高性能。
- en: Working with Ember observers in Ember.js
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ember.js 中使用 Ember 观察者
- en: Observers are fundamental to the Ember object model. In the next recipe, we'll
    take our light example, add an observer, and see how it operates.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者是 Ember 对象模型的基础。在下一个配方中，我们将使用我们的灯示例，添加一个观察者，并查看它是如何运行的。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To begin, we''ll add a new observer called `isOnChanged`. This will only trigger
    when the `isOn` property changes:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个名为 `isOnChanged` 的新观察者。它只会在 `isOn` 属性更改时触发：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Ember.observer` `isOnChanged` monitors the `isOn` property. If any changes
    occur to this property, `isOnChanged` is invoked.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Ember.observer` `isOnChanged` 监视 `isOn` 属性。如果此属性发生任何更改，`isOnChanged` 将被调用。'
- en: Note
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Computed properties versus observers**'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**计算属性与观察者**'
- en: At first glance, it might seem that observers are the same as computed properties.
    In fact, they are very different. Computed properties can use `get` and `set`
    methods and can be used in templates. Observers, on the other hand, just monitor
    property changes and cannot be used in templates or be accessed like properties.
    They don't return any values as well. With this said, be careful not to overuse
    observers. In many instances, a computed property is a more appropriate solution.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初看之下，观察者可能看起来与计算属性相同。实际上，它们非常不同。计算属性可以使用 `get` 和 `set` 方法，并且可以在模板中使用。另一方面，观察者只是监视属性变化，不能在模板中使用或像属性一样访问。它们也不返回任何值。因此，请注意不要过度使用观察者。在许多情况下，计算属性是更合适的解决方案。
- en: 'Additionally, if needed, you can add multiple properties to the observer. Just
    use the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果需要，您可以为观察者添加多个属性。只需使用以下代码：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `isAnything` observer is invoked whenever the `isOn` or `color` properties
    change. The observer will fire twice as each property has changed.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`isOn`或`color`属性变化时，`isAnything`观察者会被调用。观察者会触发两次，因为每个属性都发生了变化。
- en: Synchronous issues with the Light object and observers
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Light对象和观察者的同步问题
- en: It's very easy to get observers out of sync. If, for example, a property that
    it observes changes, it will be invoked as expected. After being invoked, it might
    manipulate a property that hasn't been updated yet. This can cause synchronization
    issues as everything happens at the same time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者很容易变得不同步。例如，如果它观察的属性发生变化，它将按预期被调用。调用后，它可能会操作一个尚未更新的属性。由于所有事情都同时发生，这可能导致同步问题。
- en: 'The following example shows this behavior:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例展示了这种行为：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When `isOn` is changed it's not clear if `fullDescription`, a computed property,
    has been updated yet or not. As observers work synchronously, it's difficult to
    tell what has been fired and changed. This can lead to unexpected behavior.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`isOn`发生变化时，不清楚计算属性`fullDescription`是否已经更新。由于观察者同步工作，很难判断已经触发和改变的内容。这可能导致意外的行为。
- en: 'To counter this, it''s best to use the `Ember.run.once` method. This method
    is a part of the Ember `run` loop, which is Ember''s way of managing how code
    gets executed. Reopen the `Light` object and you will see the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，最好使用`Ember.run.once`方法。这是Ember `run`循环的一部分，是Ember管理代码执行的方式。重新打开`Light`对象，你会看到以下内容：
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `checkIsOn` observer calls the `checkChanged` observer using `Ember.run.once`.
    This method gets run only once per `run` loop. Normally, `checkChanged` would
    get fired twice; however, as it's being called using `Ember.run.once`, it outputs
    only once.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`checkIsOn`观察者使用`Ember.run.once`调用`checkChanged`观察者。此方法在每个`run`循环中只运行一次。通常，`checkChanged`会被触发两次；然而，由于它是通过`Ember.run.once`调用的，它只输出一次。'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ember observers are mixins from the `Ember.Observable` class. They work by monitoring
    property changes. When any change occurs, they are triggered. Keep in mind that
    these are not the same as computed properties and cannot be used in templates
    or with getters or setters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ember观察者是来自`Ember.Observable`类的混入。它们通过监控属性变化来工作。当任何变化发生时，它们会被触发。请注意，这些与计算属性不同，不能在模板中使用，也不能与获取器或设置器一起使用。
- en: Working with bindings
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与绑定一起工作
- en: Most frameworks include some sort of binding implementation. Ember is no exception
    and has bindings that can be used with any object. The following recipes explain
    how to use them as well as one-way and two-way binding.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数框架都包含某种绑定实现。Ember也不例外，它有可以与任何对象一起使用的绑定。以下食谱解释了如何使用它们以及单向和双向绑定。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this example, there is a teacher and student Ember object. Each has its own
    set of properties and they both have homeroom. We can share the homeroom by setting
    an alias for the teacher object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个教师和学生Ember对象。每个都有自己的属性集，并且它们都有homeroom。我们可以通过为教师对象设置别名来共享homeroom。
- en: 'Let''s begin by creating a teacher and student `Ember.Object`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个教师和学生`Ember.Object`开始：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The student `homeroom` is `Ember.computed.alias`, which will bind the `homeroom`
    property to `teacher.homeroom`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生`homeroom`是`Ember.computed.alias`，它将`homeroom`属性绑定到`teacher.homeroom`。
- en: 'Next, we''ll instantiate the `teacher` and `student` objects:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实例化`teacher`和`student`对象：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `joey` object has the `homeroom` property set to `avery`, which is the `teacher`
    object that we just created.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`joey`对象将`homeroom`属性设置为`avery`，这是我们刚刚创建的`teacher`对象。'
- en: 'We can now use `console.log` to output our findings:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`console.log`来输出我们的发现：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, whenever the `avery` object changes its `homeroom`, the student
    `joey` `homeroom` changes as well. This is because the homeroom for joey is an
    alias for the teacher, `avery`.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，每当`avery`对象更改其`homeroom`时，学生`joey`的`homeroom`也会改变。这是因为joey的homeroom是教师`avery`的别名。
- en: 'You do not always have to access properties that reference other objects. You
    can bind to anything:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你并不总是需要访问引用其他对象的属性。你可以绑定到任何东西：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The alias points to `name`; therefore, when printing to the console, it shows
    `Erik Hanchett` for both.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 别名指向`name`；因此，当打印到控制台时，它显示`Erik Hanchett`。
- en: Note
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ember has a class called `Ember.Binding`. This is a public class that has very
    similar behavior and functionality as `Ember.computed.alias` and `Ember.computed.oneWay`.
    You should use `Ember.computed.alias` and not `Ember.Binding`. Computed aliases
    are the preferred method of binding in Ember. `Ember.Binding` is still around
    and will probably be deprecated at some point.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember 有一个名为 `Ember.Binding` 的类。这是一个具有与 `Ember.computed.alias` 和 `Ember.computed.oneWay`
    非常相似的行为和功能的公共类。你应该使用 `Ember.computed.alias`，而不是 `Ember.Binding`。计算别名是 Ember 中绑定的首选方法。`Ember.Binding`
    仍然存在，并可能在某个时候被弃用。
- en: One-way binding
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单向绑定
- en: Ember defaults to something called two-way binding. What this means is that
    when properties are changed in the UI, this is updated back in the controller
    or component. On the other hand, one-way binding propagates changes in one direction
    only.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 默认使用一种称为双向绑定的机制。这意味着当 UI 中的属性发生变化时，这些变化会更新回控制器或组件。另一方面，单向绑定只在一个方向上传播变化。
- en: For instance, let's say that we have a `User` object with a `firstName`, `lastName`,
    and `nickName` property. We can use `Ember.computed.oneWay` to create a one-way
    binding for the `firstName` property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个具有 `firstName`、`lastName` 和 `nickName` 属性的 `User` 对象。我们可以使用 `Ember.computed.oneWay`
    为 `firstName` 属性创建一个单向绑定。
- en: 'Let''s see what happens when we try to make a change to it. Create a new user
    object with these properties. Instantiate the object and try changing the properties:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们尝试修改它时会发生什么。创建一个新的用户对象并具有这些属性。实例化对象并尝试更改属性：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can see that `nickName` does not change even though user has been updated.
    You can think of one-way binding like using `Ember.computed.alias`. However, it
    allows you to get values only and not set them. The upstream properties don't
    get changed when using `Ember.computed.oneWay`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，即使用户已经更新，`nickName` 也没有改变。你可以将单向绑定视为使用 `Ember.computed.alias`。然而，它只允许你获取值，而不能设置值。使用
    `Ember.computed.oneWay` 时，上游属性不会发生变化。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ember bindings are used in many parts of the Ember framework. They are derived
    from the `Ember.computed` namespace. In this namespace is the computed alias method.
    A computed alias specifies the path to another object by creating a two-way binding.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 绑定被用于 Ember 框架的许多部分。它们是从 `Ember.computed` 命名空间派生出来的。在这个命名空间中是计算别名方法。计算别名通过创建双向绑定来指定另一个对象的路径。
- en: Binding objects don't update immediately. Ember waits until all the application
    code has finished running before synchronizing all the changes. This prevents
    unneeded overhead of syncing bindings when values are being updated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定对象不会立即更新。Ember 会等待所有应用程序代码运行完毕后再同步所有更改。这防止了在值更新时同步绑定产生不必要的开销。
- en: One-way binding works by information being propagated only one way. Information
    does not get updated in the upstream properties.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 单向绑定通过只单向传播信息来工作。信息不会在上游属性中更新。
- en: Using mixins
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混入
- en: Mixins are a great way of reusing and sharing code in Ember. The following recipes
    go over some basic operations on how to use them in your code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是 Ember 中重用和共享代码的绝佳方式。以下配方将介绍如何在代码中使用它们的一些基本操作。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this recipe, we'll create a common mixin object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个通用的混入对象。
- en: 'Create an Ember mixin object that has a couple of properties and a function:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有一些属性和函数的 Ember 混入对象：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This mixin can be added to any object. For the sake of simplicity, all this
    mixin does is display some text and set the `isEditing` property to `true` if
    the `edit` function is invoked.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个混入可以被添加到任何对象中。为了简单起见，这个混入所做的只是显示一些文本，并在调用 `edit` 函数时将 `isEditing` 属性设置为 `true`。
- en: 'Let''s see what it looks like when we add this object to an object:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当我们把这个对象添加到另一个对象中时它看起来是什么样子：
- en: '[PRE26]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `extend` method present in `Ember.Object` allows for one or more optional
    arguments of the `Ember.Mixin` type. In this example, we added the common mixin
    to the new `Ember.Object` object. We then instantiated this Ember object using
    `create`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Ember.Object` 中存在的 `extend` 方法允许有一个或多个可选的 `Ember.Mixin` 类型的参数。在这个例子中，我们将通用混入添加到新的
    `Ember.Object` 对象中。然后我们使用 `create` 实例化这个 Ember 对象。'
- en: 'All that''s left is to output the contents. Use `console.log` to display each
    property:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的就是输出内容。使用 `console.log` 来显示每个属性：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is what the output will look like. As you can see, we can access any of
    the mixin properties or methods as if the mixin was included in the Ember object
    itself. This is a convenient way of reusing code in your applications.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是输出将看起来像什么。如您所见，我们可以访问mixin的任何属性或方法，就像mixin被包含在Ember对象本身中一样。这是在应用程序中重用代码的一种方便方式。
- en: 'Let''s create another mixin:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个mixin：
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s see how this looks if we add it to an Ember object:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看如果我们将其添加到Ember对象中会是什么样子：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can have access to both the common and `secondMixin` in our object.
    We can use `console.log` to output `secondProperty`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的对象中访问公共的`secondMixin`。我们可以使用`console.log`来输出`secondProperty`：
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Mixins with the Ember CLI
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Ember CLI的mixin
- en: Mixins work very well with the Ember CLI. To start, use the mixin generator
    to create one.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins与Ember CLI配合得非常好。首先，使用mixin生成器创建一个。
- en: 'Make sure that you''re in the application directory, and then type the following
    command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你处于应用程序目录中，然后输入以下命令：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `generator` command creates an `app/mixins` folder and the `common.js` file.
    The `common.js` file is where we will put the code for the mixin.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`generator`命令会创建一个`app/mixins`文件夹和`common.js`文件。`common.js`文件是我们将放置mixin代码的地方。'
- en: 'We''ll use the mixin from the previous example and add it to this file:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用前面的例子中的mixin并将其添加到这个文件中：
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This mixin is exactly the same as the previous example; however, now it's in
    a module that we can import anywhere, including components or controllers.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个mixin与前面的例子完全相同；然而，现在它在一个我们可以导入到任何地方的模块中，包括组件或控制器。
- en: For now, we'll import it to our `app.js` file in the `app` folders directory.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将将其导入到`app`文件夹目录中的`app.js`文件中。
- en: 'First, we''ll need to add the `import` statement to the top of the file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在文件顶部添加`import`语句：
- en: '[PRE33]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This allows us to use the common mixin anywhere in the `app.js` file.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许我们在`app.js`文件的任何地方使用公共mixin。
- en: 'We''ll add the following code to the bottom of the `app/app.js` file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`app/app.js`文件的底部添加以下代码：
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, all the properties and methods in the common mixin are available
    to the object.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，公共mixin中的所有属性和方法都可用于该对象。
- en: 'If we were to add the common mixin to a component, it might look like following
    code. Add this code to the `common-example.js` file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将公共mixin添加到组件中，它可能看起来像以下代码。将此代码添加到`common-example.js`文件中：
- en: '[PRE35]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As always, we must first import the mixin to our component. The path is always
    relative to the directory you're in, therefore, we must use `../mixins/common`
    to find it.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和往常一样，我们必须首先将mixin导入到我们的组件中。路径始终相对于你所在的目录，因此，我们必须使用`../mixins/common`来找到它。
- en: In the component, I added a simple action called `pressed` that triggers the
    mixin `edit` method. If the action gets triggered, we would see the `Starting
    to edit message` in the console. Look for more examples of components in [Chapter
    6](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb "Chapter 6. Ember
    Components"), *Ember Components*.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在组件中，我添加了一个简单的动作`pressed`，它触发mixin的`edit`方法。如果动作被触发，我们将在控制台看到`Starting to edit
    message`。更多组件的例子请参考[第6章](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb
    "第6章。Ember组件")，*Ember组件*。
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Ember.Mixin` class allows the creation of mixins whose properties and methods
    can be added to other classes. They can't be instantiated but they can be added
    or *mixed in*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.Mixin`类允许创建可以将其属性和方法添加到其他类的mixin。它们不能被实例化，但可以被添加或*混合*。'
- en: A mixin in computer science is a class that lends or copies it's behavior to
    a borrowing class using composition instead of inheritance. It encourages code
    reuse and avoids ambiguity that multiple inheritance can cause.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的mixin是一个类，它通过组合而不是继承将其行为借用到借用类中。它鼓励代码重用，并避免了多重继承可能引起的歧义。
- en: Using enumerables with arrays
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组中的可枚举
- en: The `Ember.Enumerable` methods are very important when dealing with arrays.
    In these recipes, we'll look at some common use cases.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数组时，`Ember.Enumerable`方法非常重要。在这些菜谱中，我们将查看一些常见用例。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To understand how to use enumerables, we must first take a look at the standard
    JavaScript array methods and their equivalents using observable enumerables:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用可枚举的，我们首先需要看看标准的JavaScript数组方法和它们使用可观察枚举的等效方法：
- en: '| Standard method | Observable equivalent |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 标准方法 | 可观察的等效方法 |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `unshift` | `unshiftObject` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `unshift` | `unshiftObject` |'
- en: '| `shift` | `shiftObject` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `shift` | `shiftObject` |'
- en: '| `reverse` | `reverseObjects` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `reverse` | `reverseObjects` |'
- en: '| `push` | `pushObject` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `push` | `pushObject` |'
- en: '| `pop` | `popObject` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `pop` | `popObject` |'
- en: We'll be using some of these methods in our examples, so keep in mind what the
    standard and observable equivalents are.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例中使用一些这些方法，所以请记住它们的标准和可观察的等效方法。
- en: 'The `Ember.Enumerable` class has several methods that we can use in our Ember
    applications. Here is the list of the more common methods and what they do:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.Enumerable`类有几个我们可以在我们的Ember应用程序中使用的方法。以下是更常见的方法列表以及它们的作用：'
- en: '| Enumerable method | Definition |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 枚举方法 | 定义 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `forEach` | This iterates through the enumerable, calling the passed function
    on each item |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `forEach` | 这遍历枚举，对每个项调用传递的函数 |'
- en: '| `firstObject` | This returns the first object in a collection |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `firstObject` | 这返回集合中的第一个对象 |'
- en: '| `lastObject` | This returns the last object in a collection |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `lastObject` | 这返回集合中的最后一个对象 |'
- en: '| `map()` | This maps all the items in the enumeration to another value, similar
    to map in JavaScript 1.6 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `map()` | 这会将枚举中的所有项映射到另一个值，类似于JavaScript 1.6中的map |'
- en: '| `mapBy()` | Similar to map, this returns the value of the named property
    on all items on the enumeration |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `mapBy()` | 与map类似，这返回枚举中所有项的命名属性的值 |'
- en: '| `filter` | This returns an array with all of the items in the enumeration
    that the passed function returns true |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 这返回一个数组，包含枚举中传递的函数返回true的所有项 |'
- en: '| `find` | This returns the first item in the array that the method returns
    true |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `find` | 这返回方法返回的第一个数组项 |'
- en: '| `findby` | This returns the first item with a property that matches the passed
    value |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `findby` | 这返回第一个具有与传递的值匹配的属性的项 |'
- en: '| `every` | This returns true only if the passed function returns true for
    every item in the enumeration |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `every` | 这仅在传递的函数对枚举中的每个项返回true时才返回true |'
- en: '| `any` | This returns true only if the passed function returns true for any
    item in the enumeration |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `any` | 这仅在传递的函数对枚举中的任何项返回true时才返回true |'
- en: Many of these methods are similar to their JavaScript counterparts. If you know
    how to use the JavaScript method, you should be able to use the Ember equivalent
    as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些方法与它们的JavaScript对应方法类似。如果您知道如何使用JavaScript方法，您应该能够使用Ember的等效方法。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '`Ember.Enumerables` adds all the nice features of Ember objects to enumerables.
    We''ll take a look at several examples on how to do this. The contents for all
    these recipes are in the `chapter2/example6` folder in the `app.js` file.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.Enumerables`将Ember对象的全部良好特性添加到枚举中。我们将查看几个示例，说明如何做到这一点。所有这些食谱的内容都在`app.js`文件中的`chapter2/example6`文件夹中。'
- en: Using forEach with an array
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组中的forEach
- en: A very common use case for an enumerable is iterating over an array with `forEach`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的一个非常常见的用例是使用`forEach`遍历数组。
- en: 'Create an array of students:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个学生数组：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the `forEach` enumerable to iterate over the array:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach`枚举遍历数组：
- en: '[PRE37]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The console output will show each student''s name in the array:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制台输出将显示数组中的每个学生的姓名：
- en: '[PRE38]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tip
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Template literals**'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**模板字面量**'
- en: Ember is compatible with the latest in ECMAScript 2015\. One neat new feature
    is called template literals or template strings. Template literals are string
    literals that can stretch across multiple lines and include interpolated expressions.
    You can do string interpolation by surrounding variables in your strings, like
    this `${}`. Each variable will be displayed in the string as shown in the preceding
    `forEach` example.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember与最新的ECMAScript 2015兼容。一个很酷的新特性被称为模板字面量或模板字符串。模板字面量是可以在多行中扩展并包含插值表达式的字符串字面量。您可以通过在字符串中包围变量来进行字符串插值，如下所示`${}`。每个变量将按前一个`forEach`示例中所示的方式显示在字符串中。
- en: Using map with an array
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组中的map
- en: The `map` method takes an array, maps each item, and returns a new modified
    array. Let's say that we want to make the student names all in uppercase. We can
    do this using `map`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法接受一个数组，映射每个项，并返回一个新的修改后的数组。假设我们想将学生姓名全部转换为大写。我们可以使用`map`来实现这一点。'
- en: 'Create a list of `students`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`students`列表：
- en: '[PRE39]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first letter is capitalized; however, we want all the letters in uppercase.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个字母需要大写；然而，我们希望所有的字母都大写。
- en: 'Use `map` to convert every item to uppercase:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map`将每个项目转换为大写：
- en: '[PRE40]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Every item in the array has been converted to uppercase. The new `upperCaseStudent`
    array has all the new values.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组中的每个项目都已转换为大写。新的`upperCaseStudent`数组包含所有新值。
- en: 'Use the `forEach` enumerable to iterate through every item in the array and
    display its contents:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach`枚举遍历数组中的每个项目并显示其内容：
- en: '[PRE41]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output displays each name in the new `upperCaseStudent` array:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出显示了新 `upperCaseStudent` 数组中的每个名称：
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using mapBy with an array
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `mapBy` 和一个数组
- en: The `mapBy` enumerable can be used if your array is comprised of objects. From
    each object, we can extract its named properties and return a new array.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数组由对象组成，可以使用 `mapBy` 可枚举来提取每个对象的命名属性并返回一个新数组。
- en: 'Let''s create a teacher and student object:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个教师和学生对象：
- en: '[PRE43]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Each object has one property called `name`:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个对象都有一个名为 `name` 的属性：
- en: Next we'll instantiate each object.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实例化每个对象。
- en: '[PRE44]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Each object is put into a `people` array:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将每个对象放入 `people` 数组中：
- en: We can use `mapBy` to create a new array.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `mapBy` 来创建一个新数组。
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This new array returned has the values from the `name` property from both objects.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新数组返回了两个对象 `name` 属性的值。
- en: Finding the first and last objects in an array
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在数组中查找第一个和最后一个对象
- en: If necessary, we have an easy way to grab the first and last objects in an array.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们有一个简单的方法来获取数组中的第一个和最后一个对象。
- en: 'We''ll begin by creating a student array:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个学生数组：
- en: '[PRE46]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This array has six different students.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个数组有六个不同的学生。
- en: 'Let''s grab the last object in the array:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取数组中的最后一个对象：
- en: '[PRE47]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will display `Susan`, the last object in the array.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示数组中的最后一个对象 `Susan`。
- en: 'Now let''s retrieve the first object in the array:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检索数组中的第一个对象：
- en: '[PRE48]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will display `Erik`, the first item in the array.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示数组中的第一个项目 `Erik`。
- en: 'We can push objects on the array as well:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以将对象推送到数组中：
- en: '[PRE49]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The student `Jeff` has now been added to the list:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学生 `Jeff` 现在已经被添加到列表中：
- en: '[PRE50]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Fun with filters
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用过滤器进行有趣的操作
- en: A very common practice is to take an array and return a filtered list of items.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的做法是取一个数组并返回一个过滤后的项目列表。
- en: 'To begin, create an array of numbers:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个数字数组：
- en: '[PRE51]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Take the `array` and `filter` it, returning only those numbers over `10`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `array` 和 `filter` 结合起来，只返回那些大于 `10` 的数字：
- en: '[PRE52]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use `console.log` to display the new array:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `console.log` 来显示新数组：
- en: '[PRE53]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This new array has numbers only greater then 10 in it.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新数组中只包含大于 `10` 的数字。
- en: Using filterBy with a collection of objects
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `filterBy` 和一组对象
- en: With `filterBy`, you can take a collection of objects and filter it by some
    property.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `filterBy`，你可以通过某些属性过滤一组对象。
- en: 'Create a new `student` object that has a `name` and `grade`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `student` 对象，它有一个 `name` 和 `grade`：
- en: '[PRE54]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the students to a new array:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将学生添加到新数组中：
- en: '[PRE55]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Use `filterBy` to show the students who are seniors:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `filterBy` 来显示高年级学生：
- en: '[PRE56]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This returns an array of students who are seniors.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回一个包含所有高年级学生的数组。
- en: 'We can double-check the output using `forEach`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `forEach` 来双重检查输出：
- en: '[PRE57]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using find to get the first match
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `find` 来获取第一个匹配项
- en: The `find` enumerable works very similarly to `filter` except that it stops
    after finding the first match.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 可枚举与 `filter` 的工作方式非常相似，但它会在找到第一个匹配项后停止。'
- en: 'Create an array of numbers:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数字数组：
- en: '[PRE58]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use `array.find` to retrieve the first number in the list that is over `10`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `array.find` 来检索列表中第一个大于 `10` 的数字：
- en: '[PRE59]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''ll then check the output of the new array:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将检查新数组的输出：
- en: '[PRE60]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The answer is `25` as it's the first number in the list that is over 10.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案是 `25`，因为它是列表中第一个大于 `10` 的数字。
- en: Using findBy with collections
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `findBy` 和集合
- en: The `findBy` enumerable works very similarly to `filterBy` except that it stops
    after finding the first match.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`findBy` 可枚举与 `filterBy` 的工作方式非常相似，但它会在找到第一个匹配项后停止。'
- en: 'Create a new `student` object:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `student` 对象：
- en: '[PRE61]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, create an array of students:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个学生数组：
- en: '[PRE62]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use `findBy` to match only the properties that have `grade` of `senior`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `findBy` 来匹配只有 `grade` 为 `senior` 的属性：
- en: '[PRE63]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will return the first student who is a senior:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将返回第一个高年级学生：
- en: '[PRE64]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`Jen Smith` is the first student who matches this criteria so it is returned
    to the `newStudent` array.'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Jen Smith` 是第一个符合这个标准的学生，因此它被返回到 `newStudent` 数组中。'
- en: Learning with the every enumerable
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `every` 可枚举来学习
- en: The `every` enumerable will return `true` only if every item matches a certain
    condition.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`every` 可枚举只有在每个项目都符合某个特定条件时才会返回 `true`。'
- en: 'Begin by creating an array of numbers:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建一个数字数组：
- en: '[PRE65]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the `every` enumerable to check whether every item in the array is greater
    than `10`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `every` 可枚举来检查数组中的每个项目是否大于 `10`：
- en: '[PRE66]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This returns `true` because every item in the array is over `10`
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这返回 `true`，因为数组中的每个项目都大于 `10`。
- en: Using any to find at least one match
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `any` 来找到至少一个匹配项
- en: The `any` enumerable will return `true` if at least one item matches a certain
    condition.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 可枚举将在至少有一个项目符合某个条件时返回 `true`。'
- en: 'Once again, create a list of numbers:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次创建一个数字列表：
- en: '[PRE67]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Use the `any` enumerable to check whether any of these numbers in this array
    are over `10`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `any` 可枚举来检查这个数组中的这些数字是否超过 `10`：
- en: '[PRE68]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This will return `true` because at least one number is above `10`.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回 `true`，因为至少有一个数字超过了 `10`。
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Ember.Enumerable` mixin is Ember's implementation of the array API defined
    up to JavaScript 1.8\. It's applied automatically on page load so any method is
    available. In order for Ember to be able to observe changes in an enumerable,
    you must use `Ember.Enumerable`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.Enumerable` 混合是 Ember 对 JavaScript 1.8 之前定义的数组 API 的实现。它在页面加载时自动应用，因此任何方法都是可用的。为了使
    Ember 能够观察可枚举的变化，你必须使用 `Ember.Enumerable`。'
- en: The enumerable API follows ECMAScript specifications as much as possible so
    it minimizes incompatibilities with the other libraries. It uses native browser
    implementations in arrays where available.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可枚举 API 尽可能遵循 ECMAScript 规范，以最小化与其他库的不兼容性。在可用的情况下，它使用原生的浏览器实现。
