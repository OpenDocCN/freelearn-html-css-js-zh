- en: Chapter 8. Adding Physics to Your Games Using the Chipmunk2D Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用Chipmunk2D引擎给你的游戏添加物理
- en: In the previous chapter, you saw how to add physics to your games using Box2D.
    However, Box2D isn't the only physics engine supported by Cocos2d-JS; you can
    also feature physics in your games using the Chipmunk2D engine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了如何使用Box2D给你的游戏添加物理。然而，Box2D并不是Cocos2d-JS支持的唯一物理引擎；你还可以使用Chipmunk2D引擎在你的游戏中添加物理特性。
- en: 'So the main question is: should you use Box2D or Chipmunk2D to add physics
    to your games? There isn''t a right answer. Just use the one you feel the most
    comfortable with.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所以主要问题是：你应该使用Box2D还是Chipmunk2D来给你的游戏添加物理？没有正确答案。只需使用你感觉最舒适的一个。
- en: That's why, in this chapter, I will show you how to create the same Totem Destroyer
    game using Chipmunk2D, highlighting the similarities and differences between the
    two physics engines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我将向你展示如何使用Chipmunk2D创建相同的Totem Destroyer游戏，突出两个物理引擎之间的相似之处和不同之处。
- en: 'As you saw in the previous chapter, it''s time to learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，现在是时候学习了：
- en: Configuring Cocos2d-JS to add Chipmunk2D engine to your games
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Cocos2d-JS以将Chipmunk2D引擎添加到你的游戏中
- en: Creating a physics space with gravity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有重力的物理空间
- en: Combining bodies and shapes to create a physics object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将刚体和形状组合以创建物理对象
- en: Creating a material
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建材料
- en: Creating static objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建静态对象
- en: Creating dynamic objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态对象
- en: Attaching sprites to physics objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵附加到物理对象上
- en: Selecting physics objects with the mouse or finger
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标或手指选择物理对象
- en: Destroying physics objects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁物理对象
- en: Checking for collisions among objects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查物体之间的碰撞
- en: Running the physics simulation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行物理模拟
- en: Using debug draw to test your projects
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试绘图来测试你的项目
- en: I assume you are quite familiar with basic Box2D concepts discussed in the previous
    chapter, so I will move on rather fast in the creation of the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你对上一章中讨论的基本Box2D概念相当熟悉，所以我在创建游戏时会快速进行。
- en: Adding the Chipmunk2D engine to your project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Chipmunk2D引擎添加到你的项目中
- en: As we will create the same game as the one in the previous chapter, I suggest
    you copy your project into a new folder since we will reuse most of the code already
    written in the previous chapter. All graphic assets will not change, so simply
    don't touch the `assets` folder. The same thing goes for the `loadassets.js`,
    `main.js` and `project.json` files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将创建与上一章相同的游戏，我建议你将你的项目复制到一个新文件夹中，因为我们将在上一章中已经编写的代码中重用大部分。所有图形资产都不会改变，所以只需不要触摸`assets`文件夹。对于`loadassets.js`、`main.js`和`project.json`文件也是如此。
- en: So basically, the only file we will change is `gamescript.js`. Get ready to
    dive into the Chipmunk2D world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，我们唯一要更改的文件是`gamescript.js`。准备好深入Chipmunk2D的世界。
- en: A physics game, without physics
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个没有物理的物理游戏
- en: As we already built the Totem Destroyer game prototype, we can strip all the
    physics parts out of it and leave just the bare bones, where we will build the
    new physics engine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经构建了Totem Destroyer游戏原型，我们可以从中移除所有物理部分，只留下骨架，在那里我们将构建新的物理引擎。
- en: 'The physics-stripped version of `gamescript.js` is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`gamescript.js`去物理版本如下：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, everything is ready to inject Chimpunk2D physics into the game. Let's start
    from the beginning and create the physics world.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切准备就绪，可以将Chimpunk2D物理引擎注入到游戏中。让我们从头开始，创建物理世界。
- en: Configuring the physics space
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置物理空间
- en: Look at the heading. It says **Configuring the physics space**. I used *space*
    rather than *world* because Chipmunk2D calls *space* what Box2D calls *world*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 看看标题。它说**配置物理空间**。我使用*space*而不是*world*，因为Chipmunk2D称*space*为Box2D所称的*world*。
- en: 'Both world and space represent the same thing: the place where physics-driven
    things happen.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 世界和空间代表同一件事：物理驱动事件发生的地方。
- en: Although Chipmunk2D calls it *space*, we will continue to use a variable called
    *world* to keep as much similarity with Box2D code as we can. This is the best
    way for you to see the similarities and differences between the two engines.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Chipmunk2D称之为*space*，但我们将继续使用名为*world*的变量，以尽可能多地与Box2D代码保持相似。这是你看到两个引擎相似之处和不同之处的最佳方式。
- en: 'Change the `init` function in game declaration as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更改游戏声明中的`init`函数：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, create the `world` global variable at the very beginning of the script:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在脚本的最开始创建`world`全局变量：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s see what happens when the following line is executed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当执行以下行时会发生什么：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `cp.Space` method creates the Chipmunk2D space; by now, you should know
    this is the same as the Box2D world:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp.Space` 方法创建 Chipmunk2D 空间；到现在你应该知道这与 Box2D 世界相同：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `gravity` property sets `world gravity` with a vector. `cp.v` is how Chipmunk2D
    represents vectors, in the same way as Box2D uses `b2Vec2`. There's a horizontal
    and a vertical component and, to simulate earth gravity, you can use `(0,-100)`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`gravity` 属性使用向量设置 `world gravity`。`cp.v` 是 Chipmunk2D 表示向量的方式，与 Box2D 使用 `b2Vec2`
    的方式相同。它有一个水平和垂直分量，要模拟地球重力，可以使用 `(0,-100)`。'
- en: Unlike Box2D, Chipmunk2D does not use real-world units of measurements, so expect
    to use pixels rather than meters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Box2D 不同，Chipmunk2D 不使用现实世界的测量单位，所以请期待使用像素而不是米。
- en: Adding bodies to the space
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向空间添加物体
- en: 'We already have the `addBody` function with all required arguments, so it''s
    time to define it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了带有所有必需参数的 `addBody` 函数，所以是时候定义它了：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is where big differences between Box2D and Chipmunk2D start to show. Thus,
    we will explain the `addBody` function line-by-line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Box2D 和 Chipmunk2D 之间的大差异开始显现的地方。因此，我们将逐行解释 `addBody` 函数：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have two ways to create a body, irrespective of whether it's static or dynamic.
    Both use the `cp.Body` method, whose arguments are the mass and the moment of
    inertia. The moment of inertia is the mass property of a rigid body that determines
    the torque needed for a desired angular acceleration about an axis of rotation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种创建物体的方式，无论它是静态的还是动态的。两者都使用 `cp.Body` 方法，其参数是质量和惯性矩。惯性矩是刚体质量属性，它决定了围绕旋转轴所需的扭矩以实现所需的角加速度。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, visit the Wikipedia article at [http://en.wikipedia.org/wiki/Moment_of_inertia](http://en.wikipedia.org/wiki/Moment_of_inertia),
    which explains it very clearly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问维基百科上的文章 [http://en.wikipedia.org/wiki/Moment_of_inertia](http://en.wikipedia.org/wiki/Moment_of_inertia)，它解释得非常清楚。
- en: When a body is dynamic, I set the mass to `1`, but it could be any positive
    finite number, and the moment of inertia is a result of the calculation of the
    mass, the width, and the height by the `momentForBox` method, which does the hard
    work for us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个物体是动态的，我会将其质量设置为 `1`，但它可以是任何正的有限数，惯性矩是质量、宽度和高度通过 `momentForBox` 方法计算的结果，这个方法为我们做了繁重的工作。
- en: 'So, a box with *mass = 1* will be declared this way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个质量为 *1* 的盒子可以这样声明：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While a box with mass 15 will be declared, replacing 1 with 15 in this way:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明一个质量为 15 的盒子时，可以这样替换 1 为 15：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, for a dynamic body, the mass can be set to any positive number.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于动态物体，质量可以设置为任何正数。
- en: On the other hand, when dealing with static bodies, you must set both the mass
    and the moment of inertia to an infinite number, which JavaScript represents with
    infinity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当处理静态物体时，你必须将质量和惯性矩都设置为无限大，JavaScript 使用无限大来表示。
- en: 'Once the body is created, you need to give it a position in the space:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了物体，你需要给它一个空间中的位置：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `setPos` method places it on the space using pixel coordinates. As you can
    see, `cp.v` arguments are the actual pixel coordinates you set when you call the
    `addBody` function with no conversions between units of measurement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPos` 方法使用像素坐标将其放置在空间中。正如你所看到的，`cp.v` 参数是你调用 `addBody` 函数时设置的像素坐标，无需进行单位转换。'
- en: If you remember, in the Box2D chapter, you needed to convert meters to pixels.
    However, Chipmunk2D works directly in pixels.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在 Box2D 章节中，你需要将米转换为像素。然而，Chipmunk2D 直接在像素中工作。
- en: 'Now, it''s time to add the body to the space:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将物体添加到空间中了：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `addBody` method adds a body to the space. You are probably wondering why
    I am adding the body to it only if it's dynamic. Once a body has been defined
    as static with infinite mass and a moment of inertia, there's no need to add it
    to the space unless you plan to move it manually during the game (think about
    a moving platform, which is not the case with our solid ground), because you will
    only add its collision shape.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`addBody` 方法将一个物体添加到空间中。你可能想知道为什么我只在它是动态的情况下将其添加到空间中。一旦一个物体被定义为具有无限质量和惯性矩的静态物体，除非你计划在游戏过程中手动移动它（例如一个移动的平台，这与我们的固体地面不同），否则不需要将其添加到空间中，因为你只会添加它的碰撞形状。'
- en: 'What is a body collision shape? You are about to discover it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是一个物体的碰撞形状？你即将发现它：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Pretty much like Box2D, Chipmunk2D works with bodies and shapes, where bodies
    represent abstract physics entities, and shapes are actual pieces of physics matter
    attached to bodies. In Box2D, we also use fixtures as glue between a body and
    a shape while, in Chipmunk2D, this is not necessary: we can directly create a
    shape and attach it to a body.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大概和Box2D一样，Chipmunk2D使用物体和形状工作，其中物体代表抽象的物理实体，而形状是附加到物体上的实际物理物质。在Box2D中，我们使用固定件作为物体和形状之间的粘合剂，而在Chipmunk2D中，这并不是必要的：我们可以直接创建一个形状并将其附加到物体上。
- en: 'Let''s create the shape then:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建形状然后：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `cp.BoxShape` method creates the shape, gives a width, height, and a body
    to attach the shape to `setFriction`, and `setElasticity` defines the shape material,
    which is referred to as elasticity as Box2D's restitution. I am also giving the
    shape a name; then the `addShape` method adds the shape to the space.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp.BoxShape`方法创建形状，设置宽度、高度，并将形状附加到`setFriction`和`setElasticity`定义的形状材料上，这被称为弹性，类似于Box2D的恢复系数。我还为形状赋予了一个名称；然后`addShape`方法将形状添加到空间中。'
- en: Now, all these shapes and bodies should be ready to be processed by the Chipmunk2D
    space, so it's time to see how to run the simulation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些形状和物体都应该准备好由Chipmunk2D空间处理，所以是时候看看如何运行模拟了。
- en: Updating Chipmunk2D space and using debug draw
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新Chipmunk2D空间和使用debug draw
- en: 'To update the Chipmunk2D space, just call the `step` method in the update function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新Chipmunk2D空间，只需在更新函数中调用`step`方法：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will make the simulation advance by the `dt` time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使模拟前进`dt`时间。
- en: Okay, now run the project and you will see just the background gradient. Did
    we miss something?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在运行项目，你会看到只有背景渐变。我们遗漏了什么吗？
- en: Like Box2D, Chipmunk2D does not draw the space; it simply computes it and leaves
    us the job of rendering it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与Box2D类似，Chipmunk2D不绘制空间；它只是计算它，并留给我们渲染它的任务。
- en: Anyway, to make quick and simple tests, there's a feature called debug draw
    (also included in Box2D), although I did not show you how to reduce the page count,
    which allows you to render the space without having actual graphic assets attached
    to bodies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，为了快速简单的测试，有一个名为debug draw的功能（也包含在Box2D中），尽管我没有向你展示如何减少页面数量，这允许你在没有将实际图形资产附加到物体上时渲染空间。
- en: 'Change the `init` function this way:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样修改`init`函数：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These three lines will create a debug draw layer with the `cc.PhysicsDebugNode.create`
    method, which is later added to the stage.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条线将使用`cc.PhysicsDebugNode.create`方法创建一个debug draw层，稍后将其添加到舞台中。
- en: 'Run the project now:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行项目：
- en: '![Updating Chipmunk2D space and using debug draw](img/0075SOS_08_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![更新Chipmunk2D空间和使用debug draw](img/0075SOS_08_01.jpg)'
- en: Also, here are our dynamic totem pieces and our static background rendered with
    debug draw. `PhysicsDebug` will iterate through the shapes and constraints in
    space, and draw them with the default color. Now, we can continue adding features
    to the game and add actual graphic assets once the game is completed. This will
    save developing time because, if something does not work as it should, then we
    can use debug draw to see whether Chipmunk2D bodies position-match the graphic
    assets position.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里是我们用debug draw渲染的动态图腾碎片和静态背景。`PhysicsDebug`将遍历空间中的形状和约束，并以默认颜色绘制它们。现在，我们可以在游戏完成后继续添加功能，并添加实际的图形资产。这将节省开发时间，因为如果某些东西没有按预期工作，我们可以使用debug
    draw来查看Chipmunk2D物体的位置是否与图形资产的位置匹配。
- en: Selecting and destroying space bodies
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和摧毁空间物体
- en: 'The player must be able to destroy certain bodies: the ones called with the
    `destroyable` name by clicking or tapping over them. Thus, this is the complete
    `touchListener` declaration:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家必须能够摧毁某些物体：通过点击或轻触名为`destroyable`的物体来摧毁它们。因此，这是完整的`touchListener`声明：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before commenting on it, I will explain to you another way to iterate through
    all these bodies or shapes in the space.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在评论它之前，我将向你解释另一种遍历空间中所有这些物体或形状的方法。
- en: Do you remember body selection in Box2D? We looped through all world bodies
    using the `GetBodyList()` function. That's one way to do it. However, there are
    other ways; since I want to show you as many features as possible, this time we'll
    loop through shapes without using any Chipmunk2D proprietary function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得Box2D中的物体选择吗？我们使用`GetBodyList()`函数遍历所有世界物体。这是其中一种方法。然而，还有其他方法；既然我想尽可能多地展示功能，这次我们将遍历形状而不使用任何Chipmunk2D专有函数。
- en: 'We can just add another global variable called `shapeArray`, an empty array:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加另一个全局变量，称为`shapeArray`，一个空数组：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, in the `addBody` function, once we add a shape to the space, we append
    it to `shapeArray`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `addBody` 函数中，一旦我们将形状添加到空间中，我们就将其追加到 `shapeArray`：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once we have all the shapes in `shapeArray`, it's easy to loop through them
    and see whether the clicked or touched point is inside one of them thanks to `pointQuery`,
    whose argument is a vector with stage coordinates. If it does not return `undefined`,
    it means the point is inside the given shape.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `shapeArray` 中的所有形状，就很容易通过循环遍历它们，并使用 `pointQuery`（其参数是一个具有舞台坐标的向量）来查看点击或触摸的点是否在它们之中。如果它不返回
    `undefined`，则意味着该点在给定的形状内。
- en: Then, the `removeBody` and `removeShape` space's methods delete the shape and
    the body, respectively. Remember to manually splice `shapeArray` when you remove
    something.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`removeBody` 和 `removeShape` 空间方法分别删除形状和物体。记得在删除东西时手动修改 `shapeArray`。
- en: 'Want to see whether this works? Just run the project and click on a destroyable
    brick:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 想看看这行不行？只需运行项目并点击可摧毁的砖块：
- en: '![Selecting and destroying space bodies](img/0075SOS_08_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![选择和销毁空间物体](img/0075SOS_08_02.jpg)'
- en: Watch out! It's falling bricks!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！这是掉落的砖块！
- en: This reminds me of two things. First, this is not the best way to solve the
    level. Second, we have to detect when the idol hits the ground.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起了两件事。首先，这不是解决关卡的最佳方式。其次，我们必须检测偶像何时撞击地面。
- en: Checking for collisions among bodies
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查物体之间的碰撞
- en: In the previous chapter, to check for collision, we iterated through idol contact
    points to see when it hit the ground.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，为了检测碰撞，我们遍历了偶像接触点以查看何时撞击地面。
- en: Both Box2D and Chipmunk2D have more interesting ways to check for collisions,
    as they handle collision listeners.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 和 Chipmunk2D 都有更有趣的方式来检查碰撞，因为它们处理碰撞监听器。
- en: 'Add the highlighted line to the `init` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将高亮行添加到 `init` 函数中：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With just one single line, we entered the world of collision listeners. The
    different types of listeners that can be used are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只用一行代码，我们就进入了碰撞监听器的世界。可以使用以下不同类型的监听器：
- en: '`setDefaultCollisionHandler`: This method will call four functions each time
    a collision will be updated. In Chipmunk2D as well as in Box2D, a collision has
    four states:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDefaultCollisionHandler`: 每当碰撞更新时，此方法将调用四个函数。在 Chipmunk2D 以及 Box2D 中，碰撞有四种状态：'
- en: '`begin`: This method defines the time the script realizes that two shapes are
    touching.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin`: 此方法定义脚本意识到两个形状接触的时间。'
- en: '`preSolve`: This method is called just before solving the collision. To solve
    a collision means to update shapes and bodies according to the collision itself.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preSolve`: 在解决碰撞之前调用此方法。解决碰撞意味着根据碰撞本身更新形状和物体。'
- en: '`postSolve`: This method is called just after solving the collision.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postSolve`: 在解决碰撞后调用此方法。'
- en: '`separate`: This method is called when the collision ceases to exist—that is,
    these two shapes are no longer in touch.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`separate`: 当碰撞不再存在时，即这两个形状不再接触时，会调用此方法。'
- en: 'We just need to check when the collision begins; that''s why I am passing `collisionBegin`
    as the first argument, leaving other arguments to `null`. The `collisionBegin`
    function is very simple:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要检查碰撞何时开始；这就是为什么我将 `collisionBegin` 作为第一个参数传递，将其他参数留为 `null`。`collisionBegin`
    函数非常简单：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I am just checking whether the first shape: `arbiter.a` is called `totem`,
    and the second shape: `arbiter.b` is called `ground` or vice versa to output a
    console message.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是检查第一个形状：`arbiter.a` 是否被称作 `totem`，第二个形状：`arbiter.b` 是否被称作 `ground` 或反之，以输出控制台信息。
- en: You also have to return `true`, or the collision will be ignored.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须返回 `true`，否则碰撞将被忽略。
- en: 'Run the project, and when the totem touches the ground this way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，当图腾以这种方式接触地面时：
- en: '![Checking for collisions among bodies](img/0075SOS_08_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![检查物体之间的碰撞](img/0075SOS_08_03.jpg)'
- en: 'You will see this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到这个：
- en: '**Oh no!!!!**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**哦不！！！**'
- en: Finally, we completed all the game mechanics of our Totem Destroyer prototype.
    We just have to add our graphic assets to the game.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了 Totem Destroyer 原型的所有游戏机制。我们只需将我们的图形资源添加到游戏中。
- en: Did you notice? We are completing a project by adding graphic assets whereas,
    in the previous chapter, we started by adding them. This is one of the things
    I love about programming. Your choices are unlimited.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到吗？我们通过添加图形资源来完成项目，而在上一章中，我们是先添加它们的。这是我喜欢编程的原因之一。你的选择是无限的。
- en: Using your own graphic assets
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用你自己的图形资源
- en: Just as in the previous chapter, we will add graphics when we add a body, then
    update their position and rotation according to its body position and rotation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一章中一样，当我们添加身体时，我们会添加图形，然后根据其身体位置和旋转更新它们的位置和旋转。
- en: 'First, update the `addBody` function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新`addBody`函数：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This works in the same way as we saw with Box2D: a sprite is added to the game
    and is saved in a custom shape attribute—in this case, `image`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在Box2D中看到的方式相同：精灵被添加到游戏中，并保存在自定义形状属性中——在这种情况下，`image`。
- en: 'To update the sprite''s position in the `update` function, we need to loop
    through all shapes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`update`函数中更新精灵的位置，我们需要遍历所有形状：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We loop through our custom variable, `shapeArray`, and update each shape image
    according to its body position and rotation. While it's very easy to get a body
    position with the `p` property, Chipmunk2D does not return a body rotation in
    degrees or radians, but with a vector; you can get its position with the `rot`
    property. That's why I am using the `atan2` method to get an angle from a vector;
    then I multiply it by `57.2957795` to turn radians into degrees.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历我们的自定义变量`shapeArray`，并根据其身体位置和旋转更新每个形状图像。虽然使用`p`属性获取身体位置非常简单，但Chipmunk2D不返回以度或弧度为单位的角度，而是以向量形式返回；你可以使用`rot`属性获取其位置。这就是为什么我使用`atan2`方法从向量中获取角度；然后我将它乘以`57.2957795`将弧度转换为度。
- en: 'Also, don''t forget to manually remove a sprite when you remove its body:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，别忘了在移除其身体时手动移除精灵：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the project and see your custom graphics in action:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并查看您的自定义图形效果：
- en: '![Using your own graphic assets](img/0075SOS_08_04.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![使用您自己的图形资源](img/0075SOS_08_04.jpg)'
- en: At this time, you can remove debug draw graphics; this leaves you with the same
    game made with two different physics engines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你可以移除调试绘图图形；这让你有了使用两个不同物理引擎制作的相同游戏。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let me congratulate you; you not only made a Totem Destroyer game, but you were
    also able to make it using two different physics engines. Not all developers out
    there are able to do it. Now, add to the game the same improvement you added to
    the Box2D game because you improved the game, didn't you? Let's start the last
    chapter, where you will create a blockbuster game in a matter of minutes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我恭喜你；你不仅制作了一个图腾破坏者游戏，而且你还能够使用两个不同的物理引擎来制作它。并不是所有的开发者都能做到这一点。现在，将你在Box2D游戏中添加的相同改进添加到游戏中，因为你已经改进了游戏，不是吗？让我们开始最后一章，在那里你将在几分钟内创建一个大片游戏。
