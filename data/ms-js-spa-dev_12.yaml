- en: Chapter 12. Connecting the App to Social Media
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。将应用连接到社交媒体
- en: Many web applications use third-party authentication for registering and logging
    in. In particular, using popular social media sites such as Facebook and Twitter
    to authenticate users has become very popular. Since these sites have already
    done some work to validate users, sites using them to authenticate users save
    a some time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络应用使用第三方身份验证进行注册和登录。特别是，使用像 Facebook 和 Twitter 这样的流行社交媒体网站来验证用户已经变得非常流行。因为这些网站已经对用户进行了某些验证工作，所以使用它们来验证用户可以节省一些时间。
- en: In this chapter, we are going to set up Passport strategies to sign up and authenticate
    users using their Facebook and Twitter accounts. We're going to be using a popular
    protocol called OAuth 2.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置 Passport 策略，使用 Facebook 和 Twitter 账户注册和验证用户。我们将使用一个流行的协议，称为 OAuth
    2。
- en: 'Additionally, we''re going to finish building out the functionality for users
    to create and share gift lists. In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将完成构建用户创建和分享礼物清单的功能。在本章中，我们将涵盖以下内容：
- en: Authenticating users with Facebook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Facebook 验证用户
- en: Authenticating users with Twitter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Twitter 验证用户
- en: Handling gift list creation in the dashboard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仪表板中处理礼物清单创建
- en: Adding share buttons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加分享按钮
- en: Connecting to Facebook
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 Facebook
- en: We are going to begin integration with social media by allowing users to create
    accounts and log in using their Facebook accounts. The first things we need to
    do are to set up a Facebook developer account and build a Facebook app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过允许用户使用他们的 Facebook 账户创建账户和登录来开始与社交媒体的集成。我们需要做的第一件事是设置一个 Facebook 开发者账户并构建一个
    Facebook 应用。
- en: Setting up your Facebook developer account and app
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的 Facebook 开发者账户和应用
- en: In order to authenticate users using Facebook, you have to have a Facebook app.
    Fortunately, Facebook makes setting this up really easy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Facebook 验证用户，你必须有一个 Facebook 应用。幸运的是，Facebook 使设置这一点变得非常简单。
- en: 'If you do not have a Facebook developer account, head over to [https://developers.facebook.com/](https://developers.facebook.com/)
    right now and sign up for a developer account. Just follow the instructions and
    agree to the terms of service. Next, we need to set up an app. From the developers''
    dashboard, select **Add** **New App** from the **My Apps** dropdown. You''ll get
    a modal window that looks like the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 Facebook 开发者账户，请立即访问[https://developers.facebook.com/](https://developers.facebook.com/)并注册一个开发者账户。只需遵循说明并同意服务条款。接下来，我们需要设置一个应用。从开发者仪表板中，选择**我的应用**下拉菜单中的**添加新应用**。你将得到一个类似于以下截图的模态窗口：
- en: '![Setting up your Facebook developer account and app](img/image_12_001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的 Facebook 开发者账户和应用](img/image_12_001.jpg)'
- en: 'Select **Website**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**网站**：
- en: '![Setting up your Facebook developer account and app](img/image_12_002.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的 Facebook 开发者账户和应用](img/image_12_002.jpg)'
- en: 'Give your new app a name and select **Create New Facebook App ID**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的新应用起一个名字，并选择**创建新的 Facebook App ID**：
- en: '![Setting up your Facebook developer account and app](img/image_12_003.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的 Facebook 开发者账户和应用](img/image_12_003.jpg)'
- en: 'Choose a category for your new app (any one will do, really). Make sure to
    leave off the selection for **Is this a test version of another app?** Then click
    **Create App ID**:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的新应用选择一个类别（实际上任何类别都可以）。确保不要选择**这是另一个应用的测试版本吗？**选项。然后点击**创建 App ID**：
- en: '![Setting up your Facebook developer account and app](img/image_12_004.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的 Facebook 开发者账户和应用](img/image_12_004.jpg)'
- en: 'From here, I suggest you select **Skip Quick Start** and we''ll set up your
    application manually. On the next screen, select **Settings**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我建议你选择**跳过快速入门**，我们将手动设置你的应用程序。在下一屏幕上，选择**设置**：
- en: '![Setting up your Facebook developer account and app](img/image_12_005.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的 Facebook 开发者账户和应用](img/image_12_005.jpg)'
- en: 'You''ll need to enter your e-mail address here and click **Save Changes**.
    Next, click on **App Review**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在这里输入你的电子邮件地址并点击**保存更改**。接下来，点击**应用审核**：
- en: '![Setting up your Facebook developer account and app](img/image_12_006.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的 Facebook 开发者账户和应用](img/image_12_006.jpg)'
- en: 'Select **Yes** for **Do you want to make this app and all its live features
    available to the general public?** Next, go back to your dashboard:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**你希望将此应用及其所有实时功能提供给公众吗？**选择**是**。然后返回到你的仪表板：
- en: '![Setting up your Facebook developer account and app](img/image_12_007.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![设置你的 Facebook 开发者账户和应用](img/image_12_007.jpg)'
- en: You're going to need your App ID and App Secret values. Facebook will force
    you to enter your password to show your App Secret.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要你的 App ID 和 App Secret 值。Facebook 将强制你输入密码以显示你的 App Secret。
- en: '**App Secret** is exactly that - secret. You should protect it and not do anything
    like check it into public source control.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**App Secret** 正如其名——是秘密。你应该保护它，不要将其检查到公共源代码控制中。'
- en: Setting up the Passport strategy
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Passport 策略
- en: 'The next thing we need to do is to set up the strategy in Passport. Open up
    your terminal and navigate to your `giftapp` root directory:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是在 Passport 中设置策略。打开你的终端并导航到你的 `giftapp` 根目录：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we've installed the Passport Facebook module, which allows us to log in
    with Facebook using OAuth 2.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已经安装了 Passport Facebook 模块，它允许我们使用 OAuth 2 通过 Facebook 登录。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OAuth is an open protocol to allow secure authorization in a simple and standard
    method from web, mobile and desktop applications. You can find more information
    about OAuth 2, the latest version of the protocol, at [http://oauth.net/2/](http://oauth.net/2/).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是一个开放协议，允许通过简单和标准的方法在网页、移动和桌面应用程序中进行安全的授权。你可以在 [http://oauth.net/2/](http://oauth.net/2/)
    找到有关 OAuth 2（该协议的最新版本）的更多信息。
- en: Configuring for Facebook
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Facebook
- en: 'Now we need to set up our strategy. Inside your giftapp directory, make a new
    directory called `config`, and add a new file called `authorization.js`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要制定我们的策略。在你的 giftapp 目录内，创建一个名为 `config` 的新目录，并添加一个名为 `authorization.js`
    的新文件：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We just stash an object with a few values we're going to need later. The `clientID`
    is our App ID. The `clientSecret` is our App Secret (no, that isn't my real secret).
    The last value is our `callBackURL`. This is a URL that Facebook will redirect
    to on authorization.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是存储了一个包含我们稍后需要的几个值的对象。`clientID` 是我们的 App ID。`clientSecret` 是我们的 App Secret（不，那不是我的真实秘密）。最后一个值是我们的
    `callBackURL`。这是一个 Facebook 在授权后会重定向到的 URL。
- en: If you are using a Git repository to store your source code, it would be a good
    idea to add this `config` file to your `.gitignore` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Git 仓库来存储你的源代码，将这个 `config` 文件添加到你的 `.gitignore` 文件中是个好主意。
- en: Setting up the routes for Facebook authentication
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Facebook 认证的路由
- en: 'The next thing we need to do is to set up a couple of routes. In your `routes`
    directory, open up your routes file, `login.js`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是设置几个路由。在你的 `routes` 目录中，打开你的路由文件，`login.js`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first new route is going to be used to log in using Facebook. The callback
    URL is used after authentication. On failure, the user is redirected to login.
    On success, the user is sent to the dashboard.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新路由将被用于使用 Facebook 登录。回调 URL 在认证后使用。如果失败，用户将被重定向到登录页面。如果成功，用户将被发送到仪表板。
- en: Note that the second argument to the call to `passport.authenticate` on the
    `facebook` route. This object contains a scope property, which takes an array.
    That array consists of strings for data fields for which Facebook requires extra
    permissions to access. Facebook requires extra permissions to access a user's
    e-mail address.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `facebook` 路由上调用 `passport.authenticate` 的第二个参数。这个对象包含一个 scope 属性，它接受一个数组。这个数组由
    Facebook 需要额外权限才能访问的数据字段字符串组成。Facebook 需要额外权限来访问用户的电子邮件地址。
- en: Finishing setting up the Passport strategy
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成设置 Passport 策略
- en: Now we have a few more steps to set up the strategy. In your Passport directory,
    create a new file called `facebook.js:`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有更多步骤来设置策略。在你的 Passport 目录中，创建一个名为 `facebook.js` 的新文件：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We begin by requiring our dependencies, including the Strategy object provided
    by the `passport-facebook` module, our User model, and our authorization configuration
    file containing our Facebook credentials.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先引入我们的依赖项，包括由 `passport-facebook` 模块提供的 Strategy 对象、我们的 User 模型以及包含我们的 Facebook
    凭据的授权配置文件。
- en: We then create a module that defines our Facebook authentication strategy. It
    receives a configuration object as its first argument, which we define using the
    `facebook` authorization values from our configuration file. The final property,
    `profileFields`, sets the fields we're expecting to receive in the profile object
    we get back from Facebook.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着创建一个模块，该模块定义了我们的 Facebook 认证策略。它接受一个配置对象作为其第一个参数，我们使用配置文件中的 `facebook` 授权值来定义它。最后一个属性
    `profileFields` 设置了我们期望从 Facebook 返回的配置文件中接收的字段。
- en: The second argument is a function that gets called when the authorization strategy
    is used. It receives an `accessToken`, `refreshToken`, `profile`, and `callback`
    as arguments from Facebook.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个在授权策略被使用时被调用的函数。它从Facebook接收`accessToken`、`refreshToken`、`profile`和`callback`作为参数。
- en: We use the User's `findOne` function to see if the user already exists based
    on the `profile.id` returned from Facebook. We first check to see if there's an
    error. If there is, we return it to the callback. If there's no error and the
    user exists, the user object is passed back to the callback with a null in the
    error field. Finally, if the user doesn't already exist, we create a new user,
    save that user to the database, then pass the new user object back to the callback.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用用户的`findOne`函数来查看用户是否基于从Facebook返回的`profile.id`已存在。我们首先检查是否有错误。如果有，我们将其返回给回调。如果没有错误且用户存在，则将用户对象传递回回调，错误字段为null。最后，如果用户不存在，我们创建一个新的用户，将该用户保存到数据库中，然后将新的用户对象传递回回调。
- en: Note that we will not always get e-mails back from Facebook, so we need to test
    to see if we get that property back on profile before we try to access it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不一定总是从Facebook收到电子邮件，因此在我们尝试访问它之前，我们需要测试在配置文件中是否返回了该属性。
- en: Remember that if you want to delete your `users` collection you can use the
    Mongo console. Enter `use giftapp` to select the database, then `db.users.drop()`
    to drop the collection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果您想删除`users`集合，可以使用Mongo控制台。输入`use giftapp`来选择数据库，然后输入`db.users.drop()`来删除集合。
- en: Altering the User model for Facebook data
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改用户模型以存储Facebook数据
- en: 'Let''s make some changes to our `User` model. Our Facebook authorization will
    give us some data that we weren''t getting before, and there''s some stuff we
    need to store. Open up your `user.js` file in your models directory and edit the
    following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的`User`模型做一些修改。我们的Facebook授权将给我们一些之前没有的数据，并且有一些东西我们需要存储。打开你的模型目录中的`user.js`文件并编辑以下内容：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we're going to use the `mongoose.Schema` function to start to build out
    our schema. We've added a `Facebook` object to the user which stores an ID, and
    a token. Note that this new ID is provided by Facebook and is different from the
    ID at the top level of the `User` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`mongoose.Schema`函数开始构建我们的模式。我们在用户中添加了一个`Facebook`对象，用于存储ID和令牌。请注意，这个新的ID是由Facebook提供的，并且与`User`对象顶层的ID不同。
- en: The token is a unique `id` that Facebook provides on an application-by-application
    basis. We need to store this for authentication to work correctly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌是一个Facebook为每个应用程序提供的唯一`id`。我们需要存储这个信息以确保认证能够正确工作。
- en: Finishing the connection to Facebook
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成与Facebook的连接
- en: We are almost good to go. We have just a couple more steps to do to complete
    the work for authenticating and signing up with Facebook.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好了。我们只需要完成最后几个步骤，以完成使用Facebook进行认证和注册的工作。
- en: Recreating our home page
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重建我们的主页
- en: 'Let''s make life a little easier on ourselves and rewrite our `index.ejs` file
    inside our views directory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简化一下自己的工作，并在视图目录内重写我们的`index.ejs`文件：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we''ve created a simple welcome page using the Bootstrap `jumbotron`.
    We have three buttons, which are actually links styled as buttons: one for login,
    one for signup, and one for Facebook signup/login.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Bootstrap的`jumbotron`创建了一个简单的欢迎页面。我们有三个按钮，实际上这些按钮是作为链接样式设计的：一个用于登录，一个用于注册，还有一个用于Facebook注册/登录。
- en: 'The page, at `http://localhost:3000`, will look like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 页面，在`http://localhost:3000`，将看起来如下所示：
- en: '![Recreating our home page](img/image_12_008.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![重建我们的主页](img/image_12_008.jpg)'
- en: 'You can test out the buttons. Unfortunately, clicking on our Facebook button
    gets you an error:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以测试这些按钮。不幸的是，点击我们的Facebook按钮会出现错误：
- en: '![Recreating our home page](img/image_12_009.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![重建我们的主页](img/image_12_009.jpg)'
- en: 'This is because we have to specifically enable URLs inside our Facebook app.
    Facebook enforces this security measure. Not a problem for us. Go back to **Settings**
    on your Facebook app dashboard:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们必须在Facebook应用程序内特别启用URL。Facebook强制执行这项安全措施。对我们来说没问题。回到你的Facebook应用程序仪表板的**设置**：
- en: '![Recreating our home page](img/image_12_010.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![重建我们的主页](img/image_12_010.jpg)'
- en: Once in here, click on **+ Add Platform** and select **Website**. Enter `http://localhost`
    in the URL field. Now you should be able to register and authenticate with Facebook.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入这里，点击**+ 添加平台**并选择**网站**。在URL字段中输入`http://localhost`。现在您应该能够使用Facebook进行注册和认证。
- en: One thing you may want to implement on your own is checking to see if a user
    already exists in the database by checking any e-mail address returned by Facebook
    against user e-mails already in the database. This will help to avoid duplicate
    accounts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望自行实现的一个功能是检查数据库中是否已存在用户，通过检查 Facebook 返回的任何电子邮件地址与数据库中已有的用户电子邮件地址进行对比。这将有助于避免重复账户。
- en: Connecting to Twitter
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到 Twitter
- en: One of the great things about Passport, and OAuth 2, is that there are a ton
    of different strategies we can use to authenticate with third parties. Let's set
    up Twitter authentication.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 和 OAuth 2 的一个优点是，我们可以使用许多不同的策略来与第三方进行身份验证。让我们设置 Twitter 身份验证。
- en: Adding a Twitter app
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Twitter 应用
- en: 'Similar to Facebook, we need to set up an app on Twitter for our application
    to communicate with. Head on over to [https://apps.twitter.com](https://apps.twitter.com)
    and create a new app:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Facebook 类似，我们需要在我们的应用程序与 Twitter 通信时在 Twitter 上设置一个应用。前往 [https://apps.twitter.com](https://apps.twitter.com)
    并创建一个新的应用：
- en: '![Adding a Twitter app](img/image_12_011.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![添加 Twitter 应用](img/image_12_011.jpg)'
- en: Fill in a name, description, and the two URLs. At the time of writing, Twitter
    does not allow `http://localhost` as a URL, so you have to use `http://127.0.0.1`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 填写名称、描述和两个 URL。在撰写本文时，Twitter 不允许使用 `http://localhost` 作为 URL，因此您必须使用 `http://127.0.0.1`。
- en: 'Now click over to **Keys and Access Tokens** and grab your Consumer Key and
    Consumer Secret. We''re going to add these to our `authorization.js` configuration
    file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击到 **密钥和访问令牌** 并获取您的 Consumer Key 和 Consumer Secret。我们将把这些添加到我们的 `authorization.js`
    配置文件中：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We add a `twitterAuth` section to our authorization `config` file that contains
    the keys we need as well as the callback. This all is very similar to Facebook.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的授权 `config` 文件中添加一个 `twitterAuth` 部分，其中包含我们需要的密钥以及回调。这一切都与 Facebook 非常相似。
- en: Setting up our Twitter strategy
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的 Twitter 策略
- en: Now we need to take the steps to build our Twitter strategy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要采取步骤构建我们的 Twitter 策略。
- en: 'First things first, we need to install the Passport Twitter strategy module:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 Passport Twitter 策略模块：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now create a `twitter.js` file inside your Passport directory:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的 Passport 目录中创建一个 `twitter.js` 文件：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This strategy is very similar to our Facebook strategy. We set up our keys and
    callback using our authorization config. We then check if a user with the same
    Twitter ID is already in the database. If not, we create a new user with the data
    Twitter sends us and save the record to the database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略与我们的 Facebook 策略非常相似。我们使用授权配置设置我们的密钥和回调。然后我们检查是否已存在具有相同 Twitter ID 的用户。如果没有，我们将使用
    Twitter 发送给我们的数据创建一个新的用户，并将记录保存到数据库中。
- en: 'Speaking of databases, we now need to make a change to our `User` model to
    handle our Twitter data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到数据库，我们现在需要修改我们的 `User` 模型以处理我们的 Twitter 数据：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Just like with the Facebook section, we add a Twitter property to store the
    data that we get back from Twitter separately.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Facebook 部分，我们添加一个 Twitter 属性来存储我们从 Twitter 分离获取的数据。
- en: 'Next, we need to add the routes for Twitter authentication to our `routes/login.js`
    file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的 `routes/login.js` 文件中添加 Twitter 身份验证的路由：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, the Twitter routes are very similar to the routes we use for Facebook
    authentication. We have the main authorization route and the route we use for
    callback.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Twitter 路由与我们在 Facebook 身份验证中使用的路由非常相似。我们有主要的授权路由和用于回调的路由。
- en: 'Now we just need to make a couple of edits to our `passport/init.js` file to
    include the Twitter strategy:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要对我们的 `passport/init.js` 文件进行一些编辑，以包含 Twitter 策略：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The only changes we need here are to import the Twitter strategy and initialize
    it. At this point, our Twitter strategy should work. Let's just make it a little
    easier for our users.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要做的唯一改变是导入 Twitter 策略并初始化它。到这一点，我们的 Twitter 策略应该可以工作。让我们让它对用户来说更容易一些。
- en: Adding Twitter authorization to our home page
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Twitter 授权添加到我们的主页
- en: 'As with our Facebook strategy, let''s add a Twitter login button to our `index.ejs`
    file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的 Facebook 策略一样，让我们在我们的 `index.ejs` 文件中添加一个 Twitter 登录按钮：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've added a Twitter login button.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已添加了一个 Twitter 登录按钮。
- en: 'Note that to test this, start at `http://127.0.0.1:3000/` and not `http://localhost:3000`.
    The reason for this is that you need the domain for the session cookies to match
    in the callback URL. When you do, you''ll see the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了测试，请从 `http://127.0.0.1:3000/` 开始，而不是 `http://localhost:3000`。这样做的原因是您需要域与回调
    URL 中的会话 cookie 匹配。当您这样做时，您将看到以下内容：
- en: '![Adding Twitter authorization to our home page](img/image_12_012.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![将 Twitter 授权添加到我们的主页](img/image_12_012.jpg)'
- en: 'Clicking on the Twitter login button will redirect you to Twitter, which will
    ask you to log in or authorize for your app:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 点击Twitter登录按钮将带您重定向到Twitter，它将要求您登录或为您的应用授权：
- en: '![Adding Twitter authorization to our home page](img/image_12_013.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![将Twitter授权添加到我们的主页](img/image_12_013.jpg)'
- en: Clicking on **Sign in** should bring you to your dashboard.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**登录**应该会带您到仪表板。
- en: 'Now that we have logged in with both Facebook and Twitter, let''s look at our
    `users` collection on our `giftapp` database. Fire up your MongoDB client by typing
    mongo on your command line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过Facebook和Twitter登录，让我们看看我们的`giftapp`数据库中的`users`集合。通过在命令行中输入mongo启动您的MongoDB客户端：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, we have two users in our `users` collection, one with a set of Facebook
    credentials, and one with Twitter credentials. You'll notice that the Twitter
    profile does not include e-mail.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的`users`集合中有两个用户，一个有一组Facebook凭证，另一个有Twitter凭证。您会注意到Twitter配置文件不包括电子邮件。
- en: Sharing giftlists
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享giftlists
- en: Currently, our giftlist functionality doesn't really work. We want users to
    be able to create giftlists which they can then share.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的giftlist功能实际上并不起作用。我们希望用户能够创建他们可以分享的giftlists。
- en: Fleshing out the giftlist model
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完善giftlist模型
- en: 'Since we''re using Mongoose to model data for our users, let''s also put it
    to use to model our `giftlists`. Inside your `models` folder, create a new file
    called `giftlist.js`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Mongoose为我们的用户建模数据，让我们也用它来为我们的`giftlists`建模。在您的`models`文件夹中，创建一个名为`giftlist.js`的新文件：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This model is pretty straightforward. A giftlist has an ID, a name, a list of
    `gift` objects, and a `user_id` field. We will populate the `user_id` with the
    ID of the user who owns the giftlist. In a relational database, this would be
    a foreign key, defining a one-to-many relationship between users and giftlists.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型相当简单。一个giftlist有一个ID，一个名称，一个`gift`对象的列表，以及一个`user_id`字段。我们将用拥有giftlist的用户ID填充`user_id`。在一个关系型数据库中，这将是一个外键，定义了用户和giftlist之间的一对多关系。
- en: The gifts field is an array of objects expecting only a name property. We also
    have a list of users with whom we have shared the giftlist. We will leave the
    sharing functionality for later.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: gifts字段是一个只期望有name属性的object数组。我们还有一个与我们已经分享的giftlist的用户列表。我们将分享功能留到以后。
- en: Connecting the UI
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接UI
- en: The next thing we want to do is to allow users to create new giftlists from
    our SPA dashboard.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们希望允许用户从我们的SPA仪表板创建新的giftlists。
- en: 'Since we''re going to be POSTing data back via Ajax, we need to do a little
    work to make the CSRF token available to our Angular application. There are two
    steps to do this; first, we want to pass the token in our `dashboard.js` route:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算通过Ajax发送数据，我们需要做一些工作来使CSRF令牌对Angular应用可用。为此有两个步骤；首先，我们希望在`dashboard.js`路由中传递令牌：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We pass the token to the render function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将令牌传递给渲染函数。
- en: 'Next, we will add something to our `dashboard.ejs` template:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`dashboard.ejs`模板中添加一些内容：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We create a new Angular module inside our page and add a value to it. A value
    is basically an injectable name value pair we can use in our application. We do
    this in the dashboard template, because we need the server to provide the `csrfToken`
    to the UI.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的页面内创建一个新的Angular模块，并向其中添加一个值。一个值基本上是一个可注入的名称值对，我们可以在我们的应用程序中使用它。我们在仪表板模板中这样做，因为我们需要服务器将`csrfToken`提供给UI。
- en: We've also added a script tag to load a new controller script file that we will
    use to handle processing and submitting the form.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个script标签来加载一个新控制器脚本文件，我们将使用它来处理和提交表单。
- en: Connecting the form
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接表单
- en: Next, we need to connect the giftlist form to the controller and have the controller
    talk to the backend.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将giftlist表单连接到控制器，并让控制器与后端通信。
- en: Creating the controller
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'Create a new file in your `javascripts/controllers` directory called `giftappFormController.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`javascripts/controllers`目录中创建一个名为`giftappFormController.js`的新文件：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We add a new controller into our `giftappControllers` module. We inject a number
    of things into the controller, including our List resource, and $state. We're
    also injecting `csrfToken`. We don't have access to that quite yet, but we'll
    inject its module into our module in a bit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`giftappControllers`模块中添加了一个新的控制器。我们将一些东西注入到控制器中，包括我们的List资源，以及$state。我们还注入了`csrfToken`。我们目前还不能访问它，但稍后我们会将其模块注入到我们的模块中。
- en: Inside the controller, we set up an object on `$scope` called `formData`. This
    will hold the data entered by a user on our form. We also add a function to scope,
    called `create`, which will be invoked when a user submits the form. We create
    a new instance of our List resource, add our data to it, and save it to the backend.
    After saving, we trigger a state change to return to the dashboard.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器内部，我们在`$scope`上设置了一个名为`formData`的对象。这个对象将保存用户在我们表单中输入的数据。我们还添加了一个名为`create`的函数到作用域中，当用户提交表单时将被调用。我们创建了一个新的列表资源实例，将我们的数据添加到其中，并将其保存到后端。保存后，我们触发状态改变以返回仪表板。
- en: 'Since our module is actually defined `insidedashMainController`.`js`, this
    is where we want to inject the module containing our `csrfToken` value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模块实际上是在`insidedashMainController`.`js`中定义的，这是我们想要注入包含我们的`csrfToken`值的模块的地方：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Simply by adding the name of the module to our module's dependencies, we get
    access to the value service inside our module.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地将模块名称添加到我们的模块依赖中，我们就可以访问模块内的值服务。
- en: Angularizing the form
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范化表单
- en: 'The next thing we need to do is to add some AngularJS directives to our template
    at `public/templates/dash-add.tpl.html`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要在`public/templates/dash-add.tpl.html`模板中添加一些AngularJS指令：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first change is adding the `ng-submit` directive to the form. On submitting
    the form, the controller's `$scope.create()` function will be invoked.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次更改是在表单中添加`ng-submit`指令。在提交表单时，控制器中的`$scope.create()`函数将被调用。
- en: We then connect the inputs to the `$scope.formdata` using `ng-model` directives.
    This creates two-way data binding. To demonstrate this, we add `{{formData}}`
    into the template. This will show you all the data held by `$scope.formdata` and
    is a great way to troubleshoot your form. Obviously it's not something you'd leave
    in the template in production.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将输入与`$scope.formdata`通过`ng-model`指令连接起来。这创建了两向数据绑定。为了演示这一点，我们在模板中添加了`{{formData}}`。这将显示`$scope.formdata`中保存的所有数据，并且是调试表单的好方法。显然，这不是在生产模板中留下的事情。
- en: Connecting to the backend controller
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到后端控制器
- en: 'Now that our form is connected to our controller, we need to connect our controller
    to our backend to store and retrieve our data from the database. Open your `controllers/giftlist_controller.js`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的表单已经连接到我们的控制器，我们需要将我们的控制器连接到后端以存储和从数据库中检索我们的数据。打开你的`controllers/giftlist_controller.js`文件：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We require in our `giftlist` model, and we've edited the index, show, and create
    routes to take advantage of the Mongoose database functions. Because we want to
    be able to share lists easily with people who aren't logged into our dashboard,
    non-JSON requests to show are going to render in a separate page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`giftlist`模型中引入了依赖，并编辑了索引、显示和创建路由以利用Mongoose数据库功能。因为我们希望能够轻松地将列表与未登录我们的仪表板的人分享，所以显示的非JSON请求将渲染在单独的页面上。
- en: 'Inside your views directory, create a new `giftlist` directory and create a
    template called `show.ejs`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的视图目录中，创建一个新的`giftlist`目录，并创建一个名为`show.ejs`的模板：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a pretty straightforward template that renders the list name and the
    gifts on the list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的模板，用于渲染列表名称和列表上的礼物。
- en: Adding the ability to share lists on social media
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加在社交媒体上分享列表的能力
- en: 'Next, we want to allow users to easily share their lists. We need to make a
    minor adjustment to the `dash-main` template:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望允许用户轻松地分享他们的列表。我们需要对`dash-main`模板进行一些小的调整：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The URL we've added to the link will trigger the show route in our controller,
    passing it the ID of the list we want to show.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到链接中的URL将触发控制器中的显示路由，并传递我们想要显示的列表的ID。
- en: 'Next, we''ll add sharing buttons to our `giftlist/show.ejs` template:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的`giftlist/show.ejs`模板添加分享按钮：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We add some open graph tags, and some code to enable Twitter and Facebook sharing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些开放图标签，以及一些代码来启用Twitter和Facebook分享。
- en: Twitter has a neat form-based wizard to set up Twitter sharing buttons. You
    can find it at [https://about.twitter.com/resources/buttons#tweet](https://about.twitter.com/resources/buttons#tweet).
    You'll want to configure the Facebook button specifically for your app ID. Facebook
    also has a form-based configuration tool, at [https://developers.facebook.com/docs/plugins/like-button](https://developers.facebook.com/docs/plugins/like-button).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter有一个基于表单的便捷向导来设置Twitter分享按钮。你可以在[https://about.twitter.com/resources/buttons#tweet](https://about.twitter.com/resources/buttons#tweet)找到它。你将需要为你的应用ID特别配置Facebook按钮。Facebook也有一个基于表单的配置工具，在[https://developers.facebook.com/docs/plugins/like-button](https://developers.facebook.com/docs/plugins/like-button)。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began this chapter by setting up Passport strategies for authenticating with
    Facebook and Twitter. Setting up developer accounts with each social media site
    is a straightforward, but necessary, step.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置与Facebook和Twitter的Passport策略来开始本章，为每个社交媒体网站设置开发者账户是一个简单但必要的步骤。
- en: We then utilized our `Mongoose Giftlist` model, as well as our resourceful controller,
    to enable creating gift lists from within the SPA. We enabled the frontend code
    and AJAX functionality by building a new AngularJS controller. To be able to post
    data to the backend, we added an injectable value service to carry the CSRF token.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们利用我们的`Mongoose Giftlist`模型以及我们资源丰富的控制器，从SPA内部启用创建礼品列表。我们通过构建一个新的AngularJS控制器来启用前端代码和AJAX功能。为了能够将数据发布到后端，我们添加了一个可注入的值服务来携带CSRF令牌。
- en: There are a few things we leave to you to round out the application. This includes
    a way to add more gift inputs dynamically, and share lists with other registered
    users.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情留给我们来完成应用的完善。这包括动态添加更多礼品输入的方式，以及与其他注册用户共享列表。
