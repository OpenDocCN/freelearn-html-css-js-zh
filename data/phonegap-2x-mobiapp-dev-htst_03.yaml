- en: Chapter 3. Being Productive
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 提高生产力
- en: PhoneGap can be used for more than simple games and social media apps; it can
    also be used to create productivity apps that can be very useful. To do that,
    however, we need to learn about how to store persistent data using PhoneGap's
    File APIs. In this project, we'll do just that. We'll build a simple note-taking
    app named Filer that uses the File API to manage the available notes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap不仅可以用于简单的游戏和社交媒体应用；它还可以用于创建非常有用的生产力应用。然而，为了做到这一点，我们需要了解如何使用PhoneGap的文件API存储持久数据。在这个项目中，我们将这样做。我们将构建一个名为Filer的简单记事本应用，它使用文件API来管理可用的笔记。
- en: What do we build?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将构建什么？
- en: At its core, Filer is more about file management than it is about taking notes,
    but it is absolutely critical that you get file management right. Users don't
    take it kindly when an app corrupts or loses their data, so you must make sure
    to manage it correctly. Once that is accomplished, you can move on to making the
    app more complex. Thankfully, the concepts you learn in this project can be applied
    to all your future apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，Filer更关注文件管理而不是记笔记，但正确管理文件至关重要。当应用损坏或丢失用户数据时，用户不会友好地对待，因此你必须确保正确管理。一旦完成，你就可以继续使应用更复杂。幸运的是，你在本项目中学习的概念可以应用于你未来的所有应用。
- en: What does it do?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它能做什么？
- en: As the name implies, the app permits the user to *file* away notes for later
    retrieval. Doing this requires the use of the File APIs provided by PhoneGap.
    Not only do we need to be able to save and load notes, but we need to manage them
    as well. This includes removing notes at the user's request, renaming them, and
    duplicating them as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，该应用允许用户将笔记*存档*起来以供以后检索。这样做需要使用PhoneGap提供的文件API。我们不仅需要能够保存和加载笔记，还需要管理它们。这包括根据用户的要求删除笔记、重命名它们以及复制它们。
- en: Once a note is created or opened, the app itself becomes very simple, essentially
    a large `TEXTAREA` element that will accept any kind of text you want to put in
    it. We'll also take a look at good ways to save and retrieve the data you enter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建或打开笔记，应用本身就变得非常简单，本质上是一个大型的`TEXTAREA`元素，可以接受你想要放入的任何类型的文本。我们还将探讨保存和检索你输入的数据的好方法。
- en: Why is it great?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它很棒？
- en: This app is a great way to learn the File APIs present in PhoneGap to manage
    files that your App needs in order to save and retrieve data. We'll also consider
    how to present this to the user in a form they can easily understand.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用是学习PhoneGap中用于管理应用需要保存和检索数据的文件API的绝佳方式。我们还将考虑如何以用户易于理解的形式展示这些内容。
- en: How are we going to do it?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何实现？
- en: 'We''ll be going about creating this app much like we have the past apps, using
    the following pointers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照创建过去应用的方式创建这个应用，使用以下指南：
- en: Designing the user interface
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用户界面
- en: Designing the data model
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计数据模型
- en: Implementing the data models
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据模型
- en: Implementing the documents view
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现文档视图
- en: Implementing the file view
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现文件视图
- en: What do I need to get started?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要什么来开始？
- en: You should be able to create your project and set it up much the same way as
    the prior apps. Call this project `Filer`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够以与先前应用相同的方式创建你的项目并设置它。将这个项目命名为`Filer`。
- en: Note that, if you want, you can include the sharing libraries from the second
    project. We'll not use them directly, but there is a challenge at the end of the
    project that asks you to add sharing. If you intend to do this, you might as well
    add everything now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你愿意，你可以包含第二个项目中的共享库。我们不会直接使用它们，但在项目的最后有一个挑战要求你添加共享功能。如果你打算这样做，你不妨现在就添加所有内容。
- en: Designing the user interface
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计用户界面
- en: First, get your paper and pencil out or use your favorite image editor. Like
    in previous projects, we'll design our views using sketches and wireframes first,
    then flesh them out a bit more to design the graphical assets.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，拿出你的纸和铅笔，或者使用你最喜欢的图像编辑器。像以前的项目一样，我们首先使用草图和线框来设计我们的视图，然后进一步细化以设计图形资产。
- en: Getting on with it
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: 'As in previous projects, the first view is the start view, but since it is
    the same as all the prior apps, we won''t go into detail about it here (refer
    to the *Designing the UI/interactions* section of [Project 1](ch01.html "Chapter 1. Let''s
    Get Local!"), *Let''s Get Local!*). Instead, let''s go to the documents view,
    shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，第一个视图是起始视图，但由于它与所有先前的应用相同，我们这里不会详细介绍它（请参阅[项目1](ch01.html "第一章：让我们本地化！")的*设计UI/交互*部分，*让我们本地化!*）。相反，让我们转到文档视图，如下面的截图所示：
- en: '![Getting on with it](img/9403_03_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_03_01.jpg)'
- en: In this view we've actually got two looks; the left is for the iPhone, while
    the right is for Android. The reason for the two different looks is simply how
    a lot of apps do things on each platform. You typically see large, horizontal
    scrolling interfaces on iOS, and on Android you typically see vertical lists representing
    files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们实际上有两种外观；左边是iPhone的，而右边是Android的。这两种不同外观的原因仅仅是许多应用在每个平台上处理事情的方式。在iOS上，你通常看到大型的水平滚动界面，而在Android上，你通常看到代表文件的垂直列表。
- en: Let's go over how this view works. The button in the navigation bar, named **Create**,
    allows the user to create a new note. Below the navigation bar is the list of
    files that are available. On the first run, of course, this will be empty, but
    as files are created, they are added here. This view will scroll as needed in
    order to show the entire list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个视图是如何工作的。导航栏中的按钮，命名为**创建**，允许用户创建一个新的笔记。在导航栏下方是可用的文件列表。当然，在第一次运行时，这将是一个空列表，但随着文件的创建，它们会被添加到这里。这个视图将根据需要滚动，以显示整个列表。
- en: Each item in the list will have the same contents, even though they are arranged
    and sized differently. The first is the icon that represents the item; many apps
    will render a version of the content as this icon. To avoid complexity, we won't
    do that here; we'll use a static image instead. Tapping on the icon will open
    the note. The next is the icon's label, this shows the name of the file. When
    pressed, however, it will allow the user to rename the file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每一项都将包含相同的内容，尽管它们的排列和大小不同。首先是表示该项的图标；许多应用都会以这种图标的形式呈现内容。为了避免复杂性，我们这里不会这么做；我们将使用静态图像。点击图标将打开笔记。接下来是图标的标签，这显示了文件名。但是，当按下时，它将允许用户重命名文件。
- en: 'Below the file name are the following three icons:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件名下方有三个图标：
- en: For duplicating (copying) the note
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于复制（复制）笔记
- en: For sharing the note
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于分享笔记
- en: For destroying (deleting) the note
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于销毁（删除）笔记
- en: At first, none of this is terribly difficult, and really, it isn't. But the
    way the File APIs are implemented, it does take a bit of work to get right.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这一切并不特别困难，实际上，也并不困难。但是，由于文件API的实现方式，要正确实现它确实需要一些工作。
- en: 'Let''s move on to the file view, seen in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到文件视图，如下面的截图所示：
- en: '![Getting on with it](img/9403_03_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_03_02.jpg)'
- en: 'This view is pretty simple: it displays the contents of the note and allows
    the user to edit it. Notice that there''s no **Save** button; the idea is that
    the notes will save themselves automatically.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图非常简单：它显示笔记的内容，并允许用户编辑它。请注意，这里没有**保存**按钮；想法是笔记将自动保存。
- en: When the view first appears, the keyboard won't be visible. This allows the
    user to see the note fill the screen. Once the note is tapped, however, the keyboard
    will appear, and the user will be able to change the note to their desire.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图首次出现时，键盘将不可见。这使用户能够看到笔记填满整个屏幕。但是，一旦点击笔记，键盘就会出现，用户就可以将笔记更改为他们想要的。
- en: 'Now that we''ve created the wireframes, let''s go into our graphics program
    and create our resources. Here''s what we came up with:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了线框，让我们进入我们的图形程序并创建我们的资源。这是我们得到的结果：
- en: '![Getting on with it](img/9403_03_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_03_03.jpg)'
- en: We'll take most of the interface here as images, the icons, the large paper
    image, and the navigation bar and view background itself as well. For Android,
    only the icons and the paper image matter; the latter two are for iOS only.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大部分界面以图像的形式展示，包括图标、大纸张图像以及导航栏和视图背景本身。对于Android，只有图标和纸张图像是重要的；后两者仅适用于iOS。
- en: The icons themselves are obtainable from App-Bits for free ([http://app-bits.com/free-icons.html](http://app-bits.com/free-icons.html)),
    and the background texture is from Subtle Patterns, again for free ([http://subtlepatterns.com](http://subtlepatterns.com)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图标本身可以从 App-Bits 免费获得（[http://app-bits.com/free-icons.html](http://app-bits.com/free-icons.html)），背景纹理来自
    Subtle Patterns，同样免费（[http://subtlepatterns.com](http://subtlepatterns.com)）。
- en: What did we do?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task, we created the desired look and feel, and generated the necessary
    resources for our app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们创建了所需的外观和感觉，并为我们的应用程序生成了必要的资源。
- en: Designing the data model
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据模型
- en: 'Go ahead and get your paper and pencil out again. We need to design the data
    model for the app. We''ll have two portions: one to manage the list of available
    documents, and another to manage a single document.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 再次拿出你的纸和铅笔。我们需要为应用程序设计数据模型。我们将有两个部分：一个用于管理可用文档的列表，另一个用于管理单个文档。
- en: Getting on with it
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'Here''s what our model looks like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的模型看起来像什么：
- en: '![Getting on with it](img/9403_03_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_03_04.jpg)'
- en: The first model, named **FilerDocuments,** is responsible for managing all the
    files available to the app, while the one on the right, named **FilerDocument**,
    is responsible only for a single note. The latter is responsible for loading a
    note and saving a note, while the former is responsible for reading an entire
    directory of notes and then managing them via renames, copies, and deletes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模型，命名为 **FilerDocuments**，负责管理应用程序可用的所有文件，而右侧的模型，命名为 **FilerDocument**，仅负责单个笔记。后者负责加载笔记和保存笔记，而前者负责读取整个笔记目录，然后通过重命名、复制和删除来管理它们。
- en: A few notes of interest before we wrap this task up. Notice all methods that
    end with `…Success`. This is simply due to the way the File API is structured;
    everything is done asynchronously so you have to write each call to it with callbacks
    to both a `success` and a `failure` function. The `success` function points at
    the corresponding `Success` method, while the `failure` function points at the
    generic `dispatchFailure` method. (Failures are pretty generic; we want to log
    the failure, whereas successes may require additional steps to complete an operation.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个任务之前，我们注意到一些有趣的笔记。注意所有以 `…Success` 结尾的方法。这仅仅是由于文件 API 的结构方式；所有操作都是异步进行的，因此你必须为每个调用编写回调函数，以指向一个
    `success` 和一个 `failure` 函数。`success` 函数指向相应的 `Success` 方法，而 `failure` 函数指向通用的
    `dispatchFailure` 方法。（失败相当通用；我们希望记录失败，而成功可能需要额外的步骤来完成操作。）
- en: The `fileSystem` and `fileEntry` properties are also related to the File API.
    The `fileEntry` property is a pointer to a specific file, while the `fileSystem`
    property is a pointer to a specific directory on the device. (PhoneGap lets you
    specify if the directory should be a persistent one or a temporary one; we're
    using persistent.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileSystem` 和 `fileEntry` 属性也与文件 API 有关。`fileEntry` 属性是指向特定文件的指针，而 `fileSystem`
    属性是指向设备上特定目录的指针。（PhoneGap 允许你指定目录应该是持久的还是临时的；我们使用持久目录。）'
- en: On the second model, note the title and text properties as well as the associated
    `get`/`set` methods. This is the actual data of a single note; everything else
    was simply to manage it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个模型中，注意标题和文本属性以及相关的 `get`/`set` 方法。这是单个笔记的实际数据；其他一切都是为了管理它。
- en: What did we do?
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We created our data model for the document manager and a single note. In the
    next task, we'll implement both.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为文档管理器和单个笔记创建了数据模型。在下一个任务中，我们将实现这两个模型。
- en: Implementing the data models
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据模型
- en: At this point you should have your project already created. We're going to be
    creating two models under the `www/models` directory, named `filerDocuments.js`
    and `filerDocument.js`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经创建了你的项目。我们将在 `www/models` 目录下创建两个模型，分别命名为 `filerDocuments.js` 和 `filerDocument.js`。
- en: Getting on with it
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'Let''s get started by working on the Documents model that manages all the available
    documents:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作，先从管理所有可用文档的 Documents 模型入手：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the beginning of our constructor for the `Filers` object. The `completion`
    and `failure` variables are passed in because at the end of the constructor we
    will kick off a directory read operation and we want to alert the application
    when we're finished (or we get an error).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Filers` 对象构造函数的开始。`completion` 和 `failure` 变量被传递进来，因为在构造函数的末尾，我们将启动目录读取操作，并且我们希望在完成时（或遇到错误时）通知应用程序。
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `state` property will store the current progress of an operation, which
    should make it easier to debug if an operation fails.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`state` 属性将存储操作的当前进度，这将在操作失败时使调试更容易。'
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `completion` function here initially receives the completion but it also
    stores the `completion` function used by other functions within the object. This
    is because an operation may take several steps, each requiring an interim `completion`
    method. This just happens to be one from the app, not from within our object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`completion` 函数最初接收完成信息，但它还存储了对象内部其他函数使用的 `completion` 函数。这是因为一个操作可能需要几个步骤，每个步骤都需要一个临时的
    `completion` 方法。这恰好是应用程序中的一个，而不是我们对象内部的一个。
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `documents` property stores the information received from the filesystem
    on each file we can read. It's not the actual document.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`documents` 属性存储了我们从文件系统中读取的每个文件的接收信息。它不是实际的文档。'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `fileSystem` property points at the persistent storage on the device. Most
    operations begin by asking for a filesystem, and we can speed it up by saving
    it the first time we ask. Then other operations can use our cached value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileSystem` 属性指向设备上的持久存储。大多数操作都是从请求文件系统开始的，我们可以在第一次请求时保存它，这样其他操作就可以使用我们的缓存值。'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just like `completion`, this is the `failure` function. `dispatchFailure()`
    will be called first, which then calls this one, if it is non-null.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `completion` 一样，这也是一个 `failure` 函数。`dispatchFailure()` 将首先被调用，然后如果它非空，将调用这个函数。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For some of our operations, we have to store the information about a specific
    file; we do that using the `fileEntry` property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的某些操作，我们必须存储有关特定文件的信息；我们使用 `fileEntry` 属性来完成此操作。
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `loadFileSystem()` function can be called by the app at any time, but it
    is usually called when the app suspects that the documents available to us have
    changed. Say there may be a new one out there, and we want to be sure to display
    it to the user. Most of the operations in this class will try to re-read the directory
    after an operation (like renaming a file), but not every operation supports this,
    and this doesn't stop documents from appearing that we didn't explicitly create
    (say, from an iTunes import).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadFileSystem()` 函数可以在任何时间由应用程序调用，但它通常是在应用程序怀疑我们可用的文档已更改时调用。比如说，可能有一个新的文档出现，我们想要确保向用户显示它。这个类中的大多数操作都会在操作（如重命名文件）之后尝试重新读取目录，但并非每个操作都支持此操作，这并不会阻止出现我们没有明确创建的文档（比如说，来自iTunes导入）。'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `getFilesystem()` function does the first thing we have to do when asking
    to see what files we have available to us: requests the filesystem. In this case,
    we''re asking for the persistent filesystem so that the data is stored permanently.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFilesystem()` 函数在我们请求查看我们可用的文件时必须做的第一件事：请求文件系统。在这种情况下，我们请求持久文件系统，以便数据永久存储。'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Generally, I like to keep `success`/`failure` methods close to the invoking
    method, but failures can be handled pretty generically (in our case), and so I
    just have one `failure` function that all our operations can call. It records
    a nice log message for us, and then checks to see if the app has registered a
    failure callback, and if it has, we'll call it too.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我喜欢将 `success`/`failure` 方法与调用方法保持接近，但失败可以相当通用地处理（在我们的情况下），所以我只有一个 `failure`
    函数，我们的所有操作都可以调用。它为我们记录了一条漂亮的日志消息，然后检查应用程序是否注册了失败回调，如果有，我们也会调用它。
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we're in the preceding function, we've got a valid filesystem. We save
    it for later use, and then we also call `getDocuments()` to start the process
    of getting every document our app can access.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前面的函数中时，我们有一个有效的文件系统。我们将其保存以供以后使用，然后我们还会调用 `getDocuments()` 以开始获取应用程序可以访问的每个文档的过程。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to go over every entry in the directory of the filesystem we've got,
    we have to create a directory reader. We can do this by using the `directoryEntry`
    function passed to us (which is pointing to the filesystem we requested). Once
    we have that, we ask it to read all the entries and call `getDocumentsSuccess()`
    when it is finished.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遍历文件系统目录中的每个条目，我们必须创建一个目录读取器。我们可以通过使用传递给我们的 `directoryEntry` 函数（它指向我们请求的文件系统）来完成此操作。一旦我们有了它，我们就要求它读取所有条目，并在完成后调用
    `getDocumentsSuccess()`。
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding function, we read through all the entries given to us. One
    should never assume that all the entries in a directory are something that our
    app can handle, so we screen for subdirectories (which we won't be creating, so
    it won't be anything we can deal with), and then we also check for the file extension.
    If it is `.fln`, we assume the file is one of ours and add it to the list. If
    it has anything else, we ignore it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们阅读了我们得到的所有条目。一个人永远不应该假设目录中的所有条目都是我们的应用可以处理的，因此我们会筛选子目录（我们不会创建，所以它不会是我们能处理的任何东西），然后我们也会检查文件扩展名。如果是`.fln`，我们假设文件是我们的文件之一，并将其添加到列表中。如果有其他任何东西，我们就会忽略它。
- en: Once we're done iterating over the list, we call the `completion` method (if
    it exists) so that the app can do what it wants with the list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们遍历完列表，我们就会调用`completion`方法（如果存在），这样应用就可以对列表做它想做的事情。
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The prior two methods are pretty self-explanatory. The first returns the number
    of documents we were able to get from the directory, and the second returns the
    information obtained for a specific document.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法相当直观。第一个返回我们从目录中获取的文档数量，第二个返回特定文档获取的信息。
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method isn't playing games; it'll physically remove the document at the
    specified index. Our app will ask the user first if they'd like to remove the
    document, so that it can't be accidentally called, but this function won't ask
    anyone if it is okay on its own. So be careful when calling it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法并不是在玩弄文字；它将物理地删除指定索引处的文档。我们的应用会先询问用户是否想要删除文档，这样就不会意外调用，但这个函数本身不会询问任何人是否可以这样做。所以调用时要小心。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After a successful delete, we need to re-read the filesystem so that our `documents`
    array is up-to-date. We do this by calling `getFileSystem()`. You may wonder how
    the `completion` method defined in `deleteDocumentAtIndex` gets called, though.
    It gets called at the end of `getFileSystem()`. It checks to see if the `completion`
    property has been set (which we do at the beginning of `deleteDocumentAtIndex`),
    and if it has, it calls it. This is a pattern a lot of our operations will follow.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功删除后，我们需要重新读取文件系统，以便我们的`documents`数组保持最新。我们通过调用`getFileSystem()`来实现这一点。你可能想知道在`deleteDocumentAtIndex`中定义的`completion`方法是如何被调用的。它是在`getFileSystem()`的末尾被调用的。它会检查`completion`属性是否已经设置（我们在`deleteDocumentAtIndex`的开始处这样做），如果设置了，就会调用它。这是我们许多操作将遵循的模式。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Renaming a document is simply a `moveTo` operation to the same directory. It
    follows the same pattern of operation as the preceding `delete` operation. Note
    that there is no check here for the new name of the file for if it isn't already
    being used by an existing file. If there is a name conflict, the new file will
    overwrite the old file, not likely something you want to occur. Since the preceding
    `deletion` method doesn't ask, we won't ask here either, but it is something you
    should do in the app itself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名文档只是将`moveTo`操作应用于同一目录。它遵循与前面的`delete`操作相同的操作模式。请注意，这里没有检查新文件名是否已被现有文件使用。如果有名称冲突，新文件将覆盖旧文件，这很可能不是你想要发生的事情。由于前面的`deletion`方法没有询问，我们这里也不会询问，但这是你在应用本身中应该做的事情。
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Copying is again remarkably similar to renaming, as seen in the prior code;
    the difference is that we use `copyTo` instead of `moveTo`. The operation is also
    a bit different; if you were to try to copy over an existing document, the attempt
    fails, unlike moving over an existing document.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 复制与重命名非常相似，如前代码所示；区别在于我们使用`copyTo`而不是`moveTo`。操作也略有不同；如果你尝试复制一个现有的文档，尝试会失败，这与移动现有文档不同。
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `createDocument()` method creates a new file in the directory and after
    it does so, it re-reads the filesystem. This demonstrates an alternative to using
    `…Success()` methods. It works just the same, though. Just like renaming, this
    can be dangerous if a file with the same name already exists, so be sure to check
    before calling this method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`createDocument()`方法在目录中创建一个新文件，并在这样做之后重新读取文件系统。这展示了使用`…Success()`方法的替代方案。它的工作方式完全相同。就像重命名一样，如果已经存在具有相同名称的文件，这可能会很危险，所以调用此方法之前一定要检查。'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As seen in the prior code, opening a document is very similar to creating a
    document, except we don't ask the filesystem to create it if it doesn't exist.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码所示，打开文档与创建文档非常相似，只是我们不会要求文件系统在它不存在时创建它。
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Some operations, such as creating and opening a document, also set the `fileEntry`
    property to the newly opened document. This is handy for use when asking a note
    to open itself. It can read in contents of the file in this property.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作，如创建和打开文档，也会将`fileEntry`属性设置为新打开的文档。这在要求笔记打开自身时很有用。它可以读取此属性中的文件内容。
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we mentioned prior to looking at the code for our model, we said that we'd
    initiate a directory read upon creation, and this is what we're doing at the end
    of the model. That way, when we create an object, it will instantly go to work
    reading the entries in the directory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们模型的代码之前，我们提到过，我们会在创建时初始化目录读取，这就是模型末尾所做的工作。这样，当我们创建一个对象时，它会立即开始读取目录中的条目。
- en: 'Now, let''s look at the code for a single document:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看单个文档的代码：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code should be self-explanatory now. Next up, in the following
    code, we see how to read the contents of a file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码现在应该是自解释的。接下来，在下面的代码中，我们看到如何读取文件的内容：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When requesting to read a file, we have to call the `file()` method of the file's
    corresponding `fileEntry`. If it finds the file, it'll call `gotFile()` , but
    if it can't read it, for some reason, it'll call `dispatchFailure()`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求读取文件时，我们必须调用文件对应的`fileEntry`的`file()`方法。如果它找到了文件，它会调用`gotFile()`，但如果由于某种原因它无法读取，它会调用`dispatchFailure()`。
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once we've got the file, we have to create a `FileReader` variable for it. Unlike
    other API calls, we have to set up some event handlers, but they mean the same
    thing here as `completion` and `failure`. Then we ask the reader to read the file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了文件，我们必须为它创建一个`FileReader`变量。与其他API调用不同，我们必须设置一些事件处理程序，但它们在这里与`completion`和`failure`意味着相同的事情。然后我们要求读者读取文件。
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once we are here, `e.target.result` has the contents of the entire file. Now
    we can try to load it in.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达这里，`e.target.result`就有整个文件的内容。现在我们可以尝试加载它。
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If there's nothing in the file, we set up some reasonable defaults. Notice that
    we're using `JSON` here. This is because we'll be storing our file in the `JSON`
    file format.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件中没有内容，我们会设置一些合理的默认值。注意，我们在这里使用`JSON`。这是因为我们将文件存储在`JSON`文件格式中。
- en: Next, we try to parse the contents of the file as `JSON`. This is where the
    `try/catch` block comes in. If we can't parse the contents of the file, we'll
    get an error and we can call the `failure` function. But if we do parse it correctly,
    we can set our own `title` and `text` to the file's `title` and `text`, and we'll
    have successfully loaded the file's contents.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试将文件内容解析为`JSON`。这就是`try/catch`块发挥作用的地方。如果我们无法解析文件内容，我们会得到一个错误，并可以调用`failure`函数。但如果我们正确解析了它，我们可以将我们自己的`title`和`text`设置为文件的`title`和`text`，这样我们就成功加载了文件的内容。
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Saving a file isn't terribly different than loading a file, except that we can
    create the file writer directly from the `fileEntry` property rather than calling
    `file()` first. In `gotFileWriter` , though, we have to set similar events before
    calling `write()` with the file contents. We `stringify` the results of `serialize()`
    so that it is in a proper `JSON` format.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件与加载文件并没有太大的不同，只是我们可以直接从`fileEntry`属性创建文件写入器，而不是首先调用`file()`。然而，在`gotFileWriter`中，在调用`write()`文件内容之前，我们必须设置类似的事件。我们将`serialize()`的结果`stringify`，使其成为正确的`JSON`格式。
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Speaking of serialization, here's the method that does it. Not hard, but you
    may be asking why we didn't just stringify `self`. And that's a great question.
    Turns out you can't stringify objects that contain methods, because it will lose
    those methods; so that's one reason. Another reason is that we really don't need
    to save the entire object, just the title and the text; so instead of saving a
    lot of stuff we don't need, we'll just return an object that has exactly what
    we need.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到序列化，这里就是实现它的方法。并不难，但你可能会问为什么我们不是直接将`self`转换为字符串。这是一个很好的问题。实际上，你不能将包含方法的对象转换为字符串，因为这会丢失那些方法；所以这是其中一个原因。另一个原因是，我们实际上并不需要保存整个对象，只需要标题和文本；所以，我们不会保存我们不需要的大量东西，而是只返回一个包含我们所需内容的对象。
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Like our first model, we ask the document here to load its file contents immediately
    upon creation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的第一个模型一样，我们要求文档在创建时立即加载其文件内容。
- en: What did we do?
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this section, we created two data models, one for the list of available documents
    in a directory, and the second for the actual note itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了两个数据模型，一个用于目录中可用的文档列表，另一个用于实际的笔记本身。
- en: What else do I need to know?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要知道什么？
- en: The File API is notoriously hard to get used to, especially for programmers
    who assume that the order of processing is always the next statement after this
    one. The File API, however, does things differently, by requiring each operation
    to have a `success` and `failure` callback. Furthermore, there are several operations
    when reading or saving a file (or when reading a directory), and as such the callback
    chain can start to get pretty confusing. This is generally why I try to make separate
    functions instead of inline callbacks, but there are times when inline callbacks
    make the most sense.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 文件API因其难以适应而闻名，尤其是对于认为处理顺序总是紧随其后语句的程序员来说。然而，文件API的工作方式却不同，它要求每个操作都必须有一个`success`和`failure`回调。此外，在读取或保存文件（或读取目录）时，有几个操作，因此回调链可能会变得相当混乱。这通常是我尝试使用单独的函数而不是内联回调的原因，但有时内联回调才是最合适的。
- en: The File API can do more than what we've covered here, so you'd do well to go
    take a look at it at [http://docs.phonegap.com/en/edge/cordova_file_file.md.html#File](http://docs.phonegap.com/en/edge/cordova_file_file.md.html#File).
    Just remember how the callbacks work and you'll be fine, even if your code will
    feel a bit spaghetti-ish.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 文件API可以做的不仅仅是这里所涵盖的，所以你最好去查看一下[http://docs.phonegap.com/en/edge/cordova_file_file.md.html#File](http://docs.phonegap.com/en/edge/cordova_file_file.md.html#File)。只需记住回调的工作方式，你就可以做得很好，即使你的代码可能感觉有点像意大利面一样。
- en: Implementing documents view
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现文档视图
- en: The documents view will be used to display the list of available documents to
    the end user. It will also permit the user to create a document, rename a document,
    copy a document, and delete a document.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 文档视图将用于向最终用户显示可用的文档列表。它还将允许用户创建文档、重命名文档、复制文档和删除文档。
- en: 'Let''s take a quick look at the finished product, on iOS first:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下最终产品，首先是iOS版本：
- en: '![Implementing documents view](img/9403_03_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![实现文档视图](img/9403_03_05.jpg)'
- en: 'For Android, the view will be as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，视图将如下所示：
- en: '![Implementing documents view](img/9403_03_06.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![实现文档视图](img/9403_03_06.jpg)'
- en: Notice that the screenshot for the iPhone has a totally different look and feel
    than the Android screenshot. While many apps for the iPhone use the alternative
    method used for Android, the method of scrolling horizontally through large document
    representations is more common on the iPhone, and is what we use here. Thankfully,
    it only takes a small code change and some CSS to render the two disparate looks.
    Otherwise, they function identically.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，iPhone的截图与Android的截图在外观和感觉上完全不同。虽然许多iPhone应用使用Android使用的替代方法，但在iPhone上，通过水平滚动大文档表示的方法更为常见，这也是我们在这里使用的方法。幸运的是，这只需要少量的代码更改和一些CSS即可渲染两种截然不同的外观。否则，它们的功能是相同的。
- en: Getting on with it
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始吧
- en: 'As always, we''re going to start with the HTML portion of the view. The boilerplate
    portion is virtually identical to our previous apps, so we''ll start with the
    template instead:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将从视图的HTML部分开始。样板部分几乎与我们的前一个应用相同，所以我们将从模板开始：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This template defines the HTML for each document we display. It's not terribly
    complicated. Note that we have `onClick` handlers for each portion of the template
    that can respond to touch, but beyond that the style is controlled in `style.css`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板定义了我们显示的每个文档的HTML。它并不复杂。注意，我们为模板的每个可以响应触摸的部分都设置了`onClick`处理程序，但除此之外，样式由`style.css`控制。
- en: 'Let''s take a look at the code that powers this view:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看驱动这个视图的代码：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First up, our properties. `lastScrollLeft` is for maintaining our scroll position
    when we switch between views. `myScroll` will hold our scroller (for iOS and Android),
    and `availableDocuments` will hold all the documents the filesystem has for our
    app.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是我们的属性。`lastScrollLeft`用于在切换视图时保持我们的滚动位置。`myScroll`将保存我们的滚动器（用于iOS和Android），而`availableDocuments`将保存文件系统为我们应用提供的所有文档。
- en: The `initializeView()` method is so similar to our previous projects (refer
    to the *Implementing the start view* section of [Project 1](ch01.html "Chapter 1. Let's
    Get Local!"), *Let's Get Local!*), I'll go ahead and skip it and jump to `displayAvailableDocuments()`
    (which the `initializeView()` method does call).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeView()`方法与我们的前一个项目非常相似（参考[项目1](ch01.html "第一章：让我们本地化！")中的*实现起始视图*部分），我将跳过它，直接跳到`displayAvailableDocuments()`（`initializeView()`方法确实调用了它）。'
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, we create a new `DOCS.Filers` object. Remember that this will immediately
    send a request to the filesystem for all the files it contains that we can use.
    When it successfully completes that request, it will call `documentsView.documentIterator()`,
    a method that will go over each item in the list and render the preceding template.
    If it fails, however, it calls the `failure` function defined earlier and displays
    an alert message.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的 `DOCS.Filers` 对象。记住，这将立即向文件系统发送请求，获取我们可用的所有文件。当它成功完成请求时，它将调用 `documentsView.documentIterator()`
    方法，该方法将遍历列表中的每个项目并渲染前面的模板。如果失败，它将调用之前定义的 `failure` 函数并显示一个警告消息。
- en: This is big; we're no longer using the in-built `alert()` method! Instead, we're
    creating a new `Alert` object with the title of `Oops!` and `I couldn't read your
    persistent storage!` Granted, not the best error message in the world, but if
    this does occur, we're essentially toast anyway. The bigger issue is that this
    object, which we'll cover in more detail as we progress through this task, provides
    us with platform-specific non-native alerts. This means we can customize them
    to our needs; in this case that isn't much, we're displaying an error message,
    but the `PKUI.MESSAGE` namespace provides options for prompts as well. The `Alert`
    object also gives us the ability to specify a callback when a button is pressed,
    very useful if we need to ask a Yes/No question.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很大的变化；我们不再使用内置的 `alert()` 方法！相反，我们创建了一个新的 `Alert` 对象，标题为 `Oops!` 和 `I couldn't
    read your persistent storage!` 虽然这并不是世界上最好的错误消息，但如果这种情况发生，我们实际上已经失败了。更大的问题是，这个对象，我们将在完成这个任务的过程中更详细地介绍，为我们提供了平台特定的非原生警告。这意味着我们可以根据需要自定义它们；在这种情况下，这并不多，我们只是显示一个错误消息，但
    `PKUI.MESSAGE` 命名空间提供了提示选项。`Alert` 对象还允许我们在按钮按下时指定一个回调，这在需要询问是/否问题时非常有用。
- en: The next method, `reloadAvailableDocuments()`, is so similar to the earlier
    method that I'll also skip it. It's only used when the file view is being popped
    off the view stack.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是 `reloadAvailableDocuments()`，它与之前的方法非常相似，所以我也会跳过它。它仅在文件视图从视图堆栈中弹出时使用。
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is a pretty simple function: all we do is iterate through the documents
    that are returned from the filesystem and create a new instance of the `documentsView_documentTemplate`
    template. We''re using a new convenience method called `PKUTIL.instanceOfTemplate()`
    to make this easier. It will take a DOM element and an object containing the properties
    that should be replaced, in this case, `title` and `index`, along with their corresponding
    values. (The `substr()` method is used to chop off the file extension.)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的函数：我们只是遍历从文件系统返回的文档，并为 `documentsView_documentTemplate` 模板创建一个新的实例。我们使用一个新的便利方法
    `PKUTIL.instanceOfTemplate()` 来简化这个过程。它将接受一个 DOM 元素和一个包含应替换的属性的对象，在这个例子中是 `title`
    和 `index` 以及它们对应的值。（使用 `substr()` 方法来截断文件扩展名。）
- en: This method is doing the same thing we were doing manually before, using `replace()`,
    but it does it better. If you hadn't noticed, we were cleverly avoiding using
    the same substitution variable in our templates more than once. This is because
    `replace()` only replaces one instance at a time. Our convenience method keeps
    calling `replace()` until all instances are replaced, which means we can now use
    `%TITLE%` and `%INDEX%` all we want.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法执行的是我们之前手动执行的任务，使用 `replace()`，但它做得更好。如果你没有注意到，我们巧妙地避免在我们的模板中多次使用相同的替换变量。这是因为
    `replace()` 只能一次替换一个实例。我们的便利方法会一直调用 `replace()`，直到所有实例都被替换，这意味着我们现在可以随意使用 `%TITLE%`
    和 `%INDEX%`。
- en: The portion of code specific to iOS simply determines the width of the content
    area for scrolling purposes. For Android, this code isn't executed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 专门针对 iOS 的代码部分只是确定内容区域的宽度，以便进行滚动。对于 Android，这段代码不会执行。
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Opening a document occurs when a user taps on the document's icon. (For Android,
    this is something you should think about changing, but for the purposes of this
    app, we'll keep consistent).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文档发生在用户点击文档图标时。（对于 Android，这是你应该考虑更改的事情，但为了这个应用的目的，我们将保持一致。）
- en: We call `openDocumentAtIndex()` and pass along the `completion` and `failure`
    functions that are called when the document is opened. The `success` method will
    set the `fileEntry` property of the `fileView` method and then push it on to the
    screen. This act will trigger loading the contents as well. Failure will log the
    error to the console, though you probably should add a meaningful error alert
    as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`openDocumentAtIndex()`并传递当文档打开时被调用的`completion`和`failure`函数。`success`方法将设置`fileView`方法的`fileEntry`属性，并将其推送到屏幕上。这一行为将触发加载内容。失败将错误记录到控制台，尽管您可能还应该添加一个有意义的错误警报。
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Welcome to the wonderful world of chaining callbacks! We have two steps to create
    a document. First, we ask the user what they want to name the document (using
    an admittedly obtuse default). Then we create the document, which means we have
    to have another success/failure callback. If we fail to create the document, we
    create another alert to further confuse matters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到链式回调的奇妙世界！创建一个文档需要两个步骤。首先，我们询问用户希望将文档命名为什么（使用一个公认的晦涩的默认值）。然后我们创建文档，这意味着我们必须有另一个成功/失败回调。如果我们无法创建文档，我们将创建另一个警报来进一步混淆问题。
- en: The big deal, though, is that our initial request of the user is actually giving
    them a chance to type something in to our alert message! We've not done this yet
    in any of our apps, and this is monumental. Furthermore, we have custom buttons—a
    `Don't Create` button and a `Create` button.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，真正重要的是，我们最初对用户的请求实际上是在给他们一个机会在我们的警报消息中输入一些内容！在我们所有的应用中，我们还没有这样做过，这是一个巨大的进步。此外，我们还有自定义按钮——一个“不创建”按钮和一个“创建”按钮。
- en: If you're wondering what the `<` and `>` are in the preceding code attached
    to the buttons – great catch! These are used primarily for iOS, though you could
    extend these to the other platforms as well. iOS has the concept of a destructive
    action; these buttons should always be colored red. (Or, if the locale that you
    are targeting uses a different color, use that color instead.) It also has the
    concept of **Cancel** button colors (typically a darker gray). To add to it, we
    decided to color buttons that would go to the next step in the process green.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道前面代码中按钮旁边的`<`和`>`是什么——太棒了！这些主要用于iOS，尽管您也可以将这些扩展到其他平台。iOS有破坏性行动的概念；这些按钮应该总是用红色。或者，如果您要针对的本地使用不同的颜色，请使用该颜色。它还有**取消**按钮颜色的概念（通常是较深的灰色）。为了增加这一点，我们决定将进行下一步操作的按钮涂成绿色。
- en: Each of these gets a special character at the end of the button's name. For
    example, `Cancel<` would color the button a darker color and use the text of `Cancel`
    for the button. `Go>` would use `Go` as the text, and color the button green.
    `Delete*`, on the other hand, would use `Delete` as the text, but color the button
    red.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮的每个都将在按钮名称的末尾得到一个特殊字符。例如，`Cancel<`将使按钮颜色变深，并使用`Cancel`的文本作为按钮。`Go>`将使用`Go`作为文本，并将按钮涂成绿色。另一方面，`Delete*`将使用`Delete`作为文本，但将按钮涂成红色。
- en: 'Just so you have a good idea of what an alert/prompt will look like on each
    system, here''s an example for iOS:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您对每个系统上的警报/提示有一个良好的了解，这里是一个iOS的示例：
- en: '![Getting on with it](img/9403_03_11.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_03_11.jpg)'
- en: 'For Android, the view will be as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，视图将如下所示：
- en: '![Getting on with it](img/9403_03_12.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_03_12.jpg)'
- en: 'Renaming a document is somewhat similar to creating a new document, except
    that we won''t display the document at the end. We will ask the user what the
    new name should be, and if they choose to continue, we''ll try to perform the
    function. The following code snippet can be used for this action:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名文档与创建新文档有些相似，但我们在最后不会显示文档。我们将询问用户新的名称应该是什么，如果他们选择继续，我们将尝试执行该功能。以下代码片段可以用于此操作：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If there is a failure of some sort, we'll indicate this by displaying an error,
    once as a `failure` function, and second in the `catch` portion of the `try`/`catch`
    block.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生某种类型的失败，我们将通过显示一个错误来表示，一次作为“失败”函数，第二次在“try”/“catch”块的“catch”部分。
- en: Note that, as written, we make no check here to see if the new name would conflict
    with another file. Therefore, if the user renamed one file to the name of another,
    the previous file would be overwritten. You should add an additional check in
    your code to make sure that the new file name doesn't already exist.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，按照目前的写法，我们没有检查新的名称是否会与其他文件冲突。因此，如果用户将一个文件重命名为另一个文件的名称，则之前的文件将被覆盖。您应该在代码中添加一个额外的检查，以确保新的文件名尚未存在。
- en: 'The `copyDocument()` method is nearly identical, so we''ll skip it and move
    on to the `deleteDocument()` method shown in the following code snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyDocument()`方法几乎相同，所以我们将跳过它，转到以下代码片段中显示的`deleteDocument()`方法：'
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Deleting a document is much more simple than copying or renaming one, so we're
    not delving as deep in a callback chain here. The primary thing I wanted to point
    out was the use of the `*` to indicate that the `Remove` button would display
    as a red button to warn the user that it was a destructive action on iOS. Android
    silently ignores this flag, though you could modify the framework to display similar
    colors as well on Android
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文档比复制或重命名文档要简单得多，所以我们在这里不会深入回调链。我想强调的主要一点是使用`*`来表示“删除”按钮将以红色按钮的形式显示，以警告用户在iOS上这是一个破坏性操作。尽管如此，你仍然可以修改框架，在Android上也显示类似的颜色。
- en: The remaining methods are similar to those in the previous views, so we'll go
    ahead and skip them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的方法与之前视图中的方法类似，所以我们将跳过它们。
- en: What did we do?
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: Though there is a lot of room to improve, we've created a pretty good document
    manager for our app. We've permitted the user to rename their files, delete them,
    copy them, open them, and create them, all things a good file manager should do.
    The only thing we didn't do was permit the user to share them, though the intent
    is there with the pleasant **Share** icon. This was only in the interest of space,
    and because it is a subject that we've covered before.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然还有很多改进的空间，但我们已经为我们的应用程序创建了一个相当不错的文档管理器。我们允许用户重命名文件、删除文件、复制文件、打开文件和创建文件，这些都是一个好的文件管理器应该做的。唯一我们没有做的是允许用户共享文件，尽管有一个愉快的**分享**图标表示这个意图。这只是为了节省空间，并且因为这是一个我们之前已经讨论过的话题。
- en: What else do I need to know?
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: 'There are plenty of things we *haven''t* covered in this file manager of ours,
    and they''re big ones and definitely things you need to think about implementing
    on your own. The code itself would be self-explanatory, so we won''t go into great
    detail, but here are the primary issues:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个文件管理器中，还有很多我们没有涉及的内容，它们都是重要的问题，而且肯定是你需要考虑自己实现的功能。代码本身是自我解释的，所以我们不会深入细节，但以下是一些主要问题：
- en: 'Filenames can''t contain certain characters: Everyone handles this somewhat
    differently; you could display an error to the user indicating that they need
    to pick different characters or you could silently change them to something else
    (typical for iOS). Either way, you should check for them prior to creating a new
    file or renaming/copying a document.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名不能包含某些字符：每个人处理这个问题的方式都有些不同；你可以向用户显示一个错误信息，告诉他们需要选择不同的字符，或者你可以默默地将其更改为其他内容（这在iOS中很常见）。无论如何，你都应该在创建新文件或重命名/复制文档之前检查这些字符。
- en: 'Create/Rename operations can overwrite existing data: You''d think that since
    a copy operation will fail if the destination file exists, that rename/create
    would also. Unfortunately, no. They''ll just overwrite the file. You must iterate
    over the entire directory structure in order to determine if you''re about to
    overwrite an existing file! Users don''t like losing data, even if they themselves
    were the cause.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建/重命名操作可能会覆盖现有数据：你会认为由于复制操作如果目标文件存在会失败，那么重命名/创建也会失败。不幸的是，并非如此。它们会直接覆盖文件。你必须遍历整个目录结构，以确定你是否即将覆盖一个现有的文件！用户不喜欢丢失数据，即使他们自己是原因。
- en: 'Opening a document for non-iOS users: Android users shouldn''t need to know
    that tapping the icon will open the document; they''ll assume the entire area
    is tappable (minus the icons). So it would be a good idea to give them another
    icon for renaming a file and allow the filename itself (as well as the document
    icon) to open the file instead of renaming the file.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为非iOS用户打开文档：Android用户不应该需要知道点击图标会打开文档；他们会假设整个区域都是可点击的（除了图标）。因此，为它们提供一个用于重命名文件的另一个图标，并允许文件名本身（以及文档图标）打开文件，而不是重命名文件，这会是一个好主意。
- en: 'iOS document images should reflect the contents of the file: This one''s harder
    to implement, granted, but typically the document icon would contain some portion
    of the actual contents of the file. There are various ways of doing this, from
    reading the actual contents in and displaying them over the DOM (and clipping
    them after some portion) to rendering them to an HTML `canvas` tag and saving
    the result as a thumbnail. Either way, it''s something the user will expect.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS文档图像应反映文件的内容：这个实现起来可能更困难，但通常文档图标会包含文件实际内容的某个部分。有各种方法可以实现这一点，从读取实际内容并在DOM上显示它们（并在某个部分后剪辑它们）到将它们渲染到HTML
    `canvas` 标签并将结果保存为缩略图。无论如何，这是用户会期望的。
- en: Implementing the file view
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现文件视图
- en: 'This view is pretty easy; actually it''s essentially a big `TEXTAREA` element
    with some code to automatically save the contents every few seconds. Let''s take
    a look at how it will render on each platform, first for iOS:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图相当简单；实际上它本质上是一个大的 `TEXTAREA` 元素，带有一些代码，每隔几秒自动保存内容。让我们看看它将在每个平台上如何渲染，首先是iOS：
- en: '![Implementing the file view](img/9403_03_08.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![实现文件视图](img/9403_03_08.jpg)'
- en: 'For Android, the view will be as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，视图将如下所示：
- en: '![Implementing the file view](img/9403_03_09.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![实现文件视图](img/9403_03_09.jpg)'
- en: All of these look pretty similar and reflect the simplicity of the view.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都看起来很相似，反映了视图的简单性。
- en: Getting on with it
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'The HTML portion of the view is much like prior views, so we''ll skip that
    for now. Just know that there is a `TEXTAREA` element named `fileView_text` that
    our code will reference. There is also an `onClick` handler on the title bar to
    enable changing the title of the note. These are seen in the following code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的HTML部分与先前的视图非常相似，所以我们现在先跳过它。只需知道，有一个名为 `fileView_text` 的 `TEXTAREA` 元素，我们的代码将引用它。还有一个在标题栏上的
    `onClick` 处理器，用于启用更改笔记标题。这些在以下代码片段中可以看到：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As always, we have several properties. The first is intended to store information
    about the file we're currently working on, while the second is the actual document
    contents. The last property will store a value returned by `setInterval()`, this
    is used to call our auto-save functionality every few seconds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们有几个属性。第一个是用来存储我们目前正在处理的文件的信息，而第二个是实际的文档内容。最后一个属性将存储由 `setInterval()`
    返回的值，这用于每隔几秒调用我们的自动保存功能。
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we just provide a way for the `documentView` method to tell us which file
    to work with.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是提供了一个方法，让 `documentView` 方法告诉我们要使用哪个文件。
- en: 'The next method, `initializeView()`, is similar enough to the other views that
    we''ll skip over it. Next up is `entitleDocument()` shown in the following code
    snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法 `initializeView()` 与其他视图足够相似，所以我们将其跳过。接下来是 `entitleDocument()`，如下代码片段所示：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the title is tapped, we'll display a prompt to the user that enables them
    to change the title of the note.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击标题时，我们将向用户显示一个提示，使他们能够更改笔记的标题。
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Loading the contents of a specific document is accomplished by creating a new
    `DOC.Filer()` object using the contents of our `fileEntry` property. This is assumed
    to have been set by `documentView` prior to pushing us onto the view stack.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新的 `DOC.Filer()` 对象并使用我们的 `fileEntry` 属性的内容来加载特定文档的内容。这假设在将我们推入视图堆栈之前已经由
    `documentView` 设置。
- en: Upon successfully parsing the document, we set the navigation bar's title to
    the document's title, and the `TEXTAREA` element's contents to the note's text.
    Then we set up the auto-save at an interval of five seconds.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功解析文档后，我们将导航栏的标题设置为文档的标题，并将 `TEXTAREA` 元素的文本内容设置为笔记的文本。然后我们设置每五秒自动保存一次。
- en: If, for some reason, we can't open the file, we'll display an error, but we'll
    also pop ourselves off the view stack. No sense in displaying an editor if we
    can't even open the file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因我们无法打开文件，我们将显示一个错误，但也会从视图堆栈中弹出我们自身。如果我们甚至无法打开文件，就没有必要显示编辑器。
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Saving the contents is a simple affair. We copy the text from the `TEXTAREA`
    element and put in the `Filer` object. Then we ask it to save the contents of
    the file. If it is successful, we just log a message to the console (something
    you'd remove in a production app), and if it isn't, we display an error and pop
    the view. (Whether popping the view is a good idea or not is debatable.)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 保存内容是一件简单的事情。我们从 `TEXTAREA` 元素中复制文本，并将其放入 `Filer` 对象中。然后我们要求它保存文件的内容。如果成功，我们只需在控制台（在生产应用中你会移除它）中记录一条消息，如果不成功，我们显示一个错误并弹出视图。（弹出视图是否是一个好主意是有争议的。）
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our `viewWillAppear()` method is pretty simple: we kick off a load of our note.
    This means that by setting `fileEntry` and pushing us on the view stack, we''ll
    automatically load the contents of the note.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`viewWillAppear()`方法相当简单：我们启动加载我们的笔记。这意味着通过设置`fileEntry`并将我们推入视图堆栈，我们将自动加载笔记的内容。
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our `viewWillHide()` method is a little more complex. Here we disable our auto-save.
    After all, we don't want to be saving a document that is no longer open. Then
    we force-save the document. Perhaps the user is navigating back in between an
    auto-save interval; they wouldn't want to lose any data, right?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`viewWillHide()`方法稍微复杂一些。在这里，我们禁用了自动保存功能。毕竟，我们不想保存一个已经不再打开的文档。然后我们强制保存文档。也许用户在自动保存间隔之间正在导航；他们不希望丢失任何数据，对吧？
- en: After we save the contents, we also force the `documentsView` method to reload
    the list of documents. This isn't a big deal when we're-editing existing documents,
    but it is a big deal when we're creating new documents, as we want the file manager
    to be able to display our newly created note.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存内容后，我们还强制`documentsView`方法重新加载文档列表。当我们编辑现有文档时，这并不是什么大问题，但当我们创建新文档时，这却是一个大问题，因为我们希望文件管理器能够显示我们新创建的笔记。
- en: What did we do?
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We created a simple text editor view that can open file contents and save them
    back again. It implements a simple auto-save function as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的文本编辑视图，可以打开文件内容并将其保存回来。它还实现了一个简单的自动保存功能。
- en: What else do I need to know?
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: Most of the devices that you will be targeting use soft keyboards for input.
    This means that some portion of the screen will be covered by the onscreen keyboard.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要针对的大多数设备都使用软键盘进行输入。这意味着屏幕的一部分将被屏幕键盘覆盖。
- en: How each device does this differs by platform and type of keyboard. For example,
    Android permits many different keyboards to be installed, and not every keyboard
    does things the same way.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备如何做这取决于平台和键盘类型。例如，Android允许安装许多不同的键盘，而且不是每个键盘都以相同的方式操作。
- en: Essentially, though, what happens is the available real-estate is moved or resized
    to permit the onscreen keyboard. This means our user interface also moves along
    with the keyboard. Whether or not this is done fluidly depends on the platform
    (and on Android, the keyboard itself, to some extent). iOS does this the best;
    there's a minimum of fuss involved, and the display scrolls neatly to ensure the
    text remains on the screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，所发生的情况是可用的空间被移动或调整大小，以允许显示屏幕键盘。这意味着我们的用户界面也会随着键盘一起移动。这种操作是否流畅取决于平台（在Android上，键盘本身在一定程度上也起到作用）。iOS在这方面做得最好；涉及到的麻烦最小，显示屏滚动得也很整洁，以确保文本保持在屏幕上。
- en: Android has a tendency to flicker a bit while they do this, unfortunately, and
    there's very little we can do to control how the keyboard itself appears.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在执行此操作时，Android会有一些闪烁，而我们几乎无法控制键盘本身的外观。
- en: One interesting option would be to implement the soft keyboard ourselves in
    pure HTML, CSS, and JavaScript. Technically this can work, but it remains a pretty
    large hack, and your soft keyboard won't really ever act like the legitimate keyboard
    on the platform. (And on Android, fans of a particular keyboard configuration
    will instantly hate it.) You'd also have to take into account the case when a
    user has connected a Bluetooth keyboard. This typically prevents the soft keyboard
    from appearing, which means the full real-estate of the screen is used for our
    display. Since there's no way (short of developing our own plugin) to determine
    if a hard keyboard is attached, we highly advise against using this option.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的选择可能是我们自己用纯HTML、CSS和JavaScript实现软键盘。技术上这可以行得通，但这仍然是一个相当大的漏洞，而且你的软键盘永远不会像平台上的合法键盘那样工作。（在Android上，喜欢特定键盘配置的用户会立刻讨厌它。）你还得考虑用户连接了蓝牙键盘的情况。这通常会导致软键盘不显示，这意味着屏幕的全部空间都被用于我们的显示。由于没有方法（除非开发我们自己的插件）来确定是否连接了物理键盘，我们强烈建议不要使用这个选项。
- en: Some Android distributions also add an interesting quirk. It appears that `input`
    and `textarea` elements actually display another editable region above themselves
    when being edited. On my phone, this was visible by having a portion of the flashing
    cursor visible just underneath the current editor, almost as if the DOM element
    was just a mirror of a native input element. It wouldn't have been noticeable
    except for the fact that they were slightly misaligned. Odd, anyway, and I thought
    I would mention it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Android发行版还添加了一个有趣的特性。看起来当`input`和`textarea`元素被编辑时，实际上会在它们自己上方显示另一个可编辑区域。在我的手机上，这通过当前编辑器下方可见的闪烁光标的一部分来体现，几乎就像DOM元素只是原生输入元素的镜像。如果不是因为它们略有错位，这不会引起注意。无论如何，我觉得应该提一下。
- en: Game Over..... Wrapping it up
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束..... 结束语
- en: We've accomplished quite a lot in this task and while none if it is particularly
    glorious, it is absolutely necessary for what's ahead. Our apps must be able to
    store data permanently and they must also be able to retrieve that same data.
    Likewise, they need to provide methods for managing that data, including renaming,
    duplicating, and deleting it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个任务中已经取得了相当多的成就，虽然这些成就并不特别辉煌，但对于接下来的工作来说绝对是必要的。我们的应用程序必须能够永久存储数据，并且它们还必须能够检索相同的数据。同样，它们需要提供管理这些数据的方法，包括重命名、复制和删除。
- en: Can you take the HEAT? The Hotshot Challenge
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受高温吗？热手挑战
- en: 'There are several ways you can improve upon this app:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以改进这个应用程序：
- en: Our app only asks the user if they really want to delete a file, but other operations
    are equally dangerous. Add in confirmations if the action the user is about to
    perform would overwrite data (for example, renaming a document to an existing
    document's name or creating a document with the same name as an existing document).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序只询问用户是否真的想要删除文件，但其他操作同样危险。如果用户即将执行的操作会覆盖数据（例如，将文档重命名为现有文档的名称或创建与现有文档同名的新文档），则应添加确认提示。
- en: Add functionality to check if the filename a user is supplying is valid. Then,
    either indicate this to the user or silently change the invalid characters to
    valid characters.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加功能以检查用户提供的文件名是否有效。然后，要么向用户指示这一点，要么将无效字符静默地更改为有效字符。
- en: We don't provide subdirectory functionality, but there's no reason why you couldn't.
    In fact, we explicitly ignore subdirectories in our code, as they add a lot of
    complexity to the file management system. Why don't you add subdirectory management
    to the app?
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有提供子目录功能，但你完全有能力做到。实际上，我们在代码中明确忽略了子目录，因为它们会给文件管理系统增加很多复杂性。你为什么不给应用程序添加子目录管理功能呢？
- en: Instead of storing notes, perhaps you could store some forms instead. Perhaps
    simple addresses or reminders—really, just about anything.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是存储笔记，也许你可以存储一些表格。也许是一些简单的地址或提醒——实际上，几乎可以是任何东西。
