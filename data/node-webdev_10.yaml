- en: Authenticating Users with a Microservice
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 通过微服务对用户进行身份验证
- en: Now that our Notes application can save its data in a database, we can think
    about the next phase of making this a real application—namely, authenticating
    our users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Notes应用程序可以将数据保存在数据库中，我们可以考虑下一步，即使这成为一个真正的应用程序的下一阶段，即对用户进行身份验证。
- en: It's so natural to log in to a website to use its services. We do it every day,
    and we even trust banking and investment organizations to secure our financial
    information through login procedures on a website. The **HyperText Transfer Protocol**
    (**HTTP**) is a stateless protocol, and a web application cannot tell much about
    one HTTP request compared with another. Because HTTP is stateless, HTTP requests
    do not natively know the user's identity, whether the user driving the web browser
    is logged in, or even whether the HTTP request was initiated by a human being.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 登录网站并使用其服务是非常自然的。我们每天都这样做，甚至信任银行和投资机构通过网站上的登录程序来保护我们的财务信息。超文本传输协议（HTTP）是一种无状态协议，网页应用程序无法通过HTTP请求比较多了解用户的信息。因为HTTP是无状态的，HTTP请求本身并不知道用户的身份，也不知道驱动网络浏览器的用户是否已登录，甚至不知道HTTP请求是否由人发起。
- en: The typical method for user authentication is to send a cookie containing a
    token to the browser, to carry the user's identity, and indicate whether that
    browser is logged in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用户身份验证的典型方法是向浏览器发送包含令牌的cookie，以携带用户的身份，并指示该浏览器是否已登录。
- en: With Express, the best way to do this is with the `express-session` middleware,
    which handles session management with a cookie. It is easy to configure but is
    not a complete solution for user authentication since it does not handle user
    login/logout.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Express，最好的方法是使用`express-session`中间件，它可以处理带有cookie的会话管理。它易于配置，但不是用户身份验证的完整解决方案，因为它不处理用户登录/注销。
- en: The package that appears to be leading the pack in user authentication is Passport
    ([http://passportjs.org/](http://passportjs.org/)). In addition to authenticating
    users against local user information, it supports a long list of third-party services
    against which to authenticate. With this, a website can be developed that lets
    users sign up with credentials from another website—Twitter, for example.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户身份验证方面，似乎领先的包是Passport（[http://passportjs.org/](http://passportjs.org/)）。除了对本地用户信息进行身份验证外，它还支持对长列表的第三方服务进行身份验证。有了这个，可以开发一个网站，让用户使用来自另一个网站（例如Twitter）的凭据进行注册。
- en: We will use Passport to authenticate users against either a locally stored database
    or a Twitter account. We'll also take this as an opportunity to explore a **representational
    state transfer** (**REST**)-based microservice with Node.js.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Passport来对用户进行身份验证，无论是存储在本地数据库中还是Twitter账户中。我们还将利用这个机会来探索基于REST的微服务，使用Node.js。
- en: The rationale is the greater opportunity to increase security by storing user
    information in a highly protected enclave. Many application teams store user information
    in a well-protected barricaded area with a strictly controlled **application programming
    interface** (**API**), and even physical access to the user information database,
    implementing as many technological barriers as possible against unapproved access.
    We're not going to go quite that far, but by the end of the book, the user information
    service will be deployed in its own Docker container.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是通过将用户信息存储在高度保护的飞地中，可以增加安全性的机会更大。许多应用团队将用户信息存储在一个受到严格控制的API和甚至物理访问用户信息数据库的严格控制区域中，尽可能多地实施技术屏障以防止未经批准的访问。我们不会走得那么远，但在本书结束时，用户信息服务将部署在自己的Docker容器中。
- en: 'In this chapter, we''ll discuss the following three aspects of this phase:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下三个方面：
- en: Creating a microservice to store user profile/authentication data.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个微服务来存储用户资料/身份验证数据。
- en: Authenticating a user with a locally stored password.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地存储的密码对用户进行身份验证。
- en: Using OAuth2 to support authentication via third-party services. Specifically,
    we'll use Twitter as a third-party authentication service.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth2支持通过第三方服务进行身份验证。具体来说，我们将使用Twitter作为第三方身份验证服务。
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: The first thing to do is to duplicate the code used for the previous chapter.
    For example, if you kept that code in the `chap07/notes` directory, create a new
    directory, `chap08/notes`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是复制上一章节使用的代码。例如，如果你将该代码保存在`chap07/notes`目录中，那么创建一个新目录`chap08/notes`。
- en: Creating a user information microservice
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户信息微服务
- en: We could implement user authentication and accounts by simply adding a user
    model and a few routes and views to the existing *Notes* application. While that's
    easy, is this what is done in a real-world production application?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地向现有的*Notes*应用程序添加用户模型、一些路由和视图来实现用户身份验证和账户。虽然这很容易，但在真实的生产应用程序中是否会这样做呢？
- en: Consider the high value of user identity information and the super-strong need
    for robust and reliable user authentication. Website intrusions happen regularly,
    and it seems the item most frequently stolen is user identities. To that end,
    we declared earlier an intention to develop a user information microservice, but
    we must first discuss the technical rationale for doing so.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到用户身份信息的高价值和对强大可靠用户身份验证的极大需求。网站入侵经常发生，而似乎最经常被盗窃的是用户身份。因此，我们之前宣布了开发用户信息微服务的意图，但首先我们必须讨论这样做的技术原因。
- en: Microservices are not a panacea, of course, meaning we shouldn't try to force-fit
    every application into the microservice box. By analogy, microservices fit with
    the Unix philosophy of small tools, each doing one thing well, which we mix/match/combine
    into larger tools. Another word for this is composability. While we can build
    a lot of useful software tools with that philosophy, does it work for applications
    such as Photoshop or LibreOffice?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，微服务并不是万能药，这意味着我们不应该试图将每个应用程序都强行塞进微服务的框架中。类比一下，微服务与Unix哲学中的小工具相契合，每个工具都做一件事情很好，然后我们将它们混合/匹配/组合成更大的工具。这个概念的另一个词是可组合性。虽然我们可以用这种哲学构建许多有用的软件工具，但它适用于诸如Photoshop或LibreOffice之类的应用程序吗？
- en: This is why microservices are popular today among application teams. Microservice
    architectures are more agile if used well. And, as we noted earlier, we're aiming
    for a highly secured microservice deployment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么微服务在应用团队中如此受欢迎的原因。如果使用得当，微服务架构更加灵活。正如我们之前提到的，我们的目标是实现高度安全的微服务部署。
- en: 'With that decision out of the way, there are two other decisions to be made
    with regard to security implications. They are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 决定已经做出，还有两个关于安全性影响的决定需要做。它们如下：
- en: Do we create our own REST application framework?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要创建自己的REST应用程序框架吗？
- en: Do we create our own user login/authentication framework?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要创建自己的用户登录/身份验证框架吗？
- en: In many cases, it is better to use a well-regarded existing library where the
    maintainers have already stomped out lots of bugs, just as we used the Sequelize
    **ORM** (**Object-Relational Mapping**) library in the previous chapter, because
    of its maturity. We have identified two libraries for this phase of the Notes
    project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，最好使用一个声誉良好的现有库，其中维护者已经解决了许多bug，就像我们在上一章中使用Sequelize **ORM** (**Object-Relational
    Mapping**)库一样，因为它很成熟。我们已经为Notes项目的这个阶段确定了两个库。
- en: We already mentioned using Passport for user login support, as well as authenticating
    Twitter users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到使用Passport来支持用户登录，以及对Twitter用户进行身份验证。
- en: For REST support, we could have continued using Express, but instead will use
    Restify ([http://restify.com/](http://restify.com/)), which is a popular REST-centric
    application framework.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于REST支持，我们本可以继续使用Express，但我们将使用Restify ([http://restify.com/](http://restify.com/))，这是一个流行的面向REST的应用程序框架。
- en: To test the service, we'll write a command-line tool for administering user
    information in the database. We won't be implementing an administrative user interface
    in the Notes application, and will instead rely on this tool to administer the
    users. As a side effect, we'll have a tool for testing the user service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试服务，我们将编写一个命令行工具，用于管理数据库中的用户信息。我们不会在Notes应用程序中实现管理用户界面，而是依靠这个工具来管理用户。作为一个副作用，我们将拥有一个用于测试用户服务的工具。
- en: Once this service is functioning correctly, we'll set about modifying the Notes
    application to access user information from the service, while using Passport
    to handle authentication.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这项服务正常运行，我们将开始修改Notes应用程序，以从服务中访问用户信息，同时使用Passport来处理身份验证。
- en: The first step is to create a new directory to hold the user information microservice.
    This should be a sibling directory to the Notes application. If you created a
    directory named `chap08/notes` to hold the Notes application, then create a directory
    named `chap08/users` to hold the microservice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新目录来保存用户信息微服务。这应该是Notes应用程序的同级目录。如果您创建了一个名为`chap08/notes`的目录来保存Notes应用程序，那么请创建一个名为`chap08/users`的目录来保存微服务。
- en: 'Then, in the `chap08/users` directory, run the following commands:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`chap08/users`目录中，运行以下命令：
- en: '[PRE0]js\1'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: As with our Sequelize-based model for Notes, we will use a **YAML Ain't Markup
    Language** (**YAML**) file to store connection configuration. We're even using
    the same environment variable, `SEQUELIZE_CONNECT`, and the same approach to overriding
    fields of the configuration. The approach is similar, with a `connectDB` function
    setting up the connection and initializing the SQUsers table.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们基于Sequelize的Notes模型一样，我们将使用**YAML Ain't Markup Language** (**YAML**)文件来存储连接配置。我们甚至使用相同的环境变量`SEQUELIZE_CONNECT`，以及相同的覆盖配置字段的方法。这种方法类似，通过`connectDB`函数设置连接并初始化SQUsers表。
- en: With this approach, we can use a base configuration file in the `SEQUELIZE_CONNECT`
    variable and then use the other environment variables to override its fields. 
    This will be useful when we start deploying Docker containers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们可以使用`SEQUELIZE_CONNECT`变量中的基本配置文件，然后使用其他环境变量来覆盖其字段。当我们开始部署Docker容器时，这将非常有用。
- en: The user profile schema shown here is derived from the normalized profile provided by
    Passport—for more information, refer to [http://www.passportjs.org/docs/profile](http://www.passportjs.org/docs/profile).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的用户配置文件模式是从Passport提供的规范化配置文件派生出来的，有关更多信息，请参阅[http://www.passportjs.org/docs/profile](http://www.passportjs.org/docs/profile)。
- en: The Passport project developed this object by harmonizing the user information
    given by several third-party services into a single object definition. To simplify
    our code, we're simply using the schema defined by Passport.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Passport项目通过将多个第三方服务提供的用户信息协调为单个对象定义来开发了这个对象。为了简化我们的代码，我们只是使用了Passport定义的模式。
- en: 'There are several functions to create that will be an API to manage user data.
    Let''s add them to the bottom of `users-sequelize.mjs`, starting with the following
    code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个函数需要创建，这些函数将成为管理用户数据的API。让我们将它们添加到`users-sequelize.mjs`的底部，从以下代码开始：
- en: '[PRE1]js\1'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: 'When we fetch an SQUser object from the database, Sequelize obviously gives
    us a Sequelize object that has many extra fields and functions used by Sequelize.
    We don''t want to send that data to our callers. Furthermore, we think it will
    increase security to not provide the *password* data beyond the boundary of this
    server. This function produces a simple, sanitized, anonymous JavaScript object
    from the SQUser instance. We could have defined a full JavaScript class, but would
    that have served any purpose? This anonymous JavaScript class is sufficient for
    this simple server, as illustrated in the following code block:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从数据库中获取SQUser对象时，Sequelize显然会给我们一个具有许多额外字段和Sequelize使用的函数的Sequelize对象。我们不希望将这些数据发送给我们的调用者。此外，我们认为不提供*密码*数据超出此服务器的边界将增加安全性。这个函数从SQUser实例中产生一个简单的、经过消毒的匿名JavaScript对象。我们本可以定义一个完整的JavaScript类，但那有什么用呢？这个匿名的JavaScript类对于这个简单的服务器来说已经足够了，如下面的代码块所示：
- en: '[PRE2]js\1'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: This is just like the configuration files we used in the previous chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像我们在上一章中使用的配置文件一样。
- en: That's what we need for the database side of this service. Let's now move on
    to creating the REST service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在服务的数据库端所需要的。现在让我们继续创建REST服务。
- en: Creating a REST server for user information
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为用户信息创建一个REST服务器
- en: The user information service is a REST server to handle user information data
    and authentication. Our goal is, of course, to integrate that with the Notes application,
    but in a real project, such a user information service could be integrated with
    several web applications. The REST service will provide functions we found useful
    while developing the user login/logout support in Notes, which we'll show later
    in the chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用户信息服务是一个用于处理用户信息数据和身份验证的REST服务器。我们的目标当然是将其与Notes应用程序集成，但在一个真实的项目中，这样的用户信息服务可以与多个Web应用程序集成。REST服务将提供我们在开发Notes中用户登录/注销支持时发现有用的功能，我们稍后将在本章中展示。
- en: 'In the `package.json` file, change the `main` tag to the following line of
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中，将`main`标签更改为以下代码行：
- en: '[PRE3]js\1'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: Clearly, this is how we'll start our server. It uses the configuration file
    from the previous section and specifies that we'll listen on port `5858`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是我们启动服务器的方式。它使用上一节的配置文件，并指定我们将在端口`5858`上监听。
- en: 'Then, create a file named `user-server.mjs` containing the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`user-server.mjs`的文件，其中包含以下代码：
- en: '[PRE4]js\1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: This handler executes for every request and immediately follows `restify.plugins.authorizationParser`.
    It looks for authorization data—specifically, HTTP basic authorization—to have
    been supplied in the HTTP request. It then loops through the list of keys in the
    `apiKeys` array, and if the Basic Auth parameters supplied matched, then the caller
    is accepted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序对每个请求都执行，并紧随`restify.plugins.authorizationParser`。它查找授权数据，特别是HTTP基本授权，是否已在HTTP请求中提供。然后它循环遍历`apiKeys`数组中的键列表，如果基本授权参数匹配，则接受调用者。
- en: This should not be taken as an example of a best practice since HTTP Basic Auth
    is widely known to be extremely insecure, among other issues. But it demonstrates
    the basic concept, and also shows that enforcing token-based authorization is
    easily done with a similar handler.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应被视为最佳实践的示例，因为HTTP基本认证被广泛认为极不安全，还有其他问题。但它演示了基本概念，并且还表明通过类似的处理程序轻松实现基于令牌的授权。
- en: This also shows us the function signature of a Restify handler function—namely,
    that it is the same signature used for Express middleware, the `request` and `result`
    objects, and the `next` callback.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这也向我们展示了Restify处理程序函数的函数签名，即与Express中间件使用的相同签名，`request`和`result`对象以及`next`回调。
- en: There is a big difference between Restify and Express as to how the `next` callback
    is used. In Express, remember that a middleware function calls `next` unless that
    middleware function is the last function on the processing chain—for example if
    the function has called `res.send` (or equivalent) to send a response to the caller.
    In Restify, every handler function calls `next`. If a handler function knows it
    should be the last function on the handler chain, then it uses `next(false)`;
    otherwise, it calls `next()`. If a handler function needs to indicate an error,
    it calls `next(err)`, where `err` is an object where `instanceof Error` is `true`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Restify和Express在`next`回调的使用上有很大的区别。在Express中，记住中间件函数调用`next`，除非该中间件函数是处理链上的最后一个函数，例如，如果函数已经调用了`res.send`（或等效的）来向调用者发送响应。在Restify中，每个处理程序函数都调用`next`。如果处理程序函数知道它应该是处理程序链上的最后一个函数，那么它使用`next(false)`；否则，它调用`next()`。如果处理程序函数需要指示错误，它调用`next(err)`，其中`err`是一个对象，`instanceof
    Error`为`true`。
- en: 'Consider the following hypothetical handler function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下假设的处理程序函数：
- en: '[PRE5]js\1'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: This is just the starting point of the command-line tool. For most of the REST
    handler functions, we'll also implement a sub-command in this tool. We'll take
    care of that code in the subsequent sections. For now, let's focus on how the
    command-line tool is set up.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是命令行工具的起点。对于大多数REST处理程序函数，我们还将在此工具中实现一个子命令。我们将在后续章节中处理该代码。现在，让我们专注于命令行工具的设置方式。
- en: The Commander project suggests we name the default import `program`, as shown
    in the preceding code block. As mentioned earlier, we declare the command-line
    options and sub-commands by calling methods on this object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Commander项目建议我们将默认导入命名为`program`，如前面的代码块所示。如前所述，我们通过在此对象上调用方法来声明命令行选项和子命令。
- en: 'In order to properly parse the command line, the last line of code in `cli.mjs` must
    be as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确解析命令行，`cli.mjs`中的最后一行代码必须如下所示：
- en: '[PRE6]js\1'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: This declares an option, either `-p` or `--port`, that Commander will parse
    out of the command line. Notice that all we do is write a text string and, from
    that, Commander knows it must parse these options. Isn't this easy?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个选项，要么是`-p`要么是`--port`，Commander将从命令行中解析出来。请注意，我们所做的只是写一个文本字符串，从中Commander就知道它必须解析这些选项。这不是很容易吗？
- en: When it sees one of these options, the `<port>` declaration tells Commander
    that this option requires an argument. It will parse that argument out of the
    command line, and then assign it to `program.port`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当它看到这些选项之一时，`<port>`声明告诉Commander这个选项需要一个参数。它会从命令行中解析出该参数，然后将其分配给`program.port`。
- en: Therefore, `program.port`, `program.host`, and `program.url` were all declared
    in a similar way. When Commander sees those options, it will create the matching
    variables, and then our `client` function will take that data and modify `connect_url`
    appropriately.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`program.port`、`program.host`和`program.url`都是以类似的方式声明的。当Commander看到这些选项时，它会创建相应的变量，然后我们的`client`函数将获取这些数据并适当地修改`connect_url`。
- en: 'One of the side effects of these declarations is that Commander can generate
    help text automatically. The result we''ll achieve is being able to type the following
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些声明的一个副作用是Commander可以自动生成帮助文本。我们将能够输入以下代码来实现结果：
- en: '[PRE7]js\1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: This handles a `POST` request on the `/create-user` URL. This should look very
    similar to an Express route handler function, apart from the use of the `next`
    callback. Refer back to the discussion on this. As we did with the Notes application,
    we declare the handler callback as an async function and then use a `try`/`catch`
    structure to catch all errors and report them as errors.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数处理了`/create-user` URL上的`POST`请求。这应该看起来非常类似于Express路由处理程序函数，除了使用`next`回调。回顾一下关于这一点的讨论。就像我们在Notes应用程序中所做的那样，我们将处理程序回调声明为异步函数，然后使用`try`/`catch`结构来捕获所有错误并将它们报告为错误。
- en: The handler starts with `connectDB` to ensure the database is set up. Then,
    if you refer back to the `createUser` function, you see it gathers up the user
    data from the request parameters and then uses `SQUser.create` to create an entry
    in the database. What we will receive here is the sanitized user object, and we
    simply return that to the caller.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序以`connectDB`开始，以确保数据库设置正确。然后，如果你回顾`createUser`函数，你会看到它从请求参数中收集用户数据，然后使用`SQUser.create`在数据库中创建一个条目。我们将在这里收到经过处理的用户对象，并简单地将其返回给调用者。
- en: 'Let''s also add the following code to `user-server.mjs`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们还向`user-server.mjs`中添加以下代码： '
- en: '[PRE8]js\1'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: By using `program.command`, we are declaring a sub-command—in this case, `add`.
    The `<username>` declaration says that this sub-command takes an argument. Commander
    will provide that argument value in the `username` parameter to the function passed
    in the `action` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`program.command`，我们声明了一个子命令——在这种情况下是`add`。`<username>`声明表示这个子命令需要一个参数。Commander将会在`action`方法中传递`username`参数的值。
- en: The structure of a `program.command` declaration is to first declare the syntax
    of the sub-command. The `description` method provides user-friendly documentation.
    The `option` method calls are options for this sub-command, rather than global
    options. Finally, the `action` method is where we supply a callback function that
    will be invoked when Commander sees this sub-command in the command line.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`program.command`声明的结构首先声明子命令的语法。`description`方法提供用户友好的文档。`option`方法调用是针对这个子命令的选项，而不是全局选项。最后，`action`方法是我们提供的回调函数，当Commander在命令行中看到这个子命令时将被调用。'
- en: Any arguments declared in the `program.command` string end up as parameters
    to that callback function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`program.command`字符串中声明的任何参数最终都会成为回调函数的参数。
- en: Any values for the options for this sub-command will land in the `cmdObj` object.
    By contrast, the value for global options is attached to the `program` object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子命令的选项值都会落在`cmdObj`对象中。相比之下，全局选项的值会附加到`program`对象上。
- en: With that understanding, we can see that this sub-command gathers information
    from the command line and then uses the `client` function to connect to the server.
    It invokes the `/create-user` URL, passing along the data gathered from the command
    line. Upon receiving the response, it will print either the error or the result
    object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，我们可以看到这个子命令从命令行收集信息，然后使用`client`函数连接到服务器。它调用`/create-user` URL，传递从命令行收集的数据。收到响应后，它将打印出错误或结果对象。
- en: 'Let''s now add the sub-command corresponding to the `/find-or-create` URL,
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加对应于`/find-or-create` URL的子命令，如下所示：
- en: '[PRE9]js\1'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: 'We run this in one command window to start the server. In another command window,
    we can run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个命令窗口中运行这个命令来启动服务器。在另一个命令窗口中，我们可以运行以下命令：
- en: '[PRE10]js\1'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: Likewise, we have success with the `find-or-create` command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们成功地使用了`find-or-create`命令。
- en: That gives us the ability to create SQUser objects. Next, let's see how to read
    from the database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够创建SQUser对象。接下来，让我们看看如何从数据库中读取。
- en: Reading user data from the user information service
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从用户信息服务中读取用户数据
- en: The next thing we want to support is to look for users in the user information
    service. Instead of a general search facility, the need is to retrieve an SQUser
    object for a given username. We already have the utility function for this purpose;
    it's just a matter of hooking up a REST endpoint.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要支持的下一件事是在用户信息服务中查找用户。不是一个通用的搜索功能，而是需要为给定的用户名检索一个SQUser对象。我们已经有了这个目的的实用函数；现在只需要连接一个REST端点。
- en: 'In `user-server.mjs`, add the following function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user-server.mjs`中，添加以下函数：
- en: '[PRE11]js\1'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: We know from the previous chapter that the `findAll` operation retrieves all
    matching objects and that passing an empty query selector such as this causes
    `findAll` to match every SQUser object. Therefore, this performs the task we described,
    to retrieve information on all users.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从上一章知道，`findAll`操作会检索所有匹配的对象，并且传递一个空的查询选择器，比如这样，会导致`findAll`匹配每个SQUser对象。因此，这执行了我们描述的任务，检索所有用户的信息。
- en: 'Then, in `cli.mjs`, we add the following sub-command declarations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`cli.mjs`中，我们添加以下子命令声明：
- en: '[PRE12]js\1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: And, indeed, the results came in as we expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，结果正如我们所预期的那样。
- en: The next operation we need is to update an SQUser object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个操作是更新SQUser对象。
- en: Updating user information in the user information service
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在用户信息服务中更新用户信息
- en: The next functionality to add is to update user information. For this, we can
    use the Sequelize `update` function, and simply expose it as a REST operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加的下一个功能是更新用户信息。为此，我们可以使用Sequelize的`update`函数，并将其简单地公开为REST操作。
- en: 'To that end, add the following code to `user-server.mjs`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在`user-server.mjs`中添加以下代码：
- en: '[PRE13]js\1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: As expected, this sub-command must take the same set of user information parameters.
    It then bundles those parameters into an object, posting it to the `/update-user`
    endpoint on the REST server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是，这个子命令必须使用相同的用户信息参数集。然后，它将这些参数捆绑到一个对象中，将其发布到REST服务器上的`/update-user`端点。
- en: 'Then, to test the result, we run the command, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了测试结果，我们运行以下命令：
- en: '[PRE14]js\1'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: This is simple enough. We first look up the user to ensure it exists, and then
    call the `destroy` function on the SQUser object. There's no need for any result,
    so we send an empty object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们首先查找用户以确保它存在，然后在SQUser对象上调用`destroy`函数。不需要任何结果，所以我们发送一个空对象。
- en: 'To exercise this function, add the following code to `cli.mjs`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个函数，将以下代码添加到`cli.mjs`中：
- en: '[PRE15]js\1'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: First, we deleted Snuffy's user record, and it gave us an empty response, as
    expected. Then, we tried to retrieve his record and, as expected, there was an
    error.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们删除了Snuffy的用户记录，得到了一个预期的空响应。然后，我们尝试检索他的记录，预期地出现了错误。
- en: While we have completed the CRUD operations, we have one final task to cover.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经完成了CRUD操作，但还有最后一个任务要完成。
- en: Checking the user's password in the user information service
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在用户信息服务中检查用户的密码
- en: 'How can we have a user login/logout service without being able to check their
    password? The question is: Where should the password check occur? It seems, without
    examining it too deeply, that it''s better to perform this operation inside the
    user information service. We earlier described the decision that it''s probably
    safer to never expose the user password beyond the user information service. As
    a result, the password check should occur in that service so that the password
    does not stray beyond the service.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么能够有一个用户登录/注销服务而不能检查他们的密码呢？问题是：密码检查应该发生在哪里？似乎，不用深入研究，最好在用户信息服务内部执行此操作。我们之前描述过这个决定，可能更安全的做法是永远不要将用户密码暴露到用户信息服务之外。因此，密码检查应该发生在该服务中，以便密码不会流出服务范围。
- en: 'Let''s start with the following function in `user-server.mjs`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`user-server.mjs`中的以下函数开始：
- en: '[PRE16]js\1'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: And, as expected, the code to invoke this operation is simple. We take the `username`
    and `password` parameters from the command line, send them to the server, and
    then print the result.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，预期的是，调用此操作的代码很简单。我们从命令行获取`username`和`password`参数，将它们发送到服务器，然后打印结果。
- en: 'To verify that it works, run the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证它是否有效，运行以下命令：
- en: '[PRE17]js\1'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: 'Then, create a new file, `models/users-superagent.mjs`, containing the following
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新文件`models/users-superagent.mjs`，其中包含以下代码：
- en: '[PRE18]js\1'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: These are our `create` and `update` functions. In each case, they take the data
    provided, construct an anonymous object, and `POST` it to the server. The function
    is to be provided with the values corresponding to the SQUser schema. It bundles
    the data provided in the `send` method, sets various parameters, and then sets
    up the Basic Auth token.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的`create`和`update`函数。在每种情况下，它们接受提供的数据，构造一个匿名对象，并将其`POST`到服务器。该函数应提供与SQUser模式对应的值。它将提供的数据捆绑在`send`方法中，设置各种参数，然后设置基本身份验证令牌。
- en: The SuperAgent library uses an API style called *method chaining*. The coder
    chains together method calls to construct a request. The chain of method calls
    can end in a `.then` or `.end` clause, either of which takes a callback function.
    But leave off both, and it will return a Promise, and, of course, Promises let
    us use this directly from an async function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SuperAgent库使用一种称为*方法链*的API风格。编码者将方法调用链接在一起以构建请求。方法调用链可以以`.then`或`.end`子句结束，其中任何一个都接受一个回调函数。但是如果两者都不加，它将返回一个Promise，当然，Promise让我们可以直接从异步函数中使用它。
- en: The `res.body` value at the end of each function contains the value returned
    by the REST server. All through this library, we'll use the `.auth` clause to
    set up the required authentication key.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数末尾的`res.body`值包含了REST服务器返回的值。在整个库中，我们将使用`.auth`子句来设置所需的身份验证密钥。
- en: 'These anonymous objects are a little different than normal. We''re using a
    new **ECMAScript 2015** (**ES-2015**) feature here that we haven''t discussed
    so far. Rather than specifying the object fields using the `fieldName: fieldValue` notation,
    ES-2015 gives us the option to shorten this when the variable name used for `fieldValue` matches
    the desired `fieldName`. In other words, we can just list the variable names,
    and the field name will automatically match the variable name.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '这些匿名对象与普通对象有些不同。我们在这里使用了一个新的**ECMAScript 2015** (**ES-2015**)特性，到目前为止我们还没有讨论过。与使用`fieldName:
    fieldValue`表示对象字段不同，ES-2015给了我们一个选项，当用于`fieldValue`的变量名与所需的`fieldName`匹配时，可以缩短这个表示法。换句话说，我们只需列出变量名，字段名将自动匹配变量名。'
- en: In this case, we've purposely chosen variable names for the parameters to match
    the field names of the object with parameter names used by the server. In doing
    so, we can use this shortened notation for anonymous objects, and our code is
    a little cleaner by using consistent variable names from beginning to end.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们故意选择了参数的变量名，以匹配服务器使用的参数名称与对象字段名称。这样做，我们可以使用匿名对象的缩写表示法，通过始终使用一致的变量名，使我们的代码更清晰。
- en: 'Now, add the following function to support the retrieval of user records:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加以下函数以支持检索用户记录：
- en: '[PRE19]js\1'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: One point about this method is worth noting. It could have taken the parameters
    in the URL instead of the request body, as is done here. But since request URLs
    are routinely logged to files, putting the username and password parameters in
    the URL means user identity information would be logged to files and be part of
    activity reports. That would obviously be a very bad choice. Putting those parameters
    in the request body not only avoids that bad result but if an HTTPS connection
    to the service were used, the transaction would be encrypted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法值得注意的一点是，它可以在 URL 中获取参数，而不是在请求体中获取，就像这里所做的那样。但是，由于请求 URL 经常被记录到文件中，将用户名和密码参数放在
    URL 中意味着用户身份信息将被记录到文件中并成为活动报告的一部分。这显然是一个非常糟糕的选择。将这些参数放在请求体中不仅避免了这种糟糕的结果，而且如果使用了与服务的
    HTTPS 连接，交易将被加密。
- en: 'Then, let''s create our `find-or-create` function, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建我们的 `find-or-create` 函数，如下所示：
- en: '[PRE20]js\1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: As before, this is very straightforward.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，这非常简单。
- en: With this module, we can interface with the user information service, and we
    can now proceed with modifying the Notes user interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个模块，我们可以与用户信息服务进行接口，现在我们可以继续修改 Notes 用户界面。
- en: Incorporating login and logout routing functions in the Notes application
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Notes 应用程序中整合登录和注销路由函数
- en: What we've built so far is a user data model, with a REST API wrapping that
    model to create our authentication information service. Then, within the Notes
    application, we have a module that requests user data from this server. As yet,
    nothing in the Notes application knows that this user model exists. The next step
    is to create a routing module for login/logout URLs and to change the rest of
    Notes to use user data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建了一个用户数据模型，用一个 REST API 包装该模型来创建我们的身份验证信息服务。然后，在 Notes 应用程序中，我们有一个模块从这个服务器请求用户数据。到目前为止，Notes
    应用程序中没有任何内容知道这个用户模型的存在。下一步是创建一个用于登录/注销 URL 的路由模块，并更改 Notes 的其余部分以使用用户数据。
- en: 'The routing module is where we use `passport` to handle user authentication.
    The first task is to install the required modules, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模块是我们使用 `passport` 处理用户身份验证的地方。第一项任务是安装所需的模块，如下所示：
- en: '[PRE21]js\1'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: Express Session support, including all the various Session Store implementations,
    is documented on its GitHub project page at [https://github.com/expressjs/session](https://github.com/expressjs/session).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Express 会话支持，包括所有各种会话存储实现，都在其 GitHub 项目页面上有文档，网址为 [https://github.com/expressjs/session](https://github.com/expressjs/session)。
- en: The strategy implemented in the `passport-local` package authenticates solely
    using data stored locally to the application—for example, our user authentication
    information service. Later, we'll add a strategy module to authenticate the use
    of OAuth with Twitter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`passport-local` 包中实现的策略仅使用存储在应用程序本地的数据进行身份验证，例如我们的用户身份验证信息服务。稍后，我们将添加一个策略模块来验证使用
    Twitter 的 OAuth。'
- en: 'Let''s start by creating the routing module, `routes/users.mjs`, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建路由模块 `routes/users.mjs` 开始，如下所示：
- en: '[PRE22]js\1'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: The `initPassport` function will be called from `app.mjs`, and it installs the
    Passport middleware in the Express configuration. We'll discuss the implications
    of this later when we get to `app.mjs` changes, but Passport uses sessions to
    detect whether this HTTP request is authenticated. It looks at every request coming
    into the application, looks for clues about whether this browser is logged in, and
    attaches data to the request object as `req.user`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`initPassport` 函数将从 `app.mjs` 被调用，并在 Express 配置中安装 Passport 中间件。我们将在后面讨论这个的影响，当我们到达
    `app.mjs` 的变化时，但 Passport 使用会话来检测这个 HTTP 请求是否经过身份验证。它查看每个进入应用程序的请求，寻找关于这个浏览器是否已登录的线索，并将数据附加到请求对象作为
    `req.user`。'
- en: The `ensureAuthenticated` function will be used by other routing modules and
    is to be inserted into any route definition that requires an authenticated logged-in
    user. For example, editing or deleting a note requires the user to be logged in
    and, therefore, the corresponding routes in `routes/notes.mjs` must use `ensureAuthenticated`.
    If the user is not logged in, this function redirects them to `/users/login` so
    that they can log in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensureAuthenticated` 函数将被其他路由模块使用，并插入到任何需要经过身份验证的已登录用户的路由定义中。例如，编辑或删除笔记需要用户已登录，因此
    `routes/notes.mjs` 中的相应路由必须使用 `ensureAuthenticated`。如果用户未登录，此函数将重定向他们到 `/users/login`，以便他们可以登录。'
- en: 'Add the following route handlers in `routes/users.mjs`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/users.mjs` 中添加以下路由处理程序：
- en: '[PRE23]js\1'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: When the user requests to log out of Notes, they are to be sent to `/users/logout`.
    We'll be adding a button to the header template for this purpose. The `req.logout`
    function instructs Passport to erase their login credentials, and they are then
    redirected to the home page.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户请求注销 Notes 时，他们将被发送到 `/users/logout`。我们将在页眉模板中添加一个按钮来实现这个目的。`req.logout`
    函数指示 Passport 擦除他们的登录凭据，然后将他们重定向到主页。
- en: This function deviates from what's in the Passport documentation. There, we
    are told to simply call `req.logout`, but calling only that function sometimes
    results in the user not being logged out. It's necessary to destroy the session
    object, and to clear the cookie, in order to ensure that the user is logged out.
    The cookie name is defined in `app.mjs`, and we imported `sessionCookieName` for
    this function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与 Passport 文档中的内容有所偏差。在那里，我们被告知只需调用 `req.logout`，但有时仅调用该函数会导致用户未注销。有必要销毁会话对象，并清除
    cookie，以确保用户已注销。cookie 名称在 `app.mjs` 中定义，我们为这个函数导入了 `sessionCookieName`。
- en: 'Add the `LocalStrategy` to Passport, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `LocalStrategy` 到 Passport，如下所示：
- en: '[PRE24]js\1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: The preceding functions take care of encoding and decoding authentication data
    for the session. All we need to attach to the session is the `username`, as we
    did in `serializeUser`. The `deserializeUser` object is called while processing
    an incoming HTTP request and is where we look up the user profile data. Passport will
    attach this to the request object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数负责对会话的身份验证数据进行编码和解码。我们只需要将`username`附加到会话中，就像我们在`serializeUser`中所做的那样。`deserializeUser`对象在处理传入的HTTP请求时被调用，这是我们查找用户配置文件数据的地方。Passport会将其附加到请求对象上。
- en: Login/logout changes to app.mjs
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对app.mjs进行登录/注销更改
- en: A number of changes are necessary in `app.mjs`, some of which we've already
    touched on. We did carefully isolate the Passport module dependencies to `routes/users.mjs`.
    The changes required in `app.mjs` support the code in `routes/users.mjs`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.mjs`中需要进行一些更改，其中一些我们已经提到过。我们已经将Passport模块的依赖项仔细隔离到`routes/users.mjs`中。`app.mjs`中需要的更改支持`routes/users.mjs`中的代码。
- en: 'Add an import to bring in functions from the User router module, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加导入以从用户路由模块中引入函数，如下所示：
- en: '[PRE25]js\1'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: Because Passport uses sessions, we need to enable session support in Express,
    and these modules do so. The `session-file-store` module saves our session data
    to disk so that we can kill and restart the application without losing sessions.
    It's also possible to save sessions to databases with appropriate modules. A filesystem
    session store is suitable only when all Notes instances are running on the same
    server computer. For a distributed deployment situation, you'll need to use a
    session store that runs on a network-wide service, such as a database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Passport使用会话，我们需要在Express中启用会话支持，这些模块也这样做。`session-file-store`模块将我们的会话数据保存到磁盘上，这样我们可以在不丢失会话的情况下终止和重新启动应用程序。还可以使用适当的模块将会话保存到数据库中。文件系统会话存储仅在所有Notes实例运行在同一台服务器计算机上时才适用。对于分布式部署情况，您需要使用在整个网络服务上运行的会话存储，例如数据库。
- en: We're defining `sessionCookieName` here so that it can be used in multiple places.
    By default, `express-session` uses a cookie named `connect.sid` to store the session
    data. As a small measure of security, it's useful when there's a published default
    to use a different non-default value. Any time we use the default value, it's
    possible that an attacker might know a security flaw, depending on that default.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义`sessionCookieName`，以便它可以在多个地方使用。默认情况下，`express-session`使用名为`connect.sid`的cookie来存储会话数据。作为一种小的安全措施，当有一个已发布的默认值时，使用不同的非默认值是有用的。每当我们使用默认值时，可能会有攻击者知道安全漏洞，这取决于该默认值。
- en: 'Add the following code to `app.mjs`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`app.mjs`中：
- en: '[PRE26]js\1'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]js\1'
- en: This is the same initialization, but using `MemoryStore` instead of `FileStore`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的初始化，但是使用`MemoryStore`而不是`FileStore`。
- en: To learn more about session store implementations see:  [http://expressjs.com/en/resources/middleware/session.html#compatible-session-stores](http://expressjs.com/en/resources/middleware/session.html#compatible-session-stores)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关会话存储实现的更多信息，请参阅：[http://expressjs.com/en/resources/middleware/session.html#compatible-session-stores](http://expressjs.com/en/resources/middleware/session.html#compatible-session-stores)
- en: 'Mount the User router, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载用户路由，如下所示：
- en: '[PRE27]js\1'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]js\1'
- en: Remember that we ensured that `req.user` has the user profile data, which we
    did in `deserializeUser`. We simply check for this and make sure to add that data
    when rendering the views template.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们确保`req.user`拥有用户配置文件数据，这是在`deserializeUser`中完成的。我们只需检查这一点，并确保在渲染视图模板时添加该数据。
- en: We'll be making similar changes to most of the other route definitions. After
    that, we'll go over the changes to the view templates, in which we use `req.user`
    to show the correct buttons on each page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对大多数其他路由定义进行类似的更改。之后，我们将讨论视图模板的更改，在其中我们使用`req.user`来在每个页面上显示正确的按钮。
- en: Login/logout changes required in routes/notes.mjs
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`routes/notes.mjs`中需要进行登录/注销更改
- en: 'The changes required here are more significant but still straightforward, as
    shown in the following code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要的更改更为重要，但仍然很简单，如下面的代码片段所示：
- en: '[PRE28]js\1'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]js\1'
- en: We'll be making similar changes throughout this module, adding calls to `ensureAuthenticated`
    and using `req.user` to check whether the user is logged in. The goal is for several
    routes to ensure that the route is only available to a logged-in user, and—in
    those and additional routes—to pass the `user` object to the template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整个模块中进行类似的更改，添加对`ensureAuthenticated`的调用，并使用`req.user`来检查用户是否已登录。目标是让几个路由确保路由仅对已登录用户可用，并且在这些路由和其他路由中将`user`对象传递给模板。
- en: The first thing we added is to call `usersRouter.ensureAuthenticated` in the
    route definition. If the user is not logged in, they'll be redirected to `/users/login` thanks
    to that function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的第一件事是在路由定义中调用`usersRouter.ensureAuthenticated`。如果用户未登录，他们将由于该函数而被重定向到`/users/login`。
- en: Because we've ensured that the user is authenticated, we know that `req.user`
    will already have their profile information. We can then simply pass it to the
    view template.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已确保用户已经通过身份验证，所以我们知道`req.user`已经有了他们的配置文件信息。然后我们可以简单地将其传递给视图模板。
- en: For the other routes, we need to make similar changes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他路由，我们需要进行类似的更改。
- en: 'Modify the `/save` route handler, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`/save`路由处理程序如下：
- en: '[PRE29]js\1'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]js\1'
- en: For this route, we don't require the user to be logged in. We do need the user's
    profile information, if any, sent to the view template.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个路由，我们不需要用户已登录。如果有的话，我们需要用户的配置文件信息发送到视图模板。
- en: 'Modify the `/edit` and `/destroy` route handlers, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`/edit`和`/destroy`路由处理程序如下：
- en: '[PRE30]js\1'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]js\1'
- en: What we're doing here is controlling which buttons to display at the top of
    the screen, depending on whether the user is logged in. The earlier changes ensure
    that the `user` variable will be `undefined` if the user is logged out; otherwise,
    it will have the user profile object. Therefore, it's sufficient to check the
    `user` variable, as shown in the preceding code block, to render different user
    interface elements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是控制屏幕顶部显示哪些按钮，这取决于用户是否已登录。较早的更改确保了如果用户已注销，则`user`变量将为`undefined`；否则，它将具有用户配置文件对象。因此，只需检查`user`变量即可，如前面的代码块所示，以渲染不同的用户界面元素。
- en: A logged-out user doesn't get the ADD Note button and gets a Log in button.
    Otherwise, the user gets an ADD Note button and a Log Out button. The Log in button
    takes the user to `/users/login`, while the Log Out button takes them to `/users/logout`.
    Both of those buttons are handled in `routes/users.js` and perform the expected
    function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 未登录的用户不会看到“添加笔记”按钮，并会看到一个登录按钮。否则，用户会看到“添加笔记”按钮和一个注销按钮。登录按钮将用户带到`/users/login`，而注销按钮将他们带到`/users/logout`。这两个按钮都在`routes/users.js`中处理，并执行预期的功能。
- en: The Log Out button has a Bootstrap badge component displaying the username. This
    adds a little visual splotch in which we'll put the username that's logged in. As
    we'll see later, it will serve as a visual clue to the user as to their identity.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注销按钮具有Bootstrap徽章组件显示用户名。这为已登录的用户名提供了一个小的视觉标识。稍后我们将看到，它将作为用户身份的视觉提示。
- en: Because `nav` is now supporting login/logout buttons, we have changed the `navbar-toggler`
    button so that it controls a `<div>` with `id="navbarLogIn"`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`nav`现在支持登录/注销按钮，我们已经更改了`navbar-toggler`按钮，以便它控制具有`id="navbarLogIn"`的`<div>`。
- en: 'We need to create `views/login.hbs`, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建`views/login.hbs`，如下所示：
- en: '[PRE31]js\1'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]js\1'
- en: That's straightforward—if the user is logged in, display the form; otherwise,
    display the message in `partials/not-logged-in.hbs`. We determine which of these
    to display based on the `user` variable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单 - 如果用户已登录，则显示表单；否则，在`partials/not-logged-in.hbs`中显示消息。我们根据`user`变量确定要显示其中哪一个。
- en: 'We could insert something such as the code shown in the following block in
    `partials/not-logged-in.hbs`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`partials/not-logged-in.hbs`中插入以下代码块中显示的代码：
- en: '[PRE32]js\1'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]js\1'
- en: That is, at the bottom we add a segment that, for non-logged-in users, pulls
    in the `not-logged-in` partial.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在底部我们添加了一个段落，对于未登录的用户，引入了`not-logged-in`部分。
- en: The **Bootstrap jumbotron** component makes a nice and large text display that
    stands out nicely and will catch the viewer's attention. However, the user should
    never see this because each of those templates is used only when we've pre-verified
    the fact that the user is logged in.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bootstrap jumbotron**组件可以创建一个漂亮而大的文本显示，非常引人注目。然而，用户不应该看到这一点，因为这些模板只在我们预先验证用户已登录时使用。'
- en: A message such as this is useful as a check against bugs in your code. Suppose
    that we slipped up and failed to properly ensure that these forms were displayed
    only to logged-in users. Suppose that we had other bugs that didn't check the
    form submission to ensure it's requested only by a logged-in user. Fixing the
    template in this way is another layer of prevention against displaying forms to
    users who are not allowed to use that functionality.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的消息对于检查代码中的错误非常有用。假设我们疏忽了，并且未能确保这些表单仅显示给已登录用户。假设我们有其他错误，未检查表单提交以确保它仅由已登录用户请求。以这种方式修复模板是另一层防止向未被允许使用该功能的用户显示表单的预防措施。
- en: We have now made all the changes to the user interface and are ready to test
    the login/logout functionality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经对用户界面进行了所有更改，并准备测试登录/注销功能。
- en: Running the Notes application with user authentication
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用用户身份验证运行Notes应用程序
- en: We have created the user information REST service, created a module to access
    that service from Notes,  modified the router modules to correctly access the
    user information service, and changed other things required to support login/logout.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了用户信息REST服务，创建了一个模块来从Notes访问该服务，修改了路由模块以正确访问用户信息服务，并更改了其他支持登录/注销所需的内容。
- en: 'The final task that is necessary is to change the scripts section of `package.json`,
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的最后一个任务是修改`package.json`的脚本部分，如下所示：
- en: '[PRE33]js\1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]js\1'
- en: 'Then, in another window, start the Notes application, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个窗口中，按照以下方式启动Notes应用程序：
- en: '[PRE34]js\1'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]js\1'
- en: 'The documentation says we should load the `dotenv` package and then call `dotenv.config()`
    very early in the start up phase of our application, and that we must do this
    before accessing any environment variables. However, reading the documentation
    more closely, it seems best to add the following code to `app.mjs`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 文档表示我们应该加载`dotenv`包，然后在应用程序启动阶段非常早的时候调用`dotenv.config()`，并且我们必须在访问任何环境变量之前这样做。然而，仔细阅读文档后，似乎最好将以下代码添加到`app.mjs`中：
- en: '[PRE35]js\1'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]js\1'
- en: This is exactly the syntax we'd expect since it is the same as for shell scripts.
    In this file, we need two variables to be defined, `TWITTER_CONSUMER_KEY` and `TWITTER_CONSUMER_SECRET`.
    We will use these variables in the code we'll write in the next section. Since
    we are putting configuration values in the `scripts` section of `package.json`,
    feel free to add those environment variables to `.env` as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们期望的语法，因为它与shell脚本的语法相同。在这个文件中，我们需要定义两个变量，`TWITTER_CONSUMER_KEY`和`TWITTER_CONSUMER_SECRET`。我们将在下一节中编写的代码中使用这些变量。由于我们正在将配置值放在`package.json`的`scripts`部分中，因此可以将这些环境变量添加到`.env`中。
- en: 'The next step is to avoid committing this file to a source code control system
    such as Git. To ensure that this does not happen, you should already have a `.gitignore`
    file in the `notes` directory, and make sure its contents are something like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是避免将此文件提交到Git等源代码控制系统中。为了确保这不会发生，您应该已经在`notes`目录中有一个`.gitignore`文件，并确保其内容类似于以下内容：
- en: '[PRE36]js\1'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE36]js\1'
- en: 'In `routes/users.mjs`, let''s start making some changes, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/users.mjs`中，让我们开始做一些更改，如下所示：
- en: '[PRE37]js\1'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE37]js\1'
- en: This registers a `TwitterStrategy` instance with `passport`, arranging to call
    the user authentication service as users register with the Notes application.
    This `callback` function is called when users successfully authenticate using
    Twitter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这注册了一个`TwitterStrategy`实例到`passport`，安排在用户注册Notes应用程序时调用用户认证服务。当用户成功使用Twitter进行身份验证时，将调用此`callback`函数。
- en: If the environment variables containing the Twitter tokens are not set, then
    this code does not execute. Clearly, it would be an error to set up Twitter authentication
    without the keys, so we avoid the error by not executing the code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含Twitter令牌的环境变量没有设置，那么这段代码就不会执行。显然，没有设置Twitter认证的密钥是错误的，所以我们通过不执行代码来避免错误。
- en: To help other code know whether Twitter support is enabled, we export a flag
    variable - `twitterLogin`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助其他代码知道Twitter支持是否已启用，我们导出了一个标志变量-`twitterLogin`。
- en: We defined the `usersModel.findOrCreate` function specifically to handle user
    registration from third-party services such as Twitter. Its task is to look for
    the user described in the profile object and, if that user does not exist, to
    create that user account in Notes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专门定义了`usersModel.findOrCreate`函数来处理来自Twitter等第三方服务的用户注册。它的任务是查找在配置文件对象中描述的用户，并且如果该用户不存在，则在Notes中创建该用户帐户。
- en: The `consumerKey` and `consumerSecret` values are supplied by Twitter, after
    you've registered your application. These secrets are used in the OAuth protocol
    as proof of identity to Twitter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`consumerKey`和`consumerSecret`的值是在注册应用程序后由Twitter提供的。这些密钥在OAuth协议中用作向Twitter证明身份的凭证。'
- en: The `callbackURL` setting in the `TwitterStrategy` configuration is a holdover
    from Twitter's OAuth1-based API implementation. In OAuth1, the callback URL was
    passed as part of the OAuth request. Since `TwitterStrategy` uses Twitter's OAuth1
    service, we have to supply the URL here. We'll see in a moment where that URL
    is implemented in Notes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterStrategy`配置中的`callbackURL`设置是Twitter的基于OAuth1的API实现的遗留物。在OAuth1中，回调URL是作为OAuth请求的一部分传递的。由于`TwitterStrategy`使用了Twitter的OAuth1服务，我们必须在这里提供URL。我们马上会看到这个URL在Notes中是如何实现的。'
- en: The `callbackURL`, `consumerKey`, and `consumerSecret` settings are all injected
    using environment variables. Earlier, we discussed how it is a best practice to
    not commit the values for `consumerKey` and `consumerSecret` to a source repository,
    and therefore we set up the `dotenv` package and a `.env` file to hold those configuration
    values. In Chapter 10,* Deploying Node.js Applications to Linux Servers*, we'll
    see that these keys can be declared as environment variables in a Dockerfile.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`callbackURL`、`consumerKey`和`consumerSecret`设置都是使用环境变量注入的。之前，我们讨论了不将`consumerKey`和`consumerSecret`的值提交到源代码库是最佳实践，因此我们设置了`dotenv`包和一个`.env`文件来保存这些配置值。在第10章，*将Node.js应用程序部署到Linux服务器*中，我们将看到这些密钥可以在Dockerfile中声明为环境变量。'
- en: 'Add the following route declaration:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下路由声明：
- en: '[PRE38]js\1'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE38]js\1'
- en: This route handles the callback URL, and it corresponds to the `callbackURL`
    setting configured earlier. Depending on whether it indicates a successful registration,
    Passport will redirect the browser to either the home page or back to the `/users/login`
    page.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由处理回调URL，并且它对应于之前配置的`callbackURL`设置。根据它是否指示成功注册，Passport将重定向浏览器到首页或者回到`/users/login`页面。
- en: Because `router` is mounted on `/user`, this URL is actually `/user/auth/twitter/callback`.
    Therefore, the full URL to use in configuring the `TwitterStrategy`, and to supply
    to Twitter, is `http://localhost:3000/user/auth/twitter/callback`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`router`被挂载在`/user`上，所以这个URL实际上是`/user/auth/twitter/callback`。因此，在配置`TwitterStrategy`时要使用完整的URL，并提供给Twitter的是`http://localhost:3000/user/auth/twitter/callback`。
- en: In the process of handling the callback URL, Passport will invoke the callback
    function shown earlier. Because our callback uses the `usersModel.findOrCreate`
    function, the user will be automatically registered if necessary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理回调URL的过程中，Passport将调用之前显示的回调函数。因为我们的回调使用了`usersModel.findOrCreate`函数，如果需要，用户将自动注册。
- en: We're almost ready, but we need to make a couple of small changes elsewhere in
    Notes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好了，但是我们需要在Notes的其他地方做一些小的更改。
- en: 'In `partials/header.hbs`, make the following changes to the code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`partials/header.hbs`中，对代码进行以下更改：
- en: '[PRE39]js\1'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE39]js\1'
- en: This imports the variable, and then, in the data passed to `res.render`, we
    add this variable. This will ensure that the value reaches `partials/header.hbs`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这导入了变量，然后在传递给`res.render`的数据中，我们添加了这个变量。这将确保该值传递到`partials/header.hbs`。
- en: 'In `routes/notes.mjs`, we have a similar change to make in several router functions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/notes.mjs`中，我们需要在几个路由函数中进行类似的更改：
- en: '[PRE40]js\1'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE40]js\1'
- en: 'Then, use a browser to visit `http://localhost:3000`, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用浏览器访问`http://localhost:3000`，如下所示：
- en: '![](img/2eaeb209-1f22-424a-ab86-0563fa7474c1.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2eaeb209-1f22-424a-ab86-0563fa7474c1.png)'
- en: Notice the new button. It looks about right, thanks to having used the official
    Twitter branding image. The button is a little large, so maybe you want to consult
    a designer. Obviously, a different design is required if you're going to support
    dozens of authentication services.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新按钮。它看起来差不多，多亏了使用了官方的Twitter品牌形象。按钮有点大，所以也许你想咨询一位设计师。显然，如果你要支持数十种认证服务，就需要不同的设计。
- en: Run it while leaving out the Twitter token environment variables, and the Twitter
    login button should not appear.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在略去Twitter令牌环境变量的情况下运行它，Twitter登录按钮不应该出现。
- en: Clicking on this button takes the browser to `/users/auth/twitter`, which is
    meant to start Passport running the OAuth protocol transactions necessary to authenticate.
    Instead, you may receive an error message that states Callback URL not approved
    for this client application. Approved callback URLs can be adjusted in your application
    settings. If this is the case, it is necessary to adjust the application configuration
    on `developer.twitter.com`. The error message is clearly saying that Twitter saw
    a URL being used that was not approved.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 单击此按钮将浏览器带到`/users/auth/twitter`，这意味着启动Passport运行OAuth协议交易以进行身份验证。但是，您可能会收到一个错误消息，指出回调URL未经此客户端应用程序批准。批准的回调URL可以在您的应用程序设置中进行调整。如果是这种情况，就需要在`developer.twitter.com`上调整应用程序配置。错误消息明确表示Twitter看到了一个未经批准的URL。
- en: 'On the page for your application, on the App Details tab, click the Edit button.
    Then, scroll down to the Callback URLs section and add the following entries:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序页面上，在App Details选项卡上，点击编辑按钮。然后，向下滚动到Callback URLs部分，并添加以下条目：
- en: '![](img/cbe8f693-9128-44b9-b8f4-928b960c9770.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbe8f693-9128-44b9-b8f4-928b960c9770.png)'
- en: As it explains, this box lists the URLs that are allowed to be used for Twitter
    OAuth authentication. At the moment, we are hosting the application on our laptop
    using port `3000`. If you are accessing it from other base URLs, such as `http://MacBook-Pro-4.local`,
    then that base URL should be used in addition.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它所解释的，此框列出了允许用于Twitter OAuth身份验证的URL。目前，我们正在使用端口`3000`在笔记本电脑上托管应用程序。如果您从其他基本URL访问它，例如`http://MacBook-Pro-4.local`，那么除了该基本URL外还应该使用它。
- en: Once you have the callback URLs correctly configured, clicking on the Login
    with Twitter button will take you to a normal Twitter OAuth authentication page.
    Simply click for approval, and you'll be redirected back to the Notes application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确配置了回调URL，单击“使用Twitter登录”按钮将带您到正常的Twitter OAuth身份验证页面。只需点击批准，您将被重定向回Notes应用程序。
- en: 'And then, once you''re logged in with Twitter, you''ll see something like the following
    screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦您使用Twitter登录，您将看到类似以下截图：
- en: '![](img/0e324c9a-3128-40c1-9d5c-1d90d2682130.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e324c9a-3128-40c1-9d5c-1d90d2682130.png)'
- en: We're now logged in, and will notice that our Notes username is the same as
    our Twitter username. You can browse around the application and create, edit,
    or delete notes. In fact, you can do this to any note you like, even ones created
    by others. That's because we did not create any sort of access control or permissions
    system, and therefore every user has complete access to every note. That's a feature
    to put on the backlog.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经登录，并且会注意到我们的Notes用户名与我们的Twitter用户名相同。您可以浏览应用程序并创建、编辑或删除笔记。实际上，您可以对任何您喜欢的笔记进行操作，甚至是其他人创建的笔记。这是因为我们没有创建任何访问控制或权限系统，因此每个用户都可以完全访问每个笔记。这是一个需要放入待办事项的功能。
- en: By using multiple browsers or computers, you can simultaneously log in as different
    users, one user per browser.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多个浏览器或计算机，您可以同时以不同用户身份登录，每个浏览器一个用户。
- en: 'You can run multiple instances of the Notes application by doing what we did
    earlier, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行我们之前所做的操作来运行Notes应用程序的多个实例，如下所示：
- en: '[PRE41]js\1'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE41]js\1'
- en: 'In another command window, run the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个命令窗口中，运行以下命令：
- en: '[PRE42]js\1'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE42]js\1'
- en: This is after logging in using a Twitter account. You can see that the Twitter
    account name is stored here in the session data.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Twitter账户登录后。您可以看到Twitter账户名称存储在会话数据中。
- en: What if you want to clear a session? It's just a file in the filesystem. Deleting
    the session file erases the session, and the user's browser will be forcefully
    logged out.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要清除会话怎么办？这只是文件系统中的一个文件。删除会话文件会擦除会话，用户的浏览器将被强制注销。
- en: The session will time out if the user leaves their browser idle for long enough.
    One of the `session-file-store` options, `ttl`, controls the timeout period, which
    defaults to 3,600 seconds (an hour). With a timed-out session, the application
    reverts to a logged-out state.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户长时间不活动，会话将超时。`session-file-store`选项之一，`ttl`，控制超时时间，默认为3,600秒（一小时）。会话超时后，应用程序将恢复到已注销状态。
- en: In this section, we've gone through the full process of setting up support for
    login using Twitter's authentication service. We created a Twitter developer account
    and created an application on Twitter's backend. Then, we implemented the required
    workflow to integrate with Twitter's OAuth support. To support this, we integrated
    the storage of user authorizations from Twitter in the user information service.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经完成了设置支持使用Twitter身份验证服务进行登录的完整流程。我们创建了Twitter开发者账户，并在Twitter的后端创建了一个应用程序。然后，我们实现了与Twitter的OAuth支持集成所需的工作流程。为了支持这一点，我们集成了存储用户授权信息的服务。
- en: 'Our next task is extremely important: to keep user passwords encrypted.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个任务非常重要：保持用户密码加密。
- en: Keeping secrets and passwords secure
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持秘密和密码安全
- en: 'We''ve cautioned several times about the importance of safely handling user
    identification information. The intention to handle that data safely is one thing,
    but it is important to follow through and actually do so. While we''re using a
    few good practices so far, as it stands, the Notes application would not withstand
    any kind of security audit for the following reasons:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次警告过安全处理用户识别信息的重要性。安全处理这些数据的意图是一回事，但实际上这样做非常重要。尽管我们迄今为止使用了一些良好的做法，但就目前而言，Notes应用程序无法经受任何安全审计，原因如下：
- en: User passwords are kept in clear text in the database.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户密码以明文形式保存在数据库中。
- en: The authentication tokens for Twitter et al. are in clear text.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter等的身份验证令牌以明文形式保存。
- en: The authentication service API key is not a cryptographically secure anything;
    it's just a clear text **universally unique identifier** (**UUID**).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证服务API密钥不是加密安全的任何东西；它只是一个明文的**通用唯一标识符**（**UUID**）。
- en: If you don't recognize the phrase *clear text*, it simply means unencrypted.
    Anyone could read the text of user passwords or the authentication tokens. It's
    best to keep both encrypted to avoid information leakage.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不认识短语*明文*，它只是表示未加密。任何人都可以阅读用户密码或身份验证令牌的文本。最好将两者都加密以避免信息泄漏。
- en: Keep this issue in the back of your mind because we'll revisit these—and other—security
    issues in [Chapter 14](4cccad1e-fe7e-495a-9e90-8818820b890a.xhtml), *Security
    in Node.js Applications*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这个问题，因为我们将在[第14章](4cccad1e-fe7e-495a-9e90-8818820b890a.xhtml)中重新讨论这些以及其他安全问题。
- en: 'Before we leave this chapter, let''s fix the first of those issues: storing
    passwords in plain text. We made the case earlier that user information security
    is extremely important. Therefore, we should take care of this from the beginning.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这一章之前，让我们解决其中的第一个问题：以明文形式存储密码。我们之前已经提到用户信息安全非常重要。因此，我们应该从一开始就注意到这一点。
- en: The `bcrypt` Node.js package makes it easy to securely store passwords. With
    it, we can easily encrypt the password right away, and never store an unencrypted
    password.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`bcrypt` Node.js包使得安全存储密码变得容易。有了它，我们可以立即加密密码，永远不会存储未加密的密码。'
- en: For `bcrypt` documentation, refer to [https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`bcrypt`文档，请参阅[https://www.npmjs.com/package/bcrypt](https://www.npmjs.com/package/bcrypt)。
- en: 'To install `bcrypt` in both the `notes` and `users` directories, execute the
    following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在`notes`和`users`目录中安装`bcrypt`，执行以下命令：
- en: '[PRE43]js\1'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE43]js\1'
- en: This brings in the `bcrypt` package, and then we configure a constant that governs
    the CPU time required to decrypt a password. The `bcrypt` documentation points
    to a blog post discussing why the algorithm of `bcrypt` is excellent for storing
    encrypted passwords. The argument boils down to the CPU time required for decryption.
    A brute-force attack against the password database is harder, and therefore less
    likely to succeed if the passwords are encrypted using strong encryption, because
    of the CPU time required to test all password combinations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了`bcrypt`包，然后我们配置了一个常量，该常量控制解密密码所需的CPU时间。`bcrypt`文档指向了一篇讨论为什么`bcrypt`算法非常适合存储加密密码的博客文章。论点归结为解密所需的CPU时间。针对密码数据库的暴力攻击更加困难，因此如果使用强加密加密密码，测试所有密码组合所需的CPU时间更长，因此成功的可能性更小。
- en: The value we assign to `saltRounds` determines the CPU time requirement. The
    documentation explains this further.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给`saltRounds`的值决定了CPU时间的要求。文档进一步解释了这一点。
- en: 'Next, add the following function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下函数：
- en: '[PRE44]js\1'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE44]js\1'
- en: That is, in each, we make the callback function an async function so that we
    can use `await`. Then, we call the `hashpass` function to encrypt the password.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在每个地方，我们将回调函数设置为异步函数，以便我们可以使用`await`。然后，我们调用`hashpass`函数来加密密码。
- en: This way, we are encrypting the password right away, and the user information
    server will be storing an encrypted password.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们立即加密密码，并且用户信息服务器将存储加密密码。
- en: Therefore, in `user-server.mjs`, the `password-check` handler must be rewritten
    to accommodate checking an encrypted password.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`user-server.mjs`中，`password-check`处理程序必须重写以适应检查加密密码。
- en: 'At the top of `user-server.mjs`, add the following import:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user-server.mjs`的顶部，添加以下导入：
- en: '[PRE45]js\1'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE45]js\1'
- en: The `bcrypt.compare` function compares a plain text password, which will be
    arriving as `req.params.password`, against the encrypted password that we've stored.
    To handle encryption, we needed to refactor the checks, but we are testing for
    the same three conditions. And, more importantly, this returns the same objects
    for those conditions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`bcrypt.compare`函数比较明文密码，这些密码将作为`req.params.password`到达，与我们存储的加密密码进行比较。为了处理加密，我们需要重构检查，但我们正在测试相同的三个条件。更重要的是，对于这些条件返回相同的对象。'
- en: 'To test it, start the user information server as we''ve done before, like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，像之前一样启动用户信息服务器，如下所示：
- en: '[PRE46]js\1'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE46]js\1'
- en: We've done both these steps before. Where it differs is what we do next.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经完成了这两个步骤。不同之处在于我们接下来要做什么。
- en: 'Let''s check the database to see what was stored, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查数据库，看看存储了什么，如下所示：
- en: '[PRE47]js\1'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE47]js\1'
- en: We performed this same test earlier, but this time, it is against the encrypted
    password.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前进行了相同的测试，但这次是针对加密密码。
- en: We have verified that a REST call to check the password will work. Our next
    step is to implement the same changes in the Notes application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经验证了对密码进行REST调用将起作用。我们的下一步是在Notes应用程序中实现相同的更改。
- en: Implementing encrypted password support in the Notes application
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Notes应用程序中实现加密密码支持
- en: Since we've already proved how to implement encrypted password checking, all
    we need to do is duplicate some code in the Notes server.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经证明了如何实现加密密码检查，我们所需要做的就是在Notes服务器中复制一些代码。
- en: 'In `users-superagent.mjs`, add the following code to the top:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在`users-superagent.mjs`中，添加以下代码到顶部：
- en: '[PRE48]js\1'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE48]js\1'
- en: In those places where it is appropriate, we must encrypt the password. No other
    change is required.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的地方，我们必须加密密码。不需要其他更改。
- en: Because the `password-check` backend performs the same checks, returning the
    same object, no change is required in the frontend code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`password-check`后端执行相同的检查，返回相同的对象，所以前端代码不需要更改。
- en: To test, start both the user information server and the Notes server. Then,
    use the application to check logging in and out with both a Twitter-based user
    and a local user.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，启动用户信息服务器和Notes服务器。然后，使用应用程序检查使用基于Twitter的用户和本地用户的登录和退出。
- en: We've learned how to use encryption to safely store user passwords. If someone
    steals our user database, cracking the passwords will take longer thanks to the
    choices made here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用加密来安全存储用户密码。如果有人窃取了我们的用户数据库，由于这里的选择，破解密码将需要更长的时间。
- en: We're almost done with this chapter. The remaining task is simply to review
    the application architecture we've created.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了本章。剩下的任务只是简单地回顾我们创建的应用程序架构。
- en: Running the Notes application stack
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Notes应用程序堆栈
- en: Did you notice earlier when we said to run the Notes application stack? It's
    time to explain to the marketing team what's meant by that phrase. They may want
    to put an architecture diagram on marketing brochures or websites. It's also useful
    for developers such as us to take a step back and draw a picture of what we've
    created, or are planning to create.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到之前我们说要运行Notes应用程序堆栈？现在是时候向营销团队解释这个短语的含义了。他们可能希望在营销宣传册或网站上放置架构图。对于像我们这样的开发人员来说，退一步并绘制我们已经创建或计划创建的图片也是有用的。
- en: 'Here''s the sort of diagram that an engineer might draw to show the marketing
    team the system design (the marketing team will, of course, hire a graphics artist
    to clean it up):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是工程师可能绘制的图表，以展示给营销团队系统设计（当然，营销团队将聘请图形艺术家对其进行整理）：
- en: '![](img/56c15d1d-4fe7-45a8-8e6d-5410f048234e.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56c15d1d-4fe7-45a8-8e6d-5410f048234e.png)'
- en: The box labeled Notes Application in the preceding diagram is the public-facing
    code implemented by the templates and the router modules. As currently configured,
    it's visible from our laptop on port `3000`. It can use one of several data storage
    services. It communicates with the User Authentication Service backend over port
    `5858` (or port `3333`, as shown in the preceding diagram).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中标有“Notes应用程序”的方框是由模板和路由器模块实现的面向公众的代码。按照当前配置，它可以在我们的笔记本电脑上的端口`3000`上可见。它可以使用多个数据存储服务之一。它通过端口`5858`（或前图所示的端口`3333`）与“用户身份验证服务”后端通信。
- en: In [Chapter 10](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml),* Deploying Node.js
    Applications to Linux Servers,* we'll be expanding this picture a bit as we learn
    how to deploy on a real server.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml)中，*将Node.js应用程序部署到Linux服务器*，当我们学习如何在真实服务器上部署时，我们将扩展这个图片。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You've covered a lot of ground in this chapter, looking at not only user authentication
    in Express applications, but also microservices development.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您涵盖了很多内容，不仅涉及Express应用程序中的用户身份验证，还涉及微服务开发。
- en: Specifically, you covered session management in Express, using Passport for
    user authentication—including Twitter/OAuth, using router middleware to limit
    access, creating a REST service with Restify, and when to create a microservice.
    We've even used an encryption algorithm to ensure that we only store encrypted
    passwords.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，您涵盖了Express中的会话管理，使用Passport进行用户身份验证（包括Twitter/OAuth），使用路由器中间件限制访问，使用Restify创建REST服务，以及何时创建微服务。我们甚至使用了加密算法来确保我们只存储加密密码。
- en: Knowing how to handle login/logout, especially OAuth login from third-party
    services, is an essential skill for web application developers. Now that you've
    learned this, you'll be able to do the same for your own applications.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何处理登录/注销，特别是来自第三方服务的OAuth登录，对于Web应用程序开发人员来说是一项必不可少的技能。现在您已经学会了这一点，您将能够为自己的应用程序做同样的事情。
- en: In the next chapter, we'll take the Notes application to a new level with semi-real-time
    communication between application users. To do this, we'll write some browser-side
    JavaScript and explore how the Socket.io package can let us send messages between
    users.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过半实时通信将Notes应用程序提升到一个新水平。为此，我们将编写一些浏览器端JavaScript，并探索Socket.io包如何让我们在用户之间发送消息。
