- en: Chapter 2. Building a World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：构建一个世界
- en: This chapter explains the components of a Three.js scene in detail, including
    the different kinds of renderers, geometries, materials, and lighting. We will
    also build a procedurally generated city.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细解释 Three.js 场景的组成部分，包括不同的渲染器、几何体、材质和照明。我们还将构建一个程序生成的城市。
- en: Geometries
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何体
- en: Geometries are instances of `THREE.Geometry` that define the shape of an object
    in a scene. They are made up of vertices and faces (which are themselves objects
    and are accessible through the `vertices` and `faces` array properties). Vertices
    are the `THREE.Vector3` objects representing points in three-dimensional space,
    while faces are the `THREE.Face3` objects representing triangular surfaces. (All
    more complex shapes are subdivided into triangular faces for rendering purposes.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 几何体是 `THREE.Geometry` 的实例，用于定义场景中对象的形状。它们由顶点和面（这些面本身也是对象，可以通过 `vertices` 和 `faces`
    数组属性访问）组成。顶点是表示三维空间中点的 `THREE.Vector3` 对象，而面是表示三角形表面的 `THREE.Face3` 对象。（所有更复杂的形状都细分成三角形面以进行渲染。）
- en: Luckily, dealing with vertices and faces directly is usually unnecessary because
    `THREE.Geometry` has many subclasses that help create commonly used shapes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，直接处理顶点和面通常是不必要的，因为 `THREE.Geometry` 有许多子类可以帮助创建常用的形状。
- en: 3D primitives
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D 基本形状
- en: 'Three.js provides a number of classes that generate common shapes. The official
    documentation for each type is available at [http://threejs.org/docs/](http://threejs.org/docs/),
    but a summary of common types is shown in the following table (some obscure, optional
    constructor parameters were omitted):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了生成常见形状的多个类。每个类型的官方文档可在 [http://threejs.org/docs/](http://threejs.org/docs/)
    找到，但以下表格显示了常见类型的摘要（省略了一些不常见、可选的构造函数参数）：
- en: '| Type | Constructor | Description |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 构造函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Cube![3D primitives](img/8539_02_01.jpg) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 立方体![3D 基本形状](img/8539_02_01.jpg) |'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '| It is a rectangular box with the specified dimensions. The `segments` parameters
    split the sides into smaller rectangles. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 它是一个具有指定尺寸的矩形盒子。`segments` 参数将侧面分割成更小的矩形。 |'
- en: '| Sphere![3D primitives](img/8539_02_02.jpg) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 球![3D 基本形状](img/8539_02_02.jpg) |'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| It is a sphere approximation created by calculating segments. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 它是通过计算段来创建的球面近似。 |'
- en: '| Polyhedra (spheroids)![3D primitives](img/8539_02_03.jpg) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 多面体（球状体）![3D 基本形状](img/8539_02_03.jpg) |'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| It is a sphere approximation based on shapes with 20, 8, or 4 sides, respectively;
    the `detail` parameter specifies how many times to split each edge to make more
    faces, making the shape more spherical. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 它是基于具有 20、8 或 4 个边的形状的球面近似；`detail` 参数指定将每个边分割多少次以创建更多面，使形状更加球形。 |'
- en: '| Cylinder![3D primitives](img/8539_02_04.jpg) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 圆柱![3D 基本形状](img/8539_02_04.jpg) |'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| `radiusSegments` is the number of edges connecting the top and bottom faces,
    down the curved surface; `heightSegments` is the number of rings of faces around
    the curved surface, and if `openEnded` is `true`, the ends of the cylinder will
    not be rendered. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `radiusSegments` 是连接顶部和底部面的边的数量，沿着曲面向下；`heightSegments` 是围绕曲面周围的面的环数，如果 `openEnded`
    为 `true`，则圆柱的末端将不会渲染。 |'
- en: '| Torus![3D primitives](img/8539_02_05.jpg) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 环面![3D 基本形状](img/8539_02_05.jpg) |'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| It is a donut shape. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 它是一个甜甜圈形状。 |'
- en: '| TorusKnot![3D primitives](img/8539_02_06.jpg) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 环面结![3D 基本形状](img/8539_02_06.jpg) |'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| It is a knot shape, sort of like a pretzel. `p` and `q` are integers that
    affect how many twists are in the knot. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 它是一个类似结的形状，有点像椒盐卷饼。`p` 和 `q` 是影响结中扭曲数量的整数。 |'
- en: You can try changing the spinning icosahedron example we built in the last chapter
    to use different geometries by changing the `IcosahedronGeometry` constructor
    to one of the options in the preceding table. There is also a geometry viewer
    at [http://threejsplaygnd.brangerbriz.net/gui/](http://threejsplaygnd.brangerbriz.net/gui/)
    that allows you to tweak the constructor parameters to see the result and also
    copy the code required to generate the shape you're viewing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试将上一章中构建的旋转二十面体示例更改为使用不同的几何体，通过将 `IcosahedronGeometry` 构造函数更改为前面表格中的选项之一来实现。还有一个几何体查看器，位于
    [http://threejsplaygnd.brangerbriz.net/gui/](http://threejsplaygnd.brangerbriz.net/gui/)，允许您调整构造函数参数以查看结果，还可以复制生成您正在查看的形状所需的代码。
- en: 2D primitives
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D 基本形状
- en: 'Three.js also has default geometry for 2D shapes as shown in the following
    table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 还提供了以下表格所示默认的二维形状几何体：
- en: '| Type | Constructor | Explanation |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 构造函数 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Plane |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 平面 |'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| It is a rectangle with the specified dimensions. The `segments` parameters
    subdivide the plane into smaller rectangles. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 它是一个具有指定尺寸的矩形。`segments`参数将平面细分为更小的矩形。 |'
- en: '| Circle |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 圆 |'
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| It is a regular polygon. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 它是一个正多边形。 |'
- en: '| Ring |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 环 |'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| It is a circle with a hole in the middle. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 它是一个中间有孔的圆。 |'
- en: These shapes are created along the x and y axes by default.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形状默认沿x和y轴创建。
- en: 'Additionally, Three.js can create lines. Almost all objects you would normally
    place in a scene will be meshes, but lines are exceptions. Consider code like
    the following, which creates a mesh:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Three.js可以创建线条。你通常会在场景中放置的所有对象几乎都是网格，但线条是例外。考虑以下代码，它创建了一个网格：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead of using the preceding code, you could use the code as shown in the
    following snippet to create a line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用前面的代码，你可以使用以下代码片段来创建一条线：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This can create some strange results for standard geometry such as `IcosahedronGeometry`
    because lines will be drawn connecting points in an unexpected order. Instead,
    you will usually want to create a custom geometry so that you can add vertices
    in your desired order.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会为标准几何体（如`IcosahedronGeometry`）产生一些奇怪的结果，因为线条将以意想不到的顺序连接点。相反，你通常会想创建一个自定义几何体，这样你就可以按照你想要的顺序添加顶点。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Use `LineDashedMaterial` instead of `LineBasicMaterial` to make a dotted line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LineDashedMaterial`而不是`LineBasicMaterial`来创建虚线。
- en: Custom geometries
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义几何体
- en: 'Several default geometry types allow creating shapes based on vertices or paths
    specifically created by the developer. (You can also import geometry created in
    external programs, a topic covered in [Chapter 4](ch04.html "Chapter 4. Adding
    Detail"), *Adding Detail*.) The most basic type is the `THREE.Geometry` class
    itself. For example, you can create a triangle using the code shown in the following
    snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 几种默认的几何体类型允许根据开发者特别创建的顶点或路径创建形状。（你还可以导入在外部程序中创建的几何体，这是第4章[添加细节](ch04.html "第4章。添加细节")中讨论的主题。）最基本类型是`THREE.Geometry`类本身。例如，你可以使用以下代码片段创建一个三角形：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, this code creates a geometry object that has no vertices or faces yet.
    Then, it adds specific vertices, where each vertex is represented by a `THREE.Vector3`
    that holds spatial coordinates on the x, y, and z axes. Next, a `THREE.Face3`
    is added into the `faces` array. The `Face3` constructor's parameters indicate
    the indices of vertices in the geometry's `vertices` array to use for the face's
    corners. Finally, the bounding sphere is computed, which triggers internal calculations
    for properties Three.js needs to track such as whether the shape is in view. If
    you have trouble getting a texture to display correctly on your custom material,
    you may also need to call `geo.computeFaceNormals()` and `geo.computeVertexNormals()`.
    These functions calculate additional information about the geometry's visual layout.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这段代码创建了一个没有任何顶点或面的几何对象。然后，它添加了特定的顶点，其中每个顶点由一个表示在x、y和z轴上空间坐标的`THREE.Vector3`表示。接下来，将一个`THREE.Face3`添加到`faces`数组中。`Face3`构造函数的参数指示在几何体的`vertices`数组中使用的顶点索引，用于构成面的角。最后，计算边界球体，这会触发Three.js需要跟踪的内部计算，例如形状是否在视图中。如果你在自定义材质上正确显示纹理有困难，你可能还需要调用`geo.computeFaceNormals()`和`geo.computeVertexNormals()`。这些函数计算关于几何体视觉布局的附加信息。
- en: 'Manually creating shapes out of individual vertices can quickly get tiring;
    however, some utilities exist to help make the process faster as introduced in
    the following table:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建由单个顶点组成的形状会很快变得令人疲倦；然而，一些实用工具存在以帮助使这个过程更快，如下表所示：
- en: '| Geometry | Description |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 几何体 | 描述 |'
- en: '| --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.LatheGeometry` | It revolves a shape in a circle |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LatheGeometry` | 它在一个圆内旋转一个形状 |'
- en: '| `THREE.PolyhedronGeometry` | A spheroid; examples include `IcosahedronGeometry`,
    `TetrahedronGeometry`, and so on |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.PolyhedronGeometry` | 这是一个椭球体；例如包括`IcosahedronGeometry`、`TetrahedronGeometry`等等
    |'
- en: '| `THREE.ExtrudeGeometry` | It starts with a 2D shape and stretches it into
    a 3D space |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ExtrudeGeometry` | 它从2D形状开始并将其拉伸到3D空间 |'
- en: '| `THREE.ShapeGeometry` | It is a 2D shape |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ShapeGeometry` | 它是一个2D形状 |'
- en: '| `THREE.TubeGeometry` | It is a hollow cylinder |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.TubeGeometry` | 它是一个空心圆柱 |'
- en: '| `THREE.ParametricGeometry` | These are curved tubes |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ParametricGeometry` | 这些是弯曲的管子 |'
- en: 'Let''s take extruding as an example since that''s a relatively common operation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以拉伸为例，这是一个相对常见的操作：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The approach here is to create a 2D shape (`THREE.Shape`) out of (x, y) coordinates
    and then stretch it out along the z axis. The second parameter for `ExtrudeGeometry`
    is a map of options. The most important one, `amount`, controls how far to stretch
    out the shape. `bevelEnabled` controls whether the extruded edges are rounded
    or not. You can see the result in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的方法是创建一个由 (x, y) 坐标组成的 2D 形状 (`THREE.Shape`)，然后沿着 z 轴拉伸它。`ExtrudeGeometry`
    的第二个参数是一个选项映射。其中最重要的一个选项是 `amount`，它控制形状拉伸的距离。`bevelEnabled` 控制拉伸的边缘是否为圆角。你可以在下面的屏幕截图中看到结果：
- en: '![Custom geometries](img/8539_02_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![自定义几何体](img/8539_02_07.jpg)'
- en: An extruded triangle
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展三角形
- en: Use cases for the other custom geometries are unusual in games because normally
    if you wanted to create a complex shape, you could create a model in a 3D modeling
    program and then import it into Three.js (a process covered in [Chapter 4](ch04.html
    "Chapter 4. Adding Detail"), *Adding Detail*).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其他自定义几何体的用例在游戏中不常见，因为通常如果你想要创建一个复杂形状，你可以在 3D 建模程序中创建一个模型，然后将其导入到 Three.js 中（这个过程在
    [第 4 章](ch04.html "第 4 章。添加细节")，*添加细节* 中有介绍）。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is a WebGL-only class called `THREE.BufferGeometry` which is faster than
    `THREE.Geometry`, but is much more difficult to work with because it stores WebGL
    buffers instead of Three.js vertices and faces. However, future developments in
    Three.js will shift the default geometry to work more like `THREE.BufferGeometry`
    under the hood so that you don't have to think about the differences.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个仅适用于 WebGL 的类 `THREE.BufferGeometry`，它的速度比 `THREE.Geometry` 快，但使用起来要困难得多，因为它存储的是
    WebGL 缓冲区而不是 Three.js 的顶点和面。然而，Three.js 的未来发展中，默认的几何体将更类似于 `THREE.BufferGeometry`，这样你就不必考虑它们之间的差异。
- en: Text
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本
- en: 'Three.js can render text in 3D using geometry as well. To use this feature,
    you must include the font files after the Three.js library, but before your own
    code. For example, include the Helvetiker font using the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 可以使用几何体来渲染 3D 文本。要使用此功能，必须在 Three.js 库之后、自己的代码之前包含字体文件。例如，使用以下代码包含
    Helvetiker 字体：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (In production projects, you should download the fonts you want to use and include
    them locally.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: （在生产项目中，你应该下载你想要使用的字体并将它们本地包含。）
- en: 'Three.js comes with several fonts in the `examples/fonts` directory. Custom
    fonts must be in the `typeface.js` format (you can convert OpenType and TrueType
    fonts to Typeface format at [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html)).
    Use the following code to create text geometry:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 在 `examples/fonts` 目录中包含几个字体。自定义字体必须以 `typeface.js` 格式（你可以在 [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html)
    将 OpenType 和 TrueType 字体转换为 Typeface 格式）。使用以下代码创建文本几何体：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `THREE.TextGeometry` constructor creates a shape representing the text
    in 2D, and then extrudes it as we did with our triangle. You can see the result
    in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.TextGeometry` 构造函数创建一个代表 2D 文本的形状，然后像我们的三角形一样将其拉伸。你可以在下面的屏幕截图中看到结果：'
- en: '![Text](img/8539_02_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![文本](img/8539_02_08.jpg)'
- en: 3D text
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 文本
- en: Materials
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质
- en: 'Materials are instances of `THREE.Material` that define how objects appear.
    There are several common material subclasses:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 材质是 `THREE.Material` 的实例，它定义了对象的外观。有几个常见的材质子类：
- en: '| Constructor | Explanation |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | 说明 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MeshBasicMaterial`![Materials](img/8539_02_09.jpg) | It is not affected
    by lighting (a characteristic called **unlit**), so this is usually used to display
    a solid color or a wireframe. Two adjacent, same-colored, unlit surfaces are difficult
    to tell apart. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `MeshBasicMaterial`![材质](img/8539_02_09.jpg) | 它不受光照影响（称为 **不发光** 的特性），因此通常用于显示纯色或线框。相邻的两个相同颜色的不发光表面很难区分。|'
- en: '| `MeshNormalMaterial`![Materials](img/8539_02_10.jpg) | The red/green/blue
    values of the colors displayed by this material are based on the magnitude of
    the x/y/z values of the faces'' normal vectors. (A *normal* vector is perpendicular
    to a surface.) This material is unlit and useful for quickly distinguishing the
    shape of an object. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `MeshNormalMaterial`![材质](img/8539_02_10.jpg) | 此材质显示的颜色（红/绿/蓝）基于面法线向量的 x/y/z
    值的大小。（一个 *法线* 向量垂直于一个表面。）这种材质是不发光的，因此它适用于快速区分物体的形状。|'
- en: '| `MeshDepthMaterial`![Materials](img/8539_02_11.jpg) | It is an unlit material
    that shows shades of gray, with brightness depending on the distance from the
    camera. It is useful when designing scenes before applying more realistic textures.
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `MeshDepthMaterial`![材料](img/8539_02_11.jpg) | 它是一种未照明的材料，显示不同灰度的阴影，亮度取决于与摄像机的距离。在应用更逼真的纹理之前设计场景时很有用。|'
- en: '| `MeshLambertMaterial`![Materials](img/8539_02_12.jpg) | Faces are affected
    by lighting, but are not shiny. Specifically, lighting is calculated per-vertex
    and is interpolated over faces. It will appear black if there are no lights in
    the scene. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `MeshLambertMaterial`![材料](img/8539_02_12.jpg) | 面受到光照的影响，但不会发光。具体来说，光照是按顶点计算的，并在面上进行插值。如果没有灯光在场景中，它将显示为黑色。|'
- en: '| `MeshPhongMaterial`![Materials](img/8539_02_13.jpg) | Faces are affected
    by lighting, and can be shiny. Specifically, lighting is calculated per-*texel*
    (texture pixel), so this will be more accurate than Lambert materials when the
    light source is close to the object in question. It will appear black if there
    are no lights in the scene. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `MeshPhongMaterial`![材料](img/8539_02_13.jpg) | 面受到光照的影响，并且可以发光。具体来说，光照是按每个-*texel*（纹理像素）计算的，因此当光源靠近相关对象时，这比Lambert材料更准确。如果没有灯光在场景中，它将显示为黑色。|'
- en: '| `MeshFaceMaterial`![Materials](img/8539_02_14.jpg) | It is essentially an
    array of materials used to map different materials to different surfaces. This
    material is unique in that instantiating it is different than all the others,
    as you can see in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| `MeshFaceMaterial`![材料](img/8539_02_14.jpg) | 它本质上是一个材料数组，用于将不同的材料映射到不同的表面。这种材料是独一无二的，因为它与其他材料实例化的方式不同，如下面的代码所示：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we create three new materials we want to use, pass them in an array to
    `MeshFaceMaterial`, and then set each face on our geometry to an index of the
    `materials` array that corresponds to the material we want for that face. |
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了三个我们想要使用的新材料，将它们作为一个数组传递给`MeshFaceMaterial`，然后设置我们几何形状上的每个面，使其对应于`materials`数组中我们想要用于该面的材料索引。|
- en: '| `ShaderMaterial`![Materials](img/8539_02_15.jpg) | It displays a **GLSL**
    (**open Graphics Library Shading Language**) texture. GLSL is a programming language
    based on C that is used by WebGL and OpenGL to provide developers with a high-level,
    platform-agnostic way to control graphics. It is quite powerful and will be addressed
    more in [Chapter 4](ch04.html "Chapter 4. Adding Detail"), *Adding Detail*. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `ShaderMaterial`![材料](img/8539_02_15.jpg) | 它显示一个**GLSL**（**开放图形库着色语言**）纹理。GLSL是一种基于C的编程语言，由WebGL和OpenGL使用，为开发者提供了一种高级、平台无关的方式来控制图形。它非常强大，将在[第4章](ch04.html
    "第4章。添加细节")中更多地进行讨论，*添加细节*。|'
- en: 'All of these material constructors except `MeshFaceMaterial` take a map of
    options as their only parameter. We''ve already encountered three options from
    our icosahedron example: `color`, `wireframe`, and `wireframeLinewidth`. Additionally,
    setting the `transparency` option to `true` allows use of the `opacity` option,
    a value between zero and one indicating how see-through the material should be
    (zero is invisible, one is opaque). For materials that don''t use images, the
    other option that may be relevant is `shading`, which has a value of either `THREE.SmoothShading`
    or `THREE.FlatShading` indicating whether to blend colors of each face together,
    as shown in the next screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`MeshFaceMaterial`之外的所有材料构造函数都只接受一个选项映射作为它们的唯一参数。我们已经从我们的二十面体示例中遇到了三个选项：`color`、`wireframe`和`wireframeLinewidth`。此外，将`transparency`选项设置为`true`允许使用`opacity`选项，这是一个介于零和一之间的值，表示材料应该有多透明（零为不可见，一为不透明）。对于不使用图像的材料，可能相关的另一个选项是`shading`，其值为`THREE.SmoothShading`或`THREE.FlatShading`，表示是否混合每个面的颜色，如下一张截图所示：
- en: '![Materials](img/8539_02_16.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![材料](img/8539_02_16.jpg)'
- en: 'Left, THREE.MeshNormalMaterial({shading: THREE.FlatShading}); Right, THREE.MeshNormalMaterial({shading:
    THREE.SmoothShading});'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '左，THREE.MeshNormalMaterial({shading: THREE.FlatShading}); 右，THREE.MeshNormalMaterial({shading:
    THREE.SmoothShading});'
- en: 'There are several other properties, the most important of which is also the
    most useful: `map`. This defines the texture used to wrap over the geometry. Usually,
    using this property looks like the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个其他属性，其中最重要的也是最实用的就是`map`。这个属性定义了用于包裹几何形状的纹理。通常，使用这个属性看起来像以下代码片段：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are two issues to watch out for when loading images. First, if you are
    running your application locally (by double-clicking on the file, you will see
    a `file:///` URL), Chrome will prevent loading images by default for security
    reasons (to keep malicious JavaScript from accessing local files on your computer).
    You can solve this by either changing your browser's security settings or running
    the file using a local HTTP server as explained at [https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally](https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally).
    The second issue is that you cannot render images loaded from another domain in
    WebGL, also for security reasons. You can solve this by serving the image with
    the `Access-Control-Allow-Origin` header set to `null` as explained at [https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/](https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载图像时有两个需要注意的问题。首先，如果你是在本地运行你的应用程序（通过双击文件，你会看到一个 `file:///` URL），出于安全原因，Chrome
    默认会阻止加载图像（以防止恶意 JavaScript 访问你电脑上的本地文件）。你可以通过更改浏览器的安全设置或使用本地 HTTP 服务器运行文件来解决这个问题，具体方法请参阅
    [https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally](https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally)。第二个问题是，你不能在
    WebGL 中渲染从另一个域加载的图像，这也是出于安全原因。你可以通过将图像与 `Access-Control-Allow-Origin` 标头设置为 `null`
    来解决这个问题，具体方法请参阅 [https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/](https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/)。
- en: 'The `ImageUtils.loadTexture()` function loads images. Let''s use a slightly
    more advanced version to render the `earth` image:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageUtils.loadTexture()` 函数用于加载图像。让我们使用一个稍微高级一点的版本来渲染 `earth` 图像：'
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second parameter for `loadTexture` is currently unused, and the third parameter
    is a callback that is invoked when the image is successfully loaded. (A fourth
    parameter is also accepted for an error callback function.) We''ve seen all the
    rest of this code before except the `overdraw` option, which eliminates small
    gaps between the mesh''s faces that arise due to limitations of the canvas API.
    (The `WebGLRenderer` does not need this property; it can align faces more perfectly.)
    You can see the result in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTexture` 的第二个参数目前未使用，第三个参数是一个在图像成功加载时被调用的回调函数。（还接受一个错误回调函数的第四个参数。）我们之前已经看到了除
    `overdraw` 选项之外的所有代码，`overdraw` 选项消除了由于 canvas API 的限制而在网格面之间产生的小间隙。（`WebGLRenderer`
    不需要这个属性；它可以更完美地对齐面。）你可以在下面的屏幕截图中看到结果：'
- en: '![Materials](img/8539_02_17.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![材料](img/8539_02_17.jpg)'
- en: Earth as a sphere with a mapped texture
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 地球作为一个带有纹理映射的球体
- en: The image used in this example is available in the Three.js package at `examples/textures/planets/land_ocean_ice_cloud_2048.jpg`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中使用的图像可在 Three.js 包的 `examples/textures/planets/land_ocean_ice_cloud_2048.jpg`
    中找到。
- en: There are a number of other options for different kinds of materials that are
    too complex to address in the space we have. You can read more about them in the
    documentation for the different materials. For example, the `MeshPhongMaterial`
    documentation ([http://threejs.org/docs/#Reference/Materials/MeshPhongMaterial](http://threejs.org/docs/#Reference/Materials/MeshPhongMaterial))
    includes notes on producing reflective surfaces.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空间复杂度较高、我们无法在此处详细说明的其他材料类型，有几种其他选项。你可以在不同材料的文档中了解更多信息。例如，`MeshPhongMaterial`
    文档（[http://threejs.org/docs/#Reference/Materials/MeshPhongMaterial](http://threejs.org/docs/#Reference/Materials/MeshPhongMaterial)）中包含了关于产生反射表面的说明。
- en: A city scene
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个城市场景
- en: We've covered a lot of ground with the Three.js API. Let's tie it all together
    with a project that uses what we've learned about geometry and materials.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用 Three.js API 覆盖了很多内容。让我们通过一个项目将这些关于几何和材料的知识点综合起来。
- en: 'So far, we''ve been working with a single object in our world. If we wanted
    to move it around, we''d have to change its `position` vector. We could create
    a full scene this way by adding multiple objects and manually positioning them.
    However, for worlds with more than a few objects, this can quickly get quite tedious.
    There are several alternatives:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在我们的世界中处理单个对象。如果我们想移动它，我们就必须更改它的 `position` 向量。我们可以通过添加多个对象并手动定位它们来创建一个完整的场景。然而，对于包含多个对象的场景，这可能会很快变得相当繁琐。有几个替代方案：
- en: '**Rectangular layout**: This method involves storing a map in some simple format
    such as a string or an image, where each character or pixel color represents a
    type of object'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩形布局**：这种方法涉及将地图存储在某种简单格式中，如字符串或图像，其中每个字符或像素颜色代表一种对象类型'
- en: '**Procedural generation**: This method involves the use of an algorithm to
    position objects semi-randomly'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序生成**: 此方法涉及使用算法半随机地定位对象'
- en: '**Editor**: This method involves the use of an external tool to construct the
    scene, followed by exporting the result (for example, in JSON format), and importing
    it when the application executes'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑者**: 此方法涉及使用外部工具构建场景，然后导出结果（例如，JSON格式），并在应用程序执行时导入'
- en: The rectangular format is the easiest for simple game levels, and we'll be using
    it in [Chapter 3](ch03.html "Chapter 3. Exploring and Interacting"), *Exploring
    and Interacting*. [Chapter 5](ch05.html "Chapter 5. Design and Development"),
    *Design and Development* discusses the editor approach in detail. For now, let's
    try procedurally creating a city, based on an example created by *Ricardo Cabello*
    (the original Three.js author) at [http://www.mrdoob.com/lab/javascript/webgl/city/01/](http://www.mrdoob.com/lab/javascript/webgl/city/01/).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵格式对于简单的游戏关卡来说是最容易的，我们将在[第3章](ch03.html "第3章。探索和交互") *探索和交互*中使用它。第5章[设计和发展](ch05.html
    "第5章。设计和发展")详细讨论了编辑器方法。现在，让我们尝试根据由*Ricardo Cabello*（Three.js的原始作者）创建的示例程序生成一个城市，[请参阅这里](http://www.mrdoob.com/lab/javascript/webgl/city/01/)。
- en: 'First, let''s create a cube and material that we''ll use as the basis for our
    city buildings. We''ll copy our geometry and material for each new building and
    scale the geometry appropriately:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个立方体和材料，我们将将其作为我们城市建筑的基础。我们将为每个新建筑复制我们的几何形状和材料，并适当地缩放几何形状：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second line from the previous code snippet moves the geometry's origin (the
    point around which the geometry is scaled and rotated) to the bottom so that when
    we scale up a building, all the buildings' floors will be at the same height.
    This is done by shifting the y coordinate of every vertex and face 0.5 units up
    using a matrix that represents a vertical translation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码片段的第二行将几何形状的原点（围绕该点缩放和旋转几何形状的点）移动到底部，这样当我们放大建筑时，所有建筑的楼层都将处于相同的高度。这是通过使用表示垂直平移的矩阵将每个顶点和面的y坐标向上移动0.5个单位来完成的。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Matrices can be thought of as rectangular arrays or tables with rows and columns.
    A matrix with four rows and four columns is particularly useful for storing information
    about objects in 3D space because a single 4 x 4 matrix can represent position,
    rotation, and scale. This is the only point in this book that will mention matrices,
    so it's okay if you don't understand the underlying math; one of the reasons to
    use Three.js is to avoid having to do linear algebra manually. The transformation
    we are doing in this case is just one short way to move all the vertices and faces
    of a geometry at once without moving its origin.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以被视为具有行和列的矩形数组或表格。具有四行四列的矩阵特别适用于存储关于3D空间中对象的信息，因为单个4 x 4矩阵可以表示位置、旋转和缩放。本书中唯一提到矩阵的地方就是这里，所以如果你不理解背后的数学原理也没有关系；使用Three.js的一个原因就是避免手动进行线性代数。我们在这里进行的转换只是将所有顶点和面的几何形状一次性移动，而不移动其原点的一种简短方式。
- en: 'Next, we''ll create all our buildings:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建所有我们的建筑：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The only thing that's new here is the `clone()` method. Almost all Three.js
    objects can be cloned to create a copy that can be modified without altering the
    original. We are taking advantage of that to create new geometry and material
    instances based on our original instances.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新事物是`clone()`方法。几乎所有的Three.js对象都可以被克隆以创建一个副本，可以修改而不改变原始对象。我们正在利用这一点，根据我们的原始实例创建新的几何形状和材料实例。
- en: 'Let''s position the camera in a place where it can get a better view:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将相机放置在一个可以更好地观察的位置：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've seen rotation a couple of times now, but it's important to recall that
    rotation is measured in radians. The conversion we perform here tilts the camera
    45 degrees down. You can also use the convenient `lookAt` method. For example,
    `camera.lookAt(new THREE.Vector3(0, 0, 0))` turns the camera to look at the default
    scene origin.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到旋转几次了，但重要的是要记住旋转是以弧度来衡量的。我们在这里进行的转换使相机向下倾斜45度。你也可以使用方便的`lookAt`方法。例如，`camera.lookAt(new
    THREE.Vector3(0, 0, 0))`使相机转向默认场景原点。
- en: 'Finally, we''ll add a floor as well:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将添加一个地板：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The last two parameters to `PlaneGeometry()` split the plane into a 20 x 20
    grid. This prevents Three.js from optimizing away the floor if it thinks all the
    vertices are too far out of view. Also, the plane is created along the x and y
    axes initially, so we need to rotate it by -90 degrees to make it lie flat under
    the buildings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaneGeometry()` 的最后两个参数将平面分割成 20 x 20 的网格。这可以防止 Three.js 在认为所有顶点都太远而无法看到时优化掉地板。此外，平面最初是沿着
    x 和 y 轴创建的，因此我们需要将其旋转 -90 度，使其在建筑下方平铺。'
- en: 'Putting it all together now:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将所有这些放在一起：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s see the result, shown in the next screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果，如下面的截图所示：
- en: '![A city scene](img/8539_02_18.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![城市场景](img/8539_02_18.jpg)'
- en: Procedurally generated cityscape
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成的城市景观
- en: 'Let''s optimize the scene by merging the geometries of all the buildings. To
    do this, we''ll tweak the code that spawns our many buildings:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过合并所有建筑的几何形状来优化场景。为此，我们将调整生成我们许多建筑的代码：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The key here is that we're now merging all of the building meshes into a single
    `cityGeometry` using `GeometryUtils.merge()`. This is an important optimization
    for scenes with a lot of geometry that does not move independently because the
    renderer can more intelligently batch drawing calls if it knows about all the
    vertices and faces at once instead of drawing them one mesh at a time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们现在正在使用 `GeometryUtils.merge()` 将所有建筑网格合并成一个单一的 `cityGeometry`。这对于具有大量几何形状且不独立移动的场景是一个重要的优化，因为渲染器可以更智能地批量处理绘图调用，如果它一次知道所有顶点和面，而不是一次绘制一个网格。
- en: Lighting
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光照
- en: 'Lights are instances of `THREE.Light` that affect how the `MeshLambertMaterial`
    and `MeshPhongMaterial` surfaces are illuminated. Most lights have color (specified
    in hexadecimal notation like CSS colors) and intensity (a decimal value, usually
    between zero and one, indicating how bright the light should be). There are different
    kinds of lights as shown in the following table:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光是 `THREE.Light` 的实例，它影响 `MeshLambertMaterial` 和 `MeshPhongMaterial` 表面的光照效果。大多数灯光都有颜色（以十六进制表示法指定，类似于
    CSS 颜色）和强度（一个十进制值，通常在零到一之间，表示光线的亮度）。以下表格显示了不同类型的灯光：
- en: '| Type | Constructor | Description |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 构造函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Ambient |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 环境光 |'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| It affects all lit objects in the scene equally. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 它以相同的方式影响场景中所有被照亮的对象。 |'
- en: '| Directional |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 方向性 |'
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| For this type, all light is parallel and comes from a given direction, as
    if the source was very far away. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 对于这种类型，所有光线都是平行的，并且来自一个特定的方向，就像光源非常遥远一样。 |'
- en: '| Hemisphere |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 半球 |'
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| It simulates refractive lighting from the sun, sort of like two opposing
    directional lights. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 它模拟了来自太阳的折射光线，有点像两个相对的方向光源。 |'
- en: '| Point |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 点 |'
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| It emanates from a specific point in space, like a lightbulb. It illuminates
    only objects within `radius`. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 它从一个特定的空间点发出，就像一个灯泡。它只照亮 `radius` 范围内的对象。 |'
- en: '| Spot |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 聚焦 |'
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| It emanates from a specific point in space in a specific direction. It illuminates
    objects in a cone pointing in its direction of rotation, falling off exponentially
    within a distance of `radius`. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 它从一个特定的空间点以特定的方向发出。它照亮指向其旋转方向的圆锥形对象，在 `radius` 范围内指数衰减。 |'
- en: 'To update our procedural city scene with lighting, let''s first change the
    buildings'' material to respond to light:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新我们的程序化城市场景并添加光照，我们首先需要将建筑的材质更改为对光线做出反应：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we''ll add our light to the scene:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将光源添加到场景中：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For directional lights, the direction of the light is the direction from `light.position`
    to `light.target.position`; both are vectors that you can change, and the target
    defaults to the world's origin.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方向性光源，光线的方向是从 `light.position` 到 `light.target.position` 的方向；这两个都是可以改变的向量，目标默认是世界原点。
- en: 'Let''s also change our renderer to WebGL because `CanvasRenderer` does not
    support advanced lighting features such as shadows and fog, which we''ll want
    to add momentarily:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也把我们的渲染器改为 WebGL，因为 `CanvasRenderer` 不支持高级光照功能，如阴影和雾，这是我们即将添加的：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As a final touch now that our scene has lighting, let''s add fog for a little
    ambiance:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们场景已经添加了光照，让我们再添加一些雾气来营造一点氛围：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There are actually two kinds of fog. `FoxExp2` gets exponentially denser with
    distance, and appropriately its parameters are color and density exponent (a small
    decimal you will need to play around with depending on the scale of your world).
    The other kind of fog is `THREE.Fog`, which gets denser linearly; its parameters
    are color, minimum distance at which fog starts appearing, and maximum distance
    beyond which objects will be occluded by fog. For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种雾。`FoxExp2` 随距离的增加而指数级变密，其参数是颜色和密度指数（一个你需要根据你世界的规模进行调整的小数）。另一种雾是 `THREE.Fog`，它线性变密；其参数是颜色、雾开始出现的最小距离以及物体将被雾遮挡的最大距离。例如：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The differences between the two kinds of fog are difficult to capture in static
    images, but the next two screenshots show a contrast between exponential falloff
    and rapid linear falloff. The following screenshot shows `FogExp2` with low density:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 两种雾之间的区别在静态图像中难以捕捉，但接下来的两个截图显示了指数衰减和快速线性衰减之间的对比。以下截图显示了 `FogExp2` 的低密度：
- en: '![Lighting](img/8539_02_19.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![照明](img/8539_02_19.jpg)'
- en: 'The following screenshot shows `Fog` with short falloff:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了具有短衰减效果的 `Fog`：
- en: '![Lighting](img/8539_02_20.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![照明](img/8539_02_20.jpg)'
- en: Shadows
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影
- en: 'Only the `DirectionalLight` and `PointLight` objects can cast shadows. Casting
    shadows first requires that we enable shadows on the renderer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `DirectionalLight` 和 `PointLight` 对象可以投射阴影。首先投射阴影需要我们在渲染器上启用阴影：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you want, you can also set `renderer.shadowMapSoft = true`, which will somewhat
    smooth the edges of the shadows.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你还可以设置 `renderer.shadowMapSoft = true`，这将使阴影的边缘稍微平滑一些。
- en: 'Then, each object that will cast or receive shadows must be explicitly set
    to do so. (Shadows are disabled by default because calculating shadows can be
    slow.) For our city scene, we''ll enable shadow receiving for our floor and both
    casting and receiving for our buildings:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个将投射或接收阴影的对象必须明确设置为这样做。（阴影默认是禁用的，因为计算阴影可能会很慢。）对于我们的城市场景，我们将为地板启用阴影接收，并为建筑启用投射和接收：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `castShadow` and `receiveShadow` properties do pretty much what they sound
    like—enabling casting and receiving shadows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`castShadow` 和 `receiveShadow` 属性基本上就是它们听起来那样——启用投射和接收阴影。'
- en: 'Finally, we configure our `DirectionalLight` object to use shadows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们配置 `DirectionalLight` 对象以使用阴影：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We set the light to cast a shadow and set how dark we want it to be. The darkness
    usually ranges from `0` (no shadows) to `1` (dark shadows), but it can have other
    values; values below `0` will cause a sort of anti-shadow, where objects that
    would be in shadow are instead illuminated, and values higher than `1` will make
    shadows appear very black. Then we set the resolution of our shadows with the
    `shadowMapWidth` and `shadowMapHeight` properties, which affect the crispness
    of shadows'' edges; higher values look sharper but are more computationally expensive.
    Next, we describe the **shadow camera** that will be used to project the shadows.
    In fact, when it comes to shadows, the `DirectionalLight` and `PointLight` objects
    are analogous to the `OrthographicCamera` and `PerspectiveCamera` objects in that
    the former uses parallel projection while the latter uses perspective projection.
    Therefore, to set up our camera, we move the light to a point that is far enough
    away to be able to *see* everything we want to have a shadow. Then we describe
    the shape of the frustum with the `shadowCamera` properties; the left, right,
    top, or bottom values are the lengths of the corresponding sides of the end of
    the frustum, and the `Far` value is the distance to the end of the frustum. (Recall
    from [Chapter 1](ch01.html "Chapter 1. Hello, Three.js"), *Hello, Three.js*, that
    a frustum is a shape encompassing what a camera can *see*.) If this is difficult
    to visualize, you can display the frustum like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了光线以投射阴影，并设置了阴影的深浅。阴影的深浅通常从`0`（无阴影）到`1`（深阴影），但也可以有其他值；小于`0`的值会导致一种反阴影效果，即原本应该处于阴影中的物体反而被照亮，而大于`1`的值会使阴影显得非常黑。然后我们使用`shadowMapWidth`和`shadowMapHeight`属性设置阴影的分辨率，这些属性影响阴影边缘的清晰度；值越高，阴影看起来越清晰，但计算成本也越高。接下来，我们描述将要用于投射阴影的**阴影相机**。实际上，当涉及到阴影时，`DirectionalLight`和`PointLight`对象类似于`OrthographicCamera`和`PerspectiveCamera`对象，前者使用平行投影，而后者使用透视投影。因此，为了设置我们的相机，我们将光线移动到一个足够远的位置，以便能够*看到*我们想要投射阴影的所有内容。然后我们使用`shadowCamera`属性描述锥体的形状；左、右、上、下值是锥体末端对应边的长度，而`Far`值是锥体末端的距离。（回想一下[第1章](ch01.html
    "第1章。你好，Three.js")中的*你好，Three.js*，锥体是包含相机所能*看到*的形状。）如果这很难想象，你可以这样显示锥体：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result is a wireframe shape representing the shadow projection, shown in
    the next screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个表示阴影投影的线框形状，如下一张截图所示：
- en: '![Shadows](img/8539_02_21.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![阴影](img/8539_02_21.jpg)'
- en: A shadow camera
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影相机
- en: The `DirectionalLight` object is positioned at the peak of the red cone, the
    ends of the yellow boxes are at the `shadowCameraNear` and `shadowCameraFar` distances,
    and the edges of the box are the size of the frustum. For `PointLights`, the entire
    frustum is a cone.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectionalLight`对象位于红色圆锥的顶点，黄色盒子的末端位于`shadowCameraNear`和`shadowCameraFar`距离处，盒子的边缘是锥体的尺寸。对于`PointLights`，整个锥体是一个圆锥。'
- en: Renderers
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染器
- en: 'Earlier, we switched from `CanvasRenderer` to `WebGLRenderer` in order to support
    shadows and fog. As a rule of thumb, `WebGLRenderer` is faster and has the most
    features, while `CanvasRenderer` has fewer features but broader browser support.
    One particularly nice feature of `WebGLRenderer` is that it supports antialiasing
    to smooth out jagged edges. We can enable this for our cityscape by passing the
    option in to the renderer constructor:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 早期，我们为了支持阴影和雾效，将渲染器从`CanvasRenderer`切换到了`WebGLRenderer`。一般来说，`WebGLRenderer`速度更快，功能也更全面，而`CanvasRenderer`功能较少，但浏览器支持范围更广。`WebGLRenderer`的一个特别好的功能是它支持抗锯齿，可以平滑处理锯齿边缘。我们可以通过将选项传递给渲染器构造函数来为我们的城市景观启用此功能：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With that, our cityscape is finally complete, as shown in the next screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，我们的城市景观终于完成了，如下一张截图所示：
- en: '![Renderers](img/8539_02_22.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![渲染器](img/8539_02_22.jpg)'
- en: A completed city
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完成的城市
- en: Three.js has several other renderers, most notably for CSS and SVG. These can
    be found in the `examples/js/renderers` folder and are available as `THREE.CSS3DRenderer`
    and `THREE.SVGRenderer`, respectively, if their eponymous files are included in
    your HTML document. These renderers have a smaller set of supported features and
    are not as widely used, so they are not included in the main library, but they
    can be useful for scenes with a limited amount of primitive geometry and no lighting.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js还有其他几种渲染器，最著名的是CSS和SVG。这些可以在`examples/js/renderers`文件夹中找到，如果它们对应的文件被包含在您的HTML文档中，它们分别可用作`THREE.CSS3DRenderer`和`THREE.SVGRenderer`。这些渲染器支持的特性集较小，并且使用并不广泛，因此它们没有被包含在主库中，但它们对于具有有限原始几何形状且没有光照的场景可能很有用。
- en: For the rest of this book, we'll be using the `WebGLRenderer`, so if you're
    using a version before version 11 of Internet Explorer, you should switch to Chrome
    or Firefox.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将使用 `WebGLRenderer`，所以如果你使用的是 Internet Explorer 11 之前的版本，你应该切换到 Chrome
    或 Firefox。
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If WebGL isn't available, your game can fall back to the `CanvasRenderer` or
    just display an error message. The easiest way to do this is with the script at
    `examples/js/Detector.js`. Once the script is included on your page, you can simply
    check the `Detector.webgl` Boolean to see if WebGL is supported on the current
    system. If it's not, you can call `Detector.addGetWebGLMessage()` to explain to
    the user why your game won't run on their device and how to switch to a browser
    that supports WebGL.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 WebGL 不可用，你的游戏可以回退到 `CanvasRenderer` 或只是显示一个错误信息。这样做最简单的方式是使用 `examples/js/Detector.js`
    中的脚本。一旦脚本被包含在你的页面中，你只需简单地检查 `Detector.webgl` 布尔值，以查看当前系统是否支持 WebGL。如果不支持，你可以调用
    `Detector.addGetWebGLMessage()` 来向用户解释为什么你的游戏在他们的设备上无法运行，以及如何切换到一个支持 WebGL 的浏览器。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to work with different kinds of geometry, materials,
    and lighting. We also learned about renderers and scenes, and completed a project
    to build a city procedurally. In the next chapter, we'll learn about ways that
    users can interact with Three.js, add some physics to the mix, and build a basic
    first-person shooter game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何处理不同类型的几何形状、材质和光照。我们还了解了渲染器和场景，并完成了一个通过程序构建城市的项目。在下一章中，我们将学习用户如何与
    Three.js 交互，添加一些物理效果，并构建一个基本的单人第一人称射击游戏。
