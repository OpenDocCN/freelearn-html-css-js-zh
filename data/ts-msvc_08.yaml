- en: Testing, Debugging, and Documenting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、调试和记录
- en: So far, we've written some microservice implementations ([Chapter 4](2dd92134-2db3-4427-8565-1be5bb13be1f.xhtml), *Beginning
    Your Microservice Journey*); set up a single point of contact, API Gateway ([Chapter
    5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml), *Understanding API Gateway*);
    added a registry where each service can log their status ([Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml), *Service
    Registry and Discovery*); set up collaboration between microservices ([Chapter
    7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml), *Service State and Interservice
    Communication*); and written some implementations of them. The implementations
    seem fine from a developer's point of view, but these days nothing is accepted
    without testing. This is the age of behavior-driven development and test-driven
    development. As we write more and more microservices, developing systems without
    automated test cases and documentation becomes unmanageable and painful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了一些微服务实现（[第4章](2dd92134-2db3-4427-8565-1be5bb13be1f.xhtml)，*开始您的微服务之旅*）；建立了一个单一的接触点，API网关（[第5章](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml)，*理解API网关*）；添加了一个注册表，每个服务都可以记录其状态（[第6章](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml)，*服务注册表和发现*）；建立了微服务之间的协作（[第7章](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml)，*服务状态和服务间通信*）；并编写了一些实现。从开发者的角度来看，这些实现似乎很好，但是现在没有测试就没有人会接受。这是行为驱动开发和测试驱动开发的时代。随着我们编写越来越多的微服务，开发没有自动化测试用例和文档的系统变得难以管理和痛苦。
- en: This chapter will start with understanding the testing pyramid, with an in-depth
    description of all the different kinds of tests involved in microservices. We
    will understand the testing frameworks and understand basic unit testing terminology.
    We will then learn the art of debugging microservices and then, finally, learn
    how to document our microservices using Swagger.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从理解测试金字塔开始，深入描述微服务中涉及的所有不同类型的测试。我们将了解测试框架，并了解基本的单元测试术语。然后我们将学习调试微服务的艺术，最后学习如何使用Swagger记录我们的微服务。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Writing good automated test cases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写良好的自动化测试用例
- en: Understanding the testing pyramid and applying it to microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试金字塔并将其应用于微服务
- en: Testing microservices from the outside
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部测试微服务
- en: The art of debugging microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试微服务的艺术
- en: Documenting microservices using tools such as Swagger
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Swagger等工具记录微服务
- en: Testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Testing is a fundamental aspect of any software development. No matter how good
    the development team is, there is always scope for improvement or something has
    been left out of their training. Testing is usually a time-consuming activity
    that does not get the required attention at all. This has led to the prevalence
    of behavior-driven development, where developers write unit test cases, then write
    code, and then run a coverage report to know the status of the test cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何软件开发的基本方面。无论开发团队有多么优秀，总会有改进的空间或者他们的培训中有遗漏的地方。测试通常是一项耗时的活动，根本没有得到应有的关注。这导致了行为驱动开发的普及，开发人员编写单元测试用例，然后编写代码，然后运行覆盖率报告以了解测试用例的状态。
- en: What and how to test
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么和如何测试
- en: 'As microservices are totally distributed, the main question that comes to mind
    is what to test and how to test. First, let''s have a quick look at the major
    characteristics that define microservices and need to be tested:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务是完全分布式的，首先要考虑的问题是要测试什么以及如何测试。首先，让我们快速了解定义微服务并需要测试的主要特征：
- en: '**Independent deployment**: Whenever any'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立部署**：每当'
- en: small or a safe change has been deployed to a microservice, the microservice
    is ready to be deployed to production. But how do we know whether the change is
    safe or not? This is where automation test cases and code coverage come into the
    picture. There are several activities, such as code reviews, code analysis, and
    backward compatibility design, that can come into play, but testing is the activity
    that gives full confidence in adapting to change.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个微服务部署了一个小的或安全的更改后，该微服务就准备好部署到生产环境了。但是我们如何知道更改是否安全呢？这就是自动化测试用例和代码覆盖率发挥作用的地方。有一些活动，比如代码审查、代码分析和向后兼容性设计，可能会起作用，但是测试是一项可以完全信任适应变化的活动。
- en: '**Replaceable at will**: A good set of tests always helps to understand whether
    the new implementation is equivalent to the old implementation or not. Any new
    implementation should be tested against an equivalent implementation with a normal
    workflow.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可以随意替换**：一组良好的测试总是有助于了解新实现是否等同于旧实现。任何新实现都应该针对具有正常工作流程的等效实现进行测试。'
- en: '**Ownership by a small team**: Microservices are small and focused on an individual
    team to meet a single business requirement. We can write tests that cover all
    aspects of microservices.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小团队的所有权**：微服务是小型的，专注于一个团队，以满足单一的业务需求。我们可以编写覆盖微服务所有方面的测试。'
- en: 'The process of testing has to be fast and repeatable, and should be automated.
    The next questions are how to test and what to focus on when testing. Typically,
    all tests are divided into the following four segments:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试过程必须快速、可重复，并且应该是自动化的。接下来的问题是如何测试以及测试时要关注什么。通常，所有测试被分为以下四个部分：
- en: '**Understanding users**: The primary mode of testing is where the goal is to
    discover what users need and what problems they are having.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解用户**：主要的测试模式是发现用户需要什么以及他们遇到了什么问题。'
- en: '**Functionality check**: The goal of this mode of testing is to ensure that
    the functionality is correct and matches the specifications. It involves activities
    such as user testing, automated tests, and so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能检查**：这种测试模式的目标是确保功能正确并符合规格。它涉及用户测试、自动化测试等活动。'
- en: '**Preventing undesired changes**: The goal of this test is to prevent undesired
    changes in the system. Whenever a new change is deployed, several automated tests
    are run, a code coverage report is generated, and a code coverage level can be
    decided on.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止不必要的更改**：此测试的目标是防止系统中不必要的更改。每当部署新更改时，都会运行几个自动化测试，生成代码覆盖率报告，并可以决定代码覆盖级别。'
- en: '**Protection against runtime behavior**: The goal of this test is to check
    what operational problems the system has. Here, we protect the system by doing
    stress testing, load testing, and monitoring.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔 - 测试什么？
- en: In the next section, we will talk about the testing pyramid in microservices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务测试（中层）**：这些测试检查系统业务能力的完整执行。它们检查特定的业务需求是否已经实现。它们不关心背后需要多少服务来满足需求。'
- en: The testing pyramid – what to test?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试
- en: 'The testing pyramid is a tool to guide us through what kinds of tests can be
    written and at what levels. Tests at the top of the pyramid indicate fewer tests
    are needed, whereas more testing is required at the bottom of the pyramid. It
    illustrates what we should aim for and is shown in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔是一个指导我们编写何种测试以及在哪个级别进行测试的工具。金字塔顶部的测试表明需要较少的测试，而金字塔底部需要更多的测试。
- en: '![](img/7763e9e7-69e4-4955-8c0b-8b30f1384c3d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '**系统测试（顶层）**：这些测试跨越完整的分布式微服务系统，并通常通过GUI实现。'
- en: Testing pyramid
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔由四个级别组成，如下所述：
- en: 'The testing pyramid consists of four levels, as explained here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/7763e9e7-69e4-4955-8c0b-8b30f1384c3d.png)'
- en: '**System tests (top level)**: These tests span across the complete distributed
    microservice system and are usually implemented through the GUI.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止运行时行为**：此测试的目标是检查系统存在哪些运行时问题。在这里，我们通过压力测试、负载测试和监控来保护系统。'
- en: '**Service tests (middle level)**: These tests checks the complete execution
    of the business capability of the system. They check whether a particular business
    requirement has been fulfilled or not. They are not concerned with how many services
    behind the scenes are needed to fulfill the requirement.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分中更详细地讨论所有这些级别。
- en: '**Contract tests (lower level)**: These tests are carried out on the boundary
    of an external service to verify if meets the contract that is expected by a consuming
    service.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试（底层）**：这些测试在微服务中执行非常小的功能片段。几个较低级别的单元测试组合成一个微服务。单元测试仅涉及微服务内的一个小方面，或者我们可以说它们在宏观级别上运行。例如，我们的产品目录服务有许多服务。为其编写单元测试将涉及传递产品ID并确保我获得正确的产品。'
- en: '**Unit tests (bottom level)**: These are tests that carry out a very small
    piece of functionality in a microservice. Several lower-level unit tests combine
    to form a microservice. Unit tests involve only a small aspect inside the microservice,
    or we can say that they operate at the macroscopic level. For example, our product
    catalog service has many services. Writing a unit test for it would involve passing
    a product ID and ensuring that I get the right product.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的购物车微服务中，系统测试的一个示例将是完整的结账流程。它使用添加到购物车系统的Web UI，在那里我们添加多个项目，生成发票，应用折扣代码，并使用测试信用卡付款。如果测试通过，我们可以断言折扣代码可以应用并且可以收到付款。如果断言失败，任何事情都可能导致失败，例如商品的价格错误，可能添加了额外费用，或者可能支付服务失败。为了解决此问题，我们需要测试所有微服务以找到确切的罪魁祸首。
- en: We will look at all these levels in greater detail in the following sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**合同测试（较低级别）**：这些测试在外部服务的边界上进行，以验证是否符合消费服务期望的合同。'
- en: System tests
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将讨论微服务中的测试金字塔。
- en: Sitting at the top of the pyramid are the system tests or E2E tests. They have
    a very broad scope, or we can say they have a 50,000-foot scope, and they try
    to cover a lot of things in very few tests. They don't go down the macroscopic
    level. Whenever a system test fails, it is difficult to identify where the problem
    is because of its large scope. The test covers the entire distributed system,
    so the problem can be anywhere, in any component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 位于金字塔顶部的是系统测试或端到端测试。它们具有非常广泛的范围，或者我们可以说它们具有5万英尺的范围，并试图在很少的测试中涵盖很多内容。它们不会降到宏观级别。每当系统测试失败时，很难确定问题所在，因为它的范围很大。测试覆盖整个分布式系统，因此问题可能出现在任何地方，任何组件中。
- en: An example of a system test in our shopping cart microservices would be the
    complete checkout process. It uses the web UI of the add to cart system, where
    we add a number of items, generate an invoice, apply a discount code, and pay
    using a test credit card. If the test passes, we can assert that the discount
    code can be applied and payments can be received. If the assertion fails, anything
    could have caused the failure, such as a wrong price for an item, maybe an extra
    charge was added, or maybe a payment service failed. To resolve this issue, we
    need to test all microservices to find the exact culprit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖大量服务和更广泛的领域，系统测试通常倾向于缓慢和不精确（因为我们无法确定失败的确切服务）。而不是使用模拟系统，实际进行服务请求，将事物写入真实数据存储，并甚至轮询真实事件源以监视系统。
- en: Covering a huge number of services and a broader area, system tests usually
    tend to be slow and imprecise (as we can't determine the exact service that is
    failing). Real service requests are made rather than a mocking system, things
    are written to real data stores, and even real event feeds are polled to monitor
    the system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的问题是关于需要运行多少系统测试。系统测试成功时可以给予很大的信心，但它们也缓慢且不精确；我们只能为系统的最重要的用例编写系统级测试。这可以让我们覆盖系统中所有重要业务能力的成功路径。
- en: 'An important question that comes to mind is regarding the number of system
    tests that need to be run. System tests, when successful, give a great deal of
    confidence, but they are also slow and imprecise; we can write system-level tests
    for only the most important use cases. This can give us coverage of the success
    paths of all important business capabilities in the system. For complete E2E tests,
    we can do one of the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的端到端测试，我们可以采取以下行动之一：
- en: Test our API using JSON requests
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON请求测试我们的API
- en: Test the UI using Selenium, which emulates clicks on the DOM
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Selenium测试UI，模拟对DOM的点击。
- en: Use behavior-driven development, where use cases are mapped into actions in
    our application and are later executed on the application that we have built
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为驱动开发，将用例映射到我们应用程序中的操作，并在我们构建的应用程序上执行
- en: My recommendation is writing only business facing an important business capabilities
    system testing, as this exercises much of the fully deployed system and involves
    utilizing all the components in the ecosystem, such as the load balancer, API
    Gateway, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是只编写面向业务的重要业务能力系统测试，因为这样可以对完全部署的系统进行大量练习，并涉及利用生态系统中的所有组件，如负载均衡器、API网关等。
- en: Service tests
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务测试
- en: These tests are in the middle level of the test pyramid and they focus on interacting
    with one microservice in its entirety, and in isolation. The collaboration of
    this microservice with the outside world is replaced by mock JSON. Service-level
    tests test scenarios, rather than making a single request. They make a sequence
    of requests that together form a complete picture. These are real HTTP requests
    and responses, rather than mocked responses.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试处于测试金字塔的中间层，它们专注于与一个微服务的完整交互，并且是独立的。这个微服务与外部世界的协作被模拟JSON所取代。服务级测试测试场景，而不是进行单个请求。它们进行一系列请求，共同形成一个完整的图片。这些是真正的HTTP请求和响应，而不是模拟的响应。
- en: 'For example, a service-level test for a credits program can do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，信用计划的服务级测试可以执行以下操作：
- en: Send a command to trigger a user in the credits category (the command here follows
    the CQRS pattern seen in [Chapter 1](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml), *Debunking
    Microservices*. CQRS follows a synchronous pattern of communication, so, its testing
    code would be the same). We send a command to trigger the other service to fulfill
    our service test criteria.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送命令以触发信用类别中的用户（这里的命令遵循CQRS模式，见[第1章](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml)，“揭秘微服务”）。CQRS遵循同步通信模式，因此，它的测试代码是相同的。我们发送命令以触发其他服务来满足我们的服务测试标准。
- en: Decide the best loyalty offer based on the user's monthly spending. This can
    be hardcoded, as it is a different microservice.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户的月度消费决定最佳的忠诚度优惠。这可以是硬编码的，因为它是一个不同的微服务。
- en: Record the offer sent to the user, and send back a response to check the functionality
    of the service.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录发送给用户的优惠，并发送响应以检查服务的功能。
- en: When all these aspects pass, we can assert that the credits program microservice
    works successfully and if any one of the functionalities fails, we know for sure
    that the issue is in the credits program microservice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些方面都通过时，我们可以断言信用计划微服务成功运行，如果任何一个功能失败，我们可以肯定问题出在信用计划微服务中。
- en: Service-level tests are much more precise than system-level tests as they cover
    only a single microservice. If such a test fails, we can with certainty assert
    that the problem lies within the microservice, assuming that the API Gateway is
    not buggy and it delivers the exact same response as written in the mocks. On
    the other hand, service-level tests are still slow, as they need to interact with
    the microservice being tested over HTTP and with a real database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务级测试比系统级测试更精确，因为它们只涵盖一个单一的微服务。如果这样的测试失败，我们可以肯定地断言问题出在微服务内部，假设API网关没有错误，并且它提供了与模拟中写的完全相同的响应。另一方面，服务级测试仍然很慢，因为它们需要通过HTTP与被测试的微服务进行交互，并且需要与真实数据库进行交互。
- en: My recommendation is that these tests should be written for the most important
    viable failure scenarios, keeping in mind that writing service-level tests is
    expensive as they use all the endpoints in the microservice and involve an event-based
    subscription.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，应该为最重要的可行故障场景编写这些测试，要牢记编写服务级测试是昂贵的，因为它们使用微服务中的所有端点，并涉及基于事件的订阅。
- en: Contract tests
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同测试
- en: There is a lot of collaboration going on between microservices in a distributed
    system. Collaborations need to be implemented as requests from one microservice
    to another. Any change in an endpoint can break all the microservices calling
    that particular endpoint. This is where contract tests come into the picture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，微服务之间有很多协作。协作需要作为一个微服务对另一个微服务的请求来实现。端点的任何更改都可能破坏调用该特定端点的所有微服务。这就是合同测试的作用所在。
- en: 'When any microservices communicate, the one that makes a request to another
    has some expectations about how the other microservice will act. This is how the
    collaboration would work out: the calling microservice expects the called microservice
    to implement a certain fixed contract. A contract test is a test for the purpose
    of checking whether the called microservice implements the contract as per the
    calling microservice''s expectation.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何微服务进行通信时，发出请求的微服务对另一个微服务的行为有一些期望。这就是协作的工作方式：调用微服务期望被调用的微服务实现某个固定的合同。合同测试是为了检查被调用的微服务是否按照调用微服务的期望实现了合同的测试。
- en: Although contract tests are part of the code base of the caller microservice,
    they also test things in other microservices. As they run against the complete
    system, it is beneficial to run them against a QA or staging environment and to
    configure to run contract tests automatically on each deployment. When a contract
    fails, it implies that we need to update our test doubles or change our code to
    take in the new changes the contract has made. These tests should be run based
    on the number of changes in external service. Any failure in a contract test won't
    break the build in the same way a normal test failure would do if it failed. It's
    an indicator that the consumer needs to keep up with changes. We need to update
    the tests and code to bring everything into sync. It will trigger a conversation
    will the producer service about how that change is affecting others.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管契约测试是调用方微服务代码库的一部分，但它们也测试其他微服务中的内容。由于它们针对完整系统运行，因此有利于针对QA或分阶段环境运行它们，并配置在每次部署时自动运行契约测试。当契约失败时，意味着我们需要更新我们的测试替身或更改我们的代码以适应契约所做的新更改。这些测试应该根据外部服务的更改数量来运行。契约测试的任何失败都不会像普通测试失败那样破坏构建。这表明消费者需要跟上变化。我们需要更新测试和代码以使一切保持同步。这将引发与生产者服务的对话，讨论该变化如何影响其他方面。
- en: My conclusion is that contract tests are very similar to service tests, but
    the difference is contract tests focus on fulfilling the prerequisites for communicating
    with a service. Contract tests do not set up mock collaborators and actually make
    real HTTP requests to the microservice being tested. Therefore, they should be
    written against each microservice if possible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我的结论是，契约测试与服务测试非常相似，但区别在于契约测试侧重于满足与服务通信的先决条件。契约测试不设置模拟协作者，实际上会向正在测试的微服务发出真实的HTTP请求。因此，如果可能的话，它们应该针对每个微服务进行编写。
- en: Unit tests
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'These are the tests at the bottom of the test pyramid. These tests also deal
    with a single microservice, but unlike service tests, they don''t focus on the
    entire microservice, nor do they work over HTTP. Unit tests interact with the
    parts/units of the microservice being tested directly or through in-memory calls.
    Testing in unit testing looks exactly like you are making real HTTP requests,
    except that you are dealing with mocks and playing with assertions. There are
    usually two kinds of unit testing involved: one that involves making database
    calls and another that involves playing directly with in-memory calls. A test
    can be termed a unit test if its scope is a very small piece of functionality,
    and if the test code and the production code in the microservice run in the same
    process.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是测试金字塔底部的测试。这些测试也涉及单个微服务，但与服务测试不同，它们不关注整个微服务，也不通过HTTP工作。单元测试直接与正在测试的微服务的部分/单元进行交互，或通过内存调用。单元测试看起来就像您正在进行真实的HTTP请求，只是您在处理模拟和断言。通常涉及两种类型的单元测试：一种涉及数据库调用，另一种直接涉及内存调用。如果测试的范围非常小，并且测试代码和微服务中的生产代码在同一个进程中运行，那么测试可以被称为单元测试。
- en: Unit tests have a very narrow scope, making them very precise when identifying
    the problem. This helps in handling failures and errors effectively. Sometimes,
    you can have an even narrower scope of microservices by directly instantiating
    objects and then testing them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的范围非常狭窄，因此在识别问题时非常精确。这有助于有效处理故障和错误。有时，您可以通过直接实例化对象然后对其进行测试，使微服务的范围更窄。
- en: For our credit program, we need several unit tests to test the endpoints and
    business capabilities. We need to test the user setup with both valid and invalid
    data. We need tests to read both existing and non-existing users to check our
    loyalty and monthly benefits.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的信用计划，我们需要几个单元测试来测试端点和业务能力。我们需要测试用户设置，包括有效和无效数据。我们需要测试读取现有和不存在的用户，以检查我们的忠诚度和月度福利。
- en: 'My recommendation is that we should decide how narrow the narrowest unit test
    can be. Start with what the test should cover and then gradually add finer details.
    In general, there are two styles of unit testing that we can use: classic (state-based
    behavior testing) or mocking (interaction testing supported by mocking actual
    behavior).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，我们应该决定最窄的单元测试可以有多窄。从测试应该覆盖的内容开始，然后逐渐添加更精细的细节。一般来说，我们可以使用两种单元测试风格：经典的（基于状态的行为测试）或模拟的（通过模拟实际行为支持的交互测试）。
- en: 'In the following diagram, we can see all the kinds of test applied to a microservice:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到应用于微服务的所有测试类型：
- en: '![](img/7ac4fe7b-1a39-4f63-b333-7a7c0364be9c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ac4fe7b-1a39-4f63-b333-7a7c0364be9c.png)'
- en: Types of testing
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类型
- en: Now that we know about all the kinds of tests needed at the microservice level,
    it is time to look at our microservice testing frameworks. In the next section,
    we will look at hands-on implementations of different kinds of testing and carry
    out the code coverage level of a microservice. Let's get started.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了微服务级别需要的所有测试类型，是时候看看我们的微服务测试框架了。在下一节中，我们将看到不同类型测试的实际实现，并进行微服务的代码覆盖率。让我们开始吧。
- en: Hands-on testing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践测试
- en: 'It''s now time to get our hands dirty with microservice testing frameworks.
    In this section, we will look at testing basics and then carry on to write some
    unit tests, contract tests, and service-level tests. Writing tests has great advantages.
    We are forced to think through breaking the code into sub-functions and writing
    code based on the principle of single responsibility. Comprehensive test coverage
    with good tests makes us understand how the application works. In this section,
    we will be using some famous toolsets: Mocha, Chai, Sinon, and Ava. Ava will be
    our test runner, Chai will be our assertion library, and Sinon will be our mocking
    library.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候动手使用微服务测试框架了。在本节中，我们将首先了解测试基础知识，然后继续编写一些单元测试、合同测试和服务级测试。编写测试有很大的优势。我们被迫思考如何将代码分解为子函数，并根据单一职责原则编写代码。全面的测试覆盖率和良好的测试使我们了解应用程序的工作原理。在本节中，我们将使用一些著名的工具集：Mocha，Chai，Sinon和Ava。Ava将是我们的测试运行器，Chai将是我们的断言库，Sinon将是我们的模拟库。
- en: Our libraries and test tool types
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的库和测试工具类型
- en: 'Test tools can be divided into various functionalities. In order to get the
    best out of them, we always use a combination of them. Let''s look at the best
    tools available based on their functionalities:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具可以分为各种功能。为了充分利用它们，我们总是使用它们的组合。让我们根据它们的功能来看看可用的最佳工具：
- en: 'Provide a testing base: Mocha, Jasmine, Jest, Cucumber'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供测试基础：Mocha，Jasmine，Jest，Cucumber
- en: 'Give assertion functions: Chai, Jasmine, Jest, Unexpected'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供断言函数：Chai，Jasmine，Jest，Unexpected
- en: 'Generate, display and observe test results: Mocha, Jasmine, Jest, Karma'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成、显示和观察测试结果：Mocha，Jasmine，Jest，Karma
- en: 'Generate and compare snapshots of component and data structures: Jest, Ava'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和比较组件和数据结构的快照：Jest，Ava
- en: 'Provide mocks, spies, and stubs: Sinon, Jasmine, Enzyme, Jest, test double'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供模拟、间谍和存根：Sinon，Jasmine，Enzyme，Jest，test double
- en: 'Generate code coverage reports: Istanbul, Jest, Blanket'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成代码覆盖报告：Istanbul，Jest，Blanket
- en: 'E2E tests: Casper, Nightwatch'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E2E测试：Casper，Nightwatch
- en: In this section, we will quickly go through Ava, Chai, Mocha, and Sinon, and
    get to know what they have to offer to us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速浏览Ava，Chai，Mocha和Sinon，并了解它们对我们有什么提供。
- en: Even though Mocha is a standard library, I have selected Ava because it is very
    fast compared to Mocha and it runs each test as a separate Node.js process, thereby
    saving CPU usage and memory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Mocha是一个标准库，但我选择了Ava，因为它与Mocha相比非常快，它将每个测试作为单独的Node.js进程运行，从而节省CPU使用率和内存。
- en: Chai
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柴
- en: This is a fundamental assertion library following TDD/BDD that can be used in
    conjunction with any other libraries in order to have superior-quality tests.
    An assertion i
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的断言库，遵循TDD/BDD，可以与任何其他库一起使用，以获得高质量的测试。一个断言i
- en: s any statement that has to be fulfilled, or else an error should be thrown
    and the test should be stopped. This is a very powerful tool to write easy-to-understand
    test cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何必须实现的语句，否则应该抛出错误并停止测试。这是一个非常强大的工具，可以编写易于理解的测试用例。
- en: 'It provides the following three interfaces to make test cases more readable
    and powerful:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了以下三个接口，使测试用例更易读和更强大：
- en: '`should`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`should`'
- en: '`expect`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`'
- en: '`assert`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`'
- en: Along with these three interfaces, we can use various natural language words.
    The full list can be found at [http://www.chaijs.com/api/bdd/](http://www.chaijs.com/api/bdd/).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个接口，我们还可以使用各种自然语言词汇。完整列表可以在[http://www.chaijs.com/api/bdd/](http://www.chaijs.com/api/bdd/)找到。
- en: You must be wondering what the difference is between `should` and `expect`.
    Well, it is a natural question. Although `should` and `expect` do the same thing,
    the fundamental difference is that the `assert` and `expect` interfaces do not
    modify `Object.prototype`, while `should` does.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定想知道`should`和`expect`之间的区别是什么。嗯，这是一个自然的问题。尽管`should`和`expect`做同样的事情，但根本区别在于`assert`和`expect`接口不修改`Object.prototype`，而`should`则会。
- en: Mocha
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocha
- en: One of the most famous and widely used libraries, Mocha follows behavior-driven
    development testing. Here, the test describes the use case of any service, and
    it uses assertions from another library to verify the outcome of the executed
    code. Mocha is a test runner. It is used t
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是最著名和广泛使用的库之一，遵循行为驱动开发测试。在这里，测试描述了任何服务的用例，并且它使用另一个库的断言来验证执行代码的结果。Mocha是一个测试运行器。它被用来
- en: 'o organize and run tests through `describe` and its operators. Mocha provides
    various features, such as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 组织和运行测试通过`describe`和它的操作符。 Mocha提供了各种功能，比如：
- en: '`beforeEach()`: It is called once before each spec in describe in the test
    file from which the test runs'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()`: 在测试文件中的每个规范之前调用一次，从中运行测试'
- en: '`afterEach()`: It is called once after each spec in describe in the test file'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach()`: 在测试文件中的每个规范之后调用一次'
- en: '`before ()`: This runs code prior to any tests'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before ()`: 这在任何测试之前运行代码'
- en: '`after()`: This runs code after all tests have run'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after()`: 这在所有测试运行后运行代码'
- en: Ava
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ava
- en: Ava, like Mocha, is a test runner. Ava takes advantage of the parallel and asynchronous
    nature of Node.js and runs test files in parallel processing through a separate
    process. As per the stats, switching from Mocha to Ava in `pageres` (a plugin
    that captures screenshots), brought test time down from 31 seconds to 11 seconds
    ([https://github.com/avajs/ava/blob/master/readme.md](https://github.com/avajs/ava/blob/master/readme.md)).
    It has various options, such as fail fast, live watch (tests are rerun in watch
    mode when files are changed), storing snapshots, and so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Ava，像Mocha一样，是一个测试运行器。Ava利用Node.js的并行和异步特性，并通过单独的进程并行处理运行测试文件。根据统计数据，在`pageres`（一个捕获屏幕截图的插件）中从Mocha切换到Ava，将测试时间从31秒降至11秒（[https://github.com/avajs/ava/blob/master/readme.md](https://github.com/avajs/ava/blob/master/readme.md)）。它有各种选项，如快速失败、实时监视（在更改文件时以监视模式重新运行测试）、存储快照等。
- en: 'Ava is designed for the future and is completely written in ES6\. Test run
    concurrently here with option of going synchronous or asynchronous with the tests.
    Tests are considered synchronous by default unless they return a promise or an
    observable. They heavily use async function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ava是为未来设计的，完全使用ES6编写。测试可以并行运行，可以选择同步或异步进行测试。默认情况下，测试被认为是同步的，除非它们返回一个promise或一个observable。它们大量使用异步函数：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It has a wide range of options such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它有各种选项，如：
- en: Reports (beautiful reports showing test coverage)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告（显示测试覆盖率的美观报告）
- en: Failing fast (stops after the first failed test case)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速失败（在第一个失败的测试用例后停止）
- en: Skipping tests
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过测试
- en: Futuristic tests
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来的测试
- en: Sinon
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sinon
- en: Quite often, microservices need to call other microservices, but we don't want
    to call the actual microservice; we just want to focus on whether the method was
    called
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，微服务需要调用其他微服务，但我们不想调用实际的微服务；我们只想关注方法是否被调用
- en: 'or not. For this, we have Sinon, a framework that gives us the options of mocks
    and spies, which fulfill our purpose by providing mock responses or creating a
    spy service. It provides the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者不。为此，我们有Sinon，一个框架，它给我们提供了模拟和间谍的选项，通过提供模拟响应或创建间谍服务来实现我们的目的。它提供以下功能：
- en: '**Stub**: A stub is a dummy object with a prerecorded and specific response.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stub**：存根是一个带有预先记录和特定响应的虚拟对象。'
- en: '**Spy**: A spy is a kind of hybrid between the real object and the mock. Some
    methods are shadowed by the spy object.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spy**：间谍是真实对象和模拟对象之间的混合体。一些方法被间谍对象遮蔽。'
- en: '**Mock**: A mock is a dummy object replacing the actual object.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mock**：模拟是替换实际对象的虚拟对象。'
- en: Istanbul
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伊斯坦布尔
- en: This is a code coverage tool that covers tracking statements, branches, and
    functional coverage. The module loader hooks to instrument code on the fly without
    the need for configuration. It offers multiple report formats, such as HTML, LCOV,
    and so on. It can also be used on command lines. It can be used as a server-side
    code coverage tool for Node.js by embedding it as custom middleware.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码覆盖工具，用于跟踪语句、分支和功能覆盖。模块加载器可以在不需要配置的情况下即时对代码进行检测。它提供多种报告格式，如HTML、LCOV等。它也可以用于命令行。通过将其嵌入为自定义中间件，它可以用作Node.js的服务器端代码覆盖工具。
- en: Contract tests using Pact.js
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pact.js进行合同测试
- en: Each microservice has its own independent implementation; let's say our categories
    service(product-catalog service). It has an endpoint for fetching a list of categories,
    getting the list of products associated with those categories, adding any new
    categories, and so on. Now our shopping cart microservices (consumer) utilizes
    this service, but at any point in time, the categories microservice (provider)
    may change.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有自己独立的实现；比如我们的类别服务（产品目录服务）。它有一个用于获取类别列表、获取与这些类别相关的产品列表、添加任何新类别等的端点。现在我们的购物车微服务（消费者）利用这个服务，但在任何时候，类别微服务（提供者）可能会发生变化。
- en: 'At any point in time:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候：
- en: The provider might change the endpoint `/categories/list` to `/categories`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能会将端点“/categories/list”更改为“/categories”
- en: The provider might change several things in the payload
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能会更改有效负载中的几个内容
- en: The provider might add new mandatory parameters or may introduce a new authentication
    mechanism
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能会添加新的强制参数或引入新的身份验证机制
- en: The provider might remove endpoints that are needed by the consumer
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能会删除消费者所需的端点
- en: 'Any of these conditions may lead to a potential catastrophe! These kinds of
    test would not be handled by unit tests and the traditional approach is to use
    integration tests. But, however, we can see potential drawbacks of integration
    tests, such as the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些情况都可能导致潜在的灾难！这些类型的测试不会被单元测试处理，传统方法是使用集成测试。但是，我们可以看到集成测试的潜在缺点，例如以下内容：
- en: Integration tests are slow. They require setting up integration environments
    where dependencies for both providers and consumers are fulfilled.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试很慢。它们需要设置集成环境，满足提供者和消费者的依赖关系。
- en: They are brittle and can fail due to other reasons, such as infrastructure.
    A failed integration test doesn't necessarily mean a problem with the code. Due
    to the high scope of integration tests, it becomes very painful to find out the
    actual problem.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们很脆弱，可能因其他原因而失败，比如基础设施。集成测试的失败并不一定意味着代码有问题。由于集成测试的范围很广，要找出实际问题变得非常痛苦。
- en: Hence, we need to go for contract tests.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要进行合同测试。
- en: What is consumer-driven contract testing?
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是消费者驱动的合同测试？
- en: Contract testing means that we check our API against a set of expectations (what
    we define as contracts) which are meant to be fulfilled. This means that we want
    to check whether, upon receiving any API request call, our API server will return
    the data we specified in the documentation or not. We often miss out precise information
    regarding the needs of our API customers. To overcome this problem, consumers
    can define their set of expectations as mocks, which they use in unit tests, thus
    creating contracts that they expect us to fulfill. We collect these mocks and
    check that our provider returns the same or any similar data or not when they
    get called the same way as mocks are set up, thereby testing the service boundary.
    This complete approach is called consumer-driven contract testing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 合同测试意味着我们根据一组期望（我们定义为合同的内容）来检查我们的API，这些期望是要实现的。这意味着我们想要检查，当收到任何API请求时，我们的API服务器是否会返回我们在文档中指定的数据。我们经常忽略关于我们的API客户需求的精确信息。为了解决这个问题，消费者可以定义他们的期望集作为模拟，在单元测试中使用，从而创建他们期望我们实现的合同。我们收集这些模拟，并检查我们的提供者在以与模拟设置相同的方式调用时是否返回相同或类似的数据，从而测试服务边界。这种完整的方法被称为消费者驱动的合同测试。
- en: 'The idea of consumer-driven contracts is just to formalize any or all of the
    interactions between a consumer and a provider. The consumer creates a contract,
    which is just an agreement between the consumer and provider on the amount of
    interaction that will take place between them or simply stating what the consumer
    expects from the provider. Once the provider has agreed to the contract, both
    the consumer and provider can take a copy of the contract and use tests to verify
    that contract violation doesn''t occur on any end of the system. The major advantage
    of these kinds of tests is they can be run independently and locally and they
    are super fast and can be run without any hassle. Similarly, if a provider has
    several consumers, we will need to verify several contracts: one for each consumer.
    This will help us to ensure that changes to the provider do not break any consumer
    services.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者驱动的合同的想法只是为了规范消费者和提供者之间的任何或所有交互。消费者创建一个合同，这只是消费者和提供者之间关于将发生的交互量或简单地陈述消费者对提供者的期望的协议。一旦提供者同意了合同，消费者和提供者都可以拿到合同的副本，并使用测试来验证系统的任何一端不会发生合同违反。这种测试的主要优势是它们可以独立和本地运行，速度非常快，而且可以毫不费力地运行。同样，如果提供者有多个消费者，我们需要验证多个合同：每个消费者一个。这将帮助我们确保对提供者的更改不会破坏任何消费者服务。
- en: Pact is one of the famous open source frameworks that enable consumer-driven
    contract testing. There are various implementations for Pact for various platforms,
    such as Ruby, JVM, and NET. We will be using the JavaScript version Pact JS. So
    Let's get started. Let's start our journey with Pact.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Pact是一个著名的开源框架，可以进行消费者驱动的合同测试。 Pact有各种平台的不同实现，例如Ruby、JVM和.NET。我们将使用JavaScript版本的Pact
    JS。所以让我们开始吧。让我们开始Pact之旅。
- en: Introduction to Pact.js
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pact.js简介
- en: We will be utilizing the `pact` module ([https://www.npmjs.com/package/pact](https://www.npmjs.com/package/pact))
    available in NPM. The overall process would be as follows, where we would n
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用NPM中可用的`pact`模块（[https://www.npmjs.com/package/pact](https://www.npmjs.com/package/pact)）。整个过程将如下所示，我们将
- en: need to do operations at both the consumer and the provider levels.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在消费者和提供者两个级别进行操作。
- en: 'We will be dividing our implementation into two parts. We will set up a provider
    as well as a client to test whether the services are communicating with one another:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的实现分为两部分。我们将建立一个提供者以及一个客户端，以测试服务是否相互通信：
- en: '**On the consumer side**:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在消费者端**：'
- en: We will create a mock web server that will act as a service provider rather
    than making an actual call. Pact.js provides this functionality out of the box.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个模拟的网络服务器，它将充当服务提供者，而不是进行实际调用。 Pact.js提供了这个功能。
- en: For any request that we want to check, we will define the expected response
    that the mock service needs to return to check whether there are any sudden changes.
    In Pact language, we call these interactions; that is, for a given request what
    does the consumer want the provider to return?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们想要检查的任何请求，我们将定义模拟服务需要返回的预期响应，以检查是否有任何突然的变化。在Pact语言中，我们称这些为交互；也就是说，对于给定的请求，消费者希望提供者返回什么？
- en: We next create unit tests where we will run our service client against the mock
    provider to check whether the client returns these expected values.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建单元测试，我们将运行我们的服务客户端与模拟提供者进行检查，以确保客户端返回这些预期值。
- en: Finally, we will create a `pact` file containing the consumer expectations as
    a contract.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个包含消费者期望的合同的`pact`文件。
- en: '**On the provider side**:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在提供者端**：'
- en: The provider side gets the pact file from the consumer.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供者端从消费者那里获取pact文件。
- en: It needs to verify that it doesn't violate the expected interactions of the
    consumer. `Pact.js` will read the `pact` file, execute the request for each interaction,
    and confirm whether the service returns the payload expected by the consumer.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要验证它不违反消费者的预期交互。`Pact.js`将读取`pact`文件，执行每个交互的请求，并确认服务是否返回消费者期望的有效负载。
- en: By checking that the provider does not violate any of its consumer's contracts,
    we can be sure that the latest changes to the provider's code don't break any
    consumer code.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查提供者不违反任何消费者的合同，我们可以确保对提供者代码的最新更改不会破坏任何消费者代码。
- en: This way, we can avoid integration testing and still be confident of our system.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，我们可以避免集成测试，同时对我们的系统充满信心。
- en: 'After understanding the process, let''s now implement it. We will follow the
    preceding steps regarding the consumer and provider, one at a time. The complete
    example can be found in `chapter-8/pact-typescript`. Our example project is the
    categories microservice and we will be playing around with it. So, let''s get
    started:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了整个过程之后，现在让我们来实现它。我们将依次遵循关于消费者和提供者的前述步骤。完整的示例可以在`chapter-8/pact-typescript`中找到。我们的示例项目是类别微服务，我们将围绕它进行操作。所以，让我们开始吧：
- en: We first create a provider. We will create a service that returns some animals
    and a specific animal service that gives me an animal on passing an ID.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个提供者。我们将创建一个返回一些动物的服务以及一个在传递ID时给我动物的特定动物服务。
- en: Follow the code from the provider by adding `provider.ts`, `providerService.ts`, `repository.ts` from `packt-typescript/src/provider` and `data.json` from `pact-typescript/data`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照提供者的代码，通过从`packt-typescript/src/provider`添加`provider.ts`、`providerService.ts`、`repository.ts`以及从`pact-typescript/data`添加`data.json`。
- en: 'Add the following dependencies:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下依赖项：
- en: '[PRE1]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we will create a consumer. The consumer consumes files from providers.
    We will create a Pact server:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个消费者。消费者从提供者那里获取文件。我们将创建一个Pact服务器：
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We define our expectations next, where we will say:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的期望，我们将说：
- en: '[PRE3]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we write our usual tests, but before adding the tests, we add these interactions
    in Pact:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编写通常的测试，但在添加测试之前，我们在Pact中添加这些交互：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, w write the usual tests:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编写通常的测试：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shut down the mock server:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭模拟服务器：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we are done on the provider side, we need to verify our provider.
    Start the `provider` service and in its test file, add the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了提供者方面的工作，我们需要验证我们的提供者。启动`provider`服务，并在其测试文件中添加以下代码：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bonus (containerizing pact broker)
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奖励（容器化pact broker）
- en: 'In dynamic environments, we need to share Pacts across applications rather
    than working in a single application. To do so, we will leverage the functionality
    of the Pact broker. You can simply download it from [https://hub.docker.com/r/dius/pact-broker/](https://hub.docker.com/r/dius/pact-broker/).
    You can download it through Docker using `docker pull dius/pact-broker`. Once
    started, you can access the broker with `curl -v http://localhost/9292 #`, which
    you can visit in your browser too! You can configure it with a database and run
    a combined `docker-compose.yml` file too. A demo configuration for pact-broker
    configured with Postgres can be found at [https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml](https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml).
    Once configured by executing the `docker-compose up` command, the `pact` broker
    can be accessed on port 80 or port 443 depending on whether SSL is enabled or
    not.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '在动态环境中，我们需要跨应用程序共享Pacts，而不是在单个应用程序中工作。为此，我们将利用Pact broker的功能。您可以从[https://hub.docker.com/r/dius/pact-broker/](https://hub.docker.com/r/dius/pact-broker/)简单地下载它。您可以使用`docker
    pull dius/pact-broker`通过Docker下载它。一旦启动，您可以使用`curl -v http://localhost/9292 #`访问经纪人，您也可以在浏览器中访问！您还可以使用数据库配置它，并运行一个组合的`docker-compose.yml`文件。可以在[https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml](https://github.com/DiUS/pact_broker-docker/blob/master/docker-compose.yml)找到配置为Postgres的pact-broker的演示配置。通过执行`docker-compose
    up`命令配置后，可以在端口80或端口443上访问`pact` broker，具体取决于是否启用了SSL。'
- en: Revisiting testing key points
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视测试关键点
- en: 'Let''s recall our key points on testing before moving on to the next section
    in the book:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本书的下一部分之前，让我们回顾一下测试的关键点：
- en: The testing pyramid indicates the number of tests required for each kind of
    test. Tests at the top of the pyramid should be fewer in number than the level
    below them.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔表示每种测试所需的测试数量。金字塔顶部的测试数量应该比它们下面的级别少。
- en: Due to their broader scope, system-level tests are meant to be slow and imprecise.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其更广泛的范围，系统级测试应该是缓慢和不精确的。
- en: System-level tests should only be used to provide some test coverage for important
    business capabilities.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统级测试应该只用于为重要的业务功能提供一些测试覆盖。
- en: Service-level tests are faster and more precise then system-level tests, as
    they have to deal with a reduced scope.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务级测试比系统级测试更快，更精确，因为它们只需处理较小的范围。
- en: A practice should be followed to write service-level tests for success and important
    failure scenarios.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该遵循一种实践，即为成功和重要的失败场景编写服务级测试。
- en: Contract tests are important, as they verify the assumption one microservice
    makes about the API and behavior of another microservice.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同测试很重要，因为它们验证一个微服务对另一个微服务的API和行为的假设。
- en: Unit tests are meant to be fast and should be kept fast by only including a
    single unit or using the principle of single responsibility.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该快速，并且通过只包括一个单元或使用单一职责原则来保持快速。
- en: To have wider test coverage, always write service tests first and write unit
    tests later when it becomes unmanageable to write service tests.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了拥有更广泛的测试覆盖范围，总是先编写服务测试，当编写服务测试变得难以管理时再编写单元测试。
- en: We use Sinon, Ava, Chai, and Istanbul for testing our microservices.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Sinon，Ava，Chai和Istanbul来测试我们的微服务。
- en: 'To write service level tests:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要编写服务级测试：
- en: Write mocked endpoints of the microservice under test
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写被测试微服务的模拟端点
- en: Write scenarios that interact with the microservice
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写与微服务交互的场景
- en: Make assertions both on a response from the microservice and the requests it
    makes to collaborators
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对来自微服务的响应和它对协作者的请求进行断言
- en: By using Pact, you can write contract-level tests, thus avoiding integration
    tests.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Pact，您可以编写合同级别的测试，从而避免集成测试。
- en: Contract tests are very helpful as they make sure that a microservice adheres
    to its prefixed contracts and any sudden change in a service does not break any
    business capabilities.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同测试非常有帮助，因为它们确保微服务遵守其预先制定的合同，并且服务的任何突然变化都不会破坏任何业务功能。
- en: '**Advanced:** Sometimes you may need to try out snippets of code in a real-time
    environment, either to reproduce a problem or to try the code in a realistic environment.
    Telepresence ([http://telepresence.io/](http://telepresence.io/)) is a tool that
    allows you to swap out running code in Kubernetes.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级：** 有时您可能需要在实时环境中尝试代码片段，无论是为了重现问题还是在真实环境中尝试代码。Telepresence ([http://telepresence.io/](http://telepresence.io/))
    是一个工具，允许您在Kubernetes中交换运行的代码。'
- en: '**Advanced:** Ambassador ([https://www.getambassador.io/](https://www.getambassador.io/))
    is an API Gateway allowing microservices to easily register their public endpoints.
    It has a variety of options, such as statistics about traffic, monitoring, and
    so on.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级：** Ambassador ([https://www.getambassador.io/](https://www.getambassador.io/))
    是一个API网关，允许微服务轻松注册其公共端点。它有各种选项，例如有关流量的统计信息，监控等。'
- en: '**Advanced:** Hoverfly ([https://hoverfly.io/](https://hoverfly.io/)) is a
    way to achieve microservices virtualization. We can simulate latency and failures
    in APIs through it.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级：** Hoverfly ([https://hoverfly.io/](https://hoverfly.io/)) 是实现微服务虚拟化的一种方式。我们可以通过它模拟API中的延迟和故障。'
- en: After going through the testing process, it is now time to solve problems on
    the fly with debugging. We will learn about debugging and profiling microservices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 经过测试流程后，现在是时候通过调试解决问题了。我们将学习有关调试和分析微服务的内容。
- en: Debugging
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: 'Debugging is one of the most important aspects in the development of any system.
    Debugging, or the art of solving problems, is crucial in software development
    as it helps us to identify issues, profile the system, and identify the culprits
    responsible for taking down the system. There are some classic definitions of
    debugging:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是任何系统开发中最重要的方面之一。调试或解决问题的艺术在软件开发中至关重要，因为它帮助我们识别问题、对系统进行分析，并确定导致系统崩溃的罪魁祸首。有一些关于调试的经典定义：
- en: '"Debugging is like solving a murder mystery in which you are the murderer.
    If debugging is the process of removing bugs, then software development is the
    process of putting these bugs in it"'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: “调试就像解决一起谋杀案，而你是凶手。如果调试是消除错误的过程，那么软件开发就是将这些错误放入其中的过程”
- en: – Edsgar Dijkstra.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- Edsgar Dijkstra。'
- en: Debugging a TypeScript microservice is very similar to debugging any web application.
    Going for open source free alternatives, we will go for node-inspector, as it
    also provides very useful profiling tools.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 调试TypeScript微服务与调试任何Web应用程序非常相似。在选择开源免费替代方案时，我们将选择node-inspector，因为它还提供非常有用的分析工具。
- en: We already saw debugging through VS Code in [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第2章《为旅程做准备》中通过VS Code进行了调试。
- en: In the next section, we will learn how to profile and debug our application
    using node-inspector. We will look at various aspects of remote debugging and
    how to build a proxy in between a service to debug our microservices. So, let's
    get started.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用node-inspector对我们的应用程序进行分析和调试。我们将看看远程调试的各个方面，以及如何构建一个代理来调试我们的微服务。所以，让我们开始吧。
- en: Building a proxy in between to debug our microservices
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个代理来调试我们的微服务
- en: 'Microservices are distributed based on business capabilities. From the end-user
    they may seem a single functionality say for instance: buying a product, but behind
    the scenes, there are many microservices involved, such as the payment service,
    add to cart service, shipping service, inventory service, and so on. Now, all
    of these services should not reside inside a single server. They are spread and
    distributed as per design and infrastructure. Scenarios occur where two servers
    collaborate with each other and bad behavior may occur at any level if these services
    are not monitored. It is a very common problem in microservices, which we are
    going to solve using `http-proxy` and tunneling. We are going to create a very
    simple example that will log the raw headers of any request. This information
    can give us valuable information about what is actually going on in the network.
    This concept is very similar to what we used in the API Gateway. Normally, the
    API Gateway is a proxy for all requests; it queries the service registry to dynamically
    fetch the location of a microservice. This proxy layer, our gateway, has various
    advantages, which we saw in [Chapter 5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml), *Understanding
    API Gateway*. We will be using the node module `http-proxy` ([https://www.npmjs.com/package/http-proxy](https://www.npmjs.com/package/http-proxy))
    and log the request headers there. Initialize one Node.js project, add the `src`, `dist`,
    and `tsconfig.json` folders, and add the `http-proxy` module and its typings.
    Then, enter the following code in index.ts to create a proxy server. The full
    code can be found under the extracted source at `Chapter 8/ts-http-proxy`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是基于业务能力分布的。对于最终用户来说，它们可能看起来像是单一功能，比如购买产品，但在幕后，涉及到许多微服务，比如支付服务、加入购物车服务、运输服务、库存服务等等。现在，所有这些服务不应该驻留在单个服务器内。它们根据设计和基础设施进行分布和分发。在某些情况下，两个服务器会相互协作，如果这些服务没有受到监控，就可能在任何级别出现不良行为。这是微服务中一个非常常见的问题，我们将使用`http-proxy`和隧道来解决。我们将创建一个非常简单的示例，记录任何请求的原始标头。这些信息可以为我们提供有关网络实际发生了什么的宝贵信息。这个概念与我们在API网关中使用的非常相似。通常，API网关是所有请求的代理；它查询服务注册表动态获取微服务的位置。这个代理层，我们的网关，有各种优势，我们在第5章《理解API网关》中看到了。我们将使用node模块`http-proxy`（[https://www.npmjs.com/package/http-proxy](https://www.npmjs.com/package/http-proxy)）并在那里记录请求标头。初始化一个Node.js项目，添加`src`、`dist`和`tsconfig.json`文件夹，添加`http-proxy`模块及其类型。然后，在index.ts中输入以下代码以创建代理服务器。完整的代码可以在提取的源代码中找到，位于`第8章/ts-http-proxy`下：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, when you hit `localhost:4000`, it will print all the raw headers, which
    you can check in the source code and see the response of the service.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当您访问`localhost:4000`时，它将打印所有原始标头，您可以在源代码中检查并查看服务的响应。
- en: In the next section, we will have a look at the Chrome debugging extension and
    profiling tools.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看Chrome调试扩展和分析工具。
- en: Profiling process
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析过程
- en: Profiling is a key process these days when it comes to analyzing a service for
    performance. There are native tools available for Node.js that can profile any
    running V8 process. These are just snapshots with effective summaries that include
    statistics on how V8 treats the process when compiling, and the actions and decisions
    it makes while optimizing the hot code it ran against the V8 engine.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析服务性能方面，分析是一个关键过程。Node.js有一些原生工具可以对任何正在运行的V8进程进行分析。这些只是包含有关V8处理过程的统计信息的有效摘要的快照，以及V8在编译时如何处理该过程以及在优化运行热代码时所做的操作和决策。
- en: We can have a v8 log generated in any process simply by passing the `--prof` flag. `prof` stands
    for a profile. An example is `node --prof index.js`. That won't be much of a readable
    format. To create a more readable format, run the `node --prof-process <v8.logfilename>.log
    >` command's profile.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递`--prof`标志在任何进程中生成v8日志。`prof`代表配置文件。例如`node --prof index.js`。那不会是一个可读的格式。要创建一个更可读的格式，运行`node
    --prof-process <v8.logfilename>.log >`命令的配置文件。
- en: In this section, we will look at how to profile using profile logs, take heap
    snapshots, and utilize Chrome's CPU profiling for microservices. So, let's get
    started. You can process the logs of any file using `node --prof <file_name>.js`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用配置文件日志进行分析、获取堆快照，并利用Chrome的CPU分析来进行微服务。所以，让我们开始吧。您可以使用`node --prof
    <file_name>.js`处理任何文件的日志。
- en: Dumping heap
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转储堆
- en: 'A heap is a huge memory allocation. When we talk about our case, it is the
    memory allocated to the V8 process (time to recall how Node.js works—the Event
    Loop and the memory allocation).  By checking the memory usage, you can track
    down things such as memory leaks or just check which part of the service has the
    most consumption, based on which you can adjust the code accordingly. We have
    a very fine `npm` module ([https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump)),
    which take a dump that can be used later for inspection. Let''s get familiar with
    reading the dump process and when to take a dump, though the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一个巨大的内存分配。当我们谈论我们的情况时，它是分配给V8进程的内存（回想一下Node.js的工作原理-事件循环和内存分配）。通过检查内存使用情况，您可以跟踪诸如内存泄漏之类的问题，或者只是检查服务的哪个部分消耗最多，根据这一点，您可以相应地调整代码。我们有一个非常好的`npm`模块（[https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump)），它可以生成一个稍后用于检查的转储。让我们熟悉读取转储过程以及何时进行转储，尽管以下步骤：
- en: 'We install Heap Dump and create a dump ready to be used. Open up any project,
    and install the `heapdump` module with:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们安装Heap Dump并创建一个准备好使用的转储。打开任何项目，并使用以下命令安装`heapdump`模块：
- en: '[PRE9]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, copy the following lines of code in any process where you want to create
    the snapshot. I have kept them in `Application.ts` just as an example. You can
    follow the code in `chapter8/heapdump_demo`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码行复制到您想要创建快照的任何进程中。我将它们保留在`Application.ts`中，只是一个例子。您可以在`chapter8/heapdump_demo`中遵循代码：
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, when you run the program, you can find the snapshot in the directory from
    which we ran the preceding lines of code. You will find output like dump written
    to `/home/parth/chapter 8/heapdump_demo/../<timestamp>.heapsnapshot`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您运行程序时，您可以在我们运行前面的代码行的目录中找到快照。您将找到类似于转储写入到`/home/parth/chapter 8/heapdump_demo/../<timestamp>.heapsnapshot`的输出。
- en: 'We must have something like `<current_date_in_millis>.heapsnapshot`. It will
    be in a non-readable format, but that''s where we will be utilizing Chrome''s
    DevTools. Open Chrome DevTools and go to the Memory | Select profiling type | Load option.
    Open the snapshot file and you will be able to see the following screenshot:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有类似`<current_date_in_millis>.heapsnapshot`的东西。它将以不可读的格式存在，但这就是我们将利用Chrome的DevTools的地方。打开Chrome
    DevTools并转到Memory | Select profiling type | Load选项。打开快照文件，您将能够看到以下屏幕截图：
- en: '![](img/ac3665aa-d69e-495b-a3dc-822e9b8f0d74.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac3665aa-d69e-495b-a3dc-822e9b8f0d74.png)'
- en: 'Click on Statistics and you will be able to see this:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Statistics，您将能够看到这个：
- en: '![](img/dcca964f-77ed-4cb6-9560-a07abd7b8b84.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcca964f-77ed-4cb6-9560-a07abd7b8b84.png)'
- en: 'You can go through the following links to get in-depth knowledge about profiling:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接深入了解性能分析：
- en: '[https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101](https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101)[h](https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101](https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101)[h](https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/)'
- en: '[ttps://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/](https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ttps://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/](https://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/)'
- en: We can periodically take dumps or take dumps in the event of errors, which would
    be very helpful in order to find the issue in a microservice. Next, we will see
    how to do CPU profiling.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定期进行转储，或者在发生错误时进行转储，这将有助于找到微服务中的问题。接下来，我们将看看如何进行CPU分析。
- en: CPU profiling
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU分析
- en: 'Chrome Developer Tools has some very nice options that are not just limited
    to debugging. We can also leverage memory allocation, CPU profiling, and so on.
    Let''s dig deep into CPU profiling. For the sake of understanding the tool, we
    will spin up a program that consumes heavy CPU usage:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具有一些非常好的选项，不仅限于调试。我们还可以利用内存分配、CPU分析等。让我们深入研究CPU分析。为了理解工具，我们将启动一个消耗大量CPU的程序：
- en: 'Create any express app and create one random route, which basically iterates
    100 times and allocates a buffer 10⁸ in the memory. You can follow the code in `chapter
    8/cpu-profiling-demo`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建任何express应用程序并创建一个随机路由，基本上迭代100次并在内存中分配10⁸的缓冲区。您可以在`chapter 8/cpu-profiling-demo`中遵循代码：
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next step is to run the Node.js process in Chrome DevTools. To do so, just
    add the `--inspect` flag in `node --inspect ./dist/bin/www.js`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在Chrome DevTools中运行Node.js进程。要这样做，只需在`node --inspect ./dist/bin/www.js`中添加`--inspect`标志。
- en: The Chrome debugging protocol is included in the Node.js core module and we
    do not need to include it in every project.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome调试协议包含在Node.js核心模块中，我们不需要在每个项目中都包含它。
- en: Open `chrome://inspect` and we will be able to see our process under it. Click
    on inspect and we are ready to debug the Node.js application just like a standard
    web application.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`chrome://inspect`，我们将能够在其中看到我们的进程。单击inspect，我们就可以像标准Web应用程序一样调试Node.js应用程序。
- en: 'Click on Profiler, which is where we will debug the CPU behavior. Click on Start,
    open any tab, and hit `localhost:3000/check-mem`. Come back to our tab. Click
    on Stop when you are able to see I am done. You should be able to see something
    like this like in the figure profiling and profiling detail:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Profiler，这是我们将调试CPU行为的地方。单击Start，打开任何选项卡，然后点击`localhost:3000/check-mem`。回到我们的选项卡。当您能够看到I
    am done时，单击Stop。您应该能够看到类似于图中的分析和分析详细信息：
- en: '![](img/628ae1c9-2bd5-432a-aa8e-2bbcf22065b9.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/628ae1c9-2bd5-432a-aa8e-2bbcf22065b9.jpg)'
- en: Profiling
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析
- en: 'Now, hover over a single row and you will be able to see a detailed view like
    this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将鼠标悬停在单行上，您将能够看到这样的详细视图：
- en: '![](img/afa6e1d0-7a44-4b3b-a4fa-e3d20b84da25.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afa6e1d0-7a44-4b3b-a4fa-e3d20b84da25.png)'
- en: Profiling detail
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 分析细节
- en: Live Debugging/Remote Debugging
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时调试/远程调试
- en: 'The penultimate and important feature is to debug a problem live. With the
    introduction of the inspector protocol inside Node.js, this becomes a piece of cake as
    all we have to do is create an `--inspect` version of running the process. This
    will print the URL of the process on which debug is open, something like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二个重要功能是实时调试问题。随着Node.js内部引入检查器协议，这变得非常容易，因为我们所要做的就是创建一个运行进程的`--inspect`版本。这将打印出调试打开的进程的URL，类似于这样：
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can install the Chrome extension Node.js V8 --inspector Manager (NiM),
    from [https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj) for
    debugging remote applications or you can even spawn a process for debugging and
    specify a port with:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安装Chrome扩展程序Node.js V8 --inspector Manager (NiM)，从[https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj)用于调试远程应用程序，或者您甚至可以生成一个用于调试的进程并指定一个端口。
- en: '[PRE13]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can find other options here: [https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options](https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options).
    When any process is started with the `--inspect` switch, Node.js listens to it
    via sockets for diagnostics commands uniquely identified by the host and the port.
    Each process is assigned a unique UUID for tracking. Node-Inspector also provides
    an HTTP endpoint to serve metadata about debugger, including its WebSocket URL,
    UUID, and Chrome DevTools URL. We can get this information by hitting `<host:port>/json/list`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到其他选项：[https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options](https://nodejs.org/en/docs/guides/debugging-getting-started/#command-line-options)。当使用`--inspect`开关启动任何进程时，Node.js通过套接字侦听它，以诊断命令唯一地标识主机和端口。每个进程都被分配一个唯一的UUID以进行跟踪。Node-Inspector还提供了一个HTTP端点来提供有关调试器的元数据，包括其WebSocket
    URL、UUID和Chrome DevTools URL。我们可以通过访问`<host:port>/json/list`来获取这些信息。
- en: 'Debugging is great, but we should make sure that it does not come with a side
    effect. Debugging means opening up a port, which will have security implications.
    The following points should be taken care of with utmost precautions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 调试很棒，但我们应该确保它不会带来副作用。调试意味着打开一个端口，这将带来安全隐患。应该特别注意以下几点：
- en: Exposing the debug port publicly is not safe
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开暴露调试端口是不安全的
- en: Local applications running inside have full access to the application inspector
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部运行的本地应用程序可以完全访问应用程序检查器
- en: The same origin policy should be maintained
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该保持同源策略
- en: This concludes our debugging and profiling session. In the next section, we
    will revisit key points before moving on to documenting.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们的调试和分析会话。在下一节中，我们将重新讨论关键点，然后转向文档编制。
- en: Key points for debugging
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试的关键点
- en: 'In this section, we saw debugging and core aspects involved in profiling. We
    learned how to diagnose a leak or observe heap dump memory to analyze a service
    request. We saw how a proxy can often help, even if it increases a network hop:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了调试和与分析相关的核心方面。我们学习了如何诊断泄漏或观察堆转储内存以分析服务请求。我们看到了代理通常可以帮助，即使它增加了网络跳数：
- en: To avoid overloading, we have a module providing as in, code `503` middleware.
    Refer to [https://github.com/davidmarkclements/overload-protection](https://github.com/davidmarkclements/overload-protection) for
    implementation details.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免过载，我们有一个提供`503`中间件的模块。有关实现细节，请参阅[https://github.com/davidmarkclements/overload-protection](https://github.com/davidmarkclements/overload-protection)。
- en: Chrome Inspector is a very useful tool for debugging Node.js microservices,
    as it not only provides a debugging interface, but also heap snapshots and CPU
    profiling.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome Inspector是调试Node.js微服务的非常有用的工具，因为它不仅提供了调试界面，还提供了堆快照和CPU分析。
- en: VS Code is also a very user-friendly tool.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code也是一个非常用户友好的工具。
- en: Node.js embraced node-inspector and included it in the core module, thus making
    remote debugging very easy.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js拥抱了node-inspector并将其包含在核心模块中，从而使远程调试变得非常容易。
- en: 'Now that we know the fundamental aspects of debugging, let''s move on to the
    final part of making a developer''s life easy. Yes, you guessed it correct: proper
    documentation, which always saves the day not just for the technical team but
    also non-technical persons.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了调试的基本方面，让我们继续进行开发人员生活的最后一部分。是的，你猜对了：适当的文档，这不仅为技术团队节省了一天，也为非技术人员节省了一天。
- en: Documenting
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档编制
- en: '**Documenting** is a contract between the backend and the frontend that takes
    care of dependency management between the two sides. If the API changes, the document
    needs to adapt to it quickly. One of the easiest fails in development can be the
    lack of visibility or lack of awareness about other people''s work. Often, the
    traditional approach is to write service specification documents or use some static
    service registries that maintain different things. No matter how hard we try,
    documentation always goes out of date.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档**是后端和前端之间的一种约定，它负责管理两侧之间的依赖关系。如果API发生变化，文档需要快速适应。开发中最容易出错的之一就是缺乏对其他人工作的可见性或意识。通常，传统的方法是编写服务规范文档或使用一些静态服务注册表来维护不同的内容。无论我们如何努力，文档总是过时的。'
- en: Need of Documentation
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要文档
- en: 'Documentation of development and organizational understanding of the system
    increases developers, skill and speed while dealing with two of the most common
    challenges that come with microservice adoption—technical and organizational change.
    The importance of thorough, updated documentation cannot be underestimated. Whenever
    we ask someone about problems they face while doing anything new, the answer is
    the same. We all face the same issue: we don''t know how this thing works, it''s
    a new black box and the documentation given is worthless.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 开发文档和组织对系统的理解增加了开发人员的技能和速度，同时处理微服务采用中出现的两个最常见的挑战——技术和组织变革。彻底、更新的文档的重要性不容小觑。每当我们问别人在做任何新事物时面临的问题时，答案总是一样。我们都面临同样的问题：我们不知道这个东西是如何工作的，它是一个新的黑匣子，给出的文档毫无价值。
- en: Poor documentation of dependencies or internal tools makes developer's lives
    a nightmare and slows down their ability and the production readiness of a service.
    It wastes countless hours because the only way that remains is re-engineering
    the system until we have the resolution. Edison did indeed say, *I have found
    2000 ways of how not to make the light bulb,* but I would like to spend my time
    rather on 2000 ways to get more out of me. Poor documentation of a service also
    hurts the productivity of the developers who are contributing to it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项或内部工具的文档不完善会使开发人员的生活变成一场噩梦，并减慢他们的能力和服务的生产就绪性。这浪费了无数的时间，因为唯一剩下的方法是重新设计系统，直到我们找到解决方案。爱迪生确实说过，“我找到了2000种不制造灯泡的方法”，但我更愿意把时间花在找到让自己更出色的2000种方法上。服务的文档不完善也会影响到为其做出贡献的开发人员的生产力。
- en: 'The goal of production-ready documentation is to make and organize a centralized
    repository of knowledge about the service. Sharing this piece of information has
    two aspects: the fundamental parts of the service and where the service contributes
    to achieving what piece of functionality.  Solving these two problems requires
    standardizing a documentation approach to sharing microservice understanding.
    We can summarize the following documentation points:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 生产就绪文档的目标是制作和组织关于服务的知识的集中存储库。分享这些信息有两个方面：服务的基本部分以及服务对实现哪一部分功能的贡献。解决这两个问题需要标准化共享微服务理解的文档方法。我们可以总结以下文档要点：
- en: Any service should have comprehensive and detailed documentation (should include
    what the service is and to what it is contributing)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何服务都应该有全面和详细的文档（应该包括服务是什么以及它对什么做出了贡献）
- en: Documentation should be updated regularly (all the new methods and maintained
    version)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档应该定期更新（所有新方法和维护的版本）
- en: It should be understood by all and not just the technical team
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有人都应该理解，而不仅仅是技术团队
- en: Its architecture is reviewed and audited every fixed interval of time
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其架构每隔一段固定的时间进行审查和审核
- en: When approaching microservices, the pain increases exponentially as we divide
    each business capability into a different service. We need a more generic approach
    to documenting microservices. Swagger is currently the forerunner in documentation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在接近微服务时，随着我们将每个业务能力划分为不同的服务，痛苦呈指数级增加。我们需要一种更通用的方法来记录微服务。Swagger目前是文档的领先者。
- en: 'With Swagger, you will get the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Swagger，您将得到以下内容：
- en: No inconsistent API descriptions anymore. These will be updated with complete
    contract details and parameter information.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再有不一致的API描述。这些将被更新为完整的合同细节和参数信息。
- en: You won't need to write any more documentation; it will be auto-generated.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将不再需要编写任何文档；它将自动生成。
- en: And, of course, there will be no more arguments regarding poor documentation.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，再也不会有关于文档不完善的争论了。
- en: This section will explore how to use Swagger, understand its core tools, its
    advantages, and working implementations. So, let's get started.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨如何使用Swagger，了解其核心工具、优势和工作实现。所以，让我们开始吧。
- en: Swagger 101
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger 101
- en: Swagger is a powerful representation of your microservices or, in fact, any
    RESTful API. Thousands of developers are supporting Swagger in almost every programming
    language and environment. With a Swagger-enabled environment, we get interactive
    documentation, client SDK generation, discoverability, and testing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是您的微服务或者任何RESTful API的强大表示。成千上万的开发人员支持Swagger几乎在每一种编程语言和环境中。有了Swagger-enabled环境，我们可以得到交互式文档、客户端SDK生成、可发现性和测试。
- en: 'Swagger is a part of the Open API Initiative (a committee standardizing how
    REST APIs should be described). It provides a set of tools to describe and document
    a RESTful API.  Swagger, which began as an API documentation tool, can now also
    generate boilerplate code via **Swagger Codegen** ([https://github.com/wcandillon/swagger-js-codegen](https://github.com/wcandillon/swagger-js-codegen)).
    Swagger has a large ecosystem of tools, but primarily we will be using the following
    set of tools. We will understand how to integrate Swagger with an existing application
    or write an API specific to Swagger standards, through which our documentation
    will be auto-generated. The overall process involved can be understood from the
    following diagram:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是Open API倡议的一部分（一个标准化REST API应该如何描述的委员会）。它提供了一组工具来描述和记录RESTful API。Swagger最初是一个API文档工具，现在还可以通过Swagger
    Codegen（https://github.com/wcandillon/swagger-js-codegen）生成样板代码。Swagger有一个庞大的工具生态系统，但主要我们将使用以下一组工具。我们将了解如何将Swagger与现有应用程序集成，或者编写符合Swagger标准的API，通过这些API我们的文档将自动生成。从以下图表中可以了解到涉及的整个过程：
- en: '![](img/ef59d39a-761c-4b99-90c2-6d431f32d76f.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef59d39a-761c-4b99-90c2-6d431f32d76f.png)'
- en: Swagger_workflow
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger_workflow
- en: Let us now look at the overall tools involved in the process to get a thorough
    understanding of all the aspects involved in it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下涉及过程的整体工具，以便全面了解其中涉及的所有方面。
- en: Swagger Editor and Descriptor
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger编辑器和描述符
- en: Swagger Descriptor takes a page from design-driven development. Here, we design
    our endpoints' behavior by describing them in a YML/YAML file or a JSON file.
    (Of course, as a developer I am too lazy to even write this file and I would prefer
    this to be autogenerated, which we will look at in a further section.) This is
    the most important section as it is the contextual information about the service.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger Descriptor采用了设计驱动开发的方法。在这里，我们通过在YML/YAML文件或JSON文件中描述它们来设计我们端点的行为。（当然，作为开发人员，我甚至懒得写这个文件，我更希望它是自动生成的，我们将在后面的部分中看到。）这是最重要的部分，因为它是有关服务的上下文信息。
- en: Check out `Chapter 8/hello_world_swagger.yaml` to get an idea of the descriptor
    file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`第8章/hello_world_swagger.yaml`以了解描述文件的内容。
- en: Key points for Swagger  and Descriptor
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger和描述符的关键点
- en: Your URL route, parameter, and description is defined inside the `.yaml` file.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的URL路由、参数和描述都在`.yaml`文件中定义。
- en: Whether a parameter is required or not, you can pass using the required true,
    which will validate that parameter while testing it out
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论参数是否必需，您都可以使用required true进行传递，这将在测试参数时进行验证
- en: It can also return response codes and their descriptions
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还可以返回响应代码及其描述
- en: Swagger reads this `.yaml` file to generate its Swagger UI and test services
    using the Swagger inspector
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger读取这个`.yaml`文件来生成其Swagger UI并使用Swagger检查器测试服务
- en: Swagger Editor
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger Editor
- en: Swagger Editor is an online tool that helps y
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger Editor是一个在线工具，可以帮助您
- en: ou to edit Swagger API specifications in your browser by previewing the documentation
    in real time as per Swagger API specifications. This way, we can see how the documentation
    will look after applying the most recent changes on the fly. The editor has a
    clean interface and is easy to use with lots of features to design and document
    various microservices. It is available online at [https://editor2.swagger.io/#!/](https://editor2.swagger.io/#!/).
    By just writing or importing a `swagger.yaml` file, we can view the Swagger UI
    in real time.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在浏览器中预览实时文档来编辑Swagger API规范。这样，我们可以看到应用最新更改后文档的实际外观。编辑器具有清晰的界面，易于使用，并具有许多功能，可设计和记录各种微服务。它可以在线访问：[https://editor2.swagger.io/#!/](https://editor2.swagger.io/#!/)。只需编写或导入一个`swagger.yaml`文件，我们就可以实时查看Swagger
    UI。
- en: 'Let''s get our hands dirty with Swagger Editor and Swagger Descriptor:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过Swagger Editor和Swagger Descriptor动手：
- en: Open up [https://editor2.swagger.io](https://editor2.swagger.io) and enter our
    previous descriptor (`hello_world_swagger.yaml`).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开[https://editor2.swagger.io](https://editor2.swagger.io)，并输入我们之前的描述符（`hello_world_swagger.yaml`）。
- en: 'You will be able to see live documentation on the right side:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将能够在右侧看到实时文档：
- en: '![](img/fcdb4dcf-b65d-45f6-bdd2-7d48398895c4.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcdb4dcf-b65d-45f6-bdd2-7d48398895c4.png)'
- en: Swagger Editor
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger Editor
- en: Try inserting more code in the descriptor file and check out the interactive
    documentation. Also, try running Try this operation. It will give a description
    of the HTTP request along with all the headers and responses.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在描述符文件中插入更多代码，并查看交互式文档。另外，尝试运行“尝试此操作”。它将提供HTTP请求的描述以及所有标头和响应。
- en: Swagger Codegen
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger Codegen
- en: Swagger Codegen is a scaffolding engine that gives us the option to generate
    interactive documentation, API clients, and server stubs from Swagger definitions.
    The previous options that we saw in Swagger Editor (generating a server and generating
    a client) resemble the implementation of Swagger Codegen. It has support for a
    lot of languages.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger Codegen是一个脚手架引擎，它可以根据Swagger定义生成交互式文档、API客户端和服务器存根。我们在Swagger Editor中看到的以前的选项（生成服务器和生成客户端）类似于Swagger
    Codegen的实现。它支持许多语言。
- en: Client-side scaffolding tool that includes support for languages such as TypeScript
    Angular, TypeScript Node, JavaScript, Python, HTML, Java, and C#. Server-side
    scaffolding tool supports languages such as Haskell, Node.js, Go language, and
    Spring.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端脚手架工具，支持TypeScript Angular、TypeScript Node、JavaScript、Python、HTML、Java和C#等语言。服务器端脚手架工具支持Haskell、Node.js、Go语言和Spring等语言。
- en: '**Swagger CodeGen** ([https://swagger.io/swagger-codegen/](https://swagger.io/swagger-codegen/))
    helps us to build APIs quicker and improve the quality by adhering to OpenAPI-defined
    specifications. It generates server stubs and client SDKs so we can rather focus
    on API implementation and business logic rather than code creation and adopt standards:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swagger CodeGen** ([https://swagger.io/swagger-codegen/](https://swagger.io/swagger-codegen/))帮助我们更快地构建API，并通过遵循OpenAPI定义的规范来提高质量。它生成服务器存根和客户端SDK，因此我们可以更专注于API实现和业务逻辑，而不是代码创建和采用标准：'
- en: '**Advantages of Swagger CodeGen**:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger CodeGen的优势**：'
- en: It generates server code, client code, and documentation
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它生成服务器代码、客户端代码和文档
- en: It allows for faster changes of API
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许更快地更改API
- en: The code generated is open source
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的代码是开源的
- en: '**Disadvantages of Swagger CodeGen**:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger CodeGen的缺点**：'
- en: There is an increase in project complexity by adding extra tools and libraries
    and the added complexity of managing those
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加额外的工具和库以及管理这些工具的复杂性，项目复杂性增加了
- en: It can generate a lot of code that the user might not be able to digest
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会生成用户无法消化的大量代码
- en: You can check `Chapter 8/typescript-node-client/api.ts` to see the auto generated
    code based on our initial Swagger descriptor definition.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看`第8章/typescript-node-client/api.ts`，以查看基于我们最初的Swagger描述符定义生成的自动生成代码。
- en: Swagger UI
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger UI
- en: The Swagger UI allows us to visualize a RESTful API. Visualizations are automatically
    generated from Swagger specifications. The Swagger UI takes in a Swagger descriptor
    file and creates documentation with the Swagger inspector in the UI. The Swagger
    UI is what we saw in the preceding screenshot on the right-hand side. Furthermore,
    this can be given access based on privileges. The Swagger UI is a collection of
    HTML, JavaScript, andCSS assets that dynamically generate beautiful documentation
    from a Swagger-compliant API.  We will generate documentation for our product
    catalog microservice and use Swagger UI components in it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI允许我们可视化RESTful API。可视化是从Swagger规范自动生成的。Swagger UI接收Swagger描述文件并在UI中使用Swagger检查器创建文档。Swagger
    UI就是我们在前面截图中右侧看到的内容。此外，这可以根据权限进行访问。Swagger UI是一组HTML、JavaScript和CSS资源，可以从符合Swagger的API动态生成美丽的文档。我们将为我们的产品目录微服务生成文档，并在其中使用Swagger
    UI组件。
- en: Swagger Inspector
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger检查器
- en: 'This is a pain-free way to generate documentation based on the OpenAPI specification.
    Once you have checked SWAGGER inspector with its working, then you can create
    documentation and share it with the world. We can easily autogenerate documentation
    by selecting the previously tested endpoints from the history and then issuing
    the command for CREATE API DEFINITION. It is much like Postman on the web. You
    can download Swagger inspector as a Chrome extension. It has these options:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种基于OpenAPI规范生成文档的无痛方式。一旦您检查了SWAGGER检查器的工作原理，然后您可以创建文档并与世界分享。我们可以通过选择历史记录中先前测试过的端点来轻松自动生成文档，然后发出创建API定义的命令。这在网上很像Postman。您可以将Swagger检查器作为Chrome扩展程序下载。它具有以下选项：
- en: '![](img/3a7c8ecd-ebe5-47a5-a01b-327fe63702dc.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a7c8ecd-ebe5-47a5-a01b-327fe63702dc.png)'
- en: Swagger inspector
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger检查器
- en: Now that we got ourself acquainted with Swagger, let's look at how to use Swagger
    in our microservices to generate beautiful documentation for us. The next section
    talks about possible approaches in which we can integrate swagger.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Swagger，让我们看看如何在微服务中使用Swagger为我们生成美丽的文档。接下来的部分讨论了我们可以集成Swagger的可能方法。
- en: Possible strategies to use Swagger
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swagger的可能策略
- en: 'Swagger is mostly used for documenting services and testing services out. There
    are two fundamental approaches in implementing Swagger. They are as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger主要用于记录服务和测试服务。在实施Swagger时有两种基本方法。它们如下：
- en: '**Top-down or design-first approach: **Here, Swagger Editor is used to create
    Swagger definitions and then Swagger Code-gen is used to generate code for the
    client as well as the server. Swagger will be used to design the API and source
    before any of the code has been written.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自上而下或设计优先方法：**在这里，使用Swagger编辑器创建Swagger定义，然后使用Swagger Code-gen生成客户端和服务器的代码。在编写任何代码之前，Swagger将用于设计API和源。'
- en: '**Bottom-up approach: **Here, for any of the existing APIs, Swagger is used
    to generate documentation.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自下而上方法：**在这里，对于任何现有的API，Swagger用于生成文档。'
- en: We will look at both of the approaches along with the best practices available
    for us.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将研究这两种方法以及我们可以使用的最佳实践。 '
- en: Top-down or design-first Approach
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自上而下或设计优先方法
- en: 'Often, generating a valid Swagger file and documentation via just adding a
    few lines of code seems like a good idea. We have written all the code and then we remember:
    *Oh my goodness, how will I explain this to others? Will I need to document each
    and every API?* On the fly generation of documentation at such time simply by
    adding an annotation seems to be a dream come true in such situations.   TSOA ([https://www.npmjs.com/package/tsoa](https://www.npmjs.com/package/tsoa))
    is designed on such a principle. Based on TSOA README file, it generates a valid
    Swagger spec from a written controller and models that include the following.
    This essentially is a bottom-up approach where we already have an existing REST
    API and we leverage Swagger to document the existing API.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过添加几行代码来生成有效的Swagger文件和文档似乎是一个好主意。我们已经编写了所有的代码，然后我们记得：*天哪，我要如何向其他人解释这个？我需要记录每一个API吗？*在这种情况下，通过添加注释来实时生成文档似乎是一个梦想成真。TSOA（[https://www.npmjs.com/package/tsoa](https://www.npmjs.com/package/tsoa)）就是基于这样的原则设计的。根据TSOA的README文件，它从编写的控制器和包括以下内容的模型生成有效的Swagger规范。这本质上是一种自下而上的方法，我们已经有了现有的REST
    API，并且利用Swagger来记录现有的API。
- en: 'TSOA generates a valid Swagger `spec` file from controllers and models that
    include:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: TSOA从控制器和模型生成有效的Swagger `spec`文件，其中包括：
- en: 'Paths to various REST URLs (example: `Get users :- server_host/users/get_users`)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种REST URL的路径（例如：`获取用户：- server_host/users/get_users`）
- en: Definitions based on TypeScript interfaces (these are the model files or attribute
    descriptors)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于TypeScript接口的定义（这些是模型文件或属性描述符）
- en: 'Parameters types; that is, model properties are marked as required or optionally
    based on TypeScript syntax (for example, `productDescription?: string` is marked
    as optional in the Swagger specs)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参数类型；也就是说，根据TypeScript语法，模型属性标记为必需或可选（例如，`productDescription?: string`在Swagger规范中标记为可选）'
- en: jsDoc support for object descriptions (most other metadata can be inferred from
    TypeScript types)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jsDoc支持对象描述（大多数其他元数据可以从TypeScript类型中推断出）
- en: Like routing-controllers, routes are generated for any middleware of our choice.
    Options include Express, Hapi, and Koa. Similar to routing-controllers, TSOA has
    a class validator inbuilt. TSOA minimizes boilerplate code as much as possible
    and it has plenty of annotations available. You can check the documentation in
    `npm` for a detailed understanding of the various options available. We will be
    mainly concerned with the `@Route` annotation, which will generate the Swagger
    doc for us. In the example, we will use TSOA and generate the documentation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 与routing-controllers类似，路由可以为我们选择的任何中间件生成。选项包括Express、Hapi和Koa。与routing-controllers类似，TSOA内置了类验证器。TSOA尽可能地减少样板代码，并提供了大量的注释。您可以在`npm`中查看文档，以详细了解各种可用的选项。我们主要关注`@Route`注释，它将为我们生成Swagger文档。在示例中，我们将使用TSOA并生成文档。
- en: Please see extracted source for top-down approach, the example is pretty straight
    forward strictly adhering to the documentation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅自上而下方法的提取源，示例非常简单，严格遵循文档。
- en: Bottom-up approach
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自下而上的方法
- en: Wow! After going through a top-down approach, it seems like the perfect plan.
    But what about when we have already developed the project and now we want to generate
    our documentation. We are left in a conundrum. What should we do? Luckily, we
    have just the solution. We will leverage `swagger-ui-express` ([https://www.npmjs.com/package/swagger-ui-express](https://www.npmjs.com/package/swagger-ui-express))
    to generate the documentation. It has more than 45,000 downloads a week. It is
    a community-driven package that enables a middleware for your express application,
    which serves the Swagger UI based on the Swagger documentation file. We will need
    to add one route, which will host the Swagger UI. Documentation is good and everything
    is there—whatever we need. So, let's get started. You can follow along with the
    source code in the `Chapter 8/bottom-up-swagger` folder.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！经过自上而下的方法，似乎是完美的计划。但是当我们已经开发了项目，现在我们想要生成我们的文档时怎么办呢？我们陷入了困境。我们该怎么办呢？幸运的是，我们有解决方案。我们将利用`swagger-ui-express`
    ([https://www.npmjs.com/package/swagger-ui-express](https://www.npmjs.com/package/swagger-ui-express))来生成文档。它每周有超过45,000次下载。这是一个由社区驱动的包，为您的express应用程序提供中间件，根据Swagger文档文件提供Swagger
    UI。我们需要添加一个路由，用于托管Swagger UI。文档很好，一切都在那里——我们需要的一切。所以，让我们开始吧。您可以在`Chapter 8/bottom-up-swagger`文件夹中跟随源代码。
- en: 'Install the module from `npm` as a dependency:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`npm`中安装模块作为依赖项：
- en: '[PRE14]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we will need to add a route, which will host the Swagger UI. We need to
    generate the Swagger definition and update it on each deployment.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个路由，用于托管Swagger UI。我们需要生成Swagger定义，并在每次部署时更新它。
- en: We have two options to generate the Swagger documentation. Either we add comments
    in each of our route handlers or we use the Swagger inspector to test all the
    REST APIs, club those, and generate a definition file.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有两种选项来生成Swagger文档。要么我们在每个路由处理程序中添加注释，要么我们使用Swagger inspector来测试所有REST API，将它们合并，并生成一个定义文件。
- en: 'Whatever route we go for, our objective remains the same: to generate the `swagger.json`
    file. Going with the first approach, we will use `swagger-jsdoc` ([https://www.npmjs.com/package/swagger-jsdoc](https://www.npmjs.com/package/swagger-jsdoc)).
    Download the module as a dependency with:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论我们选择哪种路线，我们的目标都是相同的：生成`swagger.json`文件。采用第一种方法，我们将使用`swagger-jsdoc` ([https://www.npmjs.com/package/swagger-jsdoc](https://www.npmjs.com/package/swagger-jsdoc))。通过以下命令将模块作为依赖项下载：
- en: '[PRE15]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s get started with our configuration. First of all, we need to initialize
    Swagger JS Doc on Express startup. Create one class, `SwaggerSpec`, and inside
    it add the following code:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始配置。首先，我们需要在Express启动时初始化Swagger JS Doc。创建一个类`SwaggerSpec`，并在其中添加以下代码：
- en: '[PRE16]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we initialized the JSDoc and stored the `swagger.json` inside variable
    private static `swaggerJSON:any` so it can be used when we want to serve the JSON.
    We kept the usual configurations inside the `JSDoc` object.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了JSDoc，并将`swagger.json`存储在私有静态变量`swaggerJSON:any`中，这样在需要提供JSON时就可以使用它。我们在`JSDoc`对象中保留了通常的配置。
- en: Next, on express startup, we need to initialize the `setUpSwaggerJSDoc` method,
    so we can fill up the JSON at the start of the server.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在express启动时，我们需要初始化`setUpSwaggerJSDoc`方法，这样我们就可以在服务器启动时填充JSON。
- en: Create a new `Controller`, which gives us `swagger.json` as an HTTP endpoint.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Controller`，它会给我们提供`swagger.json`作为HTTP端点。
- en: '[PRE17]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hit `http://localhost:8081/swagger/swagger.json` to see the initial Swagger
    JSON.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8081/swagger/swagger.json`以查看初始的Swagger JSON。
- en: 'Now, we need to add JSDoc-style comments to each route to generate the Swagger
    spec and add comments in YAML to route handlers. Adding appropriate comments like
    this will populate our `swagger.json`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在每个路由中添加JSDoc风格的注释以生成Swagger规范，并在路由处理程序中添加YAML注释。添加适当的注释将填充我们的`swagger.json`：
- en: '[PRE18]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another option is to generate the documentation using Swagger inspector. Now
    that we are done with Swagger generation, we need to generate the Swagger UI.
    Add these in `Express.ts` this:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个选择是使用Swagger inspector生成文档。现在我们已经完成了Swagger生成，我们需要生成Swagger UI。在`Express.ts`中添加以下内容：
- en: '[PRE19]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Swagger is a great documentation tool and fulfills all our purposes. Whether
    we use it from the start or after development, it is a good fit to fulfill our
    documentation needs. The `./api/v1` file will give you generated Swagger documentation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是一个很好的文档工具，可以满足我们所有的需求。无论是从一开始使用还是在开发之后使用，它都是满足我们文档需求的好选择。`./api/v1`文件将为您生成Swagger文档。
- en: Generating a project from a Swagger definition
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Swagger定义生成项目
- en: 'Until now we were generating swagger definition from our source code. The other
    way round also holds true. We can easily generate a project from a Swagger definition
    and type of language (we saw something similar in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml),
    *Service State and Interservice Communication*. Rings a bell? That is correct.
    rPC and code generation). Let''s download swagger-code-generate and create our
    project out of it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们是从我们的源代码中生成swagger定义。反过来也是成立的。我们可以轻松地从Swagger定义和语言类型中生成项目（我们在[第7章](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml)中看到了类似的内容，*服务状态和服务间通信*。有印象吗？没错。rPC和代码生成）。让我们下载swagger-code-generate并创建我们的项目：
- en: Check out the updated `hello_world_swagger.yml` in the extracted src `chapter
    8/swagger-code-gen`. It has one more added route/endpoint of the API to update
    the product information.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查提取的src `chapter 8/swagger-code-gen`中更新的`hello_world_swagger.yml`。它增加了一个用于更新产品信息的API路由/端点。
- en: Next step is to download swagger-code-gen from at [https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen),
    so we can even configure it in automation or use it as required, rather than going
    to the online Swagger editor every time. You can also find swagger-code-gen in
    the extracted source of this book.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从[https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)下载swagger-code-gen，这样我们甚至可以将其配置为自动化或根据需要使用，而不是每次都去在线Swagger编辑器。你也可以在本书的提取源中找到swagger-code-gen。
- en: Since its a project that runs on JVM, we build the project so we can run it.
    Hit the command `mvn package` to build the JAR.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个在JVM上运行的项目，我们构建项目以便运行它。输入命令`mvn package`来构建JAR。
- en: 'Next, we will generate the source code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将生成源代码：
- en: '[PRE20]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can explore `typescript-nodejs` inside `chapter-8/swagger-code-gen` to understand
    the generated structure and play around with it. Similarly, you can go for any
    other language. Further documentation can be found here [https://github.com/swagger-api/swagger-codegen/blob/master/README.md](https://github.com/swagger-api/swagger-codegen/blob/master/README.md).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`chapter-8/swagger-code-gen`中探索`typescript-nodejs`，以了解生成的结构并进行实际操作。同样，你也可以选择任何其他语言。更多文档可以在这里找到[https://github.com/swagger-api/swagger-codegen/blob/master/README.md](https://github.com/swagger-api/swagger-codegen/blob/master/README.md)。
- en: Swagger is a wonderful utility to generate documentation on-demand. The documentation
    generated is comprehensible even for product managers or partners, human-readable,
    and easily adjustable. It makes our lives not only easy, but it makes the API
    more consumable and manageable, as it adheres to OpenAPI specs. Swagger is widely
    used by leading companies such as Netflix, Yelp, Twitter, and GitHub. In this
    section, we saw its varied uses along with its cycle and various approaches.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是一个很棒的工具，可以按需生成文档。生成的文档即使对于产品经理或合作伙伴也是易懂的，可读性强，且易于调整。它不仅使我们的生活变得更加轻松，而且使API更易消费和管理，因为它符合OpenAPI规范。Swagger被Netflix、Yelp、Twitter和GitHub等领先公司广泛使用。在本节中，我们看到了它的各种用途以及其周期和各种方法。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at testing, debugging, and documenting. We looked
    at some fundamental aspects of testing. We looked at the testing pyramid and at
    how to do unit testing, integration testing, and E2E tests. We looked at contract
    testing using Pact. Then, we had a look at the debugging and profiling process,
    which is very helpful in solving critical issues. We saw how to perform debugging
    in the event of critical failures. Finally, we looked at the documention tool
    Swagger, which helps to keep central documentation, and we examined strategies
    to introduce Swagger our microservices.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了测试、调试和文档编制。我们研究了测试的一些基本方面。我们研究了测试金字塔以及如何进行单元测试、集成测试和端到端测试。我们使用Pact进行了契约测试。然后，我们看了一下调试和分析过程，这对解决关键问题非常有帮助。我们看到了在关键故障发生时如何进行调试。最后，我们看了一下文档工具Swagger，它有助于保持中央文档，并且我们研究了引入Swagger到我们的微服务的策略。
- en: In the next chapter, we will look at deployment. We will see how to deploy our
    microservices, get introduced to Docker, and learn about the fundamentals of Docker.
    We will then see some monitoring tools and logging options. We will integrate
    ELK stacks for logs.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论部署。我们将看到如何部署我们的微服务，介绍Docker，并了解Docker的基础知识。然后，我们将了解一些监控工具和日志选项。我们将集成ELK堆栈以进行日志记录。
