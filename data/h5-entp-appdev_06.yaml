- en: 'Chapter 6. The App: Trailers via HTML5 Video'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：应用：通过HTML5视频的预告片
- en: One of the most interesting features that HTML5 introduces is the ability to
    reproduce multimedia without additional plugins. Although this appears to be the
    right solution for any enterprise application that involves media management,
    there are still many factors to consider. This chapter covers the HTML5 `video`
    and `audio` tags, their use to play media, and some caveats related to the current
    state of this technology.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5引入的最有趣的功能之一是能够在不使用额外插件的情况下播放多媒体。尽管这似乎是任何涉及媒体管理的企业应用的正确解决方案，但仍有许多因素需要考虑。本章涵盖了HTML5的`video`和`audio`标签，它们用于播放媒体，以及与当前技术状态相关的注意事项。
- en: As an example we are going to build a video player for trailers and an audio
    player for podcasts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将构建一个用于预告片的视频播放器和用于播客的音频播放器。
- en: 'This chapter includes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括：
- en: HTML5 video introduction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5视频介绍
- en: Implementing a video player
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现视频播放器
- en: HTML5 audio introduction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5音频介绍
- en: Implementing an audio player
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现音频播放器
- en: How I learned to stop worrying and love Flash
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何停止担忧并爱上Flash
- en: Introducing HTML5 video
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5视频介绍
- en: For many years, browsers have relied on video reproduction to external plugins
    like Real Player, Quicktime, and Flash. Having 99 percent penetration of the market,
    Flash became a de facto standard for media playback; however, in the last few
    years, mobile devices have replaced this solution with native apps and HTML5 solutions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，浏览器一直依赖于外部插件如Real Player、Quicktime和Flash进行视频播放。Flash的市场渗透率高达99%，成为了媒体播放的事实标准；然而，在过去的几年里，移动设备已经用原生应用和HTML5解决方案取代了这一解决方案。
- en: HTML5 video surged to become a standard and elegant way to embed videos. While
    everything points to HTML5's video solution, the lack of agreement on which video
    formats should be supported has obstructed its use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5视频迅速成为嵌入视频的标准和优雅方式。虽然一切似乎都指向HTML5的视频解决方案，但关于应支持哪些视频格式的缺乏共识阻碍了其使用。
- en: 'Ideally, there should be at least one format supported across all browsers,
    but every company has its own view on the matter. While Microsoft and Apple support
    MP4 H.264 (because they are patent holders of this format), Google and Mozilla
    back Ogg Theora and VP8 WebM as royalty-free solutions. The following table shows
    the browser support for each video format:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，所有浏览器至少应支持一种格式，但每个公司都有自己的看法。虽然微软和苹果支持MP4 H.264（因为它们是该格式的专利持有者），但谷歌和Mozilla支持Ogg
    Theora和VP8 WebM作为免费解决方案。以下表格显示了每个视频格式的浏览器支持情况：
- en: '| Browser | Operative System | Ogg Theora | MP4 H.264 | VP8 WebM |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器 | 操作系统 | Ogg Theora | MP4 H.264 | VP8 WebM |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Internet Explorer** | Windows | Manual install | 9.0 | Manual install |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **Internet Explorer** | Windows | 手动安装 | 9.0 | 手动安装 |'
- en: '| Windows Phone | No | No |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Windows Phone | 否 | 否 |'
- en: '| **Mozilla Firefox** | Windows | 3.5 | Manual install | 4.0 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **Mozilla Firefox** | Windows | 3.5 | 手动安装 | 4.0 |'
- en: '| Unix | No |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Unix | 否 |'
- en: '| Other |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 其他 |'
- en: '| **Google Chrome** | All supported | 3.0 | 3.0 (removal planned) | 6.0 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **Google Chrome** | 所有支持 | 3.0 | 3.0（计划移除） | 6.0 |'
- en: '| **Safari** | iOS | No | 3.1 | No |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **Safari** | iOS | 否 | 3.1 | 否 |'
- en: '| MacOS | Manual install | Manual install |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| MacOS | 手动安装 | 手动安装 |'
- en: '| Windows | Manual install |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Windows | 手动安装 |'
- en: '| **Opera** | All supported | 10.50 | No | 10.60 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **Opera** | 所有支持 | 10.50 | 否 | 10.60 |'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A new compression standard known as **High Efficiency Video Coding** (**HEVC**)
    or H.265 could be in commercial products by 2013\. It is almost twice as effective
    as the current H.264 standard.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一种名为**高效视频编码**（**HEVC**）或H.265的新压缩标准可能在2013年进入商业产品。它的效率几乎是当前H.264标准的两倍。
- en: Fortunately, the `video` tag supports the use of multiple sources allowing web
    browsers to select the video format supported, but this means each video needs
    to be encoded at least twice. For your enterprise, this translates to extra costs
    of encoding and storage.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`video`标签支持使用多个源，允许浏览器选择支持的视频格式，但这意味着每个视频至少需要编码两次。对于您的企业来说，这意味着编码和存储的额外成本。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some implementations rely on the video file extension too. For example, you
    cannot play a video on iOS devices with the `.f4v` extension even if it is using
    MP4 H.264 format.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现依赖于视频文件扩展名。例如，即使使用MP4 H.264格式，您也无法在iOS设备上播放扩展名为`.f4v`的视频。
- en: 'Most web browsers support progressive download instead of streaming. While
    Flash has its own proprietary protocol to stream (although an incomplete version
    of the specification has been released for public use) known as **Real Time Messaging
    Protocol** **RTMP**, only Safari, Safari iOS, and some Android browsers support
    a new streaming protocol: **HTTP Live Streaming** (**HLS**) implemented by Apple
    Inc.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络浏览器支持渐进式下载而不是流式传输。虽然 Flash 有自己的专有协议来流式传输（尽管已经发布了用于公共使用的规范的不完整版本），称为 **实时消息协议**
    **RTMP**，但只有 Safari、Safari iOS 和一些 Android 浏览器支持苹果公司实现的新流式传输协议：**HTTP Live Streaming**
    (**HLS**)。
- en: With progressive download, it is fairly easy to copy the video file from the
    browser cache, a facility that will make media pirates thankful. Furthermore,
    with a content delivery network that supports adaptive bitrate streaming, you
    can serve different video qualities depending on user bitrate if you are using
    streaming, but this is not possible using a progressive download.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用渐进式下载，从浏览器缓存中复制视频文件相当容易，这对于媒体盗版者来说是一个便利的条件。此外，如果你使用流式传输，并且内容分发网络支持自适应比特率流，你可以根据用户的比特率提供不同的视频质量，但使用渐进式下载则不可能做到这一点。
- en: Implementing a video player
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现视频播放器
- en: 'MovieNow users would love to have a way to visualize trailers of their favorite
    movies. For that, we are going to create a player with basic functionality: play,
    pause, seek, volume control, and full screen.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: MovieNow 用户会喜欢有一个方式来可视化他们最喜欢的电影的预告片。为此，我们将创建一个具有基本功能（播放、暂停、快进、音量控制、全屏）的播放器。
- en: 'We are going to use as an example a trailer of Sintel, an animated movie created
    with a free 3D animation tool known as Blender. This video trailer is hosted on
    the [http://www.w3.org/](http://www.w3.org/) site in three major video formats:
    MP4 (mp4), WebM (webm), and Ogg Theora (ogv).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以 Sintel 的预告片为例，Sintel 是使用名为 Blender 的免费 3D 动画工具制作的动画电影。这个视频预告片托管在 [http://www.w3.org/](http://www.w3.org/)
    网站上，以三种主要视频格式：MP4 (mp4)、WebM (webm) 和 Ogg Theora (ogv)。
- en: First, let's create a file called `trailer.html` and use our main page structure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 `trailer.html` 的文件，并使用我们的主页面结构。
- en: Inside the `article` tag, we use the `video` tag, which allows us to specify
    an initial image using the `poster` attribute to specify image path, and to show
    default controls using the `controls` attribute.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `article` 标签内，我们使用 `video` 标签，这允许我们使用 `poster` 属性指定初始图像，并使用 `controls` 属性显示默认控件。
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can specify the `src` property directly for the `video` tag, but to support
    multiple video format files we are going to declare our files using the `source`
    tag inside `video`. The `source` tag's `src` attribute allows us to define the
    video path and the `type` attribute (to specify the format).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接为 `video` 标签指定 `src` 属性，但为了支持多种视频格式文件，我们将在 `video` 标签内使用 `source` 标签来声明我们的文件。`source`
    标签的 `src` 属性允许我们定义视频路径，而 `type` 属性（用于指定格式）。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this case we are going to use:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用：
- en: '[http://media.w3.org/2010/05/sintel/trailer.mp4](http://media.w3.org/2010/05/sintel/trailer.mp4)
    for Chrome (while it is still supported), Internet Explorer, Safari, and Safari
    iOS'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://media.w3.org/2010/05/sintel/trailer.mp4](http://media.w3.org/2010/05/sintel/trailer.mp4)
    用于 Chrome（尽管它仍然受到支持）、Internet Explorer、Safari 和 Safari iOS'
- en: '[http://media.w3.org/2010/05/sintel/trailer.webm](http://media.w3.org/2010/05/sintel/trailer.webm)
    for Firefox, Chrome, and Opera'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://media.w3.org/2010/05/sintel/trailer.webm](http://media.w3.org/2010/05/sintel/trailer.webm)
    用于 Firefox、Chrome 和 Opera'
- en: '[http://media.w3.org/2010/05/sintel/trailer.ogv](http://media.w3.org/2010/05/sintel/trailer.ogv)
    for Firefox, Chrome, Opera, and others'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://media.w3.org/2010/05/sintel/trailer.ogv](http://media.w3.org/2010/05/sintel/trailer.ogv)
    用于 Firefox、Chrome、Opera 和其他浏览器'
- en: 'In this case, it is possible to use only two formats, but we will use three
    for our example. Finally we have:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可能只需要使用两种格式，但我们将使用三种格式作为示例。最后我们得到：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that if no video is supported it shows `<p>Video not supported.</p>`.
    This can be whatever HTML content you want.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有支持的视频，它会显示 `<p>Video not supported.</p>`。这可以是任何你想要的 HTML 内容。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your content delivery network supports HLS, you can use a video encoded as
    H.264 broken in segments and use a `.m3u8` playlist as an index file. For this,
    you can use a tool like Apple Stream Segmenter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的内容分发网络支持 HLS，你可以使用分段编码为 H.264 的视频，并使用 `.m3u8` 播单作为索引文件。为此，你可以使用 Apple Stream
    Segmenter 这样的工具。
- en: As every browser has its implementation, our player looks different in Firefox,
    Chrome, Safari, and so on. Our player renders differently on different platforms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个浏览器都有自己的实现，我们的播放器在 Firefox、Chrome、Safari 等浏览器中看起来都不同。我们的播放器在不同平台上渲染效果不同。
- en: 'In Firefox our player renders as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中，我们的播放器渲染效果如下所示：
- en: '![Implementing a video player](img/5689_06_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![实现视频播放器](img/5689_06_01.jpg)'
- en: 'In chrome our player renders as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中，我们的播放器渲染效果如下所示：
- en: '![Implementing a video player](img/5689_06_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![实现视频播放器](img/5689_06_02.jpg)'
- en: Chrome
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome
- en: 'In an iPhone our player will appear as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在iPhone上，我们的播放器将如下所示：
- en: '![Implementing a video player](img/5689_06_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![实现视频播放器](img/5689_06_06.jpg)'
- en: When it is necessary, reflect the enterprise visual style in the player or add
    custom functionality. It is possible to hide the default controllers and build
    your own.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，在播放器中反映企业视觉风格或添加自定义功能。隐藏默认控制器并构建自己的控制器是可能的。
- en: Custom controls
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义控件
- en: 'For MovieNow we will be creating play/pause, seek, volume, and full screen
    controls. Our design can be seen in the following image:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MovieNow，我们将创建播放/暂停、搜索、音量和全屏控件。我们的设计如下所示：
- en: '![Custom controls](img/5689_06_10.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![自定义控件](img/5689_06_10.jpg)'
- en: To simplify the task of creating a progress and seek bar as well as a volume
    bar, we use jQuery UI. jQuery UI is a JavaScript library that implements the most
    common user interface elements and interactions like sliders, accordions, tabs,
    and so on. In our case, we created a custom download with the UI Darkness theme
    ([http://jqueryui.com/download)](http://jqueryui.com/download)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化创建进度条、搜索条以及音量条的任务，我们使用了jQuery UI。jQuery UI是一个JavaScript库，它实现了最常见的用户界面元素和交互，如滑块、手风琴、标签等。在我们的案例中，我们创建了一个带有UI
    Darkness主题的自定义下载（[http://jqueryui.com/download](http://jqueryui.com/download)）。
- en: 'After saving our jQuery UI JavaScript file in the `js` folder and stylesheets
    in the `css` folder, we import them as always with JavaScript before the end of
    our `body` tag:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保存我们的jQuery UI JavaScript文件到`js`文件夹和样式表到`css`文件夹后，我们像往常一样在`body`标签的末尾之前导入它们：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And `css` in our `head` tag:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`head`标签中的`css`：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To support jQuery UI interactions in touch devices, we import the Touch Punch
    JavaScript library ([http://touchpunch.furf.com/](http://touchpunch.furf.com/)):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持触摸设备上的jQuery UI交互，我们导入Touch Punch JavaScript库（[http://touchpunch.furf.com/](http://touchpunch.furf.com/））：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have all the libraries we need in place, we can remove the `controls`
    attribute from the `video` tag to hide the default controls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了所有需要的库，我们可以从`video`标签中移除`controls`属性来隐藏默认控件。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this in place, let us define an HTML structure for our controls:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们定义一个用于我们控件的HTML结构：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have three main classes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个主要类：
- en: '`media-container` – wraps all our players'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media-container` – 包裹我们所有的播放器'
- en: '`media-area` – wraps video tag'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media-area` – 包裹视频标签'
- en: '`controls` – is the bottom bar that contains our controls'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controls` – 是包含我们控件的底部栏'
- en: 'Inside controls we have:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在控件内部我们有：
- en: '`play-button` – is the player''s play/pause button'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play-button` – 是播放器的播放/暂停按钮'
- en: '`seek` – the progress/seek bar'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seek` – 进度/搜索条'
- en: '`fullscreen-button` – is the full screen functionality button'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fullscreen-button` – 是全屏功能按钮'
- en: '`volume-container` – is the container of `volume-button`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume-container` – 是`volume-button`的容器'
- en: '`volume-slider` – is used to set the volume'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume-slider` – 用于设置音量'
- en: '`timer` – is an indicator of time elapsed in minutes and seconds (mm:ss)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timer` – 是显示分钟和秒（mm:ss）的时间指示器'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are using classes although jQuery selectors work faster using IDs because
    we want to permit the use of multiple players in the same page if necessary.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用类，尽管使用ID的jQuery选择器运行更快，因为我们希望允许在同一个页面中必要时使用多个播放器。
- en: Styling
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式化
- en: 'To start, we add some additional styles to `style.css`. We define a black background
    and remove the outline from all elements marked with the `media` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`style.css`中添加一些额外的样式。我们定义了一个黑色背景并移除了所有带有`media`类的元素的轮廓：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We add a margin for the **Top 5 Box Office** section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为**Top 5 Box Office**部分添加了边距：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We remove that margin for small devices where we hide the **Top 5 Box Office**
    section:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为小型设备移除了那个边距，因为我们隐藏了**Top 5 Box Office**部分：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These styles are related to layout and not directly to our player. To make styles
    for our video player, let us create a stylesheet called `mediaplayer.css` and
    import it in the `head` tag of `trailer.html`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式与布局相关，而不是直接与我们的播放器相关。为了为我们的视频播放器创建样式，让我们创建一个名为`mediaplayer.css`的样式表，并在`trailer.html`的`head`标签中导入它。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Buttons and image sprites
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按钮 和 图像精灵
- en: We define our controls area using the `controls` class, set a black background,
    set a height of `35px` (same line height to center text vertically), and set `position`
    to `relative` (so if we set absolute elements inside the positioning, they will
    be relative to `controls`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `controls` 类定义控件区域，设置黑色背景，设置高度为 `35px`（与行高相同以垂直居中文本），并将 `position` 设置为
    `relative`（这样如果我们在定位内设置绝对元素，它们将相对于 `controls`）。
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have an image sprite with all of our player controls called `player-control.png`.
    You can find it inside the `img` folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含所有播放器控件 `player-control.png` 的图像精灵。你可以在 `img` 文件夹中找到它。
- en: '![Buttons and image sprites](img/5689_06_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![按钮和图像精灵](img/5689_06_08.jpg)'
- en: 'The use of sprites is based on masking the visible element to show it and hiding
    the rest. In this case, suppose we want to show only our pause button. Our button
    has 35 x 35 pixels with `player-control.png` as the background image; the only
    part of the image that will be visible is inside our button area, so we can use
    background positioning to show different icons as is shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用精灵的基础是遮罩可见元素以显示它，并隐藏其余部分。在这种情况下，假设我们只想显示我们的暂停按钮。我们的按钮大小为 35 x 35 像素，背景图像为
    `player-control.png`；图像中唯一可见的部分是在我们的按钮区域内，因此我们可以使用背景定位来显示不同的图标，如这里所示：
- en: '![Buttons and image sprites](img/5689_06_09.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![按钮和图像精灵](img/5689_06_09.jpg)'
- en: 'Defining the play, volume, and full screen buttons that we have:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们已有的播放、音量和全屏按钮：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we saw before, we move `-35px` on the y axis to show our pause icon:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前看到的，我们在 y 轴上移动 `-35px` 来显示我们的暂停图标：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We apply the same principle to the full screen button:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将同样的原则应用于全屏按钮：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the case of the volume button, we are going to have a slider to set the
    volume below it, so we set the background color to hide elements below and set
    the `position` to `absolute` with `z-index` of `1000` to be over the slider:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在音量按钮的情况下，我们将在其下方设置一个用于设置音量的滑块，因此我们设置背景颜色来隐藏下面的元素，并将 `position` 设置为 `absolute`，`z-index`
    为 `1000` 以覆盖滑块：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Styling seek and volume bars
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 样式化搜索和音量条
- en: 'The seek and volume bars can be styled as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和音量条可以按照以下方式样式化：
- en: 'Let us define the font styles in `timer`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `timer` 中定义字体样式：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, we position `play-button` by floating it to the left-hand side
    and the timer, volume, and full screen to the right-hand side:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过浮动将 `play-button` 定位到左侧，将计时器、音量和全屏定位到右侧：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can float the `video` tag left with the `media` class to avoid extra spacing
    in some browsers:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `media` 类将 `video` 标签浮动到左侧，以避免某些浏览器中的额外间距：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use `overflow:hidden` to wrap `media-area` around `media`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `overflow:hidden` 将 `media-area` 包裹在 `media` 旁边：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using absolute positioning for the seek bar, we can dynamically expand the
    seek area using the `left` and `right` properties:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用绝对定位为 `seek` 条，我们可以使用 `left` 和 `right` 属性动态扩展搜索区域：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For this example, we created a flexible player to show some techniques related
    to styles, but it is good practice to define static dimensions for your player.
    Furthermore, it is better to use standard resolutions. The use of standard resolutions
    can improve performance for media reproduction on the client.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们创建了一个灵活的播放器来展示一些与样式相关的技术，但为你的播放器定义静态尺寸是一个好的实践。此外，使用标准分辨率会更好。使用标准分辨率可以提高客户端媒体播放的性能。
- en: Features detection
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能检测
- en: Some of the `video` tag features are not available to all browsers via the HTML5
    JavaScript API. For example, iOS devices disallow the use of volume control with
    JavaScript; it is only possible to use the default controls or hardware controls.
    Manipulating full screen controls using JavaScript is only possible in WebKit
    browsers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `video` 标签的功能不是通过 HTML5 JavaScript API 在所有浏览器中都可用。例如，iOS 设备不允许使用 JavaScript
    进行音量控制；只能使用默认控件或硬件控件。使用 JavaScript 操作全屏控件仅在 WebKit 浏览器中可行。
- en: 'We can define some classes to hide buttons when full screen or volume capabilities
    are not available. First, we hide our buttons:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一些类来隐藏在全屏或音量功能不可用时显示的按钮。首先，我们隐藏我们的按钮：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we change the `right` spacing of our `seek` bar:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们改变 `seek` 条的 `right` 间距：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Styling sliders
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 样式化滑块
- en: 'Since we are using jQuery UI to implement seek and volume sliders, we want
    to override some styles. jQuery UI sliders use the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 jQuery UI 来实现搜索和音量滑块，我们想要覆盖一些样式。jQuery UI 滑块使用以下样式：
- en: '`ui-slider-handle`: The circle that we use to drag and seek.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ui-slider-handle`: 我们用来拖动和搜索的圆形。'
- en: '`ui-state-active`: The class added to `ui-slider-handle` while we drag.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ui-state-active`: 在我们拖动时添加到 `ui-slider-handle` 的类。'
- en: '`ui-slider-range`: The bar that defines the active area. In our case, it is
    a blue bar.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ui-slider-range`: 定义活动区域的条形。在我们的例子中，它是一个蓝色条形。'
- en: Let's see the process step by step.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看这个过程。
- en: 'We want the same color for `ui-slider-handle` even when it is active, so we
    remove the background image used by jQuery UI:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望 `ui-slider-handle` 即使在活动状态下也有相同的颜色，因此我们移除了 jQuery UI 使用的背景图像：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the cursor pointer and remove the outline:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加光标指针并移除轮廓：
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Change `ui-slider-handle` size, rounded corners, and move it a little to the
    top (only for our `seek` slider):'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变 `ui-slider-handle` 的大小、圆角，并将其稍微向上移动（仅针对我们的 `seek` 滑块）：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Modify the rounded corners of the progress bar and add some inner shadows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改进度条的圆角并添加一些内部阴影：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Change the seek bar progress color to a blue gradient:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将寻道条进度颜色改为蓝色渐变：
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Change the volume progress color to a solid blue:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将音量进度颜色改为纯蓝色：
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Center our volume slider using `margin` and set `width` and `height`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `margin` 居中音量滑块并设置 `width` 和 `height`：
- en: '[PRE30]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Set the volume handle dimensions and positioning:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置音量手柄的尺寸和定位：
- en: '[PRE31]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To show and hide the volume slider, we set the `volume-container` positioning
    as `relative`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示和隐藏音量滑块，我们将 `volume-container` 的定位设置为 `relative`：
- en: '[PRE32]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Set the slider positioning as `absolute`. We set `z-index` to `900` (below
    the volume button), `overflow` to `hidden`, and a CSS transition for all properties:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将滑块定位设置为 `absolute`。我们将 `z-index` 设置为 `900`（在音量按钮下方），`overflow` 设置为 `hidden`，并为所有属性添加
    CSS 过渡：
- en: '[PRE33]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then resize `volume-container` on hover and `volume-slider-container`
    with it:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以然后在悬停时调整 `volume-container` 的大小，以及与之一起的 `volume-slider-container`：
- en: '[PRE34]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that our player looks the same, let us add all the interactions needed using
    JavaScript.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的播放器看起来一样，让我们使用 JavaScript 添加所有需要的交互。
- en: Adding interactions using JavaScript
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 JavaScript 添加交互
- en: 'To write our JavaScript code, we create a `movienow.mediaplayer.js` file in
    the `js` folder and include it before our body ends:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的 JavaScript 代码，我们在 `js` 文件夹中创建一个 `movienow.mediaplayer.js` 文件并在我们的 body
    结束前包含它：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Initial settings
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始设置
- en: 'We start our JavaScript the same way we started with geolocation by adding
    `mediaplayer` to our namespace and defining the `that` variable:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与地理位置相同的方式开始我们的 JavaScript，通过将 `mediaplayer` 添加到我们的命名空间并定义 `that` 变量：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Initializing video controllers
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化视频控制器
- en: When the `ready` document is triggered, we add the click event listeners to
    buttons, detect full screen capabilities, and add the `no-fullscreen` class if
    it is not available; initialize the jQuery UI slider for seeking and for volume
    control if it is available. Notice that we manage Mozilla, WebKit, and standard
    full screen capabilities with different functions. If volume is not available,
    we add the `no-volume` class and finally we bind the events of time update and
    reproduction ended.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ready` 文档被触发时，我们向按钮添加点击事件监听器，检测全屏功能，如果不可用则添加 `no-fullscreen` 类；如果可用，初始化用于寻道和音量控制的
    jQuery UI 滑块。注意，我们使用不同的函数管理 Mozilla、WebKit 和标准全屏功能。如果音量不可用，我们添加 `no-volume` 类，并最终绑定时间更新和播放结束的事件。
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Setting the seek slider
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置寻道滑块
- en: 'To set the seek slider, we set the initial value `value` to `0` and `step`
    to `0.01` to have a fluid movie movement on drag, `orientation` to `horizontal`,
    and `range` to `min` to consider the range between minimum value and current handle
    position value:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置寻道滑块，我们将初始值 `value` 设置为 `0`，将 `step` 设置为 `0.01` 以在拖动时实现流畅的电影移动，将 `orientation`
    设置为 `horizontal`，将 `range` 设置为 `min` 以考虑最小值和当前手柄位置值之间的范围：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are three events managed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个事件被管理：
- en: '`start` is triggered when the slider handle is pressed. Notice that we get
    `video` using the `getPlayer` function (this method will be declared later). We
    can pause the reproduction and add the `seeking` class to indicate that we are
    still dragging.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start` 在滑块手柄被按下时触发。注意，我们使用 `getPlayer` 函数获取 `video`（该方法将在稍后声明）。我们可以暂停播放并添加
    `seeking` 类来指示我们仍在拖动。'
- en: '`slide` is triggered while we drag. We call the `slideTime` function to set
    the progress bar position and time text.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slide` 在我们拖动时触发。我们调用 `slideTime` 函数来设置进度条位置和时间文本。'
- en: '`stop` is triggered on mouse up. We get the `video` tag and controls using
    the `controls` function, call `sliderTime` and restore the previous state of our
    player (playing or paused) using the `play-button playing` class. Finally, we
    remove `seeking` to indicate that we stop dragging.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop` 在鼠标抬起时触发。我们使用 `controls` 函数获取 `video` 标签和控制，调用 `sliderTime` 并使用 `play-button
    playing` 类恢复播放器的前一个状态（播放或暂停）。最后，我们移除 `seeking` 以指示我们停止拖动。'
- en: Initializing the volume slider
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化音量滑块
- en: 'If volume is available, we initialize the volume slider:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有音量可用，我们初始化音量滑块：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that the current value of our slider is contained in the `ui.value`
    variable, and to set it in our player we use the `volume` property shown as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当前滑块的值包含在 `ui.value` 变量中，要将其设置在我们的播放器中，我们使用如下所示的 `volume` 属性：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Functions to get DOM objects
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取 DOM 对象的函数
- en: 'We define two functions to execute jQuery selectors for the main player (the
    `media` class for the `video` tag or the `audio` tag if it is the case) and controls
    (the `controls` class):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个函数来执行主播放器（对于 `video` 标签或如果是的话 `audio` 标签的 `media` 类）和控制（`controls` 类）的
    jQuery 选择器：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Play and pause
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 播放和暂停
- en: For `play-button`, we toggle the `playing` class and set our player to the playing
    (`player[0].play()`) or paused (`player[0].pause()`) state.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `play-button`，我们切换 `playing` 类并将我们的播放器设置为播放状态（`player[0].play()`）或暂停状态（`player[0].pause()`）。
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Full screen
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 全屏
- en: Full screen functionality is managed in different ways by every browser. To
    enter the full screen mode we use `element.requestFullscreen()` and its equivalents
    `element.mozRequestFullScreen()` for Firefox and `element.webkitEnterFullScreen()`
    for Safari and Chrome. To exit full screen mode, we use `document.cancelFullScreen()`
    , `document.mozCancelFullScreen()` for Firefox, and `document.webkitCancelFullScreen()`
    for Safari and Chrome. Finally, to validate if the browser is in full screen mode
    we use `document.fullScreen`, `document.mozfullScreen` for Firefox, and `this.webkitFullScreen`
    for Safari and Chrome.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器以不同的方式管理全屏功能。要进入全屏模式，我们使用 `element.requestFullscreen()` 以及其等价函数 `element.mozRequestFullScreen()`（Firefox），`element.webkitEnterFullScreen()`（Safari
    和 Chrome）。要退出全屏模式，我们使用 `document.cancelFullScreen()`，`document.mozCancelFullScreen()`（Firefox），以及
    `document.webkitCancelFullScreen()`（Safari 和 Chrome）。最后，为了验证浏览器是否处于全屏模式，我们使用 `document.fullScreen`，`document.mozfullScreen`（Firefox），以及
    `this.webkitFullScreen`（Safari 和 Chrome）。
- en: Even user experience-wise the browsers vary; while Chrome and Safari show their
    own video controllers on full screen, Firefox doesn't show any controls by default.
    Full screen capabilities are not available in Internet Explorer. Our implementation
    verifies the mode and toggles between full screen and normal mode.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在用户体验方面，浏览器也有所不同；Chrome 和 Safari 在全屏时显示它们自己的视频控制器，而 Firefox 默认不显示任何控制器。在 Internet
    Explorer 中不可用全屏功能。我们的实现验证了模式并在全屏模式和正常模式之间切换。
- en: 'Using standard calls we have:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准调用，我们有：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using the Firefox prefix:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Firefox 前缀：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, for Safari and Chrome we have:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 Safari 和 Chrome，我们有：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that the event to exit full screen mode is not being triggered because
    the browsers manage that functionality using the *Esc* key, but depending on future
    implementations of the HTML5 full screen specification on every browser, we could
    show our controller in full screen mode and take advantage of this.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，退出全屏模式的触发事件没有发生，因为浏览器使用 *Esc* 键来管理该功能，但根据每个浏览器对 HTML5 全屏规范的未来实现，我们可以在全屏模式下显示我们的控制器并利用这一点。
- en: Format time
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 格式化时间
- en: 'We define the `timeFormat` function to get the player time in seconds and return
    it in mm:ss format:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `timeFormat` 函数来获取播放器时间（以秒为单位）并以 mm:ss 格式返回：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Controlling time
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制时间
- en: Every time we use the seek slider, we set media player time using the `currentTime`
    property, which triggers the `timeupdate` event calling the `timeUpdate` function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用寻道滑块时，我们使用 `currentTime` 属性设置媒体播放器时间，这会触发 `timeupdate` 事件并调用 `timeUpdate`
    函数。
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`timeUpdate` sets the time in mm:ss and if the player is not in the `seeking`
    state (defined by the `seeking` class in `mediaArea`), it updates the progress/seek
    bar too. This function is invoked when the `timeupdate` event is triggered:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeUpdate` 设置时间为 mm:ss，如果播放器不在 `seeking` 状态（由 `mediaArea` 中的 `seeking` 类定义），它也会更新进度/寻道条。此函数在
    `timeupdate` 事件触发时被调用：'
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Until the end of time
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 直到永远
- en: 'When the reproduction ends, `endReproduction` is called and we remove the `playing`
    class from `play-button` to indicate that we have finished the reproduction:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当播放结束，`endReproduction` 被调用，我们从 `play-button` 中移除 `playing` 类以指示我们已经完成了播放：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The final script should look like the following code snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的脚本应类似于以下代码片段：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As a result we have a video player for multiple platforms:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个适用于多个平台的视频播放器：
- en: '![Until the end of time](img/5689_06_07.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![直到永远](img/5689_06_07.jpg)'
- en: Possible improvements
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的改进
- en: 'At this point we have a fully functional player, but we can add more improvements
    in the future. An interesting functionality to add is a buffering notification.
    To achieve this, you will need to listen to the `loadstart` event to recognize
    the start of loading of a video, `waiting` and `stalled` (depending on the browser:
    [http://www.longtailvideo.com/html5/buffering/](http://www.longtailvideo.com/html5/buffering/))
    to detect a stop in the reproduction because of buffering, and finally `canplay`
    and `canplaythrough` to recognize the end of buffering.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个功能齐全的播放器，但未来我们可以添加更多改进。一个有趣的功能是添加缓冲通知。为了实现这一点，你需要监听`loadstart`事件以识别视频加载的开始，`waiting`和`stalled`（根据浏览器的不同：[http://www.longtailvideo.com/html5/buffering/](http://www.longtailvideo.com/html5/buffering/)）以检测由于缓冲而导致的播放停止，最后是`canplay`和`canplaythrough`以识别缓冲结束。
- en: On `loadstart`, `waiting`, and `stalled` a buffering notification should be
    shown and on `canplay` and `canplaythrough` that notification should be hidden.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadstart`、`waiting`和`stalled`时应该显示缓冲通知，而在`canplay`和`canplaythrough`时应该隐藏该通知。
- en: Still not perfect
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仍然不完美
- en: The HTML5 video specification is still in progress. Major inconsistencies exist
    because of multiple implementation decisions across browsers and platforms requiring
    different encodings. Nevertheless, it is a standard way of supporting video without
    plugins.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5视频规范仍在进行中。由于浏览器和平台之间存在多个实现决策，需要不同的编码，因此存在主要的不一致性。尽管如此，它是一个不使用插件的视频支持标准方式。
- en: Introducing HTML5 audio
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍HTML5音频
- en: 'The HTML5 audio specification—much like HTML5 video—is still in development,
    and there is no audio format supported across all browsers. Motives for this are
    the same ones that have been impeding standardized support of HTML5 video as you
    can see in the following table:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5音频规范——就像HTML5视频一样——仍在开发中，并且没有所有浏览器都支持的音频格式。造成这种情况的原因与阻碍HTML5视频标准化支持的原因相同，如下表所示：
- en: '| Browser | Ogg Vorbis | WAV PCM | MP3 | AAC |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器 | Ogg Vorbis | WAV PCM | MP3 | AAC |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Internet Explorer** | No | No | 9 | 9 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **Internet Explorer** | 不支持 | 不支持 | 9 | 9 |'
- en: '| **Mozilla Firefox** | 3.5 | 3.5 | No | No |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **Mozilla Firefox** | 3.5 | 3.5 | 无 | 无 |'
- en: '| **Google Chrome** | 6 | 6 | 6 | 6 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **Google Chrome** | 6 | 6 | 6 | 6 |'
- en: '| **Safari** | Manual install | 5 | 5 | 5 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **Safari** | 手动安装 | 5 | 5 | 5 |'
- en: '| **Opera** | 10.6 | 10.6 | No | No |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **Opera** | 10.6 | 10.6 | 无 | 无 |'
- en: Implementing an audio player
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现音频播放器
- en: MovieNow needs an audio podcast player. For that, we are going to use the HTML5
    `audio` tag.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: MovieNow需要一个音频播客播放器。为此，我们将使用HTML5的`audio`标签。
- en: 'The `audio` tag behaves more or less the same as the `video` tag:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`audio`标签的行为或多或少与`video`标签相同：'
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Like the `video` tag, the `audio` tag allows you to specify the `src` attribute
    directly inside of it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`video`标签一样，`audio`标签允许你直接在其内部指定`src`属性。
- en: 'To test, we will be using a sound effect audio from [http://www.w3schools.com/](http://www.w3schools.com/):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们将使用来自[http://www.w3schools.com/](http://www.w3schools.com/)的声音效果音频：
- en: '[http://www.w3schools.com/html5/horse.ogg](http://www.w3schools.com/html5/horse.ogg)
    for Firefox, Google Chrome, and Opera'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.w3schools.com/html5/horse.ogg](http://www.w3schools.com/html5/horse.ogg)适用于Firefox、Google
    Chrome和Opera'
- en: '[http://www.w3schools.com/html5/horse.mp3](http://www.w3schools.com/html5/horse.mp3)
    for Internet Explorer, Google Chrome, Safari, and Safari iOS'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.w3schools.com/html5/horse.mp3](http://www.w3schools.com/html5/horse.mp3)适用于Internet
    Explorer、Google Chrome、Safari和Safari iOS'
- en: We will create a `podcast.html` file and import the same libraries as `trailer.html`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`podcast.html`文件，并导入与`trailer.html`相同的库。
- en: Custom controllers
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义控制器
- en: 'Our media player is generic enough to use the same HTML structure for audio.
    We only need to replace the `video` tag with the `audio` tag, assign the `media`
    class to `audio` tag, and remove the full screen button:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的多媒体播放器足够通用，可以使用与`video`标签相同的HTML结构来播放音频。我们只需要将`video`标签替换为`audio`标签，将`media`类分配给`audio`标签，并移除全屏按钮：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Styling
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: 'One last adjustment is related to the `audio` tag. Some browsers have the `height`
    attribute defined by default, so we reset it to `0`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个调整与`audio`标签有关。一些浏览器默认定义了`height`属性，因此我们将它重置为`0`：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How I learned to stop worrying and love Flash
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我是如何学会停止担忧并爱上Flash的
- en: The awful truth is that HTML5 video and media capabilities are a new technology
    and the browser war makes it even more difficult to adopt these solutions as a
    standard for media playback. While Flash requires the installation of a plugin,
    it is a reliable technology to reproduce media and stream it across multiple browsers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 令人不安的事实是，HTML5的视频和媒体功能是一项新技术，浏览器之战使得将这些解决方案作为媒体播放的标准变得更加困难。虽然Flash需要安装插件，但它是一种可靠的技术，可以在多个浏览器中重现媒体并流式传输。
- en: While Flash support decreases on mobile devices and video and audio specifications
    improve, certainly there will be a future with no Flash media, but for now Flash
    is, at worst, a fallback solution for cross-browser compatibility.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动设备上Flash支持的减少和视频及音频规范的改进，肯定会有一个没有Flash媒体的未来，但就目前而言，Flash在最坏的情况下，是跨浏览器兼容性的后备解决方案。
- en: Huge media delivery products like YouTube still rely on Flash as the primary
    technology. You can decide to use HTML5 as your primary technology and fall back
    to Flash if the `video` and `audio` tags are not supported or vice versa, but
    the choice should be made based on your application's requirements.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 像YouTube这样的大型媒体交付产品仍然依赖于Flash作为主要技术。你可以选择将HTML5作为你的主要技术，如果`video`和`audio`标签不受支持，则回退到Flash，反之亦然，但选择应基于你的应用需求。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The HTML5 `video` and `audio` tags are simple and elegant ways to support media
    in your enterprise application, but differences between implementations across
    browsers should be taken into account when it is necessary to use them as a solution.
    For now, the best solution is to use both solutions and define a primary solution
    and a fallback.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5的`video`和`audio`标签是支持企业应用中媒体内容的简单而优雅的方式，但在需要将它们作为解决方案使用时，应考虑到不同浏览器之间的实现差异。目前，最佳方案是同时使用这两种解决方案，并定义一个主要解决方案和一个后备方案。
- en: 'The next chapter will focus on the use of another exciting feature of HTML5:
    canvas. We will use the `canvas` tag as a tool to visualize analytics related
    to movie reviews.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍HTML5的另一个令人兴奋的特性：canvas。我们将使用`canvas`标签作为可视化与电影评论相关的分析的工具。
