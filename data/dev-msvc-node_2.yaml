- en: Chapter 2. Microservices in Node.js – Seneca and PM2 Alternatives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Node.js中的微服务 - Seneca和PM2替代方案
- en: 'In this chapter, you will mainly learn about two frameworks, **Seneca** and
    **PM2**, and why they are important for building microservices. We will also get
    to know the alternatives to these frameworks in order to get a general understanding
    of what is going on in the Node.js ecosystem. In this chapter, we are going to
    focus on the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将主要了解两个框架，**Seneca**和**PM2**，以及它们对于构建微服务的重要性。我们还将了解这些框架的替代方案，以便对Node.js生态系统中正在发生的事情有一个总体了解。在本章中，我们将重点关注以下主题：
- en: '**Need for Node.js**: In this section, we are going to justify the choice of
    Node.js as a framework to build our microservices-oriented software. We will walk
    through the software stack required to use this awesome technology.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js的需求**：在本节中，我们将证明选择Node.js作为构建面向微服务的软件框架的选择。我们将介绍使用这一令人敬畏的技术所需的软件堆栈。'
- en: '**Seneca – a microservices framework**: In this section, you will learn the
    basics of Seneca and why it is the right choice if we want to keep our software
    manageable. We will explain how to integrate Seneca with Express (the most popular
    web server in Node.js) in order to follow the industry standards.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seneca - 一个微服务框架**：在本节中，您将学习Seneca的基础知识，以及为什么它是我们想要保持软件可管理性的正确选择。我们将解释如何将Seneca与Express（Node.js中最流行的Web服务器）集成，以遵循行业标准。'
- en: '**PM2**: PM2 is the best choice to run Node.js applications. No matter what
    your problem in deploying your ecosystem of apps is, PM2 will always have a solution
    for it.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PM2**：PM2是运行Node.js应用程序的最佳选择。无论您在部署应用程序生态系统时遇到什么问题，PM2总是有解决方案。'
- en: Need for Node.js
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的需求
- en: In the previous chapter, I mentioned that I wasn't a big fan of Node.js in the
    past. The reason for this was that I wasn't prepared to cope with the level of
    standardization that JavaScript was undergoing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我提到过我过去并不是Node.js的铁杆粉丝。原因是我没有准备好应对JavaScript正在经历的标准化水平。
- en: JavaScript in the browser was painful. Cross-browser compatibility was always
    a problem and the lack of standardization didn't help to ease the pain.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的JavaScript很痛苦。跨浏览器兼容性一直是一个问题，缺乏标准化也没有帮助缓解痛苦。
- en: Then Node.js came and it was easy to create highly scalable applications due
    to its non-blocking nature (we will talk about it later in this chapter) and it
    was also very easy to learn as it was based on JavaScript, a well-known language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Node.js出现了，由于其非阻塞性质（我们将在本章后面讨论），创建高度可扩展的应用程序变得很容易，而且由于它基于JavaScript，一个众所周知的语言，学习起来也很容易。
- en: Nowadays, Node.js is the preferred choice for a large number of companies across
    the world, as well as the number one choice for aspects that require a non-blocking
    nature in the server, such as web sockets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，Node.js是全球许多公司的首选，也是需要服务器非阻塞性质的方面的首选，例如Web套接字。
- en: In this book, we will primarily (but not only) use Seneca and PM2 as the frameworks
    for building and running microservices, but it does not mean that the alternatives
    are not good.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将主要（但不仅仅）使用Seneca和PM2作为构建和运行微服务的框架，但这并不意味着其他替代方案不好。
- en: 'There are few alternatives in the market such as **restify** or **Express**
    for building applications and **forever** or **nodemon** to run them. However,
    I find Seneca and PM2 to be the most appropriate combination for building microservices
    for the following reasons:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有一些替代品，如**restify**或**Express**用于构建应用程序，**forever**或**nodemon**用于运行它们。然而，我发现Seneca和PM2是构建微服务的最合适的组合，原因如下：
- en: PM2 is extremely powerful regarding application deployments
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PM2在应用程序部署方面非常强大
- en: Seneca is not only a framework to build microservices, but it is also a paradigm
    that reshapes what we know about object-oriented software
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seneca不仅是构建微服务的框架，而且还是重新塑造我们对面向对象软件的认识的范式
- en: We will be using Express in a few examples in the chapters of this book and
    we will also discuss how to integrate Seneca in Express as a middleware.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的几个章节中，我们将使用Express，并讨论如何将Seneca作为中间件集成到Express中。
- en: However, before that, let's discuss some concepts around Node.js that will help
    us to understand those frameworks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在此之前，让我们讨论一些围绕Node.js的概念，这将帮助我们理解这些框架。
- en: Installing Node.js, npm, Seneca, and PM2
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js、npm、Seneca和PM2
- en: Node.js is fairly easy to install. Depending on your system, there is an installer
    available that makes the installation of Node.js and **npm** (**Node Package Manager**)
    a fairly simple task. Simply double-click on it and follow the instructions. At
    the time of writing this book, there are installers available for Windows and
    OSX.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的安装相当简单。根据您的系统，有一个安装程序可用，可以使Node.js和**npm**（Node包管理器）的安装变得非常简单。只需双击它，然后按照说明操作。在撰写本书时，Windows和OSX都有安装程序可用。
- en: However, the advanced users, especially DevOps engineers, will need to install
    Node.js and npm from the sources or binaries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，高级用户，特别是DevOps工程师，需要从源代码或二进制文件安装Node.js和npm。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Both Node.js and npm programs come bundled together in a single package that
    we can download for various platforms from the Node.js website (either sources
    or binaries):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和npm程序都捆绑在一起，我们可以从Node.js网站上下载各种平台的单个软件包（源代码或二进制文件）：
- en: '[https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
- en: 'For the Chef users, a popular configuration management software to build servers,
    there are few options available, but the most popular is the following recipe
    (for those unfamiliar with Chef, a recipe is basically a script to install or
    configure software in a server through Chef):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Chef用户，一个流行的配置管理软件来构建服务器，有一些选项可用，但最流行的是以下配方（对于不熟悉Chef的人来说，配方基本上是一个脚本，用于通过Chef在服务器上安装或配置软件）：
- en: '[https://github.com/redguide/nodejs](https://github.com/redguide/nodejs)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/redguide/nodejs](https://github.com/redguide/nodejs)'
- en: At the time of writing this book, there are binaries available for Linux.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Linux上有可用的二进制文件。
- en: Learning npm
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习npm
- en: '**npm** is a software that comes with Node.js and enables you to pull dependencies
    from the Internet without worrying about their management. It can also be used
    to maintain and update dependencies, as well as create projects from scratch.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm**是随Node.js一起提供的软件，它使您能够从互联网上获取依赖项，而无需担心其管理。它还可以用于维护和更新依赖项，以及从头开始创建项目。'
- en: 'As you probably know, every node app comes with a `package.json` file. This
    file describes the configuration of the project (dependencies, versions, common
    commands, and so on). Let''s see the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能知道，每个node应用程序都带有一个`package.json`文件。该文件描述了项目的配置（依赖项、版本、常用命令等）。让我们看下面的例子：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The file itself is self-explanatory. There is an interesting section in the
    file—`scripts`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 文件本身是不言自明的。文件中有一个有趣的部分-`scripts`。
- en: In this section, we can specify the command that is used to run for different
    actions. In this case, if we run `npm test` from the terminal, npm will execute
    `grunt validate --verbose`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们可以指定用于不同操作的运行命令。在这种情况下，如果我们从终端运行`npm test`，npm将执行`grunt validate --verbose`。
- en: 'Node applications are usually as easy to run as executing the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Node应用程序通常很容易运行，只需执行以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the root of your project, consider that the bootstrapping file is `index.js`.
    If this is not the case, the best thing you can do is add a subsection in the
    `scripts` section in `package.json`, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目根目录中，考虑引导文件是`index.js`。如果不是这种情况，您最好在`package.json`的`scripts`部分中添加一个子部分，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, now we have two commands executing the same program:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在我们有两个命令执行相同的程序：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The benefits of using `npm start` are quite obvious—uniformity. No matter how
    complex your application is, `npm start` will always run it (if you have configured
    the `scripts` section correctly).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm start`的好处是非常明显的-统一性。无论您的应用程序有多复杂，`npm start`都将始终运行它（如果您已正确配置了`scripts`部分）。
- en: Let's install Seneca and PM2 on a clean project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个干净的项目中安装Seneca和PM2。
- en: 'First, execute `npm init` in a new folder from the terminal after installing
    Node.js. You should get a prompt similar to the following image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在安装Node.js后，在终端中的一个新文件夹中执行`npm init`。您应该会得到一个类似以下图片的提示：
- en: '![Learning npm](img/B04889_02_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![学习npm](img/B04889_02_01.jpg)'
- en: npm will ask you for a few parameters to configure your project, and once you
    are done, it writes a `package.json` file with content similar to the preceding
    code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: npm会要求您输入一些参数来配置您的项目，一旦完成，它会写入一个`package.json`文件，内容类似于上述代码。
- en: 'Now we need to install the dependencies; npm will do that for us. Just run
    the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要安装依赖项；npm会为我们做这件事。只需运行以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, if you inspect `package.json` again, you can see that there is a new section
    called `dependencies` that contains an entry for Seneca:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果再次检查`package.json`，您会看到一个名为`dependencies`的新部分，其中包含了Seneca的条目：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This means that from now on, our app can require the Seneca module and the
    `require()` function will be able to find it. There are a few variations of the
    `save` flag, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着从现在开始，我们的应用程序可以需要Seneca模块，并且`require()`函数将能够找到它。`save`标志有一些变化，如下所示：
- en: '`save`: This saves the dependency in the `dependencies` section. It is available
    through all the development life cycle.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save`：这将在`dependencies`部分保存依赖项。它在整个开发生命周期中都可用。'
- en: '`save-dev`: This saves the dependency in the `devDependencies` section. It
    is only available in development and does not get deployed into production.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save-dev`：这将在`devDependencies`部分保存依赖项。它仅在开发中可用，不会部署到生产环境中。'
- en: '`save-optional`: This adds a dependency (such as `save`), but lets npm continue
    if the dependency can''t be found. It is up to the app to handle the lack of this
    dependency.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save-optional`：这会添加一个依赖项（例如`save`），但如果找不到依赖项，npm会继续执行。由应用程序来处理缺少此依赖项。'
- en: 'Let''s continue with PM2\. Although it can be used as a library, PM2 is mainly
    a command tool, like `ls` or `grep` in any Unix system. npm does a great job installing
    command-line tools:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用PM2。虽然它可以作为一个库来使用，但PM2主要是一个命令工具，就像在任何Unix系统中的`ls`或`grep`一样。npm在安装命令行工具方面做得很好：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `–g` flags instruct npm to globally install PM2, so it is available in the
    system, not in the app. This means that when the previous command finishes, `pm2`
    is available as a command in the console. If you run `pm2 help` in a terminal,
    you can see the help of PM2.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g`标志指示npm全局安装PM2，因此它在系统中可用，而不是在应用程序中。这意味着当前一个命令完成时，`pm2`在控制台中作为一个命令可用。如果在终端中运行`pm2
    help`，您可以看到PM2的帮助。'
- en: Our first program – Hello World
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个程序-Hello World
- en: 'One of the most interesting concepts around Node.js is simplicity. You can
    learn Node.js in few days and master it in a few weeks, as long as you are familiar
    with JavaScript. Code in Node.js tends to be shorter and clearer than in other
    languages:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕Node.js最有趣的概念之一是简单性。只要您熟悉JavaScript，您可以在几天内学会Node.js，并在几周内掌握它。Node.js中的代码往往比其他语言更短更清晰：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code creates a server that listens on the `8000` port for requests.
    If you don''t believe it, open a browser and type `http://127.0.0.1:8000` in the
    navigation bar, as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个服务器，监听`8000`端口的请求。如果您不相信，打开浏览器，在导航栏中输入`http://127.0.0.1:8000`，如下截图所示：
- en: '![Our first program – Hello World](img/B04889_02_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个程序-Hello World](img/B04889_02_02.jpg)'
- en: 'Let''s explain the code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下代码：
- en: The first line loads the `http` module. Through the `require()` instruction,
    we ask the node to load the `http` module and assign the export of this module
    to the `http` variable. Exporting language elements is the way that Node.js has
    to expose functions and variables to the outer world from inside a module.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行加载了`http`模块。通过`require()`指令，我们要求节点加载`http`模块，并将该模块的导出分配给`http`变量。导出语言元素是Node.js用来从模块内部向外部世界公开函数和变量的方式。
- en: The second construction in the script creates the HTTP server. The `http` module
    creates and exposes a method called `createServer()` that receives a function
    (remember JavaScript treats functions as first-level objects so that they can
    be passed as other functions arguments) as a parameter that, in the Node.js world,
    is called **callback**. A callback is an action to be executed as a response to
    an event. In this case, the event is that the script receives an HTTP request.
    Node.js has a heavy usage of callbacks due to its thread model. Your application
    will always be executed on a single thread so that not blocking the application
    thread while waiting for operations to complete and prevents our application from
    looking stalled or hanged. Otherwise, your program won't be responsive. We'll
    come back to this in [Chapter 4](ch04.html "Chapter 4. Writing Your First Microservice
    in Node.js"), *Writing Your First Microservice in Node.js*.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本中的第二个构造创建了HTTP服务器。`http`模块创建并公开了一个名为`createServer()`的方法，该方法接收一个函数（记住JavaScript将函数视为一级对象，因此它们可以作为其他函数的参数传递），在Node.js世界中称为**回调**。回调是作为对事件的响应而执行的操作。在这种情况下，事件是脚本接收到HTTP请求。由于Node.js的线程模型，回调的使用非常频繁。您的应用程序将始终在单个线程上执行，因此不会阻塞应用程序线程，同时等待操作完成，并且可以防止我们的应用程序看起来停滞或挂起。否则，您的程序将无法响应。我们将在[第4章](ch04.html
    "第4章。在Node.js中编写您的第一个微服务")中回到这一点，*在Node.js中编写您的第一个微服务*。
- en: In the next line, `server.listen(8000)` starts the server. From now on, every
    time our server receives a request, the callback on the `http.createServer()`
    function will be executed.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一行中，`server.listen(8000)`启动了服务器。从现在开始，每当我们的服务器收到一个请求，`http.createServer()`函数上的回调将被执行。
- en: 'This is it. Simplicity is the key to Node.js programs. The code allows you
    to go to the point without writing tons of classes, methods, and config objects
    that complicate what, in the first instance, can be done much more simply: write
    a script that serves requests.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。简单是Node.js程序的关键。代码允许您直奔主题，而不必编写大量的类、方法和配置对象，这些会使最初可以更简单地完成的事情变得复杂：编写一个提供请求的脚本。
- en: Node.js threading model
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js线程模型
- en: Programs written in Node.js are single-threaded. The impact of this is quite
    significant; in the previous example, if we have ten thousand concurrent requests,
    they will be queued and satisfied by the Node.js event loop (it will be further
    explained in [Chapter 4](ch04.html "Chapter 4. Writing Your First Microservice
    in Node.js"), *Writing Your First Microservice in Node.js* and [Chapter 6](ch06.html
    "Chapter 6. Testing and Documenting Node.js Microservices"), *Testing and Documenting
    Node.js Microservices*) one by one.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js编写的程序是单线程的。这的影响相当显著；在前面的例子中，如果我们有一万个并发请求，它们将被排队并由Node.js事件循环满足（将在[第4章](ch04.html
    "第4章。在Node.js中编写您的第一个微服务")和[第6章](ch06.html "第6章。测试和文档化Node.js微服务")中进一步解释，*在Node.js中编写您的第一个微服务*和*测试和文档化Node.js微服务*）。
- en: At first glance, this sounds wrong. I mean, the modern CPUs can handle multiple
    parallel requests due to their multicore nature. So, what is the benefit of executing
    them in one thread?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这听起来是错误的。我的意思是，现代CPU可以处理多个并行请求，因为它们是多核的。那么，在一个线程中执行它们有什么好处呢？
- en: The answer to this question is that Node.js was designed to handle asynchronous
    processing. This means that in the event of a slow operation such as reading a
    file, instead of blocking the thread, Node.js allows the thread to continue satisfying
    other events, and then the control process of the node will execute the method
    associated with the event, processing the response.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是，Node.js被设计用来处理异步处理。这意味着在读取文件等慢操作时，Node.js不会阻塞线程，而是允许线程继续满足其他事件，然后节点的控制过程将执行与事件相关的方法，处理响应。
- en: Sticking to the previous example, the `createServer()` method accepts a callback
    that will be executed in the event of an HTTP request, but meanwhile, the thread
    is free to keep executing other actions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持前面的例子，`createServer()`方法接受一个回调，该回调将在HTTP请求事件发生时执行，但与此同时，线程可以自由地继续执行其他操作。
- en: The catch in this model is what Node.js developers call the callback hell. The
    code gets complicated as every single action that is a response to a blocking
    action has to be processed on a callback, like in the previous example; the function
    used as a parameter to the `createServer()` method is a good example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的问题是Node.js开发人员所说的回调地狱。随着每个对阻塞操作的响应都必须在回调中处理，代码变得复杂，就像前面的例子中，作为`createServer()`方法参数使用的函数一样。
- en: Modular organization best practices
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化组织最佳实践
- en: The source code organization for big projects is always controversial. Different
    developers have different approaches to how to order the source code in order
    to keep the chaos away.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大型项目的源代码组织总是有争议的。不同的开发人员有不同的方法来整理源代码，以保持混乱的远离。
- en: Some languages such as Java or C# organize the code in packages so that we can
    find source code files that are related inside a package. As an example, if we
    are writing a task manager software, inside the `com.taskmanager.dao` package
    we can expect to find classes that implement the **data access object** (**DAO**)
    pattern in order to access the database. In the same way, in the `com.taskmanager.dao.domain.model`
    package, we can find all the classes that represent model objects (usually tables)
    in our application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如Java或C＃，通过包来组织代码，以便我们可以在包内找到相关的源代码文件。例如，如果我们正在编写一个任务管理器软件，在`com.taskmanager.dao`包内，我们可以期望找到实现**数据访问对象**（**DAO**）模式以访问数据库的类。同样，在`com.taskmanager.dao.domain.model`包中，我们可以找到表示模型对象（通常是表）的所有类。
- en: This is a convention in Java and C#. If you are a C# developer, and you start
    working on an existing project, it only takes you a few days to get used to how
    the code is structured as the language enforces the organization of the source.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Java和C#中的一个约定。如果你是C#开发人员，并且开始在一个现有项目上工作，只需要几天时间就可以适应代码的结构，因为语言强制执行源代码的组织。
- en: Javascript
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Javascript
- en: 'JavaScript was first designed to be run inside the browser. The code was supposed
    to be embedded in HTML documents so that the **Document Object Model** (**DOM**)
    could be manipulated to create dynamic effects. Take a look at the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最初是设计为在浏览器内运行的。代码应该嵌入在HTML文档中，以便可以操作**文档对象模型**（**DOM**）来创建动态效果。看看下面的例子：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, if you load this HTML on a browser, the text inside the `span`
    tag with the `id` as `world` is replaced when the page loads.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，如果你在浏览器上加载这个HTML，`id`为`world`的`span`标签内的文本在页面加载时被替换。
- en: In JavaScript, there is no concept of dependency management. JavaScript can
    be segregated from the HTML into its own file, but there is no way (for now) to
    include a JavaScript file into another JavaScript file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，没有依赖管理的概念。JavaScript可以从HTML中分离出来成为自己的文件，但目前没有办法将一个JavaScript文件包含到另一个JavaScript文件中。
- en: This leads to a big problem. When the project contains dozens of JavaScript
    files, the assets management become more of an art than an engineering effort.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个大问题。当项目包含数十个JavaScript文件时，资源管理变得更像是一种艺术而不是工程努力。
- en: 'The order in which you import the JavaScript files becomes important as the
    browser executes the JavaScript files as it finds them. Let''s reorder the code
    in the previous example to demonstrate it, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 导入JavaScript文件的顺序变得重要，因为浏览器会在找到JavaScript文件时执行它们。让我们重新排列前面例子中的代码来演示它，如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, save this HTML in an `index.html` file and try to load it in any browser,
    as shown in the following image:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这个HTML保存在一个名为`index.html`的文件中，并尝试在任何浏览器中加载它，如下图所示：
- en: '![Javascript](img/B04889_02_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Javascript](img/B04889_02_03.jpg)'
- en: 'In this case, I have used Chrome and the console shows an **Uncaught TypeError:
    Cannot set property ''innerText'' of null** error in line 7.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我使用了Chrome，控制台显示第7行出现了**Uncaught TypeError: Cannot set property ''innerText''
    of null**错误。'
- en: Why is that happening?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？
- en: As we explained earlier, the browser *executes* the code as it is found, and
    it turns out that when the browser executes the JavaScript, the `world` element
    does not exist yet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，浏览器*执行*代码时，当浏览器执行JavaScript时，`world`元素尚不存在。
- en: Fortunately, Node.js has solved the dependency-loading problem using a very
    elegant and standard approach.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Node.js已经通过一种非常优雅和标准的方法解决了依赖加载问题。
- en: SOLID design principles
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SOLID设计原则
- en: 'When talking about microservices, we always talk about modularity, and modularity
    always boils down to the following (**SOLID**) design principles:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论微服务时，我们总是谈论模块化，而模块化总是归结为以下（**SOLID**）设计原则：
- en: '**Single** responsibility principle'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一**职责原则'
- en: '**Open** for extension, closed for modification'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放**扩展，关闭修改'
- en: '**Liskov** substitution'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liskov**替换'
- en: '**Interface** segregation'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**隔离'
- en: '**Dependency** inversion (inversion of control and dependency injection)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖**反转（控制反转和依赖注入）'
- en: You want your code to be organized in modules. A module is an aggregation of
    code that does something simple, such as manipulating strings, and it does it
    well. The more functions (or classes, utilities, and so on) your module contains,
    the less cohesive it is, and we are trying to avoid that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的代码组织成模块。模块是一组执行简单操作的代码，比如操作字符串，并且它执行得很好。你的模块包含的函数（或类、实用程序等）越多，它的内聚性就越低，我们正试图避免这种情况。
- en: 'In Node.js, every JavaScript file is a module by default. We can also use folders
    as modules, but let''s focus on files:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，每个JavaScript文件默认都是一个模块。我们也可以使用文件夹作为模块，但让我们专注于文件：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code represents a valid module in Node.js. In this case, the module
    contains three functions, where two of them are exposed to the outside of the
    module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码代表了Node.js中的一个有效模块。在这种情况下，模块包含三个函数，其中两个函数对外部可见。
- en: In Node.js, this is done through the `module.exports` variable. Whatever you
    assign to this variable is going to be visible by the calling code so that we
    can simulate private content on a module, such as the `charToNumber()` function
    in this case.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，这是通过`module.exports`变量完成的。无论你分配给这个变量什么，都将被调用代码看到，这样我们就可以在模块上模拟私有内容，比如在这种情况下的`charToNumber()`函数。
- en: 'So, if we want to use this module, we just need to `require()` it, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要使用这个模块，我们只需要像下面这样`require()`它：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This should output `1122`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出`1122`。
- en: 'Let''s go back to the SOLID principles and see how our module looks:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到SOLID原则，看看我们的模块是什么样子的：
- en: '**Single responsibility principle**: Our module only deals with strings'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**：我们的模块只处理字符串'
- en: '**Open for extension, closed for modification**: We can add more functions,
    but the ones that we have are correct and they can be used to build new functions
    in the module'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放扩展，关闭修改**：我们可以添加更多的函数，但我们已经有的函数是正确的，它们可以用来构建模块中的新函数'
- en: '**Liskov substitution**: We will skip this one, as the structure of the module
    is irrelevant to fulfil this principle'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liskov替换**：我们将跳过这一点，因为模块的结构与实现这一原则无关'
- en: '**Interface segregation**: JavaScript is not a language that counts with an
    interface element such as Java or C#, but in this module, we exposed the interface,
    and the `module.exports` variable will act as a contract for the calling code
    and the change in our implementation won''t affect how the module is being called'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离**：JavaScript不是像Java或C#那样具有接口元素的语言，但在这个模块中，我们暴露了接口，`module.exports`变量将作为调用代码和我们实现变化之间的合同'
- en: '**Dependency inversion**: Here is where we fail, not fully, but enough to reconsider
    our approach'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转**：这就是我们失败的地方，不是完全失败，但足够让我们重新考虑我们的方法'
- en: In this case, we require the module, and the only way to interact with it is
    through the global scope. If, inside the module, we want to interact with data
    from outside, the only possible option is to create a global variable (or function)
    prior to requiring the module, and then assume that it is always going to be in
    there.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要模块，并且与之交互的唯一方法是通过全局范围。如果在模块内部，我们想要与外部的数据交互，唯一可能的选项就是在需要模块之前创建一个全局变量（或函数），然后假设它总是存在。
- en: Global variables are a big problem in Node.js. As you are probably aware, in
    JavaScript, if you omit the `var` keyword when declaring a variable, it is automatically
    global.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量在Node.js中是一个大问题。你可能知道，在JavaScript中，如果在声明变量时省略了`var`关键字，它会自动成为全局变量。
- en: This, coupled with the fact that intentional global variables create a data
    coupling between modules (coupling is what we want to avoid at any cost), is the
    reason to find a better approach to how to define the modules for our microservices
    (or in general).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这与有意的全局变量创建模块之间的数据耦合（耦合是我们想要以任何代价避免的）事实相结合，是寻找更好的方法来定义我们的微服务（或者一般情况下）模块的原因。
- en: 'Let''s restructure the code as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式重构代码：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This looks a bit more complicated, but once you get used to it, the benefits
    are enormous:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点复杂，但一旦你习惯了，好处是巨大的：
- en: We can pass configuration parameters to the module (such as debugging information)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以向模块传递配置参数（例如调试信息）
- en: Avoids the pollution of global scope as if everything is wrapped inside a function,
    and we enforce the *use strict* configuration (this avoids declarations without
    `var` with a compilation error)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免全局范围的污染，就好像所有东西都包裹在一个函数内部一样，并且我们强制执行*use strict*配置（这样可以避免没有`var`声明的编译错误）
- en: Parameterizing a module makes it easy to mock behaviors and data for testing
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对模块进行参数化使得为测试模拟行为和数据变得容易
- en: In this book, we are going to be writing a good amount of code to model systems
    from the microservices prospective. We will try to keep this pattern as much as
    we can so that we can see the benefits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将编写大量代码来模拟微服务的系统。我们将尽量保持这种模式，以便我们可以看到好处。
- en: One of the library that we are going to be using to build microservices, Seneca,
    follows this pattern, as well as a large number of libraries that can be found
    on Internet.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的一个构建微服务的库Seneca，遵循这种模式，以及许多可以在互联网上找到的库。
- en: Seneca – a microservices framework
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Seneca - 一个微服务框架
- en: Seneca is a framework for building microservices written by Richard Rodger,
    the founder and CTO of nearForm, a consultancy that helps other companies design
    and implement software using Node.js. Seneca is about simplicity, it connects
    services through a sophisticated pattern-matching interface that abstracts the
    transport from the code so that it is fairly easy to write highly scalable software.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca是由Richard Rodger编写的用于构建微服务的框架，他是nearForm的创始人兼首席技术官，nearForm是一家咨询公司，帮助其他公司使用Node.js设计和实现软件。Seneca是关于简单性的，它通过一个复杂的模式匹配接口连接服务，将传输从代码中抽象出来，因此编写高度可扩展的软件相当容易。
- en: 'Let''s stop talking and see some examples:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停止说话，看一些例子：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, the code is self-explanatory:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，代码是不言自明的：
- en: Seneca comes as a module, so the first thing that needs to be done is to `require()`
    it. Seneca package is wrapped in a function, so invoking the function initializes
    the library.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seneca作为一个模块出现，所以需要做的第一件事就是`require()`它。Seneca包装在一个函数中，因此调用该函数会初始化库。
- en: 'Next two instructions are related to a concept explained in [Chapter 1](ch01.html
    "Chapter 1. Microservices Architecture"), *Microservices Architecture*: API composition.
    The `seneca.add()` method instructs Seneca to add a function that will be invoked
    with a set of patterns. For the first one, we specify an action that will take
    place when Seneca receives the `{role: math, cmd: sum}` command. For the second
    one, the pattern is `{role: math, cmd: product}`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '接下来的两条指令与[第1章](ch01.html "第1章 微服务架构")中解释的一个概念相关：API组合。`seneca.add()`方法指示Seneca添加一个函数，该函数将在一组模式下被调用。对于第一个，我们指定当Seneca接收到`{role:
    math, cmd: sum}`命令时将发生的动作。对于第二个，模式是`{role: math, cmd: product}`。'
- en: The last line sends a command to Seneca that will be executed by the service
    that matches the pattern passed as the first parameter. In this case, it will
    match the first service as `role` and `cmd` match. The second call to act will
    match the second service.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行发送一个命令给Seneca，该命令将由与作为第一个参数传递的模式匹配的服务执行。在这种情况下，它将匹配第一个服务作为`role`和`cmd`匹配。对`act`的第二次调用将匹配第二个服务。
- en: 'Write the code in a file called `index.js` in the project that we created earlier
    in this chapter (remember that we installed Seneca and PM2), and run the following
    command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面创建的项目中的名为`index.js`的文件中编写代码（记住我们安装了Seneca和PM2），并运行以下命令：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output will be something similar to the following image:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下图像：
- en: '![Seneca – a microservices framework](img/B04889_02_19.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Seneca - 一个微服务框架](img/B04889_02_19.jpg)'
- en: We will talk about this output later in order to explain exactly what it means,
    but if you are used to enterprise applications, you can almost guess what is going
    on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会谈论这个输出，以便准确解释它的含义，但是如果你习惯于企业应用程序，你几乎可以猜到发生了什么。
- en: 'The last two lines are the responses from the two services: the first one executes
    `1+2` and the second one executes `3*4`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行是来自两个服务的响应：第一个执行`1+2`，第二个执行`3*4`。
- en: 'The `null` output that shows up as the first word in the last two lines corresponds
    to a pattern that is widely used in JavaScript: the error first callback.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两行中显示的`null`输出对应于JavaScript中广泛使用的模式：错误回调优先。
- en: 'Let''s explain it with a code example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个代码示例来解释一下：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous code rewrites the first invocation to Seneca with a more appropriate
    approach. Instead of dumping everything into the console, process the response
    from Seneca, which is a callback where the first parameter is the error, if one
    happened (`null` otherwise), and the second parameter is the data coming back
    from the microservice. This is why, in the first example, `null` was the first
    output into the console.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码重写了对Seneca的第一次调用，采用了更合适的方法。而不是将所有内容转储到控制台，处理来自Seneca的响应，这是一个回调，第一个参数是错误（如果有的话是`null`），第二个参数是来自微服务的数据。这就是为什么在第一个例子中，`null`是第一个输出到控制台的原因。
- en: In the world of Node.js, it is very common to use callbacks. Callbacks are a
    way of indicating to the program that something has happened, without being blocked
    until the result is ready to be processed. Seneca is not an exception to this.
    It relies heavily on callbacks to process the response to service calls, which
    makes more sense when you think about microservices being deployed in different
    machines (in the previous example, everything runs in the same machine), especially
    because the network latency can be something to factor into the design of your
    software.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js世界中，使用回调是非常常见的。回调是一种指示程序发生了某事的方式，而不会被阻塞，直到结果准备好被处理。Seneca也不例外。它严重依赖回调来处理对服务调用的响应，特别是当您考虑到微服务部署在不同的机器上时（在前面的例子中，一切都在同一台机器上运行），尤其是因为网络延迟可能是需要考虑到软件设计的因素。
- en: Inversion of control done right
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确的控制反转
- en: Inversion of control is a must in modern software. It comes together with the
    dependency injection.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件中，控制反转是必不可少的。它与依赖注入一起使用。
- en: Inversion of control can be defined as *a technique to delegate the creation
    or call of components and methods so that your module does not need to know how
    to build the dependencies, which usually, are obtained through the dependency
    injection*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转可以被定义为*一种委托创建或调用组件和方法的技术，使得您的模块不需要知道如何构建依赖关系，通常通过依赖注入获得*。
- en: Seneca does not really make use of the dependency injection, but it is the perfect
    example of inversion of control.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca实际上并没有使用依赖注入，但它是控制反转的完美例子。
- en: 'Let''s take a look at the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the most basic Seneca example. From enterprise software''s point of
    view, we can differentiate two components here: a producer (`Seneca.add()`) and
    a consumer (`Seneca.act()`). As mentioned earlier, Seneca does not have a dependency
    injection system as is, but Seneca is gracefully built around the inversion of
    control principle.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最基本的Seneca示例。从企业软件的角度来看，我们可以区分两个组件：一个生产者（`Seneca.add()`）和一个消费者（`Seneca.act()`）。如前所述，Seneca并没有像现在这样的依赖注入系统，但Seneca是围绕控制反转原则优雅构建的。
- en: In the `Seneca.act()` function, we don't explicitly call the component that
    holds the business logic; instead of that, we ask Seneca to resolve the component
    for us through the use of an interface, in this case, a JSON message. This is
    inversion of control.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Seneca.act()`函数中，我们不显式调用持有业务逻辑的组件；而是通过接口向Seneca询问解析组件，这里是一个JSON消息。这就是控制反转。
- en: 'Seneca is quite flexible around it: no keywords (except for integrations) and
    no mandatory fields. It just has a combination of keywords and values that are
    used by a pattern matching engine called **Patrun**.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca在这方面非常灵活：没有关键字（除了集成）和没有强制字段。它只是具有一组关键字和值，这些关键字和值由称为**Patrun**的模式匹配引擎使用。
- en: Pattern matching in Seneca
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Seneca中的模式匹配
- en: Pattern matching is one of the most flexible software patterns that you can
    use for microservices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是您可以用于微服务的最灵活的软件模式之一。
- en: 'As opposed to network addresses or messages, patterns are fairly easy to extend.
    Let''s explain it with the help of the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络地址或消息相反，模式相当容易扩展。让我们通过以下例子来解释一下：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is a service that counts the number of words in a sentence. As we have seen
    before, in the first line, we add the handler for the `wordcount` command, and
    in the second one, we send a request to Seneca to count the number of words in
    a phrase.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个统计句子中单词数量的服务。正如我们之前所见，在第一行中，我们为`wordcount`命令添加了处理程序，在第二行中，我们向Seneca发送了一个请求，以统计短语中的单词数量。
- en: 'If you execute it, you should get something similar to the following image:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行它，您应该会得到类似以下图像的结果：
- en: '![Pattern matching in Seneca](img/B04889_02_04.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Seneca中的模式匹配](img/B04889_02_04.jpg)'
- en: By now, you should be able to understand how it works and even make some modifications
    to it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够理解它是如何工作的，甚至对其进行一些修改。
- en: 'Let''s extend the pattern. Now, we want to skip the short words, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展这个模式。现在，我们想要跳过短单词，如下所示：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we have added another handler for the `wordcount` command with
    an extra `skipShort` parameter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为`wordcount`命令添加了另一个处理程序，带有额外的`skipShort`参数。
- en: 'This handler now skips all the words with three or fewer characters. If you
    execute the preceding code, the output is similar to the following image:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序现在跳过所有三个或更少字符的单词。如果您执行前面的代码，输出将类似于以下图像：
- en: '![Pattern matching in Seneca](img/B04889_02_05.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Seneca中的模式匹配](img/B04889_02_05.jpg)'
- en: 'The first line, `{words: 5}`, corresponds to the first act call. The second
    line, `{words: 4}`, corresponds to the second call.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行`{words: 5}`对应于第一个act调用。第二行`{words: 4}`对应于第二个调用。'
- en: Patrun – a pattern-matching library
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Patrun-一个模式匹配库
- en: Patrun is also written by Richard Rodger. It is used by Seneca in order to execute
    the pattern matching and decide which service should respond to the call.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Patrun也是由Richard Rodger编写的。它被Seneca用来执行模式匹配，并决定哪个服务应该响应调用。
- en: 'Patrun uses a **closest** **match** approach to resolve the calls. Let''s see
    the following example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Patrun使用**最接近** **匹配**方法来解决调用。让我们看看以下例子：
- en: '![Patrun – a pattern-matching library](img/B04889_02_06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Patrun-一个模式匹配库](img/B04889_02_06.jpg)'
- en: In the preceding image, we can see three patterns. These are equivalent to `seneca.add()`
    from the example in the previous section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到三种模式。这些等同于前一节示例中的`seneca.add()`。
- en: 'In this case, we are registering three different combinations of *x* and *y*
    variables. Now, let''s see how Patrun does the matching:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们注册了三种不同的*x*和*y*变量的组合。现在，让我们看看Patrun如何进行匹配：
- en: '`{x: 1} ->A`: This matches 100% with **A**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{x: 1} ->A`：这与**A**完全匹配'
- en: '`{x: 2} ->`: No match'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{x: 2} ->`：无匹配'
- en: '`{x:1, y:1} -> B`: 100% match with **B**; it also matches with **A**, but **B**
    is a better match—two out of two vs one out of one'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{x:1, y:1} -> B`：与**B**完全匹配；它也与**A**匹配，但**B**是更好的匹配——两对两对对一对一'
- en: '`{x:1, y:2} -> C`: 100% match with **C**; again, it also matches with **A**,
    but **C** is more concrete'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{x:1, y:2} -> C`：与**C**完全匹配；同样，它也与**A**匹配，但**C**更具体'
- en: '`{y: 1} ->`: No match'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{y: 1} ->`：无匹配'
- en: As you can see, Patrun (and Seneca) will always get the longest match. In this
    way, we can easily extend the functionality of the more abstract patterns by concreting
    the matching.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Patrun（和Seneca）总是会得到最长的匹配。这样，我们可以通过具体化匹配轻松扩展更抽象模式的功能。
- en: Reusing patterns
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重用模式
- en: In the preceding example, in order to skip the words with fewer than three characters,
    we don't reuse the word count function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，为了跳过少于三个字符的单词，我们不重用单词计数函数。
- en: In this case, it is quite hard to reuse the function as is; although the problem
    sounds very similar, the solution barely overlaps.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，很难按原样重用函数；尽管问题听起来非常相似，但解决方案几乎没有重叠。
- en: 'However, let''s go back to the example where we add two numbers:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们回到我们添加两个数字的例子：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the code has changed a bit. Now, the pattern that accepts an
    integer relies on the base pattern to calculate the sum of the numbers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码有些变化。现在，接受整数的模式依赖于基本模式来计算数字的总和。
- en: 'Patrun always tries to match the closest and most concrete pattern that it
    can find with the following two dimensions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Patrun总是试图匹配最接近和最具体的模式，它可以找到以下两个维度：
- en: The longest chain of matches
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最长的匹配链
- en: The order of the patterns
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式的顺序
- en: It will always try to find the best fit, and if there is an ambiguity, it will
    match the first pattern found.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它将始终尝试找到最佳匹配，如果存在歧义，它将匹配找到的第一个模式。
- en: In this way, we can rely on already-existing patterns to build new services.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以依赖已经存在的模式来构建新的服务。
- en: Writing plugins
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写插件
- en: Plugins are an important part of applications based on Seneca. As we discussed
    in [Chapter 1](ch01.html "Chapter 1. Microservices Architecture"), *Microservices
    Architecture*, the API aggregation is the perfect way of building applications.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是基于Seneca的应用程序的重要部分。正如我们在[第1章](ch01.html "第1章 微服务架构")中讨论的那样，API聚合是构建应用程序的完美方式。
- en: 'Node.js'' most popular frameworks are built around this concept: small pieces
    of software that are combined to create a bigger system.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js最流行的框架都是围绕这个概念构建的：小软件片段组合在一起，创建一个更大的系统。
- en: Seneca is also built around this; `Seneca.add()` principle adds a new piece
    to the puzzle so that the final API is a mixture of different small software pieces.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 塞内卡也是围绕这一点构建的；`Seneca.add()`原则向拼图添加一个新的部分，以便最终的API是不同小软件部分的混合体。
- en: Seneca goes one step further and implements an interesting plugin system so
    that the common functionality can be modularized and abstracted into reusable
    components.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 塞内卡更进一步，实现了一个有趣的插件系统，以便将常见功能模块化并抽象为可重用的组件。
- en: 'The following example is the minimal Seneca plugin:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是最小的Seneca插件：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Write the code into a `minimal-plugin.js` file and execute it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码写入`minimal-plugin.js`文件并执行它：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of this execution should be something similar to the following image:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个执行的输出应该类似于以下图像：
- en: '![Writing plugins](img/B04889_02_20.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![编写插件](img/B04889_02_20.jpg)'
- en: 'In Seneca, a plugin is loaded at the startup, but we don''t see it as the default
    log level is INFO. This means that Seneca won''t show any DEBUG level info. In
    order to see what Seneca is doing, we need to get more information, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Seneca中，插件在启动时加载，但我们看不到它，因为默认的日志级别是INFO。这意味着Seneca不会显示任何DEBUG级别的信息。为了查看Seneca在做什么，我们需要获取更多信息，如下所示：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This produces a huge output. This is pretty much everything that is happening
    inside Seneca, which can be very useful to debug complicated situations, but in
    this case, what we want to do is show a list of plugins:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生大量输出。这几乎是Seneca内部发生的一切，这对于调试复杂的情况非常有用，但在这种情况下，我们想要做的是显示插件列表：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It will produce something similar to the following image:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它会产生类似于以下图像的东西：
- en: '![Writing plugins](img/B04889_02_21.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![编写插件](img/B04889_02_21.jpg)'
- en: 'Let''s analyze the preceding output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的输出：
- en: '`basic`: This plugin is included with the main Seneca module and provides a
    small set of basic utility action patterns.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basic`：这个插件包含在主Seneca模块中，并提供一小组基本实用程序动作模式。'
- en: '`transport`: This is the transport plugin. Up until now, we have only executed
    different services (quite small and concise) on the same machine, but what if
    we want to distribute them? This plugin will help us with that, and we will see
    how to do so in the following sections.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transport`：这是传输插件。到目前为止，我们只在同一台机器上执行了不同的服务（相当小而简洁），但如果我们想要分发它们呢？这个插件将帮助我们做到这一点，我们将在接下来的章节中看到如何做到这一点。'
- en: '`web`: In [Chapter 1](ch01.html "Chapter 1. Microservices Architecture"), *Microservices
    Architecture*, we mentioned that the microservices should advocate to keep the
    pipes that connect them under a standard that is widely used. Seneca uses TCP
    by default, but creating a RESTful API can be tricky. This plugin helps to do
    it, and we will see how to do this in the following section.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web`：在[第1章](ch01.html "第1章 微服务架构")中，我们提到微服务应该倡导将连接它们的管道保持在广泛使用的标准下。Seneca默认使用TCP，但创建RESTful
    API可能会很棘手。这个插件有助于做到这一点，我们将在下一节中看到如何做到这一点。'
- en: '`mem-store`: Seneca comes with a data abstraction layer so that we can handle
    the data storage in different places: Mongo, SQL databases, and so on. Out of
    the box, Seneca provides an in-memory storage so that it just works.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem-store`：Seneca带有一个数据抽象层，以便我们可以在不同的地方处理数据存储：Mongo、SQL数据库等等。Seneca提供了一个内存存储，因此它可以直接使用。'
- en: '`minimal_plugin`: This is our plugin. So, now we know that Seneca is able to
    load it.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minimal_plugin`：这是我们的插件。所以，现在我们知道Seneca能够加载它。'
- en: 'The plugin we wrote does nothing. Now, it is time to write something useful:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的插件什么也没做。现在是时候写一些有用的东西了：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First of all, notice that in the last instruction, `act()` follows a different
    format. Instead of passing a dictionary, we pass a string with the same key values
    as the first argument, as we did with a dictionary. There is nothing wrong with
    it, but my preferred approach is to use the JSON objects (dictionaries), as it
    is a way of structuring the data without having syntax problems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意在最后一条指令中，`act()`遵循不同的格式。我们不是传递一个字典，而是传递一个带有与第一个参数相同键值的字符串，就像我们用字典一样。这样做没有问题，但我更喜欢使用JSON对象（字典），因为这是一种在没有语法问题的情况下构造数据的方式。
- en: 'In the previous example, we can see how the code got structured as a plugin.
    If we execute it, we can see that the output is similar to the following one:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到代码是如何被构造为一个插件的。如果我们执行它，我们可以看到输出与下面的类似：
- en: '![Writing plugins](img/B04889_02_22.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![编写插件](img/B04889_02_22.jpg)'
- en: One of the things you need to be careful about in Seneca is how to initialize
    your plugins. The function that wraps the plugin (in the preceding example, the
    `math()` function) is executed synchronously by design and it is called the **definition
    function**. If you remember from the previous chapter, Node.js apps are single-threaded.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在Seneca中，您需要小心如何初始化您的插件。包装插件的函数（在前面的例子中是`math()`函数）是按设计同步执行的，并且被称为**定义函数**。如果您还记得前一章，Node.js应用程序是单线程的。
- en: To initialize a plugin, you add a special `init()` action pattern. This action
    pattern is called in sequence for each plugin. The `init()` function must call
    its respond callback without errors. If the plugin initialization fails, then
    Seneca exits the Node.js process. You want your microservices to fail fast (and
    scream loudly) when there's a problem. All plugins must complete initialization
    before any actions are executed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化一个插件，您需要添加一个特殊的`init()`动作模式。这个动作模式按顺序为每个插件调用。`init()`函数必须在没有错误的情况下调用其响应回调。如果插件初始化失败，那么Seneca将退出Node.js进程。当出现问题时，您希望您的微服务能够快速失败（并大声尖叫）。所有插件必须在执行任何操作之前完成初始化。
- en: 'Let''s see an example of how to initialize a plugin in the following way:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何以以下方式初始化插件的例子：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, after executing this file, the output should look very similar to the
    following image:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在执行此文件之后，输出应该看起来与以下图像非常相似：
- en: '![Writing plugins](img/B04889_02_23.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![编写插件](img/B04889_02_23.jpg)'
- en: As you can read from the output, the function that initializes the plugin was
    called.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，初始化插件的函数被调用了。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The general rule in Node.js apps is to never block the thread. If you find yourself
    blocking the thread, you might need to rethink how to avoid it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js应用程序中的一般规则是永远不要阻塞线程。如果发现自己阻塞线程，可能需要重新考虑如何避免它。
- en: Web server integration
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web服务器集成
- en: In [Chapter 1](ch01.html "Chapter 1. Microservices Architecture"), *Microservices
    Architecture*, we put a special emphasis on using standard technologies to communicate
    with your microservices.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。微服务架构")中，*微服务架构*，我们特别强调使用标准技术与您的微服务进行通信。
- en: Seneca, by default, uses a TCP transport layer that, although it uses TCP, is
    not easy to interact with, as the criteria to decide the method that gets executed
    is based on a payload sent from the client.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca默认使用TCP传输层，尽管它使用TCP，但与之交互并不容易，因为决定执行的方法的标准是基于从客户端发送的有效负载。
- en: 'Let''s dive into the most common use case: your service is called by JavaScript
    on a browser. Although it can be done, it would be much easier if Seneca exposed
    a REST API instead of the JSON dialog, which is perfect for communication between
    microservices (unless you have ultra-low latency requirements).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨最常见的用例：你的服务是由浏览器上的JavaScript调用的。虽然可以做到，但如果Seneca暴露了REST API而不是JSON对话，将会更容易得多，这对于微服务之间的通信是完美的（除非你有超低延迟的要求）。
- en: Seneca is not a web framework. It can be defined as a *general purpose microservices
    framework*, so it would not make too much sense to build it around a concrete
    case like the one exposed before.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca不是一个Web框架。它可以被定义为*通用微服务框架*，因此围绕像之前暴露的具体案例构建它并没有太多意义。
- en: Instead of that, Seneca was built in a way that makes the integration with other
    frameworks fairly easy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Seneca是以一种使其与其他框架集成相当容易的方式构建的。
- en: '**Express** is the first option when building web applications on Node.js.
    The amount of examples and documentation that can be found on Internet about Express
    makes the task of learning it fairly easy.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express**是在Node.js上构建Web应用程序时的首选。关于Express的示例和文档的数量使得学习它的任务相当容易。'
- en: Seneca as Express middleware
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Seneca作为Express中间件
- en: Express was also built under the principle of API composition. Every piece of
    software in Express is called middleware, and they are chained in the code in
    order to process every request.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Express也是根据API组合原则构建的。Express中的每个软件都被称为中间件，并且它们在代码中被链接在一起以处理每个请求。
- en: In this case, we are going to use **seneca-web** as a middleware for Express
    so that once we specify the configuration, all the URLs will follow a naming convention.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用**seneca-web**作为Express的中间件，这样一旦我们指定配置，所有的URL都将遵循命名约定。
- en: 'Let''s consider the following example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下例子：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code is not as easy to understand as the previous examples, but I''ll
    do my best to explain it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不像前面的例子那么容易理解，但我会尽力解释：
- en: The second line adds a pattern to Seneca. We are pretty familiar with it as
    all the examples on this book do that.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行将一个模式添加到Seneca。我们对此非常熟悉，因为本书中的所有示例都这样做。
- en: The third instruction, `seneca.act()`, is where the magic happens. We are mounting
    the patterns with the `role:api` pattern and any cmd pattern (`cmd:*`) to react
    to URLs under `/my-api`. In this example, the first `seneca.add()` will reply
    to the URL `/my-api/bazinga`, as `/my-api/` is specified by the `prefix` variable
    and `bazinga` by the `cmd` part of the `seneca.add()` command.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三条指令`seneca.act()`是魔法发生的地方。我们正在将模式与`role:api`模式和任何cmd模式（`cmd:*`）挂载到`/my-api`下的URL上。在这个例子中，第一个`seneca.add()`将回复URL`/my-api/bazinga`，因为`prefix`变量指定了`/my-api/`，而`seneca.add()`命令的`cmd`部分指定了`bazinga`。
- en: '`app.use(seneca.export(''web''))` instructs Express to use seneca-web as middleware
    to execute actions based on the configuration rules.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.use(seneca.export(''web''))`指示Express使用seneca-web作为中间件，根据配置规则执行操作。'
- en: '`app.listen(3000)` binds the port `3000` to Express.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.listen(3000)`将端口`3000`绑定到Express。'
- en: If you remember from an earlier section in this chapter, `seneca.act()` takes
    a function as a second parameter. In this case, we are exposing configuration
    to be used by Express on how to map the incoming requests to Seneca actions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得本章早些时候的部分，`seneca.act()`将一个函数作为第二个参数。在这种情况下，我们正在向Express公开配置，以便用于将传入请求映射到Seneca操作的方式。
- en: 'Let''s test it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: '![Seneca as Express middleware](img/B04889_02_07.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![Seneca作为Express中间件](img/B04889_02_07.jpg)'
- en: 'The preceding code is pretty dense, so let''s explain it down to the code from
    the browser:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常密集，所以让我们将其解释为来自浏览器的代码：
- en: Express receives a request that is handled by seneca-web.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express接收到一个请求，由seneca-web处理。
- en: 'The seneca-web plugin was configured to use `/my-api/` as a prefix, which is
    being bound with the keyword `pin` (refer to `seneca.act()` from the preceding
    code) to Seneca actions (`seneca.add()`) that contain the `role:api` pattern,
    plus any cmd pattern (`cmd:*`). In this case, `/my-api/bazinga` corresponds to
    the first (and only) `seneca.add()` command with the `{role: ''api'', cmd: ''bazinga''}`
    pattern.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'seneca-web插件配置为使用`/my-api/`作为前缀，该前缀与包含`role:api`模式以及任何cmd模式（`cmd:*`）的Seneca操作（`seneca.add()`）绑定在一起。在这种情况下，`/my-api/bazinga`对应于第一个（也是唯一的）带有`{role:
    ''api'', cmd: ''bazinga''}`模式的`seneca.add()`命令。'
- en: It takes a while to fully understand the integration between Seneca and Express,
    but once it is clear, the flexibility offered by the API composability pattern
    is limitless.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 完全理解Seneca和Express之间的集成需要一些时间，但一旦清楚，API组合模式提供的灵活性是无限的。
- en: Express itself is big enough to be out of the scope of this book, but it is
    worth taking a look as it is a very popular framework.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Express本身已经足够庞大，超出了本书的范围，但值得一看，因为它是一个非常流行的框架。
- en: Data storage
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据存储
- en: Seneca comes with a data-abstraction layer that allows you to interact with
    the data of your application in a generic way.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca带有一个数据抽象层，允许您以通用方式与应用程序的数据进行交互。
- en: By default, Seneca comes with an in-memory plugin (as explained in the previous
    section), therefore, it works out of the box.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Seneca带有一个内存插件（如前一节所述），因此它可以直接使用。
- en: We are going to be using it for the majority of this book, as the different
    storage systems are completely out of scope and Seneca abstracts us from them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大部分时间里，我们将使用它，因为不同的存储系统完全超出了范围，而Seneca将我们从中抽象出来。
- en: 'Seneca provides a simple data abstraction layer (**Object-relational mapping**
    (**ORM**)) based on the following operations:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca提供了一个简单的数据抽象层（基于以下操作的对象关系映射（ORM））：
- en: '**load**: This loads an entity by identifier'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载**：通过标识符加载实体'
- en: '**save**: This creates or updates (if you provide an identifier) an entity'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存**：创建或更新（如果提供标识符）实体'
- en: '**list**: This lists entities matching a simple query'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：列出与简单查询匹配的实体'
- en: '**remove**: This deletes an entity by an identifier'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：通过标识符删除实体'
- en: 'Let''s build a plugin that manages employees in the database:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个管理数据库中员工的插件：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that the database is, by default, in memory, so we don't need to worry
    about the table structure for now.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认情况下，数据库是在内存中的，所以我们现在不需要担心表结构。
- en: The first command adds an employee to the database. The second command recovers
    an employee from the database by `id`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令将员工添加到数据库。第二条命令通过`id`从数据库中恢复员工。
- en: Note that all the ORM primitives in Seneca end up with the dollar symbol (`$`).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Seneca中的所有ORM原语最终都以美元符号（`$`）结尾。
- en: As you can see now, we have been abstracted from the data storage details. If
    the application changes in the future and we decide to use MongoDB as a data storage
    instead of an in-memory storage, the only thing we need to take care of is the
    plugin that deals with MongoDB.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到，我们已经从数据存储的细节中抽象出来。如果应用程序在将来发生变化，并且我们决定使用MongoDB作为数据存储而不是内存存储，我们唯一需要处理的就是处理MongoDB的插件。
- en: 'Let''s use our employee management plugin, as shown in the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的员工管理插件，如下所示：
- en: '[PRE28]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, we add an employee to the in-memory database by invoking
    the pattern exposed in the plugin.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过调用插件中暴露的模式向内存数据库添加了一个员工。
- en: Along the book, we will see different examples about how to use the data abstraction
    layer, but the main focus will be on how to build microservices and not how to
    deal with the different data storages.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将看到关于如何使用数据抽象层的不同示例，但主要重点将放在如何构建微服务上，而不是如何处理不同的数据存储上。
- en: PM2 – a task runner for Node.js
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PM2 - 用于Node.js的任务运行器
- en: '**PM2** is a production-process manager that helps to scale the Node.js up
    or down, as well as load balance the instances of the server. It also ensures
    that the processes are running constantly, tackling down one of the side effects
    of the thread model of Node.js: an uncaught exception kills the thread, which
    in turn kills your application.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**PM2**是一个生产进程管理器，可以帮助扩展或缩小Node.js，以及负载均衡服务器的实例。它还确保进程一直在运行，解决了Node.js线程模型的一个副作用：未捕获的异常会终止线程，从而导致应用程序崩溃。'
- en: Single-threaded applications and exceptions
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单线程应用程序和异常
- en: As you learned before, Node.js applications are run in a single thread. This
    doesn't mean that Node.js is not concurrent, it only means that your application
    runs on a single thread, but everything else runs parallel.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您之前学到的，Node.js应用程序在单个线程中运行。这并不意味着Node.js不是并发的，它只是意味着您的应用程序在单个线程上运行，但其他所有内容都是并行运行的。
- en: 'This has an implication: *if an exception bubbles out without being handled,
    your application dies*.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：*如果异常未经处理就冒出来，您的应用程序将死掉*。
- en: The solution for this is making an intensive use of promises libraries such
    as **bluebird**; it adds handlers for success and failures so that if there is
    an error, the exception does not bubble out, killing your app.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是大量使用promise库，比如**bluebird**；它添加了成功和失败的处理程序，这样如果出现错误，异常就不会冒出来，导致应用程序崩溃。
- en: 'However, there are some situations that we can''t control, *we call them unrecoverable
    errors or bugs*. Eventually, your application will die due to a badly handled
    error. In languages such as Java, an exception is not a huge deal: the thread
    dies, but the application continues working.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些情况是我们无法控制的，*我们称之为不可恢复的错误或错误*。最终，由于错误处理不当，您的应用程序将死掉。在诸如Java之类的语言中，异常并不是一个大问题：线程死掉了，但应用程序继续工作。
- en: In Node.js, it is a big problem. This problem was solved in the first instance
    using task runners such as **forever**.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，这是一个大问题。这个问题最初是使用**forever**等任务运行器解决的。
- en: Both of them are task runners that, when your application exits for some reason,
    rerun it again so it ensures the uptime.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是任务运行器，当您的应用程序因某种原因退出时，它们会重新运行它，以确保运行时间。
- en: 'Consider the following example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '![Single-threaded applications and exceptions](img/B04889_02_08.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![单线程应用程序和异常](img/B04889_02_08.jpg)'
- en: 'The `helloWorld.js` application is now handled by forever, which will rerun
    it if the application dies. Let''s kill it, as shown in the following image:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`helloWorld.js`应用程序现在由forever处理，如果应用程序死掉，它将重新运行。让我们杀死它，如下图所示：'
- en: '![Single-threaded applications and exceptions](img/B04889_02_09.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![单线程应用程序和异常](img/B04889_02_09.jpg)'
- en: 'As you can see, forever has spawned a different process with the `4903` PID.
    Now, we issue a kill command (`kill -9 4093`) and that is the output from forever,
    as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，forever已经生成了一个带有`4903` PID的不同进程。现在，我们发出一个kill命令（`kill -9 4093`），这是forever的输出如下：
- en: '![Single-threaded applications and exceptions](img/B04889_02_10.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![单线程应用程序和异常](img/B04889_02_10.jpg)'
- en: Although we have killed it, our application was respawned by forever without
    any downtime (at least, noticeable downtime).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经杀死了它，但我们的应用程序被forever重新启动，没有任何停机时间（至少没有明显的停机时间）。
- en: 'As you can see, forever is pretty basic: it reruns the application as many
    times as it gets killed.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，forever非常基础：它会重新运行应用程序，直到被杀死为止。
- en: 'There is another package called **nodemon**, which is one of the most useful
    tools for developing Node.js applications. It reloads the application if it detects
    changes in the files that it monitors (by default, `*.*`):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个叫做**nodemon**的包，它是开发Node.js应用程序最有用的工具之一。如果它检测到监视的文件发生变化（默认情况下是`*.*`），它会重新加载应用程序：
- en: '![Single-threaded applications and exceptions](img/B04889_02_11.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![单线程应用程序和异常](img/B04889_02_11.jpg)'
- en: Now, if we modify the `helloWorld.js` file, we can see how nodemon reloads the
    application. This is very interesting in order to avoid the edit/reload cycle
    and speed up the development.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们修改`helloWorld.js`文件，我们可以看到nodemon如何重新加载应用程序。这对于避免编辑/重新加载循环并加快开发速度非常有趣。
- en: Using PM2 – the industry-standard task runner
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PM2-行业标准任务运行器
- en: Although, forever looks very interesting, PM2 is a more advanced task runner
    than forever. With PM2, you can completely manage your application life cycle
    without any downtime, as well as scale your application up or down with a simple
    command.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管forever看起来非常有趣，但PM2比forever更先进。使用PM2，您可以完全管理应用程序的生命周期，而无需任何停机时间，还可以通过简单的命令扩展或缩小应用程序。
- en: PM2 also acts as a load balancer.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: PM2还充当负载均衡器。
- en: 'Let''s consider the following example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下例子：
- en: '[PRE29]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is a fairly simple application. Let''s run it using PM2:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的应用程序。让我们使用PM2运行它：
- en: '[PRE30]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This produces an output similar to the following image:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生类似以下图像的输出：
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_12.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2-行业标准任务运行器](img/B04889_02_12.jpg)'
- en: PM2 has registered an app named `helloWorld`. This app is running in the `fork`
    mode (that means, PM2 is not acting as a load balancer, it has just forked the
    app) and the PID of the operating system is `6858`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: PM2已注册了一个名为`helloWorld`的应用程序。该应用程序以`fork`模式运行（这意味着PM2不是负载均衡器，它只是分叉了应用程序），操作系统的PID为`6858`。
- en: 'Now, as the following screen suggests, we will run `pm2 show 0`, which shows
    the information relevant to the app with `id 0`, as shown in the following image:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如下图所示，我们将运行`pm2 show 0`，显示与`id 0`相关的应用程序的信息，如下图所示：
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_13.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2-行业标准任务运行器](img/B04889_02_13.jpg)'
- en: With two commands, we have managed to run a simple application in a very sophisticated
    way.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个命令，我们已经成功以非常复杂的方式运行了一个简单的应用程序。
- en: From now on, PM2 will ensure that your app is always running so that if your
    application dies, PM2 will restart it again.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，PM2将确保您的应用程序始终运行，因此如果您的应用程序死掉，PM2将再次启动它。
- en: 'We can also monitor the number of apps PM2 is running:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以监视PM2正在运行的应用程序数量：
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This shows the following output:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了以下输出：
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_14.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2-行业标准任务运行器](img/B04889_02_14.jpg)'
- en: This is the PM2 monitor. In this case, it is a complete overkill as our system
    is only composed of one application, which runs in the fork mode.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是PM2监视器。在这种情况下，这完全是一种过度杀伤，因为我们的系统只由一个应用程序组成，它在分叉模式下运行。
- en: 'We can also see the logs executing `pm2 logs` as shown in the following image:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过执行`pm2 logs`来查看日志，如下图所示：
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_15.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2-行业标准任务运行器](img/B04889_02_15.jpg)'
- en: As you can see, PM2 feels solid. With few commands, we have covered 90% of the
    monitoring necessities of our application. However, this is not everything.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，PM2非常可靠。通过少量命令，我们已经涵盖了应用程序监控的90%的需求。然而，这还不是全部。
- en: 'PM2 also comes with an easy way to reload your applications without downtime:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: PM2还提供了一种简单的方法，在不间断的情况下重新加载您的应用程序：
- en: '[PRE32]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This command ensures that your apps are restarted with zero downtime. PM2 will
    queue the incoming requests for you and reprocess them once your app is responsive
    again. There is a more fine-grained option where you can specify reloading only
    certain apps by specifying the app name:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令确保您的应用程序在零停机时间内重新启动。PM2将为您排队的传入请求，并在您的应用程序再次响应时重新处理它们。还有一个更精细的选项，您可以通过指定应用程序名称来指定仅重新加载某些应用程序：
- en: '[PRE33]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For those who have been fighting for years with Apache, NGINX, PHP-FPM, and
    so on, this will sound very familiar.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些多年来一直在与Apache、NGINX、PHP-FPM等作斗争的人来说，这听起来非常熟悉。
- en: Another interesting feature in PM2 is running your application in the cluster
    mode. In this mode, PM2 spawns a controller process and as many workers (your
    app) as you specify so that you can take the benefit of multicore CPUs with a
    single-thread technology such as Node.js.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: PM2中的另一个有趣功能是在集群模式下运行应用程序。在这种模式下，PM2会生成一个控制器进程和您指定的许多工作进程（您的应用程序），以便您可以利用单线程技术（如Node.js）的多核CPU的好处。
- en: 'Before doing this, we need to stop our running application:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作之前，我们需要停止正在运行的应用程序：
- en: '[PRE34]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will result in the following output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_16.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2-行业标准任务运行器](img/B04889_02_16.jpg)'
- en: 'PM2 remembers the apps that were running, so before rerunning the app in the
    cluster mode, we need to inform PM2 to forget about your app, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: PM2会记住正在运行的应用程序，因此在集群模式下重新运行应用程序之前，我们需要通知PM2忘记您的应用程序，如下所示：
- en: '[PRE35]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_17.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2-行业标准任务运行器](img/B04889_02_17.jpg)'
- en: 'We are ready to run our app in the cluster mode:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好在集群模式下运行我们的应用程序：
- en: '[PRE36]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_18.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2-行业标准任务运行器](img/B04889_02_18.jpg)'
- en: 'PM2 is acting as a round-robin between the main process and the three workers
    so that they can cope with three requests at the same time. We can also scale
    down or up our number of workers:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: PM2在主进程和三个工作进程之间循环运行，以便它们可以同时处理三个请求。我们还可以缩减或增加我们的工作进程数量：
- en: '[PRE37]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will result in two processes being run for the same app instead of three:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致运行相同应用程序的两个进程，而不是三个：
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_24.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![使用PM2-行业标准任务运行器](img/B04889_02_24.jpg)'
- en: As you can see, with very little effort, we have managed to configure our app
    in order to be production ready.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们几乎没有费力就成功地配置了我们的应用程序，以便投入生产。
- en: Now, we can save the status of PM2 so that if we restart the server, and PM2
    is running as a daemon, the apps will automatically start.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以保存PM2的状态，以便如果重新启动服务器，并且PM2作为守护程序运行，应用程序将自动启动。
- en: PM2 has a code API so that we can write a Node.js program to manage all the
    steps that we have been manually doing. It also has a way of configuring your
    services with a JSON file. We will discuss this in more depth in [Chapter 6](ch06.html
    "Chapter 6. Testing and Documenting Node.js Microservices"), *Testing and Documenting
    Node.js Microservices*, when we study how to use PM2 and Docker to deploy Node.js
    applications.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: PM2具有代码API，因此我们可以编写一个Node.js程序来管理我们手动进行的所有步骤。它还可以通过JSON文件配置您的服务。当我们学习如何使用PM2和Docker部署Node.js应用程序时，我们将在[第6章](ch06.html
    "第6章。测试和记录Node.js微服务")中更深入地讨论这一点，*测试和记录Node.js微服务*。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the basics of Seneca and PM2 so that we will be
    able to build and run a microservices-oriented system in [Chapter 4](ch04.html
    "Chapter 4. Writing Your First Microservice in Node.js"), *Writing Your First
    Microservice in Node.js*, of this book.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了Seneca和PM2的基础知识，以便我们能够在本书的[第4章](ch04.html "第4章。在Node.js中编写您的第一个微服务")中构建和运行面向微服务的系统，*在Node.js中编写您的第一个微服务*。
- en: We have also demonstrated that a few of the concepts exposed in the previous
    chapter are actually helpful in solving real-world problems as well as making
    our life very easy.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还证明了上一章中提出的一些概念实际上有助于解决现实世界的问题，同时也使我们的生活变得非常容易。
- en: In the next chapter, we will talk about how to split a monolithic application,
    a task for which we will need to know a few of the concepts developed during this
    chapter.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何拆分单片应用程序，这需要我们了解本章开发的一些概念。
