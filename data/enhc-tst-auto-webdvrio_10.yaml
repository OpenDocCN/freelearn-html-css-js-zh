- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Increased Flexibility – Writing Robust Selectors and Reducing Maintenance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高灵活性 - 编写健壮的选择器和减少维护
- en: Maintenance is the ever-growing villain of a test automation project. Each release
    has more tests and more elements that can go stale, causing a test to fail. If
    you are new to the test automation field, you may not realize just how much maintenance
    will increasingly impact your project release after release. I (Paul) would like
    to share with you this story that inspired several unique solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 维护是测试自动化项目的永恒敌人。每个版本都包含更多的测试和可能过时的元素，导致测试失败。如果你是测试自动化领域的初学者，你可能没有意识到维护将如何越来越多地影响你的项目发布。我（保罗）想与你分享这个故事，它启发了几种独特的解决方案。
- en: Several years ago, my client’s development team decided to change the entire
    underlying architecture supporting the application under test. My automation team
    only became aware of this change when we found nearly all 100 of our test cases
    suite failed to reach a passing state. In fact, the only test case that passed
    was the `LogIn` test we wrote on the first day of the project. We realized that
    hundreds of element objects had changed their tag name to different types and
    used different properties. We were faced with the daunting task of rewriting hundreds
    of element selectors one by one. We estimated the rework of the page objects might
    take 2 days to be returned to a working state.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我的客户的开发团队决定改变测试应用所支持的整个底层架构。我们的自动化团队只有在发现我们近100个测试用例套件几乎全部失败时才意识到这个变化。事实上，唯一通过测试的是我们在项目第一天编写的
    `LogIn` 测试用例。我们意识到数百个元素对象已经将它们的标签名称更改为不同类型并使用了不同的属性。我们面临着一项艰巨的任务，即逐个重写数百个元素选择器。我们估计页面对象的重新工作可能需要2天才能恢复到工作状态。
- en: Add to this that the client had been used to receiving a detailed summary of
    the regression test suite results in under 2 hours, along with our smoke tests
    detecting issues within 15 minutes. We were faced with the task of explaining
    that release results would not be available for another 2 days or more. The manual
    team of six resources would likely complete their testing in that amount of time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 再加上客户已经习惯了在2小时内收到回归测试套件结果的详细总结，以及我们的烟雾测试在15分钟内检测到问题。我们面临解释发布结果将在另外2天或更长时间才可获得的任务。六个资源的手动团队可能需要那么长时间才能完成测试。
- en: My coworker set about the task of updating selectors in the page object tags.
    I had a different idea. From my analysis, I realized that just one element tag
    had changed. Many of the `<a>` link anchors were now `<button>` tags. Luckily,
    none of the strings used to locate elements had changed, they were just in different
    object properties. I proposed adding a thin layer to our framework that would
    search for alternate tag elements to the one that was no longer found.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我的同事开始着手更新页面对象标签中的选择器。我有一个不同的想法。通过我的分析，我发现只有一个元素标签发生了变化。许多 `<a>` 链接锚点现在变成了 `<button>`
    标签。幸运的是，用于定位元素的字符串没有变化，只是它们位于不同的对象属性中。我建议在我们的框架中添加一个薄层，以搜索不再找到的元素标签的替代标签。
- en: The code change was completed in under an hour. The number of test cases that
    were executed increased to 95% completion. Two test cases failed the release,
    and another three needed to be maintained by hand to get to a working state. This
    was in line with the maintenance work on the previous release iterations. Our
    client understood the challenge the architectural change presented, and she was
    overjoyed we could provide actionable results within 4 hours.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更改在一小时内完成。执行测试用例的数量增加到95%的完成度。两个测试用例在发布时失败，另外三个需要手动维护才能达到工作状态。这与之前发布迭代中的维护工作一致。我们的客户理解了架构变化带来的挑战，并且对我们能在4小时内提供可操作的结果感到非常高兴。
- en: 'On similar lines, we will cover the following main topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，本章将涵盖以下主要主题：
- en: Reducing page object maintenance with generic selectors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用选择器减少页面对象维护
- en: Anatomy of an XPath selector
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XPath 选择器的结构
- en: Leveraging `data-qa` and **Accessible Rich Internet Applications** (**ARIA**)
    attributes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `data-qa` 和 **可访问的富互联网应用** (**ARIA**) 属性
- en: Writing an XPath element that contains a textual substring
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写包含文本子串的 XPath 元素
- en: Second chances – getting valid objects from stale selector
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次机会 - 从过时的选择器获取有效对象
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All test examples can be found at this GitHub repository: [https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试示例都可以在这个 GitHub 仓库中找到：[https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO)
- en: Reducing page object maintenance with generic selectors
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用选择器减少页面对象维护
- en: Before we get into the advanced concepts of making our object flexible like
    plastic, let’s begin with several ways we can write better selectors. A robust
    selector is extremely important to reduce the maintenance of your test automation
    framework. We will move beyond exact matches to use substring matches to be sure
    that we can find an element even if it changes slightly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何使我们的对象像塑料一样灵活的先进概念之前，让我们先看看几种我们可以编写更好的选择器的方法。一个健壮的选择器对于减少你的测试自动化框架的维护至关重要。我们将超越精确匹配，使用子串匹配以确保我们可以在元素略有变化的情况下找到它。
- en: 'We begin with a simple question. Which is better—XPath or CSS? There is a common
    idea that CSS is the preferred method for writing a selector because it executes
    faster. While this may be true, the speed difference today is minimal. I would
    rather spend a few more milliseconds finding an element over the minutes spent
    repeatedly updating object selectors. In addition, CSS selectors are harder to
    write syntactically. Furthermore, CSS selectors are not as flexible when we need
    to find one element relative to another—for example, locating one of many generic
    `label` object:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的问题开始。XPath 和 CSS 哪个更好？有一种普遍的观点认为，CSS 是编写选择器的首选方法，因为它执行得更快。虽然这可能是对的，但今天的速度差异微乎其微。我宁愿花几毫秒找到元素，也不愿花几分钟重复更新对象选择器。此外，CSS
    选择器的语法编写更困难。而且，当我们需要根据另一个元素找到某个元素时，CSS 选择器不够灵活——例如，定位许多通用 `label` 对象中的一个：
- en: '![Figure 10.1 – A generic radio button relative to a Label element named “One”
    on the DOM](img/B19395_10_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 相对于 DOM 中名为“One”的 Label 元素的通用单选按钮](img/B19395_10_1.jpg)'
- en: Figure 10.1 – A generic radio button relative to a Label element named “One”
    on the DOM
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 相对于 DOM 中名为“One”的 Label 元素的通用单选按钮
- en: In the preceding example, there is no way to uniquely identify any of the radio
    buttons by their text. This is because the uniquely identifiable text is contained
    in a `Label` element relative to the **Span** **radio** button.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，没有方法可以唯一地通过文本识别任何单选按钮。这是因为唯一可识别的文本包含在相对于 **Span** **单选**按钮的 `Label`
    元素中。
- en: 'We must leverage the XPath axis of a parent and child element to uniquely locate
    these elements by relative location. We write a selector to the parent object
    that has the text `One`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须利用父元素和子元素的 XPath 轴，通过相对位置唯一地定位这些元素。我们为具有文本 `One` 的父对象编写一个选择器：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then follow it with the generic child radio button:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们跟随通用子单选按钮：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then combine them:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将它们结合起来：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That was an easy riddle to solve. But what if we have text that has extra spaces,
    forced carriage returns, or even a mix of quotes and single quotes, as in the
    following example? To solve issues such as this, we will take a deeper dive into
    more ways that we can locate and identify elements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个容易解决的问题。但如果我们有包含额外空格、强制换行符，甚至混合引号和单引号的文本怎么办？为了解决这类问题，我们将更深入地探讨更多我们可以定位和识别元素的方法：
- en: '![Figure 10.2 – Extra spaces, mixed single and double quotes, and embedded
    carriage returns](img/B19395_10_2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 额外的空格，混合单引号和双引号，以及嵌入的换行符](img/B19395_10_2.jpg)'
- en: Figure 10.2 – Extra spaces, mixed single and double quotes, and embedded carriage
    returns
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 额外的空格，混合单引号和双引号，以及嵌入的换行符
- en: Thus far, we have seen examples of XPath and CSS selectors. Let us take a moment
    to further explore the components to retrieve collections of elements in WebdriverIO.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 XPath 和 CSS 选择器的示例。让我们花点时间进一步探索 WebdriverIO 中检索元素集合的组件。
- en: Anatomy of an XPath selector
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XPath 选择器的结构
- en: Selectors are comprised of one or more node tag types followed by an optional
    `[predicate]` in square brackets. The predicates have operators and functions
    to filter certain node matches. Lastly, they include path separators with generic
    *axes* with double colons to further refine the path of the element. This makes
    it more likely to find an element regardless of its location in the DOM.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器由一个或多个节点标签类型组成，后面跟着方括号中的可选 `[谓词]`。谓词有运算符和函数来过滤特定的节点匹配。最后，它们包括路径分隔符，带有双冒号的通用
    *轴*，以进一步细化元素的路径。这使得无论元素在 DOM 中的位置如何，都更有可能找到该元素。
- en: 'XPath selectors are written as *absolute* or *relative*. This is an example
    of an absolute-style selector to the **Find My Candy** button on the *Candymapper*
    website:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: XPath选择器被编写为*绝对*或*相对*。这是一个指向*Candymapper*网站上**Find My Candy**按钮的绝对样式选择器的示例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that you have seen an absolute selector, use it only as a red flag. The
    point of this exercise is the fluid nature of the numeric indexes inside the square
    brackets. The exact location will be dynamic from release to release, causing
    endless maintenance. If you see a lot of selectors with this format in your code
    base, it is all but certain your selector is not robust. Furthermore, it is a
    devilish riddle for another developer to figure out the intended element since
    the text “Find My Candy” does not appear in the selector string. Let’s look for
    better ways to write selectors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了绝对选择器，只将其用作一个红旗。这个练习的目的是方括号内数字索引的流动性。确切的位置将随着版本的不同而动态变化，导致无尽的维护。如果你在代码库中看到很多这种格式的选择器，几乎可以肯定你的选择器不是健壮的。此外，对于其他开发者来说，这是一个难以解开的谜题，因为“Find
    My Candy”这个文本没有出现在选择器字符串中。让我们寻找更好的编写选择器的方法。
- en: Rule of thumb
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则
- en: Always take extra time to replace an absolute selector with a relative selector
    and use a descriptive element name. The `myElement` name in the preceding example
    is of no help and should be renamed `findMyCandy` or, better still, `btnFindMyCandy`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总是花额外的时间将绝对选择器替换为相对选择器，并使用描述性的元素名称。前一个示例中的`myElement`名称没有帮助，应该重命名为`findMyCandy`或更好，`btnFindMyCandy`。
- en: Relative selectors
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对选择器
- en: 'Most relative selectors begin with a double slash (`//`) followed by a single
    slash indicating the next element in the path. Let’s look at this in a bit more
    detail:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数相对选择器以双斜杠（`//`）开头，后面跟单斜杠，表示路径中的下一个元素。让我们更详细地看看这个：
- en: '`//` `//div` selects all `<div>` elements anywhere in the document.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//` `//div`选择文档中任何位置的`<div>`元素。'
- en: '`/` `/html/body/div` selects all `<div>` elements that are direct children
    of the `<body>` element inside the `<``html>` root.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` `/html/body/div`选择所有是`<html>`根内部`<body>`元素的直接子元素的`<div>`元素。'
- en: '`*` **(star)**: Denotes a wildcard match.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` **（星号）**：表示通配符匹配。'
- en: 'To start, we will get a collection of all the elements on the page using the
    `*` wildcard matcher for all node types:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`*`通配符匹配器获取页面上所有节点的集合：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Node test functions – text() versus normalize-space()
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点测试函数 – text() 与 normalize-space()
- en: 'Several of the element selector tags shown here, including anchors, buttons,
    and lists, can be matched with exact text using the `text()` Node test function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的几个元素选择器标签，包括锚点、按钮和列表，可以使用`text()`节点测试函数进行精确匹配：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is an easy sample, but what if there were some strange formatting embedded
    in the text?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，但如果文本中嵌入了一些奇怪的格式呢？
- en: Broken strings
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破碎的字符串
- en: 'There can be times when extraneous spaces or carriage returns make a selector
    match challenging. In such cases, it is recommended to use `normalize-space()`
    instead of `text()`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候多余的空格或换行符会使选择器匹配变得困难。在这种情况下，建议使用`normalize-space()`而不是`text()`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can check if this selector is valid with the `SelectorsHub` Chrome extension:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SelectorsHub` Chrome扩展程序来检查此选择器是否有效：
- en: '![Figure 10.3 – SelectorsHub indicates more than one element will match the
    selector](img/B19395_10_3.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – SelectorsHub显示多个元素将匹配该选择器](img/B19395_10_3.jpg)'
- en: Figure 10.3 – SelectorsHub indicates more than one element will match the selector
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – SelectorsHub显示多个元素将匹配该选择器
- en: 'The XPath selector is valid, but it matches four additional elements on the
    screen. Another way is to get the button element relative to the container page:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: XPath选择器是有效的，但它匹配屏幕上的四个额外元素。另一种方法是相对于容器页面获取按钮元素：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This element can be located with the parent class and converted to a CSS selector
    with a period (`.`) as a shortcut for a class name:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素可以通过父类定位，并使用点（`.`）作为类名的快捷方式转换为CSS选择器：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, we can perform a close match with a `popup` on the class name to
    find an anchor link child using the CSS containing a `*=` shortcut in this way:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过类名上的`popup`进行近似匹配，以找到使用这种方式的CSS包含`*=`快捷方式的锚点链接子元素：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also narrow down the parent element to a specific tag type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将父元素缩小到特定的标签类型：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are five common web page elements we will seek: links, buttons, lists,
    fields, and text elements.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将寻找五种常见的网页元素：链接、按钮、列表、字段和文本元素。
- en: 'Here are common ways to find these elements with an exact string as well as
    a substring match in XPath:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用精确字符串以及XPath中的子字符串匹配来查找这些元素的常见方法：
- en: 'Links:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Buttons:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lists (unordered and ordered):'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表（无序列表和有序列表）：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Fields and multiline text areas:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段和多行文本区域：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Text:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Leveraging data-qa and ARIA attributes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用data-qa和ARIA属性
- en: 'There have been two new developments in website design where developers can
    help SDETs maintain robust low-maintenance selectors. Consider this web page element
    snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站设计中，已经出现了两个新的发展，开发者可以帮助SDETs维护稳健且低维护的选取器。考虑以下网页元素片段：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This can be accomplished by adding the `data-qa` attribute, which is unique
    and static. Alternately, if the developer team follows the ARIA standard, many
    text elements can be identified by the `aria-label` attribute:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过添加唯一的静态`data-qa`属性来实现。或者，如果开发团队遵循ARIA标准，许多文本元素可以通过`aria-label`属性来识别：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is an example leveraging `data-qa` and ARIA attributes to ensure that
    your web application’s elements are accessible and interactable:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个利用`data-qa`和ARIA属性来确保您的Web应用程序元素可访问和可交互的例子：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the example, we have two test cases. The first one verifies that an element
    with a `data-qa` attribute has the correct ARIA role. The second test case checks
    the keyboard accessibility of an element with a specific ARIA label. This is just
    a basic example, and you can adapt it to your specific application’s needs to
    ensure that your elements are properly accessible and have the right attributes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个测试用例。第一个测试用例验证具有`data-qa`属性的元素是否具有正确的ARIA角色。第二个测试用例检查具有特定ARIA标签的元素的键盘可访问性。这只是一个基本示例，您可以根据您特定应用程序的需求进行修改，以确保您的元素正确可访问并且具有正确的属性。
- en: Rule of thumb – alternatives to CSS selectors
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 规则要点 – CSS选取器的替代方案
- en: Unfortunately, CSS selectors do not provide a direct way to filter elements
    based on their text content, like the `text()` and `normalize-space()` functions
    in XPath.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，CSS选取器没有提供直接根据文本内容过滤元素的方法，就像XPath中的`text()`和`normalize-space()`函数一样。
- en: 'So, while CSS selectors are hailed as being faster, they can be limited in
    functionality in test automation. The next example utilizes CSS to quickly gather
    all elements on the page:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然CSS选取器被誉为更快，但在测试自动化中它们的功能可能有限。下一个例子利用CSS快速收集页面上的所有元素：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For fetching particular types of elements, a combination of XPath and CSS can
    be employed. Here are some supplementary element selector types:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于获取特定类型的元素，可以结合使用XPath和CSS。以下是一些补充的元素选取器类型：
- en: 'Text:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本：
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Links:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Buttons:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lists:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表：
- en: '[PRE23]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Fields:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段：
- en: '[PRE24]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finding an element only by text
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅通过文本查找元素
- en: 'Elements can be found with an XPath selector with an exact matching string.
    For example, a **Next** button with an exact match would be formatted as such:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用XPath选取器通过精确匹配字符串来找到元素。例如，一个精确匹配的**Next**按钮将格式化为如下：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, while the text is likely to remain constant, the angle bracket and
    spacing could change. We can reduce our chance of future maintenance with a selector
    that has a substring.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管文本很可能是恒定的，但角度括号和间距可能会改变。我们可以通过具有子字符串的选取器来减少未来维护的机会。
- en: Writing an XPath element that contains a textual substring
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写包含文本子串的XPath元素
- en: 'By adding `contains()` to the selector, the object can be found with just a
    small part of the text:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在选取器中添加`contains()`，只需文本的一小部分就可以找到对象：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This works for many elements, but checkboxes and radio buttons are tricky.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于许多元素，但复选框和单选按钮比较棘手。
- en: Finding an element relative to another element
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对于另一个元素查找元素
- en: 'In this next example, we want to click the checkbox next to the name *John
    Smith*. We have several checkboxes but none has a unique identifier by name:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们想要点击名字*约翰·史密斯*旁边的复选框。我们有几个复选框，但没有一个具有独特的名称标识符：
- en: '![Figure 10.4 – The name John Smith and its associated checkbox are two separate
    elements](img/B19395_10_4.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 约翰·史密斯的名字及其关联的复选框是两个独立的元素](img/B19395_10_4.jpg)'
- en: Figure 10.4 – The name John Smith and its associated checkbox are two separate
    elements
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 约翰·史密斯的名字及其关联的复选框是两个独立的元素
- en: 'This selector will identify all the checkboxes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选取器将识别所有复选框：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To locate this checkbox element, we need to use the link and find the input
    checkbox preceding it. Here’s how we can do that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要定位这个复选框元素，我们需要使用链接并找到它前面的输入复选框。以下是我们可以这样做的方法：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Case-insensitive partial matches
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不区分大小写的部分匹配
- en: 'What if we learn a developer sometimes changes the case of the text? A solution
    to that is to add a `translate` option and convert the text to match either upper-
    or lowercase:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们了解到有时开发者会更改文本的大小写怎么办？解决这个问题的方法是为`translate`选项添加一个，并将文本转换为匹配大写或小写：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The problem now is that the element the selector returns is not always visible.
    Here is how we handle that.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，选择器返回的元素并不总是可见的。以下是我们的处理方法。
- en: Finding only visible elements
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅查找可见元素
- en: 'One of the biggest challenges in test automation is to return a collection
    of visible elements. This reminds us of a very famous quote delivered by Michael
    Keaton: “*Want to get nuts? Let’s* *get nuts!*”'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试中最大的挑战之一是返回一个可见元素的集合。这让我们想起了迈克尔·基顿（Michael Keaton）的一个非常著名的引言：“*想要疯狂？那就让我们疯狂吧！*”
- en: 'This extensive selector is provided as one example. It will eliminate most
    objects that are not visible in multiple ways. We addressed the opacity being
    `0`, the overflow or visibility being hidden, the display being `none`, and the
    width or height being set to `0`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个广泛的选择器作为示例提供。它将以多种方式消除大多数不可见的对象。我们解决了不透明度为`0`、溢出或可见性被隐藏、显示为`none`以及宽度或高度设置为`0`的情况：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This selector also eliminates any elements that have an ancestor that is hidden.
    Here is another place where the 80/20 rule applies. Even if this selector only
    eliminates about 80% of non-visible elements, we will still need to parse through
    a collection of elements to find the first one that is visible. So, why not let
    XPath or CSS handle more than half of the work getting our visible elements?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此选择器还会消除任何具有隐藏祖先的元素。这是80/20规则适用的另一个地方。即使这个选择器只能消除大约80%的非可见元素，我们仍然需要解析元素集合以找到第一个可见的元素。那么，为什么不让XPath或CSS处理超过一半的工作，以获取我们的可见元素呢？
- en: The reason we want to do this is to give our methods a second chance at trying
    to find an element if it has been changed from its class. It’s never too late
    for a second or third chance to find an element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要这样做是为了给我们的方法第二次机会，尝试找到如果它已经从其类中更改的元素。找到元素的第二或第三次机会永远不会太晚。
- en: Second chances – getting valid objects from stale selectors
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二次机会 – 从过时的选择器中获取有效对象
- en: Now that we have our four primary method wrappers, let us make them more robust
    with self-healing code. The biggest drawback in automation is the maintenance
    to fix elements in the **Page Object Model** (**POM**) when selectors become stale.
    In this section, we look at self-healing techniques to find elements that have
    changed their node type.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了四个主要的方法包装器，让我们通过自我修复的代码使它们更加健壮。自动化最大的缺点是需要维护来修复**页面对象模型**（**POM**）中的元素，当选择器变得过时时。在本节中，我们探讨自我修复技术以找到已更改其节点类型的元素。
- en: Self healing techniques
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自我修复技术
- en: Let's go over some self-healing techniques in this sub-section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个子节中回顾一些自我修复技术。
- en: Reducing code for case-insensitive matches
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少不区分大小写的匹配代码
- en: 'All these functions will require a conversion to case-insensitive matches.
    We start by creating two constants to reduce the repeated use of the upper- and
    lowercase alphabet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都需要转换为不区分大小写的匹配。我们首先创建两个常量以减少大写和小写字母的重复使用：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we will need a function that will extract unique text from a stale locator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数，该函数将从一个过时的定位器中提取唯一文本。
- en: Extracting selector text
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取选择器文本
- en: 'This function will try to return the first match of any unique text encased
    in double or single quotes. This will be injected into a close match locator:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将尝试返回任何唯一文本的第一个匹配项，该文本被双引号或单引号包围。这将注入到一个接近匹配定位器中：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First, we check for a single quote, such as a possessive apostrophe, embedded
    in the selector string. For example, `"Moe''s Bar"` would result in an odd number
    of single quotes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查选择器字符串中嵌入的单引号，例如所有格撇号。例如，`"Moe's Bar"`会导致单引号的数量为奇数：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Handle cases where there is one single quote by surrounding it with a `concat`
    function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 处理只有一个单引号的情况，通过将其包裹在一个`concat`函数中：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This converts `"Moe's bar"` to `"concat("Moe","'","'s bar")` to support a single-quote
    match.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`"Moe's bar"`转换为`"concat("Moe","'","'s bar")`以支持单引号匹配。
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In any other language, it would be impossible to have a locator with both a
    single quote and a quoted string in a single locator. But because JavaScript allows
    literal strings with backticks, there could be a string like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他语言中，都不可能在单个定位器中同时有一个单引号和引号字符串。但是，因为JavaScript允许使用反引号表示字面字符串，所以可能会有这样的字符串：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, we handle the case where there are three single quotes and only the second
    single quote should be escaped like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们处理了有三个单引号的情况，只有第二个单引号应该被转义，如下所示：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This extracts as the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这会提取为以下内容：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Extract text between two double or single quotes as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式提取两个双引号或单引号之间的文本：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If no match is found, or the matched group is not valid, return the original
    selector. In fact, the locator string passed is likely not robust enough to be
    given a second chance. We return a string clearly identifying the issue, as returning
    a `Null` value would throw an error, and an empty string likely would match all
    elements:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配项，或者匹配的组无效，则返回原始选择器。实际上，传递的定位器字符串可能不够健壮，不足以给予第二次机会。我们返回一个清楚地标识问题的字符串，因为返回`Null`值会引发错误，而空字符串可能会匹配所有元素：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Otherwise, we return the captured group between single or double quotes modified
    if a single quote is detected:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果检测到单引号，则返回单引号或双引号之间的捕获组进行修改：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now that we have extracted the text of a locator, we can inject it into a similar
    one for each class of elements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提取了定位器的文本，我们可以将其注入到每个元素类的一个类似定位器中。
- en: From links to buttons
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从链接到按钮
- en: On the main page of the *Candymapper* sandbox website, there is exactly one
    `<Button>` element. It is the `<A>` anchor link like the other ones on the page.
    and it was in all caps. I’ve since fixed that, but do I need to spend time fixing
    the locator in my code?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Candymapper*沙盒网站的主页上，恰好有一个`<Button>`元素。它是一个`<A>`锚链接，就像页面上的其他链接一样。并且它是全大写的。我后来修复了这个问题，但我需要花时间修复代码中的定位器吗？
- en: '![Figure 10.5 –The Send button element on the Candymapper website](img/B19395_10_5.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – Candymapper网站上的发送按钮元素](img/B19395_10_5.jpg)'
- en: Figure 10.5 –The Send button element on the Candymapper website
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – Candymapper网站上的发送按钮元素
- en: 'This was the original locator that used to work:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以前曾经工作过的原始定位器：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What if we could pull the text and inject it into a button class like this?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将文本提取出来并注入到像这样的按钮类中呢？
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If it still did not work, we made a third attempt to make a case-insensitive
    match:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它仍然不起作用，我们进行了第三次尝试，进行不区分大小写的匹配：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, we have a solution that allows us to find our elements regardless of case
    sensitivity. We can now move on to optimizing this with a mutant merge power.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个解决方案，允许我们找到我们的元素，无论大小写敏感与否。现在我们可以继续使用突变合并功能来优化它。
- en: Finding an element by text alone
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅通过文本查找元素
- en: 'This can be wrapped together as a function in use by `getValidElement()` to
    give our buttons a second chance to be identified without refactoring the code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为一个函数一起使用，由`getValidElement()`调用，以给我们的按钮第二次被识别的机会，而无需重构代码：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, the **Send** button can be reached even if it changes case and class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使**发送**按钮更改了大小写和类，也可以到达它。
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Fields and lists
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段和列表
- en: 'Fields could change from `<input>` to `<textarea>` objects. To find them, this
    change can be done with the `@``placeholder` property:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 字段可以从`<input>`变为`<textarea>`对象。要找到它们，可以使用`@placeholder`属性进行此更改：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And of course, `<select>` objects might change to a `<``input>` combobox:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`<select>`对象可能会变为`<input>`组合框：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Short substrings
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短字符串
- en: 'One last trick before we leave this rabbit hole. Sometimes, small text changes
    can still be located accurately. `"Select all active files"` becomes `"Select
    all activated files"`. Divide the text into thirds. If the remaining length is
    greater than five characters, there is a good chance of matching on the middle
    string, `"all activ"`, as long as it is a unique match:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开这个兔子洞之前，还有一个技巧。有时，小的文本变化仍然可以准确找到。`"Select all active files"`变为`"Select all
    activated files"`。将文本分为三部分。如果剩余长度大于五个字符，中间字符串`"all activ"`匹配的可能性很大，只要它是一个唯一的匹配：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Statistically, this will return a unique element about 40% of the time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 统计上，这大约40%的时间会返回一个唯一的元素。
- en: On thin ice
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在薄冰上
- en: 'Scrolling elements pose a particularly difficult challenge. Occasionally, they
    will end up partially outside of the view area of the browser. Let’s take a look
    at this example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动元素提出了一个特别困难的挑战。偶尔，它们会部分超出浏览器的视图区域。让我们看看这个例子：
- en: '![Figure 10.6 – Text area object of upper-left corner 0,0 located above the
    browser view area; center of a second text area object located off the bottom
    of the browser](img/B19395_10_6.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 位于浏览器视图区域上方的左上角文本区域对象0,0；第二个文本区域对象的中心位于浏览器底部](img/B19395_10_6.jpg)'
- en: Figure 10.6 – Text area object of upper-left corner 0,0 located above the browser
    view area; center of a second text area object located off the bottom of the browser
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 位于浏览器视图区域上方的左上角 0,0 的文本区域对象；位于浏览器底部之外的第二个文本区域对象的中心
- en: 'And what if your site supports side-scrolling element animation? If your framework
    activates a sliding menu and immediately tries to click an element inside, there
    are bound to be some strange results:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网站支持侧滑元素动画，又会怎样？如果你的框架激活了一个滑动菜单，然后立即尝试点击内部的元素，很可能会得到一些奇怪的结果：
- en: '![Figure 10.7 – Example of clicking the center of a sliding menu item](img/B19395_10_7.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 点击滑动菜单项中心的示例](img/B19395_10_7.jpg)'
- en: Figure 10.7 – Example of clicking the center of a sliding menu item
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 点击滑动菜单项中心的示例
- en: What makes it more frustrating is that should this issue occur, the screen capture
    at the end of the test will likely occur once the slider animation has been completed.
    The only clue you might get is a message indicating the element was not clickable
    at point 2050, 250 which is just beyond the right edge of a display with a 1920
    x 1080 pixel resolution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更让人沮丧的是，如果出现这个问题，测试结束时的屏幕截图很可能会在滑动动画完成后出现。你可能会得到的唯一线索是一条消息，表明元素在点 2050, 250
    时不可点击，这个点位于一个 1920 x 1080 像素分辨率的显示器的右边缘之外。
- en: The intrinsic WebdriverIO `.click()` method should never have an issue interacting
    with an offscreen element. The major reason the `clickAdv()` wrapper function
    scrolls the element into the browser view area is to have a better chance of having
    the element appear in a screen capture if an error occurs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 WebdriverIO `.click()` 方法在与屏幕外的元素交互时不应有任何问题。`clickAdv()` 包装函数滚动元素进入浏览器视图区域的主要原因是为了在发生错误时有更好的机会在屏幕截图中显示元素。
- en: 'Attempting to use a fancy JavaScript click can throw errors if the element
    is not in the viewport. It depends if the click is being executed at the top-left
    corner of the object or at its calculated center. Here is an example of a JavaScript
    click call using the `browser.execute` method to execute the `arguments[0].click();`
    code string:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素不在视口中，尝试使用花哨的 JavaScript 点击可能会抛出错误。这取决于点击是在对象的左上角执行还是在计算出的中心执行。以下是一个使用 `browser.execute`
    方法执行 `arguments[0].click();` 代码字符串的 JavaScript 点击调用示例：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There is another good reason this approach can cause issues. In GUI automation,
    we always want to emulate the user as much as possible. What happens if we have
    a modal popup displayed over the desired element, as seen here?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的原因是这种做法可能会引起问题。在 GUI 自动化中，我们总是希望尽可能地模拟用户。如果我们在这里显示的模态弹出窗口覆盖了所需的元素，会发生什么呢？
- en: '![Figure 10.8 – Calling jsclick() to force interaction with an element below
    a modal popup will be problematic](img/B19395_10_8.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 调用 jsclick() 强制与模态弹出窗口下方的元素交互将会存在问题](img/B19395_10_8.jpg)'
- en: Figure 10.8 – Calling jsclick() to force interaction with an element below a
    modal popup will be problematic
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 调用 jsclick() 强制与模态弹出窗口下方的元素交互将会存在问题
- en: 'If the element we are seeking is sliding in on a control from off-screen, you
    often might get an error that the element click is out of bounds. It can occur
    if the element is an item in an expanding list that is still animating. Occasionally,
    an error can occur when the object has scrolled a few pixels out of the viewport.
    To counter this, we need to know if the element is moving when the error is thrown
    and when the movement has stopped. Here’s how we can do that:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在寻找的元素是从屏幕外滑入控制，我们通常会得到一个错误，表明元素点击超出了范围。如果元素是一个仍在动画中的展开列表中的项，这种情况可能会发生。有时，当对象滚动了几像素出视口时，可能会发生错误。为了解决这个问题，我们需要知道错误抛出时元素是否在移动，以及移动何时停止。以下是我们如何做到这一点的方法：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Scroll down one mouse wheel and click, like so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动一个鼠标滚轮并点击，如下所示：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Writing the isMoving() method
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 isMoving() 方法
- en: 'The days of clicking on an element by an *x* or *y* coordinate are long past
    us. It does not mean the coordinates of an element are of no value. Surprisingly,
    in some instances, a click is sometimes performed relative to an element’s screen
    location. With coordinates, we can determine if an element is in motion to ensure
    there is a higher degree of accuracy in our framework. Consider this line of code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 *x* 或 *y* 坐标点击元素的日子已经离我们远去。这并不意味着元素的坐标没有价值。令人惊讶的是，在某些情况下，点击操作有时是相对于元素的屏幕位置进行的。有了坐标，我们可以确定元素是否在移动，以确保我们的框架有更高的精度。考虑以下这段代码：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will return an object with the current *x* and *y* screen coordinate location
    of the element. By looping through with a brief pause of a few milliseconds, we
    can implement a dynamic wait that ensures our object scroll animation has been
    completed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含元素当前 *x* 和 *y* 屏幕坐标位置的对象。通过循环并暂停几毫秒，我们可以实现一个动态等待，确保我们的对象滚动动画已经完成：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The best practice is to implement this just after any `browser.execute` scroll
    and before any similar click-based method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在任何 `browser.execute` 滚动之后和任何类似基于点击的方法之前实现这一点。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this thrilling installment of our superhero coding saga, we’ve journeyed
    through the enigmatic world of element targeting, mastering the art of locating
    elusive HTML entities in the wilds of the web. Our quest led us to conquer the
    shifting shapes of `<a>` anchors, transforming them into mighty `<button>` sentinels,
    and evolving simple `<input>` fields into vast expanses of `<textarea>` elements.
    We’ve navigated the morphing mazes of dropdowns metamorphosing into comboboxes,
    deploying our powers to match text with a disregard for case, and even to seek
    out the hidden meanings within the midst of strings.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们超级英雄编码传奇的这次激动人心的篇章中，我们穿越了元素定位的神秘世界，掌握了在网络的荒野中定位难以捉摸的HTML实体的艺术。我们的探索之旅使我们征服了
    `<a>` 锚点的变化形态，将它们转化为强大的 `<button>` 守卫，并将简单的 `<input>` 字段进化成广阔的 `<textarea>` 元素。我们航行在变换的迷宫中，下拉菜单变成了组合框，我们运用我们的力量，忽略大小写匹配文本，甚至寻找字符串中的隐藏含义。
- en: Our toolkit expanded, and we’ve embraced the arcane arts of self-healing locators,
    weaving spells to mend themselves when the digital winds change. We stood firm
    as elements danced and darted across the screen, phasing in with animations that
    would baffle a lesser Tech Mage.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具包扩展了，我们拥抱了自我修复定位器的神秘艺术，编织咒语以应对数字风的变化。当元素在屏幕上翩翩起舞，快速穿梭时，我们坚定地站立，动画的幻影让一个低级的科技法师都感到困惑。
- en: 'As we stand at the precipice of discovery, we pose a question that defies the
    very reality of our craft: What if the need for a page object locator were but
    a mere illusion? What if, in the shadowy recesses of the UI, we could summon a
    **Send** button with nothing but a whisper to the framework? The answer beckons
    us—dare we leap into the unknown? The next chapter awaits, promising wonders beyond
    the limits of our imagination.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们站在发现的边缘时，我们提出了一个挑战我们工艺现实的问题：如果页面对象定位器的需求只是一个幻觉呢？如果在UI的阴影深处，我们只需对框架低语一声，就能召唤一个
    **发送** 按钮？答案在召唤我们——我们敢跃入未知吗？下一章等待着，承诺着超越我们想象力的奇迹。
