- en: Chapter 1. Playing with Syntax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 玩转语法
- en: '**JavaScript** was lacking behind some other programming languages when compared
    to various syntactic forms such as declaring constant variables, declaring block
    scoped variables, extracting data from arrays, shorter syntax for declaring functions
    and so on. **ES6** adds up a lot of new syntax-based features to JavaScript, which
    helps the developers to write less and do more. ES6 also prevents programmers
    from using various hacks for achieving various goals, which have negative performance
    impact and made code harder to read. In this chapter, we will look at the new
    syntactic features, introduced by ES6.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript** 在与声明常量变量、声明块作用域变量、从数组中提取数据、函数声明更简短的语法等各种语法形式相比时，落后于一些其他编程语言。**ES6**
    为 JavaScript 添加了许多基于新语法的特性，这有助于开发者写出更少但功能更强大的代码。ES6 还防止程序员使用各种为了达到各种目标而采取的“黑客”手段，这些手段会对性能产生负面影响，并使代码更难以阅读。在本章中，我们将探讨
    ES6 引入的新语法特性。'
- en: 'In this chapter, we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating the block scoped variables using the `let` keyword
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `let` 关键字创建块作用域变量
- en: Creating constant variables using the `const` keyword
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `const` 关键字创建常量变量
- en: The spread operator and the rest parameter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展运算符和剩余参数
- en: Extracting the data from iterables and objects using the destructuring assignment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解构赋值从可迭代对象和对象中提取数据
- en: The arrow functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: The new syntaxes for creating the object properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象属性的新语法
- en: The let keyword
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `let` 关键字
- en: The ES6 `let` keyword is used to declare a block scoped variable, optionally
    initializing it to a value. The programmers who come from other programming language
    background, but new to JavaScript, often end up writing error-prone JavaScript
    programs, believing that the JavaScript variables are block scoped. Almost every
    popular programming language has the same rules when it comes to the variable
    scopes, but JavaScript acts a bit different due to a lack of the block scoped
    variables. Due to the fact that JavaScript variables are not block scoped, there
    are chances of memory leak and also the JavaScript programs are harder to read
    and debug.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 的 `let` 关键字用于声明一个块作用域变量，可选地初始化它为一个值。来自其他编程语言背景但新接触 JavaScript 的程序员，常常会编写出容易出错的
    JavaScript 程序，认为 JavaScript 变量是块作用域的。几乎每种流行的编程语言在变量作用域方面都有相同的规则，但 JavaScript 由于缺乏块作用域变量而略有不同。由于
    JavaScript 变量不是块作用域的，存在内存泄漏的风险，而且 JavaScript 程序也更难以阅读和调试。
- en: Declaring function scoped variables
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明函数作用域变量
- en: The JavaScript variables that are declared using the `var` keyword are called
    as **function scoped** variables. The function scoped variables are accessible
    globally to the script, that is, throughout the script, if declared outside a
    function. Similarly, if the function scoped variables are declared inside a function,
    then they become accessible throughout the function, but not outside the function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 关键字声明的 JavaScript 变量被称为 **函数作用域** 变量。函数作用域变量在整个脚本中全局可访问，即如果在外部声明，则在整个脚本中可访问。同样，如果函数作用域变量在函数内部声明，则它们在整个函数中可访问，但在函数外部不可访问。
- en: 'Here is an example that shows how to create the function-scoped variables:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了如何创建函数作用域变量：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the code is:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: Here, you can see that the `c` variable is accessible outside the `if` statement,
    but this is not the case in other programming languages. So, the programmers coming
    from other languages would expect the `c` variable to be undefined outside the
    `if` statement, but that's not the case. Therefore, ES6 had introduced the `let`
    keyword, which can be used for creating variables that are block scoped.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到 `c` 变量在 `if` 语句外部是可访问的，但在其他编程语言中并非如此。因此，来自其他语言的程序员会期望 `c` 变量在 `if`
    语句外部是未定义的，但事实并非如此。因此，ES6 引入了 `let` 关键字，它可以用来创建块作用域变量。
- en: Declaring block scoped variables
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明块作用域变量
- en: Variables that are declared using the `let` keyword are called as block scoped
    variables. The block scoped variables behave the same way as the function scoped
    variables when declared outside a function, that is, they are accessible globally.
    But when the block scoped variables are declared inside a block, then they are
    accessible inside the block that they are defined in (and also any sub-blocks)
    but not outside the block.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`关键字声明的变量被称为块作用域变量。当在函数外部声明时，块作用域变量的行为与函数作用域变量相同，即它们是全局可访问的。但是，当块作用域变量在块内部声明时，它们只在其定义的块内部（以及任何子块）可访问，而不可在块外部访问。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A block is used to group zero or more statements. A pair of curly brackets delimits
    the block, that is `{}`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 块用于组合零个或多个语句。一对花括号定义了块，即`{}`。
- en: 'Let''s take the previous example script, replace `var` with the `let` keyword,
    and see the output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿之前的示例脚本，将`var`替换为`let`关键字，看看输出结果：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the code is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出是：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, the output is as expected by a programmer who is used to another programming
    language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出结果符合习惯使用其他编程语言的程序员的预期。
- en: Re-declaring variables
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新声明变量
- en: 'When you declare a variable using the `var` keyword that is already declared
    using `var` keyword (in the same scope) then it''s overwritten. Consider this
    example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`var`关键字声明一个变量，而这个变量在同一作用域内已经使用`var`关键字声明时，它会被覆盖。考虑以下示例：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the code is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出是：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output is as expected. But the variables created using the `let` keyword
    don't behave in the same way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果符合预期。但是使用`let`关键字创建的变量表现方式并不相同。
- en: 'When you declare a variable using the `let` keyword that is already declared
    using the `let` keyword in the same scope, then it throws a `TypeError` exception.
    Consider this example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`let`关键字声明一个变量，而这个变量在同一作用域内已经使用`let`关键字声明时，它会抛出一个`TypeError`异常。考虑以下示例：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you declare a variable with a name that''s already accessible in a function
    (or inner function), or is a sub-block using `var` or the `let` keyword respectively,
    then it''s a different variable. Here, is an example that shows the behavior:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一个在函数（或内部函数）中已经可访问的名称声明一个变量，或者使用`var`或`let`关键字分别创建一个子块时，那么它是一个不同的变量。这里有一个示例来展示这种行为：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the code is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出是：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`var` versus `let`, which one to use?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`与`let`，哪一个该用？'
- en: When writing the ES6 code, it is recommended to switch to using the `let` keyword
    because it makes scripts more memory friendly, prevents scoping mistakes, prevents
    accidental bugs, and makes the code easier to read. But if you are already addicted
    to the `var` keyword and comfortable using it, then you can still use this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写ES6代码时，建议切换到使用`let`关键字，因为它使脚本更节省内存，防止作用域错误，防止意外错误，并使代码更容易阅读。但如果你已经习惯了`var`关键字并且使用起来很舒服，那么你仍然可以使用它。
- en: You may be wondering why not just make the `var` keyword to define the block-scoped
    variables instead of introducing the `let` keyword? The reason why the `var` keyword
    wasn't made enough to define block-scoped variables, instead of introducing the
    `let` keyword, was for the sake of backward compatibility.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么不直接使用`var`关键字来定义块作用域变量，而不是引入`let`关键字？之所以没有将`var`关键字做得足够用来定义块作用域变量，而是引入`let`关键字，是为了向后兼容。
- en: The const keyword
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`const`关键字'
- en: 'The ES6 `const` keyword is used to declare the read-only variables, that is,
    the variables whose value cannot be reassigned. Before ES6, the programmers usually
    used to prefix the variables that were supposed to be constant. For example, take
    a look at the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ES6的`const`关键字用于声明只读变量，即值不能重新分配的变量。在ES6之前，程序员通常会在应该为常量的变量前加上前缀。例如，看看以下代码：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The value of `pi` should always remain constant. Here, although we have prefixed
    it, there is still a chance that we might accidentally change its value somewhere
    in the program, as they're no native protection to the value of `pi`. Prefixing
    is just not enough to keep the track of the constant variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi`的值应该始终保持不变。在这里，尽管我们已添加了前缀，但仍有可能在程序中的某个地方意外更改其值，因为它们没有对`pi`值的原生保护。添加前缀只是不足以追踪常量变量。'
- en: 'Therefore, the `const` keyword was introduced to provide a native protection
    to the constant variables. So, the previous program should be written in this
    way in ES6:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，引入了`const`关键字来为常量变量提供原生保护。所以，之前的程序在ES6中应该这样编写：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, when we tried to change the value of `pi`, a read-only exception was thrown.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当我们尝试改变 `pi` 的值时，抛出了一个只读异常。
- en: The scope of constant variables
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量变量的作用域
- en: 'Constant variables are block-scoped variables, that is, they follow the same
    scoping rules as the variables that are declared using the `let` keyword. Here
    is an example, which shows the scope of the constant variables:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 常量变量是块作用域变量，即它们遵循与使用 `let` 关键字声明的变量相同的作用域规则。以下是一个示例，展示了常量变量的作用域：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding code is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can see that the constant variables behave in the same way as the block
    scoped variables, when it comes to the scoping rules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，常量变量在作用域规则方面与块作用域变量表现相同。
- en: Referencing the objects using constant variables
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用常量变量引用对象
- en: When we assign an object to a variable, the reference of the object is what
    the variable holds and not the object itself. So, when assigning an object to
    a constant variable, the reference of the object becomes constant to that variable
    and not to the object itself. Therefore, the object is mutable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个对象赋值给一个变量时，变量持有的是对象的引用而不是对象本身。因此，当将对象赋值给一个常量变量时，对象的引用就变成了对该变量的常量引用，而不是对对象本身的引用。因此，对象是可变的。
- en: 'Consider this example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the preceding code is:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `a` variable stores the address (that is, reference) of
    the object. So the address of the object is the value of the `a` variable, and
    it cannot be changed. But the object is mutable. So when we tried to assign another
    object to the `a` variable, we got an exception as we were trying to change the
    value of the `a` variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a` 变量存储了对象的地址（即引用）。因此，对象的地址是 `a` 变量的值，且不能被改变。但是对象是可变的。所以当我们尝试将另一个对象赋值给
    `a` 变量时，我们得到了一个异常，因为我们试图改变 `a` 变量的值。
- en: Default parameter values
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'In JavaScript there is no defined way to assign the default values to the function
    parameters that are not passed. So, the programmers usually check for the parameters
    with the `undefined` value (as it is the default value for the missing parameters),
    and assign the default values to them. Here is an example, which shows how to
    do this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，没有定义的方法来为未传递的函数参数分配默认值。因此，程序员通常检查具有 `undefined` 值的参数（因为它是缺失参数的默认值），并将默认值分配给它们。以下是一个示例，展示了如何做到这一点：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'ES6 provides a new syntax that can be used to do this in an easier way. Here
    is the code which demonstrates how to do this in ES6:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 提供了一种新的语法，可以更简单地实现这一点。以下代码演示了如何在 ES6 中实现这一点：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, passing `undefined` is considered as missing an argument. Here is an
    example to demonstrate this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，传递 `undefined` 被视为缺少参数。以下是一个示例来演示这一点：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Defaults can also be expressions. Here is an example to demonstrate this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值也可以是表达式。以下是一个示例来演示这一点：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The spread operator
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展运算符
- en: '**A spread operator** is represented by the "`…`" token. A spread operator
    splits an iterable object into the individual values.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展运算符**由"`…`"符号表示。扩展运算符将可迭代对象拆分为单独的值。'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An iterable is an object that contains a group of values, and implements ES6
    iterable protocol to let us iterate through its values. An array is an example
    of built in an iterable object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象是包含一组值并实现 ES6 可迭代协议的对象，使我们能够遍历其值。数组是内置的可迭代对象的一个例子。
- en: A spread operator can be placed wherever multiple function arguments or multiple
    elements (for array literals) are expected in code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符可以放置在代码中期望多个函数参数或多个元素（对于数组字面量）的任何位置。
- en: The spread operator is commonly used to spread the values of an iterable object
    into the arguments of a function. Let's take an example of an array and see how
    to split it into the arguments of a function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符通常用于将可迭代对象的值扩展到函数的参数中。让我们以一个数组为例，看看如何将其拆分为函数的参数。
- en: 'Before ES6, for providing the values of an array as function argument, the
    programmers used the `apply()` method of functions. Here is an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 之前，为了将数组的值作为函数参数提供，程序员使用函数的 `apply()` 方法。以下是一个示例：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the apply method takes an array, extracts the values, passes them as individual
    arguments to the function, and then calls it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`apply` 方法接受一个数组，提取其值，将它们作为单独的参数传递给函数，然后调用它。
- en: 'ES6 provides an easy way to do this, using the spread operator. Here is an
    example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 提供了一种简单的方法来实现这一点，使用扩展运算符。以下是一个示例：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'During runtime, before the JavaScript interpreter calls the `myFunction` function,
    it replaces `…data` with the `1,4` expression:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，在JavaScript解释器调用`myFunction`函数之前，它将`…data`替换为`1,4`表达式：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code is replaced with:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码被替换为：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After this, the function is called.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，函数被调用。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A spread operator doesn't call the `apply()` method. The JavaScript runtime
    engine spreads the array using the iteration protocols, and has nothing to do
    with the `apply()` method, but the behavior is same.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展操作符不调用`apply()`方法。JavaScript运行时引擎使用迭代协议来展开数组，这与`apply()`方法无关，但行为相同。
- en: Other usages of the spread operator
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展操作符的其他用法
- en: The spread operator is not just limited to spreading an iterable object into
    the function arguments, but it can be used wherever multiple elements (for array
    literals) are expected in code. So it has many uses. Let's see some other use
    cases of the spread operator for arrays.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展操作符不仅限于将可迭代对象展开为函数参数，它还可以用于代码中期望多个元素（对于数组字面量）的任何地方。因此，它有很多用途。让我们看看扩展操作符在数组中的其他一些用例。
- en: Making array values a part of another array
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数组值作为另一个数组的一部分
- en: It can also be used to make the array values a part of another array. Here is
    an example code that demonstrates how to make the values of an existing array
    a part of another array while creating it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用来将数组值作为另一个数组的一部分。以下是一个示例代码，演示了如何在创建数组的同时将现有数组的值作为另一个数组的一部分。
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here the following line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是以下行：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Will be replaced with the following line:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将被替换为以下行：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Pushing the values of an array into another array
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数组值推入另一个数组
- en: Sometimes, we may need to push the values of an existing array into the end
    of another existing array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要将现有数组的值推入另一个现有数组的末尾。
- en: 'Before ES6, this is how the programmers used to do it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，程序员通常这样做：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But in ES6 we have a much cleaner way to do it, which is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但在ES6中，我们有一个更简洁的方式来处理，如下所示：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here the push method takes a series of variables, and adds them to the end of
    the array on which it is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，push方法接受一系列变量，并将它们添加到被调用数组的末尾。
- en: 'Here the following line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是以下行：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Will be replaced with the following line:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将被替换为以下行：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Spreading multiple arrays
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展多个数组
- en: 'Multiple arrays can be spread on a single line of expression. For example,
    take the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 多个数组可以被展开到一行表达式上。例如，以下代码：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The rest parameter
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余参数
- en: The rest parameter is also represented by the "`…`" token. The last parameter
    of a function prefixed with "`…`" is called as a rest parameter. The rest parameter
    is an array type, which contains the rest of the parameters of a function when
    number of arguments exceeds the number of named parameters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余参数也由“`…`”标记表示。带有“`…`”前缀的函数的最后一个参数被称为剩余参数。剩余参数是一个数组类型，它包含当参数数量超过命名参数数量时函数的其余参数。
- en: The rest parameter is used to capture a variable number of the function arguments
    from within a function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余参数用于在函数内部捕获可变数量的函数参数。
- en: Before ES6, the programmers used the `arguments` object of a function to retrieve
    the extra arguments, passed to the function. The `arguments` object is not an
    array, but it provides some interfaces that are similar to an array.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，程序员使用函数的`arguments`对象来检索传递给函数的额外参数。`arguments`对象不是一个数组，但它提供了一些类似于数组的接口。
- en: 'Here is a code example that shows how to use the `arguments` object to retrieve
    the extra arguments:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，展示了如何使用`arguments`对象来检索额外的参数：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In ES6, this can be done in a much easier and cleaner way, using the rest parameter.
    Here is an example of using the rest parameter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，这可以通过使用剩余参数以更简单、更干净的方式完成。以下是一个使用剩余参数的示例：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `arguments` object is not an array object. Therefore, to do array operations
    on the `arguments` object, you need to first convert it to an array. As the ES6
    rest parameter is an array type, it's easier to work with it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`对象不是一个数组对象。因此，要在`arguments`对象上执行数组操作，您需要首先将其转换为数组。由于ES6的剩余参数是数组类型，与之一起工作更容易。'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What is the "…" token called?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: “…”标记被称为什么？
- en: The "…" token is called as the spread operator or rest parameter, depending
    on where and how it's used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: “…”标记被称为扩展操作符或剩余参数，具体取决于其使用方式和位置。
- en: The destructuring assignment
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构赋值
- en: The destructuring assignment is an expression that allows you to assign the
    values or properties of an iterable or object, to the variables, using a syntax
    that looks similar to the array or object construction literals respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值是一个表达式，允许您使用类似于数组或对象构造字面量的语法将可迭代或对象的值或属性分配给变量。
- en: A destructuring assignment makes it easy to extract data from iterables or objects
    by providing a shorter syntax. A destructuring assignment is already present in
    the programming languages, such as **Perl** and **Python**, and works the same
    way everywhere.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值通过提供更短的语法，使得从可迭代对象或对象中提取数据变得容易。解构赋值已经在编程语言中存在，例如**Perl**和**Python**，并且它们的工作方式在所有地方都是相同的。
- en: There are two kinds of destructuring assignment expressions—the array and object
    destructuring assignment. Let's see each of them in details.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种解构赋值表达式——数组和对象解构赋值。让我们详细看看每一种。
- en: The array destructuring assignment
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组解构赋值
- en: An array destructuring assignment is used to extract the values of an iterable
    object and assign them to the variables. It's named as the *array destructuring
    assignment* because the expression is similar to an array construction literal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构赋值用于从可迭代对象中提取值并将它们分配给变量。它被称为*数组解构赋值*，因为表达式类似于数组构造字面量。
- en: 'Before ES6, the programmers used to do it this way to assign the values of
    an array to the variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，程序员通常这样做来将数组值分配给变量：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we are extracting the values of an array and assigning them to the `a`,
    `b`, `c` variables respectively.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在提取数组的值并将它们分别分配给`a`、`b`、`c`变量。
- en: 'In ES6, we can do this in just one line statement using the array destructuring
    assignment:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，我们可以通过一行语句使用数组解构赋值来完成此操作：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you see, the `[a, b, c]` is the array destructuring expression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`[a, b, c]`是数组解构表达式。
- en: On the left-hand side of the array destructuring statement, we need to place
    the variables to which we want to assign the array values, using syntax similar
    to an array literal. On right-hand side, we need to place an array (actually any
    iterable object) whose values we want to extract.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组解构语句的左侧，我们需要放置想要分配数组值的变量，使用与数组字面量类似的语法。在右侧，我们需要放置一个数组（实际上可以是任何可迭代对象），从中提取我们想要的值。
- en: 'The previous example code can be made even shorter in this way:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例代码可以这样进一步缩短：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here we create the variables on the same statement and instead of providing
    the array variable, we provide the array with a construction literal.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在同一语句中创建变量，而不是提供数组变量，而是提供具有构造字面量的数组。
- en: If there are fewer variables than items in the array, then only the first items
    are considered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组中的变量数量少于项目数量，则只考虑前几个项目。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you place a non-iterable object on the right-hand side of the array destructuring
    assignment syntax, then a `TypeError` exception is thrown.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在数组解构赋值语法的右侧放置一个非可迭代对象，则会抛出`TypeError`异常。
- en: Ignoring values
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略值
- en: 'We can also ignore some of the values of the iterable. Here is example code,
    which shows how to do this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以忽略可迭代对象中的一些值。以下是一个示例代码，展示了如何做到这一点：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using the rest operator in the array destructuring assignment
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在数组解构赋值中使用剩余操作符
- en: We can prefix the last variable of the array destructuring expression using
    the "`…`" token. In this case, the variable is always converted into an array
    object, which holds the rest of the values of the iterable object, if the number
    of other variables is less than the values in the iterable object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“`…`”标记作为数组解构表达式最后一个变量的前缀。在这种情况下，如果其他变量的数量少于可迭代对象中的值，则该变量始终被转换为数组对象，该对象包含可迭代对象剩余的值。
- en: 'Consider this example to understand it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例来理解它：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the previous example code, you can see that the `b` variable is converted
    into an array, and it holds all the other values of the right-hand side array.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例代码中，您可以看到`b`变量被转换为数组，并且它包含右侧数组中所有其他值。
- en: Here the "`…`" token is called as the **rest operator**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，“`…`”标记被称为**剩余操作符**。
- en: 'We can also ignore the values while using the rest operator. Here is an example
    to demonstrate this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在使用剩余操作符时忽略值。以下是一个示例来演示这一点：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we ignored the `2,` `3` values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们忽略了`2,` `3`值。
- en: Default values for variables
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量的默认值
- en: 'While destructuring, you can also provide the default values to the variables
    if an array index is `undefined`. Here is an example to demonstrate this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在展开过程中，如果你提供一个数组索引是`undefined`，你也可以为变量提供默认值。以下是一个演示此功能的示例：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Nested array destructuring
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套数组展开
- en: 'We can also extract the values from a multi-dimensional array and assign them
    to variables. Here is an example to demonstrate this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从多维数组中提取值并将它们分配给变量。以下是一个演示此功能的示例：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using the destructuring assignment as a parameter
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将展开赋值用作参数
- en: 'We can also use the array destructuring expression as the function parameter
    for extracting the values of an iterable object, passed as argument into the function
    parameters. Here is an example to demonstrate this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用数组展开表达式作为函数参数，以提取作为函数参数传递的可迭代对象的值。以下是一个演示此功能的示例：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Earlier in this chapter, we saw that if we pass `undefined` as an argument
    to a function call, then JavaScript checks for the default parameter value. So,
    we can provide a default array here too, which will be used if the argument is
    `undefined`. Here is an example to demonstrate this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们看到了如果我们将`undefined`作为参数传递给函数调用，那么JavaScript会检查默认参数值。因此，我们也可以在这里提供一个默认数组，如果参数是`undefined`，则将使用该数组。以下是一个演示此功能的示例：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we passed `undefined` as an argument and therefore, the default array,
    which is `[1, 2, 3]`, was used for extracting the values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们传递了`undefined`作为参数，因此使用了默认数组`[1, 2, 3]`来提取值。
- en: The object destructuring assignment
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象展开赋值
- en: An object destructuring assignment is used to the extract property values of
    an object and assign them to the variables.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对象展开赋值用于提取对象的属性值并将它们分配给变量。
- en: 'Before ES6, the programmers used to do it in the following way to assign the
    values of an object''s properties to the variables:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，程序员通常以以下方式将对象的属性值赋给变量：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In ES6, we can do this in just one line statement, using the object destructuring
    assignment:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，我们可以通过一行语句来完成这个操作，使用对象展开赋值：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: On the left-hand side of the object destructuring statement, we need to place
    the variables to which we want to assign the object property values using syntax
    similar to object literal. On right-hand side, we need to place an object whose
    property values we want to extract are finally close the statement using the `(
    )` token.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象展开语句的左侧，我们需要放置想要将对象属性值赋给变量的变量，使用与对象字面量类似的语法。在右侧，我们需要放置一个包含我们想要提取的属性值的对象，并最终使用`(
    )`标记来关闭语句。
- en: 'Here the variable names must be same as the object property names. If you want
    to assign different variable names, then you can do it this way:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量名必须与对象属性名相同。如果你想分配不同的变量名，可以这样做：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The previous code can be made even shorter this way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以通过这种方式进一步缩短：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here we are create the variables and object on the same line. We don't need
    to close the statement using the `( )` token, as we are creating the variables
    on the same statement.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们是在同一行上创建变量和对象。由于我们是在同一语句上创建变量，因此不需要使用`( )`标记来关闭语句。
- en: Default values for the variables
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量的默认值
- en: 'You can also provide the default values to the variables, if the object property
    is `undefined` while destructuring. Here is an example to demonstrate this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在展开对象时对象属性是`undefined`，你也可以为变量提供默认值。以下是一个演示此功能的示例：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Destructuring computed property names
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开计算属性名
- en: 'Some property names are constructed dynamically using expressions. In this
    case, to extract the property values, we can use the `[ ]` token to provide the
    property name an expression. Here is an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性名是使用表达式动态构建的。在这种情况下，为了提取属性值，我们可以使用`[ ]`标记来提供一个属性名表达式。以下是一个示例：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Destructuring nested objects
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开嵌套对象
- en: 'We can also the extract property values from the nested objects, that is, the
    objects within the objects. Here is an example to demonstrate this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从嵌套对象中提取属性值，即对象内的对象。以下是一个演示此功能的示例：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the object destructuring assignment as a parameter
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将对象展开赋值用作参数
- en: 'Just like the array destructuring assignment, we can also use the object destructuring
    assignment as a function parameter. Here is an example to demonstrate this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组展开赋值一样，我们也可以将对象展开赋值用作函数参数。以下是一个演示此功能的示例：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we passed an empty object as a default parameter value, which will be
    used as a default object if `undefined` is passed as a function argument.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们传递了一个空对象作为默认参数值，如果将 `undefined` 作为函数参数传递，它将用作默认对象。
- en: The arrow functions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: ES6 provides a new way to create functions using the `=>` operator. These functions
    are called as **arrow** functions. This new method has a shorter syntax, and the
    arrow functions are the anonymous functions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 提供了一种使用 `=>` 操作符创建函数的新方法。这些函数被称为 **箭头** 函数。这种方法具有更短的语法，箭头函数是无名函数。
- en: 'Here is an example that shows how to create an arrow function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了如何创建一个箭头函数：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, `circleArea` is a variable, referencing to the anonymous arrow function.
    The previous code is similar to the next code in ES5:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`circleArea` 是一个变量，引用了匿名箭头函数。前面的代码与以下 ES5 代码类似：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If an arrow function contains just one statement, then you don''t have to use
    the `{}` brackets to wrap the code. Here is an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果箭头函数只包含一个语句，那么你不需要使用 `{}` 括号来包裹代码。以下是一个示例：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When `{}` brackets are not used then the value of the statement in the body
    is automatically returned.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有使用 `{}` 括号时，则语句体的值会自动返回。
- en: The value of "this" in an arrow function
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数中 "this" 的值
- en: In the arrow functions, the value of `this` keyword is same as the value of
    `this` keyword of the enclosing scope (the global or function scope, inside whichever
    the arrow function is defined), instead of referring to the context object (that
    is, the object inside of which the function is a property), which is the value
    of `this` in traditional functions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数中，`this` 关键字的值与封闭作用域（全局或函数作用域，无论箭头函数在哪里定义）中 `this` 关键字的值相同，而不是指向上下文对象（即函数作为属性所在的那个对象），这是传统函数中
    `this` 的值。
- en: 'Consider this example to understand the difference in the traditional function''s
    and the arrow function''s `this` value:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，以了解传统函数和箭头函数的 `this` 值之间的差异：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, `this` inside the `f1` function refers to `object,` as `f1` is the property
    of it. `this` inside `f2` refers to the `window` object, as `f2` is a property
    of the `window` object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`f1` 函数内部的 `this` 指向 `object`，因为 `f1` 是它的属性。`f2` 函数内部的 `this` 指向 `window`
    对象，因为 `f2` 是 `window` 对象的属性。
- en: 'But `this` behaves differently in the arrow functions. Let''s replace the traditional
    functions with the arrow functions in the preceding code and see the value of
    this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在箭头函数中，`this` 的行为有所不同。让我们将前面的代码中的传统函数替换为箭头函数，并查看 `this` 的值：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, `this` inside the `f1` function copies the `this` value of global scope,
    as `f1` lies in global scope. `this` inside `f2` copies the `this` value of `f1,`
    as `f2` lies in the `f1` scope.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`f1` 函数内部的 `this` 复制了全局作用域的 `this` 值，因为 `f1` 位于全局作用域。`f2` 函数内部的 `this` 复制了
    `f1` 的 `this` 值，因为 `f2` 位于 `f1` 作用域。
- en: Other differences between the arrow and traditional functions
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数与传统函数之间的其他差异
- en: The arrow functions cannot be used as object constructors that is, the `new`
    operator cannot be applied on them.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数不能用作对象构造函数，也就是说，不能对它们应用 `new` 操作符。
- en: Apart from syntax, the `this` value, and the `new` operator, everything else
    is the same between the arrow and traditional functions, that is, they both are
    the instances of `the` `Function` constructor.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法、`this` 值和 `new` 操作符之外，箭头函数与传统函数之间没有其他差异，也就是说，它们都是 `Function` 构造函数的实例。
- en: The enhanced object literals
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强的对象字面量
- en: 'ES6 has added some new syntax-based extensions to the `{}` object literal for
    creating properties. Let''s see them:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 为 `{}` 对象字面量添加了一些基于语法的扩展，用于创建属性。让我们看看它们：
- en: Defining properties
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义属性
- en: ES6 provides a shorter syntax for assigning the object properties to the values
    of the variables, which have the same name as the properties.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 提供了一种更短的语法来将对象属性分配给具有相同名称的变量值。
- en: 'In ES5, you have been doing this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，你一直是这样做：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In ES6, you can do it this way:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，你可以这样操作：
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Defining methods
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义方法
- en: 'ES6 provides a new syntax for defining the methods on an object. Here is an
    example to demonstrate the new syntax:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 提供了一种新的语法来定义对象上的方法。以下是一个演示新语法的示例：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This concise function allows the use of `super` in them, whereas the traditional
    methods of the objects don't allow the use of `super`. We will learn more about
    it later in this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简洁的函数允许在其中使用 `super`，而对象的传统方法不允许使用 `super`。我们将在本书的后面了解更多关于它的内容。
- en: The computed property names
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性名称
- en: The property names that are evaluated during runtime are called as the **computed
    property names**. An expression is usually resolved to find the property name
    dynamically.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时评估的属性名称被称为**计算属性名称**。通常，表达式会被解析以动态地找到属性名称。
- en: 'In ES5, the computed properties are defined in this way:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，计算属性是这样定义的：
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, after creating the object, we attach the properties to the object. But
    in ES6, we can add the properties with the computed name while creating the objects.
    Here is an example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在创建对象之后，我们将属性附加到对象上。但在ES6中，我们可以在创建对象的同时添加具有计算名称的属性。以下是一个示例：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the variable's scopes, read-only variables,
    splitting arrays into individual values, passing indefinite parameters to a function,
    extracting data from objects and arrays, arrow functions, and new syntaxes for
    creating object properties.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了变量的作用域、只读变量、将数组拆分为单个值、向函数传递不定参数、从对象和数组中提取数据、箭头函数以及创建对象属性的新语法。
- en: In the next chapter, we will learn about built-in objects and symbols, and we
    will discover the properties added by ES6 into strings, arrays, and objects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习内置对象和符号，并发现ES6为字符串、数组和对象添加的新属性。
