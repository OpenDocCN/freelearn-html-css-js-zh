- en: Real-Time Communication with Socket.IO and ExpressJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Socket.IO和ExpressJS进行实时通信
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Understanding NodeJS events
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解NodeJS事件
- en: Understanding Socket.IO events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Socket.IO事件
- en: Working with Socket.IO namespaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Socket.IO命名空间
- en: Defining and joining to Socket.IO rooms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义并加入Socket.IO房间
- en: Writing middleware for Socket.IO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Socket.IO编写中间件
- en: Integrating Socket.IO with ExpressJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Socket.IO与ExpressJS集成
- en: Using ExpressJS middleware in Socket.IO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Socket.IO中使用ExpressJS中间件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have an IDE, Visual Studio Code, Node.js and MongoDB.
    You will also need to install Git, in order use the Git repository of this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个IDE，Visual Studio Code，Node.js和MongoDB。 您还需要安装Git，以便使用本书的Git存储库。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter04)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[https://goo.gl/xfyDBn](https://goo.gl/xfyDBn)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/xfyDBn](https://goo.gl/xfyDBn)'
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Modern web applications usually require real-time communication where data is
    continuously flowing from client to server and vice versa with (almost) no delay.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序通常需要实时通信，其中数据不断从客户端流向服务器，反之亦然，几乎没有延迟。
- en: The HTML5 WebSocket Protocol was created to fulfill this requirement. WebSocket
    uses a single TCP connection that is kept open even when the server or client
    is not sending any data. That means, while a connection between the client and
    the server exists, data can be sent at any time without having to open a new connection
    to the server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 WebSocket协议是为了满足这一要求而创建的。 WebSocket使用单个TCP连接，即使服务器或客户端不发送任何数据，该连接也会保持打开。
    这意味着，在客户端和服务器之间存在连接时，可以随时发送数据，而无需打开到服务器的新连接。
- en: Real-time communication has several applications from building chat applications
    to multi-user games, where the response time is really important.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实时通信有多个应用场景，从构建聊天应用程序到多用户游戏，响应时间非常重要。
- en: In this chapter, we will focus on learning how to build a real-time web application
    using Socket.IO ([https://socket.io](https://socket.io)) and understanding the
    Node.js event-driven architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于学习如何使用Socket.IO（[https://socket.io](https://socket.io)）构建实时Web应用程序，并理解Node.js的事件驱动架构。
- en: Socket.IO is one of the most used libraries for implementing real-time communication.
    Socket.IO uses WebSocket whenever possible but falls-back to other methods when
    WebSocket is not supported on a specific web browser. Because you probably want
    to make your application accessible from any web browser, having to work directly
    with WebSocket may not seem like a good idea.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO是实现实时通信最常用的库之一。 Socket.IO在可能的情况下使用WebSocket，但在特定Web浏览器不支持WebSocket时会退回到其他方法。
    因为您可能希望使您的应用程序可以从任何Web浏览器访问，所以必须直接使用WebSocket可能看起来不是一个好主意。
- en: Understanding Node.js events
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Node.js事件
- en: Node.js has an event-driven architecture. Most of Node.js' core API is built
    around `EventEmitter`. This is a Node.js module that allows `listeners` to subscribe
    to certain named events that can be triggered later by an **emitter**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js具有事件驱动的架构。 Node.js的大部分核心API都是围绕`EventEmitter`构建的。 这是一个允许`侦听器`订阅特定命名事件的Node.js模块，稍后可以由**发射器**触发。
- en: 'You can define your own event emitter easily by just including the events Node.js
    module and creating a new instance of `EventEmitter`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过包含事件Node.js模块并创建`EventEmitter`的新实例来轻松定义自己的事件发射器：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you can trigger the `welcome` event by using the `emit` method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`emit`方法触发`welcome`事件：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is actually, pretty simple. One of the advantages is that you can subscribe
    multiple listeners to the same event, and they will get triggered when the `emit`
    method is used:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上相当简单。 其中一个优点是您可以订阅多个侦听器到同一个事件，并且当使用`emit`方法时它们将被触发：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `EventEmitter` API provides several helpful methods that give you more
    control to handle events. Check the official Node.js documentation to see all
    information about the API: [https://nodejs.org/api/events.html](https://nodejs.org/api/events.html).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` API提供了几种有用的方法，可以让您更好地控制处理事件。 请查看官方Node.js文档，以查看有关API的所有信息：[https://nodejs.org/api/events.html](https://nodejs.org/api/events.html)。'
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will create a class that will extend `EventEmitter`, and
    which will contain its own instance methods to trigger listeners attached to a
    specific event. First, create a new project by opening a Terminal and running
    the following line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将创建一个类，它将扩展`EventEmitter`，并且将包含其自己的实例方法来触发附加到特定事件的侦听器。 首先，通过打开终端并运行以下命令来创建一个新项目：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a class that extends `EventEmitter` and define two instance methods
    called `start` and `stop`. When the `start` method is called, it will trigger
    all listeners attached to the `start` event. It will keep the starting time using
    `process.hrtime`. Then, when the `stop` method is called, it will trigger all
    listeners attached to the `stop` event passing as an argument the difference in
    time since the `start` method was called:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类，它扩展`EventEmitter`并定义两个名为`start`和`stop`的实例方法。 当调用`start`方法时，它将触发附加到`start`事件的所有侦听器。
    它将使用`process.hrtime`保持起始时间。 然后，当调用`stop`方法时，它将触发附加到`stop`事件的所有侦听器，并将自`start`方法调用以来的时间差作为参数传递：
- en: Create a new file named `timer.js`
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`timer.js`的新文件
- en: 'Include the events NodeJS module:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括事件NodeJS模块：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define two constants that we will use to convert the returned value of `process.hrtime`
    from seconds to nanoseconds and then to milliseconds:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个常量，我们将使用它们将`process.hrtime`的返回值从秒转换为纳秒，然后转换为毫秒：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define a class named `Timer` with two instance methods:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`Timer`的类，其中包含两个实例方法：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a new instance of the previously defined class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建先前定义的类的新实例：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Attach an event listener to the `start` event that will have a loop that will
    perform multiplications. Afterwards, it will call the `stop` method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个事件监听器附加到`start`事件，它将有一个循环执行乘法。之后，它将调用`stop`方法：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Attach an event listener to the `stop` event that will print the time it took
    for the event `start` to execute all its attached listeners:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个事件监听器附加到`stop`事件，它将打印事件`start`执行所有附加监听器所花费的时间：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the `start` method to trigger all `start` event listeners:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`start`方法来触发所有`start`事件监听器：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the file
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Open a new Terminal and run:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the `start` method is executed, it keeps the starting time using `process.hrtime`,
    which returns the current high-resolution real time in an array of two items,
    where the first item is a number that represents seconds while the second item
    is another number that represents nanoseconds. Then, it triggers all event listeners
    attached to the `start` event.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`start`方法时，它使用`process.hrtime`来保留开始时间，该方法返回一个包含两个项目的数组，第一个项目是表示秒的数字，而第二个项目是表示纳秒的另一个数字。然后，它触发所有附加到`start`事件的事件监听器。
- en: On the other side, when the `stop` method is executed, it uses the result of
    previously calling `process.hrtime` as an argument to the same function, which
    returns the difference in time. This is useful to measure the time from when the
    `start` method was called until the time when the `stop` method was called.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当执行`stop`方法时，它使用之前调用`process.hrtime`的结果作为相同函数的参数，该函数返回时间差。这对于测量从调用`start`方法到调用`stop`方法的时间非常有用。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A common mistake is to assume that events are called asynchronously. It is
    true that defined events can be called at any time. However, they are still executed
    synchronously. Take the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是假设事件是异步调用的。确实，定义的事件可以在任何时候被调用。然而，它们仍然是同步执行的。看下面的例子：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The outputs for the preceding code will be shown as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you have a loop running inside one of your events, the next event won't get
    called until the previous one finishes executing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的事件中有一个循环在运行，下一个事件将不会被调用直到前一个完成执行。
- en: 'Events can be made asynchronous by simply adding an `async` function as an
    event listener. By doing so, every function will still be called in order from
    the first `listener` defined to the last. However, the emitter won''t wait for
    the first `listener` to finish its execution to call the next listener. That means
    you cannot guarantee that the output will always be in the same order, for instance:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以通过简单地将`async`函数添加为事件监听器来变成异步的。这样做，每个函数仍然会按照从第一个定义的`listener`到最后一个的顺序被调用。然而，发射器不会等待第一个`listener`完成执行才调用下一个listener。这意味着你不能保证输出总是按照相同的顺序，例如：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The outputs for the preceding code will be shown as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Asynchronous functions allow us to write non-blocking applications. If implemented
    correctly, you won't run into problems like this above.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数允许我们编写非阻塞的应用程序。如果实现正确，您不会遇到上面的问题。
- en: '`EventEmitter` instances have a method called `listeners` which when executed,
    providing an event name as an argument, returns an array of the attached listeners
    for that specific event. We can use this method in a way to allow `async` functions
    to be executed in the order they were attached, for instance:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`实例有一个名为`listeners`的方法，当执行时，提供一个事件名称作为参数，返回附加到该特定事件的监听器数组。我们可以使用这种方法以允许`async`函数按照它们被附加的顺序执行，例如：'
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will execute and display output in the order they were attached:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按照它们被附加的顺序执行并显示输出：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Understanding Socket.IO events
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Socket.IO事件
- en: Socket.IO is an event-driven module or library, and, as you probably guessed,
    is based on `EventEmitter`. Everything in Socket.IO works with events. An event
    is triggered when a new connection is made to the Socket.IO server and an event
    can be emitted to send data to the client.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO是一个基于`EventEmitter`的事件驱动模块或库，正如您可能猜到的那样。Socket.IO中的一切都与事件有关。当新连接建立到Socket.IO服务器时，将触发一个事件，并且可以发出事件以向客户端发送数据。
- en: The Socket.IO server API differs from the Socket.IO client API. However, both
    work with events to send data from client to server and vice versa.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器API与Socket.IO客户端API不同。然而，两者都使用事件来从客户端向服务器发送数据，反之亦然。
- en: The Socket.IO server events
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO服务器事件
- en: Socket.IO uses a single TCP connection to a single path. That means, by default,
    the connection is made to the URL `http[s]://host:port/socket.io`. However, within
    Socket.IO, it allows you to define **namespaces**. That means, different end-points
    but the connection will still remain a single URL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO使用单个TCP连接到单个路径。这意味着，默认情况下，连接是建立到URL`http[s]://host:port/socket.io`。然而，在Socket.IO中，它允许您定义**命名空间**。这意味着不同的终点，但连接仍然保持单一URL。
- en: By default, Socket.IO Server uses the `"/"` or root namespace
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Socket.IO服务器使用`"/"`或根命名空间
- en: You can, of course, define multiple instances and listen to different URLs as
    well. However, we will assume, for the purpose of this recipe, that only one connection
    is created.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以定义多个实例并监听不同的URL。然而，为了本教程的目的，我们将假设只创建一个连接。
- en: 'The Socket.IO namespace has the following events that your application can
    subscribe to:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO命名空间具有以下事件，您的应用程序可以订阅：
- en: '`connect` or `connection`: When a new connection is made, this event is fired.
    It provides a **socket object** to the listener as the first parameter that represents
    the new connection with the client'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect`或`connection`：当建立新连接时，将触发此事件。它将**socket对象**作为第一个参数提供给监听器，表示与客户端的新连接'
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Socket.IO socket object has the following events:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO套接字对象具有以下事件：
- en: '`disconnecting`: This event is emitted when the client is going to be disconnected
    from the server. It provides to the listener a parameter that specifies the reason
    for the disconnection'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnecting`：当客户端即将从服务器断开连接时发出此事件。它向监听器提供一个指定断开连接原因的参数'
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`disconnected`: Similar to the disconnecting event. However, this event is
    fired after the client has been disconnected from the server:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnected`：类似于断开连接事件。但是，此事件在客户端从服务器断开连接后触发：'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`error`: This event is emitted when an error occurs within events'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：当事件发生错误时触发此事件'
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`[eventName]`: A user-defined event that will get fired when the client emits
    an event with the same name. The client can emit an event providing data in the
    arguments. On the server, the event will be fired and it will receive the data
    sent by the client'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[eventName]`：一个用户定义的事件，当客户端发出具有相同名称的事件时将被触发。客户端可以发出一个提供参数中的数据的事件。在服务器上，事件将被触发，并且将接收客户端发送的数据'
- en: Socket.IO client events
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO客户端事件
- en: A client doesn't necessarily need to be a web browser. We could write a Node.js
    Socket.IO client application as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端不一定需要是一个网络浏览器。我们也可以编写一个Node.js Socket.IO客户端应用程序。
- en: 'The Socket.IO client events are extensive and give a lot of control over your
    application:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO客户端事件非常广泛，可以对应用程序进行很好的控制：
- en: '`connect`: This event gets fired when there is a successful connection to the
    server'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect`：当成功连接到服务器时触发此事件'
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`connect_error`: This event is emitted when there is an error when trying to
    connect or reconnect to the server'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect_error`：当尝试连接或重新连接到服务器时出现错误时，会触发此事件'
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`connect_timeout:` By default, the timeout set before a `connect_error` and
    `connect_timeout` is emitted is 20 seconds. After this, the Socket.IO client may
    try to reconnect to the server once again:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect_timeout:` 默认情况下，在发出`connect_error`和`connect_timeout`之前设置的超时时间为20秒。之后，Socket.IO客户端可能会再次尝试重新连接到服务器：'
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`disconnect`: This event is fired when the client is disconnected from the
    server. An argument is provided specifying the reason of the disconnection:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnect`：当客户端从服务器断开连接时触发此事件。提供一个参数，指定断开连接的原因：'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`reconnect`: Fired after a successful reconnection attempt. An argument is
    provided that specifies how many attempts happened before the connection was successful:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reconnect`：在成功重新连接尝试后触发。提供一个参数，指定在连接成功之前发生了多少次尝试：'
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`reconnect_attempt` or `reconnecting`: This event is emitted when trying to
    reconnect to the server. An argument is provided specifying the number of current
    attempts to connect to the server:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reconnect_attempt`或`reconnecting`：当尝试重新连接到服务器时会触发此事件。提供一个参数，指定当前尝试连接到服务器的次数：'
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`reconnect_error`: Similar to the `connect_error` event. However, it gets fired
    only if there is an error when trying to reconnect to the server:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reconnect_error`：类似于`connect_error`事件。但是，只有在尝试重新连接到服务器时出现错误时才会触发：'
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`reconnect_failed:` By the default, the maximum number of attempts is set to
    `Infinity`. That means, it is unlikely that this event will ever get fired. However,
    we can specify an option to limit the maximum number of connection attempts. Let''s
    see that later:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reconnect_failed:` 默认情况下，尝试的最大次数设置为`Infinity`。这意味着，这个事件很可能永远不会被触发。但是，我们可以指定一个选项来限制最大连接尝试次数。稍后我们会看到：'
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ping`: In short, this event gets fired to check if the connection with the
    server is still alive:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ping`：简而言之，此事件被触发以检查与服务器的连接是否仍然存在：'
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`pong`: Fired when a response is received from the server after the event `ping`
    is fired. An argument is provided specifying the latency or response time:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pong`：在从服务器接收到`ping`事件后触发。提供一个参数，指定延迟或响应时间：'
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`error`: This event is fired when an error occurs within events:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：当事件发生错误时触发此事件：'
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`[eventName]`: A user-defined event that gets fired when the event is emitted
    in the server. The arguments provided by the server will be received by the client.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[eventName]`：当在服务器中发出事件时触发的用户定义的事件。服务器提供的参数将被客户端接收。'
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will build a Socket.IO server and a Socket.IO client using
    what you have just learned about events. Before you start, create a new `package.json`
    file with the following content:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将使用刚刚学到的有关事件的知识构建一个Socket.IO服务器和一个Socket.IO客户端。在开始之前，请创建一个新的`package.json`文件，内容如下：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: A Socket.IO server will be built to respond to a single event named `time`.
    When the event is fired, it will get the server's current time and emit another
    event named `"got time?"` providing two arguments, the current `time` and a `counter`
    that specifies how many times a request was made.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建一个Socket.IO服务器来响应一个名为`time`的单个事件。当事件被触发时，它将获取服务器的当前时间，并发出另一个名为`"got time?"`的事件，提供两个参数，当前的`time`和一个指定请求次数的`counter`。
- en: Create a new file named `simple-io-server.js`
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`simple-io-server.js`的新文件
- en: 'Include the Socket.IO module and initialize a new server:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括Socket.IO模块并初始化一个新服务器：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define the URL path where connections will be made:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义连接将被建立的URL路径：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the root or `"/"` namespace:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用根目录或`"/"`命名空间：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When a new connection is made, initialize a `counter` variable to `0`. Then,
    add a new listener to the `time` event that will increase the `counter` by one,
    every time there is a new request, and emit the `"got time?"` event that will
    be later defined on the client side:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当建立新连接时，将`counter`变量初始化为`0`。然后，添加一个新的监听器到`time`事件，每次有新的请求时，将`counter`增加一次，并发出后来在客户端定义的`"got
    time?"`事件：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listen on port `1337` for new connections:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听端口`1337`以获取新连接：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Save the file
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Next, build a Socket.IO client that will connect to our server:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建一个连接到我们服务器的Socket.IO客户端：
- en: Create a new file named `simple-io-client.js`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`simple-io-client.js`的新文件
- en: 'Include the Socket.IO client module:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括Socket.IO客户端模块：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Initialize a new Socket.IO client providing the server URL and an options object
    where we will define the path used in the URL where the connections will be made:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的Socket.IO客户端，提供服务器URL和一个选项对象，在该对象中我们将定义URL中使用的路径，连接将在该路径上进行：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add an event listener to the `connect` event. Then, when a connection is made,
    using a `for` loop, emit the `time` event 5 times:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`connect`事件添加一个事件监听器。然后，当建立连接时，使用`for`循环，发出`time`事件5次：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add an event listener to the `"got time?"` event that will expect to receive
    two arguments the time and a counter that specifies how many requests were made
    to the server, then print on the console:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`"got time?"`事件上添加一个事件监听器，该事件将期望接收两个参数，时间和一个指定了向服务器发出了多少次请求的计数器，然后在控制台上打印：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save the file
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Open a Terminal and run first the Socket.IO server:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并首先运行Socket.IO服务器：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Open another terminal and run the Socket.IO client:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端并运行Socket.IO客户端：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Everything works with events. Socket.IO allows events to be defined in the server
    side that the client can emit. On the other side, it also allows to define events
    in the client side that the server can emit.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都与事件有关。Socket.IO允许在服务器端定义客户端可以发出的事件。另一方面，它还允许在客户端端定义服务器可以发出的事件。
- en: 'When a user-defined event is emitted by the server side, the data is sent to
    the client. The Socket.IO client checks whether there is a listener for that event
    first. Then, if there is a listener, it will get triggered. The same thing happens
    the other way around when a user-defined event is emitted by the client side:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器端发出用户定义的事件时，数据被发送到客户端。Socket.IO客户端首先检查是否有该事件的监听器。然后，如果有监听器，它将被触发。当客户端端发出用户定义的事件时，同样的事情也会发生：
- en: An event listener `time` was added in our Socket.IO server's **socket object**
    which can be emitted by the client side
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Socket.IO服务器的**socket对象**中添加了一个事件监听器`time`，可以由客户端发出
- en: An event listener `"got time?"` was added in our Socket.IO Client which can
    be emitted by the server side
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Socket.IO客户端中添加了一个事件监听器`"got time?"`，可以由服务器端发出
- en: On connection, the client emits the `time` event first
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接时，客户端首先发出`time`事件
- en: Afterwards, the `time` event is fired on the server side which will emit the
    `"got time?"` event providing two arguments, the current server's `time` and a
    `counter` that specifies how many times a request was made
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，在服务器端触发`time`事件，该事件将提供两个参数，当前服务器的`time`和一个指定了请求次数的`counter`
- en: Then, the `"got time?"` event is fired on the client side receiving two arguments
    that were provided by the server, the `time` and a `counter`
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在客户端端触发`"got time?"`事件，接收服务器提供的两个参数，`time`和`counter`。
- en: Working with Socket.IO namespaces
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Socket.IO命名空间
- en: Namespaces are a way of separating the business logic of your application while
    reusing the same TCP connection or minimizing the need for creating new TCP connections
    for to implement real-time communication between the server and the client.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一种分隔应用程序业务逻辑的方式，同时重用相同的TCP连接或最小化创建新TCP连接的需求，以实现服务器和客户端之间的实时通信。
- en: 'Namespaces look pretty similar to ExpressJS'' route paths:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间看起来与ExpressJS的路由路径非常相似：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: However, as mentioned in previous recipes, these are not related to URLs. By
    default, a single TCP connection is created at this URL `http[s]://host:port/socket.io`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如前面的配方中提到的，这些与URL无关。默认情况下，在此URL`http[s]://host:port/socket.io`创建单个TCP连接
- en: 'Reusing the same event names is a good practice when using namespaces. For
    example, let''s suppose that we have a Socket.IO server that we use to emit a
    `setWelcomeMsg` event when the client emits a `getWelcomeMsg` event:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用命名空间时，重用相同的事件名称是一个很好的做法。例如，假设我们有一个Socket.IO服务器，当客户端发出`getWelcomeMsg`事件时，我们用来发出`setWelcomeMsg`事件：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, we defined a listener for the event `getWelcomeMsg` in two
    different namespaces:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在两个不同的命名空间中为事件`getWelcomeMsg`定义了监听器：
- en: If the client is connected to the English or `/en` namespace, when the `setWelcomeMsg`
    event is fired, the client will receive `"Hello World!"`
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果客户端连接到英语或`/en`命名空间，当`setWelcomeMsg`事件被触发时，客户端将收到`"Hello World!"`
- en: On the other hand, if the client is connected to the Spanish or `/es` namespace,
    when the `setWelcomeMsg` event is fired, the client will receive `"Hola Mundo!"`
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果客户端连接到西班牙语或`/es`命名空间，当`setWelcomeMsg`事件被触发时，客户端将收到`"Hola Mundo!"`
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will see how to work with two different namespaces that
    contain the same event names. Before you start, create a new `package.json` file
    with the following content:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将看到如何使用包含相同事件名称的两个不同命名空间。在开始之前，请创建一个新的`package.json`文件，其中包含以下内容：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Build a Socket.IO server that will fire a `data` event and send an object containing
    two properties, `title` and `msg`, that will be used to populate HTML content
    in the selected language. Use namespaces to separate and send different data according
    to the language that the client chooses, English or Spanish.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个Socket.IO服务器，该服务器将触发一个`data`事件，并发送一个包含两个属性`title`和`msg`的对象，该对象将用于填充所选语言的HTML内容。使用命名空间来分隔并根据客户端选择的语言（英语或西班牙语）发送不同的数据。
- en: Create a new file named `nsp-server.js`
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nsp-server.js`的新文件
- en: 'Include the Socket.IO npm module and the required modules for creating an HTTP
    server:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括Socket.IO npm模块和创建HTTP服务器所需的模块：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the `http` module to create a new HTTP server that will serve an HTML file
    you will create later as a Socket.IO client:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`http`模块创建一个新的HTTP服务器，该服务器将作为Socket.IO客户端提供的HTML文件的服务：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Specify the path new connections will be made to:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定新连接将要进行的路径：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For the `"/en"` namespace, add a new event listener, `getData`, which when
    fired will emit a `data` event on the client side and send an object including
    a `title` and a `msg` property in the English language:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"/en"`命名空间，添加一个新的事件监听器`getData`，当触发时将在客户端发出一个`data`事件，并发送一个包含`title`和`msg`属性的对象，使用英语语言：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the `"/es"` namespace, do the same. However, the object sent to the client
    will include a `title` and a `msg` property in the Spanish language:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"/es"`命名空间，做同样的事情。但是，发送到客户端的对象将包含西班牙语言中的`title`和`msg`属性：
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listen on port `1337` for new connections and attach Socket.IO to the underlying
    HTTP server:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听端口`1337`以获取新连接，并将Socket.IO附加到底层HTTP服务器：
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Save the file.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Afterwards, create a Socket.IO client that will connect to our server and populate
    HTML content based on the data received from the server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建一个Socket.IO客户端，将连接到我们的服务器，并根据从服务器接收到的数据填充HTML内容。
- en: Create a new file named `nsp-client.html`
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nsp-client.html`的新文件
- en: 'First, specify the document type as HTML5\. Next to it, add an `html` tag and
    set the language to English. Inside the `html` tag, include the `head` and `body`
    tags as well:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将文档类型指定为HTML5。在其旁边，添加一个`html`标签，并将语言设置为英语。在`html`标签内，还包括`head`和`body`标签：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Inside the `body` tag, add the first three elements: a heading (`h1`) that
    will contain the title of the content, a `p` tag that will include a message from
    the server, and a `button` that will be used to switch to a different namespace.
    Also, include the Socket.IO client library. The Socket.IO server will make the
    library file available at this URL: http[s]://host:port/socket.io/socket.io.js
    . Then, also include as well the `babel` standalone library which will transform
    the code in the next steps into JavaScript code that can run in all browsers:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`标签内，添加前三个元素：一个包含内容标题的标题（`h1`），一个包含来自服务器的消息的`p`标签，以及一个用于切换到不同命名空间的`button`。还包括Socket.IO客户端库。Socket.IO服务器将在此URL上提供库文件：http[s]://host:port/socket.io/socket.io.js。然后，还包括`babel`独立库，它将把下一步的代码转换为可以在所有浏览器中运行的JavaScript代码：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside the `body`, after the last `script` tags, add another `script` tag and
    set its type to `"text/babel"`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`内，在最后的`script`标签之后，添加另一个`script`标签，并将其类型设置为`"text/babel"`：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After that, inside the `script` tag, add the following JavaScript code
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`script`标签内，添加以下JavaScript代码
- en: 'Define three constants that will contain a reference to the elements we have
    created in the `body`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三个常量，它们将包含对`body`中创建的元素的引用：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define a Socket.IO client manager. It will help us to create sockets with the
    provided configuration:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Socket.IO客户端管理器。它将帮助我们使用提供的配置创建套接字：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a new socket that will connect to the `"/en"` namespace. We will assume
    that this is the default connection:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的套接字，将连接到`"/en"`命名空间。我们将假设这是默认连接：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Reserve two connections for namespaces `"/en"` and `"/es"`. A reserved connection
    will allow us to switch to a different namespace without the need of to create
    a new TCP connection:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`"/en"`和`"/es"`命名空间保留两个连接。保留连接将允许我们在不需要创建新的TCP连接的情况下切换到不同的命名空间：
- en: '[PRE62]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add an event listener that, once the socket is connected, will emit a `getData`
    event to request data from the server:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件监听器，一旦套接字连接，就会发出一个`getData`事件来请求服务器的数据：
- en: '[PRE63]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add an event listener for the `data` event that will get triggered when the
    client received data from the server:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`data`事件的事件监听器，当客户端从服务器接收到数据时将被触发：
- en: '[PRE64]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add an event listener for the `button`. When it gets clicked, switch to a different
    namespace:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`button`添加一个事件监听器。当单击时，切换到不同的命名空间：
- en: '[PRE65]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Save the file
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Open a new terminal and run:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE66]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the web browser, navigate to:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中，导航到：
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Let's test it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'To see your previous work in action, follow these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前的工作效果，请按照以下步骤操作：
- en: Once you navigate to `http://localhost:1337/` in your web browser, click on
    the `"Get Content in Spanish"` button to switch to the Spanish namespace
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在Web浏览器中导航到`http://localhost:1337/`，单击`"Get Content in Spanish"`按钮，切换到西班牙语命名空间
- en: Click on the `"Get Content in English"` button to switch back to the English
    namespace
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`"Get Content in English"`按钮，切换回英语命名空间
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This is what happens on the server side:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器端发生的事情：
- en: We defined two namespaces, `"/en"` and `"/es"`, then added a new event listener,
    `getData`, to the **socket object.**
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个命名空间，`"/en"`和`"/es"`，然后向**套接字对象**添加了一个新的事件监听器`getData`。
- en: When the `getData` event is fired in any of the two defined namespaces, it will
    emit a data event and send an object, that contains a title and a message property,
    to the client
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在任何两个定义的命名空间中触发`getData`事件时，它将发出一个数据事件，并向客户端发送一个包含标题和消息属性的对象
- en: 'On the client side, inside the script tag in our HTML document:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，在我们的HTML文档的`script`标签内：
- en: 'Initially, a new socket is created for the namespace `"/en"`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，为命名空间`"/en"`创建一个新的套接字：
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'At the same time, we created two new **sockets** for the namespaces `"/en"`
    and `"/es"`. They will act as reserved connections:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，我们为`"/en"`和`"/es"`命名空间创建了两个新的**套接字**。它们将充当保留连接：
- en: '[PRE69]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After, an event listener connect was added that sends a request to the server
    on connection
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，添加了一个事件监听器`connect`，在连接时向服务器发送请求
- en: Then, another event listener data was added that is fired when data is received
    from the server
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加了另一个`data`事件的事件监听器，当从服务器接收到数据时触发
- en: Inside the event listener that handles onclick events for our button, we change
    the nsp property to switch to a different namespace. However, for this to happen,
    we had to disconnect the **socket** first, and call the open method to make a
    new connection again using the new namespace
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理按钮的`onclick`事件的事件监听器内部，我们将`nsp`属性更改为切换到不同的命名空间。但是，为了实现这一点，我们必须首先断开**套接字**，然后调用`open`方法，再次使用新的命名空间建立新的连接
- en: 'Let''s see one of the confusing parts about reserved connections. When you
    create one or more **sockets** in the same namespace, the first connection is
    reused, for example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看关于保留连接的一个令人困惑的部分。当您在同一个命名空间中创建一个或多个**sockets**时，第一个连接会被重用，例如：
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: On the client side, if there were no reserved connections, then switching to
    a namespace that was not used before would result in a new connection being created.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，如果没有保留连接，那么切换到以前未使用过的命名空间将导致创建一个新连接。
- en: 'If you are curious, remove these two lines from the `nsp-client.html` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感到好奇，请从`nsp-client.html`文件中删除这两行：
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Afterwards, restart or run the Socket.IO server again. You will notice that
    there is a slow response when switching to a different namespace because a new
    connection is created instead of being reused.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，重新启动或再次运行Socket.IO服务器。您会注意到切换到不同命名空间时会有一个缓慢的响应，因为会创建一个新连接而不是重用。
- en: 'There is an alternative way of achieving the same goal. We could have created
    two sockets that point to two different namespaces, `"/en"` and `"/es"`. Then,
    we could have added two event listeners connect and data to each socket. However,
    because the first and second socket would contain the same event names and receive
    data in the same format from the server, we would have gotten repeated code. Imagine
    the case if we had to do the same for five different namespaces that have the
    same event names and receive data in the same format, there would be too many
    repeated lines of code. This is where switching namespaces and reusing the same
    socket object is helpful. However, there may be cases were two or more different
    namespaces have different event names for different kinds of event, in that case,
    it is better to add event listeners for each of the namespaces separately. For
    example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代方法可以实现相同的目标。我们可以创建两个指向两个不同命名空间`"/en"`和`"/es"`的socket。然后，我们可以为每个socket添加两个事件监听器connect和data。然而，因为第一个和第二个socket将包含相同的事件名称，并且以相同的格式从服务器接收数据，我们将得到重复的代码。想象一下，如果我们必须为五个具有相同事件名称并以相同格式从服务器接收数据的不同命名空间做同样的事情，那将会有太多重复的代码行。这就是切换命名空间并重用相同的socket对象有帮助的地方。然而，可能存在两个或更多不同的命名空间具有不同事件名称的情况，对于不同类型的事件，最好为每个命名空间单独添加事件监听器。例如：
- en: '[PRE72]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: On the client side, you have probably noticed one thing that we didn't use before,
    `io.Manager`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，您可能已经注意到了一个我们以前没有使用过的东西，`io.Manager`。
- en: io.Manager
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: io.Manager
- en: This allows us predefine or configure how new connections will be created. The
    options defined in a `Manager`, as the URL, will be passed to the socket on initiation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够预定义或配置新连接将如何创建。在`Manager`中定义的选项，如URL，将在初始化时传递给socket。
- en: 'In our HTML file, inside a `script` tag, we created a new instance of `io.Manager`
    and passed two arguments; the server URL and an options object including a `path`
    property which indicates where new connections will be made:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML文件中，在`script`标签内，我们创建了`io.Manager`的一个新实例，并传递了两个参数；服务器URL和一个包含`path`属性的选项对象，该属性指示新连接将被创建的位置：
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: To find out more about the `io.Manager` API visit the official documentation
    Website offer for Socket.IO [https://socket.io/docs/client-api/#manager](https://socket.io/docs/client-api/#manager).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`io.Manager`API的更多信息，请访问官方文档网站提供的Socket.IO [https://socket.io/docs/client-api/#manager](https://socket.io/docs/client-api/#manager)。
- en: 'Later, we used the `socket` method to initialize and create a new Socket for
    the provided namespace:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们使用了`socket`方法来初始化并创建一个提供的命名空间的新Socket：
- en: '[PRE74]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This way, it is easier to work with several namespaces at the same time without
    having to configure each one of them with the same options.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，就可以更容易地同时处理多个命名空间，而无需为每个命名空间配置相同的选项。
- en: Defining and joining Socket.IO rooms
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和加入Socket.IO房间
- en: Within namespaces, you can define rooms or channels that a socket can join and
    leave.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间内，您可以定义一个socket可以加入和离开的房间或通道。
- en: 'By default, a room is created with a random un-guessable ID for the connected
    **socket**:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，房间会使用一个随机的不可猜测的ID来创建与连接的**socket**：
- en: '[PRE75]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'On connection, when emitting an event, for example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接时，例如发出一个事件时：
- en: '[PRE76]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'What happens underneath is similar to this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 底层发生的情况类似于这样：
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `join` method was used to include the socket inside a room. In this case,
    the socket ID is the joint room, and the only client connected to that room is
    the socket itself.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`方法用于将socket包含在房间内。在这种情况下，socket ID是联合房间，连接到该房间的唯一客户端就是socket本身。'
- en: Because a socket ID represents a unique connection with a client and, by default,
    a room with the same ID is created; all data sent by the server to that room will
    be received only by that client. However, if several clients or socket IDs join
    a room with the same name and the server sends data; all clients could be able
    to receive it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因为socket ID代表与客户端的唯一连接，并且默认情况下会创建具有相同ID的房间；服务器发送到该房间的所有数据将只被该客户端接收。然而，如果几个客户端或socket
    ID加入具有相同名称的房间，并且服务器发送数据；所有客户端都可以接收到。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will see how to join a room and broadcast a message to
    all clients connected to that specific room. Before you start, create a new `package.json`
    file with the following content:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将看到如何加入一个房间并向连接到该特定房间的所有客户端广播消息。在开始之前，创建一个新的`package.json`文件，内容如下：
- en: '[PRE78]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE79]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Build a Socket.IO server that will notify all the connected clients to the `"commonRoom"`
    room when a new socket is connected.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个Socket.IO服务器，当新的socket连接时，它将通知所有连接的客户端加入`"commonRoom"`房间。
- en: Create a new file named `rooms-server.js`
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`rooms-server.js`的新文件
- en: 'Include the Socket.IO NPM module and initialize a new HTTP server:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括Socket.IO NPM模块并初始化一个新的HTTP服务器：
- en: '[PRE80]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Specify the path where new connections will be made:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定新连接将被创建的路径：
- en: '[PRE81]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Use the root namespace to listen for events:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用根命名空间来监听事件：
- en: '[PRE82]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Define a method that will be used to emit an `updateClientCount` event to all
    socket clients connected to the `"commonRoom"` providing as an argument the number
    of connected clients:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法，用于向连接到`"commonRoom"`的所有套接字客户端发出`updateClientCount`事件，并提供连接的客户端数量作为参数：
- en: '[PRE83]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'On connection, all newly connected Socket clients will join the `commonRoom`.
    Then, the server will emit a `welcome` event. After this, notify all connected
    sockets to update the number of connected clients and also do the same operation
    once a client is disconnected:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接后，所有新连接的Socket客户端都将加入`commonRoom`。然后，服务器将发出`welcome`事件。之后，通知所有连接的套接字更新连接客户端的数量，并在客户端断开连接时执行相同的操作：
- en: '[PRE84]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Listen on port `1337` for new connections and attach Socket.IO to the HTTP
    server:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听端口`1337`以进行新连接，并将Socket.IO附加到HTTP服务器：
- en: '[PRE85]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Save the file.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'After this, build a Socket.IO client that will connect to the Socket.IO server
    and populate the HTML content with received data:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，构建一个Socket.IO客户端，该客户端将连接到Socket.IO服务器并使用接收到的数据填充HTML内容：
- en: Create a new file named `rooms-client.html`
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`rooms-client.html`的新文件
- en: 'Add the following code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE86]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Inside the script tag, add code in the following steps, starting from step 4
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签中，按以下步骤添加代码，从第4步开始
- en: 'Define two constants that will make a reference to two HTML elements that we
    will update according to the data sent by the Socket.IO Server:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个常量，它们将引用两个HTML元素，我们将根据Socket.IO服务器发送的数据进行更新：
- en: '[PRE87]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Define a Socket.IO Client Manager:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Socket.IO客户端管理器：
- en: '[PRE88]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Use the root namespace which is the one used in the Socket.IO Server:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Socket.IO服务器中使用的根命名空间：
- en: '[PRE89]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Add an event listener for the `welcome` event that expects an argument that
    will contain a welcome message sent by the server:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`welcome`事件添加事件侦听器，该事件预期包含服务器发送的欢迎消息作为参数：
- en: '[PRE90]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Add an event listener for the `updateClientCount` event that expects an argument
    that will contain the number of connected clients:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`updateClientCount`事件添加事件侦听器，该事件预期包含一个参数，该参数将包含连接的客户端数量：
- en: '[PRE91]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Save the file
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Open a new Terminal and run:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE92]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'On the web browser, navigate to:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中，导航到：
- en: '[PRE93]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Without closing the previous tab or window, on the web browser, navigate once
    again to:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不关闭上一个选项卡或窗口的情况下，再次在Web浏览器中导航到：
- en: '[PRE94]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The number of connected clients in both tabs or windows should have increased
    to `2`
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个选项卡或窗口中连接的客户端数量应该增加到`2`
- en: There's more...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Sending the same message or data, to more than one client, is called broadcasting.
    The method we have seen broadcasts a message to all clients, including the client
    that generated the request.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 向多个客户端发送相同的消息或数据称为广播。我们已经看到的方法向所有客户端广播消息，包括生成请求的客户端。
- en: 'There are other several methods to broadcast a message. For instance:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几种广播消息的方法。例如：
- en: '[PRE95]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Which will emit an `updateClientCount` event to all clients in `commonRoom`
    expect to the sender or the socket that originated the request.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向`commonRoom`中的所有客户端发出`updateClientCount`事件，但不包括发出请求的发送方或套接字。
- en: 'For a complete list check the official documentation of Socket.IO emit cheatsheet:
    [https://socket.io/docs/emit-cheatsheet/](https://socket.io/docs/emit-cheatsheet/)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整列表，请查看Socket.IO发射速查表的官方文档：[https://socket.io/docs/emit-cheatsheet/](https://socket.io/docs/emit-cheatsheet/)
- en: Writing middleware for Socket.IO
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Socket.IO编写中间件
- en: 'Socket.IO allows us to define two kinds of middleware functions in the server
    side:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO允许我们在服务器端定义两种类型的中间件函数：
- en: '**Namespace middleware**: Registers a function that gets executed for every
    new connected Socket and has the following signature:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间中间件**：注册一个函数，该函数将在每个新连接的Socket上执行，并具有以下签名：'
- en: '[PRE96]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '**Socket middleware**: Registers a function that gets executed for every incoming
    Packet and has the following signature:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Socket中间件**：注册一个函数，该函数将在每个传入的数据包上执行，并具有以下签名：'
- en: '[PRE97]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It works similarly to how ExpressJS middleware functions do. We can add new
    properties to the `socket` or `packet` objects. Then, we can call `next` to pass
    the control to the next middleware in the chain. If `next` is not called, then
    the `socket` won't be connected, or the `packet` received.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式类似于ExpressJS中间件函数。我们可以向`socket`或`packet`对象添加新属性。然后，我们可以调用`next`将控制传递给链中的下一个中间件。如果未调用`next`，则不会连接`socket`，或者接收到的`packet`。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will build a Socket.IO server application where you will
    define middleware functions to restrict access to a certain namespace as well
    as restricting access to a certain socket based on some criteria. Before you start,
    create a new `package.json` file with the following content:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将构建一个Socket.IO服务器应用程序，在其中定义中间件函数以限制对某个命名空间的访问，以及根据某些条件限制对某个套接字的访问。在开始之前，请创建一个包含以下内容的新的`package.json`文件：
- en: '[PRE98]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE99]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How to do it...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The Socket.IO server application will expect the users to be logged-in in order
    for them to be able to connect to the `/home` namespace. Using socket middleware,
    we will also restrict access to `/home` namespace to a certain user:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器应用程序将期望用户已登录，以便他们能够连接到`/home`命名空间。使用socket中间件，我们还将限制对`/home`命名空间的访问权限：
- en: Create a new file named `middleware-server.js`
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`middleware-server.js`的新文件
- en: 'Include the Socket.IO library and initialize a new HTTP server:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括Socket.IO库并初始化一个新的HTTP服务器：
- en: '[PRE100]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Specify the path where new connections will be made:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定新连接将建立的路径：
- en: '[PRE101]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Define an array of users that we will use as an in-memory database:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用户数组，我们将将其用作内存数据库：
- en: '[PRE102]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Define a method to verify if the provided username and password exist in the
    users array:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法来验证提供的用户名和密码是否存在于用户数组中：
- en: '[PRE103]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Define a namespace middleware function that will check whether the user is
    already logged-in. A client won''t be able to connect to a specific namespace
    using this middleware if they are not logged in:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个命名空间中间件函数，该函数将检查用户是否已经登录。如果用户未登录，客户端将无法使用此中间件连接到特定命名空间：
- en: '[PRE104]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Define two namespaces, one for `/login` and another for `/home`. The `/home`
    namespace will use our previously defined middleware function to check whether
    the user is logged in:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个命名空间，一个用于`/login`，另一个用于`/home`。`/home`命名空间将使用我们之前定义的中间件函数来检查用户是否已登录：
- en: '[PRE105]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When a new socket is connected to `/login` namespace, first we will define
    a socket middleware function for checking all incoming packages and ban access
    to the `johntm` username. Then, we will add an event listener for the enter event
    that will expect to receive a plain object containing a username and password,
    and if they exist in the users array, then we set a session object which will
    tell whether the user is logged in. Otherwise, we will send a `loginError` event
    with an error message to the client:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个新的socket连接到`/login`命名空间时，首先我们将为检查所有传入的数据包定义一个socket中间件函数，并禁止`johntm`用户名的访问。然后，我们将为输入事件添加一个事件监听器，该事件将期望接收一个包含用户名和密码的纯对象，如果它们存在于用户数组中，那么我们将设置一个会话对象，告诉用户是否已登录。否则，我们将向客户端发送一个带有错误消息的`loginError`事件：
- en: '[PRE106]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Listen on port 1337 for new connections and attach Socket.IO to the HTTP server:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听端口1337以获取新连接并将Socket.IO附加到HTTP服务器：
- en: '[PRE107]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Save the file
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'After this, build a Socket.IO client application that will connect to our Socket.IO
    Server and allow us to attempt to log in and test:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，构建一个Socket.IO客户端应用程序，它将连接到我们的Socket.IO服务器，并允许我们尝试登录和测试：
- en: Create a new file named `middleware-cli.html`
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`middleware-cli.html`的新文件
- en: 'Add the following code:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE108]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Inside the script tag, add the code in the following steps, starting from step
    4
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签内，从步骤4开始，添加以下代码
- en: 'Define three constant that will make a reference to the HTML elements that
    we will use to get input or display output:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三个常量，它们将引用我们将用于获取输入或显示输出的HTML元素：
- en: '[PRE109]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Define a Socket.IO Manager:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Socket.IO管理器：
- en: '[PRE110]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Let''s define a namespace constant that will contain an object containing the
    Socket.IO namespaces `/home` and `/login`:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个命名空间常量，其中包含一个包含Socket.IO命名空间`/home`和`/login`的对象：
- en: '[PRE111]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Add an event listener for the connect event to the `/home` namespace. It will
    get triggered only when the `/home` namespace successfully connects to the server:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`/home`命名空间添加一个`connect`事件的事件监听器。只有当`/home`命名空间成功连接到服务器时才会触发：
- en: '[PRE112]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Add an event listener for the `loginSuccess` event to the `/login` namespace.
    It will ask the `/home` namespace to connect to the server again. If the user
    is logged in, then the server will allow this connection:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`/login`命名空间添加一个`loginSuccess`事件的事件监听器。它将要求`/home`命名空间再次连接到服务器。如果用户已登录，则服务器将允许此连接：
- en: '[PRE113]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Add an event listener for the `loginError` event to the `/login` namespace.
    It will display error messages sent by the server:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`/login`命名空间添加一个`loginError`事件的事件监听器。它将显示服务器发送的错误消息：
- en: '[PRE114]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Add an event listener for the submit event for the login form. It will emit
    the enter event providing an object containing the username and password filled
    in the form:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为登录表单的提交事件添加事件监听器。它将发出输入事件，提供一个包含在表单中填写的用户名和密码的对象：
- en: '[PRE115]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Save the file
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: Let's test it...
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'To see our previous work in action:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '查看我们之前的工作的效果： '
- en: 'Run the Socket.IO server first. Open a new terminal and run:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先运行Socket.IO服务器。打开一个新的终端并运行：
- en: '[PRE116]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'On your web browser, navigate to:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中，导航到：
- en: '[PRE117]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: You will see a login form with two fields, `username` and `password`
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个带有两个字段`username`和`password`的登录表单
- en: 'Try to log in with random invalid credentials. The following error is displayed:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用随机无效的凭据登录。将显示以下错误：
- en: '[PRE118]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Next, try to log in with `johntm` as `username` and any `password`. The following
    error is displayed:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试使用`johntm`作为`username`和任何`password`登录。将显示以下错误：
- en: '[PRE119]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'After that, log in with any of the two other valid credentials. For instance,
    using `jingxuan` as username and `qscwdvb` as password. The following title is
    displayed:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用另外两个有效凭据之一登录。例如，使用`jingxuan`作为用户名和`qscwdvb`作为密码。将显示以下标题：
- en: '[PRE120]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Integrating Socket.IO with ExpressJS
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Socket.IO与ExpressJS集成
- en: Socket.IO works well with ExpressJS. In fact, it's possible to run an ExpressJS
    application and a Socket.IO server using the same port or HTTP server.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO与ExpressJS配合良好。事实上，可以在同一端口或HTTP服务器上运行ExpressJS应用程序和Socket.IO服务器。
- en: Getting ready
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will see how to integrate Socket.IO with ExpressJS. You
    will build an ExpressJS application that will serve an HTML file containing a
    Socket.IO client application. Before you start, create a new `package.json` file
    with the following content:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何将Socket.IO与ExpressJS集成。您将构建一个ExpressJS应用程序，该应用程序将提供包含Socket.IO客户端应用程序的HTML文件。在开始之前，创建一个新的`package.json`文件，内容如下：
- en: '[PRE121]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行来安装依赖项：
- en: '[PRE122]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a Socket.IO client application that will connect to the Socket.IO server,
    that you will build next, and display a welcome message sent by the server.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Socket.IO客户端应用程序，它将连接到您将要构建的Socket.IO服务器，并显示服务器发送的欢迎消息。
- en: Create a new file named `io-express-view.html`
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`io-express-view.html`的新文件
- en: 'Add the following code:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE123]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Save the file
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Next, build an ExpressJS application and a Socket.IO server. The ExpressJS
    application will serve the previously created HTML file on the root path `"/"`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建一个ExpressJS应用程序和一个Socket.IO服务器。ExpressJS应用程序将在根路径`"/"`上提供先前创建的HTML文件：
- en: Create a new file named `io-express-server.js`
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`io-express-server.js`的新文件
- en: 'Initialize a new Socket.IO server application and an ExpressJS application:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的Socket.IO服务器应用程序和一个ExpressJS应用程序：
- en: '[PRE124]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Define the URL path where new connections will be made to the Socket.IO server:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新连接将连接到Socket.IO服务器的URL路径：
- en: '[PRE125]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Define a route method to serve our HTML file containing our Socket.IO client
    application:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个路由方法来提供包含我们的Socket.IO客户端应用程序的HTML文件：
- en: '[PRE126]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Define a namespace `"/"` and emit a `welcome` event with welcome message:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个命名空间`"/"`并发出一个带有欢迎消息的`welcome`事件：
- en: '[PRE127]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Attach the Socket.IO to ExpressJS Server:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Socket.IO附加到ExpressJS服务器：
- en: '[PRE128]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Save the file
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Open the Terminal and run:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行：
- en: '[PRE129]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'In your browser, visit:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中访问：
- en: '[PRE130]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: How it works...
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Socket.IO's `attach` method expects to receive a HTTP server as a parameter
    in order to attach the Socket.IO server application to it. The reason why we can
    attach Socket.IO to an ExpressJS server application is because the `listen` method
    returns the underlying HTTP server to which ExpressJS is connected.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO的`attach`方法期望接收一个HTTP服务器作为参数，以便将Socket.IO服务器应用程序附加到它上面。我们之所以能够将Socket.IO附加到ExpressJS服务器应用程序上，是因为`listen`方法返回ExpressJS连接的基础HTTP服务器。
- en: To sum up, the `listen` method returns the underlying HTTP server. Then, it
    is passed as a parameter to the `attach` method. This way, we can share the same
    connection with ExpressJS.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`listen`方法返回基础HTTP服务器。然后，它作为参数传递给`attach`方法。这样，我们可以与ExpressJS共享相同的连接。
- en: There's more...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: So far, we have seen that we can share the same underlying HTTP server between
    ExpressJS and Socket.IO. However, that is not all.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以在ExpressJS和Socket.IO之间共享相同的基础HTTP服务器。然而，这还不是全部。
- en: 'The reason why we define a Socket.IO path is actually useful when working with
    ExpressJS. Take the following example:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义Socket.IO路径的原因实际上在与ExpressJS一起工作时非常有用。看以下示例：
- en: '[PRE131]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As you can see, we are using the same URL path for Socket.IO and ExpressJS.
    We accept new connections to the Socket.IO server on the `/socket.io` path, but
    we also send content for `/socket.io` using the GET route method.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在Socket.IO和ExpressJS中使用相同的URL路径。我们接受新连接到`/socket.io`路径上的Socket.IO服务器，但我们也使用GET路由方法发送内容到`/socket.io`。
- en: 'Even though this preceding example won''t actually break your application,
    make sure to never use the same URL path to serve content from ExpressJS and accept
    new connections for Socket.IO at the same time. For instance, changing the previous
    code to this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述示例实际上不会破坏您的应用程序，但请确保永远不要同时使用相同的URL路径来从ExpressJS提供内容并接受Socket.IO的新连接。例如，将上一个代码更改为以下内容：
- en: '[PRE132]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'While you may expect your browser, when visiting `http://localhost:1337/socket.io/message`,
    to display `message`, that won''t be the case and you will see the following instead:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问`http://localhost:1337/socket.io/message`时，您可能期望您的浏览器显示`message`，但事实并非如此，您将看到以下内容：
- en: '[PRE133]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: That is because Socket.IO will interpret the incoming data first and it won't
    understand the data you just sent. In addition, your route handler will never
    be executed.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Socket.IO将首先解释传入的数据，它不会理解您刚刚发送的数据。此外，您的路由处理程序将永远不会被执行。
- en: Besides that, the Socket.IO server also serves, by default, its own Socket.IO
    Client under the defined URL path. For example, try visiting [http://localhost:1337/socket.io/socket.io.js](http://localhost:1337/socket.io/socket.io.js)
    and you will be able to see the minimized JavaScript code of the Socket.IO client.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Socket.IO服务器还默认提供其自己的Socket.IO客户端，位于定义的URL路径下。例如，尝试访问[http://localhost:1337/socket.io/socket.io.js](http://localhost:1337/socket.io/socket.io.js)，您将能够看到Socket.IO客户端的最小化JavaScript代码。
- en: 'If you wish to server your own version of Socket.IO client or if it is included
    in the bundle of your application, you can disable the default behavior in your
    Socket.IO server application with the `serveClient` method:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望提供自己版本的Socket.IO客户端，或者如果它包含在您的应用程序的捆绑包中，您可以使用`serveClient`方法在Socket.IO服务器应用程序中禁用默认行为。
- en: '[PRE134]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: See also
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 2](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml), *Building a Web server
    with ExpressJS*, section *Using Express.js'' built-in middleware function for
    serving static assets*'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml)，*使用Express.js内置中间件函数为静态资源提供服务*'
- en: Using ExpressJS middleware in Socket.IO
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Socket.IO中使用ExpressJS中间件
- en: 'Socket.IO namespace middleware works pretty similar to how ExpressJS middleware
    does. In fact, the Socket Object also contains a `request` and a `response` object
    that we can use to store other properties in the same manner as we do with ExpressJS
    middleware functions:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO命名空间中间件的工作方式与ExpressJS中间件非常相似。事实上，Socket对象还包含一个`request`和一个`response`对象，我们可以使用它们以与ExpressJS中间件函数相同的方式存储其他属性：
- en: '[PRE135]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Because ExpressJS middleware functions have the following signature:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ExpressJS中间件函数具有以下签名：
- en: '[PRE136]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We can safely execute the same function in a Socket.IO namespace middleware
    passing the necessary arguments:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地在Socket.IO命名空间中间件中执行相同的函数，传递必要的参数：
- en: '[PRE137]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: However, that doesn't mean that all ExpressJS middleware functions will work
    out of the box. For example, if an ExpressJS middleware function uses methods
    only available within ExpressJS, it may fail or have an unexpected behavior.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着所有ExpressJS中间件函数都能直接使用。例如，如果ExpressJS中间件函数仅使用ExpressJS中可用的方法，它可能会失败或产生意外行为。
- en: Getting ready
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will see how to integrate the ExpressJS `express-session`
    middleware to share the session object between Socket.IO and ExpressJS. Before
    you start, create a new `package.json` file with the following content:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何将ExpressJS的`express-session`中间件集成到Socket.IO和ExpressJS之间共享会话对象。在开始之前，创建一个新的`package.json`文件，内容如下：
- en: '[PRE138]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE139]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How to do it...
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Build a Socket.IO client application that will connect to a Socket.IO server
    you will build next. Include a form where the user can type a username and a password
    to attempt to log in. The Socket.IO client will only be able to connect to the
    `/home` namespace after the user is logged-in:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个Socket.IO客户端应用程序，它将连接到接下来您将构建的Socket.IO服务器。包括一个表单，用户可以在其中输入用户名和密码尝试登录。只有在用户登录后，Socket.IO客户端才能连接到`/home`命名空间：
- en: Create a new file named `io-express-cli.html`
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`io-express-cli.html`的新文件
- en: 'Add the following HTML content:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下HTML内容：
- en: '[PRE140]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Inside the script tag add the code in the next steps, starting from step 4
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签中添加从第4步开始的下一步中的代码
- en: 'Define constants that make a reference to the HTML elements that we will use:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义引用我们将使用的HTML元素的常量：
- en: '[PRE141]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Define a Socket.IO Manager:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Socket.IO管理器：
- en: '[PRE142]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Define two namespaces, one for `/login` and another one for `/home`:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个命名空间，一个用于`/login`，另一个用于`/home`：
- en: '[PRE143]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Add an event listener for the `welcome` event that will be triggered by the
    server side once a connection is allowed to the `/home` namespace:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`welcome`事件添加一个事件监听器，该事件将在允许连接到`/home`命名空间时由服务器端触发：
- en: '[PRE144]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Add an event listener for `loginSuccess` event that, when triggered, will ask
    the `/home` namespace to try and reconnect to the Socket.IO Server:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`loginSuccess`事件添加一个事件监听器，当触发时，将要求`/home`命名空间尝试重新连接到Socket.IO服务器：
- en: '[PRE145]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Add an event listener for `loginError` event that will display an error when
    invalid credentials are provided:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`loginError`事件添加一个事件监听器，当提供无效凭据时将显示错误：
- en: '[PRE146]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Add an event listener for `submit` event that will get triggered when submitting
    the form. It will emit an `enter` event with data containing the provided `username`
    and `password`:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`submit`事件添加一个事件监听器，当提交表单时将触发该事件。它将发出一个带有包含提供的`username`和`password`的数据的`enter`事件：
- en: '[PRE147]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Save the file.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'After this, build an ExpressJS application that will serve the Socket.IO client
    on the root path `"/"` and a Socket.IO server that will include the logic for
    logging the user:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，构建一个ExpressJS应用程序，该应用程序将在根路径`"/"`上提供Socket.IO客户端，并包含用于记录用户的逻辑的Socket.IO服务器：
- en: Create a new file named `io-express-srv.js`
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`io-express-srv.js`的新文件
- en: 'Initialize a new ExpressJS application and a Socket.IO server application.
    Also, include the `express-session` NPM module:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的ExpressJS应用程序和一个Socket.IO服务器应用程序。还包括`express-session` NPM模块：
- en: '[PRE148]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Define the path where new connections to Socket.IO server will be made:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新连接到Socket.IO服务器的路径：
- en: '[PRE149]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Define an ExpressJS session middleware function with the given options:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定选项定义一个ExpressJS会话中间件函数：
- en: '[PRE150]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Define a Socket.IO namespace middleware that will use the previously created
    session middleware to generate a session object:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Socket.IO命名空间中间件，该中间件将使用先前创建的会话中间件生成会话对象：
- en: '[PRE151]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Define two namespaces, one for `/home` and another for `/login`:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个命名空间，一个用于`/home`，另一个用于`/login`：
- en: '[PRE152]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Define an in-memory database or array of objects that will contain `username`
    and `password` properties. These define which users are allowed to login:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个内存数据库或包含`username`和`password`属性的对象数组。这些属性定义了允许登录的用户：
- en: '[PRE153]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Include the session middleware in ExpressJS:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ExpressJS中包含会话中间件：
- en: '[PRE154]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Add a route method for `/home` path that will serve our previously created
    HTML document containing the Socket.IO client:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`/home`路径添加一个路由方法，用于提供我们之前创建的包含Socket.IO客户端的HTML文档：
- en: '[PRE155]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Use the session middleware in `/home` Socket.IO namespace. Then, check for
    every new socket if the user is logged in. If not, forbid the user to connect
    to this namespace:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/home` Socket.IO命名空间中使用会话中间件。然后，检查每个新的socket是否已登录。如果没有，禁止用户连接到此命名空间：
- en: '[PRE156]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Once a connection is made to the `/home` namespace, meaning that the user can
    log in, emits a `welcome` event with a welcome message that will be displayed
    to the user:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接到`/home`命名空间，也就是用户可以登录，就会发出一个带有欢迎消息的`welcome`事件，该消息将显示给用户：
- en: '[PRE157]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Use the Session Middleware in the `/login` Socket.IO namespace. Then, when
    the client emits an `enter` event with the provided username and password, it
    verifies the profile exists in the `users` array. If the user exists, set the
    `isLogged` property to `true` and the `username` property to the current user
    that has logged in:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/login` Socket.IO命名空间中使用会话中间件。然后，当客户端发出带有提供的用户名和密码的`enter`事件时，它会验证`users`数组中是否存在该配置文件。如果用户存在，则将`isLogged`属性设置为`true`，并将`username`属性设置为当前已登录的用户：
- en: '[PRE158]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Listen on port `1337` for new connections and attach the Socket.IO server to
    it:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听端口`1337`以获取新连接，并将Socket.IO服务器附加到该端口：
- en: '[PRE159]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Save the file
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Open a new Terminal and run:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE160]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'In your browser, visit:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问：
- en: '[PRE161]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Login with valid credentials. For example:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用有效的凭据登录。例如：
- en: '[PRE162]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: If you logged in successfully, after refreshing the page, your Socket.IO client
    application will still be able to connect to `/home` and you will see a welcome
    message every time
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您成功登录，刷新页面后，您的Socket.IO客户端应用程序仍然能够连接到`/home`，并且每次都会看到欢迎消息
- en: How it works...
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the session middleware is used inside ExpressJS, after modifying the session
    object, the `save` method is automatically called at the end of the response.
    However, that is not the case when using the session middleware in Socket.IO namespaces,
    that is why we call the `save` method manually to save the session back to the
    store. In our case, the store is the memory where the sessions are kept until
    the server stops.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 当在ExpressJS中使用会话中间件时，在修改会话对象后，响应结束时会自动调用`save`方法。然而，在Socket.IO命名空间中使用会话中间件时并非如此，这就是为什么我们需要手动调用`save`方法将会话保存回存储中的原因。在我们的情况下，存储是内存，会话会一直保存在那里直到服务器停止。
- en: Forbidding access to certain namespaces based on specific conditions is possible
    thanks to Socket.IO namespace middleware. If the control is not passed to the
    `next` handler, then the connection is not made. That's why after the login is
    successful, we ask the `/home` namespace to attempt to connect again.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定条件禁止访问某些命名空间是可能的，这要归功于Socket.IO命名空间中间件。如果控制权没有传递给`next`处理程序，那么连接就不会建立。这就是为什么在登录成功后，我们要求`/home`命名空间再次尝试连接。
- en: See also
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 2](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml), *Building a Web server
    with ExpressJS*, section *Writing middleware functions*'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](66f37ef6-5a78-4c3e-85ba-738094c9eba2.xhtml)，*使用ExpressJS构建Web服务器*，*编写中间件函数*部分'
