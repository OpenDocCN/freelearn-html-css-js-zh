- en: Chapter 7. Viewing Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 视觉信息
- en: The view layer is the last data flow stop in a Flux architecture. Views are
    the essence of our application because they provide information directly to the
    user and respond directly to user interactions. This chapter takes a detailed
    look at view components within the context of a Flux architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 视图层是Flux架构中数据流的最后一个停止点。视图是我们应用程序的本质，因为它们直接向用户提供信息并直接响应用户交互。本章将详细探讨在Flux架构背景下视图组件。
- en: We'll start with a discussion about getting views their data, and what they
    can do with it once they have it. Next, we'll look at some examples that emphasize
    the stateless nature of Flux views. Then, we'll review the responsibilities of
    views in Flux architectures, which are different from views in other types of
    frontend architectures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论如何获取视图数据以及它们拥有数据后可以做什么开始。接下来，我们将查看一些强调Flux视图无状态特性的示例。然后，我们将回顾Flux架构中视图的责任，这与其他类型的前端架构中的视图责任不同。
- en: We'll wrap the chapter up with a look at using ReactJS components as the view
    layer. Let's get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用使用ReactJS组件作为视图层的例子来结束本章。让我们开始吧！
- en: Passing views data
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向视图传递数据
- en: Views don't have their own data source that they can use to render UI elements.
    Instead, they rely on the state of Flux stores, and they listen for changes in
    state. In this section, we'll cover the change event that stores will emit to
    signify that views can render themselves. We'll also discuss the idea that it's
    ultimately up to the view to decide when and how to render the UI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 视图没有它们自己的数据源来渲染UI元素。相反，它们依赖于Flux存储的状态，并监听状态的变化。在本节中，我们将介绍存储将发出以表示视图可以渲染自己的变化事件。我们还将讨论最终由视图决定何时以及如何渲染UI的想法。
- en: Data via the change event
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过变化事件传递数据
- en: The view components that we've seen so far in this book have all relied on the
    change event that stores emit when the state of a store has changed. This is how
    the view knows that it can render itself to the DOM—because there's new store
    state, meaning that there's probably a visual change that we want the user to
    see.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们迄今为止看到的视图组件都依赖于存储在状态发生变化时发出的变化事件。这就是视图知道它可以渲染到DOM的原因——因为存在新的存储状态，这意味着可能有一个我们希望用户看到的视觉变化。
- en: 'You may have noticed from the earlier examples that all the handler functions
    that listen for change events had a state parameter—this is the state of the store.
    The question is—why do we need to include this state data? Why can''t the view
    just reference the store directly to reference the state data? This idea is illustrated
    here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，从早期示例中，所有监听变化事件的处理器函数都有一个状态参数——这是存储的状态。问题是——为什么我们需要包含这些状态数据？视图为什么不能直接引用存储来引用状态数据？这个想法在这里得到了说明：
- en: '![Data via the change event](img/B05419_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![通过变化事件传递数据](img/B05419_07_01.jpg)'
- en: 'The change event is still necessary, even though the view is directly referencing
    the store''s state—how else would it know to render? The change event is emitted,
    and the view then knows that the state it''s referencing has changed as well.
    There''s a potential issue with this approach, and it has to do with immutability.
    Let''s look at some code to better understand the problem. Here''s a store with
    a `name` property as its state:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使视图直接引用存储的状态，变化事件仍然是必要的——否则它如何知道要渲染呢？变化事件被发出，然后视图知道它引用的状态也发生了变化。这种方法存在一个潜在问题，这与不可变性有关。让我们看看一些代码来更好地理解这个问题。这是一个具有`name`属性作为其状态的存储：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When this store responds to the `NAME_CAPS` action, its job is to transform
    the state of the `name` property, using a simple call to `toUpperCase()`. Then,
    the change event is emitted with the state as the event data. Let''s look at another
    store that does the same thing, but using a different approach to updating the
    `state` object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个存储响应`NAME_CAPS`动作时，它的任务是使用简单的`toUpperCase()`调用转换`name`属性的状态。然后，变化事件以状态作为事件数据被发出。让我们看看另一个执行相同操作但使用不同方法更新`state`对象的存储：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the two stores are basically identical, and they produce the
    same result when the `NAME_CAPS` action is dispatched. However, note that this
    transformation doesn''t mutate the `state` object. It replaces it instead. This
    approach keeps the state object immutable, meaning that the store will never change
    any of its properties. The difference is felt in the view layer, and it highlights
    the need for the state argument in the change event handler:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个商店基本上是相同的，当`NAME_CAPS`动作被分发时，它们会产生相同的结果。然而，请注意，这种转换不会改变`state`对象。相反，它会替换它。这种方法使状态对象不可变，这意味着商店永远不会改变其任何属性。差异在视图层感受到，并突出了在更改事件处理程序中需要状态参数的需求：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is why we can't make assumptions about the state of a store. In the preceding
    code, we just made a critical error in assuming that we could hold onto a `secondStore.state`
    reference. It turns out that this object is immutable, and so the only way for
    views to access the new state is through the state argument in the change handler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们不能对商店的状态做出假设。在前面的代码中，我们犯了一个关键的错误，假设我们可以保留`secondStore.state`引用。结果证明，这个对象是不可变的，因此视图访问新状态的唯一方法是通过更改处理程序中的状态参数。
- en: Views decide when to render
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图决定何时渲染
- en: The job of a Flux store is centered primarily on generating the correct information
    for views to consume. What isn't part of a store's job description is to know
    when a view actually needs to update or not. This means that it's up to the view
    to decide what happens when a store triggers a change event—it could be that nothing
    in the DOM needs to be updated. The question then becomes—why would a store emit
    a change event if nothing has changed?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Flux商店的工作主要集中在为视图生成正确的信息。不属于商店工作描述的一部分是知道视图是否实际上需要更新。这意味着当商店触发一个更改事件时，决定发生什么的是视图——可能DOM中没有任何东西需要更新。那么问题就变成了——如果没有任何变化，为什么商店会发出更改事件？
- en: The simple answer is that stores don't do enough bookkeeping to make a determination
    as to whether something has changed or not. The store knows how to perform the
    correct state transformations, but it doesn't necessarily keep track of previous
    states for diffing purposes—although it certainly could do that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的答案是商店没有做足够的账目记录来确定是否有什么变化。商店知道如何执行正确的状态转换，但它不一定跟踪以前的状态以进行差异比较——尽管它当然可以这么做。
- en: 'Let''s look at a store that doesn''t mutate its state. Instead, it creates
    new state when something is transformed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个不改变其状态的商店。相反，当某个东西被转换时，它会创建新的状态：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This store is listening to the same `NAME_CAPS` message from the previous example.
    Its job is still the same—transform the `name` property to uppercase. However,
    this code works differently than in the last version of the store. It's immutable
    in that it doesn't mutate the `state` object—it replaces it. But it only does
    so if the value has actually changed. Otherwise, the `state` object stays the
    same. The idea here isn't to show that stores should detect state changes on individual
    properties, but rather that the change event can be emitted even when the state
    hasn't changed. In other words, our views shouldn't make the assumption that rendering
    to the DOM is necessary, just because of a change event.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个商店正在监听来自上一个示例的相同`NAME_CAPS`消息。它的任务仍然是相同的——将`name`属性转换为大写。然而，这段代码与商店的上一版本不同。它是不可变的，因为它不会改变`state`对象——它会替换它。但它只会在值实际发生变化时这么做。否则，`state`对象保持不变。这里的想法不是表明商店应该检测单个属性的状态变化，而是表明即使在状态没有变化的情况下，也可以发出更改事件。换句话说，我们的视图不应该假设仅仅因为更改事件，渲染到DOM就是必要的。
- en: 'Let''s turn our attention to the view now. The plan is simple—don''t render
    unless we have to:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把注意力转向视图。计划很简单——除非必要，否则不要渲染：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that the `previousState` property keeps a reference to the state
    of the store. But wait, isn''t that a bad thing, according to the section before
    this one? Well, no, because we''re not actually using the reference for anything
    other than strict equality checking. This is used to determine whether or not
    the view needs to render. Since the store state is immutable, we can assert that
    if the same reference is passed as an argument to the change event handler, nothing
    actually changed and we can safely ignore the event. Let''s see what happens when
    we call the same action several times in succession:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`previousState`属性保留了对存储状态的引用。但是等等，根据前面的章节，这不是一件坏事吗？嗯，不是的，因为我们实际上并没有使用这个引用做任何其他事情，只是进行严格的相等性检查。这是用来确定视图是否需要渲染的。由于存储状态是不可变的，我们可以断言，如果相同的引用作为参数传递给更改事件处理器，实际上并没有发生任何变化，我们可以安全地忽略该事件。让我们看看当我们连续多次调用同一个动作会发生什么：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Later in this chapter when we look at ReactJS, we'll see more advanced scenarios
    of views that only render what they need to. Later in the book when we look at
    `Immutable.js`, we'll tackle more advanced state change detection.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后当我们查看ReactJS时，我们将看到只渲染所需内容的视图的更高级场景。在本书稍后当我们查看`Immutable.js`时，我们将处理更高级的状态变化检测。
- en: Keeping views stateless
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持视图无状态
- en: Views can't be completely stateless because they interact with the DOM, and
    the DOM elements associated with a view will always have a state. However, we
    can take steps to treat views as stateless entities within the context of our
    Flux architecture. In this section, we'll address two aspects of stateless views.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 视图不能完全无状态，因为它们与DOM交互，并且与视图关联的DOM元素将始终具有状态。然而，我们可以在Flux架构的上下文中采取步骤将视图视为无状态实体。在本节中，我们将讨论无状态视图的两个方面。
- en: First, we'll go over the idea that all state in a Flux architecture belongs
    in a store, including any UI state that we might be tempted to keep in our view
    components. Second, we'll look at DOM querying and why we want to avoid doing
    this from within our Flux views.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍Flux架构中的所有状态都属于存储的想法，包括我们可能倾向于保存在我们的视图组件中的任何UI状态。其次，我们将探讨DOM查询以及为什么我们想要避免在Flux视图中进行这种操作。
- en: UI state belongs in stores
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI状态属于存储
- en: 'As you learned in the previous chapter, UI state is just like state that''s
    derived from application data—it all belongs in a store. UI state includes things
    such as the `disabled` property of a button or the name of a class that''s applied
    to a `div`. The reason these bits of state belong in a store is that other stores
    might depend on them. This in turn affects the rendering outcome of other views.
    This type of dependency is visualized as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如同你在上一章所学到的，UI状态就像是从应用数据派生出来的状态——它们都属于存储。UI状态包括按钮的`disabled`属性或应用于`div`的类的名称。这些状态片段属于存储的原因是其他存储可能依赖于它们。这反过来又影响了其他视图的渲染结果。这种依赖关系如下所示：
- en: '![UI state belongs in stores](img/B05419_07_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![UI状态属于存储](img/B05419_07_02.jpg)'
- en: If the UI state that other stores might depend on isn't kept in a store, then
    they'd have to depend on the view or the DOM itself. This is inconsistent and
    goes against what Flux stands for—strict update ordering and keeping state confined.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他存储可能依赖的UI状态没有保存在存储中，那么它们将不得不依赖于视图或DOM本身。这是不一致的，并且与Flux所代表的原则相悖——严格的更新顺序和将状态限制在范围内。
- en: No querying the DOM
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不查询DOM
- en: When the UI state is kept in a Flux store, there's no need to query the DOM
    to figure out whether or not a button is disabled. Think about the jQuery approach
    to manipulating application state. First, we have to issue a DOM query that gets
    us the relevant DOM elements, and then we have to figure out whether they're in
    the appropriate state by reading some of their properties. Then, we can make changes
    elsewhere in the application. Or perhaps there's a blend of state that's kept
    directly in the DOM and some JavaScript objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当UI状态保存在Flux存储中时，无需查询DOM以确定按钮是否被禁用。想想jQuery处理应用状态的方法。首先，我们必须发出一个DOM查询来获取相关的DOM元素，然后我们必须通过读取它们的某些属性来确定它们是否处于适当的状态。然后，我们可以在应用程序的其他地方进行更改。或者可能有一些状态直接保存在DOM中，以及一些JavaScript对象。
- en: It's the consistency that's the biggest difference maker in Flux architectures,
    because we don't have to query the DOM to get the `href` property of a link. The
    stores that hold onto UI state already have this information. This is always the
    case—it's never a matter of figuring out whether it's in the DOM or some other
    component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性是Flux架构中最大的区别制造者，因为我们不需要查询DOM来获取链接的`href`属性。保留UI状态的存储已经拥有了这些信息。这始终是这种情况——永远不是在DOM或其他组件中寻找信息的问题。
- en: Another advantage of having all the UI state that we need to make rendering
    decisions in our stores is that there's no performance bottleneck. Querying the
    DOM once or twice is not a big deal, and this does need to happen if we're going
    to display changes for the user. What we don't want is to have a long series of
    DOM query calls that don't even result in something being rendered. In other words,
    there's no need to query the DOM to extract information when it should already
    be in a store.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的存储中拥有所有必要的UI状态以做出渲染决策的另一个优点是，没有性能瓶颈。查询DOM一次或两次并不是什么大问题，而且如果我们想要向用户显示更改，这确实需要发生。我们不希望有一系列冗长的DOM查询调用，而这些调用甚至没有导致任何渲染。换句话说，当信息已经在存储中时，没有必要查询DOM来提取信息。
- en: This is the same strategy used by virtual DOM tree technologies such as ReactJS,
    where the DOM data is all stored in JavaScript objects. Looking up some UI state
    from a JavaScript object is inherently faster than looking up DOM element properties,
    and this is how ReactJS is able to perform so well—by minimizing the number of
    DOM interactions for a given UI change.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这与虚拟DOM树技术（如ReactJS）所使用的相同策略，其中DOM数据全部存储在JavaScript对象中。从JavaScript对象中查找一些UI状态比查找DOM元素属性要快得多，这就是ReactJS能够表现得如此出色的原因——通过最小化给定UI更改的DOM交互次数。
- en: View responsibilities
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图职责
- en: At this point in the book, you probably have a pretty good handle on the role
    of view components in a Flux architecture. Put simply, their job is to display
    store information for users by inserting it into the DOM. In this section, we'll
    break this core view concept into three parts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，你可能已经很好地掌握了视图组件在Flux架构中的作用。简单来说，它们的任务是通过将其插入DOM来向用户显示存储信息。在本节中，我们将这个核心视图概念分为三个部分。
- en: First there's the input to the views—the store data. Next, we have the structure
    of the view itself, and the various ways that it can be decomposed into smaller
    views. Finally, there's the user interactivity. Each of these three areas of view
    components has a relation to the flow of data through our Flux architecture. Let's
    look at each of them now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是视图的输入——存储数据。接下来是视图本身的架构，以及它可以分解成更小视图的各种方式。最后是用户交互。视图组件的这三个领域都与我们的Flux架构中的数据流有关。现在让我们看看每一个。
- en: Rendering store data
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染存储数据
- en: If the store transforms data into information that the user needs, then why
    have views at all? Why not have the stores directly render the information to
    the DOM? We need views for a couple reasons. First of all, a store could actually
    be used in several places, rendered by several views. Second of all, Flux isn't
    necessarily concerned with the visual display of information. For example, if
    we were to design some view that's doesn't render HTML but some other display
    format, that would be perfectly fine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储将数据转换成用户需要的信息，那么为什么还需要视图呢？为什么不直接让存储将信息渲染到DOM中呢？我们需要视图有几个原因。首先，存储实际上可以在多个地方使用，由多个视图渲染。其次，Flux并不一定关心信息的视觉显示。例如，如果我们设计了一些不渲染HTML而渲染其他显示格式的视图，那也是完全可以的。
- en: 'Views don''t keep any state or perform any transformations on store information.
    However, they do need to transform the information a little, to turn it into valid
    markup for display in the browser or any other display medium where our application
    runs. But aside from marking up the information returned from stores, views have
    little to do. It''s the view technology, such as ReactJS, that does the majority
    of the legwork in terms of marking up JavaScript objects and inserting them into
    the DOM. Here is a diagram that shows the process:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 视图不保留任何状态或对存储信息进行任何转换。然而，它们确实需要稍微转换信息，将其转换为浏览器或任何其他运行我们应用程序的显示介质中显示的有效标记。但除了标记从存储返回的信息之外，视图几乎没有其他事情要做。在标记JavaScript对象并将它们插入DOM方面，视图技术（如ReactJS）做了大部分基础工作。以下是展示该过程的图解：
- en: '![Rendering store data](img/B05419_07_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![渲染存储数据](img/B05419_07_03.jpg)'
- en: Subview structure
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子视图结构
- en: The aim of stores in Flux architectures is to structure them so that there's
    only one store per top-level feature. This gets us around the issues created by
    having massive hierarchies of data structures. Views, on the other hand, can benefit
    from a little bit of hierarchical structure. Just because a top-level feature
    is driven by information from a single store, it doesn't mean that only a single
    view can drive the user experience.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 架构中商店的目标是结构化它们，使得每个顶级特性只有一个商店。这使我们绕过了由大量数据结构层次结构引起的问题。另一方面，视图可以从一点层次结构中受益。仅仅因为顶级特性是由单个商店的信息驱动的，并不意味着只有一个视图可以驱动用户体验。
- en: 'Earlier in the book, we discussed the notion of hierarchical structure and
    how it should be avoided in Flux architectures. This is still true to an extent
    with views, because no matter how you slice it, deep hierarchies are difficult
    to comprehend. Views do need to be decomposed to an extent, because otherwise
    we''ll end of putting all the markup complexity in one place. HTML markup is hierarchical
    by nature, so to some degree our views should mimic this structure, as illustrated
    here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我们讨论了层次结构的概念以及如何在 Flux 架构中避免它。这在一定程度上对视图仍然适用，因为无论如何划分，深层层次结构都是难以理解的。视图确实需要在一定程度上进行分解，否则我们最终会将所有标记复杂度放在一个地方。HTML
    标记本质上是层次化的，因此从某种程度上说，我们的视图应该模仿这种结构，如图所示：
- en: '![Subview structure](img/B05419_07_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![子视图结构](img/B05419_07_04.jpg)'
- en: Just like stores can be generic, so can views. More than one feature can use
    generic components to present information using a common display pattern. For
    instance, think about some kind of expandable/collapsible panel that's used by
    all of our features—would it not make sense to plug this into our larger features
    rather than duplicate the functionality? The view technology that we're using
    is also a deciding factor in how we want to decompose our views into smaller reusable
    pieces, since this is easier to do with some frameworks than others. For example,
    we'll see in the next section that ReactJS makes it easy to compose coarse-grained
    views out of smaller more fine-grained views because they're largely self-contained.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与商店可以通用一样，视图也可以通用。多个特性可以使用通用组件以通用显示模式展示信息。例如，考虑一种可展开/可折叠的面板，它被我们所有的特性使用——将其插入到我们的更大特性中而不是重复功能，不是更有意义吗？我们使用的视图技术也是我们想要将视图分解成更小、可重用部分的决策因素，因为某些框架比其他框架更容易做到这一点。例如，我们将在下一节中看到，ReactJS
    使得从更小的、更精细的视图组合出粗粒度视图变得容易，因为它们在很大程度上是自包含的。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Something to be aware of when composing view hierarchies like this—be mindful
    of the data-flow. For example, when a Flux store changes, it emits the change
    event so that the top-level view can render itself. Then it renders its immediate
    children, who render their immediate children, and so on. As the store state flows
    through these views, no data transformations should be happening along the way.
    Put another way, the leaf views in the tree should get the same information as
    the root view.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合此类视图层次结构时需要注意的事项——注意数据流。例如，当 Flux 商店发生变化时，它会发出变化事件，以便顶级视图可以渲染自身。然后它渲染其直接子视图，这些子视图再渲染它们的直接子视图，依此类推。随着商店状态通过这些视图流动，沿途不应发生任何数据转换。换句话说，树中的叶视图应该获得与根视图相同的信息。
- en: User interactivity
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户交互
- en: The final area of view responsibility we need to think about is user interactivity.
    Apart from passively watching the information on their screens change as the underlying
    stores of our architecture handle actions, they're going to need to do things.
    If nothing else, users need to be able to navigate around the application to use
    the various features we've implemented. To handle this sort of thing, the view
    components that render the UI should also intercept the DOM events as they're
    triggered. This generally results in a new action being dispatched, as we've already
    seen earlier in the book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的最后一个视图责任领域是用户交互。除了被动地观察屏幕上的信息随我们架构的底层商店处理动作而变化之外，他们还需要做一些事情。如果至少，用户需要能够导航到应用程序的不同功能。为了处理这类事情，渲染
    UI 的视图组件也应该拦截它们被触发时的 DOM 事件。这通常会导致发出新的动作，正如我们在本书前面已经看到的。
- en: The key thing to remember about these event handlers is that they should have
    essentially one responsibility—calling the right action creator function. What
    these event handlers should avoid is trying to execute any logic—this belongs
    in a store, along with the state that the logic affects. This is so fundamental
    to Flux that it's quite possible I'll repeat it at least twelve more times in
    the book. Once we start introducing logic in places other than stores, we lose
    the ability to reason about the state of something—and the state largely determines
    what the user sees.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些事件处理程序，要记住的关键点是它们应该基本上只有一个职责——调用正确的动作创建函数。这些事件处理程序应该避免尝试执行任何逻辑——这属于库，以及受逻辑影响的州。这是
    Flux 的基础，所以我很可能在书中至少重复它十二次。一旦我们在库之外的地方引入逻辑，我们就失去了对某物状态的推理能力——状态在很大程度上决定了用户看到的内容。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's entirely plausible to pass action creator functions directly as event handlers
    to DOM nodes. This could actually help us, because it provides a very low chance
    of logic being introduced in the wrong place.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将动作创建函数作为事件处理程序传递给 DOM 节点是完全可能的。这实际上可能对我们有所帮助，因为它提供了非常低的逻辑被引入错误位置的风险。
- en: Using ReactJS with Flux
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ReactJS 与 Flux
- en: ReactJS is a library for creating view components. In fact, React doesn't even
    label itself as a view library—it's a set of tools for creating components that
    render UI elements. This simple premise is easy to understand and powerful—a perfect
    fit as the view technology in our Flux architecture.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 是一个用于创建视图组件的库。实际上，React 甚至不将自己标榜为视图库——它是一套用于创建渲染 UI 元素组件的工具。这个简单的原则易于理解且功能强大——完美地适合作为我们
    Flux 架构中的视图技术。
- en: In this section, we'll look at making ReactJS the technology of choice for views
    in our Flux applications, starting with passing state information from stores
    into React components. Next, we'll talk about the composition of views, and how
    Flux state flows from stores to parent views to child views. Lastly, we'll implement
    some event handling capabilities in our views using React mechanisms and a router
    using the `react-router` library.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨将 ReactJS 作为我们 Flux 应用程序中视图的首选技术，从将状态信息从库传递到 React 组件开始。接下来，我们将讨论视图的组合，以及
    Flux 状态如何从库流向父视图再到子视图。最后，我们将使用 React 机制和 `react-router` 库中的路由器在我们的视图中实现一些事件处理功能。
- en: Setting the view state
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置视图状态
- en: 'There are two ways to render React components based on the state of our Flux
    stores. These involve two different types of components—statefull and stateless—both
    of which we''ll address here. First, let''s take a look at the store containing
    the state that drives our views:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们 Flux 库的状态渲染 React 组件有两种方式。这涉及到两种不同类型的组件——有状态和无状态——我们都会在这里讨论。首先，让我们看看包含驱动我们视图的状态的库：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The idea here is simple—any time an `ADD` action is dispatched, we''re pushing
    the action payload onto the `items` array. Any React components that wish to respond
    to this store state change can do so by listening for the change event. First,
    let''s look at a stateful React component that renders the items list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法很简单——每当分发 `ADD` 动作时，我们都会将动作有效载荷推送到 `items` 数组。任何希望响应这种库状态变化的 React 组件都可以通过监听变化事件来实现。首先，让我们看看渲染项目列表的有状态
    React 组件：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a typical React component, created using the ES2015 class syntax and
    extending the base React `Component` class. This approach is necessary for stateful
    components. As you can see, the constructor of this component directly interacts
    with a Flux store. When the store changes, it calls `setState()`, which is how
    the component renders to reflect new store state. The constructor also sets the
    initial state by setting the `state` property. Next, we have the `render()` method,
    which returns React elements based on this state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的 React 组件，使用 ES2015 类语法创建，并扩展了基本的 React `Component` 类。这种做法对于有状态的组件是必要的。正如你所看到的，这个组件的构造函数直接与
    Flux 库交互。当库发生变化时，它会调用 `setState()`，这就是组件如何渲染以反映新的库状态。构造函数还通过设置 `state` 属性来设置初始状态。接下来，我们有
    `render()` 方法，它根据这个状态返回 React 元素。
- en: Note that our React component is using JSX syntax to define elements. We're
    not going to cover how this works in this book, nor will we cover other aspects
    of React in any level of detail. This is a book on Flux architecture, and we'll
    cover parts of React that are relevant in a Flux context. If you want more of
    a technical deep dive on React itself, there's plenty of free resources, as well
    as plenty of other books on the subject.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的React组件正在使用JSX语法来定义元素。我们不会在这本书中介绍它是如何工作的，也不会详细介绍React的其他方面。这是一本关于Flux架构的书，我们将介绍在Flux环境中相关的React部分。如果你想要对React本身进行更深入的技术研究，有大量的免费资源，以及许多关于这个主题的其他书籍。
- en: 'Now let''s look at another implementation of the exact same component, meaning
    the exact same output. This is the stateless approach to React components/views:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个组件的另一种实现，这意味着完全相同的输出。这是React组件/视图的无状态方法：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wait, what? This is the exact same component, only it doesn''t depend on state.
    This could be a good thing if we''re implementing this as a view component inside
    our Flux architecture. The thing that stands out most about this implementation
    is that there are more comments than code, which is a good thing, allowing us
    to focus on the resulting DOM structure. You''ll notice that there''s no interaction
    with a Flux store in this module. Remember, this is a stateless React component,
    a simple arrow function, which means we don''t have any life cycle methods to
    define, including the initial state. This is okay; let''s see how we use both
    types of components in our `main.js` module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，这是什么？这是完全相同的组件，只是它不依赖于状态。如果我们将其作为Flux架构中的视图组件实现，这可能是个好事。这个实现最引人注目的是，注释比代码多，这是好事，因为它让我们能够关注生成的DOM结构。你会注意到在这个模块中没有与Flux存储的交互。记住，这是一个无状态的React组件，一个简单的箭头函数，这意味着我们不需要定义任何生命周期方法，包括初始状态。这是可以的；让我们看看我们如何在`main.js`模块中使用这两种类型的组件：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The key difference here is that the `Stateless` view needs to have its interactions
    with the store set up manually here. The stateful component encapsulates this
    by setting up the change listener in the constructor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键区别在于，`Stateless` 视图需要在这里手动设置与存储的交互。有状态组件通过在构造函数中设置更改监听器来封装这一点。
- en: Is one approach superior to the other? Within a Flux architecture, stateless
    React components tend to have an advantage over their stateful counterparts. This
    is due to the simple fact that they enforce the idea that state belongs in stores,
    nowhere else. When our React components are simple functions, we have no choice
    but to figure out the correct way to transform store state into something that
    can be consumed as simple immutable properties.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是否优于另一种方法？在Flux架构中，无状态React组件通常比它们的有状态对应物有优势。这仅仅是因为它们强制执行状态属于存储，而不属于其他地方的理念。当我们的React组件是简单的函数时，我们别无选择，只能找出正确的方式将存储状态转换成可以被消费为简单不可变属性的东西。
- en: Composing views
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合视图
- en: 'Just as the state of our application is composed into stores, the views of
    that state are composed hierarchically to a degree. I say to a degree because
    we want to avoid decomposing the structure of our UI at a deep level, as this
    just makes it difficult to grasp. Where view composition really matters is when
    we have smaller parts that are used by many larger components. React is good at
    composing views without introducing too much complexity. In particular, stateless
    views are a good way to keep the vein of unidirectional data flow as it traverses
    the view levels. Let''s look at an example. Here''s a store with some initial
    state, which sorts this state upon a specific action:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的应用程序状态是由存储组成的一样，该状态的观点也是以某种程度进行分层组合的。我说到某种程度，是因为我们希望避免在深度上分解我们的UI结构，因为这只会使其难以理解。视图组合真正重要的时候是我们有较小的部分被许多较大的组件使用时。React擅长在不引入太多复杂性的情况下组合视图。特别是，无状态视图是保持单向数据流在穿越视图层级时保持一致的好方法。让我们看看一个例子。这是一个具有一些初始状态的存储，它会在特定操作上对这个状态进行排序：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, we would expect the array to be *Third*, *Second*, *First* (alphabetically)
    when the `SORT_DESC` action is dispatched. Now, let''s look at the main view component
    that listens to this store:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们预计当`SORT_DESC`操作被分派时，数组将是*第三*，*第二*，*第一*（按字母顺序）。现在，让我们看看监听此存储的主要视图组件：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once again, we have a simple functional view that doesn''t hold on to any state,
    because there''s no need—all state is held in the Flux stores. Rather than use
    an `li` element here, we''re using a custom `Item` React component that we''ve
    implemented for our application. This is part of the larger `App` view, and perhaps
    its part of other larger views. The result is code reuse and simplified aggregate
    views. Let''s look at the `Item` component next:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有一个简单的函数视图，它不保留任何状态，因为没有这个必要——所有状态都保留在Flux存储中。而不是在这里使用`li`元素，我们使用了一个自定义的`Item`
    React组件，这是我们为应用程序实现的。这是更大的`App`视图的一部分，也许也是其他更大视图的一部分。结果是代码重用和简化了聚合视图。现在让我们看看`Item`组件：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Not the most exciting view in the world, and in practice you''ll find more
    complex atomic views than this. But the idea is the same—the value of `props.children`
    ultimately comes from a Flux store, and it traverses a parent view to get here.
    Let''s see how all the pieces fit together in `main.js`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是世界上最令人兴奋的视图，在实践中，你会发现比这更复杂的原子视图。但理念是相同的——`props.children`的值最终来自Flux存储，并且它通过父视图传递到这里。让我们看看所有这些部分如何在`main.js`中组合在一起：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reacting to events
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对事件做出反应
- en: React components have their own event system baked into them. They're actually
    a wrapper around the DOM event system, making it easier for us to include event
    handling functions as part of the component JSX markup. This has implications
    for our Flux architecture too, because these events often translate directly to
    action creator function calls.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: React组件自身包含一个事件系统。实际上，它们是DOM事件系统的包装器，这使得我们更容易将事件处理函数作为组件JSX标记的一部分。这对我们的Flux架构也有影响，因为这些事件通常直接转换为动作创建函数调用。
- en: 'To get a feel for React events in a Flux context, let''s build on the previous
    example. We''ll add a button that toggles the sort order of our items. But first,
    we''ll take a look at the store modifications required to support this new behavior:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Flux环境中感受React事件，让我们基于之前的示例继续构建。我们将添加一个按钮来切换项目的排序顺序。但在做之前，我们先看看支持这种新行为所需的存储修改：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There''s a new piece of state in `MyStore`—`direction`. It''s relevant to both
    the sort direction of the items and the text content of the sort button in the
    view. Let''s take a look at the new application view now:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyStore`中有一个新的状态片段——`direction`。它与项目的排序方向以及视图中的排序按钮的文本内容相关。现在让我们看看新的应用程序视图：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see that the element returned by this stateless function is a `div`.
    Although not strictly necessary from a markup perspective, it is necessary from
    a `React` component perspective—rendering functions can only return one element.
    The `Sort` element we''ve added above the list represents the sort button. Let''s
    take a look at this component now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个无状态函数返回的元素是一个`div`。虽然从标记的角度来看不是严格必要的，但从`React`组件的角度来看是必要的——渲染函数只能返回一个元素。我们添加在列表上方的`Sort`元素代表排序按钮。现在让我们看看这个组件：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This element is a simple `button` HTML element, with a style that will capitalize
    the `direction` label. You can see too that the `onClick` property is used to
    specify the event handler. In this case, it's simple—we're calling the `sort()`
    action creator function directly when the button is clicked.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素是一个简单的`button` HTML元素，其样式将使`direction`标签大写。你还可以看到，`onClick`属性用于指定事件处理器。在这种情况下，它是简单的——当按钮被点击时，我们直接调用`sort()`动作创建函数。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In practice, other state-handling actions might be dispatched in concert with
    the `SORT` action. For example, a `PRE_SORT` action might be necessary to handle
    button state.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，可能需要与其他状态处理动作一起调度`SORT`动作。例如，可能需要一个`PRE_SORT`动作来处理按钮状态。
- en: Routing and actions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由和动作
- en: The `react-router` library is the de facto routing solution of ReactJS projects.
    If we're using React component for in the view layer of our Flux architecture,
    then there's a good chance that we'll want to use this package for routing in
    our application. However, there are some subtle nuances to be aware of when using
    `react-router` in the context of Flux. In this final section of the chapter, we'll
    address some of the tradeoffs we need to make with `react-router` by implementing
    it in a Flux architecture.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router`库是ReactJS项目的既定路由解决方案。如果我们使用React组件作为Flux架构视图层的组件，那么我们很可能希望在这个应用程序中使用这个包进行路由。然而，在使用Flux环境中的`react-router`时，有一些细微之处需要注意。在本章的最后部分，我们将通过在Flux架构中实现它来讨论我们需要与`react-router`做出的权衡。'
- en: The basic premise of `react-router` is what makes it so attractive in the first
    place. The router and the routes within it are themselves React components that
    we can render into the DOM. We can declare that a given route should render a
    given React component when the route is activated. The router handles all of the
    nitty-gritty details for us. The question is, how does this work within the context
    of a Flux application? As we know, stores are where state lives in our application.
    So this means that they might want to know about the state of the router as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router`的基本前提是它最初吸引人的原因。路由器及其内部的路线本身就是我们可以渲染到DOM中的React组件。我们可以声明，当路线激活时，应该渲染给定的React组件。路由器为我们处理所有琐碎的细节。问题是，在Flux应用程序的上下文中，它是如何工作的？正如我们所知，存储是我们应用程序中状态所在的地方。这意味着它们可能还想了解路由器的状态。'
- en: 'Let''s start by looking at the `main.js` module, where the router component
    is declared and rendered:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`main.js`模块开始看起，在那里声明并渲染了路由组件：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can see here that there are three main routes, the default `/` route, followed
    by a `/first` and a `/second` route. Each route has a corresponding component
    that''s rendered when the route becomes active. What''s interesting about these
    route declarations is that the `First` and `Second` components are children of
    `App`. This means that when their routes are activated, they''re actually rendered
    within `App`. Let''s take a look at the `App` component now:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里有三个主要路线，默认的`/`路线，然后是`/first`和`/second`路线。每个路线都有一个相应的组件，当路线变为活动状态时渲染。这些路线声明有趣的地方在于，`First`和`Second`组件是`App`的子组件。这意味着当它们的路线激活时，它们实际上是在`App`内部渲染的。现在让我们看看`App`组件：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This component renders a list of links that point to our two routes—`first`
    and `second`. It also renders child components through `props.children`. This
    is where the child component is rendered. Let''s turn our attention to the `routeUpdate()`
    action creator function now. This is called by the `Router` component whenever
    the route changes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件渲染了一个指向我们的两个路线——`first`和`second`——的链接列表。它还通过`props.children`渲染子组件。这就是子组件被渲染的地方。现在让我们转向`routeUpdate()`动作创建函数。这个函数由`Router`组件在路线更改时调用：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There''s actually two actions that are dispatched by this function. First,
    there''s the `PRE_ROUTE_UPDATE` action, which is dispatched so that stores have
    an opportunity to prepare for the changed route. Then, we perform some asynchronous
    behavior using `setTimeout()` and then dispatch the `ROUTE_UPDATE` action. Now
    let''s take a look at one of the stores used by our components. We''ll then look
    at one of the views that listens to this store. The stores and views are nearly
    identical, so there''s no need to look at more than one of each:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个函数派发了两个动作。首先，有`PRE_ROUTE_UPDATE`动作，它被派发，以便存储有机会为更改的路线做准备。然后，我们使用`setTimeout()`执行一些异步行为，然后派发`ROUTE_UPDATE`动作。现在让我们看看我们组件使用的其中一个存储。然后我们将看看监听这个存储的一个视图。存储和视图几乎相同，所以没有必要查看每个都超过一个：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The store updates its `content` state based on the action type and the current
    route. This is important because other areas of the application might want to
    know that this store is waiting for a route update to complete. Now let''s look
    at the view that listens to this store:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据动作类型和当前路线，存储更新其`content`状态。这很重要，因为应用程序的其他区域可能想知道这个存储正在等待路线更新完成。现在让我们看看监听这个存储的视图：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This component is stateful because it has to be. Since it's the router that
    renders the component initially, we can't re-render it other than by setting its
    state. This is how we're able to re-render the component to reflect the state
    of the store—by setting up a handler for the change event. This component also
    has life cycle methods for listening to the change event of the store, as well
    as removing the listener. If we didn't remove it, it would try to set the state
    on a component that isn't mounted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件是状态化的，因为它必须如此。由于它是路由器最初渲染该组件，所以我们不能通过其他方式重新渲染它，只能通过设置其状态。这就是我们能够通过设置更改事件处理程序来重新渲染组件以反映存储状态的方式。这个组件还有生命周期方法来监听存储的更改事件，以及移除监听器。如果我们不移除它，它将尝试在一个未挂载的组件上设置状态。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter went into detail on the view layer of Flux architectures. Starting
    with getting information into views, you learned that the change event is fundamental
    in reflecting the state of the store in the view, and that views often read directly
    from stores during their initial render. Then, we went over the idea that views
    are stateless. The state of a given UI element belongs in a store, because other
    parts of the application might depend on this state, and we don't want to have
    to query the DOM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了Flux架构的视图层。从将信息引入视图开始，你了解到变化事件是反映存储在视图中的状态的基本方式，并且视图通常在它们的初始渲染期间直接从存储中读取。然后，我们讨论了视图是无状态的这一观点。给定UI元素的状态属于存储，因为应用程序的其他部分可能依赖于这个状态，我们不希望不得不查询DOM。
- en: Next, we went over some of the high-level responsibilities of view components.
    These include rendering store information, composing larger view structures out
    of smaller view components, and handling user interactivity. We wrapped the chapter
    up with a walkthrough of using ReactJS components as the view technology in a
    Flux architecture. In the following chapter, we'll dig into the life cycle of
    Flux components and how they differ from other architectures.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了视图组件的一些高级职责。这包括渲染存储信息，将较小的视图组件组合成较大的视图结构，以及处理用户交互。我们以使用ReactJS组件作为Flux架构中的视图技术为例，结束了这一章。在下一章中，我们将深入探讨Flux组件的生命周期以及它们与其他架构的不同之处。
