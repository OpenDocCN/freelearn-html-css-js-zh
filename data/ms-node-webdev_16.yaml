- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Authenticating and Authorizing Requests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和授权请求
- en: 'Most projects need to restrict access to features; otherwise, anyone who knows
    an application’s URL can execute any operation. This is currently how the example
    application is set up: anyone who can request `http://localhost:5000` will be
    able to store and delete data, regardless of who they are.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目都需要限制对功能的访问；否则，任何知道应用程序URL的人都可以执行任何操作。目前示例应用程序就是这样设置的：任何可以请求`http://localhost:5000`的人都将能够存储和删除数据，无论他们是谁。
- en: '*Authorization*, often referred to as *AuthZ*, is the process of restricting
    access so that operations can only be performed by some users – known, naturally
    enough, as *authorized users*. *Authentication*, often referred to as *AuthN*,
    is the process of a user identifying themselves so that the application can determine
    whether the user is authorized for the operations they request. This chapter explains
    how Node.js applications can apply authentication and authorization, building
    on the features described in earlier chapters. *Table 15.1* puts this chapter
    in context.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权*，通常称为*AuthZ*，是限制访问的过程，以便只有某些用户（自然地称为*授权用户*）可以执行操作。*身份验证*，通常称为*AuthN*，是用户识别自己的过程，以便应用程序可以确定用户是否有权执行他们请求的操作。本章解释了Node.js应用程序如何应用身份验证和授权，基于前面章节中描述的功能。*表15.1*
    将本章置于上下文中。'
- en: 'Table 15.1: Putting authorization and authentication in context'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1：将授权和身份验证置于上下文中
- en: '| Question | Answer |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 答案 |'
- en: '| What are they? | Authentication is the process of identifying a user. Authorization
    is the process of restricting access to application features to a subset of users.
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 它们是什么？ | 身份验证是识别用户的过程。授权是将对应用程序功能的访问限制到用户子集的过程。|'
- en: '| Why are they useful? | Identifying users allows an application to alter its
    behavior by using data or preferences that are specific to one account. Restricting
    access to features means that applications can support operations that would otherwise
    be dangerous or prejudicial to effective service provision. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它们有用？ | 识别用户允许应用程序通过使用特定于一个账户的数据或偏好来改变其行为。限制对功能的访问意味着应用程序可以支持那些否则可能危险或对有效服务提供有偏见的行为。|'
- en: '| How is it used? | Users identify themselves by presenting credentials to
    the application, which produces a temporary token that is included in subsequent
    requests. The token is used to associate an identity with each request, which
    can be inspected to authorize access to restricted features. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 它是如何使用的？ | 用户通过向应用程序提供凭证来识别自己，应用程序生成一个临时令牌，该令牌包含在后续请求中。该令牌用于将一个身份与每个请求关联起来，可以检查以授权访问受限制的功能。|'
- en: '| Are there any pitfalls or limitations? | Thorough testing is required to
    ensure that authentication and authorization work as expected. Many applications
    will require additional work to support user enrolment and account maintenance.
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 有任何陷阱或限制吗？ | 需要进行彻底的测试以确保身份验证和授权按预期工作。许多应用程序将需要额外的工作来支持用户注册和账户维护。|'
- en: '| Are there any alternatives? | Not all applications require authentication
    and authorization, but most do. Some of the surrounding features can be delegated
    to third-party authentication providers, but integration is still required. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 并非所有应用程序都需要身份验证和授权，但大多数都需要。一些相关功能可以委托给第三方身份验证提供商，但仍然需要集成。|'
- en: '*Table 15.2* summarizes the chapter.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*表15.2* 总结了本章内容。'
- en: 'Table 15.2: Chapter summary'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.2：章节总结
- en: '| Problem | Solution | Listing |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Authenticate users | Provide a mechanism that allows the user to provide
    credentials, which can be validated against stored data. | *4-9, 26-28* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 身份验证用户 | 提供一种机制，允许用户提供凭证，这些凭证可以与存储的数据进行验证。 | *4-9, 26-28* |'
- en: '| Create an authentication token for HTML clients | Include the user’s identity
    in the session so that the session cookie becomes the authentication token. |
    *10-12* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 为HTML客户端创建身份验证令牌 | 在会话中包含用户的身份，以便会话cookie成为身份验证令牌。 | *10-12* |'
- en: '| Create an authentication token for API clients | Create a bearer token. |
    *13-16* |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 为API客户端创建身份验证令牌 | 创建一个携带令牌。 | *13-16* |'
- en: '| Authorize requests | Use the identity associated with a request to determine
    if the user is entitled to perform the target operation. | *17-25, 29* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 授权请求 | 使用与请求关联的标识来确定用户是否有权执行目标操作。 | *17-25, 29* |'
- en: Preparing for this chapter
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为本章做准备
- en: 'This chapter uses the `part2app` project from *Chapter 14*. The first set of
    examples in this chapter is for a round-trip application. To prepare, add a file
    named `data.handlebars` to the `templates/server` folder with the content shown
    in *Listing 15.1*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用*第14章*中的`part2app`项目。本章的第一个示例是为往返应用程序准备的。为了准备，将名为`data.handlebars`的文件添加到`templates/server`文件夹中，其内容如*列表15.1*所示：
- en: '**Tip**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)下载本章的示例项目——以及本书中所有其他章节的示例项目。有关运行示例时遇到问题的帮助，请参阅*第1章*。
- en: 'Listing 15.1: The contents of the data.handlebars file in the templates/server
    folder'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.1：`templates/server`文件夹中`data.handlebars`文件的内容
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This template contains a table that displays data, with a form that sends HTTP
    requests to the server. To handle the HTTP requests, replace the contents of the
    `forms.ts` file in the `src/server` folder with the code shown in *Listing 15.2*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板包含一个显示数据的表格，以及一个向服务器发送HTTP请求的表单。为了处理HTTP请求，将`src/server`文件夹中`forms.ts`文件的内容替换为*列表15.2*中显示的代码。
- en: 'Listing 15.2: The contents of the forms.ts file in the src/server folder'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.2：`src/server`文件夹中`forms.ts`文件的内容
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The routes defined in *Listing 15.2* render the data template, delete an item
    from the database, and store an item. After data is stored or deleted, the browser
    is sent a redirection to the `/form` URL that will show the user the results of
    their actions. Run the command shown in *Listing 15.3* in the `part2app` folder
    to start the development tools:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15.2*中定义的路由渲染数据模板，从数据库中删除一个条目，并存储一个条目。数据存储或删除后，浏览器会收到重定向到`/form` URL的请求，该URL将显示用户操作的结果。在`part2app`文件夹中运行*列表15.3*中显示的命令以启动开发工具：'
- en: 'Listing 15.3: Starting the development tools'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.3：启动开发工具
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use a browser to request `http://localhost:5000/form`, and you will see the
    content generated by the new template, as shown in *Figure 15.1*. Clicking one
    of the **Delete** buttons will remove an item from the database, and clicking
    the **Add** button will store a new item using fixed data values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求`http://localhost:5000/form`，您将看到由新模板生成的内容，如图15.1所示。点击**删除**按钮将从一个数据库中删除一个条目，点击**添加**按钮将使用固定数据值存储一个新的条目。
- en: '![](img/B21959_15_01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_15_01.png)'
- en: 'Figure 15.1: Running the example application'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：运行示例应用程序
- en: Understanding the end-to-end process
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解端到端过程
- en: 'The topics covered in this chapter are part of a larger process through which
    a user gains access to the features provided by an application. The process is
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题是用户获取应用程序提供功能的一个更大过程的一部分。该过程如下：
- en: Enrolment. The enrolment process creates an account for the user, who is given
    credentials to identify themselves.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册。注册过程为用户创建一个账户，并给予凭证以供用户识别自己。
- en: User Authentication. The user presents their credentials when they want to use
    the application. The authentication process, often called signing in, produces
    a token that temporarily identifies the user.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户认证。当用户想要使用应用程序时，会展示他们的凭证。认证过程，通常称为登录，生成一个临时令牌以识别用户。
- en: Request Authentication. When making HTTP requests, the client includes the temporary
    token to identify the user without needing to provide the credentials again.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求认证。在发起HTTP请求时，客户端包含临时令牌以识别用户，而无需再次提供凭证。
- en: Authorization. The token included in the request is used to determine whether
    the user can access the feature specified by the request.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权。请求中包含的令牌用于确定用户是否可以访问请求中指定的功能。
- en: This chapter covers the authentication and authorization parts of the process.
    The details of the enrolment process are not described because they depend on
    the type of application. For corporate applications, enrolment will usually happen
    when a new employee joins the company and, for larger companies, will be done
    by the HR department through a central employee directory. For consumer-facing
    applications, enrolment is often linked to payment and is done before the user
    receives access to the application (for services, such as Spotify) or after they
    have made a product selection (for goods, such as Amazon). In both cases, the
    user enrolls themselves.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了认证和授权的过程部分。注册过程的细节没有描述，因为它们取决于应用程序的类型。对于企业应用程序，注册通常发生在新员工加入公司时，对于大型公司，将由人力资源部门通过中央员工目录来完成。对于面向消费者的应用程序，注册通常与支付相关联，在用户获得应用程序访问权之前（例如，Spotify服务）或在他们做出产品选择之后（例如，亚马逊商品）进行。在两种情况下，用户都会自行注册。
- en: Applications that require users to enroll themselves usually provide account
    maintenance tools, which allow users to change their credentials, update personal
    information, and close their accounts. In some parts of the world, users are legally
    entitled to receive a copy of all of the data held about them, and this is often
    part of the account management process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要用户自行注册的应用程序通常提供账户维护工具，允许用户更改他们的凭证、更新个人信息以及关闭他们的账户。在某些地区的法律中，用户有权利获得所有关于他们的数据的副本，这通常是账户管理过程的一部分。
- en: Authenticating users
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户认证
- en: The authentication process requires the user to present their credentials to
    identify themselves to the application. The standard credentials are a username
    and password. The password is known only to the user, which means they can prove
    they are the user who owns the account by submitting the correct password.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 认证过程要求用户向应用程序出示他们的凭证以证明自己的身份。标准凭证是用户名和密码。密码只有用户知道，这意味着他们可以通过提交正确的密码来证明他们是账户的所有者。
- en: Of course, passwords can be stolen or shared, and so a common approach is to
    require additional proof of identity. The conventional approach is to combine
    a password with a physical token, which can be a dedicated hardware device or
    an authenticator app running on a phone. The device provides a time-limited code
    that proves the user has the device.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，密码可能会被盗用或共享，因此，一个常见的做法是要求额外的身份证明。传统的方法是将密码与一个物理令牌结合，这个令牌可以是专用的硬件设备，也可以是运行在手机上的认证应用。该设备提供一段有时间限制的代码，以证明用户拥有该设备。
- en: To work through the details of how users are authenticated, I am going to add
    support for usernames and passwords to the example application. Later in the chapter,
    I’ll introduce an open-source package that supports a wider range of credentials,
    but simple passwords are enough to explain how the overall authentication and
    authorization processes work. *Part 3* of this book demonstrates the use of a
    third-party authentication service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明用户认证的过程，我将在示例应用中添加对用户名和密码的支持。在本章的后面部分，我将介绍一个支持更广泛凭证的开源包。但简单的密码足以解释整体认证和授权过程是如何工作的。本书的*第3部分*展示了第三方认证服务的使用。
- en: Creating a credential store
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建凭证存储库
- en: 'To authenticate users, an application needs to have a store of credentials
    against which requests can be validated. Create the `src/server/auth` folder and
    add to it a file named `auth_types.ts`, with the content shown in *Listing 15.4*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了认证用户，应用程序需要有一个凭证存储库，以便可以验证请求。创建`src/server/auth`文件夹，并向其中添加一个名为`auth_types.ts`的文件，其内容如*清单15.4*所示：
- en: 'Listing 15.4: The contents of the auth_types.ts file in the src/server/auth
    folder'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15.4：`src/server/auth`文件夹中`auth_types.ts`文件的内容
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Credentials` interface describes a user’s credentials as they are stored
    for validation. It is poor practice to store passwords in plain text, and the
    conventional approach is to create a one-way hash code and store that instead.
    To validate credentials, the password provided by the user is put through the
    same hashing algorithm and compared with the stored value. Hash algorithms always
    produce the same result, which means the credential store will contain the same
    hash code for all users who pick the same password. If the password for one of
    those accounts is obtained, then anyone who can see the credential store will
    be able to figure out which other accounts can be accessed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Credentials` 接口描述了用于验证的用户凭证。将密码以明文形式存储是不好的做法，传统的方法是创建一个单向哈希码并将其存储。为了验证凭证，将用户提供的密码通过相同的哈希算法处理，并与存储的值进行比较。哈希算法总是产生相同的结果，这意味着凭证存储将包含所有选择相同密码的用户相同的哈希码。如果获取了这些账户中的任何一个账户的密码，那么任何可以查看凭证存储的人都能推断出哪些其他账户可以访问。'
- en: To avoid this problem, a random *salt* value is added to the password so that
    users can have the same password without causing duplicate hash codes in the credential
    store. The salt value must be stored alongside the password so that credentials
    can be validated. The hash code and the salt are `Buffer` values, which is the
    type that Node.js uses to represent byte arrays. The `AuthStore` interface defines
    the methods that will be used to retrieve and store credentials.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，密码中添加了一个随机的 *盐* 值，这样用户即使使用相同的密码也不会在凭证存储中产生重复的哈希码。盐值必须与密码一起存储，以便验证凭证。哈希码和盐值是
    `Buffer` 类型的值，这是 Node.js 用于表示字节数组的类型。`AuthStore` 接口定义了用于检索和存储凭证的方法。
- en: 'Add a file named `orm_auth_models.ts` to the `src/server/auth` folder with
    the contents shown in *Listing 15.5*, which defines the data model for credentials
    using the *Sequelize ORM package* introduced in *Chapter 12*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/server/auth` 文件夹中添加一个名为 `orm_auth_models.ts` 的文件，其内容如 *列表 15.5* 所示，该文件使用在
    *第 12 章* 中介绍的 *Sequelize ORM 包* 定义了凭证的数据模型：
- en: 'Listing 15.5: The contents of the orm_auth_models.ts file in the src/server/auth
    folder'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.5：src/server/auth 文件夹中 orm_auth_models.ts 文件的内容
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `CredentialsModel` class extends the Sequelize `Model` class and implements
    the `Credentials` interface, which allows `CredentialsModel` objects to be stored
    in the database and used as a method result with the `AuthStore` interface. The
    `initializeAuthModels` function receives a `Sequelize` object and initializes
    the `CredentialsModel` for database storage, identifying the `username` property
    as the primary key and telling `Sequelize` to represent values, using the SQL
    `STRING` data type for the username property and the `BLOB` type for the hash
    code and salt values (the `BLOB` type allows data to be stored as strings or buffers).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`CredentialsModel` 类继承自 Sequelize 的 `Model` 类并实现了 `Credentials` 接口，这使得 `CredentialsModel`
    对象可以存储在数据库中，并可以作为带有 `AuthStore` 接口的方法结果使用。`initializeAuthModels` 函数接收一个 `Sequelize`
    对象，并为数据库存储初始化 `CredentialsModel`，将 `username` 属性标识为主键，并告诉 Sequelize 使用 SQL 的 `STRING`
    数据类型表示用户名属性，使用 `BLOB` 类型表示哈希码和盐值（`BLOB` 类型允许数据以字符串或缓冲区形式存储）。'
- en: To create a Sequelize implementation of the `AuthStore` interface, add a file
    named `orm_authstore.ts` to the `src/server/auth` folder with the contents shown
    in *Listing 15.6*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `AuthStore` 接口的 Sequelize 实现，在 `src/server/auth` 文件夹中添加一个名为 `orm_authstore.ts`
    的文件，其内容如 *列表 15.6* 所示。
- en: 'Listing 15.6: The contents of the orm_authstore.ts file in the src/server/auth
    folder'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.6：src/server/auth 文件夹中 orm_authstore.ts 文件的内容
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `OrmAuthStore` class implements the `AuthStore` interface using the Sequelize
    features presented by the `CredentialsModel` class. The `getUser` method is implemented
    using the `findByPk` method, which queries the database using a primary key value.
    The `storeOrUpdateUser` method is implemented using the `upsert` method, which
    updates an existing value if there is one and otherwise creates a new value. The
    data will be stored in an SQLite database file named `orm_auth.db`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrmAuthStore` 类使用 `CredentialsModel` 类提供的 Sequelize 特性实现了 `AuthStore` 接口。`getUser`
    方法通过 `findByPk` 方法实现，该方法使用主键值查询数据库。`storeOrUpdateUser` 方法通过 `upsert` 方法实现，如果存在现有值则更新该值，否则创建新值。数据将存储在名为
    `orm_auth.db` 的 SQLite 数据库文件中。'
- en: The `createHashCode` method accepts a password and a salt value and creates
    a new hash code, using the `pbkdf2` function from the Node.js `crypto` module.
    This function is an implementation of a **Password-Based Key Derivation Function**
    (**PBKDF**), which is a function that is well-suited to create hash codes from
    passwords (see [https://en.wikipedia.org/wiki/PBKDF2](https://en.wikipedia.org/wiki/PBKDF2)
    for details). The arguments to the `pbkdf2` function are the password to be hashed,
    the salt value, the number of iterations used to generate the hash code, the length
    of the hash code, and the algorithm that will be used to generate the hash code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`createHashCode`方法接受一个密码和一个盐值，并使用Node.js `crypto`模块中的`pbkdf2`函数创建一个新的哈希码。这个函数是**基于密码的密钥派生函数**（**PBKDF**）的一个实现，它非常适合从密码中创建哈希码（有关详细信息，请参阅[https://en.wikipedia.org/wiki/PBKDF2](https://en.wikipedia.org/wiki/PBKDF2)）。`pbkdf2`函数的参数是要哈希的密码、盐值、用于生成哈希码的迭代次数、哈希码的长度以及将用于生成哈希码的算法。'
- en: '*Listing 15.6* uses the values described in the Node.js API ([https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback](https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback)).
    The `pbkdf2` function uses a callback, which is wrapped in a Promise to make it
    easier to work with the `Sequelize` API.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15.6*使用了Node.js API中描述的值（[https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback](https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback)）。`pbkdf2`函数使用回调，该回调被Promise包装，以便更容易与`Sequelize`
    API一起使用。'
- en: The `validateCredentials` method uses the `getUser` method to retrieve the stored
    credentials and uses the stored salt value to compute a new hash code with the
    candidate password, which is then compared to the stored hash code, using the
    `timingSafeEqual` function in the Node.js `crypto` module. This function is used
    to compare hash codes securely, as described in the API documentation `(`[https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b](https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateCredentials`方法使用`getUser`方法检索存储的凭证，并使用存储的盐值计算候选密码的新哈希码，然后使用Node.js
    `crypto`模块中的`timingSafeEqual`函数将该哈希码与存储的哈希码进行比较。该函数用于安全地比较哈希码，如API文档中所述（[https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b](https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b)）。'
- en: The database is seeded with two sets of credentials, matching those described
    in *Table 15.3*. Credentials are usually created as part of an enrolment process,
    as described earlier in the chapter, but test credentials are enough for this
    chapter. See *Part 3* for an example of an enrolment process typical of an online
    store. As with examples in earlier chapters, the database is reset each time the
    application is started.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中预置了两套凭证，与*表15.3*中描述的相匹配。凭证通常在注册过程中创建，如本章前面所述，但本章节中测试凭证就足够了。有关在线商店典型注册过程的示例，请参阅*第3部分*。与前面章节中的示例一样，每次启动应用程序时都会重置数据库。
- en: 'Table 15.3: The test credentials added to the database'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.3：添加到数据库中的测试凭证
- en: '| Name | Password |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 密码 |'
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Creating the authentication workflow
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建认证工作流程
- en: 'The next step is to create a workflow that allows a user to sign in and out
    of the application. Add a file named `signin.handlebars` to the `templates/server`
    folder with the content shown in *Listing 15.7*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个工作流程，允许用户登录和注销应用程序。将名为`signin.handlebars`的文件添加到`templates/server`文件夹中，其内容如*列表15.7*所示：
- en: 'Listing 15.7: The contents of the signin.handlebars file in the templates/server
    folder'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.7：templates/server文件夹中signin.handlebars文件的内容
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The template contains a form to send a username and password to the application,
    along with an error message that is hidden by default but which will be displayed
    if the user provides invalid credentials.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 模板包含一个表单，用于将用户名和密码发送到应用程序，并包含一个默认隐藏的错误消息，如果用户提供了无效的凭证，则该消息将被显示。
- en: 'The next step is to create the Express routes that will present the user with
    the contents of the `signin` template and validate credentials when they are submitted.
    Add a file named `index.ts` to the `src/server/auth` folder with the content shown
    in *Listing 15.8*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建Express路由，这些路由将向用户展示`signin`模板的内容，并在提交凭证时验证凭证。将名为`index.ts`的文件添加到`src/server/auth`文件夹中，其内容如*列表15.8*所示：
- en: 'Listing 15.8: The contents of the index.ts file in the src/server/auth folder'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.8：src/server/auth文件夹中index.ts文件的内容
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This file exports a function named `createAuth`, which sets up authentication
    for the application. The contents of the `signin` template are rendered when a
    GET request is sent to `/signin`. When a POST request is sent to `/signin`, the
    credentials it contains are validated. A redirection is used to send the user
    back to the application if the credentials are valid.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件导出一个名为 `createAuth` 的函数，该函数为应用程序设置身份验证。当向 `/signin` 发送 GET 请求时，将渲染 `signin`
    模板的内 容。当向 `/signin` 发送 POST 请求时，将验证其中包含的凭据。如果凭据有效，将使用重定向将用户送回应用程序。
- en: A redirection is also sent when credentials fail validation but, this time,
    to the same URL. This is a pattern known as `Post/Redirect/Get`, and it ensures
    that the user can reload the browser without triggering another sign-in attempt.
    This pattern can be used in any form, but it is particularly useful for authentication,
    where repeated failed attempts are often counted and can lead to an account being
    logged out. The URL query string is used to include the credentials provided by
    the user so they will be displayed by the result of the GET request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当凭据验证失败时，也会发送重定向，但这次是到相同的 URL。这是一种称为 `Post/Redirect/Get` 的模式，它确保用户可以重新加载浏览器而不会触发另一个登录尝试。这种模式可以用于任何表单，但在身份验证中特别有用，因为重复的失败尝试经常被计数，可能导致账户被注销。URL
    查询字符串用于包含用户提供的凭据，以便它们可以通过 GET 请求的结果显示。
- en: '**Note**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Authentication should always be performed over an encrypted HTTP connection;
    otherwise, the credentials provided by the user can be exposed to network sniffing.
    See *Chapter 5* for details of setting up HTTPS for a stand-alone Node.js server
    and see *Part 3* for an example that demonstrates how HTTPS is typically set up
    for more complex Node.js applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证应始终在加密的 HTTP 连接上执行；否则，用户提供的凭据可能会暴露给网络嗅探。有关为独立 Node.js 服务器设置 HTTPS 的详细信息，请参阅*第
    5 章*，有关如何为更复杂的 Node.js 应用程序设置 HTTPS 的示例，请参阅*第 3 部分*。
- en: '*Listing 15.9* calls the `createAuth` function as part of the server startup
    so that the authentication features are part of the request-handling process:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15.9* 在服务器启动过程中调用 `createAuth` 函数，以便身份验证功能成为请求处理过程的一部分：'
- en: 'Listing 15.9: Enabling authentication in the server.ts file in the src/server
    folder'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.9：在 src/server 文件夹中的 server.ts 文件中启用身份验证
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `createAuth` method is called after the middleware components required by
    forms are set up, but before the rest of the application. This allows the authentication
    request handlers to rely on the features previously described for forms, such
    as decoding form data and using sessions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置表单所需的中间件组件之后，但在应用程序的其余部分之前调用 `createAuth` 方法。这允许身份验证请求处理程序依赖于之前描述的表单功能，例如解码表单数据和使用会话。
- en: To test the authentication workflow, use a web browser to request `http://localhost:5000/signin`,
    enter `alice` and `badpass` into the form, and click the **Sign In** button. Validation
    will fail because the wrong password has been provided. Change the password to
    `mysecret` and click the button again. This time, the credentials are validated,
    and the browser is redirected to the root URL. This sequence is shown in *Figure
    15.2*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试身份验证工作流程，请使用网络浏览器请求 `http://localhost:5000/signin`，在表单中输入 `alice` 和 `badpass`，然后点击
    **登录** 按钮。验证将失败，因为提供了错误的密码。将密码更改为 `mysecret` 并再次点击按钮。这次，凭据将被验证，浏览器将被重定向到根 URL。此序列在*图
    15.2*中显示。
- en: '![](img/B21959_15_02.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_15_02.png)'
- en: 'Figure 15.2: The signing-in workflow'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2：登录工作流程
- en: Authenticating requests
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证请求
- en: The application can validate credentials, but that isn’t much use because there
    is currently no association between credentials sent to the `/signin` URL and
    any subsequent HTTP requests made by the browser.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以验证凭据，但这并没有太大用处，因为目前发送到 `/signin` URL 的凭据与浏览器发出的任何后续 HTTP 请求之间没有关联。
- en: 'This is the purpose of the temporary token that can be presented to the application
    to prove that the user has been through the credential validation process. Cookies
    are the most common way to solve this problem, either by creating a separate cookie
    or by associating authentication data with an existing session cookie, which is
    the approach I am going to take in this chapter because it is the simplest approach
    and takes advantage of session features, such as automatic inactivity expiration.
    *Listing 15.10* uses a session to record successful authentication, and it defines
    middleware that detects the new session data and adds a `user` property to the
    request object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是可以展示给应用程序的临时令牌的目的，以证明用户已经通过了凭据验证过程。Cookies 是解决这个问题的最常见方式，要么创建一个单独的cookie，要么将认证数据与现有的会话cookie关联起来，这是我在本章中将采取的方法，因为它是最简单的方法，并利用了会话功能，如自动不活动过期。*列表15.10*
    使用会话记录成功的认证，并定义了一个检测新会话数据并将 `user` 属性添加到请求对象的中间件：
- en: 'Listing 15.10: Completing authentication in the index.ts file in the src/server/auth
    folder'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.10：在src/server/auth文件夹中的index.ts文件中完成认证
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first `declare` statement extends the `SessionData` interface to define
    a `username` property so that a user’s identity can be associated with a session.
    It can be tempting to put more complex data in the session, but the purpose of
    this new property is just to identify the user, which can be done by just adding
    one `string` property to the `SessionData` interface. The second `declare` statement
    adds `user` and `authenticated` properties to the Express `Request` interface,
    which will allow more complex user data to be provided to the rest of the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `declare` 语句扩展了 `SessionData` 接口以定义一个 `username` 属性，以便将用户的身份与一个会话关联起来。虽然可能会诱使将更复杂的数据放入会话中，但这个新属性的目的仅仅是用来识别用户，这可以通过仅仅向
    `SessionData` 接口添加一个 `string` 属性来实现。第二个 `declare` 语句向 Express 的 `Request` 接口添加了
    `user` 和 `authenticated` 属性，这将允许向应用程序的其余部分提供更复杂用户数据。
- en: 'When the user’s credentials are validated, the `username` property added to
    the `SessionData` interface is used to store the username:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户的凭据被验证后，添加到 `SessionData` 接口的 `username` 属性被用来存储用户名：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new middleware component inspects the session data for requests to check
    to see if this property has been set. If it has, then the `username` and `authenticated`
    properties of the `Request` object are set, which is how the rest of the application
    will be able to identify the authenticated user.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 新的中间件组件检查请求的会话数据，以查看是否设置了此属性。如果设置了，那么 `Request` 对象的 `username` 和 `authenticated`
    属性将被设置，这就是应用程序的其余部分将如何识别已认证用户的方式。
- en: The final addition is a new route for the `/signout` URL, which lets a user
    sign out of the application by destroying the session, by calling the `destroy`
    method, which is a feature provided by the `express-session` package added to
    the project in *Chapter 13*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的添加是一个新的 `/signout` URL 路由，它允许用户通过销毁会话来注销应用程序，通过调用 `destroy` 方法，这是在 *第13章*
    中添加到项目中的 `express-session` 包提供的一个功能。
- en: This means that the session cookie has been transformed into the temporary token
    that authenticates the user’s requests. When the browser includes the session
    cookie in a request, the application knows that the request has been sent on behalf
    of the user because the session cookie represents the successful validation of
    the user’s credentials.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着会话cookie已经被转换成了用于验证用户请求的临时令牌。当浏览器在请求中包含会话cookie时，应用程序知道这个请求是代表用户发送的，因为会话cookie代表了用户凭据验证的成功。
- en: Using the authentication data
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用认证数据
- en: 'To complete the authentication feature, the user has to be able to see that
    they have successfully signed in and allowed to sign out again. Express has a
    useful feature for working with templates, called *local data* or *locals*, that
    allows data to be provided to a template outside of the call to the render method.
    Local data is specific to a single request/response pair, and any value that is
    assigned to the `Response.locals` property is available for use within any template.
    This is perfect for providing authentication information to templates, which would
    otherwise have to be added to the context data for every call to the `render`
    method. *Listing 15.11* uses this feature to provide templates with authentication
    information:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成身份验证功能，用户必须能够看到他们已成功登录并允许再次注销。Express 有一个用于处理模板的有用功能，称为 *本地数据* 或 *locals*，它允许在调用
    `render` 方法之外向模板提供数据。本地数据特定于单个请求/响应对，任何分配给 `Response.locals` 属性的值都可以在任何模板中使用。这对于向模板提供身份验证信息非常完美，否则必须在每次调用
    `render` 方法时将其添加到上下文数据中。*列表 15.11* 使用此功能向模板提供身份验证信息：
- en: 'Listing 15.11: Providing authentication details in the index.ts file in the
    src/server/auth folder'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.11：在 src/server/auth 文件夹中的 index.ts 文件中提供身份验证详细信息
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The new statements added to the middleware component create local data values
    named `user` and `authenticated`, which means that this information will be available
    to any template that is executed by a request/response that has been processed
    by this middleware. There is also a regular context data property named `signinpage`,
    which is passed to the `render` method when the sign-in form is presented to the
    user.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到中间件组件中的新语句创建名为 `user` 和 `authenticated` 的本地数据值，这意味着这些信息将可用于任何由经过此中间件处理的请求/响应执行的自定义模板。还有一个名为
    `signinpage` 的常规上下文数据属性，当登录表单呈现给用户时，它会被传递给 `render` 方法。
- en: '*Listing 15.12* updates the layout that is used with all templates, which allows
    the authentication information to be displayed throughout the application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15.12* 更新了与所有模板一起使用的布局，这使得可以在整个应用程序中显示身份验证信息：'
- en: 'Listing 15.12: Using authentication data in the main.handlebars file in the
    templates/server/layouts folder'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.12：在模板/server/layouts 文件夹中的 main.handlebars 文件中使用身份验证数据
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Local data values are used in the same way as regular template context data,
    and the additions to the template display the user’s name and a sign-out button
    if the request has been authenticated. If the request isn’t authenticated, then
    the template displays a sign-in button, unless the `signinpage` property is set,
    in which case no new content is shown.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本地数据值的使用方式与常规模板上下文数据相同，如果请求已验证，模板将显示用户名和注销按钮。如果请求未验证，则模板将显示登录按钮，除非设置了 `signinpage`
    属性，在这种情况下，不会显示新内容。
- en: To see the effect of the changes, use a browser to navigate to `http://localhost:5000/signin`,
    enter `alice` and `mysecret` into the `Name` and `Password` fields, respectively,
    and click the **Sign In** button. The credentials will be validated, and the browser
    will display the username and a **Sign Out** button. Click the **Sign Out** button,
    and a **Sign In** button will be displayed. This sequence is shown in *Figure
    15.3*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更改的效果，请使用浏览器导航到 `http://localhost:5000/signin`，分别在 `Name` 和 `Password` 字段中输入
    `alice` 和 `mysecret`，然后点击 **Sign In** 按钮。凭据将被验证，浏览器将显示用户名和一个 **Sign Out** 按钮。点击
    **Sign Out** 按钮，将显示一个 **Sign In** 按钮。此序列在 *图 15.3* 中显示。
- en: '![](img/B21959_15_03.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21959_15_03.png](img/B21959_15_03.png)'
- en: 'Figure 15.3: Using authentication data'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3：使用身份验证数据
- en: Authenticating web service requests
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证 Web 服务请求
- en: Applications can’t rely on forms to authenticate web services because clients
    may not be browsers and cannot be relied on to render HTML.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不能依赖于表单来验证 Web 服务，因为客户端可能不是浏览器，并且不能依赖于渲染 HTML。
- en: Web service clients can use cookies – because they are a standard part of HTTP
    – but session cookies can often cause problems because the session expiry is often
    set to suit round-trip clients, where every user interaction refreshes the cookie.
    Web service clients only send requests when they need data, and the frequency
    of requests can be so low that sessions expire too quickly to be useful.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务客户端可以使用 cookies – 因为它们是 HTTP 的标准部分 – 但会话 cookies 通常会引起问题，因为会话过期通常设置为适合往返客户端，其中每个用户交互都会刷新
    cookie。Web 服务客户端仅在需要数据时发送请求，请求的频率可能很低，以至于会话过期得太快，无法使用。
- en: Applications can address the lack of HTML support by providing an API to present
    credentials as JSON data. Instead of a cookie, the authentication API produces
    a *bearer token*, which is a string that can be included in requests, much like
    a cookie, but with its own lifecycle and without the dependency on sessions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过提供一个 API 来呈现凭据作为 JSON 数据来弥补 HTML 支持的不足。与 cookie 不同，认证 API 生成一个 *bearer
    令牌*，这是一个可以包含在请求中的字符串，就像 cookie 一样，但它有自己的生命周期，且不依赖于会话。
- en: The most common form of bearer token is the **JSON Web Token** (**JWT**) standard,
    which is a self-contained authentication token that doesn’t depend on server-side
    data. (There is a good overview of JWT at [https://jwt.io](https://jwt.io), along
    with tools to validate tokens, which can be useful during development).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 bearer 令牌形式是 **JSON Web Token**（JWT）标准，它是一个自包含的认证令牌，不依赖于服务器端数据。（有关 JWT
    的良好概述请参阅 [https://jwt.io](https://jwt.io)，以及用于验证令牌的工具，这在开发期间可能很有用）。
- en: 'As with just about every aspect of web services, there are no hard-and-fast
    standards for how a client performs authentication, but I am going to follow widely
    used conventions. To sign in, the client will send an `HTTP POST` request to the
    `/api/signin` URL, with a JSON payload that includes the user’s credentials, like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就像几乎网络服务的各个方面一样，客户端如何执行认证没有硬性标准，但我将遵循广泛使用的约定。为了登录，客户端将向 `/api/signin` URL 发送
    `HTTP POST` 请求，其中包含一个 JSON 有效负载，包含用户的凭据，如下所示：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result will contain a JSON object that contains a success property that
    indicates whether the credentials were accepted and, if they were, a `token` property
    that contains the bearer token, like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将包含一个包含成功属性的 JSON 对象，该属性指示凭据是否被接受，如果是，则包含一个 `token` 属性，其中包含 bearer 令牌，如下所示：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Real JWT tokens are longer sequences of characters, but I have shorted this
    one for brevity. The client doesn’t have to parse or process the token in any
    way, and they just have to include the token in HTTP requests using the `Authorization`
    header, like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 JWT 令牌是更长的字符序列，但我为了简洁起见缩短了这一示例。客户端无需以任何方式解析或处理令牌，只需在 HTTP 请求中使用 `Authorization`
    标头包含令牌即可，如下所示：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The value of the `Authorization` header is a scheme, which is `Bearer`, followed
    by the token generated during authentication. The server decodes the token and
    uses it to determine the identity of the authenticated user.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorization` 标头的值是一个方案，它是 `Bearer`，后面跟着认证过程中生成的令牌。服务器解码令牌并使用它来确定已认证用户的身份。'
- en: '**Understanding API keys**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解 API 密钥**'
- en: The examples in this chapter focus on user authentication. Web services can
    also use API keys, which identify the client making the request on behalf of the
    user, which can be useful when a third-party creates clients that consume your
    project’s APIs. API keys usually have a long life and are used to control access
    to API features, track request volumes, and so on. I don’t describe API keys in
    this book, but there is a good overview available at [https://cloud.google.com/endpoints/docs/openapi/when-why-api-key](https://cloud.google.com/endpoints/docs/openapi/when-why-api-key).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例主要关注用户认证。网络服务还可以使用 API 密钥，这些密钥标识代表用户发出请求的客户端，当第三方创建消费您项目 API 的客户端时可能很有用。API
    密钥通常具有较长的生命周期，用于控制 API 功能的访问、跟踪请求数量等。本书中未描述 API 密钥，但有一个良好的概述可在 [https://cloud.google.com/endpoints/docs/openapi/when-why-api-key](https://cloud.google.com/endpoints/docs/openapi/when-why-api-key)
    找到。
- en: Creating the authentication API
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建认证 API
- en: 'Run the command shown in *Listing 15.13* in the `part2app` folder to add a
    JWT package and its type descriptions to the example project:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `part2app` 文件夹中运行 *清单 15.13* 命令，以将 JWT 包及其类型描述添加到示例项目中：
- en: 'Listing 15.13: Installing a package'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15.13：安装包
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is possible to generate and validate JWT values using custom code, but it
    is simpler and easier to use a good package. *Listing 15.14* adds support to sign
    in API clients:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义代码生成和验证 JWT 值是可能的，但使用一个好的包更简单、更容易。*清单 15.14* 为登录 API 客户端添加了支持：
- en: 'Listing 15.14: Signing in API clients in the index.ts file in the src/server/auth
    folder'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15.14：在 src/server/auth 文件夹中的 index.ts 文件中登录 API 客户端
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `/api/signin` route relies on the Express JSON middleware to parse the
    data sent by the client and validates the user’s credentials. If the credentials
    are valid, then a token is created, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`/api/signin` 路由依赖于 Express JSON 中间件来解析客户端发送的数据，并验证用户的凭据。如果凭据有效，则创建一个令牌，如下所示：'
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `sign` function creates a token, which is signed to prevent tampering. The
    arguments are the data to use as the token payload, a secret used to sign the
    token (which must be used again during validation), and a configuration object
    that is used to specify the token expiry.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`sign`函数创建一个令牌，该令牌经过签名以防止篡改。参数是作为令牌有效负载使用的数据，用于签名字符串的密钥（在验证期间必须再次使用），以及用于指定令牌过期的配置对象。'
- en: The `jsonwebtoken` package supports setting expiry times using the syntax defined
    by the `ms` package ([https://github.com/vercel/ms](https://github.com/vercel/ms)).
    This allows the `expiresIn` property to be set to `1h`, which creates a token
    that’svalid for 60 mins.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonwebtoken`包支持使用`ms`包定义的语法设置过期时间（[https://github.com/vercel/ms](https://github.com/vercel/ms)）。这允许将`expiresIn`属性设置为`1h`，创建一个有效期为60分钟的令牌。'
- en: '**Note**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can put any data in a token that is consumed by the same application that
    generates it. If you are generating tokens that will be validated by third parties,
    then there are well-defined payload properties that are used to describe authentication
    and authorization data, which can be found at [https://jwt.io/introduction](https://jwt.io/introduction).
    Tokens are signed but not encrypted, which means that sensitive data should not
    be included in a token.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在令牌中放入任何由生成它的同一应用程序消耗的数据。如果您正在生成将由第三方验证的令牌，那么有一些用于描述身份验证和授权数据的定义良好的有效负载属性，可以在[https://jwt.io/introduction](https://jwt.io/introduction)找到。令牌是经过签名的，但不是加密的，这意味着不应在令牌中包含敏感数据。
- en: The authentication middleware checks to see if the request includes the `Authorization`
    header and, if it does, verifies its value as a token. The verification checks
    the signature to ensure that the payload hasn’t been altered and ensures the token
    has not expired. The username is read from the token’s payload and used to authenticate
    the request.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证中间件检查请求是否包含`Authorization`头，如果包含，则验证其值作为令牌。验证检查签名以确保有效负载未被更改，并确保令牌未过期。用户名从令牌的有效负载中读取，并用于验证请求。
- en: Authenticating the web service client
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证Web服务客户端
- en: 'To complete the authentication implementation, *Listing 15.15* updates the
    command-line client to add operations to sign in and out of the application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成身份验证实现，*清单15.15*更新了命令行客户端，添加了登录和注销应用程序的操作：
- en: 'Listing 15.15: Adding authentication in the operations.mjs file in the src/cmdline
    folder'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.15：在src/cmdline文件夹中的operations.mjs文件中添加身份验证
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The token received from successfully signing in is assigned to the variable
    named `bearer_token`, which is included in subsequent requests using the `Authorization`
    header. Note that the client doesn’t explicitly sign out of the application but
    simply discards the token. That’s because the server doesn’t keep track of the
    tokens it has issued, and there is no way to invalidate them. Once a token has
    been issued, it is valid until it has expired, and so web service clients simply
    stop using the token.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后收到的令牌被分配给名为`bearer_token`的变量，该变量包含在后续请求的`Authorization`头中。请注意，客户端不会明确注销应用程序，而是简单地丢弃令牌。这是因为服务器不会跟踪它已发行的令牌，也没有使其失效的方法。一旦发行了令牌，它就有效，直到过期，因此Web服务客户端只需停止使用该令牌即可。
- en: 'Open a second command prompt, and run the command shown in *Listing 15.16*
    in the `part2app` folder to start the command-line client:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 打开第二个命令提示符，并在`part2app`文件夹中运行*清单15.16*中显示的命令以启动命令行客户端：
- en: 'Listing 15.16: Starting the client'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.16：启动客户端
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Select the **Sign In** option, and enter `alice` as the username and `mysecret`
    as the password. The response from the server shows the outcome of the authentication
    and the token, like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**登录**选项，并以`alice`作为用户名，`mysecret`作为密码进行输入。服务器的响应显示了身份验证的结果和令牌，如下所示：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You will see a different token value, but the structure of the data will be
    the same.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到不同的令牌值，但数据结构将是相同的。
- en: Authorizing requests
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权请求
- en: Now that the user can authenticate themselves, the next step is to restrict
    access to operations based on the user’s identity so that actions can only be
    performed by authorized users.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以自行进行身份验证，下一步是限制基于用户身份的操作访问，以确保只有授权用户才能执行操作。
- en: The foundation for authorization is the *authorization policy*, which is a mapping
    between the operations the application provides and the users that are allowed
    to perform them. At its simplest, the mapping can be expressed as a simple list,
    as shown in *Table 15.4* for the example application, which provides `Add` and
    `Delete` operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 授权的基础是*授权策略*，它是应用程序提供的操作与允许执行这些操作的用户之间的映射。在最简单的情况下，映射可以表示为一个简单的列表，如示例应用程序中的*表15.4*所示，它提供了`添加`和`删除`操作。
- en: 'Table 15.4: A simple authorization policy'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.4：一个简单的授权策略
- en: '| Operation | Authorized Users |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 授权用户 |'
- en: '| `Add` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `添加` |'
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Delete` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `删除` |'
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The problem with this approach is that the authorization policy is an integral
    part of the application, which means that adding a new user or changing the operations
    that a user can perform requires a code change and a new release to be tested
    and deployed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是授权策略是应用程序的一个组成部分，这意味着添加新用户或更改用户可以执行的操作需要代码更改，并需要测试和部署新版本。
- en: For this reason, most applications introduce *roles* and rely on *role* *assignment*
    to authorize requests. Rather than checking to see if the user is on the list,
    the application checks to see if the user has been assigned to one of the roles
    that are authorized to perform an operation. The details of which users are assigned
    to each role can be stored in a database so that changes can be made without altering
    the application’s code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数应用程序引入了*角色*并依赖于*角色*分配来授权请求。而不是检查用户是否在列表中，应用程序会检查用户是否被分配给有权执行操作的某个角色。哪些用户被分配给每个角色的详细信息可以存储在数据库中，以便在不更改应用程序代码的情况下进行更改。
- en: Applications are free to assign users to roles in whatever way makes the most
    sense, but a common approach is to focus on the different ways in which they engage
    with an application. For this chapter, I am going to create two roles, as described
    in *Table 15.5*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以自由地以任何最有意义的方式将用户分配给角色，但一种常见的方法是关注他们与应用程序交互的不同方式。对于本章，我将创建两个角色，如*表15.5*所述。
- en: 'Table 15.5: The example application roles'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.5：示例应用程序角色
- en: '| Roles | Members |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 角色 | 成员 |'
- en: '| `Users` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `Users` |'
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Admins` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `Admins` |'
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The authorization policy can now be expressed in terms of authorized roles,
    rather than individual users, as described in *Table 15.6*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在授权策略可以用授权角色的术语来表达，而不是单个用户，如*表15.6*所述。
- en: 'Table 15.6: A role-based authorization policy'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.6：基于角色的授权策略
- en: '| Operation | Authorized Roles |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 授权角色 |'
- en: '| `Add` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `添加` |'
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Delete` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `删除` |'
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The user `alice` has been assigned to both roles and will be able to perform
    the `Add` and `Delete` operations. The user `bob` has been assigned to the `Users`
    role and will be able to perform the `Add` operation, but not the `Delete` operation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用户`alice`被分配了两个角色，将能够执行`添加`和`删除`操作。用户`bob`被分配了`用户`角色，将能够执行`添加`操作，但不能执行`删除`操作。
- en: Adding support for roles
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对角色的支持
- en: 'The first step is to expand the database to add support for describing roles,
    as shown in *Listing 15.17*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是扩展数据库以支持描述角色，如下所示*清单15.17*：
- en: 'Listing 15.17: Adding types in the auth_types.ts in the src/server/auth folder'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.17：在src/server/auth文件夹中的auth_types.ts中添加类型
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 15.18* defines the model class that Sequelize will use to represent
    roles in the database and modifies the existing model class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15.18*定义了Sequelize将用于在数据库中表示角色的模型类，并修改了现有的模型类：'
- en: '**Note**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For consistency, it is easier to store credentials and role assignments in the
    same database so that the primary key for a user account can be used as a foreign
    key for role membership. You can use separate databases, if you prefer, just as
    long as you ensure that changes are applied consistently, such as updating role
    memberships when a user account is deleted.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，将凭证和角色分配存储在同一个数据库中会更简单，这样用户账户的主键就可以用作角色成员的外键。如果你更喜欢使用单独的数据库，只要确保更改是一致性的，例如，当删除用户账户时更新角色成员。
- en: 'Listing 15.18: Adding a model in the orm_auth_models.ts file in the src/server/auth
    folder'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.18：在src/server/auth文件夹中的orm_auth_models.ts文件中添加模型
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Storing role memberships requires a *many-to-many relationship*, where each
    role can be associated with many user credentials, and each user credential can
    be associated with many roles. The `RoleModel` class represents a role, with properties
    that provide the role name and an array of `CredentialsModels` objects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 存储角色成员资格需要一个**多对多关系**，其中每个角色可以与许多用户凭据相关联，每个用户凭据也可以与许多角色相关联。`RoleModel`类表示一个角色，具有提供角色名称和`CredentialsModels`对象数组的属性。
- en: 'Many-to-many relationships are represented in SQL using a junction table, where
    each row represents the relationship between one user and one role. Many-to-many
    relationships are always awkwardly represented by ORM packages, and some trial
    and error is usually required to get the objects created by the ORM to match up
    to the SQL tables that are created. Sequelize has a better-than-average approach,
    and the relationship between the model classes is created using the `belongsToMany`
    method, like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系在SQL中使用连接表表示，其中每一行代表一个用户和一个角色之间的关系。多对多关系通常由ORM包以尴尬的方式表示，并且通常需要一些尝试和错误才能使ORM创建的对象与创建的SQL表相匹配。Sequelize有一个比平均水平更好的方法，并且使用`belongsToMany`方法创建模型类之间的关系，如下所示：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The arguments define the many-to-many relationship using a table named after
    the `RoleMembershipJunction` class to create the junction. Sequelize will create
    the table and figure out the column data types automatically and will include
    associated data in results when the `include` query configuration setting is used,
    as you will see in *Listing 15.18*. The associated data can be read using properties
    that are added to the model class, which are described to TypeScript like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 参数定义了使用名为`RoleMembershipJunction`类的表的多对多关系以创建连接表。Sequelize将自动创建表并确定列数据类型，并在使用`include`查询配置设置时将关联数据包含在结果中，正如你将在*列表15.18*中看到的那样。关联数据可以通过添加到模型类的属性来读取，这些属性被描述为TypeScript如下：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The properties are optional, as denoted by the `?` character, because they
    will only be populated when the query includes related data. Sequelize adds methods
    to model objects to allow their relationships to other models to be used for more
    than reading data. For the benefit of TypeScript, the `declare` keyword has to
    be used to describe the properties, like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是可选的，正如`?`字符所示，因为它们只有在查询包含相关数据时才会被填充。Sequelize为模型对象添加了方法，以便它们与其他模型的关系可以用于读取数据之外的操作。为了TypeScript的好处，必须使用`declare`关键字来描述属性，如下所示：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The names given to the methods combine the operation and the model class, such
    that `setCredentialsModels` is a method that allows the `CredentialModels` objects
    associated with a `RoleModel` to be set in a single operation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给方法的名称结合了操作和模型类，例如`setCredentialsModels`是一个允许在单个操作中设置与`RoleModel`关联的`CredentialModels`对象的方法。
- en: For each of these methods, Sequelize provides types that can be used with the
    `declare` statement. In the case of the set operation, the type is named `HasManySetAssociationsMixin`,
    and the generic type parameters are used to specify the associated model class
    as the type of the primary key.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些方法中的每一个，Sequelize都提供了可以与`declare`语句一起使用的类型。在设置操作的情况下，类型被命名为`HasManySetAssociationsMixin`，并且使用泛型类型参数来指定关联模型类作为主键的类型。
- en: '**Note**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: This is the only method I need for this example because roles are updated by
    replacing all of the members, but Sequelize adds methods to read, add, and remove
    associated data, along with type descriptions for each of them, as described at
    [https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances](https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在这个示例中需要的唯一方法，因为角色是通过替换所有成员来更新的，但Sequelize添加了读取、添加和删除关联数据的方法，以及每个方法的类型描述，如[https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances](https://sequelize.org/docs/v6/core-concepts/assocs/#special-methodsmixins-added-to-instances)中所述。
- en: The next step is to extend the store to add support to query, store, and check
    roles, as shown in *Listing 15.19*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是扩展存储以添加对查询、存储和检查角色的支持，如*列表15.19*所示。
- en: 'Listing 15.19: Supporting roles in the orm_authstore.ts file in the src/server/auth
    folder'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.19：在src/server/auth文件夹中的orm_authstore.ts文件中支持角色
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The new statements in the constructor initialize the database models and add
    the `Admins` and `Users` roles, which will be used to demonstrate the authorization
    process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的新语句初始化数据库模型，并添加 `Admins` 和 `Users` 角色，这些角色将用于演示授权过程。
- en: 'The `getRole` method queries the database for `RoleModel` objects and uses
    the `include` option to include the associated `CredentialsModel` objects in the
    results, which is transformed into the `Role` result required by the `RoleStore`
    interface. I only need the `username` value to create a role, and I have specified
    the column I want `Sequelize` to include in the query using the `attributes` property:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRole` 方法查询数据库中的 `RoleModel` 对象，并使用 `include` 选项将相关的 `CredentialsModel`
    对象包含在结果中，这被转换成 `RoleStore` 接口所需的 `Role` 结果。我只需要 `username` 值来创建一个角色，并且我已经使用 `attributes`
    属性指定了 `Sequelize` 在查询中要包含的列：'
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `include` property is configured with an object whose `model` property specifies
    the associated data and `attributes` property specifies the model properties to
    populate in the result.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 属性配置为一个对象，其 `model` 属性指定相关数据，`attributes` 属性指定要在结果中填充的模型属性。'
- en: 'A similar technique is used to implement the `getRolesForUser` method. The
    `findAll` method is used to query for all `RoleModel` objects, but the `where`
    clause is used to make a selection based on the associated data so that only `RoleModel`
    objects that have associations with `CredentialsModel` objects whose `username`
    property matches a given value. An empty `attributes` array is used to exclude
    all of the `CredentialModel` data from the result:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的技术用于实现 `getRolesForUser` 方法。使用 `findAll` 方法查询所有 `RoleModel` 对象，但使用 `where`
    子句根据相关数据进行选择，以便只选择与 `CredentialsModel` 对象相关联且 `username` 属性与给定值匹配的 `RoleModel`
    对象。使用空的 `attributes` 数组来排除结果中的所有 `CredentialModel` 数据：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There can be several different ways to approach queries when there are relationships
    between models, and the same data can be obtained by starting with the `CredentialModel`
    class and including the `RoleModel` class. My advice is to pick whichever approach
    feels the most natural to you, which will be a matter of personal preference.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型之间存在关系时，查询可能有几种不同的方法，并且可以从 `CredentialModel` 类开始，包括 `RoleModel` 类来获取相同的数据。我的建议是选择对你来说最自然的方法，这将是个人偏好的问题。
- en: The `storeOrUpdateRole` method accepts a `Role` object and queries the database
    for all of the matching `CredentialsModel` objects, which ensures that any name
    for which there are no user credentials is ignored. The `findOrCreate` method
    ensures that a `RoleModel` object exists in the database, and the `setCredentialsModels`
    method is used to set the role membership. A transaction is used to ensure that
    the update is performed atomically.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`storeOrUpdateRole` 方法接受一个 `Role` 对象，并查询数据库以找到所有匹配的 `CredentialsModel` 对象，这确保了任何没有用户凭据的名称都被忽略。`findOrCreate`
    方法确保数据库中存在 `RoleModel` 对象，并使用 `setCredentialsModels` 方法设置角色成员资格。使用事务来确保更新是原子性的。'
- en: The `validateMembership` method gets the roles to which a user has been assigned
    and checks that one of them matches the required role.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateMembership` 方法获取用户已被分配的角色，并检查其中之一是否与所需角色匹配。'
- en: Checking authorization
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查授权
- en: 'The next step is to guard routes so that only users who are assigned to authorized
    roles can perform operations. There are lots of ways to implement authorization,
    but one of the simplest is to use the Express feature that allows middleware components
    to be added to individual routes, which means that requests can be inspected and
    rejected before they are passed to the route’s request handler. *Listing 15.20*
    adds a function that creates a middleware component that restricts access to one
    or more roles:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是保护路由，以确保只有被分配到授权角色的用户才能执行操作。实现授权的方法有很多，但其中最简单的一种是使用 Express 的功能，允许将中间件组件添加到单个路由中，这意味着请求可以在传递给路由请求处理器之前进行检查和拒绝。*列表
    15.20* 添加了一个创建中间件组件的函数，该组件限制对一个或多个角色的访问：
- en: 'Listing 15.20: Defining a guard handler in the index.ts file in the src/server/auth
    folder'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.20：在 src/server/auth 文件夹中的 index.ts 文件中定义守卫处理器
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `roleGuard` function accepts a role and returns a middleware component that
    will only pass on the request to the handler if the user has been assigned to
    that role, which is checked using the `validateMembership` method provided by
    the store.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`roleGuard`函数接受一个角色并返回一个中间件组件，该组件只有在用户被分配到该角色时才会将请求传递到处理器，这是通过store提供的`validateMembership`方法来检查的。'
- en: There are two outcomes for unauthorized requests. If the user has not been authenticated,
    then the user is redirected to the `/signin` URL, so they can authenticate themselves
    and try again.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未经授权的请求，有两种结果。如果用户尚未认证，则用户将被重定向到`/signin` URL，以便他们可以自行认证并重试。
- en: 'For authenticated requests, the user is redirected to the `/unauthorized` URL.
    *Listing 15.20* adds a route for `/unauthorized` that renders a template. To create
    the template, add a file named `unauthorized.handlebars` to the `templates/server`
    folder with the content shown in *Listing 15.21*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已认证的请求，用户将被重定向到`/unauthorized` URL。*列表15.20*为`/unauthorized`添加了一个渲染模板的路由。要创建模板，请将名为`unauthorized.handlebars`的文件添加到`templates/server`文件夹中，其内容如*列表15.21*所示：
- en: 'Listing 15.21: The contents of the unauthorized.handlebars file in the templates/server
    folder'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.21：在templates/server文件夹中的unauthorized.handlebars文件的内容
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The final step is to apply the guard to restrict access to operations, as shown
    in *Listing 15.22*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将守卫应用到限制操作访问，如*列表15.22*所示：
- en: 'Listing 15.22: Authorizing requests in the forms.ts file in the src/server
    folder'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.22：在src/server文件夹中的forms.ts文件中授权请求
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `/form/add` route is restricted to the `Users` role, and the `/form/delete/:id`
    route is restricted to the `Admins` role.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`/form/add`路由限制为`Users`角色，而`/form/delete/:id`路由限制为`Admins`角色。'
- en: 'Applying the role guard reveals an inconsistency in the type descriptions for
    the Express API, which causes the TypeScript compiler to complain about statements
    like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 应用角色守卫揭示了Express API类型描述中的不一致性，这导致TypeScript编译器对类似这样的语句发出警告：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The type that the compiler uses for the `Request.params` property has changed,
    and the compiler will complain about the `id` property. It is possible to correct
    this by adding a type annotation to the request handler, but a quick fix is to
    access the property like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器用于`Request.params`属性的类型已更改，编译器将对`id`属性发出警告。可以通过向请求处理器添加类型注解来纠正此问题，但快速修复方法是像这样访问属性：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Use a browser to request `http://localhost:5000`, and make sure that no user
    is signed in. Click the **Add** button. The browser will send a request to the
    `/form/add` route, but since the request is unauthenticated, the browser will
    be redirected to the `/signin` page. Sign in with the username `bob` and the password
    `mysecret`, and click the **Add** button again. This time, the request is authenticated,
    and the user has been assigned to the `Users` role, so the request is authorized
    and passed onto the request handler, which adds a new value to the database.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求`http://localhost:5000`，并确保没有用户登录。点击**添加**按钮。浏览器将向`/form/add`路由发送请求，但由于请求未经认证，浏览器将被重定向到`/signin`页面。使用用户名`bob`和密码`mysecret`登录，然后再次点击**添加**按钮。这次，请求已认证，用户已被分配到`Users`角色，因此请求被授权并传递到请求处理器，该处理器将新值添加到数据库中。
- en: Click the **Delete** button, and the browser will send a request to the `/form/delete/:id`
    route. The request is authenticated but the user has not been assigned to the
    `Admins` role, so the browser is redirected to the `/unauthorized` URL. The complete
    sequence is shown in *Figure 15.4*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**删除**按钮，浏览器将向`/form/delete/:id`路由发送请求。请求已认证，但用户没有被分配到`Admins`角色，因此浏览器被重定向到`/unauthorized`
    URL。完整的序列如*图15.4*所示。
- en: '![](img/B21959_15_04.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_15_04.png)'
- en: 'Figure 15.4: Testing authorization'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：测试授权
- en: Authorizing API requests
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权API请求
- en: 'The `Feathers` package that I introduced in *Chapter 14* provides support for
    hooks, which allow requests to be intercepted, and which I used to alter the status
    code when a specific error was thrown. In this chapter, I am going to use the
    same feature to manage authorization. The first step is to create a function that
    will create a hook that checks the user’s membership of a role, as shown in *Listing
    15.23*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*第14章*中介绍的`Feathers`包提供了对钩子的支持，这允许拦截请求，并且我使用它来在抛出特定错误时更改状态码。在本章中，我将使用相同的功能来管理授权。第一步是创建一个函数，该函数将创建一个检查用户角色成员资格的钩子，如*列表15.23*所示：
- en: 'Listing 15.23: Adding a hook function in the index.ts file in the src/server/auth
    folder'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.23：在src/server/auth文件夹中的index.ts文件中添加钩子函数
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `roleHook` function creates a hook that will authorize access if a user
    has been assigned to a specified role. The user’s identity is accessed through
    the `HookContext` parameter, which Feathers provides when a hook is invoked. The
    key difference from the route guard used for non-API requests is that the responses
    are HTTP status codes and not HTML documents. The `401` status code indicates
    a request that does not include authentication data, and a `403` status code is
    sent when the user is authenticated but not authorized. The status code is set
    using the `HookContext.http` property, and setting the `result` property has the
    effect of terminating request handling.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`roleHook`函数创建一个钩子，如果用户被分配到指定的角色，则授权访问。用户的身份通过`HookContext`参数访问，这是Feathers在调用钩子时提供的。与用于非API请求的路由守卫相比，主要区别在于响应是HTTP状态码而不是HTML文档。`401`状态码表示不包含认证数据的请求，当用户已认证但未授权时，会发送`403`状态码。状态码使用`HookContext.http`属性设置，设置`result`属性的效果是终止请求处理。'
- en: '*Listing 15.24* applies the hook and configures Feathers so that the hook receives
    the request’s authentication data:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15.24*应用了钩子并配置了Feathers，使钩子接收请求的认证数据：'
- en: 'Listing 15.24: Applying authorization in the index.ts file in the src/server/api
    folder'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.24：在src/server/api文件夹中的index.ts文件中应用授权
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first step is to get the authentication data from the request and add it
    to the `feathers` property, which is added to requests when Feathers is used and
    presented through the `HookContext` object provided to hooks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是从请求中获取认证数据并将其添加到`feathers`属性中，该属性在Feathers被使用时添加到请求中，并通过提供给钩子的`HookContext`对象展示。
- en: The second step is to create hooks to protect the web service. The `before`
    property is used to register hooks that are invoked before a web service method
    is invoked, and the `create`, `remove`, `update`, and `patch` methods are protected
    by hooks that require either the `Users` or `Admins` role.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是创建钩子来保护Web服务。`before`属性用于注册在调用Web服务方法之前被调用的钩子，而`create`、`remove`、`update`和`patch`方法由需要`Users`或`Admins`角色的钩子保护。
- en: 'If you closed the command-line client from earlier in the chapter, then open
    a new command prompt, navigate to the `part2app` folder, and run the command shown
    in *Listing 15.25*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关闭了本章早期提到的命令行客户端，那么打开一个新的命令提示符，导航到`part2app`文件夹，并运行*列表15.25*中显示的命令：
- en: 'Listing 15.25: Starting the command-line client'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.25：启动命令行客户端
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Select the **Store** option, enter the data values, and when the request is
    sent, the server will response with a `401` status code, which indicates that
    an operation requires authorization but the request contained no authentication
    data, like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**存储**选项，输入数据值，当请求发送时，服务器将响应`401`状态码，这表示操作需要授权，但请求中没有包含认证数据，如下所示：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Sign in as `bob` with the password `mysecret` and repeat the process. This
    time, the request will contain the bearer token, and the user `bob` has been assigned
    to the `Users` role, so the operation will be authorized, like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密码`mysecret`以`bob`的身份登录并重复此过程。这次，请求将包含承载令牌，用户`bob`已被分配到`Users`角色，因此操作将被授权，如下所示：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Select **Delete** and enter an `ID`. The request will contain a token, but
    `bob` hasn’t been assigned to the `Admins` role, so the server will respond with
    a `403` status code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**删除**并输入一个`ID`。请求将包含一个令牌，但`bob`没有被分配到`Admins`角色，因此服务器将响应`403`状态码：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Sign in as `alice` and repeat the `Delete` request, which will succeed because
    `alice` has been assigned to the `Admins` role:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以`alice`的身份登录并重复执行`Delete`请求，这将成功，因为`alice`已被分配到`Admins`角色：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The authorization process for the web service is based on the same user data
    as for HTML clients, but returning a status code gives API clients a response
    that can be handled programmatically.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务的授权过程基于与HTML客户端相同的用户数据，但返回状态码使API客户端能够得到可以程序化处理的响应。
- en: Using packages for authentication and authorization
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包进行认证和授权
- en: Now that you understand how authentication and authorization work together in
    a web application, it is time to replace some of the custom code with open-source
    packages.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在Web应用程序中认证和授权是如何协同工作的，是时候用开源包替换一些自定义代码了。
- en: There are two good reasons to use open-source packages for authentication in
    particular. The first reason is that it is easy to make a mistake when writing
    custom code that creates a security vulnerability. The second reason is that a
    good authentication package will support a range of different authentication strategies,
    including authentication with third-party services, such as Google and Facebook.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开源包进行身份验证有两个很好的理由。第一个理由是，在编写创建安全漏洞的自定义代码时很容易出错。第二个理由是，一个好的身份验证包将支持一系列不同的身份验证策略，包括使用第三方服务（如
    Google 和 Facebook）进行身份验证。
- en: In *Part 3* of this book, I demonstrate a different authentication strategy,
    but for this chapter, I am going to use open-source packages but still use usernames
    and passwords for authentication.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的 *第 3 部分* 中，我将演示不同的身份验证策略，但在这个章节中，我将使用开源包，但仍然使用用户名和密码进行身份验证。
- en: Not all features can be replaced with custom code. The focus tends to be on
    authentication, while authorization is left to individual applications to implement.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有功能都可以用自定义代码替换。重点往往放在身份验证上，而授权则留给各个应用程序来实现。
- en: Authenticating HTML clients
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 HTML 客户端
- en: 'I am going to use the Passport package ([https://www.passportjs.org](https://www.passportjs.org))
    to provide authentication. Passport supports a wide range of authentication strategies,
    including support for using third-party authentication services, and provides
    an API to implement custom strategies. In this chapter, I use the `Local` strategy,
    which provides support to authenticate users with locally stored username and
    password data and uses sessions to authenticate subsequent requests. I also use
    the **JWT** strategy, which uses bearer tokens to authenticate requests. Run the
    commands shown in *Listing 15.26* in the `part2app` folder to install the main
    passport package, the packages that contain the strategies, and type descriptions
    for all of them:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Passport 包 ([https://www.passportjs.org](https://www.passportjs.org)) 来提供身份验证。Passport
    支持广泛的身份验证策略，包括对使用第三方身份验证服务的支持，并提供了一个 API 来实现自定义策略。在本章中，我使用 `Local` 策略，该策略支持使用本地存储的用户名和密码数据来验证用户，并使用会话来验证后续请求。我还使用了
    **JWT** 策略，该策略使用携带令牌来验证请求。在 `part2app` 文件夹中运行 *清单 15.26* 中显示的命令来安装主要的 passport
    包、包含策略的包以及所有这些包的类型描述：
- en: 'Listing 15.26: Installing packages'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15.26：安装包
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Passport requires configuration so that it can be integrated into the application.
    Add a file named `passport_config.ts` to the `src/server/auth` folder, with the
    content shown in *Listing 15.27*:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 需要配置才能集成到应用程序中。将一个名为 `passport_config.ts` 的文件添加到 `src/server/auth`
    文件夹中，其内容如 *清单 15.27* 所示：
- en: 'Listing 15.27: The contents of the passport_config.ts file in the src/server/auth
    folder'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15.27：src/server/auth 文件夹中 passport_config.ts 文件的内容
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `passport.use` function is used to set up strategies, and in *Listing 15.27*,
    the local and JWT strategies are applied. These strategies require a verification
    function, which receives the request data and returns an object representing the
    user.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`passport.use` 函数用于设置策略，在 *清单 15.27* 中应用了本地和 JWT 策略。这些策略需要一个验证函数，该函数接收请求数据并返回一个表示用户的对象。'
- en: 'The verification function for the local strategy receives the username and
    password sent by the user, which is validated using the stored credentials. The
    outcome is provided to Passport with a callback, which either provides an object
    that represents the user or `false` if verification fails:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本地策略的验证函数接收用户发送的用户名和密码，使用存储的凭证进行验证。结果通过回调提供给 Passport，要么提供一个表示用户的对象，要么在验证失败时返回
    `false`：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The verification function will only be called when the user signs in, after
    which Passport uses a temporary token to authenticate subsequent requests. One
    option is to use session cookies to store the user data, which is the same approach
    used by the custom code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 验证函数仅在用户登录时被调用，之后 Passport 使用临时令牌来验证后续请求。一个选项是使用会话cookie来存储用户数据，这与自定义代码中使用的方法相同。
- en: The verification for the JWT strategy is different. Passport doesn’t generate
    JWT tokens, and the verification function is called when a bearer token is received.
    The strategy is configured with an object that tells Passport how to locate the
    bearer token in the request and provides the key to check the token signature.
    The verification function receives the payload from the token and is responsible
    for providing an object that represents the authenticated user.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 策略的验证方式不同。Passport 不生成 JWT 令牌，而是在收到携带令牌时调用验证函数。策略配置了一个对象，告诉 Passport 如何在请求中定位携带令牌，并提供检查令牌签名的密钥。验证函数接收令牌的有效负载，并负责提供一个表示已认证用户的对象。
- en: 'The `serializeUser` and `deserializeUser` functions are used by Passport to
    include user information in the session. These functions must be defined even
    when, as in this case, user data is just an object containing a username. *Listing
    15.28* uses Passport to authenticate requests:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`serializeUser` 和 `deserializeUser` 函数由 Passport 用于在会话中包含用户信息。即使在这种情况下，用户数据只是一个包含用户名的对象，这些函数也必须被定义。*列表
    15.28* 使用 Passport 验证请求：'
- en: 'Listing 15.28: Using Passport in the index.ts File in the src/server/auth Folder'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.28：在 src/server/auth 文件夹中的 index.ts 文件中使用 Passport
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Passport provides its own additions to the `Express` `Request` object, so adjustments
    are required to prevent conflicts. The `Passport` `authenticate` function is used
    twice. When used with a route, the `authenticate` method is used to create a request
    handler that will validate credentials using the local strategy:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 为 `Express` 的 `Request` 对象提供了自己的扩展，因此需要进行调整以防止冲突。`Passport` 的 `authenticate`
    函数被使用两次。当与路由一起使用时，`authenticate` 方法用于创建一个请求处理器，该处理器将使用本地策略验证凭据：
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The configuration options tell Passport where to redirect the browser for successful
    and failed sign-in attempts. Passport doesn’t include the username and password
    in redirections for failed sign-in attempts, which is why the values are no longer
    included when the sign-in template is rendered.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 配置选项告诉 Passport 在成功和失败的登录尝试中应将浏览器重定向到何处。Passport 不在失败的登录尝试的重定向中包含用户名和密码，这就是为什么在渲染登录模板时不再包含这些值。
- en: 'The other use of the `authenticate` function is to authenticate requests, and
    the argument specifies that the session is the source of authentication data:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate` 函数的另一种用途是验证请求，参数指定会话是认证数据的来源：'
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Passport doesn’t have an `authenticate` property, but a follow-on handler function
    allows the property to be set, along with the local data required for templates.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 没有名为 `authenticate` 的属性，但后续的处理函数允许设置该属性，以及模板所需的本地数据。
- en: 'As noted, Passport doesn’t create JWT tokens, so the code that authenticates
    API clients remains unchanged. Passport does *validate* JWT tokens, however, which
    is why the code that read and validated the bearer token was removed in *Listing
    15.28*. *Listing 15.29* uses Passport to authenticate bearer tokens for web service
    requests:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Passport 不创建 JWT 令牌，因此验证 API 客户端的代码保持不变。然而，Passport 确实 *验证* JWT 令牌，这就是为什么在
    *列表 15.28* 中移除了读取和验证携带令牌的代码。*列表 15.29* 使用 Passport 验证 Web 服务请求的携带令牌：
- en: 'Listing 15.29: Using Passport in the index.ts file in the src/server/api folder'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.29：在 src/server/api 文件夹中的 index.ts 文件中使用 Passport
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `authenticate` function is used to create a request handler that will validate
    tokens, using the JWT strategy. A follow-on function is used to set the values
    used by the Feathers hook so that authorization checks can be performed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate` 函数用于创建一个请求处理器，该处理器将使用 JWT 策略验证令牌。后续函数用于设置 Feathers 钩子使用的值，以便执行授权检查。'
- en: '**Note**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Feathers has its own authentication and authorization features, which are useful
    if you are creating a stand-alone API project, and they are described at [https://feathersjs.com/api/authentication](https://feathersjs.com/api/authentication).
    Mixing authentication features from multiple packages can be difficult, which
    is why I have used Passport for all authentication in the examples, even though
    some features, like JWT creation, are not available.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Feathers 有自己的认证和授权功能，如果你正在创建一个独立的 API 项目，这些功能非常有用，它们在 [https://feathersjs.com/api/authentication](https://feathersjs.com/api/authentication)
    中进行了描述。混合来自多个包的认证功能可能很困难，这就是为什么我在示例中使用了 Passport 进行所有认证，即使某些功能，如 JWT 创建，不可用。
- en: The use of the Passport package doesn’t alter the way authentication works,
    and users sign into the application in the same way. The difference is the reduction
    in custom code and support for a wider range of authentication strategies, which
    can make it easier to integrate an application into an existing environment or
    to use third-party authentication services.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Passport包的使用不会改变身份验证的工作方式，用户以相同的方式登录应用程序。区别在于减少了自定义代码并支持更广泛的身份验证策略，这使得将应用程序集成到现有环境或使用第三方身份验证服务变得更加容易。
- en: Custom code is still required to perform role-based authorization, which is
    why it is important to understand how users and requests are authenticated, and
    how the results can be used to restrict access to application features.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 执行基于角色的授权仍需要自定义代码，这就是为什么理解用户和请求是如何进行身份验证的，以及如何使用这些结果来限制对应用程序功能的访问很重要的原因。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, I demonstrated how users and requests can be authenticated,
    and how authentication data can be used to authorize access to application features:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我演示了如何对用户和请求进行身份验证，以及如何使用身份验证数据授权访问应用程序功能：
- en: Users present their credentials, whether using an HTML form or a JSON payload.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户通过HTML表单或JSON有效负载展示其凭证。
- en: When credentials are validated, the client is sent a temporary token that can
    be used to authenticate subsequent requests.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当凭证得到验证时，客户端会收到一个临时令牌，该令牌可用于验证后续请求。
- en: The temporary authentication token can be a cookie (and a session cookie is
    often used) or a bearer token.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时身份验证令牌可以是cookie（通常使用会话cookie）或携带令牌。
- en: Authorization is usually performed through roles, which prevents you having
    to hardcode user permissions into the application. The relationship between users
    and roles is stored in a database, so it can be altered without releasing a new
    version of the application.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权通常通过角色来执行，这可以防止你需要在应用程序中硬编码用户权限。用户和角色之间的关系存储在数据库中，因此可以在不发布新版本应用程序的情况下进行修改。
- en: There are good open-source packages available for user and request authentication,
    but authorization is typically done using custom code.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户和请求的身份验证，有可用的开源包，但通常使用自定义代码进行授权。
- en: In *Part 3*, I use the features described in *Parts 1* and *2* of this book
    to create an online store that shows how the different parts of an application
    work together.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第3部分**中，我使用本书**第1部分**和**第2部分**中描述的功能创建了一个在线商店，展示了应用程序的不同部分是如何协同工作的。
