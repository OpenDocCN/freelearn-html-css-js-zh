- en: Node and MongoDB Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node和MongoDB基础知识
- en: Before we dig in and start building a full-blown web application using Node
    and MongoDB, it's important that we review some of the basics. This chapter will
    give you a crash course on syntax and important topics. It is broken down into
    two parts, where the first half focuses on JavaScript or Node, and the second
    half covers MongoDB. You will gain insight into some of the more common and powerful
    tools available to you, and a lot of sample code will be reviewed to get you up
    to speed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究并开始使用Node和MongoDB构建一个完整的Web应用程序之前，重温一些基础知识是很重要的。本章将为你提供一个关于语法和重要主题的速成课程。它分为两部分，前半部分侧重于JavaScript或Node，后半部分涵盖MongoDB。你将深入了解一些常见和强大的可用工具，并将回顾大量的示例代码，以便让你快速上手。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Fundamentals of the JavaScript language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript语言的基础知识
- en: The basics of Node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的基础知识
- en: Node's package manager, npm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node的包管理器npm
- en: The basics of MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB的基础知识
- en: By the end of this chapter, you should have a solid understanding of the syntax
    and how to use both Node and MongoDB. There's a lot to cover, so let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该对语法以及如何使用Node和MongoDB有扎实的理解。有很多内容需要涵盖，所以让我们开始吧。
- en: A JavaScript primer
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript入门指南
- en: As we already know, Node.js is not just another language, but JavaScript. The
    language syntax and tools you used while coding JavaScript on the browser will
    work verbatim on the server. Node.js has additional tools that are only available
    on the server, but the language and syntax are again the same as JavaScript. I'm
    assuming you have a general understanding of the basic JavaScript syntax, but
    I will introduce JavaScript to you with a very brief primer on the language, just
    in case.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Node.js不仅仅是另一种语言，而是JavaScript。在编写浏览器上的JavaScript时使用的语言语法和工具将完全适用于服务器端。Node.js具有一些仅在服务器上可用的附加工具，但语言和语法再次与JavaScript相同。我假设你对基本的JavaScript语法有一般的了解，但我会简要介绍一下JavaScript的语言，以防万一。
- en: In general, JavaScript is a fairly simple language when it comes to syntax,
    and you only need to know a few important elements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，JavaScript在语法方面是一个相当简单的语言，你只需要了解一些重要的元素。
- en: Introducing es6
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍es6
- en: The es6, or ECMAScript, 2015 is a JavaScript language update for all types,
    values, object literals, properties, functions, and program syntaxes. The whole
    new semantics of es6 (which is similar to other languages like Java, C#, and so
    on) invites cross-platform developers to learn JavaScript with ease. Not only
    it improve the languages in syntactical aspects, it also provides new inbuilt
    tools, such as promises, proper tail calls, destructuring, modules, and so on.
    As we have already installed Node version 8, all the ECMAScript 6 features or
    es2017 till date are inclusive. If you are using a Node version less than 4.3.2,
    you will need to install trans-compilation tools like babel.js. We will be learning
    es6 by making a gradual implementation in code and a comparative study as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: es6，或者ECMAScript 2015，是JavaScript语言的更新，适用于所有类型、值、对象文字、属性、函数和程序语法。es6的全新语义（类似于其他语言如Java、C#等）使跨平台开发人员能够轻松学习JavaScript。它不仅改进了语言的语法方面，还提供了新的内置工具，如promises、proper
    tail calls、destructuring、modules等。由于我们已经安装了Node版本8，所有ECMAScript 6功能或es2017直至今都是包括在内的。如果你使用的是低于4.3.2版本的Node，你将需要安装类似babel.js的转译工具。我们将通过逐步在代码中实现和进行比较研究来学习es6。
- en: Syntax basics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法基础
- en: 'The most basic thing you can do in pretty much any programming language is
    declare a variable. Unlike most other languages, JavaScript is a dynamically-typed
    language, which means when you declare a variable, its value can be of any type
    and can change during the course of its lifetime. However, in contrast, a strongly-typed
    language dictates that a variable defined as a `string` type must always be a
    string and must always have a value of a string. The strong typed feature is included
    in es6 which we are going to learn next. For now, to declare a variable in JavaScript,
    simply use the `var` keyword before your variable name:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎任何编程语言中，你可以做的最基本的事情就是声明一个变量。与大多数其他语言不同，JavaScript是一种动态类型的语言，这意味着当你声明一个变量时，它的值可以是任何类型，并且在其生命周期内可以改变。然而，相反，强类型语言规定，定义为`string`类型的变量必须始终是一个字符串，并且必须始终具有字符串的值。强类型特性包含在我们接下来要学习的es6中。目前，在JavaScript中声明一个变量，只需在变量名之前使用`var`关键字：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code snippet shows how we declare variables and define them with
    initial values alongside their declarations. The `+` operator is used for string
    concatenation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了我们如何声明变量并在声明时定义它们的初始值。`+`运算符用于字符串连接。
- en: Also, we use **camel** case for the variable names. It is not mandatory that
    you use camel case for variable naming, but it is more common in object-oriented
    languages to follow camel case as opposed to the underscore-based approach.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用**驼峰**命名法来命名变量。使用驼峰命名法并不是强制性的，但在面向对象的语言中，遵循驼峰命名法比基于下划线的方法更常见。
- en: JavaScript won't complain if you forget to put a semicolon at the end of each
    statement. Instead, it will attempt to put the semicolons for you if there are
    proper statement terminations missing. This can lead to unexpected results. The
    rules of semicolon insertion are explained in this article at [http://bclary.com/2004/11/07/#a-7.9.1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不会因为你忘记在每个语句的末尾加上分号而抱怨。相反，如果缺少适当的语句终止，它会尝试为你添加分号。这可能导致意想不到的结果。关于分号插入的规则在这篇文章中有解释：[http://bclary.com/2004/11/07/#a-7.9.1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)。
- en: 'Since, es6 has introduced two more keywords for variable declarations, namely
    `let` and `const`, has made JavaScript a lot more elegant. First, lets learn `const`
    by considering the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自es6引入了两个更多的变量声明关键字，即`let`和`const`，使JavaScript变得更加优雅。首先，让我们通过以下示例学习`const`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The usage of `const` is same as `var`. Declaring a variable with `const` makes
    itself immutable and it cannot be used for reassigning new content in itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`的用法与`var`相同。用`const`声明变量会使其不可变，并且不能用于重新分配新的内容。'
- en: One more distinction about the `const` keyword that it does not mean something
    is constant but it emphasizes one time assignment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`const`关键字的另一个区别是，它并不意味着某物是常量，而是强调一次赋值。
- en: 'Let''s test it by adding the following line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下行来测试它：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It throws the following error:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它会抛出以下错误：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Well, Why is it needed? The recommended practice for coder is to keep things
    simple which means using a single variable to represent a single value for a time.
    However, we discussed about the dynamicity of the variable earlier which has its
    own advantages, sometimes there is need to represent a data which is immutable
    itself. Like store some credentials of server configuration or the Node packages
    itself. The usage can vary but will be applied with a single rule of one time
    assignment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么需要呢？对于程序员来说，推荐的做法是保持简单，这意味着使用一个变量来表示一个值。然而，我们之前讨论过变量的动态性，它有自己的优点，有时需要表示一个不可变的数据。比如存储一些服务器配置的凭据或Node包本身。用法可能有所不同，但都会遵循一次赋值的单一规则。
- en: To study the `let` keyword, we need to know about the scope of variables first
    which is covered in the following section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习`let`关键字，我们首先需要了解变量的作用域，这在下一节中有所涉及。
- en: Understanding the scope of variables
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变量的作用域
- en: Understanding the scope of variables is very important in JavaScript to gain
    a better hold of the language. Scope may be referred to as a bucket in which your
    variable or your function exists. Unlike Java and other popular languages, JavaScript
    follows function-level scoping as opposed to block-level scoping (which is now
    introduced in es6). So, this means that the variables you define will be limited
    to a scope that is bound to its parent function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中理解变量的作用域非常重要，以更好地掌握这门语言。作用域可以被称为您的变量或函数存在的一个容器。与Java和其他流行的语言不同，JavaScript遵循函数级作用域，而不是块级作用域（这在es6中引入）。这意味着您定义的变量将受限于其父函数绑定的作用域。
- en: 'Consider the following code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you run the preceding code, we can see the scope of the `inner` variable
    is limited to the parent function named `myFunction`. It won't be accessible outside
    it and will provide a `referenceError` notification. Also, the variables available
    in outer scopes are available in function scopes, and you don't need to make any
    extra effort to access them, as you have seen with the variable named `outer`
    in the preceding example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前述代码时，我们可以看到`inner`变量的作用域仅限于名为`myFunction`的父函数。它在外部是不可访问的，并且会提供一个`referenceError`通知。此外，外部作用域中的变量在函数作用域中是可用的，您无需额外的努力来访问它们，就像在前面的示例中看到的名为`outer`的变量一样。
- en: 'An important thing to discuss in this context is the use of the `var` keyword.
    JavaScript won''t complain if you miss `var` while declaring a new variable. But
    things can get really bad if that happens. See the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下需要讨论的一个重要事情是`var`关键字的使用。如果在声明新变量时漏掉了`var`，JavaScript不会抱怨。但如果发生这种情况，情况可能会变得非常糟糕。请看以下例子：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, as the `var` keyword was skipped along with the variable declaration inside
    the inner function, JavaScript considered that this variable should be searched
    in its parent scopes, then attached it to the global scope, and ended up making
    it available everywhere. So, to avoid such issues with the code, it is always
    useful if you pass your code through code quality tools such as JSHint. The preceding
    code structure may have confused you, as it used self-invoked functions just to
    induce scopes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于在内部函数中跳过了`var`关键字和变量声明，JavaScript认为应该在其父作用域中搜索该变量，然后将其附加到全局作用域，并最终使其在任何地方都可用。因此，为了避免代码中出现此类问题，通过JSHint等代码质量工具对代码进行检查总是很有用的。前面的代码结构可能会让你感到困惑，因为它使用了自调用函数来引入作用域。
- en: 'Now with the arrival of es6, you can declare variables with the block scope
    rather than only the function scope. To understand the block level scoping, let''s
    go through the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着es6的到来，您可以在块级作用域中声明变量，而不仅仅是函数作用域。要理解块级作用域，让我们看下面的例子：
- en: '|'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The only difference in preceding snippets is the declaration of variable `i`.
    The `i` variable is not accessible outside the `for` loop block.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码片段的唯一区别是变量`i`的声明。`i`变量在`for`循环块之外是不可访问的。
- en: 'For more details regarding `let` refer the link: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`let`的更多详细信息，请参考链接：[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let)
- en: So that was all about scope of variables. JavaScript supports a number of data
    types. Let's take a look at them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于变量作用域的全部内容。JavaScript支持多种数据类型。让我们来看看它们。
- en: Data types
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: Data types are the base of any language. The data types available in JavaScript
    are
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是任何语言的基础。JavaScript中可用的数据类型有
- en: 'as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如下：
- en: Number
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Object
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: 'Null'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: Undefined
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: Symbol (new in es6)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号（es6中新增）
- en: In our code, every variable we declare will contain values that belong to any
    of the preceding types. Number, String, and Boolean types are quite straightforward
    to understand. These comes under the primitive data types supported by the language.
    Here, one important point is to note that JavaScript has no distinction between
    integers or floating points at its type level.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们声明的每个变量都包含属于前述类型的值。数字、字符串和布尔类型都很容易理解。这些属于语言支持的原始数据类型。在这里，一个重要的要点是要注意，JavaScript在类型级别上没有整数或浮点数之间的区别。
- en: Types such as array, function, regex, and date come under the object data type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数组、函数、正则表达式和日期等类型属于对象数据类型。
- en: They are considered to be composite data types. So the functions that you define
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被认为是复合数据类型。因此，您定义的函数
- en: in your code will also be nothing but objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中也只是对象。
- en: Null and undefined are two special types supported by JavaScript. Null points
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Null和undefined是JavaScript支持的两种特殊类型。Null指向
- en: to a deliberate non-value, whereas undefined points to an uninitialized value.
    So, when you just declare a variable and haven't yet initialized it with a value,
    the variable will be of undefined type. Last but not least, es6 has introduced
    a new primitive data type of symbol. They are used for unique property keys and
    constants representative concepts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 指向故意的非值，而undefined指向未初始化的值。因此，当您只声明变量并尚未使用值对其进行初始化时，变量将是未定义类型。最后但同样重要的是，es6引入了一种新的原始数据类型符号。它们用于唯一的属性键和代表概念的常量。
- en: We are not using them in context of our book, however you can visit the following
    link for more details [http://exploringjs.com/es6/ch_symbols.html](http://exploringjs.com/es6/ch_symbols.html).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在我们的书中使用它们，但是您可以访问以下链接以获取更多详细信息[http://exploringjs.com/es6/ch_symbols.html](http://exploringjs.com/es6/ch_symbols.html)。
- en: So before we understand various ways to define functions, arrays, and objects,
    lets go through operators and flows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们了解定义函数、数组和对象的各种方法之前，让我们先了解运算符和流程。
- en: Operators and flows
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符和流程
- en: JavaScript supports similar control structures to other languages in the C family.
    Conditional statements are written with `if` and `else`, and you can chain together
    the statements using `else-if` ladders.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript支持与C语言系列中的其他语言类似的控制结构。条件语句使用`if`和`else`编写，并且可以使用`else-if`梯级将语句链接在一起。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Control statements can be written using `while`, `do-while`, `for`, and `switch`
    statements. One important thing to consider while writing conditions in JavaScript
    is to understand what equates to `true` and/or `false`. Any value greater or less
    than zero, not null, and not undefined equates to `true`. Strings such as `0`,
    `null`, `undefined`, or `empty` strings equate to `false`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`while`、`do-while`、`for`和`switch`语句编写控制语句。在编写JavaScript条件时，需要考虑的一个重要事项是了解什么等于`true`和/或`false`。大于或小于零的任何值，非null和非undefined都等于`true`。诸如`0`、`null`、`undefined`或`空`字符串的字符串等于`false`。
- en: 'Some sample examples using `while`, `do-while`, `for`, and `switch` statements
    are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`while`、`do-while`、`for`和`switch`语句的一些示例如下：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another important thing will be to understand the basic difference between
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是要理解
- en: the comparisons using `==` and `===`. The `==` comparisons should be used where
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`==`和`===`进行比较。应该在何处使用`==`比较
- en: 'the type of variable is not your concern; and if the data type of the variables
    also should be compared, then you should opt for a `===` comparison symbol as
    given in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的类型不是你关心的问题；如果还应该比较变量的数据类型，那么你应该选择`===`比较符号，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here in the code snippet, the first condition evaluates to true while the second
    doesn't. So while you code, it's always safer to depend on strict (`===`) equality
    checks as a best practice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，第一个条件评估为true，而第二个条件不是。因此，在编写代码时，始终更安全地依赖严格的（`===`）相等检查作为最佳实践。
- en: It's always advised to run your code through code quality tools such as JSHint
    before you approve them for your application. You can automate the code quality
    checks via task runners such as Grunt so that each time we make a change in our
    code, the code quality tool runs and presents if there are any potential issues
    with the code that has been written.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在批准应用程序之前，建议始终通过诸如JSHint之类的代码质量工具运行代码。您可以通过诸如Grunt之类的任务运行器自动运行代码质量检查，以便每次我们更改代码时，代码质量工具都会运行并显示代码编写中是否存在任何潜在问题。
- en: Understanding objects
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象
- en: 'In JavaScript objects, the arrays and even functions we create fall into the
    same data type: `Object`. Declaring an object is a fairly straightforward process:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript对象中，我们创建的数组甚至函数都属于相同的数据类型：`Object`。声明对象是一个非常简单的过程：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You may add properties or attributes to this object, which may belong to any
    type. It means you can add arrays, functions, or even other objects as properties
    of this object. Adding a new property to this object can be done in any of the
    two ways shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向此对象添加任何类型的属性或属性。这意味着您可以将数组、函数甚至其他对象添加为此对象的属性。向此对象添加新属性可以通过以下两种方式之一完成：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s look at an example where we add arrays and functions as properties of
    this object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们将数组和函数添加为此对象的属性：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see in the preceding code that we defined a basic object called `person`
    and assigned it some properties and a function. It's important to note that the
    use of the `this` keyword in the `fullName` function. The `this` keyword refers
    to the object that the function is a part of. So via the `this` keyword, the function
    will be able to access the other properties that are part of the object it belongs
    to.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的代码中看到，我们定义了一个名为`person`的基本对象，并为其分配了一些属性和一个函数。重要的是要注意在`fullName`函数中使用了`this`关键字。`this`关键字指的是函数所属的对象。因此，通过`this`关键字，函数将能够访问其所属对象的其他属性。
- en: 'Apart from the approach of adding properties after the object creation, we
    can also attach the initial object properties as part of its creation, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在对象创建后添加属性的方法之外，我们还可以在创建对象时将初始对象属性附加为其一部分，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we are creating objects without specifying any class
    from which they should be created by using `{}`. So, this results in the creation
    of this new object from the `Object` base class from which other composite types
    such as arrays and functions are extended. So, when you use `{}`, it is equivalent
    to a new `Object()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建对象时没有指定它们应该由哪个类创建，而是使用`{}`。因此，这将导致从`Object`基类创建此新对象，其他复合类型（如数组和函数）都是从该基类扩展的。因此，当您使用`{}`时，它等同于一个新的`Object()`。
- en: 'Here, the objects we create via the use of the object literal `{}` are instances
    of the `Object` class. To define custom classes for our application, we will need
    to use functions and prototypes. Mozilla has a fairly good tutorial on introducing
    this whole point, available at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript).
    The es6 has enhanced the object properties by adding various features as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用对象字面量`{}`创建的对象是`Object`类的实例。要为我们的应用程序定义自定义类，我们需要使用函数和原型。Mozilla在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)上提供了一个相当不错的教程，介绍了整个要点。es6通过添加各种功能增强了对象属性：
- en: 'First and foremost of all is **property shorthand**. Now with es6 we can assign
    property using a variable. Lets understand this using the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最重要的是**属性简写**。现在，使用es6，我们可以使用变量分配属性。让我们使用以下示例来理解这一点：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, the variable value is implicitly assigned to object
    property and there is no need to have a property specified while declaring an
    object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，变量值隐式分配给对象属性，声明对象时无需指定属性。
- en: The next amazing feature is computation of property key in object literals.
    To learn this feature, let's add a property to the preceding object called `book`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个令人惊叹的功能是计算对象字面量中属性键的属性。要了解此功能，让我们向前面的对象添加一个名为`book`的属性。
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The es6 introduces us to one of the most awaited feature called the **template
    literals**. You may have noticed a kind of interpolation operation used in preceding
    snippets with placeholder `${}`. It is nothing but a concatenation of variable
    in string without using any operator, such as `+`. The template literal enhances
    the feature of readability in JavaScript which is quite essential. For more information
    follow the link [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: es6向我们介绍了一个最期待的功能之一，称为**模板文字**。您可能已经注意到在前面的片段中使用了`${}`占位符的一种插值操作。这只是一个字符串中变量的连接，而不使用任何运算符，例如`+`。模板文字增强了JavaScript中的可读性功能，这是非常重要的。有关更多信息，请访问链接[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals)。
- en: 'Once we run the preceding code, we note that es6 enables us to perform any
    computation for property names using a square bracket. Lastly, we can follow an
    elegant feature of the method notation in the `object` property for all functions.
    This can be seen in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，我们注意到es6使我们能够使用方括号计算属性名称的任何计算。最后，我们可以遵循`object`属性中所有函数的方法表示的优雅特性。这可以在以下示例中看到：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Always remember that objects are nothing but an address of a memory location
    and not actual storage. For instance, `firstName: ''Jason''` is stored in memory
    location with address `person.firstName`. Until now, we have learned about a single
    point of storage called as variables, moving further let''s learn multiple point
    of storage.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '始终记住，对象只是内存位置的地址，而不是实际存储。例如，`firstName: ''Jason''`存储在内存位置`person.firstName`的地址中。到目前为止，我们已经了解了称为变量的单个存储点，让我们进一步学习多个存储点。'
- en: Understanding arrays
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数组
- en: 'Arrays work the same way in JavaScript as they do in pretty much any other
    language. They are zero indexed, and you can declare a variable as an empty array
    or a pre-populated array. You can manipulate the items in an array, and arrays
    are not fixed in length:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，数组的工作方式与几乎任何其他语言中的工作方式相同。它们是从零开始索引的，您可以将变量声明为空数组或预填充数组。您可以操作数组中的项目，并且数组的长度不固定：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To be more precise, you can consider arrays as extended child classes of the
    base `Object` class with extra implementations of `Array` functions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，您可以将数组视为基本`Object`类的扩展子类，具有`Array`函数的额外实现。
- en: Understanding functions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数
- en: Functions are first-class citizens in JavaScript. What this means is that a
    `function` by itself is an object, so it can be treated as such and extended with
    properties and additional functions to the base `Object` class. We will see a
    lot of situations where we pass functions as parameters to other functions and
    return functions from other function calls.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是头等公民。这意味着`function`本身是一个对象，因此可以将其视为对象，并将其与基本`Object`类扩展为具有属性和附加函数。我们将看到许多情况下，我们将函数作为参数传递给其他函数，并从其他函数调用中返回函数。
- en: 'Here, we will take a standard function (in this case, `myFunction`). We will
    assign this function a `timesRun` property, just like we do for any other object
    during its execution, and see how to refer to that property later:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将采用标准函数（在本例中为`myFunction`）。我们将为此函数分配一个`timesRun`属性，就像在执行任何其他对象时一样，并查看如何稍后引用该属性：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we have seen in the preceding example, by using the var keyword, we can
    define functions in the same way as variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中所看到的，使用var关键字，我们可以以与变量相同的方式定义函数：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both methods are almost identical in the preceding sample code. The first method
    is the most common way to define a function, and is called the **named function
    approach**. The second method discussed here is the function expression approach,
    where you assign the unnamed function as a reference to a variable and keep it
    unnamed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，两种方法几乎是相同的。第一种方法是定义函数的最常见方式，称为**命名函数方法**。这里讨论的第二种方法是函数表达式方法，其中您将未命名函数分配为变量的引用并保持其未命名。
- en: 'The single most important difference between these two approaches is related
    to a concept called JavaScript **hoisting**. Basically, the difference is that
    when you adopt a function expression strategy, the function will not be available
    in its containing scope till the point, its definition statement gets executed.
    In the named function approach, regardless of the position you define it at, the
    function will be available throughout the containing scope as given in the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法之间最重要的区别与一个叫做JavaScript hoisting的概念有关。基本上，不同之处在于当你采用函数表达式策略时，函数在其定义语句执行之前将不会在其包含的范围内可用。在命名函数方法中，无论你在哪个位置定义它，该函数都将在其包含的范围内可用，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding sample code snippet, `function one` can be invoked from anywhere
    in its parent scope. But `function two` will not be available before the point
    where its expression is evaluated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码片段中，`function one`可以从其父范围的任何地方调用。但是在其表达式被评估之前，`function two`将不可用。
- en: JavaScript hoisting is the process by which the function definitions and variable
    declarations are moved to the top of the containing scope by the JS interpreter
    before the script is executed. So, in the previous case of named functions, the
    definition was moved to the top of the scope. However, for the function expression,
    only the declaration of the variable moved to the top of the scope, setting it
    to undefined till the point in the script where it was actually executed. You
    can read more about the concept of hoisting at [http://code.tutsplus.com/tutorials/JavaScript-hoisting-explained--net-15092](http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript hoisting是指在脚本执行之前，JS解释器将函数定义和变量声明移动到包含范围的顶部的过程。因此，在命名函数的前一个案例中，定义被移动到了范围的顶部。然而，对于函数表达式，只有变量的声明移动到了范围的顶部，将其设置为未定义，直到脚本中实际执行的那一点。你可以在[http://code.tutsplus.com/tutorials/JavaScript-hoisting-explained--net-15092](http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092)上阅读更多关于hoisting的概念。
- en: Anonymous functions and callbacks
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数和回调
- en: Often, you will need to use a temporary function that you don't necessarily
    want to declare ahead of time. In this type of scenario, you can use an anonymous
    function, which is simply a function that is declared at the time you need it.
    This is similar to the function expression context we explored earlier, with a
    simple difference that the function isn't assigned to a variable so it has no
    way of being referenced to later. The most common use of anonymous functions is
    when they are defined as a parameter to another function (most notably when used
    as a *callback*).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要使用一个临时函数，你不一定想提前声明。在这种情况下，你可以使用匿名函数，它只是在需要时声明的函数。这类似于我们之前探讨的函数表达式上下文，唯一的区别是该函数没有分配给一个变量，因此没有办法在以后引用它。匿名函数最常见的用法是当它们被定义为另一个函数的参数时（尤其是当用作*回调*时）。
- en: 'One of the most common places to use an anonymous function (which also acts
    as a callback even if you didn''t realize it) is with `setTimeout` or `setInterval`.
    These are two standard JavaScript functions that will execute code after a specified
    delay (in milliseconds) or repeat the execution of code after a specified delay.
    Here is an example of one of them, `setTimeout`, using an anonymous inline function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名函数（即使你没有意识到它）的最常见的地方之一是与`setTimeout`或`setInterval`一起使用。这两个标准的JavaScript函数将在指定的延迟时间（以毫秒为单位）后执行代码，或者在指定的延迟时间后重复执行代码。以下是其中一个`setTimeout`的示例，使用了内联的匿名函数：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can see that the anonymous function was passed as the first parameter to
    `setTimeout` because `setTimeout` expects a function. You can, if you desire,
    declare the function ahead of time as a variable and pass that to `setTimeout`
    instead of the inline anonymous function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到匿名函数作为第一个参数传递给了`setTimeout`，因为`setTimeout`需要一个函数。如果你愿意，你可以提前声明函数作为变量，并将其传递给`setTimeout`，而不是内联的匿名函数：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The anonymous function just acts as a clean inline disposable function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数只是作为一个干净的内联一次性函数。
- en: Callbacks are important because one of the most powerful (and confusing) features
    of JavaScript is that it's asynchronous. This means that every line executes sequentially,
    but it doesn't wait around for code that might be taking longer than it should
    (even if by design). We have explored this via an example in the first chapter
    while looking into the asynchronous nature of Node.js.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回调很重要，因为JavaScript最强大（也最令人困惑）的特性之一是它是异步的。这意味着每一行都是按顺序执行的，但它不会等待可能需要更长时间的代码（即使是按设计）。我们在第一章中通过一个例子探讨了这一点，当时我们正在研究Node.js的异步特性。
- en: Mozilla has a detailed tutorial on JavaScript concepts, which we advise you
    to go through once you finish this chapter. The tutorial includes highly advanced
    concepts, such as closures, that were not covered in this chapter due to the depth
    of the topic. So refer to this Mozilla Development Network article at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla有一个关于JavaScript概念的详细教程，我们建议你在完成本章后阅读一次。该教程包括高级概念，比如闭包，这些概念由于主题的深度而没有在本章中涵盖。因此，请参考Mozilla开发网络文章[https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript)。
- en: JSON
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: '**JavaScript Object Notation** (**JSON**) is the standard syntax used when
    dealing with data in JavaScript as well as most other languages and web services.
    The basic premise of JSON is that it looks exactly like a standard JavaScript
    object with a few strict exceptions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是处理JavaScript以及大多数其他语言和网络服务中的数据时使用的标准语法。JSON的基本原则是它看起来与标准的JavaScript对象完全相同，只有一些严格的例外：'
- en: JSON is pure text. There are no data types with properties; that is, date values
    are stored as strings and so on
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON是纯文本。没有带属性的数据类型；也就是说，日期值被存储为字符串等等
- en: All names and string values must be in double quotes
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有名称和字符串值必须用双引号括起来
- en: There can be no functions as properties
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性中不能包含函数
- en: 'Let''s take a quick look at a pretty standard JSON object:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下一个标准的JSON对象：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you are at all familiar with XML, JSON is somewhat similar, except it is
    much easier to read and make sense out of. As described best by the ECMA, "*JSON
    is a text format that facilitates structured data interchange between all programming
    languages"*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对XML有所了解，JSON有些类似，只是它更容易阅读和理解。正如ECMA所描述的那样，“*JSON是一种文本格式，可以促进所有编程语言之间的结构化数据交换*”。
- en: The basics of Node.js
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的基础知识
- en: With the basics of JavaScript out of the way, let's focus on some of the basics
    of Node. We will start by understanding the node.js core architecture. The significance
    of different node features lies in its architecture and way it works. Let us study
    it carefully in the following section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解JavaScript的基础知识之后，让我们专注于Node的一些基础知识。我们将从理解node.js核心架构开始。不同的node特性的重要性在于它的架构和工作方式。让我们在下一节仔细研究它。
- en: Node.js architecture
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js架构
- en: The web application normally follows three tier web architecture consisting
    of client, web server, and data source. In our context, we have created a web
    app server using Node.js. As we discussed in [chapter 1](7af048ea-93a4-4290-a37b-c530857e55d9.xhtml),
    *Welcome to JavaScript in The Full Stack*, Node.js follows a single threaded architectural
    model. To reduce the memory leak and understand asynchronousity while writing
    the code, we need to understand how Node.js works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序通常遵循由客户端、Web服务器和数据源组成的三层Web架构。在我们的上下文中，我们使用Node.js创建了一个Web应用服务器。正如我们在[第1章](7af048ea-93a4-4290-a37b-c530857e55d9.xhtml)中讨论的那样，*欢迎来到全栈JavaScript中*，Node.js遵循单线程的架构模型。为了减少内存泄漏并在编写代码时理解异步性，我们需要了解Node.js的工作原理。
- en: 'The following diagram depicts a visual representation of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了代码的可视化表示：
- en: '![](img/adb24843-8871-4455-9c64-88a3da79ef3d.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adb24843-8871-4455-9c64-88a3da79ef3d.jpg)'
- en: Every processing component is sequenced in the following order"
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理组件按以下顺序进行排列：
- en: The client sends a request (consider an HTTP request).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送请求（考虑一个HTTP请求）。
- en: The Chrome's v8 engine is a **just-in-time** (**JIT**) compiler. Once the request
    is received at the server, v8 converts the JavaScript code to the machine code.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Chrome的v8引擎是一个**即时**（**JIT**）编译器。一旦服务器接收到请求，v8将JavaScript代码转换为机器代码。
- en: The C++ APIs within the Node.js core provide a binding for other system-level
    components. Binding is basically a wrapper library so that a code written in one
    language can communicate with a code written in another language. This API is
    responsible for emitting an event.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js核心中的C++ API为其他系统级组件提供了绑定。绑定基本上是一个包装库，使得用一种语言编写的代码可以与用另一种语言编写的代码进行通信。这个API负责发出一个事件。
- en: Once the event is emitted, it is stored in the **event queue**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦事件被触发，它就被存储在**事件队列**中。
- en: The **eventloop** is responsible for fetching the event from the queue and executing
    it in the callstack.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件循环**负责从队列中获取事件并在调用堆栈中执行它。'
- en: If an event requires an asynchronous operation to be done, such as using database
    files, it switches its execution context to another worker thread and gets executed.
    This is done by libuv. The libuv library is responsible for handling the asynchronous
    behavior of an event life cycle in the system. It is written in C. It maintains
    a pool of threads to handle asynchronous requests such as I/O and network-related
    operations.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个事件需要执行异步操作，比如使用数据库文件，它会切换执行上下文到另一个工作线程并执行。这是由libuv完成的。libuv库负责处理系统中事件生命周期的异步行为。它是用C编写的。它维护一个线程池来处理诸如I/O和网络相关操作的异步请求。
- en: Once the asynchronous operation is completed, it returns the callback. The callback
    remains in the event queue until the callstack gets empty.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦异步操作完成，它返回回调。回调保持在事件队列中，直到调用堆栈为空。
- en: Once the callstack is empty, the eventloop pulls the callback from the event
    queue and executes it in the callstack.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦调用堆栈为空，事件循环就会从事件队列中提取回调并在调用堆栈中执行它。
- en: Eventually, the event returns the data to the Node API.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，事件将数据返回给Node API。
- en: In each loop, it performs a single operation. Though the operations are performed
    sequentially, this single-threaded mechanized eventloop is so fast that it provides
    an illusion of concurrency. A single thread can utilize a single core of the system;
    hence, it provides better performance and minimal response time to client.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个循环中，它执行单个操作。虽然操作是顺序执行的，但这个单线程的机械化事件循环非常快，以至于提供了并发的错觉。单个线程可以利用系统的单个核心；因此，它提供了更好的性能和最小的响应时间给客户端。
- en: Event-driven
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动
- en: At its core, one of the most powerful features of Node is that it is event-driven.
    This means that almost all the code you write in Node is going to be written in
    a way that is either responding to an event or is itself firing an event (which
    in turn will fire other code listening for that event).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Node最强大的功能之一是它是事件驱动的。这意味着你在Node中编写的几乎所有代码都是以响应事件的方式编写的，或者是自身触发事件（进而触发其他代码监听该事件）。
- en: 'Let''s take a look at the code that we''ll write in a later chapter that handles
    connecting to a MongoDB server using Mongoose, a popular Node.js MongoDB **Object
    Document Mapper** (**ODM**) module:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们将在后面的章节中编写的处理使用Mongoose连接到MongoDB服务器的代码，Mongoose是一个流行的Node.js MongoDB
    **对象文档映射**（**ODM**）模块：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we tell our `mongoose` object to connect to the server provided as a
    string parameter to the function. Connecting will take an undetermined amount
    of time though, and we have no way of knowing how long. So, what we do is bind
    a listener to the `open` event on the `mongoose.connection` object. With the use
    of the on keyword, we are indicating that when the `mongoose.connection` object
    triggers an `open` event, it executes the anonymous function that was passed in
    as the parameter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉我们的 `mongoose` 对象连接到作为参数传递给函数的服务器。连接可能需要一段时间，但我们无法知道需要多长时间。因此，我们绑定了一个监听器到
    `mongoose.connection` 对象的 `open` 事件上。通过使用 on 关键字，我们指示当 `mongoose.connection` 对象触发
    `open` 事件时，执行作为参数传递的匿名函数。
- en: Asynchronous execution
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步执行
- en: Earlier, we reviewed the idea of asynchronous JavaScript code in the browser
    using `setTimeout;` the principles apply more strongly in the world of Node. As
    you may be making a number of network-dependent connections to different REST
    API services, database servers, and anything else, it is important that your code
    can be executed smoothly and has proper callback usage in place whenever each
    service responds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们在浏览器中使用 `setTimeout` 来回顾异步 JavaScript 代码的概念；这些原则在 Node 的世界中更为强大。由于您可能会对不同的
    REST API 服务、数据库服务器和其他任何内容进行许多网络相关的连接，因此很重要的是，您的代码可以平稳执行，并且在每个服务响应时都有适当的回调使用。
- en: The module system
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块系统
- en: 'In an effort to make the code as modular and reusable as possible, Node uses
    a module system that allows you to better organize your code. The basic premise
    is that you write a code fulfilling a single concern, and export this code using
    `module.exports` (or simply `exports`) as a module that serves that single purpose.
    Whenever you need to use that code elsewhere in your code base, you will require
    that module:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码尽可能模块化和可重用，Node 使用了一个模块系统，允许您更好地组织代码。基本前提是，您编写一个满足单一关注点的代码，并使用 `module.exports`（或简单地
    `exports`）将此代码导出为服务于该单一目的的模块。每当您需要在代码库的其他地方使用该代码时，您将需要该模块：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using this system, it is simple to reuse the functionality in a module (in this
    case, the `dowork` module) in a number of other files. Furthermore, the individual
    files of a module act as a private namespace, which means every file defines a
    module and is executed separately. Any variables declared and used within the
    module file are private to that module and not exposed to any code that uses the
    module via `require()`. The developer has control over which part of module will
    be exported or not. Such implementation of modules is called as the **commonJs**
    modules pattern.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个系统，可以简单地在许多其他文件中重用模块（在本例中是 `dowork` 模块）中的功能。此外，模块的各个文件充当私有命名空间，这意味着每个文件定义一个模块并且被单独执行。在模块文件中声明和使用的任何变量都是私有的，不会暴露给通过
    `require()` 使用模块的任何代码。开发人员可以控制模块的哪一部分将被导出。这种模块的实现被称为**commonJs**模块模式。
- en: Before we conclude module system in Node.js, we need to learn about the `require`
    keyword. The `require` keyword accepts an address of a file as string and provides
    it to JavaScript engine to compile it into a method `Module._load`. The `Module._load`
    method is executed for first time, it actually loads from the exported file and
    further it is cached. Caching is done so as to reduce the number of file reads
    and can speed up your application significantly. In addition, when a module is
    loaded next time, it provides an instance of that loaded module from cache. This
    allows sharing of modules across the project with the state of singleton. At the
    end, the `Module._load` method returns the `module.exports` property of the addressed
    file on their respective execution.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结 Node.js 中的模块系统之前，我们需要了解 `require` 关键字。`require` 关键字接受文件地址作为字符串，并将其提供给
    JavaScript 引擎编译为 `Module._load` 方法。`Module._load` 方法首次执行时，实际上是从导出的文件中加载，并且进一步进行缓存。缓存是为了减少文件读取次数，可以显著加快应用程序的速度。此外，当下次加载模块时，它会从缓存中提供已加载模块的实例。这允许在项目中共享模块，并保持单例状态。最后，`Module._load`
    方法返回所述文件的 `module.exports` 属性在其各自的执行中。
- en: The module system extends infinitely as well. Within your modules, you can require
    other modules and so on and so forth. Make sure while importing it, do not cause
    so called a **cyclic** dependency.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统也可以无限扩展。在您的模块中，您可以要求其他模块，依此类推。在导入时要确保不会导致所谓的**循环**依赖。
- en: 'Cyclic or circular dependency is a situation when a module requires itself
    directly or indirectly. We can learn about this more from the discussion in the
    following link :'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖是指模块直接或间接地要求自身的情况。我们可以从以下链接的讨论中了解更多：
- en: '[https://stackoverflow.com/questions/10869276/how-to-deal-with-cyclic-dependencies-in-node-js](https://stackoverflow.com/questions/10869276/how-to-deal-with-cyclic-dependencies-in-node-js).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://stackoverflow.com/questions/10869276/how-to-deal-with-cyclic-dependencies-in-node-js](https://stackoverflow.com/questions/10869276/how-to-deal-with-cyclic-dependencies-in-node-js)。'
- en: The Node.js core
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 核心
- en: 'The Node.js core literally has hundreds of modules available for you to use
    while writing your applications. These modules are already compiled into binary
    and are defined within Node.js source code. These include the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 核心实际上有数百个模块可供您在编写应用程序时使用。这些模块已经编译成二进制，并在 Node.js 源代码中定义。其中包括以下内容：
- en: Events
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Filesystems
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统
- en: 'Just like other languages, the Node.js core also provides an ability to interact
    with filesystem using the `fs` module. This module is equipped with different
    methods for performing different operations on file synchronously as well as asynchronously.
    Refer [chapter 1](7af048ea-93a4-4290-a37b-c530857e55d9.xhtml). *Welcome to JavaScript
    in The Full Stack* to learn more about the difference of sync and async. The synchronous
    methods of `fs` are suffixed by the keyword Sync for instance `readFileSync`.
    For all reviewing the module in depth refer the following link : [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言一样，Node.js核心还提供了使用`fs`模块与文件系统交互的能力。该模块配备了不同的方法，用于同步和异步地执行文件的不同操作。参考[第1章](7af048ea-93a4-4290-a37b-c530857e55d9.xhtml)。*欢迎来到全栈JavaScript*，了解更多关于同步和异步的区别。`fs`的同步方法以关键字Sync结尾，例如`readFileSync`。要深入了解模块，请参考以下链接：[https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)。
- en: HTTP
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: An HTTP module is one of the most important module in Node.js core. HTTP module
    provides functionality to implement an HTTP client as well as server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP模块是Node.js核心中最重要的模块之一。HTTP模块提供了实现HTTP客户端和服务器的功能。
- en: 'Following is the minimum code required to create a basic server and a client:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建基本服务器和客户端所需的最小代码：
- en: '| **HTTP Server** | **HTTP Client** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP服务器** | **HTTP客户端** |'
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Considering the preceding code, once the module is required, we use an instance
    of the HTTP Object to either create a server or to request a server on the other
    side. The `createServer` method requires a callback as a parameter. This `callback`
    is called whenever the server is hit by an HTTP request. Further, it also provides
    a response object as a parameter to handle the response back accordingly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面的代码，一旦模块被引入，我们就可以使用HTTP对象的实例来创建服务器或请求另一端的服务器。`createServer`方法需要一个回调作为参数。每当服务器受到HTTP请求时，都会调用这个`callback`。此外，它还提供一个响应对象作为参数，以便相应地处理返回的响应。
- en: Net
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Net
- en: 'The preceding HTTP module is wired using the net module. According to documentation
    of the node.js api, the net module provides an asynchronous network API for creating
    stream-based TCP or IPC servers. This is one of the compiled binary library of
    core Node, which interacts with the internal C library called libuv. The libuv
    library is responsible for handling asynchronous request such as I/O and network-related
    operations. The best documentation to refer is Node''s own documentation: [https://nodejs.org/api/net.html](https://nodejs.org/api/fs.html).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的HTTP模块是使用net模块连接的。根据node.js api的文档，net模块提供了用于创建基于流的TCP或IPC服务器的异步网络API。这是Node的核心编译二进制库之一，它与内部C库libuv交互。libuv库负责处理异步请求，如I/O和网络相关操作。最好的参考文档是Node自己的文档：[https://nodejs.org/api/net.html](https://nodejs.org/api/fs.html)。
- en: Streams
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流
- en: 'The stream is one of the most significant module among the core modules. To
    define the stream in simple words, it is the flow of data received as small data
    chunks from a particular source. At the receiver''s end, it might neither have
    all the stream data nor it will have to fit it memory all at once. This allows
    us to handle a large amount of data with limited resources. We can visualize the
    stream by an analogy given by Dominic Denicola. According to him:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 流是核心模块中最重要的模块之一。简单来说，流是从特定来源接收的数据流的小数据块。在接收端，它可能既没有所有的流数据，也不必一次性将其全部放入内存。这使我们能够使用有限的资源处理大量数据。我们可以通过Dominic
    Denicola提供的类比来形象地描述流。根据他的说法：
- en: '"Streams are to asynchronous iterables as arrays are t synchronous iterables".'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '"流是异步可迭代对象，就像数组是同步可迭代对象一样"。'
- en: Consider if we need to read a large file of data in the environment where multiple
    read/write operations takes place. In such cases, streams provides a powerful
    abstraction to handle the low-level I/O system calls while still providing performance
    benefits.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们需要在进行多次读写操作的环境中读取大文件数据。在这种情况下，流提供了一个强大的抽象来处理低级I/O系统调用，同时提供性能优势。
- en: The internal stream module should not be used directly so as to avoid the behavioral
    changes between Node versions. However, we can use the wrapper modules like readable-streams
    on the npm.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 内部流模块不应直接使用，以避免在Node版本之间发生行为变化。但是，我们可以在npm上使用可读流等包装模块。
- en: 'Although, streams are not extensively used in context of our book, it is one
    of the backbone feature of Node.js core used by its internal modules itself and
    has always been a big part of Node.js ecosystem. To learn more about streams follow
    the link: [https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/](https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们的书的上下文中并未广泛使用流，但它是Node.js核心的一个支柱特性，被其内部模块使用，并一直是Node.js生态系统的重要组成部分。要了解更多关于流的信息，请访问以下链接：[https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/](https://community.risingstack.com/the-definitive-guide-to-object-streams-in-node-js/)。
- en: 'Definitely make sure to check out the online docs on Node at: [http://nodejs.org/api](http://nodejs.org/api),
    to see the full list of modules available in Node''s core and see plenty of sample
    code and explanations.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看Node的在线文档：[http://nodejs.org/api](http://nodejs.org/api)，以查看Node核心中可用模块的完整列表，并查看大量示例代码和解释。
- en: Installing modules using npm
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用npm安装模块
- en: The module system in Node is very powerful that consuming a third-party module
    written by other developers is a piece of cake. Node includes its own package
    manager called **npm**, which is a registry that currently contains over 475,000
    modules written in Node. These modules are completely open source and available
    to you via a few short commands. In addition, you can release your own personal
    modules via npm and allow anyone in the world to use your feature!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Node中的模块系统非常强大，使用其他开发者编写的第三方模块非常简单。Node包含了自己的包管理器**npm**，它是一个注册表，目前包含了超过475,000个用Node编写的模块。这些模块完全开源，并且可以通过几个简短的命令让你使用。此外，你也可以通过npm发布你自己的个人模块，并允许世界上的任何人使用你的功能！
- en: 'Let''s say you want to include a popular web framework, `express`, in your
    project (the one we will be using later in this book). There are two simple steps
    required to download a module and use it in your code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在你的项目中（我们在本书后面会使用的）包含一个流行的web框架`express`。下载一个模块并在你的代码中使用它只需要两个简单的步骤：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And that's it! Literally, it's that simple! From the command line of the folder
    where your project is located, simply execute `npm install package-name`, and
    the package will be downloaded from npm and stored in a folder called `node_modules`
    within your project. If you browse through the `node_modules` folder, you will
    find a folder for the package you installed, and within that folder, you will
    find the raw source code for the package itself. Once the package is downloaded,
    it's as simple as using `require()` within your code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！真的，就是这么简单！从你的项目所在的文件夹的命令行中，只需要执行`npm install package-name`，这个包就会从npm下载并存储在你的项目中的一个叫做`node_modules`的文件夹中。如果你浏览`node_modules`文件夹，你会发现一个你安装的包的文件夹，在这个文件夹中，你会找到这个包本身的原始源代码。一旦这个包被下载，使用`require()`在你的代码中就会变得非常简单。
- en: There may be times when you want to install a Node package globally, for example,
    when using a popular command-line build tool called Grunt.js. To install an npm
    package globally, simply include the `-g` or `--global` flag, and the module will
    be installed as a global executable instead. When installing npm packages globally,
    the source files for the package are not stored within the `node_modules` folder
    of a specific project, but instead within a `node_modules` folder in a system
    directory of your machine.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想要全局安装一个Node包，比如说，当你使用一个叫做Grunt.js的流行命令行构建工具的时候。要全局安装一个npm包，只需要包含`-g`或者`--global`标志，这个模块就会被安装为一个全局可执行文件。当全局安装npm包时，这个包的源文件并不会存储在特定项目的`node_modules`文件夹中，而是存储在你机器的系统目录下的`node_modules`文件夹中。
- en: A really powerful feature of npm is that it allows a quick, easy, and consistent
    way for other developers to boot up your code in their local environment. Node
    projects, typically, include a special file called `package.json` that contains
    information about the project as well as a list of all npm packages that the project
    depends on. A developer with a copy of your local code can simply execute `npm
    install` to have every dependency downloaded and installed locally using this
    file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: npm的一个非常强大的特性是它允许其他开发者快速、简单、一致地在他们的本地环境中启动你的代码。Node项目通常包括一个特殊的文件叫做`package.json`，其中包含了关于项目的信息以及项目依赖的所有npm包的列表。拥有你本地代码副本的开发者只需要执行`npm
    install`就可以通过这个文件下载并在本地安装每个依赖。
- en: 'The npm install flag `--save` or `--save-dev` is required if you want the dependency
    that you are installing to be saved to the `package.json` file. If you are starting
    a new project and don''t want to create a `package.json` file by hand, you can
    simply execute `npm init` and answer a few quick questions to get a default `package.json`
    file quickly set up. You can leave every question blank during `init` and accept
    the default values if you want:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要安装的依赖被保存到`package.json`文件中，`npm install`标志`--save`或者`--save-dev`是必需的。如果你正在开始一个新项目，不想手动创建一个`package.json`文件，你可以简单地执行`npm
    init`并回答几个快速的问题来快速设置一个默认的`package.json`文件。在`init`期间，如果你想的话可以留空每个问题并接受默认值：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `dependencies` and `devDependencies` sections have `express` and `grunt`
    listed. The difference between these two sections is that the `dependencies` section
    is absolutely critical for the app to function properly and the `devDependencies`
    section has only packages that need to be installed for a developer to use during
    the development of the project (such as Grunt for various build steps, testing
    frameworks, and so on). If you are confused about the use of the `^` symbol in
    the package versions, it's used to update the dependency to the most recent minor
    version or patch version (the second or third number). `^1.2.3` will match any
    1.x.x release including 1.3.0, but will hold off on 2.0.0\. So, in our case `^3.5.1`
    of Express.js will look for the most recent minor version of express.js but will
    not take 4.0.0, as it's a major version.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`和`devDependencies`部分列出了`express`和`grunt`。这两个部分的区别在于，`dependencies`部分对于应用程序的正常运行是绝对关键的，而`devDependencies`部分只包含了在项目开发过程中需要安装的包（比如Grunt用于各种构建步骤、测试框架等）。如果你对包版本中的`^`符号的使用感到困惑，它用于更新依赖到最新的次要版本或者补丁版本（第二个或第三个数字）。`^1.2.3`将匹配任何1.x.x版本，包括1.3.0，但不会包括2.0.0。所以，在我们的例子中，`^3.5.1`的Express.js将寻找最新的express.js的次要版本，但不会接受4.0.0，因为这是一个主要版本。'
- en: The basics of MongoDB
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB的基础知识
- en: Since MongoDB is largely powered by JavaScript, the Mongo shell acts as a JavaScript
    environment. In addition to being able to execute regular Mongo queries, you can
    also execute standard JavaScript statements. Most of the items mentioned earlier
    in the JavaScript primer apply directly to the Mongo shell as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MongoDB主要由JavaScript驱动，Mongo shell充当了一个JavaScript环境。除了能够执行常规的Mongo查询之外，你还可以执行标准的JavaScript语句。在JavaScript入门中提到的大部分内容同样适用于Mongo
    shell。
- en: In this section, we will primarily focus on the various ways to perform standard
    CRUD operations via the Mongo shell.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将主要关注通过Mongo shell执行标准CRUD操作的各种方法。
- en: The Mongo shell
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongo shell
- en: 'To access the Mongo shell, simply execute `mongo` from any terminal. The Mongo
    shell requires the `mongod` server to be currently running and available on the
    machine, as the first thing it does is connect to the server. Use the following
    command to access the Mongo shell:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问Mongo shell，只需从任何终端执行`mongo`。Mongo shell需要`mongod`服务器当前正在运行并且可用于机器，因为它的第一件事就是连接到服务器。使用以下命令访问Mongo
    shell：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By default, when you first launch Mongo, you are connected to the local server
    and set to use the `test` database. To display a list of all databases on the
    server, use the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当您首次启动Mongo时，您会连接到本地服务器，并设置为使用`test`数据库。要显示服务器上所有数据库的列表，请使用以下命令：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To switch databases to any of those listed in the output of `show dbs`, use
    the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到`show dbs`输出中列出的任何数据库，请使用以下命令：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: An interesting thing to note is that if you use `use` on a database that doesn't
    exist,
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果您在一个不存在的数据库上使用`use`，
- en: 'one will be created automatically. If you are using an existing database and
    want to view a list of collections in the database, execute the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将自动创建一个。如果您正在使用现有数据库，并且想要查看数据库中的集合列表，请执行以下命令：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case of my `chapter3` database, I had no existing collections since
    it was automatically generated as a new database for me. Collections in MongoDB
    are similar to the tables in a relational database.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我`chapter3`数据库的情况下，由于它是自动生成的新数据库，我没有现有的集合。MongoDB中的集合类似于关系数据库中的表。
- en: Inserting data
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入数据
- en: 'Since we are working with the `chapter3` database, which is a brand new database,
    there are currently no collections in it. You can use any collection (table) you
    want by simply referring to a new collection name with the `db` object:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用`chapter3`数据库，这是一个全新的数据库，目前里面没有集合。您可以通过简单地引用一个新的集合名称和`db`对象来使用任何集合（表）：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Performing a `find` operation on an empty collection simply returns nothing.
    Let''s insert some data so we can experiment with some queries:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在空集合上执行`find`操作只会返回空。让我们插入一些数据，这样我们就可以尝试一些查询：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After we perform a simple insertion (basically of a JavaScript JSON object),
    we will perform another `find` operation on the collection and get our new record
    returned, this time with an additional `_id` field added. The `_id` field is Mongo's
    method for tracking a unique identifier for every document (record). We also chained
    the `pretty()` function to the end of the `find()`, which outputs the results
    a little more nicely.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行简单的插入（基本上是一个JavaScript JSON对象）之后，我们将在集合上执行另一个`find`操作，并且返回我们的新记录，这次还添加了一个额外的`_id`字段。`_id`字段是Mongo用来跟踪每个文档（记录）的唯一标识符的方法。我们还在`find()`的末尾链接了`pretty()`函数，这样可以更好地输出结果。
- en: Go ahead and insert a few more records, so you have some data to play with for
    the next section when we go over querying.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 继续插入一些记录，这样您就有一些数据可以在下一节进行查询时使用。
- en: Querying
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询
- en: 'Querying and searching for documents in a MongoDB collection is pretty straightforward.
    Using the `find()` function by itself with no parameters will return every document
    in the collection. To narrow down the search results, you can provide a `JSON`
    object as the first parameter with as much or as little specific information to
    match against as you wish, as shown in the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB集合中查询和搜索文档非常简单。仅使用没有参数的`find()`函数将返回集合中的每个文档。为了缩小搜索结果，您可以提供一个`JSON`对象作为第一个参数，其中包含尽可能多或尽可能少的特定信息以匹配，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can include additional parameters to make the search more precise:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以包含额外的参数来使搜索更精确：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With each result set, every field is included. If you want to only return a
    specific set of fields with the result, you can include `map` as the second parameter
    to `find()`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个结果集，每个字段都包含在内。如果您只想返回特定的一组字段，您可以将`map`作为`find()`的第二个参数包括：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `_id` field will always be included by default, unless you specifically
    state that you don't want it included.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`_id`字段将始终默认包含，除非您明确声明不想包含它。'
- en: 'Additionally, you can use query operators to search for things that are within
    ranges. These include greater than (or equal to) and less than (or equal to).
    If you want to perform a search against a collection of homework, and you want
    to find every document with a score within the B range (80-89), you can execute
    the following search:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用查询运算符来搜索范围内的内容。这些包括大于（或等于）和小于（或等于）。如果您想对作业集合执行搜索，并且想要找到每个分数在B范围内（80-89）的文档，您可以执行以下搜索：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, you can use `regex` while performing a search to return multiple matching
    documents:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以在执行搜索时使用`regex`来返回多个匹配的文档：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding query will return every document that contains the word `Krol`.
    You can get as advanced as you want with `regex` statements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询将返回包含单词`Krol`的每个文档。您可以使用`regex`语句进行高级查询。
- en: If you know that you are going to be returning multiple documents on a query
    and only want the first result, use `findOne()` in place of a regular `find()`
    operation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道您将在查询中返回多个文档，并且只想要第一个结果，请使用`findOne()`代替常规的`find()`操作。
- en: Updating data
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新数据
- en: 'To update a record, use the `update()` function, but include a find query as
    the first parameter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新记录，请使用`update()`函数，但将查找查询作为第一个参数包括：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There''s a bit of a catch here. If you perform a new `find({ name: ''Jason
    Krol'' })` operation, something strange happens. No data is returned. What happened?
    Well, the second parameter in the `update()` function is actually the new version
    of the complete document. Since, you only wanted to update the `website` field,
    what actually happened was that the document that was found was replaced with
    the new version that consists of only the `website` field. To reiterate, the reason
    this happens at all is because with NoSQL such as MongoDB, the document does not
    have a set number of fields (as a relational database does). To fix this problem,
    you should use the `$set` operator instead:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有一个小问题。如果你执行一个新的`find({ name: ''Jason Krol'' })`操作，会发生一些奇怪的事情。没有返回数据。发生了什么？好吧，`update()`函数的第二个参数实际上是完整文档的新版本。因此，你只想要更新`website`字段，实际发生的是找到的文档被新版本替换，新版本只包含`website`字段。重申一下，之所以会发生这种情况，是因为在NoSQL（如MongoDB）中，文档没有固定数量的字段（如关系数据库）。要解决这个问题，你应该使用`$set`运算符。'
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There may be a time when you want to update a document, but the document itself
    may or may not exist. What happens when the document does not exist, and you''d
    like a new one to be created instantly based on the updated values you provide?
    Well, there''s a handy function just for that. Pass `{upsert: true}` as the third
    parameter to the `update()` function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '也许有一天你想要更新一个文档，但文档本身可能存在，也可能不存在。当文档不存在时，如果你想根据提供的更新值立即创建一个新文档，会发生什么？好吧，有一个很方便的函数专门用于这个目的。将`{upsert:
    true}`作为`update()`函数的第三个参数传递：'
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If we have a document with a `name` field that matches `Joe Smith`, the `website`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个`name`字段匹配`Joe Smith`的文档，`website`
- en: field will be updated (and the `name` field preserved). However, if we do not
    have
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 字段将被更新（并且`name`字段将被保留）。但是，如果我们没有
- en: a matching document, a new one will be created automatically.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的文档，将自动创建一个新文档。
- en: Deleting data
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'Deleting documents works almost exactly like `find()`, except instead of finding
    and returning results, it deletes those documents that match the search criteria:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文档的工作方式几乎与`find()`完全相同，只是不是查找和返回结果，而是删除与搜索条件匹配的文档：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you want the nuclear option, you can use the `drop()` function, which will
    remove every document in a collection:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要核心选项，你可以使用`drop()`函数，它将删除集合中的每个文档：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Additional resources
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外资源
- en: 'For additional learning with JavaScript, I suggest you check out some of the
    following resources:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript的进一步学习，我建议你查看以下一些资源：
- en: Mozilla Developer Network at [https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla开发者网络位于[https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
- en: '*Secrets of the JavaScript Ninja*, *John Resig*, *Bear Bibeault*, *Manning*'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Secrets of the JavaScript Ninja*，*John Resig*，*Bear Bibeault*，*Manning*'
- en: '*Learning JavaScript Design Patterns*, *Addy Osmani*, *O''Reilly*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Learning JavaScript Design Patterns*，*Addy Osmani*，*O''Reilly*'
- en: '*JavaScript: The Good Parts*, *Douglas Crockford*, *O''Reilly*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript: The Good Parts*，*Douglas Crockford*，*O''Reilly*'
- en: The Node API online documentation is going to be your best bet for fully understanding
    everything that's available within the Node core set of modules. The Node API
    docs can be found at [http://nodejs.org/api](http://nodejs.org/api).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Node API在线文档将是你全面了解Node核心模块中所有可用内容的最佳选择。Node API文档可以在[http://nodejs.org/api](http://nodejs.org/api)找到。
- en: Additionally, there is a great website that teaches Node using actual programming
    problems that you must solve. The emphasis with these exercises is to understand
    the nuts and bolts of how Node works and get down into the fundamentals of working
    with streams, asynchronous I/O, promises, and more. Node school can be found at
    [http://nodeschool.io](http://nodeschool.io).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有一个很棒的网站，教你使用实际的编程问题来学习Node。这些练习的重点是理解Node的工作原理，并深入了解流、异步I/O、promises等基本知识。Node
    school可以在[http://nodeschool.io](http://nodeschool.io)找到。
- en: Finally, the creators of MongoDB offer an amazing 7-8 week online training and
    certification program completely free of charge, where you will learn everything
    you need to be a true MongoDB master. This can be found at MongoDB University
    at [https://university.mongodb.com](https://university.mongodb.com).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，MongoDB的创建者提供了一个令人惊叹的7-8周在线培训和认证计划，完全免费，你将学到成为真正的MongoDB大师所需的一切。这可以在MongoDB大学的[https://university.mongodb.com](https://university.mongodb.com)找到。
- en: Now it's time to dive in and start writing some real code!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入进入并开始编写一些真正的代码了！
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you took a crash course on the basics of JavaScript, Node.js,
    and MongoDB. In addition, you learned about Node's package manager, npm. For further
    learning, additional resources were provided for JavaScript, Node.js, and MongoDB.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你快速学习了JavaScript、Node.js和MongoDB的基础知识。此外，你还了解了Node的包管理器npm。为了进一步学习，提供了JavaScript、Node.js和MongoDB的额外资源。
- en: In the next chapter, you will write your first Node web server using Express.js
    and get started with creating a complete web application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将使用Express.js编写你的第一个Node web服务器，并开始创建一个完整的Web应用程序。
