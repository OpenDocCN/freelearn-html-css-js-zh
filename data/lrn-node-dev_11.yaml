- en: Testing the Node Applications – Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Node应用程序-第2部分
- en: In this chapter, we'll continue our journey of testing the Node applications.
    In the previous chapter, we looked at the basic testing framework and worked on
    synchronous as well as asynchronous Node application. In this chapter we'll move
    on to testing the Express applications, then we'll look into a method to organize
    our test better in the result output, and last but not least we'll get into some
    advanced methods of testing Node application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续测试Node应用程序的旅程。在上一章中，我们看了基本的测试框架，并且处理了同步和异步的Node应用程序。在本章中，我们将继续测试Express应用程序，然后我们将研究一种方法来更好地组织我们的测试结果输出，最后但并非最不重要的是，我们将进入一些高级的测试Node应用程序的方法。
- en: 'Specifically, we''ll look into the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将研究以下主题：
- en: Setting up testing for Express app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Express应用程序设置测试
- en: Testing Express application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Express应用程序
- en: Organizing test with `describe()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`describe()`组织测试
- en: Test spies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试间谍
- en: Testing the Express application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Express应用程序
- en: In this section, we'll be setting up an Express app and then, we'll look at
    how we can test it to verify that the data that comes back from our routes is
    what the user should be getting. Now before we do any of that, we will need to
    create an Express server and that's the goal of this section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将设置一个Express应用程序，然后，我们将看看如何测试它，以验证从我们的路由返回的数据是否是用户应该得到的。现在，在我们做任何事情之前，我们需要创建一个Express服务器，这就是本节的目标。
- en: Setting up testing for the Express app
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Express应用程序设置测试
- en: 'We''ll start with installing Express. We''ll use `npm i`, which is short for
    install, to install Express. Remember, you could always replace install with `i`.
    We''ll grab the most recent version, `@4.16.2`. Now, we''ll be using the `save`
    flag as opposed to the save `dev` flag that we''ve used for testing in the previous
    chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从安装Express开始。我们将使用`npm i`，这是安装的缩写，来安装Express。记住，你总是可以用`i`替换`install`。我们将获取最新版本`@4.16.2`。现在，我们将使用`save`标志，而不是我们在上一章中用于测试的`save
    dev`标志：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command is going to install Express as a regular dependency, which is
    exactly what we want:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将安装Express作为常规依赖项，这正是我们想要的：
- en: '![](img/b264ed25-457b-42ed-aa81-95a9d3b293c5.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b264ed25-457b-42ed-aa81-95a9d3b293c5.png)'
- en: We need Express when we deploy to production, whether it's Heroku or some other
    service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在部署到生产环境时需要Express，无论是Heroku还是其他一些服务。
- en: 'Back inside the app, if we open up `package.json`, we can see we have dependencies
    which we''ve seen before, and `devDependencies` which is new to us:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到应用程序内部，如果我们打开`package.json`，我们可以看到我们之前见过的依赖项，以及对我们来说是新的`devDependencies`：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is how we can break up the different dependencies. From here, we'll make
    a `server` folder inside the root of the project where we can store the server
    example as well as the test file. We'll make a directory called `server`. Then
    inside `server`, we'll make a file called `server.js`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何分解不同的依赖关系。从这里开始，我们将在项目的根目录下创建一个`server`文件夹，我们可以在其中存储服务器示例以及测试文件。我们将创建一个名为`server`的目录。然后在`server`内，我们将创建一个名为`server.js`的文件。
- en: 'The `server.js` file will contain the actual code that starts up our server.
    We''ll define our routes, we''ll listen to a port, all that stuff is going to
    happen in here. This is what we had before for the previous server chapter. In
    `server.js`, we''ll add `const express`, and this will get equal to the `require
    (''express'')` return result:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.js`文件将包含启动服务器的实际代码。我们将定义我们的路由，我们将监听一个端口，所有这些都将在这里发生。这就是我们在以前的服务器章节中所做的。在`server.js`中，我们将添加`const
    express`，并将其等于`require(''express'')`的返回结果：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next up, we can make our application by creating a variable called `app` and
    setting it equal to a call to `express`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过创建一个名为`app`的变量并将其设置为对`express`的调用来制作我们的应用程序：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we can start configuring our routes. Let''s set up just one for this section,
    `app.get`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以开始配置我们的路由。让我们为本节设置一个`app.get`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will set up an HTTP GET handler. The URL will be just `/` (forward slash),
    the root of the website. And when someone requests that, for the moment we''ll
    specify a really simple string as the return result. We get the request and the
    response object like we do for all of our `express` routes. Yo respond, we''ll
    call `res.send`, sending back the string `Hello World!`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个HTTP GET处理程序。URL将仅为`/`（正斜杠），即网站的根目录。当有人请求时，我们暂时将指定一个非常简单的字符串作为返回结果。我们像对所有的`express`路由一样获得请求和响应对象。要响应，我们将调用`res.send`，发送字符串`Hello
    World!`作为返回结果：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last step in the process will be to listen on a port using `app.listen`.
    We''ll bind to port `3000` by passing it in as the first and only argument:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的最后一步将是使用`app.listen`监听一个端口。我们将通过将其作为第一个且唯一的参数传递来绑定到端口`3000`：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this in place, we are now done. We have a basic Express server. Before
    we move on to explore how to test these routes, let''s start it up. We''ll do
    that by using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在完成了。我们有了一个基本的Express服务器。在我们继续探索如何测试这些路由之前，让我们启动它。我们将使用以下命令来做到这一点：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we run this, we don't get any logs because we haven't added a callback
    function for when the server starts, but it should indeed be up.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们不会得到任何日志，因为我们还没有为服务器启动添加回调函数，但它确实已经启动了。
- en: 'If we go over to Chrome and visit `localhost:3000`, we get Hello world! printing
    to the screen:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到Chrome并访问`localhost:3000`，我们会看到Hello world!打印到屏幕上：
- en: '![](img/238604f2-8f63-4c3b-b7a1-21f278d8c9c6.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/238604f2-8f63-4c3b-b7a1-21f278d8c9c6.png)'
- en: Now, we are ready to move on to start testing our Express application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好开始测试我们的Express应用程序了。
- en: Testing the Express app using SuperTest
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SuperTest测试Express应用程序
- en: Now, we'll learn an easy, no-nonsense way to test our Express applications.
    That means we can verify that when we make an HTTP GET request to the `/` URL,
    we get the `Hello world!` response back.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习一种简单而直接的方法来测试我们的Express应用程序。这意味着我们可以验证当我们向`/`URL发出HTTP GET请求时，我们会得到`Hello
    world!`的响应。
- en: Now traditionally, testing HTTP apps has been one of the more difficult things
    to test. We would have to fire up a server, like we did in the previous section.
    Then we would need some code to actually make the request to the appropriate URL.
    And then we have to dig through the response, getting what we want, and making
    assertions about it, whether it's headers, the status code, the body, or anything
    else. It is a real burden. That is not the goal for this section. Our goal here
    is to make testing easy and approachable, so we'll use a library called SuperTest
    to test our Express applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，测试HTTP应用程序一直是最难测试的事情之一。我们需要启动一个服务器，就像我们在上一节中所做的那样。然后我们需要一些代码来实际向适当的URL发出请求。然后我们必须浏览响应，获取我们想要的内容，并对其进行断言，无论是头部、状态码、正文还是其他任何内容。这是一个真正的负担。这不是本节的目标。我们的目标是使测试变得简单和易于接近，所以我们将使用一个名为SuperTest的库来测试我们的Express应用程序。
- en: SuperTest was created by the developers who originally created Express. It has
    built-in support for Express and it makes testing your Express apps dead simple.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SuperTest是由最初创建Express的开发人员创建的。它内置支持Express，使得测试Express应用程序变得非常简单。
- en: The SuperTest documentation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SuperTest文档
- en: 'In order to get started, let''s pull up the docs page so you know where it
    lives if you ever want to look at any other features that it has to offer. If
    you Google `supertest`, it should be the first result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们打开文档页面，这样你就知道它在哪里，如果你想查看它提供的任何其他功能。如果你谷歌`supertest`，它应该是第一个结果：
- en: '![](img/4f38bb5a-5756-44c8-8b0e-895ef3042dfe.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f38bb5a-5756-44c8-8b0e-895ef3042dfe.png)'
- en: 'It''s the VisionMedia repository and the repository itself is called SuperTest.
    Let''s switch over to the repository page and we can take a quick look at what
    it has to offer. On this page, we can find installation instructions and introduction
    stuff. We don''t really need that. Let''s take a quick look at an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是VisionMedia的存储库，存储库本身称为SuperTest。让我们切换到存储库页面，我们可以快速看一下它提供了什么。在这个页面上，我们可以找到安装说明和介绍内容。我们不真的需要那个。让我们快速看一个例子：
- en: '![](img/4774cb87-52c5-459c-be9e-22b805d7f3f5.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4774cb87-52c5-459c-be9e-22b805d7f3f5.png)'
- en: As shown in the previous screenshot, we can see an example of how SuperTest
    works. We create an Express application, just like we normally would, and we define
    a route. Then we make a call to the `request` method, which is provided by SuperTest,
    passing in our Express application. We say we want to make a `get` request to
    the `/` URL. Then we start making assertions. There's no need to manually check
    either the headers, the status code, or the body. It has built-in assertions for
    all of that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们可以看到SuperTest的工作示例。我们创建一个Express应用程序，就像我们通常做的那样，并定义一个路由。然后我们调用`request`方法，这是由SuperTest提供的，传入我们的Express应用程序。我们说我们要对`/`
    URL进行`get`请求。然后我们开始进行断言。无需手动检查头部、状态码或正文。它对所有这些都有内置的断言。
- en: Creating a test for the Express app
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Express应用程序创建测试
- en: To get started, we'll install SuperTest in our application by running npm install
    from the Terminal. We have the Node server still running. Let's shut that down
    and then install the module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将通过在终端中运行npm install来在我们的应用程序中安装SuperTest。我们的Node服务器仍在运行。让我们关闭它，然后安装该模块。
- en: 'We can use `npm i`, the module name is `supertest` and we''ll be grabbing the
    most recent version, `@2.0.0`. This is a test-specific module so we''ll be installing
    it with save. We''ll use `save-dev` to add it to the `devDependencies` in `package.json`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`npm i`，模块名称是`supertest`，我们将获取最新版本`@2.0.0`。这是一个专门用于测试的模块，所以我们将使用`save`来安装它。我们将使用`save-dev`将其添加到`package.json`中的`devDependencies`中：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/91335d87-250c-4135-b7e8-668ca5977ef0.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91335d87-250c-4135-b7e8-668ca5977ef0.png)'
- en: 'With SuperTest installed, we are now ready to work on the `server.test.js`
    file. As it doesn''t yet exist inside the `server` folder, so we can create it.
    It''s going to sit just alongside `server.js`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了SuperTest后，我们现在准备在`server.test.js`文件上工作。因为它还不存在于`server`文件夹中，所以我们可以创建它。它将与`server.js`并排放置：
- en: '![](img/b5647907-a1e0-4e25-b9e5-3b35e634bc81.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5647907-a1e0-4e25-b9e5-3b35e634bc81.png)'
- en: 'Now that we have `server.test.js` in place, we can start setting up our very
    first test. First, we''ll be creating a constant called request and setting that
    equal to the return result from requiring `supertest`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`server.test.js`，我们可以开始设置我们的第一个测试。首先，我们将创建一个名为request的常量，并将其设置为从`supertest`中导入的返回结果：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the main method we''ll be using to test our Express apps. From here,
    we can load in the Express application. Now inside `server.js`, we don''t have
    an export that exports the app, so we''ll have to add that. I''ll add it next
    to the `app.listen` statement by creating `module.exports.app` and setting that
    equal to the `app` variable:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用来测试我们的Express应用程序的主要方法。从这里，我们可以加载Express应用程序。现在在`server.js`中，我们没有导出导出应用程序的导出，所以我们需要添加。我将在`app.listen`语句旁边添加，通过创建`module.exports.app`并将其设置为`app`变量：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we have an export called app that we can access from other files. The `server.js`
    is still going to run as expected when we start it from the Terminal, not in test
    mode. We just added an export so if anyone happens to require it, they can get
    access to that app. Inside `server.test.js`, we''ll make a variable to import
    this. We''ll call the variable `app`. Then we''ll require using `require(''./server.js'')`,
    or just `server`. Then we''ll access the `.app` property:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为app的导出，我们可以从其他文件中访问。当我们从终端启动时，`server.js`仍将按预期运行，而不是在测试模式下。我们只是添加了一个导出，所以如果有人需要它，他们可以访问该应用程序。在`server.test.js`中，我们将创建一个变量来导入这个。我们将调用变量`app`。然后我们将使用`require('./server.js')`或者只是`server`来进行导入。然后我们将访问`.app`属性：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this in place, we now have everything we need to write our very first test.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在拥有了编写我们的第一个测试所需的一切。
- en: Writing the test for the Express app
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Express应用程序编写测试
- en: 'The first test we''ll write is a test that verifies when we make an HTTP GET
    request to the `/` URL, we get `Hello world!` back. To do this, we will be calling
    `it` just like we did for our other tests in the previous chapter. We''re still
    using `mocha` as the actual test framework. We''re using SuperTest to fill in
    the gaps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的第一个测试是验证当我们对`/` URL进行HTTP GET请求时，我们会得到`Hello world!`。为此，我们将调用`it`，就像我们在上一章中为其他测试所做的那样。我们仍然使用`mocha`作为实际的测试框架。我们使用SuperTest来填补空白：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we''ll set up the function as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置函数如下：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is going to be an asynchronous call so I are providing `done` as the argument
    to let `mocha` know to wait before determining whether or not the test passed
    or failed. From here, we can now make our very first call to `request`. To use
    SuperTest, we call `request` passing in the actual Express application. In this
    case, we pass in the `app` variable:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个异步调用，所以我正在提供`done`作为参数，让`mocha`知道在确定测试是否通过或失败之前等待。从这里，我们现在可以对`request`进行第一次调用。要使用SuperTest，我们调用`request`并传入实际的Express应用程序。在这种情况下，我们传入`app`变量：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then we can start chaining together all the methods we need to make the request,
    make our assertions, and finally wrap things up. First up, you'll be using a method
    to actually make that request, whether it's a `get`, `put`, `delete`, or a `post`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以开始链接所有我们需要的方法来发出请求，做出断言，最后结束。首先，您将使用一个方法来实际发出请求，无论是`get`，`put`，`delete`还是`post`。
- en: 'For now, we''ll be making a `get` request, so we will use `.get`. The `.get`
    request takes the URL. So, we''ll provide `/` (forward slash), just as we did
    in `server.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将发出一个`get`请求，所以我们将使用`.get`。`.get`请求需要URL。因此，我们将提供`/`（斜杠），就像我们在`server.js`中所做的那样：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next up, we can make some assertions. To make assertions, we''ll use `.expect`.
    Now `.expect` is one of those methods that does different things depending on
    what you pass to it. In our case, we''ll be passing in a string. Let''s pass in
    a string which will be the response body that we assert, `Hello world!`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以做一些断言。要进行断言，我们将使用`.expect`。现在`.expect`是其中一种方法，根据您传递给它的内容而执行不同的操作。在我们的情况下，我们将传递一个字符串。让我们传递一个字符串，这将是我们断言的响应主体，`Hello
    world!`：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we''re done and we''ve made our assertions, we can wrap things up.
    To wrap up a request in SuperTest, all we do is we call `.end` passing in `done`
    as the callback:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成并做出了断言，我们可以结束了。要在SuperTest中结束一个请求，我们所做的就是调用`.end`并传入`done`作为回调：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This handles everything behind the scenes so you don't need to manually call
    `done` at a later point in time. All of it is handled by SuperTest. With these
    four lines (in the previous code), we have successfully tested our very first
    API request.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是在幕后处理的，所以您不需要在以后手动调用`done`。所有这些都由SuperTest处理。通过这四行代码（在上一段代码中），我们已经成功测试了我们的第一个API请求。
- en: Testing our first API request
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的第一个API请求
- en: 'We''ll kick things off in the Terminal by running our `test-watch` script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在终端中通过运行我们的`test-watch`脚本来开始：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The test script is going to start and as shown here, we have some tests:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本将开始运行，如图所示，我们有一些测试：
- en: '![](img/412cbf0b-4734-47eb-b4e0-92f75fe19b2d.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/412cbf0b-4734-47eb-b4e0-92f75fe19b2d.png)'
- en: We have our test, `should return hello world response`, showing up in the previous
    screenshot.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试`应该返回hello world响应`显示在上一张截图中。
- en: 'Now we can take things a step further making other assertions about the data
    that comes back. For example, we can use expect after the `.get` request in `server.test.js`
    to make an assertion about the status code. By default, all of our Express calls
    are going to return a `200` status code, which means that things went OK:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进一步进行其他关于返回数据的断言。例如，我们可以在`server.test.js`中的`.get`请求之后使用`expect`来对状态码进行断言。默认情况下，我们所有的Express调用都将返回`200`状态码，这意味着事情进行得很顺利：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we save the file, the test still passes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存文件，测试仍然通过：
- en: '![](img/6a37cd1c-3c98-4e2d-8fc4-ea79b890c976.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a37cd1c-3c98-4e2d-8fc4-ea79b890c976.png)'
- en: 'Now let''s make some changes to the request to make these tests fail. First
    up, in `server.js` we''ll just add a few characters (`ww`) to the string, and
    save the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对请求进行一些更改，使这些测试失败。首先，在`server.js`中，我们将在字符串中添加几个字符（`ww`），然后保存文件：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This should cause the SuperTest test to fail and it does indeed do that:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致SuperTest测试失败，确实如此：
- en: '![](img/c6bd94fa-5169-4ff0-8f3a-17e5df616194.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6bd94fa-5169-4ff0-8f3a-17e5df616194.png)'
- en: As shown in the previous screenshot, we get a message, `expected 'Hello world!'
    response body, but we got 'Hello wwworld!'`. This is letting us know exactly what
    happened. Back inside `server.js`, we can remove those extra characters (`ww`)
    and try something else.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一张截图所示，我们得到了一条消息，`expected 'Hello world!' response body, but we got 'Hello
    wwworld!'`。这让我们知道发生了什么。回到`server.js`中，我们可以删除那些额外的字符（`ww`）并尝试其他方法。
- en: Setting up custom status
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置自定义状态
- en: 'Now we haven''t talked about how to set a custom status for our response, but
    we can do that with one method, `.status`. Let''s add `.status` in `server.js`,
    chaining it on, before, `send(''Hello world!'')`, just like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还没有讨论如何为我们的响应设置自定义状态，但我们可以使用一个方法`.status`来实现。让我们在`server.js`中添加`.status`，在`send('Hello
    world!')`之前链接它，就像这样：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we can pass in the numerical status code. For example, we could use a
    `404` for page not found:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以传入数字状态码。例如，我们可以使用`404`表示页面未找到：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we save the file this time around, the body is going to match up, but inside
    the Terminal we can see we now have a different error:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这次保存文件，主体将匹配，但在终端内我们可以看到我们现在有一个不同的错误：
- en: '![](img/c75b0864-1897-4484-b5c7-a428d5394a5d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c75b0864-1897-4484-b5c7-a428d5394a5d.png)'
- en: 'We expected a `200`, but we got a `404`. Using SuperTest, we can make all sorts
    of assertions about our application. Now the same thing is true for different
    types of responses. For example, we can create an object as the response. Let''s
    make a simple object and we''ll create a property called `error`. Then we''ll
    set `error` equal to a generic error message for a `404`, something like `Page
    not found`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望得到一个`200`，但我们得到了一个`404`。使用SuperTest，我们可以对我们的应用程序进行各种断言。现在对于不同类型的响应也是如此。例如，我们可以创建一个对象作为响应。让我们创建一个简单的对象，然后创建一个名为`error`的属性。然后我们将`error`设置为一个`404`的通用错误消息，比如`Page
    not found`：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we''re sending back a JSON body, but currently we''re not making any assertions
    about that body so the test is going to fail:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们发送了一个JSON body，但目前我们没有对这个body做任何断言，所以测试将失败：
- en: '![](img/27e0ba2b-48fd-4105-a9ac-c6902106ede5.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27e0ba2b-48fd-4105-a9ac-c6902106ede5.png)'
- en: 'We can update our tests to `expect` JSON to come back. In order to get that
    done, all we have to do inside `server.test` is change what we pass to `expect`.
    Instead of passing in a string, we''ll pass in an object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新我们的测试来`expect` JSON返回。为了完成这个目标，我们只需要在`server.test`中改变我们传递给`expect`的内容。我们不再传递一个字符串，而是传递一个对象：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we can match up that object exactly. Inside the object, we''ll `expect`
    that the `error` property exists and that it equals exactly what we have in `server.js`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以精确匹配这个对象。在对象内部，我们将`expect`错误属性存在，并且它等于我们在`server.js`中的内容：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we''ll change the `.expect` call to a `404` from `200`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`.expect`调用从`200`更改为`404`：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With this in place, our assertions now match up with the actual endpoint we''ve
    defined inside the Express application. Let''s save the file and see if all the
    tests pass:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的断言现在与我们在Express应用程序中定义的实际端点相匹配。让我们保存文件，看看所有的测试是否通过：
- en: '![](img/8ab5f585-ac2e-4164-888c-96995b2f1703.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ab5f585-ac2e-4164-888c-96995b2f1703.png)'
- en: As shown in the previous screenshot, we can see it is indeed passing. The `Should
    return hello world` response is passing. It took about `41ms` (milliseconds) to
    complete, and that is perfectly fine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们可以看到它确实通过了。`Should return hello world`响应通过了。完成大约`41ms`（毫秒），这完全没问题。
- en: Adding flexibility to SuperTest
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为SuperTest添加灵活性
- en: 'A lot of the built-in assertions do get the job done for the majority of cases.
    There are times where you want a little more flexibility. For example, in the
    previous chapter, we learned about all those cool assertions expect can make.
    We can use `toInclude`, `toExclude`, all of that stuff is really handy and it''s
    a shame to lose it. Luckily, there''s a lot of flexibility with SuperTest. What
    we can do instead of taking an object and passing it into expect, or a number
    for the status code, we can provide a function. This function will get called
    by SuperTest and it will get passed the response:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内置断言确实可以完成大部分工作。有时候你想要更灵活一点。例如，在上一章中，我们学习了所有那些很酷的断言，expect可以做到。我们可以使用`toInclude`，`toExclude`，所有这些都非常方便，失去它真是太可惜了。幸运的是，SuperTest非常灵活。我们可以提供一个函数，而不是将一个对象传递给expect，或者一个状态码的数字，这个函数将被SuperTest调用，并且会传递响应：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means we can access headers, body, anything we want to access from the
    HTTP response—it's going to be available in the function. We can pipe it through
    the regular expect assertion library like we've done in the previous chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以访问头部，body，我们想要从HTTP响应中访问的任何内容——它都可以在函数中使用。我们可以通过常规的expect断言库进行断言，就像我们在上一章中所做的那样。
- en: 'Let''s load it in, creating a constant called `expect` and setting it equal
    to require `expect`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载它，创建一个名为`expect`的常量，并将其设置为require `expect`：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now before we look at how it''s going to work, we''ll make a change in `server.js`.
    Here, we''ll add a second property on to the `.status` object. We''ll add an `error`
    and then add something else. Let''s use `name`, setting it equal to the application
    name, `Todo App v1.0`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们看它将如何工作之前，我们将在`server.js`中做一个改变。在这里，我们将在`.status`对象上添加第二个属性。我们将添加一个`error`，然后添加其他内容。让我们使用`name`，将其设置为应用程序名称，`Todo
    App v1.0`：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we have this in place, we can take a look at how we can use those custom
    assertions inside our test file. In the `.expect` object, we'll have access to
    the response and in the response there is a body property. This will be a JavaScript
    object with key-value pairs, which means we would expect to have an `error` property
    and a `name` property, which we set in `server.js`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，我们可以看看如何在我们的测试文件中使用这些自定义断言。在`.expect`对象中，我们将可以访问响应，在响应中有一个body属性。这将是一个具有键值对的JavaScript对象，这意味着我们期望有一个`error`属性和一个`name`属性，这是我们在`server.js`中设置的。
- en: 'Back inside our test file, we can make a custom assertion using `expect`. I''ll
    `expect` something about the body, `res.body`. Now we can use any assertion we
    like, not just the equals assertion, which is the only one SuperTest supports.
    Let''s use the `toInclude` assertion:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试文件，我们可以使用`expect`来创建自定义断言。我会对body，`res.body`做一些`expect`。现在我们可以使用任何我们喜欢的断言，不仅仅是等于断言，这是SuperTest支持的唯一一种。让我们使用`toInclude`断言：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Remember, `toInclude` lets you specify a subset of the properties on the object.
    As long as it has those ones that''s fine. It doesn''t matter that it has extra
    ones. In our case, inside `toInclude`, we can just specify the `error` message,
    leaving off the fact that name exists at all. We want to check that `error: Page
    not found`, formatted exactly like we have it inside of `server.js`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '记住，`toInclude`让你指定对象上的属性的一个子集。只要它有这些属性就可以。它并不要求它有额外的属性。在我们的情况下，在`toInclude`内部，我们只需指定`error`消息，不需要指定name是否存在。我们想要检查`error:
    Page not found`，格式与我们在`server.js`中的格式完全一样：'
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now when we save the file back inside the Terminal, things restart and all
    of my tests are passing:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们保存文件回到终端时，一切都重新启动了，我的所有测试都通过了：
- en: '![](img/e33be389-d1e9-4939-881b-31908affca8d.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e33be389-d1e9-4939-881b-31908affca8d.png)'
- en: Using a combination of SuperTest and expect we can have super flexible test
    suites for our HTTP endpoints. With this in place, we'll create another `express`
    route and we'll define a test that makes sure it works as expected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SuperTest和expect的组合，我们可以为我们的HTTP端点创建超级灵活的测试套件。有了这个，我们将创建另一个`express`路由，并定义一个测试，确保它按预期工作。
- en: Creating an express route
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个express路由
- en: 'There will be two sides to this express route, the actual setup in `server.js`
    and the test. We can start inside `server.js`. In here, we''ll make a new route.
    First, let''s add a few comments to specify exactly what we''ll do. It''s going
    to be an HTTP `GET` route. The route itself will be `/users` and we can just assume
    this returns an array of users:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个express路由将有两个方面，一个是`server.js`中的实际设置，另一个是测试。我们可以从`server.js`开始。在这里，我们将创建一个新的路由。首先，让我们添加一些注释，明确指定我们要做什么。这将是一个HTTP
    `GET`路由。路由本身将是`/users`，我们可以假设这会返回一个用户数组：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can pass an array back through the `send` method, just like we do an object
    in the previous code. Now this array is going to be an array of objects where
    each object is a user. For now, we want to give users a `name` property and an
    `age` prop:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`send`方法返回一个数组，就像我们在先前的代码中对对象所做的那样。现在这个数组将是一个对象数组，其中每个对象都是一个用户。现在，我们想给用户一个`name`属性和一个`age`属性：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we''ll create two or three users for this example. Now once we have this
    done, we''ll be responsible for writing a test that asserts it works as expected.
    That''s going to happen in `server.test.js`. Inside `server.test.js`, we''ll make
    a new test:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将为这个示例创建两到三个用户。一旦我们完成了这个，我们将负责编写一个测试，断言它按预期工作。这将发生在`server.test.js`中。在`server.test.js`中，我们将创建一个新的测试：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And this test is going to assert a couple of things. First up, we assert that
    the status code that comes back is a `200` and we want to make an assertion that
    inside of that array and we''ll do that using `toInclude`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将断言一些事情。首先，我们断言返回的状态码是`200`，我们想要断言的是数组中的内容，我们将使用`toInclude`来做到这一点：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s start with defining the endpoint first. Inside `server.js`, just following
    the comments, we''ll call `app.get` so we can register the brand new HTTP endpoint
    for our application. This one is going to be at `/users`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义端点。在`server.js`中，跟随注释，我们将调用`app.get`，这样我们就可以为我们的应用程序注册全新的HTTP端点。这个将会在`/users`处：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next up, we''ll specify the callback that takes both request and response:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将指定接受请求和响应的回调函数：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will let us actually respond to the request, and the goal here is just
    to respond with an array. In this case, I''ll call `response.send` passing in
    an array of objects:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我们实际响应请求，这里的目标只是响应一个数组。在这种情况下，我将调用`response.send`，传入一个对象数组：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first object will be `name`. We''ll set the `name` equal to `Mike` and
    we''ll set his `age` equal to `27`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对象将是`name`。我们将把`name`设置为`Mike`，并将他的`age`设置为`27`：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then I can add another object. Let''s add the second object to the array with
    a name equal to `Andrew` and an age equal to `25`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以添加另一个对象。让我们将第二个对象添加到数组中，名称设置为`Andrew`，年龄设置为`25`：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the last one, we''ll set the name equal to `Jen` and the age equal to `26`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个中，我们将把名称设置为`Jen`，年龄设置为`26`：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now that we have our endpoint done, we can save `server.js`, move into `server.test.js`,
    and start worrying about actually creating our test case.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的端点已经完成，我们可以保存`server.js`，进入`server.test.js`，并开始担心实际创建我们的测试用例。
- en: Writing the test for the express route
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写express路由的测试
- en: 'In `server.test.js`, just following the comments, we need to start things out
    by calling `it`. `it` is the only way to make a new test:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.test.js`中，跟随注释，我们需要首先调用`it`来开始。`it`是创建新测试的唯一方法：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we''ll specify the callback function. It will get past the `done` argument
    because this one is going to be asynchronous:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将指定回调函数。它将传递`done`参数，因为这是一个异步的：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To kick things off inside the test case, we''ll be calling requests just like
    we did in hello world response, passing in the Express application:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试用例中开始时，我们将调用请求，就像我们在hello world响应中所做的那样，传入Express应用程序：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we can set up the actual call. In this case, we''re just making a call,
    a `get` request, to the following URL, inside of quotes, `/users`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置实际的调用。在这种情况下，我们只是在以下URL进行调用，`/users`：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next up, we can start making our assertions and the first thing we''re supposed
    to assert that the status code is at `200`, which is the default status code used
    by Express. We can assert that by calling `.expect` and passing in the status
    code as a number. In this case, we''ll pass in `200`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始做出断言，首先我们要断言的是状态码为`200`，这是Express使用的默认状态码。我们可以通过调用`.expect`并传入状态码作为数字来断言。在这种情况下，我们将传入`200`：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After this, we''ll use a custom `expect` assertion. This means that we''ll
    call `expect` passing in a function and use `toInclude` inside `it` to make the
    assertion that you exist in that users array. We''ll call `expect` the method
    passing in the function, and that function will get called with the response:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用自定义的`expect`断言。这意味着我们将调用`expect`，传入一个函数，并在`it`内部使用`toInclude`来断言你存在于那个用户数组中。我们将调用`expect`方法，传入函数，该函数将使用响应调用：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will let us make some assertions about the response. What we''re actually
    going to do is make an assertion using `expect`. We''ll expect something about
    the response body. In this case, we''ll be checking that it includes using `toInclude`,
    our user object:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我们对响应做出一些断言。我们实际上将使用`expect`进行断言。我们将期望响应体的某些内容。在这种情况下，我们将检查它是否包含我们的用户对象：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now remember you can call `toInclude` on both arrays and objects. All we do
    is pass in the item we want to confirm is in the array. In our case, it''s an
    object where the `name` property equals `Andrew` and the `age` property equals
    `25`, which is what we used inside `server.js`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在记住，你可以在数组和对象上都调用`toInclude`。我们所做的就是传入我们想要确认在数组中的项目。在我们的情况下，它是一个对象，其中`name`属性等于`Andrew`，`age`属性等于`25`，这是我们在`server.js`中使用的内容：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that we have our custom `expect` call in place, at the very bottom we can
    call `.end`. This is going to wrap up the request and we can pass in `done` as
    the callback so it can properly fire off those errors if any actually occurred:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了自定义的`expect`调用，我们可以在最底部调用`.end`。这将结束请求，我们可以将`done`作为回调传入，这样如果有任何错误发生，它就可以正确地触发：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With this in place, we are ready to get going. We can save the file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以开始了。我们可以保存文件。
- en: 'Inside the Terminal, we can see the tests are indeed rerunning:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们可以看到测试确实正在重新运行：
- en: '![](img/3521bffa-2049-4c26-a4a7-6bcdd5586349.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3521bffa-2049-4c26-a4a7-6bcdd5586349.png)'
- en: We have a test as shown in the previous screenshot, `should return my user object`.
    It is passing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个测试，如前面的截图所示，`should return my user object`。它通过了。
- en: 'Now we can confirm that we''ll not go crazy and test the wrong thing by just
    messing up the data. We will now add a lowercase `a` after the uppercase one in
    `Andrew` in `server.js`, as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以确认，我们不会因为弄乱数据而疯狂地测试错误的东西。我们现在将在`server.js`中的`Andrew`后面添加一个小写的`a`，如下所示：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The test is going to fail. We can see that in the Terminal:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将会失败。我们可以在终端中看到：
- en: '![](img/508cafd2-49ef-4e05-8d44-0c33b51c793f.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/508cafd2-49ef-4e05-8d44-0c33b51c793f.png)'
- en: We have done testing for our Express apps. We'll now talk about one more way
    we can test our Node code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的Express应用程序进行了测试。现在我们将讨论另一种测试Node代码的方法。
- en: Organizing test with describe()
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用describe()组织测试
- en: 'In this section, we will learn how to use `describe()`. `describe` is a function
    injected into our test files, just like the `it` function is. It comes from `mocha`
    and it''s really fantastic. Essentially, it lets us group tests together. That
    makes it a lot easier to scan the test output. If we run our `npm test` command
    in the Terminal, we get our tests:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用`describe()`。`describe`是一个注入到我们的测试文件中的函数，就像`it`函数一样。它来自于`mocha`，真的很棒。基本上，它让我们将测试分组在一起。这样可以更容易地扫描测试输出。如果我们在终端中运行`npm
    test`命令，我们会得到我们的测试：
- en: '![](img/2e8cf5ce-b9fb-45a3-84ea-dc4804f28ba3.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e8cf5ce-b9fb-45a3-84ea-dc4804f28ba3.png)'
- en: We have seven tests and currently they're all grouped together. It's really
    hard to look for the tests in the `utils` file and it's impossible to find the
    tests for `asyncAdd` without scanning all of the text. What we'll do is call `describe()`.
    This will let us make groups of tests. We can give that group a name. It will
    make our test output much more readable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有七个测试，目前它们都被分组在一起。在`utils`文件中查找测试非常困难，而且要找到`asyncAdd`的测试几乎是不可能的，除非扫描所有文本。我们将调用`describe()`。这将让我们对测试进行分组。我们可以给该组起一个名字。这将使我们的测试输出更易读。
- en: 'In the `utils.test.js` file, right after the `utils` constant, we''ll call
    `describe()`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils.test.js`文件中，在`utils`常量右边，我们将调用`describe()`：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The describe object takes two arguments, just like `it`. The first one is the
    name and the other is the callback function. We''ll use `Utils`. This will be
    the `describe` block that contains all of the tests in the `utils.test` file.
    Then we''ll provide the function. This is the callback function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 描述对象接受两个参数，就像`it`一样。第一个是名称，另一个是回调函数。我们将使用`Utils`。这将是包含`utils.test`文件中所有测试的`describe`块。然后我们提供函数。这是回调函数：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Inside the callback function, we'll be defining tests. Any test defined in the
    callback function will be a part of the `utils` block. That means we can take
    our existing tests, cut them out of the file, paste them in there, and we'll have
    a `describe` block called `utils` with all of the tests for this file. So, let's
    do just that.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，我们将定义测试。在回调函数中定义的任何测试都将成为`utils`块的一部分。这意味着我们可以拿出现有的测试，剪切它们出来，粘贴到那里，我们将在文件中有一个名为`utils`的`describe`块，其中包含了所有的测试。所以，让我们就这样做吧。
- en: 'We''ll grab all the tests, excluding the ones that are just playground tests
    where we play around with various `expect` functionality. We''ll then paste them
    right into the callback function. The resultant code is going to look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获取所有的测试，排除那些只是在各种`expect`功能中玩耍的测试。然后我们将把它们粘贴到回调函数中。结果代码将如下所示：
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'These are four tests for `add`, `asyncAdd`, `square`, and `asyncSquare` respectively.
    Now we''ll save the file and we can start up the `test-watch` script from the
    Terminal and check the output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分别是`add`、`asyncAdd`、`square`和`asyncSquare`的四个测试。现在我们将保存文件，然后可以从终端启动`test-watch`脚本并检查输出：
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The script will start and run through our tests, and as shown in the following
    screenshot, we''ll have different outputs:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将启动并运行我们的测试，如下截图所示，我们将得到不同的输出：
- en: '![](img/02860fc6-4a4f-4142-be2c-54f79836c70a.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02860fc6-4a4f-4142-be2c-54f79836c70a.png)'
- en: We have a `Utils` section and under `Utils`, we have all of the tests in that
    `describe` block. This makes reading and scanning your tests much, much easier.
    We can do the same thing for the individual methods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Utils`部分，在`Utils`下，我们有该`describe`块中的所有测试。这样可以使阅读和扫描测试变得更加容易。我们也可以对各个方法做同样的事情。
- en: Adding describe() for individual methods
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为单独的方法添加describe()
- en: 'Now, in the case of `utils.test.js` (refer to the previous screenshot), we
    have one test per method, but if you have a lot of tests that are targeting a
    complex method, it''s best to wrap that in its own `describe` block. We can nest
    `describe` blocks and tests in any way we like. For example, right inside `utils`
    just after the `describe` statement, we can call `describe` again. We can pass
    a new description. Let''s use `#` (pound sign) followed by `add`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`utils.test.js`的情况下（参考前面的截图），我们每个方法有一个测试，但是如果你有很多测试针对一个复杂的方法，最好将其包装在自己的`describe`块中。我们可以以任何我们喜欢的方式嵌套`describe`块和测试。例如，在`utils`的`describe`语句之后，我们可以再次调用`describe`。我们可以传递一个新的描述。让我们使用`#`（井号）后跟`add`：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `#` (pound sign) followed by the method name is the common syntax for adding
    a `describe` block for a specific method. Then we can provide that callback function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`#`（井号）后跟方法名是为特定方法添加`describe`块的常见语法。然后我们可以提供回调函数：'
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we can take any tests we want to add into that group, cut them out, and
    paste them in:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将任何要添加到该组的测试剪切出来，粘贴进去：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then I can save the file. This will rerun the test suite and now we have test
    output that''s even more scannable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我保存文件。这将重新运行测试套件，现在我们有更易于扫描的测试输出：
- en: '![](img/bc75b06b-dcc9-4b98-8f16-53fd5d39688f.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc75b06b-dcc9-4b98-8f16-53fd5d39688f.png)'
- en: It's super easy to find the `utils` add method tests because they're clearly
    labelled. Now you could go as crazy or as uncrazy with this as you want. There
    really is no hard-and-fast rule for how often to use `describe` to structure your
    tests. It's really up to you to figure out what makes sense given the amount of
    tests you have for a method or a file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易找到`utils`添加方法的测试，因为它们都有清晰的标签。你可以根据需要进行任意的嵌套。关于在测试中使用`describe`的频率并没有硬性规定，真的取决于你要根据方法或文件的测试数量来决定使用`describe`的次数。
- en: In this case, we have quite a few tests in the file so it definitely makes sense
    to add that `utils` block. And I just wanted to show you you could nest them,
    so I added it for `add` as well. If I was writing this code, I probably wouldn't
    add a second layer of tests, but if I had more than one test per method, I definitely
    would add a second `describe` block.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文件中有相当多的测试，因此添加`utils`块是有意义的。我只是想向你展示你可以嵌套它们，所以我也为`add`添加了它。如果我写这段代码，我可能不会添加第二层测试，但如果一个方法有多个测试，我肯定会添加第二个`describe`块。
- en: Adding the route describe block for the server.test.js file
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`server.test.js`文件添加路由`describe`块
- en: 'Now, let''s create some `describe` blocks in the `server.test` file. We''ll
    create a route `describe` block called `Server`. Then we''ll create `describe`
    blocks for both the route URL and for `/users`. We''ll have `GET/`. That will
    have the test case in there, `some test case`. Then alongside `//`, we''ll have
    `GET /users`, and that will have its own test case, `some test case` as explained
    in the comments next:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`server.test`文件中创建一些`describe`块。我们将创建一个名为`Server`的路由`describe`块。然后我们将为路由URL和`/users`分别创建`describe`块。我们将有`GET/`，其中将包含测试用例`some
    test case`。然后在`//`旁边，我们将有`GET /users`，它将有自己的测试用例`some test case`，如旁边的注释所解释的那样：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now the test cases are obviously already defined. All we need to do is call
    `describe` three times to generate the previously explained structure.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试用例显然已经定义好了。我们只需要调用`describe`三次来生成之前解释过的结构。
- en: 'We''ll start with calling `describe()` once following the comments part, and
    this description will be for the route, so we''ll call this one `Server`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在注释部分之后调用`describe()`一次，这个描述将是关于路由的，所以我们将称之为`Server`：
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is going to contain all the tests in our `server` file. We can add the
    callback function next and we can move on:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含我们`server`文件中的所有测试。接下来我们可以添加回调函数，然后继续：
- en: '[PRE61]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next up, we''ll call `describe` again. This time we''re creating a `describe`
    block for tests that test the `GET /` route and add the callback function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将再次调用`describe`。这次我们将为测试`GET /`路由创建一个`describe`块，并添加回调函数：
- en: '[PRE62]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now we can simply take our test, cut it out, and paste it right inside the
    `describe` callback. The resultant code is going to look like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简单地将我们的测试剪切出来，然后粘贴到`describe`回调函数中。最终的代码将如下所示：
- en: '[PRE63]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next up, we''ll call `describe` the third time. We''ll be calling `describe`
    passing in as the description `GET /users`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将第三次调用`describe`。我们将调用`describe`并传入`GET /users`作为描述：
- en: '[PRE64]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We''ll have our callback function as always and then we can copy and paste
    our test right inside:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像往常一样拥有我们的回调函数，然后我们可以直接复制并粘贴我们的测试代码：
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With this in place, we are now done. We have a much better structure for our
    tests and when we rerun the test suite by saving the file, we''ll be able to see
    that in the Terminal:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在完成了。我们的测试结构更加清晰，当我们保存文件重新运行测试套件时，我们将能够在终端中看到结果：
- en: '![](img/b29209b4-2c4b-4d9e-9971-b45402671484.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b29209b4-2c4b-4d9e-9971-b45402671484.png)'
- en: As shown in the previous code, we have a much more scannable test suite. We
    can see our server tests right away. We can create groups of tests for each feature.
    Since we have static data right now, we really don't need more than one test per
    feature. But down the line, we will have multiple tests for each of our HTTP requests,
    so it's a good idea to get into that habit of creating `describe` blocks early.
    And that's it for this one!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们有一个更易于扫描的测试套件。我们可以立即看到我们的服务器测试。我们可以为每个功能创建测试组。由于我们现在只有静态数据，我们实际上不需要每个功能超过一个测试。但在未来，我们将为每个HTTP请求有多个测试，因此及早创建`describe`块是个好习惯。就是这样了！
- en: Test spies
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试间谍
- en: In this section, which is the final section for the testing chapter, we'll learn
    some pretty advanced testing techniques. We'll be using these techniques as we
    build real-world apps, but for now let's start off with an example. We'll worry
    about the vocabulary for what we're about to do in just a second.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，也是测试章节的最后一部分，我们将学习一些相当高级的测试技术。我们将在构建真实应用时使用这些技术，但现在让我们从一个例子开始。我们将在接下来的内容中学习相关词汇。
- en: 'For the moment, we''ll close all our current files and create a new directory
    in the root of the project. We''ll make a new folder called `spies`. We''ll talk
    about what exactly `spies` are and how they relate to testing in just a moment.
    Inside `spies`, we''ll make two files: `app.js` (this is the file that we''ll
    be testing) and a second one, called `db.js`. In our example, we can just assume
    that `db.js` is a file that has all sorts of methods for saving and reading data
    from the database.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时，我们将关闭所有当前的文件，并在项目的根目录下创建一个新的目录。我们将创建一个名为`spies`的新文件夹。我们将马上讨论`spies`到底是什么，以及它们与测试的关系。在`spies`文件夹中，我们将创建两个文件：`app.js`（这是我们将要测试的文件）和另一个名为`db.js`的文件。在我们的示例中，我们可以假设`db.js`是一个包含各种方法用于保存和读取数据库中数据的文件。
- en: 'Inside `db.js`, we''ll create one function using `module.exports`. Let''s create
    a function called `saveUser`. The `saveUser` function will be a really simple
    function, and it will take a `user` object like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`db.js`中，我们将使用`module.exports`创建一个函数。让我们创建一个名为`saveUser`的函数。`saveUser`函数将是一个非常简单的函数，它将接受一个像这样的`user`对象：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we''ll just print it to the screen using the `console.log` statement.
    We''ll print it a little message, `Saving the user`, and we''ll also print out
    the object as shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`console.log`语句将其打印到屏幕上。我们将打印一条消息“保存用户”，并打印出如下所示的对象：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now obviously, this is not a real `saveUser` function. We do not interact with
    any sort of database, but it will illustrate exactly how we will be using `spies`
    to test our code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是一个真正的`saveUser`函数。我们不与任何类型的数据库交互，但它将清楚地说明我们将如何使用`spies`来测试我们的代码。
- en: 'Next up, we will fill our `app.js`, and this is the file we''ll actually be
    testing. Inside `app.js`, we''ll create a new function: `module.exports.handleSignup`.
    In the context of an application with authentication, `handleSignup` might take
    an `email` and a `password`; maybe it goes ahead and checks if the `email` already
    exists. If it doesn''t, great; it saves the user and then it sends some sort of
    a welcome email. We can simulate that by creating an arrow function (`=>`) that
    takes in `email` and a `password`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将填充我们的`app.js`，这是我们实际要测试的文件。在`app.js`中，我们将创建一个新函数：`module.exports.handleSignup`。在具有身份验证的应用程序的上下文中，`handleSignup`可能会接受一个`email`和一个`password`；也许它会继续检查`email`是否已经存在。如果没有，很好；它保存用户，然后发送某种欢迎邮件。我们可以通过创建一个接受`email`和`password`的箭头函数(`=>`)来模拟这一点：
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Inside the arrow function (`=>`), we''ll leave three comments. These will be
    things that the function is supposed to do. It will check if the `email` already
    exists; it will save the user to the database; and finally, we''ll send that welcome
    email:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数(`=>`)中，我们将留下三条注释。这些将是函数应该执行的操作。它将检查`email`是否已经存在；它将用户保存到数据库；最后，我们将发送欢迎邮件：
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, these three things are just an example of what a `handleSignup` method
    might actually do. When we go through the real process, you''ll see how it pans
    out. Now, we already have one of these in place. We just created `saveUser`, so
    we''ll do is call `saveUser` instead of having this second comment:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这三件事只是`handleSignup`方法可能实际执行的一个示例。当我们经历真正的过程时，你会看到它是如何进行的。现在，我们已经有了其中一个。我们刚刚创建了`saveUser`，所以我们要做的是调用`saveUser`，而不是有第二个注释：
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'It''s not imported just yet, but that''s not going to stop us from calling
    it; we''ll add the import in just a second, and we''ll pass in what it expects,
    the `user` object. Now, we don''t have a `user` object; we have an `email` and
    a `password`. We can create that `user` object by setting `email` equal to the
    `email` argument and setting `password` equal to the `password` argument:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它还没有被导入，但这不会阻止我们调用它；我们将在接下来的一秒钟内添加导入，并传入它所期望的`user`对象。现在，我们没有一个`user`对象；我们有一个`email`和一个`password`。我们可以通过将`email`设置为`email`参数并将`password`设置为`password`参数来创建该`user`对象：
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now one important thing to note: inside ES6, if the property name in an object
    you''re setting is the same as the variable name, you can actually define it like
    this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一件重要的事情要注意：在ES6中，如果你设置的对象中的属性名与变量名相同，你实际上可以这样定义它：
- en: '[PRE72]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this example, since we're setting a `password` property equal to whatever
    on the `password` variable, there's no need to have both. This ES6 syntax also
    allows us to create a much simpler-looking call. There's no need to have it on
    multiple lines since it's pretty reasonable in length.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于我们将`password`属性设置为`password`变量上的任何值，所以没有必要两者都有。这种ES6语法还允许我们创建一个看起来简单得多的调用。由于长度相当合理，所以没有必要将其放在多行上。
- en: 'Now, at the top, we can load in `db` by creating a variable, calling it `db`,
    and setting it equal to `require(''db.js'')`. That is a local file, so we''ll
    start it with a `./` to grab it from the current directory:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在顶部，我们可以通过创建一个变量`db`并将其设置为`require('db.js')`来加载`db`。这是一个本地文件，所以我们将以`./`开头，以从当前目录中获取它：
- en: '[PRE73]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, this is an example of something that we''ll want to test inside our code.
    We have a `handleSignup` method. It takes an `email` and a `password`, and we
    need to make sure that `db.saveUser` works as well. That is a big problem, and
    this means that we''re not just testing `handleSignup`, we are also testing the
    following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是我们想要在我们的代码中测试的一个示例。我们有一个`handleSignup`方法。它接受一个`email`和一个`password`，我们需要确保`db.saveUser`也能正常工作。这是一个大问题，这意味着我们不仅要测试`handleSignup`，还要测试以下内容：
- en: We're testing `handleSignup`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在测试`handleSignup`
- en: We're testing our code that checks if an `email` exists
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在测试我们的代码，检查`email`是否存在
- en: Maybe that allows another function
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许这允许另一个功能
- en: We're checking if the `saveUser` function works as expected
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在检查`saveUser`函数是否按预期工作
- en: we're checking if the welcome email is sent
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在检查欢迎邮件是否已发送
- en: This is a real pain. What we'll do instead is fake the `saveUser` function.
    It's never actually going to execute the code inside it `db`, but it will let
    us verify that when we run `handleSignup`, `saveUser` gets called. We're going
    to do this with something called `spies`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是一个痛苦。我们将做的是伪造`saveUser`函数。它实际上永远不会执行`db`中的代码，但它会让我们验证当我们运行`handleSignup`时，`saveUser`是否被调用。我们将使用一种称为`spies`的东西来做到这一点。
- en: The `spies` function let you swap out a real function such as `saveUser` for
    a testing utility. When that test function gets called we can create various assertions
    about it, making sure it was called with certain arguments. Let's start exploring
    that.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`spies`函数允许您将真实函数（如`saveUser`）替换为测试实用程序。当调用该测试函数时，我们可以对其进行各种断言，确保它是使用特定参数调用的。让我们开始探索一下。'
- en: Creating a test file for spies
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为间谍创建一个测试文件
- en: 'We''ll start it with creating a new file. Inside the `spies` directory, we''ll
    make a new file called `app.test.js`, and we can start playing around with `spies`.
    Now, `spies` comes built-in with `expect`, so all we have to do is load it in:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个新文件开始。在`spies`目录中，我们将创建一个名为`app.test.js`的新文件，然后我们可以开始玩弄`spies`。现在，`spies`是内置在`expect`中的，所以我们只需要加载它：
- en: '[PRE74]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'From here we can create our very first test. We''ll put this in a `describe`
    block so it''s easier to find over in our test output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以创建我们的第一个测试。我们将把它放在一个`describe`块中，这样在我们的测试输出中更容易找到：
- en: '[PRE75]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We''ll call this `describe` block `App` and we''ll add my callback function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称这个`describe`块为`App`，然后我们将添加我的回调函数：
- en: '[PRE76]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we can add individual test cases. First up, we''ll call `it` and make a
    new test where we can just play around with `spies`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加单独的测试用例。首先，我们将调用`it`并创建一个新的测试，我们可以在其中玩弄`spies`：
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We won''t be calling the function in our `app.js` file just yet. We''ll add
    in the `it` object a string say, `Should call the spy correctly`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有在`app.js`文件中调用这个函数。我们将在`it`对象中添加一个字符串，比如，`Should call the spy correctly`：
- en: '[PRE78]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In order to visualize how `spies` work, we'll go through the most basic example
    we can. First up, creating a `spy`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化`spies`的工作原理，我们将通过最基本的例子来进行。首先，创建一个`spy`。
- en: Creating a spy
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个`spy`
- en: 'To create a `spy`, we''ll call a function `expect.createSpy` inside the `it`
    callback function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`spy`，我们将在`it`回调函数中调用一个名为`expect.createSpy`的函数：
- en: '[PRE79]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `createSpy` is going to return a function, and that is the function that
    we''ll swap out for the real one, which means we do want to store that in a variable.
    I''ll create a variable called `spy`, setting it equal to the returned result:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSpy`将返回一个函数，这个函数将替换真实的函数，这意味着我们确实想要将其存储在一个变量中。我将创建一个名为`spy`的变量，将其设置为返回的结果：'
- en: '[PRE80]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And now we would inject `spy` into our code, whether it''s `app.js` or some
    other function, and we would wait for it to get called. We can call it directly
    just like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`spy`注入到我们的代码中，无论是`app.js`还是其他函数，我们都会等待它被调用。我们可以直接像这样调用它：
- en: '[PRE81]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Setting up spies assertions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置间谍断言
- en: Next up, we can set up a series of assertions using expect's spies assertions
    by heading over to the browser and going to the `expect` documentation, mjackson
    expect ([https://github.com/mjackson/expect](https://github.com/mjackson/expect)).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过前往浏览器并转到`expect`文档，mjackson expect ([https://github.com/mjackson/expect](https://github.com/mjackson/expect))，来设置一系列断言。
- en: 'On this page, we can scroll down to the spies section, where they talk about
    all the assertions we have access to. We should start seeing spies in the method
    names, and that''s when we know we''ve gotten there:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们可以向下滚动到间谍部分，他们在那里谈论我们可以访问的所有断言。我们应该开始在方法名称中看到间谍，这时我们就知道我们已经到达那里了：
- en: '&gt;![](img/0311259d-04c6-4edb-93e7-fbe4b349cede.png)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '&gt;![](img/0311259d-04c6-4edb-93e7-fbe4b349cede.png)'
- en: 'As shown in the previous code, we have the `toHaveBeenCalled` function and
    this is our first assertion with spies. We can assert that our `spy` was indeed
    called. Inside Atom, we''ll do that by calling `expect` and passing in the `spy`,
    just like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们有`toHaveBeenCalled`函数，这是我们使用`spies`的第一个断言。我们可以断言我们的`spy`确实被调用了。在Atom中，我们将通过调用`expect`并传入`spy`来做到这一点，就像这样：
- en: '[PRE82]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then, we''ll add the assertion, `toHaveBeenCalled`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加断言`toHaveBeenCalled`：
- en: '[PRE83]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This will cause the test to pass if `spy` was called, which it was, and it''ll
    cause the test to fail if the `spy` was never called. We can run the test suite
    inside the Terminal using the `npm run test-watch` command, and this is going
    to kick off the tests using `nodemon`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`spy`被调用，这将导致测试通过，如果`spy`从未被调用，这将导致测试失败。我们可以使用`npm run test-watch`命令在终端中运行测试套件，这将使用`nodemon`启动测试：
- en: '![](img/33d05e07-6245-4e92-a744-5563a2d22312.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33d05e07-6245-4e92-a744-5563a2d22312.png)'
- en: As shown in the previous screenshot, we have all our test cases, and under the
    `App` one, we have `should call the spy correctly`. It did indeed pass, which
    is fantastic.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们有所有的测试用例，在`App`下面，我们有`should call the spy correctly`。它确实通过了，这太棒了。
- en: 'Now let''s comment out the line where I call `spy`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们注释掉我调用`spy`的那一行：
- en: '[PRE84]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And this time around, the test should fail because `spy` was never actually
    called, and as shown in the following screenshot, we see `spy was not called`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次测试应该失败，因为`spy`实际上从未被调用，如下截图所示，我们看到`spy was not called`：
- en: '![](img/69b6fdcc-3963-40fa-95b5-6e75ecafce77.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69b6fdcc-3963-40fa-95b5-6e75ecafce77.png)'
- en: More details out of spy assertion
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间谍断言的更多细节
- en: 'Now, checking if a `spy` was called or not called is great, but we can get
    even more detail out of our assertions. For example, what if I call the `spy`
    with the name `Andrew` and the age `25`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查`spy`是否被调用或未被调用是很好的，但我们可以从我们的断言中获得更多细节。例如，如果我用名字`Andrew`和年龄`25`来调用`spy`，会发生什么：
- en: '[PRE85]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, we want to verify if the `spy` was not just called but was called with
    these arguments? Well, luckily, we have an assertion for that too. Instead of
    `toHaveBeenCalled`, we can call `toHaveBeenCalledWith`, and this lets us pass
    in some arguments and verify the `spy` was indeed called with those arguments.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要验证`spy`不仅仅是被调用了，而且是被调用了这些参数？幸运的是，我们也有一个断言。我们可以调用`toHaveBeenCalledWith`，这样我们就可以传入一些参数并验证`spy`确实是用这些参数被调用的。
- en: 'As shown in the following code, we''ll assert that my `spy` was called with
    `Andrew` and the number `25`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，我们将断言我的`spy`是否被调用，并且传入了`Andrew`和数字`25`：
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'When we save the file and the test cases restart, we should see all the tests
    passing, and that''s exactly what we get:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存文件并重新启动测试用例时，我们应该看到所有的测试都通过了，这正是我们得到的：
- en: '![](img/9ae4a79e-ed08-452a-b700-444efee2ad00.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ae4a79e-ed08-452a-b700-444efee2ad00.png)'
- en: 'Now, if the `spy` was not called with the mentioned data, I''ll remove `25`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`spy`没有用提到的数据被调用，我将删除`25`：
- en: '[PRE87]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now if we rerun the test suite, the test will fail. It will give you an error
    message letting you know that `spy was never called with [ 'Andrew', 25 ]`. This
    is causing the test to fail, which is fantastic.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新运行测试套件，测试将失败。它将给出一个错误消息，让你知道`spy was never called with [ 'Andrew',
    25 ]`。这导致了测试失败，这很棒。
- en: 'There are plenty of other assertions we can use with our spies. You can find
    them in the `expect` docs. We have `toHaveBeenCalled`, which we used; `toNotHaveBeenCalled`,
    verifying that a `spy` was not called. Then we have `toHaveBeenCalledWith`, which
    we also used. You can see there''s a lot more to spies as well: how to create
    spies, which we''ve already done, and a few other methods.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的`spy`进行许多其他断言。你可以在`expect`文档中找到它们。我们有`toHaveBeenCalled`，我们使用了；`toNotHaveBeenCalled`，验证`spy`是否未被调用。然后我们有`toHaveBeenCalledWith`，我们也使用了。你还可以看到`spy`还有很多其他功能：如何创建`spy`，我们已经做过了，还有一些其他方法。
- en: Swapping of the function with spy
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数与间谍交换
- en: For our purposes, we need a spy so we can simulate that function inside of `app.js`
    (`saveUser`). We need a way to replace `saveUser` function with a `spy`. Then
    we can verify that when `handleSignup` gets called, it does indeed call `saveUser`.
    It doesn't need to actually go through the process over in `db.js`; this is not
    important to our tests. The only thing that is important is that the function
    was called with the correct arguments.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们需要一个间谍，这样我们就可以在`app.js`（`saveUser`）内模拟该函数。我们需要一种方法来用`spy`替换`saveUser`函数。然后我们可以验证当`handleSignup`被调用时，它确实调用了`saveUser`。它不需要实际经过`db.js`中的过程；这对我们的测试不重要。唯一重要的是函数是否以正确的参数被调用。
- en: To do that, we'll look at an npm module called `rewire`, which lets us swap
    out variables for our tests. In our case, in our test file, we'll be able to replace
    the `db` object with something else completely. Then, when the code runs, instead
    of calling `db.saveUser` as defined in `app.js`, it will be calling `db.saveUser`,
    which will be a `spy`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将看看一个名为`rewire`的npm模块，它允许我们在测试中交换变量。在我们的情况下，在我们的测试文件中，我们将能够完全用其他东西替换`db`对象。然后，当代码运行时，而不是调用`app.js`中定义的`db.saveUser`，它将调用`db.saveUser`，这将是一个`spy`。
- en: Installing and setting up the rewire function
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和设置rewire函数
- en: 'To get started, we do need to install `rewire` in the Terminal. It''s a fantastic
    test utility. It''s pretty essential for testing functions with side effects,
    like the one we have seen in this section. Let''s run `npm install`. The module
    name itself is called `rewire`, and we''ll be grabbing the most recent version
    as of this filming, version `@3.0.2`. This is a test-specific module. We''ll not
    need it for our application to run regularly, so we will be using the `--save-dev`
    flag to add it to our `package.json` dependencies list:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们确实需要在终端中安装`rewire`。这是一个很棒的测试工具。对于测试具有副作用的函数，就像我们在本节中看到的那样，它非常重要。让我们运行`npm
    install`。模块名称本身称为`rewire`，我们将根据此次拍摄的最新版本`@3.0.2`来获取。这是一个专门用于测试的模块。我们不需要它来正常运行我们的应用程序，所以我们将使用`--save-dev`标志将其添加到我们的`package.json`依赖列表中：
- en: '[PRE88]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '![](img/772b3e90-b3e7-4f24-abdf-7a844dcbde72.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/772b3e90-b3e7-4f24-abdf-7a844dcbde72.png)'
- en: 'Once the module is installed we can get started using it, and it''s pretty
    simple to set up. Inside `app.test.js` we can start by loading it in. Up at the
    very top, we''ll create a new constant. This one will be called `rewire`, and
    we''ll set it equal to the returned result from requiring `rewire`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 模块安装后，我们可以开始使用它，设置起来非常简单。在`app.test.js`内，我们可以开始加载它。在顶部，我们将创建一个新的常量。这个将被称为`rewire`，我们将其设置为从`rewire`中要求的返回结果：
- en: '[PRE89]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Replacing db with the spy
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用spy替换db
- en: 'Now, the way that `rewire` works is it requires you to use `rewire` instead
    of require when you''re loading in the file that you want to mock out. For this
    example, we want to replace `db` with something else, so when we load an `app`
    we have to load it in in a special way. We''ll make a variable called `app`, and
    we''ll set it equal to `rewire` followed by what we would usually put inside of
    `require`. In this case it''s a relative file, a file that we created `./app`
    will get the job done:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`rewire`的工作方式是，当你加载要模拟的文件时，它要求你使用`rewire`而不是`require`。在这个例子中，我们想要用其他东西替换`db`，所以当我们加载`app`时，我们必须以特殊的方式加载它。我们将创建一个名为`app`的变量，并将其设置为`rewire`，然后是我们通常放在`require`内的内容。在这种情况下，它是一个相对文件，我们创建的文件`./app`就可以完成任务：
- en: '[PRE90]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now rewire loads your file through require, but it also adds two methods onto
    `app`. These methods are:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，rewire通过require加载你的文件，但它还在`app`上添加了两个方法。这些方法是：
- en: '`app.__set__`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.__set__`'
- en: '`app.__get__`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.__get__`'
- en: We can use these to mock out various data inside of `app.js`. That means we'll
    make a simulation of the `db` object, the one that comes back from `db.js`, but
    we'll swap out the function with a `spy`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些来模拟`app.js`内的各种数据。这意味着我们将模拟`db`对象，即从`db.js`返回的对象，但我们将用`spy`替换函数。
- en: 'Inside our `describe` block, we can kick things off by making a variable. This
    variable is going to be called `db`, and we''ll set it equal to an object:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`describe`块内，我们可以通过创建一个变量来开始。这个变量将被称为`db`，我们将其设置为一个对象：
- en: '[PRE91]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The only thing we need to mock out in our case is `saveUser`. Inside the object,
    we''ll define `saveUser` and then I''ll set it equal to a `spy` by creating one
    using `expect.createSpy`, just like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们唯一需要模拟的是`saveUser`。在对象内，我们将定义`saveUser`，然后将其设置为`spy`，通过使用`expect.createSpy`来创建一个，就像这样：
- en: '[PRE92]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now we have this `db` variable, and the only thing left to do is replace it.
    We do that using `app.__set__`, and this is going to take two arguments:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个`db`变量，唯一剩下的事情就是替换它。我们使用`app.__set__`来做到这一点，它将需要两个参数：
- en: '[PRE93]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The first one is the thing you want to replace. We''re trying to replace `db`,
    and we''re trying to replace it with the `db` variable, which is our object that
    has the `saveUser` function:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是你想要替换的东西。我们试图替换`db`，并试图用`db`变量替换它，这是我们的对象，其中有`saveUser`函数：
- en: '[PRE94]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: With that in place, we can now write a test that verifies that `handleSignup`
    does indeed call `saveUser`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以编写一个测试，验证`handleSignup`确实调用了`saveUser`。
- en: Writing a test to verify swapping of the function
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个测试来验证函数的交换
- en: 'To verify if `handleSignup` calls `saveUser`, inside `app.test.js`, we''ll
    call `it`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证`handleSignup`是否调用了`saveUser`，在`app.test.js`中，我们将调用`it`：
- en: '[PRE95]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Then we can pass in our function, and this is what will actually run when the
    test gets executed, and there''s no need to use any asynchronous done arguments.
    This will be a synchronous test for now:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以传入我们的函数，这将在测试执行时实际运行，不需要使用任何异步的done参数。这将是一个同步测试：
- en: '[PRE96]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Inside the callback function, we can come up with an `email` and a `password`
    that we''ll pass in to `handleSignup` in `db.js`. We''ll make a variable called
    `email` setting it equal to some email `andrew@example.com`, and we can do the
    same thing with the `password`, `var password`; we''ll set that equal to `123abc`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，我们可以想出一个`email`和一个`password`，然后将它们传递给`db.js`中的`handleSignup`。我们将创建一个名为`email`的变量，将其设置为某个邮箱`andrew@example.com`，然后我们可以用`password`做同样的事情，`var
    password`；我们将把它设置为`123abc`：
- en: '[PRE97]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Next up, we will call `handleSignup`. This is the function we want to test.
    We''ll call `app.handleSignup`, passing in our two arguments, `email` and `password`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用`handleSignup`。这是我们想要测试的函数。我们将调用`app.handleSignup`，传入我们的两个参数，`email`和`password`：
- en: '[PRE98]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now at this point, `handleSignup` will get executed. This means that the code
    over here will run and it will fire `db.saveUser`, but `db.saveUser` is not the
    method in `db.js`; it's a `spy` instead, which means we can now use those assertions
    we just learned about.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这一点上，`handleSignup`将被执行。这意味着这里的代码将运行，并且它将触发`db.saveUser`，但`db.saveUser`不是`db.js`中的方法；它是一个`spy`，这意味着我们现在可以使用我们刚学到的那些断言。
- en: 'Inside of the test case, we''ll use `expect` to `expect` something about `db`;
    the variable `.saveUser`, which we set equal to a `spy`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试用例中，我们将使用`expect`来期望关于`db`的某些内容；我们将变量`.saveUser`设置为一个`spy`：
- en: '[PRE99]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We''ll call `.toHaveBeenCalledWith` with an object because that is what `db.js`
    should have been called with. We''ll use that same ES6 shortcut: `email`, `password`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个对象调用`.toHaveBeenCalledWith`，因为这是`db.js`应该被调用的方式。我们将使用相同的ES6快捷方式：`email`，`password`：
- en: '[PRE100]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This creates an `email` attribute set to the `email` variable, and a `password`
    attribute set to the `password` variable. With this in place, we can now save
    our test file, and in the Terminal we can restart the `test-watch` script by using
    the up arrow key twice to rerun our `npm run test-watch` command. This is going
    to kick off our test suite, starting up all of our tests:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`email`属性，设置为`email`变量，并创建一个`password`属性，设置为`password`变量。有了这个设置，我们现在可以保存我们的测试文件，在终端中，我们可以使用上箭头键两次重新运行`npm
    run test-watch`命令来重新启动`test-watch`脚本。这将启动我们的测试套件，开始所有的测试：
- en: '![](img/62d3796d-0000-4bab-882f-4b588b6d3ad5.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62d3796d-0000-4bab-882f-4b588b6d3ad5.png)'
- en: As shown in the previous screenshot, we see `should call the spy correctly`
    passes. Also, the test case we just created also passes. We can see `should call
    saveUser with the user object`, and this is fantastic. We now have a way to test
    pretty much anything inside Node. We can even test functions that call other functions,
    verifying that the communication happens as expected. All of this can be done
    using spies.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们看到`should call the spy correctly`通过了。同时，我们刚刚创建的测试用例也通过了。我们可以看到`should
    call saveUser with the user object`，这太棒了。我们现在有一种方法可以测试几乎任何Node中的东西。我们甚至可以测试调用其他函数的函数，验证通信是否如预期发生。所有这些都可以使用spy来完成。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked into testing the Express applications as we did with
    the synchronous and async Node applications in the previous chapter. Then, we
    worked on organizing our tests with the `describe()` object so that we can see
    our different test methods right away.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了如何测试Express应用程序，就像在上一章中对同步和异步Node应用程序进行测试一样。然后，我们使用`describe()`对象组织我们的测试，以便我们可以立即看到不同的测试方法。
- en: In the last section we explored one more way we can test our Node applications,
    that is, spies. We created test files for spies, looked into the `spy` assertions
    and swapping of a function with `spy`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了另一种测试Node应用程序的方法，即spy。我们为spy创建了测试文件，研究了`spy`断言和使用`spy`交换函数。
- en: Conclusion
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: That's the end of the book! Through the course of is book, you learned the fundamentals
    of Node.js so that you test and deploy Node.js applications on the web. We hope
    that you liked the journey this book has taken you through. We wish you all the
    success and hope that you continue to better your Node.js applications.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是书的结尾！在本书的过程中，您学习了Node.js的基础知识，以便在网络上测试和部署Node.js应用程序。我们希望您喜欢本书带您走过的旅程。我们祝愿您一切成功，并希望您继续改进您的Node.js应用程序。
