- en: Testing an MEVN Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试MEVN应用
- en: 'Let''s do a quick recap of what we have done so far in previous chapters:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下在前几章中我们已经做了什么：
- en: We created different Vue components for different pages
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为不同的页面创建了不同的Vue组件
- en: We implemented Vuex—centralized state management for Vue.js applications, and
    defined state, getters, mutations, and actions for the components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了Vuex——Vue.js应用的集中式状态管理，并为组件定义了状态、获取器、突变和动作
- en: We created controllers and models to interact with the Node.js backend
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了控制器和模型来与Node.js后端交互
- en: In this chapter, we will discuss how to write test code to make sure that everything
    in the application works well. Writing test code is an integral part of any application.
    It helps to ensure that the functionalities that we have written do not break,
    and maintains the quality of the code we write.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何编写测试代码以确保应用中的所有内容都能正常工作。编写测试代码是任何应用的组成部分。它有助于确保我们编写的功能不会崩溃，并保持我们编写代码的质量。
- en: Different practices can be followed while writing tests. It's always a good
    practice to write test code first, before writing the actual code. Writing tests
    ensures that our application will not break and everything will work as expected.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时可以遵循不同的实践。始终先编写测试代码，然后再编写实际代码是一个好习惯。编写测试代码确保我们的应用不会崩溃，并且一切都会按预期工作。
- en: This helps us to write better code and also helps to reveal the potential problems
    before they arise.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们编写更好的代码，也有助于在问题出现之前揭示潜在的问题。
- en: Benefits of writing tests
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试的好处
- en: 'Writing test code when developing an application has a lot of benefits. Some
    of them are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用时编写测试代码有很多好处。以下是一些：
- en: '**Ensures code works as expected**: It helps to ensure that each piece of functionality
    that we have written in our application works exactly as expected.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保代码按预期工作**：它有助于确保我们应用中编写的每一块功能都按预期工作。'
- en: '**Improves the quality of code**: It improves the quality of code. Since writing
    test code helps to  pre-empt defects that may arise, before we write actual code,
    it improves the quality of the code.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码质量**：它提高了代码质量。由于编写测试代码有助于预防可能出现的缺陷，因此在编写实际代码之前，它提高了代码的质量。'
- en: '**Identifies bugs beforehand**: It helps to identify bugs in the early stages.
    Since test code is written for every functionality, bugs and issues can be identified
    early.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提前识别bug**：它有助于在早期阶段识别bug。由于为每个功能编写了测试代码，因此可以提前识别bug和问题。'
- en: '**Serves as documentation for new developers**: Test code is like documentation.
    If we need new developers to start work on the same application, test code helps
    them to understand how the application works instead of going through all the
    application code.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为新开发者的文档**：测试代码就像文档一样。如果我们需要新开发者开始在同一应用上工作，测试代码帮助他们理解应用是如何工作的，而不是通过所有应用代码。'
- en: '**Application development is faster with test code**: If we write code without
    the test code, we will code faster. However, if we skip the process, we will later
    spending most of our time later fixing the bugs that will start to crawl in, which
    could have been identified earlier with the test code.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试代码使应用开发更快**：如果我们不编写测试代码，我们会更快地编写代码。然而，如果我们跳过这个过程，我们后来会花费大部分时间来修复开始爬入的bug，而这些bug本可以用测试代码提前识别出来。'
- en: '**Application doesn''t need to be run**: Writing test code and running it doesn''t
    require the application to be up and running. It also doesn''t require the application
    to be built either. This reduces the development time significantly.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用无需运行**：编写测试代码并运行它不需要应用处于运行状态。它也不需要构建应用。这显著减少了开发时间。'
- en: 'So, in this chapter, we will discuss the following topics:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将讨论以下主题：
- en: Learn why and how to write unit tests and end-to-end tests
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习为什么以及如何编写单元测试和端到端测试
- en: Learn about the technologies for writing test code for a Vue.js and Node.js
    application
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解为Vue.js和Node.js应用编写测试代码的技术
- en: Modify our application's structure to implement unit and end-to-end code
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改我们的应用结构以实现单元和端到端代码
- en: Write test code for Vue components
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Vue组件编写测试代码
- en: Introduction to unit tests
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试简介
- en: Unit testing is a software development process in which the smallest functionality
    of the application is tested and examined to check whether it works as expected
    or not. A unit is the smallest part of any application. Every test code written
    for a unit of an application is independent of each other. The goal of unit testing
    itself is to perform an individual tests and make sure that each piece is correct.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种软件开发过程，其中测试并检查应用程序的最小功能是否按预期工作。单元是任何应用程序的最小部分。为应用程序的每个单元编写的测试代码都是相互独立的。单元测试本身的目标是执行单个测试并确保每个部分都是正确的。
- en: Convention for writing unit tests
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试的约定
- en: 'If you follow certain guidelines and principles while writing unit tests, it
    makes your code maintainable and readable. The following are a few techniques
    that we can use while writing unit tests for any application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编写单元测试时遵循某些指南和原则，这将使你的代码易于维护和阅读。以下是一些我们可以在为任何应用程序编写单元测试时使用的技巧：
- en: Unit testing should be carried out in small units—for a single class or a method.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应该在小的单元中进行——针对单个类或方法。
- en: Unit testing should be carried out in isolation, meaning that a unit test should
    not be dependent on any other classes or methods, which is achieved by mocking
    such dependencies.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应在隔离状态下进行，这意味着单元测试不应依赖于任何其他类或方法，这通过模拟这些依赖关系来实现。
- en: Since unit testing is done in smaller parts, these should be very lightweight,
    which makes the tests run faster.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于单元测试是在较小的部分中进行的，因此它们应该非常轻量级，这使得测试运行得更快。
- en: A unit test should test the behavior of a unit of an application. It should
    expect a certain value and return a certain output.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试应测试应用程序单元的行为。它应期望一个特定的值并返回一个特定的输出。
- en: Since unit tests are done in isolation, the ordering of tests for different
    units does not create a problem.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于单元测试是在隔离状态下进行的，因此不同单元的测试顺序不会造成问题。
- en: Follow **Do not Repeat Yourself** (**DRY**); the code should not be repeatable.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循**不要重复自己**（**DRY**）的原则；代码不应该可重复。
- en: Add comments explaining where you can, which explains the why part of the test
    so that it is understandable.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的地方添加注释，解释测试的“为什么”，以便它易于理解。
- en: An introduction to end-to-end test
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试简介
- en: End-to-end testing is the testing of our application from start to finish. Where
    as unit testing tests whether the functionalities of your application work independently
    or not—end-to-end testing checks whether the flow of the application is performing
    as expected or not. Usually, the end-to-end testing makes sure that all the user
    interactions are carried out the way as expected. End-to-end testing ensures that
    the flow of the application is working as expected.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是从头到尾测试我们的应用程序。而单元测试测试的是应用程序的功能是否独立工作——端到端测试检查应用程序的流程是否按预期执行。通常，端到端测试确保所有用户交互都按预期进行。端到端测试确保应用程序的流程按预期工作。
- en: Convention for writing end-to-end tests
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写端到端测试的约定
- en: 'There are certain guidelines to be followed when writing the end-to-end tests:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编写端到端测试时有一些需要遵循的指南：
- en: Test cases should be written considering the end users and considering the real
    scenario
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试用例时应考虑最终用户和实际场景
- en: Multiple test cases should be created for different scenarios
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应为不同的场景创建多个测试用例
- en: The requirements should be gathered for all the software or applications that
    are involved
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应为所有涉及的软件或应用程序收集需求
- en: For each requirement, gather as many conditions or scenarios as possible
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个需求，尽可能收集尽可能多的条件或场景
- en: Write separate test cases for each scenario
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个场景编写单独的测试用例
- en: Technologies we will be using
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将使用的技术
- en: 'Here are some of the packages that we will be working with to write the tests
    for our application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们将用于编写应用程序测试的包：
- en: '**Mocha**: A JavaScript test framework to write unit testing ([https://mochajs.org/](https://mochajs.org/))'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mocha**：一个用于编写单元测试的JavaScript测试框架 ([https://mochajs.org/](https://mochajs.org/))'
- en: '**Chai**: An assertion library for the Node.js framework ([http://chaijs.com/](http://chaijs.com/))'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chai**：Node.js框架的断言库 ([http://chaijs.com/](http://chaijs.com/))'
- en: '**Sinon**: `sinon` is for test spies, stubs, and mocks ([http://sinonjs.org/](http://sinonjs.org/))'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sinon**：`sinon`用于测试间谍、存根和模拟 ([http://sinonjs.org/](http://sinonjs.org/))'
- en: '**Nightwatch**: A JavaScript library for writing end-to-end tests ([http://nightwatchjs.org/](http://nightwatchjs.org/))'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nightwatch**：一个用于编写端到端测试的JavaScript库 ([http://nightwatchjs.org/](http://nightwatchjs.org/))'
- en: '**Karma**: `karma` is the test runner for JavaScript ([https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html))'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Karma**：`karma`是JavaScript的测试运行器([https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html))'
- en: We will discuss each of these technologies as we go along.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在学习过程中讨论这些技术。
- en: Introducing Mocha
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Mocha
- en: 'Let''s create a separate working directory to learn to write tests. Create
    a folder called `test_js`  and switch to the `test_js` directory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个单独的工作目录来学习编写测试。创建一个名为`test_js`的文件夹，并切换到`test_js`目录：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s also create a separate folder for `test` inside the `test_js` folder:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`test_js`文件夹内创建一个名为`test`的单独文件夹：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To access `mocha`, you have to install it globally:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`mocha`，您必须全局安装它：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's write a simple test code in `mocha`. We will write a test for a simple
    function, which takes two arguments and returns the sum of the arguments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`mocha`中编写一个简单的测试代码。我们将为简单的函数编写一个测试，该函数接受两个参数并返回参数的和。
- en: 'Let''s create a file called `add.spec.js` inside the `test` folder and add
    the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`test`文件夹内创建一个名为`add.spec.js`的文件，并添加以下代码：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, run the following command from the `test_js` folder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从`test_js`文件夹中运行以下命令：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This test will fail, and we will require a utility called `add.js`, which does
    not exist. It displays the following error:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试将失败，我们需要一个名为`add.js`的工具，它不存在。它显示以下错误：
- en: '![](img/7fb7cc82-8cec-40c1-8d5f-584929a7e921.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fb7cc82-8cec-40c1-8d5f-584929a7e921.png)'
- en: 'Let''s go ahead and write just enough code to pass the test. Create a file
    called `add.js` in the root of the `test_js` project and run the code again, which
    should pass:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写足够的代码来通过测试。在`test_js`项目的根目录下创建一个名为`add.js`的文件，然后再次运行代码，应该可以通过：
- en: '![](img/4fb775f9-cbe4-48e8-bfec-babd34f2c394.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fb775f9-cbe4-48e8-bfec-babd34f2c394.png)'
- en: 'Let''s go ahead and add the logic to the test code to check our `add` function.
    In `add.spec.js`, add the following lines of code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续给测试代码添加逻辑来检查我们的`add`函数。在`add.spec.js`中，添加以下代码行：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now comes the `assert` library. The `assert` library helps to check whether
    the passed expression is right or wrong. Here, we will use the built-in assertion
    library for Node.js.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`assert`库的时间。`assert`库有助于检查传递的表达式是正确还是错误。在这里，我们将使用Node.js的内置断言库。
- en: 'To include the `assert` library, let''s add the following lines of code in
    `add.spec.js`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含`assert`库，让我们在`add.spec.js`中添加以下代码行：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s rerun `mocha`. This should again fail, because we haven''t added a method
    to our module. So, let''s go ahead and do that.  In `add.js`, let''s add the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新运行`mocha`。这应该再次失败，因为我们还没有向我们的模块添加方法。所以，让我们继续并添加以下代码到`add.js`中：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s rerun `mocha`. The spec should pass now:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新运行`mocha`。现在应该可以通过测试了：
- en: '![](img/1e2c62a1-ff29-41b8-a5d3-13c0548354fe.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e2c62a1-ff29-41b8-a5d3-13c0548354fe.png)'
- en: 'Now, let''s add the functional part to the sum method. In `add_spec.js`, add
    the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将功能部分添加到求和方法中。在`add_spec.js`中添加以下代码：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, take a look at the test; it fails. Then, add the logic to our module:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，看看测试；它失败了。然后，向我们的模块中添加逻辑：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, rerun `mocha` and the test should pass. That''s it!:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新运行`mocha`，测试应该可以通过。就这样！：
- en: '![](img/031b7203-8a24-4c76-a0ea-cfa3dcfb0996.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/031b7203-8a24-4c76-a0ea-cfa3dcfb0996.png)'
- en: You can go on adding a few more cases to the test to ensure that nothing breaks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续添加更多测试案例以确保没有东西出错。
- en: Introducing chai
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍chai
- en: Let's discuss `chai`. `chai` is an assertion library, used with `mocha`. We
    could also use the native `assertion` library , but `chai` adds a lot of flexibility.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论`chai`。`chai`是一个断言库，与`mocha`一起使用。我们也可以使用本地的`assertion`库，但`chai`提供了更多的灵活性。
- en: '`chai` makes it a lot easier to write test definitions. Let''s install `chai`
    and modify the preceding test to make it look more simple and easy to understand:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`chai`使编写测试定义变得容易得多。让我们安装`chai`并修改前面的测试，使其看起来更简单易懂：'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We passed the `-g` option to install it globally, since we do not have a `package.json`
    configuration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了`-g`选项来全局安装它，因为我们没有`package.json`配置。
- en: 'Let''s use `chai` in our previous test. In `add.spec.js`, add the following
    lines of code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前的测试中使用`chai`。在`add.spec.js`中，添加以下代码行：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have replaced the `assertion` library with, `chai` `expect()` method, which
    makes the code very much simpler and understandable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`assertion`库替换为`chai`的`expect()`方法，这使得代码更加简单易懂。
- en: Introducing sinon
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍sinon
- en: '`sinon` is used to test spies, stubs, and mocks for JavaScript tests. To learn
    about these, let''s move on to the movie rating application we have in our `controller`
    file, `controller/movies.js`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinon` 用于测试 JavaScript 测试中的 spies、stubs 和 mocks。为了了解这些，让我们继续学习我们 `controller`
    文件 `controller/movies.js` 中的电影评分应用程序：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, each API call needs a request and a response object,
    which we need to mock. For this purpose, we have `sinon`. `sinon` provides us with
    a mechanism to `stub` and `mock` the requests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每个 API 调用都需要一个请求和一个响应对象，我们需要对其进行模拟。为此，我们使用了 `sinon`。`sinon` 提供了一种机制来
    `stub` 和 `mock` 请求。
- en: 'The three major methods that `sinon` provides are spies, stubs, and mocks:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinon` 提供的三个主要方法是 spies、stubs 和 mocks：'
- en: '**Spies**: Spies helps to create fake functions. We can use spies to track
    whether the functions are executed or not.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍（Spies）**：间谍有助于创建假函数。我们可以使用间谍来跟踪函数是否被执行。'
- en: '**Stubs**: Stubs helps us to make functions return whatever we want. This is
    useful when we want to test different scenarios for the given function.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根（Stubs）**：存根帮助我们使函数返回我们想要的任何内容。当我们想要测试给定函数的不同场景时，这很有用。'
- en: '**Mocks**: Mocks are used to fake network connections. They help to create
    a dummy class instance, which helps to set the predetermined expectations.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟（Mocks）**：模拟用于伪造网络连接。它们帮助我们创建一个模拟的类实例，这有助于设定预定的期望。'
- en: 'Let''s write a test for a `get` call in the `movies` controller:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `movies` 控制器中编写一个 `get` 调用的测试：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a new file, called `movies.spec.js`, inside the `test/units`
    folder:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `test/units` 文件夹内创建一个新文件，称为 `movies.spec.js`：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This test code simply checks whether the `controller` exists or not, which
    should pass when we run the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段测试代码简单地检查 `controller` 是否存在，当我们运行以下命令时应该通过：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command runs the tests for our `controller/movies.js` and should pass
    with the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令运行我们的 `controller/movies.js` 的测试，并且应该通过以下输出：
- en: '![](img/19083b7c-1469-4580-99ad-672027db64f7.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19083b7c-1469-4580-99ad-672027db64f7.png)'
- en: 'Let''s first write a test for a simple method. Let''s create a request that
    responds with just an object with a name. In `movies.js`,  let''s add the following
    code to create a dummy API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为这个简单的方法写一个测试。让我们创建一个只响应一个具有名称的对象的请求。在 `movies.js` 中，让我们添加以下代码来创建一个模拟的API：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we have a simple method that returns an object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个简单的返回对象的函数。
- en: Let's move on to add the functional test part. We will be writing the test for
    the `/dummy_test` method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加功能测试部分。我们将为 `/dummy_test` 方法编写测试。
- en: 'In `movies.spec.js`, let''s add the following lines of code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `movies.spec.js` 中，让我们添加以下代码行：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we have added a new package called `chai-http`, which
    is used to mock the request. Let''s install this package, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个名为 `chai-http` 的新包，用于模拟请求。让我们按照以下方式安装此包：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s now run the test with the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在使用以下命令运行测试：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding command should give us the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该给出以下输出：
- en: '![](img/f7e5559c-b74b-43cb-ab62-d6998504a05a.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7e5559c-b74b-43cb-ab62-d6998504a05a.png)'
- en: Writing tests for Node.js server
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Node.js 服务器的测试
- en: Let's start writing the tests for the application we built for the backend part
    of the `node` server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为后端部分的 `node` 服务器构建的应用程序编写测试开始。
- en: 'We will be using the following folder structure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下文件夹结构：
- en: '![](img/d12847d5-9326-47f1-a4c8-c06f8178230f.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d12847d5-9326-47f1-a4c8-c06f8178230f.png)'
- en: There are two folders inside the `test` folder. One for unit testing, called
    `unit`, and another for end-to-end testing, called `e2e`. We will start by writing
    the unit tests, which go under the `unit` directory. The naming convention is
    appending the `.spec` part to the filename for every file we will be writing tests
    for.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test` 文件夹内有两个文件夹。一个用于单元测试，称为 `unit`，另一个用于端到端测试，称为 `e2e`。我们将从编写单元测试开始，这些测试将放在
    `unit` 目录下。命名约定是给每个我们将为其编写测试的文件添加 `.spec` 部分。
- en: Writing tests for controllers
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写控制器的测试
- en: 'Let''s get started with writing tests for the controllers we added. Create
    a folder called `controllers` inside the `test/unit/specs` and create a new file
    inside it called `movies.spec.js`. This will be the naming convention that we
    will follow while creating the test files for any components: controllers, models,
    or Vue components—the actual filename followed by `.spec.js`. This helps to maintain
    the readability of the code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写我们添加的控制器测试开始。在`test/unit/specs`中创建一个名为`controllers`的文件夹，并在其中创建一个名为`movies.spec.js`的新文件。这将是我们创建任何组件（控制器、模型或Vue组件）测试文件时遵循的命名约定：实际的文件名后跟`.spec.js`。这有助于保持代码的可读性。
- en: 'Let''s first recap what we have in our `movies.js` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下`movies.js`文件中有什么：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This controller has two methods—one GET request and a POST request. The GET
    request is for fetching all the movies from the database, and the POST request saves
    the movies with the given parameters to the database.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器有两个方法——一个GET请求和一个POST请求。GET请求用于从数据库中获取所有电影，而POST请求将带有给定参数的电影保存到数据库中。
- en: 'Let''s move on to adding the spec for the GET request first. Add the following
    contents in the `movies.spec.js` file that we just created:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加GET请求的规范。在刚刚创建的`movies.spec.js`文件中添加以下内容：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first two lines required the corresponding controller and model for the `Movie`
    component, which we will need later. We will also require the server file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行需要相应的`Movie`组件控制器和模型，我们稍后会用到。我们还需要服务器文件。
- en: The other packages, such as `chai`, `sinon`, `expect`, and `should`, are needed
    for the assertions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其他包，如`chai`、`sinon`、`expect`和`should`，也是为了断言所需的。
- en: 'The next thing that we will need to make requests to the server is a package
    called `chai-http`.  This package will be used for HTTP request assertions. So,
    let''s install this package first with the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个名为`chai-http`的包来向服务器发送请求。这个包将用于HTTP请求断言。所以，让我们首先使用以下命令安装这个包：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can get ahead with adding the first test. Replace the contents in `movies.spec.js`
    with the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始添加第一个测试。用以下代码替换`movies.spec.js`中的内容：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding method describes the `movies` controller. It simply checks whether
    the controller we are describing exists or not.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法描述了`movies`控制器。它只是简单地检查我们描述的控制器是否存在。
- en: 'To make sure we have the connection of our `node` server, let''s export the
    server from `server.js`. Add the following code into `server.js`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的`node`服务器有连接，让我们从`server.js`导出服务器。将以下代码添加到`server.js`中：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s run the test using the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令运行测试：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The test should pass.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该通过。
- en: 'Let''s move on to adding the test for the GET request. In `movies.js`, we have
    the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加GET请求的测试。在`movies.js`中，我们有以下代码：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since this method fetches all the existing movies from the database, we will
    first need to build the mock movies here to actually test it. Let''s replace the
    contents of `movies.spec.js` with the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个方法是从数据库中获取所有现有电影，我们首先需要在这里构建模拟电影来实际测试它。让我们用以下代码替换`movies.spec.js`中的内容：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s learn step by step what we did here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地了解我们在这里做了什么：
- en: We created a couple of movies with `sinon` mocks
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`sinon`模拟创建了一些电影。
- en: We created an HTTP GET request using `chai`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`chai`创建了一个HTTP GET请求
- en: 'We had three expectations:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有三个期望：
- en: The status of the request should be `200`
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的状态应该是`200`
- en: The request response should be an object
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求响应应该是一个对象
- en: The response should contain the list of movies that we created with the mock
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应应包含我们使用模拟创建的电影列表。
- en: 'Let''s run the test again with the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用以下命令运行测试：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The tests should pass.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该通过。
- en: 'Let''s now move on to add the tests for the POST request for `movies.js`. In
    `movies.js`, here is what we have so far:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续添加`movies.js`的POST请求测试。在`movies.js`中，我们有以下代码：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The POST method takes the preceding four attributes of the movie and saves
    them to the database. Let''s add the test for this POST request. Replace the contents
    of `movies.spec.js` with the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: POST方法接受电影的前四个属性并将它们保存到数据库中。让我们为这个POST请求添加测试。用以下代码替换`movies.spec.js`中的内容：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, in the preceding code block, what we have done is, for the POST request:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们所做的是，对于POST请求：
- en: 'We are sending the POST request with movie parameters: `name`, `description`,
    `release_year`, and `genre`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用电影参数：`name`、`description`、`release_year`和`genre`发送POST请求。
- en: 'We had three expectations:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有三个预期：
- en: The status of the request should be `200`
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的状态应该是`200`
- en: The request response should be an object
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求响应应该是一个对象
- en: The response should contain all four attributes, along with the ID of the movie
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应应该包含所有四个属性，以及电影的ID
- en: Now if we run the tests again, they should all pass.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们再次运行测试，它们都应该通过。
- en: Similarly, we can add tests for other controllers as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以为其他控制器添加测试。
- en: Writing tests for models
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模型的测试
- en: Let's move on to adding the tests for the models that we have defined. Let's
    create a folder called `models` inside `test/unit/specs` and create a test file
    for our `Movie.js` model. So, the name of the spec file would be `Movie.spec.js`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加对我们定义的模型进行的测试。在`test/unit/specs`中创建一个名为`models`的文件夹，并为我们的`Movie.js`模型创建一个测试文件。因此，规范文件的名称将是`Movie.spec.js`。
- en: 'Let''s first take a look at what we have in our `Movie.js`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看我们的`Movie.js`中有什么：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We just have a `Schema` defined here, which defines the data type for the `Movie`
    collection.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只定义了一个`Schema`，它定义了`Movie`集合的数据类型。
- en: 'Let''s add the specs for this model. Add the following contents to the `Movie.spec.js`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Movie.spec.js`中添加这个模型的规范。添加以下内容到其中：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We do not need all the components that we added to the controller test here.
    We just have simple assertion tests here, so we will need the `Movie` model and
    the `chai` methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在控制器测试中添加的所有组件。我们这里只有简单的断言测试，所以我们需要`Movie`模型和`chai`方法。
- en: 'Let''s add the test for the `Movie` existence just like we did for the controller.
    Replace the contents in `Movie.spec.js` with the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像为控制器添加测试一样，添加对`Movie`存在的测试。将`Movie.spec.js`中的内容替换为以下代码：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This test checks whether the `Model` we are describing exists or not. Let''s
    run the test using the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查我们描述的`Model`是否存在。让我们使用以下命令运行测试：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The test should pass with the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该通过以下输出：
- en: '![](img/4da3257a-1664-4b20-b273-9196fb3ba7eb.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4da3257a-1664-4b20-b273-9196fb3ba7eb.png)'
- en: Let's move on to add a test when we send the `release_year` attribute of the
    `Movie` a string. Since we have a validation for the `release_year` attribute,
    sending a string value to it should throw an error.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加当我们将`Movie`的`release_year`属性发送为字符串时的测试。由于我们对`release_year`属性有验证，向其发送字符串值应该抛出错误。
- en: 'Replace the contents in `Movie.spec.js` with the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Movie.spec.js`中的内容替换为以下代码：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we have prepared a movie object with `release_year` with an invalid value.
    The expectation we have here is that, when validating the model, it should send
    an error.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们准备了一个具有无效`release_year`值的电影对象。我们在这里的预期是，在验证模型时，应该发送一个错误。
- en: 'Let''s run the test, and it should pass with the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试，它应该通过以下输出：
- en: '![](img/4860ebca-061b-41d0-855f-a41f93c04a9e.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4860ebca-061b-41d0-855f-a41f93c04a9e.png)'
- en: Similarly, we can add tests for other models as well.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以为其他模型添加测试。
- en: Writing tests for Vue.js components
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Vue.js组件的测试
- en: Let's move on to write the test specs for our Vue.js components. We will start
    with the simplest component, which is the `Contact.vue` page.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写我们的Vue.js组件的测试规范。我们将从最简单的组件开始，即`Contact.vue`页面。
- en: 'This is what we have in our `Contact.vue` page so far:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`Contact.vue`页面是这样的：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s modify the component a little bit to make the tests more understandable.
    Replace the contents in `Contact.vue` with the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下组件，使测试更易于理解。将`Contact.vue`中的内容替换为以下代码：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s first create the necessary folder and file to write our tests.
    Create a file called `Contact.spec.js` inside the `test/unit/specs` directory
    and add the following contents to it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们首先创建必要的文件夹和文件来编写我们的测试。在`test/unit/specs`目录中创建一个名为`Contact.spec.js`的文件，并将以下内容添加到其中：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, we have added a test to check whether the `vue` component
    `Contact.vue` renders the correct contents or not. We expected to have a `div`
    element with the `contact` class, and inside it, there should be an `h1` tag,
    which should contain the `this is contact` content.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个测试来检查Vue组件`Contact.vue`是否渲染了正确的内容。我们期望有一个带有`contact`类的`div`元素，并且在其内部，应该有一个包含`this
    is contact`内容的`h1`标签。
- en: 'Now, to make sure that our tests run, let''s verify that we have the correct
    script set up to run the unit test in `package.json`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了确保我们的测试运行，让我们验证我们是否在`package.json`中设置了正确的脚本以运行单元测试：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s run the test with the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令运行测试：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The test should pass with the following output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该通过以下输出：
- en: '![](img/78d15aee-07a0-4fb6-bea0-efe3af6bb819.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78d15aee-07a0-4fb6-bea0-efe3af6bb819.png)'
- en: 'Let''s move on to add specs for the component called `AddMovie.vue.` Create
    a file called `AddMovie.spec.js` inside `test/unit/specs` and add the following
    contents:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加名为`AddMovie.vue`的组件的规格。在`test/unit/specs`内创建一个名为`AddMovie.spec.js`的文件，并将以下内容添加到其中：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This test states that the `years` variable should have the given values, which
    is `['2018', '2017', '2016', '2015']`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试声明`years`变量应该有给定的值，即`['2018', '2017', '2016', '2015']`。
- en: 'Let''s add another test to check whether the required methods exist in our
    `vue` component, `AddMovie.js`, or not. Replace the contents in `AddMovie.spec.js`
    with the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试来检查我们的`vue`组件`AddMovie.js`中是否存在所需的方法。用以下代码替换`AddMovie.spec.js`中的内容：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s run the tests with the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令运行测试：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The tests should pass.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该通过。
- en: 'Finally, to run all the tests, we can simply run the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要运行所有测试，我们可以简单地运行以下命令：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Writing e2e testing
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写e2e测试
- en: The vue.js applications created with `vue-cli` command contains the support
    for end-to-end testing which uses `Nightwatch`. `Nightwatch` is a very easy framework
    to write end-to-end test. `Nightwatch` uses `Selenium` commands to run the JavaScript.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vue-cli`命令创建的vue.js应用程序包含对使用`Nightwatch`的端到端测试的支持。`Nightwatch`是一个非常容易编写端到端测试的框架。`Nightwatch`使用`Selenium`命令来运行JavaScript。
- en: Installing Nightwatch
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Nightwatch
- en: 'If you haven''t set up the application for `e2e`, then let''s first install
    the package needed to run the `e2e` tests:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有为`e2e`设置应用程序，那么让我们首先安装运行`e2e`测试所需的包：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Configuring Nightwatch
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Nightwatch
- en: 'Now, we need a configuration file to run the test. Create a folder called `e2e`
    inside the `test` folder. Add the `nightwatch.conf.js` file and add the following
    contents to it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个配置文件来运行测试。在`test`文件夹内创建一个名为`e2e`的文件夹。添加`nightwatch.conf.js`文件，并将以下内容添加到其中：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding code, in the setting inside the `test_settings` attribute,
    we can see the different setups for different browsers. In this case, Chrome,
    Firefox, and the host and port settings for the development environment to run
    on the browser.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`test_settings`属性内的设置中，我们可以看到为不同浏览器设置的不同配置。在这种情况下，Chrome、Firefox以及开发环境在浏览器上运行的宿主和端口设置。
- en: 'Also, in the preceding code, we have specified two folders: `specs` and `custom-assertions`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在前面的代码中，我们指定了两个文件夹：`specs`和`custom-assertions`。
- en: The `specs` folder contains the main test code for the application
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`specs`文件夹包含应用程序的主要测试代码。'
- en: '`custom-assertion` contains a script, which contains custom messages that get
    displayed when assertion tests are run on the command line'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`custom-assertion`包含一个脚本，该脚本包含在命令行上运行断言测试时显示的自定义消息。'
- en: 'Let''s first set up our `custom-assertions`. Create a file called `elementCount.js`
    inside `custom-assertions` and add the following contents to it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先设置我们的`custom-assertions`。在`custom-assertions`内创建一个名为`elementCount.js`的文件，并将以下内容添加到其中：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you checked the `e2e` option when creating this application, you should
    also have the `test/e2e/specs/test.js` file. If not, go ahead and create this
    file and add the following contents into it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建此应用程序时选择了`e2e`选项，那么你也应该有`test/e2e/specs/test.js`文件。如果没有，请继续创建此文件并将以下内容添加到其中：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is the main file, where we will add our test cases for the application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主文件，我们将在此添加我们的应用程序测试用例。
- en: The end-to-end testing makes sure that all the the flow of our application is
    performing as expected or not. When we run the `e2e` test, we want certain parts
    of our application to be clicked and behave the way it should. This can be described
    as testing the behavior of the application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试确保我们的应用程序的所有流程都按预期执行。当我们运行`e2e`测试时，我们希望应用程序的某些部分被点击并按预期的方式表现。这可以描述为测试应用程序的行为。
- en: 'To be able to run the `e2e` tests, we will need to start a `selenium-server`.
    If we take a look at the `test/e2e/nightwatch.conf.js` file, we can find a line
    that says:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够运行`e2e`测试，我们需要启动一个`selenium-server`。如果我们查看`test/e2e/nightwatch.conf.js`文件，我们可以找到一个说：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This means that when we run the `e2e` test, a `selenium-server` is started automatically,
    and we don't have to run a separate server. The port defines which port to use
    for `selenium-server`. You can leave this as it is and run the test, or you can
    change the values and configure it yourself.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们运行 `e2e` 测试时，会自动启动 `selenium-server`，我们不需要运行单独的服务器。端口号定义了用于 `selenium-server`
    的端口号。您可以保持原样并运行测试，或者您可以更改这些值并自行配置。
- en: 'Finally, we need a `runner` file for `Nightwatch` to run the test. Create a
    file called `runner.js` inside the `e2e` folder and add the following contents:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个 `runner` 文件来让 `Nightwatch` 运行测试。在 `e2e` 文件夹内创建一个名为 `runner.js` 的文件，并添加以下内容：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will use a stand-alone Selenium server and port `5555` for this application.
    For that, we will need to install the standalone server first:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用独立的 Selenium 服务器和端口 `5555` 来运行此应用程序。为此，我们首先需要安装独立服务器：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s run the package using the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行包：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `npx` is a command that runs the npm packages.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`npx` 是一个运行 npm 包的命令。'
- en: Since we are using the `5555` port, we will need to update it in the `nightwatch.conf.js`
    file as well.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 `5555` 端口，我们还需要在 `nightwatch.conf.js` 文件中更新它。
- en: 'Update the Selenium config in `nightwatch.conf.js` with the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `nightwatch.conf.js` 中的 Selenium 配置：
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Since we are using the `8081` port to run the `node` server, make sure that
    you update the `devServerURL` attribute as well, as was done in the preceding
    piece of code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 `8081` 端口运行 `node` 服务器，请确保您已更新 `devServerURL` 属性，正如前面代码所示。
- en: 'Now, we are all set to run the tests with the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用以下命令运行测试：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The test should fail with the following output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该会失败，并显示以下输出：
- en: '![](img/61bec658-6b51-44f6-a8dc-a8dba79c76cb.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61bec658-6b51-44f6-a8dc-a8dba79c76cb.png)'
- en: The tests are failing because we do not have the element present with the `.hello`
    class in our application. So, to make the tests pass, we first need to add an
    identifier to the elements, which we will be doing as a part the `e2e` tests by
    following the below steps.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败是因为在我们的应用程序中没有具有 `.hello` 类的元素。因此，为了使测试通过，我们首先需要向元素添加一个标识符，我们将通过以下步骤在 `e2e`
    测试中完成这一操作。
- en: 'Here are the things that we want to capture with the `e2e` test:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们想要通过 `e2e` 测试捕获的内容：
- en: Open the browser using `http://localhost:8081`
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `http://localhost:8081` 打开浏览器
- en: 'Check whether the element with the `#inspire` ID exists. We have defined that
    in `App.vue` with the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查具有 `#inspire` ID 的元素是否存在。我们已在 `App.vue` 中定义了以下代码：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Check that the sidebar consists of the `Home` and `Contact` page links
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查侧边栏是否包含 `Home` 和 `Contact` 页面链接
- en: Click on the `Contact` page
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Contact` 页面
- en: The contact page should contain the text `this is contact`
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系页面应包含文本 `this is contact`
- en: Click on the login page to make sure that the login works fine
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击登录页面以确保登录正常工作
- en: Add a movie to our application
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的应用程序添加电影
- en: Rate the movie
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评分电影
- en: Finally, add the ability for users to log out of the application
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加用户退出应用程序的功能
- en: These are the important parts of our application. So, we will need to add an
    identifier to all of preceding components. The best practice for adding an identifier
    to the elements is to define a `class` or an `id` while building the application
    itself. However, we will assign an identifier to the now.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们应用程序的重要部分。因此，我们需要为所有前面的组件添加一个标识符。向元素添加标识符的最佳实践是在构建应用程序本身时定义一个 `class` 或
    `id`。然而，我们将现在为它们分配一个标识符。
- en: 'In `App.vue`, update the highlighted parts with the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.vue` 中，使用以下代码更新高亮部分：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Also, let''s update the `id` in `AddMovie.vue`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们更新 `AddMovie.vue` 中的 `id`：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Also, in `Login.vue`, let''s add corresponding `id` for the form fields:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `Login.vue` 中，让我们为表单字段添加相应的 `id`：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `Movie.vue`, update the `id` for `Rate this Movie` with:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Movie.vue` 中，使用以下命令更新 `Rate this Movie` 的 `id`：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have added the necessary identifier to all of the components. Now, let's
    add the `e2e` tests for the previously mentioned scenarios.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已为所有组件添加了必要的标识符。现在，让我们为之前提到的场景添加 `e2e` 测试。
- en: 'Replace the contents of `test/e2e/specs/test.js` with the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `test/e2e/specs/test.js` 中的内容替换为以下代码：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To run the `e2e` script, make sure that we have set up the correct command
    in `package.json`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 `e2e` 脚本，请确保我们在 `package.json` 中设置了正确的命令：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After adding the `e2e` script, we should be able to run the test with the following
    command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `e2e` 脚本后，我们应该能够使用以下命令运行测试：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, all the tests should pass, and the output should look like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有的测试都应该通过，输出应该看起来像这样：
- en: '![](img/4288c176-6724-4551-ae71-395d9b03501b.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4288c176-6724-4551-ae71-395d9b03501b.png)'
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to write unit tests and we discussed the different
    technologies you can use to write them, such as `chai`, `mocha`, and `sinon`.
    You also learned to write tests for controllers, models, and Vue component.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写单元测试，我们讨论了你可以用来编写测试的不同技术，例如 `chai`、`mocha` 和 `sinon`。你还学习了如何编写控制器、模型和
    Vue 组件的测试。
- en: In the next chapter, you will learn about continuous integration and how to
    deploy your apps to Heroku using GitHub.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解持续集成以及如何使用 GitHub 将你的应用部署到 Heroku。
