- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Improving the Environment with Lighting and Materials
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过光照和材质改善环境
- en: Welcome to [*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207)! This chapter
    is brought to you by The Number 5, twice. Babylon.js v5 brings with it not only
    incredibly powerful and fast features but also a suite of new tools to help work
    with almost every area that a game engine could ask for from a framework. We’ve
    worked with several of them already, including just this past chapter on the **GUI
    Editor** (**GUIE**). Previously, we’ve worked with the **Particle Editor** in
    the **Inspector** in addition to the **GUIE** and the **Playground**. But that’s
    not all of them, not by a long shot.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[第10章](B17266_10_Final_AM.xhtml#_idTextAnchor207)！这一章由数字5带来了两次。Babylon.js
    v5不仅带来了强大且快速的特性，还带来了一套新工具，以帮助处理游戏引擎可能从框架中请求的几乎所有领域。我们已经与其中的一些工具一起工作过，包括刚刚过去的这一章关于**GUI编辑器**（**GUIE**）。之前，我们除了与**GUIE**和**Playground**一起工作外，还与**Inspector**中的**粒子编辑器**一起工作。但这还不是全部，远非如此。
- en: As we cover the **IBL Toolkit** and the **Sandbox** in this chapter, the shadow
    of a giant looms over us. The mighty **Node Material Editor** (**NME**) will be
    the topic of the next chapter, and we’re going to use this chapter to prepare
    for it by leveling up our knowledge of some important topics in 3D graphics programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**IBL工具包**和**沙盒**，一个巨人的阴影笼罩着我们。强大的**节点材质编辑器**（**NME**）将是下一章的主题，我们将利用这一章来为它做准备，通过提升我们对3D图形编程中一些重要主题的知识水平。
- en: When it comes to the graphical experience of a game or 3D application, lighting
    is probably the single greatest contributor to the overall look and feel of a
    scene. Like many of the topics we’ve covered or will be covering, there are entire
    libraries of much more in-depth, better written, and thorough texts that cover
    these subjects. Hence, our objective will be to provide a solid basis of the principles,
    grounded in a practical usage scenario. No matter what visual effects look is
    desired, the best and most performant lighting technique for current real-time
    3D rendering is **Image-Based Lighting** (**IBL**), where the main source of light
    for a scene is, as the name implies, a specially prepared image texture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到游戏或3D应用程序的图形体验时，光照可能是对场景整体外观和感觉贡献最大的单一因素。像我们之前或将要讨论的许多主题一样，关于这些主题有大量的更深入、更精心编写、更全面的文本库。因此，我们的目标将是提供一个基于实际使用场景的坚实基础，以阐述这些原则。无论希望实现什么样的视觉效果，当前实时3D渲染的最佳和最高效的光照技术是**基于图像的光照**（**IBL**），其中场景的主要光源，正如其名所示，是一种特别准备好的图像纹理。
- en: Note
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The 1993 movie *Jurassic Park* pioneered this technique as a way to capture
    the on-set lighting for use with the computer-generated elements of scenes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 1993年的电影《侏罗纪公园》开创了这项技术，作为捕捉现场光照以用于场景计算机生成元素的方法。
- en: This chapter isn’t just about lighting, however. It’s incredibly difficult to
    talk meaningfully about lighting in a scene without involving the concept of materials.
    Simply put, **material** is the term we use for mathematics to describe how light
    interacts with a surface. There’s quite a lot more that goes into that definition,
    but as usual, Babylon.js provides a shortcut with the **PBRMaterial**. This helps
    keep the most complicated parts of the math – both here in this book and in your
    code – tucked and hidden away behind a shiny abstraction that leaves us the task
    of knowing which parameters need to be set and to what value.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一章不仅仅关于光照。在场景中有意义地讨论光照而不涉及材质的概念是非常困难的。简单来说，**材质**是我们用来描述光线如何与表面交互的数学术语。这个定义中包含了很多内容，但像往常一样，Babylon.js提供了一个捷径，即**PBRMaterial**。这有助于将数学中最复杂的部分——无论是这本书中还是你的代码中——隐藏在光鲜的抽象背后，而我们将负责知道需要设置哪些参数以及设置什么值。
- en: Before we try to drink from the firehose of lighting topics, there are some
    other pieces of business for us to tackle. Make sure to check out the *Technical
    Requirements* section for some links to posts, books, and articles relevant to
    the topics in this chapter. There’s also a list of fancy words you can use in
    Scrabble or to impress your friends who aren’t fortunate enough to be reading
    this book like you are and a list of both free and paid software for working with
    and preparing images to use in your project. Don’t feel guilty about your rapidly
    growing knowledge – feel good as you read the first section to learn about all
    the different things we’ve done and changed since we last visited the code base.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试从照明主题的火流中汲取知识之前，还有一些其他的事情需要我们处理。请确保查看*技术要求*部分，其中包含一些与本章主题相关的帖子、书籍和文章的链接。还有一个你可以用于Scrabble游戏或用来给你的朋友（他们不幸没有像你一样阅读这本书）留下深刻印象的时髦词汇列表，以及一个用于处理和准备图像以供项目使用的免费和付费软件列表。不要因为你的知识快速增长而感到内疚——当你阅读第一部分了解自上次访问代码库以来我们所做和改变的所有不同事情时，你会感到很高兴。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Materials, Lighting, and the BRDF
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料和照明以及BRDF
- en: Working with PBR Materials and IBL Scenes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PBR材料和IBL场景
- en: Tone Mapping and Basic Post-Processing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 色度映射和基本后期处理
- en: Technical Requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this chapter is locat[ed at https://github.com/jelster/space-truckers/tre](https://github.com/jelster/space-truckers/tree/ch10)e/ch10\.
    While we’ll still be looking at some Playground code, most of our work in this
    chapter lies elsewhere. For working with images and textures, the following non-exhaustive
    list of tools will be useful for preparing and converting image assets for use
    with Babylon.js.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于[https://github.com/jelster/space-truckers/tree/ch10](https://github.com/jelster/space-truckers/tree/ch10)的ch10目录中。虽然我们仍将查看一些Playground代码，但本章的大部分工作都在其他地方。对于处理图像和纹理，以下非详尽的工具列表将有助于准备和转换图像资产以供Babylon.js使用。
- en: Tools
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具
- en: 'The following tools will help you in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具将帮助你在本章中：
- en: '![](img/Table_10.01_B17866.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table_10.01_B17866.jpg)'
- en: Glossary of terms (abridged)
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语表（简略版）
- en: 'Here is a list of some of the more common acronyms and terms that you might
    encounter during this chapter or while reading other resources on the topic of
    3D lighting and materials. It’s far from complete but will serve as a jumping-off
    point to expand your vocabulary further:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在本章或阅读其他关于3D照明和材料主题的资源时可能会遇到的常见缩写和术语列表。这远非完整，但可以作为扩展词汇的起点：
- en: '**Direct Draw Surface** (**DDS**): A file format that’s useful for storing
    high-resolution images. This includes MIP maps. Babylon.js supports the so-called
    “legacy” DX1 DDS format.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接绘制表面**（**DDS**）：一种用于存储高分辨率图像的文件格式。这包括MIP贴图。Babylon.js支持所谓的“遗留”DX1 DDS格式。'
- en: '**MIP map**: Referred to as pyramids in some areas of 3D graphics, a MIP map
    is a series of progressively smaller, lower- resolution reproductions of the original
    image. This is used for many applications, such as **Level of Detail** (**LOD**)
    and storing pre-computed lighting values.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MIP贴图**：在某些3D图形领域被称为金字塔，MIP贴图是一系列逐渐缩小、分辨率较低的原始图像的再现。这用于许多应用，如**细节级别**（**LOD**）和存储预计算的照明值。'
- en: '**Physical Based Rendering** (**PBR**): This is a technique for realistically
    simulating the behavior of light after interacting with some surface material.
    A Specular/Glossiness model and a Roughness/Metallicity model are two approaches.
    For the two major parameters, there are pairs of Specular/Gloss, and Rough/Metallic,
    respectively, with values that fall in the range of [0,1].'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于物理的渲染**（**PBR**）：这是一种模拟光线与某些表面材料相互作用后行为的技术。镜面/光泽度模型和粗糙度/金属度模型是两种方法。对于两个主要参数，分别有镜面/光泽和粗糙/金属的配对，其值在[0,1]范围内。'
- en: '**Image-Based Lighting** (**IBL**): A method of scene illumination that incorporates
    a spherical projection of an image to provide lighting.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于图像的照明**（**IBL**）：一种场景照明的技术，它通过将图像的球形投影结合进来提供照明。'
- en: '**Skybox**: A mesh cube textured on the inside, with the camera positioned
    within. This is done by using a specially laid out single image or six separate
    individual images. A camera positioned on the interior of the cube will view the
    texture as if it appeared very far away.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天空盒**：一个内部纹理化的网格立方体，相机位于其中。这是通过使用一个特别布局的单个图像或六个单独的图像来实现的。位于立方体内部的相机将纹理视为非常遥远的地方。'
- en: '**Environment Texture**: This is a special type of texture; it is the “I” of
    “IBL.”'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境纹理**：这是一种特殊的纹理类型；它是“IBL”中的“I”。'
- en: '**BRDF**: This stands for **Bidirectional Reflectance Distribution Function**
    (pronounced similar to “Bird”) and is a mathematical function that contributes
    terms to the overall Rendering Function that relates the angle of reflectance
    to the amount of incoming and outgoing light.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BRDF**：代表**双向反射分布函数**（发音类似于“Bird”），这是一个数学函数，它向整体渲染函数贡献项，该函数将反射角度与入射和出射光量相关联。'
- en: '**Rendering Function**: When implemented, this is known as a rendering pipeline.
    This is a mathematical function that’s used to calculate the final screen color
    of a 2D pixel depicting part of a 3D scene. The final color value of that pixel
    is influenced by many different factors, such as lighting or the position of the
    camera.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染函数**：当实现时，这被称为渲染管线。这是一个用于计算2D像素最终屏幕颜色的数学函数，该像素描绘了3D场景的一部分。该像素的最终颜色值受许多不同因素的影响，例如光照或摄像机的位置。'
- en: '**Material**: This is an asset or code component that, when applied to a mesh
    geometry, defines the behavior of light impacting upon the mesh.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质**：这是一个资产或代码组件，当应用于网格几何体时，定义了光线对网格的影响行为。'
- en: '**Luminance**: This is a measurement of the amount of light in a given unit
    area.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亮度**：这是对给定单位面积内光量的测量。'
- en: '**Dynamic Range**: The ratio between the brightest and the darkest parts of
    a scene.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态范围**：场景中最亮和最暗部分之间的比率。'
- en: '**Tone Mapping**: Used to adapt an HDR image for use in a non-HDR display or
    medium.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**色调映射**：用于将HDR图像适配用于非HDR显示或媒介。'
- en: '**Color Space**: The potential range of colors that can be represented by a
    particular file or image format. This is often notated in terms of bytes per channel;
    for example, R8G8B8A8.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**色彩空间**：特定文件或图像格式可以表示的颜色范围。这通常以每通道字节数表示；例如，R8G8B8A8。'
- en: Recommended Reading
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推荐阅读
- en: 'Here are some links to resources that can be helpful to skim before, during,
    or after reading this chapter. Some are more on the conceptual side, while the
    documentation links are eminently practical:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之前、期间或之后，这里有一些资源链接，可以帮助你快速浏览。其中一些更侧重于概念方面，而文档链接则非常实用：
- en: 'The BRDF, as told by Wikipedia: [https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function](https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如维基百科所述的BRDF：[https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function](https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function)
- en: 'The PBR BRDF, as described by the Academy Award-winning engineering group who
    pioneered the technique in professional film: [https://www.pbr-book.org/](https://www.pbr-book.org/)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由获得奥斯卡奖的工程团队描述的PBR BRDF，该团队在专业电影中率先采用该技术：[https://www.pbr-book.org/](https://www.pbr-book.org/)
- en: 'Official BJS docs:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方BJS文档：
- en: 'Setting up an HDR Environment to use with PBR: [https://doc.babylonjs.com/divingDeeper/materials/using/HDREnvironment](https://doc.babylonjs.com/divingDeeper/materials/using/HDREnvironment)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置HDR环境以与PBR一起使用：[https://doc.babylonjs.com/divingDeeper/materials/using/HDREnvironment](https://doc.babylonjs.com/divingDeeper/materials/using/HDREnvironment)
- en: 'All the things you never knew you wanted to know about the properties of **PBRMaterial**:
    [https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR](https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR)'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有那些你从未想过想要了解的关于**PBRMaterial**属性的知识：[https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR](https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR)
- en: 'Break-out of different reflection and refraction features: [https://doc.babylonjs.com/divingDeeper/materials/using/reflectionTexture](https://doc.babylonjs.com/divingDeeper/materials/using/reflectionTexture)'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同反射和折射功能的突破：[https://doc.babylonjs.com/divingDeeper/materials/using/reflectionTexture](https://doc.babylonjs.com/divingDeeper/materials/using/reflectionTexture)
- en: 'The Khronos Foundation BRDF reference implementation used by Babylon.js for
    modeling metallic roughness materials: [https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.xhtml#appendix-b-brdf-implementation](https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.xhtml#appendix-b-brdf-implementation)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babylon.js用于建模金属粗糙度材料的Khronos Foundation BRDF参考实现：[https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.xhtml#appendix-b-brdf-implementation](https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.xhtml#appendix-b-brdf-implementation)
- en: 'Two separate Hard-Core BRDF definitions, along with example implementations
    of realistic PBR suitable for scientific or engineering models:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个独立的硬核BRDF定义，以及适合科学或工程模型的现实PBR的示例实现：
- en: '[https://math.nist.gov/~FHunt/appearance/brdf.xhtml](https://math.nist.gov/~FHunt/appearance/brdf.xhtml)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://math.nist.gov/~FHunt/appearance/brdf.xhtml](https://math.nist.gov/~FHunt/appearance/brdf.xhtml)'
- en: '[https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-18-spatial-brdfs](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-18-spatial-brdfs)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-18-spatial-brdfs](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-18-spatial-brdfs)'
- en: 'For the textbook crowd: *Essential Mathematics for Games and Interactive Applications*,
    3rd ed. Van Herth and Bishop. 2016 Taylor & Francis Group. ([https://www.essentialmath.com](https://www.essentialmath.com))'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于教科书读者：《游戏和交互式应用必备数学》，第3版。范·赫特和毕晓普著。2016年泰勒弗朗西斯集团。([https://www.essentialmath.com](https://www.essentialmath.com))
- en: 'Image Encoding for HDR: [http://www.anyhere.com/gward/hdrenc/hdr_encodings.xhtml](http://www.anyhere.com/gward/hdrenc/hdr_encodings.xhtml)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HDR图像编码：[http://www.anyhere.com/gward/hdrenc/hdr_encodings.xhtml](http://www.anyhere.com/gward/hdrenc/hdr_encodings.xhtml)
- en: Materials, Lighting, and the BRDF
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料和BRDF
- en: The analogy of a 3D scene to a real-world movie studio set is an obvious but
    useful one. Some parts are obvious, such as the scene and stage, cameras, and
    lights, while others are not. Meshes are the actors and the set pieces, while
    materials are their costumes. This section is all about the costuming and lights,
    but it’s tough to discuss either without digging down a bit into the theoretical
    underpinnings of how light gets modeled in a scene.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将3D场景比作现实世界的电影工作室场景是一个显而易见但很有用的类比。有些部分是显而易见的，比如场景和舞台、摄像机和灯光，而有些则不是。网格是演员和场景道具，而材料则是他们的服装。本节内容全部关于服装和灯光，但如果不深入探讨场景中光线建模的理论基础，讨论这两者都很难。
- en: This section is a bit of a doozy, so here’s a quick fly-over of what we’re going
    to talk about. First, we’re going to dabble with a little bit of symbolic mathematics
    and some extremely light calculus. Next, we’ll look at the different ways that
    light can reflect and interact with surfaces, and how it’s modeled or approximated
    in 3D. This will serve as a strong basis for us to learn about Materials and how
    they relate to math at a high level. After that, we will introduce PBR and Environments
    to cap off our tour. Time to dive in!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分内容有点复杂，所以这里先快速浏览一下我们将要讨论的内容。首先，我们将涉猎一点符号数学和一些非常基础的微积分。接下来，我们将探讨光如何以不同的方式反射和与表面相互作用，以及它在3D中的建模或近似方法。这将为我们学习材料及其在高级数学中的关系提供一个坚实的基础。之后，我们将介绍PBR和环境，以结束我们的探索之旅。现在是时候深入研究了！
- en: Introducing the BRDF
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍BRDF
- en: 'Light is modeled in terms of either being incident or reflected – denoted with
    the subscripts i and r – representing a measured amount of light that is either
    incident upon an object (is being reflected) or coming from an object (reflected
    off of it). The terms for these two scenarios are **radiance** for the light reflected
    from the object and **irradiance** to represent the amount of incoming light.
    The ratio between the incident radiance and the reflected irradiance is computed
    using some derivation of the BRDF:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 光线以入射或反射的形式进行建模——用下标i和r表示——代表的是测量到的光线量，这些光线要么是照射到物体上（正在被反射），要么是从物体上发出的（从它反射出来）。这两个场景的术语是**辐射**，表示从物体反射出的光线，以及**辐照度**，表示入射光线的量。入射辐射和反射辐照度之间的比率是通过BRDF的一些推导来计算的：
- en: 'This is a scary-looking piece of math if you’re not a level 3 calculus adept
    or higher, but it’s not as bad as it seems when we restate the equation in terms
    of how it works. The change in reflected radiance (dLr) depends on the angle between
    the incident (Li) ray of light and the surface normal (n) – used to calculate
    θ, with input values represented by the combination of (ωi, ωr). There are three
    important constraints that any code implementing this function must satisfy to
    realistically model a physical system:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是3级微积分或更高水平的专家，这个数学表达式看起来可能会让人害怕，但当我们用它的工作原理重新表述方程时，它并不像看起来那么糟糕。反射辐射的变化（dLr）取决于入射（Li）光线与表面法线（n）之间的角度——用于计算θ，输入值由(ωi,
    ωr)的组合表示。任何实现此功能的代码都必须满足三个重要的约束条件，以真实地模拟物理系统：
- en: The result of fr(ωi, ωr) must be greater than or equal to zero.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fr(ωi, ωr)的结果必须大于或等于零。
- en: Reversing the terms (ωi, ωr) yields identical output. This is known as reciprocity.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换(ωi, ωr)的术语会产生相同的结果。这被称为互易性。
- en: Energy must be conserved. In other words, the total amount of irradiance going
    into a particular area and the total amount of radiance going out of that same
    area must be less than or equal to one.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能量必须守恒。换句话说，进入特定区域的总辐射通量和从该区域发出的总辐射通量必须小于或等于一。
- en: We don’t ever have to directly deal with implementing this equation, fortunately,
    but it’s good to know the underlying forces driving the higher-level abstractions
    in Babylon.js. Later in this section, we’ll look at how the **PBRMaterial** parameters
    affect the underlying BRDF, but first, we’re going to continue exploring the theory
    and concepts behind lighting.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必直接处理这个方程的实现，但了解驱动Babylon.js中高级抽象的底层力量是好的。在本节稍后，我们将探讨**PBRMaterial**参数如何影响底层BRDF，但首先，我们将继续探索光照背后的理论和概念。
- en: How Light is Modeled in 3D Applications
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在3D应用程序中如何模拟光线
- en: 'To reduce the sheer number and complexity of lighting calculations needed,
    we need to simplify how we treat light. For our purposes, light behaves as a ray
    emitted from its source that then reflects from surfaces in a deterministic fashion.
    When it comes to these calculations, there can be great numbers of individual
    parameters that contribute to the result, but at the heart of it, there are just
    a few parameters that contain essential terms for lighting computation: light
    direction (I), radiance (L), the surface normal (n), and the view position (V).
    The BRDF is evaluated once per light source, for every light sample in a scene,
    because of the need to calculate the angle between the object’s surface normal
    and the point of incidence:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少所需的光照计算的数量和复杂性，我们需要简化我们对光的处理方式。就我们的目的而言，光表现为从其源头发出的射线，然后以确定的方式从表面反射。在这些计算中，可能会有大量单个参数对结果有贡献，但核心中，只有少数参数包含对光照计算至关重要的术语：光方向（I）、辐射（L）、表面法线（n）和观察位置（V）。由于需要计算物体表面法线和入射点之间的角度，BRDF对每个光源进行一次评估，对场景中的每个光样本进行一次评估：
- en: '![Figure 10.1 – Basic parameters involved in lighting computations. The normalized
    vectors, I and V, represent the direction of the light and the viewer, respectively,
    while the normalized vector, n, points in the direction of the surface normal'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 参与光照计算的基参数。归一化向量I和V分别代表光的方向和观察者的方向，而归一化向量n指向表面法线的方向'
- en: '](img/Figure_10.01_B17866.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.01_B17866.jpg)'
- en: Figure 10.1 – Basic parameters involved in lighting computations. The normalized
    vectors, I and V, represent the direction of the light and the viewer, respectively,
    while the normalized vector, n, points in the direction of the surface normal
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 参与光照计算的基参数。归一化向量I和V分别代表光的方向和观察者的方向，而归一化向量n指向表面法线的方向
- en: The normalized vector I points toward the light source, while the vector L –
    sometimes denoted with ω in equations – provides the intensity. When you put these
    together, you get the brightness (luminance) of light incident upon the object
    in each color. Different light sources use different equations to compute values
    for I and L. Two examples of this are the point light, which radiates light equally
    in all directions, and the spotlight, which radiates light in a single direction.
    Both types of lights illuminate an object, but their properties result in different
    behavior in surface interactions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 归一化向量I指向光源，而向量L（有时在方程中用ω表示）提供强度。当你将这些结合起来，你就得到了光在物体上每个颜色上的亮度（亮度）。不同的光源使用不同的方程来计算I和L的值。两个例子是点光源，它在所有方向上均匀辐射光，和聚光灯，它在单一方向上辐射光。这两种类型的光都能照亮物体，但它们的属性导致了表面交互中的不同行为。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important that the I, N, and V vectors are normalized to preserve the relationships
    between values after transformation. The final value is scaled by either a color
    or scalar value computed from L.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 确保I、N和V向量被归一化，以保留变换后值之间的关系。最终值通过从L计算出的颜色或标量值进行缩放。
- en: The quality of **radiance** is a measure of the amount of incident light impacting
    a square meter area if you want to be technically precise. More colloquially,
    radiance is the brightness of a particular source of light. Complementary to radiance
    is color. Color is, physically speaking, defined by the wavelength of a particular
    packet of light, or the amount of energy contained in a photon. Computationally,
    color is usually represented as a Vector3 or Vector4 quantity, depending on whether
    an alpha transparency channel is being used. Being able to treat colors as vectors
    is a very useful technique since the whole toolbox of vector calculations then
    applies to mixing and blending colors. Before we know what types of calculations
    to perform, though, we need to know more about the types of reflected light.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**辐射度**的质量是衡量每平方米面积上入射光量的度量，如果想要技术上精确的话。更通俗地说，辐射度是特定光源的亮度。与辐射度相辅相成的是颜色。从物理学的角度来看，颜色是由特定光包的波长定义的，或者是由光子包含的能量量。在计算上，颜色通常表示为
    Vector3 或 Vector4 量，这取决于是否使用了 alpha 透明度通道。能够将颜色作为向量处理是一种非常有用的技术，因为整个向量计算工具箱就可以应用于混合和混合颜色。然而，在我们知道要执行哪些类型的计算之前，我们需要更多地了解反射光的类型。'
- en: Diffuse
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 散射
- en: 'When light reaches the View position, it can do so along an almost infinite
    number of different combinations of paths. The diffuse lighting term refers to
    light that is evenly scattered from the surface of an object. Another way of putting
    it is that a shaft of light striking the object’s surface scatters diffuse light
    in all possible directions. Light being scattered will be influenced by the color
    specified by the object’s diffuse material settings or from a texture lookup:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当光线达到观察位置时，它可以沿着几乎无限多种不同的路径组合到达。散射照明项指的是从物体表面均匀散射的光。另一种说法是，一束光线击中物体表面会向所有可能的方向散射散射光。散射的光会受到物体漫反射材料设置指定的颜色或从纹理查找的影响：
- en: '![Figure 10.2 – Diffuse light is scattered in all directions'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – 散射光向所有方向散射'
- en: '](img/Figure_10.02_B17866.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 10.02_B17866.jpg](img/Figure_10.02_B17866.jpg)'
- en: Figure 10.2 – Diffuse light is scattered in all directions
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 散射光向所有方向散射
- en: Specular
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜面
- en: 'The Specular term of the lighting model represents light that reflects directly
    from an object to the viewer. Depending on the term’s value, this can give an
    object a “shiny” appearance, approximating a smooth or rough surface. The specular
    term is very strongly affected by the angle between the incident shaft of light,
    the object, and the viewer as the angle approaches 90 degrees:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 照明模型中的镜面项表示从物体直接反射到观察者的光。根据该术语的值，这可以使物体具有“闪亮”的外观，近似于光滑或粗糙的表面。当入射光束、物体和观察者之间的角度接近
    90 度时，镜面项会受到强烈影响：
- en: '![Figure 10.3 – Specular light is directly reflected by the viewer'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 镜面光直接被观察者反射'
- en: '](img/Figure_10.03_B17866.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 10.03_B17866.jpg](img/Figure_10.03_B17866.jpg)'
- en: Figure 10.3 – Specular light is directly reflected by the viewer
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 镜面光直接被观察者反射
- en: Emissive
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发射
- en: 'Unlike the other lighting terms, the emissive term is not related to the external
    light source, but rather is light that is generated by the object itself. Importantly
    for lighting design purposes, it does not illuminate other objects in the scene.
    For that reason, emissive lighting is sometimes referred to as self-lighting:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他照明术语不同，发射项与外部光源无关，而是由物体本身产生的光。对于照明设计来说，重要的是它不会照亮场景中的其他物体。因此，发射照明有时被称为自发光：
- en: '![Figure 10.4 – Emissive lighting or self-lighting illuminates only the object
    itself'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – 发射照明或自发光只照亮物体本身'
- en: '](img/Figure_10.04_B17866.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 10.04_B17866.jpg](img/Figure_10.04_B17866.jpg)'
- en: Figure 10.4 – Emissive lighting or self-lighting illuminates only the object
    itself
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 发射照明或自发光只照亮物体本身
- en: So far, we’ve looked at the definitions for the Uem, Uspec, and Udiffuse terms,
    but we’ve said nothing as to how we compute those values in the first place, nor
    how we combine these values. If you are curious, you can go to the *Recommended
    Reading* section of this chapter for more information on the details of these
    equations. The last lighting term we’ll cover is ambient lighting, one of the
    simplest forms of light.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了 Uem、Uspec 和 Udiffuse 术语的定义，但我们没有说明如何首先计算这些值，也没有说明如何组合这些值。如果你对此好奇，可以参考本章的“推荐阅读”部分，了解更多关于这些方程式细节的信息。我们将要讨论的最后一种照明项是环境光，这是最简单的照明形式之一。
- en: Ambient
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境光
- en: 'When ambient lighting is discussed in the context of 3D applications, it refers
    to a general class of lighting contributors that are incident to the surface but
    whose paths do not directly come from the light source. An intuitive example of
    this is the lighting of a cloudy, sunless day. On such a day, all light from the
    environment seems to come from every direction; it’s omnidirectional. Shadows
    (that is, **Ambient Occlusion** or **AO**) can be pre-baked and are easy to make
    and fast to render:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当在3D应用程序的上下文中讨论环境光时，它指的是一类对表面有影响但路径并不直接来自光源的光照贡献者。一个直观的例子是多云无日照的日子。在这样的日子里，来自环境的光似乎来自每个方向；它是全方向的。阴影（即**环境遮挡**或**AO**）可以预先烘焙，制作简单且渲染速度快：
- en: '![Figure 10.5 – UAmbient light doesn’t depend on direction and comes from the
    indirect incidence of light from the source environment. It is approximated by
    a single color with a constant value across the scene'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.5 – 环境光不依赖于方向，来自光源环境的间接照射。它通过场景中具有恒定值的单一颜色进行近似]'
- en: '](img/Figure_10.05_B17866.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.05_B17866.jpg]'
- en: Figure 10.5 – UAmbient light doesn’t depend on direction and comes from the
    indirect incidence of light from the source environment. It is approximated by
    a single color with a constant value across the scene
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.5 – 环境光不依赖于方向，来自光源环境的间接照射。它通过场景中具有恒定值的单一颜色进行近似]'
- en: Because of the indirect path taken by the light ray from the source to the receiver
    via the object’s surface, we approximate the ambient contribution by setting a
    single color per scene. Ambient light has no direction, so its brightness is constant
    throughout the scene.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于光线从光源到接收器经过物体表面的间接路径，我们通过为每个场景设置单一颜色来近似环境贡献。环境光没有方向，因此其亮度在整个场景中保持恒定。
- en: Defining the properties of light and its basic behavior is but one piece of
    the lighting puzzle. The other piece of the puzzle is the surface material properties
    that govern what happens to incident light coming in from a given direction with
    a given view position. Modern 3D engines and asset creation tools have embraced
    the concept of a **material** as a means of defining how an object’s surface reacts
    to light at any given angle and point.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 定义光的基本特性和行为只是光照问题的一部分。问题的另一部分是表面材料特性，它决定了来自特定方向且具有给定视位置的入射光会发生什么。现代3D引擎和资产创建工具已经接受**材料**的概念作为定义物体表面在任何给定角度和点对光反应的手段。
- en: Materials and Textures
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料和纹理
- en: At a conceptual level, a material is a **BRDF** implementation; the material
    contains a combination of data and logic that’s plugged into the relevant terms
    of the overall graphics pipeline (see [*Chapter 11*](B17266_11_Final_AM.xhtml#_idTextAnchor230),
    *Scratching the Surface of Shaders*, for more on graphics pipelines and shaders)
    in the form of programmable shaders, textures, and other attributes. Bringing
    together the concepts from the previous sections, we’ll see why it makes sense
    to use the term **Material** to encompass the specific configuration of shaders
    and textures and introduce the approximations that allow for real-time realistically
    lit scenes in the form of **PBR**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念层面上，一种材料是一种**BRDF**实现；材料包含一组数据与逻辑的组合，这些数据与逻辑被插入到整体图形管道的相关术语中（参见[*第11章*](B17266_11_Final_AM.xhtml#_idTextAnchor230)，*着色器的表面处理*，了解更多关于图形管道和着色器的内容），以可编程着色器、纹理和其他属性的形式存在。结合前几节的概念，我们将看到为什么使用术语**材料**来涵盖着色器和纹理的特定配置是有意义的，并介绍允许以**PBR**形式实现实时逼真光照场景的近似。
- en: Materials Overview
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 材料概述
- en: In Babylon.js, there are two basic general-purpose material components, along
    with a library of specialized ones, that allow you to add cool and interesting
    effects with very little effort. For example, the Lava Material procedurally simulates
    a lava effect to applied meshes, while the Fur Material gives meshes a furry appearance.
    You can even render video from external sources into your scene using the **VideoTexture**!
    Browse the **Babylon.js Materials Library** and read about how to use them at
    [https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary](https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Babylon.js 中，有两个基本的通用材质组件，以及一系列专门的组件库，允许您以非常少的努力添加酷炫和有趣的效果。例如，熔岩材质通过程序化模拟熔岩效果应用于网格，而毛皮材质则使网格看起来像毛茸茸的。您甚至可以使用
    **VideoTexture** 将外部源的视频渲染到场景中！浏览 **Babylon.js 材质库** 并了解如何使用它们，请参阅[https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary](https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary)。
- en: '**StandardMaterial** is the workhorse material in Babylon.js. Materials in
    general (for example, **StandardMaterial**) group color and texture attributes
    and shaders, with an important performance implication: each distinct material
    is drawn to the screen in a separate call. Better performance is generally realized
    with fewer draw calls, so avoid creating new instances of a particular material
    and instead assign existing instances to meshes when possible. **PBRMaterial**
    is the Babylon.js implementation of PBR, a technique we’ll discuss in further
    detail shortly.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准材质**是 Babylon.js 中的工作马材料。一般来说，材质（例如，**标准材质**）将颜色、纹理属性和着色器分组，这有一个重要的性能影响：每个不同的材质都会在单独的调用中绘制到屏幕上。通常，通过减少绘制调用可以获得更好的性能，因此应避免创建特定材质的新实例，而应尽可能将现有实例分配给网格。**PBR材质**是
    Babylon.js 对 PBR（物理基础渲染）的实现，我们将在稍后详细讨论这一技术。'
- en: Which material to use, be it standard or PBR, depends on the needs of the scene.
    Most of the time, a properly set up **PBRMaterial** will have a far greater degree
    of photorealism than one using **StandardMaterial**. The realism comes at the
    expense of greater computational cost. Given the additional and much more complex
    BRDF involved, it doesn’t always make the most sense. For example, a depiction
    of a star, such as the Sun in the route planning screen, should use **StandardMaterial**
    since it self-illuminates via emissive lighting. **Emissive lighting** isn’t necessarily
    contradictory to a PBR process, but in the example of the Sun, any visual benefits
    of PBR are lost in the emissive glare.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是使用标准材质还是 PBR，都取决于场景的需求。大多数情况下，正确设置的 **PBR材质** 将比使用 **标准材质** 的材质具有更高的照片级真实感。这种真实感是以更高的计算成本为代价的。考虑到涉及到的更复杂的
    BRDF，这并不总是最合理的选择。例如，在路线规划屏幕上对恒星（如太阳）的描绘应使用 **标准材质**，因为它通过发射光照自发光。**发射光照**并不一定与
    PBR 过程相矛盾，但在太阳的例子中，任何 PBR 的视觉优势都丢失在发射的眩光中。
- en: As mentioned earlier, a material is a container and a wrapper of both assets
    and executable logic. Calling back to even earlier discussions, it is responsible
    for computing the various lighting terms in its BRDF. The **Ambient**, **Specular**,
    **Emissive**, and **Diffuse** options can vary by the material type for the specialized
    materials, but for both **StandardMaterial** and **PBRMaterial**, each of those
    lighting terms can be specified by either a color or a set of one or more different
    texture images.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，材质是一个容器和包装器，用于资产和可执行逻辑。回顾更早的讨论，它负责在其 BRDF 中计算各种光照项。对于专用材质，**环境光**、**镜面光**、**发射光**和**漫反射**选项可能因材质类型而异，但对于
    **标准材质** 和 **PBR材质**，每个光照项都可以通过颜色或一组一个或多个不同的纹理图像来指定。
- en: Textures and Materials
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理和材质
- en: Setting the color for a particular term, say the diffuse term, has the effect
    of introducing that color evenly across every mesh covered by that material. This
    might be OK for some scenarios, but it makes for a very bland and boring-looking
    scene. Assigning textures to different terms is the way to go here, and it’s also
    where the complexity starts ramping up (as if it weren’t already complex enough!)
    significantly. Another factor that complicates things is that the choices and
    types of textures you’ll want to use can differ between **StandardMaterial** and
    **PBRMaterial**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为特定项设置颜色，例如漫反射项，会在该材质覆盖的每个网格上均匀引入该颜色。这可能适用于某些场景，但它会使场景看起来非常单调乏味。将纹理分配给不同的项是这里的方法，而且这也是复杂性开始显著增加的地方（好像它还不够复杂一样！）另一个使事情复杂化的因素是，你想要使用的纹理的选择和类型可能在
    **StandardMaterial** 和 **PBRMaterial** 之间有所不同。
- en: Important note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may notice mention of **PBRMetallicRoughnessMaterial** and **PBRSpecularGlossinessMaterial**
    in the Babylon.js docs and APIs. These materials provide a fast on-ramp to converting
    from using **StandardMaterial** to **PBRMaterial** with little effort or for adding
    PBR to a scene quickly at the cost of fine control over parameters. See [https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR#from-metallicroughness-to-pbrmaterial](https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR#from-metallicroughness-to-pbrmaterial)
    for more on the differences between the simplified PBRXXXMaterials and the general-purpose
    **PBRMaterial**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在 Babylon.js 的文档和 API 中注意到对 **PBRMetallicRoughnessMaterial** 和 **PBRSpecularGlossinessMaterial**
    的提及。这些材质提供了快速从使用 **StandardMaterial** 转换到 **PBRMaterial** 的途径，几乎不需要费力，或者可以快速将
    PBR 添加到场景中，但代价是对参数的精细控制。有关简化 PBRXXXMaterials 和通用 **PBRMaterial** 之间差异的更多信息，请参阅
    [https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR#from-metallicroughness-to-pbrmaterial](https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR#from-metallicroughness-to-pbrmaterial)。
- en: Texturing assets is a sub-skill of 3D graphics design that takes practice, patience,
    and the ability to look at the world in a slightly warped fashion. If a mesh’s
    material is its costume, then the material’s textures are the mesh’s blouse. A
    mesh defines a 2D set of coordinates for each vertex commonly referred to as `(u,v)`
    instead of `(x,y)`. A `[0,1]`. It is the point on the texture that, when sampled,
    defines the color of that point on the mesh. This lookup is referred to as using
    a **Texture Map**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对纹理资产进行着色是 3D 图形设计的一个子技能，需要练习、耐心和以略微扭曲的方式观察世界的能力。如果一个网格的材质是它的服装，那么材质的纹理就是网格的上衣。网格为每个顶点定义了一个二维坐标集，通常称为
    `(u,v)` 而不是 `(x,y)`。它是纹理上的一个 `[0,1]` 点，当采样时，定义了网格上该点的颜色。这种查找被称为使用 **纹理贴图**。
- en: On the topic of maps, think of how you can project the Earth, which is spherical,
    onto a flat piece of paper. Even though Australia is roughly three times larger
    in area, Greenland appears to be the same size. This is the distortion inherent
    to mapping the surface of a sphere onto the surface of a plane, and the degree
    to which it will be apparent is largely dependent upon the geometry that the texture
    was created to cover. We’ll return to this topic when we cover spherical environment
    maps, but returning to the topic of **Texture Maps**, it is the lookup aspect
    that is most pertinent to our current discussion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于贴图的话题，想想如何将球形地球投影到一张平面上。尽管澳大利亚的面积大约是三倍，但格陵兰岛看起来大小相同。这是将球面表面映射到平面表面固有的扭曲，其明显程度在很大程度上取决于纹理创建时覆盖的几何形状。当我们介绍球形环境贴图时，我们将回到这个话题，但回到
    **纹理贴图** 的话题，它在我们当前讨论中最相关的是查找方面。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Albedo** is to **Diffuse** as **Reflectivity** is to **Specular** when looking
    at the Babylon.js **PBRMaterial**. Colors can be set for each lighting term as
    an alternative or in addition to textures providing the same.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看 Babylon.js 的 **PBRMaterial** 时，**Albedo** 对 **Diffuse** 的作用就像 **Reflectivity**
    对 **Specular** 的作用。可以为每个光照项设置颜色，作为纹理提供相同效果的替代或补充。
- en: As we saw earlier in our discussion of *How Light is Modeled*, there is more
    to lighting than just looking up a particular color from a texture and adjusting
    its intensity based on the distance to the light source. The preceding *Note*
    gives an analogy for translating the terms for base texture between materials,
    but there will often be more than one texture involved in a Material.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前关于 *如何模拟光线* 的讨论中看到的，照明不仅仅是根据纹理查找特定颜色并根据光源距离调整其强度。前面的 *提示* 给出了在材质之间转换基础纹理术语的类比，但通常在材质中会涉及不止一个纹理。
- en: When additional image textures are mixed with either `diffuseTexture` in `albedoTexture`
    in `bumpTexture`. An **ambient** (sometimes also called **occlusion**) texture
    and other lighting factors, such as the **surface normal (N)**, aren’t part of
    a regular texture image and are supplied as data contained in one or more separate
    texture images. Most 3D content creation software has varying capabilities for
    generating and creating these alternative types of textures, and as a result,
    most 3D models that can be obtained via asset marketplaces and the like will already
    have these textures packaged. The key to making the best use of these is knowing
    which things to plug into what values, so let’s learn about the parameters that
    we can supply before looking at how we can supply them!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当额外的图像纹理与 `diffuseTexture` 中的 `albedoTexture` 或 `bumpTexture` 混合时。一个 **环境**（有时也称为
    **遮挡**）纹理和其他光照因素，如 **表面法线 (N)**，不是常规纹理图像的一部分，而是作为包含在一个或多个单独纹理图像中的数据提供。大多数 3D 内容创建软件具有生成和创建这些替代类型纹理的不同能力，因此，大多数可以通过资产市场等途径获得的
    3D 模型已经包含这些纹理。充分利用这些纹理的关键在于知道将哪些东西连接到哪些值，因此，在我们探讨如何提供这些参数之前，让我们先了解我们可以提供哪些参数！
- en: PBR as a Different Type of BRDF
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PBR 作为一种不同的 BRDF 类型
- en: 'Looking at **PBRMaterial** through the “lens” of the **BRDF**, though the output
    has the same shape (that is, format) as any other BRDF, the means of arriving
    at the values is quite different. This manifests in the form of a whole swathe
    of different parameters controlling very specific aspects of the material’s behavior
    toward lighting. Here is a selected list of commonly used properties and a short
    description, in the order that they appear in the Babylon.js documentation at
    [https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR](https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR).
    This page contains many Playground examples showing the different effects of setting
    various PBR properties, which can be useful in understanding what options are
    available:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 **BRDF** 的“透镜”观察 **PBRMaterial**，尽管输出与任何其他 BRDF 的形状（即格式）相同，但到达这些值的方法却相当不同。这体现在一系列不同的参数上，这些参数控制着材料对光照行为的非常具体方面。以下是一个常用属性列表及其简要描述，按照它们在
    Babylon.js 文档中的顺序排列，文档地址为 [https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR](https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR)。此页面包含许多
    Playground 示例，展示了设置各种 PBR 属性的不同效果，这些效果在理解可用的选项时可能很有用：
- en: '**Metallic**: This affects the specular term and determines how much the material
    behaves like a conductive or metal substance.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金属度**: 这影响镜面项并决定材料有多像导电或金属物质。'
- en: '**Roughness**: This specifies how smooth a surface is. Smoother surfaces will
    have sharper specular highlights (that is, shiny spots).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗糙度**: 这指定了表面的平滑程度。更平滑的表面将会有更尖锐的镜面高光（即，光亮的斑点）。'
- en: '`#sub-surface`): A whole category of properties that are used in things from
    flesh tones to translucent reflective materials. This specifically applies to
    refraction and translucency in v5.0 of Babylon.js. It also controls the scattering
    effect.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#sub-surface`): 这是一类用于从肤色到半透明反射材料等物品中的属性。这特别适用于 Babylon.js v5.0 中的折射和半透明度。它还控制散射效果。'
- en: '`#clear-coat`): Models light interactions with the topmost surface of the material.
    A shiny clean waxed car has a clear coat layer just visible above the actual paint
    color.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#clear-coat`): 这用于描述材料最顶层表面与光照的相互作用。一辆光亮干净的抛光汽车在其实际漆色之上仅可见一层清漆层。'
- en: '`#anisotropy`): This is used to shape asymmetrical reflections (specular highlights)
    and is highly dependent upon view and incident angles.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#anisotropy`): 这用于塑造非对称反射（镜面高光）并且高度依赖于视角和入射角度。'
- en: Many different parameters and settings can be configured on **PBRMaterial**,
    so it’s worth taking a step back to look at what goes into PBR.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 **PBRMaterial** 上配置许多不同的参数和设置，因此值得退后一步看看 PBR 中包含的内容。
- en: PBR and IBL
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PBR 和 IBL
- en: Formally speaking, `useRoughnessFromMetallicTextureAlpha` and `useMetallnessFromMetallicTextureBlue`
    can allow broad flexibility on the part of the asset designer, as well as the
    developer, to be creatively efficient in how material data is supplied at runtime.
    This can be of vital importance when memory and compute resources are limited
    – it’s far better to process a single texture than three separately. PBR can give
    great-looking results on its own in a scene, but it is far more effective when
    used in conjunction with IBL.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从正式的角度来说，`useRoughnessFromMetallicTextureAlpha`和`useMetallnessFromMetallicTextureBlue`可以允许资产设计师以及开发者，在运行时提供材质数据时具有广泛的灵活性，从而在创意上更加高效。当内存和计算资源有限时，这一点至关重要——处理单个纹理远比处理三个单独的纹理要好。PBR可以在场景中产生非常好的效果，但与IBL结合使用时效果更佳。
- en: Important note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Despite the superficial resemblance to the acronym for **Irritable Bowel Syndrome**
    (**IBS**), IBL has nothing to do with yours nor with anyone else’s bowels. Neither
    does PBR, in case there was any need for clarification.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与**肠易激综合症**（**IBS**）的缩写有表面上的相似之处，但IBL与你的或任何人的肠道都没有关系。PBR也是如此，以防需要澄清。
- en: '**IBL** is a technique for lighting a scene that derives a scene’s primary
    lighting information from an image source. While other light sources may still
    be present, such as a **PointLight**, they are there to provide secondary and/or
    supplemental illumination. IBL is a distinctly different category of technique
    from PBR, but it doesn’t make much sense to set up an IBL scene and not use PBR
    Materials that can take advantage of it! The way that IBL works is that, during
    rendering, a **high dynamic range** (**HDR**) image – that’s been specially captured
    and prepared as a **CubeMap** – is sampled to supply the Li values instead of
    a particular light source.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**IBL**是一种照明场景的技术，它从图像源中获取场景的主要光照信息。尽管可能仍然存在其他光源，例如**点光源**，但它们的存在是为了提供次要和/或补充照明。IBL是PBR技术的一个明显不同的类别，但如果不使用可以利用它的PBR材质来设置IBL场景，那就没有太多意义！IBL的工作方式是在渲染过程中，采样一个特别捕获和准备的**高动态范围**（**HDR**）图像——这是一个作为**立方体贴图**准备的图像——来提供Li值，而不是特定的光源。'
- en: Environment Textures and Reflection Textures
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境纹理和反射纹理
- en: One of the benefits of using IBL and PBR is that with the right setup, things
    that would be otherwise complex to procedurally model simply fall out of the physical
    light simulation. Take, for example, an urban scene.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IBL和PBR的一个好处是，在正确的设置下，那些原本复杂难以通过程序建模的事物，可以简单地从物理光照模拟中产生。以城市场景为例。
- en: It is night, and there are neon lights above dark restaurant doorways. The center
    of the scene is a four-way street intersection, where a car has suffered an accident.
    Reflections in the windshield show the surrounding buildings, while shattered
    panes of glass gleam with scintillations tinged with the neon glow of signs advertising
    cheap beer. Water gushes onto the street from a broken fire hydrant, and in the
    rippling faces of the growing puddles, the driver’s shock of curly hair can be
    seen exploding from the sides of the airbag, her visible eye appearing to tremble
    with the rippling puddle. What a rich description!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 夜幕降临，黑暗的餐厅门口上方闪烁着霓虹灯。场景的中心是一个四岔路口，一辆汽车在那里发生了事故。挡风玻璃上的反射显示出周围的建筑，而破碎的玻璃窗片在霓虹灯招牌的廉价啤酒广告的闪烁中闪耀着。从破裂的消防栓中涌出的水流到街道上，在逐渐扩大的水坑的波纹面上，可以看到驾驶员卷曲的头发从安全气囊的两侧爆炸开来，她可见的眼睛似乎随着波纹的水坑而颤抖。多么丰富的描述啊！
- en: In a conventional or, more accurately nowadays, a more legacy rendering approach,
    almost all the details described in the preceding passage would need to be custom
    crafted and coded for a single use and purpose. Using IBL and PBR in combination
    with appropriate texture assets can allow designers to create and use scenes with
    the kind of details you can only read about in a cheap noir detective novel! The
    key component of an IBL setup is the image part, naturally. This image is known
    as the **Environment Texture** and, as mentioned earlier, is what is sampled to
    provide lighting information for **PBRMaterial** instances.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的或更准确地说，如今更传统的渲染方法中，前面段落中描述的几乎所有细节都需要为单一用途和目的定制制作和编码。使用IBL和PBR以及适当的纹理资产，可以让设计师创建和使用只有在你能在廉价黑色侦探小说中读到的那种细节的场景！IBL设置的组成部分自然是图像部分。这个图像被称为**环境纹理**，正如之前提到的，它是为**PBRMaterial**实例提供光照信息的样本。
- en: While it is certainly possible to specify a separate environment map for each
    **PBRMaterial**, it’s generally easier to set it up on the **Scene**, a task which
    we will see how to accomplish in greater detail in the next section, *Working
    with PBR Materials and IBL Scenes*. A specific use case where an environment texture
    and a material’s reflection texture might be different might be the rear-view
    mirror of a car, which shows not just the environment but reflections of objects
    within the scene itself – something that IBL and environment lighting can’t do.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当然可以为每个**PBRMaterial**指定一个单独的环境贴图，但通常在**Scene**上设置它更容易，我们将在下一节中更详细地了解如何完成这项任务，即*与PBR材料和IBL场景一起工作*。一个可能的环境纹理和材料的反射纹理可能不同的特定用例是汽车的倒车镜，它不仅显示了环境，还显示了场景中物体的反射——这是IBL和环境光照所无法做到的。
- en: 'In this scenario, a common solution is to dynamically generate a reflection
    texture using a **Reflection Probe**. This is a form of **Render Target Texture**
    (which itself is a form of procedural texture) that can provide an updated environment
    map from a specified position’s perspective using a list of render targets to
    track. The Babylon.js docs contain more details on how to use reflection probes:
    [https://doc.babylonjs.com/divingDeeper/materials/using/reflectionTexture#dynamic-environment-maps-rendertargettexture-and-friends](https://doc.babylonjs.com/divingDeeper/materials/using/reflectionTexture#dynamic-environment-maps-rendertargettexture-and-friends).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，一个常见的解决方案是使用**Reflection Probe**动态生成一个反射纹理。这是一种**Render Target Texture**（它本身是一种程序纹理），可以从指定位置的角度使用一系列渲染目标来跟踪，从而提供更新的环境贴图。Babylon.js文档中包含了更多关于如何使用反射探针的详细信息：[https://doc.babylonjs.com/divingDeeper/materials/using/reflectionTexture#dynamic-environment-maps-rendertargettexture-and-friends](https://doc.babylonjs.com/divingDeeper/materials/using/reflectionTexture#dynamic-environment-maps-rendertargettexture-and-friends)。
- en: In this section, we’ve introduced a raft of new concepts, such as the **BRDF**
    and some of the parameters and terms involved in simulating lighting, starting
    with an understanding of the difference between diffuse, specular (Albedo), emissive,
    and ambient lighting sources. That laid the groundwork for us to explore the concept
    of a material with a focus on the Babylon.js **PBRMaterial**. **PBRMaterial**
    implements a technique known as PBR, which uses lighting information provided
    by the environment, along with a constellation of material properties, to realistically
    simulate the behavior of light against surfaces rough and shiny, smooth, and dull.
    Once we learned about materials and lighting, we looked at how **IBL** can be
    used to further enhance the realism of a rendered scene.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一系列新的概念，例如**BRDF**以及一些与模拟光照相关的参数和术语，从理解漫反射、镜面（反照率）、发射和环境光照源之间的区别开始。这为我们探索具有重点的Babylon.js
    **PBRMaterial**这一材料概念奠定了基础。**PBRMaterial**实现了一种称为PBR的技术，它使用环境提供的照明信息，结合一系列材料属性，以逼真地模拟光线在粗糙和光滑、平滑和暗淡的表面上的行为。一旦我们了解了材料和光照，我们就探讨了如何使用**IBL**进一步增强渲染场景的真实感。
- en: In the next section, we’re going to put theory into practice and learn about
    the different assets needed to make use of the previously discussed concepts.
    After learning about some of the asset types involved and the file and image formats
    related to them, we’ll look at some of the tooling needed to produce those assets
    and how to use them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将理论付诸实践，了解使用之前讨论的概念所需的不同资产。在了解一些涉及的资产类型以及与之相关的文件和图像格式之后，我们将探讨制作这些资产所需的工具以及如何使用它们。
- en: This is a complicated subject, so if you don’t feel like everything makes sense
    yet, it’s OK to take a beat and look at some of the Playground examples listed
    in the Babylon.js documents. If this section has mostly been a review for you,
    then you might be interested in some of the more advanced topics linked in the
    *Recommended Reading* section earlier in this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的话题，所以如果你觉得还不是一切都很有意义，那么花点时间看看Babylon.js文档中列出的Playground示例是完全可以的。如果这一节对你来说主要是复习，那么你可能对这一章前面“推荐阅读”部分中链接的一些更高级主题感兴趣。
- en: Working with PBR Materials and IBL Scenes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与PBR材料和IBL场景一起工作
- en: '**StandardMaterial** is very forgiving when it comes to being able to use various
    types of assets. It doesn’t mind if a texture is 8, 16, or 3 bits per pixel or
    JPEG, GIF, or PNG – it’ll paint a mesh with it. While this is also largely true
    for **PBRMaterial** in that it is a robust component and able to operate with
    a wide range of inputs, the rendered look of any **PBRMaterial** is far more sensitive
    to insufficient or improperly formatted texture data. We’re going to look at the
    specifics of what the Babylon.js PBR implementation expects, as well as the tools
    that will help create assets that fit those specifications. Later, we’ll go through
    the heuristics – a set of guidelines – of how to decide what and which assets
    and values to put into which properties to accomplish a particular look for your
    material. Let’s start by examining some of the ways to represent an image digitally.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**StandardMaterial**在能够使用各种类型的资产方面非常宽容。它不介意纹理是每像素8位、16位还是3位，也不介意是JPEG、GIF还是PNG
    – 它会用它来绘制网格。虽然这在**PBRMaterial**中也大致正确，因为它是一个健壮的组件，能够处理广泛的输入，但任何**PBRMaterial**的渲染外观对不足或不正确格式的纹理数据非常敏感。我们将探讨Babylon.js
    PBR实现的具体要求，以及有助于创建符合这些规范的资产的工具。稍后，我们将讨论启发式方法——一套指南——如何决定将哪些资产和值放入哪些属性中，以实现材料特定的外观。让我们首先检查一些表示数字图像的方法。 '
- en: Image Formats and File Types
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像格式和文件类型
- en: Bitmaps are the simplest type of image. The name says it all – it’s a sequential
    array (or map) of values that each represent a single channel (red, green, or
    blue) of a single pixel in the image. When an image is decompressed into (typically
    the GPU) RAM, a bitmap is the result. With each pixel mapped to a different location
    in memory, it is extremely fast to look up values from arbitrary locations in
    the image. When storing images on a disk, however, the goal is to optimize file
    size at the expense of computational speed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 位图是最简单的图像类型。名字已经说明了一切——它是一个按顺序排列的值数组（或映射），每个值代表图像中单个像素的单个通道（红色、绿色或蓝色）。当图像解压缩到（通常是GPU）RAM中时，结果是位图。由于每个像素都映射到内存中的不同位置，因此从图像中的任意位置查找值非常快。然而，当在磁盘上存储图像时，目标是优化文件大小，以牺牲计算速度为代价。
- en: There are only a few file formats that can support HDR images. Two popular native
    HDRI formats are **HDR** and **EXR**. The RAW image format captures pixel values
    as close to the digital camera’s sensors as possible, meaning calibration may
    be needed across different devices to get consistent results. Some image types,
    such as TIFF, can act as containers for other images, and similarly, some offer
    a wide range of options in their formats, such as **DDS**. Despite their popularity,
    GIF, and JPEG are not formats that are capable of representing an **HDRI**, even
    though they may still be able to display what appears to be an HDR image. This
    is made possible by a process known as **tone mapping**, which we’ll discuss after
    we finish exploring why a JPEG isn’t an HDRI. To do so, we will cover bit depth
    and dynamic ranges.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 能够支持HDR图像的文件格式只有少数几种。两种流行的原生HDRI格式是**HDR**和**EXR**。RAW图像格式尽可能接近数字相机的传感器捕获像素值，这意味着可能需要在不同的设备上进行校准以获得一致的结果。某些图像类型，如TIFF，可以作为其他图像的容器，同样，一些格式提供了广泛的选择，例如**DDS**。尽管GIF和JPEG很受欢迎，但它们并不是能够表示**HDRI**的格式，尽管它们仍然能够显示看似HDR的图像。这是通过称为**色调映射**的过程实现的，我们将在探讨完为什么JPEG不是HDRI之后讨论它。为此，我们将涵盖位深度和动态范围。
- en: Bit Depth and Dynamic Ranges
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位深度和动态范围
- en: When thinking about graphics and how they are displayed, it’s useful to break
    the topic down into fundamentals. Each pixel of an image has a value for each
    of the red, green, and blue color channels (some images may also have an additional
    alpha channel for transparency).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当思考图形及其显示方式时，将其分解为基本概念是有用的。图像的每个像素都有红色、绿色和蓝色颜色通道的值（某些图像可能还有一个用于透明度的额外alpha通道）。
- en: If we use a single byte (8 bits) to represent each channel, we have 24 or 32
    bits per pixel, again depending on the presence of a dedicated alpha channel.
    Each color channel can only take on a value between 0 and 255, for a total of
    65,536 total unique possible colors in the **color space**. That sounds like a
    lot of colors – and it is – but it is a far cry from the range of colors discernable
    by the human eye. More importantly, in the context of display technologies, it
    is incapable of properly representing an HDR without **tone mapping**. Tone mapping
    is the process of scaling down from the infinite to the finite in discrete steps.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个字节（8位）来表示每个通道，那么每个像素就有24或32位，这取决于是否存在专门的alpha通道。每个颜色通道只能取0到255之间的值，总共65,536种可能的独特颜色在**颜色空间**中。这听起来颜色很多——确实如此——但它远远低于人眼所能分辨的颜色范围。更重要的是，在显示技术的背景下，它无法在没有**色调映射**的情况下正确地表示HDR。色调映射是将无限缩小到有限的过程，通过离散的步骤进行。
- en: Between zero and one lies infinity, or close enough to it if you’re using 32-bit
    floating point numbers to represent a color channel. On the other hand, the much
    smaller and countable ratio of 1:256 is the full dynamic range possible in an
    8-bit channel. To be a **High Dynamic Range Image** (**HDRI**), an image needs
    to be able to use 16- or 32-bit floating point numbers to represent the red, green,
    and blue color channels. This adds up to a total of 48/96 bits per pixel, allowing
    for a theoretically 1:infinite dynamic range. As a practical matter, though, this
    can take quite a large amount of space – a 4K image has roughly 8.3 million pixels,
    and at 96 bpp has a raw size of 800 MB!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在零和一之间是无穷大，或者如果你使用32位浮点数来表示颜色通道，那么它就足够接近无穷大了。另一方面，1:256这个更小且可计数的比例是8位通道中可能的全动态范围。要成为**高动态范围图像**（**HDRI**），图像需要能够使用16位或32位浮点数来表示红色、绿色和蓝色颜色通道。这总共是每像素48/96位，理论上可以实现1:无穷大的动态范围。然而，实际上，这可能会占用相当大的空间——一个4K图像大约有830万个像素，以96
    bpp计算，原始大小约为800 MB！
- en: That’s not all, though. An image used in PBR and IBL needs to have what is known
    as **mipmaps**, either generated at loading time or pre-baked into the image file.
    A **mipmap** is a lower-resolution version of the main texture and is used similarly
    to a meshes **Level-of-Detail** (**LOD**) in which objects further away are rendered
    using less detailed textures, thus saving memory and rendering time. Just like
    auto-LOD works for meshes, Babylon.js can generate mipmaps at the time a texture
    is loaded.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但不仅如此。用于PBR和IBL的图像需要具有所谓的**米普贴图**，这些米普贴图可以在加载时生成，也可以预先烘焙到图像文件中。**米普贴图**是主纹理的较低分辨率版本，其使用方式类似于网格的**细节级别**（**LOD**），其中远离的对象使用更详细的纹理进行渲染，从而节省内存和渲染时间。就像自动LOD对网格起作用一样，Babylon.js可以在加载纹理时生成米普贴图。
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As pretty much anyone who has purchased a download-only version of a modern
    AAA game knows, those high-quality textures come with a high-bandwidth and high-disk
    usage cost. The last installment of the *Call of Duty* franchise, *Modern Warfare*,
    is over 175 GB! If the assets are all that size after being compressed, consider
    how large the textures are and that will answer the question of what all those
    gigabytes of RAM are doing during gameplay.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有购买过现代AAA游戏下载版的人都知道，这些高质量的纹理伴随着高带宽和高磁盘使用成本。*使命召唤*系列的最后一部作品，*现代战争*，超过175 GB！如果资产在压缩后都是这个大小，那么考虑一下纹理的大小，这将回答在游戏过程中那些GB的RAM都在做什么的问题。
- en: It’s not just important that an art asset looks good in an image viewer – it
    must be sized and formatted properly so that it contains or retains the full range
    of colors and brightness across the image. Fortunately, there are a few available
    tools within the Babylon.js ecosystem alone that can help with that task.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个艺术资产在图像查看器中看起来不错固然重要，但它的大小和格式必须正确，以确保它在整个图像中包含或保留完整的颜色和亮度范围。幸运的是，仅Babylon.js生态系统内就有一些可用的工具可以帮助完成这项任务。
- en: Using and Creating Assets for PBR and IBL
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于PBR和IBL的资产的使用和创建
- en: 'Because there are such varying ways to consume and use assets with PBR and
    IBL, it’s difficult to figure out what to use where, and why. Assets created specifically
    for a given project are the most likely to give the best results overall but have
    the inherent difficulty of requiring the skill and knowledge to create the assets
    yourself, or the financial resources to purchase or commission the assets from
    someone who does. Regardless of how the texture or other asset is obtained, more
    decisions are required to assess its suitability and compatibility with Babylon.js.
    The following diagram illustrates the high-level decision-making process you can
    use to evaluate a given texture asset, known as the “I” in IBL:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 PBR 和 IBL 消费和使用资产的方式多种多样，很难确定在哪里使用什么，以及为什么。专门为特定项目创建的资产最有可能带来最佳的整体效果，但同时也存在需要自己创建资产或购买或委托他人创建资产的技能和知识，或者需要购买资产的财务资源的固有困难。无论以何种方式获取纹理或其他资产，都需要更多决策来评估其适合性和与
    Babylon.js 的兼容性。以下图表说明了您可以使用的高级别决策过程来评估给定的纹理资产，称为 IBL 中的“我”：
- en: '![Figure 10.6 – High-level evaluation process for working with a texture and
    IBL/PBR. This is a qualitative assessment, not a quantitative one, so other factors
    such as texture resolution are still important to evaluate'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – 使用纹理和 IBL/PBR 的高级别评估流程。这是一个定性评估，而不是定量评估，因此其他因素，如纹理分辨率，仍然很重要进行评估'
- en: '](img/Figure_10.06_B17866.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.06_B17866.jpg)'
- en: Figure 10.6 – High-level evaluation process for working with a texture and IBL/PBR.
    This is a qualitative assessment, not a quantitative one, so other factors such
    as texture resolution are still important to evaluate
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 使用纹理和 IBL/PBR 的高级别评估流程。这是一个定性评估，而不是定量评估，因此其他因素，如纹理分辨率，仍然很重要进行评估
- en: Let’s walk through the highlights for each of these nodes. Keep in mind that
    whether or not an asset is suitable for use with PBR and IBL doesn’t necessarily
    mean that it is useful. At the same time, it is useful to consider the context
    in which the asset will be viewed; what good is a high-resolution texture that
    is only ever rendered at a large distance from the camera?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一概述这些节点的亮点。请记住，资产是否适合与 PBR 和 IBL 一起使用并不一定意味着它是有用的。同时，考虑资产将被查看的上下文也很重要；一个仅在相机远处渲染的高分辨率纹理有什么好处？
- en: Obtaining Assets
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取资产
- en: 'This step is one of the more complicated and hard-to-define steps. The process
    of getting the proper 3D assets will differ greatly, depending on a few basic
    factors:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步是较为复杂且难以定义的步骤之一。获取适当的 3D 资产的过程将因几个基本因素而有很大差异：
- en: Access to a professional graphic artist (and the time for them to work on it!)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取专业图形艺术家的服务（以及他们工作所需的时间！）
- en: Purchase/obtain an asset pack from a vendor
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从供应商处购买/获取资产包
- en: Self-authoring capabilities – for example, produce everything yourself
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自我创作能力 – 例如，自己制作所有内容
- en: A la carte assemble assets from a mixture of sources
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多种来源混合组装资产
- en: Important note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: No matter which approach or path you take, always make sure that you have clear
    and free permission and rights to use an art asset before deciding to include
    it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪种方法或路径，在决定包含艺术资产之前，务必确保您有明确和免费的许可和权利使用该艺术资产。
- en: If you have the resources, it’s best to engage with a professional artist or
    team of artists, but these people can’t draw for free. Be prepared to compensate
    them for their work. Purchasing a set of pre-made assets can often be almost as
    good as having assets custom made-to-suit, but they have the advantage of being
    able to be deployed almost immediately at the cost of a lack of flexibility –
    any changes or file conversions are up to you. Unless you are a polymath – that
    is, professionally skilled in multiple areas such as the famed creator of Babylon.js
    **Deltakosh**, then it’s usually going to be a better use of your time and efforts
    to not try and do more than a light edit of assets.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有资源，最好是聘请专业艺术家或艺术家团队，但这些人不免费绘画。准备好为他们的工作支付报酬。购买一套预制的资产通常几乎与定制资产一样好，但它们的优势在于几乎可以立即部署，代价是缺乏灵活性——任何更改或文件转换都由您负责。除非您是多面手——也就是说，在多个领域（如
    Babylon.js 著名的创建者 **Deltakosh**）专业熟练，否则通常将时间和精力用于对资产的轻微编辑会更好。
- en: Important note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don’t neglect to browse through the Babylon.js Asset Library – it contains many
    very useful “base” texture and mesh assets that are ready for you to put into
    your project! New to v5, the Asset Librarian is a tool for directly injecting
    references to BJS Assets into a Playground. You can learn more at [https://doc.babylonjs.com/toolsAndResources/assetLibrarian](https://doc.babylonjs.com/toolsAndResources/assetLibrarian).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忽视浏览 Babylon.js 资产库——它包含许多非常实用的“基础”纹理和网格资产，这些资产已经准备好供您将其放入项目中！从 v5 版本开始，资产管理员是一个工具，可以直接将
    BJS 资产的引用注入到游乐场中。您可以在[https://doc.babylonjs.com/toolsAndResources/assetLibrarian](https://doc.babylonjs.com/toolsAndResources/assetLibrarian)了解更多信息。
- en: The last option, a la carte asset amalgamation, is a compromise of the other
    three options, and as such, basically offers almost all the downsides from each
    and only a few of the upsides. The only thing this approach has going for it is
    its flexibility, which can’t be beaten. It is a sort of lowest common denominator
    to take this approach, but care and effort are needed to provide a consistent
    overall look and feel for the application. As a corollary to this approach, there
    is always the “escape hatch” of programmatically setting the material properties
    through code without textures.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项，按需资产合并，是其他三个选项的折中方案，因此基本上提供了每个选项的大部分缺点和少数优点。这个方法唯一的优势是其灵活性，这是无法被超越的。这是一种最低的共同分母，采用这种方法需要小心和努力，以提供应用程序的一致外观和感觉。作为这种方法的一个推论，总是存在通过代码程序设置材质属性的“逃生门”，而不使用纹理。
- en: Environment Textures, Conversions, and Compression
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境纹理、转换和压缩
- en: To be used in Babylon.js as an HDRI for PBR, an environment texture must be
    in an HDR format. If it isn’t, then it needs to be converted into either HDR or
    DDS format if it can store 16- or 32-bit floating point representations of each
    color channel for the texture. From that point, there are a couple of options,
    but from a scene quality perspective, it’s important to make sure that the image
    has been prepared as either a single **Equirectangular** or as a series of **CubeMap**
    images.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Babylon.js 中用作 PBR 的 HDRI，环境纹理必须以 HDR 格式。如果不是，则需要将其转换为 HDR 或 DDS 格式，如果它可以存储每个颜色通道的
    16 位或 32 位浮点表示。从那时起，有几个选项，但从场景质量的角度来看，重要的是要确保图像已经准备为单个**等经线**或一系列**立方体贴图**图像。
- en: In a process such as adapting a flat paper map of the world onto a globe, the
    environment map represents a spherical or panoramic view of the surrounding environment.
    As an alternative to using a sphere, a cube can also be used in the same fashion,
    with a projected image of each face on the cube unwrapped into six separate images
    or image sections. See [https://doc.babylonjs.com/divingDeeper/environment/skybox#about-skyboxes](https://doc.babylonjs.com/divingDeeper/environment/skybox#about-skyboxes)
    for more on **CubeMap** images.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在将世界平面的地图适应到球体上的过程中，环境贴图代表周围环境的球形或全景视图。作为使用球体的替代方案，也可以以相同的方式使用立方体，每个面的投影图像展开成六个单独的图像或图像部分。有关**立方体贴图**的更多信息，请参阅[https://doc.babylonjs.com/divingDeeper/environment/skybox#about-skyboxes](https://doc.babylonjs.com/divingDeeper/environment/skybox#about-skyboxes)。
- en: Important note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When the environment texture is a Cube Map, HDR rendering is unavailable and
    seams or other visual artifacts may be visible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当环境纹理是立方体贴图时，HDR 渲染不可用，可能会出现接缝或其他视觉伪影。
- en: 'As mentioned in the *Bit Depth and Dynamic Ranges* section, there is a large
    footprint to storing all that floating-point image data, something that can be
    very important when dealing with web-based applications. The e[asiest way to compress
    a DDS or HDR](https://www.babylonjs.com/tools/ibl/) image for use in an application
    is to use the Babylon.js IBL tool at [https://www.babylonjs.com/tools/ibl/](https://www.babylonjs.com/tools/ibl/).
    Using an image that has been prepared as an equirectangular, as described earlier,
    will give the best results, but it isn’t required. Drag and drop the image file
    you want to use into the central panel of the page and wait a moment – you may
    not see anything immediately happen because it can take some time to process an
    image, depending on its size and type. Once the tool has finished, two things
    will happen: first, the image will appear on the page, prepped and ready as a
    preview. Second, a `.env` file will be downloaded to your computer. This file
    is a compressed and pre-processed version of the source image, and a quick comparison
    of file sizes will show a *significant* difference between the source and output
    files – 30 MB can easily be compressed to a few hundred KB! You can read more
    about the rle-RGBE format and extra pre-computed data that allows this compression
    to be achieved at [https://doc.babylonjs.com/divingDeeper/materials/using/HDREnvironment#what-is-a-env-tech-deep-dive](https://doc.babylonjs.com/divingDeeper/materials/using/HDREnvironment#what-is-a-env-tech-deep-dive).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*位深度和动态范围*部分所述，存储所有这些浮点图像数据需要很大的空间，这在处理基于Web的应用程序时可能非常重要。在应用程序中使用DDS或HDR图像（[https://www.babylonjs.com/tools/ibl/](https://www.babylonjs.com/tools/ibl/)）的最简单方法是在[Babylon.js
    IBL工具](https://www.babylonjs.com/tools/ibl/)中使用。使用前面描述的作为等角图的准备好的图像将给出最佳结果，但这不是必需的。将你想要使用的图像文件拖放到页面中央面板，稍等片刻——你可能不会立即看到任何变化，因为处理图像可能需要一些时间，这取决于其大小和类型。一旦工具完成，将发生两件事：首先，图像将出现在页面上，准备就绪作为预览。其次，一个`.env`文件将被下载到你的电脑上。这个文件是源图像的压缩和预处理版本，通过文件大小的快速比较将显示出源文件和输出文件之间的*显著*差异——30
    MB可以轻松压缩到几百KB！你可以在[https://doc.babylonjs.com/divingDeeper/materials/using/HDREnvironment#what-is-a-env-tech-deep-dive](https://doc.babylonjs.com/divingDeeper/materials/using/HDREnvironment#what-is-a-env-tech-deep-dive)了解更多关于rle-RGBE格式和允许实现这种压缩的额外预计算数据。
- en: Assigning to Material Texture Slots
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配给材质纹理槽
- en: The non-environmental texture section of *Figure 10.6* illustrates some of the
    more commonly used texture channels in a Babylon.js **PBRMaterial**, along with
    some things to keep in mind when using it. For example, when using a texture to
    define the material’s metallic and/or roughness parameters, it might be necessary
    to specify which color channel (R, G, or B) contains the relevant data values.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.6*的非环境纹理部分展示了Babylon.js **PBRMaterial**中一些更常用的纹理通道，以及在使用时需要注意的一些事项。例如，当使用纹理来定义材质的金属和/或粗糙度参数时，可能需要指定哪个颜色通道（R、G或B）包含相关数据值。'
- en: Some properties of **PBRMaterial** expand into a new set of properties, many
    of which can accept a texture as the means of specifying values. Clear coat, subsurface,
    and detail maps (and more) each have their own set of parameters and textures
    that can be used to improve the quality of the final output, making for a bewildering
    array of possible configurations. Don’t worry about trying to understand and visualize
    every one of them and how they work – in the next chapter, we’ll learn how the
    **Node Material Editor** (**NME**) helps make sense of these options.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**PBRMaterial**的一些属性扩展成一组新的属性，其中许多可以接受纹理作为指定值的手段。清漆、次表面和细节图（等等）各自都有自己的一套参数和纹理，可以用来提高最终输出的质量，从而产生一个令人眼花缭乱的配置组合。不必担心试图理解并可视化每一个选项及其工作原理——在下一章中，我们将学习**节点材质编辑器**（**NME**）如何帮助理解这些选项。'
- en: In this section, we built upon the theoretical foundations established by previous
    sections to learn about how **HDR** images are digitally represented and stored.
    An HDR image is in **linear color space** (as opposed to **gamma** or **sRGB**
    space – that is, how many and what arrangement of bits are used to represent each
    color channel) and uses at least 16-bit floating point numbers for each color.
    Most of the time, in standard Dynamic Range images, linear colors fall between
    the range of [0,1]. An HDRI, though, has a range that can, at a practical level,
    go from [0, ∞]. For example, an HDRI of a scene including the Sun on a cloudless
    day might have a range of [0, 150000]!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们基于前几节建立的理论基础，学习HDR图像是如何在数字上表示和存储的。HDR图像位于**线性色彩空间**（与**伽玛**或**sRGB**空间相对——也就是说，每个颜色通道使用多少位以及位的使用方式）中，并且每个颜色至少使用16位浮点数。大多数情况下，在标准动态范围图像中，线性颜色位于[0,1]的范围内。然而，HDRI的范围在实用层面上可以从[0,
    ∞]变化。例如，一个包括晴朗天空中的太阳的场景的HDRI可能具有[0, 150000]的范围！
- en: 'There are several commonly-used file formats for storing HDR images, but the
    two best-supported for use with Babylon.js assets are HDR and DDS. Environment
    textures need to be laid out in either a rectangular projection onto a spherical
    surface – an Equirectangular projection – or as a series of six images in a Cube
    Map. The **Babylon.js IBL Tool** is useful for viewing the fine details of an
    image dropped onto it, but more importantly, it can convert and compress an HDR
    or DDS image into a size much more manageable for use on the web: the ENV file
    format.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 存储HDR图像的常用文件格式有几个，但与Babylon.js资产一起使用支持最好的是HDR和DDS。环境纹理需要布局在球面表面的矩形投影上——即等角投影——或者作为一系列六个图像的立方体贴图。**Babylon.js
    IBL工具**可以用来查看放置在其上的图像的细微细节，但更重要的是，它可以转换和压缩HDR或DDS图像，使其在网页上使用时的大小更加易于管理：ENV文件格式。
- en: Most computer displays and print technologies are incapable of rendering such
    a wide range of values – and indeed, any display capable of accurately representing
    the brightness of the Sun would be an extremely toasty experience for anyone viewing
    it. To accurately render an HDR image in a non-HDR display, it is necessary to
    remap color values back into the range of [0,1]. The process of doing this is
    called **tone mapping** and is part of an important step in finishing a scene
    for presentation, known as **Post-Processing**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机显示器和打印技术无法渲染如此广泛的值范围——实际上，任何能够准确表示太阳亮度的显示器，对于观看者来说都会是一个极其热辣的体验。要在非HDR显示器上准确渲染HDR图像，必须将颜色值重新映射回[0,1]的范围。这个过程被称为**色调映射**，并且是完成场景展示的重要步骤之一，被称为**后期处理**。
- en: Tone Mapping and Basic Post-Processing
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 色调映射和基本后期处理
- en: Although this section is split into separate sub-sections between tone mapping
    and Post-Processing, tone mapping is technically a type of post-process. It’s
    an important enough subject within the context of this chapter to warrant a bit
    of space to explain it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节在色调映射和后期处理之间分为几个独立的子节，但从技术上来说，色调映射是一种后期处理。在本章的背景下，这是一个足够重要的主题，值得占用一些篇幅来解释。
- en: Post-Processing is a familiar concept wrapped in a potentially unfamiliar language.
    When you superimpose cat ears on your FaceTime, Zoom, or Teams calls, you are
    using a post-process. If you select an Instagram filter, you’re using a post-process.
    When you give yourself a cool motion blur effect in TikTok, you’re using a post-process.
    Babylon.js comes with several different built-in effects, both subtle and not
    so, and to avoid you having to remember and create the most common post-process
    effects, there’s also a Default Rendering Pipeline that comes with all the basics
    wrapped up in a plug-and-play fashion.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 后期处理是一个熟悉的概念，但可能用了一种不熟悉的语言。当你将猫耳朵叠加到FaceTime、Zoom或Teams通话中时，你正在使用后期处理。如果你选择Instagram滤镜，你也在使用后期处理。当你想在TikTok中给自己添加一个酷炫的运动模糊效果时，你也在使用后期处理。Babylon.js内置了多种不同的内置效果，既有细微的也有明显的，为了避免你记住并创建最常见的后期处理效果，还有一个默认渲染管线，它将所有基本功能打包在一起，以即插即用的方式提供。
- en: Tone Mapping
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 色调映射
- en: As we discussed in the previous section, rendering an HDR image onto a non-HDR
    display medium requires the values for each pixel’s colors to be remapped from
    a potentially infinite range into a decidedly finite one via the process of tone
    mapping. There are several different algorithms and ways to accomplish this, but
    regardless of the specifics, any tone map is going to have to make compromises.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的，将HDR图像渲染到非HDR显示介质上需要通过色调映射的过程，将每个像素颜色的值从可能的无穷大范围重新映射到一个明确的有限范围内。有几种不同的算法和方法可以实现这一点，但无论具体细节如何，任何色调映射都不可避免地需要做出妥协。
- en: 'Let’s just say that we have a set of numbers – [0.1, 0.1, 0.2, 0.3, 0.5, 0.8,
    1.0, 1.0, 2.5, 10] – that we need to remap into a range between zero and one.
    Here’s a chart that shows the difference before and after tone mapping that series
    using the simplest tone mapping technique:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，我们有一组数字 – [0.1, 0.1, 0.2, 0.3, 0.5, 0.8, 1.0, 1.0, 2.5, 10] – 我们需要将其重新映射到零和一之间的范围。以下是一个图表，显示了使用最简单的色调映射技术前后该系列的变化：
- en: '![Figure 10.7 – Chart of pre- and post- tone mapping combined radiance values
    with HDR values. This mapping doesn’t perfectly capture the original dynamic range
    of values'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 – 预色调映射和后色调映射结合辐射值与HDR值的图表。这种映射并不能完美地捕捉原始值的动态范围'
- en: '](img/Figure_10.07_B17866.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.07_B17866.jpg)'
- en: Figure 10.7 – Chart of pre- and post- tone mapping combined radiance values
    with HDR values. This mapping doesn’t perfectly capture the original dynamic range
    of values
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 预色调映射和后色调映射结合辐射值与HDR值的图表。这种映射并不能完美地捕捉原始值的动态范围
- en: 'The dashed line in the preceding chart shows how the range represented by the
    solid line has been compressed to fit between the zero and one bars of the chart.
    An ideal mapping would closely mimic the solid line as much as possible – this
    is not the case with this simple linear mapping. This is adequate for many applications,
    but other mapping functions can get us closer to matching the curve. A gamma-correction
    function uses two constants, A and γ, which must be either separately computed
    or manually determined, to map values in a way that much more closely matches
    the original curve:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图表中的虚线显示了如何将实线所代表的范围压缩到图表的零和一之间。理想的映射应该尽可能地模仿实线 – 但在这个简单的线性映射中并非如此。这对于许多应用来说是足够的，但其他映射函数可以使我们更接近匹配曲线。伽玛校正函数使用两个常数，A和γ，这些常数必须单独计算或手动确定，以便以更接近原始曲线的方式映射值：
- en: '![Figure 10.8 – Tone mapping with gamma correction produces a curve almost
    indistinguishable from the original. The values for the two constants must be
    determined separately'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8 – 使用伽玛校正的色调映射产生几乎与原始图像无法区分的曲线。两个常数的值必须分别确定'
- en: '](img/Figure_10.08_B17866.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.08_B17866.jpg)'
- en: Figure 10.8 – Tone mapping with gamma correction produces a curve almost indistinguishable
    from the original. The values for the two constants must be determined separately
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 使用伽玛校正的色调映射产生几乎与原始图像无法区分的曲线。两个常数的值必须分别确定
- en: The dashed line perfectly overlaps with the original HDR brightness curve when
    the appropriate values of the constants, A and gamma, are supplied. A drawback
    of this technique is that those constants can vary by display device, OS, and
    other potential variables. Fortunately, Babylon.js does all the work for you when
    it comes to tone mapping as part of its built-in Image Processing and Post-Processing
    features.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供适当的常数A和伽玛的值时，虚线与原始HDR亮度曲线完美重叠。这种技术的缺点是，这些常数可能会因显示设备、操作系统和其他潜在变量而有所不同。幸运的是，Babylon.js在它的内置图像处理和后处理功能中为你完成了色调映射的所有工作。
- en: Post-Processing and the Rendering Pipeline
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后处理和渲染管线
- en: It’s a safe assumption that anyone reading this is familiar with the concept
    of a live camera filter. Flip a switch and your photo looks like an old-time photo,
    another and it takes on the look of a comic book poster, all in real time. If
    you’ve ever wondered how that sort of thing works, then Post-Processing is as
    good a place as any to start! Think of a post-process as being like a real-time
    Photoshop for your scene. In games, some of the more obvious post-processes are
    ones such as rain or snow falling, screen shaking, and the always classic “drunken
    stagger.”
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设阅读这篇文章的任何人熟悉实时相机滤镜的概念。只需切换一下开关，你的照片就会变成老式照片，再切换一下，它就会变成漫画书海报，这一切都在实时进行。如果你曾经好奇过这类事物是如何工作的，那么从后处理开始是个不错的选择！将后处理想象成是实时Photoshop，用于你的场景。在游戏中，一些更明显的后处理包括雨或雪的落下、屏幕震动以及始终经典的“醉酒踉跄”效果。
- en: 'There are a few different ways to implement, import, and employ post-processes
    with Babylon.js, but all post-process effects work the same way: they start with
    a texture. This texture is kind of like a framed blank canvas at the start of
    the frame; the color of the blankness is the Scene’s clear color. If each stage
    in the digital rendering process is like a step in the manual rendering of paint
    onto canvas, the point in time during the frame’s rendering pipeline we are interested
    in is the part after the paint’s been laid down on the canvas but before it’s
    been set and dried. This texture is the output of transforming all the scene’s
    geometry into positions relative to the camera, then to 2D screen space. A post
    process deals with the individual pixels of this texture, not the geometry of
    the scene. Babylon.js has several ready-to-use **PostProcessRenderingPipelines**
    and **PostProcesses** that can be added with a line or two of code. A little bit
    further down the road in the next chapter, we’ll look at how we can create post
    processes and two different ways to accomplish that. Let’s not let the next chapter
    steal this chapter’s thunder and continue to look at more built-in post-processing
    functionality with volumetric light scattering – that is, “God Rays.”'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Babylon.js中，有几种不同的方式来实现、导入和使用后处理，但所有后处理效果的工作方式都是一样的：它们从纹理开始。这种纹理在帧的开始就像一个装裱的空白画布；空白处的颜色是场景的清除颜色。如果数字渲染过程中的每个阶段都像是在画布上手动渲染油漆的步骤，那么我们感兴趣的帧渲染管道中的时间点就是油漆已经铺在画布上但尚未干燥和固定的部分。这个纹理是将场景的所有几何形状转换成相对于摄像机的位置，然后转换到2D屏幕空间的结果。后处理处理的是这个纹理的单独像素，而不是场景的几何形状。Babylon.js有几个现成的**PostProcessRenderingPipelines**和**PostProcesses**，可以通过一行或两行代码添加。在下一章中，我们将探讨如何创建后处理以及实现这一点的两种不同方法。让我们不要让下一章抢了本章的风头，继续探讨更多内置的后处理功能，比如体积光散射——也就是“上帝之光”。
- en: Adding the Volumetric Light Scattering Post-Process Effect
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加体积光散射后处理效果
- en: 'Let’s look at a simple yet concrete example of using a built-in post process
    in the route planning screen. When a strong light source lies behind an object
    and the viewer, light striking the object at oblique angles may scatter, creating
    a distinctive glare effect that will make the Sun, well, shine! This type of effect
    is called volumetric light scattering (also known as “God Rays”), and it’s so
    easy to use you don’t even need to know how it works. Here are the two lines of
    code needed (split across multiple lines for clarity):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在路线规划屏幕上使用内置后处理的一个简单而具体的例子。当一个强烈的光源位于物体和观察者后面时，以斜角击中物体的光线可能会散射，从而产生一种独特的眩光效果，使太阳看起来更加明亮！这种效果被称为体积光散射（也称为“上帝之光”），使用起来非常简单，你甚至不需要知道它是如何工作的。以下是需要的两行代码（为了清晰起见，分多行显示）：
- en: '[PRE0]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These lines, added to the `Star.mesh` sphere, using the active camera for rendering.
    The last line sets an internal property that instructs the internally used **Render
    Target Texture** involved in the post-processing to render particles to include
    in the effect.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行代码被添加到`Star.mesh`球体上，使用活动相机进行渲染。最后一行设置了一个内部属性，指示在后期处理中使用的内部**渲染目标纹理**将粒子渲染到效果中。
- en: 'The following screenshot depicts the results of applying this post-process.
    Quite the improvement:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了应用此后处理的效果。相当大的改进：
- en: '![Figure 10.9 – The volumetric light scattering effect added via post-processing
    gives the apparent impression of camera glare from the bright Sun on the route
    planning screen'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9 – 通过后处理添加的体积光散射效果，给路线规划屏幕上的明亮阳光造成了相机眩光的效果]'
- en: '](img/Figure_10.09_B17866.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.09](img/Figure_10.09_B17866.jpg)'
- en: Figure 10.9 – The volumetric light scattering effect added via post-processing
    gives the apparent impression of camera glare from the bright Sun on the route
    planning screen
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 通过后处理添加的体积光散射效果，给路线规划屏幕上明亮的太阳造成的相机眩光感
- en: Babylon.js has several post processes available right out of the box in addition
    to the VLSPP, most of which are just as easy to use. If none of those suit your
    needs, the option to create a post-process of your own always exists in several
    forms, which we’ll cover in the next chapter. To wrap things up with the current
    subject matter, we’ll look at how easy it is to get a big bundle of rendering
    quality improvements for a small bit of code with the Default Rendering Pipeline
    of post processes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js除了VLSPP之外，还提供了多种开箱即用的后处理效果，其中大部分同样易于使用。如果这些都不符合您的需求，您始终可以选择以多种形式创建自己的后处理效果，我们将在下一章中介绍。就当前主题而言，我们将探讨如何通过默认渲染管线后处理，用一小段代码就能获得大量渲染质量提升。
- en: The Default Rendering Pipeline
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认渲染管线
- en: It’s not as much of a mouthful to say as the previous section was, but the **Default
    Render Pipeline** makes up for it by being such a cute and useful bundle of different
    effects. A diligent browser of video game graphics settings menus (who isn’t?)
    will recognize many of the post processes that comprise this **Rendering Pipeline**.
    Included in the pipeline are the same **Image Processing** effects that are available
    at the material level, but there are also others such as Bloom, Film Grain, FXAA,
    and more! Each is provided with sensible defaults, but it is important to know
    what those are so they can be adjusted to fit the specifics of the situation.
    The BJS Playground at [https://playground.babylonjs.com/#Y3C0HQ#146](https://playground.babylonjs.com/%23Y3C0HQ%23146)
    is a complete example of the Default Rendering Pipeline straight from the Babylon.js
    docs page – it has an interactive UI to allow you to quickly change parameters
    or enable/disable post processes and see their effects. Play around with the sample
    to get a feel for how different types of effects and their settings can completely
    change a scene’s look and feel with only a few adjustments! Using this rendering
    pipeline is basic table stakes for getting a high-quality image; it’s a good place
    to start.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与前文相比，这个说法并不那么冗长，但**默认渲染管线**通过其可爱且实用的效果组合来弥补这一点。一个勤奋浏览视频游戏图形设置菜单的浏览器（谁不是呢？）会认出构成这个**渲染管线**的许多后处理效果。管线中包括与材质级别上可用的相同**图像处理**效果，但还有其他一些，如Bloom、胶片颗粒、FXAA等！每个效果都提供了合理的默认设置，但了解这些设置很重要，以便可以根据具体情况进行调整。BJS游乐场在[https://playground.babylonjs.com/#Y3C0HQ#146](https://playground.babylonjs.com/%23Y3C0HQ%23146)是来自Babylon.js文档页面的默认渲染管线的完整示例——它有一个交互式用户界面，允许您快速更改参数或启用/禁用后处理并查看其效果。玩一玩这个示例，以了解不同类型的效果及其设置如何仅通过少量调整就能完全改变场景的外观和感觉！使用这个渲染管线是获得高质量图像的基本筹码；这是一个良好的起点。
- en: The evolution of an application or game’s look and feel will invariably include
    the addition of other, unique combinations of post processes and effects. This
    is what makes a game or application stand out from others, and it’s a place where
    there’s lots of room for art and aesthetics. In this section, we discussed how
    **tone mapping** works to “shift” a high-dynamic range image or scene into a range
    that displays are capable of rendering. There are different types of tone mapping
    algorithms because there are some compromises that need to be made when performing
    tone mapping that result in varying visual differences in output. We learned about
    how tone mapping fits into a post-processing pipeline as part of either material-based
    or pixel-based Image Processing effects. These effects share common configurations
    and include several adjustments in addition to tone mapping. Other post-processing
    effects are included with the Image Processing effect in the Default Rendering
    Pipeline. These effects include FXAA, Bloom, Film Grain, and more.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 应用或游戏的外观和感觉的演变不可避免地包括添加其他独特的后期处理和效果组合。这就是使游戏或应用程序与其他游戏或应用程序区别开来的原因，这也是艺术和美学有很多空间的地方。在本节中，我们讨论了**色调映射**如何将高动态范围图像或场景“转换”为显示器能够渲染的范围。由于在执行色调映射时需要做出一些妥协，因此存在不同类型的色调映射算法，这导致了输出中不同的视觉差异。我们学习了色调映射如何作为基于材料或基于像素的图像处理效果的一部分融入后期处理管道。这些效果具有共同的配置，并包括除色调映射之外的一些调整。其他后期处理效果包含在默认渲染管道中的图像处理效果中。这些效果包括FXAA、光晕、胶片颗粒等。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter may have felt either extremely long, extremely short, or extremely
    boring, depending on your existing knowledge and experience. The behavior of light
    in the real world is extremely complicated, so when simulating it in a scene,
    it’s necessary to make simplifications and assumptions about that behavior.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这章可能感觉要么非常长，要么非常短，要么非常无聊，这取决于你现有的知识和经验。现实世界中光的行为极其复杂，因此在场景中模拟它时，有必要对该行为进行简化和假设。
- en: Traveling in rays from source to destination material, light is modeled using
    some implementation of the **Bi-Directional Reflectance Function** (**BRDF**).
    This function computes the (ir)radiance or brightness at a given input point and
    angle from a source of light. The function has a set of terms that are each calculated
    in separate functions, then combined to provide a result.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从光源到目标材料的射线旅行中，光是通过某种**双向反射分布函数**（**BRDF**）的实现来建模的。此函数计算从光源在给定输入点和角度处的（非）辐射或亮度。该函数有一组术语，每个术语都在单独的函数中计算，然后组合以提供结果。
- en: The Diffuse term (also called Albedo) accounts for light that has been evenly
    scattered from the surface of the material, kind of like how a point light evenly
    projects light in all directions. Specular is the term for light that is reflected
    from the material directly into the camera or observer and has a bright, potentially
    sharp outline. The specifics of the specular lighting contribution depend greatly
    on the material’s properties; a metallic, smooth surface will more cohesively
    reflect light than a rough, non-metallic one will. Emissive light is also called
    self-illumination because it is light that doesn’t have a light source as an origin
    and it does not factor into other material’s lighting. Finally, ambient lighting
    is a catch-all term for any type of lighting that arrives at the camera indirectly
    from its source. Atmospheric scattering is one example of an ambient lighting
    source.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射项（也称为反照率）负责解释从材料表面均匀散射的光，有点像点光源均匀地向所有方向投射光。镜面反射是指从材料直接反射到相机或观察者那里的光，它具有明亮、可能尖锐的轮廓。镜面反射光的具体贡献很大程度上取决于材料的特性；金属、光滑的表面比粗糙、非金属的表面更能一致地反射光。发射光也称为自发光，因为它没有光源作为起点，并且它不会影响其他材料的照明。最后，环境光照是一个总称，用于任何从其源头间接到达相机的光照类型。大气散射是环境光照源的一个例子。
- en: The different qualities and properties that describe the behavior of light on
    a mesh are grouped into components called materials. A material implements various
    key functions that go into the BRDF. **StandardMaterial** of Babylon.js fulfills
    most basic scene needs that do not require a photorealistic rendering, while **PBRMaterial**
    provides a **Physically-Based Rendering** (**PBR**) BRDF implementation that closely
    models the real-world behavior of different surface types, from rough to smooth,
    shiny to dull.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 描述光线在网格上行为的不同质量和属性被分组到称为材质的组件中。材质实现了各种关键功能，这些功能被用于BRDF（双向反射分布函数）。Babylon.js的**StandardMaterial**满足大多数基本的场景需求，这些需求不需要进行逼真的渲染，而**PBRMaterial**提供了一个**基于物理的渲染**（**PBR**）BRDF实现，该实现紧密模拟了不同表面类型（从粗糙到光滑，从光亮到暗淡）的真实世界行为。
- en: For PBR to work effectively, the environment of a scene needs to provide essential
    lighting information. **Image-Based Lighting** (**IBL**) is a technique in which
    a special type of image is sampled at rendering time to provide information about
    the scene’s lighting at the current camera position and view. What makes the image
    type special is that it represents image data using 16- or 32-bit floating point
    numbers for each color channel (Red, Green, Blue, and, sometimes, Alpha). Having
    more bits to represent a number means that, for practical purposes, the ratio,
    or range of brightness in a scene between its brightest and darkest areas, can
    effectively be infinite. This is what both defines and allows an HDR photo or
    image to be captured and stored.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使PBR（基于物理的渲染）有效地工作，场景的环境需要提供必要的光照信息。**基于图像的照明**（**IBL**）是一种技术，在渲染时对一种特殊类型的图像进行采样，以提供关于场景在当前相机位置和视角下的光照信息。使这种图像类型特殊的是，它使用16位或32位浮点数来表示每个颜色通道（红色、绿色、蓝色，有时还有Alpha）的图像数据。用更多的位来表示一个数字意味着，从实用角度来看，场景中最亮和最暗区域之间的亮度比或范围可以有效地是无限的。这正是定义并允许捕获和存储HDR照片或图像的原因。
- en: The texture is known as an **Environment texture**, but in the context of a
    skybox, this comes in the form of a **reflection texture**; both perform the same
    duties using the same texture, but from different approaches. Environment or reflection
    textures for a static scene can be pre-generated in several ways. They can be
    “baked” using a 3DCC tool such as Blender or Maya from an existing scene, they
    can be captured from render output by a suitably configured camera, or they can
    be manually prepared from an existing image using a tool such as GIMP or Photoshop.
    These will be unable to take into account the scene’s meshes and their properties,
    so a dynamic approach such as Reflection Probes can be used to generate a reflection
    texture in real time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种纹理被称为**环境纹理**，但在天空盒的上下文中，它以**反射纹理**的形式出现；两者使用相同的纹理执行相同的任务，但采用不同的方法。静态场景的环境或反射纹理可以通过几种方式预先生成。它们可以使用Blender或Maya等3DCC工具从现有场景中“烘焙”出来，它们可以被配置适当的相机从渲染输出中捕获，或者它们可以使用GIMP或Photoshop等工具从现有图像中手动准备。这些方法将无法考虑到场景的网格及其属性，因此可以使用如反射探针这样的动态方法来实时生成反射纹理。
- en: Once you’ve obtained an HDR image, there are a couple of options regarding what
    to do next. File sizes for DDS and HDR images can be quite large, so the Babylon.js
    IBL Tool is where to go to convert images into the ENV format for use in Babylon.js
    scenes. There are several different parameters and texture slots available to
    assign on a **PBRMaterial**, but between the BJS docs, Playground examples, and,
    of course, this book, you should be sufficiently equipped to explore them all!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了HDR图像，关于下一步要做什么有几个选择。DDS和HDR图像的文件大小可能相当大，因此，Babylon.js IBL工具是转换图像为ENV格式以在Babylon.js场景中使用的地方。在**PBRMaterial**上有几个不同的参数和纹理槽可供分配，但通过BJS文档、Playground示例，当然还有这本书，你应该有足够的装备来探索它们！
- en: Once a scene has been rendered on the GPU, it isn’t necessarily passed to the
    display device right away. **Post-processes** are employed in the form of a series
    of Pipelines that allow the output from a scene’s camera to be successively processed
    in different ways. The built-in **ImageProcessing** offers many common image corrections
    and adjustments that you may recognize from your smartphone’s photo editing software,
    but other post processes are available that add real-time effects only limited
    by RAM and imagination.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦场景在GPU上渲染完成，并不一定立即传递到显示设备。**后处理**以一系列管道的形式被采用，允许场景相机的输出依次以不同的方式进行处理。内置的**图像处理**提供了许多常见的图像校正和调整，这些你可能从智能手机的图片编辑软件中熟悉，但还有其他后处理可供选择，这些后处理只受限于RAM和想象力。
- en: One of the more important post processes to engage when working with PBR/HDR
    scenes is **tone mapping**. This is a mathematical operation that converts the
    **High Dynamic Range**, which can’t be represented by most display devices, into
    a standard range of colors and brightness. Because this involves compressing the
    potentially infinite (or at least very large) into a much more finite space, there
    will be some losses in fidelity and accuracy. Thus, there are different algorithms
    for performing this mapping that emphasize different areas of the brightness or
    color curve.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当与PBR/HDR场景一起工作时，最重要的后处理之一是**色调映射**。这是一个数学运算，将无法由大多数显示设备表示的**高动态范围**转换为标准范围的颜色和亮度。因为这涉及到将可能无限（或至少非常大）的空间压缩到一个更有限的空间，所以会有一些保真度和准确性的损失。因此，有不同算法用于执行此映射，这些算法强调亮度或颜色曲线的不同区域。
- en: In the next chapter, we’re going to be taking a diamond awl to the rock-hard
    topic of Shaders. Babylon.js has many ways that allow developers to write, manage,
    and apply standard GLSL code. What that means and what a shader is are things
    that will be defined shortly, so buckle up – this next chapter’s going to be a
    wild ride!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨一个硬核主题——着色器。Babylon.js有许多方式允许开发者编写、管理和应用标准GLSL代码。这意味着什么以及着色器是什么将在稍后定义，所以系好安全带——下一章将是一次疯狂的旅程！
- en: Extended Topics
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: 'There’s no better way to learn something new than to just take a stab at carving
    something familiar from what is unfamiliar territory. At the same time, it can
    be difficult to determine where and what slices are best to cut off. Here are
    some ideas, exercises, and examples that might give you a good starting point:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比尝试从未知领域雕刻熟悉的东西更好的方式来学习新事物了。同时，确定最佳切割位置和内容可能很困难。以下是一些想法、练习和例子，可能为你提供一个良好的起点：
- en: 'Using an example from your IRL world, create a photorealistic recreation of
    that example’s environment:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你现实世界中的一个例子，创建该例子的环境的逼真再现：
- en: Use the camera on your smartphone or device to capture the surrounding cube
    or sphere map texture in as high of a quality as the device allows.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的智能手机或设备上的相机捕捉周围立方体或球面贴图纹理，以尽可能高的质量。
- en: Import the pictures into an image editing tool and adjust the image to give
    it a high dynamic range (make sure to save it in a 32-bit RGBA format!).
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图片导入到图像编辑工具中，调整图片以使其具有高动态范围（确保以32位RGBA格式保存！）。
- en: Export the HDR images in DDS format, then convert them into an ENV file using
    the BJS texture tools.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HDR图像导出为DDS格式，然后使用BJS纹理工具将其转换为ENV文件。
- en: Create a PG that uses your environment and test it by placing some meshes into
    the environment. Make sure to configure and give them a **PBR Material**!
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用你环境的PG，并通过将一些网格放入环境中来测试它。确保配置并给他们一个**PBR材质**！
- en: A skybox doesn’t have to share the same texture as the scene’s environment (reflection)
    texture. Demonstrate this by modifying the Space-Truckers route planning scene
    to use a high-quality skybox with a highly compressed ENV file.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天空盒不必与场景的环境（反射）纹理共享相同的纹理。通过修改Space-Truckers路线规划场景以使用高质量的压缩ENV文件的天空盒来演示这一点。
- en: Using a static background environment for reflections doesn’t mean that a scene
    can’t create a reflection texture on the fly that is dynamic to the scene. Make
    the driving phase route mesh shiny and reflective and then use a reflection probe
    (see [https://doc.babylonjs.com/divingDeeper/environment/reflectionProbes](https://doc.babylonjs.com/divingDeeper/environment/reflectionProbes)
    for how to use them) to cause the surface of the Space-Road to reflect an image
    of the truck as it passes over it.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态背景环境进行反射并不意味着场景不能即时创建一个对场景动态的反射纹理。使驾驶阶段的路线网格闪亮并具有反射性，然后使用反射探头（有关如何使用它们，请参阅[https://doc.babylonjs.com/divingDeeper/environment/reflectionProbes](https://doc.babylonjs.com/divingDeeper/environment/reflectionProbes)）使Space-Road的表面反射卡车经过时的图像。
- en: Some systems can handle the added load of post-processes, but others (especially
    mobile devices) may not be able to maintain a desirable frame rate. Enable the
    post-processes to be toggled and for variables to be tweaked by the end users
    of Space-Truckers. Later, this can be hooked up to a Settings dialog, or potentially
    linked to a Scene Optimization (see [*Chapter 12*](B17266_12_Final_AM.xhtml#_idTextAnchor248),
    *Measuring and Optimizing Performance*, for more details).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些系统可以处理后期处理增加的负载，但其他系统（尤其是移动设备）可能无法维持一个令人满意的帧率。允许Space-Truckers的最终用户启用后期处理并调整变量。稍后，这可以连接到设置对话框，或者可能链接到场景优化（有关更多详细信息，请参阅[*第12章*](B17266_12_Final_AM.xhtml#_idTextAnchor248)，*测量和优化性能*）。
- en: 'Part 3: Going the Distance'
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：走得更远
- en: The last part of the book is where we take our developed game from being a rough
    demo to a completed application. As a bonus, the final chapter contains a smorgasbord
    of disparate topics that weren’t addressed in the rest of the text. Guest contributors
    bring additional context to and detail on other topics of interest within the
    world of Babylon.js.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 书的最后一部分是我们将开发的游戏从粗糙的演示转变为完整的应用程序。作为额外奖励，最后一章包含了一系列未在其他文本中讨论的不同主题。嘉宾贡献者为Babylon.js世界中的其他感兴趣的主题提供了额外的背景和细节。
- en: 'This section comprises the following chapters:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 11*](B17266_11_Final_AM.xhtml#_idTextAnchor230), *Scratching the
    Surface of Shaders*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B17266_11_Final_AM.xhtml#_idTextAnchor230)，*探索着色器表面*'
- en: '[*Chapter 12*](B17266_12_Final_AM.xhtml#_idTextAnchor248), *Measuring and Optimizing
    Performance*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B17266_12_Final_AM.xhtml#_idTextAnchor248)，*测量和优化性能*'
- en: '[*Chapter 13*](B17266_13_Final_AM.xhtml#_idTextAnchor264), *Converting the
    Application to a PWA*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B17266_13_Final_AM.xhtml#_idTextAnchor264)，*将应用程序转换为PWA*'
- en: '[*Chapter 14*](B17266_14_Final_AM.xhtml#_idTextAnchor290), *Extended Topics,
    Extended*'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B17266_14_Final_AM.xhtml#_idTextAnchor290)，*扩展主题，扩展*'
