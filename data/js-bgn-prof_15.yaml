- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Next Steps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: You've come very far already! At this point, you should have the building blocks
    of JavaScript down. And you are able to create apps, write clever scripts, and
    read a lot of code. This is a great foundation for some serious next steps. In
    this chapter, we will be taking what you've learned to the next step by practicing
    and figuring out what interests you out of the endless possibilities that JavaScript
    offers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经走得很远了！在这个阶段，你应该已经掌握了JavaScript的基础知识。你能够创建应用程序、编写巧妙的脚本，并且能够阅读大量的代码。这为接下来的重要步骤打下了坚实的基础。在本章中，我们将通过实践和探索JavaScript提供的无限可能性中你感兴趣的部分，将你所学的知识提升到下一个层次。
- en: We won't go into too much detail about all the topics here. The details will
    be outdated soon and there is an endless supply of very well-crafted tutorials
    and information on the internet for each one of them. Chances are that by the
    time you are reading this, the frameworks and libraries we are recommending are
    hopelessly old. The good news is that the likelihood that the next big thing will
    use the same concepts is huge.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里过多地详细介绍所有这些主题。这些细节很快就会过时，并且互联网上有大量针对每个主题精心制作的教程和信息。可能性很大，在你阅读这段文字的时候，我们推荐的框架和库已经过时了。好消息是，下一个大事件使用相同概念的可能性非常大。
- en: 'This chapter will serve as a starting point for your next steps with JavaScript.
    We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将作为你在JavaScript中下一步的起点。我们将涵盖以下主题：
- en: Libraries and frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库和框架
- en: Learning the backend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习后端
- en: Next steps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: Libraries and frameworks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库和框架
- en: Let's start with libraries and frameworks. Libraries are basically pre-programmed
    JavaScript modules that you can use to speed up your development process. They
    typically do one specific thing for you. Frameworks are very similar, they are
    also pre-programmed, but instead of doing only one thing for you, they arrange
    a whole list of things. This is why it is called a framework, it really is providing
    you a solid place to start from and usually demands a certain structure for your
    files in order to do so. A framework is often a bundle of libraries that provide
    an all-in-one solution. Or at least a many-in-one. You'll eventually even find
    yourself using external libraries on top of the frameworks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从库和框架开始。库基本上是预先编程的JavaScript模块，你可以使用它们来加速你的开发过程。它们通常为你做一件特定的事情。框架非常相似，它们也是预先编程的，但它们不仅仅为你做一件事情，而是安排了一系列的事情。这就是为什么它被称为框架，它确实为你提供了一个坚实的起点，并且通常要求你的文件有一定的结构才能做到这一点。框架通常是一组提供一站式解决方案的库。或者至少是多合一的解决方案。你最终甚至会发现自己在框架之上使用外部库。
- en: To give a non-code example, if we started building a car, we could do so from
    scratch and make every single piece of this car ourselves. This is pretty much
    what we've been doing in this book so far. With libraries, we get ready-made parts—in
    our car example, we could get fully built chairs that we only would have to install
    onto the car frame we've built. If we used a framework to make a car, we would
    get the skeleton of the car itself, with all the essential parts in it already,
    and it would probably be capable of driving already. We would only need to focus
    on customizing the car and making sure it includes all the special things for
    our wants and needs. While doing that, we would have to keep in mind the skeleton
    of the car we already have and continue in that style.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个非代码的例子来说明，如果我们开始建造一辆汽车，我们可以从头开始，并且自己制作汽车的所有部件。这正是我们在这本书中到目前为止所做的事情。有了库，我们可以获得现成的部件——在我们的汽车例子中，我们可以获得完全建成的椅子，我们只需要将其安装到我们已建造的汽车底盘上。如果我们使用框架来制作汽车，我们会得到汽车的骨架，其中已经包含了所有必要的部件，而且它可能已经能够驾驶了。我们只需要专注于定制汽车并确保它包含我们想要和需要的所有特殊功能。在这样做的时候，我们必须牢记我们已有的汽车骨架，并继续以这种方式进行。
- en: As you can imagine, we would be done with our car project a lot faster using
    libraries and frameworks. Also, we would run into less trouble using libraries
    and frameworks, since the pre-made parts would have been well tested by many others
    already. If we were to make our own car chairs from scratch, chances are that
    after a year of driving they are no longer comfortable, whereas the standard solution
    has been thoroughly checked already.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，如果我们使用库和框架，我们的汽车项目将会更快完成。此外，使用库和框架时遇到的问题也会更少，因为预先准备的部分已经被许多人测试过了。如果我们从头开始制作自己的汽车座椅，那么一年后它们可能就不再舒适了，而标准的解决方案已经被彻底检查过了。
- en: So, libraries and frameworks don't just speed up the process, they also provide
    you with a more stable and better-tested solution. Are there no downsides? Well,
    of course there are. The most important one is probably flexibility, as you will
    have to stick to the structure of the framework you are using. To some extent,
    this could also be an advantage because it usually requires a well-structured
    coding style from you, which will improve the code quality.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，库和框架不仅加快了进程，还为你提供了一个更稳定、经过更好测试的解决方案。难道没有缺点吗？当然有。其中最重要的可能是灵活性，因为你将不得不遵循你所使用的框架的结构。在某种程度上，这也可以是一个优点，因为它通常要求你采用良好的编码风格，这将提高代码质量。
- en: Another downside is that you'll have to keep on updating your app whenever the
    framework or library you are using is updated. This is very important, especially
    when the updates are fixes to security issues. On the one hand, frameworks and
    libraries are very reliable, but because they're so commonly used, it is not unusual
    for hackers to find weaknesses. If they find one, this will give them opportunities
    on many apps, including your own. On the other hand, your own code is probably
    weaker than an average framework, by a lot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，你将不得不在所使用的框架或库更新时不断更新你的应用程序。这非常重要，尤其是当更新是针对安全问题的修复时。一方面，框架和库非常可靠，但由于它们被广泛使用，黑客发现弱点并不罕见。如果他们找到了一个，这将给他们提供许多应用程序的机会，包括你的应用程序。另一方面，你自己的代码可能比平均框架要弱得多。
- en: However, in many cases, hacking your custom app might be too costly. For example,
    when you just have a hobby project online, you are probably not going to pay a
    huge amount of ransom money to hackers and the data in your app also won't be
    worth the hackers' effort. Whereas a script that just tries to exploit a weakness
    of an often-used framework for apps on a random number of websites is common.
    To minimize the risk, update your dependencies often and keep an eye out for reported
    weaknesses by the owner of your library or framework.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，破解你定制的应用程序可能成本太高。例如，当你只是有一个在线的爱好项目时，你可能不会支付大量的赎金给黑客，而且你应用程序中的数据也可能不值得黑客的努力。而一个试图利用常用框架在随机数量网站上弱点的脚本却是常见的。为了最小化风险，经常更新你的依赖项，并关注你库或框架所有者报告的弱点。
- en: Libraries
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库
- en: Technically, we cannot do anything more with frameworks and libraries than we
    can do without them. That is, if you leave time out of the equation. Frameworks
    and libraries allow us to develop to a higher quality a lot faster, and this is
    why they are so popular.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们无法使用框架和库做比不用它们更多的事情。也就是说，如果我们不考虑时间。框架和库使我们能够更快地开发出高质量的软件，这也是它们如此受欢迎的原因。
- en: We will be discussing a few of the most popular libraries here. This is definitely
    not an exclusive list, and it is also very dynamic, so other libraries or frameworks
    might be more popular in a year's time. This is why we are not going to be covering
    full tutorials and how to get started here. We will just explain the basic principles
    and show some code snippets. However, this is still a solid foundation for the
    next big step in your development career.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论一些最受欢迎的库。这绝对不是一个独家列表，它也非常动态，所以一年后其他库或框架可能更受欢迎。这就是为什么我们不会在这里涵盖完整的教程和如何开始的原因。我们只会解释基本原理并展示一些代码片段。然而，这仍然是你在开发生涯中迈出下一步的稳固基础。
- en: 'Many of the libraries can be included in a page by adding a script tag to the
    head of the HTML, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多库可以通过在HTML的头部添加一个script标签来包含在页面中，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will start by discussing a few common libraries.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论一些常见的库开始。
- en: jQuery
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: '**jQuery** is arguably the most famous JavaScript library. It was great to
    use in the past, when it would be compiled into the latest version of JavaScript
    for the specific browser. Nowadays, it is just a different way of writing some
    of the things we have seen in the book. You can recognize jQuery easily by the
    amount of dollar signs in the code. You can also tell if a website is using jQuery
    if you type `$` or `jQuery` into the console of the website, and it returns the
    jQuery object. The jQuery library is mainly focused on selecting HTML elements
    from the DOM and interacting with and manipulating them. It roughly looks like
    this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery** 可以说是最著名的 JavaScript 库。在过去，它会被编译成特定浏览器的最新版本的 JavaScript，使用起来非常方便。如今，它只是以不同的方式编写我们在书中看到的一些东西。你可以通过代码中的美元符号数量轻松识别
    jQuery。你还可以通过在网站的控制台中输入 `$` 或 `jQuery` 来判断一个网站是否使用了 jQuery，如果它返回 jQuery 对象，则表示该网站正在使用
    jQuery。jQuery 库主要关注从 DOM 中选择 HTML 元素，并与它们交互和操作。它大致看起来像这样：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the dollar sign you indicate that you want to start jQuery, and with the
    selector you can select the element in HTML. The signs here are a bit like CSS:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用美元符号表示你想要开始使用 jQuery，而使用选择器可以选中 HTML 中的元素。这里的符号有点像 CSS：
- en: 'Just a simple string value targets an HTML element: `$("p")`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的字符串值可以定位一个 HTML 元素：`$("p")`
- en: 'A period before a word or phrase indicates you want to select all elements
    with a certain class: `$(".special")`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单词或短语前的点号表示你想要选择具有特定类的所有元素：`$(".special")`
- en: 'A hashtag targets an element with a certain ID: `$("#unique")`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个井号可以定位具有特定 ID 的元素：`$("#unique")`
- en: You can also use any other CSS selector, including the more complicated chained
    ones
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以使用任何其他 CSS 选择器，包括更复杂的链式选择器
- en: 'Here is an example where the jQuery library is imported in the `script` element
    starting on line 3:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子，jQuery 库从第 3 行开始导入到 `script` 元素中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is what the page looks like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是页面看起来像这样：
- en: '![Text'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![文本'
- en: Description automatically generated with medium confidence](img/B16682_15_01.png)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述，置信度中等](img/B16682_15_01.png)
- en: 'Figure 15.1: Page with a simple jQuery script'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：包含简单 jQuery 脚本的页面
- en: When you click the **Great idea** button, all the paragraphs will be hidden.
    This is done inside the event that's been added using jQuery. First, we selected
    the button with the ID `hidebutton`, next we call the `click` function on it,
    which specifies what will happen on click. In that function, we state that we'll
    select all `p` elements and hide them. `hide` is a special jQuery function that
    adds the `display:none` style to the HTML element.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 **好主意** 按钮时，所有段落都将被隐藏。这是在 jQuery 添加的事件中完成的。首先，我们选择了具有 ID `hidebutton` 的按钮，然后我们调用它的
    `click` 函数，该函数指定了点击时会发生什么。在该函数中，我们声明将选择所有 `p` 元素并将它们隐藏。`hide` 是一个特殊的 jQuery 函数，它将
    `display:none` 样式添加到 HTML 元素中。
- en: So, after clicking, all the paragraphs are gone. When we click on **Found you!**,
    only one comes back, the last one reading **I'm easy to find**. This is because
    when the button with the ID `revealbutton` gets clicked, it selects all elements
    with class `easy` and removes the `display:none` from the style using the jQuery
    `show` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，点击后，所有段落都消失了。当我们点击 **找到你了** 时，只有一个返回，最后一个读作 **我容易找到**。这是因为当具有 ID `revealbutton`
    的按钮被点击时，它会选择所有具有类 `easy` 的元素，并使用 jQuery 的 `show` 函数移除样式中的 `display:none`。
- en: 'This is what jQuery really comes down to:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 jQuery 真正的核心所在：
- en: Getting the selectors down
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握选择器
- en: Knowing some extra or differently named functions to manipulate the elements
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解一些额外的或不同命名的函数来操作元素
- en: You can use jQuery in your code, but this won't expand your possibilities to
    do more with JavaScript. It will just allow you to do the same thing with fewer
    characters of code. The reason jQuery was so popular is that it added a lot of
    value when browsers were less standardized, in which case using jQuery would actually
    provide the solution to standardizing JavaScript across multiple browsers. This
    is of little use nowadays, and if you are going to write new code, you would be
    better just using JavaScript. However, whenever you are working on older code,
    it is very likely you'll run into jQuery so knowing how it works will definitely
    help you in these cases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的代码中使用 jQuery，但这不会扩大你使用 JavaScript 做更多事情的可能性。它只会让你用更少的代码字符做同样的事情。jQuery
    非常受欢迎的原因是，在浏览器标准化程度较低的时候，它增加了许多价值，在这种情况下，使用 jQuery 实际上提供了跨多个浏览器标准化 JavaScript
    的解决方案。如今，这已经没有多少用处了，如果你要编写新的代码，最好直接使用 JavaScript。然而，无论何时你在处理旧代码，你很可能遇到 jQuery，因此了解它是如何工作的将肯定有助于你处理这些情况。
- en: 'At the time of writing, you can find the jQuery docs here: [https://api.jquery.com/](https://api.jquery.com/).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你可以在以下位置找到jQuery文档：[https://api.jquery.com/](https://api.jquery.com/)。
- en: D3
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D3
- en: '**D3** stands for three Ds: **data-driven documents**. It is a JavaScript library
    that helps manipulate documents based on data and it can be used to visualize
    data using HTML, SVG, and CSS. It comes in very handy for dashboards that need
    to contain any sort of data representation.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**D3** 代表三个“D”：**数据驱动文档**。它是一个JavaScript库，可以帮助基于数据进行文档操作，并且可以使用HTML、SVG和CSS来可视化数据。对于需要包含任何类型数据表示的仪表板来说，它非常有用。'
- en: 'You can make pretty much any kind of graph you could want with a lot of features
    using D3\. It can look rather intimidating, because all the settings for the graph
    figure need to be set. Diving into it and breaking it up in pieces will ensure
    you''ll overcome any hurdles. Below you''ll find a very basic example to add three
    spheres to an SVG using D3:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用D3，你可以用很多特性制作几乎任何你想要的图表。它可能看起来相当令人畏惧，因为需要设置图表图形的所有设置。深入其中，将其分解成小块，将确保你克服任何障碍。下面是一个非常基本的示例，使用D3向SVG添加三个球体：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The D3 library gets imported in the first `script` tag. And the `svg` variable
    gets created using the `d3.select` method on the `svg` with ID `drawing-area`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: D3库在第一个`script`标签中导入。`svg`变量是通过在具有ID `drawing-area` 的`svg`上使用`d3.select`方法创建的。
- en: We are not doing the possibilities of D3 any justice—in this case, this isn't
    a lot more useful than just doing this with a canvas. However, you can make beautiful
    animations of the data, such as a zoom effect, a sortable bar graph, a spin effect
    on a sphere, and so much more. That code would take up multiple pages of the book
    though.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有完全公正地对待D3的可能性——在这种情况下，这并不比只用canvas做更多。然而，你可以制作漂亮的数据动画，例如缩放效果、可排序的条形图、球体的旋转效果等等。不过，这些代码将占据这本书的多个页面。
- en: 'At the time of writing, you can find the full documentation here: [https://devdocs.io/d3~4/](https://devdocs.io/d3~4/).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你可以在以下位置找到完整的文档：[https://devdocs.io/d3~4/](https://devdocs.io/d3~4/)。
- en: Underscore
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Underscore
- en: Underscore is a JavaScript library that can be summarized as a toolkit for functional
    programming. Functional programming can be considered a programming paradigm,
    it revolves around using descriptive functions in a sequence rather than separate
    examples. **Object-oriented programming** (**OOP**) is also a programming paradigm,
    which is all about objects and their state, and the data can be encapsulated and
    hidden from the outside code. In functional programming the functions are very
    important, but there is less state to be concerned about. These functions do the
    same thing with different arguments all the time, and they can be easily chained.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore是一个JavaScript库，可以概括为函数式编程的工具包。函数式编程可以被认为是一种编程范式，它围绕使用描述性函数的序列进行，而不是单独的例子。**面向对象编程**（**OOP**）也是一种编程范式，它全部关于对象及其状态，数据可以被封装并隐藏在外部代码之外。在函数式编程中，函数非常重要，但需要关注的州更少。这些函数总是用不同的参数做同样的事情，并且可以很容易地串联起来。
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are many other functions for filtering, grouping elements, transforming
    elements, getting a random value, getting the current time, and a lot more.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他用于过滤、分组元素、转换元素、获取随机值、获取当前时间等功能。
- en: This snippet probably explains the name as well, since we access Underscore
    functions using an underscore. You will have to install Underscore first though,
    else the interpreter won't understand the syntax.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能也解释了名字的由来，因为我们通过下划线访问Underscore函数。不过，你首先需要安装Underscore，否则解释器将不理解语法。
- en: 'At the time of writing, you can find the full documentation here: [https://devdocs.io/underscore/](https://devdocs.io/underscore/).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你可以在以下位置找到完整的文档：[https://devdocs.io/underscore/](https://devdocs.io/underscore/)。
- en: React
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React
- en: React is the last frontend library we are going to discuss. If you would rather
    say React is a framework you are not completely wrong, but not right either. The
    reason that we consider React a library is that you'll need to use some other
    libraries to get to the point where it feels like a framework.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: React是我们将要讨论的最后一个前端库。如果你认为React是一个框架，你并不完全错误，但也不完全正确。我们之所以将React视为一个库，是因为你需要使用其他一些库才能达到它像框架一样的效果。
- en: 'React is used to build beautiful and dynamic user interfaces. It splits up
    pages into different components and the data gets sent and updated between components
    as it changes. Here is a very basic example that only scratches the very surface
    of what React can do. This HTML will give this sentence on the page: **Hi Emile,
    what''s up?**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: React 用于构建美观且动态的用户界面。它将页面拆分为不同的组件，并且当数据发生变化时，数据在组件之间发送和更新。以下是一个非常基础的示例，它只是触及了
    React 能做什么的皮毛。这个 HTML 将在页面上显示这句话：**Hi Emile, what's up?**：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It will do this when the following JavaScript is associated with it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下 JavaScript 与之关联时，它将这样做：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will only work when the React library is available. And it will render
    the DOM, replacing the `innerHTML` of the `div` with the first argument of the
    `render` function. We can do this by adding React in a `script` element in the
    header and not installing anything on our system. The completed script looks like
    this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会在 React 库可用时才有效。它将渲染 DOM，用 `render` 函数的第一个参数替换 `div` 的 `innerHTML`。我们可以通过在头部添加一个
    `script` 元素来实现这一点，而不需要在我们的系统上安装任何东西。完整的脚本看起来像这样：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will write **Hi Emile, what's up?** to the page using React elements created
    manually in the `script` tag. This is not something you should be doing for large
    projects though. It is way more valuable to set up React and everything you need
    using a package manager such as **Node Package Manager** (**NPM**). This will
    allow you to easily manage all the dependencies and keep your code organized.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用在 `script` 标签中手动创建的 React 元素将 **Hi Emile, what's up?** 写入页面。不过，对于大型项目来说，你不应该这样做。使用包管理器（如
    **Node Package Manager** （**NPM**））设置 React 和所有你需要的东西要更有价值。这将允许你轻松管理所有依赖项并保持你的代码井井有条。
- en: 'At the time of writing, more can be found here: [https://reactjs.org/docs/getting-started.html](https://reactjs.org/docs/getting-started.html).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，更多信息可以在这里找到：[https://reactjs.org/docs/getting-started.html](https://reactjs.org/docs/getting-started.html)。
- en: Frameworks
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: The frameworks are more complex and usually you'll have to install them on your
    computer. How to do this can be found in the online documentation of the specific
    framework. And whenever you are done coding and you want to run your code, you'll
    have to run a command that will process your code into something the browser will
    understand. We are "serving" the application when we do this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 框架更复杂，通常你需要在你的电脑上安装它们。如何在特定框架的在线文档中找到如何安装的信息。并且，每当你完成编码并想要运行你的代码时，你都需要运行一个命令，该命令将处理你的代码，使其成为浏览器可以理解的东西。当我们这样做时，我们“提供”应用程序。
- en: Vue.js
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vue.js
- en: 'Vue.js is a lightweight JavaScript framework. It can be used to build user
    interfaces and **single-page applications** (**SPAs**). The way user interfaces
    are written with Vue.js can be hard to get your head around the first time you
    encounter it. Have a look at this code sample:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 是一个轻量级的 JavaScript 框架。它可以用来构建用户界面和 **单页应用程序** （**SPAs**）。使用 Vue.js 编写的用户界面可能在你第一次遇到它时难以理解。看看这个代码示例：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a simple HTML page, importing a JavaScript link from Vue. There is
    something weird going on in the HTML of the `<p>` tag: there is a `v-if` element.
    This element will only be displayed when the condition in that `v-if` is true.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 HTML 页面，从 Vue 导入了一个 JavaScript 链接。在 `<p>` 标签的 HTML 中有一些奇怪的事情发生：有一个 `v-if`
    元素。这个元素只有在 `v-if` 中的条件为真时才会显示。
- en: In this case, it is looking at the `hide` property of our data object in our
    Vue instance. If you change the value of this `hide` to `true`, the negated `hide`
    statement will become `false`, and the element will disappear. This is something
    that we could have done without Vue as well, but we would then have specified
    a JavaScript event for the change of the value and used JavaScript to edit the
    CSS to hide the paragraph.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它正在查看我们 Vue 实例中数据对象的 `hide` 属性。如果你将这个 `hide` 的值改为 `true`，否定的 `hide` 语句将变为
    `false`，元素将消失。这本来也是我们可以不用 Vue 就做到的，但那样的话，我们就需要指定一个 JavaScript 事件来改变值，并使用 JavaScript
    来编辑 CSS 以隐藏段落。
- en: 'You can even see HTML elements that are new to you. That is because these are
    not regular HTML elements, but rather from Vue, which lets you define your own
    elements. You can run into HTML that looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以看到对你来说全新的 HTML 元素。这是因为这些不是常规的 HTML 元素，而是来自 Vue，它允许你定义自己的元素。你可能会遇到如下这样的
    HTML：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And when you open the webpage associated with it, it shows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开与之关联的网页时，它会显示：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, a new Vue component is created, and it can actually hold
    data and have a function too, but this one is very basic and just to illustrate
    we can add HTML templates in the `template` property. There is a paragraph specified.
    When the webpage gets loaded, the `<maaike>` component will be replaced with whatever
    is in the template.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，创建了一个新的Vue组件，实际上它可以持有数据，也可以有函数，但这个组件非常基础，只是为了说明我们可以在`template`属性中添加HTML模板。指定了一段段落。当网页加载时，`<maaike>`组件将被模板中的内容所替换。
- en: The content of one page can come from many files. Usually these components all
    have their own file. There is a lot more official Vue tooling that you will get
    to know once you dive into Vue.js. It is actually a great framework for beginners
    with frameworks, as it is rather clear what is going on and is a great starting
    point for comprehending frameworks in general.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一页的内容可以来自多个文件。通常这些组件各自都有自己的文件。一旦你深入到Vue.js中，你会了解到更多官方的Vue工具。实际上，它是一个非常适合初学者的框架，因为它非常清晰，是理解框架的绝佳起点。
- en: 'At the time of writing, you can find the full Vue docs here: [https://v3.vuejs.org/guide/introduction.html](https://v3.vuejs.org/guide/introduction.html).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你可以在以下链接找到完整的Vue文档：[https://v3.vuejs.org/guide/introduction.html](https://v3.vuejs.org/guide/introduction.html)。
- en: Angular
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular
- en: Angular is a framework that originates from and is (currently) maintained by
    Google. Angular is a lot heavier than Vue.js, but it can be considered a complete
    package. This means that Angular takes up more disk space, and more disk space
    usually means it is slower to compile and install. Looking at Angular code isn't
    really that much different from Vue.js. However, Angular uses TypeScript instead
    of JavaScript. TypeScript is a superset of JavaScript and gets transpiled to JavaScript,
    but it is stricter and has a different syntax as well.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个由Google发起并（目前）维护的框架。Angular比Vue.js重得多，但可以被视为一个完整的包。这意味着Angular占用更多的磁盘空间，通常这意味着编译和安装速度较慢。查看Angular代码与Vue.js并没有太大的区别。然而，Angular使用TypeScript而不是JavaScript。TypeScript是JavaScript的超集，会被编译成JavaScript，但它更严格，也有不同的语法。
- en: 'Angular can be recognized by the `ng` attributes in the HTML. We are not going
    to show a full example, but here is the HTML that will show all the tasks on a
    to-do list (when the code around it is set correctly):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Angular可以通过HTML中的`ng`属性来识别。我们不会展示一个完整的示例，但这里有一个HTML示例，它将显示待办事项列表上的所有任务（当周围的代码设置正确时）：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ng-repeat` attribute is specifying the repeat action that for every task
    on the task list, it should create a `<li>` element. And `task` can be used as
    a variable inside `<li>` as well, as indicated by `{{ task }}`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-repeat`属性指定了重复操作，对于任务列表上的每个任务，它应该创建一个`<li>`元素。`task`也可以在`<li>`内部作为变量使用，如`{{
    task }}`所示。'
- en: 'There''s one more Angular-specific thing going on, `ng-click`, which tells
    Angular what to do when an element gets clicked. This is similar to the `onclick`
    event of JavaScript, but it can now be dynamically binded. This means that when
    writing the code, you don''t need to know about `onclick` yet. Clearly, you can
    achieve the same thing in JavaScript by specifying events that will lead to changes
    of the `onclick` attribute (and the complete element if necessary), but this is
    a lot more code that needs to be written. This goes for anything in Angular: it
    can be done with just JavaScript but it is a lot more work (and that might actually
    be an understatement, depending on the complexity of the situation).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个Angular特有的功能，`ng-click`，它告诉Angular当元素被点击时应该做什么。这与JavaScript的`onclick`事件类似，但现在它可以动态绑定。这意味着在编写代码时，你不需要了解`onclick`。显然，你可以在JavaScript中通过指定将导致`onclick`属性（以及必要时整个元素）变化的事件来实现相同的功能，但这需要编写更多的代码。这适用于Angular中的任何内容：它可以用JavaScript完成，但这需要更多的工作（这实际上可能是一个低估，取决于情况的复杂性）。
- en: 'At the time of writing, you can find the full docs here: [https://angular.io/docs](https://angular.io/docs).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，你可以在以下链接找到完整的文档：[https://angular.io/docs](https://angular.io/docs)。
- en: Learning to work with libraries and frameworks such as React, Angular, or Vue
    is a very logical and even must-have next step if you seek to be a frontend developer.
    In the authors' view, the difficulty of these options doesn't really differ that
    much. Which one is the best choice depends on the place you want to work and the
    region that you are in, because there are regional preferences for these frameworks
    and libraries.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用React、Angular或Vue等库和框架是一个非常合理甚至可以说是必须的下一步，如果你希望成为一名前端开发者。在作者看来，这些选项的难度并没有太大的区别。哪个是最好的选择取决于你想要工作的地点和你所在的地区，因为这些框架和库在不同地区有不同的偏好。
- en: Learning the backend
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习后端
- en: So far, we have only been dealing with the frontend. The frontend is the part
    that is running on the client side, which could be any device that the user is
    using, such as a phone, laptop, or tablet. In order for websites to do interesting
    stuff, we also need a backend. For example, if you want to log on to a website,
    this website somehow needs to know whether this user exists.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了前端。前端是运行在客户端的部分，可以是用户使用的任何设备，例如手机、笔记本电脑或平板电脑。为了使网站能够执行有趣的功能，我们还需要后端。例如，如果你想登录到一个网站，这个网站需要以某种方式知道这个用户是否存在。
- en: This is the job of the server-side code, the backend. This is code that is running
    not on the device of the user, but on some sort of server elsewhere, which is
    often owned or leased by the company hosting the website. Hosting the website
    usually means that they make it available to the world wide web by placing it
    on a server that can take outside requests via a URL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务器端代码，后端的工作。这是在用户的设备上运行，而是在某个服务器上运行的代码，通常由托管网站的公司的所有或租赁。托管网站通常意味着他们通过将网站放置在可以接受外部请求的URL上的服务器，使其对整个互联网可用。
- en: The code on the server does many things, all related to deeper logic and data.
    For example, an e-commerce store has a bunch of items in the shop that come from
    a database. The server gets the items from the database, parsing the HTML template
    and sending the HTML, CSS, and JavaScript over to the client.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的代码执行了许多与更深层逻辑和数据相关的事情。例如，一个电子商务商店在商店中有许多来自数据库的商品。服务器从数据库中获取商品，解析HTML模板，并将HTML、CSS和JavaScript发送到客户端。
- en: 'The same goes for logging in: when you enter your username and password on
    a website and you click on login, the code on the server gets triggered. This
    code is going to verify the details you entered with those in the database. If
    you have the correct details, it will send you back the page of your portal for
    logged-in users. And if you have entered incorrect details, it will send back
    the error to the client.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 登录也是如此：当你在一个网站上输入用户名和密码并点击登录时，服务器上的代码会被触发。这段代码将验证你输入的详细信息与数据库中的信息是否匹配。如果你有正确的详细信息，它将发送一个登录用户的门户页面给你。如果你输入了错误的详细信息，它将向客户端发送错误信息。
- en: In this section, we will cover the basics of communication between the frontend
    and backend, and we will show you how you can use JavaScript to write backend
    code as well using Node.js.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍前端和后端之间通信的基础，并展示你如何使用Node.js编写后端代码。
- en: APIs
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: APIs
- en: An **API** (**Application Programming Interface**) is essentially an interface
    for code, written with more code. A request can be made to an API using (for example)
    a URL. This will trigger a certain piece of code and this piece of code will give
    a certain response back.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**（**应用程序编程接口**）本质上是一个用更多代码编写的代码接口。可以使用（例如）URL来向API发出请求。这将触发一段特定的代码，这段代码将返回一个特定的响应。'
- en: 'This is all very abstract, so let''s use an example. If we had a website for
    a hotel, it would make sense for people to be able to make bookings online. This
    would require us to have some sort of API. Whenever a user has filled out all
    the fields and clicks on **Submit booking**, the API will get triggered by calling
    the URL and sending all the data that the user has entered to that endpoint (a
    specific URL), for example: `www.api.hotelname.com/rooms/book`. This API will
    process and validate our data and when everything is fine, it will store the room
    booking in our database and probably send a confirmation mail to our guest.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很抽象，所以让我们用一个例子来说明。如果我们有一个酒店网站，人们能够在线预订房间是有意义的。这需要我们有一种 API。每当用户填写完所有字段并点击
    **提交预订** 时，API 将通过调用 URL 并将用户输入的所有数据发送到该端点（一个特定的 URL）来触发，例如：`www.api.hotelname.com/rooms/book`。这个
    API 将处理和验证我们的数据，当一切正常时，它将在我们的数据库中存储房间预订，并可能向我们的客人发送确认邮件。
- en: 'Whenever one of the hotel clerks goes to check out the reservations, another
    API call will be made using one of the endpoints. It could be an endpoint that
    looks like this for example: `www.api.hotelname.com/reservations`. This would
    first go ahead and check whether our employee is logged in with the right role,
    and if so, it will fetch all the reservations for the selected date range from
    the database and send the page with the results back to our employee, who can
    then see all the bookings. So APIs are the connection points between the logic,
    database, and frontend.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当酒店职员去检查预订时，将使用其中一个端点发起另一个 API 调用。例如，这个端点可能看起来像这样：`www.api.hotelname.com/reservations`。这将首先检查我们的员工是否以正确的角色登录，如果是，它将从数据库中检索所选日期范围内的所有预订，并将包含结果的页面发送回我们的员工，然后员工可以看到所有预订。因此，API
    是逻辑、数据库和前端之间的连接点。
- en: 'APIs work with **Hypertext Transfer Protocol** (**HTTP**) calls. HTTP is just
    a protocol for communication between two parties: a client and a server, or a
    server and another server (in which the requesting server acts like the client).
    This means that it has to stick to certain conventions and rules that the other
    party expects, and the other party will respond in a certain way. For example,
    this means using a specific format to specify headers, using GET methods for getting
    information, using POST methods for creating new information on the server, and
    using PUT methods to change information on the server.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: API 通过 **Hypertext Transfer Protocol** （**HTTP**） 调用工作。HTTP 只是一个用于双方（客户端和服务器，或服务器和另一个服务器，其中请求服务器充当客户端）之间通信的协议。这意味着它必须遵守对方期望的某些约定和规则，对方将以某种方式做出回应。例如，这意味着使用特定的格式来指定头信息，使用
    GET 方法获取信息，使用 POST 方法在服务器上创建新信息，以及使用 PUT 方法更改服务器上的信息。
- en: There can be more done with APIs, for example, your computer and printer communicate
    via an API as well. However, this is not too relevant from a JavaScript point
    of view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 API 做更多的事情，例如，你的计算机和打印机也通过 API 进行通信。然而，从 JavaScript 的角度来看，这并不太相关。
- en: You will see how to consume these APIs in the *AJAX* section. You can also write
    your own APIs, and the ultimate basics of how to do this can be found in the *Node.js*
    section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 *AJAX* 部分看到如何消费这些 API。你也可以编写自己的 API，而如何做到这一点的最终基础知识可以在 *Node.js* 部分找到。
- en: AJAX
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AJAX
- en: '**AJAX** stands for **Asynchronous JavaScript and XML**, which is a misnomer,
    because nowadays it is more common to use JSON instead of XML. We use it to make
    calls from the frontend to the backend, without refreshing the page (asynchronously).
    AJAX is not a programming language or a library, it is a combination of the built-in
    `XMLHttpRequest` object in the browser and the JavaScript language.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**AJAX** 代表 **Asynchronous JavaScript and XML**，这是一个误称，因为如今更常见的是使用 JSON 而不是
    XML。我们使用它来从前端向后台发起调用，而不需要刷新页面（异步）。AJAX 不是一个编程语言或库，它是浏览器内置的 `XMLHttpRequest` 对象和
    JavaScript 语言的组合。'
- en: 'You probably won''t be using plain AJAX in your day-to-day life as a frontend
    developer nowadays, but it is being used beneath the surface so it won''t hurt
    to know how it works. Here is an example of calling the backend using AJAX:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前端开发者，你可能现在不会在日常工作中使用纯 AJAX，但它被隐藏在表面之下，所以了解它是如何工作的不会有害。以下是一个使用 AJAX 调用后端的示例：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is not a working example, because there is no valid URL, but it demonstrates
    how AJAX works. It sets up what it needs to do when the request has been loaded,
    in this case, replacing the HTML inside the element with ID `content` with whatever
    the link returns. This could be a link to a file, or to some API that calls a
    database. It can give different responses when there is other (or no) data in
    the database. This response is in JSON, but it could also be in XML. This depends
    on how the server was coded.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个工作示例，因为没有有效的URL，但它演示了AJAX是如何工作的。它设置了当请求被加载时需要执行的操作，在这种情况下，用链接返回的内容替换元素ID为`content`内的HTML。这可以是一个文件的链接，或者是一个调用数据库的API。当数据库中有其他（或没有）数据时，它可以给出不同的响应。这个响应是JSON格式的，但它也可以是XML格式的。这取决于服务器是如何编写的。
- en: 'More common now is the use of the **Fetch API** for AJAX requests. This is
    similar to what we can do with `XMLHttpRequest` but it provides a more flexible
    and powerful set of features. For example, in the following code we get the data
    from the URL, convert it to JSON with the `json()` method, and output it to the
    console:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更常见的是使用**Fetch API**进行AJAX请求。这与我们可以用`XMLHttpRequest`做到的事情类似，但它提供了一套更灵活、更强大的功能。例如，在下面的代码中，我们通过`json()`方法从URL获取数据，将其转换为JSON，并将其输出到控制台：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Fetch API works with promises, which should look familiar at this point.
    So after the promise is resolved, a new one gets created with `then`, and when
    that one is resolved, the next `then` gets executed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API与承诺（promises）一起工作，这一点到现在应该已经很熟悉了。所以当承诺被解决后，会通过`then`创建一个新的承诺，当这个承诺被解决后，下一个`then`会被执行。
- en: 'At the time of writing, more information can be found here: [https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，更多相关信息可以在这里找到：[https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started).
- en: Practice exercise 15.1
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习题15.1
- en: 'Create a JSON file and using `fetch`, return the results as a usable object
    into your JavaScript code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个JSON文件，并使用`fetch`将结果作为可用的对象返回到你的JavaScript代码中：
- en: Create a JSON object and save it in a file called `list.json`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个JSON对象，并将其保存到名为`list.json`的文件中。
- en: Using JavaScript, assign the filename and path to a variable named `url`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JavaScript，将文件名和路径分配给名为`url`的变量。
- en: Using `fetch`, make the request to the file URL. Return the results as JSON.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fetch`向文件URL发起请求。将结果作为JSON返回。
- en: Once the response object is ready, iterate through the data and output the results
    into the console of each item in the JSON file.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦响应对象准备就绪，遍历数据并将结果输出到JSON文件中每个项目的控制台。
- en: Node.js
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js
- en: We can write APIs in JavaScript using Node.js. Node.js is a very clever runtime
    environment that has taken the Google JavaScript engine, expanded it, and made
    it possible to run JavaScript on servers, interacting with the filesystem protocol
    and HTTP using JavaScript. Because of this, we can use JavaScript for the backend.
    This means that you can write both the backend and the frontend with only one
    language (along with HTML and CSS). Without Node.js, you would have to use another
    language such as PHP, Java, or C# for the backend.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Node.js在JavaScript中编写API。Node.js是一个非常聪明的运行环境，它采用了Google JavaScript引擎，进行了扩展，并使得JavaScript能够在服务器上运行，通过JavaScript与文件系统协议和HTTP进行交互。正因为如此，我们可以使用JavaScript进行后端开发。这意味着你可以只用一种语言（连同HTML和CSS）来编写前后端。如果没有Node.js，你将不得不使用其他语言，如PHP、Java或C#来编写后端。
- en: In order to run Node.js, you first have to set it up and then run the `node
    nameOfFile.js` command. You can find out how to set it up on your system in the
    official Node.js documentation. Often it requires downloading and installing something,
    and then you are done.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行Node.js，你首先需要设置它，然后运行`node nameOfFile.js`命令。你可以在官方Node.js文档中找到如何在你的系统上设置它的方法。通常需要下载和安装某些东西，然后你就可以完成了。
- en: At the time of writing, the download instructions are accessible at [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，下载说明可以在[https://nodejs.org/en/download/](https://nodejs.org/en/download/)找到。
- en: 'Here is an example of some code that will receive HTTP calls that can be written
    for Node.js:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码示例，它将接收可以编写在Node.js中的HTTP调用：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We start by importing the `http` module. This is an external code file that
    needs to be imported in order to run. The `http` module comes with Node.js, but
    other modules might need to be installed. You will use a package manager for this,
    such as NPM, which will help to install all the dependencies and be able to manage
    all the different versions of the external modules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 `http` 模块。这是一个需要导入以运行的外部代码文件。`http` 模块随Node.js一起提供，但其他模块可能需要安装。你将使用包管理器来完成这项工作，例如NPM，它将帮助安装所有依赖项并管理所有外部模块的不同版本。
- en: The code above sets up a server that is listening to port `8080`, and whenever
    it gets accessed, it will return `Finally, hello Rob`. We create the server with
    the `createServer` method on the imported `http` module. We then say what needs
    to happen for a call to our server. We respond with a 200 status (indicating "OK")
    and write `Finally, hello Rob` to the response. We then specify the default port
    `8080` as the listening port.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码设置了一个监听端口 `8080` 的服务器，每次访问时，它将返回 `Finally, hello Rob`。我们使用导入的 `http` 模块的
    `createServer` 方法创建服务器。然后我们说明了对我们的服务器进行调用时需要发生什么。我们以200状态（表示“OK”）响应，并将 `Finally,
    hello Rob` 写入响应。然后我们指定默认端口 `8080` 作为监听端口。
- en: This example uses the built-in `http` module for Node.js, which is very powerful
    for creating APIs. This is definitely something that's worth having some experience
    with. Being able to write your own APIs will enable you to write full applications
    yourself. This gets even easier when we add Express to the mix.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了Node.js的内置 `http` 模块，这对于创建API非常强大。这绝对是一件事，值得有一些经验。能够编写自己的API将使你能够自己编写完整的应用程序。当我们添加Express时，这变得更加容易。
- en: Using the Express Node.js framework
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Express Node.js框架
- en: Node.js is not a framework, nor a library. It is a runtime environment. This
    means that it can run and interpret the JavaScript code written. There are frameworks
    for Node.js and currently Express is the most popular one.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 不是一个框架，也不是一个库。它是一个运行环境。这意味着它可以运行和解释编写的JavaScript代码。有针对Node.js的框架，目前Express是最受欢迎的一个。
- en: 'Here is a very basic Express application—again, you will have to set up Node.js
    first, then add the Express module (if you are using NPM, `npm install express`
    will do) and run it using the `node nameOfRootFile.js` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常基础的Express应用程序——同样，你将不得不首先设置Node.js，然后添加Express模块（如果你使用NPM，`npm install
    express` 将会完成）并使用 `node nameOfRootFile.js` 命令运行它：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After running this and going to `localhost:3000` (assuming you are running it
    on localhost), you will get the message **Hello Express!** in your browser. In
    the terminal where you are running your `Node` app, it will print the console
    log message after loading.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码并访问 `localhost:3000`（假设你在本地主机上运行它），你将在浏览器中看到消息 **Hello Express!**。在你运行
    `Node` 应用的终端中，它将在加载后打印控制台日志消息。
- en: 'You can find more in the Node.js documentation, which at the time of writing
    is at the following address: [https://nodejs.org/en/docs/](https://nodejs.org/en/docs/).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Node.js文档中找到更多信息，撰写本文时，该文档的地址如下：[https://nodejs.org/en/docs/](https://nodejs.org/en/docs/)。
- en: For the Express module, you can go to [https://expressjs.com/en/5x/api.html](https://expressjs.com/en/5x/api.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Express模块，你可以访问 [https://expressjs.com/en/5x/api.html](https://expressjs.com/en/5x/api.html)。
- en: Next steps
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: You have learned a lot about JavaScript in this book and with this chapter you
    should have an idea of possible next steps you can take. This chapter hasn't taught
    you all of these topics in depth, as entire books could be (and have been) written
    about each of them, but you should have a good idea of where to look for your
    next steps and what to consider while deciding which next step to take.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书和这一章中，你已经学到了很多关于JavaScript的知识，通过这一章，你应该对可能的下一步行动有一个大致的想法。这一章并没有深入教授所有这些主题，因为关于每个主题都可以（并且已经）写出整本书，但你应该有一个很好的方向去寻找你的下一步行动，并在决定采取哪一步时考虑什么。
- en: The best way to learn is by doing. So we highly recommend you just come up with
    a fun project idea and go ahead and try to make it. Alternatively, with this knowledge,
    you may feel ready for an entry-level JavaScript position! You can also do tutorials
    online or even work in a project team as a junior, using freelance platforms such
    as Upwork or Fiverr to get a project. These are hard to find though, and we can
    imagine that you'll learn a framework or get a bit more experience with Node.js
    first. However, this is often possible on the job if you can show your skills
    and potential in the hiring process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的学习方式是通过实践。所以我们强烈建议你提出一个有趣的项目想法，然后尝试去实现它。或者，有了这些知识，你可能觉得自己已经准备好进入JavaScript的初级职位！你还可以在线做教程，甚至作为一个初级成员加入项目团队，使用Upwork或Fiverr等自由职业平台来获取项目。这些项目很难找到，我们可以想象你将首先学习一个框架或获得一些Node.js的经验。然而，如果你能在招聘过程中展示你的技能和潜力，这通常在工作时是可能的。
- en: Chapter projects
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Working with JSON
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理JSON
- en: 'Create a JSON file locally, connect to the JSON and data, and output the data
    from the JSON file into your console:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地创建一个JSON文件，连接到JSON和数据，并将JSON文件中的数据输出到你的控制台：
- en: Create a file with the extension JSON name it `people.json`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展名为JSON的文件，命名为`people.json`。
- en: Within `people.json` create an array that contains multiple objects. Each item
    in the array should be an object that has the same structure, using `first`, `last`,
    and `topic` as the property names. Make sure you use double quotes around the
    property names and values as this is the proper JSON syntax.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`people.json`中创建一个包含多个对象的数组。数组中的每个项目都应该是一个具有相同结构的对象，使用`first`、`last`和`topic`作为属性名。确保在属性名和值周围使用双引号，因为这才是正确的JSON语法。
- en: Add three or more entries into the array using the same object structure for
    each item.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的对象结构为每个项目添加三个或更多条目。
- en: Create an HTML file and add a JavaScript file. Within the JavaScript file use
    `people.json` as the URL. Using `fetch` connect to the URL and retrieve the data.
    Since this is a JSON-formatted file, once you get the response data it can be
    formatted into JSON using the `.json()` method in `fetch`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML文件并添加一个JavaScript文件。在JavaScript文件中，使用`people.json`作为URL。使用`fetch`连接到URL并检索数据。由于这是一个JSON格式的文件，一旦获取到响应数据，就可以使用`fetch`中的`.json()`方法将其格式化为JSON。
- en: Output the full contents of the data into the console.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据的全部内容输出到控制台。
- en: Using `foreach`, loop through the items in the data and output the values into
    the console. You can use a template literal and output each value.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`foreach`循环遍历数据中的项目，并将值输出到控制台。您可以使用模板字符串并输出每个值。
- en: List-making project
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表制作项目
- en: 'Create a list that saves to local storage so even if the page is refreshed,
    the data will persist within the browser. If the local storage is empty on the
    first load of the page, set up a JSON file that will be loaded to the local storage
    and saved as a default list to start the list:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个列表，将其保存到本地存储，这样即使刷新页面，数据也会在浏览器中持续存在。如果页面首次加载时本地存储为空，则设置一个JSON文件，将其加载到本地存储，并保存为默认列表以开始列表：
- en: Set up an HTML file, adding a `div` to output the list results to, and an input
    field with a button that can be clicked.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个HTML文件，添加一个`div`来输出列表结果，以及一个带有按钮的输入字段，可以点击。
- en: Using JavaScript, add the page elements as objects that can be used within the
    code.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JavaScript，将页面元素作为对象添加，以便在代码中使用。
- en: Create your default JSON file (which can be empty) and add the path to the file
    into your JavaScript code using a variable called `url`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的默认JSON文件（可以是空的），并使用名为`url`的变量将文件的路径添加到你的JavaScript代码中。
- en: Add an event listener to the button element that will run a function called
    `addToList()`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮元素添加一个事件监听器，该监听器将运行一个名为`addToList()`的函数。
- en: In `addToList()`, check if the value of the input field has a length of 3 or
    more. If it does then create an object with a name and the value of the input
    field. Create a global variable named `myList` to hold the list, and within `addToList()`
    push the new object data into `myList`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`addToList()`中，检查输入字段的值长度是否为3或更多。如果是，则创建一个具有名称和输入字段值的对象。创建一个名为`myList`的全局变量来保存列表，并在`addToList()`中将新的对象数据推入`myList`。
- en: Create a function called `maker()`, which will create the page element and add
    text into the element, appending it to the output element. Invoke `maker()` to
    add the new item within the `addToList()` function.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`maker()`的函数，该函数将创建页面元素并将文本添加到元素中，将其附加到输出元素。在`addToList()`函数中调用`maker()`以添加新项目。
- en: Also, save the item to local storage so that the visual content of `myList`
    will be synced with the local storage saved value. To do this, create a function
    called `savetoStorage()` and invoke it every time you update the `myList` in the
    script.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将项目保存到本地存储，以便`myList`的视觉内容与本地存储中保存的值同步。为此，创建一个名为`savetoStorage()`的函数，并在每次更新脚本中的`myList`时调用它。
- en: Within the `savetoStorage()` function, set the value of `myList` into `localStorage`
    using `setItem`. You will need to convert `myList` into a string value to save
    it into `localStorage`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`savetoStorage()`函数中，使用`setItem`将`myList`的值设置到`localStorage`中。您需要将`myList`转换为字符串值以保存到`localStorage`中。
- en: Add to the code `getItem()` to retrieve a value of `myList` from `localStorage`.
    Set up a global variable for the `myList` array.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向代码中添加`getItem()`以从`localStorage`检索`myList`的值。为`myList`数组设置一个全局变量。
- en: Add an event listener to listen for `DOMContentLoaded`. Within that function,
    check if the localstorage loaded a value. If it did then get `myList` from local
    storage and convert it from a string to a JavaScript object. Clear the output
    element contents. Loop through the items in `myList` and add them to the page
    with the `maker()` function created earlier.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件监听器来监听`DOMContentLoaded`。在函数中，检查是否从本地存储加载了值。如果是，则从本地存储获取`myList`并将其从字符串转换为JavaScript对象。清除输出元素的
    内容。遍历`myList`中的项目，使用之前创建的`maker()`函数将它们添加到页面中。
- en: If `localStorage` does not have content, load the JSON file with the default
    values using `fetch`. Once the data is loaded, assign it to the global `myList`
    value. Loop through the items in `myList` and using `maker()`, output them to
    the page. Don't forget to invoke `savetoStorage()` after so that the storage will
    contain the same list items as are visible on the page.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`localStorage`没有内容，使用`fetch`加载带有默认值的JSON文件。一旦数据加载，将其分配给全局的`myList`值。遍历`myList`中的项目，使用`maker()`函数将它们输出到页面。别忘了在之后调用`savetoStorage()`，这样存储将包含与页面上可见的相同列表项。
- en: Self-check quiz
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: What are JavaScript libraries and frameworks?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是JavaScript库和框架？
- en: How can you tell if a webpage is using the jQuery library?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何判断一个网页是否使用了jQuery库？
- en: Which library contains a lot of functionality for manipulating data?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个库包含了大量用于操作数据的功能？
- en: When Node.js is installed, how can you run a Node.js file?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Node.js安装后，如何运行一个Node.js文件？
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored a few of the possibilities to continue your
    JavaScript journey and keep on improving yourself. We started off by discussing
    the frontend and what libraries and frameworks are. Libraries and frameworks are
    both pre-made code that you can use in your project, but libraries typically solve
    one problem while frameworks provide a standard solution that usually controls
    the way you structure your application and will come with some limitations. On
    the other hand, frameworks are great fits for very many things you might want
    to do with your web apps.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了一些继续你的JavaScript之旅并不断提升自己的可能性。我们首先讨论了前端以及库和框架。库和框架都是预先编写的代码，你可以在项目中使用，但库通常解决一个问题，而框架提供了一种标准解决方案，通常控制你构建应用程序的方式，并可能带来一些限制。另一方面，框架非常适合你想要在Web应用程序中做的很多事情。
- en: We then moved on to looking at the backend. The backend is the code that runs
    on the server and we can write this code in JavaScript when we use Node.js. Node.js
    is a runtime engine that can process JavaScript and has some additional features
    for JavaScript that we don't have when using JavaScript in the browser.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着转向查看后端。后端是运行在服务器上的代码，当我们使用Node.js时，我们可以用JavaScript编写这段代码。Node.js是一个可以处理JavaScript的运行时引擎，并且为JavaScript提供了一些额外的功能，这些功能在使用浏览器中的JavaScript时是没有的。
- en: 'And that''s it. You have a very solid understanding of JavaScript at this point.
    You have seen all the major building blocks, and had a lot of practice with smaller
    exercises and bigger projects. There are a few things for certain: you''ll never
    be done with learning as a JavaScript programmer, and you will keep on amazing
    yourself with the things you can make as you keep on progressing.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。在这个阶段，你对JavaScript有了非常扎实的理解。你已经看到了所有主要的构建块，并在许多小练习和大型项目中进行了大量实践。有几件事是肯定的：你永远不会完成作为JavaScript程序员的学业，而且随着你不断进步，你将不断地用你可以制作的东西来让自己感到惊讶。
- en: Don't forget to have fun!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记享受乐趣！
