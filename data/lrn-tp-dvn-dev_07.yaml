- en: Making Types That Represent Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建表示操作的类型
- en: In previous chapters, we've seen how to build types to model many kinds of data.
    Through all of these chapters, we've relied on functions. Functions wrap calculations
    and actions for easy reuse, so it makes sense that they're among the most heavily
    used features in any programming language. So, by taking advantage of Reason's
    type system and functional programming techniques, we can design functions for
    maximum effectiveness.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何构建类型来模拟多种类型的数据。在所有这些章节中，我们都依赖于函数。函数封装计算和操作以便于重用，因此它们是任何编程语言中最常用的功能之一。因此，通过利用Reason的类型系统和函数式编程技术，我们可以设计出最有效的函数。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Meaningful function types and useful properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有意义的函数类型和有用的属性
- en: Currying and partial application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化和部分应用
- en: Higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Using functions to control dependency ordering and program flow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数来控制依赖顺序和程序流程
- en: Commonly used functions and operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用函数和运算符
- en: But first, what is a function? A **function** in type theory and mathematics
    has a formal definition, but we can think of it as a formula for calculating an
    output given an input. In Reason and other statically-typed functional programming
    languages, functions *always* have an output, even if they don't actually calculate
    anything. We'll examine how to express these inputs and outputs, but we first
    need a basic understanding of function types and properties.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，什么是函数？在类型理论和数学中，函数有一个正式的定义，但我们可以将其视为给定输入计算输出的公式。在Reason和其他静态类型函数式编程语言中，函数总是有输出的，即使它们实际上没有进行任何计算。我们将研究如何表达这些输入和输出，但首先我们需要对函数类型和属性有一个基本了解。
- en: Function types and other useful properties
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型和其他有用的属性
- en: In Reason, functions have very specific types and, just like other values, functions
    of different types can't be substituted for one another.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason中，函数具有非常具体的类型，并且就像其他值一样，不同类型的函数不能相互替换。
- en: 'The basic type of every Reason function is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Reason函数的基本类型如下：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Read this as *a arrow b*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将其读作`a -> b`。
- en: As you can see, the input, `a`, and the output, `b`, can be any type (even the
    same one). This basic function type, with a single input and a single output,
    gives rise to every other function type in Reason. We'll cover how this happens
    shortly, but first let's talk about a couple of useful functional programming
    concepts that are important in the type-driven world.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输入`a`和输出`b`可以是任何类型（甚至是相同的类型）。这种基本函数类型，具有单个输入和单个输出，导致了Reason中所有其他函数类型。我们将在稍后讨论这是如何发生的，但首先让我们谈谈几个在类型驱动世界中非常重要的有用函数式编程概念。
- en: Referential transparency
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明性
- en: The first property, called **referential transparency** (or **RT**), means that
    a function will always produce the same output, `b`, for a given input, `a`, no
    matter how, when, or how many times we call it. This means that a function can't
    behave unpredictably; we must be able to predict its output for every input, purely
    like a mathematical formula.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性被称为**引用透明性**（或**RT**），这意味着对于给定的输入`a`，函数将始终产生相同的输出`b`，无论我们如何、何时或多少次调用它。这意味着函数不能表现出不可预测的行为；我们必须能够预测每个输入的输出，就像一个数学公式一样。
- en: 'For example, the following is a non-referentially transparent function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个非引用透明函数：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In Reason, float arithmetic operators are distinct from integer operators (they
    are suffixed with a dot). Reason tries to be as explicit as possible about arithmetic
    and conversions so that we can avoid surprising results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason中，浮点算术运算符与整数运算符不同（它们以点作为后缀）。Reason试图在算术和转换方面尽可能明确，以便我们可以避免意外结果。
- en: 'We can''t tell what the output will be for any given input, `x`, because that
    depends on the date and time  the function is called. The problem instead is the
    hidden dependency on the current date or time. One solution is to remove the dependency
    by passing it in as a function argument, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法预测任何给定输入`x`的输出，因为这取决于函数被调用的日期和时间。问题在于对当前日期或时间的隐藏依赖。一个解决方案是通过将依赖项作为函数参数传递来消除依赖，如下所示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The immediate benefit is that the function is easier to test, but the bigger
    benefit is that functions such as this in the codebase make it easier to reason
    about*.*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 立即的好处是函数更容易测试，但更大的好处是，代码库中这样的函数使得推理更容易*。
- en: Reasoning about code (also known as **equational reasoning**) means being able
    to substitute actual values in place of function arguments, and just like a math
    equation, evaluate to the result by simplifying it. This sounds like a trivial
    benefit, but when used over a codebase, it can be a powerful technique for ensuring
    transparency.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码的推理（也称为**等式推理**）意味着能够用实际值替换函数参数，就像一个数学方程式一样，通过简化来评估结果。这听起来像是一个微不足道的优势，但当在一个代码库中使用时，它可以是一个确保透明性的强大技术。
- en: Realistically speaking, we can't make the entire codebase referentially transparent
    (unless we use advanced techniques such as effect types). We can, however, push
    out the non-RT operations to the edges of the program. For example, we can call
    the (second) `xDaysAgo` function with either the result of a call to `Js.Date.now()` or
    a date value passed in from somewhere else. This is a simple but effective form
    of **dependency injection** (passing in values to a program instead of letting
    the program try to get the values itself). We'll cover dependency injection in
    more detail later on in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上讲，我们无法使整个代码库具有引用透明性（除非我们使用诸如效果类型等高级技术）。然而，我们可以将非RT操作推到程序的边缘。例如，我们可以用`Js.Date.now()`的调用结果或从其他地方传入的日期值调用（第二个）`xDaysAgo`函数。这是一种简单但有效的**依赖注入**形式（向程序传递值而不是让程序自己尝试获取值）。我们将在本章的后面部分更详细地介绍依赖注入。
- en: Function purity
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数纯净性
- en: 'The second important property that we try to achieve is **purity**. This concept
    means that, to the caller (that is, the code that calls it) and the outside world,
    a function has no impact other than evaluating to its result. We say that the
    function does not have any **observable effects**. Observability is the crucial
    thing here; there may well be effects happening and contained inside the function
    (such as mutation), but the caller doesn''t, and cannot, know about them. The
    following is an example of a pure function that mutates internally but not observably:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图实现的第二个重要属性是**纯净性**。这个概念意味着，对于调用者（即调用它的代码）和外部世界来说，一个函数除了评估其结果外没有其他影响。我们说函数没有任何**可观察的效果**。可观察性在这里是关键；可能确实有在函数内部发生和包含的效果（如突变），但调用者不知道，也不能知道它们。以下是一个纯函数的例子，它在内部发生突变但不可观察：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we were to add a `Js.log(result^)` inside the body of the `for` loop, the
    function would become impure because its effects would become observable. People
    sometimes disagree with what exactly observable means, especially in the context
    of logging the operations of otherwise-pure functions, but it's safe to err on
    the side of caution and accept that any observable effect is an impurity in the
    function (and that's OK, because sometimes we actually need those observable effects).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`for`循环体中添加一个`Js.log(result^)`，函数就会变得不纯，因为它的效果会变得可观察。人们有时对“可观察”的确切含义存在分歧，尤其是在记录其他方面纯净函数的操作时，但出于谨慎，我们可以接受任何可观察的效果都是函数中的杂质（而且这没关系，因为有时我们确实需要那些可观察的效果）。
- en: Totality
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全性
- en: The last important property that we want functions to have is **totality**.
    This means that functions should handle every possible value of the type that
    they accept, which is actually trickier than it seems! For example, look at the
    `xDaysAgo` function again. What happens if `x` is negative? Or very large or small?
    Did we account for integer overflow? Especially when working with numbers, we
    need to understand their properties on the platform we're running on top of.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望函数拥有的最后一个重要属性是**完全性**。这意味着函数应该处理它们接受的类型的每个可能值，这实际上比看起来要复杂得多！例如，再次看看`xDaysAgo`函数。如果`x`是负数怎么办？或者非常大或非常小？我们是否考虑了整数溢出？尤其是在处理数字时，我们需要了解它们在我们运行的平台的属性。
- en: 'In our case, we''re running on a JavaScript platform such as Node.js, so all
    numbers are internally represented as IEEE floats (that''s how JavaScript works)
    and we can get pretty far before we need to worry about overflow. But consider
    the following trivial function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们运行在JavaScript平台（如Node.js）上，所以所有数字都是内部表示为IEEE浮点数（这就是JavaScript的工作方式），我们可以在需要担心溢出之前走得很远。但考虑以下一个简单的函数：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first dollar symbol needs to be escaped, otherwise the compiler tries to
    treat it as starting an interpolation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个美元符号需要转义，否则编译器会尝试将其视为开始一个插值的标志。
- en: Here, we're just printing out what we want to happen. In a real application,
    we might want to do a money transfer. Suppose we exposed this function with an
    HTTP service call. What would happen if someone called the service with a negative
    float? The best-case scenario is that the error would be caught somewhere else;
    the worst is that people could make calls to siphon money out of other people's
    accounts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是打印出我们想要发生的事情。在实际应用中，我们可能想要进行货币转账。假设我们通过HTTP服务调用公开了这个函数。如果有人用负浮点数调用服务会发生什么？最好的情况是错误会在其他地方被捕获；最坏的情况是人们可能调用服务从别人的账户中吸走资金。
- en: 'One approach to solving this is to validate our arguments at the very beginning
    of the function, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是在函数的开始处验证我们的参数，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For good measure, in this snippet, we're doing some basic validation on the
    sender and receiver strings. We're also able to get rid of the type annotations
    because the assertions will cause them to be inferred correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保万无一失，在这个片段中，我们对发送者和接收者字符串进行了一些基本的验证。我们还能够去除类型注解，因为断言将导致它们被正确推断。
- en: '`assert` is a built-in keyword, although it looks and works like a function.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`是一个内置关键字，尽管它看起来和像一个函数工作。'
- en: 'From the function''s point of view, internally it''s now a total function because
    it explicitly errors on the cases it doesn''t want to handle, but does handle
    the remaining happy path. To the outside world, however, the function is still
    taking in raw strings and floats, and failing to handle most of them. A better
    solution is to use more constrained types to describe exactly what the function
    can accept, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数的角度来看，内部现在是一个完整的函数，因为它明确地错误处理了它不想处理的案例，但处理了剩余的愉快路径。然而，对于外界来说，函数仍然接受原始字符串和浮点数，并且未能处理大多数情况。一个更好的解决方案是使用更约束的类型来精确描述函数可以接受的内容，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We had to use `to_` as the parameter name instead of `to` because the latter
    is a reserved keyword in Reason. It's a common practice to add an underscore to
    a keyword if we want to use it as a name.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不使用`to_`作为参数名而不是`to`，因为在Reason中`to`是一个保留关键字。如果我们想将其用作名称，通常会在关键字前添加一个下划线。
- en: 'This snippet looks more verbose, but in the long run is the better solution
    because we can write tests for the wrapper types and their modules in isolation,
    get peace of mind that the types really do enforce our rules, and reuse the types
    instead of adding checks throughout the codebase. Here''s how it works:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段看起来更冗长，但从长远来看，这是一个更好的解决方案，因为我们可以在隔离的情况下为包装类型及其模块编写测试，确保类型确实执行了我们的规则，并且可以重用这些类型，而不是在整个代码库中添加检查。以下是它是如何工作的：
- en: We set up a type whose values can only be non-empty strings. If a caller tries
    to construct an empty string of the type, that will fail with an exception.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一个只能是非空字符串的类型。如果调用者尝试构造一个空字符串的类型，这将引发异常。
- en: The type declaration says that this is a `private` type, meaning that we expose
    its internal representation, but we don't allow users to construct values of the
    type. This is a useful technique when we want to semi-transparently take an existing
    type and restrict it in some way. We will see how to do that shortly.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型声明表明这是一个`private`类型，这意味着我们暴露了其内部表示，但不允许用户构造该类型的值。当我们想半透明地取一个现有的类型并对其进行某种限制时，这是一种有用的技术。我们很快就会看到如何做到这一点。
- en: Similarly, we set up a type whose values can be only positive floats.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们设置了一个只能有正浮点数值的类型。
- en: In the `sendMoney` function, we reap the benefit of these types by only accepting
    these constrained types instead of their raw variants. The function is now total
    because it only accepts exactly the values it works with by (type) definition.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sendMoney`函数中，我们通过只接受这些约束类型而不是它们的原始变体来利用这些类型的好处。现在函数是完整的，因为它根据（类型）定义只接受它处理的精确值。
- en: We still need to unwrap the constrained values to get at the raw ones, because
    ultimately we want to print the raw values. Because the types are declared as
    `private` though, we can **coerce** them back to their more general versions.
    Coercion means forcing a value of a constrained type (such as `NonEmptyString.t`)
    back to being a more general type (such as `string`). Coercion is completely static;
    if we can't coerce something, we'll get a compile error. Note that the syntax
    for coercion needs to be pretty exact, and it needs to include the parentheses.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要解包约束值以获取原始值，因为我们最终想要打印原始值。尽管类型被声明为 `private`，但我们可以将它们**强制**回更通用的版本。强制意味着将约束类型（如
    `NonEmptyString.t`）的值强制转换为更通用的类型（如 `string`）。强制是完全静态的；如果我们不能强制转换某个值，我们将得到编译错误。请注意，强制转换的语法需要相当精确，并且需要包括括号。
- en: We also need to wrap the values before we pass them into the function. This
    is the point that can potentially fail, so we've moved it outside of our function
    implementation.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将值传递给函数之前，我们还需要包装这些值。这是可能失败的地方，因此我们将它移出了我们的函数实现。
- en: Here, we've used the convention of adding `Exn` to the names of the functions
    that may throw exceptions. Some people prefer to return optional values instead
    of throwing exceptions. This convention is idiomatic and type-safe, but is ultimately
    just another method of reporting errors. The key point to take away is that any
    possible failures have been moved out of our total `sendMoney` function, and other
    functions that use constrained types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了在可能抛出异常的函数名称中添加 `Exn` 的约定。有些人更喜欢返回可选值而不是抛出异常。这个约定是惯用的且类型安全的，但最终只是报告错误的一种方法。关键点是，任何可能的失败都已被移出我们的总
    `sendMoney` 函数以及其他使用约束类型的函数。
- en: What a function type means
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型意味着什么
- en: In the context of type-driven development, why are functional programming concepts
    such as referential transparency, purity, and totality important? The reason is
    that a function's type has a well-understood mathematical meaning, and breaking
    such rules muddy this meaning.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型驱动开发的背景下，为什么引用透明性、纯洁性和完备性等函数式编程概念很重要？原因是函数的类型有一个被充分理解的数学意义，违反这些规则会模糊这个意义。
- en: A function type such as `a => b` means that a function of this type will accept
    an input of type `a` and evaluate to a result of type `b`, and will do nothing
    else (for example, print out a log, start the coffee maker, or launch missiles).
    We like having this guarantee in much the same way that we like knowing that an
    `int` is just an `int`, and not a missile launch followed by an `int`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `a => b` 的函数类型意味着这种类型的函数将接受类型为 `a` 的输入并评估为类型为 `b` 的结果，并且不会做其他任何事情（例如，打印日志、启动咖啡机或发射导弹）。我们非常喜欢这种保证，就像我们喜欢知道
    `int` 只是一个 `int`，而不是导弹发射后跟一个 `int` 一样。
- en: The fact that Reason allows side effects is a great pragmatic decision, but
    we can still strive to push the side effects to the very edges of our programs
    and keep their cores purely functional. Purity in the functional sense is necessary
    for the type of a function to be accurate. If types in our program are accurate,
    we can perform type-driven development with more confidence.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，Reason 允许副作用是一个伟大的实用决策，但我们仍然可以努力将副作用推到我们程序的边缘，并保持其核心纯粹是函数式的。在函数式意义上，纯洁性对于函数类型的准确性是必要的。如果我们程序中的类型是准确的，我们就可以更有信心地进行类型驱动开发。
- en: Multiple arguments and currying
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个参数和柯里化
- en: We've already mentioned that Reason functions always accept a single argument
    and return a single value, but we've been happily using functions that look like
    they take multiple arguments, for example, `xDaysAgo(now, x)`. How is this possible?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，Reason 函数始终接受单个参数并返回单个值，但我们一直愉快地使用看起来接受多个参数的函数，例如 `xDaysAgo(now, x)`。这是如何可能的？
- en: 'In Reason, functions with multiple arguments are automatically **curried**.
    This means that they are actually functions that accept a single argument and
    return a new function, which accepts the next argument, and so on, forming a chain
    of single-argument functions that finally return a result. This might seem like
    it''s inefficient, but in practice the compiler can almost always optimize the
    chain of calls into a single, efficient call. Let''s look at the following concrete
    example, defining `xDaysAgo`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason中，具有多个参数的函数会自动**柯里化**。这意味着它们实际上是接受单个参数并返回一个新的函数，该函数接受下一个参数，依此类推，形成一个单参数函数的链，最终返回一个结果。这看起来可能效率不高，但在实践中，编译器几乎总能优化调用链为单个高效的调用。让我们看看以下具体的例子，定义`xDaysAgo`：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This syntax is equivalent to the following (which is supported by the Reason
    code formatter tool, and thus usually seen in the wild):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法等同于以下（这由Reason代码格式化工具支持，因此通常在野外看到）：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we have the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有以下内容：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, we can call the following function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以调用以下函数：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That is equivalent to the following syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下语法：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The compiler understands that this syntax is a **fully applied** function call,
    and optimizes accordingly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器理解这个语法是一个**完全应用**的函数调用，并相应地进行优化。
- en: 'Sometimes, a call isn''t fully applied. In other words, it''s **partially applied**.
    This means that it has been called with only some of the arguments that it accepts.
    A partially-applied function is just a function that accepts one or more arguments
    but, by definition, fewer arguments than the original function. Let''s look at
    the following simple example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个调用不是完全应用的。换句话说，它是**部分应用**的。这意味着它只使用了它接受的某些参数。一个部分应用的函数只是接受一个或多个参数，但根据定义，比原始函数少的参数。让我们看看以下简单的例子：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example captures the current moment in time by making a call to the appropriate
    JavaScript date function and then feeds or injects it into the `xDaysAgo` function
    to get back a new function that's been primed with the current time. This new
    function is then bound to the name `xDaysBeforeNow` and called to get a result.
    The result will be deterministic; in other words, we'll always get back the same
    output for a given input. The reason is that the non-deterministic data has already
    been *fed* into the function and is captured as a static value inside it. In other
    words, `xDaysBeforeNow` is also referentially transparent.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例通过调用适当的JavaScript日期函数并随后将其注入到`xDaysAgo`函数中，以获取一个预先加载了当前时间的新的函数来捕捉当前时刻。然后，这个新函数被绑定到名称`xDaysBeforeNow`并调用以获取结果。结果将是确定的；换句话说，对于给定的输入，我们总是会得到相同的输出。原因是非确定性的数据已经输入到函数中，并作为静态值捕获在函数内部。换句话说，`xDaysBeforeNow`也是引用透明的。
- en: 'As a rule, functions that we get from applications of a referentially-transparent
    function (such as `xDaysAgo`) are also referentially transparent. The same rule
    holds true for the other functional properties: purity and totality. This helps
    us out a lot when we''re building specialized functions out of more general ones,
    as we can start with confidence and keep that confidence at every step.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规则，我们从引用透明函数的应用中获得的函数（如`xDaysAgo`）也是引用透明的。这个规则同样适用于其他函数特性：纯净性和完备性。这在我们从更一般的函数构建专用函数时非常有帮助，因为我们可以从自信开始，并在每一步保持这种自信。
- en: Now, let's take a look at another example of partial application that is both
    fun and shows its usefulness.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个既有趣又展示了其有用性的部分应用示例。
- en: 'In the following example, we define a function that returns or prints the label
    for an envelope used to mail a letter, using the name of the recipient, the postal
    address, and so on. This function could be defined as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们定义了一个函数，该函数返回或打印用于邮寄信件的信封标签，使用收件人的姓名、邮政地址等。此函数可以定义为如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can call the function the normal way, with all of its parameters, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样以正常方式调用该函数，使用所有参数：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also define another function for partial application, passing a value
    for the country parameter, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义另一个用于部分应用的函数，为国家参数传递一个值，如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also pass a value for the `lastname` parameter, for a function that
    prints the label for the members of the same household, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为`lastname`参数传递一个值，为打印同一家庭成员标签的函数，如下所示：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The execution of the JS resulting from the compilation of this example (`src/Ch07/Ch07_Currying.re`)
    gives the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例（`src/Ch07/Ch07_Currying.re`）编译后生成的 JS 执行结果如下：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Functions as values
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为值
- en: In the previous section, we covered how function definitions syntactically **desugar**
    (that is, slightly more cumbersome syntax is used) into a series of chained function
    values. Let's examine the idea that functions are actually first-class values
    in Reason, just as much as things like numbers, strings, records, and so on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了如何通过将函数定义语法上 **去糖化**（即使用稍微繁琐的语法）成一系列链式函数值。让我们来探讨函数在 Reason 中实际上是第一类值这一观点，就像数字、字符串、记录等一样。
- en: Function literal syntax
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数字面量语法
- en: 'Reason provides strong support for so-called **function literals,** also known
    as **lambdas** or **closures**. This means that, as in JavaScript and various
    other languages, we can directly write down function values wherever it''s legal
    to write down any value. The following is the basic syntax for a function literal:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 为所谓的 **函数字面量** 提供了强大的支持，也称为 **lambda** 或 **闭包**。这意味着，就像在 JavaScript 和其他各种语言中一样，我们可以在任何可以写下任何值的地方直接写下函数值。以下是一个函数字面量的基本语法：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the syntax for writing a curried function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为编写柯里化函数的语法：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Reason provides a familiar-looking syntactic sugar for writing a curried function,
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 为编写柯里化函数提供了一个看起来熟悉的语法糖，如下所示：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice the deliberate use of `PATTERN`, as with bindings, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到与绑定一样，故意使用了 `PATTERN`：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Indeed, Reason functions (whether literal or normal function bindings) can
    always directly pattern match on their parameters. As with any pattern match,
    however, we must be cautious about matching against refutable patterns in function
    parameters, because those risk failing at runtime. The following snippet includes
    examples of function literals:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Reason 函数（无论是字面量还是正常函数绑定）都可以直接对其参数进行模式匹配。然而，与任何模式匹配一样，我们必须小心在函数参数中匹配可反驳的模式，因为这些风险在运行时失败。以下代码片段包括函数字面量的示例：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This file shows quite a lot of things, explained as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件展示了相当多的事物，如下所述：
- en: We define a function using the syntax we've been using throughout the book,
    for comparison.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用本书中一直使用的语法定义一个函数，以进行比较。
- en: How to define and immediately bind a function literal using the slightly desugared
    Reason syntax.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用稍微去糖化的 Reason 语法定义并立即绑定一个函数字面量。
- en: 'How to define and immediately bind a function literal using the fully desugared
    curried syntax. The important thing to realise here is that these three functions
    are of exactly the same type and behavior, and can be called in exactly the same
    way: `addV*n*(1, 2)`.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用完全去糖化的柯里化语法定义并立即绑定一个函数字面量。这里需要意识到的是，这三个函数在类型和行为上完全相同，并且可以以完全相同的方式调用：`addV*n*(1,
    2)`。
- en: 'How to define a type that can contain two functions: one to convert a given
    type, `''a`, to a `float`, and another to convert the `float` back to that same
    `''a`. Note that we use the naming convention to show that both functions can
    potentially throw exceptions, because we can''t guarantee beforehand that every
    type `''a` can actually be converted to and from `float`.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义一个可以包含两个函数的类型：一个将给定的类型 `'a'` 转换为 `float`，另一个将 `float` 转换回相同的 `'a'`。请注意，我们使用命名约定来表明这两个函数都可能抛出异常，因为我们不能事先保证每个类型
    `'a'` 都可以实际转换为 `float` 并返回。
- en: How to define a `FloatConverter.t(float)`, which (trivially) knows how to convert
    a `float` to a `float`. The functions are implemented as simply `float => float`,
    which in this context means to return the same float that was received as input.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义一个 `FloatConverter.t(float)`，它（简单地）知道如何将 `float` 转换为 `float`。函数实现为 `float
    => float`，在这个上下文中意味着返回与输入相同的 `float`。
- en: How to define a `FloatConverter.t(int)` that knows how to convert between `int` and
    `float`, using functions available in the Reason standard library for comparison.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义一个 `FloatConverter.t(int)`，它知道如何使用 Reason 标准库中的函数在 `int` 和 `float` 之间进行转换。
- en: Finally, we saw how to define another greeter function by creating a function
    literal, using destructuring pattern matching of the parameter and binding the
    function to the name `greet`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何通过创建一个函数字面量，使用参数的解构模式匹配并将函数绑定到名称 `greet` 来定义另一个问候函数。
- en: Eta abstraction
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eta 抽象
- en: 'Notice that, in the preceding sixth point, we used two standard library-provided
    functions directly as values. We could have wrapped them inside first-class functions
    instead, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的第六点中，我们直接使用了两个标准库提供的函数作为值。我们也可以将它们包裹在第一类函数中，如下所示：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Wrapping something inside a function in general is called **eta abstraction**.
    It's an abstraction because it adds a layer of indirection instead of returning
    a value straight away. In other words, we first need to pass in an argument, which
    is substituted inside the body of the function, before the calculated result is
    returned.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，将某个东西包裹在函数内部被称为**eta 抽象**。它是一种抽象，因为它增加了一层间接性，而不是直接返回一个值。换句话说，我们首先需要传入一个参数，该参数在函数体内部被替换，然后才能返回计算结果。
- en: In some cases, an eta abstraction is necessary. For example, our preceding float
    converter needed a way to convert a `float` to a `float` in order to fit inside
    the type we set up. For that purpose, the eta abstraction `float => float` is
    perfect. However, eta abstraction is redundant when it wraps a single function
    call directly, for example, `int => float_of_int(int)` or `output => Js.log(output)`.
    This is because that single function call is already an equivalent eta abstraction;
    it already takes the same parameter and calculates the same result. Thanks to
    Reason functions being values, we can always pass them around directly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，eta 抽象是必要的。例如，我们之前的浮点转换器需要一个将 `float` 转换为 `float` 的方法，以便适应我们设置的类型。为此，eta
    抽象 `float => float` 是完美的。然而，当它直接包裹单个函数调用时，eta 抽象是多余的，例如 `int => float_of_int(int)`
    或 `output => Js.log(output)`。这是因为那个单个函数调用本身就是一个等价的 eta 抽象；它已经接受相同的参数并计算相同的结果。多亏了
    Reason 函数是值，我们总是可以直接传递它们。
- en: Often, when we're concentrating on writing the functions we need, it's easy
    to miss these redundancies. Luckily, we can remove redundant eta abstractions
    when simplifying the codebase at a later date, and without changing the meaning
    of the code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们专注于编写所需的函数时，很容易忽略这些冗余。幸运的是，我们可以在稍后简化代码库时移除冗余的 eta 抽象，而不会改变代码的含义。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Functions are an important part of Reason and are used a lot. This chapter
    focused on presenting their essential properties: referential transparency, purity,
    and totality. We also discussed the specific techniques involved with Reason functions,
    such as currying and partial application.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 Reason 的重要组成部分，并且被广泛使用。本章重点介绍了它们的本质属性：引用透明性、纯净性和完备性。我们还讨论了与 Reason 函数相关的具体技术，例如柯里化和部分应用。
- en: In the next chapter, we are going to look at more approaches and techniques
    supported in Reason that help in code reuse and programming generically.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Reason 支持的更多方法和技术，这些方法和技术有助于代码重用和通用编程。
