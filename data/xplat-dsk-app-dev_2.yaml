- en: Creating a File Explorer with NW.js – Enhancement and Delivery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NW.js创建文件资源管理器-增强和交付
- en: Well, we have a working version of File Explorer that can be used to navigate
    the filesystem and open files with the default associated program. Now we will
    extend it for additional file operations, such as deleting and copy pasting. These
    options will keep in a dynamically built context menu. We will also consider the
    capabilities of NW.js to transfer data between diverse applications using the
    system clipboard. We will make the application respond to command-line options.
    We will also provide support for multiple languages and locales. We will protect
    the sources by compiling them into native code. We will consider packaging and
    distribution. At the end, we will set up a simple release server and make the
    File Explorer auto-update.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们有一个可以用于浏览文件系统并使用默认关联程序打开文件的文件资源管理器的工作版本。现在我们将扩展它以进行其他文件操作，比如删除和复制粘贴。这些选项将保留在动态构建的上下文菜单中。我们还将考虑NW.js在不同应用程序之间使用系统剪贴板传输数据的能力。我们将使应用程序响应命令行选项。我们还将提供对多种语言和区域设置的支持。我们将通过将其编译成本机代码来保护源代码。我们将考虑打包和分发。最后，我们将建立一个简单的发布服务器，并使文件资源管理器自动更新。
- en: Internationalization and localization
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: '**Internationalization**, often abbreviated as **i18n**, implies a particular
    software design capable of adapting to the requirements of target local markets.
    In other words, if we want to distribute our application to markets other than
    the USA, we need to take care of translations, formatting of datetime, numbers,
    addresses, and such.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**国际化**，通常缩写为**i18n**，意味着一种特定的软件设计，能够适应目标本地市场的要求。换句话说，如果我们想将我们的应用程序分发到美国以外的市场，我们需要关注翻译、日期时间、数字、地址等的格式化。'
- en: Date format by country
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按国家格式化日期
- en: 'Internationalization is a cross-cutting concern. When you are changing the
    locale, it usually affects multiple modules. So, I suggest going with the observer
    pattern that we already examined while working on `DirService`:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化是一个横切关注点。当您更改区域设置时，通常会影响多个模块。因此，我建议使用我们在处理`DirService`时已经检查过的观察者模式：
- en: '`./js/Service/I18n.js`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/I18n.js`'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you see, we can change the `locale` property by setting a new value to the
    `locale` property. As soon as we call the `notify` method, all the subscribed
    modules immediately respond.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以通过为`locale`属性设置新值来更改`locale`属性。一旦我们调用`notify`方法，所有订阅的模块立即做出响应。
- en: 'However, `locale` is a public property and therefore we have no control over
    its access and mutation. We can fix it using overloading:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`locale`是一个公共属性，因此我们无法控制其访问和变异。我们可以使用重载来修复它：
- en: '`./js/Service/I18n.js`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/I18n.js`'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, if we access the `locale` property of the `I18n` instance, it gets delivered
    by the getter (`get locale`). When setting it a value, it goes through the setter
    (`set locale`). Thus, we can add extra functionalities, such as validation and
    logging on property access and mutation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们访问`I18n`实例的`locale`属性，它将通过getter（`get locale`）传递。当设置它的值时，它将通过setter（`set
    locale`）传递。因此，我们可以添加额外的功能，比如在属性访问和变异时进行验证和记录。
- en: Remember that we have a combo box for selecting the language in the HTML. Why
    not give it a view?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们在HTML中有一个用于选择语言的组合框。为什么不给它一个视图呢？
- en: '`./js/View/LangSelector.js`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/LangSelector.js`：'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we listen for change events on the combo box.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们监听组合框的更改事件。
- en: 'When the event occurs, we change the `locale` property with the passed-in `I18n`
    instance and call `notify` to inform the subscribers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，我们使用传入的`I18n`实例更改`locale`属性，并调用`notify`通知订阅者：
- en: '`./js/app.js`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Well, we can change the locale and trigger the event. What about consuming modules?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们可以更改区域设置并触发事件。那么消费模块呢？
- en: 'In the `FileList` view, we have the `formatTime` static method that formats
    the passed in `timeString` for printing. We can make it formatted in accordance
    with the currently chosen `locale`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FileList`视图中，我们有`formatTime`静态方法，用于格式化传递的`timeString`以进行打印。我们可以使其根据当前选择的`locale`进行格式化：
- en: '`./js/View/FileList.js`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/FileList.js`：'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the constructor, we subscribe to the `I18n` update event and update the
    file list every time the locale changes. The `formatTime` static method converts
    passed the string into a `Date` object and uses the `Date.prototype.toLocaleString()`
    method to format the datetime according to a given locale. This method belongs
    to the so called **ECMAScript Internationalization API** ([http://norbertlindenberg.com/2012/12/ecmascript-internationalization-
    api/index.html](http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html)).
    This API describes methods of built-in objects--`String`, `Date`, and `Number`--designed
    to format and compare localized data. However, what it really does is to format
    a `Date` instance with `toLocaleString` for the English (United States) locale
    (`en-US`), and it returns the date, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们订阅`I18n`更新事件，并在区域设置更改时更新文件列表。`formatTime`静态方法将传递的字符串转换为`Date`对象，并使用`Date.prototype.toLocaleString()`方法根据给定的区域设置格式化日期时间。这个方法属于所谓的**ECMAScript国际化API**（[http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html](http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html)）。这个API描述了内置对象--`String`、`Date`和`Number`--的方法，旨在格式化和比较本地化数据。然而，它真正做的是使用`toLocaleString`为英语（美国）区域设置（`en-US`）格式化`Date`实例，并返回日期，如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, if we feed German locale (`de-DE`) to the method, we get quite a different
    result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将德国区域设置（`de-DE`）传递给该方法，我们会得到完全不同的结果：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To put it into action, we set an identifier to the combo box. The `./index.html`
    file contains the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了付诸实践，我们给组合框设置了一个标识符。`./index.html`文件包含以下代码：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, we have to create an instance of the `I18n` service and pass it
    in `LangSelectorView` and `FileListView`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须创建一个`I18n`服务的实例，并将其传递给`LangSelectorView`和`FileListView`：
- en: '`./js/app.js`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we shall start the application. Yeah! As we change the language in the
    combo box, the file modification dates are adjusted accordingly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将启动应用程序。是的！当我们在组合框中更改语言时，文件修改日期会相应调整：
- en: '![](img/97388f9b-0432-45bf-9777-dd650d980998.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97388f9b-0432-45bf-9777-dd650d980998.png)'
- en: Multilingual support
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言支持
- en: Localization dates and numbers is a good thing, but it will be more exciting
    to provide translation to multiple languages. We have a number of terms across
    the application, namely, the column titles of the file list and tooltips (via
    the `title` attribute) on windowing action buttons. What we need is a dictionary.
    Normally, it implies sets of token translation pairs mapped to language codes
    or locales. Thus, when you request from the translation service a term, it can
    correlate to a matching translation according to the currently used language/locale.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化日期和数字是一件好事，但为多种语言提供翻译将更加令人兴奋。我们的应用程序中有许多术语，即文件列表的列标题和窗口操作按钮上的工具提示（通过`title`属性）。我们需要的是一个字典。通常，它包含了映射到语言代码或区域设置的令牌翻译对的集合。因此，当您从翻译服务请求一个术语时，它可以与当前使用的语言/区域设置相匹配的翻译相关联。
- en: 'Here, I have suggested making the dictionary a static module that can be loaded
    with the required function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我建议将字典作为一个静态模块，可以通过所需的函数加载：
- en: '`./js/Data/dictionary.js`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Data/dictionary.js`'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, we have two locales with translations per term. We will inject the dictionary
    as a dependency into our `I18n` service:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两个翻译的术语。我们将字典作为依赖项注入到我们的`I18n`服务中：
- en: '`./js/Service/I18n.js`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/I18n.js`'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also added a new method, translate, that accepts two parameters: `token`
    and `default` translation. The first parameter can be one of the keys from the
    dictionary, such as `NAME`. The second one is guarding value for the case when
    the requested token does not yet exist in the dictionary. Thus, we still get a
    meaningful text, at least in English.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个新方法`translate`，它接受两个参数：`token`和`default`翻译。第一个参数可以是字典中的键之一，比如`NAME`。第二个参数是在字典中请求的token尚不存在时的默认值。因此，我们至少可以得到一个有意义的文本，至少是英文。
- en: 'Let''s look at how we can use this new method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个新方法：
- en: '`./js/View/FileList.js`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/FileList.js`'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We change the hardcoded column titles in the `FileList` view with calls for
    the `translate` method of the `I18n` instance, which means that every time the
    view updates, it receives the actual translations. We shall not forget about the
    `TitleBarActions` view where we have windowing action buttons:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`I18n`实例的`translate`方法来更改`FileList`视图中的硬编码列标题，这意味着每次视图更新时，它都会接收到实际的翻译。我们也不要忘记`TitleBarActions`视图，那里有窗口操作按钮：
- en: '`./js/View/TitleBarActions.js`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/TitleBarActions.js`'
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here we add the `translate` method, which updates button-title attributes with
    the actual translations. We subscribe for the `i18n` update event to call the
    method every time a user changes the `locale`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`translate`方法，它会使用实际的翻译更新按钮标题属性。我们订阅`i18n`更新事件，以便在用户更改`locale`时调用该方法：
- en: '![](img/08faa557-defe-45b5-be0d-1d505d9f6bd3.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08faa557-defe-45b5-be0d-1d505d9f6bd3.png)'
- en: Context menu
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文菜单
- en: 'Well, with our application, we can already navigate through the filesystem
    and open files, yet one might expect more of a File Explorer. We can add some
    file-related actions, such as delete and copy/paste. Usually, these tasks are
    available via the context menu, which gives us a good opportunity to examine how
    to make it with `NW.js`. With the environment integration API, we can create an
    instance of system menu ([http://docs.nwjs.io/en/latest/References/Menu/](http://docs.nwjs.io/en/latest/References/Menu/)).
    Then, we compose objects representing menu items and attach them to the menu instance
    ([http://docs.nwjs.io/en/latest/References/MenuItem/](http://docs.nwjs.io/en/latest/References/MenuItem/)).
    This `menu` can be shown in an arbitrary position:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，通过我们的应用程序，我们已经可以浏览文件系统并打开文件，但是人们可能希望文件资源管理器有更多功能。我们可以添加一些与文件相关的操作，比如删除和复制/粘贴。通常，这些任务可以通过上下文菜单来完成，这给了我们一个很好的机会来研究如何在`NW.js`中实现。通过环境集成API，我们可以创建系统菜单的实例（[http://docs.nwjs.io/en/latest/References/Menu/](http://docs.nwjs.io/en/latest/References/Menu/)）。然后，我们组合表示菜单项的对象，并将它们附加到菜单实例上（[http://docs.nwjs.io/en/latest/References/MenuItem/](http://docs.nwjs.io/en/latest/References/MenuItem/)）。这个`menu`可以在任意位置显示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Yet, our task is more specific. We have to display the menu on the right-click
    in the position of the cursor, that is, we achieve it by subscribing a handler
    to `contextmenu` DOM event:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的任务更具体。我们必须在鼠标右键单击时在光标位置显示菜单，为了实现这一点，我们通过订阅`contextmenu` DOM事件来实现：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, whenever we right-click within the application window, the menu shows
    up. It''s not exactly what we want, is it? We need it only when the cursor resides
    within a particular region, for instance, when it hovers a file name. This means
    that we have to test whether the target element matches our conditions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们在应用程序窗口内右键单击时，菜单就会显示出来。这并不完全是我们想要的，是吗？我们只需要在光标停留在特定区域时才显示菜单，例如当它悬停在文件名上时。这意味着我们必须测试目标元素是否符合我们的条件：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we ignore the event until the cursor hovers over any cell of the file
    table row, given that every row is a list item generated by the `FileList` view
    and therefore provided with a value for a data file attribute.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们忽略事件，直到光标悬停在文件表行的任何单元格上，因为每一行都是由`FileList`视图生成的列表项，并且为数据文件属性提供了一个值。
- en: 'This passage pretty much explains how to build a system menu and how to attach
    it to the file list. However, before starting on a module capable of creating
    a menu, we need a service to handle file operations:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段话基本上解释了如何构建系统菜单以及如何将其附加到文件列表上。然而，在开始创建一个能够创建菜单的模块之前，我们需要一个处理文件操作的服务：
- en: '`./js/Service/File.js`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/File.js`'
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What''s going on here? `FileService` receives an instance of `DirService` as
    a constructor argument. It uses the instance to obtain the full path to a file
    by name (`this.dir.getFile( file )`). It also exploits the `notify` method of
    the instance to request all the views subscribed to `DirService` to update. The
    `showInFolder` method calls the corresponding method of `nw.Shell` to show the
    file in the parent folder with the system file manager. As you can recon, the
    `remove` method deletes the file. As for copy/paste, we do the following trick.
    When the user clicks on copy, we store the target file path in the `copiedFile`
    property. So, when the user clicks on paste the next time, we can use it to copy
    that file to the supposedly changed current location. The `open` method evidently
    opens the file with the default associated program. That is what we do in the
    `FileList` view directly. Actually, this action belongs to `FileService`. So,
    we adjust the view to use the service:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？`FileService`接收`DirService`的实例作为构造函数参数。它使用该实例通过名称获取文件的完整路径（`this.dir.getFile(file)`）。它还利用实例的`notify`方法请求所有订阅`DirService`的视图更新。`showInFolder`方法调用`nw.Shell`的相应方法，在系统文件管理器中显示文件的父文件夹。正如你所料，`remove`方法删除文件。至于复制/粘贴，我们做了以下技巧。当用户点击复制时，我们将目标文件路径存储在`copiedFile`属性中。因此，当用户下次点击粘贴时，我们可以使用它将该文件复制到可能已更改的当前位置。`open`方法显然使用默认关联程序打开文件。这就是我们在`FileList`视图中直接做的。实际上，这个操作属于`FileService`。因此，我们调整视图以使用该服务：
- en: '`./js/View/FileList.js`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/FileList.js`'
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we have a module to handle the context menu for a selected file. The module
    will subscribe for the `contextmenu` DOM event and build a menu when the user
    right-clicks on a file. This menu will contain Show Item in the Folder, Copy,
    Paste, and Delete. Copy and Paste are separated from other items with delimiters,
    and Paste will be disabled until we store a file with Copy:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个模块来处理所选文件的上下文菜单。该模块将订阅`contextmenu`DOM事件，并在用户右键单击文件时构建菜单。此菜单将包含在文件夹中显示项目、复制、粘贴和删除。复制和粘贴与其他项目分隔开，并且在我们存储了复制文件之前，粘贴将被禁用：
- en: '`./js/View/ContextMenu.js`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/ContextMenu.js`'
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, in the `ConextMenuView` constructor, we receive instances of `FileService`
    and `I18nService`. During the construction, we also call the `attach` method,
    which subscribes for the `contextmenu` DOM event, creates the menu, and shows
    it in the position of the mouse cursor. The event gets ignored unless the cursor
    hovers over a file or resides in the empty area of the file list component. When
    the user right-clicks on the file list, the menu still appears, but with all items
    disabled except Paste (in case a file was copied before). Method render to create
    an instance of the menu and populates it with `nw.MenuItems` created by the `getItems`
    method. The method creates an array representing menu items. Elements of the array
    are object literals. The `label` property accepts translation for item captions.
    The `enabled` property defines the state of an item depending on our cases (whether
    we hold the copied file or not). Finally, the `click` property expects the handler
    for the click event.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`ConextMenuView`构造函数中，我们接收`FileService`和`I18nService`的实例。在构造过程中，我们还调用`attach`方法，该方法订阅`contextmenu`DOM事件，创建菜单，并在鼠标光标的位置显示它。除非光标悬停在文件上或停留在文件列表组件的空白区域中，否则事件将被忽略。当用户右键单击文件列表时，菜单仍然会出现，但除了粘贴（如果之前复制了文件）之外，所有项目都会被禁用。`render`方法创建菜单的实例，并使用`getItems`方法创建的`nw.MenuItems`填充它。该方法创建表示菜单项的数组。数组的元素是对象文字。`label`属性接受项目标题的翻译。`enabled`属性根据我们的情况定义项目的状态（我们是否持有复制的文件）。最后，`click`属性期望点击事件的处理程序。
- en: 'Now we need to enable our new components in the main module:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在主模块中启用我们的新组件：
- en: '`./js/app.js`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s run the application, right-click on a file, and voila! We have
    the context menu and new file actions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行应用程序，在文件上右键单击，哇！我们有上下文菜单和新文件操作：
- en: '![](img/8d5747ae-172d-4c7f-9b2c-7d0ad5c95d3d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d5747ae-172d-4c7f-9b2c-7d0ad5c95d3d.png)'
- en: System clipboard
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统剪贴板
- en: Usually, the copy/paste functionality involves system clipboard. `NW.js` provides
    an API to control it ([http://docs.nwjs.io/en/latest/References/Clipboard/](http://docs.nwjs.io/en/latest/References/Clipboard/)).
    Unfortunately, it's quite limited; we cannot transfer an arbitrary file between
    applications, which you may expect of a file manager. Yet, some things are still
    available to us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，复制/粘贴功能涉及系统剪贴板。`NW.js`提供了一个API来控制它（[http://docs.nwjs.io/en/latest/References/Clipboard/](http://docs.nwjs.io/en/latest/References/Clipboard/)）。不幸的是，它相当有限；我们无法在应用程序之间传输任意文件，这可能是您对文件管理器的期望。然而，对我们来说仍然有一些事情是可用的。
- en: Transferring text
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输文本
- en: 'In order to examine text transferring with the clipboard, we modify the method
    copy of `FileService`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查使用剪贴板传输文本，我们修改了`FileService`的`copy`方法：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What does it do? As soon as we obtain the file full path, we create an instance
    of `nw.Clipboard` and save the file path there as text. So now, after copying
    a file within the File Explorer, we can switch to an external program (for example,
    a text editor) and paste the copied path from the clipboard:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它是做什么的？一旦我们获得文件的完整路径，我们创建一个`nw.Clipboard`的实例，并将文件路径保存为文本。因此，现在在文件资源管理器中复制文件后，我们可以切换到外部程序（例如文本编辑器）并从剪贴板中粘贴复制的路径：
- en: '![](img/d76eb224-6217-4723-af99-7e6005321ec7.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d76eb224-6217-4723-af99-7e6005321ec7.png)'
- en: Transferring graphics
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输图形
- en: 'It doesn''t look very handy, does it? It would be more interesting if we could
    copy/paste a file. Unfortunately, `NW.js` doesn''t give us many options when it
    comes to file exchange. However, we can transfer PNG and JPEG images between the
    `NW.js` application and external programs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不太方便，是吗？如果我们能复制/粘贴一个文件会更有趣。不幸的是，`NW.js`在文件交换方面并没有给我们太多选择。然而，我们可以在`NW.js`应用程序和外部程序之间传输PNG和JPEG图像：
- en: '`./js/Service/File.js`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/File.js`'
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We extended our `FileService` with the `copyImage` private method. It reads
    a given file, converts its contents in Base64 and passes the resulting code in
    a clipboard instance. In addition, it creates HTML with an image tag with the
    Base64-encoded image in the data **Uniform Resource Identifier** (**URI**). Now,
    after copying an image (PNG or JPEG) in File Explorer, we can paste it in an external
    program, such as the graphical editor or text processor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`copyImage`私有方法扩展了我们的`FileService`。它读取给定的文件，将其内容转换为Base64，并将结果代码传递给剪贴板实例。此外，它创建了一个包含Base64编码图像的图像标签的HTML，其中包含数据**统一资源标识符**（**URI**）。现在，在文件资源管理器中复制图像（PNG或JPEG）后，我们可以将其粘贴到外部程序中，例如图形编辑器或文本处理器。
- en: Receiving text and graphics
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收文本和图形
- en: 'We''ve learned how to pass text and graphics from our `NW.js` application to
    external programs, but how can we receive data from outside? As you can guess,
    it is accessible through the `get` method of `nw.Clipboard`. Text can be retrieved
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将文本和图形从我们的`NW.js`应用程序传递到外部程序，但是我们如何从外部接收数据呢？正如您可以猜到的那样，它可以通过`nw.Clipboard`的`get`方法访问。文本可以按如下方式检索：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the graphic is put on the clipboard, we can get it with NW.js only as
    Base64-encoded content or as HTML. To see it in practice, we add a few methods
    to `FileService`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当图形放在剪贴板上时，我们只能在NW.js中获取Base64编码的内容或HTML。为了看到它的实际效果，我们向`FileService`添加了一些方法：
- en: '`./js/Service/File.js`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/Service/File.js`'
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `hasImageInClipboard` method checks whether the clipboard keeps any graphics.
    The `pasteFromClipboard` method takes graphical content from the clipboard as
    a Base64-encoded PNG; it converts the content into binary code, writes it into
    a file, and requests `DirService` subscribers to update it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasImageInClipboard`方法检查剪贴板是否保留任何图形。`pasteFromClipboard`方法将剪贴板中的图形内容作为Base64编码的PNG获取；它将内容转换为二进制代码，将其写入文件，并请求`DirService`订阅者更新它。'
- en: 'To make use of these methods, we need to edit the `ContextMenu` view:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些方法，我们需要编辑`ContextMenu`视图：
- en: '`./js/View/ContextMenu.js`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/ContextMenu.js`'
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We add a new item, `Paste image from clipboard`, to the menu, which is enabled
    only when there are some graphics in the clipboard.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向菜单添加一个新项目`从剪贴板粘贴图像`，仅当剪贴板中有一些图形时才启用。
- en: Menu in the system tray
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统托盘中的菜单
- en: All three platforms available for our application have a so-called system notification
    area, which is also known as the system tray. That's a part of the user interface
    (in the bottom-right corner on Windows and top-right corner on other platforms)
    where you can find the application icon even when it's not present on the desktop.
    Using the `NW.js` API ([http://docs.nwjs.io/en/latest/References/Tray/](http://docs.nwjs.io/en/latest/References/Tray/)),
    we can provide our application with an icon and drop-down menu in the tray, but
    we do not have any icon yet. So, I have created the `icon.png` image with the
    text `Fe` and saved it in the application root in the size of 32x32px. It is supported
    on Linux, Windows, and macOS. However, in Linux, we can go with a better resolution,
    so I have placed the 48x48px version next to it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可用的三个平台都有所谓的系统通知区域，也称为系统托盘。这是用户界面的一部分（在Windows的右下角和其他平台的右上角），即使在桌面上没有应用程序图标，也可以在其中找到应用程序图标。使用`NW.js`
    API（[http://docs.nwjs.io/en/latest/References/Tray/](http://docs.nwjs.io/en/latest/References/Tray/)），我们可以为我们的应用程序提供一个图标和托盘中的下拉菜单，但我们还没有任何图标。因此，我已经创建了带有文本`Fe`的`icon.png`图像，并将其保存在大小为32x32px的应用程序根目录中。它在Linux，Windows和macOS上都受支持。但是，在Linux中，我们可以使用更高的分辨率，因此我将48x48px版本放在了旁边。
- en: 'Our application in the tray will be represented by `TrayService`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在托盘中将由`TrayService`表示：
- en: '`./js/View/Tray.js`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/Tray.js`'
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What does it do? The class takes the tray's title as a constructor parameter
    and calls the `removeOnExit` and render methods during instantiation. The first
    one subscribes for the window's `close` event and ensures that the tray is removed
    when we close the application. Method render creates the `nw.Tray` instance. With
    the constructor argument, we pass the configuration object with the title, which
    is a relative path to the icon. We assign it with `icon- 48x48.png` icon for Linux
    and `icon-32x32.png` for other platforms. By default, macOS tries adapting the
    image to the menu theme, which requires an icon to consist of clear colors on
    a transparent background. If your icon doesn't fit these restrictions, you would
    rather add it into configuration object property `iconsAreTemplates`, which is
    set as `false`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它是做什么的？该类将托盘的标题作为构造函数参数，并在实例化期间调用`removeOnExit`和render方法。第一个订阅窗口的`close`事件，并确保在关闭应用程序时删除托盘。方法render创建`nw.Tray`实例。通过构造函数参数，我们传递了包含标题的配置对象，该标题是图标的相对路径。我们为Linux分配了`icon-48x48.png`图标，为其他平台分配了`icon-32x32.png`图标。默认情况下，macOS尝试将图像调整为菜单主题，这需要图标由透明背景上的清晰颜色组成。如果您的图标不符合这些限制，您最好将其添加到配置对象属性`iconsAreTemplates`中，该属性设置为`false`。
- en: When launching our File Explorer in Ubuntu 16.x, it doesn't appear in the system
    tray due to the whitelisting policy. You can fix this by running `sudo apt-get
    install libappindicator1` in the Terminal.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu 16.x中启动我们的文件资源管理器时，由于白名单策略，它不会出现在系统托盘中。您可以通过在终端中运行`sudo apt-get install
    libappindicator1`来解决这个问题。
- en: '`nw.Tray` accepts the `nw.Menu` instance. So, we populate the menu the same
    way as we did for the context menu. Now we just initialize the `Tray` view in
    the main module and run the application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`nw.Tray`接受`nw.Menu`实例。因此，我们以与上下文菜单相同的方式填充菜单。现在我们只需在主模块中初始化`Tray`视图并运行应用程序：'
- en: '`./js/app.js`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we run the application now we can see the app icon and the menu in the system
    tray:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，我们可以在系统托盘中看到应用程序图标和菜单：
- en: '![](img/f193457b-315c-42e0-8b29-adbed34fdbef.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f193457b-315c-42e0-8b29-adbed34fdbef.png)'
- en: Yes, the only menu item exit looks somehow lonely.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，唯一的菜单项退出看起来有点孤单。
- en: 'Let''s extend the `Tray` view:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展`Tray`视图：
- en: '`./js/View/Tray.js`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/Tray.js`'
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, the `render` method receives a Boolean as an argument defining whether
    the application window is in the initial mode; that flag gets passed to the new
    `getItems` method that produces an array of menu items meta. If the flag is true,
    all the menu items are enabled, except restore. What makes sense is to restore
    the switches window to the initial mode after minimizing or maximizing. Seemingly,
    when the flag is `false`, the `Minimize` and `Maximize` items are disabled, but
    how can we know the current mode of the window? While constructing, we subscribe
    to window events minimize, maximize, and restore. When an event happens, we call
    `render` with the corresponding flag. Since we can now change window mode from
    both the `TitleBarActions` and `Tray` views, the `toggle` method of `TitleBarActions`
    is not a reliable source of window mode anymore. Instead, we rather refactor the
    module to rely on window events like we did in the `Tray` view:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`render`方法接收一个布尔值作为参数，定义应用程序窗口是否处于初始模式；该标志传递给新的`getItems`方法，该方法生成菜单项元数据数组。如果标志为true，则所有菜单项都可用，除了还原。有意义的是在最小化或最大化后将窗口恢复到初始模式。显然，当标志为`false`时，`Minimize`和`Maximize`项将被禁用，但我们如何知道窗口的当前模式？在构造时，我们订阅窗口事件最小化、最大化和还原。当事件发生时，我们使用相应的标志调用`render`。由于我们现在可以从`TitleBarActions`和`Tray`视图中更改窗口模式，因此`TitleBarActions`的`toggle`方法不再是窗口模式的可靠来源。相反，我们更倾向于重构模块，依赖窗口事件，就像我们在`Tray`视图中所做的那样：
- en: '`./js/View/TitleBarActions.js`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/View/TitleBarActions.js`'
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time when we run the application we can find in the system tray application
    menu with windowing actions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们运行应用程序时，我们可以在系统托盘应用程序菜单中找到窗口操作：
- en: '![](img/18a14be2-3418-4b01-989c-90b4f25adabd.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18a14be2-3418-4b01-989c-90b4f25adabd.png)'
- en: Command-line options
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行选项
- en: Other file managers usually accept command-line options. For example, you can
    specify a folder when launching Windows Explorer. It also responds to various
    switches. Let's say that you can give it switch `/e`, and Explorer will open the
    folder in expanded mode.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文件管理器通常接受命令行选项。例如，您可以在启动Windows资源管理器时指定一个文件夹。它还响应各种开关。比如，您可以给它开关`/e`，资源管理器将以展开模式打开文件夹。
- en: '`NW.js` reveals command-line options as an array of strings in `nw.App.argv`.
    So, we can change the code of the `DirService` initialization in the main module:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`NW.js`将命令行选项显示为`nw.App.argv`中的字符串数组。因此，我们可以更改主模块中`DirService`初始化的代码：'
- en: '`./js/app.js`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`./js/app.js`'
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can open a specified folder in the File Explorer straight from the
    command line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接从命令行中打开指定的文件夹：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In UNIX-based systems, the tilde means user home directory. The equivalent
    in Windows will be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于UNIX的系统中，波浪线表示用户主目录。在Windows中的等效表示如下：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'What else can we do? Just for a showcase, I suggest implementing the `--minimize`
    and `--maximize` options that switch the application window mode on startup, respectively:
    `./js/app.js`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能做什么？仅作为展示，我建议实现`--minimize`和`--maximize`选项，分别在启动时切换应用程序窗口模式：`./js/app.js`
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It doesn't make any sense to parse `nw.App.argv` array manually when we can
    use an external module minimist ([https://www.npmjs.com/package/minimist](https://www.npmjs.com/package/minimist)).
    It exports a function that collects all the arguments that are not options or
    associated with options into the `_` (underscore) property. We expect the only
    argument of that type, which is startup directory. It also sets the `maximize`
    and `minimize` properties to true when they are provided on the command line.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们可以使用外部模块minimist（[https://www.npmjs.com/package/minimist](https://www.npmjs.com/package/minimist)）时，手动解析`nw.App.argv`数组就没有意义了。它导出一个函数，该函数将所有不是选项或与选项相关联的参数收集到`_`（下划线）属性中。我们期望该类型的唯一参数是启动目录。它还在命令行上提供`maximize`和`minimize`属性时将它们设置为true。
- en: 'One should note that NPM doesn''t delegate options to the running script, so
    we shall call the `NW.js` executable directly:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，NPM不会将选项委托给运行脚本，因此我们应该直接调用`NW.js`可执行文件：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: or
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Native look and feel
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本机外观和感觉
- en: 'Nowadays, one can find plenty of native desktop applications with semi-transparent
    background or with round corners. Can we achieve such fancy look with `NW.js`?
    Sure we can! First, we shall edit our application manifest file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，人们可以找到许多具有半透明背景或圆角的本机桌面应用程序。我们能否用`NW.js`实现这样的花哨外观？当然可以！首先，我们应该编辑我们的应用程序清单文件：
- en: '`./package.json`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`./package.json`'
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By setting the frame field to `false`, we instruct `NW.js` to not show the
    window frame, but its contents. Fortunately, we have already implemented custom
    windowing controls as the default ones will not be available anymore. With a transparent
    field, we remove the opacity of the application window. To see it in action, we
    edit the CSS definitions module:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将frame字段设置为`false`，我们指示`NW.js`不显示窗口框架，而是显示其内容。幸运的是，我们已经实现了自定义窗口控件，因为默认的窗口控件将不再可用。通过透明字段，我们去除了应用程序窗口的不透明度。要看它的实际效果，我们编辑CSS定义模块：
- en: '`./assets/css/Base/definitions.css`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Base/definitions.css`'
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With RGBA color function, we set the opacity of the title bar to 70% and other
    background colors to 90%. We also introduce a new variable, `--border-radius`,
    which we will use in the `titlebar` and `footer` components to make round corners
    on the top and in the bottom:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过RGBA颜色函数，我们将标题栏的不透明度设置为70%，其他背景颜色设置为90%。我们还引入了一个新变量`--border-radius`，我们将在`titlebar`和`footer`组件中使用它来使顶部和底部的角变圆：
- en: '`./assets/css/Component/titlebar.css`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/titlebar.css`'
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`./assets/css/Component/footer.css`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`./assets/css/Component/footer.css`'
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now we can launch the application and enjoy our renewed fancy look.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动应用程序并享受我们更新的花哨外观。
- en: On Linux, we need to use the `nw . --enable-transparent-visuals --disable-gpu`
    command-line option to trigger transparency.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我们需要使用`nw . --enable-transparent-visuals --disable-gpu`命令行选项来触发透明度。
- en: Source code protection
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码保护
- en: 'Unlike in native applications, our source code isn''t compiled and is therefore
    open to everybody. If you have any commercial use of this fact in mind, it is
    unlikely to suit you. The least you can do is to obfuscate the source code, for
    example, using Jscrambler ([https://jscrambler.com/en/](https://jscrambler.com/en/)).
    On the other hand, we can compile our sources into native code and load it with
    `NW.js` instead of JavaScript. For that, we need to separate JavaScript from the
    application bundle. Let''s create the `app` folder and move everything except
    `js` there. The `js` folder will be moved into a newly created directory, `src`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与原生应用程序不同，我们的源代码没有编译，因此对所有人都是开放的。如果你考虑商业用途，这可能不适合你。你至少可以混淆源代码，例如使用Jscrambler（[https://jscrambler.com/en/](https://jscrambler.com/en/)）。另一方面，我们可以将我们的源代码编译成本地代码，并用`NW.js`加载它，而不是JavaScript。为此，我们需要将JavaScript与应用程序捆绑分离。让我们创建`app`文件夹，并将除了`js`之外的所有内容移动到那里。`js`文件夹将被移动到一个新创建的目录`src`中：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our JavaScript modules are now out of the project scope, and we cannot reach
    them when required. However, these are still Node.js modules ([https://nodejs.org/api/modules.html](https://nodejs.org/api/modules.html))
    that confront CommonJS module definition standards. Therefore, we can merge them,
    with a bundler tool, into a single file that we later compile into native code.
    I suggest going with Webpack ([https://webpack.github.io/](https://webpack.github.io/)),
    the seemingly most popular bundler nowadays. So, we place it in the root directory
    webpack configuration file with the following contents:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript模块现在已经超出了项目范围，当需要时我们无法访问它们。然而，这些仍然是Node.js模块（[https://nodejs.org/api/modules.html](https://nodejs.org/api/modules.html)），符合CommonJS模块定义标准。因此，我们可以使用捆绑工具将它们合并成一个单一文件，然后将其编译成本地代码。我建议使用Webpack（[https://webpack.github.io/](https://webpack.github.io/)），这似乎是目前最流行的捆绑工具。因此，我们将其放在根目录webpack配置文件中，内容如下：
- en: '`webpack.config.js`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.config.js`'
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With this, we instruct Webpack to transpile all the required modules, starting
    with `src/js/app.js`, into a single `src/build/bundle.js` file. However, Webpack,
    unlike `NW.js`, expects the required dependencies relative to the hosting file
    (not project root); so, we have to remove `js/` from the file paths in the main
    module:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们指示Webpack将所有必需的模块转译，从`src/js/app.js`开始，转译成一个单一的`src/build/bundle.js`文件。然而，与`NW.js`不同，Webpack期望从托管文件（而不是项目根目录）相对于所需的依赖项；因此，我们必须从主模块的文件路径中删除`js/`：
- en: '`./src/js/app.js`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`./src/js/app.js`'
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For both transpiling CommonJS modules and compiling the derived file in the
    native code, we need a few tasks in the script field of the manifest:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了转换CommonJS模块并将派生文件编译成本地代码，我们需要在清单的脚本字段中添加一些任务：
- en: '`package.json`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With the first task, we make webpack build our JavaScript sources into a single
    file. The second one compiles it using the `NW.js` compiler. The last one does
    both at once.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个任务中，我们让webpack将我们的JavaScript源代码构建成一个单一文件。第二个任务使用`NW.js`编译器对其进行编译。最后一个任务同时完成了这两个任务。
- en: 'In the HTML file, we replace the code calling the main module with the following
    lines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文件中，我们用以下代码替换调用主模块的代码：
- en: '`app/index.html`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/index.html`'
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now we can run the application and observe that the implemented functionality
    still confronts our requirements.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行应用程序，并观察实现的功能是否仍然符合我们的要求。
- en: Packaging
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包
- en: Well, we have completed our application and that is the time to think about
    distribution. As you understand, asking our users to install `Node.js` and type
    `npm start` from the command line will not be friendly. Users will expect a package
    that can be started as simply as any other software. So, we have to bundle our
    application along with `NW.js` for every target platform. Here, `nwjs-builder`
    comes in handy ([https://github.com/evshiron/nwjs-builder](https://github.com/evshiron/nwjs-builder)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经完成了我们的应用程序，现在是时候考虑分发了。正如你所理解的，要求我们的用户安装`Node.js`并从命令行输入`npm start`并不友好。用户会期望一个可以像其他软件一样简单启动的软件包。因此，我们必须将我们的应用程序与`NW.js`捆绑在每个目标平台上。在这里，`nwjs-builder`派上了用场（[https://github.com/evshiron/nwjs-builder](https://github.com/evshiron/nwjs-builder)）。
- en: 'So, we install the `npm i -D nwjs-builder` tool and add a task to the manifest:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们安装了`npm i -D nwjs-builder`工具，并在清单中添加了一个任务：
- en: '`./package.json`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`./package.json`'
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we specified three target platforms (`-p linux64, win32,osx64`) at once
    and thus, after running this task (`npm run package`), we get platform-specific
    subfolders in the `dist` directory, containing other executable things named after
    our application:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们一次指定了三个目标平台（`-p linux64, win32,osx64`），因此，在运行此任务（`npm run package`）后，我们在`dist`目录中得到特定于平台的子文件夹，其中包含以我们应用程序命名的其他可执行文件：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`Nwjs-builder` accepts diverse options. For example, we can request it to output
    the packages as ZIP archives:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nwjs-builder`接受各种选项。例如，我们可以要求它将软件包输出为ZIP存档：'
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Alternatively, we can make it run the package after the build process with
    the given options:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在构建过程后运行包并使用给定的选项：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Autoupdate
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动更新
- en: In the era of continuous deployment, new releases are issued pretty often. As
    developers, we have to ensure that users receive the updates transparently, without
    going through the download/install routine. With the traditional web application,
    it's taken for granted. Users hit the page and the latest version gets loaded.
    With desktop applications, we need to deliver the update. Unfortunately, `NW.js`
    doesn't provide any built-in facilities to handle autoupdates, but we can trick
    it; let's see how.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续部署的时代，新版本发布得相当频繁。作为开发人员，我们必须确保用户可以透明地接收更新，而不必经过下载/安装的流程。对于传统的Web应用程序，这是理所当然的。用户访问页面，最新版本就会加载。对于桌面应用程序，我们需要传递更新。不幸的是，`NW.js`并没有提供任何内置设施来处理自动更新，但我们可以欺骗它；让我们看看如何做。
- en: 'First of all, we need a simple release server. Let''s give it a folder (for
    example, `server`) and create the manifest file there:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个简单的发布服务器。让我们给它一个文件夹（例如`server`）并在那里创建清单文件：
- en: '`./server/package.json`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`./server/package.json`'
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This file contains a `packages` custom field, describing the available application
    releases. This simplified implementation accepts only the latest release per platform.
    The release version must be set in the manifest version field. Every entry of
    package objects contains a downloadable URL and the package size in bytes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含一个`packages`自定义字段，描述可用的应用程序发布。这个简化的实现只接受每个平台的最新发布。发布版本必须在清单版本字段中设置。每个包对象的条目包含可下载的URL和包大小（以字节为单位）。
- en: 'To serve HTTP requests for this manifest and packages in the `release` folder,
    we will use the HTTP server ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)).
    So, we install the package and start the HTTP server:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为`release`文件夹中的清单和包提供HTTP请求服务，我们将使用HTTP服务器（[https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server)）。因此，我们安装该软件包并启动HTTP服务器：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we will jump back to our client and modify the application manifest file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回到我们的客户端并修改应用程序清单文件：
- en: '`./client/package.json`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`./client/package.json`'
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we add a custom field, `manifestUrl`, with a URL to the server manifest.
    After we start the server, the manifest will be available at `http://127.0.0.1:8080/package.json`.
    We instruct `nwjs-builder` to pack application bundles with ZIP and place them
    in `../server/release`. Eventually, we set the `postversion` hook; so, when bumping
    the package version (for example, `npm version patch`) NPM will automatically
    build and send a release package to the server, every time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个自定义字段`manifestUrl`，其中包含指向服务器清单的URL。启动服务器后，清单将在`http://127.0.0.1:8080/package.json`上可用。我们指示`nwjs-builder`使用ZIP打包应用程序包并将它们放在`../server/release`中。最终，我们设置了`postversion`钩子；因此，当提升软件包版本（例如`npm
    version patch`）时，NPM将自动构建并发送一个发布包到服务器，每次都是如此。
- en: 'From the client, we can read the server manifest and compare it with the application.
    If the server has a newer version, we download the release package matching our
    platform and unpack it in a temporary directory. What we need to do now is just
    replace the running application version with the downloaded one. However, the
    folder is locked until the app is running, so we close the running application
    and start the downloaded one (as a detached process). It backs up the old version
    and copies the downloaded package to the initial location. All that can be easily
    done using `nw- autoupdater` (`https://github.com/dsheiko/nw-autoupdater`), so
    we install the `npm i -D nw-autoupdater` package and create a new service to handle
    the autoupdate flow:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端，我们可以读取服务器清单并将其与应用程序进行比较。如果服务器有更新版本，我们会下载与我们平台匹配的发布包，并将其解压缩到临时目录。现在我们需要做的就是用下载的版本替换正在运行的应用程序版本。但是，该文件夹在应用程序运行时被锁定，因此我们关闭正在运行的应用程序并启动下载的应用程序（作为一个独立的进程）。它备份旧版本并将下载的软件包复制到初始位置。所有这些都可以很容易地使用`nw-autoupdater`（`https://github.com/dsheiko/nw-autoupdater`）完成，因此我们安装`npm
    i -D nw-autoupdater`软件包并创建一个新的服务来处理自动更新流程：
- en: '`./client/js/Service/Autoupdate.js`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`./client/js/Service/Autoupdate.js`'
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we applied the async/await syntax of ES2016\. By prefixing the function
    with `async`, we state that it is asynchronous. After that, we can use await in
    front of any Promise (`https://mzl.la/1jLTOHB`) to receive its resolved value.
    If Promise rejects it, the exception will be caught in the try/catch statement.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应用了ES2016的async/await语法。通过在函数前加上`async`，我们声明它是异步的。之后，我们可以在任何Promise（`https://mzl.la/1jLTOHB`）前使用await来接收其解析值。如果Promise被拒绝，异常将在try/catch语句中捕获。
- en: What exactly does the code do? As we agreed, it compares local and remote manifest
    versions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码到底是做什么的？正如我们商定的那样，它比较本地和远程清单版本。
- en: If release server has the newer version, it informs the user using the JavaScript
    confirm function. If the user is positive on upgrading, it downloads the latest
    release and unpacks it. While downloading and unpacking, the updater object emits
    the corresponding messages; so, we can subscribe and represent the progress. When
    ready, the service restarts the application for swapping; so, now it replaces
    the outdated version with the downloaded one and restarts again. On the way, the
    service reports to the user by writing in the passed-in HTML element (el). By
    the design it expects the element representing the path container in the title
    bar.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发布服务器有更新版本，它会使用JavaScript的confirm函数通知用户。如果用户同意升级，它会下载最新版本并解压缩。在下载和解压缩过程中，更新程序对象会发出相应的消息；因此，我们可以订阅并表示进度。准备就绪后，服务将重新启动应用程序进行交换；因此，现在它用下载的版本替换了过时的版本并再次重新启动。在此过程中，服务通过在传入的HTML元素（el）中写入来向用户报告。按照设计，它期望元素代表标题栏中的路径容器。
- en: 'So, we can now enable the service in the main module:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以在主模块中启用服务：
- en: '`./client/js/app.js`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`./client/js/app.js`'
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Well, how do we test it? We jump to client folder and build a distribution
    package:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们如何测试它？我们跳转到客户端文件夹并构建一个分发包：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Supposedly, it lands in server/releases. We unpack to the arbitrary location,
    for example, `~/sandbox/`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 据说它会落在服务器/releases。我们解压到任意位置，例如`~/sandbox/`：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we will find the executable (for Linux, it will be `file-explorer`) and
    run it. The File Explorer will work as usual because the release server doesn''t
    have a newer version, so we go back to the client folder and create one:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将找到可执行文件（对于Linux，它将是`file-explorer`）并运行它。文件资源管理器将像往常一样工作，因为发布服务器没有更新版本，所以我们回到客户端文件夹并创建一个：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now we switch to the server folder and edit the version of the manifest to match
    the just-generated one (1.0.1).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们切换到服务器文件夹并编辑清单的版本以匹配刚生成的版本（1.0.1）。
- en: 'Then, we restart the bundled app (for example, `~/sandbox/file-explorer`) and
    observe the prompt:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重新启动捆绑的应用程序（例如，`~/sandbox/file-explorer`）并观察提示：
- en: '![](img/4a1a69d8-fab1-4d91-a411-0956ebc63fe4.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a1a69d8-fab1-4d91-a411-0956ebc63fe4.png)'
- en: 'After clicking on OK, we see the progress on downloading and installing in
    the title bar:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”后，我们可以在标题栏中看到下载和安装的进度：
- en: '![](img/c530a27a-0b49-47aa-9f6b-7b431e4749fa.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c530a27a-0b49-47aa-9f6b-7b431e4749fa.png)'
- en: Then, the application restarts and reports swapping. When done, it restarts
    again, now updated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用程序重新启动并报告交换。完成后，它再次重新启动，现在已更新。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the beginning of this chapter, our File Explorer could only navigate the
    filesystem and open files. We extended it to show a file in the folder, and to
    copy/paste and delete files. We exploited the `NW.js` API to provide the files
    with the dynamically-built context menu. We learned to exchange text and images
    between applications using system clipboard. We made our File Explorer support
    diverse command-line options. We provided support for internalization and localization,
    and examined the protection of the sources through compilation in the native code.
    We went through the packaging process and prepared for distribution. Finally,
    we set up a release server and extended the File Explorer with a service for autoupdating.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们的文件资源管理器只能浏览文件系统并打开文件。我们扩展了它以显示文件夹中的文件，并复制/粘贴和删除文件。我们利用了`NW.js` API来为文件提供动态构建的上下文菜单。我们学会了在应用程序之间使用系统剪贴板交换文本和图像。我们使我们的文件资源管理器支持各种命令行选项。我们提供了国际化和本地化的支持，并通过在本机代码中进行编译来保护源代码。我们经历了打包过程并为分发做好了准备。最后，我们建立了一个发布服务器，并为文件资源管理器扩展了一个自动更新的服务。
