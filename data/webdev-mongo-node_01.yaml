- en: Welcome to JavaScript in the Full Stack
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到全栈JavaScript
- en: 'What was once only considered a language to add enhancements and widgets to
    a web page has since evolved into its own fully-fledged ecosystem. As of the survey
    of year 2017 ( [https://insights.stackoverflow.com/survey/2017](https://insights.stackoverflow.com/survey/2017)
    ), it stands as the most popular language in terms of usage on stack overflow
    with around a million questions tagged on it. There are tons of frameworks and
    environments to make it possible to run JavaScript almost anywhere. I believe
    Atwood''s law says it best:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经只被认为是为网页添加增强功能和小部件的语言，现在已经发展成了一个完整的生态系统。截至2017年的调查（[https://insights.stackoverflow.com/survey/2017](https://insights.stackoverflow.com/survey/2017)），它是stackoverflow上使用量最大的语言，有大约一百万个与之相关的问题标签。有大量的框架和环境可以让JavaScript几乎在任何地方运行。我相信阿特伍德定律说得最好：
- en: '"Any application that can be written in JavaScript will eventually be written
    in JavaScript!"'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “任何可以用JavaScript编写的应用程序最终都将用JavaScript编写！”
- en: 'While this quote dates back to 2007, it''s never been truer than today. Not
    only can you use JavaScript to develop a complete single-page application such
    as Gmail, but you will also see how we can use it to achieve the following projects
    in the coming chapters of the book:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这句话可以追溯到2007年，但它在今天仍然是真实的。你不仅可以使用JavaScript开发完整的单页应用程序，比如Gmail，还可以看到我们如何在本书的后续章节中使用它来实现以下项目：
- en: Completely power the backend using Node.js and Express.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全使用Node.js和Express.js来支持后端
- en: Persist data with a powerful document oriented database such as MongoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用诸如MongoDB之类的强大的文档导向数据库来持久化数据
- en: Write dynamic HTML pages using Handlebars.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Handlebars.js编写动态HTML页面
- en: Deploy your entire project to the cloud using services such as Heroku and **Amazon
    Web Services** (**AWS**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Heroku和Amazon Web Services（AWS）等服务将整个项目部署到云端
- en: With the introduction of Node.js, JavaScript has officially gone in a direction
    that was never even possible before. Now, you can use JavaScript on the server
    and you can also use it to develop full-scale, enterprise-level applications.
    When you combine this with the power of MongoDB and its JSON-powered data, you
    can work with JavaScript in every layer of your application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Node.js的引入，JavaScript正式进入了以前甚至不可能的方向。现在，你可以在服务器上使用JavaScript，也可以用它来开发完整的企业级应用程序。当你将这一点与MongoDB及其基于JSON的数据的强大功能结合起来时，你可以在应用程序的每一层中使用JavaScript。
- en: Let's quickly go through some basic concepts of Node.js and MongoDB, which will
    help you in following the rest of the chapters in this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一些Node.js和MongoDB的基本概念，这将有助于你理解本书后续章节的内容。
- en: A short introduction to Node.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js简介
- en: One of the most important things that people get confused about while getting
    introduced to Node.js is understanding what, exactly, it is. Is it a different
    language altogether, is it just a framework on top of it, or is it something else?
    Node.js is definitely not a new language, and it is not just a framework on JavaScript.
    It can be considered as a runtime environment for JavaScript built on top of Google's
    V8 engine. So, it provides us with a context where we can write JavaScript code
    on any platform where Node.js can be installed. Anywhere!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在初次接触Node.js时最容易混淆的一件事是，要理解它究竟是什么。它是一个完全不同的语言吗，它只是JavaScript的一个框架，还是其他什么东西？Node.js绝对不是一种新语言，它也不仅仅是JavaScript的一个框架。它可以被看作是建立在Google的V8引擎之上的JavaScript运行环境。因此，它为我们提供了一个上下文，我们可以在任何可以安装Node.js的平台上编写JavaScript代码。任何地方！
- en: Now, a bit about its history! Back in 2009, Ryan Dahl gave a presentation at
    JSConf that changed JavaScript forever. During his presentation, he introduced
    Node.js to the JavaScript community. He concluded it after a roughly 45-minute
    talk, receiving a standing ovation from the audience in the process. He was inspired
    to write Node.js after he saw a simple file upload progress bar on Flickr, the
    image-sharing site. Realizing that the site was going about the whole process
    the wrong way, he decided that there had to be a better solution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，稍微了解一下它的历史！2009年，Ryan Dahl在JSConf上做了一个演讲，彻底改变了JavaScript。在他的演讲中，他向JavaScript社区介绍了Node.js。在大约45分钟的演讲后，他得到了观众的起立鼓掌。他在Flickr上看到了一个简单的文件上传进度条后，受到启发，决定写Node.js。他意识到该网站正在以错误的方式处理整个过程，他决定必须有更好的解决方案。
- en: Now let's go through the features of Node.js, which make it unique from other
    server-side programming languages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速了解一下Node.js的特点，看看它与其他服务器端编程语言有何不同。
- en: The advantage that the V8 engine brings in
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: V8引擎带来的优势
- en: The V8 engine was developed by Google and was open sourced in 2008\. As we all
    know, JavaScript is an interpreted language and it will not be as efficient as
    a compiled language, as each line of code gets interpreted one by one while the
    code gets executed. The V8 engine brings in an efficient model, where the JavaScript
    code is first interpreted and then compiled into machine-level code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: V8引擎是由Google开发的，并于2008年开源。众所周知，JavaScript是一种解释性语言，它不像编译语言那样高效，因为代码的每一行在执行时都会被逐行解释。V8引擎带来了一个高效的模型，其中JavaScript代码首先被解释，然后编译成机器级代码。
- en: 'The new V8 5.9 provides a stable release that introduces **TurboFan** compiler
    which provides performance and mass optimization benefits. It also launches **Ignition**
    interpreter which is quiet efficient for all the small and big devices like servers
    or IOT devices etc that varies on memory spectrum. Due to such low memory footprint
    it delivers fast startup of an application. We can study benchmarks in following
    link : [https://goo.gl/B15xB2](https://goo.gl/B15xB2)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 新的V8 5.9发布了一个稳定版本，引入了TurboFan编译器，提供了性能和大规模优化的好处。它还推出了Ignition解释器，对于所有大小的设备如服务器或IOT设备等，它都非常高效，因为它的内存占用范围不同。由于内存占用低，它可以快速启动应用程序。我们可以在以下链接中研究基准测试：[https://goo.gl/B15xB2](https://goo.gl/B15xB2)
- en: With two powerful updates, the v8 team is also working on Orinoco, which is
    a garbage collector that works on mechanism of parallel and concurrent compacting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个强大的更新，v8团队还在开发Orinoco，这是一个基于并行和并发压缩机制的垃圾收集器。
- en: 'Such a high performance with promising results was the reason to push the node
    8(LTS) launch date from may 2018 to october 2018\. Currently we are using node
    8 with a non-LTS version. It provides clean replace for users using node v4.x.x
    and above with no broken library. The version 8 also has various inbuilt features
    like buffer improvements and inbuilt promisify methods etc. We can study them
    in following link : [https://goo.gl/kMySCS](https://goo.gl/kMySCS)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的高性能和有希望的结果是将node 8(LTS)的发布日期从2018年5月推迟到2018年10月的原因。目前我们正在使用非LTS版本的node 8。它为使用node
    v4.x.x及以上版本的用户提供了干净的替代，没有破损的库。版本8还具有各种内置功能，如缓冲区改进和内置的promisify方法等。我们可以在以下链接中学习它们：[https://goo.gl/kMySCS](https://goo.gl/kMySCS)
- en: Node.js is single-threaded!
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js是单线程的！
- en: 'With the advent of the web, the traditional JavaScript was intended to add
    simple functionality and minimal runtime in the browser. Thus, JavaScript was
    kept as a single-threaded scripting language. Now, just to get a brief idea regarding
    single-threaded model, let''s consider the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web的出现，传统的JavaScript旨在在浏览器中添加简单的功能和最小的运行时。因此，JavaScript被保持为单线程脚本语言。现在，为了对单线程模型有一个简要的了解，让我们考虑以下图表：
- en: '![](img/fac07705-b3fd-4128-88db-7c5cd27c1d22.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fac07705-b3fd-4128-88db-7c5cd27c1d22.jpg)'
- en: A single-threaded model creates a single Callstack in an execution context.
    In the preceding code, when the function `getData()` is invoked, the function
    is pushed in the stack for execution sequentially.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程模型在执行上下文中创建一个单一的调用栈。在前面的代码中，当函数`getData()`被调用时，该函数被推入堆栈以便按顺序执行。
- en: In the context of Node.js, JavaScript is the base scripting language, hence,
    Node.js is single-threaded. You might be asking, how does a single-threaded model
    help? Typical PHP, ASP.NET, Ruby, or Java-based servers follow a model where each
    client request results in the instantiation of a new thread or even a process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js的上下文中，JavaScript是基础脚本语言，因此Node.js是单线程的。您可能会问，单线程模型如何帮助？典型的PHP、ASP.NET、Ruby或基于Java的服务器遵循的模型是每个客户端请求都会导致实例化一个新的线程甚至一个进程。
- en: When it comes to Node.js, requests are run on the same thread with shared resources.
    A question that is often asked is, what will be the advantage of using such a
    model? To understand this, we should understand the problem that Node.js tries
    to resolve. It tries to do asynchronous processing on a single thread to provide
    more performance and scalability for applications that are supposed to handle
    too much web traffic. Imagine web applications that handle millions of concurrent
    requests; if the server makes a new thread for handling each request that comes
    in, it will consume a lot of resources and we will end up trying to add more and
    more servers to increase the scalability of the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到Node.js时，请求在同一个线程上运行，共享资源。一个经常被问到的问题是，使用这样的模型会有什么优势？要理解这一点，我们应该了解Node.js试图解决的问题。它试图在单个线程上进行异步处理，以提供更高的性能和可伸缩性，以处理太多的网络流量的应用程序。想象一下处理数百万并发请求的Web应用程序；如果服务器为每个进来的请求创建一个新的线程，它将消耗大量资源，我们最终将不得不添加更多的服务器来增加应用程序的可伸缩性。
- en: The single-threaded, asynchronous processing model has its advantage in the
    previous context, and you can process much more concurrent requests with fewer
    server-side resources. However, there is a downside to this approach; Node (by
    default) will not utilize the number of CPU cores available on the server it is
    running on, without using extra modules like `pm2`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程的异步处理模型在先前的上下文中有其优势，您可以使用更少的服务器端资源处理更多的并发请求。然而，这种方法也有其缺点；Node（默认情况下）不会利用服务器上可用的CPU核心数量，而不使用额外的模块，如`pm2`。
- en: The point that Node.js is single-threaded doesn't mean that it doesn't use threads
    internally. It is just that the developer and the execution context that the code
    has exposure to have no control over the threading model internally used by Node.js.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是单线程的这一点并不意味着它在内部不使用线程。只是开发人员和代码的执行上下文对Node.js内部使用的线程模型没有控制权。
- en: If you are new to the concept of threads and process, I would suggest you go
    through some preliminary articles about these topics. There are plenty of YouTube
    videos on the same topic as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对线程和进程的概念不熟悉，我建议您阅读一些关于这些主题的初步文章。还有很多YouTube视频也是关于同样的主题。
- en: 'The following reference could be used as a starting point:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参考资料可以作为一个起点：
- en: '[http://www.cs.ucsb.edu/~rich/class/cs170/notes/IntroThreads/](http://www.cs.ucsb.edu/~rich/class/cs170/notes/IntroThreads/)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.cs.ucsb.edu/~rich/class/cs170/notes/IntroThreads/](http://www.cs.ucsb.edu/~rich/class/cs170/notes/IntroThreads/)'
- en: Non-blocking asynchronous execution
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞异步执行
- en: One of the most powerful features of Node.js is that it is both event-driven
    and asynchronous. So, how does an asynchronous model work? Imagine you have a
    block of code and at some *n^(th)* line you have an operation that is time consuming.
    What happens to the lines that follow the *n^(th)* line while this code gets executed?
    In normal synchronous programming models, the lines that follow the *n^(th)* line
    will have to wait until the operation at that line completes. An asynchronous
    model handles this case differently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js最强大的特性之一是它既是事件驱动的，又是异步的。那么，异步模型是如何工作的呢？想象一下你有一段代码，在第n行有一个耗时的操作。当这段代码被执行时，后面的行会发生什么？在正常的同步编程模型中，后面的行将不得不等到该行的操作完成。异步模型会以不同的方式处理这种情况。
- en: 'Let us visualize this scenario with the help of the following code and diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码和图表来可视化这种情况：
- en: '![](img/5d3b673d-680b-4465-9fb5-f39e91ffc1a9.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d3b673d-680b-4465-9fb5-f39e91ffc1a9.jpg)'
- en: In the preceding case, the `setTimeout()` method is provided by JavaScript (Node.js)
    API. Hence, this method is recognized as synchronous and is executed in a different
    execution context. According to functionality to `setTimeout()` , it executes
    the callback function after a specified duration, in our case after three seconds.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，`setTimeout()`方法由JavaScript（Node.js）API提供。因此，这个方法被认为是同步的，并在不同的执行上下文中执行。根据`setTimeout()`的功能，它在指定的持续时间后执行回调函数，在我们的例子中是三秒后。
- en: Further, the current execution is never blocked for a process to complete. When
    Node.js API determines that the completion of an event has been fired, it will
    execute your callback function at that moment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当前的执行永远不会被阻塞以完成一个进程。当Node.js API确定事件的完成已被触发时，它将立即执行你的回调函数。
- en: 'In a typical synchronous programming language, executing the preceding code
    will yield the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的同步编程语言中，执行前面的代码将产生以下输出：
- en: '![](img/52bd7604-513e-4e81-9d83-8619af93c648.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52bd7604-513e-4e81-9d83-8619af93c648.jpg)'
- en: If you are still interested in learning more about asynchronous models and the
    callback concept in JavaScript, **Mozilla Developer Network** (**MDN**) has many
    articles that explain these concepts in detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对学习JavaScript中的异步模型和回调概念感兴趣，**Mozilla开发者网络**（**MDN**）有许多文章详细解释了这些概念。
- en: npm - the Node Package Manager
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm - Node包管理器
- en: Writing applications with Node.js is really enjoyable when you realize the sheer
    wealth of information and tools at your disposal! Using Node.js's built-in package
    manager, npm, you can find literally tens of thousands of modules that can be
    installed and used within your application with just a few keystrokes! One of
    the biggest reasons for the success of Node.js is npm, which is one of the best
    package managers out there, with a very minute learning curve. If this is the
    first ever package manager that you are getting exposed to, you should consider
    yourself lucky!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js编写应用程序真的很愉快，当你意识到你可以随时使用的大量信息和工具时！使用Node.js内置的包管理器npm，你可以找到成千上万的模块，只需几次按键就可以安装和在应用程序中使用！Node.js成功的最大原因之一是npm，它是最好的包管理器之一，学习曲线非常小。如果这是你第一次接触的包管理器，你应该觉得自己很幸运！
- en: 'On a regular month, npm handles more than a billion downloads, and it has around
    150,000 packages currently available for you to download. You can view the library
    of available modules by visiting [www.npmjs.com](https://www.npmjs.com/). Downloading
    and installing any module within your application is as simple as executing the
    following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个普通的月份，npm处理的下载量超过10亿次，目前有大约15万个包可供下载。你可以通过访问[www.npmjs.com](https://www.npmjs.com/)来查看可用模块的库。在你的应用程序中下载和安装任何模块就像执行以下命令一样简单：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Have you written a module that you want to share with the world? You can package
    it up using npm and upload it to the public registry at [www.npmjs.org](https://www.npmjs.com/)
    just as easily! If you are not sure how a module you installed works, the source
    code is right there in your project's `node_modules/` folder waiting to be explored!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你写了一个想要与世界分享的模块吗？你可以使用npm打包并将其轻松上传到[www.npmjs.org](https://www.npmjs.com/)的公共注册表中！如果你不确定安装的模块如何工作，源代码就在你的项目的`node_modules/`文件夹中等待探索！
- en: Package versions of modules in npm follow semantic versioning, such as `major.minor.patch`
    order.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: npm中的模块版本遵循语义化版本控制，例如`major.minor.patch`的顺序。
- en: Sharing and reusing JavaScript
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享和重用JavaScript
- en: 'While you develop web applications, you will always end up doing the validations
    for your UI, both at the client and server sides, as the client-side validations
    are required for better UI experience and server-side validations are needed for
    better security of the app. Think about two different languages in action: you
    will have the same logic implemented in both the server and client sides. With
    Node.js, you can think of sharing the common function between server and client,
    reducing the code duplication to a large extent.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Web应用程序时，你总是需要对UI进行验证，客户端和服务器两端都需要进行验证，因为客户端验证对于更好的UI体验是必需的，而服务器端验证则是为了更好地保护应用程序的安全。想想两种不同的语言在行动：你将在服务器和客户端两端实现相同的逻辑。使用Node.js，你可以考虑在服务器和客户端之间共享通用函数，大大减少代码重复。
- en: Ever worked on optimizing the load time for client-side components of your **Single-Page
    Application** (**SPA**) loaded from template engines such as Underscore? You would
    end up thinking about a way we could share the rendering of templates in both
    server and client at the same time; some call it hybrid templating.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经尝试过优化从模板引擎（如Underscore）加载的**单页应用程序**（**SPA**）的客户端组件的加载时间吗？你会考虑一种方法，可以同时在服务器和客户端共享模板的渲染；有些人称之为混合模板。
- en: Node.js resolves the context of duplication of client templates better than
    any other server-side technologies, just because we can use the same JS templating
    framework and the templates both at server and client.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js比其他任何服务器端技术更好地解决了客户端模板重复的问题，只是因为我们可以在服务器和客户端同时使用相同的JS模板框架和模板。
- en: If you are taking this point lightly, the problem it resolves is not just the
    issue of reusing validations or templates on the server and client. Think about
    an SPA being built; you will need to implement the subsets of server-side models
    in the client-side MV* framework also. Now, think about the templates, models,
    and controller subsets being shared on both client and server. We are solving
    a higher scenario of code redundancy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这一点持轻视态度，它解决的问题不仅仅是在服务器和客户端重用验证或模板的问题。想想正在构建的SPA；你将需要在客户端MV*框架中实现服务器端模型的子集。现在，想想在客户端和服务器上共享模板、模型和控制器子集。我们正在解决更高级别的代码冗余情景。
- en: Not just for building web servers!
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不仅仅用于构建Web服务器！
- en: Node.js is not just to write JavaScript in the server-side. Yes, we have discussed
    this point earlier. Node.js sets up the environment for the JavaScript code to
    work anywhere it can be installed. It can be a powerful solution to create command-line
    tools, as well as fully featured, locally run applications that have nothing to
    do with the web or a browser. Grunt.js is a great example of a Node-powered command-line
    tool that many web developers use daily to automate tasks such as build processes,
    compiling CoffeeScript, launching Node.js servers, running tests, and more.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js不仅仅是用于在服务器端编写JavaScript。是的，我们之前已经讨论过这一点。Node.js为JavaScript代码在任何可以安装的地方工作设置了环境。它可以是创建命令行工具的强大解决方案，也可以是完全功能的本地运行应用程序，与Web或浏览器无关。Grunt.js就是一个由Node驱动的命令行工具的很好例子，许多Web开发人员每天都在使用它来自动化任务，如构建过程、编译CoffeeScript、启动Node.js服务器、运行测试等。
- en: In addition to command-line tools, Node.js is increasingly popular among the
    hardware crowd with the Node.js bots movement. `Johnny-Five` and `Cylon.js` are
    two popular Node.js libraries that exist to provide a framework to work with robotics.
    Just search on YouTube for Node.js robots and you will see a lot of examples.
    Also, there is a chance that you might be using a text editor developed on Node.js.
    GitHub's open source editor named Atom, which is hugely popular, is an example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令行工具，Node.js在硬件领域也越来越受欢迎，尤其是Node.js机器人运动。`Johnny-Five`和`Cylon.js`是两个流行的Node.js库，用于提供与机器人工作的框架。只需在YouTube上搜索Node.js机器人，你就会看到很多例子。此外，你可能正在使用一个基于Node.js开发的文本编辑器。GitHub的开源编辑器Atom就是一个很好的例子。
- en: Real-time web application with Socket.io
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Socket.io进行实时Web应用程序
- en: 'One of the important reasons behind the origin of Node.js was to support real-time
    web applications. Node.js has a couple of frameworks built for real-time web applications
    which are hugely popular: `Socket.io` and `Sock.JS`. These frameworks make it
    very simple to build instant, collaboration-based applications such as Google
    Drive and Mozilla''s together.js. Before the introduction of WebSockets in the
    modern browsers, this was achieved via long polling, which was not a great solution
    for real-time experience. While WebSockets is a feature that is only supported
    in modern browsers, `Socket.io` acts as a framework, which also features seamless
    fallback implementations for legacy browsers.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js产生的一个重要原因是支持实时Web应用程序。Node.js有几个专为实时Web应用程序构建的框架非常受欢迎：`Socket.io`和`Sock.JS`。这些框架使构建即时协作应用程序（如Google
    Drive和Mozilla的together.js）变得非常简单。在现代浏览器引入WebSockets之前，这是通过长轮询实现的，这对于实时体验来说并不是一个很好的解决方案。虽然WebSockets是现代浏览器中支持的功能，但`Socket.io`充当了一个框架，还为旧版浏览器提供了无缝的回退实现。
- en: 'If you need to understand more on the use of WebSockets in applications, here''s
    a good resource on MDN that you can explore:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要了解更多关于在应用程序中使用WebSockets的信息，这是MDN上一个很好的资源，您可以探索一下：
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications)。'
- en: Networking and file IO
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和文件IO
- en: In addition to the powerful non-blocking asynchronous nature of Node.js, it
    also has robust networking and filesystem tools available via its core modules.
    With Node.js's networking modules, you can create server and client applications
    that accept network connections and communicate via streams and pipes. Node contains
    a module named as **fs** or filesystem which is totally responsible for all kind
    of read write operations performed on files. It also takes an advantage of streaming
    feature of node to perform those operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Node.js强大的非阻塞异步特性之外，它还通过核心模块提供了强大的网络和文件系统工具。使用Node.js的网络模块，您可以创建接受网络连接并通过流和管道进行通信的服务器和客户端应用程序。Node包含一个名为**fs**或文件系统的模块，它完全负责对文件执行的所有读写操作。它还利用了Node的流特性来执行这些操作。
- en: Microservices
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: Dividing the app with respect to a functionality unit is called a **microservice**.
    Each microservice becomes the self contained unit of deployment. Node.js is based
    on the common JS modules pattern which provides modularity in structure of an
    application. Such a pattern is used to create the microservices. With the increase
    of functionality, the number of microservices increases. To manage those services,
    the Node.js ecosystem provides powerful libraries like `pm2`. Therefore, it enables
    the elements of an application to be updated and scaled separately.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据功能单元划分应用程序称为**微服务**。每个微服务都成为自包含的部署单元。Node.js基于通用JS模块模式，提供了应用程序结构的模块化。这种模式用于创建微服务。随着功能的增加，微服务的数量也在增加。为了管理这些服务，Node.js生态系统提供了强大的库，如`pm2`。因此，它使应用程序的元素能够单独更新和扩展。
- en: Internet of things (IoT)
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网（IoT）
- en: With the advent of **Internet of things** (**IoT**), the Node.JS ecosystem provides
    amazing library support for various devices like sensors, beacons, wearables,
    and so on. Node.js is considered as an ideal technology for managing the request
    made by those devices via its powerful backbone of streams and non-blocking I/O.
    Popular IoT board variants like Arduino, Raspberry Pi, and so on, have more than
    300 Node.js packages. The developers building data-intensive, real-time applications
    often find Node.js as a natural fit.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**物联网**（**IoT**）的出现，Node.js生态系统为各种设备（如传感器、信标、可穿戴设备等）提供了惊人的库支持。Node.js被认为是管理这些设备发出的请求的理想技术，通过其强大的流和非阻塞I/O支撑。像Arduino、Raspberry
    Pi等流行的物联网板变种有300多个Node.js包。构建数据密集型、实时应用程序的开发人员通常会发现Node.js是一个自然的选择。
- en: A simple server with Node.js
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js创建一个简单的服务器
- en: 'To see an example of how lightweight Node.js can be, let''s take a look at
    some sample code that starts up an HTTP server and sends Hello World to a browser:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要看轻量级Node.js可以做到什么，让我们看一下启动HTTP服务器并向浏览器发送Hello World的示例代码：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A few basic lines of code are all it takes to write a complete Node.js application.
    Running it with a simple Node.js `app.js` command will launch an HTTP server that
    is listening on port 8080\. Point any browser to `http://localhost:8080`, and
    you will see the simple output Hello World on your screen! While this sample app
    doesn't actually do anything useful, it should give you a glimpse of the kind
    of power you will have while writing web applications using Node.js. If you don't
    have the initial Node.js development environment set up, we will discuss it in
    the next chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行基本的代码就可以编写一个完整的Node.js应用程序。使用简单的Node.js `app.js`命令运行它将启动一个监听端口8080的HTTP服务器。将任何浏览器指向`http://localhost:8080`，您将在屏幕上看到简单的输出Hello
    World！虽然这个示例应用程序实际上并没有做任何有用的事情，但它应该让您一窥使用Node.js编写Web应用程序时所拥有的强大功能。如果您还没有设置初始的Node.js开发环境，我们将在下一章中讨论它。
- en: When to use Node.js
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Node.js
- en: 'You may have heard of this proverb by an american psychologist, Abraham Maslow:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能听说过美国心理学家亚伯拉罕·马斯洛的这句谚语：
- en: '"If all you have is a hammer, everything looks like a nail!"'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “如果你手中只有一把锤子，那么任何东西看起来都像钉子！”
- en: This makes a lot of sense in this context. Node.js is not a technology to depend
    for on all the application problems that you intend to solve, and if not chosen
    wisely, the decision to use it will backfire. Node.js is well suited for applications
    that are expected to handle a huge amount of concurrent connections. Also, it
    should be noted, it is most suited for applications where each incoming request
    requires very few CPU cycles. This means that if you intend to do computation-intensive
    tasks upon request, it will end up blocking the event loop, thereby impacting
    other requests concurrently processed by the web server. Node.js is well suited
    for real-time web applications, such as chat rooms, collaboration tools, online
    games, and so on. So, when deciding whether or not to use Node.js, we should analyze
    the application context seriously and figure out whether Node.js really suits
    the context of the application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这是有道理的。Node.js不是一种可以依赖解决您打算解决的所有应用程序问题的技术，如果选择不明智，使用它的决定将适得其反。Node.js非常适合预期处理大量并发连接的应用程序。此外，应该注意，它最适合每个传入请求需要非常少的CPU周期的应用程序。这意味着，如果您打算在请求时执行计算密集型任务，它将阻塞事件循环，从而影响Web服务器同时处理的其他请求。Node.js非常适合实时Web应用程序，如聊天室、协作工具、在线游戏等。因此，在决定是否使用Node.js时，我们应该认真分析应用程序的上下文，并弄清楚Node.js是否真的适合应用程序的上下文。
- en: 'It is quite hard to debate over the use cases of Node.js in a detailed manner.
    However, the following Stack Overflow thread does this effectively, and I strongly
    recommend you to go through the answers on this post if you are more interested
    in the use cases of Node.js: [http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-node-js.](http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-node-js)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 很难详细讨论Node.js的用例。然而，以下Stack Overflow主题有效地做到了这一点，我强烈建议您阅读这篇帖子上的答案，如果您对Node.js的用例更感兴趣：[http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-node-js.](http://stackoverflow.com/questions/5062614/how-to-decide-when-to-use-node-js)
- en: As we have briefly gone through the concept and features of Node.js, now let's
    look into the NoSQL and MongoDB side.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经简要介绍了Node.js的概念和特性，现在让我们来看看NoSQL和MongoDB方面。
- en: The NoSQL movement
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL运动
- en: 'Let''s start by exploring the answers to the question: What exactly is a NoSQL
    database? NoSQL is a common term for database technologies that deviate from the
    traditional **Relational Database Management System** (**RDBMS**) concepts. The
    common reason for these database solutions to deviate from RDBMS database standards
    is to achieve and set better standards of availability and partitioning capabilities
    than traditional RDBMS solutions.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探讨一个问题的答案开始：什么是NoSQL数据库？NoSQL是数据库技术的常见术语，它偏离了传统的关系数据库管理系统（RDBMS）概念。这些数据库解决方案偏离RDBMS数据库标准的常见原因是为了实现和设定比传统RDBMS解决方案更好的可用性和分区能力标准。
- en: 'To introduce you to this concept, we should have a look at the Brewer''s theorem,
    which is otherwise known as the CAP theorem:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您介绍这个概念，我们应该看一下布鲁尔定理，也就是CAP定理：
- en: '*"It is impossible for a distributed computer system to simultaneously provide
    all three of the following guarantees: Consistency, Availability, and Partition
    Tolerance."*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算系统不可能同时提供以下三项保证：一致性、可用性和分区容错性。
- en: Traditional RDBMS solutions are good at consistency, but compromise a little
    once it comes to providing better availability (data reads) and partitioning capabilities.
    Most of the NoSQL solutions have been evolved in this direction to achieve better
    heights in data availability and partitioning.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的RDBMS解决方案在一致性方面表现良好，但在提供更好的可用性（数据读取）和分区能力方面会有所妥协。大多数NoSQL解决方案已经朝着这个方向发展，以实现更好的数据可用性和分区。
- en: As this is a common term for any database technology that deviates from the
    concepts followed by RDBMS solutions such as MySQL, PostgreSQL, and so on, there
    are various subsets for NoSQL databases. Most popular subsets of NoSQL are document
    stores, key-value stores, and graph-based database solutions. MongoDB, which is
    the one we are going to try out, falls into the document store category. There
    are many more NoSQL solutions available in the market apart from MongoDB, such
    as Cassandra, Redis, Neo4j, HBase, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是任何偏离RDBMS解决方案（如MySQL、PostgreSQL等）概念的数据库技术的常见术语，NoSQL数据库有各种子集。最流行的NoSQL子集包括文档存储、键值存储和基于图的数据库解决方案。我们将要尝试的MongoDB属于文档存储类别。除了MongoDB之外，市场上还有许多其他NoSQL解决方案，如Cassandra、Redis、Neo4j、HBase等。
- en: A short introduction to MongoDB
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB简介
- en: As we discussed in the previous paragraph, MongoDB falls into the document store
    category of NoSQL databases. MongoDB is being actively developed by 10gen, which
    has been renamed to MongoDB Inc. MongoDB is open source and its source is available
    on various platforms, such as GitHub.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的段落中讨论的，MongoDB属于NoSQL数据库的文档存储类别。MongoDB由10gen积极开发，该公司已更名为MongoDB Inc.
    MongoDB是开源的，其源代码可在GitHub等各种平台上获得。
- en: 'We will look at the following various features of MongoDB:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下MongoDB的以下各种特性：
- en: JSON-friendly database
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON友好的数据库
- en: Schema-less design
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无模式化设计
- en: Various performance facets
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种性能方面
- en: JSON-friendly database
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON友好的数据库
- en: One of the most important reasons for the popularity of MongoDB is that it is
    a JSON-friendly database. This means that documents are stored and retrieved from
    MongoDB as JavaScript objects. Internally, this JSON data gets converted to BSON
    format while getting persisted to the system. So, this gives extreme flexibility,
    where we can use the same data format from client to server and eventually to
    the database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB之所以如此受欢迎的一个最重要的原因是它是一个JSON友好的数据库。这意味着文档以JavaScript对象的形式存储和检索。在内部，这些JSON数据在持久化到系统时会转换为BSON格式。因此，这提供了极大的灵活性，我们可以在客户端、服务器和最终数据库中使用相同的数据格式。
- en: 'A typical document (record) in a MongoDB collection (table) might look like
    the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB集合（表）中的典型文档（记录）可能如下所示：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After examining the preceding output, we can see a key called `_id`. It is a
    MongoDB ID which must be encoded as a binary JSON `objectID`(BSON). If failed
    to encode, MongoDB won't be able to retrieve or update an object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查前面的输出后，我们可以看到一个名为`_id`的关键字。这是一个必须被编码为二进制JSON `objectID`(BSON)的MongoDB ID。如果编码失败，MongoDB将无法检索或更新对象。
- en: Schema-less design
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无模式化设计
- en: Another important feature of MongoDB is its schema-less nature. With a relational
    database, you are required to define the exact structure of the data being stored
    ahead of time, which is termed as the schema. This means that you must have defined
    the exact number of columns, the length, and the data type for every field in
    a table, and that each field must always match that exact set of criteria. Mongo
    provides a flexible nature where the documents that you store into the database
    need not follow any schema unless the developer enforces it through the application
    level. This makes MongoDB a great fit for Agile-based development, as you could
    carry out modifications on the application schema on the fly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的另一个重要特性是其无模式化的特性。在关系型数据库中，您需要提前定义存储的数据的确切结构，这被称为模式。这意味着您必须定义表中每个字段的确切列数、长度和数据类型，并且每个字段必须始终符合该确切的一组标准。Mongo提供了一种灵活的特性，使得您存储到数据库中的文档不需要遵循任何模式，除非开发人员通过应用程序级别强制执行它。这使得MongoDB非常适合基于敏捷开发，因为您可以在应用程序模式上进行即时修改。
- en: Various performance facets
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 各种性能方面
- en: Other than the JavaScript-friendly nature, one other resemblance between MongoDB
    and Node.js is that MongoDB is also designed with highly concurrent applications
    with heavy read operations in mind.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了友好的JavaScript特性之外，MongoDB和Node.js之间的另一个相似之处是，MongoDB也是为高并发应用程序和大量读操作而设计的。
- en: MongoDB also introduces the concept of *sharding*, which makes it possible to
    scale the database horizontally as well as vertically. If the application owner
    needs to increase the database capabilities, they could add more machines into
    the stack. This is a cheaper option compared to investing in the RAM of a single
    machine, which will be the case in RDBMS solutions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB还引入了*分片*的概念，这使得可以水平和垂直扩展数据库。如果应用程序所有者需要增加数据库的能力，他们可以在堆栈中添加更多的机器。这是一个相对于投资于单台机器的RAM来说更便宜的选择，而这将是关系型数据库解决方案的情况。
- en: The process of *Indexing* created a list of values called index for a chosen
    field. These indexes are used to query larger chunks of data. Using indexes accelerates
    the data retrieval speed and performance. The MongoDB client provides various
    methods like `ensureIndex` to create an index only if one doesn't exist.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 索引化的过程创建了一个称为索引的值列表，用于选择的字段。这些索引用于查询更大的数据块。使用索引可以加快数据检索速度和性能。MongoDB客户端提供了各种方法，比如`ensureIndex`，只有在索引不存在时才创建索引。
- en: Additionally, MongoDB has various commands to allow *aggregation* of data, such
    as group, count, and return distinct values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，MongoDB还有各种命令来允许对数据进行*聚合*，比如分组、计数和返回不同的值。
- en: All the advantages that we discussed come with some impact on the consistency,
    as MongoDB does not strictly adhere to the RDBMS standards like ACID transactions.
    Also, if you end up creating a data model that might need too many JOIN operations,
    then MongoDB won't make a good fit as it is not designed with too many aggregations,
    even though the aggregations are possible via the MongoDB aggregation framework.
    MongoDB may or may not be the right solution for your application. You should
    truly weigh the pros and cons of each technology before making a decision to determine
    which technology is right for you.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的所有优点都会对一致性产生一定影响，因为MongoDB不严格遵守ACID事务等关系型数据库标准。此外，如果您最终创建了一个可能需要太多JOIN操作的数据模型，那么MongoDB可能不适合，因为它并不是设计用于太多的聚合，尽管聚合是可能通过MongoDB聚合框架实现的。MongoDB可能适合也可能不适合您的应用程序。在做出决定之前，您应该真正权衡每种技术的利弊，以确定哪种技术适合您。
- en: Node.js and MongoDB in the wild
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js和MongoDB在实际中
- en: Both Node.js and MongoDB are extremely popular and active in the development
    community. This is true for enterprises as well. Some of the biggest names in
    the Fortune 500 space have fully embraced Node.js to power their web applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和MongoDB在开发社区中都非常受欢迎和活跃。这对企业也是如此。财富500强中一些最大的公司已经完全采用Node.js来支持他们的Web应用程序。
- en: This is due in large part to the asynchronous nature of Node.js, which makes
    it a great alternative for high traffic, high I/O applications such as e-commerce
    websites and mobile applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上是由于Node.js的异步特性，使其成为高流量、高I/O应用程序的绝佳选择，例如电子商务网站和移动应用程序。
- en: 'Here''s just a small list of some big companies that are working with Node.js:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些正在使用Node.js的大公司的小列表：
- en: PayPal
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贝宝
- en: LinkedIn
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领英
- en: eBay
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eBay
- en: Walmart
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沃尔玛
- en: Yahoo!
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雅虎！
- en: Microsoft
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软
- en: Dow Jones
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 道琼斯
- en: Uber
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优步
- en: New York Times
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纽约时报
- en: 'MongoDB''s use in the enterprise sector is equally as impressive and widespread,
    with an increasing number of companies adopting the leading NoSQL database server.
    Here''s just a small list of some big companies that are working with MongoDB:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在企业领域的使用同样令人印象深刻和广泛，越来越多的公司采用这一领先的NoSQL数据库服务器。以下是一些正在使用MongoDB的大公司的小列表：
- en: Cisco
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思科
- en: Craigslist Inc.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Craigslist公司
- en: Forbes
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 福布斯
- en: FourSquare
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FourSquare
- en: Intuit
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 财捷通
- en: McAfee
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦克菲
- en: MTV
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MTV
- en: MetLife
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大都会人寿
- en: Shutterfly
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旭通飞
- en: Under Armour
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安德玛
- en: What to expect from this book
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书的预期内容
- en: The remainder of this book is going to be a guided tour that walks you through
    the creation of a complete data-driven website. The website we create will feature
    almost every aspect of a typical large-scale web development project. The app
    will be developed using a popular Node.js framework called Express, and it will
    persist data using MongoDB. In the first few chapters, we will cover the groundwork
    involved in getting the core of the server up and serving content. This includes
    configuring your environment so you are up and running with Node.js and MongoDB,
    and a basic introduction to the core concepts of both technologies. Then, we will
    write a web server powered by ExpressJS from scratch, which will handle serving
    all of the necessary files for the website. From there, we will work with the
    Handlebars template engine to serve both static and dynamic HTML web pages. Diving
    deeper, we will make the application persistent by adding a data layer where the
    records for the website will be saved and retrieved via a MongoDB server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分将是一次引导之旅，带领您完成一个完整的数据驱动网站的创建过程。我们创建的网站将涵盖典型大型Web开发项目的几乎所有方面。该应用程序将使用一种名为Express的流行Node.js框架进行开发，并将使用MongoDB持久化数据。在最初的几章中，我们将涵盖涉及启动服务器核心并提供内容所涉及的基础工作。这包括配置您的环境，以便您可以使用Node.js和MongoDB，并对这两种技术的核心概念进行基本介绍。然后，我们将从头开始编写一个由ExpressJS驱动的Web服务器，该服务器将处理为网站提供所有必要文件。然后，我们将使用Handlebars模板引擎来提供静态和动态HTML网页。更深入地进行，我们将通过添加数据层使应用程序持久化，网站的记录将通过MongoDB服务器保存和检索。
- en: We will cover writing a RESTful API so that other people can interact with your
    application. Finally, we will go into the details to see how to write and execute
    tests for all of your code. A summary is given in the following section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍如何编写RESTful API，以便其他人可以与您的应用程序进行交互。最后，我们将深入了解如何为您的所有代码编写和执行测试。以下部分提供了摘要。
- en: Wrapping up, we will take a brief detour as we examine some popular, merging
    frontend technologies that are becoming increasingly popular while writing SPAs.
    These technologies include Backbone.js, Angular, and Ember.js.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将进行一个简短的旁观，检查一些越来越受欢迎的前端技术，这些技术在编写单页应用程序时变得越来越受欢迎。这些技术包括Backbone.js、Angular和Ember.js。
- en: Last but not least, we will go into detail about how to deploy your new website
    to the Internet using popular cloud-based hosting services such as Heroku and
    Amazon Web Services.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将详细介绍如何使用Heroku和亚马逊Web服务等流行的基于云的托管服务将您的新网站部署到互联网上。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed what is to be expected throughout the rest of this
    book. We discussed the amazing current state of JavaScript and how it can be used
    to power the full stack of a web application. Not that you needed any convincing
    in the first place, but I hope you're excited and ready to get started writing
    web applications using Node.js and MongoDB!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了本书其余部分可以期待的内容。我们讨论了JavaScript目前令人惊叹的状态，以及它如何可以用于支持Web应用程序的整个堆栈。虽然您一开始就不需要任何说服，但我希望您对开始使用Node.js和MongoDB编写Web应用程序感到兴奋并准备好了！
- en: Next up, we will set up your development environment and get you up and running
    with Node.js, MongoDB, and npm, as well as write and launch a quick Node.js app
    that uses MongoDB!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置您的开发环境，并让您使用Node.js、MongoDB和npm，并编写并启动一个使用MongoDB的快速Node.js应用程序！
