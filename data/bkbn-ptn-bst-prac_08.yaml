- en: Chapter 8. Unit Test, Stub, Spy, and Mock Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章：单元测试、存根、间谍和模拟你的应用
- en: Majority of developers believe that testing is essential, but in reality only
    a few of them actually go for test-driven development. Testing falls under one
    of the best practices of the JavaScript development process. Hence, we decided
    to include a chapter on how to unit test Backbone-based applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者认为测试是必要的，但现实中只有少数人真正进行测试驱动开发。测试是 JavaScript 开发过程中的一项最佳实践。因此，我们决定包括一个关于如何对基于
    Backbone 的应用程序进行单元测试的章节。
- en: 'A number of popular testing libraries, such as `QUnit`, `Jasmine`, `Mocha`,
    and `SinonJS`, are available to unit test JavaScript applications. In this chapter,
    we are going to show you how to test with `QUnit`, the simplest yet robust testing
    platform, which is pretty easy to learn as well. In the latter part, we will look
    into `SinonJS` to learn test spies, stubs, and mocks. Together, `QUnit` and `SinonJS`
    create a strong tool to test every part of your app. The main points to be discussed
    in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的测试库，如 `QUnit`、`Jasmine`、`Mocha` 和 `SinonJS`，都可用于单元测试 JavaScript 应用程序。在本章中，我们将向你展示如何使用
    `QUnit`，这是一个简单但强大的测试平台，学习起来也很容易。在后一部分，我们将探讨 `SinonJS` 以了解测试间谍、存根和模拟。`QUnit` 和
    `SinonJS` 一起为测试应用中的每个部分提供了一个强大的工具。本章要讨论的主要内容包括：
- en: '**Why unit testing is important**: Testing is a habit. Continuing this along
    with development may take some extra time initially, but it is essential especially
    while working in a team or developing complex applications.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为什么单元测试很重要**：测试是一种习惯。在开发过程中继续这样做可能最初需要额外的时间，但在团队工作或开发复杂应用程序时，这是必不可少的。'
- en: '**Testing with QUnit**: We will look into the basic aspects of `QUnit`, and
    we will see how to use them for the `Backbone.js` components.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 QUnit 进行测试**: 我们将探讨 `QUnit` 的基本方面，并了解如何将其用于 `Backbone.js` 组件。'
- en: '**Using spies, stubs, and mocks with SinonJS**: Spying on the behavior of JavaScript
    functions and controlling their behavior whenever needed from a test environment
    is absolutely necessary for unit testing. We will look into this concept briefly
    with the `SinonJS` test framework.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 SinonJS 进行间谍、存根和模拟**: 在单元测试中，监视 JavaScript 函数的行为并在需要时从测试环境中控制其行为是绝对必要的。我们将简要探讨这个概念，使用
    `SinonJS` 测试框架。'
- en: Understanding why unit testing is important
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单元测试为什么重要
- en: 'If you already know the benefits of testing and follow the best practices while
    developing your JavaScript apps, you can skip this section. If you still wonder
    why you should actually test your application while you are already writing clean
    and maintainable code, the following are a few reasons to consider:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经知道测试的好处，并在开发 JavaScript 应用程序时遵循最佳实践，你可以跳过这一部分。如果你仍然想知道为什么你应该在实际编写干净且易于维护的代码时测试你的应用程序，以下是一些需要考虑的原因：
- en: Testing is never a waste of time. You do not need to run your code repeatedly
    to see whether it works or not. You can run all the test cases at once to see
    whether everything is functioning as expected. Testing gives you the confidence
    that your code is working fine.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试永远不会浪费时间。你不需要反复运行代码来查看它是否工作。你可以一次性运行所有测试用例来查看是否一切按预期工作。测试让你有信心代码工作正常。
- en: Unit tests are really fast to create and fast to run too.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试创建和运行都非常快。
- en: Update your code without worry. Your test will tell you whether the function
    is working as it is expected to or not. You will find this very helpful, especially
    when you work in a team.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新你的代码无需担忧。你的测试将告诉你函数是否按预期工作。你会发现这非常有帮助，尤其是在团队工作中。
- en: Once you start writing unit tests for your code, you will soon find that you
    are writing more modular, flexible, and testable code than you used to.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你开始为你的代码编写单元测试，你很快会发现你正在编写比以前更模块化、更灵活、更易于测试的代码。
- en: In **Test Driven Development** (**TDD**), you write failing test cases first
    and then develop the code. In that case, a passing test case ensures that your
    developed code works fine without any issues.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **测试驱动开发**（**TDD**）中，你首先编写失败的测试用例，然后开发代码。在这种情况下，一个通过测试的用例确保你开发的代码没有问题地正常工作。
- en: Testing is fun. It's not very easy, sure, and not something that you can master
    in a day. It is not very difficult either—lots of developers are doing it and
    you can do it too.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很有趣。当然，它并不容易，而且不是一天之内就能掌握的。它也不太难——许多开发者都在做这件事，你也可以做到。
- en: Testing with QUnit
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 QUnit 进行测试
- en: '`QUnit` ([http://qunitjs.com](http://qunitjs.com)), a lightweight unit testing
    framework maintained by the jQuery team, which is quite easy to work with compared
    to other frameworks. Discussing `QUnit` in complete detail is beyond the scope
    of this book, but we will learn about the simple features of it and explore how
    we can use it with our Backbone components.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`QUnit` ([http://qunitjs.com](http://qunitjs.com))，由 jQuery 团队维护的一个轻量级单元测试框架，与其他框架相比，它相当容易使用。本书不会详细讨论
    `QUnit`，但我们将了解它的简单功能，并探讨我们如何使用它与我们的 Backbone 组件一起使用。'
- en: 'Assertions are the most essential elements of any unit test framework. You
    need to compare your actual implementation values to the results that the test
    produces. Assertions are the methods that serve this comparison functionality.
    `QUnit` has only eight assertions; we are going to use some of them in the next
    section. Let''s discuss a few of them here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是任何单元测试框架中最基本的元素。您需要比较您的实际实现值与测试产生的结果。断言是提供这种比较功能的方法。`QUnit` 只有八个断言；我们将在下一节中使用其中一些。让我们在这里讨论几个：
- en: '`ok (state, message)`: This passes if the first argument is true'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok (state, message)`: 如果第一个参数为真，则通过'
- en: '`equal (actual, expected, message)`: This returns true if `actual` and `expected`
    are equal'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equal (actual, expected, message)`: 如果 `actual` 和 `expected` 相等，则返回 true'
- en: '`deepEqual (actual, expected, message)`: This is a deep recursive-comparison
    assertion, working on primitive types, arrays, objects, regular expressions, dates,
    and functions'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deepEqual (actual, expected, message)`: 这是一个深度递归比较断言，它作用于原始类型、数组、对象、正则表达式、日期和函数'
- en: '`strictEqual (actual, expected, message)`: This is a strict type and a value
    comparison assertion'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictEqual (actual, expected, message)`: 这是一个严格的类型和值比较断言'
- en: '`throws (block, actual, message)`: This is an assertion to test whether a callback
    throws an exception when run'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throws (block, actual, message)`: 这是一个断言，用于测试当运行回调时是否抛出异常'
- en: 'There are few more asserts: `notEqual()`, `notDeepEqual()`, and `notStrictEqual()`.
    The functionalities of these are clearly the opposite of their counterparts. In
    addition to these, `QUnit` has a number of test methods that are used to initiate
    the tests. They are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个断言：`notEqual()`、`notDeepEqual()` 和 `notStrictEqual()`。这些断言的功能与它们的对应项正好相反。除此之外，`QUnit`
    还有一系列用于启动测试的测试方法。它们如下：
- en: '`asyncTest()`: This adds an asynchronous test to run'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncTest()`: 这将添加一个异步测试来运行'
- en: '`expect()`: This specifies how many assertions are expected to run within a
    test'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect()`: 这指定了在测试中预期运行多少个断言'
- en: '`module()`: This consists of group-related tests under a single label'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module()`: 这包含在单个标签下的相关测试组'
- en: '`test()`: This adds a test to run'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test()`: 这将添加一个要运行的测试'
- en: 'Setting up `QUnit` is fairly straightforward. First we will create a `test`
    directory and put it inside our project directory. This `test` folder is going
    to hold all our test files of the project. Then, inside this folder, we will create
    an HTML file, which will show all the test results in our browser. In general,
    `QUnit` comes up with `qunit.js` and a `qunit.css` files. You need to just include
    the following code snippet as given in the QUnit website ([http://qunitjs.com](http://qunitjs.com))
    in your HTML file and you are done with the QUnit setup:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `QUnit` 相对直接。首先，我们将创建一个 `test` 目录并将其放在我们的项目目录中。这个 `test` 文件夹将包含我们项目的所有测试文件。然后，在这个文件夹内部，我们将创建一个
    HTML 文件，它将在我们的浏览器中显示所有测试结果。通常，`QUnit` 会提供 `qunit.js` 和 `qunit.css` 文件。您只需在您的 HTML
    文件中包含 QUnit 网站上提供的以下代码片段（[http://qunitjs.com](http://qunitjs.com)），然后您就完成了 `QUnit`
    的设置：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `tests.js` file will hold all your test cases. You can have multiple test
    files depending on your requirements. If you found that this section is a little
    complex and it is difficult to understand all the definitions of assertion methods,
    do not worry. In the next section, we will show you a simple `QUnit` test case
    with few of these assertions, and you will see how easy it is to get started with
    `QUnit`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests.js` 文件将包含所有您的测试用例。根据您的需求，您可以拥有多个测试文件。如果您发现这一部分有点复杂，难以理解所有断言方法的定义，请不要担心。在下一节中，我们将向您展示一个简单的
    `QUnit` 测试用例，其中包含这些断言的一些，您将看到开始使用 `QUnit` 是多么简单。'
- en: Performing a basic test case
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行基本测试用例
- en: 'We learned the basic and important API methods of `QUnit`. Now, let''s use
    few of them to create a simple test case. We will write a method that checks whether
    a number is prime or not. Then we will make a couple of calls to the `isPrime()`
    method from our test and analyze the results as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 `QUnit` 的基本和重要的 API 方法。现在，让我们使用其中的一些方法来创建一个简单的测试用例。我们将编写一个检查一个数字是否为素数的方法。然后我们将从我们的测试中对
    `isPrime()` 方法进行几次调用，并如下分析结果：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A rather simple example is shared in the previous code snippet to show how easy
    it is to get started with `QUnit`. We use the `expect()` method at first to assure
    that we will be doing two assertions in this test case. If we do more than two
    assertions, then this test will fail. Now, those two asserts, namely `ok()` and
    `equal()`, call the `isPrime()` method with two different inputs and check whether
    those input values are prime numbers or not. When you run this test, you can see
    both the tests to pass through.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中共享了一个相当简单的示例，以展示如何轻松地开始使用 `QUnit`。我们首先使用 `expect()` 方法来确保在这个测试用例中我们将进行两个断言。如果我们进行超过两个断言，那么这个测试将失败。现在，这两个断言，即
    `ok()` 和 `equal()`，使用两个不同的输入调用 `isPrime()` 方法，并检查这些输入值是否为素数。当你运行这个测试时，你可以看到两个测试都通过了。
- en: Understanding the QUnit module (), setup (), and teardown () methods
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 QUnit 的模块（module）、setup 和 teardown 方法
- en: 'To organize multiple test cases, we need something that can provide a block
    structure and hold multiple tests together. The `module()` method allows us to
    group the test cases together. Furthermore, it introduces the two methods, `setup()`
    and `teardown()`, that run before and after each test case, as shown in the following
    code snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织多个测试用例，我们需要一种能够提供块结构并将多个测试组合在一起的东西。`module()` 方法允许我们将测试用例分组在一起。此外，它引入了两个方法，`setup()`
    和 `teardown()`，它们在每个测试用例前后运行，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `setup()` method is quite useful when you need to instantiate an object
    (such as a view or a collection) that will be used in multiple tests. The `teardown()`
    method, on the other hand, is mostly used to clean up the resources that you added
    as global variables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要实例化一个将在多个测试中使用的对象（例如视图或集合）时，`setup()` 方法非常有用。另一方面，`teardown()` 方法主要用于清理你添加为全局变量的资源。
- en: Testing Backbone.js components with QUnit
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 QUnit 测试 Backbone.js 组件
- en: 'Now as we understand the basics of `QUnit`, let''s try it with some Backbone
    components. We will first start with a Backbone model and we will create a simple
    `User` model, as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `QUnit` 的基础知识，让我们尝试使用一些 Backbone 组件。我们首先从 Backbone 模型开始，我们将创建一个简单的
    `User` 模型，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we tested the Backbone model with one of its default values and another
    attribute that we changed in the `setup()` method, but intentionally tested it
    with another value. So, this test should fail for one assert case. The following
    screenshot shows how it will look in a browser:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Backbone 模型的一个默认值和我们在 `setup()` 方法中更改的另一个属性进行了测试，但故意使用另一个值进行测试。因此，这个测试应该因为一个断言案例而失败。以下截图显示了它在浏览器中的样子：
- en: '![Testing Backbone.js components with QUnit](img/3576_08_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QUnit 测试 Backbone.js 组件](img/3576_08_01.jpg)'
- en: Using test spies, stubs, and mocks with SinonJS
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SinonJS 的测试间谍、存根和模拟
- en: We use unit testing to test one component of an application. That component
    can be a function, an object, a variable, or any outcome which is not known yet,
    and your unit test wants to make sure whether that particular component is working
    fine or not. Often, besides testing separate components, you may find testing
    the behavior of your methods is of the same importance. For example, how many
    times a method is called, what it returns, whether it has thrown any exception,
    what arguments it is called with, and so on. To perform these types of behavioral
    testing, we use test spies, stubs, and mocks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用单元测试来测试应用程序的一个组件。这个组件可以是一个函数、一个对象、一个变量，或者任何尚未知的任何结果，而你的单元测试想要确保该特定组件是否运行良好。通常，除了测试单独的组件外，你可能还会发现测试方法的行为同样重要。例如，一个方法被调用的次数、它返回的内容、是否抛出了任何异常、它被调用的参数等等。为了执行这些类型的测试，我们使用测试间谍、存根和模拟。
- en: 'There are few testing libraries which support test spies, stubs, and mocks.
    However, we found `SinonJS` quite easy to work with and robust as well. `SinonJS`
    works seamlessly with `QUnit` and you can use it with or without `QUnit` too.
    The definition of `SinonJS`, as given on their website, is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些测试库支持测试间谍、桩和模拟。然而，我们发现`SinonJS`非常易于使用，并且也很健壮。`SinonJS`与`QUnit`无缝工作，你也可以与或不与`QUnit`一起使用它。`SinonJS`在其网站上给出的定义如下：
- en: Standalone test spies, stubs and mocks for JavaScript. No dependencies, works
    with any unit testing framework.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 独立的JavaScript测试间谍（spies）、桩（stubs）和模拟（mocks）。无依赖，与任何单元测试框架兼容。
- en: Testing with spies
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用间谍进行测试
- en: 'We first need to know what a spy is. By definition, as given on the `SinonJS`
    website, a spy is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要了解什么是间谍。根据`SinonJS`网站上的定义，间谍如下：
- en: A test spy is a function that records arguments, return value, the value of
    this and exception thrown (if any) for all its calls. A test spy can be an anonymous
    function or it can wrap an existing function.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 测试间谍是一个记录所有调用参数、返回值、`this`的值以及抛出的异常（如果有）的函数。测试间谍可以是一个匿名函数，也可以是包装现有函数的函数。
- en: 'So your next question should be why a spy should be used. We use test spies
    to test the behavior of callback and other methods, and to understand how they
    work. You will find out the answer in more detail once you look into some API
    methods associated with spies:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你的下一个问题应该是为什么应该使用间谍。我们使用测试间谍来测试回调和其他方法的行为，以及了解它们是如何工作的。一旦你查看与间谍相关的某些API方法，你将找到更详细的答案：
- en: '`called()`: This returns true if the spy was called at least once'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`called()`: 如果间谍至少被调用一次，则返回true'
- en: '`calledOnce()`: This returns true if the spy was called exactly once'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calledOnce()`: 如果间谍正好被调用一次，则返回true'
- en: '`returned()`: This returns true if the spy returned the provided value at least
    once'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returned()`: 如果间谍至少一次返回了提供的值，则返回true'
- en: 'These are few of the supported methods of the spy API. Hopefully, now you can
    understand why a spy is used—it allows you to test multiple characteristics of
    a function, to know whether it gets called only once, or to check what value it
    returns. A spy allows you every possibility to test the complete flow of a function.
    Now let''s see how to use a spy from the following code snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是间谍API支持的少数方法。希望现在你能理解为什么使用间谍——它允许你测试函数的多个特性，了解它是否只被调用一次，或者检查它返回的值。间谍允许你测试函数的完整流程的每一个可能性。现在让我们看看如何从以下代码片段中使用间谍：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We used the same `User` model and added a `getNameAsArray()` method to it. We
    spied on this method to test whether it gets called only once and returns an array.
    The previous test case passes fine.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了相同的`User`模型，并为其添加了一个`getNameAsArray()`方法。我们监视了这个方法来测试它是否只被调用一次并返回一个数组。之前的测试用例通过得很好。
- en: 'So, you can use spies for any or all of the following cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用间谍来验证以下任何或所有情况：
- en: Check for the invocation of a callback
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查回调的调用
- en: Validate whether callbacks are executed with certain arguments
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证回调是否以特定参数执行
- en: Validate if internal functions provide the correct return value
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证内部函数是否提供正确的返回值
- en: Validate a certain simple calling behavior
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证某种简单的调用行为
- en: Testing with stubs
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用桩进行测试
- en: A test stub, on the other hand, extends from a spy and adds some extra functionality
    to it. It is a function with preprogramed behavior and supports the complete spy
    API. It is used to replace (or fake) the behavior of an existing method with something.
    It is quite useful when you want to prevent a specific method from being called
    directly, or force a method to throw an error in order to test error handling.
    Like spies, stubs can either be anonymous, or they can wrap the existing functions.
    When wrapping an existing function with a stub, the original function is not called.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，测试桩（test stub）是从间谍（spy）扩展而来，并为其添加了一些额外的功能。它是一个具有预编程行为的函数，并支持完整的间谍API。它被用来替换（或模拟）现有方法的某些行为。当你想要防止直接调用某个特定方法，或者为了测试错误处理而强制方法抛出错误时，它非常有用。和间谍一样，桩可以是匿名的，也可以包装现有的函数。当用桩包装现有函数时，原始函数不会被调用。
- en: 'An anonymous stub can be defined as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个匿名桩可以定义为如下：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a wrapper to a method of an object, it can be defined as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对象方法的包装器，它可以定义为如下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here the function `object.method` is replaced with an anonymous stub function.
    You can also add one more function as the third parameter to the `stub()` function,
    which will work as a spy on `object.method` and will replace the original method
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数`object.method`被替换为一个匿名存根函数。你还可以将一个额外的函数作为`stub()`函数的第三个参数添加，它将作为`object.method`的间谍，并替换原始方法如下：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To understand how a spy works with a real example, we can use the same `User`
    model that we previously used. This is shown in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过一个真实示例了解间谍是如何工作的，我们可以使用之前使用的相同的`User`模型。如下代码片段所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we stub the `getNameAsArray()` method of the `User` model and return an
    empty array. So while you call the `getNameAsArray()` method, *not the method
    but the stub will get called*. We made sure that the stub returns an empty array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们存根了`User`模型的`getNameAsArray()`方法，并返回一个空数组。所以当你调用`getNameAsArray()`方法时，*不是方法而是存根将被调用*。我们确保存根返回一个空数组。
- en: Now the test is as simple as the one we did earlier. We just call the `getNameAsArray()`
    method on the `User` instance and check the length of the returned value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的测试就像我们之前做的那样简单。我们只需在`User`实例上调用`getNameAsArray()`方法，并检查返回值的长度。
- en: Testing with mocks
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模拟进行测试
- en: Mocks (and mock expectations) are fake methods (like spies) with pre-programmed
    behavior (like stubs) as well as pre-programmed expectations. A mock will fail
    your test if it is not used as expected.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模拟（以及模拟期望）是具有预编程行为（如存根）的假方法（如间谍），以及预编程的期望。如果模拟没有被按预期使用，它将使你的测试失败。
- en: This is the definition of mock as given in the `SinonJS` website ([http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks)).
    Mocks are quite similar to stubs, but they come with built-in expectations. They
    implement both the spy and stub APIs. With a mock, you define all the expectations
    that should happen in your test. When all those things are done, you assert whether
    those things happened exactly the way they were planned. So you define the expectations
    and if they aren't met, the test fails.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SinonJS`网站上给出的模拟定义([http://sinonjs.org/docs/#mocks](http://sinonjs.org/docs/#mocks))。模拟与存根非常相似，但它们自带内置的期望。它们实现了间谍和存根API。使用模拟，你可以定义测试中应该发生的所有期望。当所有这些事情都完成时，你断言这些事情是否按照计划发生。因此，你定义期望，如果它们没有满足，测试就会失败。
- en: 'Now, how do we use a mock? We mock an object, set expectations on its methods,
    and apply modifiers on these expectations. Then we verify whether the test passes
    all the expectations or not. To understand it better, let''s explore a simple
    example with mock, as shown in the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何使用模拟？我们模拟一个对象，对其方法设置期望，并对这些期望应用修饰符。然后我们验证测试是否通过了所有期望。为了更好地理解，让我们通过以下代码片段探索一个简单的模拟示例：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the same `User` model here and create a mock with a `User` instance.
    Then we set the expectation on the mock to see whether the `getNameAsArray()`
    method is called only once on that `User` instance. All these expectations are
    set beforehand and we verify them all together at the end.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用相同的`User`模型，并创建一个带有`User`实例的模拟。然后我们在模拟上设置期望，以查看`getNameAsArray()`方法是否只在该`User`实例上调用一次。所有这些期望都是事先设置的，并在最后一起验证。
- en: Difference between mocks and stubs
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟与存根的区别
- en: 'Now, because stubs and mocks are similar in functionality, you may wonder why
    and when you should use a mock instead of a stub. As given by the website, you
    would use a mock only when you want to provide both alternate functionality and
    an expectation in your test. The main difference you can see is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为存根和模拟在功能上相似，你可能会想知道为什么和何时你应该使用模拟而不是存根。根据网站上的说明，你只有在想要在测试中提供替代功能和一个期望时才使用模拟。你可以看到的主要区别如下：
- en: Mock objects are used to define expectations, that is, in a particular scenario,
    we expect the `Foo()` method to be called with a set of parameters. Mock records
    and verifies such expectations that whether the `foo()` method actually got called
    with those parameters or not.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象用于定义期望，即在特定场景中，我们期望`Foo()`方法使用一组参数被调用。模拟记录并验证这样的期望，即`foo()`方法是否实际上使用这些参数被调用。
- en: Stubs, on the other hand, have a different purpose—they do not record or verify
    expectations, but rather allow us to "replace" the behavior and the state of the
    "fake" object in order to utilize a test scenario.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，存根有不同的目的——它们不记录或验证期望，而是允许我们“替换”假对象的行为和状态，以便利用测试场景。
- en: 'To test the life cycle with stubs, proceed with the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用存根来测试生命周期，请按照以下步骤进行：
- en: 'Set up data: Prepare the object that is being tested and its stubs collaborators.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置数据：准备待测试的对象及其存根协作者。
- en: 'Exercise: Test the functionality.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习：测试功能。
- en: 'Verify state: Use asserts to check the object''s state.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证状态：使用断言来检查对象的状态。
- en: 'Teardown: Clean up the resources.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理：清理资源。
- en: 'To test the life cycle with mocks, proceed with the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模拟来测试生命周期，请按照以下步骤进行：
- en: 'Set up data: Prepare object that is being tested.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置数据：准备待测试的对象。
- en: 'Set up expectations: Prepare expectations in a mock that is being used by the
    primary object.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置期望：在主对象使用的模拟中准备期望。
- en: 'Exercise: Test the functionality.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 练习：测试功能。
- en: 'Verify expectations: Verify that correct methods have been invoked in the mock.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证期望：验证在模拟中是否调用了正确的方法。
- en: 'Verify state: Use asserts to check the object''s state.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证状态：使用断言来检查对象的状态。
- en: 'Teardown: Clean up the resources.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理：清理资源。
- en: As you can see, there are pre and post states for a mock. We set the expectation
    before the test and verify it afterwards. Anyway, the purpose of both stub and
    mock is to eliminate testing all the dependencies of a class or function so that
    your tests are more focused and simple in what they are trying to prove.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模拟有预状态和后状态。我们在测试之前设置期望，并在之后验证它。无论如何，存根和模拟的目的是消除测试一个类或函数的所有依赖项，这样你的测试就可以更加专注于它们试图证明的内容。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have included a number of books and tutorials related to `QUnit` and `SinonJS`
    in the [Appendix A](apa.html "Appendix A. Books, Tutorials, and References"),
    *Books, Tutorials, and References*. You can follow them to get a more detailed
    idea about these two technologies.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[附录A](apa.html "附录 A. 书籍、教程和参考")中包含了与`QUnit`和`SinonJS`相关的书籍和教程，*书籍、教程和参考*。你可以参考它们来获取这两个技术的更详细的信息。
- en: A few testing concepts were described in this chapter. You got an idea about
    the power of `QUnit` and `SinonJS`, and how to use them extensively to unit test
    your JavaScript application. Though that barely scratches the surface, we never
    intended to cover everything about testing in this book either. We just tried
    to make you aware of the fact that testing is an absolutely important part of
    the application development process, and you should make it a habit to write test
    cases whenever you develop. It will make your code more structured, flexible,
    and easier to use for your teammates.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了一些测试概念。你对`QUnit`和`SinonJS`的力量以及如何广泛地使用它们进行单元测试JavaScript应用程序有了了解。尽管这仅仅触及了表面，但我们也不打算在这本书中涵盖测试的所有内容。我们只是试图让你意识到测试是应用程序开发过程中的一个绝对重要的部分，你应该养成在开发时编写测试用例的习惯。这将使你的代码更加结构化、灵活，并且更容易让你的队友使用。
