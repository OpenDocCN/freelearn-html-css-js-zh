- en: Chapter 3. Building a Card-matching Game in CSS3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用CSS3构建卡牌匹配游戏
- en: '*CSS3 introduces many exciting features. In this chapter, we will explore and
    use some of them to create a card-matching game. CSS3 styles how the game objects
    look and animate, while the jQuery library helps us to define the game logic.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*CSS3引入了许多令人兴奋的特性。在本章中，我们将探索并使用其中的一些特性来创建卡牌匹配游戏。CSS3决定了游戏对象的外观和动画，而jQuery库帮助我们定义游戏逻辑。*'
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Transform a playing card with animation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画转换玩牌
- en: Flip a playing card with new CSS3 properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的CSS3属性翻转玩牌
- en: Create the whole memory matching game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建整个记忆匹配游戏
- en: Embed a custom web font to our game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的游戏中嵌入自定义的Web字体
- en: 'You can try the card-matching game at the following URL to have a glimpse of
    what we are going to achieve in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下URL尝试卡牌匹配游戏，以一窥本章我们将实现的内容：
- en: '[http://makzan.net/html5-games/card-matching/](http://makzan.net/html5-games/card-matching/)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://makzan.net/html5-games/card-matching/](http://makzan.net/html5-games/card-matching/)'
- en: So, let's get on with it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧。
- en: Moving game objects with CSS3 transition
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS3过渡移动游戏对象
- en: We had a glimpse of the CSS3 transition and transformation modules in [Chapter
    1](ch01.html "Chapter 1. Introducing HTML5 Games"), *Introducing HTML5 Games,*
    when we were overviewing the new CSS3 features. We often want to animate the game
    objects by easing the properties. Transition is the CSS property designed for
    this purpose. Suppose that we have a playing card on the web page and want to
    move it to another position in five seconds. We would have to use JavaScript to
    set up a timer and write our own function to change the position every few milliseconds.
    By using the `transition` property, we just need to specify the start and end
    styles and the duration. The browser optimizes the output and does all the easing
    and in-between animations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 介绍HTML5游戏") *介绍HTML5游戏* 中，当我们概述新的CSS3特性时，我们瞥见了CSS3的过渡和转换模块。我们经常希望通过平滑属性来动画化游戏对象。过渡是为此目的设计的CSS属性。假设我们在网页上有一个玩牌，并想在五秒内将其移动到另一个位置。我们不得不使用JavaScript设置计时器并编写自己的函数来每隔几毫秒改变位置。通过使用`transition`属性，我们只需要指定起始和结束样式以及持续时间。浏览器优化输出并完成所有缓和和中间动画。
- en: Let's take a look at some examples to understand this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例来理解这一点。
- en: Time for action – moving a playing card around
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 移动玩牌
- en: 'In this example, we will place two playing cards on a web page and transform
    them to a different position, scale, and rotation. We will tween the transformation
    by setting the transition:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将把两张玩牌放置在网页上，并将它们转换到不同的位置、缩放和旋转。我们将通过设置过渡来缓动转换：
- en: To do this, create a new project folder with the following hierarchy. The `css3transition.css`
    and `index.html` files are empty now and we will add the code later. The `jquery-2.1.3.min.js`
    file is the jQuery library that we used in the previous chapter.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，创建一个新的项目文件夹，其结构如下。`css3transition.css`和`index.html`文件目前是空的，我们将在稍后添加代码。`jquery-2.1.3.min.js`文件是我们之前章节中使用的jQuery库。
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are using two playing card graphic images in this example. They are `AK.png`
    and `AQ.png`. The images are available in the code bundle or you can download
    them from the book assets website at [http://mak.la/book-assets/](http://mak.la/book-assets/).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了两个玩牌图形图像。它们是`AK.png`和`AQ.png`。这些图像可在代码包中找到，或者您可以从书籍资产网站上下载它们：[http://mak.la/book-assets/](http://mak.la/book-assets/)。
- en: Put the two card images inside the `images` folder.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两张牌图像放入`images`文件夹中。
- en: 'The next thing is to code the HTML with two card DIV elements. We will apply
    CSS transition style to these two cards elements when the page is loaded:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是编写带有两个卡牌DIV元素的HTML代码。当页面加载时，我们将对这些两个卡牌元素应用CSS过渡样式：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is time to define the visual styles of the playing cards via CSS. This contains
    basic CSS 2.1 properties and CSS3''s new properties. In the following code, the
    new CSS3 properties are highlighted:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候通过CSS定义玩牌的视觉样式了。这包括基本的CSS 2.1属性和CSS3的新属性。在以下代码中，新的CSS3属性被突出显示：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's save all the files and open the `index.html` file in the browser. The
    two cards should animate as shown in the following screenshot:![Time for action
    – moving a playing card around](img/B04290_03_01.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们保存所有文件并在浏览器中打开`index.html`文件。两张牌应该像以下截图所示那样动画化：![行动时间 – 移动玩牌](img/B04290_03_01.jpg)
- en: '*What just happened?*'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just created two animation effects by using the CSS3 transition to tween
    the `transform` property.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 CSS3 过渡来插值 `transform` 属性，创建了两个动画效果。
- en: 'Here is the usage of CSS transform:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 CSS transform 的用法：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The arguments of the `transform` property are functions. There are two sets
    of functions: the 2D and 3D transform functions. **CSS transform** functions are
    designed to move, scale, rotate, and skew the target DOM elements. The following
    sections show the usage of the transform functions.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform` 属性的参数是函数。有两组函数：2D 和 3D 变换函数。**CSS transform** 函数旨在移动、缩放、旋转和倾斜目标
    DOM 元素。以下部分展示了变换函数的用法。'
- en: 2D transform functions
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D 变换函数
- en: 'The 2D `rotate` function rotates the element clockwise on a given positive
    argument and counter-clockwise on a given negative argument:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 2D `rotate` 函数在给定的正参数上顺时针旋转元素，在给定的负参数上逆时针旋转元素：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `translate` function moves the element by the given *x* and *y* displacement:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`translate` 函数通过给定的 *x* 和 *y* 位移来移动元素：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can translate the *x* or *y* axis independently by calling the `translateX`
    and `translateY` function as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `translateX` 和 `translateY` 函数独立地平移 *x* 或 *y* 轴，如下所示：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `scale` function scales the element by the given `sx` and `sy` vectors.
    If we only pass the first argument, then `sy` will be of the same value as `sx`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale` 函数通过给定的 `sx` 和 `sy` 向量来缩放元素。如果我们只传递第一个参数，那么 `sy` 将与 `sx` 具有相同的值：'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In addition, we can independently scale the *x* and *y* axis as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以独立地缩放 *x* 和 *y* 轴，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 3D transform functions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D 变换函数
- en: 'The 3D rotation function rotates the element in 3D space by the given [x, y,
    z] unit vector. For example, we can rotate the *y* axis 60 degrees by using `rotate3d(0,`
    `1,` `0,` `60deg)`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 旋转函数通过给定的 [x, y, z] 单位向量在 3D 空间中旋转元素。例如，我们可以通过使用 `rotate3d(0,` `1,` `0,`
    `60deg)` 来旋转 *y* 轴 60 度：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also rotate one axis only by calling the following handy functions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过调用以下便捷函数仅旋转一个轴：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similar to the 2D `translate` function, `translate3d` allows us to move the
    element in all the three axes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与 2D `translate` 函数类似，`translate3d` 允许我们在三个轴上移动元素：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, the `scale3d` scales the element in the 3D spaces:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`scale3d` 在 3D 空间中缩放元素：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `transform` functions that we just discussed are common, and we will use
    them many times. There are several other `transform` functions that are not discussed;
    they are `matrix`, `skew`, and `perspective`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的 `transform` 函数是常见的，我们将多次使用它们。还有一些其他未讨论的 `transform` 函数，它们是 `matrix`、`skew`
    和 `perspective`。
- en: 'If you want to find the latest CSS Transforms working spec, you can visit the
    W3C website of CSS Transforms Modules at: [http://www.w3.org/TR/css3-3d-transforms/](http://www.w3.org/TR/css3-3d-transforms/).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想找到最新的 CSS 变换工作规范，你可以访问 W3C CSS 变换模块网站：[http://www.w3.org/TR/css3-3d-transforms/](http://www.w3.org/TR/css3-3d-transforms/)。
- en: Tweening the styles using CSS3 transition
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CSS3 过渡插值样式
- en: There are tons of new features in CSS3\. Transition module is one among them
    that affects us most in game designing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3 中有大量新特性。过渡模块是其中之一，它对游戏设计影响最大。
- en: 'What is **CSS3 transition**? W3C explains it in one sentence:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 **CSS3 过渡**？W3C 用一句话解释它：
- en: '*CSS transitions allows property changes in CSS values to occur smoothly over
    a specified duration.*'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*CSS 过渡允许 CSS 值在指定的时间内平滑地改变。*'
- en: Normally, when we change any properties of the element, the properties are updated
    to the new value immediately. Transition slows down the changing process. It creates
    smooth in-between easing from the old value towards the new value in the given
    duration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们更改元素的任何属性时，属性会立即更新到新值。过渡会减慢变化过程。它在给定的时间内创建从旧值到新值的平滑过渡。
- en: 'Here is the usage of the `transition` property:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `transition` 属性的用法：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following table explains each of the parameters used in the `transition`
    property:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下表解释了在 `transition` 属性中使用的每个参数：
- en: '| Argument | Definition |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `property_name` | This is the name of the property where the transition applies.
    It can be set to `all`. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `property_name` | 这是应用过渡的属性名称。它可以设置为 `all`。 |'
- en: '| `duration` | This is the duration that the transition takes. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `duration` | 这表示过渡所需要的时间。 |'
- en: '| `timing_function` | The `timing` function defines the interpolation between
    the start and end values. The default value is `ease`. Normally, we will use `ease`,
    `ease-in`, `ease-out`, and `linear`. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `timing_function` | `timing`函数定义了起始值和结束值之间的插值。默认值是`ease`。通常，我们会使用`ease`、`ease-in`、`ease-out`和`linear`。|'
- en: '| `delay` | The `delay` argument delays the start of the transition by the
    given seconds. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `delay` | `delay`参数将过渡的开始延迟给定秒数。|'
- en: 'We can put several `transition` properties in one line. For example, the following
    code transitions the opacity in 0.3 seconds and background color in 0.5 seconds:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一行中放置多个`transition`属性。例如，以下代码在0.3秒内过渡不透明度，在0.5秒内过渡背景颜色：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also define each transition property individually by using the following
    properties:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过以下属性单独定义每个过渡属性：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Modules of CSS3**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSS3模块**'
- en: According to W3C, CSS3 is unlike CSS 2.1 in that there is only one CSS 2.1 spec.
    CSS3 is divided into different modules. Each module is reviewed individually.
    For example, there is a transition module, 2D/3D transforms module, and the Flexible
    Box Layout module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据W3C的说法，CSS3与CSS 2.1不同，因为CSS 2.1只有一个规范。CSS3被划分为不同的模块。每个模块都是单独审查的。例如，有一个过渡模块、2D/3D转换模块和弹性盒子布局模块。
- en: The reason for dividing the spec into modules is because the pace at which the
    work of each part of the CSS3 progresses is not the same. Some CSS3 features are
    rather stable, such as border radius, while some have not yet settled down. Dividing
    the whole spec into different parts allows the browser vendor to support modules
    that are stable. In this scenario, slow-paced features will not slow down the
    whole spec. The aim of the CSS3 spec is to standardize the most common visual
    usage in web designing and this module fits this aim.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将规范划分为模块的原因是因为CSS3各部分的进展速度并不相同。一些CSS3特性相对稳定，例如边框半径，而一些尚未稳定。将整个规范划分为不同的部分允许浏览器厂商支持稳定的模块。在这种情况下，进展缓慢的特性不会减慢整个规范的进展。CSS3规范的目标是标准化网络设计中最常见的视觉用法，而这个模块符合这一目标。
- en: Have a go hero
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We have translated, scaled, and rotated the playing cards. How about we try
    to change different values in the example? There are three axes in the `rotate3d`
    function. What will happen if we rotate the other axis? Experiment with the code
    yourself to get familiar with the transform and transition modules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对扑克牌进行了平移、缩放和旋转。那么我们尝试在示例中更改不同的值如何？`rotate3d`函数中有三个轴。如果我们旋转其他轴会发生什么？通过自己实验代码来熟悉转换和过渡模块。
- en: Creating a card-flipping effect
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建翻牌效果
- en: Imagine now that we are not just moving the playing card around, but we also
    want to flip the card element, just like we flip a real playing card. By using
    the `rotation` `transform` function, it is now possible to create the card-flipping
    effect.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们现在不仅要在周围移动扑克牌，还想翻转卡片元素，就像我们翻转一张真实的扑克牌一样。通过使用`rotation` `transform`函数，现在可以创建翻牌效果。
- en: Time for action – flipping a card with CSS3
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用CSS3翻转卡片
- en: 'We are going to start a new project and create a card-flipping effect when
    we click on the playing card:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始一个新的项目，并在点击扑克牌时创建翻牌效果：
- en: Let's continue with our previous code example.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用之前的代码示例。
- en: 'The card now contains two faces: a front face and a back face. Replace the
    following code in the `body` tag in the HTML code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在卡片包含两个面：正面和背面。在HTML代码的`body`标签中替换以下代码：
- en: '[PRE16]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, create a new `css3flip.css` file in the `css` folder to test the flipping
    effect.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`css`文件夹中创建一个新的`css3flip.css`文件来测试翻转效果。
- en: 'In the `index.html` file, change the CSS external link to the `css3flip.css`
    file:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，将CSS外部链接更改为`css3flip.css`文件：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s add the styles to the `css3flip.css`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们向`css3flip.css`添加样式：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are two faces on each card. We are going to slowly rotate the face of
    the card. Therefore, we define how the face transitions by CSS3''s `transition`
    property. We also hide the back face''s visibility. We will look at the detail
    of this property later:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每张卡片都有两个面。我们将逐渐旋转卡片的面。因此，我们通过CSS3的`transition`属性定义面的过渡。我们还隐藏了背面可见性。我们稍后会看到这个属性的详细内容：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, it is time to style each individual face. The front face has a higher
    z-index than the back face:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候为每个单独的面添加样式了。正面比背面有更高的z-index：
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we flip the card, we rotate the front face to the back and the back face
    to the front. We also swap the z-index of the front and back faces:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们翻转卡片时，我们将正面旋转到背面，将背面旋转到正面。我们还交换了正面和背面的z-index：
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will add logic after loading the jQuery library to toggle the card-flipped
    status when we click on the card:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在加载jQuery库后添加逻辑，以便在点击卡片时切换卡片翻转状态：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The styles and the scripts are now ready. Let's save all the files and preview
    it in our web browser. Click on the playing card to flip it over, and click on
    it again to flip it back.![Time for action – flipping a card with CSS3](img/B04290_03_02.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式和脚本现在都已准备好。让我们保存所有文件，并在我们的网页浏览器中预览。点击玩牌来翻转它，再点击一次来翻转回来。![动作时间 – 使用CSS3翻转卡片](img/B04290_03_02.jpg)
- en: '*What just happened?*'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have created a card-flipping effect that can be toggled by a mouse click.
    You can try out the example at [http://makzan.net/html5-games/simple-card-flip/](http://makzan.net/html5-games/simple-card-flip/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个可以通过鼠标点击切换的卡片翻转效果。你可以在[http://makzan.net/html5-games/simple-card-flip/](http://makzan.net/html5-games/simple-card-flip/)上尝试该示例。
- en: The example made use of several CSS transform properties and JavaScript to handle
    the mouse click event.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用了多个CSS转换属性和JavaScript来处理鼠标点击事件。
- en: Toggling a class with jQuery's toggleClass function
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery的toggleClass函数切换类
- en: We apply the `card-flipped` class to the card element when the mouse is clicked
    on the card. On the second click, we want to remove the applied card-flipped style
    so that the card flips back again. This is called **toggling a class** style.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标点击卡片时，我们将`card-flipped`类应用到卡片元素上。在第二次点击时，我们希望移除应用的`card-flipped`样式，以便卡片再次翻转。这被称为**切换类**样式。
- en: jQuery provides us with a handy function named `toggleClass` to add or remove
    classes automatically, depending on whether the class is applied or not.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了一个方便的函数`toggleClass`，可以根据类是否应用来自动添加或移除类。
- en: To use the function, we simply pass the classes that we want to toggle as an
    argument.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该函数，我们只需将想要切换的类作为参数传递。
- en: 'For example, the following code adds or removes the `card-flipped` class to
    an element with the ID as `card1`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码为ID为`card1`的元素添加或移除`card-flipped`类：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `toggleClass` function accepts the toggle instruction from more than one
    class at the same time. We can pass in several class names and separate them by
    using a space. Here is an example of toggling two classes at the same time:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggleClass`函数可以同时接受多个类的切换指令。我们可以传入多个类名，并用空格分隔它们。以下是一个同时切换两个类的示例：'
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Introducing CSS' perspective property
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍CSS的perspective属性
- en: CSS3 lets us present elements in 3D, and we have been able to transform the
    elements in the 3D space. The `perspective` property defines how the 3D perspective
    view looks. You can treat the value as far as you are looking at the object. The
    closer you are, the more perspective distortion there is on the viewing object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3让我们能够在3D空间中呈现元素，并且我们已经能够将元素在3D空间中转换。`perspective`属性定义了3D视角视图的外观。你可以将值视为你观察对象时的距离。你越靠近，观察对象上的透视扭曲就越多。
- en: 'The following two 3D cubes demonstrate how different perspective values change
    the perspective view of the element:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个3D立方体演示了不同的视角值如何改变元素的视角：
- en: '![Introducing CSS'' perspective property](img/B04290_03_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![介绍CSS的perspective属性](img/B04290_03_03.jpg)'
- en: Have a go hero
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下
- en: The cube is created by putting six faces together with 3D transforms applied
    to each face. It used the techniques that we've discussed. Try to create a cube
    and experiment with the `perspective` property.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体是通过将六个面放在一起并应用每个面的3D转换来创建的。它使用了我们讨论过的技术。尝试创建一个立方体并实验一下`perspective`属性。
- en: 'The following web page gives a comprehensive explanation on creating the CSS3
    cube, and it also explains how to control the rotation of the cube with the keyboard:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下网页对创建CSS3立方体的过程进行了全面解释，并说明了如何使用键盘控制立方体的旋转：
- en: '[http://paulrhayes.com/experiments/cube-3d/](http://paulrhayes.com/experiments/cube-3d/)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://paulrhayes.com/experiments/cube-3d/](http://paulrhayes.com/experiments/cube-3d/)'
- en: Introducing backface-visibility
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍backface-visibility属性
- en: Before the `backface-visibility` property was introduced, all the elements on
    the page presented their front face to the visitor. Actually, there was no concept
    of the front face or the back face of the element because presenting the front
    face was the only choice. While CSS3 introduces the rotation in three axes, we
    can rotate an element so that its face is on the back. Try looking at your palm
    and rotating your wrist, your palm turns and you see the back of your palm. This
    happens to the rotated elements too.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`backface-visibility`属性被引入之前，页面上的所有元素都向访客展示了它们的正面。实际上，元素的前面或背面没有概念，因为展示正面是唯一的选择。当CSS3引入了三轴旋转时，我们可以旋转一个元素，使其面朝后。试着看看你的手掌，然后旋转你的手腕，你的手掌转动，你看到了手掌的背面。旋转的元素也会发生这种情况。
- en: 'CSS3 introduces a property named `backface-visibility` to define whether or
    not we can see the back face of the element. By default, it is visible. The following
    figure demonstrates the two different behaviors of the `backface-visibility` property:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3引入了一个名为`backface-visibility`的属性来定义我们是否可以看到元素的背面。默认情况下，它是可见的。以下图示展示了`backface-visibility`属性的两种不同行为：
- en: '![Introducing backface-visibility](img/B04290_03_04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![介绍背面可见性](img/B04290_03_04.jpg)'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more detailed information about different properties and functions
    in CSS 3D transforms on its official Webkit blog at [http://webkit.org/blog/386/3d-transforms/](http://webkit.org/blog/386/3d-transforms/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在其官方Webkit博客上阅读有关CSS 3D变换中不同属性和函数的更详细的信息：[http://webkit.org/blog/386/3d-transforms/](http://webkit.org/blog/386/3d-transforms/)。
- en: Creating a card-matching memory game
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个卡牌匹配记忆游戏
- en: We have gone through some basic techniques in CSS. Now, let's make a game using
    the techniques. We are going to make a card game. The card game will make use
    of transform to flip the card, transition to move the card, JavaScript to hold
    the logic, and a new HTML5 feature called **custom data attribute** to store custom
    data. Don't worry, we will discuss each component step by step.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了一些基本的CSS技术。现在，让我们使用这些技术来制作一个游戏。我们将制作一个卡牌游戏。这个卡牌游戏将使用变换来翻转卡片，使用过渡来移动卡片，使用JavaScript来处理逻辑，以及使用一个新的HTML5特性，称为**自定义数据属性**来存储自定义数据。不用担心，我们将逐步讨论每个组件。
- en: Downloading the sprite sheet of playing cards
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载牌的精灵图
- en: In the card-flipping example, we were using the graphics of two different playing
    cards. Now, we will prepare graphics for the whole deck of playing cards. Although
    we will only use six playing cards in the matching game, we will prepare the whole
    deck so that we can reuse these graphics in other card games that we may create.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡牌翻转示例中，我们使用了两张不同牌的图形。现在，我们将为整副牌准备图形。虽然我们在匹配游戏中只会使用六张牌，但我们仍会准备整副牌，这样我们就可以在其他可能创建的卡牌游戏中重用这些图形。
- en: There are 52 playing cards in a deck and we have one more graphic for the backside.
    Instead of using 53 separate files, it is good practice to put separate graphics
    into one big sprite sheet file. Sprite sheet is a graphics technique that loads
    one graphic's texture into memory and displays part of the graphics for each game
    component.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一副牌中有52张牌，我们还有一个用于背面的图形。与其使用53个单独的文件，不如将单独的图形放入一个大的精灵图文件中。精灵图是一种图形技术，它将一个图形的纹理加载到内存中，并为每个游戏组件显示图形的一部分。
- en: One benefit of using a big sprite sheet instead of separate image files is that
    we can reduce the amount of **HTTP requests**. When the browser loads the web
    page, it creates a new HTTP request to load each external resource, including
    JavaScript files, CSS files, and images. It takes quite a lot of time to establish
    a new HTTP request for each separated small file. Combining the graphics into
    one file, greatly reduces the amount of requests and thus improves the responsiveness
    of the game when it is loading in the browser.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大精灵图而不是单独的图像文件的一个好处是我们可以减少HTTP请求的数量。当浏览器加载网页时，它会创建一个新的HTTP请求来加载每个外部资源，包括JavaScript文件、CSS文件和图像。为每个分离的小文件建立新的HTTP请求需要相当多的时间。将图形组合到一个文件中，大大减少了请求的数量，从而提高了游戏在浏览器中加载时的响应速度。
- en: Another benefit of placing graphics in one file is to avoid the overhead of
    the file format header and reduce the amount of HTTP requests. The time to load
    a sprite sheet with 53 images is faster than loading 53 different images with
    the file header in each file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将图形放在一个文件中的另一个好处是避免文件格式标题的开销并减少HTTP请求的数量。加载包含53个图像的精灵图的时间比加载53个不同图像（每个文件都有文件标题）的时间要快。
- en: The following deck of playing cards' graphics is drawn and aligned in Adobe
    Illustrator. You can download it from [http://mak.la/deck.png](http://mak.la/deck.png).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一副扑克牌的图形是在Adobe Illustrator中绘制并对齐的。您可以从[http://mak.la/deck.png](http://mak.la/deck.png)下载它。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can create your own sprite sheet with Instant Sprite Generator ([http://instantsprite.com](http://instantsprite.com)).
    The article at [http://css-tricks.com/css-sprites/](http://css-tricks.com/css-sprites/)
    explains in detail why and how we can create and use the CSS sprite sheet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Instant Sprite Generator ([http://instantsprite.com](http://instantsprite.com))创建自己的精灵图集。在[http://css-tricks.com/css-sprites/](http://css-tricks.com/css-sprites/)上的文章详细解释了为什么以及如何创建和使用CSS精灵图集。
- en: '![Downloading the sprite sheet of playing cards](img/B04290_03_05.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![下载扑克牌精灵图](img/B04290_03_05.jpg)'
- en: Setting up the game environment
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置游戏环境
- en: 'Once the graphics are ready, we will need to set up a static page with the
    game objects that are prepared and placed on the game area. It is then easier
    to add game logic and interaction later:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图形准备就绪，我们需要设置一个静态页面，其中包含准备好的并放置在游戏区域中的游戏对象。这样，稍后添加游戏逻辑和交互就更容易了：
- en: Time for action – preparing the card-matching game
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 准备卡片匹配游戏
- en: 'Before adding the complicated game logic to our matching game, let''s prepare
    the HTML game structure and all the CSS styles:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在向我们的匹配游戏添加复杂的游戏逻辑之前，让我们准备HTML游戏结构和所有CSS样式：
- en: Let's continue with our project. Create a new file named `matchgame.js` inside
    the `js` folder.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续我们的项目。在`js`文件夹内创建一个名为`matchgame.js`的新文件。
- en: 'Replace the `index.html` file with the following HTML code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`index.html`文件替换为以下HTML代码：
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In order to make the game more appealing, I prepared background images for the
    game table and the page. These graphic assets can be found in the code example
    bundle. The background images are optional, and they will not affect the gameplay
    and the logic of the matching game.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使游戏更具吸引力，我准备了游戏桌和页面的背景图像。这些图形资产可以在代码示例包中找到。背景图像是可选的，它们不会影响游戏玩法和匹配游戏的逻辑。
- en: We will also place the deck's sprite sheet graphics into the images folder.
    Then, we will download the `deck.png` file from [http://mak.la/deck.png](http://mak.la/deck.png)
    and save it within the images folder.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将扑克牌的精灵图集图形放入图像文件夹。然后，我们将从[http://mak.la/deck.png](http://mak.la/deck.png)下载`deck.png`文件，并将其保存在图像文件夹中。
- en: Create a dedicated CSS file named `matchgame.css` for our game and put it inside
    the `css` folder.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的游戏创建一个专门的CSS文件，命名为`matchgame.css`，并将其放入`css`文件夹中。
- en: 'Now, let''s add style to the matching game before writing any logic. Open `matchgame.css`
    and add the following body styles:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们编写任何逻辑之前，让我们为匹配游戏添加样式。打开`matchgame.css`并添加以下body样式：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will continue to add the styles to the `game` element. This will be the
    main area of the game:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续为`game`元素添加样式。这将游戏的主要区域：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will put all card elements into a parent DOM named `cards`. By doing this,
    we can easily center all the cards in the game area:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将所有卡片元素放入一个名为`cards`的父DOM中。通过这样做，我们可以轻松地将所有卡片在游戏区域中居中：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For each card, we define a `perspective` property to give it a visual depth
    effect:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每张卡片，我们定义一个`perspective`属性来给它一个视觉深度效果：
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are two faces on each card. The back face will be rotated later, and
    we will define the transition properties to animate the style changes. We also
    want to make sure that the back face is hidden:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每张卡片有两个面。背面将在稍后旋转，我们将定义过渡属性来动画化样式变化。我们还想确保背面是隐藏的：
- en: '[PRE30]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we will set the styles for the front and back faces. They are almost the
    same as the flipping card example, except that we are now giving them background
    images and box shadows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置正面和背面的样式。它们几乎与翻牌示例相同，除了我们现在为它们提供背景图像和阴影盒：
- en: '[PRE31]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When any card is removed, we want it to fade out. Therefore, we declare a card-removed
    class with 0 opacity:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当任何卡片被移除时，我们希望它淡出。因此，我们声明一个具有0不透明度的`card-removed`类：
- en: '[PRE32]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to show different playing card graphics from the sprite sheet of the
    card deck, we clip the background of the card into different background positions:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从扑克牌图集的精灵图中显示不同的扑克牌图形，我们将卡片的背景裁剪到不同的背景位置：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have defined a lot of CSS styles. It is now time for JavaScript''s logic.
    We will open the `js/matchgame.js` file and put the following code inside:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了很多CSS样式。现在是时候为JavaScript的逻辑编写代码了。我们将打开`js/matchgame.js`文件，并在其中放入以下代码：
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, we will save all the files and preview the game in the browser. The game
    should be well styled, and 12 cards should appear in the center. However, we cannot
    click on the cards yet because we have not set any interaction logic for the cards.![Time
    for action – preparing the card-matching game](img/B04290_03_06.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将保存所有文件并在浏览器中预览游戏。游戏应该样式良好，并且应该有 12 张卡片出现在中央。然而，我们目前还不能点击卡片，因为我们还没有为卡片设置任何交互逻辑。![行动时间
    – 准备卡片匹配游戏](img/B04290_03_06.jpg)
- en: '*What just happened?*'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created the game structure in HTML and applied styles to the HTML elements.
    You can find the working example of the game with the current progress at [http://makzan.net/html5-games/card-matching-wip-step1/](http://makzan.net/html5-games/card-matching-wip-step1/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 HTML 中创建了游戏结构，并应用了样式到 HTML 元素上。您可以在 [http://makzan.net/html5-games/card-matching-wip-step1/](http://makzan.net/html5-games/card-matching-wip-step1/)
    找到当前进度下游戏的运行示例。
- en: We also used jQuery to create 12 cards on the game area once the web was loaded
    and ready. The styles to flip and remove the cards were also prepared and will
    be applied to the card by using the game logic later.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当网页加载并准备就绪后，我们也使用了 jQuery 在游戏区域创建 12 张卡片。翻动和移除卡片的效果样式也已准备就绪，稍后将通过游戏逻辑应用到卡片上。
- en: 'Since we are using absolute positioning for each card, we need to align the
    cards into 4x3 tiles ourselves. In the JavaScript logic, we loop through each
    card and align it by calculating the position with the looping index:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为每个卡片使用绝对定位，因此需要我们自己将卡片对齐成 4x3 的瓷砖。在 JavaScript 逻辑中，我们通过循环遍历每个卡片，通过计算循环索引来对齐它：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The % character in JavaScript is the **modulus operator** that returns the
    remainder left after division. The remainder is used to get the column count when
    we loop the cards. The following diagram shows the row/column relationship with
    the index number:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的 % 符号是 **取模运算符**，它返回除法后的余数。余数用于在循环卡片时获取列数。以下图表显示了索引号与行/列之间的关系：
- en: '![What just happened?](img/B04290_03_07.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_03_07.jpg)'
- en: The division, on the other hand, is used to get the row count so that we can
    position the card on the corresponding row.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，除法用于获取行数，这样我们就可以将卡片定位在相应的行上。
- en: Take index 3 as an example; 3 % 4 is 3\. So, the card at index 3 is on the third
    column. And 3 / 4 is 0, so it is on the first row.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以索引 3 为例；3 % 4 等于 3。因此，索引 3 的卡片位于第三列。而 3 / 4 等于 0，所以它位于第一行。
- en: Let's pick another number to see how the formula works. Let's see index 8; 8
    % 4 is 0, and it is on the first column. 8 / 4 is 2 so it is on the third row.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择另一个数字来看看公式是如何工作的。让我们看看索引 8；8 % 4 等于 0，它位于第一列。8 / 4 等于 2，所以它位于第三行。
- en: Cloning DOM elements with jQuery
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jQuery 克隆 DOM 元素
- en: 'In our HTML structure, we only have one card and in the result, we have 12
    cards. This is because we used the `clone` function in jQuery to clone the card
    element. After cloning the target element, we called the `appendTo` function to
    append the cloned card element as a child in the cards element:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 HTML 结构中，我们只有一个卡片，而在结果中我们有 12 张卡片。这是因为我们使用了 jQuery 中的 `clone` 函数来克隆卡片元素。在克隆目标元素后，我们调用了
    `appendTo` 函数将克隆的卡片元素作为子元素添加到卡片元素中：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Selecting the first child of an element in jQuery using child filters
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子元素过滤器在 jQuery 中选择元素的第一个子元素
- en: 'When we selected the card element and cloned it, we used the following selector:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择卡片元素并克隆它时，我们使用了以下选择器：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `:first-child` filter is a **child filter** that selects the first child
    of the given parent element.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`:first-child` 过滤器是一个 **子元素过滤器**，它选择给定父元素的第一个子元素。'
- en: Besides `:first-child`, we can also select the last child by using `:last-child`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `:first-child`，我们还可以通过使用 `:last-child` 来选择最后一个子元素。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also check other child-related selectors on the jQuery document at:
    [http://api.jquery.com/category/selectors/child-filter-selectors/](http://api.jquery.com/category/selectors/child-filter-selectors/).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 jQuery 文档中检查其他与子元素相关的选择器：[http://api.jquery.com/category/selectors/child-filter-selectors/](http://api.jquery.com/category/selectors/child-filter-selectors/)。
- en: Vertically aligning a DOM element
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直对齐 DOM 元素
- en: 'We put the cards DIV in the center of the game element. **CSS3 flexible box
    layout module** introduces an easy method to achieve the **vertical center alignment**,
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将卡片 DIV 放在游戏元素的中央。**CSS3 弹性盒布局模块**引入了一种简单的方法来实现 **垂直居中对齐**，如下所示：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The flexible box module defines the alignment of the element when there are
    extra spaces in the container. We can set the element to certain behaviors as
    a flexible box container by using the display, a CSS2 property, with the `box`
    value, and a new CSS3 property value.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性盒子模块定义了容器中有额外空间时元素的排列。我们可以通过使用CSS2属性`display`，并设置为`box`值，以及一个新的CSS3属性值，将元素设置为灵活盒子容器的特定行为。
- en: '`justify-content` and `align-items` are two properties to define how it aligns
    and uses the extra free space horizontally and vertically. We can center the element
    by setting both properties to `center`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`justify-content`和`align-items`是两个属性，用于定义如何对齐以及水平和垂直方向上如何使用额外的空闲空间。我们可以通过将这两个属性都设置为`center`来居中元素。'
- en: Vertical alignment is just a small part of the flexible box layout module. It
    is very powerful when you make layouts in web design. You may find further information
    on the W3C page of the module ([http://www.w3.org/TR/css3-flexbox/](http://www.w3.org/TR/css3-flexbox/))
    or the CSS3 tricks website ([http://css-tricks.com/snippets/css/a-guide-to-flexbox/](http://css-tricks.com/snippets/css/a-guide-to-flexbox/)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直对齐只是弹性盒子布局模块的一部分。在网页设计中制作布局时，它非常强大。你可以在W3C模块页面（[http://www.w3.org/TR/css3-flexbox/](http://www.w3.org/TR/css3-flexbox/））或CSS3技巧网站上找到更多关于该模块的信息（[http://css-tricks.com/snippets/css/a-guide-to-flexbox/](http://css-tricks.com/snippets/css/a-guide-to-flexbox/））。
- en: Using CSS sprite with a background position
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CSS精灵和背景位置
- en: The CSS sprite sheet is a big image that contains many individual graphics.
    The big sprite sheet image is applied as the background image for the elements.
    We can clip each graphic out by moving the background position to a fixed width
    and height element.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: CSS精灵表是一个包含许多单独图形的大图像。大精灵表图像被应用于元素的背景图像。我们可以通过将背景位置移动到固定宽度和高度的元素中，来裁剪出每个图形。
- en: 'Our deck''s image contains a total of 53 graphics. In order to demonstrate
    the background position easily, let''s assume that we have an image that contains
    three card images, as shown in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们牌组的图像包含总共53个图形。为了更容易地演示背景位置，让我们假设我们有一个包含三张牌图像的图像，如下面的截图所示：
- en: '![Using CSS sprite with a background position](img/B04290_03_08.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS精灵和背景位置](img/B04290_03_08.jpg)'
- en: 'In the CSS style, we set the card element to a width of 80 px and a height
    of 120 px, with the background image set to the big deck image. If we want the
    top-left graphic, we change the values of both the *x* and *y* axes of the background
    position to 0\. If we want the second graphic, we move the background image 80px
    to the left. This means setting the X position to `-80px` and Y to 0\. Since we
    have a fixed width and height, only the clipped 80 x 120 area shows the background
    image. The rectangle in the following screenshot shows the viewable area:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS样式表中，我们将卡片元素设置为宽度80像素和高度120像素，并将背景图像设置为大牌组图像。如果我们想要左上角的图形，我们将背景位置中*x*轴和*y*轴的值都设置为0。如果我们想要第二个图形，我们将背景图像向左移动80像素。这意味着将X位置设置为`-80px`，Y位置设置为0。由于我们有一个固定的宽度和高度，只有裁剪的80
    x 120区域显示了背景图像。以下截图中的矩形显示了可查看区域：
- en: '![Using CSS sprite with a background position](img/B04290_03_09.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS精灵和背景位置](img/B04290_03_09.jpg)'
- en: Adding game logic to the matching game
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将游戏逻辑添加到匹配游戏中
- en: Let's now imagine holding a real deck in our hand and setting up the matching
    game.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下，我们手中拿着一副真实的牌，并设置匹配游戏。
- en: We would first shuffle the cards in our hands and then we would put each card
    on the table with the back facing up. For an easier gameplay, we align the cards
    into a 4 x 3 array. Now, the game is set up and we are going to play it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在我们的手中洗牌，然后将每张牌背面朝上放在桌子上。为了使游戏更容易进行，我们将牌排列成4 x 3的数组。现在，游戏已经设置好了，我们准备开始玩。
- en: We pick up one card and flip it to make it face up. We pick another one and
    face it upwards. Afterwards, we have two possible actions. We take away the two
    cards if they have the same pattern. Otherwise, we put them back facing down,
    as if we had not touched them. The game continues until we pair all of the cards.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拿起一张牌并翻转它使其正面朝上。我们再拿起一张牌并使其向上。之后，我们有两种可能的行为。如果两张牌的图案相同，我们就拿走这两张牌。否则，我们将它们放回背面朝下，就像我们从未触摸过它们一样。游戏继续进行，直到我们配对所有的牌。
- en: The code flow will be much clearer after we have this step-by-step scenario
    in our mind. Actually, the code in this example is exactly the same as the procedure
    we play with a real deck. We just need to replace the human language into the
    JavaScript code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们心中有了这个逐步场景之后，代码流程将更加清晰。实际上，这个例子中的代码与我们用真实牌玩的过程完全相同。我们只需要将人类语言替换成 JavaScript
    代码。
- en: Time for action – adding game logic to the matching game
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 向配对游戏添加游戏逻辑
- en: 'We have prepared the game environment in the last example and decided the game
    logic should be the same as playing a real deck. It is time to code the JavaScript
    logic now:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们已经准备好了游戏环境，并决定游戏逻辑应该与玩一副真实的牌相同。现在是时候编写 JavaScript 逻辑了：
- en: Let's begin from our last matching game example. We have styled the CSS, and
    now, it is time to add the game logic in the `js/matchgame.js` file.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从我们最后的配对游戏示例开始。我们已经设置了 CSS，现在，是时候在 `js/matchgame.js` 文件中添加游戏逻辑了。
- en: 'The game is to match pairs of playing cards. We have 12 cards now, so we need
    six pairs of playing cards. Put the following code in the `js/matchgame.js` file.
    The array declares six pairs of card patterns:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏是要匹配一副扑克牌的配对。我们现在有 12 张牌，所以我们需要六对扑克牌。将以下代码放入 `js/matchgame.js` 文件中。数组声明了六对卡片模式：
- en: '[PRE39]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We aligned the cards in jQuery''s `ready` function in the previous chapter.
    Now we need to prepare and initialize more code in the `ready` function. To do
    this, change the `ready` function into the following code. The changed code is
    highlighted here:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一章的 jQuery 的 `ready` 函数中排列了卡片。现在我们需要在 `ready` 函数中准备和初始化更多的代码。为此，将 `ready`
    函数更改为以下代码。更改后的代码在此处突出显示：
- en: '[PRE40]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Similar to playing a real deck, the first thing we want to do is shuffle the
    deck. To do this, we need to add the following `shuffle` function to the JavaScript
    file:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与玩一副真实的牌类似，我们首先想做的事情是洗牌。为此，我们需要在 JavaScript 文件中添加以下 `shuffle` 函数：
- en: '[PRE41]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we click on the card, we flip it and schedule the checking function. So,
    we must append the following codes to the JavaScript file:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们点击卡片时，我们翻转它并安排检查函数。因此，我们必须将以下代码附加到 JavaScript 文件中：
- en: '[PRE42]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When two cards are opened, the following function is executed. It controls
    whether we remove the card or flip it back:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两张卡片被打开时，以下函数被执行。它控制我们是否移除卡片或将其翻转回来：
- en: '[PRE43]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is time for the pattern-checking function. The following function accesses
    the custom pattern attribute of the opened cards and compares them to see whether
    they are in the same pattern:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是模式检查函数的时间。以下函数访问打开卡片的自定义模式属性，并将它们进行比较，看它们是否属于同一模式：
- en: '[PRE44]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After the matched cards fade out, we execute the following function to remove
    the cards:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配的卡片淡出后，我们执行以下函数来移除卡片：
- en: '[PRE45]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The game logic is ready now. Let's open the game's HTML file in a browser and
    play. Remember to check the console window in **Developer Tools** to see whether
    there is any error.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏逻辑现在准备好了。让我们在浏览器中打开游戏的 HTML 文件并玩游戏。记得检查 **开发者工具** 中的控制台窗口，看看是否有任何错误。
- en: 'The following screenshot shows the CSS3 Card Matching game:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 CSS3 卡片配对游戏：
- en: '![Time for action – adding game logic to the matching game](img/B04290_03_10.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 向配对游戏添加游戏逻辑](img/B04290_03_10.jpg)'
- en: '*What just happened?*'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We coded the game logic of the CSS3 matching game. The logic adds the mouse
    click interaction to the playing cards, and it controls the flow of pattern checking.
    You can try the game and view the full source code at [http://makzan.net/html5-games/card-matching-wip-step2/](http://makzan.net/html5-games/card-matching-wip-step2/).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了 CSS3 配对游戏的逻辑。这个逻辑为扑克牌添加了鼠标点击交互，并控制了模式检查的流程。你可以尝试游戏并查看完整的源代码在 [http://makzan.net/html5-games/card-matching-wip-step2/](http://makzan.net/html5-games/card-matching-wip-step2/)。
- en: Executing code after the CSS transition has ended
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS 过渡结束后执行代码
- en: 'We remove the paired cards after playing the fade out transition. We can schedule
    a function to be executed after the transition has ended by using the `transitionend`
    event. The following code snippet from our code example adds a `card-removed`
    class to the paired card to start the transition. Then, it binds the `transitionend`
    event to remove the card complete with the DOM, afterwards:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束后，我们移除了配对的卡片。我们可以通过使用 `transitionend` 事件来安排在过渡结束后执行一个函数。以下来自我们代码示例的代码片段给配对的卡片添加了一个
    `card-removed` 类以启动过渡。然后，它将 `transitionend` 事件绑定到移除卡片，包括 DOM，之后：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Delaying code execution on flipping cards
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻转卡片后的代码执行延迟
- en: 'The game logic flow is designed in the same way as playing a real deck. One
    big difference is that we used several `setTimeout` functions to delay the execution
    of the code. When the second card is clicked, we schedule the `checkPattern` function
    to be executed 0.7 seconds later by using the following code example snippet:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏逻辑流程的设计方式与玩真实牌组相同。一个很大的不同之处在于我们使用了几个`setTimeout`函数来延迟代码的执行。当点击第二张牌时，我们通过以下代码示例片段安排`checkPattern`函数在0.7秒后执行：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The reason we delay the function call is to give time to the player to memorize
    the card pattern.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们延迟函数调用的原因是为了给玩家留出时间来记住牌型。
- en: Randomizing an array in JavaScript
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中随机化数组
- en: There is no built-in array randomize function in JavaScript. We have to write
    our own. Luckily, we can get help from the built-in array sorting function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中没有内置的数组随机化函数。我们必须自己编写。幸运的是，我们可以从内置的数组排序函数中获得帮助。
- en: 'Here is the usage of the `sort` function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`sort`函数的用法：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `sort` function takes one optional argument:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数接受一个可选参数：'
- en: '| Argument | Definition | Discussion |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `compare_function` | A function that defines the sort order of the array.
    The `compare_function` requires two arguments. | The `sort` function compares
    two elements in the array by using the `compare` function. Therefore, the `compare`
    function requires two arguments.When the `compare` function returns any value
    that is bigger than 0, it puts the first argument at a lower index than the second
    argument.When the return value is smaller than 0, it puts the second argument
    at a lower index than the first argument. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `compare_function` | 一个定义数组排序顺序的函数。`compare_function`需要两个参数。 | `sort`函数通过使用`compare`函数比较数组中的两个元素。因此，`compare`函数需要两个参数。当`compare`函数返回任何大于0的值时，它将第一个参数放在比第二个参数低的索引处。当返回值小于0时，它将第二个参数放在比第一个参数低的索引处。
    |'
- en: 'The trick here is that we used the `compare` function that returns a random
    number between -0.5 and 0.5:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是我们使用了返回介于-0.5和0.5之间的随机数的`compare`函数：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By returning a random number in the `compare` function, the `sort` function
    sorts the same array in an inconsistent way. In other words, we shuffle the array.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`compare`函数中返回一个随机数，`sort`函数以不一致的方式对相同的数组进行排序。换句话说，我们洗牌。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following link from the Mozilla Developer Network provides a detailed explanation
    on using the `sort` function with examples:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Mozilla开发者网络的以下链接提供了关于使用`sort`函数的详细解释，包括示例：
- en: '[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort)'
- en: Storing internal custom data with an HTML5 custom data attribute
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTML5自定义数据属性存储内部自定义数据
- en: We can store custom data inside the DOM element by using the **custom data attribute**.
    We can create a custom attribute name with the `data-` prefix and assign a value
    to it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用**自定义数据属性**在DOM元素中存储自定义数据。我们可以使用`data-`前缀创建一个自定义属性名，并为其分配一个值。
- en: 'For instance, we can embed custom data to the list elements in the following
    code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在以下代码中将自定义数据嵌入到列表元素中：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is a new feature proposed in the HTML5 spec. According to the W3C, the
    custom data attributes are intended to store custom data that is private to a
    page or an application for which there are no more appropriate attributes or elements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTML5规范中提出的新功能。根据W3C的说法，自定义数据属性旨在存储私有于页面或应用程序的自定义数据，对于这些数据没有更适合的属性或元素。
- en: W3C also states that this custom data attribute is "intended for use by the
    site's own script and not a generic extension mechanism for publicly-usable metadata."
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: W3C还指出，这个自定义数据属性“旨在由网站的脚本使用，而不是一个通用的扩展机制，用于公开可用的元数据。”
- en: We are coding our matching game and embedding our own data to the card elements;
    therefore, custom data attribute fits our usage.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写匹配游戏，并将我们自己的数据嵌入到牌元素中；因此，自定义数据属性非常适合我们的使用。
- en: 'We use the custom attribute to store the card pattern inside each card so that
    we can check by comparing the pattern value whether the two flipped cards match
    in JavaScript. In addition, the pattern is used to style the playing cards into
    corresponding graphics as well:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用自定义属性在每张牌中存储牌型，以便我们可以通过比较模式值来检查JavaScript中翻开的牌是否匹配。此外，模式还用于将玩牌样式化为相应的图形：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Pop quiz
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: Q1\. According to W3C's guidelines about the custom data attribute, which of
    the following statements is true?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 根据 W3C 关于自定义数据属性的指南，以下哪个陈述是正确的？
- en: We can create a `data-link` attribute to store the link of the `css` tag.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个 `data-link` 属性来存储 `css` 标签的链接。
- en: We can access the custom data attribute in a third-party game portal website.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以访问第三方游戏门户网站中的自定义数据属性。
- en: We can store a `data-score` attribute in each player's DOM element to sort the
    ranking in our web page.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在每个玩家的 DOM 元素中存储 `data-score` 属性，以在我们的网页中排序排名。
- en: We can create a `ranking` attribute in each player's DOM element to store the
    ranking data.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在每个玩家的 DOM 元素中创建一个 `ranking` 属性来存储排名数据。
- en: Accessing custom data attribute with jQuery
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jQuery 访问自定义数据属性
- en: 'In the matching game example, we used the `attr` function from the jQuery library
    to access our custom data:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配游戏示例中，我们使用了 jQuery 库中的 `attr` 函数来访问我们的自定义数据：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `attr` function returns the value of the given attribute name. For example,
    we can get the links in all the `a` tags by calling the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr` 函数返回给定属性名的值。例如，我们可以通过调用以下代码来获取所有 `a` 标签中的链接：'
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For the HTML5 custom data attribute, jQuery provides us with another function
    to access the HTML5 custom data attribute. This is the `data` function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HTML5 自定义数据属性，jQuery 为我们提供了一个额外的函数来访问 HTML5 自定义数据属性。这个函数就是 `data` 函数。
- en: '`Data` function was designed to embed custom data into the jQuery object of
    the HTML elements. It was designed before the HTML5 custom data attribute.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 函数是为了将自定义数据嵌入到 HTML 元素的 jQuery 对象中而设计的。它是在 HTML5 自定义数据属性之前设计的。'
- en: 'Here is the usage of the `data` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `data` 函数的使用方法：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `data` function accepts two types of functions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 函数接受两种类型的函数：'
- en: '| Function type | Arguments definition | Discussion |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 函数类型 | 参数定义 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `.data(key)` | The `key` argument is a string that names the entry of the
    data. | When only the `key` argument is given, the `data` function reads the data
    associated with the jQuery object and returns the corresponding value.In the recent
    jQuery update, this function is extended to support the HTML5 custom data attribute.
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `.data(key)` | `key` 参数是一个字符串，用于命名数据条目。 | 当只提供 `key` 参数时，`data` 函数读取与 jQuery
    对象关联的数据，并返回相应的值。在最近的 jQuery 更新中，此函数扩展以支持 HTML5 自定义数据属性。 |'
- en: '| `.data(key,` `value)` | `The key` argument is a string that names the entry
    of the data.`The value` argument is the data to be associated with the jQuery
    object. | When both the `key` and `value` arguments are given, the `data` function
    sets a new data entry to the jQuery object.The `value` argument can be any JavaScript
    type, including an array and an object. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `.data(key, value)` | `key` 参数是一个字符串，用于命名数据条目。`value` 参数是要与 jQuery 对象关联的数据。
    | 当同时提供 `key` 和 `value` 参数时，`data` 函数将新的数据条目设置到 jQuery 对象中。`value` 参数可以是任何 JavaScript
    类型，包括数组和对象。 |'
- en: In order to support the HTML5 custom data attribute, jQuery extends the `data`
    function to let it access the custom data that is defined in the HTML code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 HTML5 自定义数据属性，jQuery 扩展了 `data` 函数，使其能够访问在 HTML 代码中定义的自定义数据。
- en: 'Now, let''s see how we use the `data` function. Consider the following line
    of an HTML code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用 `data` 函数。考虑以下 HTML 代码中的一行：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, using the preceding line of code, we can access the `data-custom-name`
    attribute by calling the `data` function in jQuery:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用前面的代码行，我们可以通过在 jQuery 中调用 `data` 函数来访问 `data-custom-name` 属性：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will return "HTML5 Games".
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 "HTML5 Games"。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that `attr` would always return a string value. However, the `data`
    method will attempt to convert the HTML string value into a JavaScript value,
    such as a number or a Boolean.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`attr` 方法总是会返回一个字符串值。然而，`data` 方法会尝试将 HTML 字符串值转换为 JavaScript 值，例如数字或布尔值。
- en: Pop quiz
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Given the following HTML code, which jQuery statements read the custom
    score data and return 100 in the integer format?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 给定以下 HTML 代码，哪些 jQuery 语句读取自定义分数数据并以整数格式返回 100？
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`$("#game").attr("data-score");`'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$("#game").attr("data-score");`'
- en: '`$("#game").attr("score");`'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$("#game").attr("score");`'
- en: '`$("#game").data("data-score");`'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$("#game").data("data-score");`'
- en: '`$("#game").data("score");`'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$("#game").data("score");`'
- en: Have a go hero
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We have created the CSS3 matching game. So, what is missing here? The game logic
    does not check whether the game is over. Try adding a "You won!" text when the
    game is over. You can also animate the text by using the techniques that we discussed
    in this chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了CSS3匹配游戏。那么，这里缺少了什么？游戏逻辑没有检查游戏是否结束。当游戏结束时，尝试添加“你赢了！”的文本。你还可以通过使用本章讨论的技术来动画化文本。
- en: Making other playing card games
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作其他扑克牌游戏
- en: This CSS3 playing card approach is suitable to create card games. There are
    two sides on a card that fit the flipping. The transition feature is suitable
    to move the cards. With both moving and flipping, we can just define the playing
    rule and make the most of the card games.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这种CSS3扑克牌方法适合创建卡片游戏。卡片有两面，适合翻动。过渡特性适合移动卡片。有了移动和翻动，我们只需定义游戏规则，就能充分利用卡片游戏。
- en: Have a go hero
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: Can you use the playing card graphics and flipping techniques to create another
    game? How about poker?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你能使用扑克牌图形和翻动技术来创建另一个游戏吗？比如扑克？
- en: Embedding web fonts into our game
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将网络字体嵌入到我们的游戏中
- en: Over the years, we have been using limited fonts to design web pages. We could
    not use whatever fonts we wanted because the browser loaded the font from the
    visitor's local machine, and we cannot control or ensure that visitors have our
    desired fonts.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们一直在使用有限的字体来设计网页。我们无法使用我们想要的任何字体，因为浏览器从访客的本地机器加载字体，我们无法控制或确保访客拥有我们想要的字体。
- en: Although we can embed **web fonts** to Internet Explorer 5 with a limited type
    format, we have to wait until browser vendors support embedding the most common
    TrueType font format.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以将**网络字体**嵌入到Internet Explorer 5中，但格式有限，我们必须等待浏览器厂商支持嵌入最常见的TrueType字体格式。
- en: Imagine that we can control the mood of the game by embedding different styles
    of web fonts. We can then design the games with our desired fonts and have more
    control over the appeal of the game. Let's try to embed a web font into our memory
    matching game.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们可以通过嵌入不同风格的网络字体来控制游戏的情绪。然后我们可以用我们想要的字体设计游戏，并更多地控制游戏的吸引力。让我们尝试将网络字体嵌入到我们的记忆匹配游戏中。
- en: Time for action – embedding a font from the Google Fonts directory
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动——从Google字体目录嵌入字体
- en: '**Google Fonts** directory is a web font service that lists free-to-use web
    fonts. We will embed a web font chosen from the Google Fonts directory:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Fonts**目录是一个提供免费使用网络字体的网络字体服务。我们将嵌入从Google Fonts目录选择的网络字体：'
- en: Go to the Google Fonts directory site at [http://google.com/fonts](http://google.com/fonts).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://google.com/fonts](http://google.com/fonts)的Google字体目录网站。
- en: In the font directory, there is a list of web fonts that are available under
    an open source license and can be used freely.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在字体目录中，有一个列表，列出了在开源许可下可用的网络字体，可以免费使用。
- en: Choose one of them and click on the font name to proceed to the next step. In
    this example, I used **Droid Serif**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择其中一个，然后点击字体名称以进入下一步。在这个例子中，我使用了**Droid Serif**。
- en: After you click on a font, the font directory displays detailed information
    about the font. There are several actions that we can carry out here, such as
    preview the font, choose from variants, and most importantly, get the font embedding
    code.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你点击字体后，字体目录会显示关于该字体的详细信息。在这里，我们可以执行几个操作，例如预览字体、选择变体，最重要的是，获取字体嵌入代码。
- en: In MAC, click on the **Get the code** tab and you will see the following screenshot;
    this shows a guide on how to embed this font into our web page. Alternatively,
    in Windows, you can click on the **Use** tab and you will find instructions to
    get the code:![Time for action – embedding a font from the Google Fonts directory](img/B04290_03_11.jpg)
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MAC上，点击**获取代码**标签，你会看到以下截图；这显示了如何将此字体嵌入到我们的网页中的指南。或者，在Windows上，你可以点击**使用**标签，你会找到获取代码的说明：![开始行动——从Google字体目录嵌入字体](img/B04290_03_11.jpg)
- en: 'Copy the `link` tag provided by Google, and then paste it into the HTML code.
    This should be placed before any other style definition:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Google提供的`link`标签，并将其粘贴到HTML代码中。这应该放在任何其他样式定义之前：
- en: '[PRE58]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we can use the font to style our text. Set the body''s font family property
    as the following code:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用字体来设置我们的文本样式。将body的字体家族属性设置为以下代码：
- en: '[PRE59]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Save all the files and open the `index.html` file. The browser will download
    the font from the Google server and embed it into the web page. Keep an eye on
    the fonts; they should be loaded and rendered as our selected Google font.![Time
    for action – embedding a font from the Google Fonts directory](img/B04290_03_12.jpg)
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件并打开`index.html`文件。浏览器将从谷歌服务器下载字体并将其嵌入到网页中。请注意字体；它们应该被加载并渲染为我们所选的谷歌字体。[嵌入谷歌字体目录中的字体
    - 行动时间](img/B04290_03_12.jpg)
- en: '*What just happened?*'
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have just styled our game with an uncommon web font. The font is hosted and
    delivered through the Google Fonts directory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用一个不常见的网络字体来设计我们的游戏。该字体由谷歌字体目录托管并交付。
- en: 'Besides using the font directory, we can embed our font file by using `@font
    face`. The following link provides a bulletproof approach to embed a font ourselves:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用字体目录外，我们还可以通过使用`@font face`来嵌入我们的字体文件。以下链接提供了一个嵌入字体的安全方法：
- en: '[http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax](http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax](http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax)'
- en: Tip
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Check the font license before embedding**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**在嵌入字体之前检查字体许可**'
- en: Normally, the font license does not cover its usage on web pages. Be sure to
    check the license before embedding the font. All the fonts listed in the Google
    Fonts directory are licensed under the open source license and can be used on
    any website. You can check the license of individual fonts listed in the directory
    at [https://www.google.com/fonts/attribution](https://www.google.com/fonts/attribution).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，字体许可并不涵盖其在网页上的使用。在嵌入字体之前，请务必检查许可。谷歌字体目录中列出的所有字体都受开源许可协议的约束，可以在任何网站上使用。您可以在[https://www.google.com/fonts/attribution](https://www.google.com/fonts/attribution)查看目录中列出的单个字体的许可。
- en: Choosing different font delivery services
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择不同的字体交付服务
- en: Google Fonts directory is just one of the font delivery services. Typekit ([http://typekit.com](http://typekit.com))
    and Fontdeck ([http://fontdeck.com](http://fontdeck.com)) are two other font services
    that provide hundreds of high quality fonts via yearly subscription plans.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌字体目录只是字体交付服务之一。Typekit ([http://typekit.com](http://typekit.com)) 和 Fontdeck
    ([http://fontdeck.com](http://fontdeck.com)) 是另外两种提供数百种高质量字体的字体服务，这些服务通过年度订阅计划提供。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about using different new properties of CSS3 to
    create games.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用CSS3的不同新特性来创建游戏。
- en: Specifically, we covered how you can build a card game that is based on CSS3
    styles and animation. You learned how to transform and animate the game object
    by using the transition module. We can flip a card back and forth with perspective
    depth illusion. We also embedded web fonts from an online font delivery service.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们介绍了如何构建一个基于CSS3样式和动画的卡牌游戏。你学习了如何通过使用过渡模块来转换和动画化游戏对象。我们可以通过透视深度错觉来翻转卡片。我们还从在线字体交付服务中嵌入网络字体。
- en: Now that you've learned about creating DOM-based HTML5 games with the help of
    CSS3 features, we are going to explore another approach—using the new `canvas`
    tag and the drawing API—to create HTML5 games in the next chapter.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在CSS3特性的帮助下创建基于DOM的HTML5游戏，我们将探讨另一种方法——使用新的`canvas`标签和绘图API——在下一章中创建HTML5游戏。
