- en: Chapter 2. Working with Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：与视图一起工作
- en: Backbone view works as the presentation layer of an application. In simple terms,
    you can define it as an abstract layer for your HTML element. It doesn't contain
    any HTML markup of its own, but it contains the logic to present your model's
    data with the help of JavaScript templates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 视图作为应用程序的表现层。简单来说，你可以将其定义为你 HTML 元素的抽象层。它不包含任何自己的 HTML 标记，但它包含使用 JavaScript
    模板呈现模型数据的逻辑。
- en: If you go through the annotated source of Backbone view, you will find that
    `Backbone.View` is a small class with very few methods, including an empty `initialize()`
    method and an almost empty `render()` method, which are in general meant to be
    overridden by any custom view class. In this chapter, we will investigate some
    common problems and the solutions to these problems with respect to the Backbone
    views that developers face mostly while developing real-world Backbone.js applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了 Backbone 视图的注释源代码，你会发现 `Backbone.View` 是一个方法非常少的类，包括一个空的 `initialize()`
    方法和几乎空的 `render()` 方法，通常意味着任何自定义视图类都可以重写它们。在本章中，我们将调查一些常见问题以及开发者开发现实世界 Backbone.js
    应用程序时面临的问题的解决方案。
- en: 'The basic issues with Backbone are associated with view rendering or updating
    and maintaining multiple views within an application. We will analyze the following
    topics based on complexity:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 的一些基本问题与视图渲染或更新以及维护应用程序中的多个视图有关。我们将基于复杂性分析以下主题：
- en: '**Basic usage of views**: We will learn the basic concepts of Backbone view,
    its properties, functions, and event-handling.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图的基本用法**：我们将学习 Backbone 视图的基本概念、其属性、函数和事件处理。'
- en: '**Updating a view partially**: We will learn how to update only a part of a
    view without the need for re-rendering the complete view.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分更新视图**：我们将学习如何在不重新渲染整个视图的情况下仅更新视图的一部分。'
- en: '**Nested views**: As the complexity of an application layout increases, we
    feel the need to maintain a hierarchy of multiple views. Nested views or subviews
    simplify event-handling and layout management to a great extent. We will explore
    the following topics:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套视图**：随着应用程序布局复杂性的增加，我们感到需要维护多个视图的层次结构。嵌套视图或子视图在很大程度上简化了事件处理和布局管理。我们将探讨以下主题：'
- en: When we need to use subviews
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要使用子视图时
- en: How to initialize and render nested views
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何初始化和渲染嵌套视图
- en: How to avoid DOM reflow in the case of a large collection of nested views and
    a complex view DOM structure
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大量嵌套视图和复杂的视图 DOM 结构的情况下，如何避免 DOM 重新流
- en: How to clean up resources (child views, events) when you delete a parent view
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你删除父视图时，如何清理资源（子视图、事件）
- en: '**Templates**: Templates are an essential part of Backbone and are used in
    combination with views to create reusable copies of HTML markup. We will discuss
    the following topics:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：模板是 Backbone 的一个重要部分，与视图结合使用以创建可重用的 HTML 标记副本。我们将讨论以下主题：'
- en: The different options for storing and loading template files
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和加载模板文件的不同选项
- en: The advantages of template precompilation and storing precompiled templates
    on the client side
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板预编译和将预编译的模板存储在客户端的优点
- en: The usage of template helper functions
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板辅助函数的使用
- en: '**Marionette views**: We can reduce the view boilerplate code using the custom
    view extensions of the Marionette library.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Marionette 视图**：我们可以使用 Marionette 库的自定义视图扩展来减少视图样板代码。'
- en: '**Layout manager**: We can simplify the complex layout architecture using the
    Backbone layout manager plugin.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局管理器**：我们可以使用 Backbone 布局管理器插件简化复杂的布局架构。'
- en: Basic usage of views
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图的基本用法
- en: 'Backbone views are the tools that provide a logical structure to the HTML markup
    of your application. Views represent the data of Backbone models or collections
    via JavaScript templates. For any change in the associated model or collection,
    you do not need to redraw the complete page, only update the relevant view—that''s
    it. A basic view can be defined this way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 视图是提供逻辑结构的工具，用于你的应用程序的 HTML 标记。视图通过 JavaScript 模板表示 Backbone 模型或集合的数据。对于关联模型或集合的任何更改，你不需要重新绘制整个页面，只需更新相关的视图即可。一个基本的视图可以这样定义：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we created a simple HTML markup, placed it inside this view's element,
    and showed the view in the DOM. Let's understand the concept further by looking
    at all the steps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个简单的 HTML 标记，将其放置在这个视图元素内部，并在 DOM 中显示视图。让我们通过查看所有步骤来进一步理解这个概念。
- en: Understanding the el property
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 el 属性
- en: 'What is the `this.$el` property? It is the property that points to the jQuery-wrapped
    version of `el`. Every view possesses an `el` property that either holds a DOM
    reference where the view is ultimately going to be rendered, or an HTML element
    that functions as the main element of the view. In the previous example, we didn''t
    specify the `el` property. So, as soon as we instantiated the view, the `el` element
    was available to us though it was not rendered in the DOM. We had to do this rendering
    explicitly by appending the view element to the `#container` element. However,
    if we had mentioned the `el` property pointing to the `#container` element in
    the view definition or while creating it''s instance, we wouldn''t need to append
    it specifically to the document. Like the following code snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是`this.$el`属性？它是指向`el`的jQuery包装版本的属性。每个视图都拥有一个`el`属性，该属性要么持有视图最终将要渲染的DOM引用，要么是一个充当视图主要元素的HTML元素。在先前的例子中，我们没有指定`el`属性。因此，当我们实例化视图时，`el`元素就对我们可用，尽管它还没有在DOM中渲染。我们必须通过将视图元素附加到`#container`元素来显式地进行渲染。然而，如果我们已经在视图定义中或创建其实例时提到了指向`#container`元素的`el`属性，我们就不需要将其特别附加到文档中。如下代码片段所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This generates the same result as the first example. However, this methodology
    creates problems when you make multiple instances of the `UserView` class, as
    all of them point to the same element as given in `el`, and because the last instance
    will overwrite the previous ones. However, this can be minimized if you pass the
    `el` property each time you create the view instance, though it is not a very
    good practice. Also, another problem related to view destroy still persists—if
    you destroy this view, it removes the `#container` element too—so, if you create
    another `UserView` instance passing the same `#container` element as the `el`
    property later, it throws an error. It is good practice to let the view create
    its own element and make the parent views or the layout manager take care of rendering
    the view.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生与第一个例子相同的结果。然而，当你创建多个`UserView`类的实例时，这种方法会引发问题，因为它们都指向`el`中给出的相同元素，并且因为最后一个实例将覆盖前面的实例。然而，如果你每次创建视图实例时都传递`el`属性，这可以最小化问题，尽管这不是一个好的做法。此外，与视图销毁相关的问题仍然存在——如果你销毁这个视图，它也会移除`#container`元素——因此，如果你稍后创建另一个`UserView`实例并将相同的`#container`元素作为`el`属性传递，它将引发错误。一个好的做法是让视图创建自己的元素，并让父视图或布局管理器负责渲染视图。
- en: There are some other properties that relate to the `el` property of the Backbone
    view; these are `tagName`, `id`, `className`, and `attributes`. The `tagName`
    property expects an HTML tag name as the value that the main element of the view
    will be created with. For example, if you specify `tagName` as `'ul'`, the `el`
    element that is created by Backbone will be an empty `UL` element. By default,
    `tagName` has the value `'div'`, that is, the view element will be a `DIV` element
    if nothing is specified as `tagName`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些其他属性与Backbone视图的`el`属性相关；这些是`tagName`、`id`、`className`和`attributes`。`tagName`属性期望一个HTML标签名作为值，该值将用于创建视图的主要元素。例如，如果你将`tagName`指定为`'ul'`，Backbone创建的`el`元素将是一个空的`UL`元素。默认情况下，`tagName`的值为`'div'`，也就是说，如果没有指定`tagName`，视图元素将是一个`DIV`元素。
- en: 'The `id` and `className` properties specify the element''s ID and CSS classes
    respectively. The `attributes` property holds all of the HTML attributes as an
    object:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`和`className`属性分别指定元素的ID和CSS类。`attributes`属性包含所有HTML属性作为一个对象：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The resulting view element will look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的视图元素将看起来像这样：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listening to view events
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听视图事件
- en: 'You can attach DOM event listeners to the DOM elements using the `events` property
    of view. These events can only be registered on the view element along with its
    child elements:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用视图的`events`属性将DOM事件监听器附加到DOM元素上。这些事件只能在视图元素及其子元素上注册：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We added a `click` event on the button and defined the handler to be called
    once the user clicks on that button.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在按钮上添加了一个`click`事件，并定义了当用户点击该按钮时要调用的处理程序。
- en: Backbone delegates all of the view events, so that the events are attached even
    if the element is not rendered in the DOM. So, if you add one event hash for an
    element that is not yet available inside the view DOM, the event will be attached
    to it as soon as the element is rendered.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone将所有视图事件委托出去，这样即使元素尚未在DOM中渲染，事件也会附加到它上。所以，如果你为视图DOM内尚未可用的元素添加一个事件散列，事件将在元素渲染时立即附加到它上。
- en: Displaying model data with templates
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板显示模型数据
- en: 'This is the most important part as the main purpose of a view is to display
    the data attached to it. In the simplest case, one Backbone view is attached to
    each model, and it keeps itself updated with the model change:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的部分，因为视图的主要目的是显示与之关联的数据。在最简单的情况下，每个Backbone视图都关联到一个模型，并且它会随着模型的变化而更新自己：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code is pretty simple to understand; here we pass a `model` instance
    to the view and set the model value to the template inside the `render()` function.
    Once rendered, the view will show the HTML markup with the model data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码很容易理解；在这里，我们在`render()`函数中将`model`实例传递给视图，并将模型值设置为模板。一旦渲染，视图将显示包含模型数据的HTML标记。
- en: 'We also need to ensure that the changes in any attribute of the model should
    be reflected in the view immediately. We can achieve this functionality by listening
    to the model''s `change` event:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保模型任何属性的更改都能立即反映在视图中。我们可以通过监听模型的`change`事件来实现这个功能：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `initialize()` method, we listen to the model's `change` event and re-render
    the view. We can use both `on()` and `listenTo()` for this functionality, but
    the advantage of the latter over the former is that it automatically unbinds all
    the events that were added with the `listenTo()` method if the view is destroyed.
    On the other hand, you have to unbind these events explicitly if you bind events
    using the `on()` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize()`方法中，我们监听模型的`change`事件并重新渲染视图。我们可以使用`on()`和`listenTo()`来实现这个功能，但`listenTo()`方法的优势在于，如果视图被销毁，它会自动解绑使用`listenTo()`方法添加的所有事件。另一方面，如果你使用`on()`方法绑定事件，你必须明确地解绑这些事件。
- en: In some cases, a model can have lots of attributes and you may not want to re-render
    the complete view every time an attribute changes. Rather, updating only that
    part of the view seems more practical. Let's see how we can partially update a
    view in detail in the following section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个模型可能有很多属性，你可能不希望每次属性变化时都重新渲染整个视图。相反，只更新视图的这部分似乎更实际。让我们在下一节中详细了解如何部分更新视图。
- en: Partially updating a view
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分更新视图
- en: 'Partial view updating is a common feature request that many developers ask
    for. The requirement is to re-render part of a view without rendering the complete
    view. This is pretty significant, mostly when there is a complex view with lots
    of data and only a small portion needs to be altered. Re-rendering the complete
    view for every small change can be a performance hit. The solution to this, on
    the other hand, is quite simple. In the following example, if the `address` attribute
    changes, then only the address part of the view''s DOM will be updated, and the
    complete view will not be re-rendered:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 部分视图更新是一个许多开发者请求的常见功能。要求是重新渲染视图的一部分，而不是整个视图。这在有复杂视图和大量数据，但只需要更改一小部分的情况下非常重要。每次小更改都重新渲染整个视图可能会影响性能。另一方面，这个解决方案相当简单。在以下示例中，如果`address`属性发生变化，那么视图的DOM中的地址部分将被更新，而整个视图将不会重新渲染：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we populate the template with model data in the `render` function.
    Instead of listening to the `change` event of the model, we listen to the `change:address`
    event. Inside the `showChangedAddress()` method, we first create the HTML string
    with the template and latest model data. Then we extract the `address` DOM element
    from this HTML string. Finally, we just replace the view's present `address` DOM
    element with the latest one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`render`函数中使用模型数据填充模板。我们不是监听模型的`change`事件，而是监听`change:address`事件。在`showChangedAddress()`方法内部，我们首先使用模板和最新的模型数据创建HTML字符串。然后我们从这个HTML字符串中提取`address`
    DOM元素。最后，我们只需用最新的一个替换视图当前的`address` DOM元素。
- en: The same functionality can be achieved with a subview or child view as well,
    and this would be a better solution indeed. However, there can be situations when
    creating a new subview for such a small change is redundant and the previous solution
    might pay off. In the following section, we will understand the real scenarios
    in which (and how) we should use a subview.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的功能也可以通过子视图或子视图来实现，这确实是一个更好的解决方案。然而，在某些情况下，为如此小的更改创建一个新的子视图可能是多余的，而先前的解决方案可能更有利。在下一节中，我们将了解实际场景中（以及如何）我们应该使用子视图。
- en: Understanding nested views
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解嵌套视图
- en: A nested view or subview is basically a child view. The necessity of a subview
    arises when we have a complex view and we want to separate a part of it for the
    sake of simplicity, better event-handling, and a better model-view relationship.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套视图或子视图基本上是一个子视图。当我们的视图复杂并且我们想要为了简化、更好的事件处理和更好的模型-视图关系而将其一部分分离出来时，子视图的必要性就出现了。
- en: To give you an example, assume that we have a collection of similar data and
    we need to display a list item for each type of data. In this case, it is always
    preferable to have separate views and models that give an option to control the
    behavior of the view attached to each model. When you click on an item, you may
    need to use the data for that item for further processing. If the item is a subview,
    we can get the data readily from the model attached to it. We will explain this
    concept in the example that follows.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您举个例子，假设我们有一组相似的数据，并且我们需要为每种数据类型显示一个列表项。在这种情况下，最好有独立的视图和模型，这样可以为每个模型附加的视图提供控制其行为的选择。当您点击一个项目时，您可能需要使用该项目的数据进行进一步处理。如果该项目是一个子视图，我们可以从附加到它的模型中轻松获取数据。我们将在下面的例子中解释这个概念。
- en: 'We have seen `UserItemView` in [Chapter 1](ch01.html "Chapter 1. Reducing Boilerplate
    with Plugin Development"), *Reducing Boilerplate with Plugin Development*, which
    uses the `User` model. Now, let''s introduce a collection of user data that will
    be displayed as a list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。通过插件开发减少样板代码")中看到了`UserItemView`，*通过插件开发减少样板代码*，它使用了`User`模型。现在，让我们介绍一组将作为列表显示的用户数据：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Initially, we will use only one view to render the complete collection by creating
    a `UsersView`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将只使用一个视图通过创建`UsersView`来渲染整个集合：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `render()` method, we iterate over all of the collection data and create
    an HTML list item that gets appended to an element of the `UsersView` class. This
    works perfectly and shows you a list of names.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render()`方法中，我们遍历整个集合数据，创建一个HTML列表项，并将其附加到`UsersView`类的元素中。这工作得很好，显示了名字列表。
- en: 'The preceding implementation is absolutely fine, unless you want to receive
    a user''s data by clicking on a user''s name. In that case, we have to add the
    user ID somewhere in the HTML markup of the list item so that you can access it
    from the browser''s `event` object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现绝对没问题，除非您想通过点击用户的名字来接收用户的数据。在这种情况下，我们必须在列表项的HTML标记中添加用户ID，这样您就可以从浏览器的`event`对象中访问它：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On a `click` event, we call the `showUserName()` method that displays the name
    of the `user` model:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`click`事件中，我们调用`showUserName()`方法来显示`user`模型的名字：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `data-id` attribute of the list element can be extracted from the `target`
    property of the `event` object and the model with the same `data-id` attribute
    can be obtained from `collection`. This methodology works fine unless there are
    lots of views in your application. Managing events in this way becomes tedious
    for large applications. So, how do we solve this problem? We use subviews!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素的`data-id`属性可以从`event`对象的`target`属性中提取，并且具有相同`data-id`属性的模型可以从`collection`中获取。这种方法在您的应用程序中有许多视图时效果良好。以这种方式管理事件对于大型应用程序来说变得繁琐。那么，我们如何解决这个问题呢？我们使用子视图！
- en: Knowing when to use subviews
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解何时使用子视图
- en: 'The previous pattern is similar to what we normally use in the case of simple
    jQuery-based applications where all of the data and events are tightly coupled
    to the DOM. Continuing event binding in this manner will ultimately result in
    much complexity at a later stage. A subview can simplify this process to a great
    extent. We will separate each list item and introduce a `UserItemView` variable
    for each of them:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的模式类似于我们在基于简单jQuery的应用程序中通常使用的模式，其中所有数据和事件都紧密耦合到DOM上。以这种方式继续事件绑定最终会导致在后期阶段出现很多复杂性。子视图可以在很大程度上简化这个过程。我们将每个列表项分开，并为每个列表项引入一个`UserItemView`变量：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It''s simple. We just define one view for one model. In the `render()` method
    of `UsersView`, we eliminate the ugly HTML strings because we just need to create
    an instance of each subview (`UserItemView`) and append its elements to the main
    view:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们只为每个模型定义一个视图。在`UsersView`的`render()`方法中，我们消除了丑陋的HTML字符串，因为我们只需要创建每个子视图（`UserItemView`）的实例，并将它们的元素附加到主视图中：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We create new instances of `UserViewItem`, pass the model to it, and render
    it inside the main view. The event listeners are now subview-specific and the
    subview methods can directly access the model attached to it. This makes the application
    flow cleaner and also eliminates the extra time that, though small, is required
    to look up the collection for a particular model through its ID. If your view
    has multiple similar child items, and each child item needs its own set of events,
    subviews are the right approach.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建新的 `UserViewItem` 实例，将模型传递给它，并在主视图中渲染它。现在的事件监听器是子视图特定的，子视图方法可以直接访问附加到其上的模型。这使得应用程序的流程更清晰，并且消除了通过ID查找特定模型所需的时间，尽管这个时间很小。如果你的视图有多个类似的子项，并且每个子项都需要自己的事件集，那么子视图是正确的做法。
- en: In the final section of this chapter, we will look at an awesome library, MarionetteJS,
    which provides some useful readymade BackboneJS extensions. The `ItemView` and
    `CollectionView` extensions provide a functionality that is similar to the previous
    example but in a more robust and flexible way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨一个很棒的库，MarionetteJS，它提供了一些有用的现成 BackboneJS 扩展。`ItemView` 和 `CollectionView`
    扩展提供了一种类似于前一个示例的功能，但以更稳健和灵活的方式。
- en: Avoiding multiple DOM reflow
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免多次 DOM 重排
- en: We used jQuery's `$.append()` method to add the subview elements to the main
    view. It is found that if there is a large collection of data, appending view
    elements to the DOM one by one can create a severe performance issue; this will
    affect the UI responsiveness of the application. The performance hit can be noticed
    even in modern browsers, since every append causes a DOM reflow and forces the
    browser to recalculate the size and position of the DOM tree.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 jQuery 的 `$.append()` 方法将子视图元素添加到主视图中。发现如果数据集很大，逐个将视图元素添加到 DOM 中可以创建严重的性能问题；这将影响应用程序的
    UI 响应性。在现代浏览器中，性能下降甚至可以感觉到，因为每次添加都会导致 DOM 重排，并迫使浏览器重新计算 DOM 树的大小和位置。
- en: This multiple DOM reflow can be avoided by using `DocumentFragment`, which is
    described at [http://ejohn.org/blog/dom-documentfragments](http://ejohn.org/blog/dom-documentfragments)
    by *John Resig* as *a lightweight container that can hold DOM nodes*. We can collect
    all of the view elements inside `DocumentFragment` and then append this fragment
    to the DOM. This will cause a single reflow for the complete collection, and hence
    a performance improvement.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `DocumentFragment` 来避免多次 DOM 重排，这由 *John Resig* 在 [http://ejohn.org/blog/dom-documentfragments](http://ejohn.org/blog/dom-documentfragments)
    中描述为 *一个可以容纳 DOM 节点的轻量级容器*。我们可以在 `DocumentFragment` 内部收集所有的视图元素，然后将这个片段添加到 DOM
    中。这将导致整个集合的单次重排，从而提高性能。
- en: 'Let''s see the `render()` method with a single reflow:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用单个重排的 `render()` 方法：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This process can enhance performance if there are many subviews and the view
    HTML structure is a complex one. In general, not many developers use it and you
    should go for it only when the HTML markup is a pretty complex one. For a simple
    HTML markup, the tests show almost no change in performance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个子视图并且视图的 HTML 结构很复杂，这个过程可以增强性能。一般来说，不是很多开发者使用它，你应该只在 HTML 标记非常复杂时才使用它。对于简单的
    HTML 标记，测试显示性能几乎没有变化。
- en: Re-rendering parent views
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新渲染父视图
- en: 'Imagine the following scenario where we need to show the company details along
    with a list of its employees. We will create two views here: a `Company` view
    that is the main view, and an `Employee` view that is a child view and represents
    each employee in the list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 想象以下场景，我们需要显示公司详情以及其员工列表。在这里我们将创建两个视图：一个 `Company` 视图作为主视图，一个 `Employee` 视图作为子视图，代表列表中的每个员工：
- en: '![Re-rendering parent views](img/3576OS_02_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![重新渲染父视图](img/3576OS_02_03.jpg)'
- en: So, there will be a `Company` model and an `Employees` collection. We render
    the complete view along with the child views in a way similar to what we discussed
    earlier. If there is a change in the `Company` model, we will re-render the `Company`
    view, but that means we have to re-render all the child views too. Do we really
    need to do that? We actually do not need to, and we should not because that will
    be an overhead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将有一个 `Company` 模型和 `Employees` 集合。我们将以类似于之前讨论的方式渲染完整的视图以及子视图。如果 `Company`
    模型发生变化，我们将重新渲染 `Company` 视图，但这意味着我们也必须重新渲染所有子视图。我们真的需要这样做吗？实际上我们不需要，也不应该这样做，因为这将会增加开销。
- en: 'In most cases, as you re-render a parent view, it should not re-initialize
    its child views every time. So, it is preferable to initialize the child views
    in the `initialize()` method of the parent view, and add them in an array that
    can later be used in the `render()` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当你重新渲染父视图时，它不应该每次都重新初始化其子视图。因此，最好在父视图的`initialize()`方法中初始化子视图，并将它们添加到一个数组中，稍后在`render()`方法中使用：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This way, multiple calls to the parent `render()` method will maintain the state
    of the view and will only render the subviews again.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对父`render()`方法的多次调用将保持视图的状态，并且只会重新渲染子视图。
- en: Removing parent views
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除父视图
- en: In the previous scenario, where the company details and its employee list are
    shown, we assume a situation where we need to destroy this complete view and show
    a new view instead. Now, how do we destroy a view? We simply call the `remove()`
    method on it and it unbinds all the events that were registered with the `listenTo()`
    method. It also removes the complete view along with its child view elements from
    the DOM.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个场景中，当公司详情及其员工列表被显示时，我们假设了一个需要销毁这个完整视图并显示新视图的情况。现在，我们如何销毁一个视图？我们只需在它上面调用`remove()`方法，它就会解除使用`listenTo()`方法注册的所有事件。它还会从DOM中移除完整的视图及其子视图元素。
- en: Are we unbinding the events of the child views here? No. The child views are
    removed from the DOM for sure, but we are not calling the `remove()` method on
    them. So, the models still exist and the events attached to the model still hold
    a reference to the view (or the view's methods). As a result, even if the view's
    `el` property is removed from the DOM, those view objects will not be garbage
    collected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里是否解除了子视图的事件？不是的。子视图确实从DOM中移除了，但我们没有在它们上面调用`remove()`方法。因此，模型仍然存在，附加到模型上的事件仍然引用视图（或视图的方法）。结果，即使视图的`el`属性从DOM中移除，这些视图对象也不会被垃圾回收。
- en: 'In order to prevent these memory leaks, we should always keep track of the
    child views while removing parent views. For instance, in the previous section
    we saw how we can store the child views inside a `this.subViews` array. We can
    override the `remove()` method in the `Company` view class and destroy the subviews
    individually before removing the main view:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些内存泄漏，我们在移除父视图时应该始终跟踪子视图。例如，在上一个部分中，我们看到了如何将子视图存储在`this.subViews`数组中。我们可以在`Company`视图类中覆盖`remove()`方法，在移除主视图之前单独销毁子视图：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will ensure that all your child views are removed before the parent view.
    So, in order to get rid of memory leak issues, keep a few points in mind:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在父视图之前移除所有子视图。因此，为了解决内存泄漏问题，请记住以下几点：
- en: Always have a reference to the current top level view
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是保留对当前顶级视图的引用
- en: Keep references of all the child views inside a parent view
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在父视图中保留所有子视图的引用
- en: Ensure every event gets unbound
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个事件都被解除绑定
- en: 'Also, if you are using any Backbone.js version older than V9.9.0, calling only
    the `remove()` method will not clean up the events, and you will have to unbind
    them explicitly. The same works for the events that you register using the `on()`
    method instead of the `listenTo()` method. For older versions of Backbone, you
    may need to use something like the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你使用的是Backbone.js版本低于V9.9.0，仅调用`remove()`方法将不会清理事件，你必须显式地解除它们。使用`on()`方法而不是`listenTo()`方法注册的事件也是如此。对于Backbone的旧版本，你可能需要使用以下类似代码：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are a few tools that will help you check whether your application is leaking
    memory. You can track it with Chrome developer tools ([https://developers.google.com/chrome-developer-tools/docs/javascript-memory-profiling](https://developers.google.com/chrome-developer-tools/docs/javascript-memory-profiling)),
    or you can use Backbone-Debugger ([https://github.com/Maluen/Backbone-Debugger](https://github.com/Maluen/Backbone-Debugger)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以帮助你检查你的应用程序是否泄漏内存。你可以使用Chrome开发者工具([https://developers.google.com/chrome-developer-tools/docs/javascript-memory-profiling](https://developers.google.com/chrome-developer-tools/docs/javascript-memory-profiling))来跟踪它，或者你可以使用Backbone-Debugger([https://github.com/Maluen/Backbone-Debugger](https://github.com/Maluen/Backbone-Debugger))。
- en: Working with templates
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板进行工作
- en: Templates are an integral part of Backbone application development. With Backbone,
    Underscore.js comes up with its inbuilt micro template engine, though we can use
    other popular template engines such as Handlebars, Mustache, or Jade too. In the
    following section, we will cover some interesting patterns with templates that
    will help you to manage the templates in large applications and enhance their
    performance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是Backbone应用程序开发的一个组成部分。使用Backbone，Underscore.js提供了一个内置的微模板引擎，尽管我们也可以使用其他流行的模板引擎，如Handlebars、Mustache或Jade。在下一节中，我们将介绍一些有趣的模板模式，这些模式将帮助你在大型应用程序中管理模板并提高它们的性能。
- en: Storing templates in an HTML file
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模板存储在HTML文件中
- en: 'In the simplest of cases, we store templates in two ways; we either directly
    add them inline within the view as a view property or add them inside the `script`
    tag in the `index.html` file. We have already seen the former case in the previous
    example. Let''s see the second option:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，我们以两种方式存储模板；我们要么直接将它们作为视图属性内联添加到视图中，要么将它们添加到`index.html`文件中的`script`标签内。在前面的例子中，我们已经看到了第一种情况。让我们看看第二种选项：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here we just place the template string inside a `script` tag and give it a
    type `text/template` so that it doesn''t get evaluated as JavaScript. You can
    always retrieve the template using the script ID:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需将模板字符串放在一个`script`标签内，并给它一个类型`text/template`，这样它就不会被当作JavaScript来评估。你可以始终通过脚本ID来检索模板：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Default delimiters of the Underscore template are sometimes annoying and look
    ugly. A Mustache style `{{}}` looks cleaner and is preferred by most developers.
    You can easily transform your Underscore delimiters to the Mustache style with
    the `_.templateSettings property`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore模板的默认定界符有时很烦人，看起来很丑。Mustache风格的`{{}}`看起来更干净，并且大多数开发者都更喜欢它。你可以通过使用`_.templateSettings属性`轻松地将你的Underscore定界符转换为Mustache风格：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both these cases of template storing work fine when the application is a small
    one. However, once the volume of the application starts to increase, it becomes
    quite difficult to manage the large chunks of template strings in the JavaScript
    file and the monster HTML file with all the templates of the application. There
    are a number of options to store the templates and use them. For example, we can
    create separate HTML files for our templates; this approach gives us benefits
    such as syntax highlighting, proper indentation, and options to manage the templates
    separately. However, this technique will lead to another severe issue—the templates
    will need to be loaded separately via AJAX requests. Such multiple XHR requests
    to load the templates in a large project is a bad idea and a huge performance
    hit; avoid it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序规模较小时，这两种模板存储方式都运行良好。然而，一旦应用程序的规模开始增加，管理JavaScript文件中的大量模板字符串以及包含所有模板的巨大HTML文件就变得相当困难。有许多选项可以存储模板并使用它们。例如，我们可以为我们的模板创建单独的HTML文件；这种方法给我们带来了诸如语法高亮、适当的缩进以及单独管理模板的选项等好处。然而，这种技术将导致另一个严重问题——模板需要通过AJAX请求单独加载。在大型项目中，通过多个XHR请求加载模板是一个糟糕的想法，并且会对性能造成巨大影响；避免这样做。
- en: Let's look at some other options that may help you organize your templates in
    a better way.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些其他选项，这些选项可能有助于你以更好的方式组织你的模板。
- en: Storing templates in a JavaScript file
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模板存储在JavaScript文件中
- en: 'Many developers suggest that though a template is a chunk of HTML markup, it''s
    not completely HTML, and keeping the markup in a JavaScript file is a preferable
    option. We can create single or multiple `.js` files that include all the templates
    of the application. The templates will be stored in string format, but you can
    present them in a more human-readable way by using the `join()` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者建议，尽管模板是一段HTML标记，但它并不完全是HTML，将标记保存在JavaScript文件中是一个更好的选择。我们可以创建包含应用程序所有模板的单个或多个`.js`文件。模板将以字符串格式存储，但你可以通过使用`join()`方法以更易于阅读的方式呈现它们：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can maintain separate template files for your modules, for example, `User.js`
    and `Dashboard.js`. You can also have application-specific template namespaces,
    for instance, `App.User` and `App.Dashboard`. The crucial point is you can combine
    and minify these files later to get a single file that greatly improves the application
    performance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你的模块维护单独的模板文件，例如，`User.js`和`Dashboard.js`。你也可以有特定于应用程序的模板命名空间，例如，`App.User`和`App.Dashboard`。关键点是你可以在以后将它们合并和压缩以获得一个文件，这可以大大提高应用程序的性能。
- en: For a large application, you may not want to store your templates in this way
    inside a JavaScript file, where you will not get any facility to format and highlight
    the HTML code. However, the usefulness of this pattern cannot be denied, more
    so when we get a single JavaScript file with a minified set of all the precompiled
    templates. In [Appendix B](apb.html "Appendix B. Precompiling Templates on the
    Server Side"), *Precompiling Templates on the Server Side*, we discuss this process
    in detail.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型应用程序，你可能不希望在JavaScript文件中这样存储模板，因为在其中你将无法获得任何格式化和突出显示HTML代码的便利。然而，这种模式的实用性不容否认，尤其是在我们得到一个包含所有预编译模板的单一压缩JavaScript文件时。在[附录B](apb.html
    "附录 B. 服务器端预编译模板")，*服务器端预编译模板*中，我们详细讨论了这一过程。
- en: With the popularity of Require.js and **Asynchronous Module Definition** (**AMD**),
    most developers today prefer storing individual templates in a separate template
    or in HTML files. Later, when the complete project's source code is optimized,
    it creates a single minified file with all the templates merged in JavaScript.
    This technique is now a popular approach, and we explained the functionality in
    detail in [Appendix C](apc.html "Appendix C. Organizing Templates with AMD and
    Require.js"), *Organizing Templates with AMD and Require.js*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Require.js和**异步模块定义**（**AMD**）的流行，大多数开发者今天更倾向于将单个模板存储在单独的模板或HTML文件中。当整个项目的源代码被优化后，它将创建一个包含所有模板的单一压缩文件。这种方法现在是一种流行的方法，我们在[附录C](apc.html
    "附录 C. 使用AMD和Require.js组织模板")，*使用AMD和Require.js组织模板*中详细解释了这一功能。
- en: Precompiling templates
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预编译模板
- en: What is template compilation? In general, we create templates as strings and
    include template expressions in them. Once we pass that string for compilation,
    the template library analyze the string to create a format which can be applied
    with the data. This compiled function then returns another function where we pass
    the data and get the data integrated HTML string in return. This process is called
    template compilation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模板编译是什么？一般来说，我们创建模板作为字符串，并在其中包含模板表达式。一旦我们传递这个字符串进行编译，模板库就会分析这个字符串以创建一个可以应用数据的格式。这个编译后的函数随后返回另一个函数，我们传递数据并返回一个包含数据集成HTML字符串的函数。这个过程被称为模板编译。
- en: Why do we need to precompile a template? This is because when we use a template
    string, say `TplManager.templates.userProfile`, multiple times, the same compilation
    process gets repeated every time. This is clearly extra work that will affect
    the performance of the app significantly. You can compare the difference in this
    jsperf test ([http://jsperf.com/underscore-templates-classic-vs-precompiled](http://jsperf.com/underscore-templates-classic-vs-precompiled))
    performed by Igor Hlina ([https://twitter.com/srigi](https://twitter.com/srigi)).
    The test shows that the precompilation of a template yields a 99 percent faster
    result than the classic approach.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要预编译模板？这是因为当我们多次使用模板字符串，比如`TplManager.templates.userProfile`时，相同的编译过程会每次重复。这显然是额外的劳动，将显著影响应用程序的性能。你可以比较Igor
    Hlina（[https://twitter.com/srigi](https://twitter.com/srigi)）进行的这个jsperf测试（[http://jsperf.com/underscore-templates-classic-vs-precompiled](http://jsperf.com/underscore-templates-classic-vs-precompiled)）中的差异。测试表明，模板的预编译比经典方法快99%。
- en: 'By precompiling templates and caching them, you can reduce the overhead to
    a large extent. Let''s add a method to our template manager that will compile
    a template only once and return the cached version every time:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过预编译模板并缓存它们，你可以大幅度减少开销。让我们给我们的模板管理器添加一个方法，这个方法只会编译一次模板，并在每次调用时返回缓存的版本：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, we can access the compiled templates from the `getCachedTemplate` method.
    This is a non-optimized solution without much error handling, but the concept
    can be implemented for all your templates.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以从`getCachedTemplate`方法访问编译后的模板。这是一个没有太多错误处理的非优化解决方案，但这个概念可以应用于你所有的模板。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `_.template()` method accepts two arguments in general. If you pass both
    the template string and data, it will send you the complete HTML string with data.
    However, if you pass only the template string, it will return the function that
    takes the data as a parameter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`_.template()`方法通常接受两个参数。如果你传递模板字符串和数据，它将发送包含数据的完整HTML字符串给你。然而，如果你只传递模板字符串，它将返回一个函数，该函数接受数据作为参数。'
- en: Avoiding evaluation in templates
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免在模板中进行评估
- en: I learned about many template best practices from the Sencha library. Sencha's
    `XTemplate` functionality doesn't let you add any JavaScript code evaluation inside
    the template string, but it provides a number of variables and options to add
    the custom functions that help keep the templates clean; I never found any issues
    while creating complex templates.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 Sencha 库中学到了许多模板最佳实践。Sencha 的 `XTemplate` 功能不允许你在模板字符串中添加任何 JavaScript 代码评估，但它提供了一系列变量和选项来添加自定义函数，这有助于保持模板的整洁；我在创建复杂模板时从未遇到过任何问题。
- en: 'The Underscore.js template and most other template engines provide a functionality
    to evaluate the JavaScript code inside the template. On one hand, this looks pretty
    ugly, and on the other hand, it adds to the complexity as the number of templates
    increase in the project. Placing some JavaScript logic inside your template makes
    it very difficult to manage your code. So it is advisable to separate the JavaScript
    code from your HTML markup:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js 模板和大多数其他模板引擎都提供了一种在模板内部评估 JavaScript 代码的功能。一方面，这看起来相当难看，另一方面，随着项目中模板数量的增加，它也增加了复杂性。在模板中放置一些
    JavaScript 逻辑会使代码管理变得非常困难。因此，建议将 JavaScript 代码与你的 HTML 标记分离：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'While displaying a list of employees, we need to iterate through the list and
    display the employee names. Underscore.js doesn''t provide any inbuilt mechanism
    for this, but we can use a subtemplate here that excludes the evaluation part
    from this code. The subtemplate will be simple, such as this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当展示员工列表时，我们需要遍历列表并显示员工姓名。Underscore.js 没有提供任何内置机制来完成这项工作，但我们可以在这里使用一个子模板，将评估部分从这段代码中排除。这个子模板将很简单，例如：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will iterate through the list in your JavaScript code, use this subtemplate
    to render only this `li` element, and then append the element to the main element.
    Though it might take a little more effort this way, it will help you avoid JavaScript
    evaluation in your template.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 JavaScript 代码中遍历列表，使用这个子模板仅渲染这个 `li` 元素，然后将元素附加到主元素上。虽然这样做可能需要更多努力，但它将帮助你避免在模板中进行
    JavaScript 评估。
- en: On the other hand, there are template engines such as HandleBars.js that provide
    inbuilt logic (for instance, looping, passing contexts, if-unless block helpers,
    and so on). So, if you feel that subtemplating involves more work, you can go
    for a better template library that may not be as lightweight as Underscore but
    provides more inbuilt helper functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些模板引擎，如 HandleBars.js，提供了内置逻辑（例如循环、传递上下文、if-unless 块辅助函数等）。因此，如果你觉得子模板需要更多的工作，你可以选择一个更好的模板库，它可能不像
    Underscore 那样轻量级，但提供了更多的内置辅助函数。
- en: Another idea to avoid evaluation in your template is to use helper functions.
    Let's take a look at them in the following section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在模板中进行评估的另一个想法是使用辅助函数。让我们在下一节中看看它们。
- en: Using template helper functions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板辅助函数
- en: 'It is quite easy to use template helper functions. Imagine a situation where
    you are displaying a user''s profile in your application. In the place of user''s
    avatar, either you need to show a photo of the user or you must show a default
    avatar image. This is how you will write that condition in your template:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板辅助函数相当简单。想象一下这样的场景：在你的应用程序中展示用户资料时，在用户头像的位置，你可能需要显示用户的照片，或者必须显示默认的头像图片。这就是你在模板中编写该条件的方式：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is an option, but we already decided not to evaluate JavaScript inside
    our templates. The helper function may come handy here. Try this function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个选项，但我们已经决定不在我们的模板中评估 JavaScript。辅助函数在这里可能很有用。尝试这个函数：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, while you are passing the data into the `_.template()` method, you need
    to make sure the template methods reside there as properties or subproperties.
    The question is why do we need to add the helper function as a part of the data?
    The reason is that most template libraries, including Underscore's template, create
    the data object that is passed to it the context of the function. So, the helper
    function is called on the context of data and can only be available in that way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你将数据传递给 `_.template()` 方法时，你需要确保模板方法作为属性或子属性存在。问题是为什么我们需要将辅助函数作为数据的一部分添加？原因是大多数模板库，包括
    Underscore 的模板，都会创建一个数据对象，并将其作为函数的上下文传递给它。因此，辅助函数是在数据的上下文中调用的，并且只能以这种方式可用。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are a number of template engines that have some of the previous solutions
    inbuilt. If you are developing a small application, you may find Underscore's
    micro-templating solution enough for development. But if you are going to have
    complex templates in your application, we would recommend going for `Handlebars`,
    a popular and well accepted template engine.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多模板引擎内置了一些之前的解决方案。如果您正在开发一个小型应用程序，您可能会发现 Underscore 的微模板解决方案足够用于开发。但如果您打算在应用程序中使用复杂的模板，我们建议选择
    `Handlebars`，这是一个流行且广受欢迎的模板引擎。
- en: Understanding automatic model-view data binding
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自动模型-视图数据绑定
- en: 'Whenever an attribute of the attached model changes, we refresh the view to
    display the updated data. A `change` event listener is attached to the model inside
    the `initialize()` method of the view as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加模型的任何属性发生变化时，我们会刷新视图以显示更新后的数据。在视图的 `initialize()` 方法中，我们为模型附加了一个 `change`
    事件监听器，如下所示：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, there are options that can handle this data binding automatically and
    you do not need to take care of it for every model-view relationship. This principle
    is more aligned towards the MVVM design pattern than the Backbone's MV* pattern,
    and you will find it in frameworks such as `Knockout.js` and `Meteor.js`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些选项可以自动处理这种数据绑定，您不需要为每个模型-视图关系处理它。这个原则比 Backbone 的 MV* 模式更接近 MVVM 设计模式，您可以在
    `Knockout.js` 和 `Meteor.js` 等框架中找到它。
- en: For Backbone, there are multiple plugins such as `Backbone.Stickit` ([http://nytimes.github.io/backbone.stickit/](http://nytimes.github.io/backbone.stickit/)),
    `Backbone.ModelBinder` ([https://github.com/theironcook/Backbone.ModelBinder](https://github.com/theironcook/Backbone.ModelBinder)),
    and `Rivets.js` ([http://www.rivetsjs.com/](http://www.rivetsjs.com/)). These
    plugins provide a similar data binding feature. We are not going to discuss each
    plugin here; however, the implementation process is simple and similar for all
    of these plugins. If you wish to use such functionality, look into these plugins
    and use the one that fits your needs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Backbone，有多个插件，例如 `Backbone.Stickit` ([http://nytimes.github.io/backbone.stickit/](http://nytimes.github.io/backbone.stickit/))、`Backbone.ModelBinder`
    ([https://github.com/theironcook/Backbone.ModelBinder](https://github.com/theironcook/Backbone.ModelBinder))
    和 `Rivets.js` ([http://www.rivetsjs.com/](http://www.rivetsjs.com/))。这些插件提供了类似的数据绑定功能。我们在这里不会讨论每个插件；然而，这些插件的实现过程简单且相似。如果您希望使用此类功能，请查看这些插件并使用适合您需求的插件。
- en: Using Marionette's ItemView, CollectionView, and CompositeView
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Marionette 的 ItemView、CollectionView 和 CompositeView
- en: Marionette ([http://marionettejs.com/](http://marionettejs.com/)) is a composite
    application library for Backbone.js. Developed by Derick Bailey, it is a collection
    of common patterns and solutions to Backbone problems. It is a great library and
    lots of developers use it for their Backbone-based applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette ([http://marionettejs.com/](http://marionettejs.com/)) 是一个用于 Backbone.js
    的复合应用程序库。由 Derick Bailey 开发，它是一组常见的模式和解决方案，用于解决 Backbone 的问题。这是一个很棒的库，许多开发者都将其用于他们的基于
    Backbone 的应用程序。
- en: One important thing about Marionette is that it offers several separate packages
    for views, regions, and so on, and allows you to use any of them freely without
    requiring the complete library. In this section, we will explore Marionette's
    `ItemView`, the `CollectionView`, and the `CompositeView` functionalities. These
    views solve a number of problems we discussed in the previous sections.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Marionette 的一个重要事情是它为视图、区域等提供了几个独立的包，并允许您自由使用它们，而无需使用完整的库。在本节中，我们将探讨 Marionette
    的 `ItemView`、`CollectionView` 和 `CompositeView` 功能。这些视图解决了我们在上一节中讨论的许多问题。
- en: ItemView
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ItemView
- en: '`ItemView` represents a single view for an item, it can be a model view or
    a collection view. It extends the `Marionette.View` class, which is a core view
    with a number of reusable functions. `Marionette.View` takes care of triggering,
    delegating, and undelegating events.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemView` 代表一个项目的单个视图，它可以是模型视图或集合视图。它扩展了 `Marionette.View` 类，这是一个具有许多可重用函数的核心视图。`Marionette.View`
    负责触发、委派和取消委派事件。'
- en: 'If you plan to use Marionette, views with a model or a collection should extend
    the `ItemView` class. It provides a number of functionalities including:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划使用 Marionette，具有模型或集合的视图应该扩展 `ItemView` 类。它提供了一系列功能，包括：
- en: A `serializeData()` method that is a generic method to return data for the model
    or collection that is attached to the view.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `serializeData()` 方法，这是一个通用方法，用于返回视图附加的模型或集合的数据。
- en: A `close()` method that takes care of removing views from DOM and cleanup resources.
    This is similar to the `close()` method of the `BaseView` class we learned in
    [Chapter 1](ch01.html "Chapter 1. Reducing Boilerplate with Plugin Development"),
    *Reducing Boilerplate with Plugin Development*.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `close()` 方法，负责从 DOM 中移除视图并清理资源。这与我们在 [第 1 章](ch01.html "第 1 章。通过插件开发减少样板代码")
    中学习的 `BaseView` 类的 `close()` 方法类似，*通过插件开发减少样板代码*。
- en: 'Some custom events such as:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些自定义事件，例如：
- en: The `'render' / onRender` event
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''render'' / onRender` 事件'
- en: The `'before:render' / onBeforerender` event
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''before:render'' / onBeforerender` 事件'
- en: The `'close' / onClose` event
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''close'' / onClose` 事件'
- en: The `'before:close' / onBeforeClose` event
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''before:close'' / onBeforeClose` 事件'
- en: 'Let''s look into a basic `ItemView` class definition as shown in the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中所示的基本 `ItemView` 类定义：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will create an instance of this and pass the model to it as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个实例并按照以下方式传递模型：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is an example of a simple `ItemView` class, where we pass the model and
    use its methods to display the data. Have a look, we didn''t provide any `render()`
    method definition here. It is because `ItemView` provides a simple rendering functionality
    by default. `ItemView` has a `serializeData()` method that sends the model data
    or the collection data attached to this view, and the `render()` method applies
    this data to its template and populates the view automatically with generated
    HTML content. Here is how the `serializeData()` method looks in Marionette:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 `ItemView` 类的示例，其中我们传递模型并使用其方法来显示数据。看看，我们没有提供任何 `render()` 方法定义。这是因为
    `ItemView` 默认提供简单的渲染功能。`ItemView` 有一个 `serializeData()` 方法，它发送模型数据或附加到该视图的集合数据，而
    `render()` 方法将此数据应用于其模板，并自动用生成的 HTML 内容填充视图。以下是 Marionette 中 `serializeData()`
    方法的样子：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, `ItemView` expects a template, a model, or a collection, and it reduces
    the initial boilerplate to render the view on its own. As you can see, a number
    of basic and reusable functionalities are handled in the `ItemView` class. It
    provides all the functions that we discussed in our `BaseView` class. Using it
    as a base class for your views can give a lot of flexibility while writing Backbone.js
    based applications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ItemView` 期望一个模板、一个模型或一个集合，并且它减少了渲染视图的初始样板代码。正如你所见，许多基本和可重用的功能都在 `ItemView`
    类中处理。它提供了我们在 `BaseView` 类中讨论的所有功能。将其用作视图的基础类可以为基于 Backbone.js 的应用程序提供很多灵活性。
- en: CollectionView
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CollectionView
- en: A `CollectionView` class, as the name suggests, shows a list of items for each
    model item in the specified collection. The functionality is similar to the previous
    example, but much more robust with subviews. A `CollectionView` class creates
    an instance of `ItemView` for each data item and appends its elements to the main
    view's `el`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionView` 类，正如其名所示，显示指定集合中每个模型项的项列表。其功能与前面的示例类似，但具有更强大的子视图功能。`CollectionView`
    类为每个数据项创建一个 `ItemView` 实例并将其元素追加到主视图的 `el`。'
- en: 'Some of the common features of `CollectionView` are:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionView` 的某些常见功能包括：'
- en: Creating, adding, and removing child views.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、添加和删除子视图。
- en: Displaying an empty view when the collection is empty.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合为空时显示空视图。
- en: Automatic rendering and re-rendering for `'add'`, `'remove'`, and `'reset'`
    events of the collections, where the collection view automatically renders the
    changes.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的 `'add'`、`'remove'` 和 `'reset'` 事件的自动渲染和重新渲染，其中集合视图自动渲染更改。
- en: 'Provides a number of useful custom events:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了多个有用的自定义事件：
- en: The `'render' / onRender` event
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''render'' / onRender` 事件'
- en: The `'before:render' / beforeRender` event
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''before:render'' / beforeRender` 事件'
- en: The `'closed' / 'collection:closed'` event
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''closed'' / ''collection:closed''` 事件'
- en: The `'before:item:added' / 'after:item:added'` event
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''before:item:added'' / ''after:item:added''` 事件'
- en: The `'item:removed'` event
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''item:removed''` 事件'
- en: The `'itemview:*'` event bubbling from child views
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从子视图中冒泡的 `'itemview:*'` 事件
- en: Includes a `close()` method that removes the child views before closing.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个 `close()` 方法，在关闭之前移除子视图。
- en: 'Now let''s use the previous `UserItemView` class as the child item and create
    a `CollectionView` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用之前的 `UserItemView` 类作为子项并创建一个 `CollectionView` 类：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Look how small the code is when compared to the code we developed earlier in
    this chapter to display a list of items. We just pass the class name `UserItemView`
    in the `CollectionView` instance as `itemView`, and it takes care of everything
    from rendering to destroying child items when the parent view gets removed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 比较一下，与我们在本章早期开发的用于显示项目列表的代码相比，代码量是多么的小。我们只需在`CollectionView`实例中将类名`UserItemView`作为`itemView`传递，它就会负责从渲染到在父视图被移除时销毁子项的所有事情。
- en: Marionette's `CollectionView` reduces the boilerplate in your code to a great
    extent. If you are developing an application with multiple list type views, you
    can produce much cleaner code using Marionette's collection view, as it takes
    out most of the reusable functionality itself.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette的`CollectionView`在很大程度上减少了你的代码中的样板代码。如果你正在开发一个具有多个列表视图的应用程序，你可以使用Marionette的集合视图生成更干净的代码，因为它自己提取了大部分可重用功能。
- en: Working with CompositeView
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`CompositeView`
- en: A `CompositeView` extends from the `Marionette.CollectionView` class. In general,
    you can think of it as a combination of `ItemView` and `CollectionView`, where
    it accepts a model that represents a single dataset and a collection that displays
    multiple data. This is particularly useful when you have a hierarchical or a tree-like
    structure. You can relate it to the figure we mentioned in the *Re-rendering parent
    views* section. There we had to show data for the `Company` model and `Employees`
    collection together, and `CompositeView` would have been an excellent tool to
    provide a compact solution for that.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompositeView`扩展自`Marionette.CollectionView`类。一般来说，你可以将其视为`ItemView`和`CollectionView`的组合，其中它接受一个表示单个数据集的模型和一个显示多个数据的集合。这在你有层次结构或树状结构时特别有用。你可以将其与我们提到的*重新渲染父视图*部分联系起来。在那里，我们必须一起显示`Company`模型和`Employees`集合的数据，而`CompositeView`将是一个提供紧凑解决方案的绝佳工具。'
- en: 'A composite view provides some specific functionalities apart from the basic
    `CollectionView` functions, which can be explained as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 组合视图除了基本的`CollectionView`功能外，还提供了一些特定的功能，具体说明如下：
- en: Model data of `CompositeView` is applied to its template property.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompositeView`的模型数据应用于其模板属性。'
- en: It has an `itemViewContainer` property that specifies within which element the
    collection view will be rendered. The `itemViewContainer` property should either
    be a jQuery selector or a jQuery object, or it can be a function that returns
    a jQuery selector or jQuery object.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个`itemViewContainer`属性，用于指定集合视图将在哪个元素内渲染。`itemViewContainer`属性可以是jQuery选择器或jQuery对象，或者它可以是返回jQuery选择器或jQuery对象的函数。
- en: 'When `itemViewContainer` is not sufficient for specifying the exact position
    of `ItemView`, overriding the `appendHtml()` method of `CollectionView` may provide
    the desired result, as shown in the following code snippet:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`itemViewContainer`不足以指定`ItemView`的确切位置时，覆盖`CollectionView`的`appendHtml()`方法可能提供所需的结果，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s assume a scenario where we want to display company details along with
    a list of the employees. So, there will be a `Company` model, as shown in the
    following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个场景，需要显示公司详情以及员工列表。因此，将会有一个`Company`模型，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similarly, there must be an `Employee` model for each employee too, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，每个员工也必须有一个`Employee`模型，如下所示：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s define an `Employees` collection for the employee list, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`Employees`集合来表示员工列表，如下所示：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For the composite view, we want to present each employee as a separate `ItemView`
    instance so that event delegation becomes easy:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组合视图，我们希望将每个员工表示为一个单独的`ItemView`实例，以便于事件委托：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can define the composite view that will display the model data and the
    collection data together, as shown in the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个组合视图，它将一起显示模型数据和集合数据，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we first defined a template where we kept a place for the employee list
    to go. Then we mentioned the `itemView` option as the `EmployeeView` class that
    will be used by the collection to create an instance and populate it with each
    employee data. These item views will be stacked in the element mentioned in the
    `itemViewContainer` property. Now, let''s create the composite view instance,
    add a company to it, and render it, as shown in the following code snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义了一个模板，其中我们为员工列表留出了位置。然后我们提到了 `itemView` 选项，即 `EmployeeView` 类，该类将由集合使用以创建实例，并用每个员工的数据填充它。这些项目视图将堆叠在
    `itemViewContainer` 属性中提到的元素中。现在，让我们创建复合视图实例，向其中添加一个公司，并渲染它，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The result we get is as shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如下面的截图所示：
- en: '![Working with CompositeView](img/3576OS_02_02.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![与CompositeView一起工作](img/3576OS_02_02.jpg)'
- en: So, you can see that a composite view provides a compact mechanism to display
    a model and a collection associated to it in a single view. You may have a tree
    structure data, and for that, multiple composite views need to be created. By
    default, the rendering mechanism of a composite view is hierarchical in nature
    and the `itemView` property is of the `CompositeView` type, if not overridden.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到复合视图提供了一种紧凑的机制，可以在单个视图中显示与模型关联的模型和集合。您可能有一个树状结构的数据，为此需要创建多个复合视图。默认情况下，复合视图的渲染机制是层次性的，如果未覆盖，则
    `itemView` 属性为 `CompositeView` 类型。
- en: We hope we gave you a basic idea of all the Marionette views. Discussing all
    these views in an advanced level is beyond the scope of this book, but the Marionette
    docs will give you a complete description of the framework. We mention some resources
    and books about Marionette in [Appendix A](apa.html "Appendix A. Books, Tutorials,
    and References"), *Books, Tutorials, and References*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们向您提供了所有 Marionette 视图的基本概念。讨论这些视图的高级内容超出了本书的范围，但 Marionette 文档将为您提供框架的完整描述。我们在
    [附录 A](apa.html "附录 A. 书籍、教程和参考资料") 中提到了关于 Marionette 的资源和书籍，*书籍、教程和参考资料*。
- en: Using Layout Manager
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Layout Manager
- en: When you work with multiple views in an application, it often becomes difficult
    to manage activities such as multiple view rendering, adding animation to an element,
    or replacing a view with another view. Let's look into a great extension, `LayoutManager`
    ([https://github.com/tbranyen/backbone.layoutmanager](https://github.com/tbranyen/backbone.layoutmanager)),
    which provides a logical foundation to assemble layouts and views within the application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在应用程序中处理多个视图时，管理诸如多个视图渲染、向元素添加动画或用另一个视图替换视图等活动往往变得困难。让我们看看一个优秀的扩展，`LayoutManager`
    ([https://github.com/tbranyen/backbone.layoutmanager](https://github.com/tbranyen/backbone.layoutmanager))，它为在应用程序中组装布局和视图提供了逻辑基础。
- en: Marionette too provides a similar functionality with its `RegionManager`, but
    we chose to discuss the `LayoutManager` plugin here because not everyone uses
    Marionette and this plugin can work independently with your Backbone app. If you
    are already using Marionette, I advise you to verify whether `RegionManager` solves
    your needs or not. Alternatively, you can use the `LayoutManager` plugin along
    with Marionette.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette 也提供了类似的功能，通过其 `RegionManager`，但我们选择在这里讨论 `LayoutManager` 插件，因为并非每个人都使用
    Marionette，并且此插件可以独立与您的 Backbone 应用程序一起工作。如果您已经使用 Marionette，我建议您验证 `RegionManager`
    是否满足您的需求。或者，您可以使用 `LayoutManager` 插件与 Marionette 一起使用。
- en: 'The `LayoutManager` extension provides solutions to a number of pain points
    such as:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutManager` 扩展为解决许多痛点提供了解决方案：'
- en: It handles asynchronous rendering of views if you are planning to dynamically
    load your templates from external files
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您计划从外部文件动态加载模板，它处理视图的异步渲染
- en: It defines the layout as an HTML structure and assigns the views to proper elements
    as given in the layout configuration
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将布局定义为 HTML 结构，并将视图分配到布局配置中给出的适当元素
- en: 'It provides functionality to perform the following activities:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了执行以下活动的功能：
- en: Insert views, apply data to the given template, and auto render them
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入视图，将数据应用到给定的模板中，并自动渲染它们
- en: Retrieve or remove views depending on multiple selection criteria
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据多个选择标准检索或删除视图
- en: Cleans up views by unbinding all events from the view or from the model/collection
    that have this view as the context
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从视图或从作为上下文的模型/集合中解绑所有事件来清理视图
- en: 'We will look into these points by creating a simple layout as shown in the
    following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个简单的布局来探讨这些点，如下面的截图所示：
- en: '![Using Layout Manager](img/3576OS_02_01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![使用布局管理器](img/3576OS_02_01.jpg)'
- en: There is a list of users, and when you click on a user item, the user's details
    are displayed on the right-hand side of the layout. You will find the complete
    code example with all HTML, CSS, and other files in our sample code. Here we will
    describe the parts that are critical.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个用户列表，当你点击用户项时，用户的详细信息将显示在布局的右侧。你可以在我们的示例代码中找到包含所有 HTML、CSS 和其他文件的完整代码示例。在这里，我们将描述关键部分。
- en: 'We create a user model and collection first as shown in the following code
    snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个用户模型和集合，如下代码片段所示：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will have three views for this page: `UserList`, `UserItem`, and `UserDetails`
    views. The `UserItem` view will act as a subview of the `UserList` view. First,
    let''s write the templates for these three views:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个页面创建三个视图：`UserList`、`UserItem` 和 `UserDetails` 视图。`UserItem` 视图将作为 `UserList`
    视图的子视图。首先，让我们为这三个视图编写模板：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The view templates are pretty simple. The layout template, which defines the
    structure of the page, is the most important here. The task has three aspects:
    you have to divide the layout in a number of sections as you want, add proper
    styles to align them, and then define your views inside the `LayoutManager` configuration
    that will automatically render the views inside these sections.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模板相当简单。定义页面结构的布局模板在这里是最重要的。任务有三个方面：你必须根据需要将布局分成多个部分，添加适当的样式以对齐它们，然后在 `LayoutManager`
    配置中定义你的视图，这些视图将自动在这些部分中渲染。
- en: First, we will define the user list item that will display only the name of
    the user.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义用户列表项，它将只显示用户的姓名。
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice the two new properties here: manage and serialize. The `manage` property
    is a Boolean property that determines whether a view will be treated as a layout
    or not. The `manage` property must be set to `true` if you intend to use the view
    inside the layout manager and handle its rendering function. You can also set
    it to `true` globally for all the views and specify it as `FALSE` if required
    for a particular view.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里有两个新属性：manage 和 serialize。`manage` 属性是一个布尔属性，用于确定视图是否被视为布局。如果你打算在布局管理器内部使用视图并处理其渲染函数，则必须将
    `manage` 属性设置为 `true`。你也可以将其全局设置为 `true`，对于特定视图，如果需要，可以将其设置为 `FALSE`。
- en: '`LayoutManager` uses the `serialize()` method to apply the data to the view''s
    template. The default implementation of the `serialize()` method returns an empty
    object. You should override it to send the data you want to display. Here we are
    sending the model data associated with the view.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutManager` 使用 `serialize()` 方法将数据应用到视图的模板中。`serialize()` 方法的默认实现返回一个空对象。你应该重写它以发送你想要显示的数据。在这里，我们发送与视图关联的模型数据。'
- en: '`LayoutManager` provides two custom events, `beforeRender` and `afterRender`,
    to a view as it takes care of the render function itself. While using the `beforeRender()`
    method, the element of the view isn''t yet available, but if you insert a view
    into the layout, `LayoutManager` keeps track of it and renders it once the parent
    view is available in DOM. We can use this method where we will iterate through
    the users'' collection and insert the `UserItem` view to the list view:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutManager` 为视图提供了两个自定义事件，`beforeRender` 和 `afterRender`，因为它自己处理渲染函数。当使用
    `beforeRender()` 方法时，视图的元素尚未可用，但如果你将视图插入到布局中，`LayoutManager` 会跟踪它，并在父视图在 DOM 中可用时进行渲染。我们可以使用此方法在用户集合上迭代并插入
    `UserItem` 视图到列表视图中：'
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are two similar methods `insertView`/`insertViews` and `setView`/`setViews`.
    Both these functions insert views into the layout according to the given selector
    name. The `setView()` method takes an extra `insert` parameter, which is a Boolean
    value, and determines whether the view will replace the complete content of the
    selector or will simply append to it. We create `UserItem` views, attach models
    to them, and insert them into the `UserList` view. The child views get automatically
    rendered inside.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个类似的方法 `insertView`/`insertViews` 和 `setView`/`setViews`。这两个函数都根据给定的选择器名称将视图插入到布局中。`setView()`
    方法有一个额外的 `insert` 参数，它是一个布尔值，用于确定视图是否会替换选择器的完整内容，或者只是简单地附加到它。我们创建 `UserItem` 视图，将模型附加到它们，并将它们插入到
    `UserList` 视图中。子视图将自动在内部渲染。
- en: 'We are done with the basic list definition. Now, let''s define the layout manager
    functionality as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了基本列表定义。现在，让我们定义布局管理器的功能如下：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `LayoutManager` is also a type of `Backbone.View`, and you can render it
    as you do for any other Backbone view. In the `views` property, we can specify
    one or more view instances. In our case, we created the `UserList` instance, passed
    the collection to it, and let the `LayoutManager` take care of everything else
    to render it inside the `.user-list` element.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutManager` 也是一种 `Backbone.View` 类型，你可以像对任何其他 Backbone 视图一样渲染它。在 `views`
    属性中，我们可以指定一个或多个视图实例。在我们的例子中，我们创建了 `UserList` 实例，将其集合传递给它，并让 `LayoutManager` 负责其他所有渲染到
    `.user-list` 元素中的工作。'
- en: 'So, up to this point, we have our layout rendered with the user list inside.
    The only action remaining is to display the user details once we click a user
    item. Let''s define the `UserDetails` view, which is a simple one:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们已经渲染了包含用户列表的布局。剩下的唯一动作是在我们点击用户项时显示用户详情。让我们定义 `UserDetails` 视图，这是一个简单的视图：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is exactly the same as our `UserItem` view definition with an extra `setModel()`
    method that sets the model to the selected one. Now we will insert this view into
    the layout when we click a list item. For that, we will add a click event handler
    to the `UserItem` view as shown in the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的 `UserItem` 视图定义完全相同，只是多了一个 `setModel()` 方法，该方法将模型设置为所选的模型。现在，当我们在列表项上点击时，我们将插入这个视图。为此，我们将向
    `UserItem` 视图添加一个点击事件处理器，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We use the `getView` method that can retrieve a view based on multiple criterion
    such as selector, model, or function. We check whether the details view is available
    or not. If not, we create a `DetailsView` instance, set the model, and render
    it. Otherwise, we reset the model and re-render the view.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `getView` 方法，可以根据多个标准检索视图，如选择器、模型或函数。我们检查详情视图是否可用。如果没有，我们创建一个 `DetailsView`
    实例，设置模型，并渲染它。否则，我们重置模型并重新渲染视图。
- en: So, we are done with the complete layout management. It is observed that most
    of the rendering functionalities are handled by the manager itself. This is just
    a basic example; `LayoutManager` can provide many more options and functionalities
    and eliminate 90 percent of your view management tasks. Do read their documentation
    thoroughly as you will be able to use most of it in your application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了完整的布局管理。观察到大多数渲染功能都是由管理器本身处理的。这只是一个基本示例；`LayoutManager` 可以提供更多选项和功能，并消除你90%的视图管理任务。务必彻底阅读它们的文档，因为你在应用程序中能够使用其中的大部分。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone through a number of important problems most Backbone
    developers come across, and learned multiple solutions to solve them. First, we
    discussed the partial view rendering and nested views. Any Backbone application
    needs to deal with nested views and if we can maintain their initialization, DOM
    reflow, and cleanup properly, it will greatly enhance the performance of the whole
    application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了大多数 Backbone 开发者会遇到的一些重要问题，并学习了多种解决方案来解决这些问题。首先，我们讨论了部分视图渲染和嵌套视图。任何
    Backbone 应用都需要处理嵌套视图，如果我们能正确维护它们的初始化、DOM 重新流和清理，这将大大提高整个应用程序的性能。
- en: We spoke about different template-handling methods, saw a number of solutions
    to load precompiled templates from external files, organized templates within
    applications, and understood how helper functions can eliminate evaluation of
    JavaScript codes inside templates and help us to create cleaner templates.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了不同的模板处理方法，看到了从外部文件加载预编译模板的多种解决方案，组织了应用程序内的模板，并了解了辅助函数如何消除模板内 JavaScript
    代码的评估，并帮助我们创建更干净的模板。
- en: 'Finally, we learned about some of the very important extensions: Marionette''s
    `ItemView`, `CollectionView`, `CompositeView`, and `LayoutManager`. All of these
    extensions provide great flexibility by taking out a lot of boilerplate code and
    managing your views by a great deal.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了一些非常重要的扩展：Marionette 的 `ItemView`、`CollectionView`、`CompositeView` 和
    `LayoutManager`。所有这些扩展通过移除大量样板代码并通过大量管理视图提供了极大的灵活性。
- en: In the next chapter, we will talk about Backbone models; we will look into model
    data validation, different plugins for validation, model serialization, and the
    relational data model.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Backbone 模型；我们将探讨模型数据验证、不同的验证插件、模型序列化和关系数据模型。
