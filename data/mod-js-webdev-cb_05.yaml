- en: Testing and Debugging Your Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试你的服务器
- en: 'In this chapter, we will look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到以下的方法：
- en: Adding logging with Winston
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Winston添加日志记录
- en: Adding HTTP logging with Morgan
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 使用Morgan添加HTTP日志记录'
- en: Configuring your server for different environments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同环境配置你的服务器
- en: Unit testing your code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 对你的代码进行单元测试'
- en: Measuring your test coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 测量你的测试覆盖率'
- en: Debugging your code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 调试你的代码'
- en: Testing simple services from the command line
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行测试简单服务
- en: Testing more complex sequences of calls with Postman
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 使用Postman测试更复杂的调用序列'
- en: Documenting and testing your REST API with Swagger
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Swagger记录和测试你的REST API
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapters, we installed `Node` and created a RESTful server.
    Is everything ready? Usually, things don't work out that well—bugs will creep
    in, and you'll have to find out how to fix your code. In this chapter, we'll be
    getting into practical details, such as testing and debugging your server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们安装了`Node`并创建了一个RESTful服务器。一切准备好了吗？通常情况下，事情不会那么顺利——bug会悄悄地爬进来，你将不得不找出如何修复你的代码。在本章中，我们将进入实际细节，比如测试和调试你的服务器。
- en: So, after this chapter, you'll have your `Node` RESTful server ready for deployment
    and for official production work. Let's get into the necessary tasks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在本章之后，你的`Node` RESTful服务器将准备好部署和正式生产工作。让我们开始必要的任务。
- en: Adding logging with Winston
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 使用Winston添加日志记录'
- en: 'Let''s start with a simple, basic need: *logging*. Having solid, correct logging
    set up can help you find problems quickly, while incomplete or otherwise lacking
    logging can make you look for hours for what could be a simple, trivial problem.
    A basic rule for any application is to ensure that proper login is set up so that
    you can be confident that any situation that comes up will at least be recognized
    and recorded for future analysis.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的基本需求开始：*日志记录*。建立稳固、正确的日志记录可以帮助你快速找到问题，而不完整或其他缺乏的日志记录可能会让你寻找几个小时，而问题可能只是一个简单的琐事。任何应用程序的基本规则是确保设置适当的登录，这样你就可以确信任何出现的情况至少会被识别和记录以供将来分析。
- en: 'The first idea you could have is to just use the console family of functions,
    such as `console.log()`, `console.warn()`, `console.info()`, and more. (For a
    complete reference, check out [https://developer.mozilla.org/en-US/docs/Web/API/console](https://developer.mozilla.org/en-US/docs/Web/API/console).)
    While these are good for quick debugging, they just don''t do it for application-level
    logging. You should be able to select what kind of logs you want (everything?
    Errors only?) to decide what logs you see depending on your environment (for example,
    you''d want to see some kinds of logs in development but not in production), or
    even to enable or disable logging. And, finally, we want to have some control
    over the provided information:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能的第一个想法是只使用控制台系列函数，比如`console.log()`，`console.warn()`，`console.info()`等。（有关完整参考，请查看[https://developer.mozilla.org/en-US/docs/Web/API/console](https://developer.mozilla.org/en-US/docs/Web/API/console)。）虽然这些对于快速调试很好，但对于应用级别的日志记录来说并不够。你应该能够选择你想要的日志类型（全部？仅错误？）来决定你在不同环境下看到的日志（例如，在开发中你可能想看到某些类型的日志，但在生产中不需要），甚至可以启用或禁用日志。最后，我们希望对提供的信息有一些控制：
- en: '*Timestamping*,to learn at what time each log was written'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- *时间戳*，了解每个日志写入的时间'
- en: '*Text formatting*,so logging can be understandable by humans, but also parseable
    by applications'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- *文本格式化*，使日志可以被人类理解，但也可以被应用程序解析'
- en: '*Level setting*, usually on a scale ranging from *error* (the most serious)
    through *warning*, *informative*, *verbose*, and ending with *debugging* and *silly*
    (yes, truly!)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*级别设置*，通常在一个范围内从*error*（最严重）到*warning*，*informative*，*verbose*，最后是*debugging*和*silly*（是的，真的！）'
- en: '*Destination picking*, like `stdout` or `stderr`, the filesystem, and so on'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择目的地*，比如`stdout`或`stderr`，文件系统等'
- en: 'If you look around in the `npm` listings, you''ll find many modules that can
    do logging: some are generic tools, and other are more specific ones. In our case,
    we''ll use `Winston` for generic, application-level logging, and we''ll turn to
    a different tool, `Morgan`, which is specifically tailored for HTTP traffic logging,
    as we''ll see in the next section.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`npm`列表中，你会发现许多可以进行日志记录的模块：有些是通用工具，而其他一些则更具体。在我们的情况下，我们将使用`Winston`进行通用的应用级别日志记录，并且我们将转向另一个工具`Morgan`，它专门用于HTTP流量日志记录，我们将在下一节中看到。
- en: You can learn more about `Winston` at [https://github.com/winstonjs/winston](https://github.com/winstonjs/winston).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '- 你可以在[https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)了解更多关于`Winston`的信息。'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We want to install `Winston`, so the first step will be to apply the time-honored
    method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '- 我们想要安装`Winston`，所以第一步将是应用这个历史悠久的方法：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Currently, version 3.0 is in beta, but by the time you get this book, it will
    almost certainly be out of beta and ready for production. (By the way, I installed
    the beta version by using a slightly changed command: `npm install winston@next
    --save`; otherwise, I''d have gotten a 2.x.x version.)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，版本3.0还处于测试版阶段，但当你拿到这本书的时候，它几乎肯定已经不再是测试版，而是准备投入生产了。（顺便说一句，我通过使用略微修改的命令安装了测试版：`npm
    install winston@next --save`；否则，我会得到一个2.x.x版本。）
- en: For (thorough!) documentation on `Winston`, check its own GitHub page at [https://github.com/winstonjs/winston](https://github.com/winstonjs/winston).
    Be careful with articles on the web, though, because there are some important
    changes in version 3, so most code won't work without some updating.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Winston`的（彻底的！）文档，请查看它自己的GitHub页面[https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)。不过要小心网络上的文章，因为在版本3中有一些重要的更改，所以大多数代码在没有更新的情况下是无法工作的。
- en: 'We want to look at a simple example about the usage of `Winston`. This package
    has many configuration parameters, so let''s try to get a basic, sane configuration
    going, which you''ll be able to extend on your own:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要看一个关于`Winston`使用的简单例子。这个包有许多配置参数，所以让我们尝试建立一个基本的、合理的配置，这样你就可以自己扩展了：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Winston` can handle several transports at the same time, and by *transport*,
    it means a storage device for whatever you log. A single logger may have multiple
    transports, but configured differently: for example, you may want to show all
    logs at the console, but only write a file with warnings and errors, and yet more
    possibilities include writing a database or sending data to some URL. Formats
    may also vary (text lines for the console, possibly JSON for a file?), so you
    have lots of flexibility regarding configuring where your messages will go.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Winston`可以同时处理多个传输，而*传输*意味着您记录的任何内容的存储设备。单个记录器可以有多个传输，但配置不同：例如，您可能希望在控制台上显示所有日志，但只在警告和错误时写入文件，还有更多可能性，包括写入数据库或将数据发送到某个URL。格式也可能不同（控制台的文本行，文件可能是JSON格式？），因此您在配置消息的输出位置方面有很大的灵活性。'
- en: 'In our case, we are creating three transports:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们创建了三个传输：
- en: '*A console output*, for all messages marked as `"info"` and above, using colorized
    output (we''ll see it in a short while), emitting output with a timestamp, a label
    (`"serv"`, to help distinguish the server''s messages from others that might show
    up in the console, coming from other applications), the error level, and a message'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制台输出*，用于所有标记为“info”及以上的消息，使用带有时间戳的着色输出（我们马上就会看到），发出带有时间戳、标签（“serv”）的输出，以帮助区分服务器的消息和可能出现在控制台上的其他应用程序的消息，错误级别和消息'
- en: '*A file output*, for all messages marked as `"warn"` and above, in text format'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个文件输出*，用于所有标记为“warn”及以上的消息，以文本格式'
- en: '*Another file output*, for the same messages, but in JSON format'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*另一个文件输出*，用于相同的消息，但以JSON格式'
- en: We'll look at how to adapt logging (and other features) later in this chapter,
    in the *Configuring your server for different environments* section, so you'll
    be able to be even more flexible in logging and other features.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分，*为不同环境配置服务器*，中看到如何调整日志记录（和其他功能），这样您就可以更加灵活地进行日志记录和其他功能。
- en: 'After having created the logger and defined the transports, all we have to
    do is use it, wherever we want. I''ll start with a very basic server so that we
    can focus on getting logging to work: we''ll just handle two routes—`/`, which
    will send back a message, and `/xyzzy`, which will simulate some program failure,
    instead of sending back a `"Nothing happens"` message.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了记录器并定义了传输后，我们只需在需要的地方使用它。我将从一个非常基本的服务器开始，这样我们就可以专注于使日志记录工作：我们只处理两个路由——`/`，它将发送一条消息，和`/xyzzy`，它将模拟一些程序故障，而不是发送一个“什么也没发生”的消息。
- en: 'At the beginning, we could log every request by hand—though we''ll get a better
    output with `Morgan`, as we''ll see afterwards. The following code does just that:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们可以手动记录每个请求——尽管我们将在之后看到，使用`Morgan`会得到更好的输出。以下代码就是这样做的：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, for each route, we can add some `info` or `debug` messages, as we may
    need:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个路由，我们可以添加一些`info`或`debug`消息，因为我们可能需要：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Handling wrong routes might produce a `warn` message, and in other unplanned
    situations, a direct `error`. For the former, I''m only listing the required route,
    and for the latter, both the error message and the traceback stack, to help in
    future debugging:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误路由可能会产生一个`warn`消息，在其他未经计划的情况下，会直接产生一个`error`。对于前者，我只列出了所需的路由，对于后者，列出了错误消息和回溯堆栈，以帮助未来调试：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We're set! Let's try it out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好了！让我们试一试。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After building the project, I ran the `Winston` logging code to catch all the
    produced logs. I tried it out with a sequence of calls, simulated with `curl`;
    we''ll be looking at how to do this in more complex tasks in later sections in
    this chapter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目后，我运行了`Winston`日志记录代码来捕获所有生成的日志。我用`curl`模拟了一系列调用进行了尝试；我们将在本章的后面部分中看到如何在更复杂的任务中执行此操作：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output on the console can be seen in the following screenshot. The normal
    lines are in green (yes, hard to see in a black and white book—sorry about that!),
    the warnings are yellow, and the errors are in red. The request for the non-existing
    `/invented` path ended in a warning, and the one for `/xyzzy` produced an error,
    since we tried to call a non-existent function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台上的输出可以在下面的截图中看到。正常行是绿色的（是的，在黑白书中很难看到，对此很抱歉！），警告是黄色的，错误是红色的。对于不存在的`/invented`路径的请求以警告结束，而对于`/xyzzy`的请求产生了一个错误，因为我们尝试调用一个不存在的函数：
- en: '![](img/5bacbfc1-3d5f-4ee8-a6f9-295db6fe93b0.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bacbfc1-3d5f-4ee8-a6f9-295db6fe93b0.png)'
- en: Winston's console output for a few dummy requests
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 温斯顿的控制台输出一些虚拟请求
- en: 'What got logged to the different log files? According to our specification,
    only the warning and the error messages were stored. The text file is basically
    the same as the console output, and that makes sense because the format specification
    we selected for those two transports is exactly the same:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的日志文件记录了什么？根据我们的规范，只有警告和错误消息被存储。文本文件基本上与控制台输出相同，这是有道理的，因为我们为这两个传输选择的格式规范完全相同：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The JSON file, on the other hand, is a bit reduced: each line includes an object
    with the `message` and `level` attributes, because we didn''t specify that anything
    in particular should be added. However, you can change that: read Winston''s documentation
    at [https://github.com/winstonjs/winston/blob/master/README.md](https://github.com/winstonjs/winston/blob/master/README.md),
    and you''ll have plenty of available possibilities:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，JSON文件有点简化：每行包括一个带有`message`和`level`属性的对象，因为我们没有指定应该添加什么。但是，您可以更改这一点：阅读温斯顿的文档[https://github.com/winstonjs/winston/blob/master/README.md](https://github.com/winstonjs/winston/blob/master/README.md)，您将有很多可用的可能性：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, we have a flexible way to log just about whatever we want to, but our HTTP
    logging was, in particular, a bit too skimpy, and that's a good reason to include
    `Morgan`, as we'll see.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一种灵活的方式来记录几乎我们想要的任何内容，但是我们的HTTP日志记录特别简略，这是包括`Morgan`的一个很好的理由，正如我们将看到的。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may also be interested in looking at other packages, such as `Bunyan` ([https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan))
    or `Pino` ([https://github.com/pinojs/pino](https://github.com/pinojs/pino));
    the latter is said to be the logging package with the best performance, but don't
    take my word for it—try it out! Finally, should you work on developing `npm` packages,
    then `debug` ([https://github.com/visionmedia/debug](https://github.com/visionmedia/debug)),
    which is basically a wrapper around `console` methods, could be your package of
    choice—and being quite simple, it also works for web applications and `Node`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还对其他软件包感兴趣，比如`Bunyan`（[https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan)）或`Pino`（[https://github.com/pinojs/pino](https://github.com/pinojs/pino)）；后者据说是性能最佳的日志软件包，但不要听我的，自己试试看！最后，如果你在开发`npm`软件包，那么`debug`（[https://github.com/visionmedia/debug](https://github.com/visionmedia/debug)）可能是你的首选软件包——它基本上是`console`方法的包装器，非常简单，也适用于Web应用和`Node`。
- en: Adding HTTP logging with Morgan
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Morgan添加HTTP日志
- en: 'In the previous section, we managed to provide a very basic HTTP logging feature
    when we included some middleware that did `Winston` logging:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，当我们包含了一些进行`Winston`记录的中间件时，我们成功提供了一个非常基本的HTTP记录功能：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While this worked, there is much more information that we could desire, such
    as the HTTP status code for the response, the processing time it required, and
    more, so let's add `Morgan` into the mix, since that package is specific for requests
    logging.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做可以工作，但我们可能还需要更多的信息，比如响应的HTTP状态码，所需的处理时间等，所以让我们将`Morgan`加入进来，因为该软件包专门用于请求记录。
- en: You can learn more about `Morgan` at [https://github.com/expressjs/morgan](https://github.com/expressjs/morgan).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/expressjs/morgan](https://github.com/expressjs/morgan)了解更多关于`Morgan`的信息。
- en: In this recipe, we'll add `Morgan` to our software stack so that we can get
    better logs for all the processed requests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将`Morgan`添加到我们的软件堆栈中，以便为所有已处理的请求获得更好的日志。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by installing `Morgan` with the usual method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从常规方法开始安装`Morgan`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we must include it in our server, and we''ll also require the `fs` package
    in order to write `Morgan`''s logs to a file. Note that I''m adding to our previous
    server, so the `Winston` parts will be in place, unchanged from what we saw in
    the previous section:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在服务器中包含它，并且我们还需要`fs`软件包来将`Morgan`的日志写入文件。请注意，我是在我们之前的服务器上添加的，所以`Winston`的部分将保持不变，与我们在上一节中看到的一样：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We want to do some general logging to a file, and also all errors (HTTP status
    code 400 and higher) to the console, so we''ll have to add `morgan` twice to our
    middleware stack. The first parameter to `morgan` defines how the log messages
    will be formed: you have to provide either a function to generate the message
    that will be logged, or a string with tokens that `morgan` will replace at runtime.
    In the following code snippet, I used both styles, just for variety: a function
    for the file output, and a string for the console:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要对文件进行一些一般性的记录，以及所有错误（HTTP状态码为400及更高）输出到控制台，所以我们必须将`morgan`添加两次到我们的中间件堆栈中。`morgan`的第一个参数定义了日志消息的形式：你必须提供一个函数来生成将被记录的消息，或者一个包含`morgan`将在运行时替换的标记的字符串。在下面的代码片段中，我使用了两种风格，只是为了多样化：文件输出使用函数，控制台使用字符串：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second option to `morgan` lets you add some options, such as the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`morgan`的第二个选项允许你添加一些选项，例如以下内容：'
- en: '`immediate`, meaning that requests will be logged as soon as they come in (`immediate:true`)
    or after they''ve been processed (`immediate:false`). The advantage of the former
    is that you are sure that all requests will be logged, even in the case of a serious
    crash, but the latter provides more information.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`immediate`，意味着请求将在进来时立即记录（`immediate:true`）或在处理后记录（`immediate:false`）。前者的优势在于你可以确保所有请求都会被记录，即使发生严重崩溃，但后者提供了更多信息。'
- en: '`skip()`, a function that lets you decide whether to log a given request or
    not. In our case, we''ll use it to just log requests that get a 400 or higher
    status.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip()`，一个函数，让你决定是否记录给定的请求。在我们的情况下，我们将使用它来记录得到400或更高状态的请求。'
- en: '`stream`, to which the output should be written.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream`，输出应写入的流。'
- en: 'When specifying the output format, you have access to several pieces of data,
    called *tokens* in Morgan''s parlance, such as the following, but check the documentation
    for the full list:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定输出格式时，你可以访问多个数据片段，称为Morgan术语中的*标记*，例如以下内容，但请查阅完整列表的文档：
- en: '| `:date[format]` | Current date and time in UTC, in several formats |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `:date[format]` | 当前日期和时间（以UTC时间）以多种格式显示 |'
- en: '| `:http-version` | HTTP version of the request |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `:http-version` | 请求的HTTP版本 |'
- en: '| `:method` | HTTP method of the request |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `:method` | 请求的HTTP方法 |'
- en: '| `:remote-addr` | Remote address of the request |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `:remote-addr` | 请求的远程地址 |'
- en: '| `:req[header]` | The given header of the request, or "-" if the header isn''t
    present |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `:req[header]` | 请求的给定标头，如果标头不存在则为“-” |'
- en: '| `:res[header]` | The given header of the response, or "-" if the header isn''t
    present  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `:res[header]` | 响应的给定标头，如果标头不存在则为“-” |'
- en: '| `:response-time` | Processing time, in milliseconds |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `:response-time` | 处理时间，以毫秒为单位 |'
- en: '| `:status` | HTTP status of the response |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `:status` | 响应的HTTP状态 |'
- en: '| `:url` | URL of the request |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `:url` | 请求的URL |'
- en: You can see that I used several of these tokens when setting up `Morgan`'s output.
    Now, let's see this works.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我在设置`Morgan`的输出时使用了几个这些标记。现在，让我们看看它是如何工作的。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s give this a whirl, using the same examples that we used for `winston`.
    Since we set the console output to show only warnings and errors, we''ll just
    see an added pair of lines. Displaying `[http]` instead of `[serv]` helps finding
    them, among the rest of the console output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试，使用我们为`winston`使用的相同示例。由于我们将控制台输出设置为仅显示警告和错误，我们将只看到添加的一对行。显示`[http]`而不是`[serv]`有助于在控制台输出的其余部分中找到它们。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The (complete) HTTP log went into a file, and is just a list of all of the
    requests:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: （完整的）HTTP日志被记录到一个文件中，只是所有请求的列表：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that we opted to do an immediate logging, which means that all requests—even
    those that might cause everything to crash—get logged, but the outcome itself
    of the request is then not available. If you wish to also get that information—but,
    say, only for requests that caused some error—you might add a third `morgan` destination,
    sharing the same file stream, but only for errors, as shown in the following code
    snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们选择立即记录日志，这意味着所有请求——即使可能导致一切崩溃的请求——都会被记录，但请求本身的结果则不可用。如果您希望获取该信息，但仅针对导致某些错误的请求，您可以添加第三个`morgan`目标，共享相同的文件流，但仅用于错误，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using this, the log would then include more data, but only for the requests
    you picked:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，日志将包括更多数据，但仅适用于您选择的请求：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you wish, you can make `Morgan`''s output to go into `Winston`''s to get
    a single common logging stream, like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以将`Morgan`的输出发送到`Winston`中，以获得单个公共日志流，如下所示：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some output could be as follows; I highlighted the `morgan` lines:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些输出可能如下；我突出显示了`morgan`行：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A few details about the changes I made are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的更改的一些细节如下：
- en: Adding `.trim()` gets rid of a possible extra new line character
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`.trim()`可以去除可能存在的额外换行符
- en: Since all messages are sent through `winston`, you don't get your `[http]` distinguishing
    text in the output
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于所有消息都通过`winston`发送，因此您在输出中看不到`[http]`的区分文本
- en: If you want to send warnings for status like 400 or above, you'll have to write
    a more complex function that will scan the message text and decide whether to
    use `logger.info()` or some other method
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望发送警告状态码为400或以上的警告，您将需要编写一个更复杂的函数，该函数将扫描消息文本并决定是否使用`logger.info()`或其他方法
- en: Configuring your server for different environments
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同环境配置服务器
- en: 'No matter what you develop, it''s certain that you''ll work at least with a
    couple of environments, *development* and *production*, and settings for your
    code won''t be the same. For example, you won''t use the same configuration for
    security, to access a database, to log errors, or to connect to analytics services,
    and so on: when running in your development environment, you''ll need a certain
    setup, and for production there may be many changes.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您开发什么，可以肯定的是，您至少会使用两个环境，*开发*和*生产*，并且代码的设置不会相同。例如，您不会使用相同的配置来访问数据库、记录错误或连接到分析服务等等：在开发环境中运行时，您将需要一定的设置，而在生产环境中可能会有很多变化。
- en: You could set everything up in your code, but having users, passwords, IPs,
    and other sensitive data in plain text and saved in a source code repository that
    might get hacked isn't a good recipe for security. You should deal exclusively
    with your development configuration and leave the actual deployment to production
    to a different team, which will safely deal with that configuration.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码中设置所有内容，但是在明文中保存用户、密码、IP等敏感数据，并将其保存在可能被黑客攻击的源代码存储库中，这并不是一个安全的做法。您应该专门处理开发配置，并将实际部署留给另一个团队，他们将安全地处理该配置。
- en: Node lets you access environment variables and use them for configuration so
    that you can move that setup outside of your code. In this chapter, let's look
    at some ways to deal with all this, which will also indirectly help with our testing,
    later in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Node允许您访问环境变量并将其用于配置，以便您可以将该设置移出代码之外。在本章中，让我们看看如何处理所有这些，这也将在本章后期间接下来的测试间接帮助我们。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: When you are developing software, you'll obviously work in a different environment
    than for production; in fact, you could have several environments such as *development*,
    *testing*, *preproduction*, *production*, and so on. We'll also do this; let's
    start by going over some of the configurations we have already seen in this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开发软件时，显然会在与生产不同的环境中工作；事实上，您可能有多个环境，如*开发*、*测试*、*预生产*、*生产*等。我们也会这样做；让我们首先回顾一些我们在本书中已经看到的配置。
- en: 'In the *Getting a connection* section of [Chapter 3](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml),
    *Developing with Node*, when we created our services, we defined four constants
    to access the database, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml)的*使用Node进行开发*部分的*获取连接*部分中，当我们创建服务时，我们定义了四个常量来访问数据库，如下所示：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the previous chapter, in the *Adding Authentication with JWT* section, we
    had a secret that we used for signing:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的*使用JWT添加身份验证*部分中，我们有一个用于签名的密钥：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, finally, in this very chapter, we decided what levels of logging should
    be done. However, we hardcoded those levels, without the possibility of making
    things different in production:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这一章中，我们决定应该做哪些级别的日志记录。然而，我们对这些级别进行了硬编码，没有可能在生产中进行不同的设置：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also wrote the following, with some hardcoding:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还写了以下内容，并进行了一些硬编码：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's worth pointing out that changes between development and production need
    not be limited to listing or not listing; you could also change the logging format,
    the files where logs should be written, and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，开发和生产之间的更改不仅限于列出或不列出；您还可以更改日志格式、日志应写入的文件等等。
- en: 'The key to changing configurations *on the fly* is the usage of environment
    variables, which are provided via the `process.env` object. Every configuration
    variable in your environment will appear as a property of that object. If we write
    and run a program that just consists of a single `console.log(process.env)` line
    (or if we do `node -e "console.log(process.env)"` at the command line) you''ll
    get an output similar to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 动态更改配置的关键是使用环境变量，这些变量通过`process.env`对象提供。您环境中的每个配置变量都将显示为该对象的属性。如果我们编写并运行一个仅包含单个`console.log(process.env)`行的程序（或者在命令行中执行`node
    -e "console.log(process.env)"`），您将获得类似以下的输出：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Read more about `process.env` and its contents at [https://nodejs.org/api/process.html#process_process_env](https://nodejs.org/api/process.html#process_process_env).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://nodejs.org/api/process.html#process_process_env](https://nodejs.org/api/process.html#process_process_env)了解更多关于`process.env`及其内容的信息。
- en: There are two ways of taking advantage of this. We can either use an `environment`
    variable to check whether we are in development, in production, or in any other
    situation, and depending on that we can set some properties, or we can directly
    get the values for those properties from the environment itself. Any of these
    two solutions will help you unlink the code from the environment; let's see how
    this works in practice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种利用这一点的方法。我们可以使用一个`环境`变量来检查我们是在开发中、生产中还是其他任何情况下，并根据此设置一些属性，或者我们可以直接从环境中获取这些属性的值。这两种解决方案中的任何一种都将帮助您将代码与环境解耦；让我们看看这在实践中是如何工作的。
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by determining the environment. The standard is to set an environment
    variable called `NODE_ENV` with the name of the environment, before running the
    `Node` server itself. How to do that would depend on your actual machine, but
    in Linux, it would be something akin to the following, while in Windows the `SET`
    command would be required:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从确定环境开始。标准是在运行`Node`服务器之前设置一个名为`NODE_ENV`的环境变量，其中包含环境的名称。如何做取决于您的实际机器，但在Linux中，类似以下内容，而在Windows中则需要`SET`命令：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In your code, you could set a `isDev` variable to true if you are running in
    development (and false otherwise) with just two lines. If no environment was specified,
    the first line makes it default to `"development"`, which is most likely the safest
    choice:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，如果您正在开发中，则可以将`isDev`变量设置为true（否则为false），只需两行代码。如果未指定环境，则第一行将默认为`"development"`，这很可能是最安全的选择：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Changing the log file would also be simple, along the same lines as the preceding
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更改日志文件也很简单，与前面的代码类似：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This style works, but it still has a couple of problems:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格有效，但仍然存在一些问题：
- en: Any change in the environment requires changing the (hardcoded) server
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境的任何更改都需要更改（硬编码的）服务器
- en: The paths, tokens, passwords, and more, all reside in the source code, in a
    very viewable state
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径、令牌、密码等都驻留在源代码中，处于非常可见的状态
- en: 'So, we can do even better by directly taking the values for our internal variables
    directly from the environment:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过直接从环境中直接获取内部变量的值来做得更好：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, for logging, we could use the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于日志记录，我们可以使用以下内容：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you want to simplify working in development, but also make it easy for others
    when pushing code to production or other environments, you may want to look into
    `dotenv`, an `npm` package that lets you work with environment variables in text
    files. Install the package with `npm install dotenv --save`, and then create a
    file at the root of your project with the `.env` extension, which contains the
    desired variables values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想简化在开发中的工作，但同时也希望在将代码推送到生产或其他环境时为其他人提供便利，您可能需要研究一下`dotenv`，这是一个`npm`包，可以让您在文本文件中使用环境变量。使用`npm
    install dotenv --save`安装该包，然后在项目的根目录创建一个具有`.env`扩展名的文件，其中包含所需的变量值：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in your code, you only need to add a single line, and that will load
    and merge all the definitions in your `.env` file into `process.env`. Of course,
    if you only want to use this feature in development (as it was originally intended
    by the creator of `dotenv`) you could previously check the `isDev` variable, as
    we saw earlier:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的代码中，您只需要添加一行代码，它将加载并合并`.env`文件中的所有定义到`process.env`中。当然，如果您只想在开发中使用此功能（正如`dotenv`的创建者最初打算的那样），您可以先检查`isDev`变量，就像我们之前看到的那样：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Environment files should never be uploaded to source control, so it makes sense
    to add a line with `**/*.env` to your `.gitignore` file. You can, however, upload
    a sample file (say, `config.env.example`), but without the actual values for the
    environment variables; this will help new developers get the necessary files,
    but preserve security.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 环境文件不应上传到源代码控制，因此在您的`.gitignore`文件中添加一行`**/*.env`是有意义的。但是，您可以上传一个示例文件（比如`config.env.example`），但不包含环境变量的实际值；这将帮助新开发人员获取必要的文件，同时保护安全性。
- en: You can learn more about `dotenv` at [https://github.com/motdotla/dotenv](https://github.com/motdotla/dotenv).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/motdotla/dotenv](https://github.com/motdotla/dotenv)了解更多关于`dotenv`的信息。
- en: Unit testing your code
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试您的代码
- en: 'One of the best practices to ensure quality and to protect yourself from regression
    bugs (those that happen when you modify something, and reintroduce an earlier,
    previously corrected, bug) is to make sure that your code is *unit tested*. There
    are three types of testing:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 确保质量并保护自己免受回归错误（在修改某些内容并重新引入先前已纠正的错误时发生的错误）的最佳实践之一是确保您的代码经过*单元测试*。有三种类型的测试：
- en: '*Unit testing*, which applies to each component, on their own'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试*，适用于每个组件，各自独立'
- en: '*Integration testing*, which applies to components working together'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成测试*，适用于组件共同工作'
- en: '***End-to-end*** (**E2E**) *testing*, which applies to the system as a whole'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***端到端***（**E2E**）*测试*，适用于整个系统'
- en: Unit testing is good—not only because it helps try out your code, but because
    if done well, as in **Test-Driven Design** (**TDD**), in which you basically first
    set up the tests, and only then write the code—as it will help produce code of
    a better quality, and this will surely have an impact on reducing bugs all over
    your system. (Finding bugs even before any testing work begins is also a money
    saver; the earlier you find and fix bugs, the less costly it is.) So, let's focus
    on how you can use unit testing for your Node work.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试很好——不仅因为它有助于尝试您的代码，而且因为如果做得好，就像**测试驱动设计**（**TDD**）一样，您基本上首先设置测试，然后再编写代码——因为它将有助于生成更高质量的代码，这肯定会对系统中的所有错误产生影响。（甚至在任何测试工作开始之前发现错误也是节省金钱的；您发现并修复错误的越早，成本就越低。）因此，让我们专注于如何在Node工作中使用单元测试。
- en: Of course, it's well-known that *testing can prove the existence of bugs, but
    not their absence*, so no matter how much testing you do, some bugs will fall
    through! And, when that happens, TDD will make you first create some new unit
    tests that pinpoint the bug, and only then work at actually fixing it; at least,
    that specific bug won't reappear, because it will be detected.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，众所周知*测试可以证明错误的存在，但不能证明它们的不存在*，所以无论您做多少测试，都会有一些错误漏掉！当发生这种情况时，TDD将使您首先创建一些新的单元测试来定位错误，然后才开始实际修复它；至少，特定的错误不会再次出现，因为它将被检测到。
- en: There are plenty of tools and frameworks for unit testing, and in this book
    we'll be using `Jest`, a modern tool for *Delightful JavaScript Testing* as its
    lemma goes, which was developed by Facebook. We'll have the additional advantage
    of being able to also use it with React or React Native. Installation is quite
    simple, requiring just `npm install jest --save-dev`. After doing that, we'll
    be able to write our tests; let's see how.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多用于单元测试的工具和框架，在本书中我们将使用`Jest`，这是一个现代的*令人愉快的JavaScript测试*工具，它是由Facebook开发的。我们还有额外的优势，可以将它用于React或React
    Native。安装非常简单，只需要`npm install jest --save-dev`。做完这些之后，我们就可以编写我们的测试了；让我们看看如何做。
- en: You can read more about `Jest` at the official web page, at [https://facebook.github.io/jest/](https://facebook.github.io/jest/).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方网页上阅读更多关于`Jest`的信息，网址是[https://facebook.github.io/jest/](https://facebook.github.io/jest/)。
- en: In this recipe, we'll look at how to write unit tests for `Node` and get valid
    experience for future chapters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看如何为`Node`编写单元测试，并为未来的章节获得有效的经验。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Writing unit tests can be simpler or harder, depending on how you designed your
    code. If you work in a clear, side effects-free style, then writing functional
    tests will be quite simple. If you start adding complexities such as callbacks
    or promises and databases or filesystems, then you'll require more work, because
    you'll have to *mock* some of those elements; after all, you don't want to run
    tests on a production database, do you?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试可能更简单或更困难，这取决于您如何设计代码。如果您以清晰、无副作用的方式工作，那么编写功能测试将会非常简单。如果您开始添加诸如回调或承诺、数据库或文件系统等复杂性，那么您将需要更多的工作，因为您将不得不*模拟*其中一些元素；毕竟，您不想在生产数据库上运行测试，对吧？
- en: In the following sections, we'll look at how we can write unit tests and learn
    how to work with some specific concepts such as *mocks* or *spies*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看看如何编写单元测试，并学习如何处理一些特定的概念，如*模拟*或*间谍*。
- en: Doing functional tests
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行功能测试
- en: 'First, let''s see a simple, basic set of functional tests, and for that, let''s
    go back to the rounding library we wrote in the *Working with modules* section
    of [Chapter 3](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml), *Developing with Node*. When
    you test a module, you only test the exported functions to see if they perform
    according to their specs. The interesting part to test is, then, the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个简单的、基本的功能测试集，为此，让我们回到我们在[第3章](f2d2d72d-2137-4f67-8d72-9a113dc3d09c.xhtml)的*使用模块*部分编写的四舍五入库。当您测试一个模块时，您只测试导出的函数，看它们是否按照规格执行。然后，有趣的部分是测试以下内容：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These four functions are totally functional, insofar that their computed results
    depend only on their input parameters, and they have absolutely no side effects.
    Writing tests requires (1) defining groups of tests, and (2) including one or
    more tests in each group. Here, it makes sense to write a group for each function,
    so let''s see how the code could go; we could start with the `addR()` function,
    and write something like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个函数在功能上是完全的，因为它们的计算结果仅取决于它们的输入参数，并且它们绝对没有副作用。编写测试需要（1）定义测试组，和（2）在每个组中包含一个或多个测试。在这里，为每个函数编写一个组是有意义的，所以让我们看看代码可能是怎样的；我们可以从`addR()`函数开始，然后写出类似这样的东西：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The most usual style is naming the unit test file in the same way as the tested
    file, but adding `"test"` or `"spec"` before the file extension. In our case,
    for `roundmath.js`, we named the unit test file as `roundmath.test.js`. As for
    placement, `Jest` is able to find your tests no matter where you place them, so
    the usual practice is to place this new file alongside the original one so that
    it will be easy to find.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的风格是将单元测试文件命名为与被测试文件相同的方式，只是在文件扩展名之前添加`"test"`或`"spec"`。在我们的情况下，对于`roundmath.js`，我们将单元测试文件命名为`roundmath.test.js`。至于放置位置，`Jest`能够找到您的测试，无论您将它们放在何处，所以通常的做法是将这个新文件放在原始文件旁边，以便找到它。
- en: Each `describe()` call defines a group, and each `it()` call within defines
    a specific test. Should a test fail, Jest will report it, giving the group's and
    test's descriptions, as in `"addR should add first and round later"`. Tests consist
    of (1) setting things up, if needed; (2) actually running the test by calling
    the function; and (3) checking whether the function did as we expected.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`describe()`调用定义了一个组，其中的每个`it()`调用定义了一个特定的测试。如果测试失败，Jest将报告它，给出组和测试的描述，如“addR应该先添加，然后再四舍五入”。测试包括（1）设置事物，如果需要的话；（2）通过调用函数实际运行测试；和（3）检查函数是否按我们的预期执行。
- en: The first test we wrote verifies that, when adding numbers, addition should
    be done first, and only then rounding; rounding first and then adding wouldn't
    be right. We test this by calling `addR(1.505, 2.505)`, and we expect the result
    to be `4.01`; if the function had been rounded first, the result would have been
    `4.02`. Each test should be good at verifying at least one property of the function;
    our second test checks that `addR()` can handle negative numbers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的第一个测试验证了当添加数字时，应该先进行加法，然后再进行四舍五入；先进行四舍五入，然后再进行加法是不正确的。我们通过调用`addR(1.505,
    2.505)`来测试这一点，我们期望结果是`4.01`；如果函数先进行了四舍五入，结果将会是`4.02`。每个测试都应该能够验证函数的至少一个属性；我们的第二个测试检查`addR()`是否能够处理负数。
- en: 'The style in which you write your assumptions about the code is meant to be
    easy to read: *expect so-and-so to be such-value*. Methods such as `toBe()` or
    `toThrow()` (see our next example) are called matchers; see the quite long list
    at [https://facebook.github.io/jest/docs/en/expect.html](https://facebook.github.io/jest/docs/en/expect.html) for
    more information.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写关于代码的假设的风格旨在易于阅读：*期望某某是某个值*。诸如`toBe()`或`toThrow()`（见我们的下一个示例）的方法称为匹配器；有关更多信息，请参阅[https://facebook.github.io/jest/docs/en/expect.html](https://facebook.github.io/jest/docs/en/expect.html)上的相当长的列表。
- en: 'Of course, just a couple of tests would probably not be enough for complex
    code, and you''ll usually have more tests, but as an example, these will do. Note
    that we should write tests for all functions; for example, `divR()` could use
    something like this. While the first test is quite straightforward (similar to
    one for `addR()`), in the second one, we verify that calling `divR()` with a zero
    divisor should throw an exception:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于复杂的代码，可能只有几个测试是不够的，通常会有更多的测试，但是作为一个例子，这些就足够了。请注意，我们应该为所有函数编写测试；例如，`divR()`可以使用类似这样的东西。虽然第一个测试非常直接（类似于`addR()`的测试），但在第二个测试中，我们验证调用`divR()`时，如果除数为零，应该抛出异常：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you miss some functions or part of them, later in this chapter, we'll look
    at ways to detect that; don't worry just now. At this point in time, we'll keep
    writing tests, and then we'll run the complete suite.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您错过了一些函数或它们的一部分，稍后在本章中，我们将看看如何检测到；现在不要担心。此时，我们将继续编写测试，然后运行完整的测试套件。
- en: Using spies
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用间谍
- en: 'The functional tests we wrote are quite good, but just won''t do for some situations,
    such as when you work with callbacks. Let''s turn to another piece of code we
    wrote: the user validation routine we used for JWT. Basically, this function received
    a username, a password, and an error-first callback, which was used to signal
    whether the username really had that password or not. We wrote very basic validation
    code (a single user was accepted!), but that doesn''t matter here; we want to
    look at how we can deal with the callback. The important parts we care about now
    are highlighted in the following code extract:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的功能测试非常好，但在某些情况下不适用，比如当您使用回调时。让我们转向另一段我们编写的代码：我们用于JWT的用户验证例程。基本上，这个函数接收一个用户名、一个密码和一个错误回调，用于表示用户名是否真的有这个密码。我们编写了非常基本的验证代码（只接受一个用户！），但这里并不重要；我们想看看如何处理回调。我们现在关心的重要部分在以下代码片段中突出显示：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Testing this would require actually passing a callback, and then trying to
    see how it was called; this can be done, but the details would be messy. Alternatively,
    we can have a spy—a dummy function, which we can later interrogate to see if it
    was called or not, with which parameters it was called, and more:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这将需要实际传递一个回调，然后尝试看它是如何被调用的；这是可以做到的，但细节会很混乱。或者，我们可以有一个间谍——一个虚拟函数，稍后我们可以询问它是否被调用，以及它是如何被调用的，以及更多：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can create such a spy by calling `jest.fn()`. Since we''ll need a new spy
    for each test we''ll write, we can take advantage of a `beforeEach()` function,
    which Jest will call automatically before running each individual test; this will
    save some extra writing. There are actually four functions you can use, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`jest.fn()`来创建这样的间谍。由于我们将为每个测试编写一个新的间谍，我们可以利用`beforeEach()`函数，Jest将在运行每个单独的测试之前自动调用它；这将节省一些额外的编写。实际上有四个函数可以使用，如下所示：
- en: '`beforeAll()` will be called only once, before starting with your tests; for
    example, you could set up a test database here and fill it with certain data'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeAll()`将在开始测试之前只调用一次；例如，您可以在这里设置一个测试数据库并填充它的某些数据'
- en: '`beforeEach()` will be called before each test, as we did in our example to
    create a spy'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()`将在每个测试之前调用，就像我们在示例中创建间谍时所做的那样。'
- en: '`afterEach()` will be called after each test, to *clean up*'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach()`将在每个测试后调用，以*清理*'
- en: '`afterAll()` will be called after running all tests; for example, you could
    destroy a test database you had created for testing purposes only'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterAll()`将在运行所有测试后调用；例如，您可以销毁仅用于测试目的创建的测试数据库'
- en: All three tests are similar; we will pick the first one. We call the validation
    routine, but pass an empty parameter. In terms of the validation specification,
    that should create an error. By doing this, we can test that the callback was
    actually called, and that it was called by passing an error as the first parameter,
    and nothing as the second.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个测试都是类似的；我们将选择第一个。我们调用验证例程，但传递一个空参数。根据验证规范，这应该创建一个错误。通过这样做，我们可以测试回调是否真的被调用，并且它是通过传递一个错误作为第一个参数，以及作为第二个参数传递了什么来调用的。
- en: (Of course, the first test, using the `.toHaveBeenCalled()` matcher, is not
    needed given the second one that tests if it was called with specific values,
    but we just wanted to show a new pair of matchers.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，第一个测试使用`.toHaveBeenCalled()`匹配器是不需要的，因为第二个测试测试了它是否使用特定值调用，但我们只是想展示一个新的匹配器对。）
- en: Using spies is quite practical if we only care about seeing if a given function
    was called or not, but what would happen if the function under test actually required
    some value back from our spy? We can also solve that; let's get into a more complex
    example.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只关心看一个给定的函数是否被调用，使用间谍是非常实用的，但是如果被测试的函数实际上需要从我们的间谍那里返回一些值会发生什么？我们也可以解决这个问题；让我们进入一个更复杂的例子。
- en: Working with mocks
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟
- en: 'Let''s finish by working with a more complex example—a part of the REST code
    that worked with regions, which requires a database and uses promises, among several
    complications. Let''s take the `DELETE` method handler as an example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后使用一个更复杂的例子来工作——一个处理与地区相关的REST代码的部分，它需要一个数据库并使用承诺，还有其他几个复杂情况。让我们以`DELETE`方法处理程序为例：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We did something right by passing the database connection (`dbConn`) as a parameter
    to the function. This means that we can *mock* it—meaning, provide an alternative
    version that will behave as we may want it, but without actually using any database.
    Similarly, processing our request will need to simulate a response object (`res`)
    whose status code we'll want to check; we could code it by hand, but using the
    `node-mocks-http` package is simpler, so just install it with `npm install node-mocks-http
    --save`. Check out its documentation at [https://github.com/howardabrams/node-mocks-http](https://github.com/howardabrams/node-mocks-http),
    for more information—it can do much more!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据库连接（`dbConn`）作为参数传递给函数，我们做对了一些事情。这意味着我们可以*模拟*它——也就是提供一个替代版本，它将按照我们的意愿行事，但实际上不使用任何数据库。同样，处理我们的请求将需要模拟一个响应对象（`res`），我们将要检查其状态码；我们可以手工编码，但使用`node-mocks-http`包更简单，所以只需使用`npm
    install node-mocks-http --save`进行安装。查看其文档[https://github.com/howardabrams/node-mocks-http](https://github.com/howardabrams/node-mocks-http)，获取更多信息——它可以做更多！
- en: 'We know that the `DELETE` method should (1) confirm that the region to be deleted
    must have no cities, and (2) if true, then actually delete the region. How can
    we test if the first check works? Let''s provide `deleteRegion()` with a mock
    that will say that the region we want to delete actually has some cities:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`DELETE`方法应该（1）确认要删除的区域不能有城市，（2）如果是真的，那么就删除该区域。我们如何测试第一个检查是否有效？让我们为`deleteRegion()`提供一个模拟，它会说我们想要删除的区域实际上有一些城市：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We could program a complete mock database that would analyze the incoming query
    and then provide some expected answer, but in this case, a little knowledge about
    how the code checks for cities is good. We can create a mock database object with
    a query attribute (`mDb.query`) and set it so that when `mDb.query()` is called
    for the first time, it will return a promise resolved to an array with a single
    1—for that's what the actual SQL statement would have produced when checking a
    region that actually includes some cities. We'll also create a mock response object
    (`mRes`) that will get the routine's answer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个完整的模拟数据库，分析传入的查询，然后提供一些预期的答案，但在这种情况下，对代码如何检查城市有一些了解是很有帮助的。我们可以创建一个带有查询属性（`mDb.query`）的模拟数据库对象，并设置当第一次调用`mDb.query()`时，它将返回一个解析为包含单个1的数组的promise——因为这就是实际的SQL语句在检查实际包含一些城市的区域时会产生的结果。我们还将创建一个模拟响应对象（`mRes`），它将得到例程的答复。
- en: What's left to do? You just have to call the `deleteRegion()` function with
    all the parameters, `await` its results, and verify that the response status code
    is 405, as expected; then, you're done!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩下什么要做？你只需要调用`deleteRegion()`函数并传入所有参数，`await`其结果，并验证响应状态码是否为405，然后你就完成了！
- en: 'The other tests are similar, but we have to simulate two SQL accesses, not
    one:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其他测试类似，但我们必须模拟两个SQL访问，而不是一个：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The interesting thing is that we can set up a mock function to produce different
    answers each time it is called, according to what we need. Thus, in order to test
    whether `deleteRegion()` would correctly delete a region without cities, our mock
    DB object must do the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们可以设置一个模拟函数，每次调用时产生不同的答案，根据我们的需要。因此，为了测试`deleteRegion()`是否能正确删除没有城市的区域，我们的模拟DB对象必须执行以下操作：
- en: First, return an empty array, showing that the region to be deleted has no cities
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，返回一个空数组，显示要删除的区域没有城市
- en: Second, return an object with `affectedRows:1`, showing that the (supposed)
    `DELETE` SQL command was successful
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，返回一个带有`affectedRows:1`的对象，显示（假设的）`DELETE` SQL命令成功了
- en: After setting things up in this way, the rest of the code is like our first
    case; await the function and check the status code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完这些后，其余的代码就像我们的第一个案例一样；等待函数并检查状态码。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To run the tests, we''ll have to edit a script in `package.json`. Change the
    `"test"` script, which up till now had just an error message, so it will read
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行测试，我们需要编辑`package.json`中的一个脚本。更改`"test"`脚本，到目前为止只有一个错误消息，所以它将读取如下内容：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `"test"` script can be run just by typing `npm` test. In our case, since
    our output code goes into the `out/` directory we are telling Jest to inspect
    that directory, and run all tests (`*.test.js` files, by default) that it can
    find. You can modify Jest''s configuration for more specific cases, but in general,
    it works well with *zero configuration*. The output is short and practical, as
    shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`"test"`脚本可以通过输入`npm test`来运行。在我们的案例中，由于我们的输出代码进入`out/`目录，我们告诉Jest检查该目录，并运行它可以找到的所有测试（默认情况下是`*.test.js`文件）。你可以修改Jest的配置以适应更特定的情况，但总的来说，它在*零配置*的情况下工作得很好。输出简洁实用，如下截图所示：'
- en: '![](img/2759c870-b28f-4bad-9c53-ca83f4232aaf.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2759c870-b28f-4bad-9c53-ca83f4232aaf.png)'
- en: The result of the npm test command is short and to the point
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: npm test命令的结果简洁明了
- en: 'In our case, matching what we did, it shows that we ran three suites of tests,
    including a total of 10 tests, and they all passed. Had one or more tests produced
    a wrong result, we''d have gotten another sort of result, with lots of red. I
    modified a test on purpose so that it would fail, and the following output was
    the result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，匹配我们所做的，它显示我们运行了三套测试，总共包括10个测试，它们都通过了。如果一个或多个测试产生了错误的结果，我们将得到另一种结果，有很多红色。我故意修改了一个测试，以便它失败，以下输出是结果：
- en: '![](img/23ee0762-814f-48a3-9f1f-db97e5f150e8.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23ee0762-814f-48a3-9f1f-db97e5f150e8.png)'
- en: Modifying a test to make it fail, and running Jest, produces a listing including
    the missed expectations, the failed test, and more
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 修改一个测试以使其失败，并运行Jest，会产生一个包括未达预期、失败测试等的列表
- en: In the preceding screenshot, we can see that one test failed, in the `restful_regions.test.js`
    file, showing that a 204 result was expected, but a 404 error was received instead.
    The file is marked with a red `FAIL` message; the other two files are marked with `PASS`,
    in green. In our case, it happened because we purposefully wrote a failing test,
    but in real life, if the test had been running fine before, and now failed, it
    would mean that someone messed with the code and accidentally introduced a bug.
    (To be fair, there also exists the possibility that the test was not totally correct
    then, and the tested function was actually right!) In any case, getting a red
    result means that the code cannot be considered ready, and more work is needed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述屏幕截图中，我们可以看到一个测试失败，在`restful_regions.test.js`文件中，显示期望获得204结果，但实际收到了404错误。该文件标有红色的`FAIL`消息；其他两个文件标有绿色的`PASS`。在我们的情况下，这是因为我们故意编写了一个失败的测试，但在现实生活中，如果测试之前一切正常，现在失败了，这意味着有人搞乱了代码并意外引入了错误。（公平地说，还存在测试当时不完全正确，而被测试的函数实际上是正确的可能性！）无论如何，获得红色结果意味着代码不能被视为准备就绪，需要更多的工作。
- en: There's more....
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多....
- en: 'Should you need to mock some package that you cannot (or won''t) inject as
    a parameter into a function, you can provide Jest with a complete mocked version.
    Suppose you wanted to mock the `"fs"` package: you''d start by creating a `__mocks__`
    directory at the same level of the `node_modules` one, then you would write and
    place your manual mock code there, and finally you would specify `jest.mock("fs")`
    at the beginning of your test file so that `Jest` will use your module rather
    than the standard one.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要模拟一些无法（或不愿意）将其作为参数注入到函数中的包，可以向Jest提供完整的模拟版本。假设您想要模拟`"fs"`包：您将首先在`node_modules`的同一级别创建一个`__mocks__`目录，然后在那里编写和放置您的手动模拟代码，最后您将在测试文件的开头指定`jest.mock("fs")`，以便`Jest`将使用您的模块而不是标准模块。
- en: All of this can become a chore, so you'd better try to provide all of the modules
    as parameters to your functions (as we did with `dbConn` when deleting regions)
    so that standard mocks can be used. However, if you can't do that, check out [https://facebook.github.io/jest/docs/en/manual-mocks.html](https://facebook.github.io/jest/docs/en/manual-mocks.html)
    for more information.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可能变成一项琐事，所以最好尝试将所有模块作为参数提供给您的函数（就像我们在删除区域时使用`dbConn`一样），以便可以使用标准模拟。但是，如果您无法这样做，请查看[https://facebook.github.io/jest/docs/en/manual-mocks.html](https://facebook.github.io/jest/docs/en/manual-mocks.html)获取更多信息。
- en: Measuring your test coverage
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量您的测试覆盖率
- en: OK, so you have written a lot of tests, but how much of your code base are you
    actually testing? This measure of the quality (breadth) of your testing is called
    *coverage*, and it's easy to determine; in this recipe, let's find out how to
    do this. Fortunately, given all the work that we have done, it will be a very
    simple recipe.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，您已经编写了很多测试，但实际上您测试了多少代码？这种测试质量（广度）的度量称为*覆盖率*，并且很容易确定；在本教程中，让我们找出如何做到这一点。幸运的是，鉴于我们所做的所有工作，这将是一个非常简单的教程。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To have `Jest` produce a coverage report, showing what parts of your code were
    (and weren''t) covered by your tests, all you have to do is add a pair of parameters
    to the corresponding script in the `package.json` file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`Jest`生成覆盖率报告，显示哪些部分的代码被您的测试覆盖（或未覆盖），您只需在`package.json`文件中的相应脚本中添加一对参数即可：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding line of code, the first parameter, `--coverage`, tells `Jest`
    to collect all of the necessary information, and the second parameter, `--no-cache`,
    ensures that all information will be fresh; in certain situations, not totally
    correct results have been produced when this parameter was omitted. How does this
    affect the testing? Let's see!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，第一个参数`--coverage`告诉`Jest`收集所有必要的信息，第二个参数`--no-cache`确保所有信息都是最新的；在某些情况下，当省略此参数时，可能会产生不完全正确的结果。这如何影响测试？让我们看看！
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The key difference when running `Jest` with coverage is that a different report
    is added at the console, and also a HTML page is built. First, let''s check the
    former: check out the following screenshot —and once again, I accept that seeing
    colors in black and white is really hard!'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用覆盖率运行`Jest`的关键区别是控制台中添加了不同的报告，并且还构建了一个HTML页面。首先，让我们检查前者：查看以下屏幕截图-再次，我承认在黑白中看到颜色真的很难！
- en: '![](img/d757eb05-b88d-4248-996e-0e0cd50becf5.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d757eb05-b88d-4248-996e-0e0cd50becf5.png)'
- en: Including coverage options when running Jest produces a more detailed analysis
    of your tests
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Jest时包括覆盖率选项会产生对测试的更详细的分析
- en: 'For each file, you get the following information:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个文件，您将获得以下信息：
- en: '`%Stmts`: The percentage of statements that were executed at least once because
    of your tests. Ideally, each and every statement should have been executed at
    least once; otherwise, whatever statement wasn''t executed could be anything,
    and you wouldn''t realize it.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％Stmts`：由于您的测试至少执行了一次的语句百分比。理想情况下，每个语句都应该至少执行一次；否则，任何未执行的语句都可能是任何内容，您都不会意识到。'
- en: '`%Branch`: The percentage of branches that were taken. The reasoning for this
    is similar to that of `%Stmts`—if there are some branches (for example, an else)
    that were never taken, that means that there are some paths in your code that
    could do anything.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％Branch`：采取的分支百分比。这与`％Stmts`的推理类似-如果有一些分支（例如，else）从未被采取，这意味着您的代码中存在一些可能执行任何操作的路径。'
- en: '`%Funcs`: The percentage of functions in the file that were called.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％Funcs`：文件中调用的函数百分比。'
- en: '`%Lines`: The percentage of lines that were covered. Note that a line may have
    several statements, so `%Lines` will always be greater or equal to `%Stmts`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％Lines`：覆盖的行数百分比。请注意，一行可能有几个语句，因此`％Lines`始终大于或等于`％Stmts`。'
- en: '`Uncovered Line #s`: This is NOT the number of lines (several billion!?), but
    the numbers of specific lines that were never executed.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`未覆盖的行号`：这不是行数（几十亿！？），而是从未执行的特定行的数字。'
- en: In our case, we find that all of the functions were tested in `validate_user.js`,
    but half the functions were missed in `roundmath.js` (we tested `addR()` and `divR()`,
    but forgot about `subR()` and `multR()`, so that's correct) and only one function
    (the `DELETE` handler) was tested in `restful_regions.js`. Getting better coverage
    numbers means more work, and it may not always be wise, in economic terms, to
    aim for 100% (80%-90% is common), but 25% or 50% is definitely too low, so more
    work is needed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们发现`validate_user.js`中的所有函数都经过了测试，但是`roundmath.js`中的一半函数被忽略了（我们测试了`addR()`和`divR()`，但忘记了`subR()`和`multR()`，所以是正确的），而`restful_regions.js`中只测试了一个函数（`DELETE`处理程序）。获得更好的覆盖率意味着更多的工作，而且从经济角度来看，追求100%可能并不总是明智的（80%-90%是常见的），但25%或50%绝对太低了，因此需要更多的工作。
- en: 'The more interesting part is that you can analyze in depth how tests ran by
    looking into the `coverage/lcov_report/` directory of your project and opening
    `index.html` in a browser, as shown in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的部分是，您可以通过查看项目的`coverage/lcov_report/`目录并在浏览器中打开`index.html`来深入分析测试运行情况，如下面的屏幕截图所示：
- en: '![](img/9a5cc820-34f4-46f8-ac51-3d304b3e030b.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/9a5cc820-34f4-46f8-ac51-3d304b3e030b.png)
- en: The main page of the web coverage report shows essentially the same data as
    the console run
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Web覆盖率报告的主页显示的数据基本上与控制台运行相同
- en: 'First, you can see the files in different colors: as usual, red means a not-too-good
    result, and green is the best result. The interesting part is that if you click
    on a file, you''ll get a detailed analysis, including each line, if it was executed
    or not, and more:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以看到不同颜色的文件：通常，红色表示不太好的结果，绿色是最好的结果。有趣的部分是，如果您点击文件，您将获得详细的分析，包括每一行，是否执行或未执行等：
- en: '![](img/b33abb0b-42aa-4653-8a5b-b1874ca5dae5.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/b33abb0b-42aa-4653-8a5b-b1874ca5dae5.png)
- en: You can see which lines were executed, and which were missed, and why 100% wasn't
    achieved
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到哪些行被执行，哪些被忽略，以及为什么没有达到100%
- en: 'In our case, even if we thought we had covered all of the cases in `deleteRegion()`,
    the screen shows us that we missed a possible situation: the SQL server failing
    to answer. Of course, whether we include a specific test for this or not is a
    decision you''ll have to take: at least we can see that all of the most important
    code was covered, but don''t forget the other functions in the same file, which
    weren''t tested at all!'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，即使我们认为我们已经覆盖了`deleteRegion()`中的所有情况，屏幕显示我们错过了一个可能的情况：SQL服务器无法回答。当然，是否为此包含特定测试是您必须做出的决定：至少我们可以看到所有最重要的代码都被覆盖了，但不要忘记同一文件中未经测试的其他函数！
- en: Debugging your code
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试您的代码
- en: At some point or another, you'll have to debug your code. You might do well
    enough with just a bit of logging (using the console object, as we saw earlier
    at the beginning of the *Adding logging with Winston* section), but using a more
    powerful debugger is a great help. In this recipe, let's see how you can do real-time
    debugging with breakpoints, inspection of variables, and so on, so that you won't
    be limited to just trying to deduce what's wrong by looking at console logs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您将不得不调试您的代码。您可能只需使用一点日志记录就足够了（使用控制台对象，正如我们在*使用Winston添加日志记录*部分中所看到的那样），但使用更强大的调试器会很有帮助。在这个教程中，让我们看看如何使用断点、变量检查等进行实时调试，这样您就不会仅仅通过查看控制台日志来推断出问题所在。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are two ways of doing debugging; let's see both methods here.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种调试方法；让我们在这里看看这两种方法。
- en: 'If you just want to stay in your IDE, Visual Studio Code lets you directly
    start a debugging session. Just click on the code you want to run (a reminder:
    pick the code in the out/ directory, and don''t forget to use `npm run build`)
    and pick Debug | Start Debugging in the menu. The window will look as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想留在您的IDE中，Visual Studio Code允许您直接开始调试会话。只需单击要运行的代码（提醒：选择out/目录中的代码，并不要忘记使用`npm
    run build`），然后在菜单中选择Debug | Start Debugging。窗口将如下所示：
- en: '![](img/581706b5-7073-4c25-9a07-27c979ddf08d.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/581706b5-7073-4c25-9a07-27c979ddf08d.png)
- en: You can start a debugging session right in Visual Studio Code
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Visual Studio Code中直接开始调试会话
- en: Alternatively, if you'd rather keep using your favorite developer tools from
    Chrome, there's an alternative you can use. First, in Chrome, look for `N.I.M.`,
    the *Node.js V8 Inspector Manager*, which can be found at [https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj),
    and add it to your browser.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您宁愿继续使用Chrome的您最喜欢的开发人员工具，那么您可以使用另一种方法。首先，在Chrome中，搜索`N.I.M.`，*Node.js
    V8 Inspector Manager*，可以在[https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj)找到，并将其添加到您的浏览器中。
- en: 'After doing that, open the `N.I.M.` console by going to `about:inspect`, and
    you''ll get something like what''s shown in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，通过转到`about:inspect`打开`N.I.M.`控制台，您将获得如下屏幕截图所示的内容：
- en: '![](img/2a6771ba-1e14-40f8-804d-f7125f58e909.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/2a6771ba-1e14-40f8-804d-f7125f58e909.png)
- en: The N.I.M. extension lets you debug Node sessions using Chrome's developer tools
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: N.I.M.扩展允许您使用Chrome的开发人员工具调试Node会话
- en: 'All you have to do now is go to VSC, or a shell session, and run your code.
    Before doing this, add the `--inspect` option, as in `node --inspect out/restful_server.js`.
    You will receive the following output:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需转到VSC或shell会话，并运行您的代码。在执行此操作之前，添加`--inspect`选项，如`node --inspect out/restful_server.js`。您将收到以下输出：
- en: '![](img/1d034af3-ca27-4439-ba1a-cdf3a2594935.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/1d034af3-ca27-4439-ba1a-cdf3a2594935.png)
- en: To connect Node to Chrome's developer tools, you must run your code with an
    extra `--inspect` option
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Node连接到Chrome的开发人员工具，您必须使用额外的`--inspect`选项运行您的代码
- en: 'After that, a window will open, and you''ll have full access to Chrome''s debugger
    console, as shown in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将打开一个窗口，您将完全访问Chrome的调试器控制台，如下面的屏幕截图所示：
- en: If you examine the URL in Chrome's debugger, you'll see something like `chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=...`,
    followed by a URL and a (long) hexadecimal number. These values are listed after
    running `Node` with `--inspect`, in the line starting with "Debugger listening
    on ws...".
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Chrome的调试器中检查URL，您会看到类似`chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=...`的东西，后面跟着一个URL和一个（长）十六进制数。这些值在运行`Node`时使用`--inspect`列出，在以"Debugger
    listening on ws..."开头的行中。
- en: '![](img/7aa4099c-240d-43ae-bee1-e6ed3be30038.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7aa4099c-240d-43ae-bee1-e6ed3be30038.png)'
- en: If N.I.M. is enabled, your Node session will connect to it, and you'll be able
    to debug your code from within Chrome
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果N.I.M.已启用，您的Node会话将连接到它，并且您将能够从Chrome内部调试您的代码
- en: Finally, in any case, you are ready to start a serious debugging session; let's
    see what you can do.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在任何情况下，您都准备好开始一个严肃的调试会话；让我们看看您能做些什么。
- en: If you want to learn about how code inspection works, read the following article: [https://nodejs.org/en/docs/guides/debugging-getting-started/](https://nodejs.org/en/docs/guides/debugging-getting-started/).
    This also gives you tips for debugging with other IDEs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解代码检查的工作原理，请阅读以下文章：[https://nodejs.org/en/docs/guides/debugging-getting-started/](https://nodejs.org/en/docs/guides/debugging-getting-started/)。这也为您提供了在其他IDE中进行调试的提示。
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding screenshots, both with VSC and Chrome, I opened the `out/restful_regions.js`
    file and set a breakpoint at the place where a `SELECT` is done in order to get
    some regions. Doing a request for `/regions/uy` caused the run to pause at the
    point. You can then do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，无论是VSC还是Chrome，我都打开了`out/restful_regions.js`文件，并在进行`SELECT`以获取一些地区的地方设置了一个断点。对`/regions/uy`的请求导致运行在这一点暂停。然后您可以执行以下操作：
- en: Examine all variables, including block, local, and global ones—this includes
    the possibility of modifying their values, if you want to
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有变量，包括块、局部和全局变量——这包括修改它们的值的可能性，如果您想的话
- en: Add some variables or expressions to watch; whenever execution pauses, you'll
    see their values
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些变量或表达式以进行监视；每当执行暂停时，您将看到它们的值
- en: See the call stack
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看调用堆栈
- en: Set some specific breakpoints
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一些特定的断点
- en: 'As for program execution, you can do the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关于程序执行，您可以执行以下操作：
- en: Stop execution at any breakpoint
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何断点处停止执行
- en: Restart execution
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新开始执行
- en: Step through your code, with the option of *drilling* *down* to analyze function
    calls
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步执行您的代码，选择*下钻*以分析函数调用
- en: If you use Chrome, you'll be able to get some extra options, like memory usage
    analysis or code execution profiling, but clearly the web-specific options won't
    do any good. However, debugging your code by using the inspection option is a
    very good aid for bug chasing, so get used to it; you'll appreciate it a lot!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Chrome，您将能够获得一些额外的选项，比如内存使用分析或代码执行分析，但显然这些特定于Web的选项不会有任何好处。然而，通过使用检查选项来调试您的代码是一个非常好的帮助，所以要习惯它；您会非常感激它！
- en: Testing simple services from the command line
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行测试简单服务
- en: 'Whenever you create services, you will need some way of testing them. So far,
    we have seen some examples of doing just that with `curl`. So, in this recipe,
    let''s go a bit deeper and check out some options that you may find useful. Alternatively,
    you could opt for another tool, such as `wget`. For our purposes, both options
    are roughly equivalent, allowing us to do everything we need for RESTful services
    testing: they are scriptable, they can download things, and they can also send
    requests posting data, so what you use will be mostly a question of personal preference.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您创建服务时，您都需要一种测试它们的方法。到目前为止，我们已经看到了一些使用`curl`进行测试的例子。因此，在这个教程中，让我们深入一点，看看一些您可能会发现有用的选项。或者，您可以选择另一个工具，比如`wget`。对于我们的目的，这两个选项都差不多，允许我们做我们需要的RESTful服务测试：它们是可脚本化的，它们可以下载东西，它们也可以发送请求来发布数据，所以您使用的将主要是个人偏好的问题。
- en: If you want to read more about `curl`, check out its site at [https://curl.haxx.se/](https://curl.haxx.se/),
    or the source code at [https://github.com/curl/curl](https://github.com/curl/curl).
    You may also be interested in *Everything Curl*, a book that details all there
    is to know about this tool, and which is freely available at [https://www.gitbook.com/download/pdf/book/bagder/everything-curl](https://www.gitbook.com/download/pdf/book/bagder/everything-curl)—however,
    do take into account that it's over 300 pages long!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`curl`的信息，请访问其网站[https://curl.haxx.se/](https://curl.haxx.se/)，或者查看源代码[https://github.com/curl/curl](https://github.com/curl/curl)。您可能还对*Everything
    Curl*感兴趣，这是一本详细介绍这个工具的书籍，可以在[https://www.gitbook.com/download/pdf/book/bagder/everything-curl](https://www.gitbook.com/download/pdf/book/bagder/everything-curl)免费获取——但是，请注意它有300多页长！
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'How to install `curl` will depend on your operating system, but it''s available
    for practically every platform you are likely to work with; just check out all
    the downloads at [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).
    The command has dozens of possible options, but for our intents, we will be looking
    at the following table. Note that most options have two versions: a short, single
    character one, and a longer one, intended to be clearer for understanding:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安装`curl`将取决于您的操作系统，但它几乎适用于您可能使用的每个平台；只需查看[https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)上的所有下载。该命令有数十种可能的选项，但对于我们的意图，我们将查看以下表格。请注意，大多数选项都有两个版本：一个短的，单个字符的版本，和一个更长的版本，旨在更清晰地理解：
- en: '| `-K filename``--config filename` | Lets you specify the name of a file that
    has options in it so that your command is shorter. In the given file, each option
    will be in a different line. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `-K filename``--config filename` | 允许您指定一个包含选项的文件的名称，以便您的命令更短。在给定的文件中，每个选项将在不同的行中。
    |'
- en: '| `-d key=value``--data key=value` | Allows you to send data in the body of
    the request. If you use this option several times, `curl` will use `&` as a separator,
    as standard. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `-d key=value``--data key=value` | 允许您在请求的正文中发送数据。如果您多次使用此选项，`curl`将使用`&`作为分隔符，作为标准。
    |'
- en: '| `--data-binary someData` | Similar to `--data`, but used to send binary data.
    Most frequently it is followed by `@filename`, meaning that the contents of the
    named file will be sent. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `--data-binary someData` | 类似于`--data`，但用于发送二进制数据。最常见的是后面跟着`@filename`，意思是将发送命名文件的内容。
    |'
- en: '| `-D filename``--dump-header filename` | Dumps the headers of the received
    data into a file. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `-D filename``--dump-header filename` | 将接收到的数据的标头转储到文件中。 |'
- en: '| `-H "header:value"``--header "header:value"` | Allows you to set and send
    some header with a request. You can use this option several times to set many
    headers. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `-H "header:value"``--header "header:value"` | 允许您设置并发送请求的某些标头。您可以多次使用此选项来设置多个标头。
    |'
- en: '| `-i``--include` | Includes headers of the received data in the output. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `-i``--include` | 在输出中包含接收数据的标头。 |'
- en: '| `-o filename``--output filename` | Stores the received data in the given
    file. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `-o filename``--output filename` | 将接收到的数据存储在给定的文件中。 |'
- en: '| `-s``--silent` | Minimizes output to the console. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `-s``--silent` | 最小化控制台输出。 |'
- en: '| `-v``--verbose` | Maximizes output to the console. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `-v``--verbose` | 最大化控制台输出。 |'
- en: '| `-X method``--request method` | Specifies which HTTP method will be used,
    such as `GET`, `POST`, `PUT`, and so on. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `-X method``--request method` | 指定将使用的HTTP方法，例如`GET`、`POST`、`PUT`等。 |'
- en: Finally, if you need help, use `curl --help` or `curl --manual`, and you'll
    get a full description of the utility and its options. Now let's look at how we
    can use `curl` to test our services.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您需要帮助，请使用`curl --help`或`curl --manual`，您将得到该实用程序及其选项的完整描述。现在让我们看看如何使用`curl`来测试我们的服务。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s do a complete set of tests for the RESTful server we created in the
    previous chapter, with all options enabled, including JWT—which, as you''ll remember,
    we removed in order to simplify our code! Let''s follow these steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为上一章中创建的RESTful服务器进行一整套测试，包括JWT在内的所有选项都已启用，您会记得，我们为了简化代码而删除了JWT！让我们按照以下步骤进行：
- en: 'Firstly, we may verify that the server is up and running; the `/` route had
    no token requirement. Remember that we are using `8443`, and actual HTTPS: requests
    will be sent to that port:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以验证服务器是否正在运行；`/`路由不需要令牌。请记住我们使用的是`8443`，实际上是HTTPS：请求将发送到该端口：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, if we try to access some region, we''ll be refused, because of the lack
    of an authorizing JWT:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试访问某个区域，我们将被拒绝，因为缺少授权的JWT：
- en: '[PRE43]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the line starts with `*`, it's some information from `curl` itself
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该行以`*`开头，则是`curl`本身的一些信息
- en: If the line starts with `>`, it's a header sent with the request
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该行以`>`开头，则是请求中发送的标头
- en: If the line starts with `<`, it's a received header
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该行以`<`开头，则是接收到的标头
- en: 'In the following listing, I highlighted the incoming data:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的清单中，我突出显示了传入的数据：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can get a token by using the `/gettoken` route and providing `user` and
    `password` values. Let''s store the received token in a file to simplify future
    tests:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`/gettoken`路由并提供`user`和`password`值来获取令牌。让我们将接收到的令牌存储在一个文件中，以简化未来的测试。
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can try a simple `GET`. We can either cut-and-paste the token in a header,
    or use some shell features, at least in Linux-based systems, and take advantage
    of the back tick option to include the token file''s contents in the request:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试一个简单的`GET`。我们可以在标头中剪切和粘贴令牌，或者在Linux系统中至少使用一些shell功能，并利用反引号选项将令牌文件的内容包含在请求中：
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'All we''ve got left is to try out the other routes and methods. Let''s change
    the name of Montevideo to MVD, which actually is the IATA code for its international
    airport; we''ll do a `PUT` first (which should produce a 204 status code) and
    then a `GET` to verify the update:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所剩下的就是尝试其他路由和方法。让我们将蒙得维的亚的名称更改为MVD，实际上这是其国际机场的IATA代码；我们首先进行`PUT`（应该产生一个204状态码），然后进行`GET`以验证更新：
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In one experiment, I created a new region, numbered 20\. Let''s delete it and
    verify that it''s gone with yet another `GET`. The first request should get a
    204 status, and the second should get a 404, because the region will no longer
    exist:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个实验中，我创建了一个新的区域，编号为20。让我们删除它，并验证它是否已经消失，然后再进行另一个`GET`。第一个请求应该得到一个204状态，第二个请求应该得到一个404，因为该区域将不再存在：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, let''s invent a new region to verify that `POST` also works; a 201
    status should be returned, as well as the new ID (which would be 20, after we
    deleted the previous invented 20th Uruguayan region):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们发明一个新的区域来验证`POST`也起作用；应该返回201状态，以及新的ID（在我们删除了之前发明的第20个乌拉圭区域后，应该是20）：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, by using `curl` and some console work, we can set out to test any kind of
    services. However, at some point, you may need to work with more complex sequences
    of service calls, and doing all this work by hand could become a chore. Indeed,
    by careful scripting you may simplify your job, but let's consider another tool,
    Postman, that's more apt for that kind of work.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用`curl`和一些控制台工作，我们可以开始测试任何类型的服务。然而，在某些时候，您可能需要处理更复杂的服务调用序列，并且手动完成所有这些工作可能会变得繁琐。通过谨慎的脚本编写，您可以简化工作，但让我们考虑另一个工具Postman，它更适合这种工作。
- en: Testing more complex sequences of calls with Postman
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Postman测试更复杂的调用序列
- en: Testing services manually, or even with a carefully crafted shell script, isn't
    really easy. Furthermore, if you require some kind of complex test, using scripting
    may prove to be just too hard. `Postman` can be used to write tests for services,
    to organize them into full testing suites, and to document the way your RESTful
    API works. You can also use it to mock services or as a help in development, but
    we won't be getting into that here. In this recipe, we'll focus on the testing
    aspects.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试服务，甚至使用精心制作的shell脚本也不是很容易。此外，如果您需要进行某种复杂的测试，使用脚本可能会变得太难。`Postman`可以用来为服务编写测试，将它们组织成完整的测试套件，并记录您的RESTful
    API的工作方式。您还可以用它来模拟服务或作为开发的帮助，但我们不会在这里讨论这些。在这个配方中，我们将专注于测试方面。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Download `Postman` from [https://www.getpostman.com/](https://www.getpostman.com/),
    and install it according to the instructions for each platform. Remember to take
    a look at its documentation for more features that we won't be seeing here.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://www.getpostman.com/](https://www.getpostman.com/)下载`Postman`，并根据每个平台的说明进行安装。记得查看其文档，了解更多我们这里不会看到的功能。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Postman lets you create requests that you can store in collections. Before and
    after each request, you may execute JavaScript code, either to set up the upcoming
    request, to process the resulting response, or to store some information for future
    requests in a test sequence. Let's take a look at the following sections.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Postman允许您创建可以存储在集合中的请求。在每个请求之前和之后，您可以执行JavaScript代码，无论是为即将到来的请求设置，处理结果响应，还是为测试序列中未来的请求存储一些信息。让我们看看以下部分。
- en: Doing basic requests
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行基本请求
- en: First, we'll start with a simple test to get a JWT, which we'll then store so
    that we can use it in upcoming tests. Open the `Postman` application and click
    on New to create a request. Give it a name and a description, and either select
    or create a collection or folder to save it. Don't worry too much about the actual
    placement; you'll be able to move requests around, edit them, and more.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从一个简单的测试开始，以获取JWT，然后将其存储，以便我们可以在即将进行的测试中使用。打开`Postman`应用程序，点击New创建一个请求。给它一个名称和描述，然后选择或创建一个集合或文件夹来保存它。不要太担心实际的放置位置；您可以移动请求，编辑它们，等等。
- en: 'Then, to get a token, we need a `POST`, so set the method appropriately. Select
    the BODY tab, pick the `x-www-form-urlencoded` option, and add two values, `user`
    and `password`, which will be sent with the request. (For other situations, you
    might send raw data such as XML or JSON, or binary data such as a file.) Check
    out the following screenshot:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了获取令牌，我们需要一个`POST`，所以设置方法。选择BODY选项卡，选择`x-www-form-urlencoded`选项，并添加两个值，`user`和`password`，这些值将随请求一起发送。（对于其他情况，您可能会发送原始数据，如XML或JSON，或二进制数据，如文件。）查看以下截图：
- en: '![](img/3487874e-670b-4b7c-a13d-f3f44f017af6.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3487874e-670b-4b7c-a13d-f3f44f017af6.png)'
- en: Creating a POST request to get a JWT
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个POST请求来获取JWT
- en: 'Now, if you test it out by clicking on Send, the request will go to your server,
    and the answer will appear at the bottom of the screen:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您点击发送进行测试，请求将发送到服务器，答复将出现在屏幕底部：
- en: '![](img/cf772a36-3196-4c25-acfe-e4f755049fa1.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf772a36-3196-4c25-acfe-e4f755049fa1.png)'
- en: A test run of our request shows that everything is working fine
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的请求测试显示一切正常运行
- en: Adding some checks
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些检查
- en: 'However, that''s not enough. We don''t just want to check whether the `/gettoken`
    endpoint works—we''d like to test if the token looks right, and if so, store it
    so that later requests can use it. We will create an environment (click on the
    gear at the upper right corner) and add a `token` entry so that we can store and
    retrieve the value we got from the server:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不够。我们不仅想检查`/gettoken`端点是否工作，我们还想测试令牌是否正确，并且如果正确，存储它以便后续请求可以使用。我们将创建一个环境（点击右上角的齿轮图标）并添加一个`token`条目，以便我们可以存储和检索从服务器获取的值：
- en: '![](img/a6954463-3113-468a-866b-b12194276ba3.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6954463-3113-468a-866b-b12194276ba3.png)'
- en: Creating an environment is one way you can share data between requests
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 创建环境是您可以在请求之间共享数据的一种方式
- en: 'Finally, let''s write some tests for the token, and also store its value in
    the environment. Writing the tests themselves is sort of similar to what we already
    did, but you''ll have to look into the documentation to see what objects and methods
    are available. As for the tests themselves, they use `Chai` (see [http://www.chaijs.com/](http://www.chaijs.com/)),
    which is similar to `Jest` when it comes to writing your expectations, but not
    exactly the same:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为令牌编写一些测试，并将其值存储在环境中。编写测试本身与我们已经做过的有些类似，但您需要查看文档，了解可用的对象和方法。至于测试本身，它们使用`Chai`（参见[http://www.chaijs.com/](http://www.chaijs.com/)），在编写您的期望方面类似于`Jest`，但并非完全相同：
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'First, we will test that the answer should be at least 40 bytes long; tokens
    have no special size limits, but 40 characters is on the low side. Then, a second
    test will check that the token is comprised of three parts, separated by periods.
    Finally, we will store the response itself in the environment, for future use.
    If you check the TESTS tab, you''ll see that both our tests passed, as shown in
    the following screenshot:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将测试答复至少应该有40个字节长；令牌没有特定的大小限制，但40个字符偏低。然后，第二个测试将检查令牌由三部分组成，由句点分隔。最后，我们将把响应本身存储在环境中，以备将来使用。如果您检查TESTS选项卡，您会看到我们的两个测试都通过了，如下截图所示：
- en: '![](img/3f82702e-4cd4-4d3e-b00d-6047f7b378d4.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f82702e-4cd4-4d3e-b00d-6047f7b378d4.png)'
- en: Both tests we created were successful
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的两个测试都成功了
- en: Chaining requests
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接请求
- en: 'If you check the environment, you''ll see that the token was stored. Now let''s
    write a second test, a `GET`, that will use the token. I went through a similar
    sequence by doing a request for `/regions/uy`, but I added a line in the headers,
    with the `Authorization` key and the `Bearer {{token}}` value, so that the previously
    stored token value would be replaced in the header. I also added a couple of tests
    to make sure (1) I got a successful JSON answer, and (2) the answer was an array
    of at least 19 regions. (Yes, I know my country, Uruguay, has exactly 19 regions,
    but sometimes, for test purposes, I may add some new ones!) The tests show some
    features we haven''t seen before:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查环境，您会看到令牌已经存储。现在让我们写一个第二个测试，一个`GET`，将使用令牌。我通过对`/regions/uy`进行请求，但我在标头中添加了一行，使用`Authorization`键和`Bearer
    {{token}}`值，以便以前存储的令牌值将替换标头中的值。我还添加了一些测试，以确保（1）我得到了成功的JSON答复，以及（2）答复是至少19个地区的数组。（是的，我知道我的国家乌拉圭确实有19个地区，但有时，出于测试目的，我可能会添加一些新的！）这些测试显示了一些我们以前没有见过的功能：
- en: '[PRE51]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this fashion, you can create complete sequences of requests; make sure that
    getting the JWT is placed earlier in the list. In a collection, you can also have
    many folders, each with a distinct sequence of steps. (You may also change the
    sequence programatically, but we won't get into that here; check out [https://www.getpostman.com/docs/v6/postman/scripts/branching_and_looping](https://www.getpostman.com/docs/v6/postman/scripts/branching_and_looping)
    for more information.)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以创建完整的请求序列；确保获取JWT放在列表中较早的位置。在一个集合中，您还可以有许多文件夹，每个文件夹都有一个不同的步骤序列。（您也可以通过程序更改序列，但我们不会在这里讨论这个问题；请查看[https://www.getpostman.com/docs/v6/postman/scripts/branching_and_looping](https://www.getpostman.com/docs/v6/postman/scripts/branching_and_looping)获取更多信息。）
- en: I created two folders to test some `GET`s and a `DELETE`—but, of course, you
    should be writing even more tests to verify every method, and as many different
    sequences as possible. Let's see how we can make them run.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了两个文件夹来测试一些`GET`和一个`DELETE`，但是，当然，您应该编写更多的测试来验证每种方法，以及尽可能多的不同序列。让我们看看如何使它们运行。
- en: How it works...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Once you have organized your requests in folders, you can run any given sequence
    by clicking on it at the sidebar on the left. If everything is OK, you''ll get
    green marks for all tests; a red mark highlights an issue:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将请求组织到文件夹中，您可以通过单击左侧边栏上的文件夹来运行任何给定的序列。如果一切正常，所有测试都将获得绿色标记；红色标记表示存在问题：
- en: '![](img/4c6ba089-e7b6-4de0-8c9f-acaabd7f706b.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c6ba089-e7b6-4de0-8c9f-acaabd7f706b.png)'
- en: Running a collection runs every test in it. Green blocks show successes; red
    ones mark errors.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个集合会运行其中的每个测试。绿色块表示成功；红色块表示错误。
- en: With this, you already have a good tool for documenting your API (make sure
    that every test and field has an explanation) and for making sure that it keeps
    working, going beyond the unit testing into full **end-to-end** (**E2E**) testing.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，您已经有了一个很好的工具来记录您的API（确保每个测试和字段都有解释），并确保它保持工作状态，超越单元测试进入完整的端到端（E2E）测试。
- en: Depending on your `Postman` account, you can also set things up to get periodical
    monitoring of your API; check out [https://www.getpostman.com/docs/v6/postman/monitors/intro_monitors](https://www.getpostman.com/docs/v6/postman/monitors/intro_monitors) for
    more information.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的`Postman`帐户，您还可以设置定期监视您的API；请查看[https://www.getpostman.com/docs/v6/postman/monitors/intro_monitors](https://www.getpostman.com/docs/v6/postman/monitors/intro_monitors)获取更多信息。
- en: There's more...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'By using the `newman` package (install it with `npm install newman --save-dev`),
    you can run your `Postman` tests from the command line, which could also allow
    you to include them in a continuous integration workflow. First, export your collection
    from `Postman` (uninspiredly, I called mine `postman_collection.json`), and then
    add a new script to your `package.json` file called `"newman":"newman run postman_collection.json"`.
    Using `npm run newman` will then produce an output like the one shown in the following
    code snippet. You could also test whether all of the tests ran satisfactorily
    or whether there was a problem:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`newman`包（使用`npm install newman --save-dev`进行安装），您可以从命令行运行您的`Postman`测试，这也可以让您将其包含在持续集成工作流程中。首先，从`Postman`中导出您的集合（我无聊地称之为`postman_collection.json`），然后在您的`package.json`文件中添加一个名为`"newman":"newman
    run postman_collection.json"`的新脚本。然后使用`npm run newman`将产生类似于以下代码片段中所示的输出。您还可以测试所有测试是否都运行良好，或者是否存在问题：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Documenting and testing your REST API with Swagger
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swagger文档和测试您的REST API
- en: 'Now let''s focus more on documentation and testing with a well-known tool:
    `Swagger`. This is a tool that''s meant to help you design, model, and test APIs.
    The key idea is that you''ll end up by having an online, interactive document
    that will describe in detail all of your API calls, the parameter types and restrictions,
    the required and optional values, and so on, even letting you try calls *on the
    fly* to better understand how the API is meant to be used.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更专注于使用一个众所周知的工具进行文档编写和测试：`Swagger`。这是一个旨在帮助您设计、建模和测试API的工具。关键思想是，最终您将拥有一个在线交互式文档，其中将详细描述所有API调用、参数类型和限制、必需和可选值等，甚至让您可以即时尝试调用，以更好地理解API的使用方式。
- en: How to do it...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The first—and hardest!—part of setting up `Swagger` is preparing the specification
    for your complete API. This is meant to be written in **YAML Ain't Markup Language** (**YAML**),
    and can be difficult to get right. However, you can use a web editor, which you
    can run at your own server (go to [https://swagger.io/tools/swagger-editor/](https://swagger.io/tools/swagger-editor/) for
    the necessary download) or online at [https://editor.swagger.io](https://editor.swagger.io).
    After writing that, however, setting everything up will be truly easy, needing
    just three lines of code!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`Swagger`的第一步，也是最难的一步是准备完整API的规范。这意味着要用**YAML Ain't Markup Language**（YAML）编写，可能很难搞定。但是，您可以使用Web编辑器，可以在自己的服务器上运行（转到[https://swagger.io/tools/swagger-editor/](https://swagger.io/tools/swagger-editor/)进行必要的下载）或在线运行[https://editor.swagger.io](https://editor.swagger.io)。然而，在写完之后，设置一切将变得非常容易，只需要三行代码！
- en: YAML is a recursive acronym that stands for *YAML Ain't Markup Language*. If
    you want to learn more about it, visit [http://yaml.org/](http://yaml.org/).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: YAML是一个递归缩写，代表*YAML Ain't Markup Language*。如果您想了解更多信息，请访问[http://yaml.org/](http://yaml.org/)。
- en: Writing our specs
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的规范
- en: 'We won''t be able to introduce the full rules for writing API specs here, and
    also won''t be able to include all of its features in our example. Furthermore,
    a complete description for any API can be hundreds of lines long, and that''s
    another problem. So, let''s just go over some basic definitions, as well as a
    couple of the services, to get a taste of what needs to be done. First, we''ll
    need some basic data about our server:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在这里介绍编写API规范的全部规则，也无法在我们的示例中包含所有功能。此外，任何API的完整描述可能长达数百行，这是另一个问题。因此，让我们先了解一些基本定义，以及一些服务，以了解需要做些什么。首先，我们需要一些关于我们服务器的基本数据：
- en: '[PRE53]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then we must describe the tags (think *sections*) that our documentation will
    be divided into. We work with tokens (for security), plus countries, regions,
    and cities, so those seem to be the needed definitions:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须描述标签（考虑*部分*），我们的文档将被分成。我们使用令牌（用于安全性），加上国家、地区和城市，因此这些似乎是所需的定义：
- en: '[PRE54]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s take a look at the `/gettoken` route. We define a POST request, which
    gets body encoded parameters, and returns plain text. Two string parameters, `user`
    and `password`, are required. The API may either return a 200 status if everything
    was OK, or 401 otherwise:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`/gettoken`路由。我们定义了一个POST请求，它获取编码的参数，并返回纯文本。需要两个字符串参数，`user`和`password`。如果一切正常，API可能会返回200状态，否则返回401：
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Getting regions for a country would get a similar specification:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个国家的地区将得到类似的规范：
- en: '[PRE56]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Enabling Swagger
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用Swagger
- en: 'To enable the `Swagger` documentation, we need the `swagger-ui-express` package,
    and also need to load the JSON version of the YAML specs, so you''ll need a couple
    of lines of code. First, install the package with the usual `npm install swagger-ui-express
    --save`, and then add the following lines to your server:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`Swagger`文档，我们需要`swagger-ui-express`包，并且还需要加载YAML规范的JSON版本，因此您需要几行代码。首先，使用通常的`npm
    install swagger-ui-express --save`安装包，然后将以下行添加到您的服务器：
- en: '[PRE57]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the server, we must also add a line for enabling the new route, at the beginning,
    after other `app.use()` statements. We are adding `Swagger` to our RESTful API,
    and without a token: you might prefer to set up a different server, only providing
    access to the API, and possibly also enabling authorization, but both changes
    will be easy to accomplish. So, let''s go with the simpler version here:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，我们还必须添加一行以启用新路由，在其他`app.use()`语句之后。我们正在为我们的RESTful API添加`Swagger`，并且没有令牌：您可能更喜欢设置一个不同的服务器，只提供对API的访问，并可能还启用授权，但这两个更改都很容易实现。所以，让我们在这里选择更简单的版本：
- en: '[PRE58]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You're all set! After you rebuild the project and start the server, the new
    route will be available, providing online documentation for your server.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经准备好了！重新构建项目并启动服务器后，新路由将可用，为您的服务器提供在线文档。
- en: How it works...
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you start the server, accessing the `/api-docs` route will provide access
    to the main `Swagger` screen, as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启动服务器，访问`/api-docs`路由将提供访问主`Swagger`屏幕，如下所示：
- en: '![](img/f8f6622a-7084-4a05-9343-0dc3f4b2c694.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8f6622a-7084-4a05-9343-0dc3f4b2c694.png)'
- en: Swagger produces a main page, with access to every route you defined
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger生成一个主页面，可以访问您定义的每个路由
- en: 'Interaction is easy: select an area, click on a given request, and you''ll
    get the list of all routes and operations. Let''s see, for example, how to get
    the regions for Uruguay. First, we must get a token, so we want to open the token
    area and enter the necessary user and password, as shown in the following screenshot:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 交互很容易：选择一个区域，点击一个给定的请求，您将获得所有路由和操作的列表。例如，让我们看看如何获取乌拉圭的地区。首先，我们必须获取一个令牌，所以我们想要打开令牌区域，并输入必要的用户和密码，如下面的截图所示：
- en: '![](img/92c311dd-05dc-4a78-9d05-fa6e9b34e8fc.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92c311dd-05dc-4a78-9d05-fa6e9b34e8fc.png)'
- en: Doing a request is just a matter of filling the fields and executing the query
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 发出请求只是填写字段并执行查询的问题
- en: 'When the process runs, you''ll get the answer, as shown in the following screenshot:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程运行时，您将得到答案，如下面的截图所示：
- en: '![](img/fd190496-fc79-4ed7-958f-02e56334257f.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd190496-fc79-4ed7-958f-02e56334257f.png)'
- en: A successful request returned the security token
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的请求返回了安全令牌
- en: 'You can see the equivalent `curl` request at the top, which matches what we
    did earlier in this chapter, in the *Testing simple services from the command
    line* section. Now, copying that token and pasting it into the `/regions/uy` endpoint
    means that we''re ready to do that query:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在顶部看到等效的`curl`请求，与本章前面所做的内容相匹配，在*从命令行测试简单服务*部分。现在，复制该令牌并粘贴到`/regions/uy`端点意味着我们已经准备好进行查询了：
- en: '![](img/66b6e274-3f42-40c4-8064-12c47c3f01a5.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66b6e274-3f42-40c4-8064-12c47c3f01a5.png)'
- en: After getting a token, we can set up the query to get all of the regions of
    a country
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 获得令牌后，我们可以设置查询以获取一个国家的所有地区。
- en: 'All that''s left to do is execute that query, and we''ll get the desired results,
    as shown in the following screenshot:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要做的就是执行该查询，我们将得到所需的结果，如下面的截图所示：
- en: '![](img/f361107e-a79d-47b2-97e6-300869feaa4c.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f361107e-a79d-47b2-97e6-300869feaa4c.png)'
- en: Doing sequences of calls is possible, and Swagger lets you experiment easily
    with different endpoints
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进行一系列调用，Swagger让您轻松尝试不同的端点
- en: What can we point out? First, obviously, `Swagger` is a very good tool, in terms
    of documentation. You can add descriptions to methods, parameters, results, and
    even include sample values and results. This means that developers who need to
    use your API will have a very good way of learning about how to use it. In terms
    of actually using your API, `Swagger` is simpler than `curl` or `Postman`, but
    it cannot chain operations, which you'll have to do on your own. You should really
    think about starting your development with this tool, and only moving forward
    with actual coding once you have everything documented; give it a try!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指出什么？首先，显然，`Swagger`是一个非常好的工具，就文档而言。您可以为方法、参数、结果添加描述，甚至包括示例值和结果。这意味着需要使用您的API的开发人员将有一个非常好的学习如何使用它的方式。就实际使用您的API而言，`Swagger`比`curl`或`Postman`更简单，但它不能链操作，这将由您自己完成。您应该真的考虑使用这个工具开始您的开发，并且只有在您把一切都记录下来后才继续实际编码；试一试吧！
