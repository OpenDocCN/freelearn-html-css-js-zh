- en: Functional Programming Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程基础
- en: JavaScript has been a multi-paradigm programming language since its inception
    back in 1995\. It allows us to take advantage of an **object-oriented programming**
    (**OOP**) style along with a functional programming style. The same can be said
    of TypeScript. However, for functional programming, TypeScript is even better
    suited than JavaScript because, as we will learn in this chapter, static type
    systems and type inference are both very important features in functional programming
    languages such as the ML family of programming languages, for example.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从1995年JavaScript诞生以来，JavaScript一直是一种多范式编程语言。它允许我们利用面向对象编程（**OOP**）风格以及函数式编程风格。同样，TypeScript也是如此。然而，对于函数式编程来说，TypeScript比JavaScript更适合，因为正如我们将在本章中学习的，静态类型系统和类型推断是函数式编程语言（例如ML编程语言家族）中非常重要的特性。
- en: The JavaScript and TypeScript ecosystems have experienced a significant increase
    in interest in functional programming over the last few years. I believe that
    this increase in interest can be attributed to the success of React. React is
    a library developed by Facebook for building user interfaces, and it is highly
    influenced by some core functional programming concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，JavaScript和TypeScript生态系统对函数式编程的兴趣显著增加。我相信这种兴趣的增加可以归因于React的成功。React是由Facebook开发的一个用于构建用户界面的库，它深受一些核心函数式编程概念的影响。
- en: In this chapter, we will focus on learning some of the most basic functional
    programming concepts and principles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于学习一些最基础的函数式编程概念和原则。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将学习以下内容：
- en: The main characteristics of functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的主要特征
- en: The main benefits of functional programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的主要好处
- en: Pure functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: side-effects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用
- en: Immutability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Function arity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的阶数
- en: Higher-order functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Laziness
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性
- en: Is TypeScript a functional programming language?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript是不是函数式编程语言？
- en: The answer to this question is yes, but only in part. TypeScript is a multi-paradigm
    programming language and, as a result, it includes many influences from both OOP
    languages and functional programming paradigms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是肯定的，但只是部分。TypeScript是一种多范式编程语言，因此它包含了来自面向对象语言和函数式编程范式的许多影响。
- en: However, if we focus on TypeScript as a functional programming language, we
    can observe that it is not a purely functional programming language because, for
    example, the TypeScript compiler doesn't force our code to be free of side-effects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把TypeScript视为一种函数式编程语言，我们会发现它并不是一种纯粹的函数式编程语言，因为例如，TypeScript编译器并不强制我们的代码无副作用。
- en: Not being a purely functional programming language should not be interpreted
    as something negative. TypeScript provides us with an extensive set of features
    that allow us to take advantage of some of the best features of the world of OOP
    languages and the world of functional programming languages. This has allowed
    TypeScript-type systems to attain a very good compromise between productivity
    and formality.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不是纯粹的函数式编程语言不应被视为负面因素。TypeScript为我们提供了一套广泛的功能，使我们能够利用面向对象编程语言世界和函数式编程语言世界的最佳特性。这使得TypeScript类型系统在生产力与形式之间达到了一个非常好的平衡。
- en: The benefits of functional programming
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的好处
- en: 'Writing TypeScript code using a functional programming style has many benefits,
    among which we can highlight the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式编程风格编写TypeScript代码有许多好处，其中我们可以突出以下内容：
- en: '**Our code is testable:** If we try to write our functions as pure functions,
    we will be able to write unit tests extremely easily. We will learn more about
    pure functions later in this chapter.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的代码是可测试的**：如果我们尝试将我们的函数编写为纯函数，我们将能够非常容易地编写单元测试。我们将在本章后面了解更多关于纯函数的内容。'
- en: '**Our code is easy to reason about:** Functional programming can seem hard
    to understand for developers with a lack of experience in functional programming.
    However, when an application is implemented correctly using the functional programming
    paradigm, the results are very small functions (often one-line functions) and
    very declarative APIs that can be reasoned about with ease. Also, pure functions
    only work with their arguments, which means that when we want to understand what
    a function does, we only need to examine the function itself and we don''t need
    to be concerned about any other external variables.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的代码易于推理：** 对于缺乏函数式编程经验的开发者来说，函数式编程可能难以理解。然而，当应用程序正确地使用函数式编程范式实现时，结果是非常小的函数（通常是单行函数）和非常声明性的API，可以轻松地进行推理。此外，纯函数只与它们的参数一起工作，这意味着当我们想要了解一个函数的功能时，我们只需要检查该函数本身，而无需担心任何其他外部变量。'
- en: '**Concurrency: **Most of our functions are stateless, and our code is mostly
    stateless. We push state out of the core of our application, which makes our applications
    much more likely to be able to support many concurrent operations and it will
    be more scalable. We will learn more about stateless code later in this chapter.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发：** 我们的大多数函数都是无状态的，我们的代码主要是无状态的。我们将状态从应用程序的核心中推出去，这使得我们的应用程序更有可能支持许多并发操作，并且将具有更好的可扩展性。我们将在本章的后面部分学习更多关于无状态代码的内容。'
- en: '**Simpler caching:** Caching strategies to cache results become much simpler
    when we can predict the output of a function given its arguments.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简单的缓存：** 当我们能根据函数的参数预测其输出时，缓存结果的缓存策略会变得简单得多。'
- en: Introducing functional programming
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍函数式编程
- en: '**Functional programming** (**FP**) is a programming paradigm that receives
    its name from the way we build applications when we use it. In a programming paradigm
    such as OOP, the main building blocks that we use to create an application are
    objects (objects are declared using classes). However, in FP, we use functions
    as the main building block in our applications**.**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**（**FP**）是一种编程范式，其名称来源于我们使用它时构建应用程序的方式。在面向对象编程（OOP）这样的编程范式中，我们用来创建应用程序的主要构建块是对象（对象使用类声明）。然而，在FP中，我们将函数作为我们应用程序中的主要构建块**。**'
- en: Each new programming paradigm introduces a series of concepts and ideas associated
    with it. Some of these concepts are universal and are also of interest while learning
    a different programming paradigm. In OOP, we have concepts such as inheritance,
    encapsulation, and polymorphism. In functional programming, concepts include higher-order
    functions, function partial application, immutability, and referential transparency.
    We are going to examine some of these concepts in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每一种新的编程范式都会引入一系列与之相关的概念和思想。其中一些概念是通用的，在学习不同的编程范式时也很有兴趣。在面向对象编程（OOP）中，我们有诸如继承、封装和多态等概念。在函数式编程中，概念包括高阶函数、函数部分应用、不可变性和引用透明性。我们将在本章中探讨一些这些概念。
- en: '**Michael Feathers**, the author of the SOLID acronym and many other well-known
    software engineering principles, once wrote the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**迈克尔·费思**（Michael Feathers），SOLID缩写词的作者以及许多其他著名的软件工程原则的作者，曾写下以下内容：'
- en: '"Object-oriented programming makes code understandable by encapsulating moving
    parts. Functional programming makes code understandable by minimizing moving parts."'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '"面向对象编程通过封装移动部件使代码易于理解。函数式编程通过最小化移动部件使代码易于理解。"'
- en: – *Michael Feathers*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: – *迈克尔·费思*
- en: The preceding quote mentions moving parts. We should understand these moving
    parts as **state changes** (also known as **state mutations**). In OOP, we use
    encapsulation to prevent objects from being aware of the state mutations of other
    objects. In functional programming, we try to avoid dealing with state mutations
    instead of encapsulating them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的引用提到了移动部件。我们应该将这些移动部件理解为**状态变化**（也称为**状态突变**）。在面向对象编程（OOP）中，我们使用封装来防止对象意识到其他对象的状态突变。在函数式编程中，我们试图避免处理状态突变，而不是封装它们。
- en: FP reduces the number of places in which state changes take place within an
    application and tries to move these places into the boundaries of the application
    to try to keep the application's core stateless.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）减少了应用程序中状态变化发生的地方的数量，并试图将这些地方移动到应用程序的边界内，以尝试保持应用程序的核心无状态。
- en: 'A mutable state is bad because it makes the behavior of our code harder to
    predict. Take the following function, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可变状态是坏的，因为它使我们的代码的行为更难以预测。以下函数为例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code snippet declared a function named `isIndexPage`. This function
    can be used to check whether the current page is the root page in a web application
    based on the current path.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段声明了一个名为`isIndexPage`的函数。这个函数可以用来检查当前页面是否是Web应用程序中的根页面，基于当前路径。
- en: The path is some data that changes all the time, so we can consider it a piece
    of state. If we try to predict the result of invoking the `isIndexPage`, we will
    need to know the current state. The problem is that we could wrongly assume that
    the state has not changed since the last known state. We can solve this problem
    by transforming the preceding function into what is known in FP as a **pure function**,
    as we will learn in the following section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是不断变化的数据，因此我们可以将其视为状态的一部分。如果我们尝试预测调用`isIndexPage`的结果，我们需要知道当前状态。问题是，我们可能会错误地假设状态自上次已知状态以来没有发生变化。我们可以通过将前面的函数转换为在FP中称为**纯函数**的形式来解决此问题，正如我们将在下一节中学习的那样。
- en: Pure functions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: FP introduces a number of concepts and principles that will help us to improve
    the predictability of our code. In this section, we are going to learn about one
    of these core concepts—pure functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程引入了许多概念和原则，这些将帮助我们提高代码的可预测性。在本节中，我们将学习这些核心概念之一——纯函数。
- en: A function can be considered pure when it returns a value that is computed using
    only the arguments passed to it. Also, a pure function avoids mutating its arguments
    or any other external variables. As a result, a pure function always returns the
    same value given the same arguments, independently of when it is invoked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数仅使用传递给它的参数来计算返回值时，我们可以认为它是纯函数。此外，纯函数避免修改其参数或任何其他外部变量。因此，纯函数在给定相同的参数时，总是返回相同的值，无论何时被调用。
- en: 'The `isIndexPage` function declared in the preceding section is not a pure
    function because it accesses the `pathname` variable, which has not been passed
    as an argument to the function. We can transform the preceding function into a
    pure function by rewriting it as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分中声明的`isIndexPage`函数不是一个纯函数，因为它访问了`pathname`变量，而这个变量并没有作为参数传递给函数。我们可以通过以下方式重写前面的函数，将其转换为纯函数：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though this is a basic example, we can easily perceive that the newer version
    is much easier to predict. Pure functions help us to make our code easier to understand,
    maintain, and test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个基本的例子，但我们很容易感知到新版本更容易预测。纯函数帮助我们使代码更容易理解、维护和测试。
- en: Imagine that we wanted to write a unit test for the impure version of the `isIndexPage`
    function. We would encounter some problems when trying to write a test because
    the function uses the `window.location` object. We could overcome this issue by
    using a mocking framework, but it would add a lot of complexity to our unit tests
    just because we didn't use a pure function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们想要为`isIndexPage`函数的不纯版本编写单元测试。在尝试编写测试时，我们会遇到一些问题，因为该函数使用了`window.location`对象。我们可以通过使用模拟框架来克服这个问题，但这会为我们的单元测试增加很多复杂性，仅仅因为我们没有使用纯函数。
- en: 'On the other hand, testing the pure version of the `isIndexPage` function would
    be straightforward, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，测试`isIndexPage`函数的纯版本将会非常直接，如下所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we understand how functional programming helps us to write better code
    by avoiding state mutations, we can learn about side-effects and referential transparency.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数式编程如何通过避免状态突变来帮助我们编写更好的代码，我们可以学习副作用和引用透明度。
- en: side-effects
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用
- en: In the preceding section, we learned that a pure function returns a value that
    can be computed using only the arguments passed to it. A pure function also avoids
    mutating its arguments or any other external variable that is not passed to the
    function as an argument. In FP terminology, it is common to say that a pure function
    is a function that has no side-effects, which means that, when we invoke a pure
    function, we can expect that the function is not going to interfere (through a
    state mutation) with any other component in our application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分中，我们了解到纯函数返回的值可以使用仅传递给它的参数来计算。纯函数还避免修改其参数或任何其他未作为参数传递给函数的外部变量。在函数式编程术语中，通常说纯函数是没有副作用的函数，这意味着当我们调用纯函数时，我们可以期望该函数不会干扰（通过状态突变）我们应用程序中的任何其他组件。
- en: 'Certain programming languages, such as Haskell, can ensure that an application
    is free of side-effects using their type system. TypeScript has fantastic interoperability
    with JavaScript, but the downside of this, compared to a more isolated language
    such as Haskell, is that the type system is not able to guarantee that our application
    is free from side-effects. However, we can use some FP techniques to improve the
    type safety of our TypeScript applications. Let''s take a look at an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 某些编程语言，如Haskell，可以使用它们的类型系统确保应用程序没有副作用。TypeScript与JavaScript有出色的互操作性，但与像Haskell这样的更隔离的语言相比，其缺点是类型系统无法保证我们的应用程序没有副作用。然而，我们可以使用一些FP技术来提高我们的TypeScript应用程序的类型安全性。让我们来看一个例子：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding function returns a `number`. The code compiles without issues.
    The problem is that the function does not always return a `number`. As a result,
    we can consume the function as follows and our code will compile and throw an
    exception at runtime:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数返回一个`number`。代码编译没有问题。问题是这个函数并不总是返回一个`number`。因此，我们可以这样使用该函数，并且代码会编译，但在运行时抛出异常：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example showcases a new implementation of the preceding function.
    This time, instead of returning a number, we will explicitly return a promise.
    The promise forces us to then use the handler. This handler is only executed if
    the promise is fulfilled, which means that if the function returns an error, we
    will never try to convert the age to years:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了先前函数的新实现。这次，我们不再返回一个数字，而是明确地返回一个承诺。这个承诺迫使我们使用处理器。这个处理器只有在承诺得到履行时才会执行，这意味着如果函数返回错误，我们永远不会尝试将年龄转换为年：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Promise` type helps us to prevent errors because it expresses potential
    errors in an explicit way. In programming languages such as Haskell, this is the
    default behavior of the type system, but, in programming languages such as TypeScript,
    it is up to us to use types in a safer way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`类型帮助我们防止错误，因为它以明确的方式表达潜在的错误。在像Haskell这样的编程语言中，这是类型系统的默认行为，但在像TypeScript这样的编程语言中，我们必须自己以更安全的方式使用类型。'
- en: We will learn more about Promises in [Chapter 3](3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml),
    *Mastering Asynchronous Programming*. We will also learn more about how we can
    use a number of libraries to reduce the chances of side-effects in our TypeScript
    applications in [Chapter 8](ca940a3c-ec71-4a5c-bb96-41dfe38228de.xhtml), *Category
    Theory*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml)“掌握异步编程”中了解更多关于承诺的内容。我们还将了解如何在[第8章](ca940a3c-ec71-4a5c-bb96-41dfe38228de.xhtml)“范畴论”中使用多个库来减少TypeScript应用程序中副作用的可能性。
- en: If you find the idea of your JavaScript applications being free of side-effects
    attractive, you can try open-source projects such as [https://github.com/bodil/eslint-config-cleanjs](https://github.com/bodil/eslint-config-cleanjs).
    This project is an ESLint configuration that aims to restrict you to a subset
    of JavaScript, which would be as close to an idealized pure functional language
    as possible. Unfortunately, at the time of publication, no similar tools are available
    that are specifically designed for TypeScript.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你的JavaScript应用程序没有副作用的想法很有吸引力，你可以尝试开源项目，例如[https://github.com/bodil/eslint-config-cleanjs](https://github.com/bodil/eslint-config-cleanjs)。该项目是一个ESLint配置，旨在限制你使用JavaScript的一个子集，使其尽可能接近理想化的纯函数式语言。不幸的是，在出版时，没有可用的类似工具是专门为TypeScript设计的。
- en: Referential transparency
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明性
- en: 'Referential transparency is another concept closely related to pure functions
    and side-effects. A function is pure when it is free from side-effects. An expression
    is said to be referentially transparent when it can be replaced with its corresponding
    value without changing the application''s behavior. For example, if we are using
    the following in our code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性是与纯函数和副作用密切相关的一个概念。一个函数在它没有副作用时是纯的。当一个表达式可以被其对应值替换而不改变应用程序的行为时，它被称为引用透明的。例如，如果我们正在使用以下代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We know that the `isIndexPage` function is referentially transparent because
    it would be safe to substitute it for its return type. In this case, we know that
    when we invoke the `isIndexPage` function with `/` as an argument, the function
    will always return `true`, which means that it would be safe to do the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`isIndexPage`函数是引用透明的，因为它可以安全地用其返回类型替换它。在这种情况下，我们知道当我们用`/`作为参数调用`isIndexPage`函数时，该函数总是会返回`true`，这意味着我们可以安全地执行以下操作：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A pure function is a referentially transparent expression. An expression that
    is not referentially transparent is known as referentially opaque.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是一个引用透明表达式。一个不是引用透明的表达式被称为引用不透明。
- en: Stateless versus stateful
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态与有状态
- en: Pure functions and referentially transparent expressions are stateless. A piece
    of code is stateless when its outcomes are not influenced by previous events.
    For example, the results of the `isIndexPage` function will not be influenced
    by the number of times that we invoke it, or by the moment in time when we invoke
    it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数和引用透明表达式是无状态的。当代码的输出不受先前事件的影响时，该代码是无状态的。例如，`isIndexPage`函数的结果不会受到我们调用它的次数或调用它的具体时间的影响。
- en: The opposite of stateless code is stateful code. Stateless code is very difficult
    to test and becomes a problem when we are trying to implement scalable and resilient
    systems. Resilient systems are systems that can handle server failures; there
    is usually more than one instance of a service, and if one of them crashes, others
    can continue handling traffic. Also, new instances are created automatically after
    one of the instances has crashed. This becomes very difficult if our servers are
    stateful because we need to save the current state before a crash and restore
    the state before we spin up a new instance. The whole process becomes much simpler
    when we design our servers to be stateless.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态代码的反面是有状态代码。无状态代码非常难以测试，当我们试图实现可扩展和具有弹性的系统时，它成为一个问题。具有弹性的系统是可以处理服务器故障的系统；通常有多个服务实例，如果一个实例崩溃，其他实例可以继续处理流量。此外，在某个实例崩溃后，会自动创建新的实例。如果我们的服务器是有状态的，这会变得非常困难，因为我们需要在崩溃前保存当前状态，并在启动新实例前恢复状态。当我们设计服务器为无状态时，整个过程会变得简单得多。
- en: With the arrival of the cloud computing revolution, these kinds of system have
    become more common, and this has led to an interest in functional programming
    languages and design principles because functional programming encourages us to
    write stateless code. The opposite can be said of OOP because classes are the
    main construct in OOP applications. Classes encapsulate state properties that
    are then modified by methods, which encourages methods to be stateful and not
    pure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算革命的到来，这类系统变得更加普遍，这导致了对函数式编程语言和设计原则的兴趣，因为函数式编程鼓励我们编写无状态代码。对于OOP来说，情况则相反，因为类是OOP应用中的主要构造。类封装了状态属性，然后通过方法进行修改，这鼓励方法是有状态的，而不是纯的。
- en: Declarative versus imperative programming
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式与命令式编程
- en: 'The advocates of the FP paradigm often use declarative programming as one of
    its main benefits. Declarative programming is not necessarily exclusive to functional
    programming, but FP certainly encourages or facilitates this programming style.
    Before we take a look at some examples, we are going to define declarative programming
    and imperative programming:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: FP范式的倡导者经常将声明式编程作为其主要好处之一。声明式编程不一定仅限于函数式编程，但FP确实鼓励或促进这种编程风格。在我们查看一些示例之前，我们将定义声明式编程和命令式编程：
- en: '**Imperative programming** is a programming paradigm that uses statements that
    change a program''s state. In much the same way that the imperative mood in natural
    languages expresses commands, an imperative program consists of commands for the
    computer to perform. Imperative programming focuses on describing how a program
    operates.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令式编程**是一种使用语句改变程序状态的编程范式。与自然语言中的祈使语气表达命令的方式类似，命令式程序由计算机执行的一系列命令组成。命令式编程侧重于描述程序如何运行。'
- en: '**Declarative programming** is a programming paradigm that expresses the logic
    of a computation without describing its control flow. Many languages that apply
    this style attempt to minimize or eliminate side-effects by describing what the
    program must accomplish in terms of the problem domain, rather than describing
    how to accomplish it as a sequence of steps.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式编程**是一种编程范式，它通过描述计算逻辑而不是描述其控制流来表达。许多采用这种风格的编程语言试图通过以问题域的术语描述程序必须完成的内容来最小化或消除副作用，而不是描述如何通过一系列步骤来完成它。'
- en: 'The following example calculates the average result of an exam given a collection
    of objects that contains an ID and a result for a list of students. This example
    uses an imperative programming style because, as we can see, it uses control flow
    statements (`for`). The example is also clearly imperative because it mutates
    a state. The `total` variable is declared using the `let` keyword because it is
    mutated as many times as results are contained in the `results` array:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例计算了一个包含学生ID和成绩列表的对象集合的考试平均结果。这个示例使用命令式编程风格，因为我们可以看到，它使用了控制流语句（`for`）。这个示例也很明显是命令式的，因为它改变了状态。`total`变量使用`let`关键字声明，因为它被修改了，就像`results`数组中的结果一样多次：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the other hand, the following example is declarative because there are no
    control flow statements and there are no state mutations:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下示例是声明式的，因为没有控制流语句，也没有状态突变：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the previous example is declarative, it is not as declarative as it could
    be. The following example takes the declarative style one step further so we can
    get an idea of how a piece of declarative code may appear. Don''t worry if you
    don''t understand everything in this example right now. We will be able to understand
    it once we learn more about functional programming techniques later in this book.
    Note how the program is now defined as a set of very small functions that don''t
    mutate the state and that also don''t use control flow statements. These functions
    are reusable because they are independent of the problem that we are trying to
    solve. For example, the `avg` function can calculate an average, but it doesn''t
    need to be an average of results:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的示例是声明式的，但它并不像可能的那样声明式。以下示例将声明式风格进一步推进，以便我们可以了解一段声明式代码可能的样子。如果你现在不理解这个示例中的所有内容，请不要担心。一旦我们在这本书的后面部分学习了更多关于函数式编程技术，我们就能理解它。注意，现在程序被定义为一组非常小的函数，这些函数不改变状态，也不使用控制流语句。这些函数是可重用的，因为它们独立于我们试图解决的问题。例如，`avg`函数可以计算平均值，但它不需要是结果的平均值：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The actual code that is specific to the problem that we are trying to solve
    is very small:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图解决的问题的特定代码非常小：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code is not reusable, but the `add`, `addMany`, `div`, `mapProp`, and `avg`
    functions are reusable. This demonstrates how declarative programming can lead
    to more reusable code than imperative programming.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不可重用，但`add`、`addMany`、`div`、`mapProp`和`avg`函数是可重用的。这展示了声明式编程如何比命令式编程产生更多可重用代码。
- en: Immutability
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: Immutability refers to the inability to change the value of a variable after
    a value has been assigned to it. Purely functional programming languages include
    immutable implementations of common data structures. For example, when we add
    an element to an array, we are mutating the original array. However, if we use
    an immutable array and we try to add a new element to it, the original array will
    not be mutated, and we will add the new item to a copy of it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性指的是在将值赋给变量之后无法更改该变量的值。纯函数式编程语言包括常见数据结构的不可变实现。例如，当我们向数组添加一个元素时，我们正在修改原始数组。然而，如果我们使用不可变数组，并尝试向其中添加新元素，原始数组将不会被修改，我们将新项目添加到它的副本中。
- en: 'The following code snippet declares a class named `ImmutableList` that demonstrates
    how it is possible to implement an immutable array:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为`ImmutableList`的类，展示了如何实现不可变数组：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Every time we add an item to, or remove it from, the immutable array, we create
    a new instance of the immutable array. This implementation is very inefficient,
    but it demonstrates the basic idea. We are going to create a quick test to demonstrate
    how the preceding class works. We are going to use some data regarding superheroes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们向不可变数组中添加或删除一个项目时，我们都会创建一个不可变数组的新的实例。这种实现非常低效，但它展示了基本思想。我们将创建一个快速测试来演示前面类的工作方式。我们将使用一些关于超级英雄的数据：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now use the preceding data to create a new immutable list instance.
    When we add a new superhero to the list, a new immutable list is created. If we
    try to search for the superhero `Hulk` in the two immutable lists, we will observe
    that only the second list contains it. We can also compare both lists to observe
    that they are two different objects, demonstrated as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用前面的数据来创建一个新的不可变列表实例。当我们向列表中添加一个新的超级英雄时，会创建一个新的不可变列表。如果我们尝试在两个不可变列表中搜索超级英雄“浩克”，我们会观察到只有第二个列表包含它。我们还可以比较这两个列表，以观察到它们是两个不同的对象，如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating our own immutable data structures is, in most cases, not necessary.
    In a real-world application, we can use libraries such as `Immutable.js` to enjoy
    immutable data structures.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，创建我们自己的不可变数据结构是不必要的。在实际应用中，我们可以使用`Immutable.js`等库来享受不可变数据结构。
- en: Functions as first-class citizens
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: 'It is common to find mentions of functions as **first-class citizens** in the
    FP literature. We say that a function is a first-class citizen when it can do
    everything that a variable can do, which means that functions can be passed to
    other functions as an argument. For example, the following function takes a function
    as its second argument:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP文献中经常提到函数作为**一等公民**。当我们说一个函数是一等公民时，意味着它可以做任何变量能做的事情，这意味着函数可以作为参数传递给其他函数。例如，以下函数将其第二个参数作为函数：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or, it is returned by another function. For example, the following function
    takes a function as its only argument and returns a function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它被另一个函数返回。例如，以下函数只接受一个函数作为其唯一参数，并返回一个函数：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Functions can also be assigned to variables. For example, in the preceding
    code snippet, we assigned the function returned by the find function to a variable
    named `findSpiderman`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以赋值给变量。例如，在前面的代码片段中，我们将find函数返回的函数赋值给名为`findSpiderman`的变量：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both JavaScript and TypeScript treat functions as first-class citizens.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript和TypeScript都将函数视为一等公民。
- en: Lambda expressions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: 'Lambda expressions are just expressions that can be used to declare anonymous
    functions (functions without a name). Before the ES6 specification, the only way
    to assign a function as a value to a variable was to use a function expression:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式只是可以用来声明匿名函数（无名的函数）的表达式。在ES6规范之前，将函数作为值赋给变量的唯一方法是使用函数表达式：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The ES6 specification introduced the arrow function syntax:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ES6规范引入了箭头函数语法：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Please refer to [Chapter 2](5c1a8b07-e106-4ea8-a5e5-909e641eb271.xhtml), *Mastering
    Functions*, [Chapter 4](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml), *The Runtime –
    The Event Loop and the this Operator*, and [Chapter 5](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml),
    *The Runtime – Closures and Prototypes*, to learn more about arrow functions and
    function expressions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第2章](5c1a8b07-e106-4ea8-a5e5-909e641eb271.xhtml)“掌握函数”、[第4章](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml)“运行时
    – 事件循环和this操作符”以及[第5章](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)“运行时 – 闭包和原型”，以了解更多关于箭头函数和函数表达式的信息。
- en: Function arity
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数元数
- en: 'The **arity** of a function is the number of arguments that the function takes.
    A unary function is a function that only takes a single argument:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的**元数**是指函数所接受的参数数量。一元函数是指只接受单个参数的函数：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Unary functions are very important in functional programming because they facilitate
    utilization of the function composition pattern.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一元函数在函数式编程中非常重要，因为它们促进了函数组合模式的应用。
- en: We will learn more about function composition patterns later in [Chapter 6](b9229d02-8eca-4ff7-a88f-e4ccb019270f.xhtml),
    *Functional Programming Techniques*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](b9229d02-8eca-4ff7-a88f-e4ccb019270f.xhtml)“函数式编程技术”中更深入地了解函数组合模式。
- en: 'A binary function is a function that takes two arguments:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 二元函数是指接受两个参数的函数：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Functions with two or more arguments are also important because some of the
    most common FP patterns and techniques (for example, partial application and currying)
    have been designed to transform functions that allow multiple arguments into unary
    functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 具有两个或更多参数的函数也很重要，因为一些最常用的FP模式和技巧（例如，部分应用和柯里化）已经被设计成将接受多个参数的函数转换为单参数函数。
- en: 'There are also functions with three (**ternary functions**) or more arguments.
    However, functions that accept a variable number of arguments, known as **variadic
    functions**, are particularly interesting in functional programming, as demonstrated
    in the following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些具有三个（**三元函数**）或更多参数的函数。然而，接受可变数量参数的函数，称为**可变参数函数**，在函数式编程中特别有趣，如下代码片段所示：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Higher-order functions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'A higher-order function is a function that does at least one of the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是指至少执行以下操作之一的函数：
- en: Takes one or more functions as arguments
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个或多个函数作为参数
- en: Returns a function as its result
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数作为其结果
- en: Higher-order functions are some of the most powerful tools that we can use to
    write JavaScript in a functional programming style. Let's look at some examples.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是我们可以使用的一些最强大的工具，可以帮助我们用函数式编程风格编写JavaScript。让我们看看一些例子。
- en: 'The following code snippet declares a function named `addDelay`. The function
    creates a new function that waits for a given number of milliseconds before printing
    a message in the console. The function is considered a higher-order function because
    it returns a function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为`addDelay`的函数。该函数创建一个新的函数，该函数在控制台打印消息之前等待给定数量的毫秒。这个函数被认为是一个高阶函数，因为它返回一个函数：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following code snippet declares a function named `addDelay`. The function
    creates a new function that adds a delay in milliseconds to the execution of another
    function that is passed as an argument. The function is considered a higher-order
    function because it takes a function as an argument and returns a function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为`addDelay`的函数。该函数创建一个新的函数，该函数将延迟（以毫秒为单位）添加到作为参数传递的另一个函数的执行中。这个函数被认为是一个高阶函数，因为它接受一个函数作为参数并返回一个函数：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Higher-order functions are an effective technique for abstracting a solution
    for a common problem. The preceding example demonstrates how we can use a higher-order
    function (`addDelay`) to add a delay to another function (`sayHello`). This technique
    allows us to abstract the delay functionality and keeps the `sayHello` function,
    or other functions, agnostic of the implementation details of the delay functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是抽象常见问题解决方案的有效技术。前面的例子演示了我们可以如何使用高阶函数（`addDelay`）来给另一个函数（`sayHello`）添加延迟。这种技术允许我们抽象延迟功能，并保持`sayHello`函数或其他函数对延迟功能的实现细节无感知。
- en: Laziness
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰性
- en: 'Many functional programming languages feature lazy-evaluated APIs. The idea
    behind lazy evaluation is that operations are not computed until doing so can
    no longer be postponed. The following example declares a function that allows
    us to find an element in an array. When the function is invoked, we don''t filter
    the array. Instead, we declare a `proxy` and a `handler`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数式编程语言都提供了懒加载的API。懒加载背后的想法是，只有在无法再推迟操作时才会进行计算。以下示例声明了一个函数，允许我们在数组中查找元素。当函数被调用时，我们不会过滤数组。相反，我们声明了一个`proxy`和一个`handler`：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is only later, when one of the properties in the result is accessed, that
    the `proxy handler` is invoked and filtering takes place:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在访问结果中的某个属性之后，才会调用`proxy handler`并执行过滤操作：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we examine the console output, we will be able to see that the Filtering... message
    is not logged into the console until we access the property `name` of the `result` object.
    The preceding implementation is a very rudimentary implementation, but it can
    help us to understand how lazy evaluation works. Laziness can sometimes improve
    the overall performance of our applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查控制台输出，我们会看到，只有在访问`result`对象的`name`属性时，`Filtering...`消息才会被记录到控制台。前面的实现是一个非常基础的实现，但它可以帮助我们理解懒加载是如何工作的。有时，懒惰性可以提高我们应用程序的整体性能。
- en: We will learn more about function composition patterns later in [Chapter 9](6a03c916-f7a5-439a-bea6-6facecef0347.xhtml),
    *Functional-Reactive Programming*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第9章[函数式响应式编程](6a03c916-f7a5-439a-bea6-6facecef0347.xhtml)中了解更多关于函数组合模式的内容。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored some of the most fundamental principles and concepts
    of the functional programming paradigm.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了函数式编程范式的某些最基本的原则和概念。
- en: Over the next four chapters, we are going to deviate a little bit from functional
    programming because we are going to take an extensive look at functions, asynchronous
    programming, and certain aspects of the TypeScript/JavaScript runtime, such as
    closures and prototypes. We need to explore these topics before we can learn more
    about the implementation of functional programming techniques. However, if you
    are already very confident with using functions, closures, the `this` operator,
    and prototypes, then you should be able to skip the next four chapters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的四章中，我们将稍微偏离函数式编程，因为我们将要深入探讨函数、异步编程以及TypeScript/JavaScript运行时的某些方面，例如闭包和原型。在我们学习更多关于函数式编程技术实现之前，我们需要探索这些主题。然而，如果你已经非常自信地使用函数、闭包、`this`运算符和原型，那么你应该能够跳过接下来的四章。
