- en: Getting Started with TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 入门
- en: In this chapter, we will look at TypeScript and see how to use TypeScript in
    a new project or an existing JavaScript project. We will see how to adapt the
    environment of your current build setup. TypeScript can be supported by a variety
    of build tools, such as Grunt, Gulp, webpack, or simply by using the **command-line
    interface** (**CLI**). We also look at the best options, among all the ones available,
    for getting started with TypeScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 TypeScript 并了解如何在新的项目或现有的 JavaScript 项目中使用 TypeScript。我们将看到如何适应你当前的构建环境。TypeScript
    可以由各种构建工具支持，例如 Grunt、Gulp、webpack 或简单地通过使用 **命令行界面**（**CLI**）。我们还探讨了在所有可用的选项中，开始使用
    TypeScript 的最佳选项。
- en: 'Before configuring any build tool, it''s important to understand that all of
    them use the same TypeScript compiler, often called a transpiler. The TypeScript
    compiler is available by using npm:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置任何构建工具之前，重要的是要理解它们都使用相同的 TypeScript 编译器，通常被称为转换器。TypeScript 编译器可以通过 npm 使用：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Npm might not be installed by default on your computer. If that is the case,
    the previous instruction will fail. It means you need to install Node.js. You
    can install Node.js by going to the official website, [https://nodejs.org/](https://nodejs.org/).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Npm 可能默认没有安装在你的电脑上。如果是这种情况，之前的指令将会失败。这意味着你需要安装 Node.js。你可以通过访问官方网站 [https://nodejs.org/](https://nodejs.org/)
    来安装 Node.js。
- en: 'At any time, you can verify that you have Node.js, npm, and TypeScript installed
    by using the following command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，你都可以使用以下命令来验证你是否已经安装了 Node.js、npm 和 TypeScript：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: TSC is the executable for the TypeScript compiler. This is the one that is used
    by all build tools. Grunt, Gulp, and webpack use TSC via their own plugin infrastructures
    that map TSC features to their platform. Note that recent TSC features might take
    a few weeks before reaching these platforms. This might explain the differences
    in compiler options when using these three build systems. In contrast, using a
    TSC CLI ensures that you are using TypeScript directly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TSC 是 TypeScript 编译器的可执行文件。这是所有构建工具都使用的文件。Grunt、Gulp 和 webpack 通过它们各自的插件基础设施使用
    TSC，这些基础设施将 TSC 的功能映射到它们自己的平台。请注意，最近的 TSC 功能可能需要几周时间才能到达这些平台。这可能是使用这三个构建系统时编译器选项差异的原因。相比之下，使用
    TSC CLI 确保你直接使用 TypeScript。
- en: 'This chapter covers the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下内容：
- en: Grunt
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grunt
- en: Gulp
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp
- en: Webpack
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack
- en: NMP/CLI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM/CLI
- en: TypeScript compiler
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 编译器
- en: Grunt
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grunt
- en: 'Grunt is a JavaScript task runner. It can be installed using NPM, which is
    used to list all its plugins:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 是一个 JavaScript 任务运行器。它可以通过 NPM 安装，NPM 用来列出所有它的插件：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the case of a new project, make sure that `package.json` exists in the root
    of your TypeScript project. You can generate a simple one by using `npm init`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在新项目的情况下，请确保你的 TypeScript 项目的根目录中存在 `package.json` 文件。你可以通过使用 `npm init` 命令来生成一个简单的
    `package.json`。
- en: 'Once it is done, you can install Grunt into your project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以在你的项目中安装 Grunt：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once Grunt is available on your machine and specified in your project, you
    need to get a TypeScript plugin. Grunt has two plugins named `grunt -TypeScript`
    and `grunt-TS`. The former has not been maintained for a few years and lacks the
    latest TypeScript compiler configuration. I strongly suggest using the latter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Grunt 在你的机器上可用并在你的项目中指定，你需要获取一个 TypeScript 插件。Grunt 有两个插件名为 `grunt -TypeScript`
    和 `grunt-TS`。前者已经有一段时间没有维护，并且缺少最新的 TypeScript 编译器配置。我强烈建议使用后者：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last package should be installed as a dev dependency for Grunt to compile
    TypeScript and to install it locally. Grunt will search for the package locally.
    Omitting TypeScript as a local dependency will result in the following error when
    executing Grunt.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个包应该被安装为一个开发依赖，以便 Grunt 能够编译 TypeScript 并本地安装它。Grunt 将会在本地搜索这个包。省略 TypeScript
    作为本地依赖将会在执行 Grunt 时导致以下错误。
- en: 'ENOENT: no such file or directory, open `''/.../node_modules/grunt-ts/node_modules/typescript/package.json''`
    Use `--force` to continue.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ENOENT：找不到文件或目录，打开 `'/.../node_modules/grunt-ts/node_modules/typescript/package.json'`
    使用 `--force` 继续操作。
- en: 'Installing TypeScript locally as a `dev` dependency is easy:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将 TypeScript 本地作为 `dev` 依赖项安装很简单：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Prior to `grunt-ts` version 6, TypeScript and Grunt were installed during the
    installation of `grunt-ts`. This is not the case anymore, so they must be added
    manually.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `grunt-ts` 版本 6 之前，TypeScript 和 Grunt 在 `grunt-ts` 的安装过程中一起安装。现在不再是这样了，所以它们必须手动添加。
- en: The next step is to configure Grunt to use a TypeScript plugin. If you are not
    using Grunt, you need to create a `Gruntfile.js` at the root of your project.
    Otherwise, you can edit your existing one. The plugin allows you to specify many
    TypeScript options in the `Gruntfile.js`, but a good practice is to limit TypeScript
    options directly in the file and to leverage the TypeScript configuration file.
    By configuring TypeScript outside Grunt, this gives you the possibility of compiling
    your code without Grunt, or migrating to another build tool without having to
    duplicate or change TypeScript preferences.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置 Grunt 以使用 TypeScript 插件。如果您没有使用 Grunt，您需要在项目的根目录下创建一个 `Gruntfile.js`
    文件。否则，您可以编辑现有的一个。该插件允许您在 `Gruntfile.js` 中指定许多 TypeScript 选项，但一个好的做法是直接在文件中限制 TypeScript
    选项，并利用 TypeScript 配置文件。通过在 Grunt 之外配置 TypeScript，这为您提供了在不重复或更改 TypeScript 首选项的情况下，编译代码而不使用
    Grunt 或迁移到另一个构建工具的可能性。
- en: 'A minimalist Grunt configuration with the sole purpose of compiling TypeScript
    into JavaScript may look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个仅用于将 TypeScript 编译成 JavaScript 的极简 Grunt 配置可能看起来像以下这样：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Grunt configuration creates a default task that executes a custom `ts` task
    that links to the `tsconfig.json` file, which is the default TypeScript configuration
    file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 配置创建了一个默认任务，该任务执行一个自定义的 `ts` 任务，该任务链接到 `tsconfig.json` 文件，这是默认的 TypeScript
    配置文件。
- en: 'The `tsconfig.json` file can look like the following one, which takes every
    TypeScript file with the extension `.ts` and will compile them outputting the
    result in the `build` folder:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsconfig.json` 文件可能看起来像以下这样，它将编译所有扩展名为 `.ts` 的 TypeScript 文件，并将结果输出到 `build`
    文件夹：'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When using `grunt` and `grunt-ts`, you must ensure that that the JSON is valid
    with no-trailing commas in the `tsconfig.json` file. Otherwise, you may get the
    following error:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `grunt` 和 `grunt-ts` 时，您必须确保 `tsconfig.json` 文件中的 JSON 是有效的，且没有尾随逗号。否则，您可能会遇到以下错误：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To test the configuration, create a simple `index.ts` file in an `src` folder
    at the root of the project. You can type `console.log('test')`. After, run `grunt`
    in a command line at the root of your project as well. This will create a `build`
    folder with an `index.js` file containing the same line of code. It will also
    create the `js.map` file that will let you debug in your browser directly in TypeScript's
    code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试配置，在项目根目录下的 `src` 文件夹中创建一个简单的 `index.ts` 文件。您可以输入 `console.log('test')`。之后，在项目根目录的命令行中运行
    `grunt`。这将创建一个包含相同代码行的 `index.js` 文件的 `build` 文件夹。它还将创建一个 `js.map` 文件，让您可以直接在浏览器中调试
    TypeScript 代码。
- en: 'If, for some reason, you do not want to rely on `tsconfig.json`, it''s possible
    to specify the source and destination directly into `Gruntfile.js` file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，您不想依赖 `tsconfig.json`，您可以直接在 `Gruntfile.js` 文件中指定源和目标：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the end, `grunt-ts` wraps the TypeScript command line. It provides options
    such as the *fast compilation*, which compile, only what has changed since the
    last compilation. It is also an interesting option if you are already using Grunt
    in your project and want to start using TypeScript without modifying your build
    process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`grunt-ts` 包装了 TypeScript 命令行。它提供了如 *快速编译* 等选项，只编译自上次编译以来发生变化的文件。如果您已经在项目中使用
    Grunt，并希望开始使用 TypeScript 而不修改您的构建过程，这也是一个有趣的选项。
- en: Gulp
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gulp
- en: 'Gulp is an automation toolkit that has a TypeScript plugin as well. There are
    two plugins available in NPM, which are `gulp-tsb` and `gulp-typescript`. The
    latter is the most popular and more maintained. You can fetch `gulp` and the plugin
    by using the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 是一个具有 TypeScript 插件的自动化工具包。NPM 中有两个插件可用，分别是 `gulp-tsb` 和 `gulp-typescript`。后者是最受欢迎且维护得更好的。您可以使用以下命令获取
    `gulp` 和插件：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you do not have a Gulp configuration file, you will need to create one at
    the root of your `gulpfile.js` project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有 Gulp 配置文件，您需要在 `gulpfile.js` 项目的根目录下创建一个。
- en: 'The configuration without an explicit option will rely on the default configuration.
    It means that configuring Gulp can be as simple as piping the source into the
    TypeScript plugin and then piping the result into the destination folder where
    the `build` files, that is the JavaScript file, will be placed for consumption.
    Once the following code is placed in `gulpfile.js`, you can execute it by using
    `gulp` in the command line. This will execute the *default task* once, automatically:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有明确选项的配置将依赖于默认配置。这意味着配置 Gulp 可以像将源代码管道输入 TypeScript 插件，然后将结果管道输入目标文件夹一样简单，该文件夹将放置
    `build` 文件，即 JavaScript 文件，以便消费。一旦将以下代码放置在 `gulpfile.js` 中，您就可以通过在命令行中使用 `gulp`
    来执行它。这将自动执行一次 *默认任务*：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is possible to have a task in Gulp to build incrementally a TypeScript file
    that changes instead of building all of them. This can be useful on a big project
    to reduce the time between the edition and the access to the result. This is similar
    to the *fast compilation* of Grunt. To have an ongoing compilation, you must create
    a new Gulp task. In this example, we will change Gulp to rely on `tsconfig.json`
    file, which will allow us to separate the TypeScript compiler option from the
    Gulp configuration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gulp 中有一个任务可以增量构建更改的 TypeScript 文件，而不是构建所有文件。这对于大型项目来说可能很有用，可以减少编辑和访问结果之间的时间。这与
    Grunt 的 *快速编译* 类似。为了实现持续编译，您必须创建一个新的 Gulp 任务。在这个例子中，我们将把 Gulp 改为依赖于 `tsconfig.json`
    文件，这将允许我们将 TypeScript 编译器选项与 Gulp 配置分开：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run the `watch` task, you need to execute Gulp followed by the name of the
    task: `gulp watch`. Unlike Grunt, Gulp will not produce the `map` file. It requires
    an additional Gulp plugin. Because the sourceMap is crucial to have an efficient
    debugging environment, it is keen to download the `gulp-sourcemap` package and
    change the previous configuration to the following. But first, let''s download
    the `gulp-sourcemaps` package:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 `watch` 任务，您需要先执行 Gulp，然后跟随着任务的名称：`gulp watch`。与 Grunt 不同，Gulp 不会生成 `map`
    文件。它需要一个额外的 Gulp 插件。因为源映射对于拥有高效的调试环境至关重要，所以强烈建议下载 `gulp-sourcemap` 包，并将之前的配置更改为以下内容。但首先，让我们下载
    `gulp-sourcemaps` 包：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And then create a new task:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个新的任务：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The configuration will create the source map in a file with the same name as
    the JavaScript file generated but with a different extension. The extension will
    be `.jsmap`. If you want to have the mapping directly in the JavaScript file,
    you can remove the two arguments passed in the `write` function. I suggest having
    a single script task that produces the source map in a file to separate the mapping
    from the code generated, and to always have the source map created. It's a small
    tax on the compilation and a huge gain in debugging.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 配置将在与生成的 JavaScript 文件同名但扩展名不同的文件中创建源映射。扩展名将是 `.jsmap`。如果您想在 JavaScript 文件中直接包含映射，可以移除在
    `write` 函数中传入的两个参数。我建议有一个单独的脚本任务，在文件中生成源映射，以将映射与生成的代码分开，并始终创建源映射。这是编译过程中的小代价，但在调试中能带来巨大的收益。
- en: Webpack
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack
- en: Webpack is one of the most commonly used ways to automate workflow when working
    with JavaScript and web development. Its main purpose is to bundle, but it can
    do many sequential steps, such as compiling TypeScript. Similarly to Grunt and
    Gulp, webpack has two loaders (similar to a plugin) for TypeScript. One is called
    `ts-loader` and the second `awesome-typescript-loader`. While with Grunt and Gulp,
    it was a clear which one users prefer, this is not the case with Webpack. Both
    loaders are similar in terms of popularity. It is also not difficult to change
    between the two if needed. Originally, `awesome-typescript-loader` was faster
    than `ts-loader` but with the evolution of TypeScript, the difference is often
    minimal. Also, there is sometimes an issue with an advanced feature in one or
    the other, and so it is practical to be able to switch depending on how your project.
    I'll present `ts-loader`, which is a little more popular, still actively maintained,
    and has a little more usage than the `awesome-typescript-loader`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack是当与JavaScript和Web开发一起工作时自动化工作流程最常用的方式之一。其主要目的是捆绑，但它可以执行许多连续步骤，例如编译TypeScript。类似于Grunt和Gulp，webpack有两个用于TypeScript的加载器（类似于插件）。一个是`ts-loader`，另一个是`awesome-typescript-loader`。在Grunt和Gulp中，用户更喜欢哪一个很明确，但在Webpack中并非如此。这两个加载器在受欢迎程度方面相似。如果需要，它们之间切换也不困难。最初，`awesome-typescript-loader`比`ts-loader`更快，但随着TypeScript的发展，差异通常很小。此外，有时一个或另一个的高级功能可能会出现问题，因此能够根据您的项目进行切换是实用的。我将介绍`ts-loader`，它稍微更受欢迎，仍然积极维护，并且比`awesome-typescript-loader`有更多的使用。
- en: 'In the case, you are not yet using `webpack`, we need to install it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未使用`webpack`，我们需要安装它：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once webpack is installed, you can install the TypeScript loader:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了webpack，您就可以安装TypeScript加载器：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once all the tools are installed, you can configure webpack to bundle the JavaScript
    produced by the `webpack` loader. However, `webpack.config.js` is needed at the
    root of your project. Like any Webpack configuration, the entry property must
    be defined. Make sure you are referring to the TypeScript file. The output is
    also specified in the output property. Webpack requires mentioning the extension
    to be analyzed. In TypeScript case it is `.ts`, but if you are working with React
    you might want to also add `.tsx` under `resolve:extensions`. Finally, the `ts-loader`
    is specified under `module:rules`. Once again, the extension of TypeScript is
    required and the name of the loader:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有工具都安装完毕，您就可以配置webpack以捆绑由`webpack`加载器产生的JavaScript。然而，在项目的根目录中需要`webpack.config.js`文件。像任何Webpack配置一样，入口属性必须被定义。确保您正在引用TypeScript文件。输出也在输出属性中指定。Webpack需要提及要分析的扩展名。在TypeScript的情况下是`.ts`，但如果您使用React工作，您可能还希望在`resolve:extensions`下添加`.tsx`。最后，在`module:rules`下指定`ts-loader`。再次强调，需要TypeScript的扩展名和加载器的名称：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can run the webpack command line (`cli`) by accessing the binary file,
    which will read the `webpack.config.js` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问二进制文件来运行webpack命令行（`cli`），这将读取`webpack.config.js`文件：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you want to avoid referencing `node_modules`, you can install `webpack-cli`
    in your global space, using `npm install -g webpack-cli`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想避免引用`node_modules`，您可以在全局空间中安装`webpack-cli`，使用`npm install -g webpack-cli`。
- en: 'Here are a few little details about webpack. There is an additional module
    that divides the production of the bundle and compilation, compared to just validating
    TypeScript. These modules might be interesting when your project starts to grow
    and you want to have a faster compilation pace. Feel free to check `fork-ts-checker-webpack-plugin`
    and `thread-loader`. Before diving into other libraries, `ts-loader` has a way
    to incrementally build and to use the TypeScript watch API to avoid building everything
    all the time. This will increase your performance on every compilation. To allow
    the watch, change the rule of `ts-loader` to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于webpack的一些小细节。与仅验证TypeScript相比，webpack有一个额外的模块，它将包的生产和编译分开。当您的项目开始增长并且希望拥有更快的编译速度时，这些模块可能很有趣。您可以随意检查`fork-ts-checker-webpack-plugin`和`thread-loader`。在深入研究其他库之前，`ts-loader`有一种增量构建的方法，并使用TypeScript的watch
    API来避免总是构建一切。这将提高每次编译的性能。要允许监视，将`ts-loader`的规则更改为以下内容：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A final detail about webpack is its dependency on `tsconfig.json` for all TypeScript
    related configurations. Grunt and Gulp allow you to override configurations inside
    their tool configuration, which is not the case with webpack. When bundling, webpack
    produces `bundle.js.map`, but only if the dev tool specifies a configuration.
    However, you must set the `tsconfig.json` "sourceMap" to `true` to have a mapping
    that works with TypeScript.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于webpack的最后一个细节是它依赖于`tsconfig.json`来进行所有TypeScript相关配置。Grunt和Gulp允许您在它们的工具配置中覆盖配置，而webpack则不是这样。在打包时，webpack会生成`bundle.js.map`，但前提是开发工具指定了配置。然而，您必须将`tsconfig.json`的“sourceMap”设置为`true`，以便生成与TypeScript兼容的映射。
- en: NPM/CLI
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPM/CLI
- en: Almost all web projects use NPM. NPM is the mechanism we used to fetch TypeScript.
    This one creates `package.json` at the root of your project and can be used to
    launch TypeScript directly. This is possible because TypeScript has a CLI called
    **tsc** (**TypeScript compiler**).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有Web项目都使用NPM。NPM是我们用来获取TypeScript的机制。它会在项目根目录创建`package.json`，并可以直接用来启动TypeScript。这是因为TypeScript有一个名为**tsc**（**TypeScript编译器**）的CLI。
- en: 'NPM configuration has a section named `scripts` where you can add any command
    you want. You can create a `build` one that invokes tsc. Without any parameters,
    tsc uses `tsconfig.json` at the root of your project. In the following snippet,
    the "build" script is defined. To run the command, the use of the `run` command
    of NPM is needed, that is, `npm run build`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: NPM配置中有一个名为`scripts`的部分，您可以在其中添加任何想要的命令。您可以创建一个`build`命令，该命令调用tsc。如果没有任何参数，tsc将使用项目根目录下的`tsconfig.json`。在下面的代码片段中，定义了“build”脚本。要运行该命令，需要使用NPM的`run`命令，即`npm
    run build`：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With a TypeScript configuration file that specifies the source map, the `rootDir`,
    and `outDir` the result will be the same as Gulp and Grunt (different from webpack
    since it won''t be bundled):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指定了源映射、`rootDir`和`outDir`的TypeScript配置文件，结果将与Gulp和Grunt相同（与webpack不同，因为它不会进行打包）：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is often not the preferred configuration because of how simplistic and
    limited it is. However, it's possible to have several commands executed one after
    the other, using the double ampersand (`&&`) to create a chain of commands. This
    option is fast, doesn't require any dependency on NPM libraries, and is often
    enough to get started at a basic level.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置通常不是首选，因为它过于简单且有限。然而，可以使用双与号(`&&`)创建一系列命令，一个接一个地执行。这个选项速度快，不需要依赖NPM库，通常足以在基本级别上开始。
- en: The advantage of the NPM and CLI approach is that TypeScript can be executed
    easily. Hence, if you have a custom build system you can easily plug TypeScript
    by invoking the CLI.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: NPM和CLI方法的优势在于TypeScript可以轻松执行。因此，如果您有一个自定义的构建系统，您可以轻松通过调用CLI来集成TypeScript。
- en: TypeScript compiler
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript编译器
- en: 'Considering all the tooling available to compile TypeScript to JavaScript,
    one pillar concept remains the same: you must know which configuration to use.
    Insofar that you are not responsible for configuring the compiler, you could skip
    this section – configuring TypeScript is something you do rarely and when it works
    as desired it can stay unaltered for a very long time. However, to have an understanding
    of the capability of TypeScript, you need to know some of the core options. In
    this section, we will see the main settings that you can enable and customize
    for your project.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有可用的工具都可以将TypeScript编译成JavaScript，一个核心概念保持不变：您必须知道使用哪种配置。既然您不负责配置编译器，您可以跳过这一节——配置TypeScript是您很少做的事情，而且当它按预期工作后，可以长时间保持不变。然而，为了了解TypeScript的能力，您需要了解一些核心选项。在本节中，我们将看到您可以为项目启用和自定义的主要设置。
- en: Files location
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件位置
- en: This section is all about the configuration of files in the file system. It
    guides TypeScript on where to find different files in your machine, as well as
    where to generate JavaScript files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节主要关于文件系统中的文件配置。它指导TypeScript在您的机器上查找不同的文件位置，以及在哪里生成JavaScript文件。
- en: rootDir and outDir
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rootDir和outDir
- en: The most basic configuration that you need to set for your project is to indicate
    to TypeScript where to get TypeScript files and where to publish the result of
    the compilation. Where will be the TypeScript (`.ts`) files and the JavaScript
    (`.js`) files be produced. This is done by specifying `rootDir` and `outDir`.
    Avoiding `rootDir` might give you a surprise in `outDir`. By default, TypeScript
    computes what it should be and tries to find a common path, which is the longest
    common prefix of all your input files. That has the drawback of being inconsistent
    when the file structures change. Recently, TypeScript changed its behavior to
    have a default to `.`, which alleviate the issue. Nevertheless, having an explicit
    configuration is the best practice to avoid confusion as to which version of TypeScript
    this new rule was applied.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的项目，您需要设置的最基本的配置是告诉 TypeScript 从哪里获取 TypeScript 文件以及将编译结果发布到何处。TypeScript
    (`.ts`) 文件和 JavaScript (`.js`) 文件将生产在哪里。这是通过指定 `rootDir` 和 `outDir` 来完成的。避免使用
    `rootDir` 可能会在 `outDir` 中给您带来惊喜。默认情况下，TypeScript 会计算它应该是什么，并尝试找到一个公共路径，即所有输入文件的最长公共前缀。这有一个缺点，即当文件结构发生变化时，它可能是不一致的。最近，TypeScript
    改变了其行为，默认为 `.`，这缓解了问题。尽管如此，具有显式配置是最佳实践，以避免对哪种版本的 TypeScript 应用了此新规则的混淆。
- en: 'Example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: baseUrl and paths
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: baseUrl 和 paths
- en: Confusion can arise when the baseUrl and paths come into play. The baseUrl allows
    specifying with a non-relative name to be resolved. Paths work closely with the
    baseUrl and is a map of key-value allowing a name to be used as a link to a specific
    path to the library, using the baseUrl as the root.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当 baseUrl 和 paths 一起使用时，可能会产生混淆。baseUrl 允许使用非相对名称进行解析。Paths 与 baseUrl 密切相关，是一个键值映射，允许使用名称作为链接到库的特定路径，使用
    baseUrl 作为根。
- en: 'Here is an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Paths can also be used for more advanced scenarios where you can define fallback
    folders. As good practice, I would advise using a relative path as much as possible
    and avoid complicated structures and potential resolving issues.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Paths 也可以用于更高级的场景，其中您可以定义后备文件夹。作为良好的实践，我建议尽可能使用相对路径，并避免复杂的结构和潜在的解析问题。
- en: sourceRoot and sourceMap and mapRoot
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sourceRoot 和 sourceMap 以及 mapRoot
- en: The sourceMap property is a boolean that when set to `true` will generate the
    mapping between the generated JavaScript and TypeScript. This is a good option
    to turn on if you do debug in a browser and want to step in the TypeScript code
    instead of stepping into the generated code. It simplifies the debugging because
    you are working in exactly the same area. This is most of the time turned on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: sourceMap 属性是一个布尔值，当设置为 `true` 时，将生成生成的 JavaScript 和 TypeScript 之间的映射。如果您在浏览器中调试并希望进入
    TypeScript 代码而不是进入生成的代码，这是一个很好的选项。这简化了调试，因为您正在工作的区域完全相同。这通常是打开的。
- en: 'However, sourceRoot is rarely used in normal circumstances. It is available
    if you move the sourceMap somewhere else to indicate at runtime where to find
    the sourceMap. This will alter the generated sourceMap path. The following code
    shows a comment indicating the path of the map file. SourceRoot would change the
    portion before `index.js.map`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在正常情况下，sourceRoot 很少被使用。如果你将 sourceMap 移动到其他位置以在运行时指示其位置，则它可用。这将改变生成的 sourceMap
    路径。以下代码展示了注释，说明了映射文件的路径。SourceRoot 会改变 `index.js.map` 前的部分：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Similarly, mapRoot allows changing the source if the map files are in a different
    place than the JavaScript file. The difference between sourceRoot and mapRoot
    is this time we alter the map file instead of the JavaScript file. In the following
    partial extraction of a code of a map file, we see paths that can be modified
    by mapRoot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，mapRoot 允许在映射文件位于 JavaScript 文件不同位置时更改源。sourceRoot 和 mapRoot 的区别在于这次我们更改的是映射文件而不是
    JavaScript 文件。在以下映射文件代码的部分提取中，我们看到可以由 mapRoot 修改的路径：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The moment to use or the other depending on how you configure positions your
    built files. If you move the map somewhere else, then `sourceRoot` is interesting.
    However, if you keep the map but move the JavaScript somewhere else than you may
    change mapRoot. I mention these configurations for the sole reason that you may
    already have a JavaScript project that you want to migrate to TypeScript. Depending
    on your existing configuration, you may need to tweak these configurations. However,
    for any standard project, no modification should be made to these configurations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用或配置的时机取决于你如何配置你的构建文件。如果你将映射移动到其他地方，那么`sourceRoot`就很有趣。然而，如果你保留映射但将JavaScript移动到其他地方，你可能需要更改`mapRoot`。我提到这些配置的唯一原因是你可能已经有一个你想要迁移到TypeScript的JavaScript项目。根据你的现有配置，你可能需要调整这些配置。然而，对于任何标准项目，都不应该对这些配置进行修改。
- en: Files and include and exclude
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和包含与排除
- en: Included is an array that specifies the glob pattern that in turn specifies
    which files/folders are to be included in the compilation. The array `exclude`
    complements `include` and removes files to be compiled. When both properties are
    specified, `exclude` will filter out from the list included files from `include`.
    By default, `include` includes all TypeScript files under the `rootDir`, hence
    no need to add an entry to `**/*.ts`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 包含是一个数组，指定了glob模式，该模式指定了哪些文件/文件夹要包含在编译中。数组`exclude`补充了`include`，并移除了要编译的文件。当这两个属性都被指定时，`exclude`将从`include`中过滤掉包含的文件。默认情况下，`include`包括`rootDir`下的所有TypeScript文件，因此不需要添加`**/*.ts`的条目。
- en: Files are rarely used because it is less flexible than `include`. It allows
    specifying by path and name which file to compile, instead of using a glob pattern.
    The pattern approach is more flexible allowing you to configure once instead of
    having to continually modify the configuration file by adding and removing entries
    in Files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 文件很少使用，因为它不如`include`灵活。它允许通过路径和名称指定要编译的文件，而不是使用glob模式。模式方法更灵活，允许你一次性配置，而不是通过在文件中添加和删除条目来不断修改配置文件。
- en: 'Here is an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A final word on these three file configurations is that, contrary to most options,
    these ones don't reside under `compilerOptions` but are directly set at the root
    of the `tsconfig.json` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这三个文件配置的最后一句话是，与大多数选项相反，这些配置不是位于`compilerOptions`下，而是直接设置在`tsconfig.json`文件的根目录。
- en: Outfile
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出文件
- en: 'The outfile is an option that can be useful if you have a need to generate
    a single JavaScript file from many TypeScript files. When using the outfile, you
    can remove `outDir` and set a path relative to the root of your project, followed
    with the name and the extension of the generated file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件是一个有用的选项，如果你需要从多个TypeScript文件生成单个JavaScript文件。当使用输出文件时，你可以移除`outDir`并设置一个相对于项目根目录的路径，然后跟上生成文件的名称和扩展名：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The example code above creates a single file but also the `sourceMap` file because
    of the `sourceMap`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例代码创建了一个单个文件，但也创建了`sourceMap`文件，这是因为配置了`sourceMap`。
- en: Type
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: This section contains information about TypeScript's type. The first configuration
    gives TypeScript a hint as to where to look for types and also if TypeScript must
    generate the definition file or not when compiling.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含有关TypeScript类型的说明。第一个配置为TypeScript提供了查找类型的提示，同时也告诉TypeScript在编译时是否必须生成定义文件。
- en: typeRoots and types
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`typeRoots`和`types`'
- en: By default, every type provided inside a `node_modules` library, which includes
    all specific `@types/` and package with `.d.ts` directly inside the library's
    folder, are read by the TypeScript compiler. However, in some scenarios where
    there is no definition file available and you need to provide a custom one then
    you need to specify where the definition file is located. This can be done by
    using in which you can specify a folder where you define all your definition files.
    The caveat is that you will need to specify `node_modules` if you want TypeScript
    to keep look for definition files in `node_modules`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`node_modules`库中提供的每个类型，包括所有特定的`@types/`和直接在库文件夹内的`.d.ts`包，都会被TypeScript编译器读取。然而，在某些没有定义文件可用且你需要提供一个自定义文件的场景中，你需要指定定义文件的位置。这可以通过指定一个文件夹来完成，在该文件夹中你可以定义所有你的定义文件。需要注意的是，如果你想让TypeScript继续在`node_modules`中查找定义文件，你需要指定`node_modules`。
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Types configuration allows cherry-picking which file TypeScript will include.
    It works in collaboration with typeRoots and is an array. It whitelists the type
    name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Types 配置允许 TypeScript 选择包含哪些文件。它与 typeRoots 协同工作，是一个数组。它将类型名称列入白名单。
- en: Declaration and declarationdir
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和声明目录
- en: If you are building a library instead of a website or program, it might be wise
    to provide the definition file along with the generated JavaScript file. The reason
    is that when building a library in TypeScript, we never share the actual TypeScript
    (`.ts`) files but instead share the JavaScript files. The rationale is that TypeScript
    is just a superset of JavaScript and we want to expose our code to the largest
    audience available. By providing the JavaScript files we are allowing every JavaScript
    developer to consume our work. However, TypeScript coders are at rest. To fix
    this issue, we can provide a definition file (`.d.ts`) that contains all the signature
    functions as well as exported variables. The TypeScript compiler lets you generate
    the definition file automatically by using `declaration`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个库而不是网站或程序，那么提供定义文件与生成的 JavaScript 文件一起可能是明智的。原因是当在 TypeScript 中构建库时，我们从不共享实际的
    TypeScript（`.ts`）文件，而是共享 JavaScript 文件。其理由是 TypeScript 只是 JavaScript 的超集，我们希望将我们的代码暴露给尽可能广泛的受众。通过提供
    JavaScript 文件，我们允许每个 JavaScript 开发者消费我们的工作。然而，TypeScript 开发者可以休息。为了解决这个问题，我们可以提供一个包含所有签名函数以及导出变量的定义文件（`.d.ts`）。TypeScript
    编译器允许你通过使用 `declaration` 自动生成定义文件：
- en: 'The option is `boolean`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项是 `boolean`：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By default, the declaration files produced are by TypeScript file and located
    at the same place as the TypeScript file. It means that the end result is for
    each JavaScript (`.js`) you will see a brother declaration file (`.d.ts`) next
    to it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的声明文件是 TypeScript 文件，并且位于与 TypeScript 文件相同的目录。这意味着对于每个 JavaScript（`.js`）文件，你都会看到紧挨着它的兄弟声明文件（`.d.ts`）：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is a caveat with `declarationDir`, which is that it cannot be used with
    `outFile`. You will get a compilation-error mentioning that both options cannot
    be defined at the same time:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`declarationDir` 有一个需要注意的问题，那就是它不能与 `outFile` 一起使用。你将得到一个编译错误，指出这两个选项不能同时定义：'
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Configuration file
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: 'TypeScript has its own configuration file that is a convenient way to avoid
    passing every option by command-line arguments. The file resides at the root of
    your project. One possibility is to have several configuration files that can
    be used in different situations. This is possible by providing **tsc** with the
    option `-p` followed by the name of the configuration. The following three command-line
    invocations show one without any parameter, which is doing exactly the same compilation
    as the second line. Nonetheless, the third compilation instruction is different,
    pointing to a completely new set of options:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 有自己的配置文件，这是一种方便的方式，可以避免通过命令行参数传递每个选项。该文件位于项目的根目录。一种可能性是拥有几个配置文件，可以在不同情况下使用。这是通过向
    `tsc` 提供带有选项 `-p` 后跟配置文件名的选项来实现的。以下三个命令行调用显示了一个没有任何参数的例子，它实际上与第二行执行相同的编译。尽管如此，第三条编译指令是不同的，指向一组完全不同的选项：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One benefit of configuration files is the possibility of reusability by extending
    configuration. You can see this principle like object-oriented inheritance – one
    file can inherit from another one. This can be done by using the `extends` property
    as a key and the file to inherit from as a value. The file provided must be relative
    to the root of your project.It can or not have the extension (`.json`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件的一个好处是可以通过扩展配置来实现可重用性。你可以将这个原则比作面向对象中的继承——一个文件可以继承另一个文件。这可以通过使用 `extends`
    属性作为键，以及要继承的文件作为值来实现。提供的文件必须相对于项目的根目录。它可以有或没有扩展名（`.json`）：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following example shows a command that invokes a compilation with the option
    in `tsconfig.test.json` and has a small set of instructions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个命令，该命令使用 `tsconfig.test.json` 中的选项进行编译，并包含一组小指令：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first one is which file to extend. In that case, it could also have been
    `./tsconfig` without the extension. The file overrides `outDir` that is also provided
    in the `tsconfig.json` file and adds additional values. A good pattern is to have
    a `base` configuration, which has a configuration that you know will be shared
    across many of your configurations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是要扩展的文件。在这种情况下，也可以是 `./tsconfig` 而不带扩展名。该文件覆盖了 `tsconfig.json` 文件中提供的 `outDir`，并添加了额外的值。一个好的模式是有一个
    `base` 配置，其中包含你已知将在许多配置中共享的配置。
- en: Module and ModuleResolution
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和模块解析
- en: 'A key concept of code separation in JavaScript is a module. A module brings
    the notion of importing and exporting code. The capability increases the ability
    to share the code by specifying a specific name and which part of a code may be
    exported. Then, other software can import the code and leverage its functionalities.
    However, there is not a single way to craft a module. TypeScript lets you write
    your code in a single way and to produce, during compilation, an output that respects
    different popular module syntax. Here is a list of modules that TypeScript can
    interpret:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中代码分离的一个关键概念是模块。模块引入了导入和导出代码的概念。通过指定特定的名称和代码的哪一部分可以导出，这种能力增加了共享代码的能力。然后，其他软件可以导入代码并利用其功能。然而，并没有一种方法可以构建模块。TypeScript
    允许你以单一的方式编写代码，并在编译期间生成一个尊重不同流行模块语法的输出。以下是 TypeScript 可以解释的模块列表：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `module` option can be seen as how TypeScript produces the module and `moduleResolution`
    as how it reads a module. There are two ways that TypeScript can understand an
    `import` statement: class and node. The former is the traditional TypeScript way,
    which has different rules to find a file that is imported. The more popular choice
    is `node`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`module` 选项可以看作是 TypeScript 如何生成模块，而 `moduleResolution` 则是它如何读取模块。TypeScript
    可以理解 `import` 语句的两种方式：类和节点。前者是传统的 TypeScript 方法，它有不同的规则来查找导入的文件。更受欢迎的选择是 `node`。'
- en: 'Regardless of the module resolution option, you should try to use relative
    resolution by specifying in your import a path from the file you are importing.
    Relative import is denoted by having a path that starts with a single dot or a
    double dot to move backward. Here are few relative imports:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无论模块解析选项如何，你应该尝试通过在导入中指定从导入文件开始的路径来使用相对解析。相对导入通过路径以单个点或双点开头来表示，以向后移动。以下是一些相对导入的例子：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The reason for using this is the clarity of where the code is imported. Using
    the absolute resolution brings confusion because it relies on other configurations
    like `baseUrl` as well as `moduleResolution`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它的原因在于代码导入的清晰性。使用绝对解析会带来混淆，因为它依赖于其他配置，如 `baseUrl` 以及 `moduleResolution`。
- en: 'On the contrary, an import that relies on a more complex resolution is non-relative
    and looks like the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，依赖于更复杂解析的导入是非相对的，其形式如下：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Without going into all the complex rules, the last example in classic would
    look for the module next to the file that is importing it and go down the folder
    structure without trying to import the module from `node_modules`. However, if `moduleResolution`
    is set to `node` than the first check would be to look-up in the `node_modules`
    folder for a `module123`. As you see, if you are using a common name, you may
    load an unexpected module.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入复杂的规则，经典示例中的最后一个例子会寻找与导入文件相邻的模块，并沿着文件夹结构向下查找，而不会尝试从 `node_modules` 中导入模块。然而，如果
    `moduleResolution` 设置为 `node`，则第一个检查将是查找 `node_modules` 文件夹中的 `module123`。正如你所看到的，如果你使用一个常见的名称，你可能会加载一个意外的模块。
- en: ECMAScript
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript
- en: This section contains Typescript configurations related to the type of ECMAScript
    produced, as well as additional packages that can be incorporated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含与生成的 ECMAScript 类型相关的 TypeScript 配置，以及可以合并的附加包。
- en: Target
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标
- en: 'The target option must be specified but rarely changed. This option indicates
    to TypeScript which version of the JavaScript files to produce. By default, it
    produces an ECMAScript 3 version, which doesn’t have all the built-in features
    that TypeScript allows. However, TypeScript can still produce such old versions
    of ECMAScript by producing JavaScript code that mimics the features. This comes
    with a price of performance penalty at runtime, but it is a great way to build
    modern code with an older browser. Here is the actual target that you can specify:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指定目标选项，但很少更改。此选项指示 TypeScript 生成哪个版本的 JavaScript 文件。默认情况下，它生成 ECMAScript 3
    版本，该版本没有 TypeScript 允许的所有内置功能。然而，TypeScript 仍然可以通过生成模拟这些功能的 JavaScript 代码来生成这样的旧版本
    ECMAScript。这伴随着运行时性能惩罚的代价，但这是在较旧的浏览器上构建现代代码的绝佳方式。以下是你可以指定的实际目标：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you are deploying for the web in general, ES5 is a safe bet with 100% support
    for all browsers. But, ES6 is very close, and Chrome supports 98% of its features,
    Firefox 97%, and Edge 96%.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通常在网络上部署，ES5 是一个安全的选择，因为所有浏览器都对其提供 100% 的支持。但是，ES6 非常接近，Chrome 支持 98% 的其功能，Firefox
    97%，Edge 96%。
- en: Lib
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lib
- en: 'TypeScript can inject the core library of ECMAScript into the produced code.
    By default, some libraries are automatically added. For example, if you specify
    a target of ES5, TypeScript adds the library: DOM, ES5, and ScriptHost. You can
    manually add an additional library. For example, if you would like to use iterable
    you can add the string `ES2015.Iterable` in the lib array. You can use a feature
    that is beyond your main target as well. For example, you can have a target of
    ES2015 and uses an ES2018 feature. See "target" as a main set of features to be
    included in the compilation and `lib` as a subset of additional features that
    you can add to the compilation.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 可以将 ECMAScript 的核心库注入到生成的代码中。默认情况下，一些库会自动添加。例如，如果您指定目标为 ES5，TypeScript
    会添加库：DOM、ES5 和 ScriptHost。您可以手动添加额外的库。例如，如果您想使用可迭代对象，可以在 lib 数组中添加字符串 `ES2015.Iterable`。您还可以使用超出您主要目标的功能。例如，您可以将目标设置为
    ES2015 并使用 ES2018 的功能。将 "target" 视为编译中要包含的主要功能集，将 `lib` 视为可以添加到编译中的附加功能的子集。
- en: Compiler strictness
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器严格性
- en: TypeScript has many option around how strict the compiler must analyze your
    code. This section shows you the difference between each setting, allowing you
    to start slowly and progressively if you are coming from an existing JavaScript.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 在如何严格分析您的代码方面有许多选项。本节向您展示了每个设置的差异，如果您来自现有的 JavaScript，允许您逐步开始。
- en: Strict
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格
- en: This is the option that turns every configuration to strict. This is what you
    should use if you start a new TypeScript project coming from JavaScript.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将每个配置转换为严格的选项。如果您从 JavaScript 开始一个新的 TypeScript 项目，这是您应该使用的。
- en: StrictFunctionTypes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StrictFunctionTypes
- en: 'This is an advanced check that does not allow bivariance for arguments of a
    function. It uses contravariance. What it means is that if a function is expecting
    a type A as a parameter, you cannot set a function that has a type B that inherits
    a type A – you must only pass a type A. The following won''t compile with `StrictFunctionTypes`
    with a `true` value. The strict option is useful to avoid a passing object that
    has more members than the expected type. The following example has `B` as the
    `firstName` field and inherits `A`, hence the name:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高级检查，不允许函数参数的二向变异性。它使用逆变异性。这意味着如果函数期望类型 A 作为参数，您不能设置一个具有类型 B 的函数，该类型继承自类型
    A - 您必须只传递类型 A。以下在 `StrictFunctionTypes` 设置为 `true` 的情况下无法编译。严格的选项有助于避免传递比预期类型有更多成员的对象。以下示例中
    `B` 是 `firstName` 字段，并继承自 `A`，因此得名：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'During compilation, TypeScript finds that the argument is passed to an object
    with more members and won''t compile:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，TypeScript 发现参数被传递给具有更多成员的对象，因此无法编译：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: StrictPropertyInitialization and StricNullChecks
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StrictPropertyInitialization 和 StricNullChecks
- en: '`StrictPropertyInitialization` property should always be set to true. It ensures
    that all properties of a class are initialized with a direct association at the
    declaration level or in the constructor of the class.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`StrictPropertyInitialization` 属性应始终设置为 true。这确保了类的所有属性都在声明级别或类的构造函数中与直接关联初始化。'
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The example does not compile because `Field1` is a number that is not defined.
    The value of the field is undefined. There are many solutions to keep the strictness
    and make the code compliant. The first solution is to set a value at the initialization:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例无法编译，因为 `Field1` 是一个未定义的数字。该字段的值是未定义的。有许多解决方案可以保持严格性并使代码符合规范。第一个解决方案是在初始化时设置值：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Setting a default value at initialization is not always possible. In some cases,
    it''s possible to specify the value at construction type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时设置默认值并不总是可能的。在某些情况下，可以在构造类型中指定值：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A third way to compile the code is to use the bang operator (`!`) after the
    member's name. The operator indicates to TypeScript that the value will be provided
    later. The scenario in which a late initialization occurs is often by some injection
    framework or by using a function to initialize the class.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码的第三种方法是使用成员名称之后的感叹号运算符（`!`）。该运算符指示 TypeScript 该值将在以后提供。延迟初始化的场景通常是通过某些注入框架或使用函数来初始化类。
- en: One caveat to having `strictPropertyInitialization` do this job is a dependency
    on another strict property that must be enabled – the `strictNullChecks`. The
    null check should also always be set to true at all times. Without this, a field
    identified as a type will automatically accept null and undefined as a valid type.
    It is less confusing and more declarative to only support a field with an explicit
    type and in the case of null or/and undefined to use the property definition that
    we will see later in this book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `strictPropertyInitialization` 执行此任务的注意事项之一是依赖于另一个必须启用的严格属性——`strictNullChecks`。空值检查也应该始终设置为
    true。如果没有这个设置，被识别为类型的字段将自动接受 null 和 undefined 作为有效的类型。仅支持具有显式类型的字段，并在 null 或/和
    undefined 的情况下使用本书后面将看到的属性定义，这样更不容易混淆，也更具有声明性。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we put in place different configurations allowing you to start
    coding with TypeScript in a straightforward way. After setting up your working
    environment to your liking, we briefly mentioned the most important compiler options
    to get you started on the right path. TypeScript is a flexible compiler, and you
    should be rapidly up-to-speed developing because of how the settings can be selected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设置了不同的配置，使您能够以直接的方式开始使用 TypeScript 进行编码。在设置您喜欢的开发环境后，我们简要介绍了最重要的编译器选项，以帮助您走上正确的道路。TypeScript
    是一个灵活的编译器，由于设置的选择方式，您应该能够快速掌握开发技能。
- en: In the next chapter, we will look at programming with TypeScript by introducing
    how ECMAScript primitive type can be strongly typed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍如何将 ECMAScript 原始类型强类型化来探讨使用 TypeScript 进行编程。
