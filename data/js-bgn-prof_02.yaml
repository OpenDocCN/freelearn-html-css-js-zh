- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: JavaScript Essentials
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 基础
- en: 'In this chapter, we will be dealing with some essential building blocks of
    JavaScript: variables and operators. We will start with variables, what they are,
    and which different variable data types exist. We need these basic building blocks
    to store and work with variable values in our scripts, making them dynamic.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理 JavaScript 的一些基本构建块：变量和操作符。我们将从变量开始，了解它们是什么，以及存在哪些不同的变量数据类型。我们需要这些基本构建块来存储和处理脚本中的变量值，使它们变得动态。
- en: Once we've got the variables covered, we will be ready to deal with operators.
    Arithmetic, assignment, and conditional and logical operators will be discussed
    at this stage. We need operators to modify our variables or to tell us something
    about these variables. This way we can do basic calculations based on factors
    such as user input.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了变量，我们就可以处理操作符了。在这个阶段，我们将讨论算术、赋值、条件逻辑操作符。我们需要操作符来修改我们的变量或告诉我们关于这些变量的信息。这样我们就可以根据用户输入等因素进行基本计算。
- en: 'Along the way, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将涵盖以下主题：
- en: Variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Primitive data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: Analyzing and modifying data types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析和修改数据类型
- en: Operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符
- en: 'Note: exercise, project, and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: Variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Variables are the first building block you will be introduced to when learning
    most languages. Variables are values in your code that can represent different
    values each time the code runs. Here is an example of two variables in a script:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是学习大多数语言时你将首先接触到的构建块。变量是代码中的值，每次代码运行时可以代表不同的值。以下是一个脚本中两个变量的示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And they can be assigned a new value while the code is running:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 并且它们可以在代码运行时分配新值：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Without variables, a piece of code would do the exact same thing every single
    time it was run. Even though that could still be helpful in some cases, it can
    be made much more powerful by working with variables to allow our code to do something
    different every time we run it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没有变量，一段代码在每次运行时都会做完全相同的事情。尽管在某些情况下这仍然可能是有帮助的，但通过使用变量可以使代码更强大，允许我们的代码在每次运行时做不同的事情。
- en: Declaring variables
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'The first time you create a variable, you declare it. And you need a special
    word for that: `let`, `var`, or `const`. We''ll discuss the use of these three
    arguments shortly. The second time you call a variable, you only use the name
    of the existing variable to assign it a new value:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次创建变量时，你需要声明它。为此，你需要一个特殊的词：`let`、`var` 或 `const`。我们很快就会讨论这三个参数的使用。第二次调用变量时，你只需使用现有变量的名称来为其分配新值：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our examples, we will be assigning a value to our variables in the code.
    This is called "hardcoded" since the value of your variable is defined in your
    script instead of coming dynamically from some external input. This is something
    you won't be doing that often in actual code, as more commonly the value comes
    from an external source, such as an input box on a website that a user filled
    out, a database, or some other code that calls your code. The use of variables
    coming from external sources instead of being hardcoded into a script is actually
    the reason that scripts are adaptable to new information, without having to rewrite
    the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将在代码中将值分配给我们的变量。这被称为“硬编码”，因为你的变量值是在你的脚本中定义的，而不是从某些外部输入动态获取。在实际代码中，你不会经常这样做，因为更常见的情况是值来自外部源，例如用户在网站上填写过的输入框、数据库或调用你的代码的其他代码。从外部源获取变量而不是将它们硬编码到脚本中，实际上是脚本能够适应新信息而不必重写代码的原因。
- en: We have just established how powerful the variable building block is in code.
    Right now, we are going to hardcode variables into our scripts, and they therefore
    will not vary until a coder changes the program. However, we will soon learn how
    to make our variables take in values from outside sources.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚确立了变量构建块在代码中的强大功能。现在，我们将硬编码变量到我们的脚本中，因此它们将不会变化，直到程序员更改程序。然而，我们很快就会学习如何使我们的变量接受来自外部源的价值。
- en: let, var, and const
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: let, var 和 const
- en: 'A variable definition consists of three parts: a variable-defining keyword
    (`let`, `var`, or `const`), a name, and a value. Let''s start with the difference
    between `let`, `var`, or `const`. Here you can see some examples of variables
    using the different keywords:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 变量定义由三部分组成：变量定义关键字（`let`、`var` 或 `const`）、名称和值。让我们从 `let`、`var` 或 `const` 之间的区别开始。这里你可以看到使用不同关键字的一些变量示例：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`let` and `var` are both used for variables that might have a new value assigned
    to them somewhere in the program. The difference between `let` and `var` is complex.
    It is related to scope.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 和 `var` 都用于可能在程序中的某个地方被赋予新值的变量。`let` 和 `var` 之间的区别很复杂，它与作用域有关。'
- en: If you understand the following sentences on scope, that is great, but it is
    totally fine if you do not get it. You will understand it soon enough as you keep
    working your way through the book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解以下关于作用域的句子，那很好，但如果你现在不理解，也完全没关系。随着你继续阅读本书，你很快就会理解它。
- en: '`var` has **global scope** and `let` has **block scope**. `var`''s global scope
    means that you can use the variables defined with `var` in the entire script.
    On the other hand, `let`''s block scope means you can only use variables defined
    with `let` in the specific block of code in which they were defined. Remember,
    a block of code will always start with `{` and end with `}`, which is how you
    can recognize them.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 有 **全局作用域**，而 `let` 有 **块级作用域**。`var` 的全局作用域意味着你可以在整个脚本中使用用 `var` 定义的变量。另一方面，`let`
    的块级作用域意味着你只能在定义它们的特定代码块中使用用 `let` 定义的变量。记住，代码块总是以 `{` 开始，以 `}` 结束，这就是你识别它们的方式。'
- en: 'On the other hand, `const` is used for variables that only get a value assigned
    once—for example, the value of pi, which will not change. If you try reassigning
    a value declared with `const`, you will get an error:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`const` 用于只被赋予一次值的变量——例如，π 的值，它不会改变。如果你尝试重新分配用 `const` 声明的值的值，你会得到一个错误：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will result in the following output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will be using `let` in most of our examples—for now, trust us that you should
    use `let` in most cases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在大多数示例中使用 `let` —— 目前，请相信我们，在大多数情况下你应该使用 `let`。
- en: Naming variables
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量命名
- en: 'When it comes to naming variables, there are some conventions in place:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到变量命名时，有一些约定：
- en: Variables start with a lowercase letter, and they should be descriptive. If
    something holds an age, do not call it `x`, but `age`. This way, when you read
    your script later, you can easily understand what you did by just reading your
    code.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量以小写字母开头，并且应该是描述性的。如果某个东西包含年龄，不要称其为 `x`，而应该称其为 `age`。这样，当你以后阅读你的脚本时，只需阅读你的代码就可以轻松理解你所做的一切。
- en: Variables cannot contain spaces, but they can use underscores. If you use a
    space, JavaScript doesn't recognize it as a single variable.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量不能包含空格，但可以使用下划线。如果你使用空格，JavaScript 不会将其识别为单个变量。
- en: 'We will be using camel case here. This means that when we want to use multiple
    words to describe a variable, we will start with a lowercase word, then use a
    capital for every new word after the first word—for example: `ageOfBuyer`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用驼峰式命名法。这意味着当我们想要用多个单词来描述一个变量时，我们将以小写字母开头，然后在第一个单词之后的每个新单词首字母大写——例如：`ageOfBuyer`。
- en: Whatever the convention is in the place you are working, the key is consistency.
    If all naming is done in a similar format, the code will look cleaner and more
    readable, which makes it a lot easier to make a small change later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你所在的地方有什么惯例，关键是保持一致性。如果所有的命名都以类似格式完成，代码将看起来更干净、更易读，这使得稍后进行小修改变得容易得多。
- en: 'The value of your variable can be anything. Let''s start with the easiest thing
    variables can be: primitives.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你的变量的值可以是任何东西。让我们从变量可以是最简单的事情开始：原始数据类型。
- en: Primitive data types
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: Now you know what variables are and why we need them in our code, it is time
    to look at the different types of values we can store in variables. Variables
    get a value assigned. And these values can be of different types. JavaScript is
    a loosely typed language. This means that JavaScript determines the type based
    on the value. The type does not need to be named explicitly. For example, if you
    declared a value of 5, JavaScript will automatically define it as a number type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了什么是变量以及为什么我们需要在代码中使用它们，现在是时候看看我们可以存储在变量中的不同类型的值了。变量会分配一个值。而且这些值可以是不同类型的。JavaScript
    是一种弱类型语言。这意味着 JavaScript 会根据值来确定类型。类型不需要显式命名。例如，如果你声明了一个值为 5，JavaScript 会自动将其定义为数字类型。
- en: 'A distinction exists between primitive data types and other, more complex data
    types. In this chapter, we will cover the primitive type, which is a relatively
    simple data structure. Let''s say for now that they just contain a value and have
    a type. JavaScript has seven primitives: String, Number, BigInt, Boolean, Symbol,
    undefined, and null. We''ll discuss each of them in more detail below.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型和其他更复杂的数据类型之间存在区别。在本章中，我们将介绍原始类型，它是一种相对简单的数据结构。现在让我们假设它们只包含一个值并且有一个类型。JavaScript
    有七个原始类型：String、Number、BigInt、Boolean、Symbol、undefined 和 null。我们将在下面更详细地讨论每个类型。
- en: String
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A string is used to store a text value. It is a sequence of characters. There
    are different ways to declare a string:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串用于存储文本值。它是一系列字符。声明字符串有不同的方式：
- en: Double quotes
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双引号
- en: Single quotes
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单引号
- en: 'Backticks: special template strings in which you can use variables directly'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反引号：可以直接使用变量的特殊模板字符串
- en: 'The single and double quotes can both be used like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号和双引号都可以这样使用：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can use the option you prefer, unless you are working on code in which one
    of these options has already been chosen. Again, consistency is key.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您喜欢的选项，除非您正在处理已经选择了这些选项之一的代码。再次强调，一致性是关键。
- en: 'The main difference between single quotes and double quotes is that you can
    use single quotes as literal characters in double-quoted strings, and vice versa.
    If you declare a string with single quotes, the string will end as soon as a second
    quote is detected, even if it''s in the middle of a word. So for example, the
    following will result in an error, because the string will be ended at the second
    single quote within `let''s`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号和双引号之间的主要区别是，您可以在双引号字符串中使用单引号作为字面字符，反之亦然。如果您用单引号声明字符串，那么字符串将在检测到第二个引号时结束，即使它位于单词的中间。所以例如，以下将导致错误，因为字符串将在
    `let's` 中的第二个单引号处结束：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Let` will be recognized as a string, but after that, the bunch of characters
    that follow cannot be interpreted by JavaScript. However, if you declare the string
    using double quotes, it will not end the string as soon as it hits the single
    quote, because it is looking for another double quote. Therefore, this alternative
    will work fine:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Let` 将被识别为字符串，但在此之后，跟随的一串字符无法被 JavaScript 解释。然而，如果您使用双引号声明字符串，它不会在遇到单引号时立即结束字符串，因为它正在寻找另一个双引号。因此，这个替代方案可以正常工作：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the same way with double quotes, the following would not work:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，使用双引号，以下将不会工作：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, the compiler will not distinguish between double quotes used in different
    contexts, and will output an error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，编译器不会区分不同上下文中使用的双引号，并将输出错误。
- en: 'In a string using backticks, you can point to variables and the variable''s
    value will be substituted into the line. You can see this in the following code
    snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用反引号的字符串中，您可以指向变量，变量的值将被替换到行中。您可以在以下代码片段中看到这一点：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, you will have to specify these variables with a rather funky
    syntax—don''t be intimidated! Variables in these template strings are specified
    between `${nameOfVariable}`. The reason that it''s such an intense syntax is that
    they want to avoid it being something you would normally use, which would make
    it unnecessarily difficult to do so. In our case, the console output would be
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您将不得不使用相当古怪的语法来指定这些变量——不要感到害怕！在这些模板字符串中，变量是在 `${nameOfVariable}` 之间指定的。之所以语法如此复杂，是因为它们希望避免将其用作您通常会用到的，这会使得这样做变得不必要地困难。在我们的例子中，控制台输出将如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the `language` variable gets replaced with its value: `JavaScript`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`language` 变量会被其值替换：`JavaScript`。
- en: Escape characters
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义字符
- en: Say we want to have double quotes, single quotes, and backticks in our string.
    We would have a problem, as this cannot be done with just the ingredients we have
    now. There is an elegant solution to this problem. There is a special character
    that can be used to tell JavaScript, "do not take the next character as you normally
    would." This is the escape character, a backslash.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在字符串中包含双引号、单引号和反引号。我们会遇到问题，因为我们现在没有足够的工具来解决这个问题。有一个优雅的解决方案。有一个特殊字符可以用来告诉
    JavaScript，“不要像平常那样处理下一个字符。”这就是转义字符，一个反斜杠。
- en: 'In this example, the backslash can be used to ensure your interpreter doesn''t
    see the single or double quote marks and end either string too early:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，反斜杠可以用来确保您的解释器不会看到单引号或双引号标记，并且不会过早地结束字符串：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This logs the following to the console:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在控制台输出以下内容：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, both types of quote marks inside the strings have been logged
    without throwing an error. This is because the backslash before the quote character
    gives the quote character a different meaning. In this case, the meaning is that
    it should be a literal character instead of an indicator to end the string.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，字符串中的两种引号类型都已记录下来而没有引发错误。这是因为引号字符前面的反斜杠给引号字符赋予了不同的意义。在这种情况下，意义是它应该是一个字面字符，而不是表示字符串结束的指示符。
- en: 'The escape character has even more purposes. You can use it to create a line
    break with `\n`, or to include a backslash character in the text with `\\`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 转义字符有更多用途。你可以用它来创建换行符`\n`，或者用`\\`在文本中包含反斜杠字符：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of these lines is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行的输出如下：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are some more options, but we will leave them for now. Let's get back
    to primitive data types by looking at the number type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多选项，但现在我们先放一放。让我们通过查看数字类型来回到原始数据类型。
- en: Number
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Number
- en: 'The number data type is used to represent, well, numbers. In many languages,
    there is a very clear difference between different types of numbers. The developers
    of JavaScript decided to go for one data type for all these numbers: number. To
    be more precise, they decided to go for a 64-bit floating-point number. This means
    that it can store rather large numbers and both signed and unsigned numbers, numbers
    with decimals, and more.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 数字数据类型用于表示，嗯，数字。在许多编程语言中，不同类型的数字之间有一个非常明显的区别。JavaScript的开发者决定为所有这些数字使用一个数据类型：number。更准确地说，他们决定使用64位浮点数。这意味着它可以存储相当大的数字，包括有符号和无符号的数字，小数数字等等。
- en: 'However, there are different kinds of numbers it can represent. First of all,
    integers, for example: 4 or 89\. But the number data type can also be used to
    represent decimals, exponentials, octal, hexadecimal, and binary numbers. The
    following code sample should speak for itself:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它可以表示不同种类的数字。首先，整数，例如：4或89。但数字数据类型也可以用来表示小数、指数、八进制、十六进制和二进制数字。以下代码示例应该可以说明一切：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You don''t need to worry about these last three if you''re not familiar with
    them. These are just different ways to represent numbers that you may encounter
    in the broader field of computer science. The takeaway here is that all the above
    numbers are of the number data type. So integers are numbers, like these ones:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些不熟悉，你不需要担心。这些只是你在计算机科学更广泛的领域中可能会遇到的不同表示数字的方式。这里的要点是上述所有数字都是数字数据类型。所以整数是数字，就像这些：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And the floating points are numbers as well, like this one:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数也是数字，就像这个：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And binary numbers are of the number data type as well, for example, this one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数字也是数字数据类型的一部分，例如，这个：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have just seen the number data type, which is very commonly used. But in
    some special cases, you will need an even bigger number.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了非常常用的数字数据类型。但在某些特殊情况下，你需要一个更大的数字。
- en: BigInt
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BigInt
- en: 'The limits of the number data type are between 2^(53)-1 and -(2^(53)-1). In
    case you were to need a bigger (or smaller) number, BigInt comes into play. A
    BigInt data type can be recognized by the postfix `n`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数字数据类型的限制在2^(53)-1和-(2^(53)-1)之间。如果你需要更大的（或更小的）数字，BigInt就派上用场了。BigInt数据类型可以通过后缀`n`来识别：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s see what happens when we start to do some calculations between our previously
    made integer Number, `intNr`, and BigInt, `bigNr`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们开始在我们之前创建的整数Number，`intNr`，和BigInt，`bigNr`之间进行一些计算时会发生什么：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output will be as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Uh-oh, a `TypeError`! It is very clear about what is going wrong. We cannot
    mix BigInt with the Number data type to perform operations. This is something
    to keep in mind for later when actually working with BigInt—you can only operate
    on BigInt with other BigInts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，一个`TypeError`！它非常清楚地说明了出了什么问题。我们不能将BigInt与Number数据类型混合进行操作。这是在以后实际使用BigInt时需要注意的事情——你只能用其他BigInt进行操作。
- en: Boolean
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The Boolean data type can hold two values: `true` and `false`. There is nothing
    in between. This Boolean is used a lot in code, especially expressions that evaluate
    to a Boolean:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型可以存储两个值：`true`和`false`。中间没有其他值。这种布尔值在代码中用得很多，尤其是在评估为布尔值的表达式：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, you can see the options we have for the Boolean data
    type. It is used for situations in which you want to store a `true` or a `false`
    value (which can indicate on/off or yes/no). For example, whether an element is
    deleted:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可以看到布尔数据类型所提供的选项。它用于需要存储`true`或`false`值（可以表示开/关或是/否）的情况。例如，一个元素是否被删除：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or, whether the light is on or off:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，灯光是开启还是关闭：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These variables suggest respectively that the specified object is not deleted,
    and that the specific light is on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量分别表明指定的对象没有被删除，以及特定的灯光是开启的。
- en: Symbol
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: 'Symbol is a brand new data type introduced in ES6 (we mentioned ECMA Script
    6, or ES6, in *Chapter 1*, *Getting Started with JavaScript*). Symbol can be used
    when it is important that variables are not equal, even though their value and
    type are the same (in this case, they would both be of the symbol type). Compare
    the following string declarations to the symbol declarations, all of equal value:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Symbol是ES6（我们在*第一章*，*JavaScript入门*中提到的ECMA Script 6，或ES6）中引入的一种全新的数据类型。当变量即使值和类型相同，也需要确保它们不相等时，可以使用Symbol。比较以下字符串声明与符号声明，它们的值都是相同的：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And the output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以及输出：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the first half, JavaScript concludes that the strings are the same. They
    have the same value, and the same type. However, in the second part, each symbol
    is unique. Therefore, although they contain the same string, they are not the
    same, and output `false` when compared. These symbol data types can be very handy
    as properties of objects, which we will see in *Chapter 3*, *JavaScript Multiple
    Values*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前半部分，JavaScript认为字符串是相同的。它们具有相同的值和类型。然而，在第二部分，每个符号都是唯一的。因此，尽管它们包含相同的字符串，但它们并不相同，并且在比较时输出`false`。这些符号数据类型可以作为对象的属性非常有用，我们将在*第三章*，*JavaScript多重值*中看到。
- en: Undefined
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未定义
- en: 'JavaScript is a very special language. It has a special data type for a variable
    that has not been assigned a value. And this data type is undefined:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种非常特殊的语言。它为未赋值的变量提供了一个特殊的数据类型。这个数据类型是未定义的：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output here will be:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的输出将是：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can also purposefully assign an `undefined` value. It is important you know
    that it is possible, but it is even more important that you know that manually
    assigning undefined is a bad practice:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以故意赋一个`undefined`值。重要的是要知道这是可能的，但更重要的是要知道手动赋值undefined是一种不良做法：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Alright, this can be done, but it is recommended to not do this. This is for
    a number of reasons—for example, checking whether two variables are the same.
    If one variable is undefined, and your own variable is manually set to undefined,
    they will be considered equal. This is an issue because if you are checking for
    equality, you would want to know whether two values are actually equal, not just
    that they are both undefined. This way, someone's pet and their last name might
    be considered equal, whereas they are actually both just empty values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是可以做到的，但建议不要这样做。这有多个原因——例如，检查两个变量是否相同。如果一个变量是未定义的，而你的变量被手动设置为未定义，它们将被视为相等。这是一个问题，因为如果你正在检查相等性，你想要知道两个值是否实际上相等，而不仅仅是它们都是未定义的。这样，某人的宠物和他们的姓氏可能会被认为是相同的，而实际上它们只是两个空值。
- en: 'null'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'null'
- en: 'In the last example, we saw an issue that can be solved with a final primitive
    type, null. null is a special value for saying that a variable is empty or has
    an unknown value. This is case sensitive. You should use lowercase for null:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，我们看到了一个可以用基本类型null解决的问题。null是一个表示变量为空或具有未知值的特殊值。这是大小写敏感的。你应该使用小写null：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To solve the issue we encountered with setting a variable as undefined, note
    that if you set it to null, you will not have the same problem. This is one of
    the reasons it is better to assign null to a variable when you want to say it
    is empty and unknown at first:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们遇到的将变量设置为未定义的问题，请注意，如果你将其设置为null，你将不会遇到相同的问题。这就是为什么当你想要表示变量最初是空和未知时，将null赋给变量更好的原因之一：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This outputs the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This shows that an automatically undefined variable, `lastName`, and a deliberately
    undefined variable, `terribleThingToDo`, are considered equal, which is problematic.
    On the other hand, `lastName` and `betterOption`, which was explicitly declared
    with a value of null, are not equal.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明一个自动未定义的变量`lastName`和一个故意未定义的变量`terribleThingToDo`被认为是相等的，这是有问题的。另一方面，`lastName`和显式声明为null值的`betterOption`不相等。
- en: Analyzing and modifying data types
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析和修改数据类型
- en: We have seen the primitive data types. There are some built-in JavaScript methods
    that will help us deal with common problems related to primitives. Built-in methods
    are pieces of logic that can be used without having to write JavaScript logic
    yourself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了原始数据类型。有一些内置的 JavaScript 方法可以帮助我们处理与原始数据类型相关的常见问题。内置方法是一些逻辑片段，可以在不自己编写
    JavaScript 逻辑的情况下使用。
- en: 'We''ve seen one built-in method already: `console.log()`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个内置方法：`console.log()`。
- en: There are many of these built-in methods, and the ones you will be meeting in
    this chapter are just the first few you will encounter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多这样的内置方法，而您在本章中将要遇到的方法只是您将要遇到的前几个。
- en: Working out the type of a variable
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定变量的类型
- en: 'Especially with null and undefined, it can be hard to determine what kind of
    data type you are dealing with. Let''s have a look at `typeof`. This returns the
    type of the variable. You can check the type of a variable by entering `typeof`,
    then either a space followed by the variable in question, or the variable in question
    in brackets:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是对于 null 和 undefined，确定你正在处理的数据类型可能很困难。让我们看看 `typeof`。这个函数返回变量的类型。你可以通过输入
    `typeof`，然后是空格后跟相关的变量，或者将变量放在括号中来检查变量的类型：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you might assume, both methods will output `number`. Brackets aren''t required
    because technically, `typeof` is an operator, not a method, unlike `console.log`.
    But, sometimes you may find that using brackets makes your code easier to read.
    Here you can see it in action:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，这两种方法都会输出 `number`。不需要括号，因为技术上 `typeof` 是一个运算符，而不是一个方法，与 `console.log`
    不同。但有时您可能会发现使用括号可以使您的代码更容易阅读。在这里您可以看到它的实际应用：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, in the same `console.log()` print command, we are printing the name of
    each variable (as a string, declared with double quotes), then its type (using
    `typeof`). This will produce the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在同一个 `console.log()` 打印命令中，我们正在打印每个变量的名称（作为字符串，用双引号声明），然后是其类型（使用 `typeof`）。这将产生以下输出：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is an odd one out, and that is the null type. In the output you can see
    that `typeof null` returns `object`, while in fact, null truly is a primitive
    and not an object. This is a bug that has been there since forever and now cannot
    be removed due to backward compatibility problems. Don't worry about this bug,
    as it won't affect our programs—just be aware of it, since it will go nowhere
    anytime soon, and it has the potential to break applications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中有一个例外，那就是 null 类型。在输出中，您可以看到 `typeof null` 返回 `object`，而实际上，null 真的是一个原始类型，而不是一个对象。这是一个从很久以前就存在的错误，现在由于向后兼容性问题无法移除。不用担心这个错误，因为它不会影响我们的程序——只需意识到它，因为它不会很快消失，并且有可能破坏应用程序。
- en: Converting data types
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换数据类型
- en: The variables in JavaScript can change types. Sometimes JavaScript does this
    automatically. What do you think the result of running the following code snippet
    will be?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的变量可以改变类型。有时 JavaScript 会自动这样做。你认为运行以下代码片段的结果会是什么？
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We try to multiply a variable of type Number with a variable of type String.
    JavaScript does not just throw an error (as many languages would), but first tries
    to convert the string value to a number. If that can be done, it can execute without
    any problem as if two numbers were declared. In this case, `console.log()` will
    write `4` to the console.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试将一个 Number 类型的变量与一个 String 类型的变量相乘。JavaScript 不会像许多语言那样直接抛出错误，而是首先尝试将字符串值转换为数字。如果可以这样做，它就可以无任何问题地执行，就像声明了两个数字一样。在这种情况下，`console.log()`
    将 `4` 写入控制台。
- en: 'But this is dangerous! Guess what this code snippet does:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是危险的！猜猜这个代码片段做了什么：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This one will log `22`. The plus sign can be used to concatenate strings. Therefore,
    instead of converting a string to a number, it is converting a number to a string
    in this example, and clubbing the two strings together—"`2`" and "`2`" make "`22`".
    Luckily, we do not need to rely on JavaScript's behavior when converting data
    types. There are built-in functions we can use to convert the data type of our
    variable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个会输出 `22`。加号可以用来连接字符串。因此，在这个例子中，不是将字符串转换为数字，而是将数字转换为字符串，然后将两个字符串合并在一起——“`2`”和“`2`”合并成“`22`”。幸运的是，我们不需要依赖于
    JavaScript 在转换数据类型时的行为。我们可以使用一些内置函数来转换我们变量的数据类型。
- en: 'There are three conversion methods: `String()`, `Number()`, and `Boolean()`.
    The first one converts a variable to type String. It pretty much takes any value,
    including undefined and null, and puts quotes around it.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种转换方法：`String()`、`Number()`和`Boolean()`。第一个方法将变量转换为String类型。它几乎可以接受任何值，包括undefined和null，并在其周围加上引号。
- en: 'The second one tries to convert a variable to a number. If that cannot be done
    logically, it will change the value into NaN (not a number). `Boolean()` converts
    a variable to a Boolean. This will be true for everything except for null, undefined,
    0 (number), an empty string, and NaN. Let''s see them in action:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个尝试将一个变量转换为数字。如果无法逻辑上完成转换，它将值更改为NaN（不是一个数字）。`Boolean()`函数将变量转换为布尔值。除了null、undefined、0（数字）、空字符串和NaN之外的所有内容都将返回true。让我们看看它们在实际操作中的表现：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will log the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录以下内容：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This might seem pretty straightforward, but not all of the options are equally
    obvious. These, for example, are not what you might think:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很简单，但并非所有选项都同样明显。例如，这些可能不是您所想的：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code snippet will log the following to the console:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将在控制台记录以下内容：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, an empty string and null will both result in the number 0\.
    This is a choice that the makers of JavaScript made, which you will have to know—it
    can come in handy at times when you want to convert a string to 0 when it is empty
    or null.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，空字符串和null都会导致数字0。这是JavaScript制作者做出的一个选择，您必须知道——在您想要将空字符串或null转换为0时，这有时会很有用。
- en: 'Next, enter the following snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入以下代码片段：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result that will be logged to the console is:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将被记录到控制台的结果是：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we can see that anything that can't be interpreted as a number by simply
    removing the quotes will evaluate as `NaN` (not a number).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到任何不能通过简单地去除引号来解释为数字的东西都会评估为`NaN`（不是一个数字）。
- en: 'Let''s continue with the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以下代码：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, this one will log the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个会记录以下内容：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This output shows that any string will return `true` when converted to a Boolean,
    even the string `"false"`! Only an empty string, null, and undefined will lead
    to a Boolean value of `false`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示，任何转换为布尔值时都会返回true的字符串，即使是字符串`"false"`！只有空字符串、null和undefined才会导致布尔值为false。
- en: Let's tease your brain a little bit more. What do you think this one will log?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再稍微刺激一下你的大脑。你认为这个会记录什么？
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This one logs `4`! The string gets converted to a number before it executes
    the plus operation, and therefore it is a mathematical operation and not a string
    concatenation. In the next sections of this chapter, we will discuss operators
    in more depth.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这一个会记录`4`！在执行加法操作之前，字符串被转换为数字，因此它是一个数学运算，而不是字符串连接。在本章的下一节中，我们将更深入地讨论运算符。
- en: Practice exercise 2.1
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.1
- en: 'What are the types of these variables listed below? Verify this with `typeof`
    and output the result to the console:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出的变量类型是什么？使用`typeof`进行验证，并将结果输出到控制台：
- en: '[PRE48]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Operators
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'After seeing quite a few data types and some ways to convert them, it is time
    for the next major building block: operators. These come in handy whenever we
    want to work with the variables, modify them, perform calculations on them, and
    compare them. They are called operators because we use them to operate on our
    variables.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到许多数据类型和一些转换方法之后，现在是时候介绍下一个主要构建块：运算符。当我们想要与变量一起工作、修改它们、对它们进行计算或比较它们时，这些运算符就派上用场了。它们被称为运算符，因为我们使用它们来对变量进行操作。
- en: Arithmetic operators
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Arithmetic operators can be used to perform operations with numbers. Most of
    these operations will feel very natural to you because they are the basic mathematics
    you will have come across earlier in life already.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符可以用来对数字执行操作。大多数这些操作对您来说都非常自然，因为它们是您在早年生活中已经接触过的基础数学。
- en: Addition
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加法
- en: 'Addition in JavaScript is very simple, we have seen it already. We use `+`
    for this operation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的加法非常简单，我们之前已经见过。我们使用`+`进行这个操作：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'However, this operator can also come in very handy for concatenating strings.
    Note the added space after `"Hello"` to ensure the end result contains space characters:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个运算符也可以在连接字符串时非常有用。注意在`"Hello"`之后添加的空格，以确保最终结果包含空格字符：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output of printing `result1` and `result2` will be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`result1`和`result2`的输出将如下所示：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, adding numbers and strings lead to different results. If we
    add two different strings, it will concatenate them into a single string.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，添加数字和字符串会导致不同的结果。如果我们添加两个不同的字符串，它们将被连接成一个单一的字符串。
- en: Practice exercise 2.2
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.2
- en: Create a variable for your name, another one for your age, and another one for
    whether you can code JavaScript or not.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的名字创建一个变量，另一个用于你的年龄，还有一个用于你是否能编写JavaScript。
- en: 'Log to the console the following sentence, where `name`, `age` and `true`/`false`
    are variables:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台输出以下句子，其中`name`、`age`和`true`/`false`是变量：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Subtraction
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减法
- en: Subtraction works as we would expect it as well. We use `-` for this operation.
    What do you think gets stored in the variable in this second example?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 减法与我们的预期一样工作。我们使用`-`来进行这个操作。你认为在这个第二个例子中变量中存储了什么？
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first result is `16`. And the second result is more interesting. It gives
    `NaN`, not an error, but just simply the conclusion that a word and a number subtracted
    is not a number. Thanks for not crashing, JavaScript!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结果是`16`。第二个结果更有趣。它给出`NaN`，不是一个错误，而只是简单地得出结论：一个单词和一个数字相减的结果不是数字。感谢JavaScript没有崩溃！
- en: Multiplication
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法
- en: We can multiply two numeric values with the `*` character. Unlike some other
    languages, we cannot successfully multiply a number and a string in JavaScript.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`*`字符来乘以两个数值。与某些其他语言不同，在JavaScript中我们不能成功地将一个数字和一个字符串相乘。
- en: 'The result of multiplying a numeric and a non-numeric value is NaN:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以一个数值和一个非数值的结果是NaN：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Division
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除法
- en: 'Another straightforward operator is division. We can divide two numbers with
    the `/` character:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个直接的运算符是除法。我们可以使用`/`字符来除以两个数字：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Exponentiation
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 幂运算
- en: 'Exponentiation means raising a certain base number to the power of the exponent,
    for example, *x*^y. This can be read as *x* to the power of *y*. It means that
    we will multiply *x* by itself *y* number of times. Here is an example of how
    to do this in JavaScript—we use `**` for this operator:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 幂运算意味着将某个基数数提升到指数的幂，例如，*x*^y。这可以读作*x*的*y*次幂。这意味着我们将*x*乘以自身*y*次。以下是在JavaScript中如何进行此操作的示例——我们使用`**`来进行这个运算符：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We get the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The result of this operation is 2 to the power of 3 (2 * 2 * 2), which is `8`.
    We''re going to avoid going into a mathematics lesson here, but we can also find
    the root of a number by using fractional exponents: for example, the square root
    of a value is the same as raising it to the power of 0.5.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的结果是2的3次方（2 * 2 * 2），即`8`。我们不会在这里深入讲解数学课程，但我们可以通过使用分数指数来找到数字的根：例如，一个值的平方根等同于将其提升到0.5的幂。
- en: Modulus
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取模
- en: 'This is one that often requires a little explanation. Modulus is the operation
    in which you determine how much is left after dividing a number by another number
    in its entirety. The amount of times the number can fit in the other number does
    not matter here. The outcome will be the remainder, or what is left over. The
    character we use for this operation is the `%` character. Here are some examples:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常需要一点解释。取模是在将一个数字除以另一个数字的整个过程中确定剩余多少的操作。这个数字可以在另一个数字中容纳的次数在这里并不重要。结果将是余数，或者剩下的部分。我们用于这个操作的字符是`%`字符。以下是一些示例：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And the output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 并且输出如下：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The first one is `10 % 3`, where 3 fits 3 times into 10, and then 1 is left.
    The second one is `8 % 2`. This results in 0, because 2 can fit 4 times into 8
    without having anything left. The last one is `15 % 4`, where 4 fits 3 times into
    15\. And then we have 3 left as a result.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是`10 % 3`，其中3可以3次进入10，然后剩下1。第二个示例是`8 % 2`。结果是0，因为2可以4次进入8而没有剩余。最后一个示例是`15
    % 4`，其中4可以3次进入15。然后我们得到3作为结果。
- en: 'This is something that would happen in your head automatically if I asked you
    to add 125 minutes to the current time. You will probably do two things: integer
    division to determine how many whole hours fit into 125 minutes, and then 125
    modulo 60 (in JavaScript terms, `125 % 60`) to conclude that you''ll have to add
    5 more minutes to the current time. Say our current time is 09:59, you will probably
    start by adding 2 hours, and get to 11:59, and then add 5 minutes, and then you
    will perform another modulus operation with 59 and 5, adding 1 more hour to the
    total and having 4 minutes left: 12:04.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我让你在当前时间上加 125 分钟时，你头脑中会自动发生的事情。你可能做两件事：整数除法来确定 125 分钟中有多少个完整的小时，然后 125 模
    60（用 JavaScript 术语，`125 % 60`）来确定你需要将 5 分钟加到当前时间上。假设我们的当前时间是 09:59，你可能会先加 2 个小时，变成
    11:59，然后加 5 分钟，然后你将执行另一个模运算，用 59 和 5，再增加 1 个小时到总时间，剩下 4 分钟：12:04。
- en: 'Unary operators: increment and decrement'
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一元运算符：递增和递减
- en: The last two operators of our arithmetic operator section are probably new to
    you, if you are new to programming (or only familiar with another programming
    language). These are the increment and decrement operators. A term we use here
    is **operand**. Operands are subject to the operator. So, if we say `x + y`, *x*
    and *y* are operands.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是编程新手（或者只熟悉另一种编程语言），那么我们算术运算符部分中的最后两个运算符可能对你来说是新的。这些是递增和递减运算符。我们在这里使用的一个术语是**操作数**。操作数受运算符的影响。所以，如果我们说
    `x + y`，*x* 和 *y* 是操作数。
- en: 'We only need one operand for these operators, and therefore we also call them
    unary operators. If we see `x++`, we can read this as *x* = *x* + 1\. The same
    is true for the decrement operators: `x--` can be read as *x* = *x* – 1:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符只需要一个操作数，因此我们也将它们称为一元运算符。如果我们看到 `x++`，我们可以将其读作 *x* = *x* + 1。对于递减运算符也是一样：`x--`
    可以读作 *x* = *x* – 1：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Prefix and postfix operators
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 前缀和后缀运算符
- en: We can have the increment operator after the operand (`x++`), in which case
    we call this the **postfix unary operator**. We can also have it before `(++x`),
    which is the **prefix unary operator**. This does something different though—the
    next few lines might be complicated, so do not worry if you need to read it a
    few times and have a good look at the examples here.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在操作数之后有递增运算符（`x++`），在这种情况下，我们称之为**后缀一元运算符**。我们也可以在它之前（`++x`），这被称为**前缀一元运算符**。但这做的是不同的事情——接下来的几行可能比较复杂，所以如果你需要多次阅读并仔细查看这里的示例，请不要担心。
- en: 'The postfix gets executed after sending the variable through, and then after
    that, the operation gets executed. In the following example, `nr` gets incremented
    by 1 *after* logging. So the first logging statement is still logging the old
    value because it has not been updated yet. It has been updated for the second
    log statement:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀运算是在将变量传递之后执行的，然后是执行操作。在下面的例子中，`nr` 在记录后增加 1。所以第一个记录语句仍然记录的是旧值，因为它还没有被更新。它已经在第二个记录语句中更新了：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The prefix gets executed *before* sending the variable through, and often this
    is the one you will need. Have a look at the following example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀运算会在将变量传递之前执行，通常这也是你需要的一个。看看下面的例子：
- en: '[PRE67]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We get the following output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE68]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Alright, if you can figure out what the next code snippets logs to the console,
    you should really have a handle on it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果你能弄清楚下一个代码片段将输出什么到控制台，你应该真的掌握了它：
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It outputs `16`. It will do the multiplication first, according to the basic
    mathematical order of operations. For multiplying, it uses 6 (prefix, so 5 is
    incremented before multiplying) and 2 (postfix, so 2 is only incremented after
    execution, meaning it won't affect our current calculation). This comes down to
    12\. And then `nr1` is a postfix operator, so this one will execute after the
    addition. Therefore, it will add 12 to 4 and become 16.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出 `16`。根据基本的数学运算顺序，它首先会进行乘法运算。对于乘法，它使用 6（前缀，所以 5 在乘法之前增加）和 2（后缀，所以 2 只在执行后增加，这意味着它不会影响我们当前的运算）。这等于
    12。然后 `nr1` 是后缀运算符，所以这个运算会在加法之后执行。因此，它会将 12 加到 4 上，变成 16。
- en: Combining the operators
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合运算符
- en: These operators can be combined, and it works just as it does in math. They
    get executed in a certain order, and not necessarily from left to right. This
    is due to a phenomenon called operator precedence.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符可以组合，并且它们的工作方式与数学中的方式相同。它们的执行顺序是特定的，并不一定是从左到右。这是由于一个称为运算符优先级的现象。
- en: 'There is one more thing to take into account here, and that is grouping. You
    can group using `(` and `)`. The operations between the parentheses have the highest
    precedence. After that, the order of the operations takes place based on the type
    of operation (highest precedence first) and if they are of equal precedence, they
    take place from left to right:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一点需要注意，那就是分组。你可以使用 `(` 和 `)` 进行分组。括号内的运算具有最高优先级。之后，运算的顺序根据运算类型（优先级最高先进行）进行，如果它们的优先级相同，则从左到右进行：
- en: '| Name | Symbol | Example |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 符号 | 示例 |'
- en: '| Grouping | `(...)` | `(x + y)` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 分组 | `(...)` | `(x + y)` |'
- en: '| Exponentiation | `**` | `x ** y` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 指数运算 | `**` | `x ** y` |'
- en: '| Prefix increment and decrement | `--`, `++` | `--x`, `++y` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 前缀递增和递减 | `--`, `++` | `--x`, `++y` |'
- en: '| Multiplication, division, modulus | `*`, `/`, `%` | `x * y`, `x / y`, `x
    % y` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 乘法、除法、取模 | `*`, `/`, `%` | `x * y`, `x / y`, `x % y` |'
- en: '| Addition and subtraction | `+`, `-` | `x + y`, `x - y` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 加法和减法 | `+`, `-` | `x + y`, `x - y` |'
- en: Practice exercise 2.3
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2.3
- en: Write some code to calculate the hypotenuse of a triangle using the Pythagorean
    theorem when given the values of the other two sides. The theorem specifies that
    the relation between the sides of a right-angled triangle is a² + b² = c².
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些代码，使用勾股定理计算三角形的斜边长度，当给定其他两边的值时。定理指定了直角三角形边之间的关系是 a² + b² = c²。
- en: The Pythagorean theorem only applies to right-angled triangles. The sides connected
    to the 90-degree angle are called the adjacent and opposite sides, represented
    by a and b in the formula. The longest side, not connected to the 90-degree angle,
    is called the hypotenuse, represented by c.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 勾股定理仅适用于直角三角形。与 90 度角相连的边称为相邻边和对边，在公式中用 a 和 b 表示。最长的边，不与 90 度角相连，称为斜边，用 c 表示。
- en: You can use `prompt()` to get the value for a and b. Write code to get the value
    from the user for `a` and `b`. Then square the values of both `a` and `b` before
    adding them together and finding the square root. Print your answer to the console.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `prompt()` 获取 a 和 b 的值。编写代码从用户那里获取 `a` 和 `b` 的值。然后对 `a` 和 `b` 的值进行平方，将它们相加，并找到平方根。将你的答案打印到控制台。
- en: Assignment operators
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: We have seen one assignment operator already when we were assigning values to
    variables. The character for this basic assignment operation is `=`. There are
    a few others available. Every binary arithmetic operator has a corresponding assignment
    operator to write a shorter piece of code. For example, *x* += 5 means *x* = *x*
    + 5, and *x* **= 3 means *x* = *x* ** 3 (x to the power of 3).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们给变量赋值时，我们已经见过一个赋值运算符了。这个基本赋值操作的字符是 `=`。还有一些其他的赋值运算符可用。每个二元算术运算符都有一个对应的赋值运算符，以便编写更短的代码。例如，*x*
    += 5 表示 *x* = *x* + 5，而 *x* **= 3 表示 *x* = *x* ** 3（x 的 3 次方）。
- en: 'In this first example we declare a variable `x`, and set it to `2` as an initial
    value:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们声明了一个变量 `x`，并将其初始值设置为 `2`：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'After this assignment operation, the value of `x` becomes 4, because *x* +=
    2 is the same as *x* = *x* + 2:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个赋值操作之后，`x` 的值变为 4，因为 *x* += 2 与 *x* = *x* + 2 是相同的：
- en: 'In the next assignment operation, we will subtract `2`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个赋值操作中，我们将减去 `2`：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'So, after this operation the value of `x` becomes `2` again (*x* = *x* – 2).
    In the next operation, we are going to multiply the value by 6:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，经过这次操作后，`x` 的值再次变为 `2`（*x* = *x* – 2）。在下一个操作中，我们将值乘以 6：
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When this line has been executed, the value of `x` is no longer 2, but becomes
    12 (*x* = *x* * 6). In the next line, we are going to use an assignment operator
    to perform a division:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一行代码执行完毕后，`x` 的值不再是 2，而是变成了 12（*x* = *x* * 6）。在下一行，我们将使用赋值运算符来进行除法操作：
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After dividing `x` by `3`, the new value becomes 4\. The next assignment operator
    we will use is exponentiation:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `x` 除以 `3` 后，新的值变为 4。接下来我们将使用的是指数运算符：
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The value of `x` becomes 16, because the old value was 4, and 4 to the power
    of 2 equals 16 (4 * 4). The last assignment operator we will talk about is the
    modulus assignment operator:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 的值变为 16，因为旧值是 4，4 的平方等于 16（4 * 4）。我们将讨论的最后一个是取模赋值运算符：'
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: After this assignment operation, the value of `x` is 1, because 3 can fit 5
    times into 16 and then leaves 1.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个赋值操作之后，`x` 的值是 1，因为 3 可以被 16 整除 5 次，然后剩下 1。
- en: Practice exercise 2.4
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2.4
- en: 'Create variables for three numbers: *a*, *b*, and *c*. Update these variables
    with the following actions using the assignment operators:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为三个数字创建变量：*a*、*b* 和 *c*。使用赋值运算符更新这些变量，执行以下操作：
- en: Add *b* to *a*
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *b* 加到 *a* 上
- en: Divide *a* by *c*
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *a* 除以 *c*
- en: Replace the value of c with the modulus of *c* and *b*
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *c* 的值替换为 *c* 和 *b* 的模
- en: Print all three numbers to the console
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有三个数字打印到控制台
- en: Comparison operators
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Comparison operators are different from the operators we have seen so far. The
    outcome of the comparison operators is always a Boolean, true, or false.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符与我们迄今为止看到的运算符不同。比较运算符的结果始终是布尔值，即 true 或 false。
- en: Equal
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等
- en: 'There are a few equality operators that determine whether two values are equal.
    They come in two flavors: equal value only, or equal value and data type. The
    first one returns true when the values are equal, even though the type is different,
    while the second returns true only when the value and the type are the same:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个相等运算符可以确定两个值是否相等。它们有两种类型：仅值相等，或值和数据类型相等。第一种在值相等时返回 true，即使类型不同，而第二种仅在值和类型都相同时返回
    true：
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The double equals operator, two equal signs, means that it will only check for
    equal value and not for data type. Both have the value `5`, so it will log `true`
    to the console. This type of equality is sometimes called loose equality.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 双等号运算符，两个等号，表示它将只检查值是否相等，而不检查数据类型。它们都有值 `5`，所以它将在控制台输出 `true`。这种相等性有时被称为松散相等。
- en: 'The triple equals operator, written as three equal signs, means that it will
    evaluate both the value and the data type to determine whether both sides are
    equal or not. They both need to be equal in order for this statement to be true,
    but they are not and therefore the following statement outputs `false`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 三等号运算符，写作三个等号，表示它将评估值和数据类型，以确定两边是否相等。为了使这个语句为真，它们都必须相等，但它们不相等，因此下面的语句输出 `false`：
- en: '[PRE77]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is sometimes also called strict equality. This triple equals operator is
    the one you should most commonly be using when you need to check for equality,
    as only with this one can you be sure that both variables are really equal.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时也称为严格相等。当你需要检查相等性时，你应该最常使用这个三等号运算符，因为只有使用这个运算符，你才能确保两个变量确实是相等的。
- en: Not equal
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不等于
- en: 'Not equal is very similar to equal, except it does the opposite—it returns
    true when two variables are not equal, and false when they are equal. We use the
    exclamation mark for not equal:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于与等于非常相似，除了它做的是相反的操作——当两个变量不相等时返回 true，当它们相等时返回 false。我们使用感叹号表示不等于：
- en: '[PRE78]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This will log `false` to the console. If you are wondering what is going on
    here, take a look again at the double and triple equals operators, because it
    is the same here. However, when there is only one equals sign in a not-equal operator,
    it is comparing loosely for non-equality. Therefore, it concludes that they are
    equal and therefore not equal should result in false. The one with two equals
    signs is checking for strict non-equality:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出 `false`。如果你想知道这里发生了什么，请再次查看双等号和三等号运算符，因为这里也是同样的情况。然而，当不等于运算符中只有一个等号时，它是在进行松散的非相等比较。因此，它得出结论它们是相等的，因此不相等应该导致
    false。带有两个等号的那个是在检查严格非相等：
- en: '[PRE79]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This will conclude that since `x` and `y` have different data types, they are
    not the same, and will log `true` to the console.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得出结论，由于 `x` 和 `y` 具有不同的数据类型，它们不是相同的，并且将在控制台输出 `true`。
- en: Greater than and smaller than
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大于和小于
- en: The greater than operator returns true if the left-hand side is greater than
    the right-hand side of the operation. We use the `>` character for this. We also
    have a greater than or equal to operator, `>=`, which returns `true` if the left-hand
    side is greater than or equal to the right-hand side.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 大于运算符如果操作符的左侧大于右侧，则返回 true。我们使用 `>` 字符表示这一点。我们还有一个大于等于运算符，`>=`，如果左侧大于或等于右侧，则返回
    `true`。
- en: '[PRE80]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This one will log `true`, because `y` is greater than `x`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这一个将输出 `true`，因为 `y` 大于 `x`。
- en: '[PRE81]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Since `x` is not greater than `y`, this one will log `false`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `x` 不大于 `y`，这将输出 `false`。
- en: '[PRE82]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`y` is not greater than `y`, so this one will log `false`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`y` 不大于 `y`，因此这将输出 `false`。'
- en: '[PRE83]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This last one is looking at whether `y` is greater than or equal to `y`, and
    since it is equal to itself, it will log `true`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是在查看 `y` 是否大于或等于 `y`，由于它等于自身，它将输出 `true`。
- en: It might not surprise you that we also have smaller than (`<`) and smaller than
    or equal to operators (`<=`). Let's have a look at the smaller than operator,
    as it is very similar to the previous ones.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不会让你感到惊讶，我们还有小于（`<`）和小于等于运算符（`<=`）。让我们看看小于运算符，因为它与前面的运算符非常相似。
- en: '[PRE84]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This first one will be `false`, since `y` is not smaller than `x`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个将是 `false`，因为 `y` 不小于 `x`。
- en: '[PRE85]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: So, this second one will log `true`, because `x` is smaller than `y`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第二个将记录 `true`，因为 `x` 小于 `y`。
- en: '[PRE86]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`y` is not smaller than `y`, so this one will log `false`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`y` 不小于 `y`，所以这将记录 `false`。'
- en: '[PRE87]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This last one looks at whether `y` is smaller than or equal to `y`. It is equal
    to `y`, so it will log `true`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个检查的是 `y` 是否小于等于 `y`。它等于 `y`，所以它将记录 `true`。
- en: Logical operators
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Whenever you want to check two conditions in one, or you need to negate a condition,
    the logical operators come in handy. You can use and, or, and not.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要检查一个条件，或者你需要否定一个条件时，逻辑运算符就派上用场了。你可以使用“与”、“或”和“非”。
- en: And
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与
- en: 'The first one we will have a look at is and. If you want to check whether `x`
    is greater than `y` and `y` is greater than `z`, you would need to be able to
    combine two expressions. This can be done with the `&&` operator. It will only
    return `true` if both expressions are true:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看的是“与”运算符。如果你想检查 `x` 是否大于 `y` 且 `y` 是否大于 `z`，你需要能够组合两个表达式。这可以通过 `&&` 运算符来完成。只有当两个表达式都为真时，它才会返回
    `true`：
- en: '[PRE88]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'With these variables in mind, we are going to have a look at the logical operators:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些变量，我们将查看逻辑运算符：
- en: '[PRE89]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This will log `true`, you can read it like this: if `x` is smaller than `y`
    and y is smaller than `z`, it will log `true`. That is the case, so it will log
    `true`. The next example will log `false`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录 `true`，你可以这样读：如果 `x` 小于 `y` 且 `y` 小于 `z`，它将记录 `true`。这是这种情况，所以它将记录 `true`。下一个示例将记录
    `false`：
- en: '[PRE90]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Since `x` is not greater than `y`, one part of the expression is not true, and
    therefore it will result in `false`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `x` 不大于 `y`，表达式的一部分不是真的，因此它将导致 `false`。
- en: Or
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 或
- en: 'If you want to get true if either one of the expressions is true, you use or.
    The operator for this is `||`. These pipes are used to see if either one of these
    two is true, in which case the whole expression evaluates to `true`. Let''s have
    a look at the or operator in action:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在任一表达式为真时得到 `true`，你将使用“或”。这个运算符是 `||`。这些管道用于检查这两个中的任何一个是否为真，在这种情况下，整个表达式评估为
    `true`。让我们看看“或”运算符的实际应用：
- en: '[PRE91]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This will result in `true`, whereas it was `false` with `&&.` This is because
    only one of the two sides needs to be true in order for the whole expression to
    evaluate to `true`. This is the case because `y` is smaller than `z`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 `true`，而之前使用 `&&` 时是 `false`。这是因为只需要两个部分中的任何一个为真，整个表达式才能评估为 `true`。这是因为
    `y` 小于 `z`。
- en: 'When both sides are false, it will log `false`, which is the case in the next
    example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当双方都为假时，它将记录`false`，这在下一个示例中就是这样：
- en: '[PRE92]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Not
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非
- en: 'In some cases you will have to negate a Boolean. This will make it the opposite
    value. It can be done with the exclamation mark, which reads as not:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要否定一个布尔值。这将使其变为相反的值。可以使用感叹号来完成，它读作“不是”：
- en: '[PRE93]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This will log true, since it will simply flip the value of the Boolean. You
    can also negate an expression that evaluates to a Boolean, but you would have
    to make sure that the expression gets evaluated first by grouping it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录 `true`，因为它只是简单地翻转布尔值的值。你也可以否定一个评估为布尔值的表达式，但你需要确保表达式首先通过分组进行评估。
- en: '[PRE94]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '`x` is smaller than `y`, so the expression evaluates to `true`. But, it gets
    negated due to the exclamation mark and prints `false` to the console.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 小于 `y`，所以表达式评估为 `true`。但是，由于感叹号的存在，它打印 `false` 到控制台。'
- en: Chapter project
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Miles-to-kilometers converter
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英里到公里的转换器
- en: 'Create a variable that contains a value in miles, convert it to kilometers,
    and log the value in kilometers in the following format:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含英里值的变量，将其转换为公里，并按以下格式记录公里值：
- en: '[PRE95]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: For reference, 1 mile equals 1.60934 kilometers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，1 英里等于 1.60934 公里。
- en: BMI calculator
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BMI 计算器
- en: 'Set values for height in inches and weight in pounds, then convert the values
    to centimeters and kilos, outputting the results to the console:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 设置身高为英寸和体重为磅的值，然后将这些值转换为厘米和公斤，并将结果输出到控制台：
- en: 1 inch is equal to 2.54 cm
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 英寸等于 2.54 厘米
- en: 2.2046 pounds is equal to 1 kilo
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.2046 磅等于 1 公斤
- en: 'Output the results. Then, calculate and log the BMI: this is equal to weight
    (in kilos) divided by squared height (in meters). Output the results to the console.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果。然后，计算并记录BMI：这是体重（以千克为单位）除以身高的平方（以米为单位）。将结果输出到控制台。
- en: Self-check quiz
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: What data type is the following variable?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下变量的数据类型是什么？
- en: '[PRE96]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: What data type is the following variable?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下变量的数据类型是什么？
- en: '[PRE97]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Which one is generally better, line 1 or line 2?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪一行通常更好，第1行还是第2行？
- en: '[PRE98]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: What is the console output for the following?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的控制台输出是什么？
- en: '[PRE99]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: What will be logged to the console?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台将记录什么？
- en: '[PRE100]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: What is the value of `a`?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`的值是多少？'
- en: '[PRE101]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: What is the value of `b` output to the console?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出到控制台的`b`的值是多少？
- en: '[PRE102]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: What is the value of `result`?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result`的值是多少？'
- en: '[PRE103]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: What is the value of `total` and `total2`?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`total`和`total2`的值是多少？'
- en: '[PRE104]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: What is logged to the console here?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里记录了什么到控制台？
- en: '[PRE105]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we dealt with the first two programming building blocks: variables
    and operators. Variables are special fields that have a name and contain values.
    We declare a variable by using one of the special variable-defining words: `let`,
    `var`, or `const`. Variables enable us to make our scripts dynamic, store values,
    access them later, and change them later. We discussed some primitive data types,
    including strings, numbers, Booleans, and Symbols, as well as more abstract types
    such as undefined and null. You learned how to determine the type of a variable
    using the `typeof` word. And you saw how you can convert the data type by using
    the built-in JavaScript methods `Number()`, `String()`, and `Boolean()`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了前两个编程构建块：变量和运算符。变量是具有名称并包含值的特殊字段。我们通过使用以下特殊变量定义词之一来声明变量：`let`、`var`或`const`。变量使我们能够使我们的脚本动态化，存储值，稍后访问它们，并稍后更改它们。我们讨论了一些原始数据类型，包括字符串、数字、布尔值和符号，以及更抽象的类型，如未定义和null。你学习了如何使用`typeof`这个词来确定变量的类型。你还看到了如何使用内置的JavaScript方法`Number()`、`String()`和`Boolean()`来转换数据类型。
- en: Then we moved on and discussed operators. Operators enable us to work with our
    variables. They can be used to perform calculations, compare variables, and more.
    The operators we discussed included arithmetic operators, assignment operators,
    comparison operators, and logical operators.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续讨论并讨论了运算符。运算符使我们能够处理我们的变量。它们可以用来执行计算、比较变量以及更多操作。我们讨论了包括算术运算符、赋值运算符、比较运算符和逻辑运算符在内的运算符。
- en: After this chapter, you are ready to deal with more complex data types, such
    as arrays and objects. We'll cover these in the next chapter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将准备好处理更复杂的数据类型，例如数组和对象。我们将在下一章介绍这些内容。
