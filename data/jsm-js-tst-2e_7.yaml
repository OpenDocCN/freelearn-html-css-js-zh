- en: Chapter 7. Testing React Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。测试React应用程序
- en: As a web developer, you are familiar with the way most websites are built today.
    There is usually a web server (in languages such as Java, Ruby, or PHP) that processes
    user requests and responds with markup (HTML).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Web开发者，您熟悉大多数网站今天是如何构建的。通常有一个Web服务器（在Java、Ruby或PHP等语言中），它处理用户请求并以标记（HTML）的形式响应。
- en: This means that on every request, the web server interprets the user action
    through the URL and renders the entire page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在每次请求时，Web服务器通过URL解释用户操作并渲染整个页面。
- en: In an attempt to improve the user experience, more and more functionality started
    to get pushed from the server side to the client side, and JavaScript was no longer
    simply adding behavior to the page but was rendering it entirely. The biggest
    advantage was that a user action was no longer triggering a whole page refresh;
    the JavaScript code could deal with the entire browser document and mutate it
    accordingly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高用户体验，越来越多的功能开始从服务器端推向客户端，JavaScript不再仅仅是向页面添加行为，而是完全渲染页面。最大的优势是用户操作不再触发整个页面的刷新；JavaScript代码可以处理整个浏览器文档并根据需要进行修改。
- en: Although this did improve the user experience, it started to add a lot of complexity
    to the application code, which led to increased maintenance costs and the worst—bugs
    in the form of inconsistencies between different parts of the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实提高了用户体验，但它开始给应用程序代码增加了很多复杂性，导致维护成本增加，最糟糕的是——屏幕不同部分之间不一致的bug。
- en: In an attempt to bring sanity to this scenario, a number of libraries and frameworks
    were built, but they all failed in the sense that they didn't tackle the root
    cause of the entire problem—mutability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种场景变得合理，许多库和框架被构建出来，但它们都失败了，因为它们没有解决整个问题的根本原因——可变性。
- en: Server-side rendering was easy because there was no mutation to deal with. Given
    a new application state, the server would simply render everything again. What
    if we could get benefits from this approach in our client-side JavaScript code?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染很容易，因为没有要处理的可变性。给定一个新的应用程序状态，服务器会简单地重新渲染一切。如果我们能在客户端JavaScript代码中从这种方法中获得好处怎么办？
- en: That is exactly what **React** proposes to do. You declaratively write the interface
    code in the form of components and tell React to render. On any change of the
    application state, you can simply tell React to re-render again; it will then
    calculate the mutations required to move the DOM to the required state and apply
    them for you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是**React**所提出的。您以组件的形式声明性地编写界面代码，并告诉React进行渲染。在任何应用程序状态变化时，您可以简单地告诉React重新渲染；然后它会计算将DOM移动到所需状态的所需更改，并为您应用它们。
- en: During this chapter, we are going to understand how React works by refactoring
    the code we've built so far into an SPA.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过重构到目前为止所编写的代码，将其重构为一个单页应用（SPA），来理解React是如何工作的。
- en: Project setup
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: However, before we can dive into React, first we need a small setup in our project
    to allow us to create React components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入React之前，首先需要在我们的项目中做一些小的设置，以便我们能够创建React组件。
- en: Go to [http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html)
    and download the React Starter Kit Version 0.12.2 or higher.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html)下载React
    Starter Kit版本0.12.2或更高版本。
- en: After the download, you can unpack its contents and move all the files from
    within the build folder to our application's lib folder. Then, just load the React
    library onto the `SpecRunner.html` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，您可以解压其内容，并将构建文件夹内的所有文件移动到我们的应用程序的lib文件夹中。然后，只需将React库加载到`SpecRunner.html`文件中。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the setup complete, we can move on to writing our very first component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们可以继续编写我们的第一个组件。
- en: Our first React component
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个React组件
- en: As stated in the introduction of this chapter, with React, you declaratively
    write the interface code through components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，使用React，您通过组件声明性地编写界面代码。
- en: The concept of a React component is analogous to the component concept presented
    in [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing Frontend
    Code*, so expect to see some similarities next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的概念与[第3章](ch03.html "第3章。测试前端代码")中提出的组件概念类似，即*测试前端代码*，因此期待在下一部分看到一些相似之处。
- en: With that in mind, let's create our very first component. To better understand
    what a React component is, we are going to use a very simple acceptance criterion
    and as usual start from the spec.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们创建我们非常第一个组件。为了更好地理解 React 组件是什么，我们将使用一个非常简单的验收标准，并像往常一样从规范开始。
- en: Let's implement "InvestmentListItem should render". It's very simple and not
    really *feature oriented* but is a good example to get us started.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 "InvestmentListItem 应该渲染"。这很简单，并不真正是 *面向功能* 的，但是一个很好的例子，让我们开始。
- en: 'With what we learned in [Chapter 3](ch03.html "Chapter 3. Testing Frontend
    Code"), *Testing Frontend Code*, we could start coding this spec by creating a
    new file called `InvestmentListItemSpec.js` and save it in the `components` folder
    inside the `spec` folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [第 3 章](ch03.html "第 3 章。测试前端代码") 中学到的内容，*测试前端代码*，我们可以通过创建一个名为 `InvestmentListItemSpec.js`
    的新文件并保存在 `spec` 文件夹内的 `components` 文件夹中来开始编写这个规范：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add the new file to the `SpecRunner.html` file, as already demonstrated in previous
    chapters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将新文件添加到 `SpecRunner.html` 文件中，如前几章中已演示。
- en: At the spec, we are basically using the `jasmine-jquery` plugin to expect that
    the encapsulated DOM element of our component is equal to a specific CSS selector.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范中，我们基本上使用 `jasmine-jquery` 插件来期望我们的组件封装的 DOM 元素等于特定的 CSS 选择器。
- en: How would we change this example to be a test of a React component? The only
    difference is the API to get the DOM node. Instead of `$element` with a jQuery
    object, React exposes a function called `getDOMNode()` that returns what it states—a
    DOM node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这个例子改为测试 React 组件？唯一的区别是获取 DOM 节点的 API。而不是使用带有 jQuery 对象的 `$element`，React
    提供了一个名为 `getDOMNode()` 的函数，它返回它所声称的——一个 DOM 节点。
- en: 'With that, we can use the same assertion as before and have our test ready,
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以使用之前相同的断言，并使测试准备就绪，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That was easy! So, the next step is to create the component, render it, and
    attach it to the document. That is simple as well; take a look at the following
    gist:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！所以，下一步是创建组件，渲染它，并将其附加到文档上。这也同样简单；请看以下代码片段：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It might seem like a lot of code, but half of it is just boilerplate to set
    up a document element fixture that we can render the React component in:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像很多代码，但其中一半只是设置文档元素固定装置的样板代码，这样我们就可以在其中渲染 React 组件：
- en: 'First, we use the `setFixtures` function from `jasmine-jquery` to create an
    element in the document with the `application-container` ID. Then, using the `getElementById`
    API, we query for this element and save it in the `container` variable. The next
    two steps are the ones specific to React:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `jasmine-jquery` 中的 `setFixtures` 函数在文档中创建一个具有 `application-container`
    ID 的元素。然后，使用 `getElementById` API 查询此元素并将其保存到 `container` 变量中。接下来的两个步骤是针对 React
    的特定步骤：
- en: 'First, in order to use a component, we must first create an element from its
    class; this is done through the `React.createElement` function, as follows:'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了使用一个组件，我们必须首先从其类中创建一个元素；这是通过 `React.createElement` 函数完成的，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, with the element instance, we can finally tell React to render it through
    the `React.render` function, as follows:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用元素实例，我们最终可以通过 `React.render` 函数告诉 React 渲染它，如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `render` function accepts the following two parameters:'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render` 函数接受以下两个参数：'
- en: The React element
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 元素
- en: A DOM node to render the element in
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于渲染元素的 DOM 节点
- en: 'As of now, the spec is complete. You can run it and see it fail, showing the
    following error:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，规范已经完成。你可以运行它并看到它失败，显示以下错误：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next step is to code the component. So, let's feed the spec, create a new
    file in the `src` folder, name it `InvestmentListItem.js`, and add it to the spec
    runner. This file should follow the module pattern we've been using until now.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是编写组件代码。所以，让我们填充规范，在 `src` 文件夹中创建一个新文件，命名为 `InvestmentListItem.js`，并将其添加到规范运行器中。这个文件应该遵循我们至今为止使用的模块模式。
- en: 'Then, create a new class of component using the `React.createClass` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `React.createClass` 方法创建一个新的组件类：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the least, the `React.createClass` method expects a single `render` function
    that should return a tree of React elements.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少，`React.createClass` 方法期望一个单独的 `render` 函数，该函数应该返回一个 React 元素的树。
- en: 'We use again the `React.createElement` method to create the element that is
    going to be the root of the rendering tree, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次使用 `React.createElement` 方法来创建将成为渲染树根的元素，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference from its previous usage in the `beforeEach` block is that here,
    it is also passing a list of **props** (with `className`) and a single child containing
    the text `Investment`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与其在 `beforeEach` 块中之前的用法相比，这里的区别在于它还传递了一个包含 `className` 的 **props** 列表和一个包含文本
    `Investment` 的单个子组件。
- en: We will get deeper into the meaning of the props parameter, but you can think
    of it as analogous to the attributes of an HTML DOM element. The `className` prop
    will turn into the class HTML attribute of the `li` element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地探讨 props 参数的含义，但你可以将其视为与 HTML DOM 元素的属性类似。`className` prop 将转换为 `li`
    元素的 class HTML 属性。
- en: 'The `React.createElement` method signature accepts three arguments:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement` 方法签名接受三个参数：'
- en: The type of the component that can be either a string representing a real DOM
    element (such as `div`, `h1`, `p`) or a React component class
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的类型，可以是表示真实 DOM 元素的字符串（如 `div`、`h1`、`p`）或 React 组件类
- en: An object containing the props values
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 props 值的对象
- en: And a variable number of children components, which in this case, is just the
    `Investment` string
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及一个可变数量的子组件，在这个例子中，就是 `Investment` 字符串
- en: 'On rendering this component (by invoking the `React.render()` method), the
    result will be:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染这个组件（通过调用 `React.render()` 方法）时，结果将是：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a direct representation of the JavaScript code that generated it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成它的 JavaScript 代码的直接表示：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Congratulations! You've built your first fully tested React component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经构建了第一个完全测试过的 React 组件。
- en: The Virtual DOM
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟 DOM
- en: When you define a component's render method and invoke the `React.createElement`
    method, you are not actually rendering anything in the document (you are not even
    creating DOM elements).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个组件的渲染方法并调用 `React.createElement` 方法时，你实际上并没有在文档中渲染任何内容（你甚至没有创建 DOM 元素）。
- en: It is only through the `React.render` function that the representation created
    by invoking these `React.createElement` calls are effectively converted into real
    DOM elements and attached to the document.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过 `React.render` 函数，调用这些 `React.createElement` 调用创建的表示才能有效地转换为真实的 DOM 元素并附加到文档上。
- en: This representation, defined by `ReactElements`, is what React calls the Virtual
    DOM. And `ReactElement` must not be confused with DOM elements; it is instead
    a light, stateless, immutable, virtual representation of a DOM element.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种由 `ReactElements` 定义的表示，是 React 所称的虚拟 DOM。而且 `ReactElement` 不能与 DOM 元素混淆；它实际上是一个轻量级、无状态、不可变、虚拟的
    DOM 元素表示。
- en: So why did React get into the trouble of creating a new way of representing
    the DOM? The answer here is *performance*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为什么 React 要陷入创建新的 DOM 表示方式的麻烦呢？答案在这里是 *性能*。
- en: As browsers evolved, JavaScript performance kept getting better and better,
    and today's application bottlenecks aren't actually JavaScript. You've probably
    heard that you should try touching the DOM as little as possible, and React allows
    you to do that by letting you interact with its own version of the DOM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着浏览器的进化，JavaScript 的性能一直在不断提升，而今天的应用瓶颈实际上并不是 JavaScript。你可能听说过，你应该尽量减少对 DOM
    的操作，React 允许你通过提供自己的 DOM 版本来实现这一点。
- en: However, that is not the only reason. React has built a very powerful diffing
    algorithm that can compare two distinct representations of the Virtual DOM, compute
    their differences, and with that information, create mutations that then get applied
    to the real DOM.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是唯一的原因。React 构建了一个非常强大的 diffing 算法，可以比较虚拟 DOM 的两种不同表示，计算它们之间的差异，并利用这些信息创建应用于真实
    DOM 的突变。
- en: It allows us to get back to the flow we used to have with server-side rendering.
    We can basically, on any change of the application state, ask React to re-render
    everything, and it will then compute the minimal number of changes required and
    apply only that to the real DOM.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们回到我们曾经使用的服务器端渲染的流程。基本上，在应用状态发生任何变化时，我们可以要求 React 重新渲染一切，然后它会计算所需的最小更改数量，并将这些更改应用到真实的
    DOM 上。
- en: It frees us developers from worrying about mutating the DOM and empowers us
    to write our user interfaces in a declarative way, while reducing bugs and improving
    productivity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它让我们开发者从担心修改 DOM 中解放出来，并赋予我们以声明式方式编写用户界面的能力，同时减少错误并提高生产力。
- en: JSX
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX
- en: If you have any experience writing frontend JavaScript applications, you might
    be familiar with a few template languages. At this moment, you might be wondering
    where can you use your favorite template language (such as Handlebars) with React.
    And the answer is that you can't.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有编写前端 JavaScript 应用程序的经验，您可能熟悉一些模板语言。此时，您可能想知道您最喜欢的模板语言（如 Handlebars）可以在
    React 中何处使用。答案是您不能。
- en: React doesn't make any distinction between markup and logic; in a React component,
    they are effectively the same.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: React 不会在标记和逻辑之间做出区分；在 React 组件中，它们实际上是相同的。
- en: However, what happens when we start crafting more complicated components? How
    would the form we built in [Chapter 3](ch03.html "Chapter 3. Testing Frontend
    Code"), *Testing Frontend Code*, translate into a React component?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们开始构建更复杂的组件时会发生什么？我们在[第3章](ch03.html "第3章。测试前端代码")中构建的表单，*测试前端代码*，将如何转换成
    React 组件？
- en: 'To just render it without any other logic, it would take a bunch of `React.createElement`
    calls, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了渲染而不涉及其他逻辑，需要调用一大堆 `React.createElement`，如下所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is very verbose and hard to read. So, given that a React component is
    both markup and logic, wouldn''t it be better if we could write it as a mixture
    of HTML and JavaScript? Here''s how:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常冗长且难以阅读。因此，鉴于 React 组件既是标记也是逻辑，我们能否将其写成 HTML 和 JavaScript 的混合体会更好？下面是如何做的：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That is **JSX**, a JavaScript syntax extension that looks like XML and was built
    to be used with React.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是JSX，一种类似于XML的 JavaScript 语法扩展，它是为了与 React 一起使用而构建的。
- en: It transforms into JavaScript, so given the latter example, it would compile
    directly to the plain JavaScript code presented before.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它会转换成 JavaScript，所以根据后一个示例，它将直接编译成前面展示的纯 JavaScript 代码。
- en: An important feature of the transformation process is that it doesn't change
    the line numbers; so, *line 10* in the JSX will translate into *line 10* in the
    transformed JavaScript file. This helps while debugging the code and doing static
    code analysis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 转换过程的一个重要特性是它不会改变行号；因此，JSX中的*第10行*将转换成转换后的 JavaScript 文件中的*第10行*。这有助于在调试代码和进行静态代码分析时。
- en: For more information about the language, you can check the official specification
    at [http://facebook.github.io/jsx/](http://facebook.github.io/jsx/), but for now,
    you can just follow the next examples as we dive into the features of this language.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于该语言的更多信息，您可以查看官方规范[http://facebook.github.io/jsx/](http://facebook.github.io/jsx/)，但就目前而言，我们可以按照下面的示例继续，当我们深入探讨该语言的功能时。
- en: It is important to know that it is not a requirement to use JSX while implementing
    React components, but it makes the process a lot easier. With that in mind, we
    are going to keep using it for now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，在实现 React 组件时使用 JSX 并不是强制要求，但它使整个过程变得更加容易。考虑到这一点，我们目前将继续使用它。
- en: Using JSX with Jasmine
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSX 与 Jasmine
- en: In order for us to use JSX with our Jasmine runner, there are a few changes
    we need to make.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够使用 JSX 与我们的 Jasmine 运行器一起使用，我们需要进行一些更改。
- en: First, we need to rename the files with which we want to use the JSX syntax
    to `.jsx`. Although this is not a requirement, it allows us to easily identify
    when a file is using this special syntax.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将想要使用 JSX 语法的文件重命名为 `.jsx`。虽然这不是强制要求，但它使我们能够轻松地识别出哪些文件正在使用这种特殊语法。
- en: 'Next, on the `SpecRunner.html` file, we need to change the script tags to indicate
    that these are not regular JavaScript files, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `SpecRunner.html` 文件中，我们需要更改脚本标签，以表明这些不是常规的 JavaScript 文件，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unfortunately, these are not the only changes we need to make. The browser doesn't
    understand JSX syntax, so we need to load a special transformer that will first
    transform these files into regular JavaScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们需要的更改不止这些。浏览器不理解 JSX 语法，因此我们需要加载一个特殊的转换器，它将首先将这些文件转换成常规 JavaScript。
- en: 'This transformer comes bundled in the React starter kit, so just load it right
    after loading React, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换器包含在 React 入门套件中，所以只需在加载 React 之后立即加载它，如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this setup done, we should be able to run the tests, shouldn't we? Unfortunately,
    there is one more step.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此设置后，我们应该能够运行测试，不是吗？不幸的是，还有一步。
- en: If you try to open the `SpecRunner.html` file in the browser, you will see that
    the tests of `InvestmentListItem` are not being executed. That is because the
    transformer works by loading the script files through AJAX, transforming them
    and finally attaching them to the DOM. By the time this process is complete, Jasmine
    has already run the tests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在浏览器中打开 `SpecRunner.html` 文件，您将看到 `InvestmentListItem` 的测试没有被执行。这是因为转换器通过
    AJAX 加载脚本文件，转换它们，最后将它们附加到 DOM 上。在此过程完成之前，Jasmine 已经运行了测试。
- en: We need a way to inform Jasmine to wait for these files to load and be transformed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来通知 Jasmine 等待这些文件加载并转换。
- en: The simplest way to do that is to change Jasmine's `boot.js` file placed in
    the `jasmine-2.1.3` folder, inside the `lib` folder.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是更改位于 `jasmine-2.1.3` 文件夹中的 `jasmine-2.1.3` 文件夹内的 `lib` 文件夹中的 Jasmine
    的 `boot.js` 文件。
- en: 'In the original file, you are going to need to find the line that contains
    the `env.execute();` method and comment it out. It should be something like the
    following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始文件中，您需要找到包含 `env.execute();` 方法的行并将其注释掉。它可能如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Everything else in the file should remain the same. After this change, you will
    see that the tests are no longer running—none of them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的其他内容应保持不变。在此更改之后，您将看到测试不再运行——一个都没有。
- en: 'The only missing piece is invoking this `execute` method once the JSX files
    are loaded. To do so, we are going to create a new file called `boot-exec.js`
    inside the `jasmine.2.1.3` folder with the following content:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的部分是在 JSX 文件加载后调用此 `execute` 方法。为此，我们将在 `jasmine.2.1.3` 文件夹中创建一个名为 `boot-exec.js`
    的新文件，内容如下：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you see, it is only executing the previously commented code from the original
    boot file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只执行了原始启动文件中先前注释的代码。
- en: 'To run this custom boot is very simple. We add it to the last line of the `<head>`
    tag of `SpecRunner.html` as a JSX type:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个自定义启动程序非常简单。我们将其添加到 `SpecRunner.html` 文件的 `<head>` 标签的最后一行，作为 JSX 类型：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `JSXTransformer` library guarantees that the scripts are loaded in the order
    they are declared. So, by the time the `boot-exec.js` file is loaded, the source
    and test files are already loaded.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSXTransformer` 库确保脚本按照声明的顺序加载。因此，当 `boot-exec.js` 文件被加载时，源文件和测试文件已经加载完毕。'
- en: With that, our test runner now supports JSX.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的测试运行器现在支持 JSX。
- en: Component attributes (props)
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件属性（props）
- en: Props are the way to pass down data from a parent to a child component in React.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Props 是在 React 中从父组件传递数据到子组件的方式。
- en: For this next example, we want to change the `InvestmentListItem` component
    to render the value of the `roi` variable formatted in percentage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，我们希望将 `InvestmentListItem` 组件修改为以百分比格式渲染 `roi` 变量的值。
- en: 'To implement the next specs, we are going to use a few helper methods that
    React offers through the `React.addons.TestUtils` object, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现下一个规范，我们将使用 React 通过 `React.addons.TestUtils` 对象提供的几个辅助方法，如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we are no longer using the `setFixture` method from the `jasmine-jquery`
    matcher. Instead, we are using the `TestUtils` module to render the component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不再使用来自 `jasmine-jquery` 匹配器的 `setFixture` 方法。相反，我们使用 `TestUtils` 模块来渲染组件。
- en: The biggest difference here is that `TestUtils.renderIntoDocument` doesn't actually
    render in the document, but it renders into a detached node.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最大区别是 `TestUtils.renderIntoDocument` 并没有在文档中渲染，而是在一个分离的节点中渲染。
- en: The next thing you will notice is that the `InvestmentListItem` component has
    an attribute (actually called **prop**) where we pass down `investment`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个您会注意到的是，`InvestmentListItem` 组件有一个属性（实际上称为 **prop**），我们通过它传递 `investment`。
- en: Then, at the spec, we are using another helper method called `findRenderedDOMComponentWithClass`
    to look for a DOM element in our `component` variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在规范中，我们使用另一个名为 `findRenderedDOMComponentWithClass` 的辅助方法来在 `component` 变量中查找
    DOM 元素。
- en: 'This method returns `ReactElement`. And again, we will use the `getDOMNode`
    method to get the actual DOM element and then use the `jasmine-jquery` matcher
    to check for its text value, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回 `ReactElement`。再次强调，我们将使用 `getDOMNode` 方法获取实际的 DOM 元素，然后使用 `jasmine-jquery`
    匹配器检查其文本值，如下所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implementing this behavior in the component is actually very simple:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件中实现此行为实际上非常简单：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can access any props passed to a component through the `this.props` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `this.props` 对象访问传递给组件的任何 props。
- en: Expanding the original implementation, we've added a `span` element with the
    expected class from the spec.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展原始实现，我们添加了一个具有预期类的 `span` 元素。
- en: 'To allow the return on investment to be dynamic, JSX has a special syntax.
    Using `{}`, you can invoke any JavaScript code in the middle of the XML. We are
    invoking the `formatPercentage` function while passing the `investment.roi()`
    value, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使投资回报率具有动态性，JSX 有一个特殊的语法。使用 `{}`，你可以在 XML 中调用任何 JavaScript 代码。我们在这里调用 `formatPercentage`
    函数，并传递 `investment.roi()` 的值，如下所示：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, just to make this clear, this JSX transformed into JavaScript would
    be:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，只是为了使这一点更清晰，这个 JSX 转换为 JavaScript 会是：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to know that a prop should be immutable. It is not the responsibility
    of a component to change its own prop values. You can consider a React component
    that has only props as a pure function, in that it always returns the same result
    value given the same argument values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的是，一个 prop 应该是不可变的。组件改变其自身的 prop 值不是组件的责任。你可以将只有一个 props 的 React 组件视为一个纯函数，因为它总是返回相同的值，前提是给定的参数值相同。
- en: This makes testing very simple as there are no mutations or changes in the state
    to test a component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试变得非常简单，因为没有突变或状态变化来测试组件。
- en: Component events
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件事件
- en: UI applications have user events; in the web, they came in the form of DOM events.
    As React wraps each DOM element into React elements, handling them will be a little
    different yet very familiar.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: UI 应用程序有用户事件；在网页中，它们以 DOM 事件的形式出现。由于 React 将每个 DOM 元素包装成 React 元素，因此处理它们会有所不同，但仍然非常熟悉。
- en: 'For this next example, let''s suppose that our application will allow users
    to delete an investment. We could write this requirement through the following
    acceptance criterion:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，假设我们的应用程序将允许用户删除投资。我们可以通过以下验收标准来编写这个需求：
- en: Given an investment, InvestmentListItem should notify an observer onClickDelete
    when the delete button is clicked on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个投资，当点击删除按钮时，InvestmentListItem 应该通知观察者 onClickDelete。
- en: The idea here is the same as presented in the *Integrate Views with observers*
    section of [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing
    Frontend Code*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法与第 3 章“整合视图与观察者”部分中提到的相同，[第 3 章](ch03.html "第 3 章。测试前端代码")，*测试前端代码*。
- en: 'So, how should we set the observer in a component? As we''ve already seen previously,
    **props** are the way to pass attributes to our component, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在组件中设置观察者呢？正如我们之前所看到的，**props** 是将属性传递给我们的组件的方式，如下所示：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, we passed down another prop to the `onClickDelete` component,
    and as its value, we set a Jasmine spy, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们向下传递了另一个 prop 给 `onClickDelete` 组件，并将其值设置为 Jasmine 间谍，如下所示：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Then, we found the delete button through its tag and used the `TestUtils`
    module to simulate a click, expecting the previously created spy to be called,
    as follows:**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**然后，我们通过其标签找到了删除按钮，并使用 `TestUtils` 模块模拟了一个点击，期望之前创建的间谍被调用，如下所示：**'
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**The `TestUtils.Simulate` module contains helper methods to simulate all types
    of DOM events, as follows:**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**`TestUtils.Simulate` 模块包含用于模拟所有类型 DOM 事件的辅助方法，如下所示：**'
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Then, we got back to the implementation:**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**然后，我们回到了实现阶段：**'
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**As you can see, it was as simple as nesting another `button` component and
    passing down the `onClickDelete` prop value as its `onClick` prop.**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**正如你所见，这就像嵌套另一个 `button` 组件并将 `onClickDelete` prop 值作为其 `onClick` prop 传递一样简单。**'
- en: '**React normalizes events so that they have consistent properties across different
    browsers, but its naming conventions and syntax is similar to inline JavaScript
    code in HTML. To get a comprehensive list of the supported events, you can check
    the official documentation at [http://facebook.github.io/react/docs/events.html](http://facebook.github.io/react/docs/events.html).**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**React 规范化事件，以便在不同浏览器中具有一致的属性，但其命名约定和语法与 HTML 中的内联 JavaScript 代码相似。要获取支持事件的完整列表，你可以查看官方文档[http://facebook.github.io/react/docs/events.html](http://facebook.github.io/react/docs/events.html)。**'
- en: '**# Component state'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 组件状态**'
- en: Until now, we've dealt with React as a stateless rendering engine, but as we
    know, applications have state, especially when using forms. So, how would we implement
    the `NewInvestment` component in order for it to keep hold of the values of the
    investment being created and then notify an observer once the user completed the
    form?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将 React 视为一个无状态的渲染引擎，但正如我们所知，应用程序有状态，尤其是在使用表单时。那么，我们如何实现 `NewInvestment`
    组件，以便它能够保留正在创建的投资的值，并在用户完成表单后通知观察者？
- en: To help us implement this behavior, we are going to use another component internal
    API—its **state**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们实现这种行为，我们将使用另一个组件内部API——它的**状态**。
- en: 'Let''s take the following acceptance criterion:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下验收标准：
- en: 'Given that the inputs of the `NewInvestment` component are correctly filled,
    when the form is submitted, it should notify the `onCreate` observer with the
    investment attributes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`NewInvestment`组件的输入已经正确填写，当表单提交时，它应该通过投资属性通知`onCreate`观察者：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This spec is basically using every trick we've learned until now, so without
    getting into the details, let's dive directly into the component implementation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范基本上使用了我们至今所学到的每一个技巧，所以不深入细节，让我们直接进入组件实现。
- en: 'The first thing that any component with state must declare is its initial state
    by defining a `getInitialState` method, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有状态的组件必须首先声明其初始状态，通过定义一个`getInitialState`方法，如下所示：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As illustrated in the preceding code, we are clearly defining the initial state
    of our form, and at the render method, we pass the state as `value` props to the
    input components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们明确定义了表单的初始状态，并在渲染方法中将状态作为`value`属性传递给输入组件。
- en: If you run this example in a browser, you will notice that you won't be able
    to change the values of the inputs. You can focus on the inputs, but trying to
    type won't change its values, and that is because of the way React works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个浏览器中运行这个示例，你会注意到你无法更改输入的值。你可以聚焦到输入上，但尝试输入不会改变其值，这是因为React的工作方式。
- en: Unlike HTML, React components must represent the state of the view at any point
    in time and not only at initialization time. If we want to change the value of
    an input, we need to listen for the `onChange` events of the inputs and, with
    that information, update the state. The change in the state will then trigger
    a render that will update the value on screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML不同，React组件必须在任何时间点表示视图的状态，而不仅仅是初始化时间。如果我们想改变输入的值，我们需要监听输入的`onChange`事件，并使用这些信息更新状态。状态的改变将触发一个渲染，从而更新屏幕上的值。
- en: To demonstrate how this works, let's implement this behavior at the `stockSymbol`
    input.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这是如何工作的，让我们在`stockSymbol`输入处实现这种行为。
- en: 'First, we need to change the render method, adding a handler to the `onChange`
    event:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改渲染方法，向`onChange`事件添加一个处理程序：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the event is triggered, it will invoke the `_handleStockSymbolChange`
    method. Its implementation should update the state by invoking the `this.setState`
    method with the new value of the input, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事件被触发，它将调用`_handleStockSymbolChange`方法。其实现应该通过调用`this.setState`方法并传入输入的新值来更新状态，如下所示：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The event handler is a good place to perform simple validation or transformation
    in the input data before passing it to the state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序是一个在将输入数据传递到状态之前执行简单验证或转换的好地方。
- en: As you can see, this is a lot of boilerplate code just to handle a single input.
    Since we are not implementing any custom behavior into our event handlers, we
    can use a special React feature that implements this "linked state" for us.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这只是一大堆样板代码，只是为了处理单个输入。由于我们并没有在我们的事件处理程序中实现任何自定义行为，我们可以使用React的一个特殊功能，该功能为我们实现了这种“链接状态”。
- en: 'We are going to use a **Mixin** called `LinkedStateMixin`; but first, what
    is a Mixin? It is a way to share common functionality between components, which,
    in this case, is the "linked state". Take a look at the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`Mixin`的`LinkedStateMixin`；但首先，什么是Mixin？它是一种在组件之间共享常见功能的方法，在这种情况下，是“链接状态”。看看以下代码：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`LinkedStateMixin` works by adding the `linkState` function to the component,
    and instead of setting the `value` of the input, we set a special prop called
    `valueLink` with the link object returned by the function `this.linkState`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedStateMixin`通过向组件添加`linkState`函数来实现，而不是设置输入的`value`，我们设置一个特殊的属性`valueLink`，该属性由`this.linkState`函数返回的链接对象设置。'
- en: The `linkState` function expects the name of the attribute of the **state**
    that it should link to the value of the input.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`linkState`函数期望的是应该链接到输入值的状态属性的名称。'
- en: Component life cycle
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: As you might have noticed, React has an opinionated view on a component's API.
    But it also has a very strong opinion on its life cycle, allowing us developers
    to add hooks to create custom behavior and perform cleanup tasks as we develop
    our components.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经注意到的，React对组件的API有很强的观点。但它也对组件的生命周期有很强的观点，允许我们开发者添加钩子以创建自定义行为并在开发组件时执行清理任务。
- en: This is one of React's greatest triumphs because it is through this standardization
    that we can create bigger and better components by composition; through that,
    we can use not only our components, but other people's components.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是 React 最大的成功之一，因为正是通过这种标准化，我们可以通过组合创建更大更好的组件；通过这种方式，我们不仅可以使用自己的组件，还可以使用其他人的组件。
- en: 'To demonstrate one use case, we are going to implement a very simple behavior:
    on page load, we want the new investment form stock symbol input to be focused
    so that a user can start typing right away.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个用例，我们将实现一个非常简单的行为：在页面加载时，我们希望新的投资表股票符号输入被聚焦，以便用户可以立即开始输入。
- en: But, before we can start writing the test, there is just one thing that we will
    need to do. As mentioned earlier, `TestUtils.renderIntoDocument` doesn't actually
    render anything in the document, but instead on a detached node. So, if we use
    it to render our component, we won't be able to make the assertion regarding the
    input's focus.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们开始编写测试之前，我们只需要做一件事。如前所述，`TestUtils.renderIntoDocument` 并没有在文档中实际渲染任何内容，而是在一个分离的节点上。因此，如果我们用它来渲染我们的组件，我们就无法对输入的焦点进行断言。
- en: 'So, yet again, we have to use the `setFixtures` method to actually render the
    React component in the document, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们再次不得不使用 `setFixtures` 方法来在文档中实际渲染 React 组件，如下所示：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this small change completed, and the spec written, we can get back to the
    implementation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个小改动，并编写完规范后，我们可以回到实现上。
- en: 'React gives a few hooks that we can implement custom code in our component
    during its life cycle; they are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了一些钩子，我们可以在组件的生命周期中实现自定义代码；它们如下所示：
- en: '`componentWillMount`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillMount`'
- en: '`componentDidMount`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount`'
- en: '`componentWillReceiveProps`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps`'
- en: '`shouldComponentUpdate`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate`'
- en: '`componentWillUpdate`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUpdate`'
- en: '`componentDidUpdate`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate`'
- en: '`componentWillUnmount`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`'
- en: To implement our custom behavior, we are going to use the `componentDidMount`
    hook that is called only once, right after the component was rendered and attached
    into a DOM element.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的自定义行为，我们将使用仅在组件渲染并附加到 DOM 元素之后调用的 `componentDidMount` 钩子。
- en: So, what we want to do is somehow inside this hook, get access to the input
    DOM element and trigger its focus. We already know how to get a DOM node; it is
    through the `getDOMNode` API. But, how do we get the input's React element?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要做的是在这个钩子内部，以某种方式获取对输入 DOM 元素的访问权限并触发其焦点。我们已经知道如何获取 DOM 节点；它是通过 `getDOMNode`
    API。但是，我们如何获取输入的 React 元素？
- en: React's other feature for this problem is called **ref**. It is basically a
    way to give names to a component's children to allow later access.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: React 为此问题提供的另一个特性称为 **ref**。它基本上是一种给组件的子元素命名的方法，以便以后可以访问。
- en: 'Since we want the stock symbol input, we need to add a `ref` attribute to it,
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要股票符号输入，我们需要给它添加一个 `ref` 属性，如下所示：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, at the `componentDidMount` hook, we can get the input by its `ref` name
    and then its DOM element and trigger the focus, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `componentDidMount` 钩子中，我们可以通过其 `ref` 名称获取输入，然后获取其 DOM 元素并触发焦点，如下所示：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The other hooks are setup in the same way, by simply defining them on the class
    definition object as properties. But each is called on different occasions, and
    has different rules. The official documentation is a great resource on their definition
    and possible use-cases which can be found at [http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods](http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 其他钩子以相同的方式设置，只需在类定义对象上定义它们作为属性。但每个钩子在不同的情况下被调用，有不同的规则。官方文档是关于它们定义和可能用例的绝佳资源，可以在
    [http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods](http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods)
    找到。
- en: Composing components
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件
- en: We've talked a lot about **composability** in the way of creating components
    by composing React's default components. However, we haven't showed how to compose
    custom components into bigger components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经就通过组合 React 的默认组件来创建组件的方式讨论了很多关于 **composability** 的内容。然而，我们还没有展示如何将自定义组件组合成更大的组件。
- en: 'As you might have guessed, this should be a pretty simple exercise, and to
    demonstrate how this works, we are going to implement a component to list investments,
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这应该是一个相当简单的练习，为了演示它是如何工作的，我们将实现一个组件来列出投资，如下所示：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is as simple as using the already available `InvestmentListItem` global variable
    as the root element of the `InvestmentList` component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像使用已可用的`InvestmentListItem`全局变量作为`InvestmentList`组件的根元素一样简单。
- en: The component expects an `investments` prop to be an array of investments. It
    then maps it through creating an `InvestmentListItem` element for each investment
    in the array.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 组件期望`investments`属性是一个投资数组。然后它通过为数组中的每个投资创建一个`InvestmentListItem`元素来映射它。
- en: Finally, it uses the `listItems` array as the children of an `ul` element, effectively
    defining how to render the list of investments.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它使用`listItems`数组作为`ul`元素的子元素，有效地定义了如何渲染投资列表。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: React is a rapidly evolving library that is getting a lot of traction by the
    JavaScript community; it introduced some interesting patterns and questioned some
    well-established dogmas as it is continually improving the development of rich
    web applications.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个快速发展的库，正受到JavaScript社区的广泛关注；随着它不断改进丰富网络应用程序的开发，它引入了一些有趣的模式，并对一些根深蒂固的教条提出了质疑。
- en: This chapter's goal was not to give an in-depth look into the library but an
    overview of its primary features and philosophies. It demonstrated that it is
    possible to do test-driven development while coding your interface with React.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是深入探讨这个库，而是概述其主要特性和哲学。它展示了在用React编写界面时，可以进行测试驱动开发。
- en: 'You learned about **prop** and **state** and their differences: A **prop**
    is not owned by the component, and should, if needed, be changed by its parent.
    The **state** is the data that the component owns. It can be changed by the component,
    and by doing so, a new render is triggered.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了**属性**和**状态**以及它们之间的区别：**属性**不属于组件，如果需要，应由其父组件更改。**状态**是组件拥有的数据。它可以由组件更改，并且通过这样做，会触发新的渲染。
- en: The fewer components with state you have in your application, the easier it
    is going to be to reason about it and test it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，具有状态的组件越少，就越容易对其进行分析和测试。
- en: It is through React's opinionated API and life cycle that we can get the maximum
    benefit of composability and code reuse.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 是通过React有见地的API和生命周期，我们可以获得最大限度的可组合性和代码重用优势。
- en: As you move into application development with React, it is recommended that
    you learn about Flux, the recommended architecture to build applications by Facebook,
    at [http://facebook.github.io/flux/](http://facebook.github.io/flux/).**
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用React进行应用程序开发时，建议你了解Facebook推荐的架构Flux，可以在[http://facebook.github.io/flux/](http://facebook.github.io/flux/)上找到。**
